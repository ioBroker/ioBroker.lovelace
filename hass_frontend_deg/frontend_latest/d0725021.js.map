{"version":3,"file":"d0725021.js","mappings":";AAyGA;AACA;AACA;AACA;AACA;AA9DA;;;;;;;;AAAA","sources":["webpack://home-assistant-frontend/./src/components/map/ha-locations-editor.ts"],"sourcesContent":["import {\n  Circle,\n  DivIcon,\n  DragEndEvent,\n  LatLng,\n  Marker,\n  MarkerOptions,\n} from \"leaflet\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type { LeafletModuleType } from \"../../common/dom/setup-leaflet-map\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"./ha-map\";\nimport type { HaMap } from \"./ha-map\";\n\ndeclare global {\n  // for fire event\n  interface HASSDomEvents {\n    \"location-updated\": { id: string; location: [number, number] };\n    \"markers-updated\": undefined;\n    \"radius-updated\": { id: string; radius: number };\n    \"marker-clicked\": { id: string };\n  }\n}\n\nexport interface MarkerLocation {\n  latitude: number;\n  longitude: number;\n  radius?: number;\n  name?: string;\n  id: string;\n  icon?: string;\n  radius_color?: string;\n  location_editable?: boolean;\n  radius_editable?: boolean;\n}\n\n@customElement(\"ha-locations-editor\")\nexport class HaLocationsEditor extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public locations?: MarkerLocation[];\n\n  @property({ type: Boolean }) public autoFit = false;\n\n  @property({ type: Number }) public zoom = 16;\n\n  @property({ type: Boolean }) public darkMode?: boolean;\n\n  @state() private _locationMarkers?: Record<string, Marker | Circle>;\n\n  @state() private _circles: Record<string, Circle> = {};\n\n  @query(\"ha-map\", true) private map!: HaMap;\n\n  private Leaflet?: LeafletModuleType;\n\n  constructor() {\n    super();\n\n    import(\"leaflet\").then((module) => {\n      import(\"leaflet-draw\").then(() => {\n        this.Leaflet = module.default as LeafletModuleType;\n        this._updateMarkers();\n        this.updateComplete.then(() => this.fitMap());\n      });\n    });\n  }\n\n  public fitMap(): void {\n    this.map.fitMap();\n  }\n\n  public fitMarker(id: string): void {\n    if (!this.map.leafletMap || !this._locationMarkers) {\n      return;\n    }\n    const marker = this._locationMarkers[id];\n    if (!marker) {\n      return;\n    }\n    if (\"getBounds\" in marker) {\n      this.map.leafletMap.fitBounds(marker.getBounds());\n      (marker as Circle).bringToFront();\n    } else {\n      const circle = this._circles[id];\n      if (circle) {\n        this.map.leafletMap.fitBounds(circle.getBounds());\n      } else {\n        this.map.leafletMap.setView(marker.getLatLng(), this.zoom);\n      }\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`<ha-map\n      .hass=${this.hass}\n      .layers=${this._getLayers(this._circles, this._locationMarkers)}\n      .zoom=${this.zoom}\n      .autoFit=${this.autoFit}\n      .darkMode=${this.darkMode}\n    ></ha-map>`;\n  }\n\n  private _getLayers = memoizeOne(\n    (\n      circles: Record<string, Circle>,\n      markers?: Record<string, Marker | Circle>\n    ): Array<Marker | Circle> => {\n      const layers: Array<Marker | Circle> = [];\n      Array.prototype.push.apply(layers, Object.values(circles));\n      if (markers) {\n        Array.prototype.push.apply(layers, Object.values(markers));\n      }\n      return layers;\n    }\n  );\n\n  public willUpdate(changedProps: PropertyValues): void {\n    super.willUpdate(changedProps);\n\n    // Still loading.\n    if (!this.Leaflet) {\n      return;\n    }\n\n    if (changedProps.has(\"locations\")) {\n      this._updateMarkers();\n    }\n  }\n\n  private _updateLocation(ev: DragEndEvent) {\n    const marker = ev.target;\n    const latlng: LatLng = marker.getLatLng();\n    let longitude: number = latlng.lng;\n    if (Math.abs(longitude) > 180.0) {\n      // Normalize longitude if map provides values beyond -180 to +180 degrees.\n      longitude = (((longitude % 360.0) + 540.0) % 360.0) - 180.0;\n    }\n    const location: [number, number] = [latlng.lat, longitude];\n    fireEvent(\n      this,\n      \"location-updated\",\n      { id: marker.id, location },\n      { bubbles: false }\n    );\n  }\n\n  private _updateRadius(ev: DragEndEvent) {\n    const marker = ev.target;\n    const circle = this._locationMarkers![marker.id] as Circle;\n    fireEvent(\n      this,\n      \"radius-updated\",\n      { id: marker.id, radius: circle.getRadius() },\n      { bubbles: false }\n    );\n  }\n\n  private _markerClicked(ev: DragEndEvent) {\n    const marker = ev.target;\n    fireEvent(this, \"marker-clicked\", { id: marker.id }, { bubbles: false });\n  }\n\n  private _updateMarkers(): void {\n    if (!this.locations || !this.locations.length) {\n      this._circles = {};\n      this._locationMarkers = undefined;\n      return;\n    }\n\n    const locationMarkers = {};\n    const circles = {};\n\n    const defaultZoneRadiusColor =\n      getComputedStyle(this).getPropertyValue(\"--accent-color\");\n\n    this.locations.forEach((location: MarkerLocation) => {\n      let icon: DivIcon | undefined;\n      if (location.icon) {\n        // create icon\n        const el = document.createElement(\"div\");\n        el.className = \"named-icon\";\n        if (location.name) {\n          el.innerText = location.name;\n        }\n        const iconEl = document.createElement(\"ha-icon\");\n        iconEl.setAttribute(\"icon\", location.icon);\n        el.prepend(iconEl);\n\n        icon = this.Leaflet!.divIcon({\n          html: el.outerHTML,\n          iconSize: [24, 24],\n          className: \"light\",\n        });\n      }\n      if (location.radius) {\n        const circle = this.Leaflet!.circle(\n          [location.latitude, location.longitude],\n          {\n            color: location.radius_color || defaultZoneRadiusColor,\n            radius: location.radius,\n          }\n        );\n        if (location.radius_editable || location.location_editable) {\n          // @ts-ignore\n          circle.editing.enable();\n          circle.addEventListener(\"add\", () => {\n            // @ts-ignore\n            const moveMarker = circle.editing._moveMarker;\n            // @ts-ignore\n            const resizeMarker = circle.editing._resizeMarkers[0];\n            if (icon) {\n              moveMarker.setIcon(icon);\n            }\n            resizeMarker.id = moveMarker.id = location.id;\n            moveMarker\n              .addEventListener(\n                \"dragend\",\n                // @ts-ignore\n                (ev: DragEndEvent) => this._updateLocation(ev)\n              )\n              .addEventListener(\n                \"click\",\n                // @ts-ignore\n                (ev: MouseEvent) => this._markerClicked(ev)\n              );\n            if (location.radius_editable) {\n              resizeMarker.addEventListener(\n                \"dragend\",\n                // @ts-ignore\n                (ev: DragEndEvent) => this._updateRadius(ev)\n              );\n            } else {\n              resizeMarker.remove();\n            }\n          });\n          locationMarkers[location.id] = circle;\n        } else {\n          circles[location.id] = circle;\n        }\n      }\n      if (\n        !location.radius ||\n        (!location.radius_editable && !location.location_editable)\n      ) {\n        const options: MarkerOptions = {\n          title: location.name,\n          draggable: location.location_editable,\n        };\n\n        if (icon) {\n          options.icon = icon;\n        }\n\n        const marker = this.Leaflet!.marker(\n          [location.latitude, location.longitude],\n          options\n        )\n          .addEventListener(\"dragend\", (ev: DragEndEvent) =>\n            this._updateLocation(ev)\n          )\n          .addEventListener(\n            // @ts-ignore\n            \"click\",\n            // @ts-ignore\n            (ev: MouseEvent) => this._markerClicked(ev)\n          );\n        (marker as any).id = location.id;\n\n        locationMarkers[location.id] = marker;\n      }\n    });\n    this._circles = circles;\n    this._locationMarkers = locationMarkers;\n    fireEvent(this, \"markers-updated\");\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        height: 300px;\n      }\n      ha-map {\n        height: 100%;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-locations-editor\": HaLocationsEditor;\n  }\n}\n"],"names":[],"sourceRoot":""}