"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-7f1393"],{

/***/ "./node_modules/@codemirror/autocomplete/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/autocomplete/dist/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CompletionContext\": function() { return /* binding */ CompletionContext; },\n/* harmony export */   \"acceptCompletion\": function() { return /* binding */ acceptCompletion; },\n/* harmony export */   \"autocompletion\": function() { return /* binding */ autocompletion; },\n/* harmony export */   \"clearSnippet\": function() { return /* binding */ clearSnippet; },\n/* harmony export */   \"closeCompletion\": function() { return /* binding */ closeCompletion; },\n/* harmony export */   \"completeAnyWord\": function() { return /* binding */ completeAnyWord; },\n/* harmony export */   \"completeFromList\": function() { return /* binding */ completeFromList; },\n/* harmony export */   \"completionKeymap\": function() { return /* binding */ completionKeymap; },\n/* harmony export */   \"completionStatus\": function() { return /* binding */ completionStatus; },\n/* harmony export */   \"currentCompletions\": function() { return /* binding */ currentCompletions; },\n/* harmony export */   \"ifIn\": function() { return /* binding */ ifIn; },\n/* harmony export */   \"ifNotIn\": function() { return /* binding */ ifNotIn; },\n/* harmony export */   \"moveCompletionSelection\": function() { return /* binding */ moveCompletionSelection; },\n/* harmony export */   \"nextSnippetField\": function() { return /* binding */ nextSnippetField; },\n/* harmony export */   \"pickedCompletion\": function() { return /* binding */ pickedCompletion; },\n/* harmony export */   \"prevSnippetField\": function() { return /* binding */ prevSnippetField; },\n/* harmony export */   \"selectedCompletion\": function() { return /* binding */ selectedCompletion; },\n/* harmony export */   \"snippet\": function() { return /* binding */ snippet; },\n/* harmony export */   \"snippetCompletion\": function() { return /* binding */ snippetCompletion; },\n/* harmony export */   \"snippetKeymap\": function() { return /* binding */ snippetKeymap; },\n/* harmony export */   \"startCompletion\": function() { return /* binding */ startCompletion; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_tooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/tooltip */ \"./node_modules/@codemirror/tooltip/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e3) { throw _e3; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e4) { didErr = true; err = _e4; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n/**\nAn instance of this is passed to completion source functions.\n*/\n\nvar CompletionContext = /*#__PURE__*/function () {\n  /**\n  Create a new completion context. (Mostly useful for testing\n  completion sourcesâ€”in the editor, the extension will create\n  these for you.)\n  */\n  function CompletionContext(\n  /**\n  The editor state that the completion happens in.\n  */\n  state,\n  /**\n  The position at which the completion is happening.\n  */\n  pos,\n  /**\n  Indicates whether completion was activated explicitly, or\n  implicitly by typing. The usual way to respond to this is to\n  only return completions when either there is part of a\n  completable entity before the cursor, or `explicit` is true.\n  */\n  explicit) {\n    _classCallCheck(this, CompletionContext);\n\n    this.state = state;\n    this.pos = pos;\n    this.explicit = explicit;\n    /**\n    @internal\n    */\n\n    this.abortListeners = [];\n  }\n  /**\n  Get the extent, content, and (if there is a token) type of the\n  token before `this.pos`.\n  */\n\n\n  _createClass(CompletionContext, [{\n    key: \"tokenBefore\",\n    value: function tokenBefore(types) {\n      var token = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(this.state).resolveInner(this.pos, -1);\n\n      while (token && types.indexOf(token.name) < 0) {\n        token = token.parent;\n      }\n\n      return token ? {\n        from: token.from,\n        to: this.pos,\n        text: this.state.sliceDoc(token.from, this.pos),\n        type: token.type\n      } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */\n\n  }, {\n    key: \"matchBefore\",\n    value: function matchBefore(expr) {\n      var line = this.state.doc.lineAt(this.pos);\n      var start = Math.max(line.from, this.pos - 250);\n      var str = line.text.slice(start - line.from, this.pos - line.from);\n      var found = str.search(ensureAnchor(expr, false));\n      return found < 0 ? null : {\n        from: start + found,\n        to: this.pos,\n        text: str.slice(found)\n      };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */\n\n  }, {\n    key: \"aborted\",\n    get: function get() {\n      return this.abortListeners == null;\n    }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    */\n\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(type, listener) {\n      if (type == \"abort\" && this.abortListeners) this.abortListeners.push(listener);\n    }\n  }]);\n\n  return CompletionContext;\n}();\n\nfunction toSet(chars) {\n  var flat = Object.keys(chars).join(\"\");\n  var words = /\\w/.test(flat);\n  if (words) flat = flat.replace(/\\w/g, \"\");\n  return \"[\".concat(words ? \"\\\\w\" : \"\").concat(flat.replace(/[^\\w\\s]/g, \"\\\\$&\"), \"]\");\n}\n\nfunction prefixMatch(options) {\n  var first = Object.create(null),\n      rest = Object.create(null);\n\n  var _iterator = _createForOfIteratorHelper(options),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var label = _step.value.label;\n      first[label[0]] = true;\n\n      for (var i = 1; i < label.length; i++) {\n        rest[label[i]] = true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var source = toSet(first) + toSet(rest) + \"*$\";\n  return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/\n\n\nfunction completeFromList(list) {\n  var options = list.map(function (o) {\n    return typeof o == \"string\" ? {\n      label: o\n    } : o;\n  });\n\n  var _ref = options.every(function (o) {\n    return /^\\w+$/.test(o.label);\n  }) ? [/\\w*$/, /\\w+$/] : prefixMatch(options),\n      _ref2 = _slicedToArray(_ref, 2),\n      span = _ref2[0],\n      match = _ref2[1];\n\n  return function (context) {\n    var token = context.matchBefore(match);\n    return token || context.explicit ? {\n      from: token ? token.from : context.pos,\n      options: options,\n      span: span\n    } : null;\n  };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/\n\n\nfunction ifIn(nodes, source) {\n  return function (context) {\n    for (var pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {\n      if (nodes.indexOf(pos.name) > -1) return source(context);\n    }\n\n    return null;\n  };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/\n\n\nfunction ifNotIn(nodes, source) {\n  return function (context) {\n    for (var pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {\n      if (nodes.indexOf(pos.name) > -1) return null;\n    }\n\n    return source(context);\n  };\n}\n\nvar Option = function Option(completion, source, match) {\n  _classCallCheck(this, Option);\n\n  this.completion = completion;\n  this.source = source;\n  this.match = match;\n};\n\nfunction cur(state) {\n  return state.selection.main.head;\n} // Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\n\n\nfunction ensureAnchor(expr, start) {\n  var _a;\n\n  var source = expr.source;\n  var addStart = start && source[0] != \"^\",\n      addEnd = source[source.length - 1] != \"$\";\n  if (!addStart && !addEnd) return expr;\n  return new RegExp(\"\".concat(addStart ? \"^\" : \"\", \"(?:\").concat(source, \")\").concat(addEnd ? \"$\" : \"\"), (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/\n\n\nvar pickedCompletion = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n\nfunction applyCompletion(view, option) {\n  var apply = option.completion.apply || option.completion.label;\n  var result = option.source;\n\n  if (typeof apply == \"string\") {\n    view.dispatch({\n      changes: {\n        from: result.from,\n        to: result.to,\n        insert: apply\n      },\n      selection: {\n        anchor: result.from + apply.length\n      },\n      userEvent: \"input.complete\",\n      annotations: pickedCompletion.of(option.completion)\n    });\n  } else {\n    apply(view, option.completion, result.from, result.to);\n  }\n}\n\nvar SourceCache = /*@__PURE__*/new WeakMap();\n\nfunction asSource(source) {\n  if (!Array.isArray(source)) return source;\n  var known = SourceCache.get(source);\n  if (!known) SourceCache.set(source, known = completeFromList(source));\n  return known;\n} // A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\n\n\nvar FuzzyMatcher = /*#__PURE__*/function () {\n  function FuzzyMatcher(pattern) {\n    _classCallCheck(this, FuzzyMatcher);\n\n    this.pattern = pattern;\n    this.chars = [];\n    this.folded = []; // Buffers reused by calls to `match` to track matched character\n    // positions.\n\n    this.any = [];\n    this.precise = [];\n    this.byWord = [];\n\n    for (var p = 0; p < pattern.length;) {\n      var _char = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(pattern, p),\n          size = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(_char);\n\n      this.chars.push(_char);\n      var part = pattern.slice(p, p + size),\n          upper = part.toUpperCase();\n      this.folded.push((0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));\n      p += size;\n    }\n\n    this.astral = pattern.length != this.chars.length;\n  } // Matches a given word (completion) against the pattern (input).\n  // Will return null for no match, and otherwise an array that starts\n  // with the match score, followed by any number of `from, to` pairs\n  // indicating the matched parts of `word`.\n  //\n  // The score is a number that is more negative the worse the match\n  // is. See `Penalty` above.\n\n\n  _createClass(FuzzyMatcher, [{\n    key: \"match\",\n    value: function match(word) {\n      if (this.pattern.length == 0) return [0];\n      if (word.length < this.pattern.length) return null;\n      var chars = this.chars,\n          folded = this.folded,\n          any = this.any,\n          precise = this.precise,\n          byWord = this.byWord; // For single-character queries, only match when they occur right\n      // at the start\n\n      if (chars.length == 1) {\n        var first = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(word, 0);\n        return first == chars[0] ? [0, 0, (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(first)] : first == folded[0] ? [-200\n        /* CaseFold */\n        , 0, (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(first)] : null;\n      }\n\n      var direct = word.indexOf(this.pattern);\n      if (direct == 0) return [0, 0, this.pattern.length];\n      var len = chars.length,\n          anyTo = 0;\n\n      if (direct < 0) {\n        for (var i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n          var next = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(word, i);\n          if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n          i += (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(next);\n        } // No match, exit immediately\n\n\n        if (anyTo < len) return null;\n      } // This tracks the extent of the precise (non-folded, not\n      // necessarily adjacent) match\n\n\n      var preciseTo = 0; // Tracks whether there is a match that hits only characters that\n      // appear to be starting words. `byWordFolded` is set to true when\n      // a case folded character is encountered in such a match\n\n      var byWordTo = 0,\n          byWordFolded = false; // If we've found a partial adjacent match, these track its state\n\n      var adjacentTo = 0,\n          adjacentStart = -1,\n          adjacentEnd = -1;\n      var hasLower = /[a-z]/.test(word),\n          wordAdjacent = true; // Go over the option's text, scanning for the various kinds of matches\n\n      for (var _i2 = 0, _e2 = Math.min(word.length, 200), prevType = 0\n      /* NonWord */\n      ; _i2 < _e2 && byWordTo < len;) {\n        var _next = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(word, _i2);\n\n        if (direct < 0) {\n          if (preciseTo < len && _next == chars[preciseTo]) precise[preciseTo++] = _i2;\n\n          if (adjacentTo < len) {\n            if (_next == chars[adjacentTo] || _next == folded[adjacentTo]) {\n              if (adjacentTo == 0) adjacentStart = _i2;\n              adjacentEnd = _i2 + 1;\n              adjacentTo++;\n            } else {\n              adjacentTo = 0;\n            }\n          }\n        }\n\n        var ch = void 0,\n            type = _next < 0xff ? _next >= 48 && _next <= 57 || _next >= 97 && _next <= 122 ? 2\n        /* Lower */\n        : _next >= 65 && _next <= 90 ? 1\n        /* Upper */\n        : 0\n        /* NonWord */\n        : (ch = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.fromCodePoint)(_next)) != ch.toLowerCase() ? 1\n        /* Upper */\n        : ch != ch.toUpperCase() ? 2\n        /* Lower */\n        : 0\n        /* NonWord */\n        ;\n\n        if (!_i2 || type == 1\n        /* Upper */\n        && hasLower || prevType == 0\n        /* NonWord */\n        && type != 0\n        /* NonWord */\n        ) {\n          if (chars[byWordTo] == _next || folded[byWordTo] == _next && (byWordFolded = true)) byWord[byWordTo++] = _i2;else if (byWord.length) wordAdjacent = false;\n        }\n\n        prevType = type;\n        _i2 += (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(_next);\n      }\n\n      if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100\n      /* ByWord */\n      + (byWordFolded ? -200\n      /* CaseFold */\n      : 0), byWord, word);\n      if (adjacentTo == len && adjacentStart == 0) return [-200\n      /* CaseFold */\n      - word.length, 0, adjacentEnd];\n      if (direct > -1) return [-700\n      /* NotStart */\n      - word.length, direct, direct + this.pattern.length];\n      if (adjacentTo == len) return [-200\n      /* CaseFold */\n      + -700\n      /* NotStart */\n      - word.length, adjacentStart, adjacentEnd];\n      if (byWordTo == len) return this.result(-100\n      /* ByWord */\n      + (byWordFolded ? -200\n      /* CaseFold */\n      : 0) + -700\n      /* NotStart */\n      + (wordAdjacent ? 0 : -1100\n      /* Gap */\n      ), byWord, word);\n      return chars.length == 2 ? null : this.result((any[0] ? -700\n      /* NotStart */\n      : 0) + -200\n      /* CaseFold */\n      + -1100\n      /* Gap */\n      , any, word);\n    }\n  }, {\n    key: \"result\",\n    value: function result(score, positions, word) {\n      var result = [score - word.length],\n          i = 1;\n\n      var _iterator2 = _createForOfIteratorHelper(positions),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var pos = _step2.value;\n          var to = pos + (this.astral ? (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.codePointSize)((0,_codemirror_text__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(word, pos)) : 1);\n          if (i > 1 && result[i - 1] == pos) result[i - 1] = to;else {\n            result[i++] = pos;\n            result[i++] = to;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return result;\n    }\n  }]);\n\n  return FuzzyMatcher;\n}();\n\nvar completionConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n  combine: function combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n      activateOnTyping: true,\n      override: null,\n      maxRenderedOptions: 100,\n      defaultKeymap: true,\n      optionClass: function optionClass() {\n        return \"\";\n      },\n      aboveCursor: false,\n      icons: true,\n      addToOptions: []\n    }, {\n      defaultKeymap: function defaultKeymap(a, b) {\n        return a && b;\n      },\n      icons: function icons(a, b) {\n        return a && b;\n      },\n      optionClass: function optionClass(a, b) {\n        return function (c) {\n          return joinClass(a(c), b(c));\n        };\n      },\n      addToOptions: function addToOptions(a, b) {\n        return a.concat(b);\n      }\n    });\n  }\n});\n\nfunction joinClass(a, b) {\n  return a ? b ? a + \" \" + b : a : b;\n}\n\nfunction optionContent(config) {\n  var content = config.addToOptions.slice();\n  if (config.icons) content.push({\n    render: function render(completion) {\n      var _icon$classList;\n\n      var icon = document.createElement(\"div\");\n      icon.classList.add(\"cm-completionIcon\");\n      if (completion.type) (_icon$classList = icon.classList).add.apply(_icon$classList, _toConsumableArray(completion.type.split(/\\s+/g).map(function (cls) {\n        return \"cm-completionIcon-\" + cls;\n      })));\n      icon.setAttribute(\"aria-hidden\", \"true\");\n      return icon;\n    },\n    position: 20\n  });\n  content.push({\n    render: function render(completion, _s, match) {\n      var labelElt = document.createElement(\"span\");\n      labelElt.className = \"cm-completionLabel\";\n      var label = completion.label,\n          off = 0;\n\n      for (var j = 1; j < match.length;) {\n        var from = match[j++],\n            to = match[j++];\n        if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n        var span = labelElt.appendChild(document.createElement(\"span\"));\n        span.appendChild(document.createTextNode(label.slice(from, to)));\n        span.className = \"cm-completionMatchedText\";\n        off = to;\n      }\n\n      if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n      return labelElt;\n    },\n    position: 50\n  }, {\n    render: function render(completion) {\n      if (!completion.detail) return null;\n      var detailElt = document.createElement(\"span\");\n      detailElt.className = \"cm-completionDetail\";\n      detailElt.textContent = completion.detail;\n      return detailElt;\n    },\n    position: 80\n  });\n  return content.sort(function (a, b) {\n    return a.position - b.position;\n  }).map(function (a) {\n    return a.render;\n  });\n}\n\nfunction createInfoDialog(option, view) {\n  var dom = document.createElement(\"div\");\n  dom.className = \"cm-tooltip cm-completionInfo\";\n  var info = option.completion.info;\n\n  if (typeof info == \"string\") {\n    dom.textContent = info;\n  } else {\n    var content = info(option.completion);\n    if (content.then) content.then(function (node) {\n      return dom.appendChild(node);\n    }, function (e) {\n      return (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.logException)(view.state, e, \"completion info\");\n    });else dom.appendChild(content);\n  }\n\n  return dom;\n}\n\nfunction rangeAroundSelected(total, selected, max) {\n  if (total <= max) return {\n    from: 0,\n    to: total\n  };\n\n  if (selected <= total >> 1) {\n    var _off = Math.floor(selected / max);\n\n    return {\n      from: _off * max,\n      to: (_off + 1) * max\n    };\n  }\n\n  var off = Math.floor((total - selected) / max);\n  return {\n    from: total - (off + 1) * max,\n    to: total - off * max\n  };\n}\n\nvar CompletionTooltip = /*#__PURE__*/function () {\n  function CompletionTooltip(view, stateField) {\n    var _this = this;\n\n    _classCallCheck(this, CompletionTooltip);\n\n    this.view = view;\n    this.stateField = stateField;\n    this.info = null;\n    this.placeInfo = {\n      read: function read() {\n        return _this.measureInfo();\n      },\n      write: function write(pos) {\n        return _this.positionInfo(pos);\n      },\n      key: this\n    };\n    var cState = view.state.field(stateField);\n    var _cState$open = cState.open,\n        options = _cState$open.options,\n        selected = _cState$open.selected;\n    var config = view.state.facet(completionConfig);\n    this.optionContent = optionContent(config);\n    this.optionClass = config.optionClass;\n    this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-tooltip-autocomplete\";\n    this.dom.addEventListener(\"mousedown\", function (e) {\n      for (var dom = e.target, match; dom && dom != _this.dom; dom = dom.parentNode) {\n        if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n          applyCompletion(view, options[+match[1]]);\n          e.preventDefault();\n          return;\n        }\n      }\n    });\n    this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));\n    this.list.addEventListener(\"scroll\", function () {\n      if (_this.info) _this.view.requestMeasure(_this.placeInfo);\n    });\n  }\n\n  _createClass(CompletionTooltip, [{\n    key: \"mount\",\n    value: function mount() {\n      this.updateSel();\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update) {\n      if (_update.state.field(this.stateField) != _update.startState.field(this.stateField)) this.updateSel();\n    }\n  }, {\n    key: \"positioned\",\n    value: function positioned() {\n      if (this.info) this.view.requestMeasure(this.placeInfo);\n    }\n  }, {\n    key: \"updateSel\",\n    value: function updateSel() {\n      var _this2 = this;\n\n      var cState = this.view.state.field(this.stateField),\n          open = cState.open;\n\n      if (open.selected < this.range.from || open.selected >= this.range.to) {\n        this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n        this.list.remove();\n        this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));\n        this.list.addEventListener(\"scroll\", function () {\n          if (_this2.info) _this2.view.requestMeasure(_this2.placeInfo);\n        });\n      }\n\n      if (this.updateSelectedOption(open.selected)) {\n        if (this.info) {\n          this.info.remove();\n          this.info = null;\n        }\n\n        var option = open.options[open.selected];\n\n        if (option.completion.info) {\n          this.info = this.dom.appendChild(createInfoDialog(option, this.view));\n          this.view.requestMeasure(this.placeInfo);\n        }\n      }\n    }\n  }, {\n    key: \"updateSelectedOption\",\n    value: function updateSelectedOption(selected) {\n      var set = null;\n\n      for (var opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n        if (i == selected) {\n          if (!opt.hasAttribute(\"aria-selected\")) {\n            opt.setAttribute(\"aria-selected\", \"true\");\n            set = opt;\n          }\n        } else {\n          if (opt.hasAttribute(\"aria-selected\")) opt.removeAttribute(\"aria-selected\");\n        }\n      }\n\n      if (set) scrollIntoView(this.list, set);\n      return set;\n    }\n  }, {\n    key: \"measureInfo\",\n    value: function measureInfo() {\n      var sel = this.dom.querySelector(\"[aria-selected]\");\n      if (!sel || !this.info) return null;\n      var listRect = this.dom.getBoundingClientRect();\n      var infoRect = this.info.getBoundingClientRect();\n      var selRect = sel.getBoundingClientRect();\n      if (selRect.top > Math.min(innerHeight, listRect.bottom) - 10 || selRect.bottom < Math.max(0, listRect.top) + 10) return null;\n      var top = Math.max(0, Math.min(selRect.top, innerHeight - infoRect.height)) - listRect.top;\n      var left = this.view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Direction.RTL;\n      var spaceLeft = listRect.left,\n          spaceRight = innerWidth - listRect.right;\n      if (left && spaceLeft < Math.min(infoRect.width, spaceRight)) left = false;else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft)) left = true;\n      return {\n        top: top,\n        left: left\n      };\n    }\n  }, {\n    key: \"positionInfo\",\n    value: function positionInfo(pos) {\n      if (this.info) {\n        this.info.style.top = (pos ? pos.top : -1e6) + \"px\";\n\n        if (pos) {\n          this.info.classList.toggle(\"cm-completionInfo-left\", pos.left);\n          this.info.classList.toggle(\"cm-completionInfo-right\", !pos.left);\n        }\n      }\n    }\n  }, {\n    key: \"createListBox\",\n    value: function createListBox(options, id, range) {\n      var ul = document.createElement(\"ul\");\n      ul.id = id;\n      ul.setAttribute(\"role\", \"listbox\");\n\n      for (var i = range.from; i < range.to; i++) {\n        var _options$i = options[i],\n            completion = _options$i.completion,\n            match = _options$i.match;\n        var li = ul.appendChild(document.createElement(\"li\"));\n        li.id = id + \"-\" + i;\n        li.setAttribute(\"role\", \"option\");\n        var cls = this.optionClass(completion);\n        if (cls) li.className = cls;\n\n        var _iterator3 = _createForOfIteratorHelper(this.optionContent),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var source = _step3.value;\n            var node = source(completion, this.view.state, match);\n            if (node) li.appendChild(node);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n      if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n      return ul;\n    }\n  }]);\n\n  return CompletionTooltip;\n}(); // We allocate a new function instance every time the completion\n// changes to force redrawing/repositioning of the tooltip\n\n\nfunction completionTooltip(stateField) {\n  return function (view) {\n    return new CompletionTooltip(view, stateField);\n  };\n}\n\nfunction scrollIntoView(container, element) {\n  var parent = container.getBoundingClientRect();\n  var self = element.getBoundingClientRect();\n  if (self.top < parent.top) container.scrollTop -= parent.top - self.top;else if (self.bottom > parent.bottom) container.scrollTop += self.bottom - parent.bottom;\n}\n\nvar MaxOptions = 300; // Used to pick a preferred option when two options with the same\n// label occur in the result.\n\nfunction score(option) {\n  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\n\nfunction sortOptions(active, state) {\n  var options = [],\n      i = 0;\n\n  var _iterator4 = _createForOfIteratorHelper(active),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var a = _step4.value;\n\n      if (a.hasResult()) {\n        if (a.result.filter === false) {\n          var _iterator6 = _createForOfIteratorHelper(a.result.options),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var option = _step6.value;\n              options.push(new Option(option, a, [1e9 - i++]));\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        } else {\n          var matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)),\n              match = void 0;\n\n          var _iterator7 = _createForOfIteratorHelper(a.result.options),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _option = _step7.value;\n\n              if (match = matcher.match(_option.label)) {\n                if (_option.boost != null) match[0] += _option.boost;\n                options.push(new Option(_option, a, match));\n              }\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  options.sort(cmpOption);\n  var result = [],\n      prev = null;\n\n  var _iterator5 = _createForOfIteratorHelper(options.sort(cmpOption)),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var opt = _step5.value;\n      if (result.length == MaxOptions) break;\n      if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != opt.completion.type || prev.apply != opt.completion.apply) result.push(opt);else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n      prev = opt.completion;\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return result;\n}\n\nvar CompletionDialog = /*#__PURE__*/function () {\n  function CompletionDialog(options, attrs, tooltip, timestamp, selected) {\n    _classCallCheck(this, CompletionDialog);\n\n    this.options = options;\n    this.attrs = attrs;\n    this.tooltip = tooltip;\n    this.timestamp = timestamp;\n    this.selected = selected;\n  }\n\n  _createClass(CompletionDialog, [{\n    key: \"setSelected\",\n    value: function setSelected(selected, id) {\n      return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);\n    }\n  }, {\n    key: \"map\",\n    value: function map(changes) {\n      return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {\n        pos: changes.mapPos(this.tooltip.pos)\n      }), this.timestamp, this.selected);\n    }\n  }], [{\n    key: \"build\",\n    value: function build(active, state, id, prev, conf) {\n      var options = sortOptions(active, state);\n      if (!options.length) return null;\n      var selected = 0;\n\n      if (prev && prev.selected) {\n        var selectedValue = prev.options[prev.selected].completion;\n\n        for (var i = 0; i < options.length && !selected; i++) {\n          if (options[i].completion == selectedValue) selected = i;\n        }\n      }\n\n      return new CompletionDialog(options, makeAttrs(id, selected), {\n        pos: active.reduce(function (a, b) {\n          return b.hasResult() ? Math.min(a, b.from) : a;\n        }, 1e8),\n        create: completionTooltip(completionState),\n        above: conf.aboveCursor\n      }, prev ? prev.timestamp : Date.now(), selected);\n    }\n  }]);\n\n  return CompletionDialog;\n}();\n\nvar CompletionState = /*#__PURE__*/function () {\n  function CompletionState(active, id, open) {\n    _classCallCheck(this, CompletionState);\n\n    this.active = active;\n    this.id = id;\n    this.open = open;\n  }\n\n  _createClass(CompletionState, [{\n    key: \"update\",\n    value: function update(tr) {\n      var _this3 = this;\n\n      var state = tr.state,\n          conf = state.facet(completionConfig);\n      var sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n      var active = sources.map(function (source) {\n        var value = _this3.active.find(function (s) {\n          return s.source == source;\n        }) || new ActiveSource(source, _this3.active.some(function (a) {\n          return a.state != 0;\n        }\n        /* Inactive */\n        ) ? 1\n        /* Pending */\n        : 0\n        /* Inactive */\n        );\n        return value.update(tr, conf);\n      });\n      if (active.length == this.active.length && active.every(function (a, i) {\n        return a == _this3.active[i];\n      })) active = this.active;\n      var open = tr.selection || active.some(function (a) {\n        return a.hasResult() && tr.changes.touchesRange(a.from, a.to);\n      }) || !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open, conf) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;\n      if (!open && active.every(function (a) {\n        return a.state != 1;\n      }\n      /* Pending */\n      ) && active.some(function (a) {\n        return a.hasResult();\n      })) active = active.map(function (a) {\n        return a.hasResult() ? new ActiveSource(a.source, 0\n        /* Inactive */\n        ) : a;\n      });\n\n      var _iterator8 = _createForOfIteratorHelper(tr.effects),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var effect = _step8.value;\n          if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n  }, {\n    key: \"tooltip\",\n    get: function get() {\n      return this.open ? this.open.tooltip : null;\n    }\n  }, {\n    key: \"attrs\",\n    get: function get() {\n      return this.open ? this.open.attrs : baseAttrs;\n    }\n  }], [{\n    key: \"start\",\n    value: function start() {\n      return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n  }]);\n\n  return CompletionState;\n}();\n\nfunction sameResults(a, b) {\n  if (a == b) return true;\n\n  for (var iA = 0, iB = 0;;) {\n    while (iA < a.length && !a[iA].hasResult) {\n      iA++;\n    }\n\n    while (iB < b.length && !b[iB].hasResult) {\n      iB++;\n    }\n\n    var endA = iA == a.length,\n        endB = iB == b.length;\n    if (endA || endB) return endA == endB;\n    if (a[iA++].result != b[iB++].result) return false;\n  }\n}\n\nvar baseAttrs = {\n  \"aria-autocomplete\": \"list\",\n  \"aria-expanded\": \"false\"\n};\n\nfunction makeAttrs(id, selected) {\n  return {\n    \"aria-autocomplete\": \"list\",\n    \"aria-expanded\": \"true\",\n    \"aria-activedescendant\": id + \"-\" + selected,\n    \"aria-controls\": id\n  };\n}\n\nvar none = [];\n\nfunction cmpOption(a, b) {\n  var dScore = b.match[0] - a.match[0];\n  if (dScore) return dScore;\n  return a.completion.label.localeCompare(b.completion.label);\n}\n\nfunction getUserEvent(tr) {\n  return tr.isUserEvent(\"input.type\") ? \"input\" : tr.isUserEvent(\"delete.backward\") ? \"delete\" : null;\n}\n\nvar ActiveSource = /*#__PURE__*/function () {\n  function ActiveSource(source, state) {\n    var explicitPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n    _classCallCheck(this, ActiveSource);\n\n    this.source = source;\n    this.state = state;\n    this.explicitPos = explicitPos;\n  }\n\n  _createClass(ActiveSource, [{\n    key: \"hasResult\",\n    value: function hasResult() {\n      return false;\n    }\n  }, {\n    key: \"update\",\n    value: function update(tr, conf) {\n      var event = getUserEvent(tr),\n          value = this;\n      if (event) value = value.handleUserEvent(tr, event, conf);else if (tr.docChanged) value = value.handleChange(tr);else if (tr.selection && value.state != 0\n      /* Inactive */\n      ) value = new ActiveSource(value.source, 0\n      /* Inactive */\n      );\n\n      var _iterator9 = _createForOfIteratorHelper(tr.effects),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var effect = _step9.value;\n          if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1\n          /* Pending */\n          , effect.value ? cur(tr.state) : -1);else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0\n          /* Inactive */\n          );else if (effect.is(setActiveEffect)) {\n            var _iterator10 = _createForOfIteratorHelper(effect.value),\n                _step10;\n\n            try {\n              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                var active = _step10.value;\n                if (active.source == value.source) value = active;\n              }\n            } catch (err) {\n              _iterator10.e(err);\n            } finally {\n              _iterator10.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      return value;\n    }\n  }, {\n    key: \"handleUserEvent\",\n    value: function handleUserEvent(tr, type, conf) {\n      return type == \"delete\" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1\n      /* Pending */\n      );\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(tr) {\n      return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0\n      /* Inactive */\n      ) : this.map(tr.changes);\n    }\n  }, {\n    key: \"map\",\n    value: function map(changes) {\n      return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\n    }\n  }]);\n\n  return ActiveSource;\n}();\n\nvar ActiveResult = /*#__PURE__*/function (_ActiveSource) {\n  _inherits(ActiveResult, _ActiveSource);\n\n  var _super = _createSuper(ActiveResult);\n\n  function ActiveResult(source, explicitPos, result, from, to, span) {\n    var _this4;\n\n    _classCallCheck(this, ActiveResult);\n\n    _this4 = _super.call(this, source, 2\n    /* Result */\n    , explicitPos);\n    _this4.result = result;\n    _this4.from = from;\n    _this4.to = to;\n    _this4.span = span;\n    return _this4;\n  }\n\n  _createClass(ActiveResult, [{\n    key: \"hasResult\",\n    value: function hasResult() {\n      return true;\n    }\n  }, {\n    key: \"handleUserEvent\",\n    value: function handleUserEvent(tr, type, conf) {\n      var from = tr.changes.mapPos(this.from),\n          to = tr.changes.mapPos(this.to, 1);\n      var pos = cur(tr.state);\n      if ((this.explicitPos > -1 ? pos < from : pos <= from) || pos > to) return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1\n      /* Pending */\n      : 0\n      /* Inactive */\n      );\n      var explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos);\n      if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to)))) return new ActiveResult(this.source, explicitPos, this.result, from, to, this.span);\n      return new ActiveSource(this.source, 1\n      /* Pending */\n      , explicitPos);\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(tr) {\n      return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0\n      /* Inactive */\n      ) : this.map(tr.changes);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);\n    }\n  }]);\n\n  return ActiveResult;\n}(ActiveSource);\n\nvar startCompletionEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nvar closeCompletionEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nvar setActiveEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n  map: function map(sources, mapping) {\n    return sources.map(function (s) {\n      return s.map(mapping);\n    });\n  }\n});\nvar setSelectedEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nvar completionState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n  create: function create() {\n    return CompletionState.start();\n  },\n  update: function update(value, tr) {\n    return value.update(tr);\n  },\n  provide: function provide(f) {\n    return [_codemirror_tooltip__WEBPACK_IMPORTED_MODULE_4__.showTooltip.from(f, function (val) {\n      return val.tooltip;\n    }), _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.contentAttributes.from(f, function (state) {\n      return state.attrs;\n    })];\n  }\n});\nvar CompletionInteractMargin = 75;\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/\n\nfunction moveCompletionSelection(forward) {\n  var by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"option\";\n  return function (view) {\n    var cState = view.state.field(completionState, false);\n    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin) return false;\n    var step = 1,\n        tooltip;\n    if (by == \"page\" && (tooltip = (0,_codemirror_tooltip__WEBPACK_IMPORTED_MODULE_4__.getTooltip)(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n    var selected = cState.open.selected + step * (forward ? 1 : -1),\n        length = cState.open.options.length;\n    if (selected < 0) selected = by == \"page\" ? 0 : length - 1;else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n    view.dispatch({\n      effects: setSelectedEffect.of(selected)\n    });\n    return true;\n  };\n}\n/**\nAccept the current completion.\n*/\n\n\nvar acceptCompletion = function acceptCompletion(view) {\n  var cState = view.state.field(completionState, false);\n  if (view.state.readOnly || !cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin) return false;\n  applyCompletion(view, cState.open.options[cState.open.selected]);\n  return true;\n};\n/**\nExplicitly start autocompletion.\n*/\n\n\nvar startCompletion = function startCompletion(view) {\n  var cState = view.state.field(completionState, false);\n  if (!cState) return false;\n  view.dispatch({\n    effects: startCompletionEffect.of(true)\n  });\n  return true;\n};\n/**\nClose the currently active completion.\n*/\n\n\nvar closeCompletion = function closeCompletion(view) {\n  var cState = view.state.field(completionState, false);\n  if (!cState || !cState.active.some(function (a) {\n    return a.state != 0;\n  }\n  /* Inactive */\n  )) return false;\n  view.dispatch({\n    effects: closeCompletionEffect.of(null)\n  });\n  return true;\n};\n\nvar RunningQuery = function RunningQuery(active, context) {\n  _classCallCheck(this, RunningQuery);\n\n  this.active = active;\n  this.context = context;\n  this.time = Date.now();\n  this.updates = []; // Note that 'undefined' means 'not done yet', whereas 'null' means\n  // 'query returned null'.\n\n  this.done = undefined;\n};\n\nvar DebounceTime = 50,\n    MaxUpdateCount = 50,\n    MinAbortTime = 1000;\nvar completionPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    _classCallCheck(this, _class);\n\n    this.view = view;\n    this.debounceUpdate = -1;\n    this.running = [];\n    this.debounceAccept = -1;\n    this.composing = 0\n    /* None */\n    ;\n\n    var _iterator11 = _createForOfIteratorHelper(view.state.field(completionState).active),\n        _step11;\n\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var active = _step11.value;\n        if (active.state == 1\n        /* Pending */\n        ) this.startQuery(active);\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n  }\n\n  _createClass(_class, [{\n    key: \"update\",\n    value: function update(_update2) {\n      var _this5 = this;\n\n      var cState = _update2.state.field(completionState);\n\n      if (!_update2.selectionSet && !_update2.docChanged && _update2.startState.field(completionState) == cState) return;\n\n      var doesReset = _update2.transactions.some(function (tr) {\n        return (tr.selection || tr.docChanged) && !getUserEvent(tr);\n      });\n\n      for (var i = 0; i < this.running.length; i++) {\n        var query = this.running[i];\n\n        if (doesReset || query.updates.length + _update2.transactions.length > MaxUpdateCount && query.time - Date.now() > MinAbortTime) {\n          var _iterator12 = _createForOfIteratorHelper(query.context.abortListeners),\n              _step12;\n\n          try {\n            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n              var handler = _step12.value;\n\n              try {\n                handler();\n              } catch (e) {\n                (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.logException)(this.view.state, e);\n              }\n            }\n          } catch (err) {\n            _iterator12.e(err);\n          } finally {\n            _iterator12.f();\n          }\n\n          query.context.abortListeners = null;\n          this.running.splice(i--, 1);\n        } else {\n          var _query$updates;\n\n          (_query$updates = query.updates).push.apply(_query$updates, _toConsumableArray(_update2.transactions));\n        }\n      }\n\n      if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n      this.debounceUpdate = cState.active.some(function (a) {\n        return a.state == 1\n        /* Pending */\n        && !_this5.running.some(function (q) {\n          return q.active.source == a.source;\n        });\n      }) ? setTimeout(function () {\n        return _this5.startUpdate();\n      }, DebounceTime) : -1;\n\n      if (this.composing != 0\n      /* None */\n      ) {\n        var _iterator13 = _createForOfIteratorHelper(_update2.transactions),\n            _step13;\n\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var tr = _step13.value;\n            if (getUserEvent(tr) == \"input\") this.composing = 2\n            /* Changed */\n            ;else if (this.composing == 2\n            /* Changed */\n            && tr.selection) this.composing = 3\n            /* ChangedAndMoved */\n            ;\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n      }\n    }\n  }, {\n    key: \"startUpdate\",\n    value: function startUpdate() {\n      var _this6 = this;\n\n      this.debounceUpdate = -1;\n      var state = this.view.state,\n          cState = state.field(completionState);\n\n      var _iterator14 = _createForOfIteratorHelper(cState.active),\n          _step14;\n\n      try {\n        var _loop = function _loop() {\n          var active = _step14.value;\n          if (active.state == 1\n          /* Pending */\n          && !_this6.running.some(function (r) {\n            return r.active.source == active.source;\n          })) _this6.startQuery(active);\n        };\n\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n    }\n  }, {\n    key: \"startQuery\",\n    value: function startQuery(active) {\n      var _this7 = this;\n\n      var state = this.view.state,\n          pos = cur(state);\n      var context = new CompletionContext(state, pos, active.explicitPos == pos);\n      var pending = new RunningQuery(active, context);\n      this.running.push(pending);\n      Promise.resolve(active.source(context)).then(function (result) {\n        if (!pending.context.aborted) {\n          pending.done = result || null;\n\n          _this7.scheduleAccept();\n        }\n      }, function (err) {\n        _this7.view.dispatch({\n          effects: closeCompletionEffect.of(null)\n        });\n\n        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.logException)(_this7.view.state, err);\n      });\n    }\n  }, {\n    key: \"scheduleAccept\",\n    value: function scheduleAccept() {\n      var _this8 = this;\n\n      if (this.running.every(function (q) {\n        return q.done !== undefined;\n      })) this.accept();else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(function () {\n        return _this8.accept();\n      }, DebounceTime);\n    } // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n\n  }, {\n    key: \"accept\",\n    value: function accept() {\n      var _this9 = this;\n\n      var _a;\n\n      if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n      this.debounceAccept = -1;\n      var updated = [];\n      var conf = this.view.state.facet(completionConfig);\n\n      var _loop2 = function _loop2(_i3) {\n        var query = _this9.running[_i3];\n\n        if (query.done === undefined) {\n          i = _i3;\n          return \"continue\";\n        }\n\n        _this9.running.splice(_i3--, 1);\n\n        if (query.done) {\n          var active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : _this9.view.state), query.done.span && query.done.filter !== false ? ensureAnchor(query.done.span, true) : null); // Replay the transactions that happened since the start of\n          // the request and see if that preserves the result\n\n          var _iterator15 = _createForOfIteratorHelper(query.updates),\n              _step15;\n\n          try {\n            for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n              var tr = _step15.value;\n              active = active.update(tr, conf);\n            }\n          } catch (err) {\n            _iterator15.e(err);\n          } finally {\n            _iterator15.f();\n          }\n\n          if (active.hasResult()) {\n            updated.push(active);\n            i = _i3;\n            return \"continue\";\n          }\n        }\n\n        var current = _this9.view.state.field(completionState).active.find(function (a) {\n          return a.source == query.active.source;\n        });\n\n        if (current && current.state == 1\n        /* Pending */\n        ) {\n          if (query.done == null) {\n            // Explicitly failed. Should clear the pending status if it\n            // hasn't been re-set in the meantime.\n            var _active = new ActiveSource(query.active.source, 0\n            /* Inactive */\n            );\n\n            var _iterator16 = _createForOfIteratorHelper(query.updates),\n                _step16;\n\n            try {\n              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                var _tr = _step16.value;\n                _active = _active.update(_tr, conf);\n              }\n            } catch (err) {\n              _iterator16.e(err);\n            } finally {\n              _iterator16.f();\n            }\n\n            if (_active.state != 1\n            /* Pending */\n            ) updated.push(_active);\n          } else {\n            // Cleared by subsequent transactions. Restart.\n            _this9.startQuery(current);\n          }\n        }\n\n        i = _i3;\n      };\n\n      for (var i = 0; i < this.running.length; i++) {\n        var _ret = _loop2(i);\n\n        if (_ret === \"continue\") continue;\n      }\n\n      if (updated.length) this.view.dispatch({\n        effects: setActiveEffect.of(updated)\n      });\n    }\n  }]);\n\n  return _class;\n}(), {\n  eventHandlers: {\n    compositionstart: function compositionstart() {\n      this.composing = 1\n      /* Started */\n      ;\n    },\n    compositionend: function compositionend() {\n      var _this10 = this;\n\n      if (this.composing == 3\n      /* ChangedAndMoved */\n      ) {\n        // Safari fires compositionend events synchronously, possibly\n        // from inside an update, so dispatch asynchronously to avoid reentrancy\n        setTimeout(function () {\n          return _this10.view.dispatch({\n            effects: startCompletionEffect.of(false)\n          });\n        }, 20);\n      }\n\n      this.composing = 0\n      /* None */\n      ;\n    }\n  }\n});\nvar baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.baseTheme({\n  \".cm-tooltip.cm-tooltip-autocomplete\": {\n    \"& > ul\": {\n      fontFamily: \"monospace\",\n      whiteSpace: \"nowrap\",\n      overflow: \"hidden auto\",\n      maxWidth_fallback: \"700px\",\n      maxWidth: \"min(700px, 95vw)\",\n      minWidth: \"250px\",\n      maxHeight: \"10em\",\n      listStyle: \"none\",\n      margin: 0,\n      padding: 0,\n      \"& > li\": {\n        overflowX: \"hidden\",\n        textOverflow: \"ellipsis\",\n        cursor: \"pointer\",\n        padding: \"1px 3px\",\n        lineHeight: 1.2\n      }\n    }\n  },\n  \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n    background: \"#17c\",\n    color: \"white\"\n  },\n  \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n    background: \"#347\",\n    color: \"white\"\n  },\n  \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n    content: '\"Â·Â·Â·\"',\n    opacity: 0.5,\n    display: \"block\",\n    textAlign: \"center\"\n  },\n  \".cm-tooltip.cm-completionInfo\": {\n    position: \"absolute\",\n    padding: \"3px 9px\",\n    width: \"max-content\",\n    maxWidth: \"300px\"\n  },\n  \".cm-completionInfo.cm-completionInfo-left\": {\n    right: \"100%\"\n  },\n  \".cm-completionInfo.cm-completionInfo-right\": {\n    left: \"100%\"\n  },\n  \"&light .cm-snippetField\": {\n    backgroundColor: \"#00000022\"\n  },\n  \"&dark .cm-snippetField\": {\n    backgroundColor: \"#ffffff22\"\n  },\n  \".cm-snippetFieldPosition\": {\n    verticalAlign: \"text-top\",\n    width: 0,\n    height: \"1.15em\",\n    margin: \"0 -0.7px -.7em\",\n    borderLeft: \"1.4px dotted #888\"\n  },\n  \".cm-completionMatchedText\": {\n    textDecoration: \"underline\"\n  },\n  \".cm-completionDetail\": {\n    marginLeft: \"0.5em\",\n    fontStyle: \"italic\"\n  },\n  \".cm-completionIcon\": {\n    fontSize: \"90%\",\n    width: \".8em\",\n    display: \"inline-block\",\n    textAlign: \"center\",\n    paddingRight: \".6em\",\n    opacity: \"0.6\"\n  },\n  \".cm-completionIcon-function, .cm-completionIcon-method\": {\n    \"&:after\": {\n      content: \"'Æ’'\"\n    }\n  },\n  \".cm-completionIcon-class\": {\n    \"&:after\": {\n      content: \"'â—‹'\"\n    }\n  },\n  \".cm-completionIcon-interface\": {\n    \"&:after\": {\n      content: \"'â—Œ'\"\n    }\n  },\n  \".cm-completionIcon-variable\": {\n    \"&:after\": {\n      content: \"'ð‘¥'\"\n    }\n  },\n  \".cm-completionIcon-constant\": {\n    \"&:after\": {\n      content: \"'ð¶'\"\n    }\n  },\n  \".cm-completionIcon-type\": {\n    \"&:after\": {\n      content: \"'ð‘¡'\"\n    }\n  },\n  \".cm-completionIcon-enum\": {\n    \"&:after\": {\n      content: \"'âˆª'\"\n    }\n  },\n  \".cm-completionIcon-property\": {\n    \"&:after\": {\n      content: \"'â–¡'\"\n    }\n  },\n  \".cm-completionIcon-keyword\": {\n    \"&:after\": {\n      content: \"'\\uD83D\\uDD11\\uFE0E'\"\n    } // Disable emoji rendering\n\n  },\n  \".cm-completionIcon-namespace\": {\n    \"&:after\": {\n      content: \"'â–¢'\"\n    }\n  },\n  \".cm-completionIcon-text\": {\n    \"&:after\": {\n      content: \"'abc'\",\n      fontSize: \"50%\",\n      verticalAlign: \"middle\"\n    }\n  }\n});\n\nvar FieldPos = function FieldPos(field, line, from, to) {\n  _classCallCheck(this, FieldPos);\n\n  this.field = field;\n  this.line = line;\n  this.from = from;\n  this.to = to;\n};\n\nvar FieldRange = /*#__PURE__*/function () {\n  function FieldRange(field, from, to) {\n    _classCallCheck(this, FieldRange);\n\n    this.field = field;\n    this.from = from;\n    this.to = to;\n  }\n\n  _createClass(FieldRange, [{\n    key: \"map\",\n    value: function map(changes) {\n      return new FieldRange(this.field, changes.mapPos(this.from, -1), changes.mapPos(this.to, 1));\n    }\n  }]);\n\n  return FieldRange;\n}();\n\nvar Snippet = /*#__PURE__*/function () {\n  function Snippet(lines, fieldPositions) {\n    _classCallCheck(this, Snippet);\n\n    this.lines = lines;\n    this.fieldPositions = fieldPositions;\n  }\n\n  _createClass(Snippet, [{\n    key: \"instantiate\",\n    value: function instantiate(state, pos) {\n      var text = [],\n          lineStart = [pos];\n      var lineObj = state.doc.lineAt(pos),\n          baseIndent = /^\\s*/.exec(lineObj.text)[0];\n\n      var _iterator17 = _createForOfIteratorHelper(this.lines),\n          _step17;\n\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var line = _step17.value;\n\n          if (text.length) {\n            var indent = baseIndent,\n                tabs = /^\\t*/.exec(line)[0].length;\n\n            for (var _i4 = 0; _i4 < tabs; _i4++) {\n              indent += state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.indentUnit);\n            }\n\n            lineStart.push(pos + indent.length - tabs);\n            line = indent + line.slice(tabs);\n          }\n\n          text.push(line);\n          pos += line.length + 1;\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n\n      var ranges = this.fieldPositions.map(function (pos) {\n        return new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to);\n      });\n      return {\n        text: text,\n        ranges: ranges\n      };\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(template) {\n      var fields = [];\n      var lines = [],\n          positions = [],\n          m;\n\n      var _iterator18 = _createForOfIteratorHelper(template.split(/\\r\\n?|\\n/)),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var line = _step18.value;\n\n          while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)) {\n            var seq = m[1] ? +m[1] : null,\n                name = m[2] || m[3] || \"\",\n                found = -1;\n\n            for (var _i5 = 0; _i5 < fields.length; _i5++) {\n              if (seq != null ? fields[_i5].seq == seq : name ? fields[_i5].name == name : false) found = _i5;\n            }\n\n            if (found < 0) {\n              var _i6 = 0;\n\n              while (_i6 < fields.length && (seq == null || fields[_i6].seq != null && fields[_i6].seq < seq)) {\n                _i6++;\n              }\n\n              fields.splice(_i6, 0, {\n                seq: seq,\n                name: name\n              });\n              found = _i6;\n\n              var _iterator19 = _createForOfIteratorHelper(positions),\n                  _step19;\n\n              try {\n                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                  var pos = _step19.value;\n                  if (pos.field >= found) pos.field++;\n                }\n              } catch (err) {\n                _iterator19.e(err);\n              } finally {\n                _iterator19.f();\n              }\n            }\n\n            positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n            line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n          }\n\n          lines.push(line);\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n\n      return new Snippet(lines, positions);\n    }\n  }]);\n\n  return Snippet;\n}();\n\nvar fieldMarker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.widget({\n  widget: /*@__PURE__*/new ( /*#__PURE__*/function (_WidgetType) {\n    _inherits(_class2, _WidgetType);\n\n    var _super2 = _createSuper(_class2);\n\n    function _class2() {\n      _classCallCheck(this, _class2);\n\n      return _super2.apply(this, arguments);\n    }\n\n    _createClass(_class2, [{\n      key: \"toDOM\",\n      value: function toDOM() {\n        var span = document.createElement(\"span\");\n        span.className = \"cm-snippetFieldPosition\";\n        return span;\n      }\n    }, {\n      key: \"ignoreEvent\",\n      value: function ignoreEvent() {\n        return false;\n      }\n    }]);\n\n    return _class2;\n  }(_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.WidgetType))()\n});\nvar fieldRange = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.mark({\n  \"class\": \"cm-snippetField\"\n});\n\nvar ActiveSnippet = /*#__PURE__*/function () {\n  function ActiveSnippet(ranges, active) {\n    _classCallCheck(this, ActiveSnippet);\n\n    this.ranges = ranges;\n    this.active = active;\n    this.deco = _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.set(ranges.map(function (r) {\n      return (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to);\n    }));\n  }\n\n  _createClass(ActiveSnippet, [{\n    key: \"map\",\n    value: function map(changes) {\n      return new ActiveSnippet(this.ranges.map(function (r) {\n        return r.map(changes);\n      }), this.active);\n    }\n  }, {\n    key: \"selectionInsideField\",\n    value: function selectionInsideField(sel) {\n      var _this11 = this;\n\n      return sel.ranges.every(function (range) {\n        return _this11.ranges.some(function (r) {\n          return r.field == _this11.active && r.from <= range.from && r.to >= range.to;\n        });\n      });\n    }\n  }]);\n\n  return ActiveSnippet;\n}();\n\nvar setActive = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n  map: function map(value, changes) {\n    return value && value.map(changes);\n  }\n});\nvar moveToField = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nvar snippetState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n  create: function create() {\n    return null;\n  },\n  update: function update(value, tr) {\n    var _iterator20 = _createForOfIteratorHelper(tr.effects),\n        _step20;\n\n    try {\n      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n        var effect = _step20.value;\n        if (effect.is(setActive)) return effect.value;\n        if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n      }\n    } catch (err) {\n      _iterator20.e(err);\n    } finally {\n      _iterator20.f();\n    }\n\n    if (value && tr.docChanged) value = value.map(tr.changes);\n    if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n    return value;\n  },\n  provide: function provide(f) {\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.decorations.from(f, function (val) {\n      return val ? val.deco : _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.none;\n    });\n  }\n});\n\nfunction fieldSelection(ranges, field) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.filter(function (r) {\n    return r.field == field;\n  }).map(function (r) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to);\n  }));\n}\n/**\nConvert a snippet template to a function that can apply it.\nSnippets are written using syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n*/\n\n\nfunction snippet(template) {\n  var snippet = Snippet.parse(template);\n  return function (editor, _completion, from, to) {\n    var _snippet$instantiate = snippet.instantiate(editor.state, from),\n        text = _snippet$instantiate.text,\n        ranges = _snippet$instantiate.ranges;\n\n    var spec = {\n      changes: {\n        from: from,\n        to: to,\n        insert: _codemirror_text__WEBPACK_IMPORTED_MODULE_2__.Text.of(text)\n      }\n    };\n    if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n\n    if (ranges.length > 1) {\n      var active = new ActiveSnippet(ranges, 0);\n      var effects = spec.effects = [setActive.of(active)];\n      if (editor.state.field(snippetState, false) === undefined) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));\n    }\n\n    editor.dispatch(editor.state.update(spec));\n  };\n}\n\nfunction moveField(dir) {\n  return function (_ref3) {\n    var state = _ref3.state,\n        dispatch = _ref3.dispatch;\n    var active = state.field(snippetState, false);\n    if (!active || dir < 0 && active.active == 0) return false;\n    var next = active.active + dir,\n        last = dir > 0 && !active.ranges.some(function (r) {\n      return r.field == next + dir;\n    });\n    dispatch(state.update({\n      selection: fieldSelection(active.ranges, next),\n      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\n    }));\n    return true;\n  };\n}\n/**\nA command that clears the active snippet, if any.\n*/\n\n\nvar clearSnippet = function clearSnippet(_ref4) {\n  var state = _ref4.state,\n      dispatch = _ref4.dispatch;\n  var active = state.field(snippetState, false);\n  if (!active) return false;\n  dispatch(state.update({\n    effects: setActive.of(null)\n  }));\n  return true;\n};\n/**\nMove to the next snippet field, if available.\n*/\n\n\nvar nextSnippetField = /*@__PURE__*/moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/\n\nvar prevSnippetField = /*@__PURE__*/moveField(-1);\nvar defaultSnippetKeymap = [{\n  key: \"Tab\",\n  run: nextSnippetField,\n  shift: prevSnippetField\n}, {\n  key: \"Escape\",\n  run: clearSnippet\n}];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/\n\nvar snippetKeymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n  combine: function combine(maps) {\n    return maps.length ? maps[0] : defaultSnippetKeymap;\n  }\n});\nvar addSnippetKeymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest( /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.keymap.compute([snippetKeymap], function (state) {\n  return state.facet(snippetKeymap);\n}));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/\n\nfunction snippetCompletion(template, completion) {\n  return Object.assign(Object.assign({}, completion), {\n    apply: snippet(template)\n  });\n}\n\nvar snippetPointerHandler = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.domEventHandlers({\n  mousedown: function mousedown(event, view) {\n    var active = view.state.field(snippetState, false),\n        pos;\n    if (!active || (pos = view.posAtCoords({\n      x: event.clientX,\n      y: event.clientY\n    })) == null) return false;\n    var match = active.ranges.find(function (r) {\n      return r.from <= pos && r.to >= pos;\n    });\n    if (!match || match.field == active.active) return false;\n    view.dispatch({\n      selection: fieldSelection(active.ranges, match.field),\n      effects: setActive.of(active.ranges.some(function (r) {\n        return r.field > match.field;\n      }) ? new ActiveSnippet(active.ranges, match.field) : null)\n    });\n    return true;\n  }\n});\n\nfunction wordRE(wordChars) {\n  var escaped = wordChars.replace(/[\\\\[.+*?(){|^$]/g, \"\\\\$&\");\n\n  try {\n    return new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_\".concat(escaped, \"]+\"), \"ug\");\n  } catch (_a) {\n    return new RegExp(\"[w\".concat(escaped, \"]\"), \"g\");\n  }\n}\n\nfunction mapRE(re, f) {\n  return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\n\nvar wordCaches = /*@__PURE__*/Object.create(null);\n\nfunction wordCache(wordChars) {\n  return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap());\n}\n\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n  for (var lines = doc.iterLines(), pos = 0; !lines.next().done;) {\n    var value = lines.value,\n        m = void 0;\n    wordRE.lastIndex = 0;\n\n    while (m = wordRE.exec(value)) {\n      if (!seen[m[0]] && pos + m.index != ignoreAt) {\n        result.push({\n          type: \"text\",\n          label: m[0]\n        });\n        seen[m[0]] = true;\n        if (result.length >= 2000\n        /* MaxList */\n        ) return;\n      }\n    }\n\n    pos += value.length + 1;\n  }\n}\n\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n  var big = doc.length >= 1000\n  /* MinCacheLen */\n  ;\n  var cached = big && cache.get(doc);\n  if (cached) return cached;\n  var result = [],\n      seen = Object.create(null);\n\n  if (doc.children) {\n    var pos = 0;\n\n    var _iterator21 = _createForOfIteratorHelper(doc.children),\n        _step21;\n\n    try {\n      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n        var ch = _step21.value;\n\n        if (ch.length >= 1000\n        /* MinCacheLen */\n        ) {\n          var _iterator22 = _createForOfIteratorHelper(collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)),\n              _step22;\n\n          try {\n            for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n              var c = _step22.value;\n\n              if (!seen[c.label]) {\n                seen[c.label] = true;\n                result.push(c);\n              }\n            }\n          } catch (err) {\n            _iterator22.e(err);\n          } finally {\n            _iterator22.f();\n          }\n        } else {\n          storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n        }\n\n        pos += ch.length + 1;\n      }\n    } catch (err) {\n      _iterator21.e(err);\n    } finally {\n      _iterator21.f();\n    }\n  } else {\n    storeWords(doc, wordRE, result, seen, ignoreAt);\n  }\n\n  if (big && result.length < 2000\n  /* MaxList */\n  ) cache.set(doc, result);\n  return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/\n\n\nvar completeAnyWord = function completeAnyWord(context) {\n  var wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n  var re = wordRE(wordChars);\n  var token = context.matchBefore(mapRE(re, function (s) {\n    return s + \"$\";\n  }));\n  if (!token && !context.explicit) return null;\n  var from = token ? token.from : context.pos;\n  var options = collectWords(context.state.doc, wordCache(wordChars), re, 50000\n  /* Range */\n  , from);\n  return {\n    from: from,\n    options: options,\n    span: mapRE(re, function (s) {\n      return \"^\" + s;\n    })\n  };\n};\n/**\nReturns an extension that enables autocompletion.\n*/\n\n\nfunction autocompletion() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [completionState, completionConfig.of(config), completionPlugin, completionKeymapExt, baseTheme];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/\n\n\nvar completionKeymap = [{\n  key: \"Ctrl-Space\",\n  run: startCompletion\n}, {\n  key: \"Escape\",\n  run: closeCompletion\n}, {\n  key: \"ArrowDown\",\n  run: /*@__PURE__*/moveCompletionSelection(true)\n}, {\n  key: \"ArrowUp\",\n  run: /*@__PURE__*/moveCompletionSelection(false)\n}, {\n  key: \"PageDown\",\n  run: /*@__PURE__*/moveCompletionSelection(true, \"page\")\n}, {\n  key: \"PageUp\",\n  run: /*@__PURE__*/moveCompletionSelection(false, \"page\")\n}, {\n  key: \"Enter\",\n  run: acceptCompletion\n}];\nvar completionKeymapExt = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest( /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.keymap.computeN([completionConfig], function (state) {\n  return state.facet(completionConfig).defaultKeymap ? [completionKeymap] : [];\n}));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/\n\nfunction completionStatus(state) {\n  var cState = state.field(completionState, false);\n  return cState && cState.active.some(function (a) {\n    return a.state == 1;\n  }\n  /* Pending */\n  ) ? \"pending\" : cState && cState.active.some(function (a) {\n    return a.state != 0;\n  }\n  /* Inactive */\n  ) ? \"active\" : null;\n}\n/**\nReturns the available completions as an array.\n*/\n\n\nfunction currentCompletions(state) {\n  var _a;\n\n  var open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  return open ? open.options.map(function (o) {\n    return o.completion;\n  }) : [];\n}\n/**\nReturn the currently selected completion, if any.\n*/\n\n\nfunction selectedCompletion(state) {\n  var _a;\n\n  var open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  return open ? open.options[open.selected].completion : null;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUVBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFFQTtBQUVBOzs7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFGQTs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFXQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUpBO0FBTUE7QUFqQkE7O0FBbUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWxCQTtBQW9CQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU5BO0FBQUE7O0FBQUE7QUFRQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBWkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWFBOztBQUNBO0FBRUE7QUFFQTtBQUNBOzs7O0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUVBO0FBRUE7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFBQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBRUE7QUFBQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUxBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFBO0FBQ0E7QUFmQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBa0JBO0FBQ0E7QUFBQTs7QUFuQkE7QUFBQTs7QUFBQTtBQW9CQTtBQUFBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUE3QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUE4QkE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBOzs7QUFtQkE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FBcEJBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSEE7QUFLQTs7Ozs7O0FBS0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFBQTs7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFmQTtBQUFBOztBQUFBO0FBZ0JBO0FBQUE7QUFDQTtBQURBO0FBaEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBbUJBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUF6QkE7QUFDQTtBQUNBOzs7Ozs7QUF5QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBO0FBREE7O0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUFBOztBQVBBO0FBQUE7O0FBQUE7QUFRQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBakJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBa0JBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBRUE7Ozs7O0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBTUE7Ozs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBOzs7O0FBekJBOztBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRkE7QUFIQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUxBO0FBQUE7O0FBQUE7QUFNQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0E7O0FBVkE7QUFBQTtBQUFBO0FBV0E7O0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFSQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQWhEQTtBQUFBO0FBQUE7QUFpREE7O0FBQ0E7QUFDQTtBQUFBOztBQUZBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUpBOztBQUdBO0FBQUE7QUFHQTtBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQXhEQTtBQUFBO0FBQUE7QUF5REE7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBdkVBO0FBQUE7QUFBQTtBQXdFQTs7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFFQTs7QUEvRUE7QUFBQTtBQUFBO0FBZ0ZBOztBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBOztBQU5BO0FBUUE7O0FBQ0E7QUFBQTtBQUNBO0FBREE7O0FBRUE7O0FBQ0E7QUFDQTtBQUVBOztBQUhBO0FBQUE7O0FBQUE7QUFJQTtBQUFBO0FBQ0E7QUFEQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBSEE7QUFBQTs7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQURBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQXRDQTtBQUFBOztBQU9BO0FBQUE7O0FBQUE7QUFnQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUExSEE7O0FBQUE7QUFBQTtBQTRIQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFYQTtBQURBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFYQTtBQURBO0FBcUJBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQUE7O0FBREE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFsR0E7O0FBdUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBOztBQUZBO0FBQUE7O0FBQUE7QUFHQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBY0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFGQTtBQUFBOztBQUFBO0FBR0E7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFMQTtBQUFBOztBQUFBO0FBTUE7QUFBQTtBQUNBO0FBREE7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUF4QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUF5QkE7QUFDQTs7Ozs7O0FBRUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQU1BO0FBQUE7QUFOQTs7QUFBQTtBQUFBO0FBQUE7QUFRQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUNBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU9BO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWZBOztBQWlCQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUNBO0FBYkE7O0FBZ0JBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7O0FBQ0E7QUFDQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBZkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWdCQTtBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2F1dG9jb21wbGV0ZS9kaXN0L2luZGV4LmpzP2Q0NTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5ub3RhdGlvbiwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBQcmVjLCBFZGl0b3JTZWxlY3Rpb24sIFRleHQgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBEaXJlY3Rpb24sIGxvZ0V4Y2VwdGlvbiwgRWRpdG9yVmlldywgVmlld1BsdWdpbiwgRGVjb3JhdGlvbiwgV2lkZ2V0VHlwZSwga2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBzaG93VG9vbHRpcCwgZ2V0VG9vbHRpcCB9IGZyb20gJ0Bjb2RlbWlycm9yL3Rvb2x0aXAnO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgaW5kZW50VW5pdCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBmcm9tQ29kZVBvaW50IH0gZnJvbSAnQGNvZGVtaXJyb3IvdGV4dCc7XG5cbi8qKlxuQW4gaW5zdGFuY2Ugb2YgdGhpcyBpcyBwYXNzZWQgdG8gY29tcGxldGlvbiBzb3VyY2UgZnVuY3Rpb25zLlxuKi9cbmNsYXNzIENvbXBsZXRpb25Db250ZXh0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgY29tcGxldGlvbiBjb250ZXh0LiAoTW9zdGx5IHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgIGNvbXBsZXRpb24gc291cmNlc+KAlGluIHRoZSBlZGl0b3IsIHRoZSBleHRlbnNpb24gd2lsbCBjcmVhdGVcbiAgICB0aGVzZSBmb3IgeW91LilcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUgdGhhdCB0aGUgY29tcGxldGlvbiBoYXBwZW5zIGluLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgY29tcGxldGlvbiBpcyBoYXBwZW5pbmcuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIGNvbXBsZXRpb24gd2FzIGFjdGl2YXRlZCBleHBsaWNpdGx5LCBvclxuICAgIGltcGxpY2l0bHkgYnkgdHlwaW5nLiBUaGUgdXN1YWwgd2F5IHRvIHJlc3BvbmQgdG8gdGhpcyBpcyB0b1xuICAgIG9ubHkgcmV0dXJuIGNvbXBsZXRpb25zIHdoZW4gZWl0aGVyIHRoZXJlIGlzIHBhcnQgb2YgYVxuICAgIGNvbXBsZXRhYmxlIGVudGl0eSBiZWZvcmUgdGhlIGN1cnNvciwgb3IgYGV4cGxpY2l0YCBpcyB0cnVlLlxuICAgICovXG4gICAgZXhwbGljaXQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5leHBsaWNpdCA9IGV4cGxpY2l0O1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYWJvcnRMaXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBleHRlbnQsIGNvbnRlbnQsIGFuZCAoaWYgdGhlcmUgaXMgYSB0b2tlbikgdHlwZSBvZiB0aGVcbiAgICB0b2tlbiBiZWZvcmUgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIHRva2VuQmVmb3JlKHR5cGVzKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHN5bnRheFRyZWUodGhpcy5zdGF0ZSkucmVzb2x2ZUlubmVyKHRoaXMucG9zLCAtMSk7XG4gICAgICAgIHdoaWxlICh0b2tlbiAmJiB0eXBlcy5pbmRleE9mKHRva2VuLm5hbWUpIDwgMClcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4ucGFyZW50O1xuICAgICAgICByZXR1cm4gdG9rZW4gPyB7IGZyb206IHRva2VuLmZyb20sIHRvOiB0aGlzLnBvcyxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMuc3RhdGUuc2xpY2VEb2ModG9rZW4uZnJvbSwgdGhpcy5wb3MpLFxuICAgICAgICAgICAgdHlwZTogdG9rZW4udHlwZSB9IDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXRjaCBvZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBkaXJlY3RseSBiZWZvcmUgdGhlXG4gICAgY3Vyc29yLlxuICAgICovXG4gICAgbWF0Y2hCZWZvcmUoZXhwcikge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGxpbmUuZnJvbSwgdGhpcy5wb3MgLSAyNTApO1xuICAgICAgICBsZXQgc3RyID0gbGluZS50ZXh0LnNsaWNlKHN0YXJ0IC0gbGluZS5mcm9tLCB0aGlzLnBvcyAtIGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBmb3VuZCA9IHN0ci5zZWFyY2goZW5zdXJlQW5jaG9yKGV4cHIsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiBmb3VuZCA8IDAgPyBudWxsIDogeyBmcm9tOiBzdGFydCArIGZvdW5kLCB0bzogdGhpcy5wb3MsIHRleHQ6IHN0ci5zbGljZShmb3VuZCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgWWllbGRzIHRydWUgd2hlbiB0aGUgcXVlcnkgaGFzIGJlZW4gYWJvcnRlZC4gQ2FuIGJlIHVzZWZ1bCBpblxuICAgIGFzeW5jaHJvbm91cyBxdWVyaWVzIHRvIGF2b2lkIGRvaW5nIHdvcmsgdGhhdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgKi9cbiAgICBnZXQgYWJvcnRlZCgpIHsgcmV0dXJuIHRoaXMuYWJvcnRMaXN0ZW5lcnMgPT0gbnVsbDsgfVxuICAgIC8qKlxuICAgIEFsbG93cyB5b3UgdG8gcmVnaXN0ZXIgYWJvcnQgaGFuZGxlcnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgICB0aGUgcXVlcnkgaXNcbiAgICBbYWJvcnRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvbkNvbnRleHQuYWJvcnRlZCkuXG4gICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlID09IFwiYWJvcnRcIiAmJiB0aGlzLmFib3J0TGlzdGVuZXJzKVxuICAgICAgICAgICAgdGhpcy5hYm9ydExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1NldChjaGFycykge1xuICAgIGxldCBmbGF0ID0gT2JqZWN0LmtleXMoY2hhcnMpLmpvaW4oXCJcIik7XG4gICAgbGV0IHdvcmRzID0gL1xcdy8udGVzdChmbGF0KTtcbiAgICBpZiAod29yZHMpXG4gICAgICAgIGZsYXQgPSBmbGF0LnJlcGxhY2UoL1xcdy9nLCBcIlwiKTtcbiAgICByZXR1cm4gYFske3dvcmRzID8gXCJcXFxcd1wiIDogXCJcIn0ke2ZsYXQucmVwbGFjZSgvW15cXHdcXHNdL2csIFwiXFxcXCQmXCIpfV1gO1xufVxuZnVuY3Rpb24gcHJlZml4TWF0Y2gob3B0aW9ucykge1xuICAgIGxldCBmaXJzdCA9IE9iamVjdC5jcmVhdGUobnVsbCksIHJlc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHsgbGFiZWwgfSBvZiBvcHRpb25zKSB7XG4gICAgICAgIGZpcnN0W2xhYmVsWzBdXSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN0W2xhYmVsW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGxldCBzb3VyY2UgPSB0b1NldChmaXJzdCkgKyB0b1NldChyZXN0KSArIFwiKiRcIjtcbiAgICByZXR1cm4gW25ldyBSZWdFeHAoXCJeXCIgKyBzb3VyY2UpLCBuZXcgUmVnRXhwKHNvdXJjZSldO1xufVxuLyoqXG5HaXZlbiBhIGEgZml4ZWQgYXJyYXkgb2Ygb3B0aW9ucywgcmV0dXJuIGFuIGF1dG9jb21wbGV0ZXIgdGhhdFxuY29tcGxldGVzIHRoZW0uXG4qL1xuZnVuY3Rpb24gY29tcGxldGVGcm9tTGlzdChsaXN0KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBsaXN0Lm1hcChvID0+IHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyB7IGxhYmVsOiBvIH0gOiBvKTtcbiAgICBsZXQgW3NwYW4sIG1hdGNoXSA9IG9wdGlvbnMuZXZlcnkobyA9PiAvXlxcdyskLy50ZXN0KG8ubGFiZWwpKSA/IFsvXFx3KiQvLCAvXFx3KyQvXSA6IHByZWZpeE1hdGNoKG9wdGlvbnMpO1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuIHx8IGNvbnRleHQuZXhwbGljaXQgPyB7IGZyb206IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zLCBvcHRpb25zLCBzcGFuIH0gOiBudWxsO1xuICAgIH07XG59XG4vKipcbldyYXAgdGhlIGdpdmVuIGNvbXBsZXRpb24gc291cmNlIHNvIHRoYXQgaXQgd2lsbCBvbmx5IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZkluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KVxuICAgICAgICAgICAgaWYgKG5vZGVzLmluZGV4T2YocG9zLm5hbWUpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZShjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cbi8qKlxuV3JhcCB0aGUgZ2l2ZW4gY29tcGxldGlvbiBzb3VyY2Ugc28gdGhhdCBpdCB3aWxsIG5vdCBmaXJlIHdoZW4gdGhlXG5jdXJzb3IgaXMgaW4gYSBzeW50YXggbm9kZSB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbmFtZXMuXG4qL1xuZnVuY3Rpb24gaWZOb3RJbihub2Rlcywgc291cmNlKSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7IHBvczsgcG9zID0gcG9zLnBhcmVudClcbiAgICAgICAgICAgIGlmIChub2Rlcy5pbmRleE9mKHBvcy5uYW1lKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgIH07XG59XG5jbGFzcyBPcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBsZXRpb24sIHNvdXJjZSwgbWF0Y2gpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uID0gY29tcGxldGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICB9XG59XG5mdW5jdGlvbiBjdXIoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7IH1cbi8vIE1ha2Ugc3VyZSB0aGUgZ2l2ZW4gcmVnZXhwIGhhcyBhICQgYXQgaXRzIGVuZCBhbmQsIGlmIGBzdGFydGAgaXNcbi8vIHRydWUsIGEgXiBhdCBpdHMgc3RhcnQuXG5mdW5jdGlvbiBlbnN1cmVBbmNob3IoZXhwciwgc3RhcnQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgc291cmNlIH0gPSBleHByO1xuICAgIGxldCBhZGRTdGFydCA9IHN0YXJ0ICYmIHNvdXJjZVswXSAhPSBcIl5cIiwgYWRkRW5kID0gc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPSBcIiRcIjtcbiAgICBpZiAoIWFkZFN0YXJ0ICYmICFhZGRFbmQpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGAke2FkZFN0YXJ0ID8gXCJeXCIgOiBcIlwifSg/OiR7c291cmNlfSkke2FkZEVuZCA/IFwiJFwiIDogXCJcIn1gLCAoX2EgPSBleHByLmZsYWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoZXhwci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSk7XG59XG4vKipcblRoaXMgYW5ub3RhdGlvbiBpcyBhZGRlZCB0byB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgcHJvZHVjZWQgYnlcbnBpY2tpbmcgYSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IHBpY2tlZENvbXBsZXRpb24gPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbmZ1bmN0aW9uIGFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb24pIHtcbiAgICBsZXQgYXBwbHkgPSBvcHRpb24uY29tcGxldGlvbi5hcHBseSB8fCBvcHRpb24uY29tcGxldGlvbi5sYWJlbDtcbiAgICBsZXQgcmVzdWx0ID0gb3B0aW9uLnNvdXJjZTtcbiAgICBpZiAodHlwZW9mIGFwcGx5ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IHJlc3VsdC5mcm9tLCB0bzogcmVzdWx0LnRvLCBpbnNlcnQ6IGFwcGx5IH0sXG4gICAgICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiByZXN1bHQuZnJvbSArIGFwcGx5Lmxlbmd0aCB9LFxuICAgICAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LmNvbXBsZXRlXCIsXG4gICAgICAgICAgICBhbm5vdGF0aW9uczogcGlja2VkQ29tcGxldGlvbi5vZihvcHRpb24uY29tcGxldGlvbilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcHBseSh2aWV3LCBvcHRpb24uY29tcGxldGlvbiwgcmVzdWx0LmZyb20sIHJlc3VsdC50byk7XG4gICAgfVxufVxuY29uc3QgU291cmNlQ2FjaGUgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGFzU291cmNlKHNvdXJjZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzb3VyY2UpKVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIGxldCBrbm93biA9IFNvdXJjZUNhY2hlLmdldChzb3VyY2UpO1xuICAgIGlmICgha25vd24pXG4gICAgICAgIFNvdXJjZUNhY2hlLnNldChzb3VyY2UsIGtub3duID0gY29tcGxldGVGcm9tTGlzdChzb3VyY2UpKTtcbiAgICByZXR1cm4ga25vd247XG59XG5cbi8vIEEgcGF0dGVybiBtYXRjaGVyIGZvciBmdXp6eSBjb21wbGV0aW9uIG1hdGNoaW5nLiBDcmVhdGUgYW4gaW5zdGFuY2Vcbi8vIG9uY2UgZm9yIGEgcGF0dGVybiwgYW5kIHRoZW4gdXNlIHRoYXQgdG8gbWF0Y2ggYW55IG51bWJlciBvZlxuLy8gY29tcGxldGlvbnMuXG5jbGFzcyBGdXp6eU1hdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5jaGFycyA9IFtdO1xuICAgICAgICB0aGlzLmZvbGRlZCA9IFtdO1xuICAgICAgICAvLyBCdWZmZXJzIHJldXNlZCBieSBjYWxscyB0byBgbWF0Y2hgIHRvIHRyYWNrIG1hdGNoZWQgY2hhcmFjdGVyXG4gICAgICAgIC8vIHBvc2l0aW9ucy5cbiAgICAgICAgdGhpcy5hbnkgPSBbXTtcbiAgICAgICAgdGhpcy5wcmVjaXNlID0gW107XG4gICAgICAgIHRoaXMuYnlXb3JkID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcGF0dGVybi5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgY2hhciA9IGNvZGVQb2ludEF0KHBhdHRlcm4sIHApLCBzaXplID0gY29kZVBvaW50U2l6ZShjaGFyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhcnMucHVzaChjaGFyKTtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gcGF0dGVybi5zbGljZShwLCBwICsgc2l6ZSksIHVwcGVyID0gcGFydC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5mb2xkZWQucHVzaChjb2RlUG9pbnRBdCh1cHBlciA9PSBwYXJ0ID8gcGFydC50b0xvd2VyQ2FzZSgpIDogdXBwZXIsIDApKTtcbiAgICAgICAgICAgIHAgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzdHJhbCA9IHBhdHRlcm4ubGVuZ3RoICE9IHRoaXMuY2hhcnMubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBNYXRjaGVzIGEgZ2l2ZW4gd29yZCAoY29tcGxldGlvbikgYWdhaW5zdCB0aGUgcGF0dGVybiAoaW5wdXQpLlxuICAgIC8vIFdpbGwgcmV0dXJuIG51bGwgZm9yIG5vIG1hdGNoLCBhbmQgb3RoZXJ3aXNlIGFuIGFycmF5IHRoYXQgc3RhcnRzXG4gICAgLy8gd2l0aCB0aGUgbWF0Y2ggc2NvcmUsIGZvbGxvd2VkIGJ5IGFueSBudW1iZXIgb2YgYGZyb20sIHRvYCBwYWlyc1xuICAgIC8vIGluZGljYXRpbmcgdGhlIG1hdGNoZWQgcGFydHMgb2YgYHdvcmRgLlxuICAgIC8vXG4gICAgLy8gVGhlIHNjb3JlIGlzIGEgbnVtYmVyIHRoYXQgaXMgbW9yZSBuZWdhdGl2ZSB0aGUgd29yc2UgdGhlIG1hdGNoXG4gICAgLy8gaXMuIFNlZSBgUGVuYWx0eWAgYWJvdmUuXG4gICAgbWF0Y2god29yZCkge1xuICAgICAgICBpZiAodGhpcy5wYXR0ZXJuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFswXTtcbiAgICAgICAgaWYgKHdvcmQubGVuZ3RoIDwgdGhpcy5wYXR0ZXJuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgeyBjaGFycywgZm9sZGVkLCBhbnksIHByZWNpc2UsIGJ5V29yZCB9ID0gdGhpcztcbiAgICAgICAgLy8gRm9yIHNpbmdsZS1jaGFyYWN0ZXIgcXVlcmllcywgb25seSBtYXRjaCB3aGVuIHRoZXkgb2NjdXIgcmlnaHRcbiAgICAgICAgLy8gYXQgdGhlIHN0YXJ0XG4gICAgICAgIGlmIChjaGFycy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gY29kZVBvaW50QXQod29yZCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgPT0gY2hhcnNbMF0gPyBbMCwgMCwgY29kZVBvaW50U2l6ZShmaXJzdCldXG4gICAgICAgICAgICAgICAgOiBmaXJzdCA9PSBmb2xkZWRbMF0gPyBbLTIwMCAvKiBDYXNlRm9sZCAqLywgMCwgY29kZVBvaW50U2l6ZShmaXJzdCldIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlyZWN0ID0gd29yZC5pbmRleE9mKHRoaXMucGF0dGVybik7XG4gICAgICAgIGlmIChkaXJlY3QgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMCwgMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aF07XG4gICAgICAgIGxldCBsZW4gPSBjaGFycy5sZW5ndGgsIGFueVRvID0gMDtcbiAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gTWF0aC5taW4od29yZC5sZW5ndGgsIDIwMCk7IGkgPCBlICYmIGFueVRvIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gY2hhcnNbYW55VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FueVRvXSlcbiAgICAgICAgICAgICAgICAgICAgYW55W2FueVRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBpICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBtYXRjaCwgZXhpdCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGFueVRvIDwgbGVuKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgdHJhY2tzIHRoZSBleHRlbnQgb2YgdGhlIHByZWNpc2UgKG5vbi1mb2xkZWQsIG5vdFxuICAgICAgICAvLyBuZWNlc3NhcmlseSBhZGphY2VudCkgbWF0Y2hcbiAgICAgICAgbGV0IHByZWNpc2VUbyA9IDA7XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZXJlIGlzIGEgbWF0Y2ggdGhhdCBoaXRzIG9ubHkgY2hhcmFjdGVycyB0aGF0XG4gICAgICAgIC8vIGFwcGVhciB0byBiZSBzdGFydGluZyB3b3Jkcy4gYGJ5V29yZEZvbGRlZGAgaXMgc2V0IHRvIHRydWUgd2hlblxuICAgICAgICAvLyBhIGNhc2UgZm9sZGVkIGNoYXJhY3RlciBpcyBlbmNvdW50ZXJlZCBpbiBzdWNoIGEgbWF0Y2hcbiAgICAgICAgbGV0IGJ5V29yZFRvID0gMCwgYnlXb3JkRm9sZGVkID0gZmFsc2U7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGZvdW5kIGEgcGFydGlhbCBhZGphY2VudCBtYXRjaCwgdGhlc2UgdHJhY2sgaXRzIHN0YXRlXG4gICAgICAgIGxldCBhZGphY2VudFRvID0gMCwgYWRqYWNlbnRTdGFydCA9IC0xLCBhZGphY2VudEVuZCA9IC0xO1xuICAgICAgICBsZXQgaGFzTG93ZXIgPSAvW2Etel0vLnRlc3Qod29yZCksIHdvcmRBZGphY2VudCA9IHRydWU7XG4gICAgICAgIC8vIEdvIG92ZXIgdGhlIG9wdGlvbidzIHRleHQsIHNjYW5uaW5nIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBtYXRjaGVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gTWF0aC5taW4od29yZC5sZW5ndGgsIDIwMCksIHByZXZUeXBlID0gMCAvKiBOb25Xb3JkICovOyBpIDwgZSAmJiBieVdvcmRUbyA8IGxlbjspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVjaXNlVG8gPCBsZW4gJiYgbmV4dCA9PSBjaGFyc1twcmVjaXNlVG9dKVxuICAgICAgICAgICAgICAgICAgICBwcmVjaXNlW3ByZWNpc2VUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGFkamFjZW50VG8gPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gY2hhcnNbYWRqYWNlbnRUb10gfHwgbmV4dCA9PSBmb2xkZWRbYWRqYWNlbnRUb10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudEVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2gsIHR5cGUgPSBuZXh0IDwgMHhmZlxuICAgICAgICAgICAgICAgID8gKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NyB8fCBuZXh0ID49IDk3ICYmIG5leHQgPD0gMTIyID8gMiAvKiBMb3dlciAqLyA6IG5leHQgPj0gNjUgJiYgbmV4dCA8PSA5MCA/IDEgLyogVXBwZXIgKi8gOiAwIC8qIE5vbldvcmQgKi8pXG4gICAgICAgICAgICAgICAgOiAoKGNoID0gZnJvbUNvZGVQb2ludChuZXh0KSkgIT0gY2gudG9Mb3dlckNhc2UoKSA/IDEgLyogVXBwZXIgKi8gOiBjaCAhPSBjaC50b1VwcGVyQ2FzZSgpID8gMiAvKiBMb3dlciAqLyA6IDAgLyogTm9uV29yZCAqLyk7XG4gICAgICAgICAgICBpZiAoIWkgfHwgdHlwZSA9PSAxIC8qIFVwcGVyICovICYmIGhhc0xvd2VyIHx8IHByZXZUeXBlID09IDAgLyogTm9uV29yZCAqLyAmJiB0eXBlICE9IDAgLyogTm9uV29yZCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyc1tieVdvcmRUb10gPT0gbmV4dCB8fCAoZm9sZGVkW2J5V29yZFRvXSA9PSBuZXh0ICYmIChieVdvcmRGb2xkZWQgPSB0cnVlKSkpXG4gICAgICAgICAgICAgICAgICAgIGJ5V29yZFtieVdvcmRUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYnlXb3JkLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgd29yZEFkamFjZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBpICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5V29yZFRvID09IGxlbiAmJiBieVdvcmRbMF0gPT0gMCAmJiB3b3JkQWRqYWNlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoLTEwMCAvKiBCeVdvcmQgKi8gKyAoYnlXb3JkRm9sZGVkID8gLTIwMCAvKiBDYXNlRm9sZCAqLyA6IDApLCBieVdvcmQsIHdvcmQpO1xuICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSBsZW4gJiYgYWRqYWNlbnRTdGFydCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFstMjAwIC8qIENhc2VGb2xkICovIC0gd29yZC5sZW5ndGgsIDAsIGFkamFjZW50RW5kXTtcbiAgICAgICAgaWYgKGRpcmVjdCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIFstNzAwIC8qIE5vdFN0YXJ0ICovIC0gd29yZC5sZW5ndGgsIGRpcmVjdCwgZGlyZWN0ICsgdGhpcy5wYXR0ZXJuLmxlbmd0aF07XG4gICAgICAgIGlmIChhZGphY2VudFRvID09IGxlbilcbiAgICAgICAgICAgIHJldHVybiBbLTIwMCAvKiBDYXNlRm9sZCAqLyArIC03MDAgLyogTm90U3RhcnQgKi8gLSB3b3JkLmxlbmd0aCwgYWRqYWNlbnRTdGFydCwgYWRqYWNlbnRFbmRdO1xuICAgICAgICBpZiAoYnlXb3JkVG8gPT0gbGVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KC0xMDAgLyogQnlXb3JkICovICsgKGJ5V29yZEZvbGRlZCA/IC0yMDAgLyogQ2FzZUZvbGQgKi8gOiAwKSArIC03MDAgLyogTm90U3RhcnQgKi8gK1xuICAgICAgICAgICAgICAgICh3b3JkQWRqYWNlbnQgPyAwIDogLTExMDAgLyogR2FwICovKSwgYnlXb3JkLCB3b3JkKTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmxlbmd0aCA9PSAyID8gbnVsbCA6IHRoaXMucmVzdWx0KChhbnlbMF0gPyAtNzAwIC8qIE5vdFN0YXJ0ICovIDogMCkgKyAtMjAwIC8qIENhc2VGb2xkICovICsgLTExMDAgLyogR2FwICovLCBhbnksIHdvcmQpO1xuICAgIH1cbiAgICByZXN1bHQoc2NvcmUsIHBvc2l0aW9ucywgd29yZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW3Njb3JlIC0gd29yZC5sZW5ndGhdLCBpID0gMTtcbiAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucykge1xuICAgICAgICAgICAgbGV0IHRvID0gcG9zICsgKHRoaXMuYXN0cmFsID8gY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdCh3b3JkLCBwb3MpKSA6IDEpO1xuICAgICAgICAgICAgaWYgKGkgPiAxICYmIHJlc3VsdFtpIC0gMV0gPT0gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtpIC0gMV0gPSB0bztcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmNvbnN0IGNvbXBsZXRpb25Db25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgYWN0aXZhdGVPblR5cGluZzogdHJ1ZSxcbiAgICAgICAgICAgIG92ZXJyaWRlOiBudWxsLFxuICAgICAgICAgICAgbWF4UmVuZGVyZWRPcHRpb25zOiAxMDAsXG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiB0cnVlLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6ICgpID0+IFwiXCIsXG4gICAgICAgICAgICBhYm92ZUN1cnNvcjogZmFsc2UsXG4gICAgICAgICAgICBpY29uczogdHJ1ZSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogW11cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgZGVmYXVsdEtleW1hcDogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIGljb25zOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6IChhLCBiKSA9PiBjID0+IGpvaW5DbGFzcyhhKGMpLCBiKGMpKSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogKGEsIGIpID0+IGEuY29uY2F0KGIpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gam9pbkNsYXNzKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/IGIgPyBhICsgXCIgXCIgKyBiIDogYSA6IGI7XG59XG5cbmZ1bmN0aW9uIG9wdGlvbkNvbnRlbnQoY29uZmlnKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBjb25maWcuYWRkVG9PcHRpb25zLnNsaWNlKCk7XG4gICAgaWYgKGNvbmZpZy5pY29ucylcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25JY29uXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0aW9uLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZCguLi5jb21wbGV0aW9uLnR5cGUuc3BsaXQoL1xccysvZykubWFwKGNscyA9PiBcImNtLWNvbXBsZXRpb25JY29uLVwiICsgY2xzKSk7XG4gICAgICAgICAgICAgICAgaWNvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IDIwXG4gICAgICAgIH0pO1xuICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uLCBfcywgbWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBsYWJlbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgbGFiZWxFbHQuY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTGFiZWxcIjtcbiAgICAgICAgICAgIGxldCB7IGxhYmVsIH0gPSBjb21wbGV0aW9uLCBvZmYgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBtYXRjaC5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBtYXRjaFtqKytdLCB0byA9IG1hdGNoW2orK107XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBvZmYpXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKG9mZiwgZnJvbSkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3BhbiA9IGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKGZyb20sIHRvKSkpO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjtcbiAgICAgICAgICAgICAgICBvZmYgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmYgPCBsYWJlbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogNTBcbiAgICB9LCB7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRpb24uZGV0YWlsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IGRldGFpbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgZGV0YWlsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkRldGFpbFwiO1xuICAgICAgICAgICAgZGV0YWlsRWx0LnRleHRDb250ZW50ID0gY29tcGxldGlvbi5kZXRhaWw7XG4gICAgICAgICAgICByZXR1cm4gZGV0YWlsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogODBcbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudC5zb3J0KChhLCBiKSA9PiBhLnBvc2l0aW9uIC0gYi5wb3NpdGlvbikubWFwKGEgPT4gYS5yZW5kZXIpO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5mb0RpYWxvZyhvcHRpb24sIHZpZXcpIHtcbiAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwIGNtLWNvbXBsZXRpb25JbmZvXCI7XG4gICAgbGV0IHsgaW5mbyB9ID0gb3B0aW9uLmNvbXBsZXRpb247XG4gICAgaWYgKHR5cGVvZiBpbmZvID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZG9tLnRleHRDb250ZW50ID0gaW5mbztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gaW5mbyhvcHRpb24uY29tcGxldGlvbik7XG4gICAgICAgIGlmIChjb250ZW50LnRoZW4pXG4gICAgICAgICAgICBjb250ZW50LnRoZW4obm9kZSA9PiBkb20uYXBwZW5kQ2hpbGQobm9kZSksIGUgPT4gbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiY29tcGxldGlvbiBpbmZvXCIpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xufVxuZnVuY3Rpb24gcmFuZ2VBcm91bmRTZWxlY3RlZCh0b3RhbCwgc2VsZWN0ZWQsIG1heCkge1xuICAgIGlmICh0b3RhbCA8PSBtYXgpXG4gICAgICAgIHJldHVybiB7IGZyb206IDAsIHRvOiB0b3RhbCB9O1xuICAgIGlmIChzZWxlY3RlZCA8PSAodG90YWwgPj4gMSkpIHtcbiAgICAgICAgbGV0IG9mZiA9IE1hdGguZmxvb3Ioc2VsZWN0ZWQgLyBtYXgpO1xuICAgICAgICByZXR1cm4geyBmcm9tOiBvZmYgKiBtYXgsIHRvOiAob2ZmICsgMSkgKiBtYXggfTtcbiAgICB9XG4gICAgbGV0IG9mZiA9IE1hdGguZmxvb3IoKHRvdGFsIC0gc2VsZWN0ZWQpIC8gbWF4KTtcbiAgICByZXR1cm4geyBmcm9tOiB0b3RhbCAtIChvZmYgKyAxKSAqIG1heCwgdG86IHRvdGFsIC0gb2ZmICogbWF4IH07XG59XG5jbGFzcyBDb21wbGV0aW9uVG9vbHRpcCB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhdGVGaWVsZCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXRlRmllbGQgPSBzdGF0ZUZpZWxkO1xuICAgICAgICB0aGlzLmluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLnBsYWNlSW5mbyA9IHtcbiAgICAgICAgICAgIHJlYWQ6ICgpID0+IHRoaXMubWVhc3VyZUluZm8oKSxcbiAgICAgICAgICAgIHdyaXRlOiAocG9zKSA9PiB0aGlzLnBvc2l0aW9uSW5mbyhwb3MpLFxuICAgICAgICAgICAga2V5OiB0aGlzXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHN0YXRlRmllbGQpO1xuICAgICAgICBsZXQgeyBvcHRpb25zLCBzZWxlY3RlZCB9ID0gY1N0YXRlLm9wZW47XG4gICAgICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xuICAgICAgICB0aGlzLm9wdGlvbkNvbnRlbnQgPSBvcHRpb25Db250ZW50KGNvbmZpZyk7XG4gICAgICAgIHRoaXMub3B0aW9uQ2xhc3MgPSBjb25maWcub3B0aW9uQ2xhc3M7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wdGlvbnMubGVuZ3RoLCBzZWxlY3RlZCwgY29uZmlnLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiO1xuICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gPSBlLnRhcmdldCwgbWF0Y2g7IGRvbSAmJiBkb20gIT0gdGhpcy5kb207IGRvbSA9IGRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkxJXCIgJiYgKG1hdGNoID0gLy0oXFxkKykkLy5leGVjKGRvbS5pZCkpICYmICttYXRjaFsxXSA8IG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb25zWyttYXRjaFsxXV0pO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUxpc3RCb3gob3B0aW9ucywgY1N0YXRlLmlkLCB0aGlzLnJhbmdlKSk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm8pXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1vdW50KCkgeyB0aGlzLnVwZGF0ZVNlbCgpOyB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCkgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsKCk7XG4gICAgfVxuICAgIHBvc2l0aW9uZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pXG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm8pO1xuICAgIH1cbiAgICB1cGRhdGVTZWwoKSB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKSwgb3BlbiA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICBpZiAob3Blbi5zZWxlY3RlZCA8IHRoaXMucmFuZ2UuZnJvbSB8fCBvcGVuLnNlbGVjdGVkID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wZW4ub3B0aW9ucy5sZW5ndGgsIG9wZW4uc2VsZWN0ZWQsIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5saXN0ID0gdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVMaXN0Qm94KG9wZW4ub3B0aW9ucywgY1N0YXRlLmlkLCB0aGlzLnJhbmdlKSk7XG4gICAgICAgICAgICB0aGlzLmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVNlbGVjdGVkT3B0aW9uKG9wZW4uc2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb3B0aW9uID0gb3Blbi5vcHRpb25zW29wZW4uc2VsZWN0ZWRdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5jb21wbGV0aW9uLmluZm8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8gPSB0aGlzLmRvbS5hcHBlbmRDaGlsZChjcmVhdGVJbmZvRGlhbG9nKG9wdGlvbiwgdGhpcy52aWV3KSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTZWxlY3RlZE9wdGlvbihzZWxlY3RlZCkge1xuICAgICAgICBsZXQgc2V0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgb3B0ID0gdGhpcy5saXN0LmZpcnN0Q2hpbGQsIGkgPSB0aGlzLnJhbmdlLmZyb207IG9wdDsgb3B0ID0gb3B0Lm5leHRTaWJsaW5nLCBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHQuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IG9wdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpXG4gICAgICAgICAgICAgICAgICAgIG9wdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXQpXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldyh0aGlzLmxpc3QsIHNldCk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIG1lYXN1cmVJbmZvKCkge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcihcIlthcmlhLXNlbGVjdGVkXVwiKTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIXRoaXMuaW5mbylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGlzdFJlY3QgPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGluZm9SZWN0ID0gdGhpcy5pbmZvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2VsUmVjdCA9IHNlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKHNlbFJlY3QudG9wID4gTWF0aC5taW4oaW5uZXJIZWlnaHQsIGxpc3RSZWN0LmJvdHRvbSkgLSAxMCB8fCBzZWxSZWN0LmJvdHRvbSA8IE1hdGgubWF4KDAsIGxpc3RSZWN0LnRvcCkgKyAxMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdG9wID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VsUmVjdC50b3AsIGlubmVySGVpZ2h0IC0gaW5mb1JlY3QuaGVpZ2h0KSkgLSBsaXN0UmVjdC50b3A7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLlJUTDtcbiAgICAgICAgbGV0IHNwYWNlTGVmdCA9IGxpc3RSZWN0LmxlZnQsIHNwYWNlUmlnaHQgPSBpbm5lcldpZHRoIC0gbGlzdFJlY3QucmlnaHQ7XG4gICAgICAgIGlmIChsZWZ0ICYmIHNwYWNlTGVmdCA8IE1hdGgubWluKGluZm9SZWN0LndpZHRoLCBzcGFjZVJpZ2h0KSlcbiAgICAgICAgICAgIGxlZnQgPSBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAoIWxlZnQgJiYgc3BhY2VSaWdodCA8IE1hdGgubWluKGluZm9SZWN0LndpZHRoLCBzcGFjZUxlZnQpKVxuICAgICAgICAgICAgbGVmdCA9IHRydWU7XG4gICAgICAgIHJldHVybiB7IHRvcCwgbGVmdCB9O1xuICAgIH1cbiAgICBwb3NpdGlvbkluZm8ocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS50b3AgPSAocG9zID8gcG9zLnRvcCA6IC0xZTYpICsgXCJweFwiO1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5jbGFzc0xpc3QudG9nZ2xlKFwiY20tY29tcGxldGlvbkluZm8tbGVmdFwiLCBwb3MubGVmdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLmNsYXNzTGlzdC50b2dnbGUoXCJjbS1jb21wbGV0aW9uSW5mby1yaWdodFwiLCAhcG9zLmxlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUxpc3RCb3gob3B0aW9ucywgaWQsIHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgICAgICB1bC5pZCA9IGlkO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlLmZyb207IGkgPCByYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBjb21wbGV0aW9uLCBtYXRjaCB9ID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGxpID0gdWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgICAgICAgIGxpLmlkID0gaWQgKyBcIi1cIiArIGk7XG4gICAgICAgICAgICBsaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgbGV0IGNscyA9IHRoaXMub3B0aW9uQ2xhc3MoY29tcGxldGlvbik7XG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIGxpLmNsYXNzTmFtZSA9IGNscztcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiB0aGlzLm9wdGlvbkNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHNvdXJjZShjb21wbGV0aW9uLCB0aGlzLnZpZXcuc3RhdGUsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLmZyb20pXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlVG9wXCIpO1xuICAgICAgICBpZiAocmFuZ2UudG8gPCBvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHVsLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b21cIik7XG4gICAgICAgIHJldHVybiB1bDtcbiAgICB9XG59XG4vLyBXZSBhbGxvY2F0ZSBhIG5ldyBmdW5jdGlvbiBpbnN0YW5jZSBldmVyeSB0aW1lIHRoZSBjb21wbGV0aW9uXG4vLyBjaGFuZ2VzIHRvIGZvcmNlIHJlZHJhd2luZy9yZXBvc2l0aW9uaW5nIG9mIHRoZSB0b29sdGlwXG5mdW5jdGlvbiBjb21wbGV0aW9uVG9vbHRpcChzdGF0ZUZpZWxkKSB7XG4gICAgcmV0dXJuICh2aWV3KSA9PiBuZXcgQ29tcGxldGlvblRvb2x0aXAodmlldywgc3RhdGVGaWVsZCk7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICBsZXQgcGFyZW50ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBzZWxmID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoc2VsZi50b3AgPCBwYXJlbnQudG9wKVxuICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wIC09IHBhcmVudC50b3AgLSBzZWxmLnRvcDtcbiAgICBlbHNlIGlmIChzZWxmLmJvdHRvbSA+IHBhcmVudC5ib3R0b20pXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gc2VsZi5ib3R0b20gLSBwYXJlbnQuYm90dG9tO1xufVxuXG5jb25zdCBNYXhPcHRpb25zID0gMzAwO1xuLy8gVXNlZCB0byBwaWNrIGEgcHJlZmVycmVkIG9wdGlvbiB3aGVuIHR3byBvcHRpb25zIHdpdGggdGhlIHNhbWVcbi8vIGxhYmVsIG9jY3VyIGluIHRoZSByZXN1bHQuXG5mdW5jdGlvbiBzY29yZShvcHRpb24pIHtcbiAgICByZXR1cm4gKG9wdGlvbi5ib29zdCB8fCAwKSAqIDEwMCArIChvcHRpb24uYXBwbHkgPyAxMCA6IDApICsgKG9wdGlvbi5pbmZvID8gNSA6IDApICtcbiAgICAgICAgKG9wdGlvbi50eXBlID8gMSA6IDApO1xufVxuZnVuY3Rpb24gc29ydE9wdGlvbnMoYWN0aXZlLCBzdGF0ZSkge1xuICAgIGxldCBvcHRpb25zID0gW10sIGkgPSAwO1xuICAgIGZvciAobGV0IGEgb2YgYWN0aXZlKVxuICAgICAgICBpZiAoYS5oYXNSZXN1bHQoKSkge1xuICAgICAgICAgICAgaWYgKGEucmVzdWx0LmZpbHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb24gb2YgYS5yZXN1bHQub3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKG5ldyBPcHRpb24ob3B0aW9uLCBhLCBbMWU5IC0gaSsrXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXIgPSBuZXcgRnV6enlNYXRjaGVyKHN0YXRlLnNsaWNlRG9jKGEuZnJvbSwgYS50bykpLCBtYXRjaDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb24gb2YgYS5yZXN1bHQub3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID0gbWF0Y2hlci5tYXRjaChvcHRpb24ubGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uLmJvb3N0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0gKz0gb3B0aW9uLmJvb3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKG5ldyBPcHRpb24ob3B0aW9uLCBhLCBtYXRjaCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBvcHRpb25zLnNvcnQoY21wT3B0aW9uKTtcbiAgICBsZXQgcmVzdWx0ID0gW10sIHByZXYgPSBudWxsO1xuICAgIGZvciAobGV0IG9wdCBvZiBvcHRpb25zLnNvcnQoY21wT3B0aW9uKSkge1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PSBNYXhPcHRpb25zKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICghcHJldiB8fCBwcmV2LmxhYmVsICE9IG9wdC5jb21wbGV0aW9uLmxhYmVsIHx8IHByZXYuZGV0YWlsICE9IG9wdC5jb21wbGV0aW9uLmRldGFpbCB8fFxuICAgICAgICAgICAgcHJldi50eXBlICE9IG9wdC5jb21wbGV0aW9uLnR5cGUgfHwgcHJldi5hcHBseSAhPSBvcHQuY29tcGxldGlvbi5hcHBseSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9wdCk7XG4gICAgICAgIGVsc2UgaWYgKHNjb3JlKG9wdC5jb21wbGV0aW9uKSA+IHNjb3JlKHByZXYpKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IG9wdDtcbiAgICAgICAgcHJldiA9IG9wdC5jb21wbGV0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgQ29tcGxldGlvbkRpYWxvZyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXR0cnMsIHRvb2x0aXAsIHRpbWVzdGFtcCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnRvb2x0aXAgPSB0b29sdGlwO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIH1cbiAgICBzZXRTZWxlY3RlZChzZWxlY3RlZCwgaWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkID09IHRoaXMuc2VsZWN0ZWQgfHwgc2VsZWN0ZWQgPj0gdGhpcy5vcHRpb25zLmxlbmd0aCA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwgdGhpcy50b29sdGlwLCB0aGlzLnRpbWVzdGFtcCwgc2VsZWN0ZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgYnVpbGQoYWN0aXZlLCBzdGF0ZSwgaWQsIHByZXYsIGNvbmYpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBzb3J0T3B0aW9ucyhhY3RpdmUsIHN0YXRlKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSAwO1xuICAgICAgICBpZiAocHJldiAmJiBwcmV2LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRWYWx1ZSA9IHByZXYub3B0aW9uc1twcmV2LnNlbGVjdGVkXS5jb21wbGV0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aCAmJiAhc2VsZWN0ZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zW2ldLmNvbXBsZXRpb24gPT0gc2VsZWN0ZWRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvbkRpYWxvZyhvcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwge1xuICAgICAgICAgICAgcG9zOiBhY3RpdmUucmVkdWNlKChhLCBiKSA9PiBiLmhhc1Jlc3VsdCgpID8gTWF0aC5taW4oYSwgYi5mcm9tKSA6IGEsIDFlOCksXG4gICAgICAgICAgICBjcmVhdGU6IGNvbXBsZXRpb25Ub29sdGlwKGNvbXBsZXRpb25TdGF0ZSksXG4gICAgICAgICAgICBhYm92ZTogY29uZi5hYm92ZUN1cnNvcixcbiAgICAgICAgfSwgcHJldiA/IHByZXYudGltZXN0YW1wIDogRGF0ZS5ub3coKSwgc2VsZWN0ZWQpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCB0aGlzLmF0dHJzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMudG9vbHRpcCksIHsgcG9zOiBjaGFuZ2VzLm1hcFBvcyh0aGlzLnRvb2x0aXAucG9zKSB9KSwgdGhpcy50aW1lc3RhbXAsIHRoaXMuc2VsZWN0ZWQpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBsZXRpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBpZCwgb3Blbikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBzdGF0aWMgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvblN0YXRlKG5vbmUsIFwiY20tYWMtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyZTYpLnRvU3RyaW5nKDM2KSwgbnVsbCk7XG4gICAgfVxuICAgIHVwZGF0ZSh0cikge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGNvbmYgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgbGV0IHNvdXJjZXMgPSBjb25mLm92ZXJyaWRlIHx8XG4gICAgICAgICAgICBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImF1dG9jb21wbGV0ZVwiLCBjdXIoc3RhdGUpKS5tYXAoYXNTb3VyY2UpO1xuICAgICAgICBsZXQgYWN0aXZlID0gc291cmNlcy5tYXAoc291cmNlID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuYWN0aXZlLmZpbmQocyA9PiBzLnNvdXJjZSA9PSBzb3VyY2UpIHx8XG4gICAgICAgICAgICAgICAgbmV3IEFjdGl2ZVNvdXJjZShzb3VyY2UsIHRoaXMuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogSW5hY3RpdmUgKi8pID8gMSAvKiBQZW5kaW5nICovIDogMCAvKiBJbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoID09IHRoaXMuYWN0aXZlLmxlbmd0aCAmJiBhY3RpdmUuZXZlcnkoKGEsIGkpID0+IGEgPT0gdGhpcy5hY3RpdmVbaV0pKVxuICAgICAgICAgICAgYWN0aXZlID0gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBvcGVuID0gdHIuc2VsZWN0aW9uIHx8IGFjdGl2ZS5zb21lKGEgPT4gYS5oYXNSZXN1bHQoKSAmJiB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZShhLmZyb20sIGEudG8pKSB8fFxuICAgICAgICAgICAgIXNhbWVSZXN1bHRzKGFjdGl2ZSwgdGhpcy5hY3RpdmUpID8gQ29tcGxldGlvbkRpYWxvZy5idWlsZChhY3RpdmUsIHN0YXRlLCB0aGlzLmlkLCB0aGlzLm9wZW4sIGNvbmYpXG4gICAgICAgICAgICA6IHRoaXMub3BlbiAmJiB0ci5kb2NDaGFuZ2VkID8gdGhpcy5vcGVuLm1hcCh0ci5jaGFuZ2VzKSA6IHRoaXMub3BlbjtcbiAgICAgICAgaWYgKCFvcGVuICYmIGFjdGl2ZS5ldmVyeShhID0+IGEuc3RhdGUgIT0gMSAvKiBQZW5kaW5nICovKSAmJiBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkpKVxuICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLm1hcChhID0+IGEuaGFzUmVzdWx0KCkgPyBuZXcgQWN0aXZlU291cmNlKGEuc291cmNlLCAwIC8qIEluYWN0aXZlICovKSA6IGEpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VsZWN0ZWRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIG9wZW4gPSBvcGVuICYmIG9wZW4uc2V0U2VsZWN0ZWQoZWZmZWN0LnZhbHVlLCB0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZSA9PSB0aGlzLmFjdGl2ZSAmJiBvcGVuID09IHRoaXMub3BlbiA/IHRoaXMgOiBuZXcgQ29tcGxldGlvblN0YXRlKGFjdGl2ZSwgdGhpcy5pZCwgb3Blbik7XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLnRvb2x0aXAgOiBudWxsOyB9XG4gICAgZ2V0IGF0dHJzKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLmF0dHJzIDogYmFzZUF0dHJzOyB9XG59XG5mdW5jdGlvbiBzYW1lUmVzdWx0cyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDA7Oykge1xuICAgICAgICB3aGlsZSAoaUEgPCBhLmxlbmd0aCAmJiAhYVtpQV0uaGFzUmVzdWx0KVxuICAgICAgICAgICAgaUErKztcbiAgICAgICAgd2hpbGUgKGlCIDwgYi5sZW5ndGggJiYgIWJbaUJdLmhhc1Jlc3VsdClcbiAgICAgICAgICAgIGlCKys7XG4gICAgICAgIGxldCBlbmRBID0gaUEgPT0gYS5sZW5ndGgsIGVuZEIgPSBpQiA9PSBiLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZEEgfHwgZW5kQilcbiAgICAgICAgICAgIHJldHVybiBlbmRBID09IGVuZEI7XG4gICAgICAgIGlmIChhW2lBKytdLnJlc3VsdCAhPSBiW2lCKytdLnJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBiYXNlQXR0cnMgPSB7XG4gICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIixcbiAgICBcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiXG59O1xuZnVuY3Rpb24gbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCIsXG4gICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiBcInRydWVcIixcbiAgICAgICAgXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIjogaWQgKyBcIi1cIiArIHNlbGVjdGVkLFxuICAgICAgICBcImFyaWEtY29udHJvbHNcIjogaWRcbiAgICB9O1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gY21wT3B0aW9uKGEsIGIpIHtcbiAgICBsZXQgZFNjb3JlID0gYi5tYXRjaFswXSAtIGEubWF0Y2hbMF07XG4gICAgaWYgKGRTY29yZSlcbiAgICAgICAgcmV0dXJuIGRTY29yZTtcbiAgICByZXR1cm4gYS5jb21wbGV0aW9uLmxhYmVsLmxvY2FsZUNvbXBhcmUoYi5jb21wbGV0aW9uLmxhYmVsKTtcbn1cbmZ1bmN0aW9uIGdldFVzZXJFdmVudCh0cikge1xuICAgIHJldHVybiB0ci5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikgPyBcImlucHV0XCIgOiB0ci5pc1VzZXJFdmVudChcImRlbGV0ZS5iYWNrd2FyZFwiKSA/IFwiZGVsZXRlXCIgOiBudWxsO1xufVxuY2xhc3MgQWN0aXZlU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHN0YXRlLCBleHBsaWNpdFBvcyA9IC0xKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZXhwbGljaXRQb3MgPSBleHBsaWNpdFBvcztcbiAgICB9XG4gICAgaGFzUmVzdWx0KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB1cGRhdGUodHIsIGNvbmYpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gZ2V0VXNlckV2ZW50KHRyKSwgdmFsdWUgPSB0aGlzO1xuICAgICAgICBpZiAoZXZlbnQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmhhbmRsZVVzZXJFdmVudCh0ciwgZXZlbnQsIGNvbmYpO1xuICAgICAgICBlbHNlIGlmICh0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5oYW5kbGVDaGFuZ2UodHIpO1xuICAgICAgICBlbHNlIGlmICh0ci5zZWxlY3Rpb24gJiYgdmFsdWUuc3RhdGUgIT0gMCAvKiBJbmFjdGl2ZSAqLylcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDAgLyogSW5hY3RpdmUgKi8pO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzdGFydENvbXBsZXRpb25FZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDEgLyogUGVuZGluZyAqLywgZWZmZWN0LnZhbHVlID8gY3VyKHRyLnN0YXRlKSA6IC0xKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhjbG9zZUNvbXBsZXRpb25FZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDAgLyogSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZUVmZmVjdCkpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGVmZmVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zb3VyY2UgPT0gdmFsdWUuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhY3RpdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBoYW5kbGVVc2VyRXZlbnQodHIsIHR5cGUsIGNvbmYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT0gXCJkZWxldGVcIiB8fCAhY29uZi5hY3RpdmF0ZU9uVHlwaW5nID8gdGhpcy5tYXAodHIuY2hhbmdlcykgOiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAxIC8qIFBlbmRpbmcgKi8pO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UodHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGN1cih0ci5zdGFydFN0YXRlKSkgPyBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAwIC8qIEluYWN0aXZlICovKSA6IHRoaXMubWFwKHRyLmNoYW5nZXMpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gY2hhbmdlcy5lbXB0eSB8fCB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IHRoaXMgOiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCB0aGlzLnN0YXRlLCBjaGFuZ2VzLm1hcFBvcyh0aGlzLmV4cGxpY2l0UG9zKSk7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlUmVzdWx0IGV4dGVuZHMgQWN0aXZlU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGV4cGxpY2l0UG9zLCByZXN1bHQsIGZyb20sIHRvLCBzcGFuKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSwgMiAvKiBSZXN1bHQgKi8sIGV4cGxpY2l0UG9zKTtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICB9XG4gICAgaGFzUmVzdWx0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGhhbmRsZVVzZXJFdmVudCh0ciwgdHlwZSwgY29uZikge1xuICAgICAgICBsZXQgZnJvbSA9IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMuZnJvbSksIHRvID0gdHIuY2hhbmdlcy5tYXBQb3ModGhpcy50bywgMSk7XG4gICAgICAgIGxldCBwb3MgPSBjdXIodHIuc3RhdGUpO1xuICAgICAgICBpZiAoKHRoaXMuZXhwbGljaXRQb3MgPiAtMSA/IHBvcyA8IGZyb20gOiBwb3MgPD0gZnJvbSkgfHwgcG9zID4gdG8pXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgdHlwZSA9PSBcImlucHV0XCIgJiYgY29uZi5hY3RpdmF0ZU9uVHlwaW5nID8gMSAvKiBQZW5kaW5nICovIDogMCAvKiBJbmFjdGl2ZSAqLyk7XG4gICAgICAgIGxldCBleHBsaWNpdFBvcyA9IHRoaXMuZXhwbGljaXRQb3MgPCAwID8gLTEgOiB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmV4cGxpY2l0UG9zKTtcbiAgICAgICAgaWYgKHRoaXMuc3BhbiAmJiAoZnJvbSA9PSB0byB8fCB0aGlzLnNwYW4udGVzdCh0ci5zdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCBleHBsaWNpdFBvcywgdGhpcy5yZXN1bHQsIGZyb20sIHRvLCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMSAvKiBQZW5kaW5nICovLCBleHBsaWNpdFBvcyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKSA/IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogSW5hY3RpdmUgKi8pIDogdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nLmVtcHR5ID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IC0xIDogbWFwcGluZy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcyksIHRoaXMucmVzdWx0LCBtYXBwaW5nLm1hcFBvcyh0aGlzLmZyb20pLCBtYXBwaW5nLm1hcFBvcyh0aGlzLnRvLCAxKSwgdGhpcy5zcGFuKTtcbiAgICB9XG59XG5jb25zdCBzdGFydENvbXBsZXRpb25FZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBjbG9zZUNvbXBsZXRpb25FZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzZXRBY3RpdmVFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAoc291cmNlcywgbWFwcGluZykgeyByZXR1cm4gc291cmNlcy5tYXAocyA9PiBzLm1hcChtYXBwaW5nKSk7IH1cbn0pO1xuY29uc3Qgc2V0U2VsZWN0ZWRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBjb21wbGV0aW9uU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIENvbXBsZXRpb25TdGF0ZS5zdGFydCgpOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHsgcmV0dXJuIHZhbHVlLnVwZGF0ZSh0cik7IH0sXG4gICAgcHJvdmlkZTogZiA9PiBbXG4gICAgICAgIHNob3dUb29sdGlwLmZyb20oZiwgdmFsID0+IHZhbC50b29sdGlwKSxcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5mcm9tKGYsIHN0YXRlID0+IHN0YXRlLmF0dHJzKVxuICAgIF1cbn0pO1xuXG5jb25zdCBDb21wbGV0aW9uSW50ZXJhY3RNYXJnaW4gPSA3NTtcbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgdGhhdCBtb3ZlcyB0aGUgY29tcGxldGlvbiBzZWxlY3Rpb24gZm9yd2FyZCBvclxuYmFja3dhcmQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiovXG5mdW5jdGlvbiBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmb3J3YXJkLCBieSA9IFwib3B0aW9uXCIpIHtcbiAgICByZXR1cm4gKHZpZXcpID0+IHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghY1N0YXRlIHx8ICFjU3RhdGUub3BlbiB8fCBEYXRlLm5vdygpIC0gY1N0YXRlLm9wZW4udGltZXN0YW1wIDwgQ29tcGxldGlvbkludGVyYWN0TWFyZ2luKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RlcCA9IDEsIHRvb2x0aXA7XG4gICAgICAgIGlmIChieSA9PSBcInBhZ2VcIiAmJiAodG9vbHRpcCA9IGdldFRvb2x0aXAodmlldywgY1N0YXRlLm9wZW4udG9vbHRpcCkpKVxuICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IodG9vbHRpcC5kb20ub2Zmc2V0SGVpZ2h0IC9cbiAgICAgICAgICAgICAgICB0b29sdGlwLmRvbS5xdWVyeVNlbGVjdG9yKFwibGlcIikub2Zmc2V0SGVpZ2h0KSAtIDEpO1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBjU3RhdGUub3Blbi5zZWxlY3RlZCArIHN0ZXAgKiAoZm9yd2FyZCA/IDEgOiAtMSksIHsgbGVuZ3RoIH0gPSBjU3RhdGUub3Blbi5vcHRpb25zO1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPCAwKVxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBieSA9PSBcInBhZ2VcIiA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgICBlbHNlIGlmIChzZWxlY3RlZCA+PSBsZW5ndGgpXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGJ5ID09IFwicGFnZVwiID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWxlY3RlZEVmZmVjdC5vZihzZWxlY3RlZCkgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkFjY2VwdCB0aGUgY3VycmVudCBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IGFjY2VwdENvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5IHx8ICFjU3RhdGUgfHwgIWNTdGF0ZS5vcGVuIHx8IERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCBDb21wbGV0aW9uSW50ZXJhY3RNYXJnaW4pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBhcHBseUNvbXBsZXRpb24odmlldywgY1N0YXRlLm9wZW4ub3B0aW9uc1tjU3RhdGUub3Blbi5zZWxlY3RlZF0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRXhwbGljaXRseSBzdGFydCBhdXRvY29tcGxldGlvbi5cbiovXG5jb25zdCBzdGFydENvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghY1N0YXRlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHN0YXJ0Q29tcGxldGlvbkVmZmVjdC5vZih0cnVlKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNsb3NlIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNvbXBsZXRpb24uXG4qL1xuY29uc3QgY2xvc2VDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWNTdGF0ZSB8fCAhY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIEluYWN0aXZlICovKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY2xhc3MgUnVubmluZ1F1ZXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhY3RpdmUsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudXBkYXRlcyA9IFtdO1xuICAgICAgICAvLyBOb3RlIHRoYXQgJ3VuZGVmaW5lZCcgbWVhbnMgJ25vdCBkb25lIHlldCcsIHdoZXJlYXMgJ251bGwnIG1lYW5zXG4gICAgICAgIC8vICdxdWVyeSByZXR1cm5lZCBudWxsJy5cbiAgICAgICAgdGhpcy5kb25lID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNvbnN0IERlYm91bmNlVGltZSA9IDUwLCBNYXhVcGRhdGVDb3VudCA9IDUwLCBNaW5BYm9ydFRpbWUgPSAxMDAwO1xuY29uc3QgY29tcGxldGlvblBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gLTE7XG4gICAgICAgIHRoaXMucnVubmluZyA9IFtdO1xuICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gLTE7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gMCAvKiBOb25lICovO1xuICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2Ygdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZSlcbiAgICAgICAgICAgIGlmIChhY3RpdmUuc3RhdGUgPT0gMSAvKiBQZW5kaW5nICovKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShhY3RpdmUpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKTtcbiAgICAgICAgaWYgKCF1cGRhdGUuc2VsZWN0aW9uU2V0ICYmICF1cGRhdGUuZG9jQ2hhbmdlZCAmJiB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpID09IGNTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGRvZXNSZXNldCA9IHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHRyLnNlbGVjdGlvbiB8fCB0ci5kb2NDaGFuZ2VkKSAmJiAhZ2V0VXNlckV2ZW50KHRyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICAgICAgICBpZiAoZG9lc1Jlc2V0IHx8XG4gICAgICAgICAgICAgICAgcXVlcnkudXBkYXRlcy5sZW5ndGggKyB1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aCA+IE1heFVwZGF0ZUNvdW50ICYmIHF1ZXJ5LnRpbWUgLSBEYXRlLm5vdygpID4gTWluQWJvcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHF1ZXJ5LmNvbnRleHQuYWJvcnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMucHVzaCguLi51cGRhdGUudHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWJvdW5jZVVwZGF0ZSA+IC0xKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VVcGRhdGUpO1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFBlbmRpbmcgKi8gJiYgIXRoaXMucnVubmluZy5zb21lKHEgPT4gcS5hY3RpdmUuc291cmNlID09IGEuc291cmNlKSlcbiAgICAgICAgICAgID8gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0VXBkYXRlKCksIERlYm91bmNlVGltZSkgOiAtMTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nICE9IDAgLyogTm9uZSAqLylcbiAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHVwZGF0ZS50cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VXNlckV2ZW50KHRyKSA9PSBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMiAvKiBDaGFuZ2VkICovO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29tcG9zaW5nID09IDIgLyogQ2hhbmdlZCAqLyAmJiB0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMyAvKiBDaGFuZ2VkQW5kTW92ZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0VXBkYXRlKCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gLTE7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGNTdGF0ZSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiBjU3RhdGUuYWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlID09IDEgLyogUGVuZGluZyAqLyAmJiAhdGhpcy5ydW5uaW5nLnNvbWUociA9PiByLmFjdGl2ZS5zb3VyY2UgPT0gYWN0aXZlLnNvdXJjZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRRdWVyeShhY3RpdmUpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgcG9zID0gY3VyKHN0YXRlKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgQ29tcGxldGlvbkNvbnRleHQoc3RhdGUsIHBvcywgYWN0aXZlLmV4cGxpY2l0UG9zID09IHBvcyk7XG4gICAgICAgIGxldCBwZW5kaW5nID0gbmV3IFJ1bm5pbmdRdWVyeShhY3RpdmUsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcucHVzaChwZW5kaW5nKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGFjdGl2ZS5zb3VyY2UoY29udGV4dCkpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmICghcGVuZGluZy5jb250ZXh0LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLmRvbmUgPSByZXN1bHQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQWNjZXB0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NoZWR1bGVBY2NlcHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcuZXZlcnkocSA9PiBxLmRvbmUgIT09IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICB0aGlzLmFjY2VwdCgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmRlYm91bmNlQWNjZXB0IDwgMClcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWNjZXB0KCksIERlYm91bmNlVGltZSk7XG4gICAgfVxuICAgIC8vIEZvciBlYWNoIGZpbmlzaGVkIHF1ZXJ5IGluIHRoaXMucnVubmluZywgdHJ5IHRvIGNyZWF0ZSBhIHJlc3VsdFxuICAgIC8vIG9yLCBpZiBhcHByb3ByaWF0ZSwgcmVzdGFydCB0aGUgcXVlcnkuXG4gICAgYWNjZXB0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmRlYm91bmNlQWNjZXB0ID4gLTEpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZUFjY2VwdCk7XG4gICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSAtMTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBbXTtcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICAgICAgICBpZiAocXVlcnkuZG9uZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVJlc3VsdChxdWVyeS5hY3RpdmUuc291cmNlLCBxdWVyeS5hY3RpdmUuZXhwbGljaXRQb3MsIHF1ZXJ5LmRvbmUsIHF1ZXJ5LmRvbmUuZnJvbSwgKF9hID0gcXVlcnkuZG9uZS50bykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VyKHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoID8gcXVlcnkudXBkYXRlc1swXS5zdGFydFN0YXRlIDogdGhpcy52aWV3LnN0YXRlKSwgcXVlcnkuZG9uZS5zcGFuICYmIHF1ZXJ5LmRvbmUuZmlsdGVyICE9PSBmYWxzZSA/IGVuc3VyZUFuY2hvcihxdWVyeS5kb25lLnNwYW4sIHRydWUpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGF5IHRoZSB0cmFuc2FjdGlvbnMgdGhhdCBoYXBwZW5lZCBzaW5jZSB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBhbmQgc2VlIGlmIHRoYXQgcHJlc2VydmVzIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0ciBvZiBxdWVyeS51cGRhdGVzKVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLmhhc1Jlc3VsdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChhY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gcXVlcnkuYWN0aXZlLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LnN0YXRlID09IDEgLyogUGVuZGluZyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBmYWlsZWQuIFNob3VsZCBjbGVhciB0aGUgcGVuZGluZyBzdGF0dXMgaWYgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzbid0IGJlZW4gcmUtc2V0IGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTb3VyY2UocXVlcnkuYWN0aXZlLnNvdXJjZSwgMCAvKiBJbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zdGF0ZSAhPSAxIC8qIFBlbmRpbmcgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goYWN0aXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyZWQgYnkgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMuIFJlc3RhcnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0QWN0aXZlRWZmZWN0Lm9mKHVwZGF0ZWQpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgIGNvbXBvc2l0aW9uc3RhcnQoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDEgLyogU3RhcnRlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zaXRpb25lbmQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPT0gMyAvKiBDaGFuZ2VkQW5kTW92ZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgZmlyZXMgY29tcG9zaXRpb25lbmQgZXZlbnRzIHN5bmNocm9ub3VzbHksIHBvc3NpYmx5XG4gICAgICAgICAgICAgICAgLy8gZnJvbSBpbnNpZGUgYW4gdXBkYXRlLCBzbyBkaXNwYXRjaCBhc3luY2hyb25vdXNseSB0byBhdm9pZCByZWVudHJhbmN5XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzdGFydENvbXBsZXRpb25FZmZlY3Qub2YoZmFsc2UpIH0pLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXRvb2x0aXAuY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjoge1xuICAgICAgICBcIiYgPiB1bFwiOiB7XG4gICAgICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlbiBhdXRvXCIsXG4gICAgICAgICAgICBtYXhXaWR0aF9mYWxsYmFjazogXCI3MDBweFwiLFxuICAgICAgICAgICAgbWF4V2lkdGg6IFwibWluKDcwMHB4LCA5NXZ3KVwiLFxuICAgICAgICAgICAgbWluV2lkdGg6IFwiMjUwcHhcIixcbiAgICAgICAgICAgIG1heEhlaWdodDogXCIxMGVtXCIsXG4gICAgICAgICAgICBsaXN0U3R5bGU6IFwibm9uZVwiLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIFwiJiA+IGxpXCI6IHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1g6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiBcImVsbGlwc2lzXCIsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjFweCAzcHhcIixcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxLjJcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZSB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzE3Y1wiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMzNDdcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZVRvcDpiZWZvcmUsIC5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b206YWZ0ZXJcIjoge1xuICAgICAgICBjb250ZW50OiAnXCLCt8K3wrdcIicsXG4gICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAuY20tY29tcGxldGlvbkluZm9cIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjNweCA5cHhcIixcbiAgICAgICAgd2lkdGg6IFwibWF4LWNvbnRlbnRcIixcbiAgICAgICAgbWF4V2lkdGg6IFwiMzAwcHhcIixcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLWxlZnRcIjogeyByaWdodDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodFwiOiB7IGxlZnQ6IFwiMTAwJVwiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMDAwMDAwMjJcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZmZmMjJcIiB9LFxuICAgIFwiLmNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiBcIjEuMTVlbVwiLFxuICAgICAgICBtYXJnaW46IFwiMCAtMC43cHggLS43ZW1cIixcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjRweCBkb3R0ZWQgIzg4OFwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjoge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkRldGFpbFwiOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiMC41ZW1cIixcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvblwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjkwJVwiLFxuICAgICAgICB3aWR0aDogXCIuOGVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiBcIi42ZW1cIixcbiAgICAgICAgb3BhY2l0eTogXCIwLjZcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tZnVuY3Rpb24sIC5jbS1jb21wbGV0aW9uSWNvbi1tZXRob2RcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifGkidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jbGFzc1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KXiydcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1pbnRlcmZhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifil4wnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdmFyaWFibGVcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZGlJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWNvbnN0YW50XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2QtidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi10eXBlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2RoSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1lbnVtXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4oiqJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXByb3BlcnR5XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4pahJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWtleXdvcmRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwn5SRXFx1RkUwRSdcIiB9IC8vIERpc2FibGUgZW1vamkgcmVuZGVyaW5nXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1uYW1lc3BhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifilqInXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdGV4dFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ2FiYydcIiwgZm9udFNpemU6IFwiNTAlXCIsIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIgfVxuICAgIH1cbn0pO1xuXG5jbGFzcyBGaWVsZFBvcyB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIGxpbmUsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmNsYXNzIEZpZWxkUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFJhbmdlKHRoaXMuZmllbGQsIGNoYW5nZXMubWFwUG9zKHRoaXMuZnJvbSwgLTEpLCBjaGFuZ2VzLm1hcFBvcyh0aGlzLnRvLCAxKSk7XG4gICAgfVxufVxuY2xhc3MgU25pcHBldCB7XG4gICAgY29uc3RydWN0b3IobGluZXMsIGZpZWxkUG9zaXRpb25zKSB7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5maWVsZFBvc2l0aW9ucyA9IGZpZWxkUG9zaXRpb25zO1xuICAgIH1cbiAgICBpbnN0YW50aWF0ZShzdGF0ZSwgcG9zKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gW10sIGxpbmVTdGFydCA9IFtwb3NdO1xuICAgICAgICBsZXQgbGluZU9iaiA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgYmFzZUluZGVudCA9IC9eXFxzKi8uZXhlYyhsaW5lT2JqLnRleHQpWzBdO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMubGluZXMpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSBiYXNlSW5kZW50LCB0YWJzID0gL15cXHQqLy5leGVjKGxpbmUpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnM7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydC5wdXNoKHBvcyArIGluZGVudC5sZW5ndGggLSB0YWJzKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gaW5kZW50ICsgbGluZS5zbGljZSh0YWJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIHBvcyArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMuZmllbGRQb3NpdGlvbnMubWFwKHBvcyA9PiBuZXcgRmllbGRSYW5nZShwb3MuZmllbGQsIGxpbmVTdGFydFtwb3MubGluZV0gKyBwb3MuZnJvbSwgbGluZVN0YXJ0W3Bvcy5saW5lXSArIHBvcy50bykpO1xuICAgICAgICByZXR1cm4geyB0ZXh0LCByYW5nZXMgfTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHRlbXBsYXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGxpbmVzID0gW10sIHBvc2l0aW9ucyA9IFtdLCBtO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRlbXBsYXRlLnNwbGl0KC9cXHJcXG4/fFxcbi8pKSB7XG4gICAgICAgICAgICB3aGlsZSAobSA9IC9bIyRdXFx7KD86KFxcZCspKD86OihbXn1dKikpP3woW159XSopKVxcfS8uZXhlYyhsaW5lKSkge1xuICAgICAgICAgICAgICAgIGxldCBzZXEgPSBtWzFdID8gK21bMV0gOiBudWxsLCBuYW1lID0gbVsyXSB8fCBtWzNdIHx8IFwiXCIsIGZvdW5kID0gLTE7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcSAhPSBudWxsID8gZmllbGRzW2ldLnNlcSA9PSBzZXEgOiBuYW1lID8gZmllbGRzW2ldLm5hbWUgPT0gbmFtZSA6IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBmaWVsZHMubGVuZ3RoICYmIChzZXEgPT0gbnVsbCB8fCAoZmllbGRzW2ldLnNlcSAhPSBudWxsICYmIGZpZWxkc1tpXS5zZXEgPCBzZXEpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnNwbGljZShpLCAwLCB7IHNlcSwgbmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcy5maWVsZCA+PSBmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MuZmllbGQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gobmV3IEZpZWxkUG9zKGZvdW5kLCBsaW5lcy5sZW5ndGgsIG0uaW5kZXgsIG0uaW5kZXggKyBuYW1lLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIG0uaW5kZXgpICsgbmFtZSArIGxpbmUuc2xpY2UobS5pbmRleCArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTbmlwcGV0KGxpbmVzLCBwb3NpdGlvbnMpO1xuICAgIH1cbn1cbmxldCBmaWVsZE1hcmtlciA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgICAgICB0b0RPTSgpIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tc25pcHBldEZpZWxkUG9zaXRpb25cIjtcbiAgICAgICAgICAgIHJldHVybiBzcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9IH0pO1xubGV0IGZpZWxkUmFuZ2UgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc25pcHBldEZpZWxkXCIgfSk7XG5jbGFzcyBBY3RpdmVTbmlwcGV0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZXMsIGFjdGl2ZSkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuZGVjbyA9IERlY29yYXRpb24uc2V0KHJhbmdlcy5tYXAociA9PiAoci5mcm9tID09IHIudG8gPyBmaWVsZE1hcmtlciA6IGZpZWxkUmFuZ2UpLnJhbmdlKHIuZnJvbSwgci50bykpKTtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTbmlwcGV0KHRoaXMucmFuZ2VzLm1hcChyID0+IHIubWFwKGNoYW5nZXMpKSwgdGhpcy5hY3RpdmUpO1xuICAgIH1cbiAgICBzZWxlY3Rpb25JbnNpZGVGaWVsZChzZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlbC5yYW5nZXMuZXZlcnkocmFuZ2UgPT4gdGhpcy5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPT0gdGhpcy5hY3RpdmUgJiYgci5mcm9tIDw9IHJhbmdlLmZyb20gJiYgci50byA+PSByYW5nZS50bykpO1xuICAgIH1cbn1cbmNvbnN0IHNldEFjdGl2ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcCh2YWx1ZSwgY2hhbmdlcykgeyByZXR1cm4gdmFsdWUgJiYgdmFsdWUubWFwKGNoYW5nZXMpOyB9XG59KTtcbmNvbnN0IG1vdmVUb0ZpZWxkID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3Qgc25pcHBldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0QWN0aXZlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhtb3ZlVG9GaWVsZCkgJiYgdmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTbmlwcGV0KHZhbHVlLnJhbmdlcywgZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHIuc2VsZWN0aW9uICYmICF2YWx1ZS5zZWxlY3Rpb25JbnNpZGVGaWVsZCh0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmLCB2YWwgPT4gdmFsID8gdmFsLmRlY28gOiBEZWNvcmF0aW9uLm5vbmUpXG59KTtcbmZ1bmN0aW9uIGZpZWxkU2VsZWN0aW9uKHJhbmdlcywgZmllbGQpIHtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMuZmlsdGVyKHIgPT4gci5maWVsZCA9PSBmaWVsZCkubWFwKHIgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKTtcbn1cbi8qKlxuQ29udmVydCBhIHNuaXBwZXQgdGVtcGxhdGUgdG8gYSBmdW5jdGlvbiB0aGF0IGNhbiBhcHBseSBpdC5cblNuaXBwZXRzIGFyZSB3cml0dGVuIHVzaW5nIHN5bnRheCBsaWtlIHRoaXM6XG5cbiAgICBcImZvciAobGV0ICR7aW5kZXh9ID0gMDsgJHtpbmRleH0gPCAke2VuZH07ICR7aW5kZXh9KyspIHtcXG5cXHQke31cXG59XCJcblxuRWFjaCBgJHt9YCBwbGFjZWhvbGRlciAoeW91IG1heSBhbHNvIHVzZSBgI3t9YCkgaW5kaWNhdGVzIGEgZmllbGRcbnRoYXQgdGhlIHVzZXIgY2FuIGZpbGwgaW4uIEl0cyBuYW1lLCBpZiBhbnksIHdpbGwgYmUgdGhlIGRlZmF1bHRcbmNvbnRlbnQgZm9yIHRoZSBmaWVsZC5cblxuV2hlbiB0aGUgc25pcHBldCBpcyBhY3RpdmF0ZWQgYnkgY2FsbGluZyB0aGUgcmV0dXJuZWQgZnVuY3Rpb24sXG50aGUgY29kZSBpcyBpbnNlcnRlZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIE5ld2xpbmVzIGluIHRoZVxudGVtcGxhdGUgYXJlIGluZGVudGVkIGJ5IHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgc3RhcnQgbGluZSwgcGx1c1xub25lIFtpbmRlbnQgdW5pdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBwZXIgdGFiIGNoYXJhY3RlciBhZnRlclxudGhlIG5ld2xpbmUuXG5cbk9uIGFjdGl2YXRpb24sIChhbGwgaW5zdGFuY2VzIG9mKSB0aGUgZmlyc3QgZmllbGQgYXJlIHNlbGVjdGVkLlxuVGhlIHVzZXIgY2FuIG1vdmUgYmV0d2VlbiBmaWVsZHMgd2l0aCBUYWIgYW5kIFNoaWZ0LVRhYiBhcyBsb25nIGFzXG50aGUgZmllbGRzIGFyZSBhY3RpdmUuIE1vdmluZyB0byB0aGUgbGFzdCBmaWVsZCBvciBtb3ZpbmcgdGhlXG5jdXJzb3Igb3V0IG9mIHRoZSBjdXJyZW50IGZpZWxkIGRlYWN0aXZhdGVzIHRoZSBmaWVsZHMuXG5cblRoZSBvcmRlciBvZiBmaWVsZHMgZGVmYXVsdHMgdG8gdGV4dHVhbCBvcmRlciwgYnV0IHlvdSBjYW4gYWRkXG5udW1iZXJzIHRvIHBsYWNlaG9sZGVycyAoYCR7MX1gIG9yIGAkezE6ZGVmYXVsdFRleHR9YCkgdG8gcHJvdmlkZVxuYSBjdXN0b20gb3JkZXIuXG4qL1xuZnVuY3Rpb24gc25pcHBldCh0ZW1wbGF0ZSkge1xuICAgIGxldCBzbmlwcGV0ID0gU25pcHBldC5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIChlZGl0b3IsIF9jb21wbGV0aW9uLCBmcm9tLCB0bykgPT4ge1xuICAgICAgICBsZXQgeyB0ZXh0LCByYW5nZXMgfSA9IHNuaXBwZXQuaW5zdGFudGlhdGUoZWRpdG9yLnN0YXRlLCBmcm9tKTtcbiAgICAgICAgbGV0IHNwZWMgPSB7IGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogVGV4dC5vZih0ZXh0KSB9IH07XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYy5zZWxlY3Rpb24gPSBmaWVsZFNlbGVjdGlvbihyYW5nZXMsIDApO1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlU25pcHBldChyYW5nZXMsIDApO1xuICAgICAgICAgICAgbGV0IGVmZmVjdHMgPSBzcGVjLmVmZmVjdHMgPSBbc2V0QWN0aXZlLm9mKGFjdGl2ZSldO1xuICAgICAgICAgICAgaWYgKGVkaXRvci5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMucHVzaChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoW3NuaXBwZXRTdGF0ZSwgYWRkU25pcHBldEtleW1hcCwgc25pcHBldFBvaW50ZXJIYW5kbGVyLCBiYXNlVGhlbWVdKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKGVkaXRvci5zdGF0ZS51cGRhdGUoc3BlYykpO1xuICAgIH07XG59XG5mdW5jdGlvbiBtb3ZlRmllbGQoZGlyKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFhY3RpdmUgfHwgZGlyIDwgMCAmJiBhY3RpdmUuYWN0aXZlID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBuZXh0ID0gYWN0aXZlLmFjdGl2ZSArIGRpciwgbGFzdCA9IGRpciA+IDAgJiYgIWFjdGl2ZS5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPT0gbmV4dCArIGRpcik7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IGZpZWxkU2VsZWN0aW9uKGFjdGl2ZS5yYW5nZXMsIG5leHQpLFxuICAgICAgICAgICAgZWZmZWN0czogc2V0QWN0aXZlLm9mKGxhc3QgPyBudWxsIDogbmV3IEFjdGl2ZVNuaXBwZXQoYWN0aXZlLnJhbmdlcywgbmV4dCkpXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQSBjb21tYW5kIHRoYXQgY2xlYXJzIHRoZSBhY3RpdmUgc25pcHBldCwgaWYgYW55LlxuKi9cbmNvbnN0IGNsZWFyU25pcHBldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghYWN0aXZlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgZWZmZWN0czogc2V0QWN0aXZlLm9mKG51bGwpIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdG8gdGhlIG5leHQgc25pcHBldCBmaWVsZCwgaWYgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IG5leHRTbmlwcGV0RmllbGQgPSAvKkBfX1BVUkVfXyovbW92ZUZpZWxkKDEpO1xuLyoqXG5Nb3ZlIHRvIHRoZSBwcmV2aW91cyBzbmlwcGV0IGZpZWxkLCBpZiBhdmFpbGFibGUuXG4qL1xuY29uc3QgcHJldlNuaXBwZXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9tb3ZlRmllbGQoLTEpO1xuY29uc3QgZGVmYXVsdFNuaXBwZXRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiVGFiXCIsIHJ1bjogbmV4dFNuaXBwZXRGaWVsZCwgc2hpZnQ6IHByZXZTbmlwcGV0RmllbGQgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbGVhclNuaXBwZXQgfVxuXTtcbi8qKlxuQSBmYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUga2V5IGJpbmRpbmdzIHVzZWQgYnlcbnNuaXBwZXRzLiBUaGUgZGVmYXVsdCBiaW5kcyBUYWIgdG9cbltgbmV4dFNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm5leHRTbmlwcGV0RmllbGQpLCBTaGlmdC1UYWIgdG9cbltgcHJldlNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLnByZXZTbmlwcGV0RmllbGQpLCBhbmQgRXNjYXBlXG50byBbYGNsZWFyU25pcHBldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsZWFyU25pcHBldCkuXG4qL1xuY29uc3Qgc25pcHBldEtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobWFwcykgeyByZXR1cm4gbWFwcy5sZW5ndGggPyBtYXBzWzBdIDogZGVmYXVsdFNuaXBwZXRLZXltYXA7IH1cbn0pO1xuY29uc3QgYWRkU25pcHBldEtleW1hcCA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL2tleW1hcC5jb21wdXRlKFtzbmlwcGV0S2V5bWFwXSwgc3RhdGUgPT4gc3RhdGUuZmFjZXQoc25pcHBldEtleW1hcCkpKTtcbi8qKlxuQ3JlYXRlIGEgY29tcGxldGlvbiBmcm9tIGEgc25pcHBldC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGVcbnByb3BlcnRpZXMgZnJvbSBgY29tcGxldGlvbmAsIHBsdXMgYW4gYGFwcGx5YCBmdW5jdGlvbiB0aGF0XG5hcHBsaWVzIHRoZSBzbmlwcGV0LlxuKi9cbmZ1bmN0aW9uIHNuaXBwZXRDb21wbGV0aW9uKHRlbXBsYXRlLCBjb21wbGV0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tcGxldGlvbiksIHsgYXBwbHk6IHNuaXBwZXQodGVtcGxhdGUpIH0pO1xufVxuY29uc3Qgc25pcHBldFBvaW50ZXJIYW5kbGVyID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAgbW91c2Vkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIGxldCBhY3RpdmUgPSB2aWV3LnN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpLCBwb3M7XG4gICAgICAgIGlmICghYWN0aXZlIHx8IChwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KSkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG1hdGNoID0gYWN0aXZlLnJhbmdlcy5maW5kKHIgPT4gci5mcm9tIDw9IHBvcyAmJiByLnRvID49IHBvcyk7XG4gICAgICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guZmllbGQgPT0gYWN0aXZlLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IGZpZWxkU2VsZWN0aW9uKGFjdGl2ZS5yYW5nZXMsIG1hdGNoLmZpZWxkKSxcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID4gbWF0Y2guZmllbGQpID8gbmV3IEFjdGl2ZVNuaXBwZXQoYWN0aXZlLnJhbmdlcywgbWF0Y2guZmllbGQpIDogbnVsbClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiB3b3JkUkUod29yZENoYXJzKSB7XG4gICAgbGV0IGVzY2FwZWQgPSB3b3JkQ2hhcnMucmVwbGFjZSgvW1xcXFxbLisqPygpe3xeJF0vZywgXCJcXFxcJCZcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYFtcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fJHtlc2NhcGVkfV0rYCwgXCJ1Z1wiKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBbXFx3JHtlc2NhcGVkfV1gLCBcImdcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwUkUocmUsIGYpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChmKHJlLnNvdXJjZSksIHJlLnVuaWNvZGUgPyBcInVcIiA6IFwiXCIpO1xufVxuY29uc3Qgd29yZENhY2hlcyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gd29yZENhY2hlKHdvcmRDaGFycykge1xuICAgIHJldHVybiB3b3JkQ2FjaGVzW3dvcmRDaGFyc10gfHwgKHdvcmRDYWNoZXNbd29yZENoYXJzXSA9IG5ldyBXZWFrTWFwKTtcbn1cbmZ1bmN0aW9uIHN0b3JlV29yZHMoZG9jLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQpIHtcbiAgICBmb3IgKGxldCBsaW5lcyA9IGRvYy5pdGVyTGluZXMoKSwgcG9zID0gMDsgIWxpbmVzLm5leHQoKS5kb25lOykge1xuICAgICAgICBsZXQgeyB2YWx1ZSB9ID0gbGluZXMsIG07XG4gICAgICAgIHdvcmRSRS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAobSA9IHdvcmRSRS5leGVjKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFzZWVuW21bMF1dICYmIHBvcyArIG0uaW5kZXggIT0gaWdub3JlQXQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6IFwidGV4dFwiLCBsYWJlbDogbVswXSB9KTtcbiAgICAgICAgICAgICAgICBzZWVuW21bMF1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+PSAyMDAwIC8qIE1heExpc3QgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gdmFsdWUubGVuZ3RoICsgMTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0V29yZHMoZG9jLCBjYWNoZSwgd29yZFJFLCB0bywgaWdub3JlQXQpIHtcbiAgICBsZXQgYmlnID0gZG9jLmxlbmd0aCA+PSAxMDAwIC8qIE1pbkNhY2hlTGVuICovO1xuICAgIGxldCBjYWNoZWQgPSBiaWcgJiYgY2FjaGUuZ2V0KGRvYyk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICBsZXQgcmVzdWx0ID0gW10sIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChkb2MuY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGRvYy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoLmxlbmd0aCA+PSAxMDAwIC8qIE1pbkNhY2hlTGVuICovKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyBvZiBjb2xsZWN0V29yZHMoY2gsIGNhY2hlLCB3b3JkUkUsIHRvIC0gcG9zLCBpZ25vcmVBdCAtIHBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuW2MubGFiZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW2MubGFiZWxdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVXb3JkcyhjaCwgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0IC0gcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBjaC5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdG9yZVdvcmRzKGRvYywgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0KTtcbiAgICB9XG4gICAgaWYgKGJpZyAmJiByZXN1bHQubGVuZ3RoIDwgMjAwMCAvKiBNYXhMaXN0ICovKVxuICAgICAgICBjYWNoZS5zZXQoZG9jLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkEgY29tcGxldGlvbiBzb3VyY2UgdGhhdCB3aWxsIHNjYW4gdGhlIGRvY3VtZW50IGZvciB3b3JkcyAodXNpbmcgYVxuW2NoYXJhY3RlciBjYXRlZ29yaXplcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpKSwgYW5kXG5yZXR1cm4gdGhvc2UgYXMgY29tcGxldGlvbnMuXG4qL1xuY29uc3QgY29tcGxldGVBbnlXb3JkID0gY29udGV4dCA9PiB7XG4gICAgbGV0IHdvcmRDaGFycyA9IGNvbnRleHQuc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgY29udGV4dC5wb3MpLmpvaW4oXCJcIik7XG4gICAgbGV0IHJlID0gd29yZFJFKHdvcmRDaGFycyk7XG4gICAgbGV0IHRva2VuID0gY29udGV4dC5tYXRjaEJlZm9yZShtYXBSRShyZSwgcyA9PiBzICsgXCIkXCIpKTtcbiAgICBpZiAoIXRva2VuICYmICFjb250ZXh0LmV4cGxpY2l0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZnJvbSA9IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zO1xuICAgIGxldCBvcHRpb25zID0gY29sbGVjdFdvcmRzKGNvbnRleHQuc3RhdGUuZG9jLCB3b3JkQ2FjaGUod29yZENoYXJzKSwgcmUsIDUwMDAwIC8qIFJhbmdlICovLCBmcm9tKTtcbiAgICByZXR1cm4geyBmcm9tLCBvcHRpb25zLCBzcGFuOiBtYXBSRShyZSwgcyA9PiBcIl5cIiArIHMpIH07XG59O1xuXG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhdXRvY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBhdXRvY29tcGxldGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGNvbXBsZXRpb25TdGF0ZSxcbiAgICAgICAgY29tcGxldGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBjb21wbGV0aW9uUGx1Z2luLFxuICAgICAgICBjb21wbGV0aW9uS2V5bWFwRXh0LFxuICAgICAgICBiYXNlVGhlbWVcbiAgICBdO1xufVxuLyoqXG5CYXNpYyBrZXliaW5kaW5ncyBmb3IgYXV0b2NvbXBsZXRpb24uXG5cbiAtIEN0cmwtU3BhY2U6IFtgc3RhcnRDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuc3RhcnRDb21wbGV0aW9uKVxuIC0gRXNjYXBlOiBbYGNsb3NlQ29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQ29tcGxldGlvbilcbiAtIEFycm93RG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSlgXG4gLSBBcnJvd1VwOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYChmYWxzZSlgXG4gLSBQYWdlRG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSwgXCJwYWdlXCIpYFxuIC0gUGFnZURvd246IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKHRydWUsIFwicGFnZVwiKWBcbiAtIEVudGVyOiBbYGFjY2VwdENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hY2NlcHRDb21wbGV0aW9uKVxuKi9cbmNvbnN0IGNvbXBsZXRpb25LZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TcGFjZVwiLCBydW46IHN0YXJ0Q29tcGxldGlvbiB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IGNsb3NlQ29tcGxldGlvbiB9LFxuICAgIHsga2V5OiBcIkFycm93RG93blwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlKSB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZmFsc2UpIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24odHJ1ZSwgXCJwYWdlXCIpIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZhbHNlLCBcInBhZ2VcIikgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBydW46IGFjY2VwdENvbXBsZXRpb24gfVxuXTtcbmNvbnN0IGNvbXBsZXRpb25LZXltYXBFeHQgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9rZXltYXAuY29tcHV0ZU4oW2NvbXBsZXRpb25Db25maWddLCBzdGF0ZSA9PiBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5kZWZhdWx0S2V5bWFwID8gW2NvbXBsZXRpb25LZXltYXBdIDogW10pKTtcbi8qKlxuR2V0IHRoZSBjdXJyZW50IGNvbXBsZXRpb24gc3RhdHVzLiBXaGVuIGNvbXBsZXRpb25zIGFyZSBhdmFpbGFibGUsXG50aGlzIHdpbGwgcmV0dXJuIGBcImFjdGl2ZVwiYC4gV2hlbiBjb21wbGV0aW9ucyBhcmUgcGVuZGluZyAoaW4gdGhlXG5wcm9jZXNzIG9mIGJlaW5nIHF1ZXJpZWQpLCB0aGlzIHJldHVybnMgYFwicGVuZGluZ1wiYC4gT3RoZXJ3aXNlLCBpdFxucmV0dXJucyBgbnVsbGAuXG4qL1xuZnVuY3Rpb24gY29tcGxldGlvblN0YXR1cyhzdGF0ZSkge1xuICAgIGxldCBjU3RhdGUgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBQZW5kaW5nICovKSA/IFwicGVuZGluZ1wiXG4gICAgICAgIDogY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBJbmFjdGl2ZSAqLykgPyBcImFjdGl2ZVwiIDogbnVsbDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgYXZhaWxhYmxlIGNvbXBsZXRpb25zIGFzIGFuIGFycmF5LlxuKi9cbmZ1bmN0aW9uIGN1cnJlbnRDb21wbGV0aW9ucyhzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb3BlbiA9IChfYSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3BlbjtcbiAgICByZXR1cm4gb3BlbiA/IG9wZW4ub3B0aW9ucy5tYXAobyA9PiBvLmNvbXBsZXRpb24pIDogW107XG59XG4vKipcblJldHVybiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbXBsZXRpb24sIGlmIGFueS5cbiovXG5mdW5jdGlvbiBzZWxlY3RlZENvbXBsZXRpb24oc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgcmV0dXJuIG9wZW4gPyBvcGVuLm9wdGlvbnNbb3Blbi5zZWxlY3RlZF0uY29tcGxldGlvbiA6IG51bGw7XG59XG5cbmV4cG9ydCB7IENvbXBsZXRpb25Db250ZXh0LCBhY2NlcHRDb21wbGV0aW9uLCBhdXRvY29tcGxldGlvbiwgY2xlYXJTbmlwcGV0LCBjbG9zZUNvbXBsZXRpb24sIGNvbXBsZXRlQW55V29yZCwgY29tcGxldGVGcm9tTGlzdCwgY29tcGxldGlvbktleW1hcCwgY29tcGxldGlvblN0YXR1cywgY3VycmVudENvbXBsZXRpb25zLCBpZkluLCBpZk5vdEluLCBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbiwgbmV4dFNuaXBwZXRGaWVsZCwgcGlja2VkQ29tcGxldGlvbiwgcHJldlNuaXBwZXRGaWVsZCwgc2VsZWN0ZWRDb21wbGV0aW9uLCBzbmlwcGV0LCBzbmlwcGV0Q29tcGxldGlvbiwgc25pcHBldEtleW1hcCwgc3RhcnRDb21wbGV0aW9uIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/autocomplete/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"copyLineDown\": function() { return /* binding */ copyLineDown; },\n/* harmony export */   \"copyLineUp\": function() { return /* binding */ copyLineUp; },\n/* harmony export */   \"cursorCharBackward\": function() { return /* binding */ cursorCharBackward; },\n/* harmony export */   \"cursorCharForward\": function() { return /* binding */ cursorCharForward; },\n/* harmony export */   \"cursorCharLeft\": function() { return /* binding */ cursorCharLeft; },\n/* harmony export */   \"cursorCharRight\": function() { return /* binding */ cursorCharRight; },\n/* harmony export */   \"cursorDocEnd\": function() { return /* binding */ cursorDocEnd; },\n/* harmony export */   \"cursorDocStart\": function() { return /* binding */ cursorDocStart; },\n/* harmony export */   \"cursorGroupBackward\": function() { return /* binding */ cursorGroupBackward; },\n/* harmony export */   \"cursorGroupForward\": function() { return /* binding */ cursorGroupForward; },\n/* harmony export */   \"cursorGroupLeft\": function() { return /* binding */ cursorGroupLeft; },\n/* harmony export */   \"cursorGroupRight\": function() { return /* binding */ cursorGroupRight; },\n/* harmony export */   \"cursorLineBoundaryBackward\": function() { return /* binding */ cursorLineBoundaryBackward; },\n/* harmony export */   \"cursorLineBoundaryForward\": function() { return /* binding */ cursorLineBoundaryForward; },\n/* harmony export */   \"cursorLineDown\": function() { return /* binding */ cursorLineDown; },\n/* harmony export */   \"cursorLineEnd\": function() { return /* binding */ cursorLineEnd; },\n/* harmony export */   \"cursorLineStart\": function() { return /* binding */ cursorLineStart; },\n/* harmony export */   \"cursorLineUp\": function() { return /* binding */ cursorLineUp; },\n/* harmony export */   \"cursorMatchingBracket\": function() { return /* binding */ cursorMatchingBracket; },\n/* harmony export */   \"cursorPageDown\": function() { return /* binding */ cursorPageDown; },\n/* harmony export */   \"cursorPageUp\": function() { return /* binding */ cursorPageUp; },\n/* harmony export */   \"cursorSubwordBackward\": function() { return /* binding */ cursorSubwordBackward; },\n/* harmony export */   \"cursorSubwordForward\": function() { return /* binding */ cursorSubwordForward; },\n/* harmony export */   \"cursorSyntaxLeft\": function() { return /* binding */ cursorSyntaxLeft; },\n/* harmony export */   \"cursorSyntaxRight\": function() { return /* binding */ cursorSyntaxRight; },\n/* harmony export */   \"defaultKeymap\": function() { return /* binding */ defaultKeymap; },\n/* harmony export */   \"deleteCharBackward\": function() { return /* binding */ deleteCharBackward; },\n/* harmony export */   \"deleteCharForward\": function() { return /* binding */ deleteCharForward; },\n/* harmony export */   \"deleteGroupBackward\": function() { return /* binding */ deleteGroupBackward; },\n/* harmony export */   \"deleteGroupForward\": function() { return /* binding */ deleteGroupForward; },\n/* harmony export */   \"deleteLine\": function() { return /* binding */ deleteLine; },\n/* harmony export */   \"deleteToLineEnd\": function() { return /* binding */ deleteToLineEnd; },\n/* harmony export */   \"deleteToLineStart\": function() { return /* binding */ deleteToLineStart; },\n/* harmony export */   \"deleteTrailingWhitespace\": function() { return /* binding */ deleteTrailingWhitespace; },\n/* harmony export */   \"emacsStyleKeymap\": function() { return /* binding */ emacsStyleKeymap; },\n/* harmony export */   \"indentLess\": function() { return /* binding */ indentLess; },\n/* harmony export */   \"indentMore\": function() { return /* binding */ indentMore; },\n/* harmony export */   \"indentSelection\": function() { return /* binding */ indentSelection; },\n/* harmony export */   \"indentWithTab\": function() { return /* binding */ indentWithTab; },\n/* harmony export */   \"insertBlankLine\": function() { return /* binding */ insertBlankLine; },\n/* harmony export */   \"insertNewline\": function() { return /* binding */ insertNewline; },\n/* harmony export */   \"insertNewlineAndIndent\": function() { return /* binding */ insertNewlineAndIndent; },\n/* harmony export */   \"insertTab\": function() { return /* binding */ insertTab; },\n/* harmony export */   \"moveLineDown\": function() { return /* binding */ moveLineDown; },\n/* harmony export */   \"moveLineUp\": function() { return /* binding */ moveLineUp; },\n/* harmony export */   \"selectAll\": function() { return /* binding */ selectAll; },\n/* harmony export */   \"selectCharBackward\": function() { return /* binding */ selectCharBackward; },\n/* harmony export */   \"selectCharForward\": function() { return /* binding */ selectCharForward; },\n/* harmony export */   \"selectCharLeft\": function() { return /* binding */ selectCharLeft; },\n/* harmony export */   \"selectCharRight\": function() { return /* binding */ selectCharRight; },\n/* harmony export */   \"selectDocEnd\": function() { return /* binding */ selectDocEnd; },\n/* harmony export */   \"selectDocStart\": function() { return /* binding */ selectDocStart; },\n/* harmony export */   \"selectGroupBackward\": function() { return /* binding */ selectGroupBackward; },\n/* harmony export */   \"selectGroupForward\": function() { return /* binding */ selectGroupForward; },\n/* harmony export */   \"selectGroupLeft\": function() { return /* binding */ selectGroupLeft; },\n/* harmony export */   \"selectGroupRight\": function() { return /* binding */ selectGroupRight; },\n/* harmony export */   \"selectLine\": function() { return /* binding */ selectLine; },\n/* harmony export */   \"selectLineBoundaryBackward\": function() { return /* binding */ selectLineBoundaryBackward; },\n/* harmony export */   \"selectLineBoundaryForward\": function() { return /* binding */ selectLineBoundaryForward; },\n/* harmony export */   \"selectLineDown\": function() { return /* binding */ selectLineDown; },\n/* harmony export */   \"selectLineEnd\": function() { return /* binding */ selectLineEnd; },\n/* harmony export */   \"selectLineStart\": function() { return /* binding */ selectLineStart; },\n/* harmony export */   \"selectLineUp\": function() { return /* binding */ selectLineUp; },\n/* harmony export */   \"selectMatchingBracket\": function() { return /* binding */ selectMatchingBracket; },\n/* harmony export */   \"selectPageDown\": function() { return /* binding */ selectPageDown; },\n/* harmony export */   \"selectPageUp\": function() { return /* binding */ selectPageUp; },\n/* harmony export */   \"selectParentSyntax\": function() { return /* binding */ selectParentSyntax; },\n/* harmony export */   \"selectSubwordBackward\": function() { return /* binding */ selectSubwordBackward; },\n/* harmony export */   \"selectSubwordForward\": function() { return /* binding */ selectSubwordForward; },\n/* harmony export */   \"selectSyntaxLeft\": function() { return /* binding */ selectSyntaxLeft; },\n/* harmony export */   \"selectSyntaxRight\": function() { return /* binding */ selectSyntaxRight; },\n/* harmony export */   \"simplifySelection\": function() { return /* binding */ simplifySelection; },\n/* harmony export */   \"splitLine\": function() { return /* binding */ splitLine; },\n/* harmony export */   \"standardKeymap\": function() { return /* binding */ standardKeymap; },\n/* harmony export */   \"transposeChars\": function() { return /* binding */ transposeChars; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/matchbrackets */ \"./node_modules/@codemirror/matchbrackets/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\n\n\n\n\n\nfunction updateSel(sel, by) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\n\nfunction setSel(state, selection) {\n  return state.update({\n    selection: selection,\n    scrollIntoView: true,\n    userEvent: \"select\"\n  });\n}\n\nfunction moveSel(_ref, how) {\n  var state = _ref.state,\n      dispatch = _ref.dispatch;\n  var selection = updateSel(state.selection, how);\n  if (selection.eq(state.selection)) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\n\nfunction rangeEnd(range, forward) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);\n}\n\nfunction cursorByChar(view, forward) {\n  return moveSel(view, function (range) {\n    return range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward);\n  });\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/\n\n\nvar cursorCharLeft = function cursorCharLeft(view) {\n  return cursorByChar(view, view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n};\n/**\nMove the selection one character to the right.\n*/\n\n\nvar cursorCharRight = function cursorCharRight(view) {\n  return cursorByChar(view, view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n};\n/**\nMove the selection one character forward.\n*/\n\n\nvar cursorCharForward = function cursorCharForward(view) {\n  return cursorByChar(view, true);\n};\n/**\nMove the selection one character backward.\n*/\n\n\nvar cursorCharBackward = function cursorCharBackward(view) {\n  return cursorByChar(view, false);\n};\n\nfunction cursorByGroup(view, forward) {\n  return moveSel(view, function (range) {\n    return range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward);\n  });\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/\n\n\nvar cursorGroupLeft = function cursorGroupLeft(view) {\n  return cursorByGroup(view, view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n};\n/**\nMove the selection one group to the right.\n*/\n\n\nvar cursorGroupRight = function cursorGroupRight(view) {\n  return cursorByGroup(view, view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n};\n/**\nMove the selection one group forward.\n*/\n\n\nvar cursorGroupForward = function cursorGroupForward(view) {\n  return cursorByGroup(view, true);\n};\n/**\nMove the selection one group backward.\n*/\n\n\nvar cursorGroupBackward = function cursorGroupBackward(view) {\n  return cursorByGroup(view, false);\n};\n\nfunction moveBySubword(view, range, forward) {\n  var categorize = view.state.charCategorizer(range.from);\n  return view.moveByChar(range, forward, function (start) {\n    var cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space,\n        pos = range.from;\n    var done = false,\n        sawUpper = false,\n        sawLower = false;\n\n    var step = function step(next) {\n      if (done) return false;\n      pos += forward ? next.length : -next.length;\n      var nextCat = categorize(next),\n          ahead;\n      if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space) cat = nextCat;\n      if (cat != nextCat) return false;\n\n      if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n        if (next.toLowerCase() == next) {\n          if (!forward && sawUpper) return false;\n          sawLower = true;\n        } else if (sawLower) {\n          if (forward) return false;\n          done = true;\n        } else {\n          if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && ahead.toLowerCase() == ahead) return false;\n          sawUpper = true;\n        }\n      }\n\n      return true;\n    };\n\n    step(start);\n    return step;\n  });\n}\n\nfunction cursorBySubword(view, forward) {\n  return moveSel(view, function (range) {\n    return range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward);\n  });\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/\n\n\nvar cursorSubwordForward = function cursorSubwordForward(view) {\n  return cursorBySubword(view, true);\n};\n/**\nMove the selection one group or camel-case subword backward.\n*/\n\n\nvar cursorSubwordBackward = function cursorSubwordBackward(view) {\n  return cursorBySubword(view, false);\n};\n\nfunction interestingNode(state, node, bracketProp) {\n  if (node.type.prop(bracketProp)) return true;\n  var len = node.to - node.from;\n  return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\n\nfunction moveBySyntax(state, start, forward) {\n  var pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);\n  var bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy; // Scan forward through child nodes to see if there's an interesting\n  // node ahead.\n\n  for (var at = start.head;;) {\n    var next = forward ? pos.childAfter(at) : pos.childBefore(at);\n    if (!next) break;\n    if (interestingNode(state, next, bracketProp)) pos = next;else at = forward ? next.to : next.from;\n  }\n\n  var bracket = pos.type.prop(bracketProp),\n      match,\n      newPos;\n  if (bracket && (match = forward ? (0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__.matchBrackets)(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;else newPos = forward ? pos.to : pos.from;\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/\n\n\nvar cursorSyntaxLeft = function cursorSyntaxLeft(view) {\n  return moveSel(view, function (range) {\n    return moveBySyntax(view.state, range, view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n  });\n};\n/**\nMove the cursor over the next syntactic element to the right.\n*/\n\n\nvar cursorSyntaxRight = function cursorSyntaxRight(view) {\n  return moveSel(view, function (range) {\n    return moveBySyntax(view.state, range, view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n  });\n};\n\nfunction cursorByLine(view, forward) {\n  return moveSel(view, function (range) {\n    if (!range.empty) return rangeEnd(range, forward);\n    var moved = view.moveVertically(range, forward);\n    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n  });\n}\n/**\nMove the selection one line up.\n*/\n\n\nvar cursorLineUp = function cursorLineUp(view) {\n  return cursorByLine(view, false);\n};\n/**\nMove the selection one line down.\n*/\n\n\nvar cursorLineDown = function cursorLineDown(view) {\n  return cursorByLine(view, true);\n};\n\nfunction cursorByPage(view, forward) {\n  var state = view.state,\n      selection = updateSel(state.selection, function (range) {\n    return range.empty ? view.moveVertically(range, forward, view.dom.clientHeight) : rangeEnd(range, forward);\n  });\n  if (selection.eq(state.selection)) return false;\n  var startPos = view.coordsAtPos(state.selection.main.head);\n  var scrollRect = view.scrollDOM.getBoundingClientRect();\n  view.dispatch(setSel(state, selection), {\n    effects: startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.main.head, {\n      y: \"start\",\n      yMargin: startPos.top - scrollRect.top\n    }) : undefined\n  });\n  return true;\n}\n/**\nMove the selection one page up.\n*/\n\n\nvar cursorPageUp = function cursorPageUp(view) {\n  return cursorByPage(view, false);\n};\n/**\nMove the selection one page down.\n*/\n\n\nvar cursorPageDown = function cursorPageDown(view) {\n  return cursorByPage(view, true);\n};\n\nfunction moveByLineBoundary(view, start, forward) {\n  var line = view.lineBlockAt(start.head),\n      moved = view.moveToLineBoundary(start, forward);\n  if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n\n  if (!forward && moved.head == line.from && line.length) {\n    var space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n    if (space && start.head != line.from + space) moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);\n  }\n\n  return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/\n\n\nvar cursorLineBoundaryForward = function cursorLineBoundaryForward(view) {\n  return moveSel(view, function (range) {\n    return moveByLineBoundary(view, range, true);\n  });\n};\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/\n\n\nvar cursorLineBoundaryBackward = function cursorLineBoundaryBackward(view) {\n  return moveSel(view, function (range) {\n    return moveByLineBoundary(view, range, false);\n  });\n};\n/**\nMove the selection to the start of the line.\n*/\n\n\nvar cursorLineStart = function cursorLineStart(view) {\n  return moveSel(view, function (range) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1);\n  });\n};\n/**\nMove the selection to the end of the line.\n*/\n\n\nvar cursorLineEnd = function cursorLineEnd(view) {\n  return moveSel(view, function (range) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1);\n  });\n};\n\nfunction toMatchingBracket(state, dispatch, extend) {\n  var found = false,\n      selection = updateSel(state.selection, function (range) {\n    var matching = (0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__.matchBrackets)(state, range.head, -1) || (0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__.matchBrackets)(state, range.head, 1) || range.head > 0 && (0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__.matchBrackets)(state, range.head - 1, 1) || range.head < state.doc.length && (0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__.matchBrackets)(state, range.head + 1, -1);\n    if (!matching || !matching.end) return range;\n    found = true;\n    var head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n    return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);\n  });\n  if (!found) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/\n\n\nvar cursorMatchingBracket = function cursorMatchingBracket(_ref2) {\n  var state = _ref2.state,\n      dispatch = _ref2.dispatch;\n  return toMatchingBracket(state, dispatch, false);\n};\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/\n\n\nvar selectMatchingBracket = function selectMatchingBracket(_ref3) {\n  var state = _ref3.state,\n      dispatch = _ref3.dispatch;\n  return toMatchingBracket(state, dispatch, true);\n};\n\nfunction extendSel(view, how) {\n  var selection = updateSel(view.state.selection, function (range) {\n    var head = how(range);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn);\n  });\n  if (selection.eq(view.state.selection)) return false;\n  view.dispatch(setSel(view.state, selection));\n  return true;\n}\n\nfunction selectByChar(view, forward) {\n  return extendSel(view, function (range) {\n    return view.moveByChar(range, forward);\n  });\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/\n\n\nvar selectCharLeft = function selectCharLeft(view) {\n  return selectByChar(view, view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n};\n/**\nMove the selection head one character to the right.\n*/\n\n\nvar selectCharRight = function selectCharRight(view) {\n  return selectByChar(view, view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n};\n/**\nMove the selection head one character forward.\n*/\n\n\nvar selectCharForward = function selectCharForward(view) {\n  return selectByChar(view, true);\n};\n/**\nMove the selection head one character backward.\n*/\n\n\nvar selectCharBackward = function selectCharBackward(view) {\n  return selectByChar(view, false);\n};\n\nfunction selectByGroup(view, forward) {\n  return extendSel(view, function (range) {\n    return view.moveByGroup(range, forward);\n  });\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/\n\n\nvar selectGroupLeft = function selectGroupLeft(view) {\n  return selectByGroup(view, view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n};\n/**\nMove the selection head one group to the right.\n*/\n\n\nvar selectGroupRight = function selectGroupRight(view) {\n  return selectByGroup(view, view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n};\n/**\nMove the selection head one group forward.\n*/\n\n\nvar selectGroupForward = function selectGroupForward(view) {\n  return selectByGroup(view, true);\n};\n/**\nMove the selection head one group backward.\n*/\n\n\nvar selectGroupBackward = function selectGroupBackward(view) {\n  return selectByGroup(view, false);\n};\n\nfunction selectBySubword(view, forward) {\n  return extendSel(view, function (range) {\n    return moveBySubword(view, range, forward);\n  });\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/\n\n\nvar selectSubwordForward = function selectSubwordForward(view) {\n  return selectBySubword(view, true);\n};\n/**\nMove the selection head one group or subword backward.\n*/\n\n\nvar selectSubwordBackward = function selectSubwordBackward(view) {\n  return selectBySubword(view, false);\n};\n/**\nMove the selection head over the next syntactic element to the left.\n*/\n\n\nvar selectSyntaxLeft = function selectSyntaxLeft(view) {\n  return extendSel(view, function (range) {\n    return moveBySyntax(view.state, range, view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n  });\n};\n/**\nMove the selection head over the next syntactic element to the right.\n*/\n\n\nvar selectSyntaxRight = function selectSyntaxRight(view) {\n  return extendSel(view, function (range) {\n    return moveBySyntax(view.state, range, view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n  });\n};\n\nfunction selectByLine(view, forward) {\n  return extendSel(view, function (range) {\n    return view.moveVertically(range, forward);\n  });\n}\n/**\nMove the selection head one line up.\n*/\n\n\nvar selectLineUp = function selectLineUp(view) {\n  return selectByLine(view, false);\n};\n/**\nMove the selection head one line down.\n*/\n\n\nvar selectLineDown = function selectLineDown(view) {\n  return selectByLine(view, true);\n};\n\nfunction selectByPage(view, forward) {\n  return extendSel(view, function (range) {\n    return view.moveVertically(range, forward, view.dom.clientHeight);\n  });\n}\n/**\nMove the selection head one page up.\n*/\n\n\nvar selectPageUp = function selectPageUp(view) {\n  return selectByPage(view, false);\n};\n/**\nMove the selection head one page down.\n*/\n\n\nvar selectPageDown = function selectPageDown(view) {\n  return selectByPage(view, true);\n};\n/**\nMove the selection head to the next line boundary.\n*/\n\n\nvar selectLineBoundaryForward = function selectLineBoundaryForward(view) {\n  return extendSel(view, function (range) {\n    return moveByLineBoundary(view, range, true);\n  });\n};\n/**\nMove the selection head to the previous line boundary.\n*/\n\n\nvar selectLineBoundaryBackward = function selectLineBoundaryBackward(view) {\n  return extendSel(view, function (range) {\n    return moveByLineBoundary(view, range, false);\n  });\n};\n/**\nMove the selection head to the start of the line.\n*/\n\n\nvar selectLineStart = function selectLineStart(view) {\n  return extendSel(view, function (range) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from);\n  });\n};\n/**\nMove the selection head to the end of the line.\n*/\n\n\nvar selectLineEnd = function selectLineEnd(view) {\n  return extendSel(view, function (range) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to);\n  });\n};\n/**\nMove the selection to the start of the document.\n*/\n\n\nvar cursorDocStart = function cursorDocStart(_ref4) {\n  var state = _ref4.state,\n      dispatch = _ref4.dispatch;\n  dispatch(setSel(state, {\n    anchor: 0\n  }));\n  return true;\n};\n/**\nMove the selection to the end of the document.\n*/\n\n\nvar cursorDocEnd = function cursorDocEnd(_ref5) {\n  var state = _ref5.state,\n      dispatch = _ref5.dispatch;\n  dispatch(setSel(state, {\n    anchor: state.doc.length\n  }));\n  return true;\n};\n/**\nMove the selection head to the start of the document.\n*/\n\n\nvar selectDocStart = function selectDocStart(_ref6) {\n  var state = _ref6.state,\n      dispatch = _ref6.dispatch;\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: 0\n  }));\n  return true;\n};\n/**\nMove the selection head to the end of the document.\n*/\n\n\nvar selectDocEnd = function selectDocEnd(_ref7) {\n  var state = _ref7.state,\n      dispatch = _ref7.dispatch;\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: state.doc.length\n  }));\n  return true;\n};\n/**\nSelect the entire document.\n*/\n\n\nvar selectAll = function selectAll(_ref8) {\n  var state = _ref8.state,\n      dispatch = _ref8.dispatch;\n  dispatch(state.update({\n    selection: {\n      anchor: 0,\n      head: state.doc.length\n    },\n    userEvent: \"select\"\n  }));\n  return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/\n\n\nvar selectLine = function selectLine(_ref9) {\n  var state = _ref9.state,\n      dispatch = _ref9.dispatch;\n  var ranges = selectedLineBlocks(state).map(function (_ref10) {\n    var from = _ref10.from,\n        to = _ref10.to;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length));\n  });\n  dispatch(state.update({\n    selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges),\n    userEvent: \"select\"\n  }));\n  return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/\n\n\nvar selectParentSyntax = function selectParentSyntax(_ref11) {\n  var state = _ref11.state,\n      dispatch = _ref11.dispatch;\n  var selection = updateSel(state.selection, function (range) {\n    var _a;\n\n    var context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(range.head, 1);\n\n    while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent))) {\n      context = context.parent;\n    }\n\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(context.to, context.from);\n  });\n  dispatch(setSel(state, selection));\n  return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/\n\n\nvar simplifySelection = function simplifySelection(_ref12) {\n  var state = _ref12.state,\n      dispatch = _ref12.dispatch;\n  var cur = state.selection,\n      selection = null;\n  if (cur.ranges.length > 1) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([cur.main]);else if (!cur.main.empty) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)]);\n  if (!selection) return false;\n  dispatch(setSel(state, selection));\n  return true;\n};\n\nfunction deleteBy(_ref13, by) {\n  var state = _ref13.state,\n      dispatch = _ref13.dispatch;\n  if (state.readOnly) return false;\n  var event = \"delete.selection\";\n  var changes = state.changeByRange(function (range) {\n    var from = range.from,\n        to = range.to;\n\n    if (from == to) {\n      var towards = by(from);\n      if (towards < from) event = \"delete.backward\";else if (towards > from) event = \"delete.forward\";\n      from = Math.min(from, towards);\n      to = Math.max(to, towards);\n    }\n\n    return from == to ? {\n      range: range\n    } : {\n      changes: {\n        from: from,\n        to: to\n      },\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from)\n    };\n  });\n  if (changes.changes.empty) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: event\n  }));\n  return true;\n}\n\nfunction skipAtomic(target, pos, forward) {\n  if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView) {\n    var _iterator = _createForOfIteratorHelper(target.pluginField(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.PluginField.atomicRanges)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var ranges = _step.value;\n        ranges.between(pos, pos, function (from, to) {\n          if (from < pos && to > pos) pos = forward ? to : from;\n        });\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return pos;\n}\n\nvar deleteByChar = function deleteByChar(target, forward) {\n  return deleteBy(target, function (pos) {\n    var state = target.state,\n        line = state.doc.lineAt(pos),\n        before,\n        targetPos;\n\n    if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n      if (before[before.length - 1] == \"\\t\") return pos - 1;\n      var col = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_5__.countColumn)(before, state.tabSize),\n          drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);\n\n      for (var i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++) {\n        pos--;\n      }\n\n      targetPos = pos;\n    } else {\n      targetPos = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_5__.findClusterBreak)(line.text, pos - line.from, forward, forward) + line.from;\n      if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;\n    }\n\n    return skipAtomic(target, targetPos, forward);\n  });\n};\n/**\nDelete the selection, or, for cursor selections, the character\nbefore the cursor.\n*/\n\n\nvar deleteCharBackward = function deleteCharBackward(view) {\n  return deleteByChar(view, false);\n};\n/**\nDelete the selection or the character after the cursor.\n*/\n\n\nvar deleteCharForward = function deleteCharForward(view) {\n  return deleteByChar(view, true);\n};\n\nvar deleteByGroup = function deleteByGroup(target, forward) {\n  return deleteBy(target, function (start) {\n    var pos = start,\n        state = target.state,\n        line = state.doc.lineAt(pos);\n    var categorize = state.charCategorizer(pos);\n\n    for (var cat = null;;) {\n      if (pos == (forward ? line.to : line.from)) {\n        if (pos == start && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n        break;\n      }\n\n      var next = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_5__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\n      var nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n      var nextCat = categorize(nextChar);\n      if (cat != null && nextCat != cat) break;\n      if (nextChar != \" \" || pos != start) cat = nextCat;\n      pos = next;\n    }\n\n    return skipAtomic(target, pos, forward);\n  });\n};\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/\n\n\nvar deleteGroupBackward = function deleteGroupBackward(target) {\n  return deleteByGroup(target, false);\n};\n/**\nDelete the selection or forward until the end of the next group.\n*/\n\n\nvar deleteGroupForward = function deleteGroupForward(target) {\n  return deleteByGroup(target, true);\n};\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/\n\n\nvar deleteToLineEnd = function deleteToLineEnd(view) {\n  return deleteBy(view, function (pos) {\n    var lineEnd = view.lineBlockAt(pos).to;\n    return skipAtomic(view, pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1), true);\n  });\n};\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/\n\n\nvar deleteToLineStart = function deleteToLineStart(view) {\n  return deleteBy(view, function (pos) {\n    var lineStart = view.lineBlockAt(pos).from;\n    return skipAtomic(view, pos > lineStart ? lineStart : Math.max(0, pos - 1), false);\n  });\n};\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/\n\n\nvar deleteTrailingWhitespace = function deleteTrailingWhitespace(_ref14) {\n  var state = _ref14.state,\n      dispatch = _ref14.dispatch;\n  if (state.readOnly) return false;\n  var changes = [];\n\n  for (var pos = 0, prev = \"\", iter = state.doc.iter();;) {\n    iter.next();\n\n    if (iter.lineBreak || iter.done) {\n      var trailing = prev.search(/\\s+$/);\n      if (trailing > -1) changes.push({\n        from: pos - (prev.length - trailing),\n        to: pos\n      });\n      if (iter.done) break;\n      prev = \"\";\n    } else {\n      prev = iter.value;\n    }\n\n    pos += iter.value.length;\n  }\n\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes: changes,\n    userEvent: \"delete\"\n  }));\n  return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/\n\n\nvar splitLine = function splitLine(_ref15) {\n  var state = _ref15.state,\n      dispatch = _ref15.dispatch;\n  if (state.readOnly) return false;\n  var changes = state.changeByRange(function (range) {\n    return {\n      changes: {\n        from: range.from,\n        to: range.to,\n        insert: _codemirror_text__WEBPACK_IMPORTED_MODULE_5__.Text.of([\"\", \"\"])\n      },\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from)\n    };\n  });\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/\n\n\nvar transposeChars = function transposeChars(_ref16) {\n  var state = _ref16.state,\n      dispatch = _ref16.dispatch;\n  if (state.readOnly) return false;\n  var changes = state.changeByRange(function (range) {\n    if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n      range: range\n    };\n    var pos = range.from,\n        line = state.doc.lineAt(pos);\n    var from = pos == line.from ? pos - 1 : (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_5__.findClusterBreak)(line.text, pos - line.from, false) + line.from;\n    var to = pos == line.to ? pos + 1 : (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_5__.findClusterBreak)(line.text, pos - line.from, true) + line.from;\n    return {\n      changes: {\n        from: from,\n        to: to,\n        insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n      },\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to)\n    };\n  });\n  if (changes.changes.empty) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"move.character\"\n  }));\n  return true;\n};\n\nfunction selectedLineBlocks(state) {\n  var blocks = [],\n      upto = -1;\n\n  var _iterator2 = _createForOfIteratorHelper(state.selection.ranges),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var range = _step2.value;\n      var startLine = state.doc.lineAt(range.from),\n          endLine = state.doc.lineAt(range.to);\n      if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);\n\n      if (upto >= startLine.number) {\n        var prev = blocks[blocks.length - 1];\n        prev.to = endLine.to;\n        prev.ranges.push(range);\n      } else {\n        blocks.push({\n          from: startLine.from,\n          to: endLine.to,\n          ranges: [range]\n        });\n      }\n\n      upto = endLine.number + 1;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return blocks;\n}\n\nfunction moveLine(state, dispatch, forward) {\n  if (state.readOnly) return false;\n  var changes = [],\n      ranges = [];\n\n  var _iterator3 = _createForOfIteratorHelper(selectedLineBlocks(state)),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var block = _step3.value;\n      if (forward ? block.to == state.doc.length : block.from == 0) continue;\n      var nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n      var size = nextLine.length + 1;\n\n      if (forward) {\n        changes.push({\n          from: block.to,\n          to: nextLine.to\n        }, {\n          from: block.from,\n          insert: nextLine.text + state.lineBreak\n        });\n\n        var _iterator4 = _createForOfIteratorHelper(block.ranges),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var r = _step4.value;\n            ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        changes.push({\n          from: nextLine.from,\n          to: block.from\n        }, {\n          from: block.to,\n          insert: state.lineBreak + nextLine.text\n        });\n\n        var _iterator5 = _createForOfIteratorHelper(block.ranges),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _r = _step5.value;\n            ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(_r.anchor - size, _r.head - size));\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes: changes,\n    scrollIntoView: true,\n    selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),\n    userEvent: \"move.line\"\n  }));\n  return true;\n}\n/**\nMove the selected lines up one line.\n*/\n\n\nvar moveLineUp = function moveLineUp(_ref17) {\n  var state = _ref17.state,\n      dispatch = _ref17.dispatch;\n  return moveLine(state, dispatch, false);\n};\n/**\nMove the selected lines down one line.\n*/\n\n\nvar moveLineDown = function moveLineDown(_ref18) {\n  var state = _ref18.state,\n      dispatch = _ref18.dispatch;\n  return moveLine(state, dispatch, true);\n};\n\nfunction copyLine(state, dispatch, forward) {\n  if (state.readOnly) return false;\n  var changes = [];\n\n  var _iterator6 = _createForOfIteratorHelper(selectedLineBlocks(state)),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var block = _step6.value;\n      if (forward) changes.push({\n        from: block.from,\n        insert: state.doc.slice(block.from, block.to) + state.lineBreak\n      });else changes.push({\n        from: block.to,\n        insert: state.lineBreak + state.doc.slice(block.from, block.to)\n      });\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  dispatch(state.update({\n    changes: changes,\n    scrollIntoView: true,\n    userEvent: \"input.copyline\"\n  }));\n  return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/\n\n\nvar copyLineUp = function copyLineUp(_ref19) {\n  var state = _ref19.state,\n      dispatch = _ref19.dispatch;\n  return copyLine(state, dispatch, false);\n};\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/\n\n\nvar copyLineDown = function copyLineDown(_ref20) {\n  var state = _ref20.state,\n      dispatch = _ref20.dispatch;\n  return copyLine(state, dispatch, true);\n};\n/**\nDelete selected lines.\n*/\n\n\nvar deleteLine = function deleteLine(view) {\n  if (view.state.readOnly) return false;\n  var state = view.state,\n      changes = state.changes(selectedLineBlocks(state).map(function (_ref21) {\n    var from = _ref21.from,\n        to = _ref21.to;\n    if (from > 0) from--;else if (to < state.doc.length) to++;\n    return {\n      from: from,\n      to: to\n    };\n  }));\n  var selection = updateSel(state.selection, function (range) {\n    return view.moveVertically(range, true);\n  }).map(changes);\n  view.dispatch({\n    changes: changes,\n    selection: selection,\n    scrollIntoView: true,\n    userEvent: \"delete.line\"\n  });\n  return true;\n};\n/**\nReplace the selection with a newline.\n*/\n\n\nvar insertNewline = function insertNewline(_ref22) {\n  var state = _ref22.state,\n      dispatch = _ref22.dispatch;\n  dispatch(state.update(state.replaceSelection(state.lineBreak), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n\nfunction isBetweenBrackets(state, pos) {\n  if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {\n    from: pos,\n    to: pos\n  };\n  var context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);\n  var before = context.childBefore(pos),\n      after = context.childAfter(pos),\n      closedBy;\n  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from) return {\n    from: before.to,\n    to: after.from\n  };\n  return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/\n\n\nvar insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/\n\nvar insertBlankLine = /*@__PURE__*/newlineAndIndent(true);\n\nfunction newlineAndIndent(atEof) {\n  return function (_ref23) {\n    var state = _ref23.state,\n        dispatch = _ref23.dispatch;\n    if (state.readOnly) return false;\n    var changes = state.changeByRange(function (range) {\n      var from = range.from,\n          to = range.to,\n          line = state.doc.lineAt(from);\n      var explode = !atEof && from == to && isBetweenBrackets(state, from);\n      if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n      var cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n        simulateBreak: from,\n        simulateDoubleBreak: !!explode\n      });\n      var indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);\n      if (indent == null) indent = /^\\s*/.exec(state.doc.lineAt(from).text)[0].length;\n\n      while (to < line.to && /\\s/.test(line.text[to - line.from])) {\n        to++;\n      }\n\n      if (explode) {\n        from = explode.from;\n        to = explode.to;\n      } else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from))) from = line.from;\n\n      var insert = [\"\", (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)];\n      if (explode) insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));\n      return {\n        changes: {\n          from: from,\n          to: to,\n          insert: _codemirror_text__WEBPACK_IMPORTED_MODULE_5__.Text.of(insert)\n        },\n        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length)\n      };\n    });\n    dispatch(state.update(changes, {\n      scrollIntoView: true,\n      userEvent: \"input\"\n    }));\n    return true;\n  };\n}\n\nfunction changeBySelectedLine(state, f) {\n  var atLine = -1;\n  return state.changeByRange(function (range) {\n    var changes = [];\n\n    for (var pos = range.from; pos <= range.to;) {\n      var line = state.doc.lineAt(pos);\n\n      if (line.number > atLine && (range.empty || range.to > line.from)) {\n        f(line, changes, range);\n        atLine = line.number;\n      }\n\n      pos = line.to + 1;\n    }\n\n    var changeSet = state.changes(changes);\n    return {\n      changes: changes,\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n    };\n  });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/\n\n\nvar indentSelection = function indentSelection(_ref24) {\n  var state = _ref24.state,\n      dispatch = _ref24.dispatch;\n  if (state.readOnly) return false;\n  var updated = Object.create(null);\n  var context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n    overrideIndentation: function overrideIndentation(start) {\n      var found = updated[start];\n      return found == null ? -1 : found;\n    }\n  });\n  var changes = changeBySelectedLine(state, function (line, changes, range) {\n    var indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);\n    if (indent == null) return;\n    if (!/\\S/.test(line.text)) indent = 0;\n    var cur = /^\\s*/.exec(line.text)[0];\n    var norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);\n\n    if (cur != norm || range.from < line.from + cur.length) {\n      updated[line.from] = indent;\n      changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n  });\n  if (!changes.changes.empty) dispatch(state.update(changes, {\n    userEvent: \"indent\"\n  }));\n  return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/\n\n\nvar indentMore = function indentMore(_ref25) {\n  var state = _ref25.state,\n      dispatch = _ref25.dispatch;\n  if (state.readOnly) return false;\n  dispatch(state.update(changeBySelectedLine(state, function (line, changes) {\n    changes.push({\n      from: line.from,\n      insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit)\n    });\n  }), {\n    userEvent: \"input.indent\"\n  }));\n  return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/\n\n\nvar indentLess = function indentLess(_ref26) {\n  var state = _ref26.state,\n      dispatch = _ref26.dispatch;\n  if (state.readOnly) return false;\n  dispatch(state.update(changeBySelectedLine(state, function (line, changes) {\n    var space = /^\\s*/.exec(line.text)[0];\n    if (!space) return;\n    var col = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_5__.countColumn)(space, state.tabSize),\n        keep = 0;\n    var insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));\n\n    while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep)) {\n      keep++;\n    }\n\n    changes.push({\n      from: line.from + keep,\n      to: line.from + space.length,\n      insert: insert.slice(keep)\n    });\n  }), {\n    userEvent: \"delete.dedent\"\n  }));\n  return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/\n\n\nvar insertTab = function insertTab(_ref27) {\n  var state = _ref27.state,\n      dispatch = _ref27.dispatch;\n  if (state.selection.ranges.some(function (r) {\n    return !r.empty;\n  })) return indentMore({\n    state: state,\n    dispatch: dispatch\n  });\n  dispatch(state.update(state.replaceSelection(\"\\t\"), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/\n\n\nvar emacsStyleKeymap = [{\n  key: \"Ctrl-b\",\n  run: cursorCharLeft,\n  shift: selectCharLeft,\n  preventDefault: true\n}, {\n  key: \"Ctrl-f\",\n  run: cursorCharRight,\n  shift: selectCharRight\n}, {\n  key: \"Ctrl-p\",\n  run: cursorLineUp,\n  shift: selectLineUp\n}, {\n  key: \"Ctrl-n\",\n  run: cursorLineDown,\n  shift: selectLineDown\n}, {\n  key: \"Ctrl-a\",\n  run: cursorLineStart,\n  shift: selectLineStart\n}, {\n  key: \"Ctrl-e\",\n  run: cursorLineEnd,\n  shift: selectLineEnd\n}, {\n  key: \"Ctrl-d\",\n  run: deleteCharForward\n}, {\n  key: \"Ctrl-h\",\n  run: deleteCharBackward\n}, {\n  key: \"Ctrl-k\",\n  run: deleteToLineEnd\n}, {\n  key: \"Ctrl-Alt-h\",\n  run: deleteGroupBackward\n}, {\n  key: \"Ctrl-o\",\n  run: splitLine\n}, {\n  key: \"Ctrl-t\",\n  run: transposeChars\n}, {\n  key: \"Ctrl-v\",\n  run: cursorPageDown\n}];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteToLineStart`](https://codemirror.net/6/docs/ref/#commands.deleteToLineStart).\n - Cmd-Delete (macOS): [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd).\n*/\n\nvar standardKeymap = /*@__PURE__*/[{\n  key: \"ArrowLeft\",\n  run: cursorCharLeft,\n  shift: selectCharLeft,\n  preventDefault: true\n}, {\n  key: \"Mod-ArrowLeft\",\n  mac: \"Alt-ArrowLeft\",\n  run: cursorGroupLeft,\n  shift: selectGroupLeft\n}, {\n  mac: \"Cmd-ArrowLeft\",\n  run: cursorLineBoundaryBackward,\n  shift: selectLineBoundaryBackward\n}, {\n  key: \"ArrowRight\",\n  run: cursorCharRight,\n  shift: selectCharRight,\n  preventDefault: true\n}, {\n  key: \"Mod-ArrowRight\",\n  mac: \"Alt-ArrowRight\",\n  run: cursorGroupRight,\n  shift: selectGroupRight\n}, {\n  mac: \"Cmd-ArrowRight\",\n  run: cursorLineBoundaryForward,\n  shift: selectLineBoundaryForward\n}, {\n  key: \"ArrowUp\",\n  run: cursorLineUp,\n  shift: selectLineUp,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowUp\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  mac: \"Ctrl-ArrowUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"ArrowDown\",\n  run: cursorLineDown,\n  shift: selectLineDown,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowDown\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  mac: \"Ctrl-ArrowDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"PageUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"PageDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"Home\",\n  run: cursorLineBoundaryBackward,\n  shift: selectLineBoundaryBackward\n}, {\n  key: \"Mod-Home\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  key: \"End\",\n  run: cursorLineBoundaryForward,\n  shift: selectLineBoundaryForward\n}, {\n  key: \"Mod-End\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  key: \"Enter\",\n  run: insertNewlineAndIndent\n}, {\n  key: \"Mod-a\",\n  run: selectAll\n}, {\n  key: \"Backspace\",\n  run: deleteCharBackward,\n  shift: deleteCharBackward\n}, {\n  key: \"Delete\",\n  run: deleteCharForward\n}, {\n  key: \"Mod-Backspace\",\n  mac: \"Alt-Backspace\",\n  run: deleteGroupBackward\n}, {\n  key: \"Mod-Delete\",\n  mac: \"Alt-Delete\",\n  run: deleteGroupForward\n}, {\n  mac: \"Mod-Backspace\",\n  run: deleteToLineStart\n}, {\n  mac: \"Mod-Delete\",\n  run: deleteToLineEnd\n}].concat( /*@__PURE__*/emacsStyleKeymap.map(function (b) {\n  return {\n    mac: b.key,\n    run: b.run,\n    shift: b.shift\n  };\n}));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Comd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n*/\n\nvar defaultKeymap = /*@__PURE__*/[{\n  key: \"Alt-ArrowLeft\",\n  mac: \"Ctrl-ArrowLeft\",\n  run: cursorSyntaxLeft,\n  shift: selectSyntaxLeft\n}, {\n  key: \"Alt-ArrowRight\",\n  mac: \"Ctrl-ArrowRight\",\n  run: cursorSyntaxRight,\n  shift: selectSyntaxRight\n}, {\n  key: \"Alt-ArrowUp\",\n  run: moveLineUp\n}, {\n  key: \"Shift-Alt-ArrowUp\",\n  run: copyLineUp\n}, {\n  key: \"Alt-ArrowDown\",\n  run: moveLineDown\n}, {\n  key: \"Shift-Alt-ArrowDown\",\n  run: copyLineDown\n}, {\n  key: \"Escape\",\n  run: simplifySelection\n}, {\n  key: \"Mod-Enter\",\n  run: insertBlankLine\n}, {\n  key: \"Alt-l\",\n  mac: \"Ctrl-l\",\n  run: selectLine\n}, {\n  key: \"Mod-i\",\n  run: selectParentSyntax,\n  preventDefault: true\n}, {\n  key: \"Mod-[\",\n  run: indentLess\n}, {\n  key: \"Mod-]\",\n  run: indentMore\n}, {\n  key: \"Mod-Alt-\\\\\",\n  run: indentSelection\n}, {\n  key: \"Shift-Mod-k\",\n  run: deleteLine\n}, {\n  key: \"Shift-Mod-\\\\\",\n  run: cursorMatchingBracket\n}].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/\n\nvar indentWithTab = {\n  key: \"Tab\",\n  run: indentMore,\n  shift: indentLess\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBR0E7QUFIQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFKQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUVBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBakJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBbkJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQWZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBZ0JBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQUE7O0FBSEE7QUFBQTs7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQW5CQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQW9CQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBOztBQUhBO0FBQUE7O0FBQUE7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQVRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBVUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUFBO0FBREE7O0FBSUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcz8yZjgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVkaXRvclNlbGVjdGlvbiwgQ2hhckNhdGVnb3J5IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgVGV4dCwgZmluZENsdXN0ZXJCcmVhaywgY291bnRDb2x1bW4gfSBmcm9tICdAY29kZW1pcnJvci90ZXh0JztcbmltcG9ydCB7IERpcmVjdGlvbiwgRWRpdG9yVmlldywgUGx1Z2luRmllbGQgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IG1hdGNoQnJhY2tldHMgfSBmcm9tICdAY29kZW1pcnJvci9tYXRjaGJyYWNrZXRzJztcbmltcG9ydCB7IEluZGVudENvbnRleHQsIGdldEluZGVudGF0aW9uLCBpbmRlbnRTdHJpbmcsIGluZGVudFVuaXQsIGdldEluZGVudFVuaXQsIHN5bnRheFRyZWUgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBOb2RlUHJvcCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG5mdW5jdGlvbiB1cGRhdGVTZWwoc2VsLCBieSkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbC5yYW5nZXMubWFwKGJ5KSwgc2VsLm1haW5JbmRleCk7XG59XG5mdW5jdGlvbiBzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSk7XG59XG5mdW5jdGlvbiBtb3ZlU2VsKHsgc3RhdGUsIGRpc3BhdGNoIH0sIGhvdykge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCBob3cpO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyByYW5nZS50byA6IHJhbmdlLmZyb20pO1xufVxuZnVuY3Rpb24gY3Vyc29yQnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciB0byB0aGUgbGVmdCAod2hpY2ggaXMgYmFja3dhcmQgaW5cbmxlZnQtdG8tcmlnaHQgdGV4dCwgZm9yd2FyZCBpbiByaWdodC10by1sZWZ0IHRleHQpLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJMZWZ0ID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgdmlldy50ZXh0RGlyZWN0aW9uICE9IERpcmVjdGlvbi5MVFIpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhclJpZ2h0ID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGN1cnNvckJ5R3JvdXAodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlHcm91cChyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGxlZnQgYWNyb3NzIG9uZSBncm91cCBvZiB3b3JkIG9yXG5ub24td29yZCAoYnV0IGFsc28gbm9uLXNwYWNlKSBjaGFyYWN0ZXJzLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCB2aWV3LnRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUik7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwUmlnaHQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkge1xuICAgIGxldCBjYXRlZ29yaXplID0gdmlldy5zdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuZnJvbSk7XG4gICAgcmV0dXJuIHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCwgc3RhcnQgPT4ge1xuICAgICAgICBsZXQgY2F0ID0gQ2hhckNhdGVnb3J5LlNwYWNlLCBwb3MgPSByYW5nZS5mcm9tO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlLCBzYXdVcHBlciA9IGZhbHNlLCBzYXdMb3dlciA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RlcCA9IChuZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBwb3MgKz0gZm9yd2FyZCA/IG5leHQubGVuZ3RoIDogLW5leHQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpLCBhaGVhZDtcbiAgICAgICAgICAgIGlmIChjYXQgPT0gQ2hhckNhdGVnb3J5LlNwYWNlKVxuICAgICAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgICAgICBpZiAoY2F0ICE9IG5leHRDYXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvTG93ZXJDYXNlKCkgPT0gbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvcndhcmQgJiYgc2F3VXBwZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNhd0xvd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2F3TG93ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhd1VwcGVyICYmIGZvcndhcmQgJiYgY2F0ZWdvcml6ZShhaGVhZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKSkgPT0gQ2hhckNhdGVnb3J5LldvcmQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFoZWFkLnRvTG93ZXJDYXNlKCkgPT0gYWhlYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNhd1VwcGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgc3RlcChzdGFydCk7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBvciBjYW1lbC1jYXNlIHN1YndvcmQgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JTdWJ3b3JkRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5U3Vid29yZCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5vZGUsIGJyYWNrZXRQcm9wKSB7XG4gICAgaWYgKG5vZGUudHlwZS5wcm9wKGJyYWNrZXRQcm9wKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGxlbiA9IG5vZGUudG8gLSBub2RlLmZyb207XG4gICAgcmV0dXJuIGxlbiAmJiAobGVuID4gMiB8fCAvW15cXHMsLjs6XS8udGVzdChzdGF0ZS5zbGljZURvYyhub2RlLmZyb20sIG5vZGUudG8pKSkgfHwgbm9kZS5maXJzdENoaWxkO1xufVxuZnVuY3Rpb24gbW92ZUJ5U3ludGF4KHN0YXRlLCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBwb3MgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIoc3RhcnQuaGVhZCk7XG4gICAgbGV0IGJyYWNrZXRQcm9wID0gZm9yd2FyZCA/IE5vZGVQcm9wLmNsb3NlZEJ5IDogTm9kZVByb3Aub3BlbmVkQnk7XG4gICAgLy8gU2NhbiBmb3J3YXJkIHRocm91Z2ggY2hpbGQgbm9kZXMgdG8gc2VlIGlmIHRoZXJlJ3MgYW4gaW50ZXJlc3RpbmdcbiAgICAvLyBub2RlIGFoZWFkLlxuICAgIGZvciAobGV0IGF0ID0gc3RhcnQuaGVhZDs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gZm9yd2FyZCA/IHBvcy5jaGlsZEFmdGVyKGF0KSA6IHBvcy5jaGlsZEJlZm9yZShhdCk7XG4gICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoaW50ZXJlc3RpbmdOb2RlKHN0YXRlLCBuZXh0LCBicmFja2V0UHJvcCkpXG4gICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhdCA9IGZvcndhcmQgPyBuZXh0LnRvIDogbmV4dC5mcm9tO1xuICAgIH1cbiAgICBsZXQgYnJhY2tldCA9IHBvcy50eXBlLnByb3AoYnJhY2tldFByb3ApLCBtYXRjaCwgbmV3UG9zO1xuICAgIGlmIChicmFja2V0ICYmIChtYXRjaCA9IGZvcndhcmQgPyBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MuZnJvbSwgMSkgOiBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MudG8sIC0xKSkgJiYgbWF0Y2gubWF0Y2hlZClcbiAgICAgICAgbmV3UG9zID0gZm9yd2FyZCA/IG1hdGNoLmVuZC50byA6IG1hdGNoLmVuZC5mcm9tO1xuICAgIGVsc2VcbiAgICAgICAgbmV3UG9zID0gZm9yd2FyZCA/IHBvcy50byA6IHBvcy5mcm9tO1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5ld1BvcywgZm9yd2FyZCA/IC0xIDogMSk7XG59XG4vKipcbk1vdmUgdGhlIGN1cnNvciBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IGN1cnNvclN5bnRheExlZnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCB2aWV3LnRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUikpO1xuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4UmlnaHQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUikpO1xuZnVuY3Rpb24gY3Vyc29yQnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgICAgICBsZXQgbW92ZWQgPSB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgICAgcmV0dXJuIG1vdmVkLmhlYWQgIT0gcmFuZ2UuaGVhZCA/IG1vdmVkIDogdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgdXAuXG4qL1xuY29uc3QgY3Vyc29yTGluZVVwID0gdmlldyA9PiBjdXJzb3JCeUxpbmUodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBjdXJzb3JMaW5lRG93biA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gY3Vyc29yQnlQYWdlKHZpZXcsIGZvcndhcmQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCB2aWV3LmRvbS5jbGllbnRIZWlnaHQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzdGFydFBvcyA9IHZpZXcuY29vcmRzQXRQb3Moc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgbGV0IHNjcm9sbFJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSwge1xuICAgICAgICBlZmZlY3RzOiBzdGFydFBvcyAmJiBzdGFydFBvcy50b3AgPiBzY3JvbGxSZWN0LnRvcCAmJiBzdGFydFBvcy5ib3R0b20gPCBzY3JvbGxSZWN0LmJvdHRvbVxuICAgICAgICAgICAgPyBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHNlbGVjdGlvbi5tYWluLmhlYWQsIHsgeTogXCJzdGFydFwiLCB5TWFyZ2luOiBzdGFydFBvcy50b3AgLSBzY3JvbGxSZWN0LnRvcCB9KVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IGN1cnNvclBhZ2VVcCA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yUGFnZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5UGFnZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChzdGFydC5oZWFkKSwgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCk7XG4gICAgaWYgKG1vdmVkLmhlYWQgPT0gc3RhcnQuaGVhZCAmJiBtb3ZlZC5oZWFkICE9IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpXG4gICAgICAgIG1vdmVkID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGZhbHNlKTtcbiAgICBpZiAoIWZvcndhcmQgJiYgbW92ZWQuaGVhZCA9PSBsaW5lLmZyb20gJiYgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKHZpZXcuc3RhdGUuc2xpY2VEb2MobGluZS5mcm9tLCBNYXRoLm1pbihsaW5lLmZyb20gKyAxMDAsIGxpbmUudG8pKSlbMF0ubGVuZ3RoO1xuICAgICAgICBpZiAoc3BhY2UgJiYgc3RhcnQuaGVhZCAhPSBsaW5lLmZyb20gKyBzcGFjZSlcbiAgICAgICAgICAgIG1vdmVkID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLmZyb20gKyBzcGFjZSk7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlZDtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGxpbmUgd3JhcCBwb2ludCwgb3IgdG8gdGhlIGVuZCBvZlxudGhlIGxpbmUgaWYgdGhlcmUgaXNuJ3Qgb25lIGxlZnQgb24gdGhpcyBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byBwcmV2aW91cyBsaW5lIHdyYXAgcG9pbnQsIG9yIGZhaWxpbmcgdGhhdCB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBJZiB0aGUgbGluZSBpcyBpbmRlbnRlZCwgYW5kIHRoZSBjdXJzb3Jcbmlzbid0IGFscmVhZHkgYXQgdGhlIGVuZCBvZiB0aGUgaW5kZW50YXRpb24sIHRoaXMgd2lsbCBtb3ZlIHRvIHRoZVxuZW5kIG9mIHRoZSBpbmRlbnRhdGlvbiBpbnN0ZWFkIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZVN0YXJ0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tLCAxKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVFbmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLnRvLCAtMSkpO1xuZnVuY3Rpb24gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUsIGRpc3BhdGNoLCBleHRlbmQpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZSwgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hpbmcgPSBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkLCAtMSlcbiAgICAgICAgICAgIHx8IG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQsIDEpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA+IDAgJiYgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCAtIDEsIDEpKVxuICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPCBzdGF0ZS5kb2MubGVuZ3RoICYmIG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQgKyAxLCAtMSkpO1xuICAgICAgICBpZiAoIW1hdGNoaW5nIHx8ICFtYXRjaGluZy5lbmQpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhlYWQgPSBtYXRjaGluZy5zdGFydC5mcm9tID09IHJhbmdlLmhlYWQgPyBtYXRjaGluZy5lbmQudG8gOiBtYXRjaGluZy5lbmQuZnJvbTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IsIGhlYWQpIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkKTtcbiAgICB9KTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBicmFja2V0IG1hdGNoaW5nIHRoZSBvbmUgaXQgaXMgY3VycmVudGx5XG5vbiwgaWYgYW55LlxuKi9cbmNvbnN0IGN1cnNvck1hdGNoaW5nQnJhY2tldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuRXh0ZW5kIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSB0aGUgc2VsZWN0aW9uXG5oZWFkIGlzIGN1cnJlbnRseSBvbiwgaWYgYW55LlxuKi9cbmNvbnN0IHNlbGVjdE1hdGNoaW5nQnJhY2tldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuZnVuY3Rpb24gZXh0ZW5kU2VsKHZpZXcsIGhvdykge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwodmlldy5zdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGhlYWQgPSBob3cocmFuZ2UpO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZC5oZWFkLCBoZWFkLmdvYWxDb2x1bW4pO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaChzZXRTZWwodmlldy5zdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzZWxlY3RCeUNoYXIodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQsIHdoaWxlIGxlYXZpbmdcbnRoZSBhbmNob3IgaW4gcGxhY2UuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckxlZnQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCB2aWV3LnRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUik7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdENoYXJSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gc2VsZWN0QnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUdyb3VwKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBbZ3JvdXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSB0b1xudGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIHZpZXcudGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RHcm91cFJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBzZWxlY3RCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5U3Vid29yZCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIHN1YndvcmQgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdFN5bnRheExlZnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsIHZpZXcudGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdFN5bnRheFJpZ2h0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUikpO1xuZnVuY3Rpb24gc2VsZWN0QnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgdXAuXG4qL1xuY29uc3Qgc2VsZWN0TGluZVVwID0gdmlldyA9PiBzZWxlY3RCeUxpbmUodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSBkb3duLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVEb3duID0gdmlldyA9PiBzZWxlY3RCeUxpbmUodmlldywgdHJ1ZSk7XG5mdW5jdGlvbiBzZWxlY3RCeVBhZ2UodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCwgdmlldy5kb20uY2xpZW50SGVpZ2h0KSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IHNlbGVjdFBhZ2VVcCA9IHZpZXcgPT4gc2VsZWN0QnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIHBhZ2UgZG93bi5cbiovXG5jb25zdCBzZWxlY3RQYWdlRG93biA9IHZpZXcgPT4gc2VsZWN0QnlQYWdlKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIHRydWUpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHByZXZpb3VzIGxpbmUgYm91bmRhcnkuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBzZWxlY3RMaW5lU3RhcnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkuZnJvbSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVFbmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG8pKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3QgY3Vyc29yRG9jU3RhcnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IDAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IGN1cnNvckRvY0VuZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdERvY1N0YXJ0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IsIGhlYWQ6IDAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0RG9jRW5kID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IsIGhlYWQ6IHN0YXRlLmRvYy5sZW5ndGggfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSBlbnRpcmUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0QWxsID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IHsgYW5jaG9yOiAwLCBoZWFkOiBzdGF0ZS5kb2MubGVuZ3RoIH0sIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5FeHBhbmQgdGhlIHNlbGVjdGlvbiB0byBjb3ZlciBlbnRpcmUgbGluZXMuXG4qL1xuY29uc3Qgc2VsZWN0TGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHJhbmdlcyA9IHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkubWFwKCh7IGZyb20sIHRvIH0pID0+IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCBNYXRoLm1pbih0byArIDEsIHN0YXRlLmRvYy5sZW5ndGgpKSk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcyksIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIG5leHQgc3ludGFjdGljIGNvbnN0cnVjdCB0aGF0IGlzIGxhcmdlciB0aGFuIHRoZVxuc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG9ubHkgd29yayBpbnNvZmFyIGFzIHRoZSBsYW5ndWFnZVxuW3Byb3ZpZGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlKSB5b3UgdXNlIGJ1aWxkcyB1cCBhIGZ1bGxcbnN5bnRheCB0cmVlLlxuKi9cbmNvbnN0IHNlbGVjdFBhcmVudFN5bnRheCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY29udGV4dCA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihyYW5nZS5oZWFkLCAxKTtcbiAgICAgICAgd2hpbGUgKCEoKGNvbnRleHQuZnJvbSA8IHJhbmdlLmZyb20gJiYgY29udGV4dC50byA+PSByYW5nZS50bykgfHxcbiAgICAgICAgICAgIChjb250ZXh0LnRvID4gcmFuZ2UudG8gJiYgY29udGV4dC5mcm9tIDw9IHJhbmdlLmZyb20pIHx8XG4gICAgICAgICAgICAhKChfYSA9IGNvbnRleHQucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50KSkpXG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY29udGV4dC50bywgY29udGV4dC5mcm9tKTtcbiAgICB9KTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2ltcGxpZnkgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBXaGVuIG11bHRpcGxlIHJhbmdlcyBhcmUgc2VsZWN0ZWQsXG5yZWR1Y2UgaXQgdG8gaXRzIG1haW4gcmFuZ2UuIE90aGVyd2lzZSwgaWYgdGhlIHNlbGVjdGlvbiBpc1xubm9uLWVtcHR5LCBjb252ZXJ0IGl0IHRvIGEgY3Vyc29yIHNlbGVjdGlvbi5cbiovXG5jb25zdCBzaW1wbGlmeVNlbGVjdGlvbiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGN1ciA9IHN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0aW9uID0gbnVsbDtcbiAgICBpZiAoY3VyLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtjdXIubWFpbl0pO1xuICAgIGVsc2UgaWYgKCFjdXIubWFpbi5lbXB0eSlcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihjdXIubWFpbi5oZWFkKV0pO1xuICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWxldGVCeSh7IHN0YXRlLCBkaXNwYXRjaCB9LCBieSkge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBldmVudCA9IFwiZGVsZXRlLnNlbGVjdGlvblwiO1xuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pIHtcbiAgICAgICAgICAgIGxldCB0b3dhcmRzID0gYnkoZnJvbSk7XG4gICAgICAgICAgICBpZiAodG93YXJkcyA8IGZyb20pXG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImRlbGV0ZS5iYWNrd2FyZFwiO1xuICAgICAgICAgICAgZWxzZSBpZiAodG93YXJkcyA+IGZyb20pXG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImRlbGV0ZS5mb3J3YXJkXCI7XG4gICAgICAgICAgICBmcm9tID0gTWF0aC5taW4oZnJvbSwgdG93YXJkcyk7XG4gICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCB0b3dhcmRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbSA9PSB0byA/IHsgcmFuZ2UgfSA6IHsgY2hhbmdlczogeyBmcm9tLCB0byB9LCByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBldmVudCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBza2lwQXRvbWljKHRhcmdldCwgcG9zLCBmb3J3YXJkKSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEVkaXRvclZpZXcpXG4gICAgICAgIGZvciAobGV0IHJhbmdlcyBvZiB0YXJnZXQucGx1Z2luRmllbGQoUGx1Z2luRmllbGQuYXRvbWljUmFuZ2VzKSlcbiAgICAgICAgICAgIHJhbmdlcy5iZXR3ZWVuKHBvcywgcG9zLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHBvcyAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZm9yd2FyZCA/IHRvIDogZnJvbTtcbiAgICAgICAgICAgIH0pO1xuICAgIHJldHVybiBwb3M7XG59XG5jb25zdCBkZWxldGVCeUNoYXIgPSAodGFyZ2V0LCBmb3J3YXJkKSA9PiBkZWxldGVCeSh0YXJnZXQsIHBvcyA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgYmVmb3JlLCB0YXJnZXRQb3M7XG4gICAgaWYgKCFmb3J3YXJkICYmIHBvcyA+IGxpbmUuZnJvbSAmJiBwb3MgPCBsaW5lLmZyb20gKyAyMDAgJiZcbiAgICAgICAgIS9bXiBcXHRdLy50ZXN0KGJlZm9yZSA9IGxpbmUudGV4dC5zbGljZSgwLCBwb3MgLSBsaW5lLmZyb20pKSkge1xuICAgICAgICBpZiAoYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxXSA9PSBcIlxcdFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBvcyAtIDE7XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihiZWZvcmUsIHN0YXRlLnRhYlNpemUpLCBkcm9wID0gY29sICUgZ2V0SW5kZW50VW5pdChzdGF0ZSkgfHwgZ2V0SW5kZW50VW5pdChzdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJvcCAmJiBiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDEgLSBpXSA9PSBcIiBcIjsgaSsrKVxuICAgICAgICAgICAgcG9zLS07XG4gICAgICAgIHRhcmdldFBvcyA9IHBvcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldFBvcyA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQsIGZvcndhcmQpICsgbGluZS5mcm9tO1xuICAgICAgICBpZiAodGFyZ2V0UG9zID09IHBvcyAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgdGFyZ2V0UG9zICs9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiBza2lwQXRvbWljKHRhcmdldCwgdGFyZ2V0UG9zLCBmb3J3YXJkKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGZvciBjdXJzb3Igc2VsZWN0aW9ucywgdGhlIGNoYXJhY3RlclxuYmVmb3JlIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlQ2hhckJhY2t3YXJkID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgZmFsc2UpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlQ2hhckZvcndhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5Q2hhcih2aWV3LCB0cnVlKTtcbmNvbnN0IGRlbGV0ZUJ5R3JvdXAgPSAodGFyZ2V0LCBmb3J3YXJkKSA9PiBkZWxldGVCeSh0YXJnZXQsIHN0YXJ0ID0+IHtcbiAgICBsZXQgcG9zID0gc3RhcnQsIHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGZvciAobGV0IGNhdCA9IG51bGw7Oykge1xuICAgICAgICBpZiAocG9zID09IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gc3RhcnQgJiYgbGluZS5udW1iZXIgIT0gKGZvcndhcmQgPyBzdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgICAgICBwb3MgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZm9yd2FyZCkgKyBsaW5lLmZyb207XG4gICAgICAgIGxldCBuZXh0Q2hhciA9IGxpbmUudGV4dC5zbGljZShNYXRoLm1pbihwb3MsIG5leHQpIC0gbGluZS5mcm9tLCBNYXRoLm1heChwb3MsIG5leHQpIC0gbGluZS5mcm9tKTtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHRDaGFyKTtcbiAgICAgICAgaWYgKGNhdCAhPSBudWxsICYmIG5leHRDYXQgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0Q2hhciAhPSBcIiBcIiB8fCBwb3MgIT0gc3RhcnQpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICBwb3MgPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gc2tpcEF0b21pYyh0YXJnZXQsIHBvcywgZm9yd2FyZCk7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgYmFja3dhcmQgdW50aWwgdGhlIGVuZCBvZiB0aGUgbmV4dFxuW2dyb3VwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlQnlHcm91cCksIG9ubHkgc2tpcHBpbmcgZ3JvdXBzIG9mXG53aGl0ZXNwYWNlIHdoZW4gdGhleSBjb25zaXN0IG9mIGEgc2luZ2xlIHNwYWNlLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwQmFja3dhcmQgPSB0YXJnZXQgPT4gZGVsZXRlQnlHcm91cCh0YXJnZXQsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgZm9yd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0IGdyb3VwLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwRm9yd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBlbmQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIGVuZCBvZiB0aGVcbmxpbmUsIGRlbGV0ZSB0aGUgbGluZSBicmVhayBhZnRlciBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVFbmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHBvcyA9PiB7XG4gICAgbGV0IGxpbmVFbmQgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcykudG87XG4gICAgcmV0dXJuIHNraXBBdG9taWModmlldywgcG9zIDwgbGluZUVuZCA/IGxpbmVFbmQgOiBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIHBvcyArIDEpLCB0cnVlKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIHRoZVxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGJlZm9yZSBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVTdGFydCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcG9zID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5saW5lQmxvY2tBdChwb3MpLmZyb207XG4gICAgcmV0dXJuIHNraXBBdG9taWModmlldywgcG9zID4gbGluZVN0YXJ0ID8gbGluZVN0YXJ0IDogTWF0aC5tYXgoMCwgcG9zIC0gMSksIGZhbHNlKTtcbn0pO1xuLyoqXG5EZWxldGUgYWxsIHdoaXRlc3BhY2UgZGlyZWN0bHkgYmVmb3JlIGEgbGluZSBlbmQgZnJvbSB0aGVcbmRvY3VtZW50LlxuKi9cbmNvbnN0IGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBwcmV2ID0gXCJcIiwgaXRlciA9IHN0YXRlLmRvYy5pdGVyKCk7Oykge1xuICAgICAgICBpdGVyLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXIubGluZUJyZWFrIHx8IGl0ZXIuZG9uZSkge1xuICAgICAgICAgICAgbGV0IHRyYWlsaW5nID0gcHJldi5zZWFyY2goL1xccyskLyk7XG4gICAgICAgICAgICBpZiAodHJhaWxpbmcgPiAtMSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBwb3MgLSAocHJldi5sZW5ndGggLSB0cmFpbGluZyksIHRvOiBwb3MgfSk7XG4gICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcHJldiA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmV2ID0gaXRlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gaXRlci52YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCB1c2VyRXZlbnQ6IFwiZGVsZXRlXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSBlYWNoIHNlbGVjdGlvbiByYW5nZSB3aXRoIGEgbGluZSBicmVhaywgbGVhdmluZyB0aGUgY3Vyc29yXG5vbiB0aGUgbGluZSBiZWZvcmUgdGhlIGJyZWFrLlxuKi9cbmNvbnN0IHNwbGl0TGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogVGV4dC5vZihbXCJcIiwgXCJcIl0pIH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tKSB9O1xuICAgIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5GbGlwIHRoZSBjaGFyYWN0ZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGN1cnNvcihzKS5cbiovXG5jb25zdCB0cmFuc3Bvc2VDaGFycyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSB8fCByYW5nZS5mcm9tID09IDAgfHwgcmFuZ2UuZnJvbSA9PSBzdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgbGV0IHBvcyA9IHJhbmdlLmZyb20sIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBmcm9tID0gcG9zID09IGxpbmUuZnJvbSA/IHBvcyAtIDEgOiBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmYWxzZSkgKyBsaW5lLmZyb207XG4gICAgICAgIGxldCB0byA9IHBvcyA9PSBsaW5lLnRvID8gcG9zICsgMSA6IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIHRydWUpICsgbGluZS5mcm9tO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IHN0YXRlLmRvYy5zbGljZShwb3MsIHRvKS5hcHBlbmQoc3RhdGUuZG9jLnNsaWNlKGZyb20sIHBvcykpIH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0bykgfTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJtb3ZlLmNoYXJhY3RlclwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpIHtcbiAgICBsZXQgYmxvY2tzID0gW10sIHVwdG8gPSAtMTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBzdGFydExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLCBlbmRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50byk7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgJiYgcmFuZ2UudG8gPT0gZW5kTGluZS5mcm9tKVxuICAgICAgICAgICAgZW5kTGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8gLSAxKTtcbiAgICAgICAgaWYgKHVwdG8gPj0gc3RhcnRMaW5lLm51bWJlcikge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBibG9ja3NbYmxvY2tzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcHJldi50byA9IGVuZExpbmUudG87XG4gICAgICAgICAgICBwcmV2LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHsgZnJvbTogc3RhcnRMaW5lLmZyb20sIHRvOiBlbmRMaW5lLnRvLCByYW5nZXM6IFtyYW5nZV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXB0byA9IGVuZExpbmUubnVtYmVyICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2Nrcztcbn1cbmZ1bmN0aW9uIG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZm9yd2FyZCkge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW10sIHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGJsb2NrIG9mIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkpIHtcbiAgICAgICAgaWYgKGZvcndhcmQgPyBibG9jay50byA9PSBzdGF0ZS5kb2MubGVuZ3RoIDogYmxvY2suZnJvbSA9PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBuZXh0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZm9yd2FyZCA/IGJsb2NrLnRvICsgMSA6IGJsb2NrLmZyb20gLSAxKTtcbiAgICAgICAgbGV0IHNpemUgPSBuZXh0TGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2sudG8sIHRvOiBuZXh0TGluZS50byB9LCB7IGZyb206IGJsb2NrLmZyb20sIGluc2VydDogbmV4dExpbmUudGV4dCArIHN0YXRlLmxpbmVCcmVhayB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgYmxvY2sucmFuZ2VzKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCByLmFuY2hvciArIHNpemUpLCBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCByLmhlYWQgKyBzaXplKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbmV4dExpbmUuZnJvbSwgdG86IGJsb2NrLmZyb20gfSwgeyBmcm9tOiBibG9jay50bywgaW5zZXJ0OiBzdGF0ZS5saW5lQnJlYWsgKyBuZXh0TGluZS50ZXh0IH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiBibG9jay5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuYW5jaG9yIC0gc2l6ZSwgci5oZWFkIC0gc2l6ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc3RhdGUuc2VsZWN0aW9uLm1haW5JbmRleCksXG4gICAgICAgIHVzZXJFdmVudDogXCJtb3ZlLmxpbmVcIlxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0ZWQgbGluZXMgdXAgb25lIGxpbmUuXG4qL1xuY29uc3QgbW92ZUxpbmVVcCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0ZWQgbGluZXMgZG93biBvbmUgbGluZS5cbiovXG5jb25zdCBtb3ZlTGluZURvd24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbmZ1bmN0aW9uIGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZm9yd2FyZCkge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgYmxvY2sgb2Ygc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSkge1xuICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLmZyb20sIGluc2VydDogc3RhdGUuZG9jLnNsaWNlKGJsb2NrLmZyb20sIGJsb2NrLnRvKSArIHN0YXRlLmxpbmVCcmVhayB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2sudG8sIGluc2VydDogc3RhdGUubGluZUJyZWFrICsgc3RhdGUuZG9jLnNsaWNlKGJsb2NrLmZyb20sIGJsb2NrLnRvKSB9KTtcbiAgICB9XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgY2hhbmdlcywgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dC5jb3B5bGluZVwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgdG9wIGNvcHkuXG4qL1xuY29uc3QgY29weUxpbmVVcCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgYm90dG9tIGNvcHkuXG4qL1xuY29uc3QgY29weUxpbmVEb3duID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSBzZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCBkZWxldGVMaW5lID0gdmlldyA9PiB7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZXMoc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBmcm9tLS07XG4gICAgICAgIGVsc2UgaWYgKHRvIDwgc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHRvKys7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvIH07XG4gICAgfSkpO1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCB0cnVlKSkubWFwKGNoYW5nZXMpO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBjaGFuZ2VzLCBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlLmxpbmVcIiB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZS5cbiovXG5jb25zdCBpbnNlcnROZXdsaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihzdGF0ZS5saW5lQnJlYWspLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIHBvcykge1xuICAgIGlmICgvXFwoXFwpfFxcW1xcXXxcXHtcXH0vLnRlc3Qoc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zICsgMSkpKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MgfTtcbiAgICBsZXQgY29udGV4dCA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MpO1xuICAgIGxldCBiZWZvcmUgPSBjb250ZXh0LmNoaWxkQmVmb3JlKHBvcyksIGFmdGVyID0gY29udGV4dC5jaGlsZEFmdGVyKHBvcyksIGNsb3NlZEJ5O1xuICAgIGlmIChiZWZvcmUgJiYgYWZ0ZXIgJiYgYmVmb3JlLnRvIDw9IHBvcyAmJiBhZnRlci5mcm9tID49IHBvcyAmJlxuICAgICAgICAoY2xvc2VkQnkgPSBiZWZvcmUudHlwZS5wcm9wKE5vZGVQcm9wLmNsb3NlZEJ5KSkgJiYgY2xvc2VkQnkuaW5kZXhPZihhZnRlci5uYW1lKSA+IC0xICYmXG4gICAgICAgIHN0YXRlLmRvYy5saW5lQXQoYmVmb3JlLnRvKS5mcm9tID09IHN0YXRlLmRvYy5saW5lQXQoYWZ0ZXIuZnJvbSkuZnJvbSlcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogYmVmb3JlLnRvLCB0bzogYWZ0ZXIuZnJvbSB9O1xuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5SZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUgYW5kIGluZGVudCB0aGUgbmV3bHkgY3JlYXRlZFxubGluZShzKS4gSWYgdGhlIGN1cnJlbnQgbGluZSBjb25zaXN0cyBvbmx5IG9mIHdoaXRlc3BhY2UsIHRoaXNcbndpbGwgYWxzbyBkZWxldGUgdGhhdCB3aGl0ZXNwYWNlLiBXaGVuIHRoZSBjdXJzb3IgaXMgYmV0d2VlblxubWF0Y2hpbmcgYnJhY2tldHMsIGFuIGFkZGl0aW9uYWwgbmV3bGluZSB3aWxsIGJlIGluc2VydGVkIGFmdGVyXG50aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmVBbmRJbmRlbnQgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudChmYWxzZSk7XG4vKipcbkNyZWF0ZSBhIGJsYW5rLCBpbmRlbnRlZCBsaW5lIGJlbG93IHRoZSBjdXJyZW50IGxpbmUuXG4qL1xuY29uc3QgaW5zZXJ0QmxhbmtMaW5lID0gLypAX19QVVJFX18qL25ld2xpbmVBbmRJbmRlbnQodHJ1ZSk7XG5mdW5jdGlvbiBuZXdsaW5lQW5kSW5kZW50KGF0RW9mKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZSwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZnJvbSk7XG4gICAgICAgICAgICBsZXQgZXhwbG9kZSA9ICFhdEVvZiAmJiBmcm9tID09IHRvICYmIGlzQmV0d2VlbkJyYWNrZXRzKHN0YXRlLCBmcm9tKTtcbiAgICAgICAgICAgIGlmIChhdEVvZilcbiAgICAgICAgICAgICAgICBmcm9tID0gdG8gPSAodG8gPD0gbGluZS50byA/IGxpbmUgOiBzdGF0ZS5kb2MubGluZUF0KHRvKSkudG87XG4gICAgICAgICAgICBsZXQgY3ggPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBzaW11bGF0ZUJyZWFrOiBmcm9tLCBzaW11bGF0ZURvdWJsZUJyZWFrOiAhIWV4cGxvZGUgfSk7XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY3gsIGZyb20pO1xuICAgICAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGluZGVudCA9IC9eXFxzKi8uZXhlYyhzdGF0ZS5kb2MubGluZUF0KGZyb20pLnRleHQpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICh0byA8IGxpbmUudG8gJiYgL1xccy8udGVzdChsaW5lLnRleHRbdG8gLSBsaW5lLmZyb21dKSlcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgKHsgZnJvbSwgdG8gfSA9IGV4cGxvZGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA+IGxpbmUuZnJvbSAmJiBmcm9tIDwgbGluZS5mcm9tICsgMTAwICYmICEvXFxTLy50ZXN0KGxpbmUudGV4dC5zbGljZSgwLCBmcm9tKSkpXG4gICAgICAgICAgICAgICAgZnJvbSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBbXCJcIiwgaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpXTtcbiAgICAgICAgICAgIGlmIChleHBsb2RlKVxuICAgICAgICAgICAgICAgIGluc2VydC5wdXNoKGluZGVudFN0cmluZyhzdGF0ZSwgY3gubGluZUluZGVudChsaW5lLmZyb20sIC0xKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKGluc2VydCkgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tICsgMSArIGluc2VydFsxXS5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIGYpIHtcbiAgICBsZXQgYXRMaW5lID0gLTE7XG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSByYW5nZS5mcm9tOyBwb3MgPD0gcmFuZ2UudG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA+IGF0TGluZSAmJiAocmFuZ2UuZW1wdHkgfHwgcmFuZ2UudG8gPiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgZihsaW5lLCBjaGFuZ2VzLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgYXRMaW5lID0gbGluZS5udW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY2hhbmdlU2V0Lm1hcFBvcyhyYW5nZS5hbmNob3IsIDEpLCBjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmhlYWQsIDEpKSB9O1xuICAgIH0pO1xufVxuLyoqXG5BdXRvLWluZGVudCB0aGUgc2VsZWN0ZWQgbGluZXMuIFRoaXMgdXNlcyB0aGUgW2luZGVudGF0aW9uIHNlcnZpY2VcbmZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpIGFzIHNvdXJjZSBmb3IgYXV0by1pbmRlbnRcbmluZm9ybWF0aW9uLlxuKi9cbmNvbnN0IGluZGVudFNlbGVjdGlvbiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHVwZGF0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgb3ZlcnJpZGVJbmRlbnRhdGlvbjogc3RhcnQgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdXBkYXRlZFtzdGFydF07XG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPT0gbnVsbCA/IC0xIDogZm91bmQ7XG4gICAgICAgIH0gfSk7XG4gICAgbGV0IGNoYW5nZXMgPSBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMsIHJhbmdlKSA9PiB7XG4gICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBsaW5lLmZyb20pO1xuICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghL1xcUy8udGVzdChsaW5lLnRleHQpKVxuICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtIHx8IHJhbmdlLmZyb20gPCBsaW5lLmZyb20gKyBjdXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgdXNlckV2ZW50OiBcImluZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkFkZCBhIFt1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIG9mIGluZGVudGF0aW9uIHRvIGFsbCBzZWxlY3RlZFxubGluZXMuXG4qL1xuY29uc3QgaW5kZW50TW9yZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcykgPT4ge1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydDogc3RhdGUuZmFjZXQoaW5kZW50VW5pdCkgfSk7XG4gICAgfSksIHsgdXNlckV2ZW50OiBcImlucHV0LmluZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlbW92ZSBhIFt1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIG9mIGluZGVudGF0aW9uIGZyb20gYWxsXG5zZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCBpbmRlbnRMZXNzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGxldCBzcGFjZSA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBpZiAoIXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29sID0gY291bnRDb2x1bW4oc3BhY2UsIHN0YXRlLnRhYlNpemUpLCBrZWVwID0gMDtcbiAgICAgICAgbGV0IGluc2VydCA9IGluZGVudFN0cmluZyhzdGF0ZSwgTWF0aC5tYXgoMCwgY29sIC0gZ2V0SW5kZW50VW5pdChzdGF0ZSkpKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBzcGFjZS5sZW5ndGggJiYga2VlcCA8IGluc2VydC5sZW5ndGggJiYgc3BhY2UuY2hhckNvZGVBdChrZWVwKSA9PSBpbnNlcnQuY2hhckNvZGVBdChrZWVwKSlcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tICsga2VlcCwgdG86IGxpbmUuZnJvbSArIHNwYWNlLmxlbmd0aCwgaW5zZXJ0OiBpbnNlcnQuc2xpY2Uoa2VlcCkgfSk7XG4gICAgfSksIHsgdXNlckV2ZW50OiBcImRlbGV0ZS5kZWRlbnRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JbnNlcnQgYSB0YWIgY2hhcmFjdGVyIGF0IHRoZSBjdXJzb3Igb3IsIGlmIHNvbWV0aGluZyBpcyBzZWxlY3RlZCxcbnVzZSBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpIHRvIGluZGVudCB0aGUgZW50aXJlXG5zZWxlY3Rpb24uXG4qL1xuY29uc3QgaW5zZXJ0VGFiID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gIXIuZW1wdHkpKVxuICAgICAgICByZXR1cm4gaW5kZW50TW9yZSh7IHN0YXRlLCBkaXNwYXRjaCB9KTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihcIlxcdFwiKSwgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNvbnRhaW5pbmcgdGhlIEVtYWNzLXN0eWxlIGJpbmRpbmdzIHRoYXQgYXJlXG5hdmFpbGFibGUgb24gbWFjT1MgYnkgZGVmYXVsdC5cblxuIC0gQ3RybC1iOiBbYGN1cnNvckNoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyTGVmdCkgKFtgc2VsZWN0Q2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJMZWZ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1mOiBbYGN1cnNvckNoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhclJpZ2h0KSAoW2BzZWxlY3RDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJSaWdodCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBDdHJsLW46IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDdHJsLWE6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1lOiBbYGN1cnNvckxpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVFbmQpIChbYHNlbGVjdExpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVFbmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWQ6IFtgZGVsZXRlQ2hhckZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJGb3J3YXJkKVxuIC0gQ3RybC1oOiBbYGRlbGV0ZUNoYXJCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckJhY2t3YXJkKVxuIC0gQ3RybC1rOiBbYGRlbGV0ZVRvTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlVG9MaW5lRW5kKVxuIC0gQ3RybC1BbHQtaDogW2BkZWxldGVHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEJhY2t3YXJkKVxuIC0gQ3RybC1vOiBbYHNwbGl0TGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRMaW5lKVxuIC0gQ3RybC10OiBbYHRyYW5zcG9zZUNoYXJzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50cmFuc3Bvc2VDaGFycylcbiAtIEN0cmwtdjogW2BjdXJzb3JQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZURvd24pXG4gLSBBbHQtdjogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcClcbiovXG5jb25zdCBlbWFjc1N0eWxlS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtYlwiLCBydW46IGN1cnNvckNoYXJMZWZ0LCBzaGlmdDogc2VsZWN0Q2hhckxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1mXCIsIHJ1bjogY3Vyc29yQ2hhclJpZ2h0LCBzaGlmdDogc2VsZWN0Q2hhclJpZ2h0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1wXCIsIHJ1bjogY3Vyc29yTGluZVVwLCBzaGlmdDogc2VsZWN0TGluZVVwIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1uXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIkN0cmwtYVwiLCBydW46IGN1cnNvckxpbmVTdGFydCwgc2hpZnQ6IHNlbGVjdExpbmVTdGFydCB9LFxuICAgIHsga2V5OiBcIkN0cmwtZVwiLCBydW46IGN1cnNvckxpbmVFbmQsIHNoaWZ0OiBzZWxlY3RMaW5lRW5kIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1kXCIsIHJ1bjogZGVsZXRlQ2hhckZvcndhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWhcIiwgcnVuOiBkZWxldGVDaGFyQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWtcIiwgcnVuOiBkZWxldGVUb0xpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1oXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtb1wiLCBydW46IHNwbGl0TGluZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtdFwiLCBydW46IHRyYW5zcG9zZUNoYXJzIH0sXG4gICAgeyBrZXk6IFwiQ3RybC12XCIsIHJ1bjogY3Vyc29yUGFnZURvd24gfSxcbl07XG4vKipcbkFuIGFycmF5IG9mIGtleSBiaW5kaW5ncyBjbG9zZWx5IHN0aWNraW5nIHRvIHBsYXRmb3JtLXN0YW5kYXJkIG9yXG53aWRlbHkgdXNlZCBiaW5kaW5ncy4gKFRoaXMgaW5jbHVkZXMgdGhlIGJpbmRpbmdzIGZyb21cbltgZW1hY3NTdHlsZUtleW1hcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZW1hY3NTdHlsZUtleW1hcCksIHdpdGggdGhlaXIgYGtleWBcbnByb3BlcnR5IGNoYW5nZWQgdG8gYG1hY2AuKVxuXG4gLSBBcnJvd0xlZnQ6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBBcnJvd1JpZ2h0OiBbYGN1cnNvckNoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhclJpZ2h0KSAoW2BzZWxlY3RDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJSaWdodCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dMZWZ0IChBbHQtQXJyb3dMZWZ0IG9uIG1hY09TKTogW2BjdXJzb3JHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwTGVmdCkgKFtgc2VsZWN0R3JvdXBMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cExlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93UmlnaHQgKEFsdC1BcnJvd1JpZ2h0IG9uIG1hY09TKTogW2BjdXJzb3JHcm91cFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cFJpZ2h0KSAoW2BzZWxlY3RHcm91cFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cFJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93TGVmdCAob24gbWFjT1MpOiBbYGN1cnNvckxpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVN0YXJ0KSAoW2BzZWxlY3RMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVTdGFydCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd1JpZ2h0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEFycm93VXA6IFtgY3Vyc29yTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lVXApIChbYHNlbGVjdExpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVVwKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dEb3duOiBbYGN1cnNvckxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRG93bikgKFtgc2VsZWN0TGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVEb3duKSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93VXAgKG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd0Rvd24gKG9uIG1hY09TKTogW2BjdXJzb3JEb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY0VuZCkgKFtgc2VsZWN0RG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NFbmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93VXAgKG9uIG1hY09TKTogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcCkgKFtgc2VsZWN0UGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlVXApIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bikgKFtgc2VsZWN0UGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VEb3duKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZVVwOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIFBhZ2VEb3duOiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bikgKFtgc2VsZWN0UGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VEb3duKSB3aXRoIFNoaWZ0KVxuIC0gSG9tZTogW2BjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCkgd2l0aCBTaGlmdClcbiAtIEVuZDogW2BjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkKSAoW2BzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1Ib21lIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY1N0YXJ0KSAoW2BzZWxlY3REb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUVuZCAoQ21kLUhvbWUgb24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEVudGVyOiBbYGluc2VydE5ld2xpbmVBbmRJbmRlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydE5ld2xpbmVBbmRJbmRlbnQpXG4gLSBDdHJsLWEgKENtZC1hIG9uIG1hY09TKTogW2BzZWxlY3RBbGxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEFsbClcbiAtIEJhY2tzcGFjZTogW2BkZWxldGVDaGFyQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJCYWNrd2FyZClcbiAtIERlbGV0ZTogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLUJhY2tzcGFjZSAoQWx0LUJhY2tzcGFjZSBvbiBtYWNPUyk6IFtgZGVsZXRlR3JvdXBCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBCYWNrd2FyZClcbiAtIEN0cmwtRGVsZXRlIChBbHQtRGVsZXRlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwRm9yd2FyZClcbiAtIENtZC1CYWNrc3BhY2UgKG1hY09TKTogW2BkZWxldGVUb0xpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlVG9MaW5lU3RhcnQpLlxuIC0gQ21kLURlbGV0ZSAobWFjT1MpOiBbYGRlbGV0ZVRvTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlVG9MaW5lRW5kKS5cbiovXG5jb25zdCBzdGFuZGFyZEtleW1hcCA9IC8qQF9fUFVSRV9fKi9bXG4gICAgeyBrZXk6IFwiQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtQXJyb3dMZWZ0XCIsIG1hYzogXCJBbHQtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yR3JvdXBMZWZ0LCBzaGlmdDogc2VsZWN0R3JvdXBMZWZ0IH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93TGVmdFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJBcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yQ2hhclJpZ2h0LCBzaGlmdDogc2VsZWN0Q2hhclJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BcnJvd1JpZ2h0XCIsIG1hYzogXCJBbHQtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckdyb3VwUmlnaHQsIHNoaWZ0OiBzZWxlY3RHcm91cFJpZ2h0IH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93VXBcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yRG9jRW5kLCBzaGlmdDogc2VsZWN0RG9jRW5kIH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiSG9tZVwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJNb2QtSG9tZVwiLCBydW46IGN1cnNvckRvY1N0YXJ0LCBzaGlmdDogc2VsZWN0RG9jU3RhcnQgfSxcbiAgICB7IGtleTogXCJFbmRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIk1vZC1FbmRcIiwgcnVuOiBjdXJzb3JEb2NFbmQsIHNoaWZ0OiBzZWxlY3REb2NFbmQgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBydW46IGluc2VydE5ld2xpbmVBbmRJbmRlbnQgfSxcbiAgICB7IGtleTogXCJNb2QtYVwiLCBydW46IHNlbGVjdEFsbCB9LFxuICAgIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCwgc2hpZnQ6IGRlbGV0ZUNoYXJCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkRlbGV0ZVwiLCBydW46IGRlbGV0ZUNoYXJGb3J3YXJkIH0sXG4gICAgeyBrZXk6IFwiTW9kLUJhY2tzcGFjZVwiLCBtYWM6IFwiQWx0LUJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUdyb3VwQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJNb2QtRGVsZXRlXCIsIG1hYzogXCJBbHQtRGVsZXRlXCIsIHJ1bjogZGVsZXRlR3JvdXBGb3J3YXJkIH0sXG4gICAgeyBtYWM6IFwiTW9kLUJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZVRvTGluZVN0YXJ0IH0sXG4gICAgeyBtYWM6IFwiTW9kLURlbGV0ZVwiLCBydW46IGRlbGV0ZVRvTGluZUVuZCB9XG5dLmNvbmNhdCgvKkBfX1BVUkVfXyovZW1hY3NTdHlsZUtleW1hcC5tYXAoYiA9PiAoeyBtYWM6IGIua2V5LCBydW46IGIucnVuLCBzaGlmdDogYi5zaGlmdCB9KSkpO1xuLyoqXG5UaGUgZGVmYXVsdCBrZXltYXAuIEluY2x1ZGVzIGFsbCBiaW5kaW5ncyBmcm9tXG5bYHN0YW5kYXJkS2V5bWFwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zdGFuZGFyZEtleW1hcCkgcGx1cyB0aGUgZm9sbG93aW5nOlxuXG4tIEFsdC1BcnJvd0xlZnQgKEN0cmwtQXJyb3dMZWZ0IG9uIG1hY09TKTogW2BjdXJzb3JTeW50YXhMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhMZWZ0KSAoW2BzZWxlY3RTeW50YXhMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RTeW50YXhMZWZ0KSB3aXRoIFNoaWZ0KVxuLSBBbHQtQXJyb3dSaWdodCAoQ3RybC1BcnJvd1JpZ2h0IG9uIG1hY09TKTogW2BjdXJzb3JTeW50YXhSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yU3ludGF4UmlnaHQpIChbYHNlbGVjdFN5bnRheFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RTeW50YXhSaWdodCkgd2l0aCBTaGlmdClcbi0gQWx0LUFycm93VXA6IFtgbW92ZUxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMubW92ZUxpbmVVcClcbi0gQWx0LUFycm93RG93bjogW2Btb3ZlTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLm1vdmVMaW5lRG93bilcbi0gU2hpZnQtQWx0LUFycm93VXA6IFtgY29weUxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY29weUxpbmVVcClcbi0gU2hpZnQtQWx0LUFycm93RG93bjogW2Bjb3B5TGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmNvcHlMaW5lRG93bilcbi0gRXNjYXBlOiBbYHNpbXBsaWZ5U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zaW1wbGlmeVNlbGVjdGlvbilcbi0gQ3RybC1FbnRlciAoQ29tZC1FbnRlciBvbiBtYWNPUyk6IFtgaW5zZXJ0QmxhbmtMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbnNlcnRCbGFua0xpbmUpXG4tIEFsdC1sIChDdHJsLWwgb24gbWFjT1MpOiBbYHNlbGVjdExpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmUpXG4tIEN0cmwtaSAoQ21kLWkgb24gbWFjT1MpOiBbYHNlbGVjdFBhcmVudFN5bnRheGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFyZW50U3ludGF4KVxuLSBDdHJsLVsgKENtZC1bIG9uIG1hY09TKTogW2BpbmRlbnRMZXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRMZXNzKVxuLSBDdHJsLV0gKENtZC1dIG9uIG1hY09TKTogW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKVxuLSBDdHJsLUFsdC1cXFxcIChDbWQtQWx0LVxcXFwgb24gbWFjT1MpOiBbYGluZGVudFNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50U2VsZWN0aW9uKVxuLSBTaGlmdC1DdHJsLWsgKFNoaWZ0LUNtZC1rIG9uIG1hY09TKTogW2BkZWxldGVMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVMaW5lKVxuLSBTaGlmdC1DdHJsLVxcXFwgKFNoaWZ0LUNtZC1cXFxcIG9uIG1hY09TKTogW2BjdXJzb3JNYXRjaGluZ0JyYWNrZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvck1hdGNoaW5nQnJhY2tldClcbiovXG5jb25zdCBkZWZhdWx0S2V5bWFwID0gLypAX19QVVJFX18qL1tcbiAgICB7IGtleTogXCJBbHQtQXJyb3dMZWZ0XCIsIG1hYzogXCJDdHJsLUFycm93TGVmdFwiLCBydW46IGN1cnNvclN5bnRheExlZnQsIHNoaWZ0OiBzZWxlY3RTeW50YXhMZWZ0IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93UmlnaHRcIiwgbWFjOiBcIkN0cmwtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvclN5bnRheFJpZ2h0LCBzaGlmdDogc2VsZWN0U3ludGF4UmlnaHQgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dVcFwiLCBydW46IG1vdmVMaW5lVXAgfSxcbiAgICB7IGtleTogXCJTaGlmdC1BbHQtQXJyb3dVcFwiLCBydW46IGNvcHlMaW5lVXAgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dEb3duXCIsIHJ1bjogbW92ZUxpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtQWx0LUFycm93RG93blwiLCBydW46IGNvcHlMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IHNpbXBsaWZ5U2VsZWN0aW9uIH0sXG4gICAgeyBrZXk6IFwiTW9kLUVudGVyXCIsIHJ1bjogaW5zZXJ0QmxhbmtMaW5lIH0sXG4gICAgeyBrZXk6IFwiQWx0LWxcIiwgbWFjOiBcIkN0cmwtbFwiLCBydW46IHNlbGVjdExpbmUgfSxcbiAgICB7IGtleTogXCJNb2QtaVwiLCBydW46IHNlbGVjdFBhcmVudFN5bnRheCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtW1wiLCBydW46IGluZGVudExlc3MgfSxcbiAgICB7IGtleTogXCJNb2QtXVwiLCBydW46IGluZGVudE1vcmUgfSxcbiAgICB7IGtleTogXCJNb2QtQWx0LVxcXFxcIiwgcnVuOiBpbmRlbnRTZWxlY3Rpb24gfSxcbiAgICB7IGtleTogXCJTaGlmdC1Nb2Qta1wiLCBydW46IGRlbGV0ZUxpbmUgfSxcbiAgICB7IGtleTogXCJTaGlmdC1Nb2QtXFxcXFwiLCBydW46IGN1cnNvck1hdGNoaW5nQnJhY2tldCB9XG5dLmNvbmNhdChzdGFuZGFyZEtleW1hcCk7XG4vKipcbkEgYmluZGluZyB0aGF0IGJpbmRzIFRhYiB0byBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpIGFuZFxuU2hpZnQtVGFiIHRvIFtgaW5kZW50TGVzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TGVzcykuXG5QbGVhc2Ugc2VlIHRoZSBbVGFiIGV4YW1wbGVdKC4uLy4uL2V4YW1wbGVzL3RhYi8pIGJlZm9yZSB1c2luZ1xudGhpcy5cbiovXG5jb25zdCBpbmRlbnRXaXRoVGFiID0geyBrZXk6IFwiVGFiXCIsIHJ1bjogaW5kZW50TW9yZSwgc2hpZnQ6IGluZGVudExlc3MgfTtcblxuZXhwb3J0IHsgY29weUxpbmVEb3duLCBjb3B5TGluZVVwLCBjdXJzb3JDaGFyQmFja3dhcmQsIGN1cnNvckNoYXJGb3J3YXJkLCBjdXJzb3JDaGFyTGVmdCwgY3Vyc29yQ2hhclJpZ2h0LCBjdXJzb3JEb2NFbmQsIGN1cnNvckRvY1N0YXJ0LCBjdXJzb3JHcm91cEJhY2t3YXJkLCBjdXJzb3JHcm91cEZvcndhcmQsIGN1cnNvckdyb3VwTGVmdCwgY3Vyc29yR3JvdXBSaWdodCwgY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQsIGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQsIGN1cnNvckxpbmVEb3duLCBjdXJzb3JMaW5lRW5kLCBjdXJzb3JMaW5lU3RhcnQsIGN1cnNvckxpbmVVcCwgY3Vyc29yTWF0Y2hpbmdCcmFja2V0LCBjdXJzb3JQYWdlRG93biwgY3Vyc29yUGFnZVVwLCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQsIGN1cnNvclN1YndvcmRGb3J3YXJkLCBjdXJzb3JTeW50YXhMZWZ0LCBjdXJzb3JTeW50YXhSaWdodCwgZGVmYXVsdEtleW1hcCwgZGVsZXRlQ2hhckJhY2t3YXJkLCBkZWxldGVDaGFyRm9yd2FyZCwgZGVsZXRlR3JvdXBCYWNrd2FyZCwgZGVsZXRlR3JvdXBGb3J3YXJkLCBkZWxldGVMaW5lLCBkZWxldGVUb0xpbmVFbmQsIGRlbGV0ZVRvTGluZVN0YXJ0LCBkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UsIGVtYWNzU3R5bGVLZXltYXAsIGluZGVudExlc3MsIGluZGVudE1vcmUsIGluZGVudFNlbGVjdGlvbiwgaW5kZW50V2l0aFRhYiwgaW5zZXJ0QmxhbmtMaW5lLCBpbnNlcnROZXdsaW5lLCBpbnNlcnROZXdsaW5lQW5kSW5kZW50LCBpbnNlcnRUYWIsIG1vdmVMaW5lRG93biwgbW92ZUxpbmVVcCwgc2VsZWN0QWxsLCBzZWxlY3RDaGFyQmFja3dhcmQsIHNlbGVjdENoYXJGb3J3YXJkLCBzZWxlY3RDaGFyTGVmdCwgc2VsZWN0Q2hhclJpZ2h0LCBzZWxlY3REb2NFbmQsIHNlbGVjdERvY1N0YXJ0LCBzZWxlY3RHcm91cEJhY2t3YXJkLCBzZWxlY3RHcm91cEZvcndhcmQsIHNlbGVjdEdyb3VwTGVmdCwgc2VsZWN0R3JvdXBSaWdodCwgc2VsZWN0TGluZSwgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQsIHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQsIHNlbGVjdExpbmVEb3duLCBzZWxlY3RMaW5lRW5kLCBzZWxlY3RMaW5lU3RhcnQsIHNlbGVjdExpbmVVcCwgc2VsZWN0TWF0Y2hpbmdCcmFja2V0LCBzZWxlY3RQYWdlRG93biwgc2VsZWN0UGFnZVVwLCBzZWxlY3RQYXJlbnRTeW50YXgsIHNlbGVjdFN1YndvcmRCYWNrd2FyZCwgc2VsZWN0U3Vid29yZEZvcndhcmQsIHNlbGVjdFN5bnRheExlZnQsIHNlbGVjdFN5bnRheFJpZ2h0LCBzaW1wbGlmeVNlbGVjdGlvbiwgc3BsaXRMaW5lLCBzdGFuZGFyZEtleW1hcCwgdHJhbnNwb3NlQ2hhcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/commands/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/gutter/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/gutter/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GutterMarker\": function() { return /* binding */ GutterMarker; },\n/* harmony export */   \"gutter\": function() { return /* binding */ gutter; },\n/* harmony export */   \"gutterLineClass\": function() { return /* binding */ gutterLineClass; },\n/* harmony export */   \"gutters\": function() { return /* binding */ gutters; },\n/* harmony export */   \"highlightActiveLineGutter\": function() { return /* binding */ highlightActiveLineGutter; },\n/* harmony export */   \"lineNumberMarkers\": function() { return /* binding */ lineNumberMarkers; },\n/* harmony export */   \"lineNumbers\": function() { return /* binding */ lineNumbers; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/rangeset */ \"./node_modules/@codemirror/rangeset/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/\n\nvar GutterMarker = /*#__PURE__*/function (_RangeValue) {\n  _inherits(GutterMarker, _RangeValue);\n\n  var _super = _createSuper(GutterMarker);\n\n  function GutterMarker() {\n    _classCallCheck(this, GutterMarker);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GutterMarker, [{\n    key: \"compare\",\n    value:\n    /**\n    @internal\n    */\n    function compare(other) {\n      return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    Compare this marker to another marker of the same type.\n    */\n\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return false;\n    }\n    /**\n    Called if the marker has a `toDOM` method and its representation\n    was removed from a gutter.\n    */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(dom) {}\n  }]);\n\n  return GutterMarker;\n}(_codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeValue);\n\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#gutter.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#gutter.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/\n\nvar gutterLineClass = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nvar defaults = {\n  \"class\": \"\",\n  renderEmptyElements: false,\n  elementStyle: \"\",\n  markers: function markers() {\n    return _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeSet.empty;\n  },\n  lineMarker: function lineMarker() {\n    return null;\n  },\n  lineMarkerChange: null,\n  initialSpacer: null,\n  updateSpacer: null,\n  domEventHandlers: {}\n};\nvar activeGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/\n\nfunction gutter(config) {\n  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];\n}\n\nvar baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n  \".cm-gutters\": {\n    display: \"flex\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    left: 0,\n    zIndex: 200\n  },\n  \"&light .cm-gutters\": {\n    backgroundColor: \"#f5f5f5\",\n    color: \"#999\",\n    borderRight: \"1px solid #ddd\"\n  },\n  \"&dark .cm-gutters\": {\n    backgroundColor: \"#333338\",\n    color: \"#ccc\"\n  },\n  \".cm-gutter\": {\n    display: \"flex !important\",\n    flexDirection: \"column\",\n    flexShrink: 0,\n    boxSizing: \"border-box\",\n    minHeight: \"100%\",\n    overflow: \"hidden\"\n  },\n  \".cm-gutterElement\": {\n    boxSizing: \"border-box\"\n  },\n  \".cm-lineNumbers .cm-gutterElement\": {\n    padding: \"0 3px 0 5px\",\n    minWidth: \"20px\",\n    textAlign: \"right\",\n    whiteSpace: \"nowrap\"\n  },\n  \"&light .cm-activeLineGutter\": {\n    backgroundColor: \"#e2f2ff\"\n  },\n  \"&dark .cm-activeLineGutter\": {\n    backgroundColor: \"#222227\"\n  }\n});\nvar unfixGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n  combine: function combine(values) {\n    return values.some(function (x) {\n      return x;\n    });\n  }\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/\n\nfunction gutters(config) {\n  var result = [gutterView, baseTheme];\n  if (config && config.fixed === false) result.push(unfixGutters.of(true));\n  return result;\n}\n\nvar gutterView = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    _classCallCheck(this, _class);\n\n    this.view = view;\n    this.prevViewport = view.viewport;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutters\";\n    this.dom.setAttribute(\"aria-hidden\", \"true\");\n    this.dom.style.minHeight = this.view.contentHeight + \"px\";\n    this.gutters = view.state.facet(activeGutters).map(function (conf) {\n      return new SingleGutterView(view, conf);\n    });\n\n    var _iterator = _createForOfIteratorHelper(this.gutters),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _gutter = _step.value;\n        this.dom.appendChild(_gutter.dom);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this.fixed = !view.state.facet(unfixGutters);\n\n    if (this.fixed) {\n      // FIXME IE11 fallback, which doesn't support position: sticky,\n      // by using position: relative + event handlers that realign the\n      // gutter (or just force fixed=false on IE11?)\n      this.dom.style.position = \"sticky\";\n    }\n\n    this.syncGutters(false);\n    view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n  }\n\n  _createClass(_class, [{\n    key: \"update\",\n    value: function update(_update) {\n      if (this.updateGutters(_update)) {\n        // Detach during sync when the viewport changed significantly\n        // (such as during scrolling), since for large updates that is\n        // faster.\n        var vpA = this.prevViewport,\n            vpB = _update.view.viewport;\n        var vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n        this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n      }\n\n      if (_update.geometryChanged) this.dom.style.minHeight = this.view.contentHeight + \"px\";\n\n      if (this.view.state.facet(unfixGutters) != !this.fixed) {\n        this.fixed = !this.fixed;\n        this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n      }\n\n      this.prevViewport = _update.view.viewport;\n    }\n  }, {\n    key: \"syncGutters\",\n    value: function syncGutters(detach) {\n      var _this = this;\n\n      var after = this.dom.nextSibling;\n      if (detach) this.dom.remove();\n      var lineClasses = _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n      var classSet = [];\n      var contexts = this.gutters.map(function (gutter) {\n        return new UpdateContext(gutter, _this.view.viewport, -_this.view.documentPadding.top);\n      });\n\n      var _iterator2 = _createForOfIteratorHelper(this.view.viewportLineBlocks),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var line = _step2.value;\n          var text = void 0;\n\n          if (Array.isArray(line.type)) {\n            var _iterator4 = _createForOfIteratorHelper(line.type),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var b = _step4.value;\n\n                if (b.type == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.BlockType.Text) {\n                  text = b;\n                  break;\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          } else {\n            text = line.type == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.BlockType.Text ? line : undefined;\n          }\n\n          if (!text) continue;\n          if (classSet.length) classSet = [];\n          advanceCursor(lineClasses, classSet, line.from);\n\n          var _iterator5 = _createForOfIteratorHelper(contexts),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var cx = _step5.value;\n              cx.line(this.view, text, classSet);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(contexts),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _cx = _step3.value;\n\n          _cx.finish();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      if (detach) this.view.scrollDOM.insertBefore(this.dom, after);\n    }\n  }, {\n    key: \"updateGutters\",\n    value: function updateGutters(update) {\n      var prev = update.startState.facet(activeGutters),\n          cur = update.state.facet(activeGutters);\n      var change = update.docChanged || update.heightChanged || update.viewportChanged || !_codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n\n      if (prev == cur) {\n        var _iterator6 = _createForOfIteratorHelper(this.gutters),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var _gutter2 = _step6.value;\n            if (_gutter2.update(update)) change = true;\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      } else {\n        change = true;\n        var _gutters = [];\n\n        var _iterator7 = _createForOfIteratorHelper(cur),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var conf = _step7.value;\n            var known = prev.indexOf(conf);\n\n            if (known < 0) {\n              _gutters.push(new SingleGutterView(this.view, conf));\n            } else {\n              this.gutters[known].update(update);\n\n              _gutters.push(this.gutters[known]);\n            }\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        var _iterator8 = _createForOfIteratorHelper(this.gutters),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var _g = _step8.value;\n\n            _g.dom.remove();\n\n            if (_gutters.indexOf(_g) < 0) _g.destroy();\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n\n        for (var _i = 0, _gutters2 = _gutters; _i < _gutters2.length; _i++) {\n          var g = _gutters2[_i];\n          this.dom.appendChild(g.dom);\n        }\n\n        this.gutters = _gutters;\n      }\n\n      return change;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _iterator9 = _createForOfIteratorHelper(this.gutters),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var view = _step9.value;\n          view.destroy();\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      this.dom.remove();\n    }\n  }]);\n\n  return _class;\n}(), {\n  provide: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.PluginField.scrollMargins.from(function (value) {\n    if (value.gutters.length == 0 || !value.fixed) return null;\n    return value.view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR ? {\n      left: value.dom.offsetWidth\n    } : {\n      right: value.dom.offsetWidth\n    };\n  })\n});\n\nfunction asArray(val) {\n  return Array.isArray(val) ? val : [val];\n}\n\nfunction advanceCursor(cursor, collect, pos) {\n  while (cursor.value && cursor.from <= pos) {\n    if (cursor.from == pos) collect.push(cursor.value);\n    cursor.next();\n  }\n}\n\nvar UpdateContext = /*#__PURE__*/function () {\n  function UpdateContext(gutter, viewport, height) {\n    _classCallCheck(this, UpdateContext);\n\n    this.gutter = gutter;\n    this.height = height;\n    this.localMarkers = [];\n    this.i = 0;\n    this.cursor = _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeSet.iter(gutter.markers, viewport.from);\n  }\n\n  _createClass(UpdateContext, [{\n    key: \"line\",\n    value: function line(view, _line, extraMarkers) {\n      if (this.localMarkers.length) this.localMarkers = [];\n      advanceCursor(this.cursor, this.localMarkers, _line.from);\n      var localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;\n      var forLine = this.gutter.config.lineMarker(view, _line, localMarkers);\n      if (forLine) localMarkers.unshift(forLine);\n      var gutter = this.gutter;\n      if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;\n      var above = _line.top - this.height;\n\n      if (this.i == gutter.elements.length) {\n        var newElt = new GutterElement(view, _line.height, above, localMarkers);\n        gutter.elements.push(newElt);\n        gutter.dom.appendChild(newElt.dom);\n      } else {\n        gutter.elements[this.i].update(view, _line.height, above, localMarkers);\n      }\n\n      this.height = _line.bottom;\n      this.i++;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      var gutter = this.gutter;\n\n      while (gutter.elements.length > this.i) {\n        var last = gutter.elements.pop();\n        gutter.dom.removeChild(last.dom);\n        last.destroy();\n      }\n    }\n  }]);\n\n  return UpdateContext;\n}();\n\nvar SingleGutterView = /*#__PURE__*/function () {\n  function SingleGutterView(view, config) {\n    var _this2 = this;\n\n    _classCallCheck(this, SingleGutterView);\n\n    this.view = view;\n    this.config = config;\n    this.elements = [];\n    this.spacer = null;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutter\" + (this.config[\"class\"] ? \" \" + this.config[\"class\"] : \"\");\n\n    var _loop = function _loop(prop) {\n      _this2.dom.addEventListener(prop, function (event) {\n        var line = view.lineBlockAtHeight(event.clientY - view.documentTop);\n        if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();\n      });\n    };\n\n    for (var prop in config.domEventHandlers) {\n      _loop(prop);\n    }\n\n    this.markers = asArray(config.markers(view));\n\n    if (config.initialSpacer) {\n      this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);\n      this.dom.appendChild(this.spacer.dom);\n      this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n    }\n  }\n\n  _createClass(SingleGutterView, [{\n    key: \"update\",\n    value: function update(_update2) {\n      var prevMarkers = this.markers;\n      this.markers = asArray(this.config.markers(_update2.view));\n\n      if (this.spacer && this.config.updateSpacer) {\n        var updated = this.config.updateSpacer(this.spacer.markers[0], _update2);\n        if (updated != this.spacer.markers[0]) this.spacer.update(_update2.view, 0, 0, [updated]);\n      }\n\n      var vp = _update2.view.viewport;\n      return !_codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(_update2) : false);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _iterator10 = _createForOfIteratorHelper(this.elements),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var elt = _step10.value;\n          elt.destroy();\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }]);\n\n  return SingleGutterView;\n}();\n\nvar GutterElement = /*#__PURE__*/function () {\n  function GutterElement(view, height, above, markers) {\n    _classCallCheck(this, GutterElement);\n\n    this.height = -1;\n    this.above = 0;\n    this.markers = [];\n    this.dom = document.createElement(\"div\");\n    this.update(view, height, above, markers);\n  }\n\n  _createClass(GutterElement, [{\n    key: \"update\",\n    value: function update(view, height, above, markers) {\n      if (this.height != height) this.dom.style.height = (this.height = height) + \"px\";\n      if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n      if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);\n    }\n  }, {\n    key: \"setMarkers\",\n    value: function setMarkers(view, markers) {\n      var cls = \"cm-gutterElement\",\n          domPos = this.dom.firstChild;\n\n      for (var iNew = 0, iOld = 0;;) {\n        var skipTo = iOld,\n            marker = iNew < markers.length ? markers[iNew++] : null,\n            matched = false;\n\n        if (marker) {\n          var c = marker.elementClass;\n          if (c) cls += \" \" + c;\n\n          for (var i = iOld; i < this.markers.length; i++) {\n            if (this.markers[i].compare(marker)) {\n              skipTo = i;\n              matched = true;\n              break;\n            }\n          }\n        } else {\n          skipTo = this.markers.length;\n        }\n\n        while (iOld < skipTo) {\n          var next = this.markers[iOld++];\n\n          if (next.toDOM) {\n            next.destroy(domPos);\n            var after = domPos.nextSibling;\n            domPos.remove();\n            domPos = after;\n          }\n        }\n\n        if (!marker) break;\n\n        if (marker.toDOM) {\n          if (matched) domPos = domPos.nextSibling;else this.dom.insertBefore(marker.toDOM(view), domPos);\n        }\n\n        if (matched) iOld++;\n      }\n\n      this.dom.className = cls;\n      this.markers = markers;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.setMarkers(null, []); // First argument not used unless creating markers\n    }\n  }]);\n\n  return GutterElement;\n}();\n\nfunction sameMarkers(a, b) {\n  if (a.length != b.length) return false;\n\n  for (var i = 0; i < a.length; i++) {\n    if (!a[i].compare(b[i])) return false;\n  }\n\n  return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/\n\n\nvar lineNumberMarkers = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nvar lineNumberConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n  combine: function combine(values) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(values, {\n      formatNumber: String,\n      domEventHandlers: {}\n    }, {\n      domEventHandlers: function domEventHandlers(a, b) {\n        var result = Object.assign({}, a);\n\n        var _loop2 = function _loop2(event) {\n          var exists = result[event],\n              add = b[event];\n          result[event] = exists ? function (view, line, event) {\n            return exists(view, line, event) || add(view, line, event);\n          } : add;\n        };\n\n        for (var event in b) {\n          _loop2(event);\n        }\n\n        return result;\n      }\n    });\n  }\n});\n\nvar NumberMarker = /*#__PURE__*/function (_GutterMarker) {\n  _inherits(NumberMarker, _GutterMarker);\n\n  var _super2 = _createSuper(NumberMarker);\n\n  function NumberMarker(number) {\n    var _this3;\n\n    _classCallCheck(this, NumberMarker);\n\n    _this3 = _super2.call(this);\n    _this3.number = number;\n    return _this3;\n  }\n\n  _createClass(NumberMarker, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return this.number == other.number;\n    }\n  }, {\n    key: \"toDOM\",\n    value: function toDOM() {\n      return document.createTextNode(this.number);\n    }\n  }]);\n\n  return NumberMarker;\n}(GutterMarker);\n\nfunction formatNumber(view, number) {\n  return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\n\nvar lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], function (state) {\n  return {\n    \"class\": \"cm-lineNumbers\",\n    renderEmptyElements: false,\n    markers: function markers(view) {\n      return view.state.facet(lineNumberMarkers);\n    },\n    lineMarker: function lineMarker(view, line, others) {\n      if (others.some(function (m) {\n        return m.toDOM;\n      })) return null;\n      return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n    },\n    lineMarkerChange: function lineMarkerChange(update) {\n      return update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig);\n    },\n    initialSpacer: function initialSpacer(view) {\n      return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n    },\n    updateSpacer: function updateSpacer(spacer, update) {\n      var max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n      return max == spacer.number ? spacer : new NumberMarker(max);\n    },\n    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\n  };\n});\n/**\nCreate a line number gutter extension.\n*/\n\nfunction lineNumbers() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [lineNumberConfig.of(config), gutters(), lineNumberGutter];\n}\n\nfunction maxLineNumber(lines) {\n  var last = 9;\n\n  while (last < lines) {\n    last = last * 10 + 9;\n  }\n\n  return last;\n}\n\nvar activeLineGutterMarker = /*@__PURE__*/new ( /*#__PURE__*/function (_GutterMarker2) {\n  _inherits(_class2, _GutterMarker2);\n\n  var _super3 = _createSuper(_class2);\n\n  function _class2() {\n    var _this4;\n\n    _classCallCheck(this, _class2);\n\n    _this4 = _super3.apply(this, arguments);\n    _this4.elementClass = \"cm-activeLineGutter\";\n    return _this4;\n  }\n\n  return _class2;\n}(GutterMarker))();\nvar activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute([\"selection\"], function (state) {\n  var marks = [],\n      last = -1;\n\n  var _iterator11 = _createForOfIteratorHelper(state.selection.ranges),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var range = _step11.value;\n\n      if (range.empty) {\n        var linePos = state.doc.lineAt(range.head).from;\n\n        if (linePos > last) {\n          last = linePos;\n          marks.push(activeLineGutterMarker.range(linePos));\n        }\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  return _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/\n\nfunction highlightActiveLineGutter() {\n  return activeLineGutterHighlighter;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvZ3V0dGVyL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7Ozs7QUFmQTs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFyQ0E7QUF5Q0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBUEE7QUFBQTs7QUFBQTtBQVFBO0FBQUE7QUFDQTtBQURBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFVQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQXBCQTtBQUFBO0FBQUE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFyQ0E7QUFBQTtBQUFBO0FBc0NBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQU5BO0FBQUE7O0FBQUE7QUFPQTtBQUFBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBRUE7QUFDQTs7QUFDQTtBQUVBO0FBRUE7O0FBaEJBO0FBQUE7O0FBQUE7QUFpQkE7QUFBQTtBQUNBO0FBREE7QUFqQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQW1CQTtBQTFCQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUEyQkE7QUFBQTs7QUFDQTtBQURBO0FBM0JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBNkJBO0FBRUE7QUFyRUE7QUFBQTtBQUFBO0FBdUVBO0FBQUE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBQ0E7O0FBRkE7QUFBQTs7QUFBQTtBQUdBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFhQTtBQUFBOztBQUNBOztBQUNBO0FBRUE7QUFqQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFrQkE7QUFBQTtBQUNBO0FBREE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBdEdBO0FBQUE7QUFBQTtBQXVHQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7QUEzR0E7O0FBQUE7QUFBQTtBQTZHQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTEE7O0FBT0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFFQTtBQVpBOztBQU9BO0FBQUE7QUFNQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTs7Ozs7O0FBRUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7OztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFNQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBSUE7O0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBREE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQURBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUpBOztBQUVBO0FBQUE7QUFHQTs7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQVpBOztBQWNBOzs7OztBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTtBQUZBO0FBR0E7Ozs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7OztBQU5BOztBQVFBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFBQTtBQW1CQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBS0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFDQTs7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTtBQUZBO0FBR0E7O0FBSkE7QUFBQTtBQU1BO0FBQ0E7QUFBQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvZ3V0dGVyL2Rpc3QvaW5kZXguanM/ODc5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3JWaWV3LCBWaWV3UGx1Z2luLCBCbG9ja1R5cGUsIFBsdWdpbkZpZWxkLCBEaXJlY3Rpb24gfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IFJhbmdlU2V0LCBSYW5nZVZhbHVlIH0gZnJvbSAnQGNvZGVtaXJyb3IvcmFuZ2VzZXQnO1xuaW1wb3J0IHsgTWFwTW9kZSwgRmFjZXQsIGNvbWJpbmVDb25maWcgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5cbi8qKlxuQSBndXR0ZXIgbWFya2VyIHJlcHJlc2VudHMgYSBiaXQgb2YgaW5mb3JtYXRpb24gYXR0YWNoZWQgdG8gYSBsaW5lXG5pbiBhIHNwZWNpZmljIGd1dHRlci4gWW91ciBvd24gY3VzdG9tIG1hcmtlcnMgaGF2ZSB0byBleHRlbmQgdGhpc1xuY2xhc3MuXG4qL1xuY2xhc3MgR3V0dGVyTWFya2VyIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBtYXJrZXIgdG8gYW5vdGhlciBtYXJrZXIgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIENhbGxlZCBpZiB0aGUgbWFya2VyIGhhcyBhIGB0b0RPTWAgbWV0aG9kIGFuZCBpdHMgcmVwcmVzZW50YXRpb25cbiAgICB3YXMgcmVtb3ZlZCBmcm9tIGEgZ3V0dGVyLlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbGVtZW50Q2xhc3MgPSBcIlwiO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS50b0RPTSA9IHVuZGVmaW5lZDtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tCZWZvcmU7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnN0YXJ0U2lkZSA9IEd1dHRlck1hcmtlci5wcm90b3R5cGUuZW5kU2lkZSA9IC0xO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG4vKipcbkZhY2V0IHVzZWQgdG8gYWRkIGEgY2xhc3MgdG8gYWxsIGd1dHRlciBlbGVtZW50cyBmb3IgYSBnaXZlbiBsaW5lLlxuTWFya2VycyBnaXZlbiB0byB0aGlzIGZhY2V0IHNob3VsZCBfb25seV8gZGVmaW5lIGFuXG5bYGVsZW1lbnRjbGFzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jZ3V0dGVyLkd1dHRlck1hcmtlci5lbGVtZW50Q2xhc3MpLCBub3QgYVxuW2B0b0RPTWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jZ3V0dGVyLkd1dHRlck1hcmtlci50b0RPTSkgKG9yIHRoZSBtYXJrZXIgd2lsbCBhcHBlYXJcbmluIGFsbCBndXR0ZXJzIGZvciB0aGUgbGluZSkuXG4qL1xuY29uc3QgZ3V0dGVyTGluZUNsYXNzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgY2xhc3M6IFwiXCIsXG4gICAgcmVuZGVyRW1wdHlFbGVtZW50czogZmFsc2UsXG4gICAgZWxlbWVudFN0eWxlOiBcIlwiLFxuICAgIG1hcmtlcnM6ICgpID0+IFJhbmdlU2V0LmVtcHR5LFxuICAgIGxpbmVNYXJrZXI6ICgpID0+IG51bGwsXG4gICAgbGluZU1hcmtlckNoYW5nZTogbnVsbCxcbiAgICBpbml0aWFsU3BhY2VyOiBudWxsLFxuICAgIHVwZGF0ZVNwYWNlcjogbnVsbCxcbiAgICBkb21FdmVudEhhbmRsZXJzOiB7fVxufTtcbmNvbnN0IGFjdGl2ZUd1dHRlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkRlZmluZSBhbiBlZGl0b3IgZ3V0dGVyLiBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlIGd1dHRlcnMgYXBwZWFyIGlzXG5kZXRlcm1pbmVkIGJ5IHRoZWlyIGV4dGVuc2lvbiBwcmlvcml0eS5cbiovXG5mdW5jdGlvbiBndXR0ZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIFtndXR0ZXJzKCksIGFjdGl2ZUd1dHRlcnMub2YoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyksIGNvbmZpZykpXTtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB6SW5kZXg6IDIwMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCIjOTk5XCIsXG4gICAgICAgIGJvcmRlclJpZ2h0OiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCIjY2NjXCJcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIG1pbkhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0sXG4gICAgXCIuY20tbGluZU51bWJlcnMgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjAgM3B4IDAgNXB4XCIsXG4gICAgICAgIG1pbldpZHRoOiBcIjIwcHhcIixcbiAgICAgICAgdGV4dEFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlMmYyZmZcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMjIyMjI3XCJcbiAgICB9XG59KTtcbmNvbnN0IHVuZml4R3V0dGVycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpXG59KTtcbi8qKlxuVGhlIGd1dHRlci1kcmF3aW5nIHBsdWdpbiBpcyBhdXRvbWF0aWNhbGx5IGVuYWJsZWQgd2hlbiB5b3UgYWRkIGFcbmd1dHRlciwgYnV0IHlvdSBjYW4gdXNlIHRoaXMgZnVuY3Rpb24gdG8gZXhwbGljaXRseSBjb25maWd1cmUgaXQuXG5cblVubGVzcyBgZml4ZWRgIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGBmYWxzZWAsIHRoZSBndXR0ZXJzIGFyZVxuZml4ZWQsIG1lYW5pbmcgdGhleSBkb24ndCBzY3JvbGwgYWxvbmcgd2l0aCB0aGUgY29udGVudFxuaG9yaXpvbnRhbGx5IChleGNlcHQgb24gSW50ZXJuZXQgRXhwbG9yZXIsIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydFxuQ1NTIFtgcG9zaXRpb246XG5zdGlja3lgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvcG9zaXRpb24jc3RpY2t5KSkuXG4qL1xuZnVuY3Rpb24gZ3V0dGVycyhjb25maWcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW1xuICAgICAgICBndXR0ZXJWaWV3LFxuICAgICAgICBiYXNlVGhlbWVcbiAgICBdO1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmZpeGVkID09PSBmYWxzZSlcbiAgICAgICAgcmVzdWx0LnB1c2godW5maXhHdXR0ZXJzLm9mKHRydWUpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZ3V0dGVyVmlldyA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnByZXZWaWV3cG9ydCA9IHZpZXcudmlld3BvcnQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJzXCI7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZ3V0dGVycyA9IHZpZXcuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycykubWFwKGNvbmYgPT4gbmV3IFNpbmdsZUd1dHRlclZpZXcodmlldywgY29uZikpO1xuICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZ3V0dGVyLmRvbSk7XG4gICAgICAgIHRoaXMuZml4ZWQgPSAhdmlldy5zdGF0ZS5mYWNldCh1bmZpeEd1dHRlcnMpO1xuICAgICAgICBpZiAodGhpcy5maXhlZCkge1xuICAgICAgICAgICAgLy8gRklYTUUgSUUxMSBmYWxsYmFjaywgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHBvc2l0aW9uOiBzdGlja3ksXG4gICAgICAgICAgICAvLyBieSB1c2luZyBwb3NpdGlvbjogcmVsYXRpdmUgKyBldmVudCBoYW5kbGVycyB0aGF0IHJlYWxpZ24gdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXIgKG9yIGp1c3QgZm9yY2UgZml4ZWQ9ZmFsc2Ugb24gSUUxMT8pXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5wb3NpdGlvbiA9IFwic3RpY2t5XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW5jR3V0dGVycyhmYWxzZSk7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdmlldy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVHdXR0ZXJzKHVwZGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIERldGFjaCBkdXJpbmcgc3luYyB3aGVuIHRoZSB2aWV3cG9ydCBjaGFuZ2VkIHNpZ25pZmljYW50bHlcbiAgICAgICAgICAgIC8vIChzdWNoIGFzIGR1cmluZyBzY3JvbGxpbmcpLCBzaW5jZSBmb3IgbGFyZ2UgdXBkYXRlcyB0aGF0IGlzXG4gICAgICAgICAgICAvLyBmYXN0ZXIuXG4gICAgICAgICAgICBsZXQgdnBBID0gdGhpcy5wcmV2Vmlld3BvcnQsIHZwQiA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICAgICAgbGV0IHZwT3ZlcmxhcCA9IE1hdGgubWluKHZwQS50bywgdnBCLnRvKSAtIE1hdGgubWF4KHZwQS5mcm9tLCB2cEIuZnJvbSk7XG4gICAgICAgICAgICB0aGlzLnN5bmNHdXR0ZXJzKHZwT3ZlcmxhcCA8ICh2cEIudG8gLSB2cEIuZnJvbSkgKiAwLjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKSAhPSAhdGhpcy5maXhlZCkge1xuICAgICAgICAgICAgdGhpcy5maXhlZCA9ICF0aGlzLmZpeGVkO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLmZpeGVkID8gXCJzdGlja3lcIiA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2Vmlld3BvcnQgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICB9XG4gICAgc3luY0d1dHRlcnMoZGV0YWNoKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMuZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIGxldCBsaW5lQ2xhc3NlcyA9IFJhbmdlU2V0Lml0ZXIodGhpcy52aWV3LnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHRoaXMudmlldy52aWV3cG9ydC5mcm9tKTtcbiAgICAgICAgbGV0IGNsYXNzU2V0ID0gW107XG4gICAgICAgIGxldCBjb250ZXh0cyA9IHRoaXMuZ3V0dGVycy5tYXAoZ3V0dGVyID0+IG5ldyBVcGRhdGVDb250ZXh0KGd1dHRlciwgdGhpcy52aWV3LnZpZXdwb3J0LCAtdGhpcy52aWV3LmRvY3VtZW50UGFkZGluZy50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXcudmlld3BvcnRMaW5lQmxvY2tzKSB7XG4gICAgICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiIG9mIGxpbmUudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGxpbmUudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IGxpbmUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRleHQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY2xhc3NTZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNsYXNzU2V0ID0gW107XG4gICAgICAgICAgICBhZHZhbmNlQ3Vyc29yKGxpbmVDbGFzc2VzLCBjbGFzc1NldCwgbGluZS5mcm9tKTtcbiAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgIGN4LmxpbmUodGhpcy52aWV3LCB0ZXh0LCBjbGFzc1NldCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICBjeC5maW5pc2goKTtcbiAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLCBhZnRlcik7XG4gICAgfVxuICAgIHVwZGF0ZUd1dHRlcnModXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2ID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyksIGN1ciA9IHVwZGF0ZS5zdGF0ZS5mYWNldChhY3RpdmVHdXR0ZXJzKTtcbiAgICAgICAgbGV0IGNoYW5nZSA9IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5oZWlnaHRDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHxcbiAgICAgICAgICAgICFSYW5nZVNldC5lcSh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB1cGRhdGUuc3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAocHJldiA9PSBjdXIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGd1dHRlciBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlci51cGRhdGUodXBkYXRlKSlcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZ3V0dGVycyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY29uZiBvZiBjdXIpIHtcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSBwcmV2LmluZGV4T2YoY29uZik7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBndXR0ZXJzLnB1c2gobmV3IFNpbmdsZUd1dHRlclZpZXcodGhpcy52aWV3LCBjb25mKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmd1dHRlcnNba25vd25dLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBndXR0ZXJzLnB1c2godGhpcy5ndXR0ZXJzW2tub3duXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiB0aGlzLmd1dHRlcnMpIHtcbiAgICAgICAgICAgICAgICBnLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3V0dGVycy5pbmRleE9mKGcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBnIG9mIGd1dHRlcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZy5kb20pO1xuICAgICAgICAgICAgdGhpcy5ndXR0ZXJzID0gZ3V0dGVycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogLypAX19QVVJFX18qL1BsdWdpbkZpZWxkLnNjcm9sbE1hcmdpbnMuZnJvbSh2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZS5ndXR0ZXJzLmxlbmd0aCA9PSAwIHx8ICF2YWx1ZS5maXhlZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdmFsdWUudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIgPyB7IGxlZnQ6IHZhbHVlLmRvbS5vZmZzZXRXaWR0aCB9IDogeyByaWdodDogdmFsdWUuZG9tLm9mZnNldFdpZHRoIH07XG4gICAgfSlcbn0pO1xuZnVuY3Rpb24gYXNBcnJheSh2YWwpIHsgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSk7IH1cbmZ1bmN0aW9uIGFkdmFuY2VDdXJzb3IoY3Vyc29yLCBjb2xsZWN0LCBwb3MpIHtcbiAgICB3aGlsZSAoY3Vyc29yLnZhbHVlICYmIGN1cnNvci5mcm9tIDw9IHBvcykge1xuICAgICAgICBpZiAoY3Vyc29yLmZyb20gPT0gcG9zKVxuICAgICAgICAgICAgY29sbGVjdC5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgfVxufVxuY2xhc3MgVXBkYXRlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoZ3V0dGVyLCB2aWV3cG9ydCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZ3V0dGVyID0gZ3V0dGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5sb2NhbE1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBSYW5nZVNldC5pdGVyKGd1dHRlci5tYXJrZXJzLCB2aWV3cG9ydC5mcm9tKTtcbiAgICB9XG4gICAgbGluZSh2aWV3LCBsaW5lLCBleHRyYU1hcmtlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxNYXJrZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubG9jYWxNYXJrZXJzID0gW107XG4gICAgICAgIGFkdmFuY2VDdXJzb3IodGhpcy5jdXJzb3IsIHRoaXMubG9jYWxNYXJrZXJzLCBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgbG9jYWxNYXJrZXJzID0gZXh0cmFNYXJrZXJzLmxlbmd0aCA/IHRoaXMubG9jYWxNYXJrZXJzLmNvbmNhdChleHRyYU1hcmtlcnMpIDogdGhpcy5sb2NhbE1hcmtlcnM7XG4gICAgICAgIGxldCBmb3JMaW5lID0gdGhpcy5ndXR0ZXIuY29uZmlnLmxpbmVNYXJrZXIodmlldywgbGluZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgaWYgKGZvckxpbmUpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMudW5zaGlmdChmb3JMaW5lKTtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICBpZiAobG9jYWxNYXJrZXJzLmxlbmd0aCA9PSAwICYmICFndXR0ZXIuY29uZmlnLnJlbmRlckVtcHR5RWxlbWVudHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBhYm92ZSA9IGxpbmUudG9wIC0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLmkgPT0gZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5ld0VsdCA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIGxpbmUuaGVpZ2h0LCBhYm92ZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgICAgIGd1dHRlci5lbGVtZW50cy5wdXNoKG5ld0VsdCk7XG4gICAgICAgICAgICBndXR0ZXIuZG9tLmFwcGVuZENoaWxkKG5ld0VsdC5kb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzW3RoaXMuaV0udXBkYXRlKHZpZXcsIGxpbmUuaGVpZ2h0LCBhYm92ZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlaWdodCA9IGxpbmUuYm90dG9tO1xuICAgICAgICB0aGlzLmkrKztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBsZXQgZ3V0dGVyID0gdGhpcy5ndXR0ZXI7XG4gICAgICAgIHdoaWxlIChndXR0ZXIuZWxlbWVudHMubGVuZ3RoID4gdGhpcy5pKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGd1dHRlci5lbGVtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIGd1dHRlci5kb20ucmVtb3ZlQ2hpbGQobGFzdC5kb20pO1xuICAgICAgICAgICAgbGFzdC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTaW5nbGVHdXR0ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zcGFjZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyXCIgKyAodGhpcy5jb25maWcuY2xhc3MgPyBcIiBcIiArIHRoaXMuY29uZmlnLmNsYXNzIDogXCJcIik7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gY29uZmlnLmRvbUV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIocHJvcCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0SGVpZ2h0KGV2ZW50LmNsaWVudFkgLSB2aWV3LmRvY3VtZW50VG9wKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRvbUV2ZW50SGFuZGxlcnNbcHJvcF0odmlldywgbGluZSwgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheShjb25maWcubWFya2Vycyh2aWV3KSk7XG4gICAgICAgIGlmIChjb25maWcuaW5pdGlhbFNwYWNlcikge1xuICAgICAgICAgICAgdGhpcy5zcGFjZXIgPSBuZXcgR3V0dGVyRWxlbWVudCh2aWV3LCAwLCAwLCBbY29uZmlnLmluaXRpYWxTcGFjZXIodmlldyldKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc3BhY2VyLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnNwYWNlci5kb20uc3R5bGUuY3NzVGV4dCArPSBcInZpc2liaWxpdHk6IGhpZGRlbjsgcG9pbnRlci1ldmVudHM6IG5vbmVcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2TWFya2VycyA9IHRoaXMubWFya2VycztcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheSh0aGlzLmNvbmZpZy5tYXJrZXJzKHVwZGF0ZS52aWV3KSk7XG4gICAgICAgIGlmICh0aGlzLnNwYWNlciAmJiB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5jb25maWcudXBkYXRlU3BhY2VyKHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0sIHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlZCAhPSB0aGlzLnNwYWNlci5tYXJrZXJzWzBdKVxuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VyLnVwZGF0ZSh1cGRhdGUudmlldywgMCwgMCwgW3VwZGF0ZWRdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdnAgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgcmV0dXJuICFSYW5nZVNldC5lcSh0aGlzLm1hcmtlcnMsIHByZXZNYXJrZXJzLCB2cC5mcm9tLCB2cC50bykgfHxcbiAgICAgICAgICAgICh0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlID8gdGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSh1cGRhdGUpIDogZmFsc2UpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5lbGVtZW50cylcbiAgICAgICAgICAgIGVsdC5kZXN0cm95KCk7XG4gICAgfVxufVxuY2xhc3MgR3V0dGVyRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICB0aGlzLmhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLmFib3ZlID0gMDtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPSBoZWlnaHQpXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSAodGhpcy5oZWlnaHQgPSBoZWlnaHQpICsgXCJweFwiO1xuICAgICAgICBpZiAodGhpcy5hYm92ZSAhPSBhYm92ZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1hcmdpblRvcCA9ICh0aGlzLmFib3ZlID0gYWJvdmUpID8gYWJvdmUgKyBcInB4XCIgOiBcIlwiO1xuICAgICAgICBpZiAoIXNhbWVNYXJrZXJzKHRoaXMubWFya2VycywgbWFya2VycykpXG4gICAgICAgICAgICB0aGlzLnNldE1hcmtlcnModmlldywgbWFya2Vycyk7XG4gICAgfVxuICAgIHNldE1hcmtlcnModmlldywgbWFya2Vycykge1xuICAgICAgICBsZXQgY2xzID0gXCJjbS1ndXR0ZXJFbGVtZW50XCIsIGRvbVBvcyA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZvciAobGV0IGlOZXcgPSAwLCBpT2xkID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgc2tpcFRvID0gaU9sZCwgbWFya2VyID0gaU5ldyA8IG1hcmtlcnMubGVuZ3RoID8gbWFya2Vyc1tpTmV3KytdIDogbnVsbCwgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICAgICAgICAgIGxldCBjID0gbWFya2VyLmVsZW1lbnRDbGFzcztcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiICsgYztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaU9sZDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2Vyc1tpXS5jb21wYXJlKG1hcmtlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUbyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBza2lwVG8gPSB0aGlzLm1hcmtlcnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGlPbGQgPCBza2lwVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubWFya2Vyc1tpT2xkKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuZGVzdHJveShkb21Qb3MpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBkb21Qb3MubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gYWZ0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobWFya2VyLnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpXG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcyA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIudG9ET00odmlldyksIGRvbVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICBpT2xkKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gY2xzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBtYXJrZXJzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldE1hcmtlcnMobnVsbCwgW10pOyAvLyBGaXJzdCBhcmd1bWVudCBub3QgdXNlZCB1bmxlc3MgY3JlYXRpbmcgbWFya2Vyc1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVNYXJrZXJzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5jb21wYXJlKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5GYWNldCB1c2VkIHRvIHByb3ZpZGUgbWFya2VycyB0byB0aGUgbGluZSBudW1iZXIgZ3V0dGVyLlxuKi9cbmNvbnN0IGxpbmVOdW1iZXJNYXJrZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgbGluZU51bWJlckNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKHZhbHVlcywgeyBmb3JtYXROdW1iZXI6IFN0cmluZywgZG9tRXZlbnRIYW5kbGVyczoge30gfSwge1xuICAgICAgICAgICAgZG9tRXZlbnRIYW5kbGVycyhhLCBiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIGEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGV2ZW50IGluIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV4aXN0cyA9IHJlc3VsdFtldmVudF0sIGFkZCA9IGJbZXZlbnRdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZXZlbnRdID0gZXhpc3RzID8gKHZpZXcsIGxpbmUsIGV2ZW50KSA9PiBleGlzdHModmlldywgbGluZSwgZXZlbnQpIHx8IGFkZCh2aWV3LCBsaW5lLCBldmVudCkgOiBhZGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY2xhc3MgTnVtYmVyTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcihudW1iZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLm51bWJlciA9PSBvdGhlci5udW1iZXI7IH1cbiAgICB0b0RPTSgpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMubnVtYmVyKTsgfVxufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKHZpZXcsIG51bWJlcikge1xuICAgIHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLmZvcm1hdE51bWJlcihudW1iZXIsIHZpZXcuc3RhdGUpO1xufVxuY29uc3QgbGluZU51bWJlckd1dHRlciA9IC8qQF9fUFVSRV9fKi9hY3RpdmVHdXR0ZXJzLmNvbXB1dGUoW2xpbmVOdW1iZXJDb25maWddLCBzdGF0ZSA9PiAoe1xuICAgIGNsYXNzOiBcImNtLWxpbmVOdW1iZXJzXCIsXG4gICAgcmVuZGVyRW1wdHlFbGVtZW50czogZmFsc2UsXG4gICAgbWFya2Vycyh2aWV3KSB7IHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJNYXJrZXJzKTsgfSxcbiAgICBsaW5lTWFya2VyKHZpZXcsIGxpbmUsIG90aGVycykge1xuICAgICAgICBpZiAob3RoZXJzLnNvbWUobSA9PiBtLnRvRE9NKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck1hcmtlcihmb3JtYXROdW1iZXIodmlldywgdmlldy5zdGF0ZS5kb2MubGluZUF0KGxpbmUuZnJvbSkubnVtYmVyKSk7XG4gICAgfSxcbiAgICBsaW5lTWFya2VyQ2hhbmdlOiB1cGRhdGUgPT4gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLFxuICAgIGluaXRpYWxTcGFjZXIodmlldykge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck1hcmtlcihmb3JtYXROdW1iZXIodmlldywgbWF4TGluZU51bWJlcih2aWV3LnN0YXRlLmRvYy5saW5lcykpKTtcbiAgICB9LFxuICAgIHVwZGF0ZVNwYWNlcihzcGFjZXIsIHVwZGF0ZSkge1xuICAgICAgICBsZXQgbWF4ID0gZm9ybWF0TnVtYmVyKHVwZGF0ZS52aWV3LCBtYXhMaW5lTnVtYmVyKHVwZGF0ZS52aWV3LnN0YXRlLmRvYy5saW5lcykpO1xuICAgICAgICByZXR1cm4gbWF4ID09IHNwYWNlci5udW1iZXIgPyBzcGFjZXIgOiBuZXcgTnVtYmVyTWFya2VyKG1heCk7XG4gICAgfSxcbiAgICBkb21FdmVudEhhbmRsZXJzOiBzdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKS5kb21FdmVudEhhbmRsZXJzXG59KSk7XG4vKipcbkNyZWF0ZSBhIGxpbmUgbnVtYmVyIGd1dHRlciBleHRlbnNpb24uXG4qL1xuZnVuY3Rpb24gbGluZU51bWJlcnMoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBsaW5lTnVtYmVyQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGd1dHRlcnMoKSxcbiAgICAgICAgbGluZU51bWJlckd1dHRlclxuICAgIF07XG59XG5mdW5jdGlvbiBtYXhMaW5lTnVtYmVyKGxpbmVzKSB7XG4gICAgbGV0IGxhc3QgPSA5O1xuICAgIHdoaWxlIChsYXN0IDwgbGluZXMpXG4gICAgICAgIGxhc3QgPSBsYXN0ICogMTAgKyA5O1xuICAgIHJldHVybiBsYXN0O1xufVxuY29uc3QgYWN0aXZlTGluZUd1dHRlck1hcmtlciA9IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmVsZW1lbnRDbGFzcyA9IFwiY20tYWN0aXZlTGluZUd1dHRlclwiO1xuICAgIH1cbn07XG5jb25zdCBhY3RpdmVMaW5lR3V0dGVySGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovZ3V0dGVyTGluZUNsYXNzLmNvbXB1dGUoW1wic2VsZWN0aW9uXCJdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IG1hcmtzID0gW10sIGxhc3QgPSAtMTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKVxuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBsaW5lUG9zID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5oZWFkKS5mcm9tO1xuICAgICAgICAgICAgaWYgKGxpbmVQb3MgPiBsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IGxpbmVQb3M7XG4gICAgICAgICAgICAgICAgbWFya3MucHVzaChhY3RpdmVMaW5lR3V0dGVyTWFya2VyLnJhbmdlKGxpbmVQb3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIHJldHVybiBSYW5nZVNldC5vZihtYXJrcyk7XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIGEgYGNtLWFjdGl2ZUxpbmVHdXR0ZXJgIGNsYXNzIHRvXG5hbGwgZ3V0dGVyIGVsZW1lbnRzIG9uIHRoZSBbYWN0aXZlXG5saW5lXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0QWN0aXZlTGluZSkuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlcigpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyO1xufVxuXG5leHBvcnQgeyBHdXR0ZXJNYXJrZXIsIGd1dHRlciwgZ3V0dGVyTGluZUNsYXNzLCBndXR0ZXJzLCBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyLCBsaW5lTnVtYmVyTWFya2VycywgbGluZU51bWJlcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/gutter/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/highlight/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@codemirror/highlight/dist/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HighlightStyle\": function() { return /* binding */ HighlightStyle; },\n/* harmony export */   \"Tag\": function() { return /* binding */ Tag; },\n/* harmony export */   \"classHighlightStyle\": function() { return /* binding */ classHighlightStyle; },\n/* harmony export */   \"defaultHighlightStyle\": function() { return /* binding */ defaultHighlightStyle; },\n/* harmony export */   \"highlightTree\": function() { return /* binding */ highlightTree; },\n/* harmony export */   \"styleTags\": function() { return /* binding */ styleTags; },\n/* harmony export */   \"tags\": function() { return /* binding */ tags; }\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! style-mod */ \"./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/rangeset */ \"./node_modules/@codemirror/rangeset/dist/index.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\nvar nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](https://codemirror.net/6/docs/ref/#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlight style](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](https://codemirror.net/6/docs/ref/#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](https://codemirror.net/6/docs/ref/#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/\n\nvar Tag = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function Tag(\n  /**\n  The set of tags that match this tag, starting with this one\n  itself, sorted in order of decreasing specificity. @internal\n  */\n  set,\n  /**\n  The base unmodified tag that this one is based on, if it's\n  modified @internal\n  */\n  base,\n  /**\n  The modifiers applied to this.base @internal\n  */\n  modified) {\n    _classCallCheck(this, Tag);\n\n    this.set = set;\n    this.base = base;\n    this.modified = modified;\n    /**\n    @internal\n    */\n\n    this.id = nextTagID++;\n  }\n  /**\n  Define a new tag. If `parent` is given, the tag is treated as a\n  sub-tag of that parent, and [highlight\n  styles](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle) that don't mention this tag\n  will try to fall back to the parent tag (or grandparent tag,\n  etc).\n  */\n\n\n  _createClass(Tag, null, [{\n    key: \"define\",\n    value: function define(parent) {\n      if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n      var tag = new Tag([], null, []);\n      tag.set.push(tag);\n\n      if (parent) {\n        var _iterator = _createForOfIteratorHelper(parent.set),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _t = _step.value;\n            tag.set.push(_t);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */\n\n  }, {\n    key: \"defineModifier\",\n    value: function defineModifier() {\n      var mod = new Modifier();\n      return function (tag) {\n        if (tag.modified.indexOf(mod) > -1) return tag;\n        return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort(function (a, b) {\n          return a.id - b.id;\n        }));\n      };\n    }\n  }]);\n\n  return Tag;\n}();\n\nvar nextModifierID = 0;\n\nvar Modifier = /*#__PURE__*/function () {\n  function Modifier() {\n    _classCallCheck(this, Modifier);\n\n    this.instances = [];\n    this.id = nextModifierID++;\n  }\n\n  _createClass(Modifier, null, [{\n    key: \"get\",\n    value: function get(base, mods) {\n      if (!mods.length) return base;\n      var exists = mods[0].instances.find(function (t) {\n        return t.base == base && sameArray(mods, t.modified);\n      });\n      if (exists) return exists;\n      var set = [],\n          tag = new Tag(set, base, mods);\n\n      var _iterator2 = _createForOfIteratorHelper(mods),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var m = _step2.value;\n          m.instances.push(tag);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var configs = permute(mods);\n\n      var _iterator3 = _createForOfIteratorHelper(base.set),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var parent = _step3.value;\n\n          var _iterator4 = _createForOfIteratorHelper(configs),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var config = _step4.value;\n              set.push(Modifier.get(parent, config));\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return tag;\n    }\n  }]);\n\n  return Modifier;\n}();\n\nfunction sameArray(a, b) {\n  return a.length == b.length && a.every(function (x, i) {\n    return x == b[i];\n  });\n}\n\nfunction permute(array) {\n  var result = [array];\n\n  for (var i = 0; i < array.length; i++) {\n    var _iterator5 = _createForOfIteratorHelper(permute(array.slice(0, i).concat(array.slice(i + 1)))),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var a = _step5.value;\n        result.push(a);\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n\n  return result;\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia\n[`LRParser.configure`](https://lezer.codemirror.net/docs/ref#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](https://codemirror.net/6/docs/ref/#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node\nname](https://lezer.codemirror.net/docs/ref#common.NodeType.name),\nor multiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single levelâ€”wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.withProps(\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n)\n```\n*/\n\n\nfunction styleTags(spec) {\n  var byName = Object.create(null);\n\n  for (var prop in spec) {\n    var _tags = spec[prop];\n    if (!Array.isArray(_tags)) _tags = [_tags];\n\n    var _iterator6 = _createForOfIteratorHelper(prop.split(\" \")),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var part = _step6.value;\n\n        if (part) {\n          var pieces = [],\n              mode = 2\n          /* Normal */\n          ,\n              rest = part;\n\n          for (var pos = 0;;) {\n            if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n              mode = 1\n              /* Inherit */\n              ;\n              break;\n            }\n\n            var m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n            if (!m) throw new RangeError(\"Invalid path: \" + part);\n            pieces.push(m[0] == \"*\" ? null : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n            pos += m[0].length;\n            if (pos == part.length) break;\n            var next = part[pos++];\n\n            if (pos == part.length && next == \"!\") {\n              mode = 0\n              /* Opaque */\n              ;\n              break;\n            }\n\n            if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n            rest = part.slice(pos);\n          }\n\n          var last = pieces.length - 1,\n              inner = pieces[last];\n          if (!inner) throw new RangeError(\"Invalid path: \" + part);\n          var rule = new Rule(_tags, mode, last > 0 ? pieces.slice(0, last) : null);\n          byName[inner] = rule.sort(byName[inner]);\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  }\n\n  return ruleNodeProp.add(byName);\n}\n\nvar ruleNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nvar highlightStyle = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: function combine(stylings) {\n    return stylings.length ? HighlightStyle.combinedMatch(stylings) : null;\n  }\n});\nvar fallbackHighlightStyle = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: function combine(values) {\n    return values.length ? values[0].match : null;\n  }\n});\n\nfunction getHighlightStyle(state) {\n  return state.facet(highlightStyle) || state.facet(fallbackHighlightStyle);\n}\n\nvar Rule = /*#__PURE__*/function () {\n  function Rule(tags, mode, context, next) {\n    _classCallCheck(this, Rule);\n\n    this.tags = tags;\n    this.mode = mode;\n    this.context = context;\n    this.next = next;\n  }\n\n  _createClass(Rule, [{\n    key: \"sort\",\n    value: function sort(other) {\n      if (!other || other.depth < this.depth) {\n        this.next = other;\n        return this;\n      }\n\n      other.next = this.sort(other.next);\n      return other;\n    }\n  }, {\n    key: \"depth\",\n    get: function get() {\n      return this.context ? this.context.length : 0;\n    }\n  }]);\n\n  return Rule;\n}();\n/**\nA highlight style associates CSS styles with higlighting\n[tags](https://codemirror.net/6/docs/ref/#highlight.Tag).\n*/\n\n\nvar HighlightStyle = /*#__PURE__*/function () {\n  function HighlightStyle(spec, options) {\n    _classCallCheck(this, HighlightStyle);\n\n    this.map = Object.create(null);\n    var modSpec;\n\n    function def(spec) {\n      var cls = style_mod__WEBPACK_IMPORTED_MODULE_1__.StyleModule.newName();\n      (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n      return cls;\n    }\n\n    this.all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : null;\n\n    var _iterator7 = _createForOfIteratorHelper(spec),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var style = _step7.value;\n        var cls = (style[\"class\"] || def(Object.assign({}, style, {\n          tag: null\n        }))) + (this.all ? \" \" + this.all : \"\");\n        var _tags2 = style.tag;\n        if (!Array.isArray(_tags2)) this.map[_tags2.id] = cls;else {\n          var _iterator8 = _createForOfIteratorHelper(_tags2),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var tag = _step8.value;\n              this.map[tag.id] = cls;\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_1__.StyleModule(modSpec) : null;\n    this.scope = options.scope || null;\n    this.match = this.match.bind(this);\n    var ext = [treeHighlighter];\n    if (this.module) ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.styleModule.of(this.module));\n    this.extension = ext.concat(highlightStyle.of(this));\n    this.fallback = ext.concat(fallbackHighlightStyle.of(this));\n  }\n  /**\n  Returns the CSS class associated with the given tag, if any.\n  This method is bound to the instance by the constructor.\n  */\n\n\n  _createClass(HighlightStyle, [{\n    key: \"match\",\n    value: function match(tag, scope) {\n      if (this.scope && scope != this.scope) return null;\n\n      var _iterator9 = _createForOfIteratorHelper(tag.set),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _t2 = _step9.value;\n          var match = this.map[_t2.id];\n\n          if (match !== undefined) {\n            if (_t2 != tag) this.map[tag.id] = match;\n            return match;\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      return this.map[tag.id] = this.all;\n    }\n    /**\n    Combines an array of highlight styles into a single match\n    function that returns all of the classes assigned by the styles\n    for a given tag.\n    */\n\n  }], [{\n    key: \"combinedMatch\",\n    value: function combinedMatch(styles) {\n      if (styles.length == 1) return styles[0].match;\n      var cache = styles.some(function (s) {\n        return s.scope;\n      }) ? undefined : Object.create(null);\n      return function (tag, scope) {\n        var cached = cache && cache[tag.id];\n        if (cached !== undefined) return cached;\n        var result = null;\n\n        var _iterator10 = _createForOfIteratorHelper(styles),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var style = _step10.value;\n            var value = style.match(tag, scope);\n            if (value) result = result ? result + \" \" + value : value;\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n\n        if (cache) cache[tag.id] = result;\n        return result;\n      };\n    }\n    /**\n    Create a highlighter style that associates the given styles to\n    the given tags. The spec must be objects that hold a style tag\n    or array of tags in their `tag` property, and either a single\n    `class` property providing a static CSS class (for highlighters\n    like [`classHighlightStyle`](https://codemirror.net/6/docs/ref/#highlight.classHighlightStyle)\n    that rely on external styling), or a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n    set of CSS properties (which define the styling for those tags).\n    \n    The CSS rules created for a highlighter will be emitted in the\n    order of the spec's properties. That means that for elements that\n    have multiple tags associated with them, styles defined further\n    down in the list will have a higher CSS precedence than styles\n    defined earlier.\n    */\n\n  }, {\n    key: \"define\",\n    value: function define(specs, options) {\n      return new HighlightStyle(specs, options || {});\n    }\n    /**\n    Returns the CSS classes (if any) that the highlight styles\n    active in the given state would assign to the given a style\n    [tag](https://codemirror.net/6/docs/ref/#highlight.Tag) and (optional) language\n    [scope](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle^define^options.scope).\n    */\n\n  }, {\n    key: \"get\",\n    value: function get(state, tag, scope) {\n      var style = getHighlightStyle(state);\n      return style && style(tag, scope || _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none);\n    }\n  }]);\n\n  return HighlightStyle;\n}();\n/**\nRun the tree highlighter over the given tree.\n*/\n\n\nfunction highlightTree(tree,\n/**\nGet the CSS classes used to style a given [tag](https://codemirror.net/6/docs/ref/#highlight.Tag),\nor `null` if it isn't styled. (You'll often want to pass a\nhighlight style's [`match`](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle.match)\nmethod here.)\n*/\ngetStyle,\n/**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/\nputStyle) {\n  var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : tree.length;\n  highlightTreeRange(tree, from, to, getStyle, putStyle);\n}\n\nvar TreeHighlighter = /*#__PURE__*/function () {\n  function TreeHighlighter(view) {\n    _classCallCheck(this, TreeHighlighter);\n\n    this.markCache = Object.create(null);\n    this.tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_4__.syntaxTree)(view.state);\n    this.decorations = this.buildDeco(view, getHighlightStyle(view.state));\n  }\n\n  _createClass(TreeHighlighter, [{\n    key: \"update\",\n    value: function update(_update) {\n      var tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_4__.syntaxTree)(_update.state),\n          style = getHighlightStyle(_update.state);\n\n      var styleChange = style != _update.startState.facet(highlightStyle);\n\n      if (tree.length < _update.view.viewport.to && !styleChange && tree.type == this.tree.type) {\n        this.decorations = this.decorations.map(_update.changes);\n      } else if (tree != this.tree || _update.viewportChanged || styleChange) {\n        this.tree = tree;\n        this.decorations = this.buildDeco(_update.view, style);\n      }\n    }\n  }, {\n    key: \"buildDeco\",\n    value: function buildDeco(view, match) {\n      var _this = this;\n\n      if (!match || !this.tree.length) return _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.none;\n      var builder = new _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_5__.RangeSetBuilder();\n\n      var _iterator11 = _createForOfIteratorHelper(view.visibleRanges),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var _step11$value = _step11.value,\n              from = _step11$value.from,\n              to = _step11$value.to;\n          highlightTreeRange(this.tree, from, to, match, function (from, to, style) {\n            builder.add(from, to, _this.markCache[style] || (_this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.mark({\n              \"class\": style\n            })));\n          });\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      return builder.finish();\n    }\n  }]);\n\n  return TreeHighlighter;\n}(); // This extension installs a highlighter that highlights based on the\n// syntax tree and highlight style.\n\n\nvar treeHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.high( /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.ViewPlugin.fromClass(TreeHighlighter, {\n  decorations: function decorations(v) {\n    return v.decorations;\n  }\n}));\nvar nodeStack = [\"\"];\n\nvar HighlightBuilder = /*#__PURE__*/function () {\n  function HighlightBuilder(at, style, span) {\n    _classCallCheck(this, HighlightBuilder);\n\n    this.at = at;\n    this.style = style;\n    this.span = span;\n    this[\"class\"] = \"\";\n  }\n\n  _createClass(HighlightBuilder, [{\n    key: \"startSpan\",\n    value: function startSpan(at, cls) {\n      if (cls != this[\"class\"]) {\n        this.flush(at);\n        if (at > this.at) this.at = at;\n        this[\"class\"] = cls;\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush(to) {\n      if (to > this.at && this[\"class\"]) this.span(this.at, to, this[\"class\"]);\n    }\n  }, {\n    key: \"highlightRange\",\n    value: function highlightRange(cursor, from, to, inheritedClass, depth, scope) {\n      var type = cursor.type,\n          start = cursor.from,\n          end = cursor.to;\n      if (start >= to || end <= from) return;\n      nodeStack[depth] = type.name;\n      if (type.isTop) scope = type;\n      var cls = inheritedClass;\n      var rule = type.prop(ruleNodeProp),\n          opaque = false;\n\n      while (rule) {\n        if (!rule.context || matchContext(rule.context, nodeStack, depth)) {\n          var _iterator12 = _createForOfIteratorHelper(rule.tags),\n              _step12;\n\n          try {\n            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n              var tag = _step12.value;\n              var st = this.style(tag, scope);\n\n              if (st) {\n                if (cls) cls += \" \";\n                cls += st;\n                if (rule.mode == 1\n                /* Inherit */\n                ) inheritedClass += (inheritedClass ? \" \" : \"\") + st;else if (rule.mode == 0\n                /* Opaque */\n                ) opaque = true;\n              }\n            }\n          } catch (err) {\n            _iterator12.e(err);\n          } finally {\n            _iterator12.f();\n          }\n\n          break;\n        }\n\n        rule = rule.next;\n      }\n\n      this.startSpan(cursor.from, cls);\n      if (opaque) return;\n      var mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n\n      if (mounted && mounted.overlay) {\n        var inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n        var hasChild = cursor.firstChild();\n\n        for (var i = 0, pos = start;; i++) {\n          var next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n          var nextPos = next ? next.from + start : end;\n          var rangeFrom = Math.max(from, pos),\n              rangeTo = Math.min(to, nextPos);\n\n          if (rangeFrom < rangeTo && hasChild) {\n            while (cursor.from < rangeTo) {\n              this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, depth + 1, scope);\n              this.startSpan(Math.min(to, cursor.to), cls);\n              if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n            }\n          }\n\n          if (!next || nextPos > to) break;\n          pos = next.to + start;\n\n          if (pos > from) {\n            this.highlightRange(inner.cursor, Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, depth, mounted.tree.type);\n            this.startSpan(pos, cls);\n          }\n        }\n\n        if (hasChild) cursor.parent();\n      } else if (cursor.firstChild()) {\n        do {\n          if (cursor.to <= from) continue;\n          if (cursor.from >= to) break;\n          this.highlightRange(cursor, from, to, inheritedClass, depth + 1, scope);\n          this.startSpan(Math.min(to, cursor.to), cls);\n        } while (cursor.nextSibling());\n\n        cursor.parent();\n      }\n    }\n  }]);\n\n  return HighlightBuilder;\n}();\n\nfunction highlightTreeRange(tree, from, to, style, span) {\n  var builder = new HighlightBuilder(from, style, span);\n  builder.highlightRange(tree.cursor(), from, to, \"\", 0, tree.type);\n  builder.flush(to);\n}\n\nfunction matchContext(context, stack, depth) {\n  if (context.length > depth - 1) return false;\n\n  for (var d = depth - 1, i = context.length - 1; i >= 0; i--, d--) {\n    var check = context[i];\n    if (check && check != stack[d]) return false;\n  }\n\n  return true;\n}\n\nvar t = Tag.define;\nvar comment = /*@__PURE__*/t(),\n    name = /*@__PURE__*/t(),\n    typeName = /*@__PURE__*/t(name),\n    propertyName = /*@__PURE__*/t(name),\n    literal = /*@__PURE__*/t(),\n    string = /*@__PURE__*/t(literal),\n    number = /*@__PURE__*/t(literal),\n    content = /*@__PURE__*/t(),\n    heading = /*@__PURE__*/t(content),\n    keyword = /*@__PURE__*/t(),\n    operator = /*@__PURE__*/t(),\n    punctuation = /*@__PURE__*/t(),\n    bracket = /*@__PURE__*/t(punctuation),\n    meta = /*@__PURE__*/t();\n/**\nThe default set of highlighting [tags](https://codemirror.net/6/docs/ref/#highlight.Tag^define) used\nby regular language packages and themes.\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](https://codemirror.net/6/docs/ref/#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an elementâ€”if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/\n\nvar tags = {\n  /**\n  A comment.\n  */\n  comment: comment,\n\n  /**\n  A line [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).\n  */\n  lineComment: /*@__PURE__*/t(comment),\n\n  /**\n  A block [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).\n  */\n  blockComment: /*@__PURE__*/t(comment),\n\n  /**\n  A documentation [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).\n  */\n  docComment: /*@__PURE__*/t(comment),\n\n  /**\n  Any kind of identifier.\n  */\n  name: name,\n\n  /**\n  The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a variable.\n  */\n  variableName: /*@__PURE__*/t(name),\n\n  /**\n  A type [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).\n  */\n  typeName: typeName,\n\n  /**\n  A tag name (subtag of [`typeName`](https://codemirror.net/6/docs/ref/#highlight.tags.typeName)).\n  */\n  tagName: /*@__PURE__*/t(typeName),\n\n  /**\n  A property or field [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).\n  */\n  propertyName: propertyName,\n\n  /**\n  An attribute name (subtag of [`propertyName`](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName)).\n  */\n  attributeName: /*@__PURE__*/t(propertyName),\n\n  /**\n  The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a class.\n  */\n  className: /*@__PURE__*/t(name),\n\n  /**\n  A label [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).\n  */\n  labelName: /*@__PURE__*/t(name),\n\n  /**\n  A namespace [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).\n  */\n  namespace: /*@__PURE__*/t(name),\n\n  /**\n  The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a macro.\n  */\n  macroName: /*@__PURE__*/t(name),\n\n  /**\n  A literal value.\n  */\n  literal: literal,\n\n  /**\n  A string [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n  */\n  string: string,\n\n  /**\n  A documentation [string](https://codemirror.net/6/docs/ref/#highlight.tags.string).\n  */\n  docString: /*@__PURE__*/t(string),\n\n  /**\n  A character literal (subtag of [string](https://codemirror.net/6/docs/ref/#highlight.tags.string)).\n  */\n  character: /*@__PURE__*/t(string),\n\n  /**\n  An attribute value (subtag of [string](https://codemirror.net/6/docs/ref/#highlight.tags.string)).\n  */\n  attributeValue: /*@__PURE__*/t(string),\n\n  /**\n  A number [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n  */\n  number: number,\n\n  /**\n  An integer [number](https://codemirror.net/6/docs/ref/#highlight.tags.number) literal.\n  */\n  integer: /*@__PURE__*/t(number),\n\n  /**\n  A floating-point [number](https://codemirror.net/6/docs/ref/#highlight.tags.number) literal.\n  */\n  \"float\": /*@__PURE__*/t(number),\n\n  /**\n  A boolean [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n  */\n  bool: /*@__PURE__*/t(literal),\n\n  /**\n  Regular expression [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n  */\n  regexp: /*@__PURE__*/t(literal),\n\n  /**\n  An escape [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal), for example a\n  backslash escape in a string.\n  */\n  escape: /*@__PURE__*/t(literal),\n\n  /**\n  A color [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n  */\n  color: /*@__PURE__*/t(literal),\n\n  /**\n  A URL [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n  */\n  url: /*@__PURE__*/t(literal),\n\n  /**\n  A language keyword.\n  */\n  keyword: keyword,\n\n  /**\n  The [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) for the self or this\n  object.\n  */\n  self: /*@__PURE__*/t(keyword),\n\n  /**\n  The [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) for null.\n  */\n  \"null\": /*@__PURE__*/t(keyword),\n\n  /**\n  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) denoting some atomic value.\n  */\n  atom: /*@__PURE__*/t(keyword),\n\n  /**\n  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that represents a unit.\n  */\n  unit: /*@__PURE__*/t(keyword),\n\n  /**\n  A modifier [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword).\n  */\n  modifier: /*@__PURE__*/t(keyword),\n\n  /**\n  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that acts as an operator.\n  */\n  operatorKeyword: /*@__PURE__*/t(keyword),\n\n  /**\n  A control-flow related [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword).\n  */\n  controlKeyword: /*@__PURE__*/t(keyword),\n\n  /**\n  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that defines something.\n  */\n  definitionKeyword: /*@__PURE__*/t(keyword),\n\n  /**\n  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) related to defining or\n  interfacing with modules.\n  */\n  moduleKeyword: /*@__PURE__*/t(keyword),\n\n  /**\n  An operator.\n  */\n  operator: operator,\n\n  /**\n  An [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that defines something.\n  */\n  derefOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Arithmetic-related [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n  */\n  arithmeticOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Logical [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n  */\n  logicOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Bit [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n  */\n  bitwiseOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Comparison [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n  */\n  compareOperator: /*@__PURE__*/t(operator),\n\n  /**\n  [Operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that updates its operand.\n  */\n  updateOperator: /*@__PURE__*/t(operator),\n\n  /**\n  [Operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that defines something.\n  */\n  definitionOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Type-related [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n  */\n  typeOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Control-flow [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n  */\n  controlOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Program or markup punctuation.\n  */\n  punctuation: punctuation,\n\n  /**\n  [Punctuation](https://codemirror.net/6/docs/ref/#highlight.tags.punctuation) that separates\n  things.\n  */\n  separator: /*@__PURE__*/t(punctuation),\n\n  /**\n  Bracket-style [punctuation](https://codemirror.net/6/docs/ref/#highlight.tags.punctuation).\n  */\n  bracket: bracket,\n\n  /**\n  Angle [brackets](https://codemirror.net/6/docs/ref/#highlight.tags.bracket) (usually `<` and `>`\n  tokens).\n  */\n  angleBracket: /*@__PURE__*/t(bracket),\n\n  /**\n  Square [brackets](https://codemirror.net/6/docs/ref/#highlight.tags.bracket) (usually `[` and `]`\n  tokens).\n  */\n  squareBracket: /*@__PURE__*/t(bracket),\n\n  /**\n  Parentheses (usually `(` and `)` tokens). Subtag of\n  [bracket](https://codemirror.net/6/docs/ref/#highlight.tags.bracket).\n  */\n  paren: /*@__PURE__*/t(bracket),\n\n  /**\n  Braces (usually `{` and `}` tokens). Subtag of\n  [bracket](https://codemirror.net/6/docs/ref/#highlight.tags.bracket).\n  */\n  brace: /*@__PURE__*/t(bracket),\n\n  /**\n  Content, for example plain text in XML or markup documents.\n  */\n  content: content,\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a heading.\n  */\n  heading: heading,\n\n  /**\n  A level 1 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n  */\n  heading1: /*@__PURE__*/t(heading),\n\n  /**\n  A level 2 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n  */\n  heading2: /*@__PURE__*/t(heading),\n\n  /**\n  A level 3 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n  */\n  heading3: /*@__PURE__*/t(heading),\n\n  /**\n  A level 4 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n  */\n  heading4: /*@__PURE__*/t(heading),\n\n  /**\n  A level 5 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n  */\n  heading5: /*@__PURE__*/t(heading),\n\n  /**\n  A level 6 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n  */\n  heading6: /*@__PURE__*/t(heading),\n\n  /**\n  A prose separator (such as a horizontal rule).\n  */\n  contentSeparator: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a list.\n  */\n  list: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a quote.\n  */\n  quote: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is emphasized.\n  */\n  emphasis: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is styled strong.\n  */\n  strong: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is part of a link.\n  */\n  link: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is styled as code or\n  monospace.\n  */\n  monospace: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that has a strike-through\n  style.\n  */\n  strikethrough: /*@__PURE__*/t(content),\n\n  /**\n  Inserted text in a change-tracking format.\n  */\n  inserted: /*@__PURE__*/t(),\n\n  /**\n  Deleted text.\n  */\n  deleted: /*@__PURE__*/t(),\n\n  /**\n  Changed text.\n  */\n  changed: /*@__PURE__*/t(),\n\n  /**\n  An invalid or unsyntactic element.\n  */\n  invalid: /*@__PURE__*/t(),\n\n  /**\n  Metadata or meta-instruction.\n  */\n  meta: meta,\n\n  /**\n  [Metadata](https://codemirror.net/6/docs/ref/#highlight.tags.meta) that applies to the entire\n  document.\n  */\n  documentMeta: /*@__PURE__*/t(meta),\n\n  /**\n  [Metadata](https://codemirror.net/6/docs/ref/#highlight.tags.meta) that annotates or adds\n  attributes to a given syntactic element.\n  */\n  annotation: /*@__PURE__*/t(meta),\n\n  /**\n  Processing instruction or preprocessor directive. Subtag of\n  [meta](https://codemirror.net/6/docs/ref/#highlight.tags.meta).\n  */\n  processingInstruction: /*@__PURE__*/t(meta),\n\n  /**\n  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates that a\n  given element is being defined. Expected to be used with the\n  various [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) tags.\n  */\n  definition: /*@__PURE__*/Tag.defineModifier(),\n\n  /**\n  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates that\n  something is constant. Mostly expected to be used with\n  [variable names](https://codemirror.net/6/docs/ref/#highlight.tags.variableName).\n  */\n  constant: /*@__PURE__*/Tag.defineModifier(),\n\n  /**\n  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) used to indicate that\n  a [variable](https://codemirror.net/6/docs/ref/#highlight.tags.variableName) or [property\n  name](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName) is being called or defined\n  as a function.\n  */\n  \"function\": /*@__PURE__*/Tag.defineModifier(),\n\n  /**\n  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that can be applied to\n  [names](https://codemirror.net/6/docs/ref/#highlight.tags.name) to indicate that they belong to\n  the language's standard environment.\n  */\n  standard: /*@__PURE__*/Tag.defineModifier(),\n\n  /**\n  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates a given\n  [names](https://codemirror.net/6/docs/ref/#highlight.tags.name) is local to some scope.\n  */\n  local: /*@__PURE__*/Tag.defineModifier(),\n\n  /**\n  A generic variant [modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that\n  can be used to tag language-specific alternative variants of\n  some common tag. It is recommended for themes to define special\n  forms of at least the [string](https://codemirror.net/6/docs/ref/#highlight.tags.string) and\n  [variable name](https://codemirror.net/6/docs/ref/#highlight.tags.variableName) tags, since those\n  come up a lot.\n  */\n  special: /*@__PURE__*/Tag.defineModifier()\n};\n/**\nA default highlight style (works well with light themes).\n*/\n\nvar defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([{\n  tag: tags.link,\n  textDecoration: \"underline\"\n}, {\n  tag: tags.heading,\n  textDecoration: \"underline\",\n  fontWeight: \"bold\"\n}, {\n  tag: tags.emphasis,\n  fontStyle: \"italic\"\n}, {\n  tag: tags.strong,\n  fontWeight: \"bold\"\n}, {\n  tag: tags.strikethrough,\n  textDecoration: \"line-through\"\n}, {\n  tag: tags.keyword,\n  color: \"#708\"\n}, {\n  tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],\n  color: \"#219\"\n}, {\n  tag: [tags.literal, tags.inserted],\n  color: \"#164\"\n}, {\n  tag: [tags.string, tags.deleted],\n  color: \"#a11\"\n}, {\n  tag: [tags.regexp, tags.escape, /*@__PURE__*/tags.special(tags.string)],\n  color: \"#e40\"\n}, {\n  tag: /*@__PURE__*/tags.definition(tags.variableName),\n  color: \"#00f\"\n}, {\n  tag: /*@__PURE__*/tags.local(tags.variableName),\n  color: \"#30a\"\n}, {\n  tag: [tags.typeName, tags.namespace],\n  color: \"#085\"\n}, {\n  tag: tags.className,\n  color: \"#167\"\n}, {\n  tag: [/*@__PURE__*/tags.special(tags.variableName), tags.macroName],\n  color: \"#256\"\n}, {\n  tag: /*@__PURE__*/tags.definition(tags.propertyName),\n  color: \"#00c\"\n}, {\n  tag: tags.comment,\n  color: \"#940\"\n}, {\n  tag: tags.meta,\n  color: \"#7a757a\"\n}, {\n  tag: tags.invalid,\n  color: \"#f00\"\n}]);\n/**\nThis is a highlight style that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThese tags are mapped to their name prefixed with `\"cmt-\"` (for\nexample `\"cmt-comment\"`):\n\n* [`link`](https://codemirror.net/6/docs/ref/#highlight.tags.link)\n* [`heading`](https://codemirror.net/6/docs/ref/#highlight.tags.heading)\n* [`emphasis`](https://codemirror.net/6/docs/ref/#highlight.tags.emphasis)\n* [`strong`](https://codemirror.net/6/docs/ref/#highlight.tags.strong)\n* [`keyword`](https://codemirror.net/6/docs/ref/#highlight.tags.keyword)\n* [`atom`](https://codemirror.net/6/docs/ref/#highlight.tags.atom) [`bool`](https://codemirror.net/6/docs/ref/#highlight.tags.bool)\n* [`url`](https://codemirror.net/6/docs/ref/#highlight.tags.url)\n* [`labelName`](https://codemirror.net/6/docs/ref/#highlight.tags.labelName)\n* [`inserted`](https://codemirror.net/6/docs/ref/#highlight.tags.inserted)\n* [`deleted`](https://codemirror.net/6/docs/ref/#highlight.tags.deleted)\n* [`literal`](https://codemirror.net/6/docs/ref/#highlight.tags.literal)\n* [`string`](https://codemirror.net/6/docs/ref/#highlight.tags.string)\n* [`number`](https://codemirror.net/6/docs/ref/#highlight.tags.number)\n* [`variableName`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)\n* [`typeName`](https://codemirror.net/6/docs/ref/#highlight.tags.typeName)\n* [`namespace`](https://codemirror.net/6/docs/ref/#highlight.tags.namespace)\n* [`className`](https://codemirror.net/6/docs/ref/#highlight.tags.className)\n* [`macroName`](https://codemirror.net/6/docs/ref/#highlight.tags.macroName)\n* [`propertyName`](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName)\n* [`operator`](https://codemirror.net/6/docs/ref/#highlight.tags.operator)\n* [`comment`](https://codemirror.net/6/docs/ref/#highlight.tags.comment)\n* [`meta`](https://codemirror.net/6/docs/ref/#highlight.tags.meta)\n* [`punctuation`](https://codemirror.net/6/docs/ref/#highlight.tags.puncutation)\n* [`invalid`](https://codemirror.net/6/docs/ref/#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](https://codemirror.net/6/docs/ref/#highlight.tags.regexp),\n  [`escape`](https://codemirror.net/6/docs/ref/#highlight.tags.escape), and\n  [`special`](https://codemirror.net/6/docs/ref/#highlight.tags.special)[`(string)`](https://codemirror.net/6/docs/ref/#highlight.tags.string)\n  are mapped to `\"cmt-string2\"`\n* [`special`](https://codemirror.net/6/docs/ref/#highlight.tags.special)[`(variableName)`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)\n  to `\"cmt-variableName2\"`\n* [`local`](https://codemirror.net/6/docs/ref/#highlight.tags.local)[`(variableName)`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)\n  to `\"cmt-variableName cmt-local\"`\n* [`definition`](https://codemirror.net/6/docs/ref/#highlight.tags.definition)[`(variableName)`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)\n  to `\"cmt-variableName cmt-definition\"`\n* [`definition`](https://codemirror.net/6/docs/ref/#highlight.tags.definition)[`(propertyName)`](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName)\n  to `\"cmt-propertyName cmt-definition\"`\n*/\n\nvar classHighlightStyle = /*@__PURE__*/HighlightStyle.define([{\n  tag: tags.link,\n  \"class\": \"cmt-link\"\n}, {\n  tag: tags.heading,\n  \"class\": \"cmt-heading\"\n}, {\n  tag: tags.emphasis,\n  \"class\": \"cmt-emphasis\"\n}, {\n  tag: tags.strong,\n  \"class\": \"cmt-strong\"\n}, {\n  tag: tags.keyword,\n  \"class\": \"cmt-keyword\"\n}, {\n  tag: tags.atom,\n  \"class\": \"cmt-atom\"\n}, {\n  tag: tags.bool,\n  \"class\": \"cmt-bool\"\n}, {\n  tag: tags.url,\n  \"class\": \"cmt-url\"\n}, {\n  tag: tags.labelName,\n  \"class\": \"cmt-labelName\"\n}, {\n  tag: tags.inserted,\n  \"class\": \"cmt-inserted\"\n}, {\n  tag: tags.deleted,\n  \"class\": \"cmt-deleted\"\n}, {\n  tag: tags.literal,\n  \"class\": \"cmt-literal\"\n}, {\n  tag: tags.string,\n  \"class\": \"cmt-string\"\n}, {\n  tag: tags.number,\n  \"class\": \"cmt-number\"\n}, {\n  tag: [tags.regexp, tags.escape, /*@__PURE__*/tags.special(tags.string)],\n  \"class\": \"cmt-string2\"\n}, {\n  tag: tags.variableName,\n  \"class\": \"cmt-variableName\"\n}, {\n  tag: /*@__PURE__*/tags.local(tags.variableName),\n  \"class\": \"cmt-variableName cmt-local\"\n}, {\n  tag: /*@__PURE__*/tags.definition(tags.variableName),\n  \"class\": \"cmt-variableName cmt-definition\"\n}, {\n  tag: /*@__PURE__*/tags.special(tags.variableName),\n  \"class\": \"cmt-variableName2\"\n}, {\n  tag: /*@__PURE__*/tags.definition(tags.propertyName),\n  \"class\": \"cmt-propertyName cmt-definition\"\n}, {\n  tag: tags.typeName,\n  \"class\": \"cmt-typeName\"\n}, {\n  tag: tags.namespace,\n  \"class\": \"cmt-namespace\"\n}, {\n  tag: tags.className,\n  \"class\": \"cmt-className\"\n}, {\n  tag: tags.macroName,\n  \"class\": \"cmt-macroName\"\n}, {\n  tag: tags.propertyName,\n  \"class\": \"cmt-propertyName\"\n}, {\n  tag: tags.operator,\n  \"class\": \"cmt-operator\"\n}, {\n  tag: tags.comment,\n  \"class\": \"cmt-comment\"\n}, {\n  tag: tags.meta,\n  \"class\": \"cmt-meta\"\n}, {\n  tag: tags.invalid,\n  \"class\": \"cmt-invalid\"\n}, {\n  tag: tags.punctuation,\n  \"class\": \"cmt-punctuation\"\n}]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvaGlnaGxpZ2h0L2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7OztBQUVBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBOztBQU5BO0FBQUE7O0FBQUE7QUFPQTtBQUFBO0FBQ0E7QUFEQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBU0E7O0FBVEE7QUFBQTs7QUFBQTtBQVVBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFhQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFGQTtBQUFBOztBQUFBO0FBSUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBN0JBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWtDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBREE7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFSQTtBQUFBOztBQUFBO0FBU0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBR0E7QUFBQTtBQUNBO0FBREE7QUFIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQWxCQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTs7QUFEQTtBQUFBOztBQUFBO0FBR0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFWQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUpBO0FBQUE7O0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBVEE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBOztBQUNBO0FBRUE7O0FBSEE7QUFBQTs7QUFBQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFTQTtBQUNBOzs7O0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUdBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFaQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNVdBO0FBOFdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBR0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzP2I5YjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZVByb3AsIE5vZGVUeXBlIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5pbXBvcnQgeyBTdHlsZU1vZHVsZSB9IGZyb20gJ3N0eWxlLW1vZCc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3LCBWaWV3UGx1Z2luLCBEZWNvcmF0aW9uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBGYWNldCwgUHJlYyB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IHN5bnRheFRyZWUgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBSYW5nZVNldEJ1aWxkZXIgfSBmcm9tICdAY29kZW1pcnJvci9yYW5nZXNldCc7XG5cbmxldCBuZXh0VGFnSUQgPSAwO1xuLyoqXG5IaWdobGlnaHRpbmcgdGFncyBhcmUgbWFya2VycyB0aGF0IGRlbm90ZSBhIGhpZ2hsaWdodGluZyBjYXRlZ29yeS5cblRoZXkgYXJlIFthc3NvY2lhdGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC5zdHlsZVRhZ3MpIHdpdGggcGFydHMgb2YgYSBzeW50YXhcbnRyZWUgYnkgYSBsYW5ndWFnZSBtb2RlLCBhbmQgdGhlbiBtYXBwZWQgdG8gYW4gYWN0dWFsIENTUyBzdHlsZSBieVxuYSBbaGlnaGxpZ2h0IHN0eWxlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC5IaWdobGlnaHRTdHlsZSkuXG5cbkJlY2F1c2Ugc3ludGF4IHRyZWUgbm9kZSB0eXBlcyBhbmQgaGlnaGxpZ2h0IHN0eWxlcyBoYXZlIHRvIGJlXG5hYmxlIHRvIHRhbGsgdGhlIHNhbWUgbGFuZ3VhZ2UsIENvZGVNaXJyb3IgdXNlcyBhIG1vc3RseSBfY2xvc2VkX1xuW3ZvY2FidWxhcnldKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MpIG9mIHN5bnRheCB0YWdzIChhcyBvcHBvc2VkIHRvXG50cmFkaXRpb25hbCBvcGVuIHN0cmluZy1iYXNlZCBzeXN0ZW1zLCB3aGljaCBtYWtlIGl0IGhhcmQgZm9yXG5oaWdobGlnaHRpbmcgdGhlbWVzIHRvIGNvdmVyIGFsbCB0aGUgdG9rZW5zIHByb2R1Y2VkIGJ5IHRoZVxudmFyaW91cyBsYW5ndWFnZXMpLlxuXG5JdCBfaXNfIHBvc3NpYmxlIHRvIFtkZWZpbmVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIHlvdXIgb3duXG5oaWdobGlnaHRpbmcgdGFncyBmb3Igc3lzdGVtLWludGVybmFsIHVzZSAod2hlcmUgeW91IGNvbnRyb2wgYm90aFxudGhlIGxhbmd1YWdlIHBhY2thZ2UgYW5kIHRoZSBoaWdobGlnaHRlciksIGJ1dCBzdWNoIHRhZ3Mgd2lsbCBub3RcbmJlIHBpY2tlZCB1cCBieSByZWd1bGFyIGhpZ2hsaWdodGVycyAodGhvdWdoIHlvdSBjYW4gZGVyaXZlIHRoZW1cbmZyb20gc3RhbmRhcmQgdGFncyB0byBhbGxvdyBoaWdobGlnaHRlcnMgdG8gZmFsbCBiYWNrIHRvIHRob3NlKS5cbiovXG5jbGFzcyBUYWcge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHNldCBvZiB0YWdzIHRoYXQgbWF0Y2ggdGhpcyB0YWcsIHN0YXJ0aW5nIHdpdGggdGhpcyBvbmVcbiAgICBpdHNlbGYsIHNvcnRlZCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNldCwgXG4gICAgLyoqXG4gICAgVGhlIGJhc2UgdW5tb2RpZmllZCB0YWcgdGhhdCB0aGlzIG9uZSBpcyBiYXNlZCBvbiwgaWYgaXQnc1xuICAgIG1vZGlmaWVkIEBpbnRlcm5hbFxuICAgICovXG4gICAgYmFzZSwgXG4gICAgLyoqXG4gICAgVGhlIG1vZGlmaWVycyBhcHBsaWVkIHRvIHRoaXMuYmFzZSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1vZGlmaWVkKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLm1vZGlmaWVkID0gbW9kaWZpZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG5leHRUYWdJRCsrO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgdGFnLiBJZiBgcGFyZW50YCBpcyBnaXZlbiwgdGhlIHRhZyBpcyB0cmVhdGVkIGFzIGFcbiAgICBzdWItdGFnIG9mIHRoYXQgcGFyZW50LCBhbmQgW2hpZ2hsaWdodFxuICAgIHN0eWxlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQuSGlnaGxpZ2h0U3R5bGUpIHRoYXQgZG9uJ3QgbWVudGlvbiB0aGlzIHRhZ1xuICAgIHdpbGwgdHJ5IHRvIGZhbGwgYmFjayB0byB0aGUgcGFyZW50IHRhZyAob3IgZ3JhbmRwYXJlbnQgdGFnLFxuICAgIGV0YykuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJhc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhbXSwgbnVsbCwgW10pO1xuICAgICAgICB0YWcuc2V0LnB1c2godGFnKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcbiAgICAgICAgICAgICAgICB0YWcuc2V0LnB1c2godCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHRhZyBfbW9kaWZpZXJfLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgdGFnLFxuICAgIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcbiAgICBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gICAgPT0gbTEodDEpYCkgYW5kIGFwcGx5aW5nIG11bHRpcGxlIG1vZGlmaWVycyB3aWxsLCByZWdhcmRsZXNzIG9yXG4gICAgb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXG4gICAgXG4gICAgV2hlbiBtdWx0aXBsZSBtb2RpZmllcnMgYXJlIGFwcGxpZWQgdG8gYSBnaXZlbiBiYXNlIHRhZywgZWFjaFxuICAgIHNtYWxsZXIgc2V0IG9mIG1vZGlmaWVycyBpcyByZWdpc3RlcmVkIGFzIGEgcGFyZW50LCBzbyB0aGF0IGZvclxuICAgIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICAgIGBtMShtMyh0MSlgLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lTW9kaWZpZXIoKSB7XG4gICAgICAgIGxldCBtb2QgPSBuZXcgTW9kaWZpZXI7XG4gICAgICAgIHJldHVybiAodGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFnLm1vZGlmaWVkLmluZGV4T2YobW9kKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgICAgICByZXR1cm4gTW9kaWZpZXIuZ2V0KHRhZy5iYXNlIHx8IHRhZywgdGFnLm1vZGlmaWVkLmNvbmNhdChtb2QpLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxubGV0IG5leHRNb2RpZmllcklEID0gMDtcbmNsYXNzIE1vZGlmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRNb2RpZmllcklEKys7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQoYmFzZSwgbW9kcykge1xuICAgICAgICBpZiAoIW1vZHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBleGlzdHMgPSBtb2RzWzBdLmluc3RhbmNlcy5maW5kKHQgPT4gdC5iYXNlID09IGJhc2UgJiYgc2FtZUFycmF5KG1vZHMsIHQubW9kaWZpZWQpKTtcbiAgICAgICAgaWYgKGV4aXN0cylcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XG4gICAgICAgIGxldCBzZXQgPSBbXSwgdGFnID0gbmV3IFRhZyhzZXQsIGJhc2UsIG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBtIG9mIG1vZHMpXG4gICAgICAgICAgICBtLmluc3RhbmNlcy5wdXNoKHRhZyk7XG4gICAgICAgIGxldCBjb25maWdzID0gcGVybXV0ZShtb2RzKTtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50IG9mIGJhc2Uuc2V0KVxuICAgICAgICAgICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgICAgICAgICAgc2V0LnB1c2goTW9kaWZpZXIuZ2V0KHBhcmVudCwgY29uZmlnKSk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoeCwgaSkgPT4geCA9PSBiW2ldKTtcbn1cbmZ1bmN0aW9uIHBlcm11dGUoYXJyYXkpIHtcbiAgICBsZXQgcmVzdWx0ID0gW2FycmF5XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGEgb2YgcGVybXV0ZShhcnJheS5zbGljZSgwLCBpKS5jb25jYXQoYXJyYXkuc2xpY2UoaSArIDEpKSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChhKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGFkZCBhIHNldCBvZiB0YWdzIHRvIGEgbGFuZ3VhZ2Ugc3ludGF4XG52aWFcbltgTFJQYXJzZXIuY29uZmlndXJlYF0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNsci5MUlBhcnNlci5jb25maWd1cmUpLlxuXG5UaGUgYXJndW1lbnQgb2JqZWN0IG1hcHMgbm9kZSBzZWxlY3RvcnMgdG8gW2hpZ2hsaWdodGluZ1xudGFnc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQuVGFnKSBvciBhcnJheXMgb2YgdGFncy5cblxuTm9kZSBzZWxlY3RvcnMgbWF5IGhvbGQgb25lIG9yIG1vcmUgKHNwYWNlLXNlcGFyYXRlZCkgbm9kZSBwYXRocy5cblN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlXG5uYW1lXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2NvbW1vbi5Ob2RlVHlwZS5uYW1lKSxcbm9yIG11bHRpcGxlIG5vZGUgbmFtZXMgKG9yIGAqYCB3aWxkY2FyZHMpIHNlcGFyYXRlZCBieSBzbGFzaFxuY2hhcmFjdGVycywgYXMgaW4gYFwiQmxvY2svRGVjbGFyYXRpb24vVmFyaWFibGVOYW1lXCJgLiBTdWNoIGEgcGF0aFxubWF0Y2hlcyB0aGUgZmluYWwgbm9kZSBidXQgb25seSBpZiBpdHMgZGlyZWN0IHBhcmVudCBub2RlcyBhcmUgdGhlXG5vdGhlciBub2RlcyBtZW50aW9uZWQuIEEgYCpgIGluIHN1Y2ggYSBwYXRoIG1hdGNoZXMgYW55IHBhcmVudCxcbmJ1dCBvbmx5IGEgc2luZ2xlIGxldmVs4oCUd2lsZGNhcmRzIHRoYXQgbWF0Y2ggbXVsdGlwbGUgcGFyZW50c1xuYXJlbid0IHN1cHBvcnRlZCwgYm90aCBmb3IgZWZmaWNpZW5jeSByZWFzb25zIGFuZCBiZWNhdXNlIExlemVyXG50cmVlcyBtYWtlIGl0IHJhdGhlciBoYXJkIHRvIHJlYXNvbiBhYm91dCB3aGF0IHRoZXkgd291bGQgbWF0Y2guKVxuXG5BIHBhdGggY2FuIGJlIGVuZGVkIHdpdGggYC8uLi5gIHRvIGluZGljYXRlIHRoYXQgdGhlIHRhZyBhc3NpZ25lZFxudG8gdGhlIG5vZGUgc2hvdWxkIGFsc28gYXBwbHkgdG8gYWxsIGNoaWxkIG5vZGVzLCBldmVuIGlmIHRoZXlcbm1hdGNoIHRoZWlyIG93biBzdHlsZSAoYnkgZGVmYXVsdCwgb25seSB0aGUgaW5uZXJtb3N0IHN0eWxlIGlzXG51c2VkKS5cblxuV2hlbiBhIHBhdGggZW5kcyBpbiBgIWAsIGFzIGluIGBBdHRyaWJ1dGUhYCwgbm8gZnVydGhlciBtYXRjaGluZ1xuaGFwcGVucyBmb3IgdGhlIG5vZGUncyBjaGlsZCBub2RlcywgYW5kIHRoZSBlbnRpcmUgbm9kZSBnZXRzIHRoZVxuZ2l2ZW4gc3R5bGUuXG5cbkluIHRoaXMgbm90YXRpb24sIG5vZGUgbmFtZXMgdGhhdCBjb250YWluIGAvYCwgYCFgLCBgKmAsIG9yIGAuLi5gXG5tdXN0IGJlIHF1b3RlZCBhcyBKU09OIHN0cmluZ3MuXG5cbkZvciBleGFtcGxlOlxuXG5gYGBqYXZhc2NyaXB0XG5wYXJzZXIud2l0aFByb3BzKFxuICBzdHlsZVRhZ3Moe1xuICAgIC8vIFN0eWxlIE51bWJlciBhbmQgQmlnTnVtYmVyIG5vZGVzXG4gICAgXCJOdW1iZXIgQmlnTnVtYmVyXCI6IHRhZ3MubnVtYmVyLFxuICAgIC8vIFN0eWxlIEVzY2FwZSBub2RlcyB3aG9zZSBwYXJlbnQgaXMgU3RyaW5nXG4gICAgXCJTdHJpbmcvRXNjYXBlXCI6IHRhZ3MuZXNjYXBlLFxuICAgIC8vIFN0eWxlIGFueXRoaW5nIGluc2lkZSBBdHRyaWJ1dGVzIG5vZGVzXG4gICAgXCJBdHRyaWJ1dGVzIVwiOiB0YWdzLm1ldGEsXG4gICAgLy8gQWRkIGEgc3R5bGUgdG8gYWxsIGNvbnRlbnQgaW5zaWRlIEl0YWxpYyBub2Rlc1xuICAgIFwiSXRhbGljLy4uLlwiOiB0YWdzLmVtcGhhc2lzLFxuICAgIC8vIFN0eWxlIEludmFsaWRTdHJpbmcgbm9kZXMgYXMgYm90aCBgc3RyaW5nYCBhbmQgYGludmFsaWRgXG4gICAgXCJJbnZhbGlkU3RyaW5nXCI6IFt0YWdzLnN0cmluZywgdGFncy5pbnZhbGlkXSxcbiAgICAvLyBTdHlsZSB0aGUgbm9kZSBuYW1lZCBcIi9cIiBhcyBwdW5jdHVhdGlvblxuICAgICdcIi9cIic6IHRhZ3MucHVuY3R1YXRpb25cbiAgfSlcbilcbmBgYFxuKi9cbmZ1bmN0aW9uIHN0eWxlVGFncyhzcGVjKSB7XG4gICAgbGV0IGJ5TmFtZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKSB7XG4gICAgICAgIGxldCB0YWdzID0gc3BlY1twcm9wXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZ3MpKVxuICAgICAgICAgICAgdGFncyA9IFt0YWdzXTtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpZWNlcyA9IFtdLCBtb2RlID0gMiAvKiBOb3JtYWwgKi8sIHJlc3QgPSBwYXJ0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCA9PSBcIi4uLlwiICYmIHBvcyA+IDAgJiYgcG9zICsgMyA9PSBwYXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDEgLyogSW5oZXJpdCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gL15cIig/OlteXCJcXFxcXXxcXFxcLikqP1wifFteXFwvIV0rLy5leGVjKHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcGllY2VzLnB1c2gobVswXSA9PSBcIipcIiA/IG51bGwgOiBtWzBdWzBdID09ICdcIicgPyBKU09OLnBhcnNlKG1bMF0pIDogbVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRbcG9zKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoICYmIG5leHQgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAwIC8qIE9wYXF1ZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IFwiL1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSBwYXJ0LnNsaWNlKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gcGllY2VzLmxlbmd0aCAtIDEsIGlubmVyID0gcGllY2VzW2xhc3RdO1xuICAgICAgICAgICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgIGxldCBydWxlID0gbmV3IFJ1bGUodGFncywgbW9kZSwgbGFzdCA+IDAgPyBwaWVjZXMuc2xpY2UoMCwgbGFzdCkgOiBudWxsKTtcbiAgICAgICAgICAgICAgICBieU5hbWVbaW5uZXJdID0gcnVsZS5zb3J0KGJ5TmFtZVtpbm5lcl0pO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnVsZU5vZGVQcm9wLmFkZChieU5hbWUpO1xufVxuY29uc3QgcnVsZU5vZGVQcm9wID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuY29uc3QgaGlnaGxpZ2h0U3R5bGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHN0eWxpbmdzKSB7IHJldHVybiBzdHlsaW5ncy5sZW5ndGggPyBIaWdobGlnaHRTdHlsZS5jb21iaW5lZE1hdGNoKHN0eWxpbmdzKSA6IG51bGw7IH1cbn0pO1xuY29uc3QgZmFsbGJhY2tIaWdobGlnaHRTdHlsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdLm1hdGNoIDogbnVsbDsgfVxufSk7XG5mdW5jdGlvbiBnZXRIaWdobGlnaHRTdHlsZShzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5mYWNldChoaWdobGlnaHRTdHlsZSkgfHwgc3RhdGUuZmFjZXQoZmFsbGJhY2tIaWdobGlnaHRTdHlsZSk7XG59XG5jbGFzcyBSdWxlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWdzLCBtb2RlLCBjb250ZXh0LCBuZXh0KSB7XG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgfVxuICAgIHNvcnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlciB8fCBvdGhlci5kZXB0aCA8IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG90aGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXIubmV4dCA9IHRoaXMuc29ydChvdGhlci5uZXh0KTtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmNvbnRleHQgPyB0aGlzLmNvbnRleHQubGVuZ3RoIDogMDsgfVxufVxuLyoqXG5BIGhpZ2hsaWdodCBzdHlsZSBhc3NvY2lhdGVzIENTUyBzdHlsZXMgd2l0aCBoaWdsaWdodGluZ1xuW3RhZ3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LlRhZykuXG4qL1xuY2xhc3MgSGlnaGxpZ2h0U3R5bGUge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgbW9kU3BlYztcbiAgICAgICAgZnVuY3Rpb24gZGVmKHNwZWMpIHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBTdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG4gICAgICAgICAgICAobW9kU3BlYyB8fCAobW9kU3BlYyA9IE9iamVjdC5jcmVhdGUobnVsbCkpKVtcIi5cIiArIGNsc10gPSBzcGVjO1xuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbCA9IHR5cGVvZiBvcHRpb25zLmFsbCA9PSBcInN0cmluZ1wiID8gb3B0aW9ucy5hbGwgOiBvcHRpb25zLmFsbCA/IGRlZihvcHRpb25zLmFsbCkgOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBzdHlsZSBvZiBzcGVjKSB7XG4gICAgICAgICAgICBsZXQgY2xzID0gKHN0eWxlLmNsYXNzIHx8IGRlZihPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgeyB0YWc6IG51bGwgfSkpKSArXG4gICAgICAgICAgICAgICAgKHRoaXMuYWxsID8gXCIgXCIgKyB0aGlzLmFsbCA6IFwiXCIpO1xuICAgICAgICAgICAgbGV0IHRhZ3MgPSBzdHlsZS50YWc7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBbdGFncy5pZF0gPSBjbHM7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHRhZ3MpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwW3RhZy5pZF0gPSBjbHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2RTcGVjID8gbmV3IFN0eWxlTW9kdWxlKG1vZFNwZWMpIDogbnVsbDtcbiAgICAgICAgdGhpcy5zY29wZSA9IG9wdGlvbnMuc2NvcGUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgbGV0IGV4dCA9IFt0cmVlSGlnaGxpZ2h0ZXJdO1xuICAgICAgICBpZiAodGhpcy5tb2R1bGUpXG4gICAgICAgICAgICBleHQucHVzaChFZGl0b3JWaWV3LnN0eWxlTW9kdWxlLm9mKHRoaXMubW9kdWxlKSk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gZXh0LmNvbmNhdChoaWdobGlnaHRTdHlsZS5vZih0aGlzKSk7XG4gICAgICAgIHRoaXMuZmFsbGJhY2sgPSBleHQuY29uY2F0KGZhbGxiYWNrSGlnaGxpZ2h0U3R5bGUub2YodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBDU1MgY2xhc3MgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiB0YWcsIGlmIGFueS5cbiAgICBUaGlzIG1ldGhvZCBpcyBib3VuZCB0byB0aGUgaW5zdGFuY2UgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICAgICovXG4gICAgbWF0Y2godGFnLCBzY29wZSkge1xuICAgICAgICBpZiAodGhpcy5zY29wZSAmJiBzY29wZSAhPSB0aGlzLnNjb3BlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAobGV0IHQgb2YgdGFnLnNldCkge1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5tYXBbdC5pZF07XG4gICAgICAgICAgICBpZiAobWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0ICE9IHRhZylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBbdGFnLmlkXSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXBbdGFnLmlkXSA9IHRoaXMuYWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21iaW5lcyBhbiBhcnJheSBvZiBoaWdobGlnaHQgc3R5bGVzIGludG8gYSBzaW5nbGUgbWF0Y2hcbiAgICBmdW5jdGlvbiB0aGF0IHJldHVybnMgYWxsIG9mIHRoZSBjbGFzc2VzIGFzc2lnbmVkIGJ5IHRoZSBzdHlsZXNcbiAgICBmb3IgYSBnaXZlbiB0YWcuXG4gICAgKi9cbiAgICBzdGF0aWMgY29tYmluZWRNYXRjaChzdHlsZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlcy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBzdHlsZXNbMF0ubWF0Y2g7XG4gICAgICAgIGxldCBjYWNoZSA9IHN0eWxlcy5zb21lKHMgPT4gcy5zY29wZSkgPyB1bmRlZmluZWQgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICByZXR1cm4gKHRhZywgc2NvcGUpID0+IHtcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSBjYWNoZSAmJiBjYWNoZVt0YWcuaWRdO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHN0eWxlLm1hdGNoKHRhZywgc2NvcGUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhY2hlKVxuICAgICAgICAgICAgICAgIGNhY2hlW3RhZy5pZF0gPSByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBoaWdobGlnaHRlciBzdHlsZSB0aGF0IGFzc29jaWF0ZXMgdGhlIGdpdmVuIHN0eWxlcyB0b1xuICAgIHRoZSBnaXZlbiB0YWdzLiBUaGUgc3BlYyBtdXN0IGJlIG9iamVjdHMgdGhhdCBob2xkIGEgc3R5bGUgdGFnXG4gICAgb3IgYXJyYXkgb2YgdGFncyBpbiB0aGVpciBgdGFnYCBwcm9wZXJ0eSwgYW5kIGVpdGhlciBhIHNpbmdsZVxuICAgIGBjbGFzc2AgcHJvcGVydHkgcHJvdmlkaW5nIGEgc3RhdGljIENTUyBjbGFzcyAoZm9yIGhpZ2hsaWdodGVyc1xuICAgIGxpa2UgW2BjbGFzc0hpZ2hsaWdodFN0eWxlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQuY2xhc3NIaWdobGlnaHRTdHlsZSlcbiAgICB0aGF0IHJlbHkgb24gZXh0ZXJuYWwgc3R5bGluZyksIG9yIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKS1zdHlsZVxuICAgIHNldCBvZiBDU1MgcHJvcGVydGllcyAod2hpY2ggZGVmaW5lIHRoZSBzdHlsaW5nIGZvciB0aG9zZSB0YWdzKS5cbiAgICBcbiAgICBUaGUgQ1NTIHJ1bGVzIGNyZWF0ZWQgZm9yIGEgaGlnaGxpZ2h0ZXIgd2lsbCBiZSBlbWl0dGVkIGluIHRoZVxuICAgIG9yZGVyIG9mIHRoZSBzcGVjJ3MgcHJvcGVydGllcy4gVGhhdCBtZWFucyB0aGF0IGZvciBlbGVtZW50cyB0aGF0XG4gICAgaGF2ZSBtdWx0aXBsZSB0YWdzIGFzc29jaWF0ZWQgd2l0aCB0aGVtLCBzdHlsZXMgZGVmaW5lZCBmdXJ0aGVyXG4gICAgZG93biBpbiB0aGUgbGlzdCB3aWxsIGhhdmUgYSBoaWdoZXIgQ1NTIHByZWNlZGVuY2UgdGhhbiBzdHlsZXNcbiAgICBkZWZpbmVkIGVhcmxpZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0U3R5bGUoc3BlY3MsIG9wdGlvbnMgfHwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBDU1MgY2xhc3NlcyAoaWYgYW55KSB0aGF0IHRoZSBoaWdobGlnaHQgc3R5bGVzXG4gICAgYWN0aXZlIGluIHRoZSBnaXZlbiBzdGF0ZSB3b3VsZCBhc3NpZ24gdG8gdGhlIGdpdmVuIGEgc3R5bGVcbiAgICBbdGFnXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC5UYWcpIGFuZCAob3B0aW9uYWwpIGxhbmd1YWdlXG4gICAgW3Njb3BlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC5IaWdobGlnaHRTdHlsZV5kZWZpbmVeb3B0aW9ucy5zY29wZSkuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KHN0YXRlLCB0YWcsIHNjb3BlKSB7XG4gICAgICAgIGxldCBzdHlsZSA9IGdldEhpZ2hsaWdodFN0eWxlKHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHN0eWxlICYmIHN0eWxlKHRhZywgc2NvcGUgfHwgTm9kZVR5cGUubm9uZSk7XG4gICAgfVxufVxuLyoqXG5SdW4gdGhlIHRyZWUgaGlnaGxpZ2h0ZXIgb3ZlciB0aGUgZ2l2ZW4gdHJlZS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRUcmVlKHRyZWUsIFxuLyoqXG5HZXQgdGhlIENTUyBjbGFzc2VzIHVzZWQgdG8gc3R5bGUgYSBnaXZlbiBbdGFnXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC5UYWcpLFxub3IgYG51bGxgIGlmIGl0IGlzbid0IHN0eWxlZC4gKFlvdSdsbCBvZnRlbiB3YW50IHRvIHBhc3MgYVxuaGlnaGxpZ2h0IHN0eWxlJ3MgW2BtYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LkhpZ2hsaWdodFN0eWxlLm1hdGNoKVxubWV0aG9kIGhlcmUuKVxuKi9cbmdldFN0eWxlLCBcbi8qKlxuQXNzaWduIHN0eWxpbmcgdG8gYSByZWdpb24gb2YgdGhlIHRleHQuIFdpbGwgYmUgY2FsbGVkLCBpbiBvcmRlclxub2YgcG9zaXRpb24sIGZvciBhbnkgcmFuZ2VzIHdoZXJlIG1vcmUgdGhhbiB6ZXJvIGNsYXNzZXMgYXBwbHkuXG5gY2xhc3Nlc2AgaXMgYSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIENTUyBjbGFzc2VzLlxuKi9cbnB1dFN0eWxlLCBcbi8qKlxuVGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0byBoaWdobGlnaHQuXG4qL1xuZnJvbSA9IDAsIFxuLyoqXG5UaGUgZW5kIG9mIHRoZSByYW5nZS5cbiovXG50byA9IHRyZWUubGVuZ3RoKSB7XG4gICAgaGlnaGxpZ2h0VHJlZVJhbmdlKHRyZWUsIGZyb20sIHRvLCBnZXRTdHlsZSwgcHV0U3R5bGUpO1xufVxuY2xhc3MgVHJlZUhpZ2hsaWdodGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMubWFya0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy50cmVlID0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvKHZpZXcsIGdldEhpZ2hsaWdodFN0eWxlKHZpZXcuc3RhdGUpKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKSwgc3R5bGUgPSBnZXRIaWdobGlnaHRTdHlsZSh1cGRhdGUuc3RhdGUpO1xuICAgICAgICBsZXQgc3R5bGVDaGFuZ2UgPSBzdHlsZSAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChoaWdobGlnaHRTdHlsZSk7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA8IHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvICYmICFzdHlsZUNoYW5nZSAmJiB0cmVlLnR5cGUgPT0gdGhpcy50cmVlLnR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRpb25zLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJlZSAhPSB0aGlzLnRyZWUgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBzdHlsZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh1cGRhdGUudmlldywgc3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkRGVjbyh2aWV3LCBtYXRjaCkge1xuICAgICAgICBpZiAoIW1hdGNoIHx8ICF0aGlzLnRyZWUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodFRyZWVSYW5nZSh0aGlzLnRyZWUsIGZyb20sIHRvLCBtYXRjaCwgKGZyb20sIHRvLCBzdHlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGZyb20sIHRvLCB0aGlzLm1hcmtDYWNoZVtzdHlsZV0gfHwgKHRoaXMubWFya0NhY2hlW3N0eWxlXSA9IERlY29yYXRpb24ubWFyayh7IGNsYXNzOiBzdHlsZSB9KSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgfVxufVxuLy8gVGhpcyBleHRlbnNpb24gaW5zdGFsbHMgYSBoaWdobGlnaHRlciB0aGF0IGhpZ2hsaWdodHMgYmFzZWQgb24gdGhlXG4vLyBzeW50YXggdHJlZSBhbmQgaGlnaGxpZ2h0IHN0eWxlLlxuY29uc3QgdHJlZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ByZWMuaGlnaCgvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoVHJlZUhpZ2hsaWdodGVyLCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSkpO1xuY29uc3Qgbm9kZVN0YWNrID0gW1wiXCJdO1xuY2xhc3MgSGlnaGxpZ2h0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYXQsIHN0eWxlLCBzcGFuKSB7XG4gICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICB0aGlzLmNsYXNzID0gXCJcIjtcbiAgICB9XG4gICAgc3RhcnRTcGFuKGF0LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdCA+IHRoaXMuYXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICAgICAgdGhpcy5jbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCh0bykge1xuICAgICAgICBpZiAodG8gPiB0aGlzLmF0ICYmIHRoaXMuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLnNwYW4odGhpcy5hdCwgdG8sIHRoaXMuY2xhc3MpO1xuICAgIH1cbiAgICBoaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgZGVwdGgsIHNjb3BlKSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGZyb206IHN0YXJ0LCB0bzogZW5kIH0gPSBjdXJzb3I7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbm9kZVN0YWNrW2RlcHRoXSA9IHR5cGUubmFtZTtcbiAgICAgICAgaWYgKHR5cGUuaXNUb3ApXG4gICAgICAgICAgICBzY29wZSA9IHR5cGU7XG4gICAgICAgIGxldCBjbHMgPSBpbmhlcml0ZWRDbGFzcztcbiAgICAgICAgbGV0IHJ1bGUgPSB0eXBlLnByb3AocnVsZU5vZGVQcm9wKSwgb3BhcXVlID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChydWxlKSB7XG4gICAgICAgICAgICBpZiAoIXJ1bGUuY29udGV4dCB8fCBtYXRjaENvbnRleHQocnVsZS5jb250ZXh0LCBub2RlU3RhY2ssIGRlcHRoKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiBydWxlLnRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ID0gdGhpcy5zdHlsZSh0YWcsIHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscyArPSBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyArPSBzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLm1vZGUgPT0gMSAvKiBJbmhlcml0ICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRlZENsYXNzICs9IChpbmhlcml0ZWRDbGFzcyA/IFwiIFwiIDogXCJcIikgKyBzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUubW9kZSA9PSAwIC8qIE9wYXF1ZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFxdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVsZSA9IHJ1bGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0U3BhbihjdXJzb3IuZnJvbSwgY2xzKTtcbiAgICAgICAgaWYgKG9wYXF1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBjdXJzb3IudHJlZSAmJiBjdXJzb3IudHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGN1cnNvci5ub2RlLmVudGVyKG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgc3RhcnQsIDEpO1xuICAgICAgICAgICAgbGV0IGhhc0NoaWxkID0gY3Vyc29yLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaSA8IG1vdW50ZWQub3ZlcmxheS5sZW5ndGggPyBtb3VudGVkLm92ZXJsYXlbaV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dCA/IG5leHQuZnJvbSArIHN0YXJ0IDogZW5kO1xuICAgICAgICAgICAgICAgIGxldCByYW5nZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpLCByYW5nZVRvID0gTWF0aC5taW4odG8sIG5leHRQb3MpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZUZyb20gPCByYW5nZVRvICYmIGhhc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IuZnJvbSA8IHJhbmdlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCByYW5nZUZyb20sIHJhbmdlVG8sIGluaGVyaXRlZENsYXNzLCBkZXB0aCArIDEsIHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBuZXh0UG9zIHx8ICFjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dFBvcyA+IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShpbm5lci5jdXJzb3IsIE1hdGgubWF4KGZyb20sIG5leHQuZnJvbSArIHN0YXJ0KSwgTWF0aC5taW4odG8sIHBvcyksIGluaGVyaXRlZENsYXNzLCBkZXB0aCwgbW91bnRlZC50cmVlLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3Bhbihwb3MsIGNscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0NoaWxkKVxuICAgICAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA8PSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGRlcHRoICsgMSwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgfSB3aGlsZSAoY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGlnaGxpZ2h0VHJlZVJhbmdlKHRyZWUsIGZyb20sIHRvLCBzdHlsZSwgc3Bhbikge1xuICAgIGxldCBidWlsZGVyID0gbmV3IEhpZ2hsaWdodEJ1aWxkZXIoZnJvbSwgc3R5bGUsIHNwYW4pO1xuICAgIGJ1aWxkZXIuaGlnaGxpZ2h0UmFuZ2UodHJlZS5jdXJzb3IoKSwgZnJvbSwgdG8sIFwiXCIsIDAsIHRyZWUudHlwZSk7XG4gICAgYnVpbGRlci5mbHVzaCh0byk7XG59XG5mdW5jdGlvbiBtYXRjaENvbnRleHQoY29udGV4dCwgc3RhY2ssIGRlcHRoKSB7XG4gICAgaWYgKGNvbnRleHQubGVuZ3RoID4gZGVwdGggLSAxKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoIC0gMSwgaSA9IGNvbnRleHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0sIGQtLSkge1xuICAgICAgICBsZXQgY2hlY2sgPSBjb250ZXh0W2ldO1xuICAgICAgICBpZiAoY2hlY2sgJiYgY2hlY2sgIT0gc3RhY2tbZF0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgdCA9IFRhZy5kZWZpbmU7XG5jb25zdCBjb21tZW50ID0gLypAX19QVVJFX18qL3QoKSwgbmFtZSA9IC8qQF9fUFVSRV9fKi90KCksIHR5cGVOYW1lID0gLypAX19QVVJFX18qL3QobmFtZSksIHByb3BlcnR5TmFtZSA9IC8qQF9fUFVSRV9fKi90KG5hbWUpLCBsaXRlcmFsID0gLypAX19QVVJFX18qL3QoKSwgc3RyaW5nID0gLypAX19QVVJFX18qL3QobGl0ZXJhbCksIG51bWJlciA9IC8qQF9fUFVSRV9fKi90KGxpdGVyYWwpLCBjb250ZW50ID0gLypAX19QVVJFX18qL3QoKSwgaGVhZGluZyA9IC8qQF9fUFVSRV9fKi90KGNvbnRlbnQpLCBrZXl3b3JkID0gLypAX19QVVJFX18qL3QoKSwgb3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovdCgpLCBwdW5jdHVhdGlvbiA9IC8qQF9fUFVSRV9fKi90KCksIGJyYWNrZXQgPSAvKkBfX1BVUkVfXyovdChwdW5jdHVhdGlvbiksIG1ldGEgPSAvKkBfX1BVUkVfXyovdCgpO1xuLyoqXG5UaGUgZGVmYXVsdCBzZXQgb2YgaGlnaGxpZ2h0aW5nIFt0YWdzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSB1c2VkXG5ieSByZWd1bGFyIGxhbmd1YWdlIHBhY2thZ2VzIGFuZCB0aGVtZXMuXG5cblRoaXMgY29sbGVjdGlvbiBpcyBoZWF2aWx5IGJpYXNlZCB0b3dhcmRzIHByb2dyYW1taW5nIGxhbmd1YWdlcyxcbmFuZCBuZWNlc3NhcmlseSBpbmNvbXBsZXRlLiBBIGZ1bGwgb250b2xvZ3kgb2Ygc3ludGFjdGljXG5jb25zdHJ1Y3RzIHdvdWxkIGZpbGwgYSBzdGFjayBvZiBib29rcywgYW5kIGJlIGltcHJhY3RpY2FsIHRvXG53cml0ZSB0aGVtZXMgZm9yLiBTbyB0cnkgdG8gbWFrZSBkbyB3aXRoIHRoaXMgc2V0LiBJZiBhbGwgZWxzZVxuZmFpbHMsIFtvcGVuIGFuXG5pc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvY29kZW1pcnJvci5uZXh0KSB0byBwcm9wb3NlIGFcbm5ldyB0YWcsIG9yIFtkZWZpbmVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIGEgbG9jYWwgY3VzdG9tIHRhZyBmb3JcbnlvdXIgdXNlIGNhc2UuXG5cbk5vdGUgdGhhdCBpdCBpcyBub3Qgb2JsaWdhdG9yeSB0byBhbHdheXMgYXR0YWNoIHRoZSBtb3N0IHNwZWNpZmljXG50YWcgcG9zc2libGUgdG8gYW4gZWxlbWVudOKAlGlmIHlvdXIgZ3JhbW1hciBjYW4ndCBlYXNpbHlcbmRpc3Rpbmd1aXNoIGEgY2VydGFpbiB0eXBlIG9mIGVsZW1lbnQgKHN1Y2ggYXMgYSBsb2NhbCB2YXJpYWJsZSksXG5pdCBpcyBva2F5IHRvIHN0eWxlIGl0IGFzIGl0cyBtb3JlIGdlbmVyYWwgdmFyaWFudCAoYSB2YXJpYWJsZSkuXG5cbkZvciB0YWdzIHRoYXQgZXh0ZW5kIHNvbWUgcGFyZW50IHRhZywgdGhlIGRvY3VtZW50YXRpb24gbGlua3MgdG9cbnRoZSBwYXJlbnQuXG4qL1xuY29uc3QgdGFncyA9IHtcbiAgICAvKipcbiAgICBBIGNvbW1lbnQuXG4gICAgKi9cbiAgICBjb21tZW50LFxuICAgIC8qKlxuICAgIEEgbGluZSBbY29tbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICAqL1xuICAgIGxpbmVDb21tZW50OiAvKkBfX1BVUkVfXyovdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBIGJsb2NrIFtjb21tZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgYmxvY2tDb21tZW50OiAvKkBfX1BVUkVfXyovdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBIGRvY3VtZW50YXRpb24gW2NvbW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBkb2NDb21tZW50OiAvKkBfX1BVUkVfXyovdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBbnkga2luZCBvZiBpZGVudGlmaWVyLlxuICAgICovXG4gICAgbmFtZSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSB2YXJpYWJsZS5cbiAgICAqL1xuICAgIHZhcmlhYmxlTmFtZTogLypAX19QVVJFX18qL3QobmFtZSksXG4gICAgLyoqXG4gICAgQSB0eXBlIFtuYW1lXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgdHlwZU5hbWU6IHR5cGVOYW1lLFxuICAgIC8qKlxuICAgIEEgdGFnIG5hbWUgKHN1YnRhZyBvZiBbYHR5cGVOYW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy50eXBlTmFtZSkpLlxuICAgICovXG4gICAgdGFnTmFtZTogLypAX19QVVJFX18qL3QodHlwZU5hbWUpLFxuICAgIC8qKlxuICAgIEEgcHJvcGVydHkgb3IgZmllbGQgW25hbWVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAvKipcbiAgICBBbiBhdHRyaWJ1dGUgbmFtZSAoc3VidGFnIG9mIFtgcHJvcGVydHlOYW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpKS5cbiAgICAqL1xuICAgIGF0dHJpYnV0ZU5hbWU6IC8qQF9fUFVSRV9fKi90KHByb3BlcnR5TmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgY2xhc3MuXG4gICAgKi9cbiAgICBjbGFzc05hbWU6IC8qQF9fUFVSRV9fKi90KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbGFiZWwgW25hbWVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBsYWJlbE5hbWU6IC8qQF9fUFVSRV9fKi90KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbmFtZXNwYWNlIFtuYW1lXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgbmFtZXNwYWNlOiAvKkBfX1BVUkVfXyovdChuYW1lKSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBtYWNyby5cbiAgICAqL1xuICAgIG1hY3JvTmFtZTogLypAX19QVVJFX18qL3QobmFtZSksXG4gICAgLyoqXG4gICAgQSBsaXRlcmFsIHZhbHVlLlxuICAgICovXG4gICAgbGl0ZXJhbCxcbiAgICAvKipcbiAgICBBIHN0cmluZyBbbGl0ZXJhbF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHN0cmluZyxcbiAgICAvKipcbiAgICBBIGRvY3VtZW50YXRpb24gW3N0cmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5zdHJpbmcpLlxuICAgICovXG4gICAgZG9jU3RyaW5nOiAvKkBfX1BVUkVfXyovdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEEgY2hhcmFjdGVyIGxpdGVyYWwgKHN1YnRhZyBvZiBbc3RyaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgY2hhcmFjdGVyOiAvKkBfX1BVUkVfXyovdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSB2YWx1ZSAoc3VidGFnIG9mIFtzdHJpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXG4gICAgKi9cbiAgICBhdHRyaWJ1dGVWYWx1ZTogLypAX19QVVJFX18qL3Qoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIG51bWJlciBbbGl0ZXJhbF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIG51bWJlcixcbiAgICAvKipcbiAgICBBbiBpbnRlZ2VyIFtudW1iZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgICovXG4gICAgaW50ZWdlcjogLypAX19QVVJFX18qL3QobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGZsb2F0aW5nLXBvaW50IFtudW1iZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgICovXG4gICAgZmxvYXQ6IC8qQF9fUFVSRV9fKi90KG51bWJlciksXG4gICAgLyoqXG4gICAgQSBib29sZWFuIFtsaXRlcmFsXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgYm9vbDogLypAX19QVVJFX18qL3QobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgUmVndWxhciBleHByZXNzaW9uIFtsaXRlcmFsXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgcmVnZXhwOiAvKkBfX1BVUkVfXyovdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBbiBlc2NhcGUgW2xpdGVyYWxdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCksIGZvciBleGFtcGxlIGFcbiAgICBiYWNrc2xhc2ggZXNjYXBlIGluIGEgc3RyaW5nLlxuICAgICovXG4gICAgZXNjYXBlOiAvKkBfX1BVUkVfXyovdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIGNvbG9yIFtsaXRlcmFsXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgY29sb3I6IC8qQF9fUFVSRV9fKi90KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgVVJMIFtsaXRlcmFsXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgdXJsOiAvKkBfX1BVUkVfXyovdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIGxhbmd1YWdlIGtleXdvcmQuXG4gICAgKi9cbiAgICBrZXl3b3JkLFxuICAgIC8qKlxuICAgIFRoZSBba2V5d29yZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgdGhlIHNlbGYgb3IgdGhpc1xuICAgIG9iamVjdC5cbiAgICAqL1xuICAgIHNlbGY6IC8qQF9fUFVSRV9fKi90KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIFRoZSBba2V5d29yZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgbnVsbC5cbiAgICAqL1xuICAgIG51bGw6IC8qQF9fUFVSRV9fKi90KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZGVub3Rpbmcgc29tZSBhdG9taWMgdmFsdWUuXG4gICAgKi9cbiAgICBhdG9tOiAvKkBfX1BVUkVfXyovdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgcmVwcmVzZW50cyBhIHVuaXQuXG4gICAgKi9cbiAgICB1bml0OiAvKkBfX1BVUkVfXyovdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIG1vZGlmaWVyIFtrZXl3b3JkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgbW9kaWZpZXI6IC8qQF9fUFVSRV9fKi90KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBhY3RzIGFzIGFuIG9wZXJhdG9yLlxuICAgICovXG4gICAgb3BlcmF0b3JLZXl3b3JkOiAvKkBfX1BVUkVfXyovdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIGNvbnRyb2wtZmxvdyByZWxhdGVkIFtrZXl3b3JkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgY29udHJvbEtleXdvcmQ6IC8qQF9fUFVSRV9fKi90KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25LZXl3b3JkOiAvKkBfX1BVUkVfXyovdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHJlbGF0ZWQgdG8gZGVmaW5pbmcgb3JcbiAgICBpbnRlcmZhY2luZyB3aXRoIG1vZHVsZXMuXG4gICAgKi9cbiAgICBtb2R1bGVLZXl3b3JkOiAvKkBfX1BVUkVfXyovdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yLFxuICAgIC8qKlxuICAgIEFuIFtvcGVyYXRvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlcmVmT3BlcmF0b3I6IC8qQF9fUFVSRV9fKi90KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBBcml0aG1ldGljLXJlbGF0ZWQgW29wZXJhdG9yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGFyaXRobWV0aWNPcGVyYXRvcjogLypAX19QVVJFX18qL3Qob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIExvZ2ljYWwgW29wZXJhdG9yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGxvZ2ljT3BlcmF0b3I6IC8qQF9fUFVSRV9fKi90KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBCaXQgW29wZXJhdG9yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGJpdHdpc2VPcGVyYXRvcjogLypAX19QVVJFX18qL3Qob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIENvbXBhcmlzb24gW29wZXJhdG9yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbXBhcmVPcGVyYXRvcjogLypAX19QVVJFX18qL3Qob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFtPcGVyYXRvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCB1cGRhdGVzIGl0cyBvcGVyYW5kLlxuICAgICovXG4gICAgdXBkYXRlT3BlcmF0b3I6IC8qQF9fUFVSRV9fKi90KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uT3BlcmF0b3I6IC8qQF9fUFVSRV9fKi90KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBUeXBlLXJlbGF0ZWQgW29wZXJhdG9yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIHR5cGVPcGVyYXRvcjogLypAX19QVVJFX18qL3Qob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIENvbnRyb2wtZmxvdyBbb3BlcmF0b3JdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29udHJvbE9wZXJhdG9yOiAvKkBfX1BVUkVfXyovdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgUHJvZ3JhbSBvciBtYXJrdXAgcHVuY3R1YXRpb24uXG4gICAgKi9cbiAgICBwdW5jdHVhdGlvbixcbiAgICAvKipcbiAgICBbUHVuY3R1YXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pIHRoYXQgc2VwYXJhdGVzXG4gICAgdGhpbmdzLlxuICAgICovXG4gICAgc2VwYXJhdG9yOiAvKkBfX1BVUkVfXyovdChwdW5jdHVhdGlvbiksXG4gICAgLyoqXG4gICAgQnJhY2tldC1zdHlsZSBbcHVuY3R1YXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pLlxuICAgICovXG4gICAgYnJhY2tldCxcbiAgICAvKipcbiAgICBBbmdsZSBbYnJhY2tldHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYDxgIGFuZCBgPmBcbiAgICB0b2tlbnMpLlxuICAgICovXG4gICAgYW5nbGVCcmFja2V0OiAvKkBfX1BVUkVfXyovdChicmFja2V0KSxcbiAgICAvKipcbiAgICBTcXVhcmUgW2JyYWNrZXRzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGBbYCBhbmQgYF1gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIHNxdWFyZUJyYWNrZXQ6IC8qQF9fUFVSRV9fKi90KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIFBhcmVudGhlc2VzICh1c3VhbGx5IGAoYCBhbmQgYClgIHRva2VucykuIFN1YnRhZyBvZlxuICAgIFticmFja2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgcGFyZW46IC8qQF9fUFVSRV9fKi90KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIEJyYWNlcyAodXN1YWxseSBge2AgYW5kIGB9YCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICAqL1xuICAgIGJyYWNlOiAvKkBfX1BVUkVfXyovdChicmFja2V0KSxcbiAgICAvKipcbiAgICBDb250ZW50LCBmb3IgZXhhbXBsZSBwbGFpbiB0ZXh0IGluIFhNTCBvciBtYXJrdXAgZG9jdW1lbnRzLlxuICAgICovXG4gICAgY29udGVudCxcbiAgICAvKipcbiAgICBbQ29udGVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBoZWFkaW5nLlxuICAgICovXG4gICAgaGVhZGluZyxcbiAgICAvKipcbiAgICBBIGxldmVsIDEgW2hlYWRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMTogLypAX19QVVJFX18qL3QoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAyIFtoZWFkaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzI6IC8qQF9fUFVSRV9fKi90KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMyBbaGVhZGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmczOiAvKkBfX1BVUkVfXyovdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDQgW2hlYWRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNDogLypAX19QVVJFX18qL3QoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA1IFtoZWFkaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzU6IC8qQF9fUFVSRV9fKi90KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNiBbaGVhZGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc2OiAvKkBfX1BVUkVfXyovdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIHByb3NlIHNlcGFyYXRvciAoc3VjaCBhcyBhIGhvcml6b250YWwgcnVsZSkuXG4gICAgKi9cbiAgICBjb250ZW50U2VwYXJhdG9yOiAvKkBfX1BVUkVfXyovdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBsaXN0LlxuICAgICovXG4gICAgbGlzdDogLypAX19QVVJFX18qL3QoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgcXVvdGUuXG4gICAgKi9cbiAgICBxdW90ZTogLypAX19QVVJFX18qL3QoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBlbXBoYXNpemVkLlxuICAgICovXG4gICAgZW1waGFzaXM6IC8qQF9fUFVSRV9fKi90KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIHN0cm9uZy5cbiAgICAqL1xuICAgIHN0cm9uZzogLypAX19QVVJFX18qL3QoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBwYXJ0IG9mIGEgbGluay5cbiAgICAqL1xuICAgIGxpbms6IC8qQF9fUFVSRV9fKi90KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIGFzIGNvZGUgb3JcbiAgICBtb25vc3BhY2UuXG4gICAgKi9cbiAgICBtb25vc3BhY2U6IC8qQF9fUFVSRV9fKi90KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaGFzIGEgc3RyaWtlLXRocm91Z2hcbiAgICBzdHlsZS5cbiAgICAqL1xuICAgIHN0cmlrZXRocm91Z2g6IC8qQF9fUFVSRV9fKi90KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIEluc2VydGVkIHRleHQgaW4gYSBjaGFuZ2UtdHJhY2tpbmcgZm9ybWF0LlxuICAgICovXG4gICAgaW5zZXJ0ZWQ6IC8qQF9fUFVSRV9fKi90KCksXG4gICAgLyoqXG4gICAgRGVsZXRlZCB0ZXh0LlxuICAgICovXG4gICAgZGVsZXRlZDogLypAX19QVVJFX18qL3QoKSxcbiAgICAvKipcbiAgICBDaGFuZ2VkIHRleHQuXG4gICAgKi9cbiAgICBjaGFuZ2VkOiAvKkBfX1BVUkVfXyovdCgpLFxuICAgIC8qKlxuICAgIEFuIGludmFsaWQgb3IgdW5zeW50YWN0aWMgZWxlbWVudC5cbiAgICAqL1xuICAgIGludmFsaWQ6IC8qQF9fUFVSRV9fKi90KCksXG4gICAgLyoqXG4gICAgTWV0YWRhdGEgb3IgbWV0YS1pbnN0cnVjdGlvbi5cbiAgICAqL1xuICAgIG1ldGEsXG4gICAgLyoqXG4gICAgW01ldGFkYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYXBwbGllcyB0byB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBkb2N1bWVudE1ldGE6IC8qQF9fUFVSRV9fKi90KG1ldGEpLFxuICAgIC8qKlxuICAgIFtNZXRhZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFubm90YXRlcyBvciBhZGRzXG4gICAgYXR0cmlidXRlcyB0byBhIGdpdmVuIHN5bnRhY3RpYyBlbGVtZW50LlxuICAgICovXG4gICAgYW5ub3RhdGlvbjogLypAX19QVVJFX18qL3QobWV0YSksXG4gICAgLyoqXG4gICAgUHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBvciBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlLiBTdWJ0YWcgb2ZcbiAgICBbbWV0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5tZXRhKS5cbiAgICAqL1xuICAgIHByb2Nlc3NpbmdJbnN0cnVjdGlvbjogLypAX19QVVJFX18qL3QobWV0YSksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXQgYVxuICAgIGdpdmVuIGVsZW1lbnQgaXMgYmVpbmcgZGVmaW5lZC4gRXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIHRoZVxuICAgIHZhcmlvdXMgW25hbWVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdGFncy5cbiAgICAqL1xuICAgIGRlZmluaXRpb246IC8qQF9fUFVSRV9fKi9UYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdFxuICAgIHNvbWV0aGluZyBpcyBjb25zdGFudC4gTW9zdGx5IGV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aFxuICAgIFt2YXJpYWJsZSBuYW1lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpLlxuICAgICovXG4gICAgY29uc3RhbnQ6IC8qQF9fUFVSRV9fKi9UYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdXNlZCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgYSBbdmFyaWFibGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSBvciBbcHJvcGVydHlcbiAgICBuYW1lXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkgaXMgYmVpbmcgY2FsbGVkIG9yIGRlZmluZWRcbiAgICBhcyBhIGZ1bmN0aW9uLlxuICAgICovXG4gICAgZnVuY3Rpb246IC8qQF9fUFVSRV9fKi9UYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBjYW4gYmUgYXBwbGllZCB0b1xuICAgIFtuYW1lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5uYW1lKSB0byBpbmRpY2F0ZSB0aGF0IHRoZXkgYmVsb25nIHRvXG4gICAgdGhlIGxhbmd1YWdlJ3Mgc3RhbmRhcmQgZW52aXJvbm1lbnQuXG4gICAgKi9cbiAgICBzdGFuZGFyZDogLypAX19QVVJFX18qL1RhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyBhIGdpdmVuXG4gICAgW25hbWVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLm5hbWUpIGlzIGxvY2FsIHRvIHNvbWUgc2NvcGUuXG4gICAgKi9cbiAgICBsb2NhbDogLypAX19QVVJFX18qL1RhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIEEgZ2VuZXJpYyB2YXJpYW50IFttb2RpZmllcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0XG4gICAgY2FuIGJlIHVzZWQgdG8gdGFnIGxhbmd1YWdlLXNwZWNpZmljIGFsdGVybmF0aXZlIHZhcmlhbnRzIG9mXG4gICAgc29tZSBjb21tb24gdGFnLiBJdCBpcyByZWNvbW1lbmRlZCBmb3IgdGhlbWVzIHRvIGRlZmluZSBzcGVjaWFsXG4gICAgZm9ybXMgb2YgYXQgbGVhc3QgdGhlIFtzdHJpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSBhbmRcbiAgICBbdmFyaWFibGUgbmFtZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIHRhZ3MsIHNpbmNlIHRob3NlXG4gICAgY29tZSB1cCBhIGxvdC5cbiAgICAqL1xuICAgIHNwZWNpYWw6IC8qQF9fUFVSRV9fKi9UYWcuZGVmaW5lTW9kaWZpZXIoKVxufTtcbi8qKlxuQSBkZWZhdWx0IGhpZ2hsaWdodCBzdHlsZSAod29ya3Mgd2VsbCB3aXRoIGxpZ2h0IHRoZW1lcykuXG4qL1xuY29uc3QgZGVmYXVsdEhpZ2hsaWdodFN0eWxlID0gLypAX19QVVJFX18qL0hpZ2hsaWdodFN0eWxlLmRlZmluZShbXG4gICAgeyB0YWc6IHRhZ3MubGluayxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIixcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcyxcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cmlrZXRocm91Z2gsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcImxpbmUtdGhyb3VnaFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCxcbiAgICAgICAgY29sb3I6IFwiIzcwOFwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLmF0b20sIHRhZ3MuYm9vbCwgdGFncy51cmwsIHRhZ3MuY29udGVudFNlcGFyYXRvciwgdGFncy5sYWJlbE5hbWVdLFxuICAgICAgICBjb2xvcjogXCIjMjE5XCIgfSxcbiAgICB7IHRhZzogW3RhZ3MubGl0ZXJhbCwgdGFncy5pbnNlcnRlZF0sXG4gICAgICAgIGNvbG9yOiBcIiMxNjRcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5zdHJpbmcsIHRhZ3MuZGVsZXRlZF0sXG4gICAgICAgIGNvbG9yOiBcIiNhMTFcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBcIiNlNDBcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzAwZlwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmxvY2FsKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzMwYVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnR5cGVOYW1lLCB0YWdzLm5hbWVzcGFjZV0sXG4gICAgICAgIGNvbG9yOiBcIiMwODVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNsYXNzTmFtZSxcbiAgICAgICAgY29sb3I6IFwiIzE2N1wiIH0sXG4gICAgeyB0YWc6IFsvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgdGFncy5tYWNyb05hbWVdLFxuICAgICAgICBjb2xvcjogXCIjMjU2XCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMwMGNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNvbW1lbnQsXG4gICAgICAgIGNvbG9yOiBcIiM5NDBcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1ldGEsXG4gICAgICAgIGNvbG9yOiBcIiM3YTc1N2FcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmludmFsaWQsXG4gICAgICAgIGNvbG9yOiBcIiNmMDBcIiB9XG5dKTtcbi8qKlxuVGhpcyBpcyBhIGhpZ2hsaWdodCBzdHlsZSB0aGF0IGFkZHMgc3RhYmxlLCBwcmVkaWN0YWJsZSBjbGFzc2VzIHRvXG50b2tlbnMsIGZvciBzdHlsaW5nIHdpdGggZXh0ZXJuYWwgQ1NTLlxuXG5UaGVzZSB0YWdzIGFyZSBtYXBwZWQgdG8gdGhlaXIgbmFtZSBwcmVmaXhlZCB3aXRoIGBcImNtdC1cImAgKGZvclxuZXhhbXBsZSBgXCJjbXQtY29tbWVudFwiYCk6XG5cbiogW2BsaW5rYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5saW5rKVxuKiBbYGhlYWRpbmdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpXG4qIFtgZW1waGFzaXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmVtcGhhc2lzKVxuKiBbYHN0cm9uZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3Muc3Ryb25nKVxuKiBbYGtleXdvcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpXG4qIFtgYXRvbWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MuYXRvbSkgW2Bib29sYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5ib29sKVxuKiBbYHVybGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MudXJsKVxuKiBbYGxhYmVsTmFtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MubGFiZWxOYW1lKVxuKiBbYGluc2VydGVkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5pbnNlcnRlZClcbiogW2BkZWxldGVkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5kZWxldGVkKVxuKiBbYGxpdGVyYWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpXG4qIFtgc3RyaW5nYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4qIFtgbnVtYmVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5udW1iZXIpXG4qIFtgdmFyaWFibGVOYW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4qIFtgdHlwZU5hbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKVxuKiBbYG5hbWVzcGFjZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MubmFtZXNwYWNlKVxuKiBbYGNsYXNzTmFtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MuY2xhc3NOYW1lKVxuKiBbYG1hY3JvTmFtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MubWFjcm9OYW1lKVxuKiBbYHByb3BlcnR5TmFtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuKiBbYG9wZXJhdG9yYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5vcGVyYXRvcilcbiogW2Bjb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5jb21tZW50KVxuKiBbYG1ldGFgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLm1ldGEpXG4qIFtgcHVuY3R1YXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLnB1bmN1dGF0aW9uKVxuKiBbYGludmFsaWRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLmludmFsaWQpXG5cbkluIGFkZGl0aW9uLCB0aGVzZSBtYXBwaW5ncyBhcmUgcHJvdmlkZWQ6XG5cbiogW2ByZWdleHBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLnJlZ2V4cCksXG4gIFtgZXNjYXBlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5lc2NhcGUpLCBhbmRcbiAgW2BzcGVjaWFsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHN0cmluZylgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbiAgYXJlIG1hcHBlZCB0byBgXCJjbXQtc3RyaW5nMlwiYFxuKiBbYHNwZWNpYWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2AodmFyaWFibGVOYW1lKWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJjbXQtdmFyaWFibGVOYW1lMlwiYFxuKiBbYGxvY2FsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5sb2NhbClbYCh2YXJpYWJsZU5hbWUpYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcImNtdC12YXJpYWJsZU5hbWUgY210LWxvY2FsXCJgXG4qIFtgZGVmaW5pdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYCh2YXJpYWJsZU5hbWUpYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcImNtdC12YXJpYWJsZU5hbWUgY210LWRlZmluaXRpb25cImBcbiogW2BkZWZpbml0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHByb3BlcnR5TmFtZSlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiAgdG8gYFwiY210LXByb3BlcnR5TmFtZSBjbXQtZGVmaW5pdGlvblwiYFxuKi9cbmNvbnN0IGNsYXNzSGlnaGxpZ2h0U3R5bGUgPSAvKkBfX1BVUkVfXyovSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICB7IHRhZzogdGFncy5saW5rLCBjbGFzczogXCJjbXQtbGlua1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZywgY2xhc3M6IFwiY210LWhlYWRpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLCBjbGFzczogXCJjbXQtZW1waGFzaXNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZywgY2xhc3M6IFwiY210LXN0cm9uZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCwgY2xhc3M6IFwiY210LWtleXdvcmRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmF0b20sIGNsYXNzOiBcImNtdC1hdG9tXCIgfSxcbiAgICB7IHRhZzogdGFncy5ib29sLCBjbGFzczogXCJjbXQtYm9vbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudXJsLCBjbGFzczogXCJjbXQtdXJsXCIgfSxcbiAgICB7IHRhZzogdGFncy5sYWJlbE5hbWUsIGNsYXNzOiBcImNtdC1sYWJlbE5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmluc2VydGVkLCBjbGFzczogXCJjbXQtaW5zZXJ0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlbGV0ZWQsIGNsYXNzOiBcImNtdC1kZWxldGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5saXRlcmFsLCBjbGFzczogXCJjbXQtbGl0ZXJhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaW5nLCBjbGFzczogXCJjbXQtc3RyaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5udW1iZXIsIGNsYXNzOiBcImNtdC1udW1iZXJcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sIGNsYXNzOiBcImNtdC1zdHJpbmcyXCIgfSxcbiAgICB7IHRhZzogdGFncy52YXJpYWJsZU5hbWUsIGNsYXNzOiBcImNtdC12YXJpYWJsZU5hbWVcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcImNtdC12YXJpYWJsZU5hbWUgY210LWxvY2FsXCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcImNtdC12YXJpYWJsZU5hbWUgY210LWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwiY210LXZhcmlhYmxlTmFtZTJcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSwgY2xhc3M6IFwiY210LXByb3BlcnR5TmFtZSBjbXQtZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudHlwZU5hbWUsIGNsYXNzOiBcImNtdC10eXBlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubmFtZXNwYWNlLCBjbGFzczogXCJjbXQtbmFtZXNwYWNlXCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsIGNsYXNzOiBcImNtdC1jbGFzc05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1hY3JvTmFtZSwgY2xhc3M6IFwiY210LW1hY3JvTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHJvcGVydHlOYW1lLCBjbGFzczogXCJjbXQtcHJvcGVydHlOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5vcGVyYXRvciwgY2xhc3M6IFwiY210LW9wZXJhdG9yXCIgfSxcbiAgICB7IHRhZzogdGFncy5jb21tZW50LCBjbGFzczogXCJjbXQtY29tbWVudFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWV0YSwgY2xhc3M6IFwiY210LW1ldGFcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmludmFsaWQsIGNsYXNzOiBcImNtdC1pbnZhbGlkXCIgfSxcbiAgICB7IHRhZzogdGFncy5wdW5jdHVhdGlvbiwgY2xhc3M6IFwiY210LXB1bmN0dWF0aW9uXCIgfVxuXSk7XG5cbmV4cG9ydCB7IEhpZ2hsaWdodFN0eWxlLCBUYWcsIGNsYXNzSGlnaGxpZ2h0U3R5bGUsIGRlZmF1bHRIaWdobGlnaHRTdHlsZSwgaGlnaGxpZ2h0VHJlZSwgc3R5bGVUYWdzLCB0YWdzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/highlight/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/language/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IndentContext\": function() { return /* binding */ IndentContext; },\n/* harmony export */   \"LRLanguage\": function() { return /* binding */ LRLanguage; },\n/* harmony export */   \"Language\": function() { return /* binding */ Language; },\n/* harmony export */   \"LanguageDescription\": function() { return /* binding */ LanguageDescription; },\n/* harmony export */   \"LanguageSupport\": function() { return /* binding */ LanguageSupport; },\n/* harmony export */   \"ParseContext\": function() { return /* binding */ ParseContext; },\n/* harmony export */   \"TreeIndentContext\": function() { return /* binding */ TreeIndentContext; },\n/* harmony export */   \"continuedIndent\": function() { return /* binding */ continuedIndent; },\n/* harmony export */   \"defineLanguageFacet\": function() { return /* binding */ defineLanguageFacet; },\n/* harmony export */   \"delimitedIndent\": function() { return /* binding */ delimitedIndent; },\n/* harmony export */   \"ensureSyntaxTree\": function() { return /* binding */ ensureSyntaxTree; },\n/* harmony export */   \"flatIndent\": function() { return /* binding */ flatIndent; },\n/* harmony export */   \"foldInside\": function() { return /* binding */ foldInside; },\n/* harmony export */   \"foldNodeProp\": function() { return /* binding */ foldNodeProp; },\n/* harmony export */   \"foldService\": function() { return /* binding */ foldService; },\n/* harmony export */   \"foldable\": function() { return /* binding */ foldable; },\n/* harmony export */   \"getIndentUnit\": function() { return /* binding */ getIndentUnit; },\n/* harmony export */   \"getIndentation\": function() { return /* binding */ getIndentation; },\n/* harmony export */   \"indentNodeProp\": function() { return /* binding */ indentNodeProp; },\n/* harmony export */   \"indentOnInput\": function() { return /* binding */ indentOnInput; },\n/* harmony export */   \"indentService\": function() { return /* binding */ indentService; },\n/* harmony export */   \"indentString\": function() { return /* binding */ indentString; },\n/* harmony export */   \"indentUnit\": function() { return /* binding */ indentUnit; },\n/* harmony export */   \"language\": function() { return /* binding */ language; },\n/* harmony export */   \"languageDataProp\": function() { return /* binding */ languageDataProp; },\n/* harmony export */   \"syntaxTree\": function() { return /* binding */ syntaxTree; }\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n/**\nNode prop stored in a grammar's top syntax node to provide the\nfacet that stores language data for that language.\n*/\n\nvar languageDataProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nHelper function to define a facet (to be added to the top syntax\nnode(s) for a language via\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\nused to associate language data with the language. You\nprobably only need this when subclassing\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\n*/\n\nfunction defineLanguageFacet(baseData) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine: baseData ? function (values) {\n      return values.concat(baseData);\n    } : undefined\n  });\n}\n/**\nA language object manages parsing and per-language\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. You'll\nwant to subclass this class for custom parsers, or use the\n[`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage) or\n[`StreamLanguage`](https://codemirror.net/6/docs/ref/#stream-parser.StreamLanguage) abstractions for\n[Lezer](https://lezer.codemirror.net/) or stream parsers.\n*/\n\n\nvar Language = /*#__PURE__*/function () {\n  /**\n  Construct a language object. You usually don't need to invoke\n  this directly. But when you do, make sure you use\n  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet) to create\n  the first argument.\n  */\n  function Language(\n  /**\n  The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) data\n  facet used for this language.\n  */\n  data, parser,\n  /**\n  The node type of the top node of trees produced by this parser.\n  */\n  topNode) {\n    var extraExtensions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    _classCallCheck(this, Language);\n\n    this.data = data;\n    this.topNode = topNode; // Kludge to define EditorState.tree as a debugging helper,\n    // without the EditorState package actually knowing about\n    // languages and lezer trees.\n\n    if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.prototype.hasOwnProperty(\"tree\")) Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.prototype, \"tree\", {\n      get: function get() {\n        return syntaxTree(this);\n      }\n    });\n    this.parser = parser;\n    this.extension = [language.of(this), _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.languageData.of(function (state, pos, side) {\n      return state.facet(languageDataFacetAt(state, pos, side));\n    })].concat(extraExtensions);\n  }\n  /**\n  Query whether this language is active at the given position.\n  */\n\n\n  _createClass(Language, [{\n    key: \"isActiveAt\",\n    value: function isActiveAt(state, pos) {\n      var side = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      return languageDataFacetAt(state, pos, side) == this.data;\n    }\n    /**\n    Find the document regions that were parsed using this language.\n    The returned regions will _include_ any nested languages rooted\n    in this language, when those exist.\n    */\n\n  }, {\n    key: \"findRegions\",\n    value: function findRegions(state) {\n      var _this = this;\n\n      var lang = state.facet(language);\n      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [{\n        from: 0,\n        to: state.doc.length\n      }];\n      if (!lang || !lang.allowsNesting) return [];\n      var result = [];\n\n      var explore = function explore(tree, from) {\n        if (tree.prop(languageDataProp) == _this.data) {\n          result.push({\n            from: from,\n            to: from + tree.length\n          });\n          return;\n        }\n\n        var mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n\n        if (mount) {\n          if (mount.tree.prop(languageDataProp) == _this.data) {\n            if (mount.overlay) {\n              var _iterator = _createForOfIteratorHelper(mount.overlay),\n                  _step;\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var r = _step.value;\n                  result.push({\n                    from: r.from + from,\n                    to: r.to + from\n                  });\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n            } else result.push({\n              from: from,\n              to: from + tree.length\n            });\n\n            return;\n          } else if (mount.overlay) {\n            var size = result.length;\n            explore(mount.tree, mount.overlay[0].from + from);\n            if (result.length > size) return;\n          }\n        }\n\n        for (var i = 0; i < tree.children.length; i++) {\n          var ch = tree.children[i];\n          if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) explore(ch, tree.positions[i] + from);\n        }\n      };\n\n      explore(syntaxTree(state), 0);\n      return result;\n    }\n    /**\n    Indicates whether this language allows nested languages. The\n    default implementation returns true.\n    */\n\n  }, {\n    key: \"allowsNesting\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return Language;\n}();\n/**\n@internal\n*/\n\n\nLanguage.setState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\n\nfunction languageDataFacetAt(state, pos, side) {\n  var topLang = state.facet(language);\n  if (!topLang) return null;\n  var facet = topLang.data;\n\n  if (topLang.allowsNesting) {\n    for (var node = syntaxTree(state).topNode; node; node = node.enter(pos, side, true, false)) {\n      facet = node.type.prop(languageDataProp) || facet;\n    }\n  }\n\n  return facet;\n}\n/**\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\nparsers.\n*/\n\n\nvar LRLanguage = /*#__PURE__*/function (_Language) {\n  _inherits(LRLanguage, _Language);\n\n  var _super = _createSuper(LRLanguage);\n\n  function LRLanguage(data, parser) {\n    var _this2;\n\n    _classCallCheck(this, LRLanguage);\n\n    _this2 = _super.call(this, data, parser, parser.topNode);\n    _this2.parser = parser;\n    return _this2;\n  }\n  /**\n  Define a language from a parser.\n  */\n\n\n  _createClass(LRLanguage, [{\n    key: \"configure\",\n    value:\n    /**\n    Create a new instance of this language with a reconfigured\n    version of its parser.\n    */\n    function configure(options) {\n      return new LRLanguage(this.data, this.parser.configure(options));\n    }\n  }, {\n    key: \"allowsNesting\",\n    get: function get() {\n      return this.parser.wrappers.length > 0;\n    } // FIXME\n\n  }], [{\n    key: \"define\",\n    value: function define(spec) {\n      var data = defineLanguageFacet(spec.languageData);\n      return new LRLanguage(data, spec.parser.configure({\n        props: [languageDataProp.add(function (type) {\n          return type.isTop ? data : undefined;\n        })]\n      }));\n    }\n  }]);\n\n  return LRLanguage;\n}(Language);\n/**\nGet the syntax tree for a state, which is the current (possibly\nincomplete) parse tree of active [language](https://codemirror.net/6/docs/ref/#language.Language),\nor the empty tree if there is no language available.\n*/\n\n\nfunction syntaxTree(state) {\n  var field = state.field(Language.state, false);\n  return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n}\n/**\nTry to get a parse tree that spans at least up to `upto`. The\nmethod will do at most `timeout` milliseconds of work to parse\nup to that point if the tree isn't already available.\n*/\n\n\nfunction ensureSyntaxTree(state, upto) {\n  var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;\n\n  var _a;\n\n  var parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n  return !parse ? null : parse.treeLen >= upto || parse.work(timeout, upto) ? parse.tree : null;\n} // Lezer-style Input object for a Text document.\n\n\nvar DocInput = /*#__PURE__*/function () {\n  function DocInput(doc) {\n    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : doc.length;\n\n    _classCallCheck(this, DocInput);\n\n    this.doc = doc;\n    this.length = length;\n    this.cursorPos = 0;\n    this.string = \"\";\n    this.cursor = doc.iter();\n  }\n\n  _createClass(DocInput, [{\n    key: \"syncTo\",\n    value: function syncTo(pos) {\n      this.string = this.cursor.next(pos - this.cursorPos).value;\n      this.cursorPos = pos + this.string.length;\n      return this.cursorPos - this.string.length;\n    }\n  }, {\n    key: \"chunk\",\n    value: function chunk(pos) {\n      this.syncTo(pos);\n      return this.string;\n    }\n  }, {\n    key: \"lineChunks\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"read\",\n    value: function read(from, to) {\n      var stringStart = this.cursorPos - this.string.length;\n      if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);else return this.string.slice(from - stringStart, to - stringStart);\n    }\n  }]);\n\n  return DocInput;\n}();\n\nvar currentContext = null;\n/**\nA parse context provided to parsers working on the editor content.\n*/\n\nvar ParseContext = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function ParseContext(parser,\n  /**\n  The current editor state.\n  */\n  state) {\n    var fragments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var\n    /**\n    @internal\n    */\n    tree = arguments.length > 3 ? arguments[3] : undefined;\n    var treeLen = arguments.length > 4 ? arguments[4] : undefined;\n    var\n    /**\n    The current editor viewport (or some overapproximation\n    thereof). Intended to be used for opportunistically avoiding\n    work (in which case\n    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.EditorParseContext.skipUntilInView)\n    should be called to make sure the parser is restarted when the\n    skipped region becomes visible).\n    */\n    viewport = arguments.length > 5 ? arguments[5] : undefined;\n    var\n    /**\n    @internal\n    */\n    skipped = arguments.length > 6 ? arguments[6] : undefined;\n    var\n    /**\n    This is where skipping parsers can register a promise that,\n    when resolved, will schedule a new parse. It is cleared when\n    the parse worker picks up the promise. @internal\n    */\n    scheduleOn = arguments.length > 7 ? arguments[7] : undefined;\n\n    _classCallCheck(this, ParseContext);\n\n    this.parser = parser;\n    this.state = state;\n    this.fragments = fragments;\n    this.tree = tree;\n    this.treeLen = treeLen;\n    this.viewport = viewport;\n    this.skipped = skipped;\n    this.scheduleOn = scheduleOn;\n    this.parse = null;\n    /**\n    @internal\n    */\n\n    this.tempSkipped = [];\n  }\n\n  _createClass(ParseContext, [{\n    key: \"startParse\",\n    value: function startParse() {\n      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"work\",\n    value: function work(time, upto) {\n      var _this3 = this;\n\n      if (upto != null && upto >= this.state.doc.length) upto = undefined;\n\n      if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && (upto == null ? this.treeLen == this.state.doc.length : this.treeLen >= upto)) {\n        this.takeTree();\n        return true;\n      }\n\n      return this.withContext(function () {\n        var _a;\n\n        if (!_this3.parse) _this3.parse = _this3.startParse();\n        if (upto != null && (_this3.parse.stoppedAt == null || _this3.parse.stoppedAt > upto) && upto < _this3.state.doc.length) _this3.parse.stopAt(upto);\n        var endTime = Date.now() + time;\n\n        for (;;) {\n          var done = _this3.parse.advance();\n\n          if (done) {\n            _this3.fragments = _this3.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, _this3.fragments, _this3.parse.stoppedAt != null));\n            _this3.treeLen = (_a = _this3.parse.stoppedAt) !== null && _a !== void 0 ? _a : _this3.state.doc.length;\n            _this3.tree = done;\n            _this3.parse = null;\n            if (_this3.treeLen < (upto !== null && upto !== void 0 ? upto : _this3.state.doc.length)) _this3.parse = _this3.startParse();else return true;\n          }\n\n          if (Date.now() > endTime) return false;\n        }\n      });\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"takeTree\",\n    value: function takeTree() {\n      var _this4 = this;\n\n      var pos, tree;\n\n      if (this.parse && (pos = this.parse.parsedPos) > this.treeLen) {\n        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);\n        this.withContext(function () {\n          while (!(tree = _this4.parse.advance())) {}\n        });\n        this.tree = tree;\n        this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\n        this.parse = null;\n      }\n    }\n  }, {\n    key: \"withContext\",\n    value: function withContext(f) {\n      var prev = currentContext;\n      currentContext = this;\n\n      try {\n        return f();\n      } finally {\n        currentContext = prev;\n      }\n    }\n  }, {\n    key: \"withoutTempSkipped\",\n    value: function withoutTempSkipped(fragments) {\n      for (var r; r = this.tempSkipped.pop();) {\n        fragments = cutFragments(fragments, r.from, r.to);\n      }\n\n      return fragments;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"changes\",\n    value: function changes(_changes, newState) {\n      var fragments = this.fragments,\n          tree = this.tree,\n          treeLen = this.treeLen,\n          viewport = this.viewport,\n          skipped = this.skipped;\n      this.takeTree();\n\n      if (!_changes.empty) {\n        var ranges = [];\n\n        _changes.iterChangedRanges(function (fromA, toA, fromB, toB) {\n          return ranges.push({\n            fromA: fromA,\n            toA: toA,\n            fromB: fromB,\n            toB: toB\n          });\n        });\n\n        fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\n        tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n        treeLen = 0;\n        viewport = {\n          from: _changes.mapPos(viewport.from, -1),\n          to: _changes.mapPos(viewport.to, 1)\n        };\n\n        if (this.skipped.length) {\n          skipped = [];\n\n          var _iterator2 = _createForOfIteratorHelper(this.skipped),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var r = _step2.value;\n\n              var from = _changes.mapPos(r.from, 1),\n                  to = _changes.mapPos(r.to, -1);\n\n              if (from < to) skipped.push({\n                from: from,\n                to: to\n              });\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      }\n\n      return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"updateViewport\",\n    value: function updateViewport(viewport) {\n      this.viewport = viewport;\n      var startLen = this.skipped.length;\n\n      for (var i = 0; i < this.skipped.length; i++) {\n        var _this$skipped$i = this.skipped[i],\n            from = _this$skipped$i.from,\n            to = _this$skipped$i.to;\n\n        if (from < viewport.to && to > viewport.from) {\n          this.fragments = cutFragments(this.fragments, from, to);\n          this.skipped.splice(i--, 1);\n        }\n      }\n\n      return this.skipped.length < startLen;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.parse) {\n        this.takeTree();\n        this.parse = null;\n      }\n    }\n    /**\n    Notify the parse scheduler that the given region was skipped\n    because it wasn't in view, and the parse should be restarted\n    when it comes into view.\n    */\n\n  }, {\n    key: \"skipUntilInView\",\n    value: function skipUntilInView(from, to) {\n      this.skipped.push({\n        from: from,\n        to: to\n      });\n    }\n    /**\n    Returns a parser intended to be used as placeholder when\n    asynchronously loading a nested parser. It'll skip its input and\n    mark it as not-really-parsed, so that the next update will parse\n    it again.\n    \n    When `until` is given, a reparse will be scheduled when that\n    promise resolves.\n    */\n\n  }, {\n    key: \"movedPast\",\n    value:\n    /**\n    @internal\n    */\n    function movedPast(pos) {\n      return this.treeLen < pos && this.parse && this.parse.parsedPos >= pos;\n    }\n    /**\n    Get the context for the current parse, or `null` if no editor\n    parse is in progress.\n    */\n\n  }], [{\n    key: \"getSkippingParser\",\n    value: function getSkippingParser(until) {\n      return new ( /*#__PURE__*/function (_Parser) {\n        _inherits(_class, _Parser);\n\n        var _super2 = _createSuper(_class);\n\n        function _class() {\n          _classCallCheck(this, _class);\n\n          return _super2.apply(this, arguments);\n        }\n\n        _createClass(_class, [{\n          key: \"createParse\",\n          value: function createParse(input, fragments, ranges) {\n            var from = ranges[0].from,\n                to = ranges[ranges.length - 1].to;\n            var parser = {\n              parsedPos: from,\n              advance: function advance() {\n                var cx = currentContext;\n\n                if (cx) {\n                  var _iterator3 = _createForOfIteratorHelper(ranges),\n                      _step3;\n\n                  try {\n                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                      var r = _step3.value;\n                      cx.tempSkipped.push(r);\n                    }\n                  } catch (err) {\n                    _iterator3.e(err);\n                  } finally {\n                    _iterator3.f();\n                  }\n\n                  if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;\n                }\n\n                this.parsedPos = to;\n                return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\n              },\n              stoppedAt: null,\n              stopAt: function stopAt() {}\n            };\n            return parser;\n          }\n        }]);\n\n        return _class;\n      }(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser))();\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      return currentContext;\n    }\n  }]);\n\n  return ParseContext;\n}();\n\nfunction cutFragments(fragments, from, to) {\n  return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [{\n    fromA: from,\n    toA: to,\n    fromB: from,\n    toB: to\n  }]);\n}\n\nvar LanguageState = /*#__PURE__*/function () {\n  function LanguageState( // A mutable parse state that is used to preserve work done during\n  // the lifetime of a state when moving to the next state.\n  context) {\n    _classCallCheck(this, LanguageState);\n\n    this.context = context;\n    this.tree = context.tree;\n  }\n\n  _createClass(LanguageState, [{\n    key: \"apply\",\n    value: function apply(tr) {\n      if (!tr.docChanged) return this;\n      var newCx = this.context.changes(tr.changes, tr.state); // If the previous parse wasn't done, go forward only up to its\n      // end position or the end of the viewport, to avoid slowing down\n      // state updates with parse work beyond the viewport.\n\n      var upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\n      if (!newCx.work(25\n      /* Apply */\n      , upto)) newCx.takeTree();\n      return new LanguageState(newCx);\n    }\n  }], [{\n    key: \"init\",\n    value: function init(state) {\n      var parseState = new ParseContext(state.facet(language).parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, {\n        from: 0,\n        to: state.doc.length\n      }, [], null);\n      if (!parseState.work(25\n      /* Apply */\n      )) parseState.takeTree();\n      return new LanguageState(parseState);\n    }\n  }]);\n\n  return LanguageState;\n}();\n\nLanguage.state = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n  create: LanguageState.init,\n  update: function update(value, tr) {\n    var _iterator4 = _createForOfIteratorHelper(tr.effects),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var e = _step4.value;\n        if (e.is(Language.setState)) return e.value;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);\n    return value.apply(tr);\n  }\n});\n\nvar requestIdle = typeof window != \"undefined\" && window.requestIdleCallback || function (callback, _ref) {\n  var timeout = _ref.timeout;\n  return setTimeout(callback, timeout);\n};\n\nvar cancelIdle = typeof window != \"undefined\" && window.cancelIdleCallback || clearTimeout;\nvar parseWorker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function ParseWorker(view) {\n    _classCallCheck(this, ParseWorker);\n\n    this.view = view;\n    this.working = -1; // End of the current time chunk\n\n    this.chunkEnd = -1; // Milliseconds of budget left for this chunk\n\n    this.chunkBudget = -1;\n    this.work = this.work.bind(this);\n    this.scheduleWork();\n  }\n\n  _createClass(ParseWorker, [{\n    key: \"update\",\n    value: function update(_update) {\n      var cx = this.view.state.field(Language.state).context;\n\n      if (_update.viewportChanged) {\n        if (cx.updateViewport(_update.view.viewport)) cx.reset();\n        if (this.view.viewport.to > cx.treeLen) this.scheduleWork();\n      }\n\n      if (_update.docChanged) {\n        if (this.view.hasFocus) this.chunkBudget += 50\n        /* ChangeBonus */\n        ;\n        this.scheduleWork();\n      }\n\n      this.checkAsyncSchedule(cx);\n    }\n  }, {\n    key: \"scheduleWork\",\n    value: function scheduleWork() {\n      if (this.working > -1) return;\n      var state = this.view.state,\n          field = state.field(Language.state),\n          frags = field.context.fragments;\n      if (field.tree == field.context.tree && field.context.treeLen >= state.doc.length && frags.length && frags[0].from == 0 && frags[0].to >= state.doc.length) return;\n      this.working = requestIdle(this.work, {\n        timeout: 500\n        /* Pause */\n\n      });\n    }\n  }, {\n    key: \"work\",\n    value: function work(deadline) {\n      this.working = -1;\n      var now = Date.now();\n\n      if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {\n        // Start a new chunk\n        this.chunkEnd = now + 30000\n        /* ChunkTime */\n        ;\n        this.chunkBudget = 3000\n        /* ChunkBudget */\n        ;\n      }\n\n      if (this.chunkBudget <= 0) return; // No more budget\n\n      var _this$view = this.view,\n          state = _this$view.state,\n          vpTo = _this$view.viewport.to,\n          field = state.field(Language.state);\n      if (field.tree == field.context.tree && field.context.treeLen >= vpTo + 1000000\n      /* MaxParseAhead */\n      ) return;\n      var time = Math.min(this.chunkBudget, deadline ? Math.max(25\n      /* MinSlice */\n      , deadline.timeRemaining()) : 100\n      /* Slice */\n      );\n      var done = field.context.work(time, vpTo + 1000000\n      /* MaxParseAhead */\n      );\n      this.chunkBudget -= Date.now() - now;\n\n      if (done || this.chunkBudget <= 0 || field.context.movedPast(vpTo)) {\n        field.context.takeTree();\n        this.view.dispatch({\n          effects: Language.setState.of(new LanguageState(field.context))\n        });\n      }\n\n      if (!done && this.chunkBudget > 0) this.scheduleWork();\n      this.checkAsyncSchedule(field.context);\n    }\n  }, {\n    key: \"checkAsyncSchedule\",\n    value: function checkAsyncSchedule(cx) {\n      var _this5 = this;\n\n      if (cx.scheduleOn) {\n        cx.scheduleOn.then(function () {\n          return _this5.scheduleWork();\n        });\n        cx.scheduleOn = null;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.working >= 0) cancelIdle(this.working);\n    }\n  }]);\n\n  return ParseWorker;\n}(), {\n  eventHandlers: {\n    focus: function focus() {\n      this.scheduleWork();\n    }\n  }\n});\n/**\nThe facet used to associate a language with an editor state.\n*/\n\nvar language = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n  combine: function combine(languages) {\n    return languages.length ? languages[0] : null;\n  },\n  enables: [Language.state, parseWorker]\n});\n/**\nThis class bundles a [language object](https://codemirror.net/6/docs/ref/#language.Language) with an\noptional set of supporting extensions. Language packages are\nencouraged to export a function that optionally takes a\nconfiguration object and returns a `LanguageSupport` instance, as\nthe main way for client code to use the package.\n*/\n\nvar LanguageSupport =\n/**\nCreate a support object.\n*/\nfunction LanguageSupport(\n/**\nThe language object.\n*/\nlanguage) {\n  var support = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  _classCallCheck(this, LanguageSupport);\n\n  this.language = language;\n  this.support = support;\n  this.extension = [language, support];\n};\n/**\nLanguage descriptions are used to store metadata about languages\nand to dynamically load them. Their main role is finding the\nappropriate language for a filename or dynamically loading nested\nparsers.\n*/\n\n\nvar LanguageDescription = /*#__PURE__*/function () {\n  function LanguageDescription(\n  /**\n  The name of this language.\n  */\n  name,\n  /**\n  Alternative names for the mode (lowercased, includes `this.name`).\n  */\n  alias,\n  /**\n  File extensions associated with this language.\n  */\n  extensions,\n  /**\n  Optional filename pattern that should be associated with this\n  language.\n  */\n  filename, loadFunc) {\n    _classCallCheck(this, LanguageDescription);\n\n    this.name = name;\n    this.alias = alias;\n    this.extensions = extensions;\n    this.filename = filename;\n    this.loadFunc = loadFunc;\n    /**\n    If the language has been loaded, this will hold its value.\n    */\n\n    this.support = undefined;\n    this.loading = null;\n  }\n  /**\n  Start loading the the language. Will return a promise that\n  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\n  object when the language successfully loads.\n  */\n\n\n  _createClass(LanguageDescription, [{\n    key: \"load\",\n    value: function load() {\n      var _this6 = this;\n\n      return this.loading || (this.loading = this.loadFunc().then(function (support) {\n        return _this6.support = support;\n      }, function (err) {\n        _this6.loading = null;\n        throw err;\n      }));\n    }\n    /**\n    Create a language description.\n    */\n\n  }], [{\n    key: \"of\",\n    value: function of(spec) {\n      return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(function (s) {\n        return s.toLowerCase();\n      }), spec.extensions || [], spec.filename, spec.load);\n    }\n    /**\n    Look for a language in the given array of descriptions that\n    matches the filename. Will first match\n    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\n    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\n    and return the first language that matches.\n    */\n\n  }, {\n    key: \"matchFilename\",\n    value: function matchFilename(descs, filename) {\n      var _iterator5 = _createForOfIteratorHelper(descs),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _d = _step5.value;\n          if (_d.filename && _d.filename.test(filename)) return _d;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var ext = /\\.([^.]+)$/.exec(filename);\n\n      if (ext) {\n        var _iterator6 = _createForOfIteratorHelper(descs),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var d = _step6.value;\n            if (d.extensions.indexOf(ext[1]) > -1) return d;\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n\n      return null;\n    }\n    /**\n    Look for a language whose name or alias matches the the given\n    name (case-insensitively). If `fuzzy` is true, and no direct\n    matchs is found, this'll also search for a language whose name\n    or alias occurs in the string (for names shorter than three\n    characters, only when surrounded by non-word characters).\n    */\n\n  }, {\n    key: \"matchLanguageName\",\n    value: function matchLanguageName(descs, name) {\n      var fuzzy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      name = name.toLowerCase();\n\n      var _iterator7 = _createForOfIteratorHelper(descs),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _d2 = _step7.value;\n          if (_d2.alias.some(function (a) {\n            return a == name;\n          })) return _d2;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      if (fuzzy) {\n        var _iterator8 = _createForOfIteratorHelper(descs),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var d = _step8.value;\n\n            var _iterator9 = _createForOfIteratorHelper(d.alias),\n                _step9;\n\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var a = _step9.value;\n                var found = name.indexOf(a);\n                if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length]))) return d;\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return LanguageDescription;\n}();\n/**\nFacet that defines a way to provide a function that computes the\nappropriate indentation depth at the start of a given line, or\n`null` to indicate no appropriate indentation could be determined.\n*/\n\n\nvar indentService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\n/**\nFacet for overriding the unit by which indentation happens.\nShould be a string consisting either entirely of spaces or\nentirely of tabs. When not set, this defaults to 2 spaces.\n*/\n\nvar indentUnit = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n  combine: function combine(values) {\n    if (!values.length) return \"  \";\n    if (!/^(?: +|\\t+)$/.test(values[0])) throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n    return values[0];\n  }\n});\n/**\nReturn the _column width_ of an indent unit in the state.\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\ncontains tabs.\n*/\n\nfunction getIndentUnit(state) {\n  var unit = state.facet(indentUnit);\n  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/**\nCreate an indentation string that covers columns 0 to `cols`.\nWill use tabs for as much of the columns as possible when the\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\ntabs.\n*/\n\n\nfunction indentString(state, cols) {\n  var result = \"\",\n      ts = state.tabSize;\n  if (state.facet(indentUnit).charCodeAt(0) == 9) while (cols >= ts) {\n    result += \"\\t\";\n    cols -= ts;\n  }\n\n  for (var i = 0; i < cols; i++) {\n    result += \" \";\n  }\n\n  return result;\n}\n/**\nGet the indentation at the given position. Will first consult any\n[indent services](https://codemirror.net/6/docs/ref/#language.indentService) that are registered,\nand if none of those return an indentation, this will check the\nsyntax tree for the [indent node prop](https://codemirror.net/6/docs/ref/#language.indentNodeProp)\nand use that if found. Returns a number when an indentation could\nbe determined, and null otherwise.\n*/\n\n\nfunction getIndentation(context, pos) {\n  if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState) context = new IndentContext(context);\n\n  var _iterator10 = _createForOfIteratorHelper(context.state.facet(indentService)),\n      _step10;\n\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var service = _step10.value;\n      var result = service(context, pos);\n      if (result != null) return result;\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  var tree = syntaxTree(context.state);\n  return tree ? syntaxIndentation(context, tree, pos) : null;\n}\n/**\nIndentation contexts are used when calling [indentation\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\nuseful in indentation logic, and can selectively override the\nindentation reported for some lines.\n*/\n\n\nvar IndentContext = /*#__PURE__*/function () {\n  /**\n  Create an indent context.\n  */\n  function IndentContext(\n  /**\n  The editor state.\n  */\n  state) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, IndentContext);\n\n    this.state = state;\n    this.options = options;\n    this.unit = getIndentUnit(state);\n  }\n  /**\n  Get a description of the line at the given position, taking\n  [simulated line\n  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n  into account. If there is such a break at `pos`, the `bias`\n  argument determines whether the part of the line line before or\n  after the break is used.\n  */\n\n\n  _createClass(IndentContext, [{\n    key: \"lineAt\",\n    value: function lineAt(pos) {\n      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var line = this.state.doc.lineAt(pos);\n      var simulateBreak = this.options.simulateBreak;\n\n      if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\n        if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {\n          text: line.text.slice(simulateBreak - line.from),\n          from: simulateBreak\n        };else return {\n          text: line.text.slice(0, simulateBreak - line.from),\n          from: line.from\n        };\n      }\n\n      return line;\n    }\n    /**\n    Get the text directly after `pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */\n\n  }, {\n    key: \"textAfterPos\",\n    value: function textAfterPos(pos) {\n      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return \"\";\n\n      var _this$lineAt = this.lineAt(pos, bias),\n          text = _this$lineAt.text,\n          from = _this$lineAt.from;\n\n      return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\n    }\n    /**\n    Find the column for the given position.\n    */\n\n  }, {\n    key: \"column\",\n    value: function column(pos) {\n      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var _this$lineAt2 = this.lineAt(pos, bias),\n          text = _this$lineAt2.text,\n          from = _this$lineAt2.from;\n\n      var result = this.countColumn(text, pos - from);\n      var override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\n      if (override > -1) result += override - this.countColumn(text, text.search(/\\S|$/));\n      return result;\n    }\n    /**\n    Find the column position (taking tabs into account) of the given\n    position in the given string.\n    */\n\n  }, {\n    key: \"countColumn\",\n    value: function countColumn(line) {\n      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : line.length;\n      return (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\n    }\n    /**\n    Find the indentation column of the line at the given point.\n    */\n\n  }, {\n    key: \"lineIndent\",\n    value: function lineIndent(pos) {\n      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var _this$lineAt3 = this.lineAt(pos, bias),\n          text = _this$lineAt3.text,\n          from = _this$lineAt3.from;\n\n      var override = this.options.overrideIndentation;\n\n      if (override) {\n        var overriden = override(from);\n        if (overriden > -1) return overriden;\n      }\n\n      return this.countColumn(text, text.search(/\\S|$/));\n    }\n    /**\n    Returns the [simulated line\n    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    for this context, if any.\n    */\n\n  }, {\n    key: \"simulatedBreak\",\n    get: function get() {\n      return this.options.simulateBreak || null;\n    }\n  }]);\n\n  return IndentContext;\n}();\n/**\nA syntax tree node prop used to associate indentation strategies\nwith node types. Such a strategy is a function from an indentation\ncontext to a column number or null, where null indicates that no\ndefinitive indentation can be determined.\n*/\n\n\nvar indentNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp(); // Compute the indentation for a given position from the syntax tree.\n\nfunction syntaxIndentation(cx, ast, pos) {\n  var tree = ast.resolveInner(pos); // Enter previous nodes that end in empty error terms, which means\n  // they were broken off by error recovery, so that indentation\n  // works even if the constructs haven't been finished.\n\n  for (var scan = tree, scanPos = pos;;) {\n    var last = scan.childBefore(scanPos);\n    if (!last) break;\n\n    if (last.type.isError && last.from == last.to) {\n      tree = scan;\n      scanPos = last.from;\n    } else {\n      scan = last;\n      scanPos = scan.to + 1;\n    }\n  }\n\n  return indentFrom(tree, pos, cx);\n}\n\nfunction ignoreClosed(cx) {\n  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\n}\n\nfunction indentStrategy(tree) {\n  var strategy = tree.type.prop(indentNodeProp);\n  if (strategy) return strategy;\n  var first = tree.firstChild,\n      close;\n\n  if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\n    var last = tree.lastChild,\n        closed = last && close.indexOf(last.name) > -1;\n    return function (cx) {\n      return delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n    };\n  }\n\n  return tree.parent == null ? topIndent : null;\n}\n\nfunction indentFrom(node, pos, base) {\n  for (; node; node = node.parent) {\n    var strategy = indentStrategy(node);\n    if (strategy) return strategy(new TreeIndentContext(base, pos, node));\n  }\n\n  return null;\n}\n\nfunction topIndent() {\n  return 0;\n}\n/**\nObjects of this type provide context information and helper\nmethods to indentation functions.\n*/\n\n\nvar TreeIndentContext = /*#__PURE__*/function (_IndentContext) {\n  _inherits(TreeIndentContext, _IndentContext);\n\n  var _super3 = _createSuper(TreeIndentContext);\n\n  /**\n  @internal\n  */\n  function TreeIndentContext(base,\n  /**\n  The position at which indentation is being computed.\n  */\n  pos,\n  /**\n  The syntax tree node to which the indentation strategy\n  applies.\n  */\n  node) {\n    var _this7;\n\n    _classCallCheck(this, TreeIndentContext);\n\n    _this7 = _super3.call(this, base.state, base.options);\n    _this7.base = base;\n    _this7.pos = pos;\n    _this7.node = node;\n    return _this7;\n  }\n  /**\n  Get the text directly after `this.pos`, either the entire line\n  or the next 100 characters, whichever is shorter.\n  */\n\n\n  _createClass(TreeIndentContext, [{\n    key: \"textAfter\",\n    get: function get() {\n      return this.textAfterPos(this.pos);\n    }\n    /**\n    Get the indentation at the reference line for `this.node`, which\n    is the line on which it starts, unless there is a node that is\n    _not_ a parent of this node covering the start of that line. If\n    so, the line at the start of that node is tried, again skipping\n    on if it is covered by another such node.\n    */\n\n  }, {\n    key: \"baseIndent\",\n    get: function get() {\n      var line = this.state.doc.lineAt(this.node.from); // Skip line starts that are covered by a sibling (or cousin, etc)\n\n      for (;;) {\n        var atBreak = this.node.resolve(line.from);\n\n        while (atBreak.parent && atBreak.parent.from == atBreak.from) {\n          atBreak = atBreak.parent;\n        }\n\n        if (isParent(atBreak, this.node)) break;\n        line = this.state.doc.lineAt(atBreak.from);\n      }\n\n      return this.lineIndent(line.from);\n    }\n    /**\n    Continue looking for indentations in the node's parent nodes,\n    and return the result of that.\n    */\n\n  }, {\n    key: \"continue\",\n    value: function _continue() {\n      var parent = this.node.parent;\n      return parent ? indentFrom(parent, this.pos, this.base) : 0;\n    }\n  }]);\n\n  return TreeIndentContext;\n}(IndentContext);\n\nfunction isParent(parent, of) {\n  for (var cur = of; cur; cur = cur.parent) {\n    if (parent == cur) return true;\n  }\n\n  return false;\n} // Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\n\n\nfunction bracketedAligned(context) {\n  var tree = context.node;\n  var openToken = tree.childAfter(tree.from),\n      last = tree.lastChild;\n  if (!openToken) return null;\n  var sim = context.options.simulateBreak;\n  var openLine = context.state.doc.lineAt(openToken.from);\n  var lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n\n  for (var pos = openToken.to;;) {\n    var next = tree.childAfter(pos);\n    if (!next || next == last) return null;\n    if (!next.type.isSkipped) return next.from < lineEnd ? openToken : null;\n    pos = next.to;\n  }\n}\n/**\nAn indentation strategy for delimited (usually bracketed) nodes.\nWill, by default, indent one unit more than the parent's base\nindent unless the line starts with a closing token. When `align`\nis true and there are non-skipped nodes on the node's opening\nline, the content of the node will be aligned with the end of the\nopening node, like this:\n\n    foo(bar,\n        baz)\n*/\n\n\nfunction delimitedIndent(_ref2) {\n  var closing = _ref2.closing,\n      _ref2$align = _ref2.align,\n      align = _ref2$align === void 0 ? true : _ref2$align,\n      _ref2$units = _ref2.units,\n      units = _ref2$units === void 0 ? 1 : _ref2$units;\n  return function (context) {\n    return delimitedStrategy(context, align, units, closing);\n  };\n}\n\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n  var after = context.textAfter,\n      space = after.match(/^\\s*/)[0].length;\n  var closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n  var aligned = align ? bracketedAligned(context) : null;\n  if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);\n  return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/**\nAn indentation strategy that aligns a node's content to its base\nindentation.\n*/\n\n\nvar flatIndent = function flatIndent(context) {\n  return context.baseIndent;\n};\n/**\nCreates an indentation strategy that, by default, indents\ncontinued lines one unit more than the node's base indentation.\nYou can provide `except` to prevent indentation of lines that\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\nconstructs), and you can change the amount of units used with the\n`units` option.\n*/\n\n\nfunction continuedIndent() {\n  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      except = _ref3.except,\n      _ref3$units = _ref3.units,\n      units = _ref3$units === void 0 ? 1 : _ref3$units;\n\n  return function (context) {\n    var matchExcept = except && except.test(context.textAfter);\n    return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n  };\n}\n\nvar DontIndentBeyond = 200;\n/**\nEnables reindentation on input. When a language defines an\n`indentOnInput` field in its [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\nexpression, the line at the cursor will be reindented whenever new\ntext is typed and the input from the start of the line up to the\ncursor matches that regexp.\n\nTo avoid unneccesary reindents, it is recommended to start the\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\nadded at the start of a line.\n*/\n\nfunction indentOnInput() {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.transactionFilter.of(function (tr) {\n    if (!tr.docChanged || !tr.isUserEvent(\"input.type\")) return tr;\n    var rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n    if (!rules.length) return tr;\n    var doc = tr.newDoc,\n        head = tr.newSelection.main.head,\n        line = doc.lineAt(head);\n    if (head > line.from + DontIndentBeyond) return tr;\n    var lineStart = doc.sliceString(line.from, head);\n    if (!rules.some(function (r) {\n      return r.test(lineStart);\n    })) return tr;\n    var state = tr.state,\n        last = -1,\n        changes = [];\n\n    var _iterator11 = _createForOfIteratorHelper(state.selection.ranges),\n        _step11;\n\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var _head = _step11.value.head;\n\n        var _line = state.doc.lineAt(_head);\n\n        if (_line.from == last) continue;\n        last = _line.from;\n        var indent = getIndentation(state, _line.from);\n        if (indent == null) continue;\n        var cur = /^\\s*/.exec(_line.text)[0];\n        var norm = indentString(state, indent);\n        if (cur != norm) changes.push({\n          from: _line.from,\n          to: _line.from + cur.length,\n          insert: norm\n        });\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n\n    return changes.length ? [tr, {\n      changes: changes,\n      sequential: true\n    }] : tr;\n  });\n}\n/**\nA facet that registers a code folding service. When called with\nthe extent of a line, such a function should return a foldable\nrange that starts on that line (but continues beyond it), if one\ncan be found.\n*/\n\n\nvar foldService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\n/**\nThis node prop is used to associate folding information with\nsyntax node types. Given a syntax node, it should check whether\nthat tree is foldable and return the range that can be collapsed\nwhen it is.\n*/\n\nvar foldNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\nthe first and the last child of a syntax node. Useful for nodes\nthat start and end with delimiters.\n*/\n\nfunction foldInside(node) {\n  var first = node.firstChild,\n      last = node.lastChild;\n  return first && first.to < last.from ? {\n    from: first.to,\n    to: last.type.isError ? node.to : last.from\n  } : null;\n}\n\nfunction syntaxFolding(state, start, end) {\n  var tree = syntaxTree(state);\n  if (tree.length == 0) return null;\n  var inner = tree.resolveInner(end);\n  var found = null;\n\n  for (var cur = inner; cur; cur = cur.parent) {\n    if (cur.to <= end || cur.from > end) continue;\n    if (found && cur.from < start) break;\n    var prop = cur.type.prop(foldNodeProp);\n\n    if (prop) {\n      var value = prop(cur, state);\n      if (value && value.from <= end && value.from >= start && value.to > end) found = value;\n    }\n  }\n\n  return found;\n}\n/**\nCheck whether the given line is foldable. First asks any fold\nservices registered through\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\na result, tries to query the [fold node\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\nof the line.\n*/\n\n\nfunction foldable(state, lineStart, lineEnd) {\n  var _iterator12 = _createForOfIteratorHelper(state.facet(foldService)),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var service = _step12.value;\n      var result = service(state, lineStart, lineEnd);\n      if (result) return result;\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  return syntaxFolding(state, lineStart, lineEnd);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7Ozs7O0FBRUE7QUFDQTtBQUNBOzs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7Ozs7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFGQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOzs7O0FBYkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFHQTs7OztBQWJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMkJBO0FBQUE7QUF0QkE7QUFDQTtBQUNBO0FBQ0E7QUFtQkE7QUFBQTtBQWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQVRBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUdBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBOztBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQWpDQTtBQUNBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBR0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQXBCQTs7QUFBQTtBQUFBO0FBc0JBOzs7QUFXQTtBQUFBO0FBQUE7Ozs7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFFQTtBQUNBO0FBVEE7O0FBV0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFWQTtBQUFBO0FBQUE7QUFZQTs7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQXpCQTtBQUFBO0FBQUE7QUEyQkE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBbENBO0FBQUE7QUFBQTtBQW9DQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBekRBO0FBQUE7QUFBQTtBQTBEQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQS9EQTtBQUFBO0FBQUE7QUFpRUE7QUFFQTtBQW5FQTs7QUFBQTtBQUFBO0FBcUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFJQTs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQ0E7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBS0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFPQTtBQUNBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQXJEQTs7QUF1REE7QUFDQTtBQUNBO0FBREE7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBOztBQVpBO0FBQUE7O0FBQUE7QUFhQTtBQUFBOztBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXpCQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQTBCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmd1YWdlL2Rpc3QvaW5kZXguanM/Y2FhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlUHJvcCwgVHJlZSwgVHJlZUZyYWdtZW50LCBQYXJzZXIsIE5vZGVUeXBlIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5pbXBvcnQgeyBGYWNldCwgRWRpdG9yU3RhdGUsIFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgVmlld1BsdWdpbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgY291bnRDb2x1bW4gfSBmcm9tICdAY29kZW1pcnJvci90ZXh0JztcblxuLyoqXG5Ob2RlIHByb3Agc3RvcmVkIGluIGEgZ3JhbW1hcidzIHRvcCBzeW50YXggbm9kZSB0byBwcm92aWRlIHRoZVxuZmFjZXQgdGhhdCBzdG9yZXMgbGFuZ3VhZ2UgZGF0YSBmb3IgdGhhdCBsYW5ndWFnZS5cbiovXG5jb25zdCBsYW5ndWFnZURhdGFQcm9wID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuLyoqXG5IZWxwZXIgZnVuY3Rpb24gdG8gZGVmaW5lIGEgZmFjZXQgKHRvIGJlIGFkZGVkIHRvIHRoZSB0b3Agc3ludGF4XG5ub2RlKHMpIGZvciBhIGxhbmd1YWdlIHZpYVxuW2BsYW5ndWFnZURhdGFQcm9wYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5sYW5ndWFnZURhdGFQcm9wKSksIHRoYXQgd2lsbCBiZVxudXNlZCB0byBhc3NvY2lhdGUgbGFuZ3VhZ2UgZGF0YSB3aXRoIHRoZSBsYW5ndWFnZS4gWW91XG5wcm9iYWJseSBvbmx5IG5lZWQgdGhpcyB3aGVuIHN1YmNsYXNzaW5nXG5bYExhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkuXG4qL1xuZnVuY3Rpb24gZGVmaW5lTGFuZ3VhZ2VGYWNldChiYXNlRGF0YSkge1xuICAgIHJldHVybiBGYWNldC5kZWZpbmUoe1xuICAgICAgICBjb21iaW5lOiBiYXNlRGF0YSA/IHZhbHVlcyA9PiB2YWx1ZXMuY29uY2F0KGJhc2VEYXRhKSA6IHVuZGVmaW5lZFxuICAgIH0pO1xufVxuLyoqXG5BIGxhbmd1YWdlIG9iamVjdCBtYW5hZ2VzIHBhcnNpbmcgYW5kIHBlci1sYW5ndWFnZVxuW21ldGFkYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS4gUGFyc2UgZGF0YSBpc1xubWFuYWdlZCBhcyBhIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldCkgdHJlZS4gWW91J2xsXG53YW50IHRvIHN1YmNsYXNzIHRoaXMgY2xhc3MgZm9yIGN1c3RvbSBwYXJzZXJzLCBvciB1c2UgdGhlXG5bYExSTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxSTGFuZ3VhZ2UpIG9yXG5bYFN0cmVhbUxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdHJlYW0tcGFyc2VyLlN0cmVhbUxhbmd1YWdlKSBhYnN0cmFjdGlvbnMgZm9yXG5bTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvKSBvciBzdHJlYW0gcGFyc2Vycy5cbiovXG5jbGFzcyBMYW5ndWFnZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbGFuZ3VhZ2Ugb2JqZWN0LiBZb3UgdXN1YWxseSBkb24ndCBuZWVkIHRvIGludm9rZVxuICAgIHRoaXMgZGlyZWN0bHkuIEJ1dCB3aGVuIHlvdSBkbywgbWFrZSBzdXJlIHlvdSB1c2VcbiAgICBbYGRlZmluZUxhbmd1YWdlRmFjZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmRlZmluZUxhbmd1YWdlRmFjZXQpIHRvIGNyZWF0ZVxuICAgIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBbbGFuZ3VhZ2UgZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgZGF0YVxuICAgIGZhY2V0IHVzZWQgZm9yIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBkYXRhLCBwYXJzZXIsIFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGUgb2YgdGhlIHRvcCBub2RlIG9mIHRyZWVzIHByb2R1Y2VkIGJ5IHRoaXMgcGFyc2VyLlxuICAgICovXG4gICAgdG9wTm9kZSwgZXh0cmFFeHRlbnNpb25zID0gW10pIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy50b3BOb2RlID0gdG9wTm9kZTtcbiAgICAgICAgLy8gS2x1ZGdlIHRvIGRlZmluZSBFZGl0b3JTdGF0ZS50cmVlIGFzIGEgZGVidWdnaW5nIGhlbHBlcixcbiAgICAgICAgLy8gd2l0aG91dCB0aGUgRWRpdG9yU3RhdGUgcGFja2FnZSBhY3R1YWxseSBrbm93aW5nIGFib3V0XG4gICAgICAgIC8vIGxhbmd1YWdlcyBhbmQgbGV6ZXIgdHJlZXMuXG4gICAgICAgIGlmICghRWRpdG9yU3RhdGUucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwidHJlZVwiKSlcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZGl0b3JTdGF0ZS5wcm90b3R5cGUsIFwidHJlZVwiLCB7IGdldCgpIHsgcmV0dXJuIHN5bnRheFRyZWUodGhpcyk7IH0gfSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtcbiAgICAgICAgICAgIGxhbmd1YWdlLm9mKHRoaXMpLFxuICAgICAgICAgICAgRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhLm9mKChzdGF0ZSwgcG9zLCBzaWRlKSA9PiBzdGF0ZS5mYWNldChsYW5ndWFnZURhdGFGYWNldEF0KHN0YXRlLCBwb3MsIHNpZGUpKSlcbiAgICAgICAgXS5jb25jYXQoZXh0cmFFeHRlbnNpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGlzIGxhbmd1YWdlIGlzIGFjdGl2ZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBpc0FjdGl2ZUF0KHN0YXRlLCBwb3MsIHNpZGUgPSAtMSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VEYXRhRmFjZXRBdChzdGF0ZSwgcG9zLCBzaWRlKSA9PSB0aGlzLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHJlZ2lvbnMgdGhhdCB3ZXJlIHBhcnNlZCB1c2luZyB0aGlzIGxhbmd1YWdlLlxuICAgIFRoZSByZXR1cm5lZCByZWdpb25zIHdpbGwgX2luY2x1ZGVfIGFueSBuZXN0ZWQgbGFuZ3VhZ2VzIHJvb3RlZFxuICAgIGluIHRoaXMgbGFuZ3VhZ2UsIHdoZW4gdGhvc2UgZXhpc3QuXG4gICAgKi9cbiAgICBmaW5kUmVnaW9ucyhzdGF0ZSkge1xuICAgICAgICBsZXQgbGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKTtcbiAgICAgICAgaWYgKChsYW5nID09PSBudWxsIHx8IGxhbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhbmcuZGF0YSkgPT0gdGhpcy5kYXRhKVxuICAgICAgICAgICAgcmV0dXJuIFt7IGZyb206IDAsIHRvOiBzdGF0ZS5kb2MubGVuZ3RoIH1dO1xuICAgICAgICBpZiAoIWxhbmcgfHwgIWxhbmcuYWxsb3dzTmVzdGluZylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZXhwbG9yZSA9ICh0cmVlLCBmcm9tKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJlZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbSwgdG86IGZyb20gKyB0cmVlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW91bnQgPSB0cmVlLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICBpZiAobW91bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQudHJlZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW91bnQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgbW91bnQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb206IHIuZnJvbSArIGZyb20sIHRvOiByLnRvICsgZnJvbSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tOiBmcm9tLCB0bzogZnJvbSArIHRyZWUubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBleHBsb3JlKG1vdW50LnRyZWUsIG1vdW50Lm92ZXJsYXlbMF0uZnJvbSArIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IHNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gdHJlZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggaW5zdGFuY2VvZiBUcmVlKVxuICAgICAgICAgICAgICAgICAgICBleHBsb3JlKGNoLCB0cmVlLnBvc2l0aW9uc1tpXSArIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBleHBsb3JlKHN5bnRheFRyZWUoc3RhdGUpLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBsYW5ndWFnZSBhbGxvd3MgbmVzdGVkIGxhbmd1YWdlcy4gVGhlXG4gICAgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIHRydWUuXG4gICAgKi9cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIHRydWU7IH1cbn1cbi8qKlxuQGludGVybmFsXG4qL1xuTGFuZ3VhZ2Uuc2V0U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5mdW5jdGlvbiBsYW5ndWFnZURhdGFGYWNldEF0KHN0YXRlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgdG9wTGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKTtcbiAgICBpZiAoIXRvcExhbmcpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmYWNldCA9IHRvcExhbmcuZGF0YTtcbiAgICBpZiAodG9wTGFuZy5hbGxvd3NOZXN0aW5nKSB7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBzeW50YXhUcmVlKHN0YXRlKS50b3BOb2RlOyBub2RlOyBub2RlID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIHRydWUsIGZhbHNlKSlcbiAgICAgICAgICAgIGZhY2V0ID0gbm9kZS50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgfHwgZmFjZXQ7XG4gICAgfVxuICAgIHJldHVybiBmYWNldDtcbn1cbi8qKlxuQSBzdWJjbGFzcyBvZiBbYExhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgZm9yIHVzZSB3aXRoIExlemVyXG5bTFIgcGFyc2Vyc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNsci5MUlBhcnNlcilcbnBhcnNlcnMuXG4qL1xuY2xhc3MgTFJMYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwYXJzZXIpIHtcbiAgICAgICAgc3VwZXIoZGF0YSwgcGFyc2VyLCBwYXJzZXIudG9wTm9kZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBsYW5ndWFnZSBmcm9tIGEgcGFyc2VyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChzcGVjLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZShkYXRhLCBzcGVjLnBhcnNlci5jb25maWd1cmUoe1xuICAgICAgICAgICAgcHJvcHM6IFtsYW5ndWFnZURhdGFQcm9wLmFkZCh0eXBlID0+IHR5cGUuaXNUb3AgPyBkYXRhIDogdW5kZWZpbmVkKV1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBsYW5ndWFnZSB3aXRoIGEgcmVjb25maWd1cmVkXG4gICAgdmVyc2lvbiBvZiBpdHMgcGFyc2VyLlxuICAgICovXG4gICAgY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMUkxhbmd1YWdlKHRoaXMuZGF0YSwgdGhpcy5wYXJzZXIuY29uZmlndXJlKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0aGlzLnBhcnNlci53cmFwcGVycy5sZW5ndGggPiAwOyB9IC8vIEZJWE1FXG59XG4vKipcbkdldCB0aGUgc3ludGF4IHRyZWUgZm9yIGEgc3RhdGUsIHdoaWNoIGlzIHRoZSBjdXJyZW50IChwb3NzaWJseVxuaW5jb21wbGV0ZSkgcGFyc2UgdHJlZSBvZiBhY3RpdmUgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSxcbm9yIHRoZSBlbXB0eSB0cmVlIGlmIHRoZXJlIGlzIG5vIGxhbmd1YWdlIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBzeW50YXhUcmVlKHN0YXRlKSB7XG4gICAgbGV0IGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gZmllbGQgPyBmaWVsZC50cmVlIDogVHJlZS5lbXB0eTtcbn1cbi8qKlxuVHJ5IHRvIGdldCBhIHBhcnNlIHRyZWUgdGhhdCBzcGFucyBhdCBsZWFzdCB1cCB0byBgdXB0b2AuIFRoZVxubWV0aG9kIHdpbGwgZG8gYXQgbW9zdCBgdGltZW91dGAgbWlsbGlzZWNvbmRzIG9mIHdvcmsgdG8gcGFyc2VcbnVwIHRvIHRoYXQgcG9pbnQgaWYgdGhlIHRyZWUgaXNuJ3QgYWxyZWFkeSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZW5zdXJlU3ludGF4VHJlZShzdGF0ZSwgdXB0bywgdGltZW91dCA9IDUwKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBwYXJzZSA9IChfYSA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZXh0O1xuICAgIHJldHVybiAhcGFyc2UgPyBudWxsIDogcGFyc2UudHJlZUxlbiA+PSB1cHRvIHx8IHBhcnNlLndvcmsodGltZW91dCwgdXB0bykgPyBwYXJzZS50cmVlIDogbnVsbDtcbn1cbi8vIExlemVyLXN0eWxlIElucHV0IG9iamVjdCBmb3IgYSBUZXh0IGRvY3VtZW50LlxuY2xhc3MgRG9jSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKGRvYywgbGVuZ3RoID0gZG9jLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gMDtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XG4gICAgfVxuICAgIHN5bmNUbyhwb3MpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSB0aGlzLmN1cnNvci5uZXh0KHBvcyAtIHRoaXMuY3Vyc29yUG9zKS52YWx1ZTtcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSBwb3MgKyB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvclBvcyAtIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgY2h1bmsocG9zKSB7XG4gICAgICAgIHRoaXMuc3luY1RvKHBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgcmVhZChmcm9tLCB0bykge1xuICAgICAgICBsZXQgc3RyaW5nU3RhcnQgPSB0aGlzLmN1cnNvclBvcyAtIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKGZyb20gPCBzdHJpbmdTdGFydCB8fCB0byA+PSB0aGlzLmN1cnNvclBvcylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0byk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tIC0gc3RyaW5nU3RhcnQsIHRvIC0gc3RyaW5nU3RhcnQpO1xuICAgIH1cbn1cbmxldCBjdXJyZW50Q29udGV4dCA9IG51bGw7XG4vKipcbkEgcGFyc2UgY29udGV4dCBwcm92aWRlZCB0byBwYXJzZXJzIHdvcmtpbmcgb24gdGhlIGVkaXRvciBjb250ZW50LlxuKi9cbmNsYXNzIFBhcnNlQ29udGV4dCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUcmVlIGZyYWdtZW50cyB0aGF0IGNhbiBiZSByZXVzZWQgYnkgaW5jcmVtZW50YWwgcmUtcGFyc2VzLlxuICAgICovXG4gICAgZnJhZ21lbnRzID0gW10sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHJlZSwgdHJlZUxlbiwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHZpZXdwb3J0IChvciBzb21lIG92ZXJhcHByb3hpbWF0aW9uXG4gICAgdGhlcmVvZikuIEludGVuZGVkIHRvIGJlIHVzZWQgZm9yIG9wcG9ydHVuaXN0aWNhbGx5IGF2b2lkaW5nXG4gICAgd29yayAoaW4gd2hpY2ggY2FzZVxuICAgIFtgc2tpcFVudGlsSW5WaWV3YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5FZGl0b3JQYXJzZUNvbnRleHQuc2tpcFVudGlsSW5WaWV3KVxuICAgIHNob3VsZCBiZSBjYWxsZWQgdG8gbWFrZSBzdXJlIHRoZSBwYXJzZXIgaXMgcmVzdGFydGVkIHdoZW4gdGhlXG4gICAgc2tpcHBlZCByZWdpb24gYmVjb21lcyB2aXNpYmxlKS5cbiAgICAqL1xuICAgIHZpZXdwb3J0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNraXBwZWQsIFxuICAgIC8qKlxuICAgIFRoaXMgaXMgd2hlcmUgc2tpcHBpbmcgcGFyc2VycyBjYW4gcmVnaXN0ZXIgYSBwcm9taXNlIHRoYXQsXG4gICAgd2hlbiByZXNvbHZlZCwgd2lsbCBzY2hlZHVsZSBhIG5ldyBwYXJzZS4gSXQgaXMgY2xlYXJlZCB3aGVuXG4gICAgdGhlIHBhcnNlIHdvcmtlciBwaWNrcyB1cCB0aGUgcHJvbWlzZS4gQGludGVybmFsXG4gICAgKi9cbiAgICBzY2hlZHVsZU9uKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLnRyZWVMZW4gPSB0cmVlTGVuO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMuc2tpcHBlZCA9IHNraXBwZWQ7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVPbiA9IHNjaGVkdWxlT247XG4gICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGVtcFNraXBwZWQgPSBbXTtcbiAgICB9XG4gICAgc3RhcnRQYXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLnN0YXJ0UGFyc2UobmV3IERvY0lucHV0KHRoaXMuc3RhdGUuZG9jKSwgdGhpcy5mcmFnbWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdvcmsodGltZSwgdXB0bykge1xuICAgICAgICBpZiAodXB0byAhPSBudWxsICYmIHVwdG8gPj0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgdXB0byA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMudHJlZSAhPSBUcmVlLmVtcHR5ICYmICh1cHRvID09IG51bGwgPyB0aGlzLnRyZWVMZW4gPT0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoIDogdGhpcy50cmVlTGVuID49IHVwdG8pKSB7XG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMuc3RhcnRQYXJzZSgpO1xuICAgICAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiAodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IHVwdG8pICYmXG4gICAgICAgICAgICAgICAgdXB0byA8IHRoaXMuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnN0b3BBdCh1cHRvKTtcbiAgICAgICAgICAgIGxldCBlbmRUaW1lID0gRGF0ZS5ub3coKSArIHRpbWU7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKFRyZWVGcmFnbWVudC5hZGRUcmVlKGRvbmUsIHRoaXMuZnJhZ21lbnRzLCB0aGlzLnBhcnNlLnN0b3BwZWRBdCAhPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUxlbiA9IChfYSA9IHRoaXMucGFyc2Uuc3RvcHBlZEF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZSA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmVlTGVuIDwgKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGVuZFRpbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdGFrZVRyZWUoKSB7XG4gICAgICAgIGxldCBwb3MsIHRyZWU7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlICYmIChwb3MgPSB0aGlzLnBhcnNlLnBhcnNlZFBvcykgPiB0aGlzLnRyZWVMZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gcG9zKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgICAgICB0aGlzLndpdGhDb250ZXh0KCgpID0+IHsgd2hpbGUgKCEodHJlZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpKSkgeyB9IH0pO1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoVHJlZUZyYWdtZW50LmFkZFRyZWUodGhpcy50cmVlLCB0aGlzLmZyYWdtZW50cywgdHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aENvbnRleHQoZikge1xuICAgICAgICBsZXQgcHJldiA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICBjdXJyZW50Q29udGV4dCA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhvdXRUZW1wU2tpcHBlZChmcmFnbWVudHMpIHtcbiAgICAgICAgZm9yIChsZXQgcjsgciA9IHRoaXMudGVtcFNraXBwZWQucG9wKCk7KVxuICAgICAgICAgICAgZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgci5mcm9tLCByLnRvKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGFuZ2VzKGNoYW5nZXMsIG5ld1N0YXRlKSB7XG4gICAgICAgIGxldCB7IGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgICAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSA9PiByYW5nZXMucHVzaCh7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSkpO1xuICAgICAgICAgICAgZnJhZ21lbnRzID0gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB0cmVlID0gVHJlZS5lbXB0eTtcbiAgICAgICAgICAgIHRyZWVMZW4gPSAwO1xuICAgICAgICAgICAgdmlld3BvcnQgPSB7IGZyb206IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG86IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcHBlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnNraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyhyLmZyb20sIDEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHIudG8sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dCh0aGlzLnBhcnNlciwgbmV3U3RhdGUsIGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQsIHRoaXMuc2NoZWR1bGVPbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdXBkYXRlVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICBsZXQgc3RhcnRMZW4gPSB0aGlzLnNraXBwZWQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2tpcHBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMuc2tpcHBlZFtpXTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgdmlld3BvcnQudG8gJiYgdG8gPiB2aWV3cG9ydC5mcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBjdXRGcmFnbWVudHModGhpcy5mcmFnbWVudHMsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBwZWQuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2tpcHBlZC5sZW5ndGggPCBzdGFydExlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE5vdGlmeSB0aGUgcGFyc2Ugc2NoZWR1bGVyIHRoYXQgdGhlIGdpdmVuIHJlZ2lvbiB3YXMgc2tpcHBlZFxuICAgIGJlY2F1c2UgaXQgd2Fzbid0IGluIHZpZXcsIGFuZCB0aGUgcGFyc2Ugc2hvdWxkIGJlIHJlc3RhcnRlZFxuICAgIHdoZW4gaXQgY29tZXMgaW50byB2aWV3LlxuICAgICovXG4gICAgc2tpcFVudGlsSW5WaWV3KGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuc2tpcHBlZC5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSBwYXJzZXIgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBwbGFjZWhvbGRlciB3aGVuXG4gICAgYXN5bmNocm9ub3VzbHkgbG9hZGluZyBhIG5lc3RlZCBwYXJzZXIuIEl0J2xsIHNraXAgaXRzIGlucHV0IGFuZFxuICAgIG1hcmsgaXQgYXMgbm90LXJlYWxseS1wYXJzZWQsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcGFyc2VcbiAgICBpdCBhZ2Fpbi5cbiAgICBcbiAgICBXaGVuIGB1bnRpbGAgaXMgZ2l2ZW4sIGEgcmVwYXJzZSB3aWxsIGJlIHNjaGVkdWxlZCB3aGVuIHRoYXRcbiAgICBwcm9taXNlIHJlc29sdmVzLlxuICAgICovXG4gICAgc3RhdGljIGdldFNraXBwaW5nUGFyc2VyKHVudGlsKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2xhc3MgZXh0ZW5kcyBQYXJzZXIge1xuICAgICAgICAgICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbMF0uZnJvbSwgdG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFBvczogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjeCA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiByYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnRlbXBTa2lwcGVkLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVudGlsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC5zY2hlZHVsZU9uID0gY3guc2NoZWR1bGVPbiA/IFByb21pc2UuYWxsKFtjeC5zY2hlZHVsZU9uLCB1bnRpbF0pIDogdW50aWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IHRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgdG8gLSBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZEF0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdG9wQXQoKSB7IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbW92ZWRQYXN0KHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlTGVuIDwgcG9zICYmIHRoaXMucGFyc2UgJiYgdGhpcy5wYXJzZS5wYXJzZWRQb3MgPj0gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRleHQgZm9yIHRoZSBjdXJyZW50IHBhcnNlLCBvciBgbnVsbGAgaWYgbm8gZWRpdG9yXG4gICAgcGFyc2UgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KCkgeyByZXR1cm4gY3VycmVudENvbnRleHQ7IH1cbn1cbmZ1bmN0aW9uIGN1dEZyYWdtZW50cyhmcmFnbWVudHMsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIFRyZWVGcmFnbWVudC5hcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBbeyBmcm9tQTogZnJvbSwgdG9BOiB0bywgZnJvbUI6IGZyb20sIHRvQjogdG8gfV0pO1xufVxuY2xhc3MgTGFuZ3VhZ2VTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gQSBtdXRhYmxlIHBhcnNlIHN0YXRlIHRoYXQgaXMgdXNlZCB0byBwcmVzZXJ2ZSB3b3JrIGRvbmUgZHVyaW5nXG4gICAgLy8gdGhlIGxpZmV0aW1lIG9mIGEgc3RhdGUgd2hlbiBtb3ZpbmcgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRyZWUgPSBjb250ZXh0LnRyZWU7XG4gICAgfVxuICAgIGFwcGx5KHRyKSB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgbmV3Q3ggPSB0aGlzLmNvbnRleHQuY2hhbmdlcyh0ci5jaGFuZ2VzLCB0ci5zdGF0ZSk7XG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBwYXJzZSB3YXNuJ3QgZG9uZSwgZ28gZm9yd2FyZCBvbmx5IHVwIHRvIGl0c1xuICAgICAgICAvLyBlbmQgcG9zaXRpb24gb3IgdGhlIGVuZCBvZiB0aGUgdmlld3BvcnQsIHRvIGF2b2lkIHNsb3dpbmcgZG93blxuICAgICAgICAvLyBzdGF0ZSB1cGRhdGVzIHdpdGggcGFyc2Ugd29yayBiZXlvbmQgdGhlIHZpZXdwb3J0LlxuICAgICAgICBsZXQgdXB0byA9IHRoaXMuY29udGV4dC50cmVlTGVuID09IHRyLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBNYXRoLm1heCh0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmNvbnRleHQudHJlZUxlbiksIG5ld0N4LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKCFuZXdDeC53b3JrKDI1IC8qIEFwcGx5ICovLCB1cHRvKSlcbiAgICAgICAgICAgIG5ld0N4LnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShuZXdDeCk7XG4gICAgfVxuICAgIHN0YXRpYyBpbml0KHN0YXRlKSB7XG4gICAgICAgIGxldCBwYXJzZVN0YXRlID0gbmV3IFBhcnNlQ29udGV4dChzdGF0ZS5mYWNldChsYW5ndWFnZSkucGFyc2VyLCBzdGF0ZSwgW10sIFRyZWUuZW1wdHksIDAsIHsgZnJvbTogMCwgdG86IHN0YXRlLmRvYy5sZW5ndGggfSwgW10sIG51bGwpO1xuICAgICAgICBpZiAoIXBhcnNlU3RhdGUud29yaygyNSAvKiBBcHBseSAqLykpXG4gICAgICAgICAgICBwYXJzZVN0YXRlLnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShwYXJzZVN0YXRlKTtcbiAgICB9XG59XG5MYW5ndWFnZS5zdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlOiBMYW5ndWFnZVN0YXRlLmluaXQsXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZS5pcyhMYW5ndWFnZS5zZXRTdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgIGlmICh0ci5zdGFydFN0YXRlLmZhY2V0KGxhbmd1YWdlKSAhPSB0ci5zdGF0ZS5mYWNldChsYW5ndWFnZSkpXG4gICAgICAgICAgICByZXR1cm4gTGFuZ3VhZ2VTdGF0ZS5pbml0KHRyLnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRyKTtcbiAgICB9XG59KTtcbmxldCByZXF1ZXN0SWRsZSA9IHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayB8fFxuICAgICgoY2FsbGJhY2ssIHsgdGltZW91dCB9KSA9PiBzZXRUaW1lb3V0KGNhbGxiYWNrLCB0aW1lb3V0KSk7XG5sZXQgY2FuY2VsSWRsZSA9IHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrIHx8IGNsZWFyVGltZW91dDtcbmNvbnN0IHBhcnNlV29ya2VyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIFBhcnNlV29ya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMud29ya2luZyA9IC0xO1xuICAgICAgICAvLyBFbmQgb2YgdGhlIGN1cnJlbnQgdGltZSBjaHVua1xuICAgICAgICB0aGlzLmNodW5rRW5kID0gLTE7XG4gICAgICAgIC8vIE1pbGxpc2Vjb25kcyBvZiBidWRnZXQgbGVmdCBmb3IgdGhpcyBjaHVua1xuICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ID0gLTE7XG4gICAgICAgIHRoaXMud29yayA9IHRoaXMud29yay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjeCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSkuY29udGV4dDtcbiAgICAgICAgaWYgKHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmIChjeC51cGRhdGVWaWV3cG9ydCh1cGRhdGUudmlldy52aWV3cG9ydCkpXG4gICAgICAgICAgICAgICAgY3gucmVzZXQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcudmlld3BvcnQudG8gPiBjeC50cmVlTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3Lmhhc0ZvY3VzKVxuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgKz0gNTAgLyogQ2hhbmdlQm9udXMgKi87XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGN4KTtcbiAgICB9XG4gICAgc2NoZWR1bGVXb3JrKCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpLCBmcmFncyA9IGZpZWxkLmNvbnRleHQuZnJhZ21lbnRzO1xuICAgICAgICBpZiAoZmllbGQudHJlZSA9PSBmaWVsZC5jb250ZXh0LnRyZWUgJiYgZmllbGQuY29udGV4dC50cmVlTGVuID49IHN0YXRlLmRvYy5sZW5ndGggJiZcbiAgICAgICAgICAgIGZyYWdzLmxlbmd0aCAmJiBmcmFnc1swXS5mcm9tID09IDAgJiYgZnJhZ3NbMF0udG8gPj0gc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy53b3JraW5nID0gcmVxdWVzdElkbGUodGhpcy53b3JrLCB7IHRpbWVvdXQ6IDUwMCAvKiBQYXVzZSAqLyB9KTtcbiAgICB9XG4gICAgd29yayhkZWFkbGluZSkge1xuICAgICAgICB0aGlzLndvcmtpbmcgPSAtMTtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rRW5kIDwgbm93ICYmICh0aGlzLmNodW5rRW5kIDwgMCB8fCB0aGlzLnZpZXcuaGFzRm9jdXMpKSB7IC8vIFN0YXJ0IGEgbmV3IGNodW5rXG4gICAgICAgICAgICB0aGlzLmNodW5rRW5kID0gbm93ICsgMzAwMDAgLyogQ2h1bmtUaW1lICovO1xuICAgICAgICAgICAgdGhpcy5jaHVua0J1ZGdldCA9IDMwMDAgLyogQ2h1bmtCdWRnZXQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtCdWRnZXQgPD0gMClcbiAgICAgICAgICAgIHJldHVybjsgLy8gTm8gbW9yZSBidWRnZXRcbiAgICAgICAgbGV0IHsgc3RhdGUsIHZpZXdwb3J0OiB7IHRvOiB2cFRvIH0gfSA9IHRoaXMudmlldywgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSk7XG4gICAgICAgIGlmIChmaWVsZC50cmVlID09IGZpZWxkLmNvbnRleHQudHJlZSAmJiBmaWVsZC5jb250ZXh0LnRyZWVMZW4gPj0gdnBUbyArIDEwMDAwMDAgLyogTWF4UGFyc2VBaGVhZCAqLylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHRpbWUgPSBNYXRoLm1pbih0aGlzLmNodW5rQnVkZ2V0LCBkZWFkbGluZSA/IE1hdGgubWF4KDI1IC8qIE1pblNsaWNlICovLCBkZWFkbGluZS50aW1lUmVtYWluaW5nKCkpIDogMTAwIC8qIFNsaWNlICovKTtcbiAgICAgICAgbGV0IGRvbmUgPSBmaWVsZC5jb250ZXh0LndvcmsodGltZSwgdnBUbyArIDEwMDAwMDAgLyogTWF4UGFyc2VBaGVhZCAqLyk7XG4gICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgLT0gRGF0ZS5ub3coKSAtIG5vdztcbiAgICAgICAgaWYgKGRvbmUgfHwgdGhpcy5jaHVua0J1ZGdldCA8PSAwIHx8IGZpZWxkLmNvbnRleHQubW92ZWRQYXN0KHZwVG8pKSB7XG4gICAgICAgICAgICBmaWVsZC5jb250ZXh0LnRha2VUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBMYW5ndWFnZS5zZXRTdGF0ZS5vZihuZXcgTGFuZ3VhZ2VTdGF0ZShmaWVsZC5jb250ZXh0KSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb25lICYmIHRoaXMuY2h1bmtCdWRnZXQgPiAwKVxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoZmllbGQuY29udGV4dCk7XG4gICAgfVxuICAgIGNoZWNrQXN5bmNTY2hlZHVsZShjeCkge1xuICAgICAgICBpZiAoY3guc2NoZWR1bGVPbikge1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPbi50aGVuKCgpID0+IHRoaXMuc2NoZWR1bGVXb3JrKCkpO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZyA+PSAwKVxuICAgICAgICAgICAgY2FuY2VsSWRsZSh0aGlzLndvcmtpbmcpO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7IGZvY3VzKCkgeyB0aGlzLnNjaGVkdWxlV29yaygpOyB9IH1cbn0pO1xuLyoqXG5UaGUgZmFjZXQgdXNlZCB0byBhc3NvY2lhdGUgYSBsYW5ndWFnZSB3aXRoIGFuIGVkaXRvciBzdGF0ZS5cbiovXG5jb25zdCBsYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobGFuZ3VhZ2VzKSB7IHJldHVybiBsYW5ndWFnZXMubGVuZ3RoID8gbGFuZ3VhZ2VzWzBdIDogbnVsbDsgfSxcbiAgICBlbmFibGVzOiBbTGFuZ3VhZ2Uuc3RhdGUsIHBhcnNlV29ya2VyXVxufSk7XG4vKipcblRoaXMgY2xhc3MgYnVuZGxlcyBhIFtsYW5ndWFnZSBvYmplY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIHdpdGggYW5cbm9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIExhbmd1YWdlIHBhY2thZ2VzIGFyZVxuZW5jb3VyYWdlZCB0byBleHBvcnQgYSBmdW5jdGlvbiB0aGF0IG9wdGlvbmFsbHkgdGFrZXMgYVxuY29uZmlndXJhdGlvbiBvYmplY3QgYW5kIHJldHVybnMgYSBgTGFuZ3VhZ2VTdXBwb3J0YCBpbnN0YW5jZSwgYXNcbnRoZSBtYWluIHdheSBmb3IgY2xpZW50IGNvZGUgdG8gdXNlIHRoZSBwYWNrYWdlLlxuKi9cbmNsYXNzIExhbmd1YWdlU3VwcG9ydCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc3VwcG9ydCBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgICovXG4gICAgbGFuZ3VhZ2UsIFxuICAgIC8qKlxuICAgIEFuIG9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIFdoZW4gbmVzdGluZyBhXG4gICAgbGFuZ3VhZ2UgaW4gYW5vdGhlciBsYW5ndWFnZSwgdGhlIG91dGVyIGxhbmd1YWdlIGlzIGVuY291cmFnZWRcbiAgICB0byBpbmNsdWRlIHRoZSBzdXBwb3J0aW5nIGV4dGVuc2lvbnMgZm9yIGl0cyBpbm5lciBsYW5ndWFnZXNcbiAgICBpbiBpdHMgb3duIHNldCBvZiBzdXBwb3J0IGV4dGVuc2lvbnMuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gW10pIHtcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgICAgICB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0O1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtsYW5ndWFnZSwgc3VwcG9ydF07XG4gICAgfVxufVxuLyoqXG5MYW5ndWFnZSBkZXNjcmlwdGlvbnMgYXJlIHVzZWQgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXQgbGFuZ3VhZ2VzXG5hbmQgdG8gZHluYW1pY2FsbHkgbG9hZCB0aGVtLiBUaGVpciBtYWluIHJvbGUgaXMgZmluZGluZyB0aGVcbmFwcHJvcHJpYXRlIGxhbmd1YWdlIGZvciBhIGZpbGVuYW1lIG9yIGR5bmFtaWNhbGx5IGxvYWRpbmcgbmVzdGVkXG5wYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlRGVzY3JpcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBbHRlcm5hdGl2ZSBuYW1lcyBmb3IgdGhlIG1vZGUgKGxvd2VyY2FzZWQsIGluY2x1ZGVzIGB0aGlzLm5hbWVgKS5cbiAgICAqL1xuICAgIGFsaWFzLCBcbiAgICAvKipcbiAgICBGaWxlIGV4dGVuc2lvbnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBleHRlbnNpb25zLCBcbiAgICAvKipcbiAgICBPcHRpb25hbCBmaWxlbmFtZSBwYXR0ZXJuIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzXG4gICAgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBmaWxlbmFtZSwgbG9hZEZ1bmMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubG9hZEZ1bmMgPSBsb2FkRnVuYztcbiAgICAgICAgLyoqXG4gICAgICAgIElmIHRoZSBsYW5ndWFnZSBoYXMgYmVlbiBsb2FkZWQsIHRoaXMgd2lsbCBob2xkIGl0cyB2YWx1ZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCBsb2FkaW5nIHRoZSB0aGUgbGFuZ3VhZ2UuIFdpbGwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0XG4gICAgcmVzb2x2ZXMgdG8gYSBbYExhbmd1YWdlU3VwcG9ydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VTdXBwb3J0KVxuICAgIG9iamVjdCB3aGVuIHRoZSBsYW5ndWFnZSBzdWNjZXNzZnVsbHkgbG9hZHMuXG4gICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nIHx8ICh0aGlzLmxvYWRpbmcgPSB0aGlzLmxvYWRGdW5jKCkudGhlbihzdXBwb3J0ID0+IHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQsIGVyciA9PiB7IHRoaXMubG9hZGluZyA9IG51bGw7IHRocm93IGVycjsgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBsYW5ndWFnZSBkZXNjcmlwdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VEZXNjcmlwdGlvbihzcGVjLm5hbWUsIChzcGVjLmFsaWFzIHx8IFtdKS5jb25jYXQoc3BlYy5uYW1lKS5tYXAocyA9PiBzLnRvTG93ZXJDYXNlKCkpLCBzcGVjLmV4dGVuc2lvbnMgfHwgW10sIHNwZWMuZmlsZW5hbWUsIHNwZWMubG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIGEgbGFuZ3VhZ2UgaW4gdGhlIGdpdmVuIGFycmF5IG9mIGRlc2NyaXB0aW9ucyB0aGF0XG4gICAgbWF0Y2hlcyB0aGUgZmlsZW5hbWUuIFdpbGwgZmlyc3QgbWF0Y2hcbiAgICBbYGZpbGVuYW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmZpbGVuYW1lKSBwYXR0ZXJucyxcbiAgICBhbmQgdGhlbiBbZXh0ZW5zaW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmV4dGVuc2lvbnMpLFxuICAgIGFuZCByZXR1cm4gdGhlIGZpcnN0IGxhbmd1YWdlIHRoYXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaEZpbGVuYW1lKGRlc2NzLCBmaWxlbmFtZSkge1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgaWYgKGQuZmlsZW5hbWUgJiYgZC5maWxlbmFtZS50ZXN0KGZpbGVuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgbGV0IGV4dCA9IC9cXC4oW14uXSspJC8uZXhlYyhmaWxlbmFtZSk7XG4gICAgICAgIGlmIChleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGlmIChkLmV4dGVuc2lvbnMuaW5kZXhPZihleHRbMV0pID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lIG9yIGFsaWFzIG1hdGNoZXMgdGhlIHRoZSBnaXZlblxuICAgIG5hbWUgKGNhc2UtaW5zZW5zaXRpdmVseSkuIElmIGBmdXp6eWAgaXMgdHJ1ZSwgYW5kIG5vIGRpcmVjdFxuICAgIG1hdGNocyBpcyBmb3VuZCwgdGhpcydsbCBhbHNvIHNlYXJjaCBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lXG4gICAgb3IgYWxpYXMgb2NjdXJzIGluIHRoZSBzdHJpbmcgKGZvciBuYW1lcyBzaG9ydGVyIHRoYW4gdGhyZWVcbiAgICBjaGFyYWN0ZXJzLCBvbmx5IHdoZW4gc3Vycm91bmRlZCBieSBub24td29yZCBjaGFyYWN0ZXJzKS5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaExhbmd1YWdlTmFtZShkZXNjcywgbmFtZSwgZnV6enkgPSB0cnVlKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5hbGlhcy5zb21lKGEgPT4gYSA9PSBuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgaWYgKGZ1enp5KVxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhIG9mIGQuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gbmFtZS5pbmRleE9mKGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiAtMSAmJiAoYS5sZW5ndGggPiAyIHx8ICEvXFx3Ly50ZXN0KG5hbWVbZm91bmQgLSAxXSkgJiYgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCArIGEubGVuZ3RoXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuRmFjZXQgdGhhdCBkZWZpbmVzIGEgd2F5IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZVxuYXBwcm9wcmlhdGUgaW5kZW50YXRpb24gZGVwdGggYXQgdGhlIHN0YXJ0IG9mIGEgZ2l2ZW4gbGluZSwgb3JcbmBudWxsYCB0byBpbmRpY2F0ZSBubyBhcHByb3ByaWF0ZSBpbmRlbnRhdGlvbiBjb3VsZCBiZSBkZXRlcm1pbmVkLlxuKi9cbmNvbnN0IGluZGVudFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkZhY2V0IGZvciBvdmVycmlkaW5nIHRoZSB1bml0IGJ5IHdoaWNoIGluZGVudGF0aW9uIGhhcHBlbnMuXG5TaG91bGQgYmUgYSBzdHJpbmcgY29uc2lzdGluZyBlaXRoZXIgZW50aXJlbHkgb2Ygc3BhY2VzIG9yXG5lbnRpcmVseSBvZiB0YWJzLiBXaGVuIG5vdCBzZXQsIHRoaXMgZGVmYXVsdHMgdG8gMiBzcGFjZXMuXG4qL1xuY29uc3QgaW5kZW50VW5pdCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB7XG4gICAgICAgIGlmICghdmFsdWVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBcIiAgXCI7XG4gICAgICAgIGlmICghL14oPzogK3xcXHQrKSQvLnRlc3QodmFsdWVzWzBdKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5kZW50IHVuaXQ6IFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWVzWzBdKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXNbMF07XG4gICAgfVxufSk7XG4vKipcblJldHVybiB0aGUgX2NvbHVtbiB3aWR0aF8gb2YgYW4gaW5kZW50IHVuaXQgaW4gdGhlIHN0YXRlLlxuRGV0ZXJtaW5lZCBieSB0aGUgW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KVxuZmFjZXQsIGFuZCBbYHRhYlNpemVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpIHdoZW4gdGhhdFxuY29udGFpbnMgdGFicy5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRVbml0KHN0YXRlKSB7XG4gICAgbGV0IHVuaXQgPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KTtcbiAgICByZXR1cm4gdW5pdC5jaGFyQ29kZUF0KDApID09IDkgPyBzdGF0ZS50YWJTaXplICogdW5pdC5sZW5ndGggOiB1bml0Lmxlbmd0aDtcbn1cbi8qKlxuQ3JlYXRlIGFuIGluZGVudGF0aW9uIHN0cmluZyB0aGF0IGNvdmVycyBjb2x1bW5zIDAgdG8gYGNvbHNgLlxuV2lsbCB1c2UgdGFicyBmb3IgYXMgbXVjaCBvZiB0aGUgY29sdW1ucyBhcyBwb3NzaWJsZSB3aGVuIHRoZVxuW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBmYWNldCBjb250YWluc1xudGFicy5cbiovXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RhdGUsIGNvbHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIiwgdHMgPSBzdGF0ZS50YWJTaXplO1xuICAgIGlmIChzdGF0ZS5mYWNldChpbmRlbnRVbml0KS5jaGFyQ29kZUF0KDApID09IDkpXG4gICAgICAgIHdoaWxlIChjb2xzID49IHRzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgIGNvbHMgLT0gdHM7XG4gICAgICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHM7IGkrKylcbiAgICAgICAgcmVzdWx0ICs9IFwiIFwiO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkdldCB0aGUgaW5kZW50YXRpb24gYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBXaWxsIGZpcnN0IGNvbnN1bHQgYW55XG5baW5kZW50IHNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpIHRoYXQgYXJlIHJlZ2lzdGVyZWQsXG5hbmQgaWYgbm9uZSBvZiB0aG9zZSByZXR1cm4gYW4gaW5kZW50YXRpb24sIHRoaXMgd2lsbCBjaGVjayB0aGVcbnN5bnRheCB0cmVlIGZvciB0aGUgW2luZGVudCBub2RlIHByb3BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50Tm9kZVByb3ApXG5hbmQgdXNlIHRoYXQgaWYgZm91bmQuIFJldHVybnMgYSBudW1iZXIgd2hlbiBhbiBpbmRlbnRhdGlvbiBjb3VsZFxuYmUgZGV0ZXJtaW5lZCwgYW5kIG51bGwgb3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIGdldEluZGVudGF0aW9uKGNvbnRleHQsIHBvcykge1xuICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgRWRpdG9yU3RhdGUpXG4gICAgICAgIGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChjb250ZXh0KTtcbiAgICBmb3IgKGxldCBzZXJ2aWNlIG9mIGNvbnRleHQuc3RhdGUuZmFjZXQoaW5kZW50U2VydmljZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNlcnZpY2UoY29udGV4dCwgcG9zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpO1xuICAgIHJldHVybiB0cmVlID8gc3ludGF4SW5kZW50YXRpb24oY29udGV4dCwgdHJlZSwgcG9zKSA6IG51bGw7XG59XG4vKipcbkluZGVudGF0aW9uIGNvbnRleHRzIGFyZSB1c2VkIHdoZW4gY2FsbGluZyBbaW5kZW50YXRpb25cbnNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpLiBUaGV5IHByb3ZpZGUgaGVscGVyIHV0aWxpdGllc1xudXNlZnVsIGluIGluZGVudGF0aW9uIGxvZ2ljLCBhbmQgY2FuIHNlbGVjdGl2ZWx5IG92ZXJyaWRlIHRoZVxuaW5kZW50YXRpb24gcmVwb3J0ZWQgZm9yIHNvbWUgbGluZXMuXG4qL1xuY2xhc3MgSW5kZW50Q29udGV4dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluZGVudCBjb250ZXh0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudW5pdCA9IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIHRha2luZ1xuICAgIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICBpbnRvIGFjY291bnQuIElmIHRoZXJlIGlzIHN1Y2ggYSBicmVhayBhdCBgcG9zYCwgdGhlIGBiaWFzYFxuICAgIGFyZ3VtZW50IGRldGVybWluZXMgd2hldGhlciB0aGUgcGFydCBvZiB0aGUgbGluZSBsaW5lIGJlZm9yZSBvclxuICAgIGFmdGVyIHRoZSBicmVhayBpcyB1c2VkLlxuICAgICovXG4gICAgbGluZUF0KHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IHsgc2ltdWxhdGVCcmVhayB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoc2ltdWxhdGVCcmVhayAhPSBudWxsICYmIHNpbXVsYXRlQnJlYWsgPj0gbGluZS5mcm9tICYmIHNpbXVsYXRlQnJlYWsgPD0gbGluZS50bykge1xuICAgICAgICAgICAgaWYgKGJpYXMgPCAwID8gc2ltdWxhdGVCcmVhayA8IHBvcyA6IHNpbXVsYXRlQnJlYWsgPD0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGxpbmUudGV4dC5zbGljZShzaW11bGF0ZUJyZWFrIC0gbGluZS5mcm9tKSwgZnJvbTogc2ltdWxhdGVCcmVhayB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGxpbmUudGV4dC5zbGljZSgwLCBzaW11bGF0ZUJyZWFrIC0gbGluZS5mcm9tKSwgZnJvbTogbGluZS5mcm9tIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgcG9zYCwgZWl0aGVyIHRoZSBlbnRpcmUgbGluZVxuICAgIG9yIHRoZSBuZXh0IDEwMCBjaGFyYWN0ZXJzLCB3aGljaGV2ZXIgaXMgc2hvcnRlci5cbiAgICAqL1xuICAgIHRleHRBZnRlclBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2ltdWxhdGVEb3VibGVCcmVhayAmJiBwb3MgPT0gdGhpcy5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UocG9zIC0gZnJvbSwgTWF0aC5taW4odGV4dC5sZW5ndGgsIHBvcyArIDEwMCAtIGZyb20pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY29sdW1uIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBjb2x1bW4ocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb3VudENvbHVtbih0ZXh0LCBwb3MgLSBmcm9tKTtcbiAgICAgICAgbGV0IG92ZXJyaWRlID0gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24gPyB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbihmcm9tKSA6IC0xO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPiAtMSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBvdmVycmlkZSAtIHRoaXMuY291bnRDb2x1bW4odGV4dCwgdGV4dC5zZWFyY2goL1xcU3wkLykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjb2x1bW4gcG9zaXRpb24gKHRha2luZyB0YWJzIGludG8gYWNjb3VudCkgb2YgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24gaW4gdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIGNvdW50Q29sdW1uKGxpbmUsIHBvcyA9IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjb3VudENvbHVtbihsaW5lLCB0aGlzLnN0YXRlLnRhYlNpemUsIHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgKi9cbiAgICBsaW5lSW5kZW50KHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgbGV0IG92ZXJyaWRlID0gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb247XG4gICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgbGV0IG92ZXJyaWRlbiA9IG92ZXJyaWRlKGZyb20pO1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlbiA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVycmlkZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRDb2x1bW4odGV4dCwgdGV4dC5zZWFyY2goL1xcU3wkLykpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBbc2ltdWxhdGVkIGxpbmVcbiAgICBicmVha10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICBmb3IgdGhpcyBjb250ZXh0LCBpZiBhbnkuXG4gICAgKi9cbiAgICBnZXQgc2ltdWxhdGVkQnJlYWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2ltdWxhdGVCcmVhayB8fCBudWxsO1xuICAgIH1cbn1cbi8qKlxuQSBzeW50YXggdHJlZSBub2RlIHByb3AgdXNlZCB0byBhc3NvY2lhdGUgaW5kZW50YXRpb24gc3RyYXRlZ2llc1xud2l0aCBub2RlIHR5cGVzLiBTdWNoIGEgc3RyYXRlZ3kgaXMgYSBmdW5jdGlvbiBmcm9tIGFuIGluZGVudGF0aW9uXG5jb250ZXh0IHRvIGEgY29sdW1uIG51bWJlciBvciBudWxsLCB3aGVyZSBudWxsIGluZGljYXRlcyB0aGF0IG5vXG5kZWZpbml0aXZlIGluZGVudGF0aW9uIGNhbiBiZSBkZXRlcm1pbmVkLlxuKi9cbmNvbnN0IGluZGVudE5vZGVQcm9wID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuLy8gQ29tcHV0ZSB0aGUgaW5kZW50YXRpb24gZm9yIGEgZ2l2ZW4gcG9zaXRpb24gZnJvbSB0aGUgc3ludGF4IHRyZWUuXG5mdW5jdGlvbiBzeW50YXhJbmRlbnRhdGlvbihjeCwgYXN0LCBwb3MpIHtcbiAgICBsZXQgdHJlZSA9IGFzdC5yZXNvbHZlSW5uZXIocG9zKTtcbiAgICAvLyBFbnRlciBwcmV2aW91cyBub2RlcyB0aGF0IGVuZCBpbiBlbXB0eSBlcnJvciB0ZXJtcywgd2hpY2ggbWVhbnNcbiAgICAvLyB0aGV5IHdlcmUgYnJva2VuIG9mZiBieSBlcnJvciByZWNvdmVyeSwgc28gdGhhdCBpbmRlbnRhdGlvblxuICAgIC8vIHdvcmtzIGV2ZW4gaWYgdGhlIGNvbnN0cnVjdHMgaGF2ZW4ndCBiZWVuIGZpbmlzaGVkLlxuICAgIGZvciAobGV0IHNjYW4gPSB0cmVlLCBzY2FuUG9zID0gcG9zOzspIHtcbiAgICAgICAgbGV0IGxhc3QgPSBzY2FuLmNoaWxkQmVmb3JlKHNjYW5Qb3MpO1xuICAgICAgICBpZiAoIWxhc3QpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGxhc3QudHlwZS5pc0Vycm9yICYmIGxhc3QuZnJvbSA9PSBsYXN0LnRvKSB7XG4gICAgICAgICAgICB0cmVlID0gc2NhbjtcbiAgICAgICAgICAgIHNjYW5Qb3MgPSBsYXN0LmZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY2FuID0gbGFzdDtcbiAgICAgICAgICAgIHNjYW5Qb3MgPSBzY2FuLnRvICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZW50RnJvbSh0cmVlLCBwb3MsIGN4KTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUNsb3NlZChjeCkge1xuICAgIHJldHVybiBjeC5wb3MgPT0gY3gub3B0aW9ucy5zaW11bGF0ZUJyZWFrICYmIGN4Lm9wdGlvbnMuc2ltdWxhdGVEb3VibGVCcmVhaztcbn1cbmZ1bmN0aW9uIGluZGVudFN0cmF0ZWd5KHRyZWUpIHtcbiAgICBsZXQgc3RyYXRlZ3kgPSB0cmVlLnR5cGUucHJvcChpbmRlbnROb2RlUHJvcCk7XG4gICAgaWYgKHN0cmF0ZWd5KVxuICAgICAgICByZXR1cm4gc3RyYXRlZ3k7XG4gICAgbGV0IGZpcnN0ID0gdHJlZS5maXJzdENoaWxkLCBjbG9zZTtcbiAgICBpZiAoZmlyc3QgJiYgKGNsb3NlID0gZmlyc3QudHlwZS5wcm9wKE5vZGVQcm9wLmNsb3NlZEJ5KSkpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0cmVlLmxhc3RDaGlsZCwgY2xvc2VkID0gbGFzdCAmJiBjbG9zZS5pbmRleE9mKGxhc3QubmFtZSkgPiAtMTtcbiAgICAgICAgcmV0dXJuIGN4ID0+IGRlbGltaXRlZFN0cmF0ZWd5KGN4LCB0cnVlLCAxLCB1bmRlZmluZWQsIGNsb3NlZCAmJiAhaWdub3JlQ2xvc2VkKGN4KSA/IGxhc3QuZnJvbSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiB0cmVlLnBhcmVudCA9PSBudWxsID8gdG9wSW5kZW50IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGluZGVudEZyb20obm9kZSwgcG9zLCBiYXNlKSB7XG4gICAgZm9yICg7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudCkge1xuICAgICAgICBsZXQgc3RyYXRlZ3kgPSBpbmRlbnRTdHJhdGVneShub2RlKTtcbiAgICAgICAgaWYgKHN0cmF0ZWd5KVxuICAgICAgICAgICAgcmV0dXJuIHN0cmF0ZWd5KG5ldyBUcmVlSW5kZW50Q29udGV4dChiYXNlLCBwb3MsIG5vZGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0b3BJbmRlbnQoKSB7IHJldHVybiAwOyB9XG4vKipcbk9iamVjdHMgb2YgdGhpcyB0eXBlIHByb3ZpZGUgY29udGV4dCBpbmZvcm1hdGlvbiBhbmQgaGVscGVyXG5tZXRob2RzIHRvIGluZGVudGF0aW9uIGZ1bmN0aW9ucy5cbiovXG5jbGFzcyBUcmVlSW5kZW50Q29udGV4dCBleHRlbmRzIEluZGVudENvbnRleHQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoYmFzZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHdoaWNoIGluZGVudGF0aW9uIGlzIGJlaW5nIGNvbXB1dGVkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgc3ludGF4IHRyZWUgbm9kZSB0byB3aGljaCB0aGUgaW5kZW50YXRpb24gc3RyYXRlZ3lcbiAgICBhcHBsaWVzLlxuICAgICovXG4gICAgbm9kZSkge1xuICAgICAgICBzdXBlcihiYXNlLnN0YXRlLCBiYXNlLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGB0aGlzLnBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICBnZXQgdGV4dEFmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QWZ0ZXJQb3ModGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGF0IHRoZSByZWZlcmVuY2UgbGluZSBmb3IgYHRoaXMubm9kZWAsIHdoaWNoXG4gICAgaXMgdGhlIGxpbmUgb24gd2hpY2ggaXQgc3RhcnRzLCB1bmxlc3MgdGhlcmUgaXMgYSBub2RlIHRoYXQgaXNcbiAgICBfbm90XyBhIHBhcmVudCBvZiB0aGlzIG5vZGUgY292ZXJpbmcgdGhlIHN0YXJ0IG9mIHRoYXQgbGluZS4gSWZcbiAgICBzbywgdGhlIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHRoYXQgbm9kZSBpcyB0cmllZCwgYWdhaW4gc2tpcHBpbmdcbiAgICBvbiBpZiBpdCBpcyBjb3ZlcmVkIGJ5IGFub3RoZXIgc3VjaCBub2RlLlxuICAgICovXG4gICAgZ2V0IGJhc2VJbmRlbnQoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHRoaXMubm9kZS5mcm9tKTtcbiAgICAgICAgLy8gU2tpcCBsaW5lIHN0YXJ0cyB0aGF0IGFyZSBjb3ZlcmVkIGJ5IGEgc2libGluZyAob3IgY291c2luLCBldGMpXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhdEJyZWFrID0gdGhpcy5ub2RlLnJlc29sdmUobGluZS5mcm9tKTtcbiAgICAgICAgICAgIHdoaWxlIChhdEJyZWFrLnBhcmVudCAmJiBhdEJyZWFrLnBhcmVudC5mcm9tID09IGF0QnJlYWsuZnJvbSlcbiAgICAgICAgICAgICAgICBhdEJyZWFrID0gYXRCcmVhay5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQoYXRCcmVhaywgdGhpcy5ub2RlKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQoYXRCcmVhay5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5kZW50KGxpbmUuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnRpbnVlIGxvb2tpbmcgZm9yIGluZGVudGF0aW9ucyBpbiB0aGUgbm9kZSdzIHBhcmVudCBub2RlcyxcbiAgICBhbmQgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhhdC5cbiAgICAqL1xuICAgIGNvbnRpbnVlKCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5ub2RlLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHBhcmVudCA/IGluZGVudEZyb20ocGFyZW50LCB0aGlzLnBvcywgdGhpcy5iYXNlKSA6IDA7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQYXJlbnQocGFyZW50LCBvZikge1xuICAgIGZvciAobGV0IGN1ciA9IG9mOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgIGlmIChwYXJlbnQgPT0gY3VyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQ2hlY2sgd2hldGhlciBhIGRlbGltaXRlZCBub2RlIGlzIGFsaWduZWQgKG1lYW5pbmcgdGhlcmUgYXJlXG4vLyBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBvcGVuaW5nIGRlbGltaXRlcikuIEFuZFxuLy8gaWYgc28sIHJldHVybiB0aGUgb3BlbmluZyB0b2tlbi5cbmZ1bmN0aW9uIGJyYWNrZXRlZEFsaWduZWQoY29udGV4dCkge1xuICAgIGxldCB0cmVlID0gY29udGV4dC5ub2RlO1xuICAgIGxldCBvcGVuVG9rZW4gPSB0cmVlLmNoaWxkQWZ0ZXIodHJlZS5mcm9tKSwgbGFzdCA9IHRyZWUubGFzdENoaWxkO1xuICAgIGlmICghb3BlblRva2VuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2ltID0gY29udGV4dC5vcHRpb25zLnNpbXVsYXRlQnJlYWs7XG4gICAgbGV0IG9wZW5MaW5lID0gY29udGV4dC5zdGF0ZS5kb2MubGluZUF0KG9wZW5Ub2tlbi5mcm9tKTtcbiAgICBsZXQgbGluZUVuZCA9IHNpbSA9PSBudWxsIHx8IHNpbSA8PSBvcGVuTGluZS5mcm9tID8gb3BlbkxpbmUudG8gOiBNYXRoLm1pbihvcGVuTGluZS50bywgc2ltKTtcbiAgICBmb3IgKGxldCBwb3MgPSBvcGVuVG9rZW4udG87Oykge1xuICAgICAgICBsZXQgbmV4dCA9IHRyZWUuY2hpbGRBZnRlcihwb3MpO1xuICAgICAgICBpZiAoIW5leHQgfHwgbmV4dCA9PSBsYXN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghbmV4dC50eXBlLmlzU2tpcHBlZClcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmZyb20gPCBsaW5lRW5kID8gb3BlblRva2VuIDogbnVsbDtcbiAgICAgICAgcG9zID0gbmV4dC50bztcbiAgICB9XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IGZvciBkZWxpbWl0ZWQgKHVzdWFsbHkgYnJhY2tldGVkKSBub2Rlcy5cbldpbGwsIGJ5IGRlZmF1bHQsIGluZGVudCBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIHBhcmVudCdzIGJhc2VcbmluZGVudCB1bmxlc3MgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSBjbG9zaW5nIHRva2VuLiBXaGVuIGBhbGlnbmBcbmlzIHRydWUgYW5kIHRoZXJlIGFyZSBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgbm9kZSdzIG9wZW5pbmdcbmxpbmUsIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIHdpbGwgYmUgYWxpZ25lZCB3aXRoIHRoZSBlbmQgb2YgdGhlXG5vcGVuaW5nIG5vZGUsIGxpa2UgdGhpczpcblxuICAgIGZvbyhiYXIsXG4gICAgICAgIGJheilcbiovXG5mdW5jdGlvbiBkZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nLCBhbGlnbiA9IHRydWUsIHVuaXRzID0gMSB9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcpO1xufVxuZnVuY3Rpb24gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nLCBjbG9zZWRBdCkge1xuICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBzcGFjZSA9IGFmdGVyLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VkID0gY2xvc2luZyAmJiBhZnRlci5zbGljZShzcGFjZSwgc3BhY2UgKyBjbG9zaW5nLmxlbmd0aCkgPT0gY2xvc2luZyB8fCBjbG9zZWRBdCA9PSBjb250ZXh0LnBvcyArIHNwYWNlO1xuICAgIGxldCBhbGlnbmVkID0gYWxpZ24gPyBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIDogbnVsbDtcbiAgICBpZiAoYWxpZ25lZClcbiAgICAgICAgcmV0dXJuIGNsb3NlZCA/IGNvbnRleHQuY29sdW1uKGFsaWduZWQuZnJvbSkgOiBjb250ZXh0LmNvbHVtbihhbGlnbmVkLnRvKTtcbiAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQgKiB1bml0cyk7XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQgYWxpZ25zIGEgbm9kZSdzIGNvbnRlbnQgdG8gaXRzIGJhc2VcbmluZGVudGF0aW9uLlxuKi9cbmNvbnN0IGZsYXRJbmRlbnQgPSAoY29udGV4dCkgPT4gY29udGV4dC5iYXNlSW5kZW50O1xuLyoqXG5DcmVhdGVzIGFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQsIGJ5IGRlZmF1bHQsIGluZGVudHNcbmNvbnRpbnVlZCBsaW5lcyBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIG5vZGUncyBiYXNlIGluZGVudGF0aW9uLlxuWW91IGNhbiBwcm92aWRlIGBleGNlcHRgIHRvIHByZXZlbnQgaW5kZW50YXRpb24gb2YgbGluZXMgdGhhdFxubWF0Y2ggYSBwYXR0ZXJuIChmb3IgZXhhbXBsZSBgL15lbHNlXFxiL2AgaW4gYGlmYC9gZWxzZWBcbmNvbnN0cnVjdHMpLCBhbmQgeW91IGNhbiBjaGFuZ2UgdGhlIGFtb3VudCBvZiB1bml0cyB1c2VkIHdpdGggdGhlXG5gdW5pdHNgIG9wdGlvbi5cbiovXG5mdW5jdGlvbiBjb250aW51ZWRJbmRlbnQoeyBleGNlcHQsIHVuaXRzID0gMSB9ID0ge30pIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IG1hdGNoRXhjZXB0ID0gZXhjZXB0ICYmIGV4Y2VwdC50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChtYXRjaEV4Y2VwdCA/IDAgOiB1bml0cyAqIGNvbnRleHQudW5pdCk7XG4gICAgfTtcbn1cbmNvbnN0IERvbnRJbmRlbnRCZXlvbmQgPSAyMDA7XG4vKipcbkVuYWJsZXMgcmVpbmRlbnRhdGlvbiBvbiBpbnB1dC4gV2hlbiBhIGxhbmd1YWdlIGRlZmluZXMgYW5cbmBpbmRlbnRPbklucHV0YCBmaWVsZCBpbiBpdHMgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSwgd2hpY2ggbXVzdCBob2xkIGEgcmVndWxhclxuZXhwcmVzc2lvbiwgdGhlIGxpbmUgYXQgdGhlIGN1cnNvciB3aWxsIGJlIHJlaW5kZW50ZWQgd2hlbmV2ZXIgbmV3XG50ZXh0IGlzIHR5cGVkIGFuZCB0aGUgaW5wdXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdXAgdG8gdGhlXG5jdXJzb3IgbWF0Y2hlcyB0aGF0IHJlZ2V4cC5cblxuVG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVpbmRlbnRzLCBpdCBpcyByZWNvbW1lbmRlZCB0byBzdGFydCB0aGVcbnJlZ2V4cCB3aXRoIGBeYCAodXN1YWxseSBmb2xsb3dlZCBieSBgXFxzKmApLCBhbmQgZW5kIGl0IHdpdGggYCRgLlxuRm9yIGV4YW1wbGUsIGAvXlxccypcXH0kL2Agd2lsbCByZWluZGVudCB3aGVuIGEgY2xvc2luZyBicmFjZSBpc1xuYWRkZWQgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRPbklucHV0KCkge1xuICAgIHJldHVybiBFZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlci5vZih0ciA9PiB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCB8fCAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgcnVsZXMgPSB0ci5zdGFydFN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiaW5kZW50T25JbnB1dFwiLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGRvYyA9IHRyLm5ld0RvYywgeyBoZWFkIH0gPSB0ci5uZXdTZWxlY3Rpb24ubWFpbiwgbGluZSA9IGRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgIGlmIChoZWFkID4gbGluZS5mcm9tICsgRG9udEluZGVudEJleW9uZClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGRvYy5zbGljZVN0cmluZyhsaW5lLmZyb20sIGhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLnNvbWUociA9PiByLnRlc3QobGluZVN0YXJ0KSkpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0ciwgbGFzdCA9IC0xLCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgICAgIGlmIChjdXIgIT0gbm9ybSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXMubGVuZ3RoID8gW3RyLCB7IGNoYW5nZXMsIHNlcXVlbnRpYWw6IHRydWUgfV0gOiB0cjtcbiAgICB9KTtcbn1cblxuLyoqXG5BIGZhY2V0IHRoYXQgcmVnaXN0ZXJzIGEgY29kZSBmb2xkaW5nIHNlcnZpY2UuIFdoZW4gY2FsbGVkIHdpdGhcbnRoZSBleHRlbnQgb2YgYSBsaW5lLCBzdWNoIGEgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZvbGRhYmxlXG5yYW5nZSB0aGF0IHN0YXJ0cyBvbiB0aGF0IGxpbmUgKGJ1dCBjb250aW51ZXMgYmV5b25kIGl0KSwgaWYgb25lXG5jYW4gYmUgZm91bmQuXG4qL1xuY29uc3QgZm9sZFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblRoaXMgbm9kZSBwcm9wIGlzIHVzZWQgdG8gYXNzb2NpYXRlIGZvbGRpbmcgaW5mb3JtYXRpb24gd2l0aFxuc3ludGF4IG5vZGUgdHlwZXMuIEdpdmVuIGEgc3ludGF4IG5vZGUsIGl0IHNob3VsZCBjaGVjayB3aGV0aGVyXG50aGF0IHRyZWUgaXMgZm9sZGFibGUgYW5kIHJldHVybiB0aGUgcmFuZ2UgdGhhdCBjYW4gYmUgY29sbGFwc2VkXG53aGVuIGl0IGlzLlxuKi9cbmNvbnN0IGZvbGROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuW0ZvbGRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBmdW5jdGlvbiB0aGF0IGZvbGRzIGV2ZXJ5dGhpbmcgYnV0XG50aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGEgc3ludGF4IG5vZGUuIFVzZWZ1bCBmb3Igbm9kZXNcbnRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIGRlbGltaXRlcnMuXG4qL1xuZnVuY3Rpb24gZm9sZEluc2lkZShub2RlKSB7XG4gICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkLCBsYXN0ID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnRvIDwgbGFzdC5mcm9tID8geyBmcm9tOiBmaXJzdC50bywgdG86IGxhc3QudHlwZS5pc0Vycm9yID8gbm9kZS50byA6IGxhc3QuZnJvbSB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHN5bnRheEZvbGRpbmcoc3RhdGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xuICAgIGlmICh0cmVlLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgaW5uZXIgPSB0cmVlLnJlc29sdmVJbm5lcihlbmQpO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgZm9yIChsZXQgY3VyID0gaW5uZXI7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkge1xuICAgICAgICBpZiAoY3VyLnRvIDw9IGVuZCB8fCBjdXIuZnJvbSA+IGVuZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgY3VyLmZyb20gPCBzdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgcHJvcCA9IGN1ci50eXBlLnByb3AoZm9sZE5vZGVQcm9wKTtcbiAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3AoY3VyLCBzdGF0ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuZnJvbSA8PSBlbmQgJiYgdmFsdWUuZnJvbSA+PSBzdGFydCAmJiB2YWx1ZS50byA+IGVuZClcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbi8qKlxuQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gbGluZSBpcyBmb2xkYWJsZS4gRmlyc3QgYXNrcyBhbnkgZm9sZFxuc2VydmljZXMgcmVnaXN0ZXJlZCB0aHJvdWdoXG5bYGZvbGRTZXJ2aWNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkU2VydmljZSksIGFuZCBpZiBub25lIG9mIHRoZW0gcmV0dXJuXG5hIHJlc3VsdCwgdHJpZXMgdG8gcXVlcnkgdGhlIFtmb2xkIG5vZGVcbnByb3BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBvZiBzeW50YXggbm9kZXMgdGhhdCBjb3ZlciB0aGUgZW5kXG5vZiB0aGUgbGluZS5cbiovXG5mdW5jdGlvbiBmb2xkYWJsZShzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKSB7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBzdGF0ZS5mYWNldChmb2xkU2VydmljZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNlcnZpY2Uoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gc3ludGF4Rm9sZGluZyhzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKTtcbn1cblxuZXhwb3J0IHsgSW5kZW50Q29udGV4dCwgTFJMYW5ndWFnZSwgTGFuZ3VhZ2UsIExhbmd1YWdlRGVzY3JpcHRpb24sIExhbmd1YWdlU3VwcG9ydCwgUGFyc2VDb250ZXh0LCBUcmVlSW5kZW50Q29udGV4dCwgY29udGludWVkSW5kZW50LCBkZWZpbmVMYW5ndWFnZUZhY2V0LCBkZWxpbWl0ZWRJbmRlbnQsIGVuc3VyZVN5bnRheFRyZWUsIGZsYXRJbmRlbnQsIGZvbGRJbnNpZGUsIGZvbGROb2RlUHJvcCwgZm9sZFNlcnZpY2UsIGZvbGRhYmxlLCBnZXRJbmRlbnRVbml0LCBnZXRJbmRlbnRhdGlvbiwgaW5kZW50Tm9kZVByb3AsIGluZGVudE9uSW5wdXQsIGluZGVudFNlcnZpY2UsIGluZGVudFN0cmluZywgaW5kZW50VW5pdCwgbGFuZ3VhZ2UsIGxhbmd1YWdlRGF0YVByb3AsIHN5bnRheFRyZWUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/language/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/legacy-modes/mode/jinja2.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/jinja2.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"jinja2\": function() { return /* binding */ jinja2; }\n/* harmony export */ });\nvar keywords = [\"and\", \"as\", \"block\", \"endblock\", \"by\", \"cycle\", \"debug\", \"else\", \"elif\", \"extends\", \"filter\", \"endfilter\", \"firstof\", \"for\", \"endfor\", \"if\", \"endif\", \"ifchanged\", \"endifchanged\", \"ifequal\", \"endifequal\", \"ifnotequal\", \"endifnotequal\", \"in\", \"include\", \"load\", \"not\", \"now\", \"or\", \"parsed\", \"regroup\", \"reversed\", \"spaceless\", \"endspaceless\", \"ssi\", \"templatetag\", \"openblock\", \"closeblock\", \"openvariable\", \"closevariable\", \"openbrace\", \"closebrace\", \"opencomment\", \"closecomment\", \"widthratio\", \"url\", \"with\", \"endwith\", \"get_current_language\", \"trans\", \"endtrans\", \"noop\", \"blocktrans\", \"endblocktrans\", \"get_available_languages\", \"get_current_language_bidi\", \"plural\"],\n    operator = /^[+\\-*&%=<>!?|~^]/,\n    sign = /^[:\\[\\(\\{]/,\n    atom = [\"true\", \"false\"],\n    number = /^(\\d[+\\-\\*\\/])?\\d+(\\.\\d+)?/;\nkeywords = new RegExp(\"((\" + keywords.join(\")|(\") + \"))\\\\b\");\natom = new RegExp(\"((\" + atom.join(\")|(\") + \"))\\\\b\");\n\nfunction tokenBase(stream, state) {\n  var ch = stream.peek(); //Comment\n\n  if (state.incomment) {\n    if (!stream.skipTo(\"#}\")) {\n      stream.skipToEnd();\n    } else {\n      stream.eatWhile(/\\#|}/);\n      state.incomment = false;\n    }\n\n    return \"comment\"; //Tag\n  } else if (state.intag) {\n    //After operator\n    if (state.operator) {\n      state.operator = false;\n\n      if (stream.match(atom)) {\n        return \"atom\";\n      }\n\n      if (stream.match(number)) {\n        return \"number\";\n      }\n    } //After sign\n\n\n    if (state.sign) {\n      state.sign = false;\n\n      if (stream.match(atom)) {\n        return \"atom\";\n      }\n\n      if (stream.match(number)) {\n        return \"number\";\n      }\n    }\n\n    if (state.instring) {\n      if (ch == state.instring) {\n        state.instring = false;\n      }\n\n      stream.next();\n      return \"string\";\n    } else if (ch == \"'\" || ch == '\"') {\n      state.instring = ch;\n      stream.next();\n      return \"string\";\n    } else if (stream.match(state.intag + \"}\") || stream.eat(\"-\") && stream.match(state.intag + \"}\")) {\n      state.intag = false;\n      return \"tag\";\n    } else if (stream.match(operator)) {\n      state.operator = true;\n      return \"operator\";\n    } else if (stream.match(sign)) {\n      state.sign = true;\n    } else {\n      if (stream.eat(\" \") || stream.sol()) {\n        if (stream.match(keywords)) {\n          return \"keyword\";\n        }\n\n        if (stream.match(atom)) {\n          return \"atom\";\n        }\n\n        if (stream.match(number)) {\n          return \"number\";\n        }\n\n        if (stream.sol()) {\n          stream.next();\n        }\n      } else {\n        stream.next();\n      }\n    }\n\n    return \"variable\";\n  } else if (stream.eat(\"{\")) {\n    if (stream.eat(\"#\")) {\n      state.incomment = true;\n\n      if (!stream.skipTo(\"#}\")) {\n        stream.skipToEnd();\n      } else {\n        stream.eatWhile(/\\#|}/);\n        state.incomment = false;\n      }\n\n      return \"comment\"; //Open tag\n    } else if (ch = stream.eat(/\\{|%/)) {\n      //Cache close tag\n      state.intag = ch;\n\n      if (ch == \"{\") {\n        state.intag = \"}\";\n      }\n\n      stream.eat(\"-\");\n      return \"tag\";\n    }\n  }\n\n  stream.next();\n}\n\n;\nvar jinja2 = {\n  startState: function startState() {\n    return {\n      tokenize: tokenBase\n    };\n  },\n  token: function token(stream, state) {\n    return state.tokenize(stream, state);\n  },\n  languageData: {\n    commentTokens: {\n      block: {\n        open: \"{#\",\n        close: \"#}\"\n      }\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvamluamEyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBa0JBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBUEEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9qaW5qYTIuanM/NzAyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIga2V5d29yZHMgPSBbXCJhbmRcIiwgXCJhc1wiLCBcImJsb2NrXCIsIFwiZW5kYmxvY2tcIiwgXCJieVwiLCBcImN5Y2xlXCIsIFwiZGVidWdcIiwgXCJlbHNlXCIsIFwiZWxpZlwiLFxuICAgICAgICAgICAgICAgIFwiZXh0ZW5kc1wiLCBcImZpbHRlclwiLCBcImVuZGZpbHRlclwiLCBcImZpcnN0b2ZcIiwgXCJmb3JcIixcbiAgICAgICAgICAgICAgICBcImVuZGZvclwiLCBcImlmXCIsIFwiZW5kaWZcIiwgXCJpZmNoYW5nZWRcIiwgXCJlbmRpZmNoYW5nZWRcIixcbiAgICAgICAgICAgICAgICBcImlmZXF1YWxcIiwgXCJlbmRpZmVxdWFsXCIsIFwiaWZub3RlcXVhbFwiLFxuICAgICAgICAgICAgICAgIFwiZW5kaWZub3RlcXVhbFwiLCBcImluXCIsIFwiaW5jbHVkZVwiLCBcImxvYWRcIiwgXCJub3RcIiwgXCJub3dcIiwgXCJvclwiLFxuICAgICAgICAgICAgICAgIFwicGFyc2VkXCIsIFwicmVncm91cFwiLCBcInJldmVyc2VkXCIsIFwic3BhY2VsZXNzXCIsXG4gICAgICAgICAgICAgICAgXCJlbmRzcGFjZWxlc3NcIiwgXCJzc2lcIiwgXCJ0ZW1wbGF0ZXRhZ1wiLCBcIm9wZW5ibG9ja1wiLFxuICAgICAgICAgICAgICAgIFwiY2xvc2VibG9ja1wiLCBcIm9wZW52YXJpYWJsZVwiLCBcImNsb3NldmFyaWFibGVcIixcbiAgICAgICAgICAgICAgICBcIm9wZW5icmFjZVwiLCBcImNsb3NlYnJhY2VcIiwgXCJvcGVuY29tbWVudFwiLFxuICAgICAgICAgICAgICAgIFwiY2xvc2Vjb21tZW50XCIsIFwid2lkdGhyYXRpb1wiLCBcInVybFwiLCBcIndpdGhcIiwgXCJlbmR3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJnZXRfY3VycmVudF9sYW5ndWFnZVwiLCBcInRyYW5zXCIsIFwiZW5kdHJhbnNcIiwgXCJub29wXCIsIFwiYmxvY2t0cmFuc1wiLFxuICAgICAgICAgICAgICAgIFwiZW5kYmxvY2t0cmFuc1wiLCBcImdldF9hdmFpbGFibGVfbGFuZ3VhZ2VzXCIsXG4gICAgICAgICAgICAgICAgXCJnZXRfY3VycmVudF9sYW5ndWFnZV9iaWRpXCIsIFwicGx1cmFsXCJdLFxuICAgIG9wZXJhdG9yID0gL15bK1xcLSomJT08PiE/fH5eXS8sXG4gICAgc2lnbiA9IC9eWzpcXFtcXChcXHtdLyxcbiAgICBhdG9tID0gW1widHJ1ZVwiLCBcImZhbHNlXCJdLFxuICAgIG51bWJlciA9IC9eKFxcZFsrXFwtXFwqXFwvXSk/XFxkKyhcXC5cXGQrKT8vO1xuXG5rZXl3b3JkcyA9IG5ldyBSZWdFeHAoXCIoKFwiICsga2V5d29yZHMuam9pbihcIil8KFwiKSArIFwiKSlcXFxcYlwiKTtcbmF0b20gPSBuZXcgUmVnRXhwKFwiKChcIiArIGF0b20uam9pbihcIil8KFwiKSArIFwiKSlcXFxcYlwiKTtcblxuZnVuY3Rpb24gdG9rZW5CYXNlIChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG5cbiAgLy9Db21tZW50XG4gIGlmIChzdGF0ZS5pbmNvbW1lbnQpIHtcbiAgICBpZighc3RyZWFtLnNraXBUbyhcIiN9XCIpKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFwjfH0vKTtcbiAgICAgIHN0YXRlLmluY29tbWVudCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgLy9UYWdcbiAgfSBlbHNlIGlmIChzdGF0ZS5pbnRhZykge1xuICAgIC8vQWZ0ZXIgb3BlcmF0b3JcbiAgICBpZihzdGF0ZS5vcGVyYXRvcikge1xuICAgICAgc3RhdGUub3BlcmF0b3IgPSBmYWxzZTtcbiAgICAgIGlmKHN0cmVhbS5tYXRjaChhdG9tKSkge1xuICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICB9XG4gICAgICBpZihzdHJlYW0ubWF0Y2gobnVtYmVyKSkge1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy9BZnRlciBzaWduXG4gICAgaWYoc3RhdGUuc2lnbikge1xuICAgICAgc3RhdGUuc2lnbiA9IGZhbHNlO1xuICAgICAgaWYoc3RyZWFtLm1hdGNoKGF0b20pKSB7XG4gICAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICAgIH1cbiAgICAgIGlmKHN0cmVhbS5tYXRjaChudW1iZXIpKSB7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHN0YXRlLmluc3RyaW5nKSB7XG4gICAgICBpZihjaCA9PSBzdGF0ZS5pbnN0cmluZykge1xuICAgICAgICBzdGF0ZS5pbnN0cmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH0gZWxzZSBpZihjaCA9PSBcIidcIiB8fCBjaCA9PSAnXCInKSB7XG4gICAgICBzdGF0ZS5pbnN0cmluZyA9IGNoO1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH0gZWxzZSBpZihzdHJlYW0ubWF0Y2goc3RhdGUuaW50YWcgKyBcIn1cIikgfHwgc3RyZWFtLmVhdChcIi1cIikgJiYgc3RyZWFtLm1hdGNoKHN0YXRlLmludGFnICsgXCJ9XCIpKSB7XG4gICAgICBzdGF0ZS5pbnRhZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfSBlbHNlIGlmKHN0cmVhbS5tYXRjaChvcGVyYXRvcikpIHtcbiAgICAgIHN0YXRlLm9wZXJhdG9yID0gdHJ1ZTtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfSBlbHNlIGlmKHN0cmVhbS5tYXRjaChzaWduKSkge1xuICAgICAgc3RhdGUuc2lnbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHN0cmVhbS5lYXQoXCIgXCIpIHx8IHN0cmVhbS5zb2woKSkge1xuICAgICAgICBpZihzdHJlYW0ubWF0Y2goa2V5d29yZHMpKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmKHN0cmVhbS5tYXRjaChhdG9tKSkge1xuICAgICAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICAgICAgfVxuICAgICAgICBpZihzdHJlYW0ubWF0Y2gobnVtYmVyKSkge1xuICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICB9XG4gICAgICAgIGlmKHN0cmVhbS5zb2woKSkge1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwie1wiKSkge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiI1wiKSkge1xuICAgICAgc3RhdGUuaW5jb21tZW50ID0gdHJ1ZTtcbiAgICAgIGlmKCFzdHJlYW0uc2tpcFRvKFwiI31cIikpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9cXCN8fS8pO1xuICAgICAgICBzdGF0ZS5pbmNvbW1lbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIC8vT3BlbiB0YWdcbiAgICB9IGVsc2UgaWYgKGNoID0gc3RyZWFtLmVhdCgvXFx7fCUvKSkge1xuICAgICAgLy9DYWNoZSBjbG9zZSB0YWdcbiAgICAgIHN0YXRlLmludGFnID0gY2g7XG4gICAgICBpZihjaCA9PSBcIntcIikge1xuICAgICAgICBzdGF0ZS5pbnRhZyA9IFwifVwiO1xuICAgICAgfVxuICAgICAgc3RyZWFtLmVhdChcIi1cIik7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9XG4gIH1cbiAgc3RyZWFtLm5leHQoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBqaW5qYTIgPSB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge3Rva2VuaXplOiB0b2tlbkJhc2V9O1xuICB9LFxuICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0sXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtibG9jazoge29wZW46IFwieyNcIiwgY2xvc2U6IFwiI31cIn19XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/jinja2.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/legacy-modes/mode/yaml.js":
/*!************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/yaml.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"yaml\": function() { return /* binding */ yaml; }\n/* harmony export */ });\nvar cons = ['true', 'false', 'on', 'off', 'yes', 'no'];\nvar keywordRegex = new RegExp(\"\\\\b((\" + cons.join(\")|(\") + \"))$\", 'i');\nvar yaml = {\n  token: function token(stream, state) {\n    var ch = stream.peek();\n    var esc = state.escaped;\n    state.escaped = false;\n    /* comments */\n\n    if (ch == \"#\" && (stream.pos == 0 || /\\s/.test(stream.string.charAt(stream.pos - 1)))) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    if (stream.match(/^('([^']|\\\\.)*'?|\"([^\"]|\\\\.)*\"?)/)) return \"string\";\n\n    if (state.literal && stream.indentation() > state.keyCol) {\n      stream.skipToEnd();\n      return \"string\";\n    } else if (state.literal) {\n      state.literal = false;\n    }\n\n    if (stream.sol()) {\n      state.keyCol = 0;\n      state.pair = false;\n      state.pairStart = false;\n      /* document start */\n\n      if (stream.match('---')) {\n        return \"def\";\n      }\n      /* document end */\n\n\n      if (stream.match('...')) {\n        return \"def\";\n      }\n      /* array list item */\n\n\n      if (stream.match(/^\\s*-\\s+/)) {\n        return 'meta';\n      }\n    }\n    /* inline pairs/lists */\n\n\n    if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n      if (ch == '{') state.inlinePairs++;else if (ch == '}') state.inlinePairs--;else if (ch == '[') state.inlineList++;else state.inlineList--;\n      return 'meta';\n    }\n    /* list separator */\n\n\n    if (state.inlineList > 0 && !esc && ch == ',') {\n      stream.next();\n      return 'meta';\n    }\n    /* pairs separator */\n\n\n    if (state.inlinePairs > 0 && !esc && ch == ',') {\n      state.keyCol = 0;\n      state.pair = false;\n      state.pairStart = false;\n      stream.next();\n      return 'meta';\n    }\n    /* start of value of a pair */\n\n\n    if (state.pairStart) {\n      /* block literals */\n      if (stream.match(/^\\s*(\\||\\>)\\s*/)) {\n        state.literal = true;\n        return 'meta';\n      }\n\n      ;\n      /* references */\n\n      if (stream.match(/^\\s*(\\&|\\*)[a-z0-9\\._-]+\\b/i)) {\n        return 'variable';\n      }\n      /* numbers */\n\n\n      if (state.inlinePairs == 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?$/)) {\n        return 'number';\n      }\n\n      if (state.inlinePairs > 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?(?=(,|}))/)) {\n        return 'number';\n      }\n      /* keywords */\n\n\n      if (stream.match(keywordRegex)) {\n        return 'keyword';\n      }\n    }\n    /* pairs (associative arrays) -> key */\n\n\n    if (!state.pair && stream.match(/^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^,\\[\\]{}#&*!|>'\"%@`])[^#]*?(?=\\s*:($|\\s))/)) {\n      state.pair = true;\n      state.keyCol = stream.indentation();\n      return \"atom\";\n    }\n\n    if (state.pair && stream.match(/^:\\s*/)) {\n      state.pairStart = true;\n      return 'meta';\n    }\n    /* nothing found, continue */\n\n\n    state.pairStart = false;\n    state.escaped = ch == '\\\\';\n    stream.next();\n    return null;\n  },\n  startState: function startState() {\n    return {\n      pair: false,\n      pairStart: false,\n      keyCol: 0,\n      inlinePairs: 0,\n      inlineList: 0,\n      literal: false,\n      escaped: false\n    };\n  },\n  languageData: {\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUveWFtbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBN0ZBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUveWFtbC5qcz85YmQ3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb25zID0gWyd0cnVlJywgJ2ZhbHNlJywgJ29uJywgJ29mZicsICd5ZXMnLCAnbm8nXTtcbnZhciBrZXl3b3JkUmVnZXggPSBuZXcgUmVnRXhwKFwiXFxcXGIoKFwiK2NvbnMuam9pbihcIil8KFwiKStcIikpJFwiLCAnaScpO1xuXG5leHBvcnQgY29uc3QgeWFtbCA9IHtcbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgIHZhciBlc2MgPSBzdGF0ZS5lc2NhcGVkO1xuICAgIHN0YXRlLmVzY2FwZWQgPSBmYWxzZTtcbiAgICAvKiBjb21tZW50cyAqL1xuICAgIGlmIChjaCA9PSBcIiNcIiAmJiAoc3RyZWFtLnBvcyA9PSAwIHx8IC9cXHMvLnRlc3Qoc3RyZWFtLnN0cmluZy5jaGFyQXQoc3RyZWFtLnBvcyAtIDEpKSkpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKCcoW14nXXxcXFxcLikqJz98XCIoW15cIl18XFxcXC4pKlwiPykvKSlcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuXG4gICAgaWYgKHN0YXRlLmxpdGVyYWwgJiYgc3RyZWFtLmluZGVudGF0aW9uKCkgPiBzdGF0ZS5rZXlDb2wpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTsgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saXRlcmFsKSB7IHN0YXRlLmxpdGVyYWwgPSBmYWxzZTsgfVxuICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgIHN0YXRlLmtleUNvbCA9IDA7XG4gICAgICBzdGF0ZS5wYWlyID0gZmFsc2U7XG4gICAgICBzdGF0ZS5wYWlyU3RhcnQgPSBmYWxzZTtcbiAgICAgIC8qIGRvY3VtZW50IHN0YXJ0ICovXG4gICAgICBpZihzdHJlYW0ubWF0Y2goJy0tLScpKSB7IHJldHVybiBcImRlZlwiOyB9XG4gICAgICAvKiBkb2N1bWVudCBlbmQgKi9cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goJy4uLicpKSB7IHJldHVybiBcImRlZlwiOyB9XG4gICAgICAvKiBhcnJheSBsaXN0IGl0ZW0gKi9cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXHMqLVxccysvKSkgeyByZXR1cm4gJ21ldGEnOyB9XG4gICAgfVxuICAgIC8qIGlubGluZSBwYWlycy9saXN0cyAqL1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL14oXFx7fFxcfXxcXFt8XFxdKS8pKSB7XG4gICAgICBpZiAoY2ggPT0gJ3snKVxuICAgICAgICBzdGF0ZS5pbmxpbmVQYWlycysrO1xuICAgICAgZWxzZSBpZiAoY2ggPT0gJ30nKVxuICAgICAgICBzdGF0ZS5pbmxpbmVQYWlycy0tO1xuICAgICAgZWxzZSBpZiAoY2ggPT0gJ1snKVxuICAgICAgICBzdGF0ZS5pbmxpbmVMaXN0Kys7XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXRlLmlubGluZUxpc3QtLTtcbiAgICAgIHJldHVybiAnbWV0YSc7XG4gICAgfVxuXG4gICAgLyogbGlzdCBzZXBhcmF0b3IgKi9cbiAgICBpZiAoc3RhdGUuaW5saW5lTGlzdCA+IDAgJiYgIWVzYyAmJiBjaCA9PSAnLCcpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gJ21ldGEnO1xuICAgIH1cbiAgICAvKiBwYWlycyBzZXBhcmF0b3IgKi9cbiAgICBpZiAoc3RhdGUuaW5saW5lUGFpcnMgPiAwICYmICFlc2MgJiYgY2ggPT0gJywnKSB7XG4gICAgICBzdGF0ZS5rZXlDb2wgPSAwO1xuICAgICAgc3RhdGUucGFpciA9IGZhbHNlO1xuICAgICAgc3RhdGUucGFpclN0YXJ0ID0gZmFsc2U7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuICdtZXRhJztcbiAgICB9XG5cbiAgICAvKiBzdGFydCBvZiB2YWx1ZSBvZiBhIHBhaXIgKi9cbiAgICBpZiAoc3RhdGUucGFpclN0YXJ0KSB7XG4gICAgICAvKiBibG9jayBsaXRlcmFscyAqL1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxccyooXFx8fFxcPilcXHMqLykpIHsgc3RhdGUubGl0ZXJhbCA9IHRydWU7IHJldHVybiAnbWV0YSc7IH07XG4gICAgICAvKiByZWZlcmVuY2VzICovXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFxzKihcXCZ8XFwqKVthLXowLTlcXC5fLV0rXFxiL2kpKSB7IHJldHVybiAndmFyaWFibGUnOyB9XG4gICAgICAvKiBudW1iZXJzICovXG4gICAgICBpZiAoc3RhdGUuaW5saW5lUGFpcnMgPT0gMCAmJiBzdHJlYW0ubWF0Y2goL15cXHMqLT9bMC05XFwuXFwsXStcXHM/JC8pKSB7IHJldHVybiAnbnVtYmVyJzsgfVxuICAgICAgaWYgKHN0YXRlLmlubGluZVBhaXJzID4gMCAmJiBzdHJlYW0ubWF0Y2goL15cXHMqLT9bMC05XFwuXFwsXStcXHM/KD89KCx8fSkpLykpIHsgcmV0dXJuICdudW1iZXInOyB9XG4gICAgICAvKiBrZXl3b3JkcyAqL1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3JkUmVnZXgpKSB7IHJldHVybiAna2V5d29yZCc7IH1cbiAgICB9XG5cbiAgICAvKiBwYWlycyAoYXNzb2NpYXRpdmUgYXJyYXlzKSAtPiBrZXkgKi9cbiAgICBpZiAoIXN0YXRlLnBhaXIgJiYgc3RyZWFtLm1hdGNoKC9eXFxzKig/OlssXFxbXFxde30mKiF8PidcIiVAYF1bXlxccydcIjpdfFteLFxcW1xcXXt9IyYqIXw+J1wiJUBgXSlbXiNdKj8oPz1cXHMqOigkfFxccykpLykpIHtcbiAgICAgIHN0YXRlLnBhaXIgPSB0cnVlO1xuICAgICAgc3RhdGUua2V5Q29sID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5wYWlyICYmIHN0cmVhbS5tYXRjaCgvXjpcXHMqLykpIHsgc3RhdGUucGFpclN0YXJ0ID0gdHJ1ZTsgcmV0dXJuICdtZXRhJzsgfVxuXG4gICAgLyogbm90aGluZyBmb3VuZCwgY29udGludWUgKi9cbiAgICBzdGF0ZS5wYWlyU3RhcnQgPSBmYWxzZTtcbiAgICBzdGF0ZS5lc2NhcGVkID0gKGNoID09ICdcXFxcJyk7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhaXI6IGZhbHNlLFxuICAgICAgcGFpclN0YXJ0OiBmYWxzZSxcbiAgICAgIGtleUNvbDogMCxcbiAgICAgIGlubGluZVBhaXJzOiAwLFxuICAgICAgaW5saW5lTGlzdDogMCxcbiAgICAgIGxpdGVyYWw6IGZhbHNlLFxuICAgICAgZXNjYXBlZDogZmFsc2VcbiAgICB9O1xuICB9LFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCIjXCJ9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/yaml.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/matchbrackets/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/matchbrackets/dist/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bracketMatching\": function() { return /* binding */ bracketMatching; },\n/* harmony export */   \"matchBrackets\": function() { return /* binding */ matchBrackets; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\n\n\nvar baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n  \".cm-matchingBracket\": {\n    color: \"#0b0\"\n  },\n  \".cm-nonmatchingBracket\": {\n    color: \"#a22\"\n  }\n});\nvar DefaultScanDist = 10000,\n    DefaultBrackets = \"()[]{}\";\nvar bracketMatchingConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: function combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n      afterCursor: true,\n      brackets: DefaultBrackets,\n      maxScanDistance: DefaultScanDist\n    });\n  }\n});\nvar matchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({\n  \"class\": \"cm-matchingBracket\"\n}),\n    nonmatchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({\n  \"class\": \"cm-nonmatchingBracket\"\n});\nvar bracketMatchingState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n  create: function create() {\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none;\n  },\n  update: function update(deco, tr) {\n    if (!tr.docChanged && !tr.selection) return deco;\n    var decorations = [];\n    var config = tr.state.facet(bracketMatchingConfig);\n\n    var _iterator = _createForOfIteratorHelper(tr.state.selection.ranges),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var range = _step.value;\n        if (!range.empty) continue;\n        var match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n        if (!match) continue;\n        var mark = match.matched ? matchingMark : nonmatchingMark;\n        decorations.push(mark.range(match.start.from, match.start.to));\n        if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set(decorations, true);\n  },\n  provide: function provide(f) {\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.from(f);\n  }\n});\nvar bracketMatchingUnique = [bracketMatchingState, baseTheme];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/\n\nfunction bracketMatching() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\n\nfunction matchingNodes(node, dir, brackets) {\n  var byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\n  if (byProp) return byProp;\n\n  if (node.name.length == 1) {\n    var index = brackets.indexOf(node.name);\n    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [brackets[index + dir]];\n  }\n\n  return null;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/\n\n\nfunction matchBrackets(state, pos, dir) {\n  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var maxScanDistance = config.maxScanDistance || DefaultScanDist,\n      brackets = config.brackets || DefaultBrackets;\n  var tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state),\n      sub = tree.resolve(pos, dir),\n      matches;\n  if (matches = matchingNodes(sub.type, dir, brackets)) return matchMarkedBrackets(state, pos, dir, sub, matches, brackets);else return matchPlainBrackets(state, pos, dir, tree, sub.type, maxScanDistance, brackets);\n}\n\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n  var parent = token.parent,\n      firstToken = {\n    from: token.from,\n    to: token.to\n  };\n  var depth = 0,\n      cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n    if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n      if (depth == 0 && matching.indexOf(cursor.type.name) > -1) {\n        return {\n          start: firstToken,\n          end: {\n            from: cursor.from,\n            to: cursor.to\n          },\n          matched: true\n        };\n      } else if (matchingNodes(cursor.type, dir, brackets)) {\n        depth++;\n      } else if (matchingNodes(cursor.type, -dir, brackets)) {\n        depth--;\n        if (depth == 0) return {\n          start: firstToken,\n          end: {\n            from: cursor.from,\n            to: cursor.to\n          },\n          matched: false\n        };\n      }\n    }\n  } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n  return {\n    start: firstToken,\n    matched: false\n  };\n}\n\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n  var startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n  var bracket = brackets.indexOf(startCh);\n  if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n  var startToken = {\n    from: dir < 0 ? pos - 1 : pos,\n    to: dir > 0 ? pos + 1 : pos\n  };\n  var iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),\n      depth = 0;\n\n  for (var distance = 0; !iter.next().done && distance <= maxScanDistance;) {\n    var text = iter.value;\n    if (dir < 0) distance += text.length;\n    var basePos = pos + distance * dir;\n\n    for (var _pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; _pos2 != end; _pos2 += dir) {\n      var found = brackets.indexOf(text[_pos2]);\n      if (found < 0 || tree.resolve(basePos + _pos2, 1).type != tokenType) continue;\n\n      if (found % 2 == 0 == dir > 0) {\n        depth++;\n      } else if (depth == 1) {\n        // Closing\n        return {\n          start: startToken,\n          end: {\n            from: basePos + _pos2,\n            to: basePos + _pos2 + 1\n          },\n          matched: found >> 1 == bracket >> 1\n        };\n      } else {\n        depth--;\n      }\n    }\n\n    if (dir > 0) distance += text.length;\n  }\n\n  return iter.done ? {\n    start: startToken,\n    matched: false\n  } : null;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbWF0Y2hicmFja2V0cy9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBUEE7QUFTQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUpBO0FBQUE7O0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFFQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFuQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFvQkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQXhCQTtBQTBCQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbWF0Y2hicmFja2V0cy9kaXN0L2luZGV4LmpzPzU5ODEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBzeW50YXhUcmVlIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgRWRpdG9yVmlldywgRGVjb3JhdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1tYXRjaGluZ0JyYWNrZXRcIjogeyBjb2xvcjogXCIjMGIwXCIgfSxcbiAgICBcIi5jbS1ub25tYXRjaGluZ0JyYWNrZXRcIjogeyBjb2xvcjogXCIjYTIyXCIgfVxufSk7XG5jb25zdCBEZWZhdWx0U2NhbkRpc3QgPSAxMDAwMCwgRGVmYXVsdEJyYWNrZXRzID0gXCIoKVtde31cIjtcbmNvbnN0IGJyYWNrZXRNYXRjaGluZ0NvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBhZnRlckN1cnNvcjogdHJ1ZSxcbiAgICAgICAgICAgIGJyYWNrZXRzOiBEZWZhdWx0QnJhY2tldHMsXG4gICAgICAgICAgICBtYXhTY2FuRGlzdGFuY2U6IERlZmF1bHRTY2FuRGlzdFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNvbnN0IG1hdGNoaW5nTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1tYXRjaGluZ0JyYWNrZXRcIiB9KSwgbm9ubWF0Y2hpbmdNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW5vbm1hdGNoaW5nQnJhY2tldFwiIH0pO1xuY29uc3QgYnJhY2tldE1hdGNoaW5nU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIERlY29yYXRpb24ubm9uZTsgfSxcbiAgICB1cGRhdGUoZGVjbywgdHIpIHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmICF0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gZGVjbztcbiAgICAgICAgbGV0IGRlY29yYXRpb25zID0gW107XG4gICAgICAgIGxldCBjb25maWcgPSB0ci5zdGF0ZS5mYWNldChicmFja2V0TWF0Y2hpbmdDb25maWcpO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiB0ci5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCwgLTEsIGNvbmZpZylcbiAgICAgICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA+IDAgJiYgbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCAtIDEsIDEsIGNvbmZpZykpXG4gICAgICAgICAgICAgICAgfHwgKGNvbmZpZy5hZnRlckN1cnNvciAmJlxuICAgICAgICAgICAgICAgICAgICAobWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCwgMSwgY29uZmlnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJhbmdlLmhlYWQgPCB0ci5zdGF0ZS5kb2MubGVuZ3RoICYmIG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQgKyAxLCAtMSwgY29uZmlnKSkpKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgbWFyayA9IG1hdGNoLm1hdGNoZWQgPyBtYXRjaGluZ01hcmsgOiBub25tYXRjaGluZ01hcms7XG4gICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcmsucmFuZ2UobWF0Y2guc3RhcnQuZnJvbSwgbWF0Y2guc3RhcnQudG8pKTtcbiAgICAgICAgICAgIGlmIChtYXRjaC5lbmQpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLmVuZC5mcm9tLCBtYXRjaC5lbmQudG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjb3JhdGlvbnMsIHRydWUpO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZilcbn0pO1xuY29uc3QgYnJhY2tldE1hdGNoaW5nVW5pcXVlID0gW1xuICAgIGJyYWNrZXRNYXRjaGluZ1N0YXRlLFxuICAgIGJhc2VUaGVtZVxuXTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYnJhY2tldCBtYXRjaGluZy4gV2hlbmV2ZXIgdGhlXG5jdXJzb3IgaXMgbmV4dCB0byBhIGJyYWNrZXQsIHRoYXQgYnJhY2tldCBhbmQgdGhlIG9uZSBpdCBtYXRjaGVzXG5hcmUgaGlnaGxpZ2h0ZWQuIE9yLCB3aGVuIG5vIG1hdGNoaW5nIGJyYWNrZXQgaXMgZm91bmQsIGFub3RoZXJcbmhpZ2hsaWdodGluZyBzdHlsZSBpcyB1c2VkIHRvIGluZGljYXRlIHRoaXMuXG4qL1xuZnVuY3Rpb24gYnJhY2tldE1hdGNoaW5nKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFticmFja2V0TWF0Y2hpbmdDb25maWcub2YoY29uZmlnKSwgYnJhY2tldE1hdGNoaW5nVW5pcXVlXTtcbn1cbmZ1bmN0aW9uIG1hdGNoaW5nTm9kZXMobm9kZSwgZGlyLCBicmFja2V0cykge1xuICAgIGxldCBieVByb3AgPSBub2RlLnByb3AoZGlyIDwgMCA/IE5vZGVQcm9wLm9wZW5lZEJ5IDogTm9kZVByb3AuY2xvc2VkQnkpO1xuICAgIGlmIChieVByb3ApXG4gICAgICAgIHJldHVybiBieVByb3A7XG4gICAgaWYgKG5vZGUubmFtZS5sZW5ndGggPT0gMSkge1xuICAgICAgICBsZXQgaW5kZXggPSBicmFja2V0cy5pbmRleE9mKG5vZGUubmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xICYmIGluZGV4ICUgMiA9PSAoZGlyIDwgMCA/IDEgOiAwKSlcbiAgICAgICAgICAgIHJldHVybiBbYnJhY2tldHNbaW5kZXggKyBkaXJdXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbkZpbmQgdGhlIG1hdGNoaW5nIGJyYWNrZXQgZm9yIHRoZSB0b2tlbiBhdCBgcG9zYCwgc2Nhbm5pbmdcbmRpcmVjdGlvbiBgZGlyYC4gT25seSB0aGUgYGJyYWNrZXRzYCBhbmQgYG1heFNjYW5EaXN0YW5jZWBcbnByb3BlcnRpZXMgYXJlIHVzZWQgZnJvbSBgY29uZmlnYCwgaWYgZ2l2ZW4uIFJldHVybnMgbnVsbCBpZiBub1xuYnJhY2tldCB3YXMgZm91bmQgYXQgYHBvc2AsIG9yIGEgbWF0Y2ggcmVzdWx0IG90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY29uZmlnID0ge30pIHtcbiAgICBsZXQgbWF4U2NhbkRpc3RhbmNlID0gY29uZmlnLm1heFNjYW5EaXN0YW5jZSB8fCBEZWZhdWx0U2NhbkRpc3QsIGJyYWNrZXRzID0gY29uZmlnLmJyYWNrZXRzIHx8IERlZmF1bHRCcmFja2V0cztcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLCBzdWIgPSB0cmVlLnJlc29sdmUocG9zLCBkaXIpLCBtYXRjaGVzO1xuICAgIGlmIChtYXRjaGVzID0gbWF0Y2hpbmdOb2RlcyhzdWIudHlwZSwgZGlyLCBicmFja2V0cykpXG4gICAgICAgIHJldHVybiBtYXRjaE1hcmtlZEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgc3ViLCBtYXRjaGVzLCBicmFja2V0cyk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gbWF0Y2hQbGFpbkJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgdHJlZSwgc3ViLnR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpO1xufVxuZnVuY3Rpb24gbWF0Y2hNYXJrZWRCcmFja2V0cyhfc3RhdGUsIF9wb3MsIGRpciwgdG9rZW4sIG1hdGNoaW5nLCBicmFja2V0cykge1xuICAgIGxldCBwYXJlbnQgPSB0b2tlbi5wYXJlbnQsIGZpcnN0VG9rZW4gPSB7IGZyb206IHRva2VuLmZyb20sIHRvOiB0b2tlbi50byB9O1xuICAgIGxldCBkZXB0aCA9IDAsIGN1cnNvciA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jdXJzb3I7XG4gICAgaWYgKGN1cnNvciAmJiAoZGlyIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZSh0b2tlbi5mcm9tKSA6IGN1cnNvci5jaGlsZEFmdGVyKHRva2VuLnRvKSkpXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChkaXIgPCAwID8gY3Vyc29yLnRvIDw9IHRva2VuLmZyb20gOiBjdXJzb3IuZnJvbSA+PSB0b2tlbi50bykge1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwICYmIG1hdGNoaW5nLmluZGV4T2YoY3Vyc29yLnR5cGUubmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogZmlyc3RUb2tlbiwgZW5kOiB7IGZyb206IGN1cnNvci5mcm9tLCB0bzogY3Vyc29yLnRvIH0sIG1hdGNoZWQ6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdOb2RlcyhjdXJzb3IudHlwZSwgZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdOb2RlcyhjdXJzb3IudHlwZSwgLWRpciwgYnJhY2tldHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGZpcnN0VG9rZW4sIGVuZDogeyBmcm9tOiBjdXJzb3IuZnJvbSwgdG86IGN1cnNvci50byB9LCBtYXRjaGVkOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlyIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBtYXRjaGVkOiBmYWxzZSB9O1xufVxuZnVuY3Rpb24gbWF0Y2hQbGFpbkJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgdHJlZSwgdG9rZW5UeXBlLCBtYXhTY2FuRGlzdGFuY2UsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHN0YXJ0Q2ggPSBkaXIgPCAwID8gc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zKSA6IHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSk7XG4gICAgbGV0IGJyYWNrZXQgPSBicmFja2V0cy5pbmRleE9mKHN0YXJ0Q2gpO1xuICAgIGlmIChicmFja2V0IDwgMCB8fCAoYnJhY2tldCAlIDIgPT0gMCkgIT0gKGRpciA+IDApKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc3RhcnRUb2tlbiA9IHsgZnJvbTogZGlyIDwgMCA/IHBvcyAtIDEgOiBwb3MsIHRvOiBkaXIgPiAwID8gcG9zICsgMSA6IHBvcyB9O1xuICAgIGxldCBpdGVyID0gc3RhdGUuZG9jLml0ZXJSYW5nZShwb3MsIGRpciA+IDAgPyBzdGF0ZS5kb2MubGVuZ3RoIDogMCksIGRlcHRoID0gMDtcbiAgICBmb3IgKGxldCBkaXN0YW5jZSA9IDA7ICEoaXRlci5uZXh0KCkpLmRvbmUgJiYgZGlzdGFuY2UgPD0gbWF4U2NhbkRpc3RhbmNlOykge1xuICAgICAgICBsZXQgdGV4dCA9IGl0ZXIudmFsdWU7XG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBiYXNlUG9zID0gcG9zICsgZGlzdGFuY2UgKiBkaXI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGRpciA+IDAgPyAwIDogdGV4dC5sZW5ndGggLSAxLCBlbmQgPSBkaXIgPiAwID8gdGV4dC5sZW5ndGggOiAtMTsgcG9zICE9IGVuZDsgcG9zICs9IGRpcikge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gYnJhY2tldHMuaW5kZXhPZih0ZXh0W3Bvc10pO1xuICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCB8fCB0cmVlLnJlc29sdmUoYmFzZVBvcyArIHBvcywgMSkudHlwZSAhPSB0b2tlblR5cGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoKGZvdW5kICUgMiA9PSAwKSA9PSAoZGlyID4gMCkpIHtcbiAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVwdGggPT0gMSkgeyAvLyBDbG9zaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0VG9rZW4sIGVuZDogeyBmcm9tOiBiYXNlUG9zICsgcG9zLCB0bzogYmFzZVBvcyArIHBvcyArIDEgfSwgbWF0Y2hlZDogKGZvdW5kID4+IDEpID09IChicmFja2V0ID4+IDEpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBpdGVyLmRvbmUgPyB7IHN0YXJ0OiBzdGFydFRva2VuLCBtYXRjaGVkOiBmYWxzZSB9IDogbnVsbDtcbn1cblxuZXhwb3J0IHsgYnJhY2tldE1hdGNoaW5nLCBtYXRjaEJyYWNrZXRzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/matchbrackets/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/panel/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/panel/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getPanel\": function() { return /* binding */ getPanel; },\n/* harmony export */   \"panels\": function() { return /* binding */ panels; },\n/* harmony export */   \"showPanel\": function() { return /* binding */ showPanel; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\nvar panelConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({\n  combine: function combine(configs) {\n    var topContainer, bottomContainer;\n\n    var _iterator = _createForOfIteratorHelper(configs),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var c = _step.value;\n        topContainer = topContainer || c.topContainer;\n        bottomContainer = bottomContainer || c.bottomContainer;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return {\n      topContainer: topContainer,\n      bottomContainer: bottomContainer\n    };\n  }\n});\n/**\nConfigures the panel-managing extension.\n*/\n\nfunction panels(config) {\n  return config ? [panelConfig.of(config)] : [];\n}\n/**\nGet the active panel created by the given constructor, if any.\nThis can be useful when you need access to your panels' DOM\nstructure.\n*/\n\n\nfunction getPanel(view, panel) {\n  var plugin = view.plugin(panelPlugin);\n  var index = plugin ? plugin.specs.indexOf(panel) : -1;\n  return index > -1 ? plugin.panels[index] : null;\n}\n\nvar panelPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    _classCallCheck(this, _class);\n\n    this.input = view.state.facet(showPanel);\n    this.specs = this.input.filter(function (s) {\n      return s;\n    });\n    this.panels = this.specs.map(function (spec) {\n      return spec(view);\n    });\n    var conf = view.state.facet(panelConfig);\n    this.top = new PanelGroup(view, true, conf.topContainer);\n    this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n    this.top.sync(this.panels.filter(function (p) {\n      return p.top;\n    }));\n    this.bottom.sync(this.panels.filter(function (p) {\n      return !p.top;\n    }));\n\n    var _iterator2 = _createForOfIteratorHelper(this.panels),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var p = _step2.value;\n        p.dom.classList.add(\"cm-panel\");\n        if (p.mount) p.mount();\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  _createClass(_class, [{\n    key: \"update\",\n    value: function update(_update) {\n      var conf = _update.state.facet(panelConfig);\n\n      if (this.top.container != conf.topContainer) {\n        this.top.sync([]);\n        this.top = new PanelGroup(_update.view, true, conf.topContainer);\n      }\n\n      if (this.bottom.container != conf.bottomContainer) {\n        this.bottom.sync([]);\n        this.bottom = new PanelGroup(_update.view, false, conf.bottomContainer);\n      }\n\n      this.top.syncClasses();\n      this.bottom.syncClasses();\n\n      var input = _update.state.facet(showPanel);\n\n      if (input != this.input) {\n        var specs = input.filter(function (x) {\n          return x;\n        });\n        var _panels = [],\n            top = [],\n            bottom = [],\n            mount = [];\n\n        var _iterator3 = _createForOfIteratorHelper(specs),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var spec = _step3.value;\n            var known = this.specs.indexOf(spec),\n                panel = void 0;\n\n            if (known < 0) {\n              panel = spec(_update.view);\n              mount.push(panel);\n            } else {\n              panel = this.panels[known];\n              if (panel.update) panel.update(_update);\n            }\n\n            _panels.push(panel);\n\n            (panel.top ? top : bottom).push(panel);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        this.specs = specs;\n        this.panels = _panels;\n        this.top.sync(top);\n        this.bottom.sync(bottom);\n\n        for (var _i = 0, _mount = mount; _i < _mount.length; _i++) {\n          var p = _mount[_i];\n          p.dom.classList.add(\"cm-panel\");\n          if (p.mount) p.mount();\n        }\n      } else {\n        var _iterator4 = _createForOfIteratorHelper(this.panels),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _p = _step4.value;\n            if (_p.update) _p.update(_update);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.top.sync([]);\n      this.bottom.sync([]);\n    }\n  }]);\n\n  return _class;\n}(), {\n  provide: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.PluginField.scrollMargins.from(function (value) {\n    return {\n      top: value.top.scrollMargin(),\n      bottom: value.bottom.scrollMargin()\n    };\n  })\n});\n\nvar PanelGroup = /*#__PURE__*/function () {\n  function PanelGroup(view, top, container) {\n    _classCallCheck(this, PanelGroup);\n\n    this.view = view;\n    this.top = top;\n    this.container = container;\n    this.dom = undefined;\n    this.classes = \"\";\n    this.panels = [];\n    this.syncClasses();\n  }\n\n  _createClass(PanelGroup, [{\n    key: \"sync\",\n    value: function sync(panels) {\n      this.panels = panels;\n      this.syncDOM();\n    }\n  }, {\n    key: \"syncDOM\",\n    value: function syncDOM() {\n      if (this.panels.length == 0) {\n        if (this.dom) {\n          this.dom.remove();\n          this.dom = undefined;\n        }\n\n        return;\n      }\n\n      if (!this.dom) {\n        this.dom = document.createElement(\"div\");\n        this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\n        this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n        var parent = this.container || this.view.dom;\n        parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n      }\n\n      var curDOM = this.dom.firstChild;\n\n      var _iterator5 = _createForOfIteratorHelper(this.panels),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var panel = _step5.value;\n\n          if (panel.dom.parentNode == this.dom) {\n            while (curDOM != panel.dom) {\n              curDOM = rm(curDOM);\n            }\n\n            curDOM = curDOM.nextSibling;\n          } else {\n            this.dom.insertBefore(panel.dom, curDOM);\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      while (curDOM) {\n        curDOM = rm(curDOM);\n      }\n    }\n  }, {\n    key: \"scrollMargin\",\n    value: function scrollMargin() {\n      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\n    }\n  }, {\n    key: \"syncClasses\",\n    value: function syncClasses() {\n      if (!this.container || this.classes == this.view.themeClasses) return;\n\n      var _iterator6 = _createForOfIteratorHelper(this.classes.split(\" \")),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var cls = _step6.value;\n          if (cls) this.container.classList.remove(cls);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      var _iterator7 = _createForOfIteratorHelper((this.classes = this.view.themeClasses).split(\" \")),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _cls = _step7.value;\n          if (_cls) this.container.classList.add(_cls);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }]);\n\n  return PanelGroup;\n}();\n\nfunction rm(node) {\n  var next = node.nextSibling;\n  node.remove();\n  return next;\n}\n\nvar baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n  \".cm-panels\": {\n    boxSizing: \"border-box\",\n    position: \"sticky\",\n    left: 0,\n    right: 0\n  },\n  \"&light .cm-panels\": {\n    backgroundColor: \"#f5f5f5\",\n    color: \"black\"\n  },\n  \"&light .cm-panels-top\": {\n    borderBottom: \"1px solid #ddd\"\n  },\n  \"&light .cm-panels-bottom\": {\n    borderTop: \"1px solid #ddd\"\n  },\n  \"&dark .cm-panels\": {\n    backgroundColor: \"#333338\",\n    color: \"white\"\n  }\n});\n/**\nOpening a panel is done by providing a constructor function for\nthe panel through this facet. (The panel is closed again when its\nconstructor is no longer provided.) Values of `null` are ignored.\n*/\n\nvar showPanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({\n  enables: [panelPlugin, baseTheme]\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvcGFuZWwvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU1BO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFSQTtBQUFBOztBQUFBO0FBU0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQWJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFjQTs7QUFmQTtBQUFBO0FBQUE7QUFpQkE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUZBO0FBQUE7O0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFDQTs7QUFDQTtBQUNBO0FBaEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBN0RBO0FBQUE7QUFBQTtBQStEQTtBQUNBO0FBQ0E7QUFqRUE7O0FBQUE7QUFBQTtBQW1FQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQTs7QUFHQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFmQTtBQUFBOztBQUFBO0FBZ0JBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQXpCQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQTBCQTtBQUNBO0FBREE7QUFFQTs7O0FBQ0E7QUFDQTtBQUlBOzs7QUFDQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFEQTtBQUhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQU1BO0FBQUE7QUFDQTtBQURBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVNBOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQWpCQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFEQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3BhbmVsL2Rpc3QvaW5kZXguanM/NzI2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWaWV3UGx1Z2luLCBQbHVnaW5GaWVsZCwgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgRmFjZXQgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5cbmNvbnN0IHBhbmVsQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCB0b3BDb250YWluZXIsIGJvdHRvbUNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjb25maWdzKSB7XG4gICAgICAgICAgICB0b3BDb250YWluZXIgPSB0b3BDb250YWluZXIgfHwgYy50b3BDb250YWluZXI7XG4gICAgICAgICAgICBib3R0b21Db250YWluZXIgPSBib3R0b21Db250YWluZXIgfHwgYy5ib3R0b21Db250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXIgfTtcbiAgICB9XG59KTtcbi8qKlxuQ29uZmlndXJlcyB0aGUgcGFuZWwtbWFuYWdpbmcgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIHBhbmVscyhjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnID8gW3BhbmVsQ29uZmlnLm9mKGNvbmZpZyldIDogW107XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHBhbmVsIGNyZWF0ZWQgYnkgdGhlIGdpdmVuIGNvbnN0cnVjdG9yLCBpZiBhbnkuXG5UaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCBhY2Nlc3MgdG8geW91ciBwYW5lbHMnIERPTVxuc3RydWN0dXJlLlxuKi9cbmZ1bmN0aW9uIGdldFBhbmVsKHZpZXcsIHBhbmVsKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHBhbmVsUGx1Z2luKTtcbiAgICBsZXQgaW5kZXggPSBwbHVnaW4gPyBwbHVnaW4uc3BlY3MuaW5kZXhPZihwYW5lbCkgOiAtMTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IHBsdWdpbi5wYW5lbHNbaW5kZXhdIDogbnVsbDtcbn1cbmNvbnN0IHBhbmVsUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB2aWV3LnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIHRoaXMuc3BlY3MgPSB0aGlzLmlucHV0LmZpbHRlcihzID0+IHMpO1xuICAgICAgICB0aGlzLnBhbmVscyA9IHRoaXMuc3BlY3MubWFwKHNwZWMgPT4gc3BlYyh2aWV3KSk7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChwYW5lbENvbmZpZyk7XG4gICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodmlldywgdHJ1ZSwgY29uZi50b3BDb250YWluZXIpO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMudG9wLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gcC50b3ApKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luYyh0aGlzLnBhbmVscy5maWx0ZXIocCA9PiAhcC50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgcC5kb20uY2xhc3NMaXN0LmFkZChcImNtLXBhbmVsXCIpO1xuICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICBpZiAodGhpcy50b3AuY29udGFpbmVyICE9IGNvbmYudG9wQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnRvcC5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3R0b20uY29udGFpbmVyICE9IGNvbmYuYm90dG9tQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3Auc3luY0NsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luY0NsYXNzZXMoKTtcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBsZXQgc3BlY3MgPSBpbnB1dC5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgICAgIGxldCBwYW5lbHMgPSBbXSwgdG9wID0gW10sIGJvdHRvbSA9IFtdLCBtb3VudCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBrbm93biA9IHRoaXMuc3BlY3MuaW5kZXhPZihzcGVjKSwgcGFuZWw7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHNwZWModXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBtb3VudC5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsID0gdGhpcy5wYW5lbHNba25vd25dO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFuZWwudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhbmVscy5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICAocGFuZWwudG9wID8gdG9wIDogYm90dG9tKS5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhib3R0b20pO1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBtb3VudCkge1xuICAgICAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgICAgICBpZiAocC5tb3VudClcbiAgICAgICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscylcbiAgICAgICAgICAgICAgICBpZiAocC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHAudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiAvKkBfX1BVUkVfXyovUGx1Z2luRmllbGQuc2Nyb2xsTWFyZ2lucy5mcm9tKHZhbHVlID0+ICh7IHRvcDogdmFsdWUudG9wLnNjcm9sbE1hcmdpbigpLCBib3R0b206IHZhbHVlLmJvdHRvbS5zY3JvbGxNYXJnaW4oKSB9KSlcbn0pO1xuY2xhc3MgUGFuZWxHcm91cCB7XG4gICAgY29uc3RydWN0b3IodmlldywgdG9wLCBjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gXCJcIjtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5zeW5jQ2xhc3NlcygpO1xuICAgIH1cbiAgICBzeW5jKHBhbmVscykge1xuICAgICAgICB0aGlzLnBhbmVscyA9IHBhbmVscztcbiAgICAgICAgdGhpcy5zeW5jRE9NKCk7XG4gICAgfVxuICAgIHN5bmNET00oKSB7XG4gICAgICAgIGlmICh0aGlzLnBhbmVscy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gdGhpcy50b3AgPyBcImNtLXBhbmVscyBjbS1wYW5lbHMtdG9wXCIgOiBcImNtLXBhbmVscyBjbS1wYW5lbHMtYm90dG9tXCI7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZVt0aGlzLnRvcCA/IFwidG9wXCIgOiBcImJvdHRvbVwiXSA9IFwiMFwiO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuY29udGFpbmVyIHx8IHRoaXMudmlldy5kb207XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLCB0aGlzLnRvcCA/IHBhcmVudC5maXJzdENoaWxkIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1ckRPTSA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZvciAobGV0IHBhbmVsIG9mIHRoaXMucGFuZWxzKSB7XG4gICAgICAgICAgICBpZiAocGFuZWwuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyRE9NICE9IHBhbmVsLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgY3VyRE9NID0gcm0oY3VyRE9NKTtcbiAgICAgICAgICAgICAgICBjdXJET00gPSBjdXJET00ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUocGFuZWwuZG9tLCBjdXJET00pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjdXJET00pXG4gICAgICAgICAgICBjdXJET00gPSBybShjdXJET00pO1xuICAgIH1cbiAgICBzY3JvbGxNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kb20gfHwgdGhpcy5jb250YWluZXIgPyAwXG4gICAgICAgICAgICA6IE1hdGgubWF4KDAsIHRoaXMudG9wID9cbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBNYXRoLm1heCgwLCB0aGlzLnZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkgOlxuICAgICAgICAgICAgICAgIE1hdGgubWluKGlubmVySGVpZ2h0LCB0aGlzLnZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSkgLSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApO1xuICAgIH1cbiAgICBzeW5jQ2xhc3NlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lciB8fCB0aGlzLmNsYXNzZXMgPT0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgY2xzIG9mIHRoaXMuY2xhc3Nlcy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICAgICAgZm9yIChsZXQgY2xzIG9mICh0aGlzLmNsYXNzZXMgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzKS5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBybShub2RlKSB7XG4gICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInN0aWNreVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCIsXG4gICAgICAgIGNvbG9yOiBcImJsYWNrXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHMtdG9wXCI6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHMtYm90dG9tXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICB9XG59KTtcbi8qKlxuT3BlbmluZyBhIHBhbmVsIGlzIGRvbmUgYnkgcHJvdmlkaW5nIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yXG50aGUgcGFuZWwgdGhyb3VnaCB0aGlzIGZhY2V0LiAoVGhlIHBhbmVsIGlzIGNsb3NlZCBhZ2FpbiB3aGVuIGl0c1xuY29uc3RydWN0b3IgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLikgVmFsdWVzIG9mIGBudWxsYCBhcmUgaWdub3JlZC5cbiovXG5jb25zdCBzaG93UGFuZWwgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBlbmFibGVzOiBbcGFuZWxQbHVnaW4sIGJhc2VUaGVtZV1cbn0pO1xuXG5leHBvcnQgeyBnZXRQYW5lbCwgcGFuZWxzLCBzaG93UGFuZWwgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/panel/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/rectangular-selection/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@codemirror/rectangular-selection/dist/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"rectangularSelection\": function() { return /* binding */ rectangularSelection; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\n\n\n // Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\n\nvar MaxOff = 2000;\n\nfunction rectangleFor(state, a, b) {\n  var startLine = Math.min(a.line, b.line),\n      endLine = Math.max(a.line, b.line);\n  var ranges = [];\n\n  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n    var startOff = Math.min(a.off, b.off),\n        endOff = Math.max(a.off, b.off);\n\n    for (var i = startLine; i <= endLine; i++) {\n      var line = state.doc.line(i);\n      if (line.length <= endOff) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(line.from + startOff, line.to + endOff));\n    }\n  } else {\n    var startCol = Math.min(a.col, b.col),\n        endCol = Math.max(a.col, b.col);\n\n    for (var _i = startLine; _i <= endLine; _i++) {\n      var _line = state.doc.line(_i);\n\n      var start = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.findColumn)(_line.text, startCol, state.tabSize, true);\n\n      if (start > -1) {\n        var end = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.findColumn)(_line.text, endCol, state.tabSize);\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(_line.from + start, _line.from + end));\n      }\n    }\n  }\n\n  return ranges;\n}\n\nfunction absoluteColumn(view, x) {\n  var ref = view.coordsAtPos(view.viewport.from);\n  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\n\nfunction getPos(view, event) {\n  var offset = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  }, false);\n  var line = view.state.doc.lineAt(offset),\n      off = offset - line.from;\n  var col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.countColumn)(line.text, view.state.tabSize, offset - line.from);\n  return {\n    line: line.number,\n    col: col,\n    off: off\n  };\n}\n\nfunction rectangleSelectionStyle(view, event) {\n  var start = getPos(view, event),\n      startSel = view.state.selection;\n  if (!start) return null;\n  return {\n    update: function update(_update) {\n      if (_update.docChanged) {\n        var newStart = _update.changes.mapPos(_update.startState.doc.line(start.line).from);\n\n        var newLine = _update.state.doc.lineAt(newStart);\n\n        start = {\n          line: newLine.number,\n          col: start.col,\n          off: Math.min(start.off, newLine.length)\n        };\n        startSel = startSel.map(_update.changes);\n      }\n    },\n    get: function get(event, _extend, multiple) {\n      var cur = getPos(view, event);\n      if (!cur) return startSel;\n      var ranges = rectangleFor(view.state, start, cur);\n      if (!ranges.length) return startSel;\n      if (multiple) return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.create(ranges.concat(startSel.ranges));else return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.create(ranges);\n    }\n  };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/\n\n\nfunction rectangularSelection(options) {\n  var filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || function (e) {\n    return e.altKey && e.button == 0;\n  };\n\n  return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.mouseSelectionStyle.of(function (view, event) {\n    return filter(event) ? rectangleSelectionStyle(view, event) : null;\n  });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvcmVjdGFuZ3VsYXItc2VsZWN0aW9uL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUdBOztBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFwQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9yZWN0YW5ndWxhci1zZWxlY3Rpb24vZGlzdC9pbmRleC5qcz9mMDMxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVkaXRvclNlbGVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IGZpbmRDb2x1bW4sIGNvdW50Q29sdW1uIH0gZnJvbSAnQGNvZGVtaXJyb3IvdGV4dCc7XG5cbi8vIERvbid0IGNvbXB1dGUgcHJlY2lzZSBjb2x1bW4gcG9zaXRpb25zIGZvciBsaW5lIG9mZnNldHMgYWJvdmUgdGhpc1xuLy8gKHNpbmNlIGl0IGNvdWxkIGdldCBleHBlbnNpdmUpLiBBc3N1bWUgb2Zmc2V0PT1jb2x1bW4gZm9yIHRoZW0uXG5jb25zdCBNYXhPZmYgPSAyMDAwO1xuZnVuY3Rpb24gcmVjdGFuZ2xlRm9yKHN0YXRlLCBhLCBiKSB7XG4gICAgbGV0IHN0YXJ0TGluZSA9IE1hdGgubWluKGEubGluZSwgYi5saW5lKSwgZW5kTGluZSA9IE1hdGgubWF4KGEubGluZSwgYi5saW5lKTtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgaWYgKGEub2ZmID4gTWF4T2ZmIHx8IGIub2ZmID4gTWF4T2ZmIHx8IGEuY29sIDwgMCB8fCBiLmNvbCA8IDApIHtcbiAgICAgICAgbGV0IHN0YXJ0T2ZmID0gTWF0aC5taW4oYS5vZmYsIGIub2ZmKSwgZW5kT2ZmID0gTWF0aC5tYXgoYS5vZmYsIGIub2ZmKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPD0gZW5kT2ZmKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydE9mZiwgbGluZS50byArIGVuZE9mZikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgc3RhcnRDb2wgPSBNYXRoLm1pbihhLmNvbCwgYi5jb2wpLCBlbmRDb2wgPSBNYXRoLm1heChhLmNvbCwgYi5jb2wpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZShpKTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGZpbmRDb2x1bW4obGluZS50ZXh0LCBzdGFydENvbCwgc3RhdGUudGFiU2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBmaW5kQ29sdW1uKGxpbmUudGV4dCwgZW5kQ29sLCBzdGF0ZS50YWJTaXplKTtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnQsIGxpbmUuZnJvbSArIGVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG5mdW5jdGlvbiBhYnNvbHV0ZUNvbHVtbih2aWV3LCB4KSB7XG4gICAgbGV0IHJlZiA9IHZpZXcuY29vcmRzQXRQb3Modmlldy52aWV3cG9ydC5mcm9tKTtcbiAgICByZXR1cm4gcmVmID8gTWF0aC5yb3VuZChNYXRoLmFicygocmVmLmxlZnQgLSB4KSAvIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKSkgOiAtMTtcbn1cbmZ1bmN0aW9uIGdldFBvcyh2aWV3LCBldmVudCkge1xuICAgIGxldCBvZmZzZXQgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQob2Zmc2V0KSwgb2ZmID0gb2Zmc2V0IC0gbGluZS5mcm9tO1xuICAgIGxldCBjb2wgPSBvZmYgPiBNYXhPZmYgPyAtMVxuICAgICAgICA6IG9mZiA9PSBsaW5lLmxlbmd0aCA/IGFic29sdXRlQ29sdW1uKHZpZXcsIGV2ZW50LmNsaWVudFgpXG4gICAgICAgICAgICA6IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgdmlldy5zdGF0ZS50YWJTaXplLCBvZmZzZXQgLSBsaW5lLmZyb20pO1xuICAgIHJldHVybiB7IGxpbmU6IGxpbmUubnVtYmVyLCBjb2wsIG9mZiB9O1xufVxuZnVuY3Rpb24gcmVjdGFuZ2xlU2VsZWN0aW9uU3R5bGUodmlldywgZXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSBnZXRQb3ModmlldywgZXZlbnQpLCBzdGFydFNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghc3RhcnQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXdTdGFydCA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh1cGRhdGUuc3RhcnRTdGF0ZS5kb2MubGluZShzdGFydC5saW5lKS5mcm9tKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3TGluZSA9IHVwZGF0ZS5zdGF0ZS5kb2MubGluZUF0KG5ld1N0YXJ0KTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHsgbGluZTogbmV3TGluZS5udW1iZXIsIGNvbDogc3RhcnQuY29sLCBvZmY6IE1hdGgubWluKHN0YXJ0Lm9mZiwgbmV3TGluZS5sZW5ndGgpIH07XG4gICAgICAgICAgICAgICAgc3RhcnRTZWwgPSBzdGFydFNlbC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoZXZlbnQsIF9leHRlbmQsIG11bHRpcGxlKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gZ2V0UG9zKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghY3VyKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbDtcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSByZWN0YW5nbGVGb3Iodmlldy5zdGF0ZSwgc3RhcnQsIGN1cik7XG4gICAgICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgaWYgKG11bHRpcGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5jb25jYXQoc3RhcnRTZWwucmFuZ2VzKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIHJlY3Rhbmd1bGFyIHNlbGVjdGlvbnMuIEJ5XG5kZWZhdWx0LCBpdCB3aWxsIHJlYWN0IHRvIGxlZnQgbW91c2UgZHJhZyB3aXRoIHRoZSBBbHQga2V5IGhlbGRcbmRvd24uIFdoZW4gc3VjaCBhIHNlbGVjdGlvbiBvY2N1cnMsIHRoZSB0ZXh0IHdpdGhpbiB0aGUgcmVjdGFuZ2xlXG50aGF0IHdhcyBkcmFnZ2VkIG92ZXIgd2lsbCBiZSBzZWxlY3RlZCwgYXMgb25lIHNlbGVjdGlvblxuW3JhbmdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlKSBwZXIgbGluZS5cbiovXG5mdW5jdGlvbiByZWN0YW5ndWxhclNlbGVjdGlvbihvcHRpb25zKSB7XG4gICAgbGV0IGZpbHRlciA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXZlbnRGaWx0ZXIpIHx8IChlID0+IGUuYWx0S2V5ICYmIGUuYnV0dG9uID09IDApO1xuICAgIHJldHVybiBFZGl0b3JWaWV3Lm1vdXNlU2VsZWN0aW9uU3R5bGUub2YoKHZpZXcsIGV2ZW50KSA9PiBmaWx0ZXIoZXZlbnQpID8gcmVjdGFuZ2xlU2VsZWN0aW9uU3R5bGUodmlldywgZXZlbnQpIDogbnVsbCk7XG59XG5cbmV4cG9ydCB7IHJlY3Rhbmd1bGFyU2VsZWN0aW9uIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/rectangular-selection/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/search/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/search/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RegExpCursor\": function() { return /* binding */ RegExpCursor; },\n/* harmony export */   \"SearchCursor\": function() { return /* binding */ SearchCursor; },\n/* harmony export */   \"SearchQuery\": function() { return /* binding */ SearchQuery; },\n/* harmony export */   \"closeSearchPanel\": function() { return /* binding */ closeSearchPanel; },\n/* harmony export */   \"findNext\": function() { return /* binding */ findNext; },\n/* harmony export */   \"findPrevious\": function() { return /* binding */ findPrevious; },\n/* harmony export */   \"getSearchQuery\": function() { return /* binding */ getSearchQuery; },\n/* harmony export */   \"gotoLine\": function() { return /* binding */ gotoLine; },\n/* harmony export */   \"highlightSelectionMatches\": function() { return /* binding */ highlightSelectionMatches; },\n/* harmony export */   \"openSearchPanel\": function() { return /* binding */ openSearchPanel; },\n/* harmony export */   \"replaceAll\": function() { return /* binding */ replaceAll; },\n/* harmony export */   \"replaceNext\": function() { return /* binding */ replaceNext; },\n/* harmony export */   \"searchConfig\": function() { return /* binding */ searchConfig; },\n/* harmony export */   \"searchKeymap\": function() { return /* binding */ searchKeymap; },\n/* harmony export */   \"selectMatches\": function() { return /* binding */ selectMatches; },\n/* harmony export */   \"selectNextOccurrence\": function() { return /* binding */ selectNextOccurrence; },\n/* harmony export */   \"selectSelectionMatches\": function() { return /* binding */ selectSelectionMatches; },\n/* harmony export */   \"setSearchQuery\": function() { return /* binding */ setSearchQuery; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_panel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/panel */ \"./node_modules/@codemirror/panel/dist/index.js\");\n/* harmony import */ var _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/rangeset */ \"./node_modules/@codemirror/rangeset/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"./node_modules/crelt/index.es.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\nvar basicNormalize = typeof String.prototype.normalize == \"function\" ? function (x) {\n  return x.normalize(\"NFKD\");\n} : function (x) {\n  return x;\n};\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\n\nvar SearchCursor = /*#__PURE__*/function () {\n  /**\n  Create a text cursor. The query is the search string, `from` to\n  `to` provides the region to search.\n  \n  When `normalize` is given, it will be called, on both the query\n  string and the content it is matched against, before comparing.\n  You can, for example, create a case-insensitive search by\n  passing `s => s.toLowerCase()`.\n  \n  Text is always normalized with\n  [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n  (when supported).\n  */\n  function SearchCursor(text, query) {\n    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : text.length;\n    var normalize = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, SearchCursor);\n\n    /**\n    The current match (only holds a meaningful value after\n    [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n    `done` is false).\n    */\n    this.value = {\n      from: 0,\n      to: 0\n    };\n    /**\n    Whether the end of the iterated region has been reached.\n    */\n\n    this.done = false;\n    this.matches = [];\n    this.buffer = \"\";\n    this.bufferPos = 0;\n    this.iter = text.iterRange(from, to);\n    this.bufferStart = from;\n    this.normalize = normalize ? function (x) {\n      return normalize(basicNormalize(x));\n    } : basicNormalize;\n    this.query = this.normalize(query);\n  }\n\n  _createClass(SearchCursor, [{\n    key: \"peek\",\n    value: function peek() {\n      if (this.bufferPos == this.buffer.length) {\n        this.bufferStart += this.buffer.length;\n        this.iter.next();\n        if (this.iter.done) return -1;\n        this.bufferPos = 0;\n        this.buffer = this.iter.value;\n      }\n\n      return (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      while (this.matches.length) {\n        this.matches.pop();\n      }\n\n      return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n\n  }, {\n    key: \"nextOverlapping\",\n    value: function nextOverlapping() {\n      for (;;) {\n        var next = this.peek();\n\n        if (next < 0) {\n          this.done = true;\n          return this;\n        }\n\n        var str = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next),\n            start = this.bufferStart + this.bufferPos;\n        this.bufferPos += (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n        var norm = this.normalize(str);\n\n        for (var i = 0, pos = start;; i++) {\n          var code = norm.charCodeAt(i);\n          var match = this.match(code, pos);\n\n          if (match) {\n            this.value = match;\n            return this;\n          }\n\n          if (i == norm.length - 1) break;\n          if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n        }\n      }\n    }\n  }, {\n    key: \"match\",\n    value: function match(code, pos) {\n      var match = null;\n\n      for (var i = 0; i < this.matches.length; i += 2) {\n        var index = this.matches[i],\n            keep = false;\n\n        if (this.query.charCodeAt(index) == code) {\n          if (index == this.query.length - 1) {\n            match = {\n              from: this.matches[i + 1],\n              to: pos + 1\n            };\n          } else {\n            this.matches[i]++;\n            keep = true;\n          }\n        }\n\n        if (!keep) {\n          this.matches.splice(i, 2);\n          i -= 2;\n        }\n      }\n\n      if (this.query.charCodeAt(0) == code) {\n        if (this.query.length == 1) match = {\n          from: pos,\n          to: pos + 1\n        };else this.matches.push(1, pos);\n      }\n\n      return match;\n    }\n  }]);\n\n  return SearchCursor;\n}();\n\nif (typeof Symbol != \"undefined\") SearchCursor.prototype[Symbol.iterator] = function () {\n  return this;\n};\nvar empty = {\n  from: -1,\n  to: -1,\n  match: /*@__PURE__*/ /.*/.exec(\"\")\n};\nvar baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\n\nvar RegExpCursor = /*#__PURE__*/function () {\n  /**\n  Create a cursor that will search the given range in the given\n  document. `query` should be the raw pattern (as you'd pass it to\n  `new RegExp`).\n  */\n  function RegExpCursor(text, query, options) {\n    var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : text.length;\n\n    _classCallCheck(this, RegExpCursor);\n\n    this.to = to;\n    this.curLine = \"\";\n    /**\n    Set to `true` when the cursor has reached the end of the search\n    range.\n    */\n\n    this.done = false;\n    /**\n    Will contain an object with the extent of the match and the\n    match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n    sucessfully finds a match.\n    */\n\n    this.value = empty;\n    if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.iter = text.iter();\n    var startLine = text.lineAt(from);\n    this.curLineStart = startLine.from;\n    this.matchPos = from;\n    this.getLine(this.curLineStart);\n  }\n\n  _createClass(RegExpCursor, [{\n    key: \"getLine\",\n    value: function getLine(skip) {\n      this.iter.next(skip);\n\n      if (this.iter.lineBreak) {\n        this.curLine = \"\";\n      } else {\n        this.curLine = this.iter.value;\n        if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n        this.iter.next();\n      }\n    }\n  }, {\n    key: \"nextLine\",\n    value: function nextLine() {\n      this.curLineStart = this.curLineStart + this.curLine.length + 1;\n      if (this.curLineStart > this.to) this.curLine = \"\";else this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      for (var off = this.matchPos - this.curLineStart;;) {\n        this.re.lastIndex = off;\n        var match = this.matchPos <= this.to && this.re.exec(this.curLine);\n\n        if (match) {\n          var from = this.curLineStart + match.index,\n              to = from + match[0].length;\n          this.matchPos = to + (from == to ? 1 : 0);\n          if (from == this.curLine.length) this.nextLine();\n\n          if (from < to || from > this.value.to) {\n            this.value = {\n              from: from,\n              to: to,\n              match: match\n            };\n            return this;\n          }\n\n          off = this.matchPos - this.curLineStart;\n        } else if (this.curLineStart + this.curLine.length < this.to) {\n          this.nextLine();\n          off = 0;\n        } else {\n          this.done = true;\n          return this;\n        }\n      }\n    }\n  }]);\n\n  return RegExpCursor;\n}();\n\nvar flattened = /*@__PURE__*/new WeakMap(); // Reusable (partially) flattened document strings\n\nvar FlattenedDoc = /*#__PURE__*/function () {\n  function FlattenedDoc(from, text) {\n    _classCallCheck(this, FlattenedDoc);\n\n    this.from = from;\n    this.text = text;\n  }\n\n  _createClass(FlattenedDoc, [{\n    key: \"to\",\n    get: function get() {\n      return this.from + this.text.length;\n    }\n  }], [{\n    key: \"get\",\n    value: function get(doc, from, to) {\n      var cached = flattened.get(doc);\n\n      if (!cached || cached.from >= to || cached.to <= from) {\n        var flat = new FlattenedDoc(from, doc.sliceString(from, to));\n        flattened.set(doc, flat);\n        return flat;\n      }\n\n      if (cached.from == from && cached.to == to) return cached;\n      var text = cached.text,\n          cachedFrom = cached.from;\n\n      if (cachedFrom > from) {\n        text = doc.sliceString(from, cachedFrom) + text;\n        cachedFrom = from;\n      }\n\n      if (cached.to < to) text += doc.sliceString(cached.to, to);\n      flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n      return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n  }]);\n\n  return FlattenedDoc;\n}();\n\nvar MultilineRegExpCursor = /*#__PURE__*/function () {\n  function MultilineRegExpCursor(text, query, options, from, to) {\n    _classCallCheck(this, MultilineRegExpCursor);\n\n    this.text = text;\n    this.to = to;\n    this.done = false;\n    this.value = empty;\n    this.matchPos = from;\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000\n    /* Base */\n    ));\n  }\n\n  _createClass(MultilineRegExpCursor, [{\n    key: \"chunkEnd\",\n    value: function chunkEnd(pos) {\n      return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      for (;;) {\n        var off = this.re.lastIndex = this.matchPos - this.flat.from;\n        var match = this.re.exec(this.flat.text); // Skip empty matches directly after the last match\n\n        if (match && !match[0] && match.index == off) {\n          this.re.lastIndex = off + 1;\n          match = this.re.exec(this.flat.text);\n        } // If a match goes almost to the end of a noncomplete chunk, try\n        // again, since it'll likely be able to match more\n\n\n        if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10) match = null;\n\n        if (match) {\n          var from = this.flat.from + match.index,\n              to = from + match[0].length;\n          this.value = {\n            from: from,\n            to: to,\n            match: match\n          };\n          this.matchPos = to + (from == to ? 1 : 0);\n          return this;\n        } else {\n          if (this.flat.to == this.to) {\n            this.done = true;\n            return this;\n          } // Grow the flattened doc\n\n\n          this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n      }\n    }\n  }]);\n\n  return MultilineRegExpCursor;\n}();\n\nif (typeof Symbol != \"undefined\") {\n  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n}\n\nfunction validRegExp(source) {\n  try {\n    new RegExp(source, baseFlags);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nfunction createLineDialog(view) {\n  var input = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n    \"class\": \"cm-textfield\",\n    name: \"line\"\n  });\n  var dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"form\", {\n    \"class\": \"cm-gotoLine\",\n    onkeydown: function onkeydown(event) {\n      if (event.keyCode == 27) {\n        // Escape\n        event.preventDefault();\n        view.dispatch({\n          effects: dialogEffect.of(false)\n        });\n        view.focus();\n      } else if (event.keyCode == 13) {\n        // Enter\n        event.preventDefault();\n        go();\n      }\n    },\n    onsubmit: function onsubmit(event) {\n      event.preventDefault();\n      go();\n    }\n  }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n    \"class\": \"cm-button\",\n    type: \"submit\"\n  }, view.state.phrase(\"go\")));\n\n  function go() {\n    var match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n    if (!match) return;\n    var state = view.state,\n        startLine = state.doc.lineAt(state.selection.main.head);\n\n    var _match = _slicedToArray(match, 5),\n        sign = _match[1],\n        ln = _match[2],\n        cl = _match[3],\n        percent = _match[4];\n\n    var col = cl ? +cl.slice(1) : 0;\n    var line = ln ? +ln : startLine.number;\n\n    if (ln && percent) {\n      var pc = line / 100;\n      if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n      line = Math.round(state.doc.lines * pc);\n    } else if (ln && sign) {\n      line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n    }\n\n    var docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n    view.dispatch({\n      effects: dialogEffect.of(false),\n      selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n      scrollIntoView: true\n    });\n    view.focus();\n  }\n\n  return {\n    dom: dom,\n    pos: -10\n  };\n}\n\nvar dialogEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nvar dialogField = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n  create: function create() {\n    return true;\n  },\n  update: function update(value, tr) {\n    var _iterator = _createForOfIteratorHelper(tr.effects),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var e = _step.value;\n        if (e.is(dialogEffect)) value = e.value;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return value;\n  },\n  provide: function provide(f) {\n    return _codemirror_panel__WEBPACK_IMPORTED_MODULE_3__.showPanel.from(f, function (val) {\n      return val ? createLineDialog : null;\n    });\n  }\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n\nThe dialog can be styled with the `panel.gotoLine` theme\nselector.\n*/\n\nvar gotoLine = function gotoLine(view) {\n  var panel = (0,_codemirror_panel__WEBPACK_IMPORTED_MODULE_3__.getPanel)(view, createLineDialog);\n\n  if (!panel) {\n    var effects = [dialogEffect.of(true)];\n    if (view.state.field(dialogField, false) == null) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n    view.dispatch({\n      effects: effects\n    });\n    panel = (0,_codemirror_panel__WEBPACK_IMPORTED_MODULE_3__.getPanel)(view, createLineDialog);\n  }\n\n  if (panel) panel.dom.querySelector(\"input\").focus();\n  return true;\n};\n\nvar baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n  \".cm-panel.cm-gotoLine\": {\n    padding: \"2px 6px 4px\",\n    \"& label\": {\n      fontSize: \"80%\"\n    }\n  }\n});\nvar defaultHighlightOptions = {\n  highlightWordAroundCursor: false,\n  minSelectionLength: 1,\n  maxMatches: 100\n};\nvar highlightConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: function combine(options) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(options, defaultHighlightOptions, {\n      highlightWordAroundCursor: function highlightWordAroundCursor(a, b) {\n        return a || b;\n      },\n      minSelectionLength: Math.min,\n      maxMatches: Math.min\n    });\n  }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\n\nfunction highlightSelectionMatches(options) {\n  var ext = [defaultTheme, matchHighlighter];\n  if (options) ext.push(highlightConfig.of(options));\n  return ext;\n}\n\nvar matchDeco = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n  \"class\": \"cm-selectionMatch\"\n});\nvar mainMatchDeco = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n  \"class\": \"cm-selectionMatch cm-selectionMatch-main\"\n});\nvar matchHighlighter = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    _classCallCheck(this, _class);\n\n    this.decorations = this.getDeco(view);\n  }\n\n  _createClass(_class, [{\n    key: \"update\",\n    value: function update(_update) {\n      if (_update.selectionSet || _update.docChanged || _update.viewportChanged) this.decorations = this.getDeco(_update.view);\n    }\n  }, {\n    key: \"getDeco\",\n    value: function getDeco(view) {\n      var conf = view.state.facet(highlightConfig);\n      var state = view.state,\n          sel = state.selection;\n      if (sel.ranges.length > 1) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n      var range = sel.main,\n          query,\n          check = null;\n\n      if (range.empty) {\n        if (!conf.highlightWordAroundCursor) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        var word = state.wordAt(range.head);\n        if (!word) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        check = state.charCategorizer(range.head);\n        query = state.sliceDoc(word.from, word.to);\n      } else {\n        var len = range.to - range.from;\n        if (len < conf.minSelectionLength || len > 200) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        query = state.sliceDoc(range.from, range.to).trim();\n        if (!query) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n      }\n\n      var deco = [];\n\n      var _iterator2 = _createForOfIteratorHelper(view.visibleRanges),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var part = _step2.value;\n          var cursor = new SearchCursor(state.doc, query, part.from, part.to);\n\n          while (!cursor.next().done) {\n            var _cursor$value = cursor.value,\n                from = _cursor$value.from,\n                to = _cursor$value.to;\n\n            if (!check || (from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.CharCategory.Word)) {\n              if (check && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n              if (deco.length > conf.maxMatches) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(deco);\n    }\n  }]);\n\n  return _class;\n}(), {\n  decorations: function decorations(v) {\n    return v.decorations;\n  }\n});\nvar defaultTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n  \".cm-selectionMatch\": {\n    backgroundColor: \"#99ff7780\"\n  },\n  \".cm-searchMatch .cm-selectionMatch\": {\n    backgroundColor: \"transparent\"\n  }\n}); // Select the words around the cursors.\n\nvar selectWord = function selectWord(_ref) {\n  var state = _ref.state,\n      dispatch = _ref.dispatch;\n  var selection = state.selection;\n  var newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(selection.ranges.map(function (range) {\n    return state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.head);\n  }), selection.mainIndex);\n  if (newSel.eq(selection)) return false;\n  dispatch(state.update({\n    selection: newSel\n  }));\n  return true;\n}; // Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\n\n\nfunction findNextOccurrence(state, query) {\n  var _state$selection = state.selection,\n      main = _state$selection.main,\n      ranges = _state$selection.ranges;\n  var word = state.wordAt(main.head),\n      fullWord = word && word.from == main.from && word.to == main.to;\n\n  var _loop = function _loop(_cycled, _cursor) {\n    _cursor.next();\n\n    if (_cursor.done) {\n      if (_cycled) {\n        cursor = _cursor;\n        {\n          cycled = _cycled;\n          return {\n            v: null\n          };\n        }\n      }\n\n      _cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n      _cycled = true;\n    } else {\n      if (_cycled && ranges.some(function (r) {\n        return r.from == _cursor.value.from;\n      })) {\n        cursor = _cursor;\n        {\n          cycled = _cycled;\n          return \"continue\";\n        }\n      }\n\n      if (fullWord) {\n        var _word = state.wordAt(_cursor.value.from);\n\n        if (!_word || _word.from != _cursor.value.from || _word.to != _cursor.value.to) {\n          cursor = _cursor;\n          {\n            cycled = _cycled;\n            return \"continue\";\n          }\n        }\n      }\n\n      cycled = _cycled;\n      cursor = _cursor;\n      return {\n        v: _cursor.value\n      };\n    }\n\n    cycled = _cycled;\n    cursor = _cursor;\n  };\n\n  for (var cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n    var _ret = _loop(cycled, cursor);\n\n    if (_ret === \"continue\") continue;\n    if (_typeof(_ret) === \"object\") return _ret.v;\n  }\n}\n/**\nSelect next occurrence of the current selection.\nExpand selection to the word when selection range is empty.\n*/\n\n\nvar selectNextOccurrence = function selectNextOccurrence(_ref2) {\n  var state = _ref2.state,\n      dispatch = _ref2.dispatch;\n  var ranges = state.selection.ranges;\n  if (ranges.some(function (sel) {\n    return sel.from === sel.to;\n  })) return selectWord({\n    state: state,\n    dispatch: dispatch\n  });\n  var searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n  if (state.selection.ranges.some(function (r) {\n    return state.sliceDoc(r.from, r.to) != searchedText;\n  })) return false;\n  var range = findNextOccurrence(state, searchedText);\n  if (!range) return false;\n  dispatch(state.update({\n    selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(range.from, range.to), false),\n    effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.scrollIntoView(range.to)\n  }));\n  return true;\n};\n\nvar searchConfigFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: function combine(configs) {\n    var _a;\n\n    return {\n      top: configs.reduce(function (val, conf) {\n        return val !== null && val !== void 0 ? val : conf.top;\n      }, undefined) || false,\n      caseSensitive: configs.reduce(function (val, conf) {\n        return val !== null && val !== void 0 ? val : conf.caseSensitive || conf.matchCase;\n      }, undefined) || false,\n      createPanel: ((_a = configs.find(function (c) {\n        return c.createPanel;\n      })) === null || _a === void 0 ? void 0 : _a.createPanel) || function (view) {\n        return new SearchPanel(view);\n      }\n    };\n  }\n});\n/**\nConfigure the behavior of the search extension.\n*/\n\nfunction searchConfig(config) {\n  return searchConfigFacet.of(config);\n}\n/**\nA search query. Part of the editor's search state.\n*/\n\n\nvar SearchQuery = /*#__PURE__*/function () {\n  /**\n  Create a query object.\n  */\n  function SearchQuery(config) {\n    _classCallCheck(this, SearchQuery);\n\n    this.search = config.search;\n    this.caseSensitive = !!config.caseSensitive;\n    this.regexp = !!config.regexp;\n    this.replace = config.replace || \"\";\n    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n  }\n  /**\n  Compare this query to another query.\n  */\n\n\n  _createClass(SearchQuery, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"create\",\n    value: function create() {\n      return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n  }]);\n\n  return SearchQuery;\n}();\n\nvar QueryType = function QueryType(spec) {\n  _classCallCheck(this, QueryType);\n\n  this.spec = spec;\n};\n\nvar StringQuery = /*#__PURE__*/function (_QueryType) {\n  _inherits(StringQuery, _QueryType);\n\n  var _super = _createSuper(StringQuery);\n\n  function StringQuery(spec) {\n    var _this;\n\n    _classCallCheck(this, StringQuery);\n\n    _this = _super.call(this, spec);\n    _this.unquoted = spec.search.replace(/\\\\([nrt\\\\])/g, function (_, ch) {\n      return ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\";\n    });\n    return _this;\n  }\n\n  _createClass(StringQuery, [{\n    key: \"cursor\",\n    value: function cursor(doc) {\n      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : doc.length;\n      return new SearchCursor(doc, this.unquoted, from, to, this.spec.caseSensitive ? undefined : function (x) {\n        return x.toLowerCase();\n      });\n    }\n  }, {\n    key: \"nextMatch\",\n    value: function nextMatch(doc, curFrom, curTo) {\n      var cursor = this.cursor(doc, curTo).nextOverlapping();\n      if (cursor.done) cursor = this.cursor(doc, 0, curFrom).nextOverlapping();\n      return cursor.done ? null : cursor.value;\n    } // Searching in reverse is, rather than implementing inverted search\n    // cursor, done by scanning chunk after chunk forward.\n\n  }, {\n    key: \"prevMatchInRange\",\n    value: function prevMatchInRange(doc, from, to) {\n      for (var pos = to;;) {\n        var start = Math.max(from, pos - 10000\n        /* ChunkSize */\n        - this.unquoted.length);\n\n        var _cursor2 = this.cursor(doc, start, pos),\n            range = null;\n\n        while (!_cursor2.nextOverlapping().done) {\n          range = _cursor2.value;\n        }\n\n        if (range) return range;\n        if (start == from) return null;\n        pos -= 10000\n        /* ChunkSize */\n        ;\n      }\n    }\n  }, {\n    key: \"prevMatch\",\n    value: function prevMatch(doc, curFrom, curTo) {\n      return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);\n    }\n  }, {\n    key: \"getReplacement\",\n    value: function getReplacement(_result) {\n      return this.spec.replace;\n    }\n  }, {\n    key: \"matchAll\",\n    value: function matchAll(doc, limit) {\n      var cursor = this.cursor(doc),\n          ranges = [];\n\n      while (!cursor.next().done) {\n        if (ranges.length >= limit) return null;\n        ranges.push(cursor.value);\n      }\n\n      return ranges;\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(doc, from, to, add) {\n      var cursor = this.cursor(doc, Math.max(0, from - this.unquoted.length), Math.min(to + this.unquoted.length, doc.length));\n\n      while (!cursor.next().done) {\n        add(cursor.value.from, cursor.value.to);\n      }\n    }\n  }]);\n\n  return StringQuery;\n}(QueryType);\n\nvar RegExpQuery = /*#__PURE__*/function (_QueryType2) {\n  _inherits(RegExpQuery, _QueryType2);\n\n  var _super2 = _createSuper(RegExpQuery);\n\n  function RegExpQuery() {\n    _classCallCheck(this, RegExpQuery);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(RegExpQuery, [{\n    key: \"cursor\",\n    value: function cursor(doc) {\n      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : doc.length;\n      return new RegExpCursor(doc, this.spec.search, this.spec.caseSensitive ? undefined : {\n        ignoreCase: true\n      }, from, to);\n    }\n  }, {\n    key: \"nextMatch\",\n    value: function nextMatch(doc, curFrom, curTo) {\n      var cursor = this.cursor(doc, curTo).next();\n      if (cursor.done) cursor = this.cursor(doc, 0, curFrom).next();\n      return cursor.done ? null : cursor.value;\n    }\n  }, {\n    key: \"prevMatchInRange\",\n    value: function prevMatchInRange(doc, from, to) {\n      for (var size = 1;; size++) {\n        var start = Math.max(from, to - size * 10000\n        /* ChunkSize */\n        );\n\n        var _cursor3 = this.cursor(doc, start, to),\n            range = null;\n\n        while (!_cursor3.next().done) {\n          range = _cursor3.value;\n        }\n\n        if (range && (start == from || range.from > start + 10)) return range;\n        if (start == from) return null;\n      }\n    }\n  }, {\n    key: \"prevMatch\",\n    value: function prevMatch(doc, curFrom, curTo) {\n      return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);\n    }\n  }, {\n    key: \"getReplacement\",\n    value: function getReplacement(result) {\n      return this.spec.replace.replace(/\\$([$&\\d+])/g, function (m, i) {\n        return i == \"$\" ? \"$\" : i == \"&\" ? result.match[0] : i != \"0\" && +i < result.match.length ? result.match[i] : m;\n      });\n    }\n  }, {\n    key: \"matchAll\",\n    value: function matchAll(doc, limit) {\n      var cursor = this.cursor(doc),\n          ranges = [];\n\n      while (!cursor.next().done) {\n        if (ranges.length >= limit) return null;\n        ranges.push(cursor.value);\n      }\n\n      return ranges;\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(doc, from, to, add) {\n      var cursor = this.cursor(doc, Math.max(0, from - 250\n      /* HighlightMargin */\n      ), Math.min(to + 250\n      /* HighlightMargin */\n      , doc.length));\n\n      while (!cursor.next().done) {\n        add(cursor.value.from, cursor.value.to);\n      }\n    }\n  }]);\n\n  return RegExpQuery;\n}(QueryType);\n/**\nA state effect that updates the current search query.\n*/\n\n\nvar setSearchQuery = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nvar togglePanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nvar searchState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n  create: function create(state) {\n    return new SearchState(defaultQuery(state).create(), createSearchPanel);\n  },\n  update: function update(value, tr) {\n    var _iterator3 = _createForOfIteratorHelper(tr.effects),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var effect = _step3.value;\n        if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return value;\n  },\n  provide: function provide(f) {\n    return _codemirror_panel__WEBPACK_IMPORTED_MODULE_3__.showPanel.from(f, function (val) {\n      return val.panel;\n    });\n  }\n});\n/**\nGet the current search query from an editor state.\n*/\n\nfunction getSearchQuery(state) {\n  var curState = state.field(searchState, false);\n  return curState ? curState.query.spec : defaultQuery(state);\n}\n\nvar SearchState = function SearchState(query, panel) {\n  _classCallCheck(this, SearchState);\n\n  this.query = query;\n  this.panel = panel;\n};\n\nvar matchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n  \"class\": \"cm-searchMatch\"\n}),\n    selectedMatchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n  \"class\": \"cm-searchMatch cm-searchMatch-selected\"\n});\nvar searchHighlighter = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class2(view) {\n    _classCallCheck(this, _class2);\n\n    this.view = view;\n    this.decorations = this.highlight(view.state.field(searchState));\n  }\n\n  _createClass(_class2, [{\n    key: \"update\",\n    value: function update(_update2) {\n      var state = _update2.state.field(searchState);\n\n      if (state != _update2.startState.field(searchState) || _update2.docChanged || _update2.selectionSet) this.decorations = this.highlight(state);\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(_ref3) {\n      var query = _ref3.query,\n          panel = _ref3.panel;\n      if (!panel || !query.spec.valid) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n      var view = this.view;\n      var builder = new _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_5__.RangeSetBuilder();\n\n      for (var i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n        var _ranges$i = ranges[i],\n            from = _ranges$i.from,\n            to = _ranges$i.to;\n\n        while (i < l - 1 && to > ranges[i + 1].from - 2 * 250\n        /* HighlightMargin */\n        ) {\n          to = ranges[++i].to;\n        }\n\n        query.highlight(view.state.doc, from, to, function (from, to) {\n          var selected = view.state.selection.ranges.some(function (r) {\n            return r.from == from && r.to == to;\n          });\n          builder.add(from, to, selected ? selectedMatchMark : matchMark);\n        });\n      }\n\n      return builder.finish();\n    }\n  }]);\n\n  return _class2;\n}(), {\n  decorations: function decorations(v) {\n    return v.decorations;\n  }\n});\n\nfunction searchCommand(f) {\n  return function (view) {\n    var state = view.state.field(searchState, false);\n    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n  };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\n\n\nvar findNext = /*@__PURE__*/searchCommand(function (view, _ref4) {\n  var query = _ref4.query;\n  var _view$state$selection = view.state.selection.main,\n      from = _view$state$selection.from,\n      to = _view$state$selection.to;\n  var next = query.nextMatch(view.state.doc, from, to);\n  if (!next || next.from == from && next.to == to) return false;\n  view.dispatch({\n    selection: {\n      anchor: next.from,\n      head: next.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, next),\n    userEvent: \"select.search\"\n  });\n  return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\n\nvar findPrevious = /*@__PURE__*/searchCommand(function (view, _ref5) {\n  var query = _ref5.query;\n  var state = view.state,\n      _state$selection$main = state.selection.main,\n      from = _state$selection$main.from,\n      to = _state$selection$main.to;\n  var range = query.prevMatch(state.doc, from, to);\n  if (!range) return false;\n  view.dispatch({\n    selection: {\n      anchor: range.from,\n      head: range.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, range),\n    userEvent: \"select.search\"\n  });\n  return true;\n});\n/**\nSelect all instances of the search query.\n*/\n\nvar selectMatches = /*@__PURE__*/searchCommand(function (view, _ref6) {\n  var query = _ref6.query;\n  var ranges = query.matchAll(view.state.doc, 1000);\n  if (!ranges || !ranges.length) return false;\n  view.dispatch({\n    selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges.map(function (r) {\n      return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(r.from, r.to);\n    })),\n    userEvent: \"select.search.matches\"\n  });\n  return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\n\nvar selectSelectionMatches = function selectSelectionMatches(_ref7) {\n  var state = _ref7.state,\n      dispatch = _ref7.dispatch;\n  var sel = state.selection;\n  if (sel.ranges.length > 1 || sel.main.empty) return false;\n  var _sel$main = sel.main,\n      from = _sel$main.from,\n      to = _sel$main.to;\n  var ranges = [],\n      main = 0;\n\n  for (var cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n    if (ranges.length > 1000) return false;\n    if (cur.value.from == from) main = ranges.length;\n    ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(cur.value.from, cur.value.to));\n  }\n\n  dispatch(state.update({\n    selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges, main),\n    userEvent: \"select.search.matches\"\n  }));\n  return true;\n};\n/**\nReplace the current match of the search query.\n*/\n\n\nvar replaceNext = /*@__PURE__*/searchCommand(function (view, _ref8) {\n  var query = _ref8.query;\n  var state = view.state,\n      _state$selection$main2 = state.selection.main,\n      from = _state$selection$main2.from,\n      to = _state$selection$main2.to;\n  if (state.readOnly) return false;\n  var next = query.nextMatch(state.doc, from, from);\n  if (!next) return false;\n  var changes = [],\n      selection,\n      replacement;\n\n  if (next.from == from && next.to == to) {\n    replacement = state.toText(query.getReplacement(next));\n    changes.push({\n      from: next.from,\n      to: next.to,\n      insert: replacement\n    });\n    next = query.nextMatch(state.doc, next.from, next.to);\n  }\n\n  if (next) {\n    var off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n    selection = {\n      anchor: next.from - off,\n      head: next.to - off\n    };\n  }\n\n  view.dispatch({\n    changes: changes,\n    selection: selection,\n    scrollIntoView: !!selection,\n    effects: next ? announceMatch(view, next) : undefined,\n    userEvent: \"input.replace\"\n  });\n  return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\n\nvar replaceAll = /*@__PURE__*/searchCommand(function (view, _ref9) {\n  var query = _ref9.query;\n  if (view.state.readOnly) return false;\n  var changes = query.matchAll(view.state.doc, 1e9).map(function (match) {\n    var from = match.from,\n        to = match.to;\n    return {\n      from: from,\n      to: to,\n      insert: query.getReplacement(match)\n    };\n  });\n  if (!changes.length) return false;\n  view.dispatch({\n    changes: changes,\n    userEvent: \"input.replace.all\"\n  });\n  return true;\n});\n\nfunction createSearchPanel(view) {\n  return view.state.facet(searchConfigFacet).createPanel(view);\n}\n\nfunction defaultQuery(state, fallback) {\n  var _a;\n\n  var sel = state.selection.main;\n  var selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n  var caseSensitive = (_a = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _a !== void 0 ? _a : state.facet(searchConfigFacet).caseSensitive;\n  return fallback && !selText ? fallback : new SearchQuery({\n    search: selText.replace(/\\n/g, \"\\\\n\"),\n    caseSensitive: caseSensitive\n  });\n}\n/**\nMake sure the search panel is open and focused.\n*/\n\n\nvar openSearchPanel = function openSearchPanel(view) {\n  var state = view.state.field(searchState, false);\n\n  if (state && state.panel) {\n    var panel = (0,_codemirror_panel__WEBPACK_IMPORTED_MODULE_3__.getPanel)(view, createSearchPanel);\n    if (!panel) return false;\n    var searchInput = panel.dom.querySelector(\"[name=search]\");\n\n    if (searchInput != view.root.activeElement) {\n      var query = defaultQuery(view.state, state.query.spec);\n      if (query.valid) view.dispatch({\n        effects: setSearchQuery.of(query)\n      });\n      searchInput.focus();\n      searchInput.select();\n    }\n  } else {\n    view.dispatch({\n      effects: [togglePanel.of(true), state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.appendConfig.of(searchExtensions)]\n    });\n  }\n\n  return true;\n};\n/**\nClose the search panel.\n*/\n\n\nvar closeSearchPanel = function closeSearchPanel(view) {\n  var state = view.state.field(searchState, false);\n  if (!state || !state.panel) return false;\n  var panel = (0,_codemirror_panel__WEBPACK_IMPORTED_MODULE_3__.getPanel)(view, createSearchPanel);\n  if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n  view.dispatch({\n    effects: togglePanel.of(false)\n  });\n  return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\n\n\nvar searchKeymap = [{\n  key: \"Mod-f\",\n  run: openSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"F3\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\",\n  preventDefault: true\n}, {\n  key: \"Mod-g\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\",\n  preventDefault: true\n}, {\n  key: \"Escape\",\n  run: closeSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Mod-Shift-l\",\n  run: selectSelectionMatches\n}, {\n  key: \"Alt-g\",\n  run: gotoLine\n}, {\n  key: \"Mod-d\",\n  run: selectNextOccurrence,\n  preventDefault: true\n}];\n\nvar SearchPanel = /*#__PURE__*/function () {\n  function SearchPanel(view) {\n    var _this2 = this;\n\n    _classCallCheck(this, SearchPanel);\n\n    this.view = view;\n    var query = this.query = view.state.field(searchState).query.spec;\n    this.commit = this.commit.bind(this);\n    this.searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n      value: query.search,\n      placeholder: phrase(view, \"Find\"),\n      \"aria-label\": phrase(view, \"Find\"),\n      \"class\": \"cm-textfield\",\n      name: \"search\",\n      onchange: this.commit,\n      onkeyup: this.commit\n    });\n    this.replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n      value: query.replace,\n      placeholder: phrase(view, \"Replace\"),\n      \"aria-label\": phrase(view, \"Replace\"),\n      \"class\": \"cm-textfield\",\n      name: \"replace\",\n      onchange: this.commit,\n      onkeyup: this.commit\n    });\n    this.caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n      type: \"checkbox\",\n      name: \"case\",\n      checked: query.caseSensitive,\n      onchange: this.commit\n    });\n    this.reField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n      type: \"checkbox\",\n      name: \"re\",\n      checked: query.regexp,\n      onchange: this.commit\n    });\n\n    function button(name, onclick, content) {\n      return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n        \"class\": \"cm-button\",\n        name: name,\n        onclick: onclick,\n        type: \"button\"\n      }, content);\n    }\n\n    this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n      onkeydown: function onkeydown(e) {\n        return _this2.keydown(e);\n      },\n      \"class\": \"cm-search\"\n    }, [this.searchField, button(\"next\", function () {\n      return findNext(view);\n    }, [phrase(view, \"next\")]), button(\"prev\", function () {\n      return findPrevious(view);\n    }, [phrase(view, \"previous\")]), button(\"select\", function () {\n      return selectMatches(view);\n    }, [phrase(view, \"all\")]), (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [this.caseField, phrase(view, \"match case\")]), (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [this.reField, phrase(view, \"regexp\")])].concat(_toConsumableArray(view.state.readOnly ? [] : [(0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"br\"), this.replaceField, button(\"replace\", function () {\n      return replaceNext(view);\n    }, [phrase(view, \"replace\")]), button(\"replaceAll\", function () {\n      return replaceAll(view);\n    }, [phrase(view, \"replace all\")]), (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n      name: \"close\",\n      onclick: function onclick() {\n        return closeSearchPanel(view);\n      },\n      \"aria-label\": phrase(view, \"close\"),\n      type: \"button\"\n    }, [\"Ã—\"])])));\n  }\n\n  _createClass(SearchPanel, [{\n    key: \"commit\",\n    value: function commit() {\n      var query = new SearchQuery({\n        search: this.searchField.value,\n        caseSensitive: this.caseField.checked,\n        regexp: this.reField.checked,\n        replace: this.replaceField.value\n      });\n\n      if (!query.eq(this.query)) {\n        this.query = query;\n        this.view.dispatch({\n          effects: setSearchQuery.of(query)\n        });\n      }\n    }\n  }, {\n    key: \"keydown\",\n    value: function keydown(e) {\n      if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.runScopeHandlers)(this.view, e, \"search-panel\")) {\n        e.preventDefault();\n      } else if (e.keyCode == 13 && e.target == this.searchField) {\n        e.preventDefault();\n        (e.shiftKey ? findPrevious : findNext)(this.view);\n      } else if (e.keyCode == 13 && e.target == this.replaceField) {\n        e.preventDefault();\n        replaceNext(this.view);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update3) {\n      var _iterator4 = _createForOfIteratorHelper(_update3.transactions),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var tr = _step4.value;\n\n          var _iterator5 = _createForOfIteratorHelper(tr.effects),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var effect = _step5.value;\n              if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"setQuery\",\n    value: function setQuery(query) {\n      this.query = query;\n      this.searchField.value = query.search;\n      this.replaceField.value = query.replace;\n      this.caseField.checked = query.caseSensitive;\n      this.reField.checked = query.regexp;\n    }\n  }, {\n    key: \"mount\",\n    value: function mount() {\n      this.searchField.select();\n    }\n  }, {\n    key: \"pos\",\n    get: function get() {\n      return 80;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.view.state.facet(searchConfigFacet).top;\n    }\n  }]);\n\n  return SearchPanel;\n}();\n\nfunction phrase(view, phrase) {\n  return view.state.phrase(phrase);\n}\n\nvar AnnounceMargin = 30;\nvar Break = /[\\s\\.,:;?!]/;\n\nfunction announceMatch(view, _ref10) {\n  var from = _ref10.from,\n      to = _ref10.to;\n  var lineStart = view.state.doc.lineAt(from).from,\n      lineEnd = view.state.doc.lineAt(to).to;\n  var start = Math.max(lineStart, from - AnnounceMargin),\n      end = Math.min(lineEnd, to + AnnounceMargin);\n  var text = view.state.sliceDoc(start, end);\n\n  if (start != lineStart) {\n    for (var i = 0; i < AnnounceMargin; i++) {\n      if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n        text = text.slice(i);\n        break;\n      }\n    }\n  }\n\n  if (end != lineEnd) {\n    for (var _i2 = text.length - 1; _i2 > text.length - AnnounceMargin; _i2--) {\n      if (!Break.test(text[_i2 - 1]) && Break.test(text[_i2])) {\n        text = text.slice(0, _i2);\n        break;\n      }\n    }\n  }\n\n  return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(\"\".concat(view.state.phrase(\"current match\"), \". \").concat(text, \" \").concat(view.state.phrase(\"on line\"), \" \").concat(view.state.doc.lineAt(from).number));\n}\n\nvar baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n  \".cm-panel.cm-search\": {\n    padding: \"2px 6px 4px\",\n    position: \"relative\",\n    \"& [name=close]\": {\n      position: \"absolute\",\n      top: \"0\",\n      right: \"4px\",\n      backgroundColor: \"inherit\",\n      border: \"none\",\n      font: \"inherit\",\n      padding: 0,\n      margin: 0\n    },\n    \"& input, & button, & label\": {\n      margin: \".2em .6em .2em 0\"\n    },\n    \"& input[type=checkbox]\": {\n      marginRight: \".2em\"\n    },\n    \"& label\": {\n      fontSize: \"80%\",\n      whiteSpace: \"pre\"\n    }\n  },\n  \"&light .cm-searchMatch\": {\n    backgroundColor: \"#ffff0054\"\n  },\n  \"&dark .cm-searchMatch\": {\n    backgroundColor: \"#00ffff8a\"\n  },\n  \"&light .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff6a0054\"\n  },\n  \"&dark .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff00ff8a\"\n  }\n});\nvar searchExtensions = [searchState, /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.lowest(searchHighlighter), baseTheme];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc2VhcmNoL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7O0FBQ0E7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQTs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQWlCQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBOztBQUhBO0FBQUE7QUFBQTtBQUtBO0FBRUE7QUFQQTtBQUFBO0FBQUE7QUFTQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBQ0E7O0FBdkJBO0FBQUE7O0FBQUE7QUF3QkE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQXRDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQXVDQTtBQUNBO0FBaERBOztBQUFBO0FBQUE7QUFrREE7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUZBOztBQUtBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7QUFGQTtBQUlBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTs7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBRUE7O0FBUEE7QUFBQTtBQVFBO0FBQUE7QUFBQTtBQUNBOztBQXBCQTtBQUFBO0FBQUE7O0FBR0E7QUFBQTs7QUFBQTtBQUFBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUhBO0FBS0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBR0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTtBQUVBOzs7O0FBL0NBOztBQWlEQTs7Ozs7Ozs7Ozs7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBRUE7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7OztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQURBO0FBRUE7Ozs7QUE3Q0E7QUErQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFiQTtBQWVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUpBO0FBQUE7QUFBQTtBQU1BOztBQUNBO0FBRUE7QUFUQTtBQUFBO0FBQUE7QUFVQTtBQUFBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQXpCQTs7QUFBQTtBQUFBO0FBMkJBO0FBQUE7QUFBQTtBQURBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQU1BO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSkE7QUFRQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7Ozs7OztBQUVBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUtBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBbkJBO0FBd0JBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQTVCQTtBQThCQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3NlYXJjaC9kaXN0L2luZGV4LmpzPzlhZmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWRpdG9yVmlldywgRGVjb3JhdGlvbiwgVmlld1BsdWdpbiwgcnVuU2NvcGVIYW5kbGVycyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEVkaXRvclNlbGVjdGlvbiwgRmFjZXQsIGNvbWJpbmVDb25maWcsIENoYXJDYXRlZ29yeSwgUHJlYyB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IHNob3dQYW5lbCwgZ2V0UGFuZWwgfSBmcm9tICdAY29kZW1pcnJvci9wYW5lbCc7XG5pbXBvcnQgeyBSYW5nZVNldEJ1aWxkZXIgfSBmcm9tICdAY29kZW1pcnJvci9yYW5nZXNldCc7XG5pbXBvcnQgZWx0IGZyb20gJ2NyZWx0JztcbmltcG9ydCB7IGNvZGVQb2ludEF0LCBmcm9tQ29kZVBvaW50LCBjb2RlUG9pbnRTaXplIH0gZnJvbSAnQGNvZGVtaXJyb3IvdGV4dCc7XG5cbmNvbnN0IGJhc2ljTm9ybWFsaXplID0gdHlwZW9mIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplID09IFwiZnVuY3Rpb25cIlxuICAgID8geCA9PiB4Lm5vcm1hbGl6ZShcIk5GS0RcIikgOiB4ID0+IHg7XG4vKipcbkEgc2VhcmNoIGN1cnNvciBwcm92aWRlcyBhbiBpdGVyYXRvciBvdmVyIHRleHQgbWF0Y2hlcyBpbiBhXG5kb2N1bWVudC5cbiovXG5jbGFzcyBTZWFyY2hDdXJzb3Ige1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRleHQgY3Vyc29yLiBUaGUgcXVlcnkgaXMgdGhlIHNlYXJjaCBzdHJpbmcsIGBmcm9tYCB0b1xuICAgIGB0b2AgcHJvdmlkZXMgdGhlIHJlZ2lvbiB0byBzZWFyY2guXG4gICAgXG4gICAgV2hlbiBgbm9ybWFsaXplYCBpcyBnaXZlbiwgaXQgd2lsbCBiZSBjYWxsZWQsIG9uIGJvdGggdGhlIHF1ZXJ5XG4gICAgc3RyaW5nIGFuZCB0aGUgY29udGVudCBpdCBpcyBtYXRjaGVkIGFnYWluc3QsIGJlZm9yZSBjb21wYXJpbmcuXG4gICAgWW91IGNhbiwgZm9yIGV4YW1wbGUsIGNyZWF0ZSBhIGNhc2UtaW5zZW5zaXRpdmUgc2VhcmNoIGJ5XG4gICAgcGFzc2luZyBgcyA9PiBzLnRvTG93ZXJDYXNlKClgLlxuICAgIFxuICAgIFRleHQgaXMgYWx3YXlzIG5vcm1hbGl6ZWQgd2l0aFxuICAgIFtgLm5vcm1hbGl6ZShcIk5GS0RcIilgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbm9ybWFsaXplKVxuICAgICh3aGVuIHN1cHBvcnRlZCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgZnJvbSA9IDAsIHRvID0gdGV4dC5sZW5ndGgsIG5vcm1hbGl6ZSkge1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGN1cnJlbnQgbWF0Y2ggKG9ubHkgaG9sZHMgYSBtZWFuaW5nZnVsIHZhbHVlIGFmdGVyXG4gICAgICAgIFtgbmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci5uZXh0KSBoYXMgYmVlbiBjYWxsZWQgYW5kIHdoZW5cbiAgICAgICAgYGRvbmVgIGlzIGZhbHNlKS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbTogMCwgdG86IDAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXRoZXIgdGhlIGVuZCBvZiB0aGUgaXRlcmF0ZWQgcmVnaW9uIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBbXTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgICAgICB0aGlzLmJ1ZmZlclBvcyA9IDA7XG4gICAgICAgIHRoaXMuaXRlciA9IHRleHQuaXRlclJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgdGhpcy5idWZmZXJTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMubm9ybWFsaXplID0gbm9ybWFsaXplID8geCA9PiBub3JtYWxpemUoYmFzaWNOb3JtYWxpemUoeCkpIDogYmFzaWNOb3JtYWxpemU7XG4gICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLm5vcm1hbGl6ZShxdWVyeSk7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlclBvcyA9PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyU3RhcnQgKz0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclBvcyA9IDA7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuaXRlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZVBvaW50QXQodGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyUG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgdGhlIG5leHQgbWF0Y2guIFVwZGF0ZXMgdGhlIGl0ZXJhdG9yJ3NcbiAgICBbYHZhbHVlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLnZhbHVlKSBhbmRcbiAgICBbYGRvbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IuZG9uZSkgcHJvcGVydGllcy4gU2hvdWxkIGJlIGNhbGxlZFxuICAgIGF0IGxlYXN0IG9uY2UgYmVmb3JlIHVzaW5nIHRoZSBjdXJzb3IuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICB3aGlsZSAodGhpcy5tYXRjaGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBgbmV4dGAgbWV0aG9kIHdpbGwgaWdub3JlIG1hdGNoZXMgdGhhdCBwYXJ0aWFsbHkgb3ZlcmxhcCBhXG4gICAgcHJldmlvdXMgbWF0Y2guIFRoaXMgbWV0aG9kIGJlaGF2ZXMgbGlrZSBgbmV4dGAsIGJ1dCBpbmNsdWRlc1xuICAgIHN1Y2ggbWF0Y2hlcy5cbiAgICAqL1xuICAgIG5leHRPdmVybGFwcGluZygpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RyID0gZnJvbUNvZGVQb2ludChuZXh0KSwgc3RhcnQgPSB0aGlzLmJ1ZmZlclN0YXJ0ICsgdGhpcy5idWZmZXJQb3M7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclBvcyArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgbGV0IG5vcm0gPSB0aGlzLm5vcm1hbGl6ZShzdHIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBub3JtLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5tYXRjaChjb2RlLCBwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBub3JtLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gc3RhcnQgJiYgaSA8IHN0ci5sZW5ndGggJiYgc3RyLmNoYXJDb2RlQXQoaSkgPT0gY29kZSlcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2goY29kZSwgcG9zKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXRjaGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm1hdGNoZXNbaV0sIGtlZXAgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5LmNoYXJDb2RlQXQoaW5kZXgpID09IGNvZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5xdWVyeS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiB0aGlzLm1hdGNoZXNbaSArIDFdLCB0bzogcG9zICsgMSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzW2ldKys7XG4gICAgICAgICAgICAgICAgICAgIGtlZXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2VlcCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5LmNoYXJDb2RlQXQoMCkgPT0gY29kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB7IGZyb206IHBvcywgdG86IHBvcyArIDEgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMucHVzaCgxLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKVxuICAgIFNlYXJjaEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbmNvbnN0IGVtcHR5ID0geyBmcm9tOiAtMSwgdG86IC0xLCBtYXRjaDogLypAX19QVVJFX18qLy8uKi8uZXhlYyhcIlwiKSB9O1xuY29uc3QgYmFzZUZsYWdzID0gXCJnbVwiICsgKC94Ly51bmljb2RlID09IG51bGwgPyBcIlwiIDogXCJ1XCIpO1xuLyoqXG5UaGlzIGNsYXNzIGlzIHNpbWlsYXIgdG8gW2BTZWFyY2hDdXJzb3JgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IpXG5idXQgc2VhcmNoZXMgZm9yIGEgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gaW5zdGVhZCBvZiBhIHBsYWluXG5zdHJpbmcuXG4qL1xuY2xhc3MgUmVnRXhwQ3Vyc29yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBjdXJzb3IgdGhhdCB3aWxsIHNlYXJjaCB0aGUgZ2l2ZW4gcmFuZ2UgaW4gdGhlIGdpdmVuXG4gICAgZG9jdW1lbnQuIGBxdWVyeWAgc2hvdWxkIGJlIHRoZSByYXcgcGF0dGVybiAoYXMgeW91J2QgcGFzcyBpdCB0b1xuICAgIGBuZXcgUmVnRXhwYCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSA9IDAsIHRvID0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgU2V0IHRvIGB0cnVlYCB3aGVuIHRoZSBjdXJzb3IgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc2VhcmNoXG4gICAgICAgIHJhbmdlLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdpbGwgY29udGFpbiBhbiBvYmplY3Qgd2l0aCB0aGUgZXh0ZW50IG9mIHRoZSBtYXRjaCBhbmQgdGhlXG4gICAgICAgIG1hdGNoIG9iamVjdCB3aGVuIFtgbmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlJlZ0V4cEN1cnNvci5uZXh0KVxuICAgICAgICBzdWNlc3NmdWxseSBmaW5kcyBhIG1hdGNoLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XG4gICAgICAgIGlmICgvXFxcXFtzV0Rucl18XFxufFxccnxcXFtcXF4vLnRlc3QocXVlcnkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aWxpbmVSZWdFeHBDdXJzb3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20sIHRvKTtcbiAgICAgICAgdGhpcy5yZSA9IG5ldyBSZWdFeHAocXVlcnksIGJhc2VGbGFncyArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiKSk7XG4gICAgICAgIHRoaXMuaXRlciA9IHRleHQuaXRlcigpO1xuICAgICAgICBsZXQgc3RhcnRMaW5lID0gdGV4dC5saW5lQXQoZnJvbSk7XG4gICAgICAgIHRoaXMuY3VyTGluZVN0YXJ0ID0gc3RhcnRMaW5lLmZyb207XG4gICAgICAgIHRoaXMubWF0Y2hQb3MgPSBmcm9tO1xuICAgICAgICB0aGlzLmdldExpbmUodGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgIH1cbiAgICBnZXRMaW5lKHNraXApIHtcbiAgICAgICAgdGhpcy5pdGVyLm5leHQoc2tpcCk7XG4gICAgICAgIGlmICh0aGlzLml0ZXIubGluZUJyZWFrKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA+IHRoaXMudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5jdXJMaW5lLnNsaWNlKDAsIHRoaXMudG8gLSB0aGlzLmN1ckxpbmVTdGFydCk7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRMaW5lKCkge1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCA+IHRoaXMudG8pXG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbWF0Y2gsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDs7KSB7XG4gICAgICAgICAgICB0aGlzLnJlLmxhc3RJbmRleCA9IG9mZjtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMubWF0Y2hQb3MgPD0gdGhpcy50byAmJiB0aGlzLnJlLmV4ZWModGhpcy5jdXJMaW5lKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5jdXJMaW5lU3RhcnQgKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0byArIChmcm9tID09IHRvID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHRoaXMuY3VyTGluZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHRvIHx8IGZyb20gPiB0aGlzLnZhbHVlLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb20sIHRvLCBtYXRjaCB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2ZmID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuY3VyTGluZVN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoIDwgdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGZsYXR0ZW5lZCA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLy8gUmV1c2FibGUgKHBhcnRpYWxseSkgZmxhdHRlbmVkIGRvY3VtZW50IHN0cmluZ3NcbmNsYXNzIEZsYXR0ZW5lZERvYyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgc3RhdGljIGdldChkb2MsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSBmbGF0dGVuZWQuZ2V0KGRvYyk7XG4gICAgICAgIGlmICghY2FjaGVkIHx8IGNhY2hlZC5mcm9tID49IHRvIHx8IGNhY2hlZC50byA8PSBmcm9tKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IG5ldyBGbGF0dGVuZWREb2MoZnJvbSwgZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvKSk7XG4gICAgICAgICAgICBmbGF0dGVuZWQuc2V0KGRvYywgZmxhdCk7XG4gICAgICAgICAgICByZXR1cm4gZmxhdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkLmZyb20gPT0gZnJvbSAmJiBjYWNoZWQudG8gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tOiBjYWNoZWRGcm9tIH0gPSBjYWNoZWQ7XG4gICAgICAgIGlmIChjYWNoZWRGcm9tID4gZnJvbSkge1xuICAgICAgICAgICAgdGV4dCA9IGRvYy5zbGljZVN0cmluZyhmcm9tLCBjYWNoZWRGcm9tKSArIHRleHQ7XG4gICAgICAgICAgICBjYWNoZWRGcm9tID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkLnRvIDwgdG8pXG4gICAgICAgICAgICB0ZXh0ICs9IGRvYy5zbGljZVN0cmluZyhjYWNoZWQudG8sIHRvKTtcbiAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIG5ldyBGbGF0dGVuZWREb2MoY2FjaGVkRnJvbSwgdGV4dCkpO1xuICAgICAgICByZXR1cm4gbmV3IEZsYXR0ZW5lZERvYyhmcm9tLCB0ZXh0LnNsaWNlKGZyb20gLSBjYWNoZWRGcm9tLCB0byAtIGNhY2hlZEZyb20pKTtcbiAgICB9XG59XG5jbGFzcyBNdWx0aWxpbmVSZWdFeHBDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XG4gICAgICAgIHRoaXMubWF0Y2hQb3MgPSBmcm9tO1xuICAgICAgICB0aGlzLnJlID0gbmV3IFJlZ0V4cChxdWVyeSwgYmFzZUZsYWdzICsgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlQ2FzZSkgPyBcImlcIiA6IFwiXCIpKTtcbiAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0ZXh0LCBmcm9tLCB0aGlzLmNodW5rRW5kKGZyb20gKyA1MDAwIC8qIEJhc2UgKi8pKTtcbiAgICB9XG4gICAgY2h1bmtFbmQocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MgPj0gdGhpcy50byA/IHRoaXMudG8gOiB0aGlzLnRleHQubGluZUF0KHBvcykudG87XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBvZmYgPSB0aGlzLnJlLmxhc3RJbmRleCA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmZsYXQuZnJvbTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucmUuZXhlYyh0aGlzLmZsYXQudGV4dCk7XG4gICAgICAgICAgICAvLyBTa2lwIGVtcHR5IG1hdGNoZXMgZGlyZWN0bHkgYWZ0ZXIgdGhlIGxhc3QgbWF0Y2hcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiAhbWF0Y2hbMF0gJiYgbWF0Y2guaW5kZXggPT0gb2ZmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmYgKyAxO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGhpcy5yZS5leGVjKHRoaXMuZmxhdC50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGEgbWF0Y2ggZ29lcyBhbG1vc3QgdG8gdGhlIGVuZCBvZiBhIG5vbmNvbXBsZXRlIGNodW5rLCB0cnlcbiAgICAgICAgICAgIC8vIGFnYWluLCBzaW5jZSBpdCdsbCBsaWtlbHkgYmUgYWJsZSB0byBtYXRjaCBtb3JlXG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgdGhpcy5mbGF0LnRvIDwgdGhpcy50byAmJiBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA+IHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAtIDEwKVxuICAgICAgICAgICAgICAgIG1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5mbGF0LmZyb20gKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb20sIHRvLCBtYXRjaCB9O1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0byArIChmcm9tID09IHRvID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxhdC50byA9PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHcm93IHRoZSBmbGF0dGVuZWQgZG9jXG4gICAgICAgICAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0aGlzLnRleHQsIHRoaXMuZmxhdC5mcm9tLCB0aGlzLmNodW5rRW5kKHRoaXMuZmxhdC5mcm9tICsgdGhpcy5mbGF0LnRleHQubGVuZ3RoICogMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFJlZ0V4cEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IE11bHRpbGluZVJlZ0V4cEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9XG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG59XG5mdW5jdGlvbiB2YWxpZFJlZ0V4cChzb3VyY2UpIHtcbiAgICB0cnkge1xuICAgICAgICBuZXcgUmVnRXhwKHNvdXJjZSwgYmFzZUZsYWdzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5lRGlhbG9nKHZpZXcpIHtcbiAgICBsZXQgaW5wdXQgPSBlbHQoXCJpbnB1dFwiLCB7IGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLCBuYW1lOiBcImxpbmVcIiB9KTtcbiAgICBsZXQgZG9tID0gZWx0KFwiZm9ybVwiLCB7XG4gICAgICAgIGNsYXNzOiBcImNtLWdvdG9MaW5lXCIsXG4gICAgICAgIG9ua2V5ZG93bjogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBkaWFsb2dFZmZlY3Qub2YoZmFsc2UpIH0pO1xuICAgICAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uc3VibWl0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9XG4gICAgfSwgZWx0KFwibGFiZWxcIiwgdmlldy5zdGF0ZS5waHJhc2UoXCJHbyB0byBsaW5lXCIpLCBcIjogXCIsIGlucHV0KSwgXCIgXCIsIGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCB0eXBlOiBcInN1Ym1pdFwiIH0sIHZpZXcuc3RhdGUucGhyYXNlKFwiZ29cIikpKTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gL14oWystXSk/KFxcZCspPyg6XFxkKyk/KCUpPyQvLmV4ZWMoaW5wdXQudmFsdWUpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc3RhcnRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgbGV0IFssIHNpZ24sIGxuLCBjbCwgcGVyY2VudF0gPSBtYXRjaDtcbiAgICAgICAgbGV0IGNvbCA9IGNsID8gK2NsLnNsaWNlKDEpIDogMDtcbiAgICAgICAgbGV0IGxpbmUgPSBsbiA/ICtsbiA6IHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIGlmIChsbiAmJiBwZXJjZW50KSB7XG4gICAgICAgICAgICBsZXQgcGMgPSBsaW5lIC8gMTAwO1xuICAgICAgICAgICAgaWYgKHNpZ24pXG4gICAgICAgICAgICAgICAgcGMgPSBwYyAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIChzdGFydExpbmUubnVtYmVyIC8gc3RhdGUuZG9jLmxpbmVzKTtcbiAgICAgICAgICAgIGxpbmUgPSBNYXRoLnJvdW5kKHN0YXRlLmRvYy5saW5lcyAqIHBjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsbiAmJiBzaWduKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZSAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvY0xpbmUgPSBzdGF0ZS5kb2MubGluZShNYXRoLm1heCgxLCBNYXRoLm1pbihzdGF0ZS5kb2MubGluZXMsIGxpbmUpKSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgZWZmZWN0czogZGlhbG9nRWZmZWN0Lm9mKGZhbHNlKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihkb2NMaW5lLmZyb20gKyBNYXRoLm1heCgwLCBNYXRoLm1pbihjb2wsIGRvY0xpbmUubGVuZ3RoKSkpLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tLCBwb3M6IC0xMCB9O1xufVxuY29uc3QgZGlhbG9nRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgZGlhbG9nRmllbGQgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZS5pcyhkaWFsb2dFZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsID8gY3JlYXRlTGluZURpYWxvZyA6IG51bGwpXG59KTtcbi8qKlxuQ29tbWFuZCB0aGF0IHNob3dzIGEgZGlhbG9nIGFza2luZyB0aGUgdXNlciBmb3IgYSBsaW5lIG51bWJlciwgYW5kXG53aGVuIGEgdmFsaWQgcG9zaXRpb24gaXMgcHJvdmlkZWQsIG1vdmVzIHRoZSBjdXJzb3IgdG8gdGhhdCBsaW5lLlxuXG5TdXBwb3J0cyBsaW5lIG51bWJlcnMsIHJlbGF0aXZlIGxpbmUgb2Zmc2V0cyBwcmVmaXhlZCB3aXRoIGArYCBvclxuYC1gLCBkb2N1bWVudCBwZXJjZW50YWdlcyBzdWZmaXhlZCB3aXRoIGAlYCwgYW5kIGFuIG9wdGlvbmFsXG5jb2x1bW4gcG9zaXRpb24gYnkgYWRkaW5nIGA6YCBhbmQgYSBzZWNvbmQgbnVtYmVyIGFmdGVyIHRoZSBsaW5lXG5udW1iZXIuXG5cblRoZSBkaWFsb2cgY2FuIGJlIHN0eWxlZCB3aXRoIHRoZSBgcGFuZWwuZ290b0xpbmVgIHRoZW1lXG5zZWxlY3Rvci5cbiovXG5jb25zdCBnb3RvTGluZSA9IHZpZXcgPT4ge1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZUxpbmVEaWFsb2cpO1xuICAgIGlmICghcGFuZWwpIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBbZGlhbG9nRWZmZWN0Lm9mKHRydWUpXTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmllbGQoZGlhbG9nRmllbGQsIGZhbHNlKSA9PSBudWxsKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihbZGlhbG9nRmllbGQsIGJhc2VUaGVtZSQxXSkpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICAgICAgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVMaW5lRGlhbG9nKTtcbiAgICB9XG4gICAgaWYgKHBhbmVsKVxuICAgICAgICBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcImlucHV0XCIpLmZvY3VzKCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgYmFzZVRoZW1lJDEgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXBhbmVsLmNtLWdvdG9MaW5lXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIycHggNnB4IDRweFwiLFxuICAgICAgICBcIiYgbGFiZWxcIjogeyBmb250U2l6ZTogXCI4MCVcIiB9XG4gICAgfVxufSk7XG5cbmNvbnN0IGRlZmF1bHRIaWdobGlnaHRPcHRpb25zID0ge1xuICAgIGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3I6IGZhbHNlLFxuICAgIG1pblNlbGVjdGlvbkxlbmd0aDogMSxcbiAgICBtYXhNYXRjaGVzOiAxMDBcbn07XG5jb25zdCBoaWdobGlnaHRDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcob3B0aW9ucywgZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMsIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3I6IChhLCBiKSA9PiBhIHx8IGIsXG4gICAgICAgICAgICBtaW5TZWxlY3Rpb25MZW5ndGg6IE1hdGgubWluLFxuICAgICAgICAgICAgbWF4TWF0Y2hlczogTWF0aC5taW5cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblRoaXMgZXh0ZW5zaW9uIGhpZ2hsaWdodHMgdGV4dCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdGlvbi4gSXQgdXNlc1xudGhlIGBcImNtLXNlbGVjdGlvbk1hdGNoXCJgIGNsYXNzIGZvciB0aGUgaGlnaGxpZ2h0aW5nLiBXaGVuXG5gaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcmAgaXMgZW5hYmxlZCwgdGhlIHdvcmQgYXQgdGhlIGN1cnNvclxuaXRzZWxmIHdpbGwgYmUgaGlnaGxpZ2h0ZWQgd2l0aCBgXCJjbS1zZWxlY3Rpb25NYXRjaC1tYWluXCJgLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMob3B0aW9ucykge1xuICAgIGxldCBleHQgPSBbZGVmYXVsdFRoZW1lLCBtYXRjaEhpZ2hsaWdodGVyXTtcbiAgICBpZiAob3B0aW9ucylcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0Q29uZmlnLm9mKG9wdGlvbnMpKTtcbiAgICByZXR1cm4gZXh0O1xufVxuY29uc3QgbWF0Y2hEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlbGVjdGlvbk1hdGNoXCIgfSk7XG5jb25zdCBtYWluTWF0Y2hEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlbGVjdGlvbk1hdGNoIGNtLXNlbGVjdGlvbk1hdGNoLW1haW5cIiB9KTtcbmNvbnN0IG1hdGNoSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XG4gICAgfVxuICAgIGdldERlY28odmlldykge1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoaGlnaGxpZ2h0Q29uZmlnKTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbC5tYWluLCBxdWVyeSwgY2hlY2sgPSBudWxsO1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGlmICghY29uZi5oaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIGlmICghd29yZClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgY2hlY2sgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHdvcmQuZnJvbSwgd29yZC50byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gcmFuZ2UudG8gLSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgaWYgKGxlbiA8IGNvbmYubWluU2VsZWN0aW9uTGVuZ3RoIHx8IGxlbiA+IDIwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50bykudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFxdWVyeSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWNvID0gW107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHF1ZXJ5LCBwYXJ0LmZyb20sIHBhcnQudG8pO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2sgfHwgKChmcm9tID09IDAgfHwgY2hlY2soc3RhdGUuc2xpY2VEb2MoZnJvbSAtIDEsIGZyb20pKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRvID09IHN0YXRlLmRvYy5sZW5ndGggfHwgY2hlY2soc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgMSkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrICYmIGZyb20gPD0gcmFuZ2UuZnJvbSAmJiB0byA+PSByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY28ucHVzaChtYWluTWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZyb20gPj0gcmFuZ2UudG8gfHwgdG8gPD0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY28ucHVzaChtYXRjaERlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY28ubGVuZ3RoID4gY29uZi5tYXhNYXRjaGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcbmNvbnN0IGRlZmF1bHRUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk5ZmY3NzgwXCIgfSxcbiAgICBcIi5jbS1zZWFyY2hNYXRjaCAuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIiB9XG59KTtcbi8vIFNlbGVjdCB0aGUgd29yZHMgYXJvdW5kIHRoZSBjdXJzb3JzLlxuY29uc3Qgc2VsZWN0V29yZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICBsZXQgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWxlY3Rpb24ucmFuZ2VzLm1hcChyYW5nZSA9PiBzdGF0ZS53b3JkQXQocmFuZ2UuaGVhZCkgfHwgRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkKSksIHNlbGVjdGlvbi5tYWluSW5kZXgpO1xuICAgIGlmIChuZXdTZWwuZXEoc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogbmV3U2VsIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vLyBGaW5kIG5leHQgb2NjdXJyZW5jZSBvZiBxdWVyeSByZWxhdGl2ZSB0byBsYXN0IGN1cnNvci4gV3JhcCBhcm91bmRcbi8vIHRoZSBkb2N1bWVudCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBtYXRjaGVzLlxuZnVuY3Rpb24gZmluZE5leHRPY2N1cnJlbmNlKHN0YXRlLCBxdWVyeSkge1xuICAgIGxldCB7IG1haW4sIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KG1haW4uaGVhZCksIGZ1bGxXb3JkID0gd29yZCAmJiB3b3JkLmZyb20gPT0gbWFpbi5mcm9tICYmIHdvcmQudG8gPT0gbWFpbi50bztcbiAgICBmb3IgKGxldCBjeWNsZWQgPSBmYWxzZSwgY3Vyc29yID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHF1ZXJ5LCByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvKTs7KSB7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGN5Y2xlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgMCwgTWF0aC5tYXgoMCwgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS5mcm9tIC0gMSkpO1xuICAgICAgICAgICAgY3ljbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjeWNsZWQgJiYgcmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gY3Vyc29yLnZhbHVlLmZyb20pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGZ1bGxXb3JkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdvcmQgPSBzdGF0ZS53b3JkQXQoY3Vyc29yLnZhbHVlLmZyb20pO1xuICAgICAgICAgICAgICAgIGlmICghd29yZCB8fCB3b3JkLmZyb20gIT0gY3Vyc29yLnZhbHVlLmZyb20gfHwgd29yZC50byAhPSBjdXJzb3IudmFsdWUudG8pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuU2VsZWN0IG5leHQgb2NjdXJyZW5jZSBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5FeHBhbmQgc2VsZWN0aW9uIHRvIHRoZSB3b3JkIHdoZW4gc2VsZWN0aW9uIHJhbmdlIGlzIGVtcHR5LlxuKi9cbmNvbnN0IHNlbGVjdE5leHRPY2N1cnJlbmNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgeyByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAocmFuZ2VzLnNvbWUoc2VsID0+IHNlbC5mcm9tID09PSBzZWwudG8pKVxuICAgICAgICByZXR1cm4gc2VsZWN0V29yZCh7IHN0YXRlLCBkaXNwYXRjaCB9KTtcbiAgICBsZXQgc2VhcmNoZWRUZXh0ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2VzWzBdLmZyb20sIHJhbmdlc1swXS50byk7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc29tZShyID0+IHN0YXRlLnNsaWNlRG9jKHIuZnJvbSwgci50bykgIT0gc2VhcmNoZWRUZXh0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCByYW5nZSA9IGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSwgc2VhcmNoZWRUZXh0KTtcbiAgICBpZiAoIXJhbmdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgc2VsZWN0aW9uOiBzdGF0ZS5zZWxlY3Rpb24uYWRkUmFuZ2UoRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmZyb20sIHJhbmdlLnRvKSwgZmFsc2UpLFxuICAgICAgICBlZmZlY3RzOiBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHJhbmdlLnRvKVxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNlYXJjaENvbmZpZ0ZhY2V0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogY29uZmlncy5yZWR1Y2UoKHZhbCwgY29uZikgPT4gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdm9pZCAwID8gdmFsIDogY29uZi50b3AsIHVuZGVmaW5lZCkgfHwgZmFsc2UsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBjb25maWdzLnJlZHVjZSgodmFsLCBjb25mKSA9PiB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB2b2lkIDAgPyB2YWwgOiAoY29uZi5jYXNlU2Vuc2l0aXZlIHx8IGNvbmYubWF0Y2hDYXNlKSwgdW5kZWZpbmVkKSB8fCBmYWxzZSxcbiAgICAgICAgICAgIGNyZWF0ZVBhbmVsOiAoKF9hID0gY29uZmlncy5maW5kKGMgPT4gYy5jcmVhdGVQYW5lbCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jcmVhdGVQYW5lbCkgfHwgKHZpZXcgPT4gbmV3IFNlYXJjaFBhbmVsKHZpZXcpKVxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuLyoqXG5Db25maWd1cmUgdGhlIGJlaGF2aW9yIG9mIHRoZSBzZWFyY2ggZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIHNlYXJjaENvbmZpZyhjb25maWcpIHtcbiAgICByZXR1cm4gc2VhcmNoQ29uZmlnRmFjZXQub2YoY29uZmlnKTtcbn1cbi8qKlxuQSBzZWFyY2ggcXVlcnkuIFBhcnQgb2YgdGhlIGVkaXRvcidzIHNlYXJjaCBzdGF0ZS5cbiovXG5jbGFzcyBTZWFyY2hRdWVyeSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcXVlcnkgb2JqZWN0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gY29uZmlnLnNlYXJjaDtcbiAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID0gISFjb25maWcuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5yZWdleHAgPSAhIWNvbmZpZy5yZWdleHA7XG4gICAgICAgIHRoaXMucmVwbGFjZSA9IGNvbmZpZy5yZXBsYWNlIHx8IFwiXCI7XG4gICAgICAgIHRoaXMudmFsaWQgPSAhIXRoaXMuc2VhcmNoICYmICghdGhpcy5yZWdleHAgfHwgdmFsaWRSZWdFeHAodGhpcy5zZWFyY2gpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHF1ZXJ5IHRvIGFub3RoZXIgcXVlcnkuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2ggPT0gb3RoZXIuc2VhcmNoICYmIHRoaXMucmVwbGFjZSA9PSBvdGhlci5yZXBsYWNlICYmXG4gICAgICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPT0gb3RoZXIuY2FzZVNlbnNpdGl2ZSAmJiB0aGlzLnJlZ2V4cCA9PSBvdGhlci5yZWdleHA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHAgPyBuZXcgUmVnRXhwUXVlcnkodGhpcykgOiBuZXcgU3RyaW5nUXVlcnkodGhpcyk7XG4gICAgfVxufVxuY2xhc3MgUXVlcnlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nUXVlcnkgZXh0ZW5kcyBRdWVyeVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoc3BlYyk7XG4gICAgICAgIHRoaXMudW5xdW90ZWQgPSBzcGVjLnNlYXJjaC5yZXBsYWNlKC9cXFxcKFtucnRcXFxcXSkvZywgKF8sIGNoKSA9PiBjaCA9PSBcIm5cIiA/IFwiXFxuXCIgOiBjaCA9PSBcInJcIiA/IFwiXFxyXCIgOiBjaCA9PSBcInRcIiA/IFwiXFx0XCIgOiBcIlxcXFxcIik7XG4gICAgfVxuICAgIGN1cnNvcihkb2MsIGZyb20gPSAwLCB0byA9IGRvYy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWFyY2hDdXJzb3IoZG9jLCB0aGlzLnVucXVvdGVkLCBmcm9tLCB0bywgdGhpcy5zcGVjLmNhc2VTZW5zaXRpdmUgPyB1bmRlZmluZWQgOiB4ID0+IHgudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIG5leHRNYXRjaChkb2MsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLmN1cnNvcihkb2MsIGN1clRvKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKVxuICAgICAgICAgICAgY3Vyc29yID0gdGhpcy5jdXJzb3IoZG9jLCAwLCBjdXJGcm9tKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5kb25lID8gbnVsbCA6IGN1cnNvci52YWx1ZTtcbiAgICB9XG4gICAgLy8gU2VhcmNoaW5nIGluIHJldmVyc2UgaXMsIHJhdGhlciB0aGFuIGltcGxlbWVudGluZyBpbnZlcnRlZCBzZWFyY2hcbiAgICAvLyBjdXJzb3IsIGRvbmUgYnkgc2Nhbm5pbmcgY2h1bmsgYWZ0ZXIgY2h1bmsgZm9yd2FyZC5cbiAgICBwcmV2TWF0Y2hJblJhbmdlKGRvYywgZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdG87Oykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoZnJvbSwgcG9zIC0gMTAwMDAgLyogQ2h1bmtTaXplICovIC0gdGhpcy51bnF1b3RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMuY3Vyc29yKGRvYywgc3RhcnQsIHBvcyksIHJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHRPdmVybGFwcGluZygpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBwb3MgLT0gMTAwMDAgLyogQ2h1bmtTaXplICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChkb2MsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZNYXRjaEluUmFuZ2UoZG9jLCAwLCBjdXJGcm9tKSB8fFxuICAgICAgICAgICAgdGhpcy5wcmV2TWF0Y2hJblJhbmdlKGRvYywgY3VyVG8sIGRvYy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChfcmVzdWx0KSB7IHJldHVybiB0aGlzLnNwZWMucmVwbGFjZTsgfVxuICAgIG1hdGNoQWxsKGRvYywgbGltaXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMuY3Vyc29yKGRvYyksIHJhbmdlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGhpZ2hsaWdodChkb2MsIGZyb20sIHRvLCBhZGQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMuY3Vyc29yKGRvYywgTWF0aC5tYXgoMCwgZnJvbSAtIHRoaXMudW5xdW90ZWQubGVuZ3RoKSwgTWF0aC5taW4odG8gKyB0aGlzLnVucXVvdGVkLmxlbmd0aCwgZG9jLmxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcbiAgICB9XG59XG5jbGFzcyBSZWdFeHBRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XG4gICAgY3Vyc29yKGRvYywgZnJvbSA9IDAsIHRvID0gZG9jLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cEN1cnNvcihkb2MsIHRoaXMuc3BlYy5zZWFyY2gsIHRoaXMuc3BlYy5jYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogeyBpZ25vcmVDYXNlOiB0cnVlIH0sIGZyb20sIHRvKTtcbiAgICB9XG4gICAgbmV4dE1hdGNoKGRvYywgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMuY3Vyc29yKGRvYywgY3VyVG8pLm5leHQoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKVxuICAgICAgICAgICAgY3Vyc29yID0gdGhpcy5jdXJzb3IoZG9jLCAwLCBjdXJGcm9tKS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBjdXJzb3IuZG9uZSA/IG51bGwgOiBjdXJzb3IudmFsdWU7XG4gICAgfVxuICAgIHByZXZNYXRjaEluUmFuZ2UoZG9jLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBzaXplID0gMTs7IHNpemUrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoZnJvbSwgdG8gLSBzaXplICogMTAwMDAgLyogQ2h1bmtTaXplICovKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLmN1cnNvcihkb2MsIHN0YXJ0LCB0byksIHJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgICAgIHJhbmdlID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlICYmIChzdGFydCA9PSBmcm9tIHx8IHJhbmdlLmZyb20gPiBzdGFydCArIDEwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmV2TWF0Y2goZG9jLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKGRvYywgMCwgY3VyRnJvbSkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldk1hdGNoSW5SYW5nZShkb2MsIGN1clRvLCBkb2MubGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0UmVwbGFjZW1lbnQocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMucmVwbGFjZS5yZXBsYWNlKC9cXCQoWyQmXFxkK10pL2csIChtLCBpKSA9PiBpID09IFwiJFwiID8gXCIkXCJcbiAgICAgICAgICAgIDogaSA9PSBcIiZcIiA/IHJlc3VsdC5tYXRjaFswXVxuICAgICAgICAgICAgICAgIDogaSAhPSBcIjBcIiAmJiAraSA8IHJlc3VsdC5tYXRjaC5sZW5ndGggPyByZXN1bHQubWF0Y2hbaV1cbiAgICAgICAgICAgICAgICAgICAgOiBtKTtcbiAgICB9XG4gICAgbWF0Y2hBbGwoZG9jLCBsaW1pdCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gdGhpcy5jdXJzb3IoZG9jKSwgcmFuZ2VzID0gW107XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaGlnaGxpZ2h0KGRvYywgZnJvbSwgdG8sIGFkZCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gdGhpcy5jdXJzb3IoZG9jLCBNYXRoLm1heCgwLCBmcm9tIC0gMjUwIC8qIEhpZ2hsaWdodE1hcmdpbiAqLyksIE1hdGgubWluKHRvICsgMjUwIC8qIEhpZ2hsaWdodE1hcmdpbiAqLywgZG9jLmxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcbiAgICB9XG59XG4vKipcbkEgc3RhdGUgZWZmZWN0IHRoYXQgdXBkYXRlcyB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3Qgc2V0U2VhcmNoUXVlcnkgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCB0b2dnbGVQYW5lbCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHNlYXJjaFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWFyY2hTdGF0ZShkZWZhdWx0UXVlcnkoc3RhdGUpLmNyZWF0ZSgpLCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZShlZmZlY3QudmFsdWUuY3JlYXRlKCksIHZhbHVlLnBhbmVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUodmFsdWUucXVlcnksIGVmZmVjdC52YWx1ZSA/IGNyZWF0ZVNlYXJjaFBhbmVsIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsLnBhbmVsKVxufSk7XG4vKipcbkdldCB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnkgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gZ2V0U2VhcmNoUXVlcnkoc3RhdGUpIHtcbiAgICBsZXQgY3VyU3RhdGUgPSBzdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBjdXJTdGF0ZSA/IGN1clN0YXRlLnF1ZXJ5LnNwZWMgOiBkZWZhdWx0UXVlcnkoc3RhdGUpO1xufVxuY2xhc3MgU2VhcmNoU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBwYW5lbCkge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICB9XG59XG5jb25zdCBtYXRjaE1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VhcmNoTWF0Y2hcIiB9KSwgc2VsZWN0ZWRNYXRjaE1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VhcmNoTWF0Y2ggY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIiB9KTtcbmNvbnN0IHNlYXJjaEhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmhpZ2hsaWdodCh2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlICE9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuaGlnaGxpZ2h0KHN0YXRlKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHsgcXVlcnksIHBhbmVsIH0pIHtcbiAgICAgICAgaWYgKCFwYW5lbCB8fCAhcXVlcnkuc3BlYy52YWxpZClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcmFuZ2VzID0gdmlldy52aXNpYmxlUmFuZ2VzLCBsID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbCAtIDEgJiYgdG8gPiByYW5nZXNbaSArIDFdLmZyb20gLSAyICogMjUwIC8qIEhpZ2hsaWdodE1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICB0byA9IHJhbmdlc1srK2ldLnRvO1xuICAgICAgICAgICAgcXVlcnkuaGlnaGxpZ2h0KHZpZXcuc3RhdGUuZG9jLCBmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gZnJvbSAmJiByLnRvID09IHRvKTtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgc2VsZWN0ZWQgPyBzZWxlY3RlZE1hdGNoTWFyayA6IG1hdGNoTWFyayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5mdW5jdGlvbiBzZWFyY2hDb21tYW5kKGYpIHtcbiAgICByZXR1cm4gdmlldyA9PiB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLnF1ZXJ5LnNwZWMudmFsaWQgPyBmKHZpZXcsIHN0YXRlKSA6IG9wZW5TZWFyY2hQYW5lbCh2aWV3KTtcbiAgICB9O1xufVxuLyoqXG5PcGVuIHRoZSBzZWFyY2ggcGFuZWwgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvcGVuLCBhbmQgbW92ZSB0aGVcbnNlbGVjdGlvbiB0byB0aGUgZmlyc3QgbWF0Y2ggYWZ0ZXIgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uXG5XaWxsIHdyYXAgYXJvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgd2hlbiBpdCByZWFjaGVzIHRoZVxuZW5kLlxuKi9cbmNvbnN0IGZpbmROZXh0ID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHZpZXcuc3RhdGUuZG9jLCBmcm9tLCB0byk7XG4gICAgaWYgKCFuZXh0IHx8IG5leHQuZnJvbSA9PSBmcm9tICYmIG5leHQudG8gPT0gdG8pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uOiB7IGFuY2hvcjogbmV4dC5mcm9tLCBoZWFkOiBuZXh0LnRvIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBlZmZlY3RzOiBhbm5vdW5jZU1hdGNoKHZpZXcsIG5leHQpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaFwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBwcmV2aW91cyBpbnN0YW5jZSBvZiB0aGUgc2VhcmNoIHF1ZXJ5LFxuYmVmb3JlIHRoZSBjdXJyZW50IG1haW4gc2VsZWN0aW9uLiBXaWxsIHdyYXAgcGFzdCB0aGUgc3RhcnRcbm9mIHRoZSBkb2N1bWVudCB0byBzdGFydCBzZWFyY2hpbmcgYXQgdGhlIGVuZCBhZ2Fpbi5cbiovXG5jb25zdCBmaW5kUHJldmlvdXMgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCByYW5nZSA9IHF1ZXJ5LnByZXZNYXRjaChzdGF0ZS5kb2MsIGZyb20sIHRvKTtcbiAgICBpZiAoIXJhbmdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IHJhbmdlLmZyb20sIGhlYWQ6IHJhbmdlLnRvIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBlZmZlY3RzOiBhbm5vdW5jZU1hdGNoKHZpZXcsIHJhbmdlKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2hcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblNlbGVjdCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hlcyA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZS5kb2MsIDEwMDApO1xuICAgIGlmICghcmFuZ2VzIHx8ICFyYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMubWFwKHIgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2gubWF0Y2hlc1wiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuU2VsZWN0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0LlxuKi9cbmNvbnN0IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSB8fCBzZWwubWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwubWFpbjtcbiAgICBsZXQgcmFuZ2VzID0gW10sIG1haW4gPSAwO1xuICAgIGZvciAobGV0IGN1ciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpOyAhY3VyLm5leHQoKS5kb25lOykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjdXIudmFsdWUuZnJvbSA9PSBmcm9tKVxuICAgICAgICAgICAgbWFpbiA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShjdXIudmFsdWUuZnJvbSwgY3VyLnZhbHVlLnRvKSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIG1haW4pLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBjdXJyZW50IG1hdGNoIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3QgcmVwbGFjZU5leHQgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHN0YXRlLmRvYywgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFuZXh0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgc2VsZWN0aW9uLCByZXBsYWNlbWVudDtcbiAgICBpZiAobmV4dC5mcm9tID09IGZyb20gJiYgbmV4dC50byA9PSB0bykge1xuICAgICAgICByZXBsYWNlbWVudCA9IHN0YXRlLnRvVGV4dChxdWVyeS5nZXRSZXBsYWNlbWVudChuZXh0KSk7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG5leHQuZnJvbSwgdG86IG5leHQudG8sIGluc2VydDogcmVwbGFjZW1lbnQgfSk7XG4gICAgICAgIG5leHQgPSBxdWVyeS5uZXh0TWF0Y2goc3RhdGUuZG9jLCBuZXh0LmZyb20sIG5leHQudG8pO1xuICAgIH1cbiAgICBpZiAobmV4dCkge1xuICAgICAgICBsZXQgb2ZmID0gY2hhbmdlcy5sZW5ndGggPT0gMCB8fCBjaGFuZ2VzWzBdLmZyb20gPj0gbmV4dC50byA/IDAgOiBuZXh0LnRvIC0gbmV4dC5mcm9tIC0gcmVwbGFjZW1lbnQubGVuZ3RoO1xuICAgICAgICBzZWxlY3Rpb24gPSB7IGFuY2hvcjogbmV4dC5mcm9tIC0gb2ZmLCBoZWFkOiBuZXh0LnRvIC0gb2ZmIH07XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLCBzZWxlY3Rpb24sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiAhIXNlbGVjdGlvbixcbiAgICAgICAgZWZmZWN0czogbmV4dCA/IGFubm91bmNlTWF0Y2godmlldywgbmV4dCkgOiB1bmRlZmluZWQsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5yZXBsYWNlXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5SZXBsYWNlIGFsbCBpbnN0YW5jZXMgb2YgdGhlIHNlYXJjaCBxdWVyeSB3aXRoIHRoZSBnaXZlblxucmVwbGFjZW1lbnQuXG4qL1xuY29uc3QgcmVwbGFjZUFsbCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZS5kb2MsIDFlOSkubWFwKG1hdGNoID0+IHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IG1hdGNoO1xuICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgaW5zZXJ0OiBxdWVyeS5nZXRSZXBsYWNlbWVudChtYXRjaCkgfTtcbiAgICB9KTtcbiAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5yZXBsYWNlLmFsbFwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhbmVsKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkuY3JlYXRlUGFuZWwodmlldyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0UXVlcnkoc3RhdGUsIGZhbGxiYWNrKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgc2VsVGV4dCA9IHNlbC5lbXB0eSB8fCBzZWwudG8gPiBzZWwuZnJvbSArIDEwMCA/IFwiXCIgOiBzdGF0ZS5zbGljZURvYyhzZWwuZnJvbSwgc2VsLnRvKTtcbiAgICBsZXQgY2FzZVNlbnNpdGl2ZSA9IChfYSA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5jYXNlU2Vuc2l0aXZlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkuY2FzZVNlbnNpdGl2ZTtcbiAgICByZXR1cm4gZmFsbGJhY2sgJiYgIXNlbFRleHQgPyBmYWxsYmFjayA6IG5ldyBTZWFyY2hRdWVyeSh7IHNlYXJjaDogc2VsVGV4dC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSwgY2FzZVNlbnNpdGl2ZSB9KTtcbn1cbi8qKlxuTWFrZSBzdXJlIHRoZSBzZWFyY2ggcGFuZWwgaXMgb3BlbiBhbmQgZm9jdXNlZC5cbiovXG5jb25zdCBvcGVuU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLnBhbmVsKSB7XG4gICAgICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZVNlYXJjaFBhbmVsKTtcbiAgICAgICAgaWYgKCFwYW5lbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHNlYXJjaElucHV0ID0gcGFuZWwuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbbmFtZT1zZWFyY2hdXCIpO1xuICAgICAgICBpZiAoc2VhcmNoSW5wdXQgIT0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS52YWxpZClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHRvZ2dsZVBhbmVsLm9mKHRydWUpLFxuICAgICAgICAgICAgICAgIHN0YXRlID8gc2V0U2VhcmNoUXVlcnkub2YoZGVmYXVsdFF1ZXJ5KHZpZXcuc3RhdGUsIHN0YXRlLnF1ZXJ5LnNwZWMpKSA6IFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihzZWFyY2hFeHRlbnNpb25zKVxuICAgICAgICAgICAgXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgc2VhcmNoIHBhbmVsLlxuKi9cbmNvbnN0IGNsb3NlU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUucGFuZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgaWYgKHBhbmVsICYmIHBhbmVsLmRvbS5jb250YWlucyh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCkpXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRGVmYXVsdCBzZWFyY2gtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIE1vZC1mOiBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbClcbiAtIEYzLCBNb2QtZzogW2BmaW5kTmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmROZXh0KVxuIC0gU2hpZnQtRjMsIFNoaWZ0LU1vZC1nOiBbYGZpbmRQcmV2aW91c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmRQcmV2aW91cylcbiAtIEFsdC1nOiBbYGdvdG9MaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZ290b0xpbmUpXG4gLSBNb2QtZDogW2BzZWxlY3ROZXh0T2NjdXJyZW5jZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlbGVjdE5leHRPY2N1cnJlbmNlKVxuKi9cbmNvbnN0IHNlYXJjaEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtZlwiLCBydW46IG9wZW5TZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiRjNcIiwgcnVuOiBmaW5kTmV4dCwgc2hpZnQ6IGZpbmRQcmV2aW91cywgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1nXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbG9zZVNlYXJjaFBhbmVsLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIgfSxcbiAgICB7IGtleTogXCJNb2QtU2hpZnQtbFwiLCBydW46IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgfSxcbiAgICB7IGtleTogXCJBbHQtZ1wiLCBydW46IGdvdG9MaW5lIH0sXG4gICAgeyBrZXk6IFwiTW9kLWRcIiwgcnVuOiBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbl07XG5jbGFzcyBTZWFyY2hQYW5lbCB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnF1ZXJ5ID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkucXVlcnkuc3BlYztcbiAgICAgICAgdGhpcy5jb21taXQgPSB0aGlzLmNvbW1pdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHF1ZXJ5LnNlYXJjaCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UodmlldywgXCJGaW5kXCIpLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcIkZpbmRcIiksXG4gICAgICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcbiAgICAgICAgICAgIG5hbWU6IFwic2VhcmNoXCIsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXQsXG4gICAgICAgICAgICBvbmtleXVwOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogcXVlcnkucmVwbGFjZSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UodmlldywgXCJSZXBsYWNlXCIpLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcIlJlcGxhY2VcIiksXG4gICAgICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcbiAgICAgICAgICAgIG5hbWU6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0LFxuICAgICAgICAgICAgb25rZXl1cDogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FzZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJjYXNlXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcInJlXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS5yZWdleHAsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGJ1dHRvbihuYW1lLCBvbmNsaWNrLCBjb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIG5hbWUsIG9uY2xpY2ssIHR5cGU6IFwiYnV0dG9uXCIgfSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20gPSBlbHQoXCJkaXZcIiwgeyBvbmtleWRvd246IChlKSA9PiB0aGlzLmtleWRvd24oZSksIGNsYXNzOiBcImNtLXNlYXJjaFwiIH0sIFtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoRmllbGQsXG4gICAgICAgICAgICBidXR0b24oXCJuZXh0XCIsICgpID0+IGZpbmROZXh0KHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwibmV4dFwiKV0pLFxuICAgICAgICAgICAgYnV0dG9uKFwicHJldlwiLCAoKSA9PiBmaW5kUHJldmlvdXModmlldyksIFtwaHJhc2UodmlldywgXCJwcmV2aW91c1wiKV0pLFxuICAgICAgICAgICAgYnV0dG9uKFwic2VsZWN0XCIsICgpID0+IHNlbGVjdE1hdGNoZXModmlldyksIFtwaHJhc2UodmlldywgXCJhbGxcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLmNhc2VGaWVsZCwgcGhyYXNlKHZpZXcsIFwibWF0Y2ggY2FzZVwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMucmVGaWVsZCwgcGhyYXNlKHZpZXcsIFwicmVnZXhwXCIpXSksXG4gICAgICAgICAgICAuLi52aWV3LnN0YXRlLnJlYWRPbmx5ID8gW10gOiBbXG4gICAgICAgICAgICAgICAgZWx0KFwiYnJcIiksXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQsXG4gICAgICAgICAgICAgICAgYnV0dG9uKFwicmVwbGFjZVwiLCAoKSA9PiByZXBsYWNlTmV4dCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInJlcGxhY2VcIildKSxcbiAgICAgICAgICAgICAgICBidXR0b24oXCJyZXBsYWNlQWxsXCIsICgpID0+IHJlcGxhY2VBbGwodmlldyksIFtwaHJhc2UodmlldywgXCJyZXBsYWNlIGFsbFwiKV0pLFxuICAgICAgICAgICAgICAgIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY2xvc2VcIixcbiAgICAgICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gY2xvc2VTZWFyY2hQYW5lbCh2aWV3KSxcbiAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcImNsb3NlXCIpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgfSwgW1wiw5dcIl0pXG4gICAgICAgICAgICBdXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGxldCBxdWVyeSA9IG5ldyBTZWFyY2hRdWVyeSh7XG4gICAgICAgICAgICBzZWFyY2g6IHRoaXMuc2VhcmNoRmllbGQudmFsdWUsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiB0aGlzLmNhc2VGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVnZXhwOiB0aGlzLnJlRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZUZpZWxkLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXF1ZXJ5LmVxKHRoaXMucXVlcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWFyY2hRdWVyeS5vZihxdWVyeSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5ZG93bihlKSB7XG4gICAgICAgIGlmIChydW5TY29wZUhhbmRsZXJzKHRoaXMudmlldywgZSwgXCJzZWFyY2gtcGFuZWxcIikpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5zZWFyY2hGaWVsZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgKGUuc2hpZnRLZXkgPyBmaW5kUHJldmlvdXMgOiBmaW5kTmV4dCkodGhpcy52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5yZXBsYWNlRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlcGxhY2VOZXh0KHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSAmJiAhZWZmZWN0LnZhbHVlLmVxKHRoaXMucXVlcnkpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHNldFF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSA9IHF1ZXJ5LnNlYXJjaDtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQudmFsdWUgPSBxdWVyeS5yZXBsYWNlO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZC5jaGVja2VkID0gcXVlcnkuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5yZUZpZWxkLmNoZWNrZWQgPSBxdWVyeS5yZWdleHA7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLnNlbGVjdCgpO1xuICAgIH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gODA7IH1cbiAgICBnZXQgdG9wKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS50b3A7IH1cbn1cbmZ1bmN0aW9uIHBocmFzZSh2aWV3LCBwaHJhc2UpIHsgcmV0dXJuIHZpZXcuc3RhdGUucGhyYXNlKHBocmFzZSk7IH1cbmNvbnN0IEFubm91bmNlTWFyZ2luID0gMzA7XG5jb25zdCBCcmVhayA9IC9bXFxzXFwuLDo7PyFdLztcbmZ1bmN0aW9uIGFubm91bmNlTWF0Y2godmlldywgeyBmcm9tLCB0byB9KSB7XG4gICAgbGV0IGxpbmVTdGFydCA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChmcm9tKS5mcm9tLCBsaW5lRW5kID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKS50bztcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lU3RhcnQsIGZyb20gLSBBbm5vdW5jZU1hcmdpbiksIGVuZCA9IE1hdGgubWluKGxpbmVFbmQsIHRvICsgQW5ub3VuY2VNYXJnaW4pO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zdGF0ZS5zbGljZURvYyhzdGFydCwgZW5kKTtcbiAgICBpZiAoc3RhcnQgIT0gbGluZVN0YXJ0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQW5ub3VuY2VNYXJnaW47IGkrKylcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgKyAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kICE9IGxpbmVFbmQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRleHQubGVuZ3RoIC0gMTsgaSA+IHRleHQubGVuZ3RoIC0gQW5ub3VuY2VNYXJnaW47IGktLSlcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgLSAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShcImN1cnJlbnQgbWF0Y2hcIil9LiAke3RleHR9ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJvbiBsaW5lXCIpfSAke3ZpZXcuc3RhdGUuZG9jLmxpbmVBdChmcm9tKS5udW1iZXJ9YCk7XG59XG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXBhbmVsLmNtLXNlYXJjaFwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDZweCA0cHhcIixcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImIFtuYW1lPWNsb3NlXVwiOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgdG9wOiBcIjBcIixcbiAgICAgICAgICAgIHJpZ2h0OiBcIjRweFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgfSxcbiAgICAgICAgXCImIGlucHV0LCAmIGJ1dHRvbiwgJiBsYWJlbFwiOiB7XG4gICAgICAgICAgICBtYXJnaW46IFwiLjJlbSAuNmVtIC4yZW0gMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBpbnB1dFt0eXBlPWNoZWNrYm94XVwiOiB7XG4gICAgICAgICAgICBtYXJnaW5SaWdodDogXCIuMmVtXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImIGxhYmVsXCI6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiBcIjgwJVwiLFxuICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJwcmVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZmYwMDU0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWFyY2hNYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMDBmZmZmOGFcIiB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmY2YTAwNTRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZjAwZmY4YVwiIH1cbn0pO1xuY29uc3Qgc2VhcmNoRXh0ZW5zaW9ucyA9IFtcbiAgICBzZWFyY2hTdGF0ZSxcbiAgICAvKkBfX1BVUkVfXyovUHJlYy5sb3dlc3Qoc2VhcmNoSGlnaGxpZ2h0ZXIpLFxuICAgIGJhc2VUaGVtZVxuXTtcblxuZXhwb3J0IHsgUmVnRXhwQ3Vyc29yLCBTZWFyY2hDdXJzb3IsIFNlYXJjaFF1ZXJ5LCBjbG9zZVNlYXJjaFBhbmVsLCBmaW5kTmV4dCwgZmluZFByZXZpb3VzLCBnZXRTZWFyY2hRdWVyeSwgZ290b0xpbmUsIGhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMsIG9wZW5TZWFyY2hQYW5lbCwgcmVwbGFjZUFsbCwgcmVwbGFjZU5leHQsIHNlYXJjaENvbmZpZywgc2VhcmNoS2V5bWFwLCBzZWxlY3RNYXRjaGVzLCBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcywgc2V0U2VhcmNoUXVlcnkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/search/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/stream-parser/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/stream-parser/dist/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StreamLanguage\": function() { return /* binding */ StreamLanguage; },\n/* harmony export */   \"StringStream\": function() { return /* binding */ StringStream; }\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/highlight */ \"./node_modules/@codemirror/highlight/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n // Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\n\nfunction countCol(string, end, tabSize) {\n  var startIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var startValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) end = string.length;\n  }\n\n  var n = startValue;\n\n  for (var i = startIndex; i < end; i++) {\n    if (string.charCodeAt(i) == 9) n += tabSize - n % tabSize;else n++;\n  }\n\n  return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/\n\n\nvar StringStream = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function StringStream(\n  /**\n  The line.\n  */\n  string, tabSize,\n  /**\n  The current indent unit size.\n  */\n  indentUnit) {\n    _classCallCheck(this, StringStream);\n\n    this.string = string;\n    this.tabSize = tabSize;\n    this.indentUnit = indentUnit;\n    /**\n    The current position on the line.\n    */\n\n    this.pos = 0;\n    /**\n    The start position of the current token.\n    */\n\n    this.start = 0;\n    this.lastColumnPos = 0;\n    this.lastColumnValue = 0;\n  }\n  /**\n  True if we are at the end of the line.\n  */\n\n\n  _createClass(StringStream, [{\n    key: \"eol\",\n    value: function eol() {\n      return this.pos >= this.string.length;\n    }\n    /**\n    True if we are at the start of the line.\n    */\n\n  }, {\n    key: \"sol\",\n    value: function sol() {\n      return this.pos == 0;\n    }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.string.charAt(this.pos) || undefined;\n    }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */\n\n  }, {\n    key: \"eat\",\n    value: function eat(match) {\n      var ch = this.string.charAt(this.pos);\n      var ok;\n      if (typeof match == \"string\") ok = ch == match;else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n\n      if (ok) {\n        ++this.pos;\n        return ch;\n      }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */\n\n  }, {\n    key: \"eatWhile\",\n    value: function eatWhile(match) {\n      var start = this.pos;\n\n      while (this.eat(match)) {}\n\n      return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */\n\n  }, {\n    key: \"eatSpace\",\n    value: function eatSpace() {\n      var start = this.pos;\n\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n        ++this.pos;\n      }\n\n      return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */\n\n  }, {\n    key: \"skipToEnd\",\n    value: function skipToEnd() {\n      this.pos = this.string.length;\n    }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */\n\n  }, {\n    key: \"skipTo\",\n    value: function skipTo(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n\n      if (found > -1) {\n        this.pos = found;\n        return true;\n      }\n    }\n    /**\n    Move back `n` characters.\n    */\n\n  }, {\n    key: \"backUp\",\n    value: function backUp(n) {\n      this.pos -= n;\n    }\n    /**\n    Get the column position at `this.pos`.\n    */\n\n  }, {\n    key: \"column\",\n    value: function column() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n\n      return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */\n\n  }, {\n    key: \"indentation\",\n    value: function indentation() {\n      return countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */\n\n  }, {\n    key: \"match\",\n    value: function match(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function cased(str) {\n          return caseInsensitive ? str.toLowerCase() : str;\n        };\n\n        var substr = this.string.substr(this.pos, pattern.length);\n\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        } else return null;\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    }\n    /**\n    Get the current token.\n    */\n\n  }, {\n    key: \"current\",\n    value: function current() {\n      return this.string.slice(this.start, this.pos);\n    }\n  }]);\n\n  return StringStream;\n}();\n\nfunction fullParser(spec) {\n  return {\n    token: spec.token,\n    blankLine: spec.blankLine || function () {},\n    startState: spec.startState || function () {\n      return true;\n    },\n    copyState: spec.copyState || defaultCopyState,\n    indent: spec.indent || function () {\n      return null;\n    },\n    languageData: spec.languageData || {},\n    tokenTable: spec.tokenTable || noTokens\n  };\n}\n\nfunction defaultCopyState(state) {\n  if (_typeof(state) != \"object\") return state;\n  var newState = {};\n\n  for (var prop in state) {\n    var val = state[prop];\n    newState[prop] = val instanceof Array ? val.slice() : val;\n  }\n\n  return newState;\n}\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a streaming\nparser.\n*/\n\n\nvar StreamLanguage = /*#__PURE__*/function (_Language) {\n  _inherits(StreamLanguage, _Language);\n\n  var _super = _createSuper(StreamLanguage);\n\n  function StreamLanguage(parser) {\n    var _this;\n\n    _classCallCheck(this, StreamLanguage);\n\n    var data = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.defineLanguageFacet)(parser.languageData);\n    var p = fullParser(parser),\n        self;\n    var impl = new ( /*#__PURE__*/function (_Parser) {\n      _inherits(_class, _Parser);\n\n      var _super2 = _createSuper(_class);\n\n      function _class() {\n        _classCallCheck(this, _class);\n\n        return _super2.apply(this, arguments);\n      }\n\n      _createClass(_class, [{\n        key: \"createParse\",\n        value: function createParse(input, fragments, ranges) {\n          return new Parse(self, input, fragments, ranges);\n        }\n      }]);\n\n      return _class;\n    }(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser))();\n    _this = _super.call(this, data, impl, docID(data), [_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.indentService.of(function (cx, pos) {\n      return _this.getIndent(cx, pos);\n    })]);\n    self = _assertThisInitialized(_this);\n    _this.streamParser = p;\n    _this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n      perNode: true\n    });\n    _this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n    return _this;\n  }\n\n  _createClass(StreamLanguage, [{\n    key: \"getIndent\",\n    value: function getIndent(cx, pos) {\n      var tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.syntaxTree)(cx.state),\n          at = tree.resolve(pos);\n\n      while (at && at.type != this.topNode) {\n        at = at.parent;\n      }\n\n      if (!at) return null;\n      var start = findState(this, tree, 0, at.from, pos),\n          statePos,\n          state;\n\n      if (start) {\n        state = start.state;\n        statePos = start.pos + 1;\n      } else {\n        state = this.streamParser.startState(cx.unit);\n        statePos = 0;\n      }\n\n      if (pos - statePos > 10000\n      /* MaxIndentScanDist */\n      ) return null;\n\n      while (statePos < pos) {\n        var line = cx.state.doc.lineAt(statePos),\n            end = Math.min(pos, line.to);\n\n        if (line.length) {\n          var stream = new StringStream(line.text, cx.state.tabSize, cx.unit);\n\n          while (stream.pos < end - line.from) {\n            readToken(this.streamParser.token, stream, state);\n          }\n        } else {\n          this.streamParser.blankLine(state, cx.unit);\n        }\n\n        if (end == pos) break;\n        statePos = line.to + 1;\n      }\n\n      var _cx$state$doc$lineAt = cx.state.doc.lineAt(pos),\n          text = _cx$state$doc$lineAt.text;\n\n      return this.streamParser.indent(state, /^\\s*(.*)/.exec(text)[1], cx);\n    }\n  }, {\n    key: \"allowsNesting\",\n    get: function get() {\n      return false;\n    }\n  }], [{\n    key: \"define\",\n    value: function define(spec) {\n      return new StreamLanguage(spec);\n    }\n  }]);\n\n  return StreamLanguage;\n}(_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.Language);\n\nfunction findState(lang, tree, off, startPos, before) {\n  var state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n  if (state) return {\n    state: lang.streamParser.copyState(state),\n    pos: off + tree.length\n  };\n\n  for (var i = tree.children.length - 1; i >= 0; i--) {\n    var child = tree.children[i],\n        pos = off + tree.positions[i];\n    var found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);\n    if (found) return found;\n  }\n\n  return null;\n}\n\nfunction cutTree(lang, tree, from, to, inside) {\n  if (inside && from <= 0 && to >= tree.length) return tree;\n  if (!inside && tree.type == lang.topNode) inside = true;\n\n  for (var i = tree.children.length - 1; i >= 0; i--) {\n    var pos = tree.positions[i],\n        child = tree.children[i],\n        inner = void 0;\n\n    if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n      if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;\n      return !inside ? inner : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n    }\n  }\n\n  return null;\n}\n\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n  var _iterator = _createForOfIteratorHelper(fragments),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var f = _step.value;\n      var from = f.from + (f.openStart ? 25 : 0),\n          to = f.to - (f.openEnd ? 25 : 0);\n      var found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to),\n          tree = void 0;\n      if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {\n        state: found.state,\n        tree: tree\n      };\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    state: lang.streamParser.startState(editorState ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.getIndentUnit)(editorState) : 4),\n    tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty\n  };\n}\n\nvar Parse = /*#__PURE__*/function () {\n  function Parse(lang, input, fragments, ranges) {\n    _classCallCheck(this, Parse);\n\n    this.lang = lang;\n    this.input = input;\n    this.fragments = fragments;\n    this.ranges = ranges;\n    this.stoppedAt = null;\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunk = [];\n    this.chunkReused = undefined;\n    this.rangeIndex = 0;\n    this.to = ranges[ranges.length - 1].to;\n    var context = _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.ParseContext.get(),\n        from = ranges[0].from;\n\n    var _findStartInFragments = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state),\n        state = _findStartInFragments.state,\n        tree = _findStartInFragments.tree;\n\n    this.state = state;\n    this.parsedPos = this.chunkStart = from + tree.length;\n\n    for (var i = 0; i < tree.children.length; i++) {\n      this.chunks.push(tree.children[i]);\n      this.chunkPos.push(tree.positions[i]);\n    }\n\n    if (context && this.parsedPos < context.viewport.from - 100000\n    /* MaxDistanceBeforeViewport */\n    ) {\n      this.state = this.lang.streamParser.startState((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.getIndentUnit)(context.state));\n      context.skipUntilInView(this.parsedPos, context.viewport.from);\n      this.parsedPos = context.viewport.from;\n    }\n  }\n\n  _createClass(Parse, [{\n    key: \"advance\",\n    value: function advance() {\n      var context = _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.ParseContext.get();\n      var parseEnd = this.stoppedAt == null ? this.to : this.stoppedAt;\n      var end = Math.min(parseEnd, this.chunkStart + 2048\n      /* ChunkSize */\n      );\n      if (context) end = Math.min(end, context.viewport.to);\n\n      while (this.parsedPos < end) {\n        this.parseLine(context);\n      }\n\n      if (this.chunkStart < this.parsedPos) this.finishChunk();\n      if (this.parsedPos >= parseEnd) return this.finish();\n\n      if (context && this.parsedPos >= context.viewport.to) {\n        context.skipUntilInView(this.parsedPos, parseEnd);\n        return this.finish();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"stopAt\",\n    value: function stopAt(pos) {\n      this.stoppedAt = pos;\n    }\n  }, {\n    key: \"lineAfter\",\n    value: function lineAfter(pos) {\n      var chunk = this.input.chunk(pos);\n\n      if (!this.input.lineChunks) {\n        var eol = chunk.indexOf(\"\\n\");\n        if (eol > -1) chunk = chunk.slice(0, eol);\n      } else if (chunk == \"\\n\") {\n        chunk = \"\";\n      }\n\n      return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n  }, {\n    key: \"nextLine\",\n    value: function nextLine() {\n      var from = this.parsedPos,\n          line = this.lineAfter(from),\n          end = from + line.length;\n\n      for (var index = this.rangeIndex;;) {\n        var rangeEnd = this.ranges[index].to;\n        if (rangeEnd >= end) break;\n        line = line.slice(0, rangeEnd - (end - line.length));\n        index++;\n        if (index == this.ranges.length) break;\n        var rangeStart = this.ranges[index].from;\n        var after = this.lineAfter(rangeStart);\n        line += after;\n        end = rangeStart + after.length;\n      }\n\n      return {\n        line: line,\n        end: end\n      };\n    }\n  }, {\n    key: \"skipGapsTo\",\n    value: function skipGapsTo(pos, offset, side) {\n      for (;;) {\n        var end = this.ranges[this.rangeIndex].to,\n            offPos = pos + offset;\n        if (side > 0 ? end > offPos : end >= offPos) break;\n        var start = this.ranges[++this.rangeIndex].from;\n        offset += start - end;\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"emitToken\",\n    value: function emitToken(id, from, to, size, offset) {\n      if (this.ranges.length > 1) {\n        offset = this.skipGapsTo(from, offset, 1);\n        from += offset;\n        var len0 = this.chunk.length;\n        offset = this.skipGapsTo(to, offset, -1);\n        to += offset;\n        size += this.chunk.length - len0;\n      }\n\n      this.chunk.push(id, from, to, size);\n      return offset;\n    }\n  }, {\n    key: \"parseLine\",\n    value: function parseLine(context) {\n      var _this$nextLine = this.nextLine(),\n          line = _this$nextLine.line,\n          end = _this$nextLine.end,\n          offset = 0,\n          streamParser = this.lang.streamParser;\n\n      var stream = new StringStream(line, context ? context.state.tabSize : 4, context ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.getIndentUnit)(context.state) : 2);\n\n      if (stream.eol()) {\n        streamParser.blankLine(this.state, stream.indentUnit);\n      } else {\n        while (!stream.eol()) {\n          var token = readToken(streamParser.token, stream, this.state);\n          if (token) offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n          if (stream.start > 10000\n          /* MaxLineLength */\n          ) break;\n        }\n      }\n\n      this.parsedPos = end;\n      if (this.parsedPos < this.to) this.parsedPos++;\n    }\n  }, {\n    key: \"finishChunk\",\n    value: function finishChunk() {\n      var tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n        buffer: this.chunk,\n        start: this.chunkStart,\n        length: this.parsedPos - this.chunkStart,\n        nodeSet: nodeSet,\n        topID: 0,\n        maxBufferLength: 2048\n        /* ChunkSize */\n        ,\n        reused: this.chunkReused\n      });\n      tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);\n      this.chunks.push(tree);\n      this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n      this.chunk = [];\n      this.chunkReused = undefined;\n      this.chunkStart = this.parsedPos;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n  }]);\n\n  return Parse;\n}();\n\nfunction readToken(token, stream, state) {\n  stream.start = stream.pos;\n\n  for (var i = 0; i < 10; i++) {\n    var result = token(stream, state);\n    if (stream.pos > stream.start) return result;\n  }\n\n  throw new Error(\"Stream parser failed to advance stream.\");\n}\n\nvar noTokens = /*@__PURE__*/Object.create(null);\nvar typeArray = [_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none];\nvar nodeSet = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);\nvar warned = [];\nvar defaultTable = /*@__PURE__*/Object.create(null);\n\nfor (var _i = 0, _arr = [[\"variable\", \"variableName\"], [\"variable-2\", \"variableName.special\"], [\"string-2\", \"string.special\"], [\"def\", \"variableName.definition\"], [\"tag\", \"typeName\"], [\"attribute\", \"propertyName\"], [\"type\", \"typeName\"], [\"builtin\", \"variableName.standard\"], [\"qualifier\", \"modifier\"], [\"error\", \"invalid\"], [\"header\", \"heading\"], [\"property\", \"propertyName\"]]; _i < _arr.length; _i++) {\n  var _arr$_i = _slicedToArray(_arr[_i], 2),\n      legacyName = _arr$_i[0],\n      name = _arr$_i[1];\n\n  defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);\n}\n\nvar TokenTable = /*#__PURE__*/function () {\n  function TokenTable(extra) {\n    _classCallCheck(this, TokenTable);\n\n    this.extra = extra;\n    this.table = Object.assign(Object.create(null), defaultTable);\n  }\n\n  _createClass(TokenTable, [{\n    key: \"resolve\",\n    value: function resolve(tag) {\n      return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n    }\n  }]);\n\n  return TokenTable;\n}();\n\nvar defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);\n\nfunction warnForPart(part, msg) {\n  if (warned.indexOf(part) > -1) return;\n  warned.push(part);\n  console.warn(msg);\n}\n\nfunction createTokenType(extra, tagStr) {\n  var tag = null;\n\n  var _iterator2 = _createForOfIteratorHelper(tagStr.split(\".\")),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var part = _step2.value;\n      var value = extra[part] || _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags[part];\n\n      if (!value) {\n        warnForPart(part, \"Unknown highlighting tag \".concat(part));\n      } else if (typeof value == \"function\") {\n        if (!tag) warnForPart(part, \"Modifier \".concat(part, \" used at start of tag\"));else tag = value(tag);\n      } else {\n        if (tag) warnForPart(part, \"Tag \".concat(part, \" used as modifier\"));else tag = value;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (!tag) return 0;\n  var name = tagStr.replace(/ /g, \"_\"),\n      type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n    id: typeArray.length,\n    name: name,\n    props: [(0,_codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.styleTags)(_defineProperty({}, name, tag))]\n  });\n  typeArray.push(type);\n  return type.id;\n}\n\nfunction docID(data) {\n  var type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n    id: typeArray.length,\n    name: \"Document\",\n    props: [_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.languageDataProp.add(function () {\n      return data;\n    })]\n  });\n  typeArray.push(type);\n  return type;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RyZWFtLXBhcnNlci9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUlBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7Ozs7O0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBSEE7O0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQVpBO0FBYUE7Ozs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBRUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQUE7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFuQ0E7QUFBQTtBQUFBOzs7O0FBZkE7O0FBb0RBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU9BO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBREE7O0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU5BO0FBT0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQWNBO0FBZEE7O0FBZUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBRUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBSUE7QUFDQTtBQW5CQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQW9CQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RyZWFtLXBhcnNlci9kaXN0L2luZGV4LmpzPzE5MjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZVR5cGUsIE5vZGVTZXQsIFBhcnNlciwgTm9kZVByb3AsIFRyZWUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IHRhZ3MsIHN0eWxlVGFncyB9IGZyb20gJ0Bjb2RlbWlycm9yL2hpZ2hsaWdodCc7XG5pbXBvcnQgeyBMYW5ndWFnZSwgZGVmaW5lTGFuZ3VhZ2VGYWNldCwgaW5kZW50U2VydmljZSwgc3ludGF4VHJlZSwgUGFyc2VDb250ZXh0LCBnZXRJbmRlbnRVbml0LCBsYW5ndWFnZURhdGFQcm9wIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuXG4vLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cbi8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG5mdW5jdGlvbiBjb3VudENvbChzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCA9IDAsIHN0YXJ0VmFsdWUgPSAwKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxzXFx1MDBhMF0vKTtcbiAgICAgICAgaWYgKGVuZCA9PSAtMSlcbiAgICAgICAgICAgIGVuZCA9IHN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBuID0gc3RhcnRWYWx1ZTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KVxuICAgICAgICAgICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbisrO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8qKlxuRW5jYXBzdWxhdGVzIGEgc2luZ2xlIGxpbmUgb2YgaW5wdXQuIEdpdmVuIHRvIHN0cmVhbSBzeW50YXggY29kZSxcbndoaWNoIHVzZXMgaXQgdG8gdG9rZW5pemUgdGhlIGNvbnRlbnQuXG4qL1xuY2xhc3MgU3RyaW5nU3RyZWFtIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsaW5lLlxuICAgICovXG4gICAgc3RyaW5nLCB0YWJTaXplLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBpbmRlbnQgdW5pdCBzaXplLlxuICAgICovXG4gICAgaW5kZW50VW5pdCkge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy50YWJTaXplID0gdGFiU2l6ZTtcbiAgICAgICAgdGhpcy5pbmRlbnRVbml0ID0gaW5kZW50VW5pdDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBsaW5lLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBlb2woKSB7IHJldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBzb2woKSB7IHJldHVybiB0aGlzLnBvcyA9PSAwOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBuZXh0IGNvZGUgdW5pdCBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgb3IgdW5kZWZpbmVkXG4gICAgaWYgd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHBlZWsoKSB7IHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHVuZGVmaW5lZDsgfVxuICAgIC8qKlxuICAgIFJlYWQgdGhlIG5leHQgY29kZSB1bml0IGFuZCBhZHZhbmNlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPCB0aGlzLnN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCB0aGUgbmV4dCBjaGFyYWN0ZXIgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nLCByZWd1bGFyXG4gICAgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlLiBDb25zdW1lIGFuZCByZXR1cm4gaXQgaWYgaXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIGVhdChtYXRjaCkge1xuICAgICAgICBsZXQgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgb2s7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIG9rID0gY2ggPT0gbWF0Y2g7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9rID0gY2ggJiYgKG1hdGNoIGluc3RhbmNlb2YgUmVnRXhwID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpO1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ29udGludWUgbWF0Y2hpbmcgY2hhcmFjdGVycyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBzdHJpbmcsXG4gICAgcmVndWxhciBleHByZXNzaW9uLCBvciBwcmVkaWNhdGUgZnVuY3Rpb24uIFJldHVybiB0cnVlIGlmIGFueVxuICAgIGNoYXJhY3RlcnMgd2VyZSBjb25zdW1lZC5cbiAgICAqL1xuICAgIGVhdFdoaWxlKG1hdGNoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXQobWF0Y2gpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnN1bWUgd2hpdGVzcGFjZSBhaGVhZCBvZiBgdGhpcy5wb3NgLiBSZXR1cm4gdHJ1ZSBpZiBhbnkgd2FzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBlYXRTcGFjZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKVxuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHNraXBUb0VuZCgpIHsgdGhpcy5wb3MgPSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIGRpcmVjdGx5IGJlZm9yZSB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBpZiBmb3VuZCBvbiB0aGVcbiAgICBjdXJyZW50IGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG8oY2gpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xuICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBmb3VuZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYmFjayBgbmAgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIGJhY2tVcChuKSB7IHRoaXMucG9zIC09IG47IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgY29sdW1uKCkge1xuICAgICAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbCh0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgaW5kZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiBjb3VudENvbCh0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIGlucHV0IGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAod2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggYSBgXmApLiBSZXR1cm4gdHJ1ZSBvciB0aGUgcmVnZXhwIG1hdGNoXG4gICAgaWYgaXQgbWF0Y2hlcy5cbiAgICBcbiAgICBVbmxlc3MgYGNvbnN1bWVgIGlzIHNldCB0byBgZmFsc2VgLCB0aGlzIHdpbGwgbW92ZSBgdGhpcy5wb3NgXG4gICAgcGFzdCB0aGUgbWF0Y2hlZCB0ZXh0LlxuICAgIFxuICAgIFdoZW4gbWF0Y2hpbmcgYSBzdHJpbmcgYGNhc2VJbnNlbnNpdGl2ZWAgY2FuIGJlIHNldCB0byB0cnVlIHRvXG4gICAgbWFrZSB0aGUgbWF0Y2ggY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAqL1xuICAgIG1hdGNoKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IGNhc2VkID0gKHN0cikgPT4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7XG4gICAgICAgICAgICBsZXQgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2gocGF0dGVybik7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgKi9cbiAgICBjdXJyZW50KCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpOyB9XG59XG5cbmZ1bmN0aW9uIGZ1bGxQYXJzZXIoc3BlYykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBzcGVjLnRva2VuLFxuICAgICAgICBibGFua0xpbmU6IHNwZWMuYmxhbmtMaW5lIHx8ICgoKSA9PiB7IH0pLFxuICAgICAgICBzdGFydFN0YXRlOiBzcGVjLnN0YXJ0U3RhdGUgfHwgKCgpID0+IHRydWUpLFxuICAgICAgICBjb3B5U3RhdGU6IHNwZWMuY29weVN0YXRlIHx8IGRlZmF1bHRDb3B5U3RhdGUsXG4gICAgICAgIGluZGVudDogc3BlYy5pbmRlbnQgfHwgKCgpID0+IG51bGwpLFxuICAgICAgICBsYW5ndWFnZURhdGE6IHNwZWMubGFuZ3VhZ2VEYXRhIHx8IHt9LFxuICAgICAgICB0b2tlblRhYmxlOiBzcGVjLnRva2VuVGFibGUgfHwgbm9Ub2tlbnNcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENvcHlTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGxldCBuZXdTdGF0ZSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gc3RhdGUpIHtcbiAgICAgICAgbGV0IHZhbCA9IHN0YXRlW3Byb3BdO1xuICAgICAgICBuZXdTdGF0ZVtwcm9wXSA9ICh2YWwgaW5zdGFuY2VvZiBBcnJheSA/IHZhbC5zbGljZSgpIDogdmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xufVxuLyoqXG5BIFtsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgY2xhc3MgYmFzZWQgb24gYSBzdHJlYW1pbmdcbnBhcnNlci5cbiovXG5jbGFzcyBTdHJlYW1MYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBkZWZpbmVMYW5ndWFnZUZhY2V0KHBhcnNlci5sYW5ndWFnZURhdGEpO1xuICAgICAgICBsZXQgcCA9IGZ1bGxQYXJzZXIocGFyc2VyKSwgc2VsZjtcbiAgICAgICAgbGV0IGltcGwgPSBuZXcgY2xhc3MgZXh0ZW5kcyBQYXJzZXIge1xuICAgICAgICAgICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZShzZWxmLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihkYXRhLCBpbXBsLCBkb2NJRChkYXRhKSwgW2luZGVudFNlcnZpY2Uub2YoKGN4LCBwb3MpID0+IHRoaXMuZ2V0SW5kZW50KGN4LCBwb3MpKV0pO1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIgPSBwO1xuICAgICAgICB0aGlzLnN0YXRlQWZ0ZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnRva2VuVGFibGUgPSBwYXJzZXIudG9rZW5UYWJsZSA/IG5ldyBUb2tlblRhYmxlKHAudG9rZW5UYWJsZSkgOiBkZWZhdWx0VG9rZW5UYWJsZTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7IHJldHVybiBuZXcgU3RyZWFtTGFuZ3VhZ2Uoc3BlYyk7IH1cbiAgICBnZXRJbmRlbnQoY3gsIHBvcykge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoY3guc3RhdGUpLCBhdCA9IHRyZWUucmVzb2x2ZShwb3MpO1xuICAgICAgICB3aGlsZSAoYXQgJiYgYXQudHlwZSAhPSB0aGlzLnRvcE5vZGUpXG4gICAgICAgICAgICBhdCA9IGF0LnBhcmVudDtcbiAgICAgICAgaWYgKCFhdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc3RhcnQgPSBmaW5kU3RhdGUodGhpcywgdHJlZSwgMCwgYXQuZnJvbSwgcG9zKSwgc3RhdGVQb3MsIHN0YXRlO1xuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gc3RhcnQuc3RhdGU7XG4gICAgICAgICAgICBzdGF0ZVBvcyA9IHN0YXJ0LnBvcyArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoY3gudW5pdCk7XG4gICAgICAgICAgICBzdGF0ZVBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyAtIHN0YXRlUG9zID4gMTAwMDAgLyogTWF4SW5kZW50U2NhbkRpc3QgKi8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHN0YXRlUG9zIDwgcG9zKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGN4LnN0YXRlLmRvYy5saW5lQXQoc3RhdGVQb3MpLCBlbmQgPSBNYXRoLm1pbihwb3MsIGxpbmUudG8pO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZS50ZXh0LCBjeC5zdGF0ZS50YWJTaXplLCBjeC51bml0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyZWFtLnBvcyA8IGVuZCAtIGxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRva2VuKHRoaXMuc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyLmJsYW5rTGluZShzdGF0ZSwgY3gudW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXRlUG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgdGV4dCB9ID0gY3guc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1QYXJzZXIuaW5kZW50KHN0YXRlLCAvXlxccyooLiopLy5leGVjKHRleHQpWzFdLCBjeCk7XG4gICAgfVxuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmZ1bmN0aW9uIGZpbmRTdGF0ZShsYW5nLCB0cmVlLCBvZmYsIHN0YXJ0UG9zLCBiZWZvcmUpIHtcbiAgICBsZXQgc3RhdGUgPSBvZmYgPj0gc3RhcnRQb3MgJiYgb2ZmICsgdHJlZS5sZW5ndGggPD0gYmVmb3JlICYmIHRyZWUucHJvcChsYW5nLnN0YXRlQWZ0ZXIpO1xuICAgIGlmIChzdGF0ZSlcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZShzdGF0ZSksIHBvczogb2ZmICsgdHJlZS5sZW5ndGggfTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgY2hpbGQgPSB0cmVlLmNoaWxkcmVuW2ldLCBwb3MgPSBvZmYgKyB0cmVlLnBvc2l0aW9uc1tpXTtcbiAgICAgICAgbGV0IGZvdW5kID0gY2hpbGQgaW5zdGFuY2VvZiBUcmVlICYmIHBvcyA8IGJlZm9yZSAmJiBmaW5kU3RhdGUobGFuZywgY2hpbGQsIHBvcywgc3RhcnRQb3MsIGJlZm9yZSk7XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjdXRUcmVlKGxhbmcsIHRyZWUsIGZyb20sIHRvLCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlICYmIGZyb20gPD0gMCAmJiB0byA+PSB0cmVlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgaWYgKCFpbnNpZGUgJiYgdHJlZS50eXBlID09IGxhbmcudG9wTm9kZSlcbiAgICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgcG9zID0gdHJlZS5wb3NpdGlvbnNbaV0sIGNoaWxkID0gdHJlZS5jaGlsZHJlbltpXSwgaW5uZXI7XG4gICAgICAgIGlmIChwb3MgPCB0byAmJiBjaGlsZCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgIGlmICghKGlubmVyID0gY3V0VHJlZShsYW5nLCBjaGlsZCwgZnJvbSAtIHBvcywgdG8gLSBwb3MsIGluc2lkZSkpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcmV0dXJuICFpbnNpZGUgPyBpbm5lclxuICAgICAgICAgICAgICAgIDogbmV3IFRyZWUodHJlZS50eXBlLCB0cmVlLmNoaWxkcmVuLnNsaWNlKDAsIGkpLmNvbmNhdChpbm5lciksIHRyZWUucG9zaXRpb25zLnNsaWNlKDAsIGkgKyAxKSwgcG9zICsgaW5uZXIubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRTdGFydEluRnJhZ21lbnRzKGxhbmcsIGZyYWdtZW50cywgc3RhcnRQb3MsIGVkaXRvclN0YXRlKSB7XG4gICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBmLmZyb20gKyAoZi5vcGVuU3RhcnQgPyAyNSA6IDApLCB0byA9IGYudG8gLSAoZi5vcGVuRW5kID8gMjUgOiAwKTtcbiAgICAgICAgbGV0IGZvdW5kID0gZnJvbSA8PSBzdGFydFBvcyAmJiB0byA+IHN0YXJ0UG9zICYmIGZpbmRTdGF0ZShsYW5nLCBmLnRyZWUsIDAgLSBmLm9mZnNldCwgc3RhcnRQb3MsIHRvKSwgdHJlZTtcbiAgICAgICAgaWYgKGZvdW5kICYmICh0cmVlID0gY3V0VHJlZShsYW5nLCBmLnRyZWUsIHN0YXJ0UG9zICsgZi5vZmZzZXQsIGZvdW5kLnBvcyArIGYub2Zmc2V0LCBmYWxzZSkpKVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IGZvdW5kLnN0YXRlLCB0cmVlIH07XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXRlOiBsYW5nLnN0cmVhbVBhcnNlci5zdGFydFN0YXRlKGVkaXRvclN0YXRlID8gZ2V0SW5kZW50VW5pdChlZGl0b3JTdGF0ZSkgOiA0KSwgdHJlZTogVHJlZS5lbXB0eSB9O1xufVxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxhbmcsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLmxhbmcgPSBsYW5nO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gW107XG4gICAgICAgIHRoaXMuY2h1bmsgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1JldXNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy50byA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgIGxldCBjb250ZXh0ID0gUGFyc2VDb250ZXh0LmdldCgpLCBmcm9tID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIGxldCB7IHN0YXRlLCB0cmVlIH0gPSBmaW5kU3RhcnRJbkZyYWdtZW50cyhsYW5nLCBmcmFnbWVudHMsIGZyb20sIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5zdGF0ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSB0aGlzLmNodW5rU3RhcnQgPSBmcm9tICsgdHJlZS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0cmVlLnBvc2l0aW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgJiYgdGhpcy5wYXJzZWRQb3MgPCBjb250ZXh0LnZpZXdwb3J0LmZyb20gLSAxMDAwMDAgLyogTWF4RGlzdGFuY2VCZWZvcmVWaWV3cG9ydCAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBjb250ZXh0LnZpZXdwb3J0LmZyb20pO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBjb250ZXh0LnZpZXdwb3J0LmZyb207XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBQYXJzZUNvbnRleHQuZ2V0KCk7XG4gICAgICAgIGxldCBwYXJzZUVuZCA9IHRoaXMuc3RvcHBlZEF0ID09IG51bGwgPyB0aGlzLnRvIDogdGhpcy5zdG9wcGVkQXQ7XG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwYXJzZUVuZCwgdGhpcy5jaHVua1N0YXJ0ICsgMjA0OCAvKiBDaHVua1NpemUgKi8pO1xuICAgICAgICBpZiAoY29udGV4dClcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgY29udGV4dC52aWV3cG9ydC50byk7XG4gICAgICAgIHdoaWxlICh0aGlzLnBhcnNlZFBvcyA8IGVuZClcbiAgICAgICAgICAgIHRoaXMucGFyc2VMaW5lKGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgdGhpcy5wYXJzZWRQb3MpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKCk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA+PSBwYXJzZUVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiB0aGlzLnBhcnNlZFBvcyA+PSBjb250ZXh0LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNraXBVbnRpbEluVmlldyh0aGlzLnBhcnNlZFBvcywgcGFyc2VFbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIGxpbmVBZnRlcihwb3MpIHtcbiAgICAgICAgbGV0IGNodW5rID0gdGhpcy5pbnB1dC5jaHVuayhwb3MpO1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQubGluZUNodW5rcykge1xuICAgICAgICAgICAgbGV0IGVvbCA9IGNodW5rLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgICBpZiAoZW9sID4gLTEpXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5zbGljZSgwLCBlb2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNodW5rID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGNodW5rID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zICsgY2h1bmsubGVuZ3RoIDw9IHRoaXMudG8gPyBjaHVuayA6IGNodW5rLnNsaWNlKDAsIHRoaXMudG8gLSBwb3MpO1xuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnBhcnNlZFBvcywgbGluZSA9IHRoaXMubGluZUFmdGVyKGZyb20pLCBlbmQgPSBmcm9tICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5yYW5nZUluZGV4OzspIHtcbiAgICAgICAgICAgIGxldCByYW5nZUVuZCA9IHRoaXMucmFuZ2VzW2luZGV4XS50bztcbiAgICAgICAgICAgIGlmIChyYW5nZUVuZCA+PSBlbmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCByYW5nZUVuZCAtIChlbmQgLSBsaW5lLmxlbmd0aCkpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgcmFuZ2VTdGFydCA9IHRoaXMucmFuZ2VzW2luZGV4XS5mcm9tO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5saW5lQWZ0ZXIocmFuZ2VTdGFydCk7XG4gICAgICAgICAgICBsaW5lICs9IGFmdGVyO1xuICAgICAgICAgICAgZW5kID0gcmFuZ2VTdGFydCArIGFmdGVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsaW5lLCBlbmQgfTtcbiAgICB9XG4gICAgc2tpcEdhcHNUbyhwb3MsIG9mZnNldCwgc2lkZSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4XS50bywgb2ZmUG9zID0gcG9zICsgb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHNpZGUgPiAwID8gZW5kID4gb2ZmUG9zIDogZW5kID49IG9mZlBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XS5mcm9tO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0YXJ0IC0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIGVtaXRUb2tlbihpZCwgZnJvbSwgdG8sIHNpemUsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKGZyb20sIG9mZnNldCwgMSk7XG4gICAgICAgICAgICBmcm9tICs9IG9mZnNldDtcbiAgICAgICAgICAgIGxldCBsZW4wID0gdGhpcy5jaHVuay5sZW5ndGg7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8odG8sIG9mZnNldCwgLTEpO1xuICAgICAgICAgICAgdG8gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLmNodW5rLmxlbmd0aCAtIGxlbjA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVuay5wdXNoKGlkLCBmcm9tLCB0bywgc2l6ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIHBhcnNlTGluZShjb250ZXh0KSB7XG4gICAgICAgIGxldCB7IGxpbmUsIGVuZCB9ID0gdGhpcy5uZXh0TGluZSgpLCBvZmZzZXQgPSAwLCB7IHN0cmVhbVBhcnNlciB9ID0gdGhpcy5sYW5nO1xuICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLCBjb250ZXh0ID8gY29udGV4dC5zdGF0ZS50YWJTaXplIDogNCwgY29udGV4dCA/IGdldEluZGVudFVuaXQoY29udGV4dC5zdGF0ZSkgOiAyKTtcbiAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgc3RyZWFtUGFyc2VyLmJsYW5rTGluZSh0aGlzLnN0YXRlLCBzdHJlYW0uaW5kZW50VW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHJlYWRUb2tlbihzdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmVtaXRUb2tlbih0aGlzLmxhbmcudG9rZW5UYWJsZS5yZXNvbHZlKHRva2VuKSwgdGhpcy5wYXJzZWRQb3MgKyBzdHJlYW0uc3RhcnQsIHRoaXMucGFyc2VkUG9zICsgc3RyZWFtLnBvcywgNCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnN0YXJ0ID4gMTAwMDAgLyogTWF4TGluZUxlbmd0aCAqLylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBlbmQ7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA8IHRoaXMudG8pXG4gICAgICAgICAgICB0aGlzLnBhcnNlZFBvcysrO1xuICAgIH1cbiAgICBmaW5pc2hDaHVuaygpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBUcmVlLmJ1aWxkKHtcbiAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy5jaHVuayxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmNodW5rU3RhcnQsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMucGFyc2VkUG9zIC0gdGhpcy5jaHVua1N0YXJ0LFxuICAgICAgICAgICAgbm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiAwLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiAyMDQ4IC8qIENodW5rU2l6ZSAqLyxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5jaHVua1JldXNlZFxuICAgICAgICB9KTtcbiAgICAgICAgdHJlZSA9IG5ldyBUcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbiwgdHJlZS5wb3NpdGlvbnMsIHRyZWUubGVuZ3RoLCBbW3RoaXMubGFuZy5zdGF0ZUFmdGVyLCB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZSh0aGlzLnN0YXRlKV1dKTtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCAtIHRoaXMucmFuZ2VzWzBdLmZyb20pO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IHRoaXMucGFyc2VkUG9zO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLmxhbmcudG9wTm9kZSwgdGhpcy5jaHVua3MsIHRoaXMuY2h1bmtQb3MsIHRoaXMucGFyc2VkUG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSkuYmFsYW5jZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlYWRUb2tlbih0b2tlbiwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0cmVhbS5wb3MgPiBzdHJlYW0uc3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gcGFyc2VyIGZhaWxlZCB0byBhZHZhbmNlIHN0cmVhbS5cIik7XG59XG5jb25zdCBub1Rva2VucyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgdHlwZUFycmF5ID0gW05vZGVUeXBlLm5vbmVdO1xuY29uc3Qgbm9kZVNldCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVNldCh0eXBlQXJyYXkpO1xuY29uc3Qgd2FybmVkID0gW107XG5jb25zdCBkZWZhdWx0VGFibGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZvciAobGV0IFtsZWdhY3lOYW1lLCBuYW1lXSBvZiBbXG4gICAgW1widmFyaWFibGVcIiwgXCJ2YXJpYWJsZU5hbWVcIl0sXG4gICAgW1widmFyaWFibGUtMlwiLCBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCJdLFxuICAgIFtcInN0cmluZy0yXCIsIFwic3RyaW5nLnNwZWNpYWxcIl0sXG4gICAgW1wiZGVmXCIsIFwidmFyaWFibGVOYW1lLmRlZmluaXRpb25cIl0sXG4gICAgW1widGFnXCIsIFwidHlwZU5hbWVcIl0sXG4gICAgW1wiYXR0cmlidXRlXCIsIFwicHJvcGVydHlOYW1lXCJdLFxuICAgIFtcInR5cGVcIiwgXCJ0eXBlTmFtZVwiXSxcbiAgICBbXCJidWlsdGluXCIsIFwidmFyaWFibGVOYW1lLnN0YW5kYXJkXCJdLFxuICAgIFtcInF1YWxpZmllclwiLCBcIm1vZGlmaWVyXCJdLFxuICAgIFtcImVycm9yXCIsIFwiaW52YWxpZFwiXSxcbiAgICBbXCJoZWFkZXJcIiwgXCJoZWFkaW5nXCJdLFxuICAgIFtcInByb3BlcnR5XCIsIFwicHJvcGVydHlOYW1lXCJdXG5dKVxuICAgIGRlZmF1bHRUYWJsZVtsZWdhY3lOYW1lXSA9IC8qQF9fUFVSRV9fKi9jcmVhdGVUb2tlblR5cGUobm9Ub2tlbnMsIG5hbWUpO1xuY2xhc3MgVG9rZW5UYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZXh0cmEpIHtcbiAgICAgICAgdGhpcy5leHRyYSA9IGV4dHJhO1xuICAgICAgICB0aGlzLnRhYmxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBkZWZhdWx0VGFibGUpO1xuICAgIH1cbiAgICByZXNvbHZlKHRhZykge1xuICAgICAgICByZXR1cm4gIXRhZyA/IDAgOiB0aGlzLnRhYmxlW3RhZ10gfHwgKHRoaXMudGFibGVbdGFnXSA9IGNyZWF0ZVRva2VuVHlwZSh0aGlzLmV4dHJhLCB0YWcpKTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0VG9rZW5UYWJsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVG9rZW5UYWJsZShub1Rva2Vucyk7XG5mdW5jdGlvbiB3YXJuRm9yUGFydChwYXJ0LCBtc2cpIHtcbiAgICBpZiAod2FybmVkLmluZGV4T2YocGFydCkgPiAtMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHdhcm5lZC5wdXNoKHBhcnQpO1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5UeXBlKGV4dHJhLCB0YWdTdHIpIHtcbiAgICBsZXQgdGFnID0gbnVsbDtcbiAgICBmb3IgKGxldCBwYXJ0IG9mIHRhZ1N0ci5zcGxpdChcIi5cIikpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gKGV4dHJhW3BhcnRdIHx8IHRhZ3NbcGFydF0pO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgVW5rbm93biBoaWdobGlnaHRpbmcgdGFnICR7cGFydH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoIXRhZylcbiAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgTW9kaWZpZXIgJHtwYXJ0fSB1c2VkIGF0IHN0YXJ0IG9mIHRhZ2ApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhZyA9IHZhbHVlKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGFnKVxuICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBUYWcgJHtwYXJ0fSB1c2VkIGFzIG1vZGlmaWVyYCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFnID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0YWcpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGxldCBuYW1lID0gdGFnU3RyLnJlcGxhY2UoLyAvZywgXCJfXCIpLCB0eXBlID0gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgaWQ6IHR5cGVBcnJheS5sZW5ndGgsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHByb3BzOiBbc3R5bGVUYWdzKHsgW25hbWVdOiB0YWcgfSldXG4gICAgfSk7XG4gICAgdHlwZUFycmF5LnB1c2godHlwZSk7XG4gICAgcmV0dXJuIHR5cGUuaWQ7XG59XG5mdW5jdGlvbiBkb2NJRChkYXRhKSB7XG4gICAgbGV0IHR5cGUgPSBOb2RlVHlwZS5kZWZpbmUoeyBpZDogdHlwZUFycmF5Lmxlbmd0aCwgbmFtZTogXCJEb2N1bWVudFwiLCBwcm9wczogW2xhbmd1YWdlRGF0YVByb3AuYWRkKCgpID0+IGRhdGEpXSB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IHsgU3RyZWFtTGFuZ3VhZ2UsIFN0cmluZ1N0cmVhbSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/stream-parser/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/tooltip/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@codemirror/tooltip/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"closeHoverTooltips\": function() { return /* binding */ closeHoverTooltips; },\n/* harmony export */   \"getTooltip\": function() { return /* binding */ getTooltip; },\n/* harmony export */   \"hasHoverTooltips\": function() { return /* binding */ hasHoverTooltips; },\n/* harmony export */   \"hoverTooltip\": function() { return /* binding */ hoverTooltip; },\n/* harmony export */   \"repositionTooltips\": function() { return /* binding */ repositionTooltips; },\n/* harmony export */   \"showTooltip\": function() { return /* binding */ showTooltip; },\n/* harmony export */   \"tooltips\": function() { return /* binding */ tooltips; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar ios = typeof navigator != \"undefined\" && ! /*@__PURE__*/ /Edge\\/(\\d+)/.exec(navigator.userAgent) && /*@__PURE__*/ /Apple Computer/.test(navigator.vendor) && ( /*@__PURE__*/ /Mobile\\/\\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);\nvar Outside = \"-10000px\";\n\nvar TooltipViewManager = /*#__PURE__*/function () {\n  function TooltipViewManager(view, facet, createTooltipView) {\n    _classCallCheck(this, TooltipViewManager);\n\n    this.facet = facet;\n    this.createTooltipView = createTooltipView;\n    this.input = view.state.facet(facet);\n    this.tooltips = this.input.filter(function (t) {\n      return t;\n    });\n    this.tooltipViews = this.tooltips.map(createTooltipView);\n  }\n\n  _createClass(TooltipViewManager, [{\n    key: \"update\",\n    value: function update(_update) {\n      var input = _update.state.facet(this.facet);\n\n      var tooltips = input.filter(function (x) {\n        return x;\n      });\n\n      if (input === this.input) {\n        var _iterator = _createForOfIteratorHelper(this.tooltipViews),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var t = _step.value;\n            if (t.update) t.update(_update);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return false;\n      }\n\n      var tooltipViews = [];\n\n      for (var i = 0; i < tooltips.length; i++) {\n        var tip = tooltips[i],\n            known = -1;\n        if (!tip) continue;\n\n        for (var _i = 0; _i < this.tooltips.length; _i++) {\n          var other = this.tooltips[_i];\n          if (other && other.create == tip.create) known = _i;\n        }\n\n        if (known < 0) {\n          tooltipViews[i] = this.createTooltipView(tip);\n        } else {\n          var tooltipView = tooltipViews[i] = this.tooltipViews[known];\n          if (tooltipView.update) tooltipView.update(_update);\n        }\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this.tooltipViews),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _t = _step2.value;\n          if (tooltipViews.indexOf(_t) < 0) _t.dom.remove();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this.input = input;\n      this.tooltips = tooltips;\n      this.tooltipViews = tooltipViews;\n      return true;\n    }\n  }]);\n\n  return TooltipViewManager;\n}();\n/**\nReturn an extension that configures tooltip behavior.\n*/\n\n\nfunction tooltips() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return tooltipConfig.of(config);\n}\n\nfunction windowSpace() {\n  return {\n    top: 0,\n    left: 0,\n    bottom: innerHeight,\n    right: innerWidth\n  };\n}\n\nvar tooltipConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({\n  combine: function combine(values) {\n    var _a, _b, _c;\n\n    return {\n      position: ios ? \"absolute\" : ((_a = values.find(function (conf) {\n        return conf.position;\n      })) === null || _a === void 0 ? void 0 : _a.position) || \"fixed\",\n      parent: ((_b = values.find(function (conf) {\n        return conf.parent;\n      })) === null || _b === void 0 ? void 0 : _b.parent) || null,\n      tooltipSpace: ((_c = values.find(function (conf) {\n        return conf.tooltipSpace;\n      })) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace\n    };\n  }\n});\nvar tooltipPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    var _this = this;\n\n    _classCallCheck(this, _class);\n\n    var _a;\n\n    this.view = view;\n    this.inView = true;\n    this.lastTransaction = 0;\n    this.measureTimeout = -1;\n    var config = view.state.facet(tooltipConfig);\n    this.position = config.position;\n    this.parent = config.parent;\n    this.classes = view.themeClasses;\n    this.createContainer();\n    this.measureReq = {\n      read: this.readMeasure.bind(this),\n      write: this.writeMeasure.bind(this),\n      key: this\n    };\n    this.manager = new TooltipViewManager(view, showTooltip, function (t) {\n      return _this.createTooltip(t);\n    });\n    this.intersectionObserver = typeof IntersectionObserver == \"function\" ? new IntersectionObserver(function (entries) {\n      if (Date.now() > _this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) _this.measureSoon();\n    }, {\n      threshold: [1]\n    }) : null;\n    this.observeIntersection();\n    (_a = view.dom.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.addEventListener(\"resize\", this.measureSoon = this.measureSoon.bind(this));\n    this.maybeMeasure();\n  }\n\n  _createClass(_class, [{\n    key: \"createContainer\",\n    value: function createContainer() {\n      if (this.parent) {\n        this.container = document.createElement(\"div\");\n        this.container.style.position = \"relative\";\n        this.container.className = this.view.themeClasses;\n        this.parent.appendChild(this.container);\n      } else {\n        this.container = this.view.dom;\n      }\n    }\n  }, {\n    key: \"observeIntersection\",\n    value: function observeIntersection() {\n      if (this.intersectionObserver) {\n        this.intersectionObserver.disconnect();\n\n        var _iterator3 = _createForOfIteratorHelper(this.manager.tooltipViews),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var tooltip = _step3.value;\n            this.intersectionObserver.observe(tooltip.dom);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  }, {\n    key: \"measureSoon\",\n    value: function measureSoon() {\n      var _this2 = this;\n\n      if (this.measureTimeout < 0) this.measureTimeout = setTimeout(function () {\n        _this2.measureTimeout = -1;\n\n        _this2.maybeMeasure();\n      }, 50);\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update2) {\n      if (_update2.transactions.length) this.lastTransaction = Date.now();\n      var updated = this.manager.update(_update2);\n      if (updated) this.observeIntersection();\n      var shouldMeasure = updated || _update2.geometryChanged;\n\n      var newConfig = _update2.state.facet(tooltipConfig);\n\n      if (newConfig.position != this.position) {\n        this.position = newConfig.position;\n\n        var _iterator4 = _createForOfIteratorHelper(this.manager.tooltipViews),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var t = _step4.value;\n            t.dom.style.position = this.position;\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        shouldMeasure = true;\n      }\n\n      if (newConfig.parent != this.parent) {\n        if (this.parent) this.container.remove();\n        this.parent = newConfig.parent;\n        this.createContainer();\n\n        var _iterator5 = _createForOfIteratorHelper(this.manager.tooltipViews),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _t2 = _step5.value;\n            this.container.appendChild(_t2.dom);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        shouldMeasure = true;\n      } else if (this.parent && this.view.themeClasses != this.classes) {\n        this.classes = this.container.className = this.view.themeClasses;\n      }\n\n      if (shouldMeasure) this.maybeMeasure();\n    }\n  }, {\n    key: \"createTooltip\",\n    value: function createTooltip(tooltip) {\n      var tooltipView = tooltip.create(this.view);\n      tooltipView.dom.classList.add(\"cm-tooltip\");\n\n      if (tooltip.arrow && !tooltipView.dom.querySelector(\"cm-tooltip > cm-tooltip-arrow\")) {\n        var arrow = document.createElement(\"div\");\n        arrow.className = \"cm-tooltip-arrow\";\n        tooltipView.dom.appendChild(arrow);\n      }\n\n      tooltipView.dom.style.position = this.position;\n      tooltipView.dom.style.top = Outside;\n      this.container.appendChild(tooltipView.dom);\n      if (tooltipView.mount) tooltipView.mount(this.view);\n      return tooltipView;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _a, _b;\n\n      (_a = this.view.dom.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"resize\", this.measureSoon);\n\n      var _iterator6 = _createForOfIteratorHelper(this.manager.tooltipViews),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var dom = _step6.value.dom;\n          dom.remove();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n      clearTimeout(this.measureTimeout);\n    }\n  }, {\n    key: \"readMeasure\",\n    value: function readMeasure() {\n      var _this3 = this;\n\n      var editor = this.view.dom.getBoundingClientRect();\n      return {\n        editor: editor,\n        parent: this.parent ? this.container.getBoundingClientRect() : editor,\n        pos: this.manager.tooltips.map(function (t) {\n          return _this3.view.coordsAtPos(t.pos);\n        }),\n        size: this.manager.tooltipViews.map(function (_ref) {\n          var dom = _ref.dom;\n          return dom.getBoundingClientRect();\n        }),\n        space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)\n      };\n    }\n  }, {\n    key: \"writeMeasure\",\n    value: function writeMeasure(measured) {\n      var editor = measured.editor,\n          space = measured.space;\n      var others = [];\n\n      for (var i = 0; i < this.manager.tooltips.length; i++) {\n        var tooltip = this.manager.tooltips[i],\n            tView = this.manager.tooltipViews[i],\n            dom = tView.dom;\n        var pos = measured.pos[i],\n            size = measured.size[i]; // Hide tooltips that are outside of the editor.\n\n        if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right <= Math.max(editor.left, space.left) || pos.left >= Math.min(editor.right, space.right)) {\n          dom.style.top = Outside;\n          continue;\n        }\n\n        var arrow = tooltip.arrow ? tView.dom.querySelector(\".cm-tooltip-arrow\") : null;\n        var arrowHeight = arrow ? 7\n        /* Size */\n        : 0;\n        var width = size.right - size.left,\n            height = size.bottom - size.top;\n        var offset = tView.offset || noOffset,\n            ltr = this.view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Direction.LTR;\n        var left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14\n        /* Offset */\n        : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14\n        /* Offset */\n        : 0) - offset.x);\n        var above = !!tooltip.above;\n        if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = !above;\n        var top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;\n        var right = left + width;\n\n        if (tView.overlap !== true) {\n          var _iterator7 = _createForOfIteratorHelper(others),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var r = _step7.value;\n              if (r.left < right && r.right > left && r.top < top + height && r.bottom > top) top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n\n        if (this.position == \"absolute\") {\n          dom.style.top = top - measured.parent.top + \"px\";\n          dom.style.left = left - measured.parent.left + \"px\";\n        } else {\n          dom.style.top = top + \"px\";\n          dom.style.left = left + \"px\";\n        }\n\n        if (arrow) arrow.style.left = \"\".concat(pos.left + (ltr ? offset.x : -offset.x) - (left + 14\n        /* Offset */\n        - 7\n        /* Size */\n        ), \"px\");\n        if (tView.overlap !== true) others.push({\n          left: left,\n          top: top,\n          right: right,\n          bottom: top + height\n        });\n        dom.classList.toggle(\"cm-tooltip-above\", above);\n        dom.classList.toggle(\"cm-tooltip-below\", !above);\n        if (tView.positioned) tView.positioned();\n      }\n    }\n  }, {\n    key: \"maybeMeasure\",\n    value: function maybeMeasure() {\n      if (this.manager.tooltips.length) {\n        if (this.view.inView) this.view.requestMeasure(this.measureReq);\n\n        if (this.inView != this.view.inView) {\n          this.inView = this.view.inView;\n\n          if (!this.inView) {\n            var _iterator8 = _createForOfIteratorHelper(this.manager.tooltipViews),\n                _step8;\n\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var tv = _step8.value;\n                tv.dom.style.top = Outside;\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return _class;\n}(), {\n  eventHandlers: {\n    scroll: function scroll() {\n      this.maybeMeasure();\n    }\n  }\n});\nvar baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n  \".cm-tooltip\": {\n    zIndex: 100\n  },\n  \"&light .cm-tooltip\": {\n    border: \"1px solid #bbb\",\n    backgroundColor: \"#f5f5f5\"\n  },\n  \"&light .cm-tooltip-section:not(:first-child)\": {\n    borderTop: \"1px solid #bbb\"\n  },\n  \"&dark .cm-tooltip\": {\n    backgroundColor: \"#333338\",\n    color: \"white\"\n  },\n  \".cm-tooltip-arrow\": {\n    height: \"\".concat(7\n    /* Size */\n    , \"px\"),\n    width: \"\".concat(7\n    /* Size */\n    * 2, \"px\"),\n    position: \"absolute\",\n    zIndex: -1,\n    overflow: \"hidden\",\n    \"&:before, &:after\": {\n      content: \"''\",\n      position: \"absolute\",\n      width: 0,\n      height: 0,\n      borderLeft: \"\".concat(7\n      /* Size */\n      , \"px solid transparent\"),\n      borderRight: \"\".concat(7\n      /* Size */\n      , \"px solid transparent\")\n    },\n    \".cm-tooltip-above &\": {\n      bottom: \"-\".concat(7\n      /* Size */\n      , \"px\"),\n      \"&:before\": {\n        borderTop: \"\".concat(7\n        /* Size */\n        , \"px solid #bbb\")\n      },\n      \"&:after\": {\n        borderTop: \"\".concat(7\n        /* Size */\n        , \"px solid #f5f5f5\"),\n        bottom: \"1px\"\n      }\n    },\n    \".cm-tooltip-below &\": {\n      top: \"-\".concat(7\n      /* Size */\n      , \"px\"),\n      \"&:before\": {\n        borderBottom: \"\".concat(7\n        /* Size */\n        , \"px solid #bbb\")\n      },\n      \"&:after\": {\n        borderBottom: \"\".concat(7\n        /* Size */\n        , \"px solid #f5f5f5\"),\n        top: \"1px\"\n      }\n    }\n  },\n  \"&dark .cm-tooltip .cm-tooltip-arrow\": {\n    \"&:before\": {\n      borderTopColor: \"#333338\",\n      borderBottomColor: \"#333338\"\n    },\n    \"&:after\": {\n      borderTopColor: \"transparent\",\n      borderBottomColor: \"transparent\"\n    }\n  }\n});\nvar noOffset = {\n  x: 0,\n  y: 0\n};\n/**\nBehavior by which an extension can provide a tooltip to be shown.\n*/\n\nvar showTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({\n  enables: [tooltipPlugin, baseTheme]\n});\nvar showHoverTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();\n\nvar HoverTooltipHost = /*#__PURE__*/function () {\n  function HoverTooltipHost(view) {\n    var _this4 = this;\n\n    _classCallCheck(this, HoverTooltipHost);\n\n    this.view = view;\n    this.mounted = false;\n    this.dom = document.createElement(\"div\");\n    this.dom.classList.add(\"cm-tooltip-hover\");\n    this.manager = new TooltipViewManager(view, showHoverTooltip, function (t) {\n      return _this4.createHostedView(t);\n    });\n  } // Needs to be static so that host tooltip instances always match\n\n\n  _createClass(HoverTooltipHost, [{\n    key: \"createHostedView\",\n    value: function createHostedView(tooltip) {\n      var hostedView = tooltip.create(this.view);\n      hostedView.dom.classList.add(\"cm-tooltip-section\");\n      this.dom.appendChild(hostedView.dom);\n      if (this.mounted && hostedView.mount) hostedView.mount(this.view);\n      return hostedView;\n    }\n  }, {\n    key: \"mount\",\n    value: function mount(view) {\n      var _iterator9 = _createForOfIteratorHelper(this.manager.tooltipViews),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var hostedView = _step9.value;\n          if (hostedView.mount) hostedView.mount(view);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      this.mounted = true;\n    }\n  }, {\n    key: \"positioned\",\n    value: function positioned() {\n      var _iterator10 = _createForOfIteratorHelper(this.manager.tooltipViews),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var hostedView = _step10.value;\n          if (hostedView.positioned) hostedView.positioned();\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update3) {\n      this.manager.update(_update3);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(view) {\n      return new HoverTooltipHost(view);\n    }\n  }]);\n\n  return HoverTooltipHost;\n}();\n\nvar showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], function (state) {\n  var tooltips = state.facet(showHoverTooltip).filter(function (t) {\n    return t;\n  });\n  if (tooltips.length === 0) return null;\n  return {\n    pos: Math.min.apply(Math, _toConsumableArray(tooltips.map(function (t) {\n      return t.pos;\n    }))),\n    end: Math.max.apply(Math, _toConsumableArray(tooltips.filter(function (t) {\n      return t.end != null;\n    }).map(function (t) {\n      return t.end;\n    }))),\n    create: HoverTooltipHost.create,\n    above: tooltips[0].above,\n    arrow: tooltips.some(function (t) {\n      return t.arrow;\n    })\n  };\n});\n\nvar HoverPlugin = /*#__PURE__*/function () {\n  function HoverPlugin(view, source, field, setHover, hoverTime) {\n    _classCallCheck(this, HoverPlugin);\n\n    this.view = view;\n    this.source = source;\n    this.field = field;\n    this.setHover = setHover;\n    this.hoverTime = hoverTime;\n    this.hoverTimeout = -1;\n    this.restartTimeout = -1;\n    this.pending = null;\n    this.lastMove = {\n      x: 0,\n      y: 0,\n      target: view.dom,\n      time: 0\n    };\n    this.checkHover = this.checkHover.bind(this);\n    view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n    view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n  }\n\n  _createClass(HoverPlugin, [{\n    key: \"update\",\n    value: function update() {\n      var _this5 = this;\n\n      if (this.pending) {\n        this.pending = null;\n        clearTimeout(this.restartTimeout);\n        this.restartTimeout = setTimeout(function () {\n          return _this5.startHover();\n        }, 20);\n      }\n    }\n  }, {\n    key: \"active\",\n    get: function get() {\n      return this.view.state.field(this.field);\n    }\n  }, {\n    key: \"checkHover\",\n    value: function checkHover() {\n      this.hoverTimeout = -1;\n      if (this.active) return;\n      var hovered = Date.now() - this.lastMove.time;\n      if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);else this.startHover();\n    }\n  }, {\n    key: \"startHover\",\n    value: function startHover() {\n      var _this6 = this;\n\n      var _a;\n\n      clearTimeout(this.restartTimeout);\n      var lastMove = this.lastMove;\n      var pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;\n      if (pos == null) return;\n      var posCoords = this.view.coordsAtPos(pos);\n      if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth) return;\n      var bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find(function (s) {\n        return s.from <= pos && s.to >= pos;\n      });\n      var rtl = bidi && bidi.dir == _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Direction.RTL ? -1 : 1;\n      var open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);\n\n      if ((_a = open) === null || _a === void 0 ? void 0 : _a.then) {\n        var pending = this.pending = {\n          pos: pos\n        };\n        open.then(function (result) {\n          if (_this6.pending == pending) {\n            _this6.pending = null;\n            if (result) _this6.view.dispatch({\n              effects: _this6.setHover.of(result)\n            });\n          }\n        }, function (e) {\n          return (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.logException)(_this6.view.state, e, \"hover tooltip\");\n        });\n      } else if (open) {\n        this.view.dispatch({\n          effects: this.setHover.of(open)\n        });\n      }\n    }\n  }, {\n    key: \"mousemove\",\n    value: function mousemove(event) {\n      var _a;\n\n      this.lastMove = {\n        x: event.clientX,\n        y: event.clientY,\n        target: event.target,\n        time: Date.now()\n      };\n      if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);\n      var tooltip = this.active;\n\n      if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {\n        var _ref2 = tooltip || this.pending,\n            pos = _ref2.pos,\n            end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;\n\n        if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6\n        /* MaxDist */\n        )) {\n          this.view.dispatch({\n            effects: this.setHover.of(null)\n          });\n          this.pending = null;\n        }\n      }\n    }\n  }, {\n    key: \"mouseleave\",\n    value: function mouseleave() {\n      clearTimeout(this.hoverTimeout);\n      this.hoverTimeout = -1;\n      if (this.active) this.view.dispatch({\n        effects: this.setHover.of(null)\n      });\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      clearTimeout(this.hoverTimeout);\n      this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n      this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n    }\n  }]);\n\n  return HoverPlugin;\n}();\n\nfunction isInTooltip(elt) {\n  for (var cur = elt; cur; cur = cur.parentNode) {\n    if (cur.nodeType == 1 && cur.classList.contains(\"cm-tooltip\")) return true;\n  }\n\n  return false;\n}\n\nfunction isOverRange(view, from, to, x, y, margin) {\n  var range = document.createRange();\n  var fromDOM = view.domAtPos(from),\n      toDOM = view.domAtPos(to);\n  range.setEnd(toDOM.node, toDOM.offset);\n  range.setStart(fromDOM.node, fromDOM.offset);\n  var rects = range.getClientRects();\n  range.detach();\n\n  for (var i = 0; i < rects.length; i++) {\n    var rect = rects[i];\n    var dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);\n    if (dist <= margin) return true;\n  }\n\n  return false;\n}\n/**\nEnable a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos` return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer isâ€”it will be -1 if the\npointer is before the position, 1 if after the position.\n\nNote that all hover tooltips are hosted within a single tooltip\ncontainer element. This allows multiple tooltips over the same\nrange to be \"merged\" together without overlapping.\n*/\n\n\nfunction hoverTooltip(source) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define();\n  var hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({\n    create: function create() {\n      return null;\n    },\n    update: function update(value, tr) {\n      if (value && options.hideOnChange && (tr.docChanged || tr.selection)) return null;\n\n      var _iterator11 = _createForOfIteratorHelper(tr.effects),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var effect = _step11.value;\n          if (effect.is(setHover)) return effect.value;\n          if (effect.is(closeHoverTooltipEffect)) return null;\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      if (value && tr.docChanged) {\n        var newPos = tr.changes.mapPos(value.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.MapMode.TrackDel);\n        if (newPos == null) return null;\n        var copy = Object.assign(Object.create(null), value);\n        copy.pos = newPos;\n        if (value.end != null) copy.end = tr.changes.mapPos(value.end);\n        return copy;\n      }\n\n      return value;\n    },\n    provide: function provide(f) {\n      return showHoverTooltip.from(f);\n    }\n  });\n  var hoverTime = options.hoverTime || 600\n  /* Time */\n  ;\n  return [hoverState, _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.define(function (view) {\n    return new HoverPlugin(view, source, hoverState, setHover, hoverTime);\n  }), showHoverTooltipHost];\n}\n/**\nGet the active tooltip view for a given tooltip, if available.\n*/\n\n\nfunction getTooltip(view, tooltip) {\n  var plugin = view.plugin(tooltipPlugin);\n  if (!plugin) return null;\n  var found = plugin.manager.tooltips.indexOf(tooltip);\n  return found < 0 ? null : plugin.manager.tooltipViews[found];\n}\n/**\nReturns true if any hover tooltips are currently active.\n*/\n\n\nfunction hasHoverTooltips(state) {\n  return state.facet(showHoverTooltip).some(function (x) {\n    return x;\n  });\n}\n\nvar closeHoverTooltipEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define();\n/**\nTransaction effect that closes all hover tooltips.\n*/\n\nvar closeHoverTooltips = /*@__PURE__*/closeHoverTooltipEffect.of(null);\n/**\nTell the tooltip extension to recompute the position of the active\ntooltips. This can be useful when something happens (such as a\nre-positioning or CSS change affecting the editor) that could\ninvalidate the existing tooltip positions.\n*/\n\nfunction repositionTooltips(view) {\n  var _a;\n\n  (_a = view.plugin(tooltipPlugin)) === null || _a === void 0 ? void 0 : _a.maybeMeasure();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvdG9vbHRpcC9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUVBO0FBR0E7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUEzQkE7QUFBQTs7QUFBQTtBQTRCQTtBQUFBO0FBQ0E7QUFEQTtBQTVCQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFIQTtBQUtBO0FBUkE7QUFVQTtBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF0QkE7QUFBQTtBQUFBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWpDQTtBQUFBO0FBQUE7QUFtQ0E7QUFDQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQXhDQTtBQUFBO0FBQUE7QUF5Q0E7O0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUEvQ0E7QUFBQTtBQUFBO0FBaURBO0FBRUE7QUFDQTtBQUVBOztBQUNBOztBQUNBO0FBQ0E7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQURBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUpBO0FBQUE7O0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFEQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBT0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFFQTtBQTVFQTtBQUFBO0FBQUE7QUE4RUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQTNGQTtBQUFBO0FBQUE7QUE2RkE7O0FBQ0E7O0FBRkE7QUFBQTs7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQURBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFLQTtBQUNBO0FBQ0E7QUFuR0E7QUFBQTtBQUFBO0FBb0dBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUxBO0FBT0E7QUE3R0E7QUFBQTtBQUFBO0FBK0dBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBS0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQWhLQTtBQUFBO0FBQUE7QUFrS0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBNUtBOztBQUFBO0FBQUE7QUE4S0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBTkE7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRkE7QUFMQTtBQVVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFGQTtBQUxBO0FBeEJBO0FBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBbERBO0FBNkRBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQUNBO0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBS0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBMUJBO0FBQ0E7QUFDQTs7Ozs7O0FBMEJBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBTEE7QUFPQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTs7O0FBQ0E7QUFBQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQURBOztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUF2QkE7QUF5QkE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci90b29sdGlwL2Rpc3QvaW5kZXguanM/N2NhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWaWV3UGx1Z2luLCBEaXJlY3Rpb24sIEVkaXRvclZpZXcsIGxvZ0V4Y2VwdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgRmFjZXQsIFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBNYXBNb2RlIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuXG5jb25zdCBpb3MgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiZcbiAgICAhLypAX19QVVJFX18qLy9FZGdlXFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC8qQF9fUFVSRV9fKi8vQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcikgJiZcbiAgICAoLypAX19QVVJFX18qLy9Nb2JpbGVcXC9cXHcrLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDIpO1xuY29uc3QgT3V0c2lkZSA9IFwiLTEwMDAwcHhcIjtcbmNsYXNzIFRvb2x0aXBWaWV3TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IodmlldywgZmFjZXQsIGNyZWF0ZVRvb2x0aXBWaWV3KSB7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwVmlldyA9IGNyZWF0ZVRvb2x0aXBWaWV3O1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0aGlzLmlucHV0LmZpbHRlcih0ID0+IHQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRoaXMudG9vbHRpcHMubWFwKGNyZWF0ZVRvb2x0aXBWaWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgaW5wdXQgPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhpcy5mYWNldCk7XG4gICAgICAgIGxldCB0b29sdGlwcyA9IGlucHV0LmZpbHRlcih4ID0+IHgpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgaWYgKHQudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b29sdGlwVmlld3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRpcCA9IHRvb2x0aXBzW2ldLCBrbm93biA9IC0xO1xuICAgICAgICAgICAgaWYgKCF0aXApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSB0aGlzLnRvb2x0aXBzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlciAmJiBvdGhlci5jcmVhdGUgPT0gdGlwLmNyZWF0ZSlcbiAgICAgICAgICAgICAgICAgICAga25vd24gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcodGlwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b29sdGlwVmlldyA9IHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMudG9vbHRpcFZpZXdzW2tub3duXTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcFZpZXcudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3cy5pbmRleE9mKHQpIDwgMClcbiAgICAgICAgICAgICAgICB0LmRvbS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdG9vbHRpcFZpZXdzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcblJldHVybiBhbiBleHRlbnNpb24gdGhhdCBjb25maWd1cmVzIHRvb2x0aXAgYmVoYXZpb3IuXG4qL1xuZnVuY3Rpb24gdG9vbHRpcHMoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gdG9vbHRpcENvbmZpZy5vZihjb25maWcpO1xufVxuZnVuY3Rpb24gd2luZG93U3BhY2UoKSB7XG4gICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IGlubmVySGVpZ2h0LCByaWdodDogaW5uZXJXaWR0aCB9O1xufVxuY29uc3QgdG9vbHRpcENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBpb3MgPyBcImFic29sdXRlXCIgOiAoKF9hID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBvc2l0aW9uKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvc2l0aW9uKSB8fCBcImZpeGVkXCIsXG4gICAgICAgICAgICBwYXJlbnQ6ICgoX2IgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYucGFyZW50KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcmVudCkgfHwgbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBTcGFjZTogKChfYyA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi50b29sdGlwU3BhY2UpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9vbHRpcFNwYWNlKSB8fCB3aW5kb3dTcGFjZSxcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCB0b29sdGlwUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5pblZpZXcgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBjb25maWcucG9zaXRpb247XG4gICAgICAgIHRoaXMucGFyZW50ID0gY29uZmlnLnBhcmVudDtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gdmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5yZWFkTWVhc3VyZS5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy53cml0ZU1lYXN1cmUuYmluZCh0aGlzKSwga2V5OiB0aGlzIH07XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG5ldyBUb29sdGlwVmlld01hbmFnZXIodmlldywgc2hvd1Rvb2x0aXAsIHQgPT4gdGhpcy5jcmVhdGVUb29sdGlwKHQpKTtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIgPyBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IHRoaXMubGFzdFRyYW5zYWN0aW9uIC0gNTAgJiZcbiAgICAgICAgICAgICAgICBlbnRyaWVzLmxlbmd0aCA+IDAgJiYgZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvIDwgMSlcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVTb29uKCk7XG4gICAgICAgIH0sIHsgdGhyZXNob2xkOiBbMV0gfSkgOiBudWxsO1xuICAgICAgICB0aGlzLm9ic2VydmVJbnRlcnNlY3Rpb24oKTtcbiAgICAgICAgKF9hID0gdmlldy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5tZWFzdXJlU29vbiA9IHRoaXMubWVhc3VyZVNvb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMudmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMudmlldy5kb207XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZUludGVyc2VjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9vbHRpcCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0b29sdGlwLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZVNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICBpZiAodXBkYXRlZClcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xuICAgICAgICBsZXQgc2hvdWxkTWVhc3VyZSA9IHVwZGF0ZWQgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZDtcbiAgICAgICAgbGV0IG5ld0NvbmZpZyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgaWYgKG5ld0NvbmZpZy5wb3NpdGlvbiAhPSB0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gbmV3Q29uZmlnLnBvc2l0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHQuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgICAgIHNob3VsZE1lYXN1cmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDb25maWcucGFyZW50ICE9IHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG5ld0NvbmZpZy5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHQuZG9tKTtcbiAgICAgICAgICAgIHNob3VsZE1lYXN1cmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMudmlldy50aGVtZUNsYXNzZXMgIT0gdGhpcy5jbGFzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMgPSB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRNZWFzdXJlKVxuICAgICAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICB9XG4gICAgY3JlYXRlVG9vbHRpcCh0b29sdGlwKSB7XG4gICAgICAgIGxldCB0b29sdGlwVmlldyA9IHRvb2x0aXAuY3JlYXRlKHRoaXMudmlldyk7XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcFwiKTtcbiAgICAgICAgaWYgKHRvb2x0aXAuYXJyb3cgJiYgIXRvb2x0aXBWaWV3LmRvbS5xdWVyeVNlbGVjdG9yKFwiY20tdG9vbHRpcCA+IGNtLXRvb2x0aXAtYXJyb3dcIikpIHtcbiAgICAgICAgICAgIGxldCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBhcnJvdy5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAtYXJyb3dcIjtcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3LmRvbS5hcHBlbmRDaGlsZChhcnJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRvb2x0aXBWaWV3LmRvbSk7XG4gICAgICAgIGlmICh0b29sdGlwVmlldy5tb3VudClcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiB0b29sdGlwVmlldztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgKF9hID0gdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm1lYXN1cmVTb29uKTtcbiAgICAgICAgZm9yIChsZXQgeyBkb20gfSBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgZG9tLnJlbW92ZSgpO1xuICAgICAgICAoX2IgPSB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tZWFzdXJlVGltZW91dCk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlKCkge1xuICAgICAgICBsZXQgZWRpdG9yID0gdGhpcy52aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQgPyB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IGVkaXRvcixcbiAgICAgICAgICAgIHBvczogdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLm1hcCh0ID0+IHRoaXMudmlldy5jb29yZHNBdFBvcyh0LnBvcykpLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cy5tYXAoKHsgZG9tIH0pID0+IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksXG4gICAgICAgICAgICBzcGFjZTogdGhpcy52aWV3LnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpLnRvb2x0aXBTcGFjZSh0aGlzLnZpZXcpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB3cml0ZU1lYXN1cmUobWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IHsgZWRpdG9yLCBzcGFjZSB9ID0gbWVhc3VyZWQ7XG4gICAgICAgIGxldCBvdGhlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzW2ldLCB0VmlldyA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV0sIHsgZG9tIH0gPSB0VmlldztcbiAgICAgICAgICAgIGxldCBwb3MgPSBtZWFzdXJlZC5wb3NbaV0sIHNpemUgPSBtZWFzdXJlZC5zaXplW2ldO1xuICAgICAgICAgICAgLy8gSGlkZSB0b29sdGlwcyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXG4gICAgICAgICAgICBpZiAoIXBvcyB8fCBwb3MuYm90dG9tIDw9IE1hdGgubWF4KGVkaXRvci50b3AsIHNwYWNlLnRvcCkgfHxcbiAgICAgICAgICAgICAgICBwb3MudG9wID49IE1hdGgubWluKGVkaXRvci5ib3R0b20sIHNwYWNlLmJvdHRvbSkgfHxcbiAgICAgICAgICAgICAgICBwb3MucmlnaHQgPD0gTWF0aC5tYXgoZWRpdG9yLmxlZnQsIHNwYWNlLmxlZnQpIHx8XG4gICAgICAgICAgICAgICAgcG9zLmxlZnQgPj0gTWF0aC5taW4oZWRpdG9yLnJpZ2h0LCBzcGFjZS5yaWdodCkpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhcnJvdyA9IHRvb2x0aXAuYXJyb3cgPyB0Vmlldy5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwLWFycm93XCIpIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBhcnJvd0hlaWdodCA9IGFycm93ID8gNyAvKiBTaXplICovIDogMDtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHNpemUucmlnaHQgLSBzaXplLmxlZnQsIGhlaWdodCA9IHNpemUuYm90dG9tIC0gc2l6ZS50b3A7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdFZpZXcub2Zmc2V0IHx8IG5vT2Zmc2V0LCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBzaXplLndpZHRoID4gc3BhY2UucmlnaHQgLSBzcGFjZS5sZWZ0ID8gKGx0ciA/IHNwYWNlLmxlZnQgOiBzcGFjZS5yaWdodCAtIHNpemUud2lkdGgpXG4gICAgICAgICAgICAgICAgOiBsdHIgPyBNYXRoLm1pbihwb3MubGVmdCAtIChhcnJvdyA/IDE0IC8qIE9mZnNldCAqLyA6IDApICsgb2Zmc2V0LngsIHNwYWNlLnJpZ2h0IC0gd2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIDogTWF0aC5tYXgoc3BhY2UubGVmdCwgcG9zLmxlZnQgLSB3aWR0aCArIChhcnJvdyA/IDE0IC8qIE9mZnNldCAqLyA6IDApIC0gb2Zmc2V0LngpO1xuICAgICAgICAgICAgbGV0IGFib3ZlID0gISF0b29sdGlwLmFib3ZlO1xuICAgICAgICAgICAgaWYgKCF0b29sdGlwLnN0cmljdFNpZGUgJiYgKGFib3ZlXG4gICAgICAgICAgICAgICAgPyBwb3MudG9wIC0gKHNpemUuYm90dG9tIC0gc2l6ZS50b3ApIC0gb2Zmc2V0LnkgPCBzcGFjZS50b3BcbiAgICAgICAgICAgICAgICA6IHBvcy5ib3R0b20gKyAoc2l6ZS5ib3R0b20gLSBzaXplLnRvcCkgKyBvZmZzZXQueSA+IHNwYWNlLmJvdHRvbSkgJiZcbiAgICAgICAgICAgICAgICBhYm92ZSA9PSAoc3BhY2UuYm90dG9tIC0gcG9zLmJvdHRvbSA+IHBvcy50b3AgLSBzcGFjZS50b3ApKVxuICAgICAgICAgICAgICAgIGFib3ZlID0gIWFib3ZlO1xuICAgICAgICAgICAgbGV0IHRvcCA9IGFib3ZlID8gcG9zLnRvcCAtIGhlaWdodCAtIGFycm93SGVpZ2h0IC0gb2Zmc2V0LnkgOiBwb3MuYm90dG9tICsgYXJyb3dIZWlnaHQgKyBvZmZzZXQueTtcbiAgICAgICAgICAgIGxldCByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICAgICAgICAgIGlmICh0Vmlldy5vdmVybGFwICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2Ygb3RoZXJzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoci5sZWZ0IDwgcmlnaHQgJiYgci5yaWdodCA+IGxlZnQgJiYgci50b3AgPCB0b3AgKyBoZWlnaHQgJiYgci5ib3R0b20gPiB0b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBhYm92ZSA/IHIudG9wIC0gaGVpZ2h0IC0gMiAtIGFycm93SGVpZ2h0IDogci5ib3R0b20gKyBhcnJvd0hlaWdodCArIDI7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gKHRvcCAtIG1lYXN1cmVkLnBhcmVudC50b3ApICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5sZWZ0ID0gKGxlZnQgLSBtZWFzdXJlZC5wYXJlbnQubGVmdCkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcnJvdylcbiAgICAgICAgICAgICAgICBhcnJvdy5zdHlsZS5sZWZ0ID0gYCR7cG9zLmxlZnQgKyAobHRyID8gb2Zmc2V0LnggOiAtb2Zmc2V0LngpIC0gKGxlZnQgKyAxNCAvKiBPZmZzZXQgKi8gLSA3IC8qIFNpemUgKi8pfXB4YDtcbiAgICAgICAgICAgIGlmICh0Vmlldy5vdmVybGFwICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgIG90aGVycy5wdXNoKHsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tOiB0b3AgKyBoZWlnaHQgfSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYWJvdmVcIiwgYWJvdmUpO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWJlbG93XCIsICFhYm92ZSk7XG4gICAgICAgICAgICBpZiAodFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICB0Vmlldy5wb3NpdGlvbmVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF5YmVNZWFzdXJlKCkge1xuICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnRvb2x0aXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5pblZpZXcpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pblZpZXcgIT0gdGhpcy52aWV3LmluVmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5WaWV3ID0gdGhpcy52aWV3LmluVmlldztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0diBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHYuZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICBzY3JvbGwoKSB7IHRoaXMubWF5YmVNZWFzdXJlKCk7IH1cbiAgICB9XG59KTtcbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIHpJbmRleDogMTAwXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2JiYlwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1zZWN0aW9uOm5vdCg6Zmlyc3QtY2hpbGQpXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wOiBcIjFweCBzb2xpZCAjYmJiXCIsXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIlxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcC1hcnJvd1wiOiB7XG4gICAgICAgIGhlaWdodDogYCR7NyAvKiBTaXplICovfXB4YCxcbiAgICAgICAgd2lkdGg6IGAkezcgLyogU2l6ZSAqLyAqIDJ9cHhgLFxuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICB6SW5kZXg6IC0xLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgXCImOmJlZm9yZSwgJjphZnRlclwiOiB7XG4gICAgICAgICAgICBjb250ZW50OiBcIicnXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBib3JkZXJMZWZ0OiBgJHs3IC8qIFNpemUgKi99cHggc29saWQgdHJhbnNwYXJlbnRgLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IGAkezcgLyogU2l6ZSAqL31weCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgIH0sXG4gICAgICAgIFwiLmNtLXRvb2x0aXAtYWJvdmUgJlwiOiB7XG4gICAgICAgICAgICBib3R0b206IGAtJHs3IC8qIFNpemUgKi99cHhgLFxuICAgICAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBgJHs3IC8qIFNpemUgKi99cHggc29saWQgI2JiYmAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3A6IGAkezcgLyogU2l6ZSAqL31weCBzb2xpZCAjZjVmNWY1YCxcbiAgICAgICAgICAgICAgICBib3R0b206IFwiMXB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuY20tdG9vbHRpcC1iZWxvdyAmXCI6IHtcbiAgICAgICAgICAgIHRvcDogYC0kezcgLyogU2l6ZSAqL31weGAsXG4gICAgICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAkezcgLyogU2l6ZSAqL31weCBzb2xpZCAjYmJiYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYCR7NyAvKiBTaXplICovfXB4IHNvbGlkICNmNWY1ZjVgLFxuICAgICAgICAgICAgICAgIHRvcDogXCIxcHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcCAuY20tdG9vbHRpcC1hcnJvd1wiOiB7XG4gICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgYm9yZGVyVG9wQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IFwiIzMzMzMzOFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICB9XG4gICAgfVxufSk7XG5jb25zdCBub09mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuLyoqXG5CZWhhdmlvciBieSB3aGljaCBhbiBleHRlbnNpb24gY2FuIHByb3ZpZGUgYSB0b29sdGlwIHRvIGJlIHNob3duLlxuKi9cbmNvbnN0IHNob3dUb29sdGlwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgZW5hYmxlczogW3Rvb2x0aXBQbHVnaW4sIGJhc2VUaGVtZV1cbn0pO1xuY29uc3Qgc2hvd0hvdmVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNsYXNzIEhvdmVyVG9vbHRpcEhvc3Qge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXAtaG92ZXJcIik7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG5ldyBUb29sdGlwVmlld01hbmFnZXIodmlldywgc2hvd0hvdmVyVG9vbHRpcCwgdCA9PiB0aGlzLmNyZWF0ZUhvc3RlZFZpZXcodCkpO1xuICAgIH1cbiAgICAvLyBOZWVkcyB0byBiZSBzdGF0aWMgc28gdGhhdCBob3N0IHRvb2x0aXAgaW5zdGFuY2VzIGFsd2F5cyBtYXRjaFxuICAgIHN0YXRpYyBjcmVhdGUodmlldykge1xuICAgICAgICByZXR1cm4gbmV3IEhvdmVyVG9vbHRpcEhvc3Qodmlldyk7XG4gICAgfVxuICAgIGNyZWF0ZUhvc3RlZFZpZXcodG9vbHRpcCkge1xuICAgICAgICBsZXQgaG9zdGVkVmlldyA9IHRvb2x0aXAuY3JlYXRlKHRoaXMudmlldyk7XG4gICAgICAgIGhvc3RlZFZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLXNlY3Rpb25cIik7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhvc3RlZFZpZXcuZG9tKTtcbiAgICAgICAgaWYgKHRoaXMubW91bnRlZCAmJiBob3N0ZWRWaWV3Lm1vdW50KVxuICAgICAgICAgICAgaG9zdGVkVmlldy5tb3VudCh0aGlzLnZpZXcpO1xuICAgICAgICByZXR1cm4gaG9zdGVkVmlldztcbiAgICB9XG4gICAgbW91bnQodmlldykge1xuICAgICAgICBmb3IgKGxldCBob3N0ZWRWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGlmIChob3N0ZWRWaWV3Lm1vdW50KVxuICAgICAgICAgICAgICAgIGhvc3RlZFZpZXcubW91bnQodmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcG9zaXRpb25lZCgpIHtcbiAgICAgICAgZm9yIChsZXQgaG9zdGVkVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICBpZiAoaG9zdGVkVmlldy5wb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIGhvc3RlZFZpZXcucG9zaXRpb25lZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUpO1xuICAgIH1cbn1cbmNvbnN0IHNob3dIb3ZlclRvb2x0aXBIb3N0ID0gLypAX19QVVJFX18qL3Nob3dUb29sdGlwLmNvbXB1dGUoW3Nob3dIb3ZlclRvb2x0aXBdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IHRvb2x0aXBzID0gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCkuZmlsdGVyKHQgPT4gdCk7XG4gICAgaWYgKHRvb2x0aXBzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBNYXRoLm1pbiguLi50b29sdGlwcy5tYXAodCA9PiB0LnBvcykpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KC4uLnRvb2x0aXBzLmZpbHRlcih0ID0+IHQuZW5kICE9IG51bGwpLm1hcCh0ID0+IHQuZW5kKSksXG4gICAgICAgIGNyZWF0ZTogSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUsXG4gICAgICAgIGFib3ZlOiB0b29sdGlwc1swXS5hYm92ZSxcbiAgICAgICAgYXJyb3c6IHRvb2x0aXBzLnNvbWUodCA9PiB0LmFycm93KSxcbiAgICB9O1xufSk7XG5jbGFzcyBIb3ZlclBsdWdpbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc291cmNlLCBmaWVsZCwgc2V0SG92ZXIsIGhvdmVyVGltZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLnNldEhvdmVyID0gc2V0SG92ZXI7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lID0gaG92ZXJUaW1lO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7IHg6IDAsIHk6IDAsIHRhcmdldDogdmlldy5kb20sIHRpbWU6IDAgfTtcbiAgICAgICAgdGhpcy5jaGVja0hvdmVyID0gdGhpcy5jaGVja0hvdmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSA9IHRoaXMubW91c2VsZWF2ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSA9IHRoaXMubW91c2Vtb3ZlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0SG92ZXIoKSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5maWVsZCk7XG4gICAgfVxuICAgIGNoZWNrSG92ZXIoKSB7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGhvdmVyZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0TW92ZS50aW1lO1xuICAgICAgICBpZiAoaG92ZXJlZCA8IHRoaXMuaG92ZXJUaW1lKVxuICAgICAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuY2hlY2tIb3ZlciwgdGhpcy5ob3ZlclRpbWUgLSBob3ZlcmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zdGFydEhvdmVyKCk7XG4gICAgfVxuICAgIHN0YXJ0SG92ZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzdGFydFRpbWVvdXQpO1xuICAgICAgICBsZXQgeyBsYXN0TW92ZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMudmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGxhc3RNb3ZlLnRhcmdldCkgPyB0aGlzLnZpZXcucG9zQXRDb29yZHMobGFzdE1vdmUpIDogbnVsbDtcbiAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zQ29vcmRzID0gdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgIGlmIChwb3NDb29yZHMgPT0gbnVsbCB8fCBsYXN0TW92ZS55IDwgcG9zQ29vcmRzLnRvcCB8fCBsYXN0TW92ZS55ID4gcG9zQ29vcmRzLmJvdHRvbSB8fFxuICAgICAgICAgICAgbGFzdE1vdmUueCA8IHBvc0Nvb3Jkcy5sZWZ0IC0gdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCB8fFxuICAgICAgICAgICAgbGFzdE1vdmUueCA+IHBvc0Nvb3Jkcy5yaWdodCArIHRoaXMudmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBiaWRpID0gdGhpcy52aWV3LmJpZGlTcGFucyh0aGlzLnZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpKS5maW5kKHMgPT4gcy5mcm9tIDw9IHBvcyAmJiBzLnRvID49IHBvcyk7XG4gICAgICAgIGxldCBydGwgPSBiaWRpICYmIGJpZGkuZGlyID09IERpcmVjdGlvbi5SVEwgPyAtMSA6IDE7XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5zb3VyY2UodGhpcy52aWV3LCBwb3MsIChsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgPyAtcnRsIDogcnRsKSk7XG4gICAgICAgIGlmICgoX2EgPSBvcGVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGhlbikge1xuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmcgPSB7IHBvcyB9O1xuICAgICAgICAgICAgb3Blbi50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZyA9PSBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKHJlc3VsdCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZSA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlLCBcImhvdmVyIHRvb2x0aXBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2Yob3BlbikgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2Vtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSwgdGFyZ2V0OiBldmVudC50YXJnZXQsIHRpbWU6IERhdGUubm93KCkgfTtcbiAgICAgICAgaWYgKHRoaXMuaG92ZXJUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lKTtcbiAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgaWYgKHRvb2x0aXAgJiYgIWlzSW5Ub29sdGlwKHRoaXMubGFzdE1vdmUudGFyZ2V0KSB8fCB0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIGxldCB7IHBvcyB9ID0gdG9vbHRpcCB8fCB0aGlzLnBlbmRpbmcsIGVuZCA9IChfYSA9IHRvb2x0aXAgPT09IG51bGwgfHwgdG9vbHRpcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9vbHRpcC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvcztcbiAgICAgICAgICAgIGlmICgocG9zID09IGVuZCA/IHRoaXMudmlldy5wb3NBdENvb3Jkcyh0aGlzLmxhc3RNb3ZlKSAhPSBwb3NcbiAgICAgICAgICAgICAgICA6ICFpc092ZXJSYW5nZSh0aGlzLnZpZXcsIHBvcywgZW5kLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZLCA2IC8qIE1heERpc3QgKi8pKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YobnVsbCkgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3VzZWxlYXZlKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ob3ZlclRpbWVvdXQpO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKG51bGwpIH0pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ob3ZlclRpbWVvdXQpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSk7XG4gICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNJblRvb2x0aXAoZWx0KSB7XG4gICAgZm9yIChsZXQgY3VyID0gZWx0OyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEgJiYgY3VyLmNsYXNzTGlzdC5jb250YWlucyhcImNtLXRvb2x0aXBcIikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc092ZXJSYW5nZSh2aWV3LCBmcm9tLCB0bywgeCwgeSwgbWFyZ2luKSB7XG4gICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBsZXQgZnJvbURPTSA9IHZpZXcuZG9tQXRQb3MoZnJvbSksIHRvRE9NID0gdmlldy5kb21BdFBvcyh0byk7XG4gICAgcmFuZ2Uuc2V0RW5kKHRvRE9NLm5vZGUsIHRvRE9NLm9mZnNldCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoZnJvbURPTS5ub2RlLCBmcm9tRE9NLm9mZnNldCk7XG4gICAgbGV0IHJlY3RzID0gcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICByYW5nZS5kZXRhY2goKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgIGxldCBkaXN0ID0gTWF0aC5tYXgocmVjdC50b3AgLSB5LCB5IC0gcmVjdC5ib3R0b20sIHJlY3QubGVmdCAtIHgsIHggLSByZWN0LnJpZ2h0KTtcbiAgICAgICAgaWYgKGRpc3QgPD0gbWFyZ2luKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuRW5hYmxlIGEgaG92ZXIgdG9vbHRpcCwgd2hpY2ggc2hvd3MgdXAgd2hlbiB0aGUgcG9pbnRlciBob3ZlcnNcbm92ZXIgcmFuZ2VzIG9mIHRleHQuIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgaG92ZXJzXG5vdmVyIHRoZSBkb2N1bWVudCB0ZXh0LiBJdCBzaG91bGQsIGlmIHRoZXJlIGlzIGEgdG9vbHRpcFxuYXNzb2NpYXRlZCB3aXRoIHBvc2l0aW9uIGBwb3NgIHJldHVybiB0aGUgdG9vbHRpcCBkZXNjcmlwdGlvblxuKGVpdGhlciBkaXJlY3RseSBvciBpbiBhIHByb21pc2UpLiBUaGUgYHNpZGVgIGFyZ3VtZW50IGluZGljYXRlc1xub24gd2hpY2ggc2lkZSBvZiB0aGUgcG9zaXRpb24gdGhlIHBvaW50ZXIgaXPigJRpdCB3aWxsIGJlIC0xIGlmIHRoZVxucG9pbnRlciBpcyBiZWZvcmUgdGhlIHBvc2l0aW9uLCAxIGlmIGFmdGVyIHRoZSBwb3NpdGlvbi5cblxuTm90ZSB0aGF0IGFsbCBob3ZlciB0b29sdGlwcyBhcmUgaG9zdGVkIHdpdGhpbiBhIHNpbmdsZSB0b29sdGlwXG5jb250YWluZXIgZWxlbWVudC4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgdG9vbHRpcHMgb3ZlciB0aGUgc2FtZVxucmFuZ2UgdG8gYmUgXCJtZXJnZWRcIiB0b2dldGhlciB3aXRob3V0IG92ZXJsYXBwaW5nLlxuKi9cbmZ1bmN0aW9uIGhvdmVyVG9vbHRpcChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBzZXRIb3ZlciA9IFN0YXRlRWZmZWN0LmRlZmluZSgpO1xuICAgIGxldCBob3ZlclN0YXRlID0gU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgICAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgKG9wdGlvbnMuaGlkZU9uQ2hhbmdlICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEhvdmVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXdQb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyh2YWx1ZS5wb3MsIC0xLCBNYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3UG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29weS5wb3MgPSBuZXdQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmVuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LmVuZCA9IHRyLmNoYW5nZXMubWFwUG9zKHZhbHVlLmVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGU6IGYgPT4gc2hvd0hvdmVyVG9vbHRpcC5mcm9tKGYpXG4gICAgfSk7XG4gICAgbGV0IGhvdmVyVGltZSA9IG9wdGlvbnMuaG92ZXJUaW1lIHx8IDYwMCAvKiBUaW1lICovO1xuICAgIHJldHVybiBbXG4gICAgICAgIGhvdmVyU3RhdGUsXG4gICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gbmV3IEhvdmVyUGx1Z2luKHZpZXcsIHNvdXJjZSwgaG92ZXJTdGF0ZSwgc2V0SG92ZXIsIGhvdmVyVGltZSkpLFxuICAgICAgICBzaG93SG92ZXJUb29sdGlwSG9zdFxuICAgIF07XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHRvb2x0aXAgdmlldyBmb3IgYSBnaXZlbiB0b29sdGlwLCBpZiBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZ2V0VG9vbHRpcCh2aWV3LCB0b29sdGlwKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHRvb2x0aXBQbHVnaW4pO1xuICAgIGlmICghcGx1Z2luKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZm91bmQgPSBwbHVnaW4ubWFuYWdlci50b29sdGlwcy5pbmRleE9mKHRvb2x0aXApO1xuICAgIHJldHVybiBmb3VuZCA8IDAgPyBudWxsIDogcGx1Z2luLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ZvdW5kXTtcbn1cbi8qKlxuUmV0dXJucyB0cnVlIGlmIGFueSBob3ZlciB0b29sdGlwcyBhcmUgY3VycmVudGx5IGFjdGl2ZS5cbiovXG5mdW5jdGlvbiBoYXNIb3ZlclRvb2x0aXBzKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZhY2V0KHNob3dIb3ZlclRvb2x0aXApLnNvbWUoeCA9PiB4KTtcbn1cbmNvbnN0IGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBlZmZlY3QgdGhhdCBjbG9zZXMgYWxsIGhvdmVyIHRvb2x0aXBzLlxuKi9cbmNvbnN0IGNsb3NlSG92ZXJUb29sdGlwcyA9IC8qQF9fUFVSRV9fKi9jbG9zZUhvdmVyVG9vbHRpcEVmZmVjdC5vZihudWxsKTtcbi8qKlxuVGVsbCB0aGUgdG9vbHRpcCBleHRlbnNpb24gdG8gcmVjb21wdXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgYWN0aXZlXG50b29sdGlwcy4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgKHN1Y2ggYXMgYVxucmUtcG9zaXRpb25pbmcgb3IgQ1NTIGNoYW5nZSBhZmZlY3RpbmcgdGhlIGVkaXRvcikgdGhhdCBjb3VsZFxuaW52YWxpZGF0ZSB0aGUgZXhpc3RpbmcgdG9vbHRpcCBwb3NpdGlvbnMuXG4qL1xuZnVuY3Rpb24gcmVwb3NpdGlvblRvb2x0aXBzKHZpZXcpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXliZU1lYXN1cmUoKTtcbn1cblxuZXhwb3J0IHsgY2xvc2VIb3ZlclRvb2x0aXBzLCBnZXRUb29sdGlwLCBoYXNIb3ZlclRvb2x0aXBzLCBob3ZlclRvb2x0aXAsIHJlcG9zaXRpb25Ub29sdGlwcywgc2hvd1Rvb2x0aXAsIHRvb2x0aXBzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/tooltip/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultBufferLength\": function() { return /* binding */ DefaultBufferLength; },\n/* harmony export */   \"MountedTree\": function() { return /* binding */ MountedTree; },\n/* harmony export */   \"NodeProp\": function() { return /* binding */ NodeProp; },\n/* harmony export */   \"NodeSet\": function() { return /* binding */ NodeSet; },\n/* harmony export */   \"NodeType\": function() { return /* binding */ NodeType; },\n/* harmony export */   \"Parser\": function() { return /* binding */ Parser; },\n/* harmony export */   \"Tree\": function() { return /* binding */ Tree; },\n/* harmony export */   \"TreeBuffer\": function() { return /* binding */ TreeBuffer; },\n/* harmony export */   \"TreeCursor\": function() { return /* binding */ TreeCursor; },\n/* harmony export */   \"TreeFragment\": function() { return /* binding */ TreeFragment; },\n/* harmony export */   \"parseMixed\": function() { return /* binding */ parseMixed; }\n/* harmony export */ });\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node (1024).\nvar DefaultBufferLength = 1024;\nvar nextPropID = 0;\n\nvar Range = function Range(from, to) {\n  _classCallCheck(this, Range);\n\n  this.from = from;\n  this.to = to;\n}; /// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\n\n\nvar NodeProp = /*#__PURE__*/function () {\n  /// Create a new node prop type.\n  function NodeProp() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, NodeProp);\n\n    this.id = nextPropID++;\n    this.perNode = !!config.perNode;\n\n    this.deserialize = config.deserialize || function () {\n      throw new Error(\"This node type doesn't define a deserialize function\");\n    };\n  } /// This is meant to be used with\n  /// [`NodeSet.extend`](#common.NodeSet.extend) or\n  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n  /// prop values for each node type in the set. Takes a [match\n  /// object](#common.NodeType^match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n\n\n  _createClass(NodeProp, [{\n    key: \"add\",\n    value: function add(match) {\n      var _this = this;\n\n      if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\");\n      if (typeof match != \"function\") match = NodeType.match(match);\n      return function (type) {\n        var result = match(type);\n        return result === undefined ? null : [_this, result];\n      };\n    }\n  }]);\n\n  return NodeProp;\n}(); /// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\n\n\nNodeProp.closedBy = new NodeProp({\n  deserialize: function deserialize(str) {\n    return str.split(\" \");\n  }\n}); /// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\n\nNodeProp.openedBy = new NodeProp({\n  deserialize: function deserialize(str) {\n    return str.split(\" \");\n  }\n}); /// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\n\nNodeProp.group = new NodeProp({\n  deserialize: function deserialize(str) {\n    return str.split(\" \");\n  }\n}); /// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\n\nNodeProp.contextHash = new NodeProp({\n  perNode: true\n}); /// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\n\nNodeProp.lookAhead = new NodeProp({\n  perNode: true\n}); /// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages.\n\nNodeProp.mounted = new NodeProp({\n  perNode: true\n}); /// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\n\nvar MountedTree = function MountedTree( /// The inner tree.\ntree, /// If this is null, this tree replaces the entire node (it will\n/// be included in the regular iteration instead of its host\n/// node). If not, only the given ranges are considered to be\n/// covered by this tree. This is used for trees that are mixed in\n/// a way that isn't strictly hierarchical. Such mounted trees are\n/// only entered by [`resolveInner`](#common.Tree.resolveInner)\n/// and [`enter`](#common.SyntaxNode.enter).\noverlay, /// The parser used to create this subtree.\nparser) {\n  _classCallCheck(this, MountedTree);\n\n  this.tree = tree;\n  this.overlay = overlay;\n  this.parser = parser;\n};\n\nvar noProps = Object.create(null); /// Each node in a syntax tree has a node type associated with it.\n\nvar NodeType = /*#__PURE__*/function () {\n  /// @internal\n  function NodeType( /// The name of the node type. Not necessarily unique, but if the\n  /// grammar was written properly, different node types with the\n  /// same name within a node set should play the same semantic\n  /// role.\n  name, /// @internal\n  props, /// The id of this node in its set. Corresponds to the term ids\n  /// used in the parser.\n  id) {\n    var flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    _classCallCheck(this, NodeType);\n\n    this.name = name;\n    this.props = props;\n    this.id = id;\n    this.flags = flags;\n  }\n\n  _createClass(NodeType, [{\n    key: \"prop\",\n    value: /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    function prop(_prop) {\n      return this.props[_prop.id];\n    } /// True when this is the top node of a grammar.\n\n  }, {\n    key: \"isTop\",\n    get: function get() {\n      return (this.flags & 1\n      /* Top */\n      ) > 0;\n    } /// True when this node is produced by a skip rule.\n\n  }, {\n    key: \"isSkipped\",\n    get: function get() {\n      return (this.flags & 2\n      /* Skipped */\n      ) > 0;\n    } /// Indicates whether this is an error node.\n\n  }, {\n    key: \"isError\",\n    get: function get() {\n      return (this.flags & 4\n      /* Error */\n      ) > 0;\n    } /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n\n  }, {\n    key: \"isAnonymous\",\n    get: function get() {\n      return (this.flags & 8\n      /* Anonymous */\n      ) > 0;\n    } /// Returns true when this node's name or one of its\n    /// [groups](#common.NodeProp^group) matches the given string.\n\n  }, {\n    key: \"is\",\n    value: function is(name) {\n      if (typeof name == 'string') {\n        if (this.name == name) return true;\n        var group = this.prop(NodeProp.group);\n        return group ? group.indexOf(name) > -1 : false;\n      }\n\n      return this.id == name;\n    } /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#common.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n\n  }], [{\n    key: \"define\",\n    value: function define(spec) {\n      var props = spec.props && spec.props.length ? Object.create(null) : noProps;\n      var flags = (spec.top ? 1\n      /* Top */\n      : 0) | (spec.skipped ? 2\n      /* Skipped */\n      : 0) | (spec.error ? 4\n      /* Error */\n      : 0) | (spec.name == null ? 8\n      /* Anonymous */\n      : 0);\n      var type = new NodeType(spec.name || \"\", props, spec.id, flags);\n\n      if (spec.props) {\n        var _iterator = _createForOfIteratorHelper(spec.props),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var src = _step.value;\n            if (!Array.isArray(src)) src = src(type);\n\n            if (src) {\n              if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\");\n              props[src[0].id] = src[1];\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return type;\n    }\n  }, {\n    key: \"match\",\n    value: function match(map) {\n      var direct = Object.create(null);\n\n      for (var prop in map) {\n        var _iterator2 = _createForOfIteratorHelper(prop.split(\" \")),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var name = _step2.value;\n            direct[name] = map[prop];\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return function (node) {\n        for (var groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n          var found = direct[i < 0 ? node.name : groups[i]];\n          if (found) return found;\n        }\n      };\n    }\n  }]);\n\n  return NodeType;\n}(); /// An empty dummy node type to use when no actual type is available.\n\n\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8\n/* Anonymous */\n); /// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\n\nvar NodeSet = /*#__PURE__*/function () {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  function NodeSet( /// The node types in this set, by id.\n  types) {\n    _classCallCheck(this, NodeSet);\n\n    this.types = types;\n\n    for (var i = 0; i < types.length; i++) {\n      if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n  } /// Create a copy of this set with some node properties added. The\n  /// arguments to this method should be created with\n  /// [`NodeProp.add`](#common.NodeProp.add).\n\n\n  _createClass(NodeSet, [{\n    key: \"extend\",\n    value: function extend() {\n      var newTypes = [];\n\n      for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n        props[_key] = arguments[_key];\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(this.types),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var type = _step3.value;\n          var newProps = null;\n\n          var _iterator4 = _createForOfIteratorHelper(props),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var source = _step4.value;\n              var add = source(type);\n\n              if (add) {\n                if (!newProps) newProps = Object.assign({}, type.props);\n                newProps[add[0].id] = add[1];\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return new NodeSet(newTypes);\n    }\n  }]);\n\n  return NodeSet;\n}();\n\nvar CachedNode = new WeakMap(); /// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\n\nvar Tree = /*#__PURE__*/function () {\n  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n  function Tree( /// The type of the top node.\n  type, /// This node's child nodes.\n  children, /// The positions (offsets relative to the start of this tree) of\n  /// the children.\n  positions, /// The total length of this tree\n  length, /// Per-node [node props](#common.NodeProp) to associate with this node.\n  props) {\n    _classCallCheck(this, Tree);\n\n    this.type = type;\n    this.children = children;\n    this.positions = positions;\n    this.length = length; /// @internal\n\n    this.props = null;\n\n    if (props && props.length) {\n      this.props = Object.create(null);\n\n      var _iterator5 = _createForOfIteratorHelper(props),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              prop = _step5$value[0],\n              value = _step5$value[1];\n\n          this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } /// @internal\n\n\n  _createClass(Tree, [{\n    key: \"toString\",\n    value: function toString() {\n      var mounted = this.prop(NodeProp.mounted);\n      if (mounted && !mounted.overlay) return mounted.tree.toString();\n      var children = \"\";\n\n      var _iterator6 = _createForOfIteratorHelper(this.children),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var ch = _step6.value;\n          var str = ch.toString();\n\n          if (str) {\n            if (children) children += \",\";\n            children += str;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n    } /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When\n    /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)\n    /// to the given position and side.\n\n  }, {\n    key: \"cursor\",\n    value: function cursor(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var scope = pos != null && CachedNode.get(this) || this.topNode;\n      var cursor = new TreeCursor(scope);\n\n      if (pos != null) {\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n      }\n\n      return cursor;\n    } /// Get a [tree cursor](#common.TreeCursor) that, unlike regular\n    /// cursors, doesn't skip through\n    /// [anonymous](#common.NodeType.isAnonymous) nodes.\n\n  }, {\n    key: \"fullCursor\",\n    value: function fullCursor() {\n      return new TreeCursor(this.topNode, 1\n      /* Full */\n      );\n    } /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n    /// tree.\n\n  }, {\n    key: \"topNode\",\n    get: function get() {\n      return new TreeNode(this, 0, 0, null);\n    } /// Get the [syntax node](#common.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.cursor(pos, side).node;\n    } /// Like [`resolve`](#common.Tree.resolve), but will enter\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    /// pointing into the innermost overlaid tree at the given position\n    /// (with parent links going through all parent structure, including\n    /// the host trees).\n\n  }, {\n    key: \"resolveInner\",\n    value: function resolveInner(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var result = this.topNode;\n\n      for (;;) {\n        var inner = result.enter(pos, side);\n        if (!inner) return result;\n        result = inner;\n      }\n    } /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, that node will\n    /// not have its children iterated over (or `leave` called).\n\n  }, {\n    key: \"iterate\",\n    value: function iterate(spec) {\n      var enter = spec.enter,\n          leave = spec.leave,\n          _spec$from = spec.from,\n          from = _spec$from === void 0 ? 0 : _spec$from,\n          _spec$to = spec.to,\n          to = _spec$to === void 0 ? this.length : _spec$to;\n\n      for (var c = this.cursor(), get = function get() {\n        return c.node;\n      };;) {\n        var mustLeave = false;\n\n        if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {\n          if (c.firstChild()) continue;\n          if (!c.type.isAnonymous) mustLeave = true;\n        }\n\n        for (;;) {\n          if (mustLeave && leave) leave(c.type, c.from, c.to, get);\n          mustLeave = c.type.isAnonymous;\n          if (c.nextSibling()) break;\n          if (!c.parent()) return;\n          mustLeave = true;\n        }\n      }\n    } /// Get the value of the given [node prop](#common.NodeProp) for this\n    /// node. Works with both per-node and per-type props.\n\n  }, {\n    key: \"prop\",\n    value: function prop(_prop2) {\n      return !_prop2.perNode ? this.type.prop(_prop2) : this.props ? this.props[_prop2.id] : undefined;\n    } /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    /// format that can be passed to the [`Tree`](#common.Tree)\n    /// constructor.\n\n  }, {\n    key: \"propValues\",\n    get: function get() {\n      var result = [];\n      if (this.props) for (var id in this.props) {\n        result.push([+id, this.props[id]]);\n      }\n      return result;\n    } /// Balance the direct children of this tree, producing a copy of\n    /// which may have children grouped into subtrees with type\n    /// [`NodeType.none`](#common.NodeType^none).\n\n  }, {\n    key: \"balance\",\n    value: function balance() {\n      var _this2 = this;\n\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.children.length <= 8\n      /* BranchFactor */\n      ? this : balanceRange(this.type, this.children, this.positions, 0, this.children.length, 0, this.length, function (children, positions, length) {\n        return new Tree(_this2.type, children, positions, length, _this2.propValues);\n      }, config.makeTree || function (children, positions, length) {\n        return new Tree(NodeType.none, children, positions, length);\n      });\n    } /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n\n  }], [{\n    key: \"build\",\n    value: function build(data) {\n      return buildTree(data);\n    }\n  }]);\n\n  return Tree;\n}(); /// The empty tree\n\n\nTree.empty = new Tree(NodeType.none, [], [], 0);\n\nvar FlatBufferCursor = /*#__PURE__*/function () {\n  function FlatBufferCursor(buffer, index) {\n    _classCallCheck(this, FlatBufferCursor);\n\n    this.buffer = buffer;\n    this.index = index;\n  }\n\n  _createClass(FlatBufferCursor, [{\n    key: \"id\",\n    get: function get() {\n      return this.buffer[this.index - 4];\n    }\n  }, {\n    key: \"start\",\n    get: function get() {\n      return this.buffer[this.index - 3];\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.buffer[this.index - 2];\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.buffer[this.index - 1];\n    }\n  }, {\n    key: \"pos\",\n    get: function get() {\n      return this.index;\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      this.index -= 4;\n    }\n  }, {\n    key: \"fork\",\n    value: function fork() {\n      return new FlatBufferCursor(this.buffer, this.index);\n    }\n  }]);\n\n  return FlatBufferCursor;\n}(); /// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\n\n\nvar TreeBuffer = /*#__PURE__*/function () {\n  /// Create a tree buffer.\n  function TreeBuffer( /// The buffer's content.\n  buffer, /// The total length of the group of nodes in the buffer.\n  length, /// The node set used in this buffer.\n  set) {\n    _classCallCheck(this, TreeBuffer);\n\n    this.buffer = buffer;\n    this.length = length;\n    this.set = set;\n  } /// @internal\n\n\n  _createClass(TreeBuffer, [{\n    key: \"type\",\n    get: function get() {\n      return NodeType.none;\n    } /// @internal\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var result = [];\n\n      for (var index = 0; index < this.buffer.length;) {\n        result.push(this.childString(index));\n        index = this.buffer[index + 3];\n      }\n\n      return result.join(\",\");\n    } /// @internal\n\n  }, {\n    key: \"childString\",\n    value: function childString(index) {\n      var id = this.buffer[index],\n          endIndex = this.buffer[index + 3];\n      var type = this.set.types[id],\n          result = type.name;\n      if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n      index += 4;\n      if (endIndex == index) return result;\n      var children = [];\n\n      while (index < endIndex) {\n        children.push(this.childString(index));\n        index = this.buffer[index + 3];\n      }\n\n      return result + \"(\" + children.join(\",\") + \")\";\n    } /// @internal\n\n  }, {\n    key: \"findChild\",\n    value: function findChild(startIndex, endIndex, dir, pos, side) {\n      var buffer = this.buffer,\n          pick = -1;\n\n      for (var i = startIndex; i != endIndex; i = buffer[i + 3]) {\n        if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n          pick = i;\n          if (dir > 0) break;\n        }\n      }\n\n      return pick;\n    } /// @internal\n\n  }, {\n    key: \"slice\",\n    value: function slice(startI, endI, from, to) {\n      var b = this.buffer;\n      var copy = new Uint16Array(endI - startI);\n\n      for (var i = startI, j = 0; i < endI;) {\n        copy[j++] = b[i++];\n        copy[j++] = b[i++] - from;\n        copy[j++] = b[i++] - from;\n        copy[j++] = b[i++] - startI;\n      }\n\n      return new TreeBuffer(copy, to - from, this.set);\n    }\n  }]);\n\n  return TreeBuffer;\n}();\n\nfunction checkSide(side, pos, from, to) {\n  switch (side) {\n    case -2\n    /* Before */\n    :\n      return from < pos;\n\n    case -1\n    /* AtOrBefore */\n    :\n      return to >= pos && from < pos;\n\n    case 0\n    /* Around */\n    :\n      return from < pos && to > pos;\n\n    case 1\n    /* AtOrAfter */\n    :\n      return from <= pos && to > pos;\n\n    case 2\n    /* After */\n    :\n      return to > pos;\n\n    case 4\n    /* DontCare */\n    :\n      return true;\n  }\n}\n\nvar TreeNode = /*#__PURE__*/function () {\n  function TreeNode(node, _from, // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n  index, _parent) {\n    _classCallCheck(this, TreeNode);\n\n    this.node = node;\n    this._from = _from;\n    this.index = index;\n    this._parent = _parent;\n  }\n\n  _createClass(TreeNode, [{\n    key: \"type\",\n    get: function get() {\n      return this.node.type;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.node.type.name;\n    }\n  }, {\n    key: \"from\",\n    get: function get() {\n      return this._from;\n    }\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this._from + this.node.length;\n    }\n  }, {\n    key: \"nextChild\",\n    value: function nextChild(i, dir, pos, side) {\n      var mode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n      for (var parent = this;;) {\n        for (var _parent$node = parent.node, children = _parent$node.children, positions = _parent$node.positions, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n          var next = children[i],\n              start = positions[i] + parent._from;\n          if (!checkSide(side, pos, start, start + next.length)) continue;\n\n          if (next instanceof TreeBuffer) {\n            if (mode & 2\n            /* NoEnterBuffer */\n            ) continue;\n            var index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n            if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n          } else if (mode & 1\n          /* Full */\n          || !next.type.isAnonymous || hasChild(next)) {\n            var mounted = void 0;\n            if (next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);\n            var inner = new TreeNode(next, start, i, parent);\n            return mode & 1\n            /* Full */\n            || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n          }\n        }\n\n        if (mode & 1\n        /* Full */\n        || !parent.type.isAnonymous) return null;\n        if (parent.index >= 0) i = parent.index + dir;else i = dir < 0 ? -1 : parent._parent.node.children.length;\n        parent = parent._parent;\n        if (!parent) return null;\n      }\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.nextChild(0, 1, 0, 4\n      /* DontCare */\n      );\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.nextChild(this.node.children.length - 1, -1, 0, 4\n      /* DontCare */\n      );\n    }\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      return this.nextChild(0, 1, pos, 2\n      /* After */\n      );\n    }\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      return this.nextChild(this.node.children.length - 1, -1, pos, -2\n      /* Before */\n      );\n    }\n  }, {\n    key: \"enter\",\n    value: function enter(pos, side) {\n      var overlays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var buffers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var mounted;\n\n      if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {\n        var rPos = pos - this.from;\n\n        var _iterator7 = _createForOfIteratorHelper(mounted.overlay),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var _step7$value = _step7.value,\n                from = _step7$value.from,\n                to = _step7$value.to;\n            if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n\n      return this.nextChild(0, 1, pos, side, buffers ? 0 : 2\n      /* NoEnterBuffer */\n      );\n    }\n  }, {\n    key: \"nextSignificantParent\",\n    value: function nextSignificantParent() {\n      var val = this;\n\n      while (val.type.isAnonymous && val._parent) {\n        val = val._parent;\n      }\n\n      return val;\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4\n      /* DontCare */\n      ) : null;\n    }\n  }, {\n    key: \"prevSibling\",\n    get: function get() {\n      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4\n      /* DontCare */\n      ) : null;\n    }\n  }, {\n    key: \"cursor\",\n    get: function get() {\n      return new TreeCursor(this);\n    }\n  }, {\n    key: \"tree\",\n    get: function get() {\n      return this.node;\n    }\n  }, {\n    key: \"toTree\",\n    value: function toTree() {\n      return this.node;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.cursor.moveTo(pos, side).node;\n    }\n  }, {\n    key: \"getChild\",\n    value: function getChild(type) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      var r = _getChildren(this, type, before, after);\n\n      return r.length ? r[0] : null;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(type) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      return _getChildren(this, type, before, after);\n    } /// @internal\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.node.toString();\n    }\n  }]);\n\n  return TreeNode;\n}();\n\nfunction _getChildren(node, type, before, after) {\n  var cur = node.cursor,\n      result = [];\n  if (!cur.firstChild()) return result;\n  if (before != null) while (!cur.type.is(before)) {\n    if (!cur.nextSibling()) return result;\n  }\n\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result;\n    if (cur.type.is(type)) result.push(cur.node);\n    if (!cur.nextSibling()) return after == null ? result : [];\n  }\n}\n\nvar BufferContext = function BufferContext(parent, buffer, index, start) {\n  _classCallCheck(this, BufferContext);\n\n  this.parent = parent;\n  this.buffer = buffer;\n  this.index = index;\n  this.start = start;\n};\n\nvar BufferNode = /*#__PURE__*/function () {\n  function BufferNode(context, _parent, index) {\n    _classCallCheck(this, BufferNode);\n\n    this.context = context;\n    this._parent = _parent;\n    this.index = index;\n    this.type = context.buffer.set.types[context.buffer.buffer[index]];\n  }\n\n  _createClass(BufferNode, [{\n    key: \"name\",\n    get: function get() {\n      return this.type.name;\n    }\n  }, {\n    key: \"from\",\n    get: function get() {\n      return this.context.start + this.context.buffer.buffer[this.index + 1];\n    }\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this.context.start + this.context.buffer.buffer[this.index + 2];\n    }\n  }, {\n    key: \"child\",\n    value: function child(dir, pos, side) {\n      var buffer = this.context.buffer;\n      var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n      return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.child(1, 0, 4\n      /* DontCare */\n      );\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.child(-1, 0, 4\n      /* DontCare */\n      );\n    }\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      return this.child(1, pos, 2\n      /* After */\n      );\n    }\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      return this.child(-1, pos, -2\n      /* Before */\n      );\n    }\n  }, {\n    key: \"enter\",\n    value: function enter(pos, side, overlays) {\n      var buffers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      if (!buffers) return null;\n      var buffer = this.context.buffer;\n      var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n      return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent || this.context.parent.nextSignificantParent();\n    }\n  }, {\n    key: \"externalSibling\",\n    value: function externalSibling(dir) {\n      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4\n      /* DontCare */\n      );\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      var buffer = this.context.buffer;\n      var after = buffer.buffer[this.index + 3];\n      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n      return this.externalSibling(1);\n    }\n  }, {\n    key: \"prevSibling\",\n    get: function get() {\n      var buffer = this.context.buffer;\n      var parentStart = this._parent ? this._parent.index + 4 : 0;\n      if (this.index == parentStart) return this.externalSibling(-1);\n      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4\n      /* DontCare */\n      ));\n    }\n  }, {\n    key: \"cursor\",\n    get: function get() {\n      return new TreeCursor(this);\n    }\n  }, {\n    key: \"tree\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"toTree\",\n    value: function toTree() {\n      var children = [],\n          positions = [];\n      var buffer = this.context.buffer;\n      var startI = this.index + 4,\n          endI = buffer.buffer[this.index + 3];\n\n      if (endI > startI) {\n        var from = buffer.buffer[this.index + 1],\n            to = buffer.buffer[this.index + 2];\n        children.push(buffer.slice(startI, endI, from, to));\n        positions.push(0);\n      }\n\n      return new Tree(this.type, children, positions, this.to - this.from);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.cursor.moveTo(pos, side).node;\n    } /// @internal\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.context.buffer.childString(this.index);\n    }\n  }, {\n    key: \"getChild\",\n    value: function getChild(type) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      var r = _getChildren(this, type, before, after);\n\n      return r.length ? r[0] : null;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(type) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      return _getChildren(this, type, before, after);\n    }\n  }]);\n\n  return BufferNode;\n}(); /// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\n\n\nvar TreeCursor = /*#__PURE__*/function () {\n  /// @internal\n  function TreeCursor(node) {\n    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, TreeCursor);\n\n    this.mode = mode;\n    this.buffer = null;\n    this.stack = [];\n    this.index = 0;\n    this.bufferNode = null;\n\n    if (node instanceof TreeNode) {\n      this.yieldNode(node);\n    } else {\n      this._tree = node.context.parent;\n      this.buffer = node.context;\n\n      for (var n = node._parent; n; n = n._parent) {\n        this.stack.unshift(n.index);\n      }\n\n      this.bufferNode = node;\n      this.yieldBuf(node.index);\n    }\n  } /// Shorthand for `.type.name`.\n\n\n  _createClass(TreeCursor, [{\n    key: \"name\",\n    get: function get() {\n      return this.type.name;\n    }\n  }, {\n    key: \"yieldNode\",\n    value: function yieldNode(node) {\n      if (!node) return false;\n      this._tree = node;\n      this.type = node.type;\n      this.from = node.from;\n      this.to = node.to;\n      return true;\n    }\n  }, {\n    key: \"yieldBuf\",\n    value: function yieldBuf(index, type) {\n      this.index = index;\n      var _this$buffer = this.buffer,\n          start = _this$buffer.start,\n          buffer = _this$buffer.buffer;\n      this.type = type || buffer.set.types[buffer.buffer[index]];\n      this.from = start + buffer.buffer[index + 1];\n      this.to = start + buffer.buffer[index + 2];\n      return true;\n    }\n  }, {\n    key: \"yield\",\n    value: function _yield(node) {\n      if (!node) return false;\n\n      if (node instanceof TreeNode) {\n        this.buffer = null;\n        return this.yieldNode(node);\n      }\n\n      this.buffer = node.context;\n      return this.yieldBuf(node.index, node.type);\n    } /// @internal\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    } /// @internal\n\n  }, {\n    key: \"enterChild\",\n    value: function enterChild(dir, pos, side) {\n      if (!this.buffer) return this[\"yield\"](this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));\n      var buffer = this.buffer.buffer;\n      var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n      if (index < 0) return false;\n      this.stack.push(this.index);\n      return this.yieldBuf(index);\n    } /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n\n  }, {\n    key: \"firstChild\",\n    value: function firstChild() {\n      return this.enterChild(1, 0, 4\n      /* DontCare */\n      );\n    } /// Move the cursor to this node's last child.\n\n  }, {\n    key: \"lastChild\",\n    value: function lastChild() {\n      return this.enterChild(-1, 0, 4\n      /* DontCare */\n      );\n    } /// Move the cursor to the first child that ends after `pos`.\n\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      return this.enterChild(1, pos, 2\n      /* After */\n      );\n    } /// Move to the last child that starts before `pos`.\n\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      return this.enterChild(-1, pos, -2\n      /* Before */\n      );\n    } /// Move the cursor to the child around `pos`. If side is -1 the\n    /// child may end at that position, when 1 it may start there. This\n    /// will also enter [overlaid](#common.MountedTree.overlay)\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    /// set to false.\n\n  }, {\n    key: \"enter\",\n    value: function enter(pos, side) {\n      var overlays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var buffers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      if (!this.buffer) return this[\"yield\"](this._tree.enter(pos, side, overlays, buffers));\n      return buffers ? this.enterChild(1, pos, side) : false;\n    } /// Move the node's parent node, if this isn't the top node.\n\n  }, {\n    key: \"parent\",\n    value: function parent() {\n      if (!this.buffer) return this.yieldNode(this.mode & 1\n      /* Full */\n      ? this._tree._parent : this._tree.parent);\n      if (this.stack.length) return this.yieldBuf(this.stack.pop());\n      var parent = this.mode & 1\n      /* Full */\n      ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n      this.buffer = null;\n      return this.yieldNode(parent);\n    } /// @internal\n\n  }, {\n    key: \"sibling\",\n    value: function sibling(dir) {\n      if (!this.buffer) return !this._tree._parent ? false : this[\"yield\"](this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4\n      /* DontCare */\n      , this.mode));\n      var buffer = this.buffer.buffer,\n          d = this.stack.length - 1;\n\n      if (dir < 0) {\n        var parentStart = d < 0 ? 0 : this.stack[d] + 4;\n        if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4\n        /* DontCare */\n        ));\n      } else {\n        var after = buffer.buffer[this.index + 3];\n        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n      }\n\n      return d < 0 ? this[\"yield\"](this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4\n      /* DontCare */\n      , this.mode)) : false;\n    } /// Move to this node's next sibling, if any.\n\n  }, {\n    key: \"nextSibling\",\n    value: function nextSibling() {\n      return this.sibling(1);\n    } /// Move to this node's previous sibling, if any.\n\n  }, {\n    key: \"prevSibling\",\n    value: function prevSibling() {\n      return this.sibling(-1);\n    }\n  }, {\n    key: \"atLastNode\",\n    value: function atLastNode(dir) {\n      var index,\n          parent,\n          buffer = this.buffer;\n\n      if (buffer) {\n        if (dir > 0) {\n          if (this.index < buffer.buffer.buffer.length) return false;\n        } else {\n          for (var i = 0; i < this.index; i++) {\n            if (buffer.buffer.buffer[i + 3] < this.index) return false;\n          }\n        }\n\n        index = buffer.index;\n        parent = buffer.parent;\n      } else {\n        var _this$_tree = this._tree;\n        index = _this$_tree.index;\n        parent = _this$_tree._parent;\n      }\n\n      for (; parent; _parent2 = parent, index = _parent2.index, parent = _parent2._parent, _parent2) {\n        var _parent2;\n\n        if (index > -1) for (var _i2 = index + dir, e = dir < 0 ? -1 : parent.node.children.length; _i2 != e; _i2 += dir) {\n          var child = parent.node.children[_i2];\n          if (this.mode & 1\n          /* Full */\n          || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"move\",\n    value: function move(dir, enter) {\n      if (enter && this.enterChild(dir, 0, 4\n      /* DontCare */\n      )) return true;\n\n      for (;;) {\n        if (this.sibling(dir)) return true;\n        if (this.atLastNode(dir) || !this.parent()) return false;\n      }\n    } /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty or `enter` is false, its next sibling or\n    /// the next sibling of the first parent node that has one.\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      var enter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return this.move(1, enter);\n    } /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by its last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n\n  }, {\n    key: \"prev\",\n    value: function prev() {\n      var enter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return this.move(-1, enter);\n    } /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      // Move up to a node that actually holds the position, if possible\n      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) {\n        if (!this.parent()) break;\n      } // Then scan down into child nodes as far as possible\n\n\n      while (this.enterChild(1, pos, side)) {}\n\n      return this;\n    } /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    /// position.\n\n  }, {\n    key: \"node\",\n    get: function get() {\n      if (!this.buffer) return this._tree;\n      var cache = this.bufferNode,\n          result = null,\n          depth = 0;\n\n      if (cache && cache.context == this.buffer) {\n        scan: for (var index = this.index, d = this.stack.length; d >= 0;) {\n          for (var c = cache; c; c = c._parent) {\n            if (c.index == index) {\n              if (index == this.index) return c;\n              result = c;\n              depth = d + 1;\n              break scan;\n            }\n          }\n\n          index = this.stack[--d];\n        }\n      }\n\n      for (var i = depth; i < this.stack.length; i++) {\n        result = new BufferNode(this.buffer, result, this.stack[i]);\n      }\n\n      return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    } /// Get the [tree](#common.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#common.TreeBuffer).\n\n  }, {\n    key: \"tree\",\n    get: function get() {\n      return this.buffer ? null : this._tree.node;\n    }\n  }]);\n\n  return TreeCursor;\n}();\n\nfunction hasChild(tree) {\n  return tree.children.some(function (ch) {\n    return ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch);\n  });\n}\n\nfunction buildTree(data) {\n  var _a;\n\n  var buffer = data.buffer,\n      nodeSet = data.nodeSet,\n      _data$maxBufferLength = data.maxBufferLength,\n      maxBufferLength = _data$maxBufferLength === void 0 ? DefaultBufferLength : _data$maxBufferLength,\n      _data$reused = data.reused,\n      reused = _data$reused === void 0 ? [] : _data$reused,\n      _data$minRepeatType = data.minRepeatType,\n      minRepeatType = _data$minRepeatType === void 0 ? nodeSet.types.length : _data$minRepeatType;\n  var cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n  var types = nodeSet.types;\n  var contextHash = 0,\n      lookAhead = 0;\n\n  function takeNode(parentStart, minPos, children, positions, inRepeat) {\n    var id = cursor.id,\n        start = cursor.start,\n        end = cursor.end,\n        size = cursor.size;\n    var lookAheadAtStart = lookAhead;\n\n    while (size < 0) {\n      cursor.next();\n\n      if (size == -1\n      /* Reuse */\n      ) {\n        var _node = reused[id];\n        children.push(_node);\n        positions.push(start - parentStart);\n        return;\n      } else if (size == -3\n      /* ContextChange */\n      ) {\n        // Context change\n        contextHash = id;\n        return;\n      } else if (size == -4\n      /* LookAhead */\n      ) {\n        lookAhead = id;\n        return;\n      } else {\n        throw new RangeError(\"Unrecognized record size: \".concat(size));\n      }\n    }\n\n    var type = types[id],\n        node,\n        buffer;\n    var startPos = start - parentStart;\n\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      var _data = new Uint16Array(buffer.size - buffer.skip);\n\n      var endPos = cursor.pos - buffer.size,\n          index = _data.length;\n\n      while (cursor.pos > endPos) {\n        index = copyToBuffer(buffer.start, _data, index);\n      }\n\n      node = new TreeBuffer(_data, end - buffer.start, nodeSet);\n      startPos = buffer.start - parentStart;\n    } else {\n      // Make it a node\n      var _endPos = cursor.pos - size;\n\n      cursor.next();\n      var localChildren = [],\n          localPositions = [];\n      var localInRepeat = id >= minRepeatType ? id : -1;\n      var lastGroup = 0,\n          lastEnd = end;\n\n      while (cursor.pos > _endPos) {\n        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n          if (cursor.end <= lastEnd - maxBufferLength) {\n            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n            lastGroup = localChildren.length;\n            lastEnd = cursor.end;\n          }\n\n          cursor.next();\n        } else {\n          takeNode(start, _endPos, localChildren, localPositions, localInRepeat);\n        }\n      }\n\n      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n      localChildren.reverse();\n      localPositions.reverse();\n\n      if (localInRepeat > -1 && lastGroup > 0) {\n        var make = makeBalanced(type);\n        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n      } else {\n        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n      }\n    }\n\n    children.push(node);\n    positions.push(startPos);\n  }\n\n  function makeBalanced(type) {\n    return function (children, positions, length) {\n      var lookAhead = 0,\n          lastI = children.length - 1,\n          last,\n          lookAheadProp;\n\n      if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n        if (!lastI && last.type == type && last.length == length) return last;\n        if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;\n      }\n\n      return makeTree(type, children, positions, length, lookAhead);\n    };\n  }\n\n  function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n    var localChildren = [],\n        localPositions = [];\n\n    while (children.length > i) {\n      localChildren.push(children.pop());\n      localPositions.push(positions.pop() + base - from);\n    }\n\n    children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n    positions.push(from - base);\n  }\n\n  function makeTree(type, children, positions, length) {\n    var lookAhead = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var props = arguments.length > 5 ? arguments[5] : undefined;\n\n    if (contextHash) {\n      var pair = [NodeProp.contextHash, contextHash];\n      props = props ? [pair].concat(props) : [pair];\n    }\n\n    if (lookAhead > 25) {\n      var _pair = [NodeProp.lookAhead, lookAhead];\n      props = props ? [_pair].concat(props) : [_pair];\n    }\n\n    return new Tree(type, children, positions, length, props);\n  }\n\n  function findBufferSize(maxSize, inRepeat) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    var fork = cursor.fork();\n    var size = 0,\n        start = 0,\n        skip = 0,\n        minStart = fork.end - maxBufferLength;\n    var result = {\n      size: 0,\n      start: 0,\n      skip: 0\n    };\n\n    scan: for (var minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      var _nodeSize = fork.size; // Pretend nested repeat nodes of the same type don't exist\n\n      if (fork.id == inRepeat && _nodeSize >= 0) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size;\n        result.start = start;\n        result.skip = skip;\n        skip += 4;\n        size += 4;\n        fork.next();\n        continue;\n      }\n\n      var startPos = fork.pos - _nodeSize;\n      if (_nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n      var localSkipped = fork.id >= minRepeatType ? 4 : 0;\n      var nodeStart = fork.start;\n      fork.next();\n\n      while (fork.pos > startPos) {\n        if (fork.size < 0) {\n          if (fork.size == -3\n          /* ContextChange */\n          ) localSkipped += 4;else break scan;\n        } else if (fork.id >= minRepeatType) {\n          localSkipped += 4;\n        }\n\n        fork.next();\n      }\n\n      start = nodeStart;\n      size += _nodeSize;\n      skip += localSkipped;\n    }\n\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size;\n      result.start = start;\n      result.skip = skip;\n    }\n\n    return result.size > 4 ? result : undefined;\n  }\n\n  function copyToBuffer(bufferStart, buffer, index) {\n    var id = cursor.id,\n        start = cursor.start,\n        end = cursor.end,\n        size = cursor.size;\n    cursor.next();\n\n    if (size >= 0 && id < minRepeatType) {\n      var startIndex = index;\n\n      if (size > 4) {\n        var endPos = cursor.pos - (size - 4);\n\n        while (cursor.pos > endPos) {\n          index = copyToBuffer(bufferStart, buffer, index);\n        }\n      }\n\n      buffer[--index] = startIndex;\n      buffer[--index] = end - bufferStart;\n      buffer[--index] = start - bufferStart;\n      buffer[--index] = id;\n    } else if (size == -3\n    /* ContextChange */\n    ) {\n      contextHash = id;\n    } else if (size == -4\n    /* LookAhead */\n    ) {\n      lookAhead = id;\n    }\n\n    return index;\n  }\n\n  var children = [],\n      positions = [];\n\n  while (cursor.pos > 0) {\n    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n  }\n\n  var length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\n\nvar nodeSizeCache = new WeakMap();\n\nfunction nodeSize(balanceType, node) {\n  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;\n  var size = nodeSizeCache.get(node);\n\n  if (size == null) {\n    size = node.children.reduce(function (s, ch) {\n      return s + nodeSize(balanceType, ch);\n    }, 1);\n    nodeSizeCache.set(node, size);\n  }\n\n  return size;\n}\n\nfunction balanceRange( // The type to tag the resulting tree with. Will also be used for\n// internal nodes when it is an anonymous type\ntype, // The direct children and their positions\nchildren, positions, // The index range in children/positions to use\nfrom, to, // The start position of the nodes, relative to their parent.\nstart, // Length of the outer node\nlength, // Function to build the top node of the balanced tree\nmkTop, // Function to build internal nodes for the balanced tree\nmkTree) {\n  var total = 0;\n\n  for (var i = from; i < to; i++) {\n    total += nodeSize(type, children[i]);\n  }\n\n  var maxChild = Math.ceil(total * 1.5 / 8\n  /* BranchFactor */\n  );\n  var localChildren = [],\n      localPositions = [];\n\n  function divide(children, positions, from, to, offset) {\n    for (var _i3 = from; _i3 < to;) {\n      var groupFrom = _i3,\n          groupStart = positions[_i3],\n          groupSize = nodeSize(type, children[_i3]);\n      _i3++;\n\n      for (; _i3 < to; _i3++) {\n        var nextSize = nodeSize(type, children[_i3]);\n        if (groupSize + nextSize >= maxChild) break;\n        groupSize += nextSize;\n      }\n\n      if (_i3 == groupFrom + 1) {\n        if (groupSize > maxChild) {\n          var only = children[groupFrom];\n          divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n          continue;\n        }\n\n        localChildren.push(children[groupFrom]);\n      } else {\n        var _length = positions[_i3 - 1] + children[_i3 - 1].length - groupStart;\n\n        localChildren.push(balanceRange(type, children, positions, groupFrom, _i3, groupStart, _length, null, mkTree));\n      }\n\n      localPositions.push(groupStart + offset - start);\n    }\n  }\n\n  divide(children, positions, from, to, 0);\n  return (mkTop || mkTree)(localChildren, localPositions, length);\n} /// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\n\n\nvar TreeFragment = /*#__PURE__*/function () {\n  /// Construct a tree fragment.\n  function TreeFragment( /// The start of the unchanged range pointed to by this fragment.\n  /// This refers to an offset in the _updated_ document (as opposed\n  /// to the original tree).\n  from, /// The end of the unchanged range.\n  to, /// The tree that this fragment is based on.\n  tree, /// The offset between the fragment's tree and the document that\n  /// this fragment can be used against. Add this when going from\n  /// document to tree positions, subtract it to go from tree to\n  /// document positions.\n  offset) {\n    var openStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var openEnd = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    _classCallCheck(this, TreeFragment);\n\n    this.from = from;\n    this.to = to;\n    this.tree = tree;\n    this.offset = offset;\n    this.open = (openStart ? 1\n    /* Start */\n    : 0) | (openEnd ? 2\n    /* End */\n    : 0);\n  } /// Whether the start of the fragment represents the start of a\n  /// parse, or the end of a change. (In the second case, it may not\n  /// be safe to reuse some nodes at the start, depending on the\n  /// parsing algorithm.)\n\n\n  _createClass(TreeFragment, [{\n    key: \"openStart\",\n    get: function get() {\n      return (this.open & 1\n      /* Start */\n      ) > 0;\n    } /// Whether the end of the fragment represents the end of a\n    /// full-document parse, or the start of a change.\n\n  }, {\n    key: \"openEnd\",\n    get: function get() {\n      return (this.open & 2\n      /* End */\n      ) > 0;\n    } /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the resulting\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    /// true.\n\n  }], [{\n    key: \"addTree\",\n    value: function addTree(tree) {\n      var fragments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var partial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n\n      var _iterator8 = _createForOfIteratorHelper(fragments),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var f = _step8.value;\n          if (f.to > tree.length) result.push(f);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return result;\n    } /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n\n  }, {\n    key: \"applyChanges\",\n    value: function applyChanges(fragments, changes) {\n      var minGap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 128;\n      if (!changes.length) return fragments;\n      var result = [];\n      var fI = 1,\n          nextF = fragments.length ? fragments[0] : null;\n\n      for (var cI = 0, pos = 0, off = 0;; cI++) {\n        var nextC = cI < changes.length ? changes[cI] : null;\n        var nextPos = nextC ? nextC.fromA : 1e9;\n        if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n          var cut = nextF;\n\n          if (pos >= cut.from || nextPos <= cut.to || off) {\n            var fFrom = Math.max(cut.from, pos) - off,\n                fTo = Math.min(cut.to, nextPos) - off;\n            cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n          }\n\n          if (cut) result.push(cut);\n          if (nextF.to > nextPos) break;\n          nextF = fI < fragments.length ? fragments[fI++] : null;\n        }\n        if (!nextC) break;\n        pos = nextC.toA;\n        off = nextC.toA - nextC.toB;\n      }\n\n      return result;\n    }\n  }]);\n\n  return TreeFragment;\n}(); /// A superclass that parsers should extend.\n\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser() {\n    _classCallCheck(this, Parser);\n  }\n\n  _createClass(Parser, [{\n    key: \"startParse\",\n    value: /// Start a parse, returning a [partial parse](#common.PartialParse)\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\n    /// make the parse incremental.\n    ///\n    /// By default, the entire input is parsed. You can pass `ranges`,\n    /// which should be a sorted array of non-empty, non-overlapping\n    /// ranges, to parse only those ranges. The tree returned in that\n    /// case will start at `ranges[0].from`.\n    function startParse(input, fragments, ranges) {\n      if (typeof input == \"string\") input = new StringInput(input);\n      ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(function (r) {\n        return new Range(r.from, r.to);\n      }) : [new Range(0, 0)];\n      return this.createParse(input, fragments || [], ranges);\n    } /// Run a full parse, returning the resulting tree.\n\n  }, {\n    key: \"parse\",\n    value: function parse(input, fragments, ranges) {\n      var parse = this.startParse(input, fragments, ranges);\n\n      for (;;) {\n        var done = parse.advance();\n        if (done) return done;\n      }\n    }\n  }]);\n\n  return Parser;\n}();\n\nvar StringInput = /*#__PURE__*/function () {\n  function StringInput(string) {\n    _classCallCheck(this, StringInput);\n\n    this.string = string;\n  }\n\n  _createClass(StringInput, [{\n    key: \"length\",\n    get: function get() {\n      return this.string.length;\n    }\n  }, {\n    key: \"chunk\",\n    value: function chunk(from) {\n      return this.string.slice(from);\n    }\n  }, {\n    key: \"lineChunks\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"read\",\n    value: function read(from, to) {\n      return this.string.slice(from, to);\n    }\n  }]);\n\n  return StringInput;\n}(); /// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\n///\n/// The nesting function is passed a cursor to provide context for a\n/// node, but _should not_ move that cursor, only inspect its\n/// properties and optionally access its\n/// [node object](#common.TreeCursor.node).\n\n\nfunction parseMixed(nest) {\n  return function (parse, input, fragments, ranges) {\n    return new MixedParse(parse, nest, input, fragments, ranges);\n  };\n}\n\nvar InnerParse = function InnerParse(parser, parse, overlay, target) {\n  _classCallCheck(this, InnerParse);\n\n  this.parser = parser;\n  this.parse = parse;\n  this.overlay = overlay;\n  this.target = target;\n};\n\nvar ActiveOverlay = function ActiveOverlay(parser, predicate, mounts, index, start, target, prev) {\n  _classCallCheck(this, ActiveOverlay);\n\n  this.parser = parser;\n  this.predicate = predicate;\n  this.mounts = mounts;\n  this.index = index;\n  this.start = start;\n  this.target = target;\n  this.prev = prev;\n  this.depth = 0;\n  this.ranges = [];\n};\n\nvar MixedParse = /*#__PURE__*/function () {\n  function MixedParse(base, nest, input, fragments, ranges) {\n    _classCallCheck(this, MixedParse);\n\n    this.nest = nest;\n    this.input = input;\n    this.fragments = fragments;\n    this.ranges = ranges;\n    this.inner = [];\n    this.innerDone = 0;\n    this.baseTree = null;\n    this.stoppedAt = null;\n    this.baseParse = base;\n  }\n\n  _createClass(MixedParse, [{\n    key: \"advance\",\n    value: function advance() {\n      if (this.baseParse) {\n        var _done = this.baseParse.advance();\n\n        if (!_done) return null;\n        this.baseParse = null;\n        this.baseTree = _done;\n        this.startInner();\n      }\n\n      if (this.innerDone == this.inner.length) return this.baseTree;\n      var inner = this.inner[this.innerDone],\n          done = inner.parse.advance();\n\n      if (done) {\n        this.innerDone++; // This is a somewhat dodgy but super helpful hack where we\n        // patch up nodes created by the inner parse (and thus\n        // presumably not aliased anywhere else) to hold the information\n        // about the inner parse.\n\n        var props = Object.assign(Object.create(null), inner.target.props);\n        props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n        inner.target.props = props;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"parsedPos\",\n    get: function get() {\n      if (this.baseParse) return 0;\n      var next = this.inner[this.innerDone];\n      return next ? next.parse.parsedPos : this.input.length;\n    }\n  }, {\n    key: \"stopAt\",\n    value: function stopAt(pos) {\n      this.stoppedAt = pos;\n      if (this.baseParse) this.baseParse.stopAt(pos);else for (var i = this.innerDone; i < this.inner.length; i++) {\n        this.inner[i].parse.stopAt(pos);\n      }\n    }\n  }, {\n    key: \"startInner\",\n    value: function startInner() {\n      var _this3 = this;\n\n      var fragmentCursor = new FragmentCursor(this.fragments);\n      var overlay = null;\n      var covered = null;\n\n      var _loop = function _loop(cursor, _nest, _isCovered) {\n        var enter = true,\n            range = void 0;\n\n        if (fragmentCursor.hasNode(cursor)) {\n          if (overlay) {\n            var match = overlay.mounts.find(function (m) {\n              return m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay;\n            });\n\n            if (match) {\n              var _iterator9 = _createForOfIteratorHelper(match.mount.overlay),\n                  _step9;\n\n              try {\n                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                  var r = _step9.value;\n                  var from = r.from + match.pos,\n                      to = r.to + match.pos;\n                  if (from >= cursor.from && to <= cursor.to) overlay.ranges.push({\n                    from: from,\n                    to: to\n                  });\n                }\n              } catch (err) {\n                _iterator9.e(err);\n              } finally {\n                _iterator9.f();\n              }\n            }\n          }\n\n          enter = false;\n        } else if (covered && (_isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n          enter = _isCovered != 2\n          /* Full */\n          ;\n        } else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (_nest = _this3.nest(cursor, _this3.input))) {\n          if (!cursor.tree) materialize(cursor);\n          var oldMounts = fragmentCursor.findMounts(cursor.from, _nest.parser);\n\n          if (typeof _nest.overlay == \"function\") {\n            overlay = new ActiveOverlay(_nest.parser, _nest.overlay, oldMounts, _this3.inner.length, cursor.from, cursor.tree, overlay);\n          } else {\n            var ranges = punchRanges(_this3.ranges, _nest.overlay || [new Range(cursor.from, cursor.to)]);\n            if (ranges.length) _this3.inner.push(new InnerParse(_nest.parser, _nest.parser.startParse(_this3.input, enterFragments(oldMounts, ranges), ranges), _nest.overlay ? _nest.overlay.map(function (r) {\n              return new Range(r.from - cursor.from, r.to - cursor.from);\n            }) : null, cursor.tree));\n            if (!_nest.overlay) enter = false;else if (ranges.length) covered = {\n              ranges: ranges,\n              depth: 0,\n              prev: covered\n            };\n          }\n        } else if (overlay && (range = overlay.predicate(cursor))) {\n          if (range === true) range = new Range(cursor.from, cursor.to);\n          if (range.from < range.to) overlay.ranges.push(range);\n        }\n\n        if (enter && cursor.firstChild()) {\n          if (overlay) overlay.depth++;\n          if (covered) covered.depth++;\n        } else {\n          for (;;) {\n            if (cursor.nextSibling()) break;\n\n            if (!cursor.parent()) {\n              isCovered = _isCovered;\n              {\n                nest = _nest;\n                return \"break|scan\";\n              }\n            }\n\n            if (overlay && ! --overlay.depth) {\n              var _ranges = punchRanges(_this3.ranges, overlay.ranges);\n\n              if (_ranges.length) _this3.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(_this3.input, enterFragments(overlay.mounts, _ranges), _ranges), overlay.ranges.map(function (r) {\n                return new Range(r.from - overlay.start, r.to - overlay.start);\n              }), overlay.target));\n              overlay = overlay.prev;\n            }\n\n            if (covered && ! --covered.depth) covered = covered.prev;\n          }\n        }\n\n        nest = _nest;\n        isCovered = _isCovered;\n      };\n\n      scan: for (var cursor = this.baseTree.fullCursor(), nest, isCovered;;) {\n        var _ret = _loop(cursor, nest, isCovered);\n\n        if (_ret === \"break|scan\") break scan;\n      }\n    }\n  }]);\n\n  return MixedParse;\n}();\n\nfunction checkCover(covered, from, to) {\n  var _iterator10 = _createForOfIteratorHelper(covered),\n      _step10;\n\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var range = _step10.value;\n      if (range.from >= to) break;\n      if (range.to > from) return range.from <= from && range.to >= to ? 2\n      /* Full */\n      : 1\n      /* Partial */\n      ;\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  return 0\n  /* None */\n  ;\n} // Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\n\n\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n  if (startI < endI) {\n    var from = buf.buffer[startI + 1],\n        to = buf.buffer[endI - 2];\n    nodes.push(buf.slice(startI, endI, from, to));\n    positions.push(from - off);\n  }\n} // This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\n\n\nfunction materialize(cursor) {\n  var node = cursor.node,\n      depth = 0; // Scan up to the nearest tree\n\n  do {\n    cursor.parent();\n    depth++;\n  } while (!cursor.tree); // Find the index of the buffer in that tree\n\n\n  var i = 0,\n      base = cursor.tree,\n      off = 0;\n\n  for (;; i++) {\n    off = base.positions[i] + cursor.from;\n    if (off <= node.from && off + base.children[i].length >= node.to) break;\n  }\n\n  var buf = base.children[i],\n      b = buf.buffer; // Split a level in the buffer, putting the nodes before and after\n  // the child that contains `node` into new buffers.\n\n  function split(startI, endI, type, innerOffset) {\n    var i = startI;\n\n    while (b[i + 2] + off <= node.from) {\n      i = b[i + 3];\n    }\n\n    var children = [],\n        positions = [];\n    sliceBuf(buf, startI, i, children, positions, innerOffset);\n    var isTarget = b[i + 1] + off == node.from && b[i + 2] + off == node.to && b[i] == node.type.id;\n    children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], b[i + 1]));\n    positions.push(b[i + 1] - innerOffset);\n    sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n    var last = children.length - 1;\n    return new Tree(type, children, positions, positions[last] + children[last].length);\n  }\n\n  base.children[i] = split(0, b.length, NodeType.none, 0); // Move the cursor back to the target node\n\n  for (var d = 0; d <= depth; d++) {\n    cursor.childAfter(node.from);\n  }\n}\n\nvar StructureCursor = /*#__PURE__*/function () {\n  function StructureCursor(root, offset) {\n    _classCallCheck(this, StructureCursor);\n\n    this.offset = offset;\n    this.done = false;\n    this.cursor = root.fullCursor();\n  } // Move to the first node (in pre-order) that starts at or after `pos`.\n\n\n  _createClass(StructureCursor, [{\n    key: \"moveTo\",\n    value: function moveTo(pos) {\n      var cursor = this.cursor,\n          p = pos - this.offset;\n\n      while (!this.done && cursor.from < p) {\n        if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;else if (!cursor.next(false)) this.done = true;\n      }\n    }\n  }, {\n    key: \"hasNode\",\n    value: function hasNode(cursor) {\n      this.moveTo(cursor.from);\n\n      if (!this.done && this.cursor.from + this.offset == cursor.from) {\n        for (var tree = this.cursor.tree;;) {\n          if (tree == cursor.tree) return true;\n          if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];else break;\n        }\n      }\n\n      return false;\n    }\n  }]);\n\n  return StructureCursor;\n}();\n\nvar FragmentCursor = /*#__PURE__*/function () {\n  function FragmentCursor(fragments) {\n    _classCallCheck(this, FragmentCursor);\n\n    this.fragments = fragments;\n    this.fragI = 0;\n\n    if (fragments.length) {\n      var first = this.curFrag = fragments[0];\n      this.inner = new StructureCursor(first.tree, -first.offset);\n    } else {\n      this.curFrag = this.inner = null;\n    }\n  }\n\n  _createClass(FragmentCursor, [{\n    key: \"hasNode\",\n    value: function hasNode(node) {\n      while (this.curFrag && node.from >= this.curFrag.to) {\n        this.nextFrag();\n      }\n\n      return this.curFrag && this.curFrag.from <= node.from && this.curFrag.to >= node.to && this.inner.hasNode(node);\n    }\n  }, {\n    key: \"nextFrag\",\n    value: function nextFrag() {\n      this.fragI++;\n\n      if (this.fragI == this.fragments.length) {\n        this.curFrag = this.inner = null;\n      } else {\n        var frag = this.curFrag = this.fragments[this.fragI];\n        this.inner = new StructureCursor(frag.tree, -frag.offset);\n      }\n    }\n  }, {\n    key: \"findMounts\",\n    value: function findMounts(pos, parser) {\n      var _a;\n\n      var result = [];\n\n      if (this.inner) {\n        this.inner.cursor.moveTo(pos, 1);\n\n        for (var _pos = this.inner.cursor.node; _pos; _pos = _pos.parent) {\n          var mount = (_a = _pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n\n          if (mount && mount.parser == parser) {\n            for (var i = this.fragI; i < this.fragments.length; i++) {\n              var frag = this.fragments[i];\n              if (frag.from >= _pos.to) break;\n              if (frag.tree == this.curFrag.tree) result.push({\n                frag: frag,\n                pos: _pos.from - frag.offset,\n                mount: mount\n              });\n            }\n          }\n        }\n      }\n\n      return result;\n    }\n  }]);\n\n  return FragmentCursor;\n}();\n\nfunction punchRanges(outer, ranges) {\n  var copy = null,\n      current = ranges;\n\n  for (var i = 1, j = 0; i < outer.length; i++) {\n    var gapFrom = outer[i - 1].to,\n        gapTo = outer[i].from;\n\n    for (; j < current.length; j++) {\n      var r = current[j];\n      if (r.from >= gapTo) break;\n      if (r.to <= gapFrom) continue;\n      if (!copy) current = copy = ranges.slice();\n\n      if (r.from < gapFrom) {\n        copy[j] = new Range(r.from, gapFrom);\n        if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));\n      } else if (r.to > gapTo) {\n        copy[j--] = new Range(gapTo, r.to);\n      } else {\n        copy.splice(j--, 1);\n      }\n    }\n  }\n\n  return current;\n}\n\nfunction findCoverChanges(a, b, from, to) {\n  var iA = 0,\n      iB = 0,\n      inA = false,\n      inB = false,\n      pos = -1e9;\n  var result = [];\n\n  for (;;) {\n    var nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n    var nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n\n    if (inA != inB) {\n      var start = Math.max(pos, from),\n          end = Math.min(nextA, nextB, to);\n      if (start < end) result.push(new Range(start, end));\n    }\n\n    pos = Math.min(nextA, nextB);\n    if (pos == 1e9) break;\n\n    if (nextA == pos) {\n      if (!inA) inA = true;else {\n        inA = false;\n        iA++;\n      }\n    }\n\n    if (nextB == pos) {\n      if (!inB) inB = true;else {\n        inB = false;\n        iB++;\n      }\n    }\n  }\n\n  return result;\n} // Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\n\n\nfunction enterFragments(mounts, ranges) {\n  var result = [];\n\n  var _iterator11 = _createForOfIteratorHelper(mounts),\n      _step11;\n\n  try {\n    var _loop2 = function _loop2() {\n      var _step11$value = _step11.value,\n          pos = _step11$value.pos,\n          mount = _step11$value.mount,\n          frag = _step11$value.frag;\n      var startPos = pos + (mount.overlay ? mount.overlay[0].from : 0),\n          endPos = startPos + mount.tree.length;\n      var from = Math.max(frag.from, startPos),\n          to = Math.min(frag.to, endPos);\n\n      if (mount.overlay) {\n        var overlay = mount.overlay.map(function (r) {\n          return new Range(r.from + pos, r.to + pos);\n        });\n        var changes = findCoverChanges(ranges, overlay, from, to);\n\n        for (var i = 0, _pos2 = from;; i++) {\n          var last = i == changes.length,\n              end = last ? to : changes[i].from;\n          if (end > _pos2) result.push(new TreeFragment(_pos2, end, mount.tree, -startPos, frag.from >= _pos2, frag.to <= end));\n          if (last) break;\n          _pos2 = changes[i].to;\n        }\n      } else {\n        result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));\n      }\n    };\n\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      _loop2();\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  return result;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUFBOztBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7O0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFrQkE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7OztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBN0NBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFVQTtBQUNBOzs7QUE4QkE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7OztBQUVBOzs7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBOztBQUNBOztBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBRUE7QUFDQTs7Ozs7QUFDQTtBQUNBOztBQURBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBRUE7QUFBQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBVUE7QUFDQTtBQWJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBY0E7QUFDQTs7Ozs7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQURBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBSkE7QUFBQTs7QUFBQTtBQUtBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBWkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFhQTtBQUdBO0FBRUE7QUFDQTs7OztBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFEQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBQ0E7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7OztBQUNBO0FBQUE7QUFBQTs7OztBQUVBOzs7QUFDQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUVBO0FBQUE7QUFBQTs7OztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFOQTtBQVFBOztBQUNBO0FBQ0E7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFFQTtBQUFBO0FBQUE7Ozs7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQURBOztBQUdBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFDQTtBQUNBOzs7O0FBRUE7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7OztBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7OztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7OztBQUVBO0FBQUE7QUFBQTs7OztBQUVBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBREE7QUFHQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUFBOztBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBOzs7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBR0E7QUFIQTs7O0FBTUE7O0FBQ0E7QUFDQTtBQUVBOzs7O0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFQQTs7QUFRQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUlBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBS0E7QUFDQTtBQUVBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7OztBQUVBOzs7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7OztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQURBO0FBRUE7OztBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUhBO0FBS0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BOztBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTs7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTs7QUFqRUE7QUFBQTtBQUFBOztBQUlBO0FBQUE7O0FBQUE7QUE4REE7QUFDQTs7Ozs7O0FBRUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFPQTtBQUFBO0FBQUE7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQUE7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBREE7QUFFQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTs7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQW5CQTs7QUFFQTtBQUFBO0FBa0JBO0FBcEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBcUJBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanM/OTY2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGSVhNRSBwcm9maWxlIGFkZGluZyBhIHBlci1UcmVlIFRyZWVOb2RlIGNhY2hlLCB2YWxpZGF0aW5nIGl0IGJ5XG4vLyBwYXJlbnQgcG9pbnRlclxuLy8vIFRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUgKDEwMjQpLlxuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8vLyBFYWNoIFtub2RlIHR5cGVdKCNjb21tb24uTm9kZVR5cGUpIG9yIFtpbmRpdmlkdWFsIHRyZWVdKCNjb21tb24uVHJlZSlcbi8vLyBjYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG4vLy8gY2xhc3MgcmVwcmVzZW50IHByb3AgbmFtZXMuXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLy8vIENyZWF0ZSBhIG5ldyBub2RlIHByb3AgdHlwZS5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLmlkID0gbmV4dFByb3BJRCsrO1xuICAgICAgICB0aGlzLnBlck5vZGUgPSAhIWNvbmZpZy5wZXJOb2RlO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gY29uZmlnLmRlc2VyaWFsaXplIHx8ICgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG5vZGUgdHlwZSBkb2Vzbid0IGRlZmluZSBhIGRlc2VyaWFsaXplIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8vIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgLy8vIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuICAgIC8vLyBbYExSUGFyc2VyLmNvbmZpZ3VyZWBdKCNsci5QYXJzZXJDb25maWcucHJvcHMpIHRvIGNvbXB1dGVcbiAgICAvLy8gcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgLy8vIG9iamVjdF0oI2NvbW1vbi5Ob2RlVHlwZV5tYXRjaCkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHVuZGVmaW5lZFxuICAgIC8vLyBpZiB0aGUgbm9kZSB0eXBlIGRvZXNuJ3QgZ2V0IHRoaXMgcHJvcCwgYW5kIHRoZSBwcm9wJ3MgdmFsdWUgaWZcbiAgICAvLy8gaXQgZG9lcy5cbiAgICBhZGQobWF0Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMucGVyTm9kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgYWRkIHBlci1ub2RlIHByb3BzIHRvIG5vZGUgdHlwZXNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgbWF0Y2ggPSBOb2RlVHlwZS5tYXRjaChtYXRjaCk7XG4gICAgICAgIHJldHVybiAodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IFt0aGlzLCByZXN1bHRdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8vLyBQcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuLy8vIGRlbGltaXRlcnMsIHRoaXMgaG9sZHMgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lcyAod3JpdHRlbiBhcyBhXG4vLy8gc3BhY2Utc2VwYXJhdGVkIHN0cmluZyB3aGVuIGRlY2xhcmluZyB0aGlzIHByb3AgaW4gYSBncmFtbWFyKVxuLy8vIGZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbk5vZGVQcm9wLmNsb3NlZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFRoZSBpbnZlcnNlIG9mIFtgY2xvc2VkQnlgXSgjY29tbW9uLk5vZGVQcm9wXmNsb3NlZEJ5KS4gVGhpcyBpc1xuLy8vIGF0dGFjaGVkIHRvIGNsb3NpbmcgZGVsaW1pdGVycywgaG9sZGluZyBhbiBhcnJheSBvZiBub2RlIG5hbWVzXG4vLy8gb2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuTm9kZVByb3Aub3BlbmVkQnkgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vLy8gVXNlZCB0byBhc3NpZ24gbm9kZSB0eXBlcyB0byBncm91cHMgKGZvciBleGFtcGxlLCBhbGwgbm9kZVxuLy8vIHR5cGVzIHRoYXQgcmVwcmVzZW50IGFuIGV4cHJlc3Npb24gY291bGQgYmUgdGFnZ2VkIHdpdGggYW5cbi8vLyBgXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbk5vZGVQcm9wLmdyb3VwID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFRoZSBoYXNoIG9mIHRoZSBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyLmNvbnN0cnVjdG9yKVxuLy8vIHRoYXQgdGhlIG5vZGUgd2FzIHBhcnNlZCBpbiwgaWYgYW55LiBVc2VkIHRvIGxpbWl0IHJldXNlIG9mXG4vLy8gY29udGV4dHVhbCBub2Rlcy5cbk5vZGVQcm9wLmNvbnRleHRIYXNoID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8vLyBUaGUgZGlzdGFuY2UgYmV5b25kIHRoZSBlbmQgb2YgdGhlIG5vZGUgdGhhdCB0aGUgdG9rZW5pemVyXG4vLy8gbG9va2VkIGFoZWFkIGZvciBhbnkgb2YgdGhlIHRva2VucyBpbnNpZGUgdGhlIG5vZGUuIChUaGUgTFJcbi8vLyBwYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3Jcbi8vLyBlZmZpY2llbmN5IHJlYXNvbnMuKVxuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8vLyBUaGlzIHBlci1ub2RlIHByb3AgaXMgdXNlZCB0byByZXBsYWNlIGEgZ2l2ZW4gbm9kZSwgb3IgcGFydCBvZiBhXG4vLy8gbm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuLy8vIGRpZmZlcmVudCBsYW5ndWFnZXMuXG5Ob2RlUHJvcC5tb3VudGVkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8vLyBBIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbi8vLyBhIHRyZWUgbm9kZSB0byBpbmRpY2F0ZSB0aGF0IHBhcnRzIG9mIGl0cyBjb250ZW50IGFyZVxuLy8vIHJlcHJlc2VudGVkIGJ5IGFub3RoZXIgdHJlZS5cbmNsYXNzIE1vdW50ZWRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIGlubmVyIHRyZWUuXG4gICAgdHJlZSwgXG4gICAgLy8vIElmIHRoaXMgaXMgbnVsbCwgdGhpcyB0cmVlIHJlcGxhY2VzIHRoZSBlbnRpcmUgbm9kZSAoaXQgd2lsbFxuICAgIC8vLyBiZSBpbmNsdWRlZCBpbiB0aGUgcmVndWxhciBpdGVyYXRpb24gaW5zdGVhZCBvZiBpdHMgaG9zdFxuICAgIC8vLyBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICAvLy8gY292ZXJlZCBieSB0aGlzIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgdHJlZXMgdGhhdCBhcmUgbWl4ZWQgaW5cbiAgICAvLy8gYSB3YXkgdGhhdCBpc24ndCBzdHJpY3RseSBoaWVyYXJjaGljYWwuIFN1Y2ggbW91bnRlZCB0cmVlcyBhcmVcbiAgICAvLy8gb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICAvLy8gYW5kIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLlxuICAgIG92ZXJsYXksIFxuICAgIC8vLyBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICBwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxufVxuY29uc3Qgbm9Qcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vLy8gRWFjaCBub2RlIGluIGEgc3ludGF4IHRyZWUgaGFzIGEgbm9kZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICAvLy8gZ3JhbW1hciB3YXMgd3JpdHRlbiBwcm9wZXJseSwgZGlmZmVyZW50IG5vZGUgdHlwZXMgd2l0aCB0aGVcbiAgICAvLy8gc2FtZSBuYW1lIHdpdGhpbiBhIG5vZGUgc2V0IHNob3VsZCBwbGF5IHRoZSBzYW1lIHNlbWFudGljXG4gICAgLy8vIHJvbGUuXG4gICAgbmFtZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHByb3BzLCBcbiAgICAvLy8gVGhlIGlkIG9mIHRoaXMgbm9kZSBpbiBpdHMgc2V0LiBDb3JyZXNwb25kcyB0byB0aGUgdGVybSBpZHNcbiAgICAvLy8gdXNlZCBpbiB0aGUgcGFyc2VyLlxuICAgIGlkLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgZmxhZ3MgPSAwKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIHN0YXRpYyBkZWZpbmUoc3BlYykge1xuICAgICAgICBsZXQgcHJvcHMgPSBzcGVjLnByb3BzICYmIHNwZWMucHJvcHMubGVuZ3RoID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IG5vUHJvcHM7XG4gICAgICAgIGxldCBmbGFncyA9IChzcGVjLnRvcCA/IDEgLyogVG9wICovIDogMCkgfCAoc3BlYy5za2lwcGVkID8gMiAvKiBTa2lwcGVkICovIDogMCkgfFxuICAgICAgICAgICAgKHNwZWMuZXJyb3IgPyA0IC8qIEVycm9yICovIDogMCkgfCAoc3BlYy5uYW1lID09IG51bGwgPyA4IC8qIEFub255bW91cyAqLyA6IDApO1xuICAgICAgICBsZXQgdHlwZSA9IG5ldyBOb2RlVHlwZShzcGVjLm5hbWUgfHwgXCJcIiwgcHJvcHMsIHNwZWMuaWQsIGZsYWdzKTtcbiAgICAgICAgaWYgKHNwZWMucHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBzcmMgb2Ygc3BlYy5wcm9wcykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzcmMpKVxuICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmModHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3JjWzBdLnBlck5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IHN0b3JlIGEgcGVyLW5vZGUgcHJvcCBvbiBhIG5vZGUgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbc3JjWzBdLmlkXSA9IHNyY1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICAvLy8gUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgLy8vIHRoZSBwcm9wIGlzbid0IHByZXNlbnQgb24gdGhpcyBub2RlLlxuICAgIHByb3AocHJvcCkgeyByZXR1cm4gdGhpcy5wcm9wc1twcm9wLmlkXTsgfVxuICAgIC8vLyBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgIGdldCBpc1RvcCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBUb3AgKi8pID4gMDsgfVxuICAgIC8vLyBUcnVlIHdoZW4gdGhpcyBub2RlIGlzIHByb2R1Y2VkIGJ5IGEgc2tpcCBydWxlLlxuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLy8vIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYW4gZXJyb3Igbm9kZS5cbiAgICBnZXQgaXNFcnJvcigpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgNCAvKiBFcnJvciAqLykgPiAwOyB9XG4gICAgLy8vIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIC8vLyBuYW1lZCBub2RlLCBmb3IgZXhhbXBsZSBiZWNhdXNlIGl0IGlzIHVzZWQgdG8gY2FjaGUgcmVwZXRpdGlvbi5cbiAgICBnZXQgaXNBbm9ueW1vdXMoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDggLyogQW5vbnltb3VzICovKSA+IDA7IH1cbiAgICAvLy8gUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgLy8vIFtncm91cHNdKCNjb21tb24uTm9kZVByb3BeZ3JvdXApIG1hdGNoZXMgdGhlIGdpdmVuIHN0cmluZy5cbiAgICBpcyhuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHRoaXMubmFtZSA9PSBuYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbGV0IGdyb3VwID0gdGhpcy5wcm9wKE5vZGVQcm9wLmdyb3VwKTtcbiAgICAgICAgICAgIHJldHVybiBncm91cCA/IGdyb3VwLmluZGV4T2YobmFtZSkgPiAtMSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlkID09IG5hbWU7XG4gICAgfVxuICAgIC8vLyBDcmVhdGUgYSBmdW5jdGlvbiBmcm9tIG5vZGUgdHlwZXMgdG8gYXJiaXRyYXJ5IHZhbHVlcyBieVxuICAgIC8vLyBzcGVjaWZ5aW5nIGFuIG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBuYW1lcyBhcmUgbm9kZSBvclxuICAgIC8vLyBbZ3JvdXBdKCNjb21tb24uTm9kZVByb3BeZ3JvdXApIG5hbWVzLiBPZnRlbiB1c2VmdWwgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICAvLy8gbmFtZXMsIHNlcGFyYXRlZCBieSBzcGFjZXMsIGluIGEgc2luZ2xlIHByb3BlcnR5IG5hbWUgdG8gbWFwXG4gICAgLy8vIG11bHRpcGxlIG5vZGUgbmFtZXMgdG8gYSBzaW5nbGUgdmFsdWUuXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vLyBBbiBlbXB0eSBkdW1teSBub2RlIHR5cGUgdG8gdXNlIHdoZW4gbm8gYWN0dWFsIHR5cGUgaXMgYXZhaWxhYmxlLlxuTm9kZVR5cGUubm9uZSA9IG5ldyBOb2RlVHlwZShcIlwiLCBPYmplY3QuY3JlYXRlKG51bGwpLCAwLCA4IC8qIEFub255bW91cyAqLyk7XG4vLy8gQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuLy8vIGNvbXBhY3RseSByZXByZXNlbnQgdHJlZXMgYnkgc3RvcmluZyB0aGVpciB0eXBlIGlkcywgcmF0aGVyIHRoYW4gYVxuLy8vIGZ1bGwgcG9pbnRlciB0byB0aGUgdHlwZSBvYmplY3QsIGluIGEgbnVtZXJpYyBhcnJheS4gRWFjaCBwYXJzZXJcbi8vLyBbaGFzXSgjbHIuTFJQYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG4vLy8gYnVmZmVyc10oI2NvbW1vbi5UcmVlQnVmZmVyKSBjYW4gb25seSBzdG9yZSBjb2xsZWN0aW9ucyBvZiBub2Rlc1xuLy8vIGZyb20gdGhlIHNhbWUgc2V0LiBBIHNldCBjYW4gaGF2ZSBhIG1heGltdW0gb2YgMioqMTYgKDY1NTM2KSBub2RlXG4vLy8gdHlwZXMgaW4gaXQsIHNvIHRoYXQgdGhlIGlkcyBmaXQgaW50byAxNi1iaXQgdHlwZWQgYXJyYXkgc2xvdHMuXG5jbGFzcyBOb2RlU2V0IHtcbiAgICAvLy8gQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgLy8vIHR5cGUgc2hvdWxkIGNvcnJlc3BvbmQgdG8gaXRzIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXJyYXkuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICB0eXBlcykge1xuICAgICAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodHlwZXNbaV0uaWQgIT0gaSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBpZHMgc2hvdWxkIGNvcnJlc3BvbmQgdG8gYXJyYXkgcG9zaXRpb25zIHdoZW4gY3JlYXRpbmcgYSBub2RlIHNldFwiKTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBzZXQgd2l0aCBzb21lIG5vZGUgcHJvcGVydGllcyBhZGRlZC4gVGhlXG4gICAgLy8vIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY3JlYXRlZCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLlxuICAgIGV4dGVuZCguLi5wcm9wcykge1xuICAgICAgICBsZXQgbmV3VHlwZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBvZiB0aGlzLnR5cGVzKSB7XG4gICAgICAgICAgICBsZXQgbmV3UHJvcHMgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgc291cmNlIG9mIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFkZCA9IHNvdXJjZSh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3UHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGUucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1thZGRbMF0uaWRdID0gYWRkWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1R5cGVzLnB1c2gobmV3UHJvcHMgPyBuZXcgTm9kZVR5cGUodHlwZS5uYW1lLCBuZXdQcm9wcywgdHlwZS5pZCwgdHlwZS5mbGFncykgOiB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZXQobmV3VHlwZXMpO1xuICAgIH1cbn1cbmNvbnN0IENhY2hlZE5vZGUgPSBuZXcgV2Vha01hcCgpO1xuLy8vIEEgcGllY2Ugb2Ygc3ludGF4IHRyZWUuIFRoZXJlIGFyZSB0d28gd2F5cyB0byBhcHByb2FjaCB0aGVzZVxuLy8vIHRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbi8vLyBjb252ZW5pZW50IHdheS5cbi8vL1xuLy8vIFN5bnRheCB0cmVlcyBhcmUgc3RvcmVkIGFzIGEgdHJlZSBvZiBgVHJlZWAgYW5kIGBUcmVlQnVmZmVyYFxuLy8vIG9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbi8vLyBub2RlcywgdGhlIHJlcHJlc2VudGF0aW9uIGlzIG1hZGUgYSBsb3QgbW9yZSBtZW1vcnktZWZmaWNpZW50LlxuLy8vXG4vLy8gSG93ZXZlciwgd2hlbiB5b3Ugd2FudCB0byBhY3R1YWxseSB3b3JrIHdpdGggdHJlZSBub2RlcywgdGhpc1xuLy8vIHJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbi8vLyB1c2UgdGhlIFtgVHJlZUN1cnNvcmBdKCNjb21tb24uVHJlZUN1cnNvcikgb3Jcbi8vLyBbYFN5bnRheE5vZGVgXSgjY29tbW9uLlN5bnRheE5vZGUpIGludGVyZmFjZSBpbnN0ZWFkLCB3aGljaCBwcm92aWRlc1xuLy8vIGEgdmlldyBvbiBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvXG4vLy8gbW92ZSBhcm91bmQgdG8gYWRqYWNlbnQgbm9kZXMuXG5jbGFzcyBUcmVlIHtcbiAgICAvLy8gQ29uc3RydWN0IGEgbmV3IHRyZWUuIFNlZSBhbHNvIFtgVHJlZS5idWlsZGBdKCNjb21tb24uVHJlZV5idWlsZCkuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSB0eXBlIG9mIHRoZSB0b3Agbm9kZS5cbiAgICB0eXBlLCBcbiAgICAvLy8gVGhpcyBub2RlJ3MgY2hpbGQgbm9kZXMuXG4gICAgY2hpbGRyZW4sIFxuICAgIC8vLyBUaGUgcG9zaXRpb25zIChvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGlzIHRyZWUpIG9mXG4gICAgLy8vIHRoZSBjaGlsZHJlbi5cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdHJlZVxuICAgIGxlbmd0aCwgXG4gICAgLy8vIFBlci1ub2RlIFtub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wKSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIG5vZGUuXG4gICAgcHJvcHMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5wcm9wcyA9IG51bGw7XG4gICAgICAgIGlmIChwcm9wcyAmJiBwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgW3Byb3AsIHZhbHVlXSBvZiBwcm9wcylcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzW3R5cGVvZiBwcm9wID09IFwibnVtYmVyXCIgPyBwcm9wIDogcHJvcC5pZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBtb3VudGVkID0gdGhpcy5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgcmV0dXJuIG1vdW50ZWQudHJlZS50b1N0cmluZygpO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gY2gudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IFwiLFwiO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHJvb3RlZCBhdCB0aGlzIHRyZWUuIFdoZW5cbiAgICAvLy8gYHBvc2AgaXMgZ2l2ZW4sIHRoZSBjdXJzb3IgaXMgW21vdmVkXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKVxuICAgIC8vLyB0byB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUuXG4gICAgY3Vyc29yKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgbGV0IHNjb3BlID0gKHBvcyAhPSBudWxsICYmIENhY2hlZE5vZGUuZ2V0KHRoaXMpKSB8fCB0aGlzLnRvcE5vZGU7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihzY29wZSk7XG4gICAgICAgIGlmIChwb3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpO1xuICAgICAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgY3Vyc29yLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHRoYXQsIHVubGlrZSByZWd1bGFyXG4gICAgLy8vIGN1cnNvcnMsIGRvZXNuJ3Qgc2tpcCB0aHJvdWdoXG4gICAgLy8vIFthbm9ueW1vdXNdKCNjb21tb24uTm9kZVR5cGUuaXNBbm9ueW1vdXMpIG5vZGVzLlxuICAgIGZ1bGxDdXJzb3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLnRvcE5vZGUsIDEgLyogRnVsbCAqLyk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIC8vLyB0cmVlLlxuICAgIGdldCB0b3BOb2RlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHRoaXMsIDAsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIC8vLyBJZiBgc2lkZWAgaXMgLTEsIHRoaXMgd2lsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBlbmQgYXQgdGhlXG4gICAgLy8vIHBvc2l0aW9uLiBJZiAxLCBpdCdsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBzdGFydCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIC8vLyBmcm9tIGJvdGggc2lkZXMuXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvcihwb3MsIHNpZGUpLm5vZGU7XG4gICAgfVxuICAgIC8vLyBMaWtlIFtgcmVzb2x2ZWBdKCNjb21tb24uVHJlZS5yZXNvbHZlKSwgYnV0IHdpbGwgZW50ZXJcbiAgICAvLy8gW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpIG5vZGVzLCBwcm9kdWNpbmcgYSBzeW50YXggbm9kZVxuICAgIC8vLyBwb2ludGluZyBpbnRvIHRoZSBpbm5lcm1vc3Qgb3ZlcmxhaWQgdHJlZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICAvLy8gKHdpdGggcGFyZW50IGxpbmtzIGdvaW5nIHRocm91Z2ggYWxsIHBhcmVudCBzdHJ1Y3R1cmUsIGluY2x1ZGluZ1xuICAgIC8vLyB0aGUgaG9zdCB0cmVlcykuXG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMudG9wTm9kZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gcmVzdWx0LmVudGVyKHBvcywgc2lkZSk7XG4gICAgICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQgPSBpbm5lcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgLy8vIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICAvLy8gcnVubmluZyBvdmVyIHN1Y2ggYSBub2RlJ3MgY2hpbGRyZW4sIGFuZCBgbGVhdmVgIChpZiBnaXZlbikgd2hlblxuICAgIC8vLyBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIC8vLyBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IoKSwgZ2V0ID0gKCkgPT4gYy5ub2RlOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjLmZyb20gPD0gdG8gJiYgYy50byA+PSBmcm9tICYmIChjLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIoYy50eXBlLCBjLmZyb20sIGMudG8sIGdldCkgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11c3RMZWF2ZSAmJiBsZWF2ZSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoYy50eXBlLCBjLmZyb20sIGMudG8sIGdldCk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gYy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmIChjLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghYy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIFtub2RlIHByb3BdKCNjb21tb24uTm9kZVByb3ApIGZvciB0aGlzXG4gICAgLy8vIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgcHJvcChwcm9wKSB7XG4gICAgICAgIHJldHVybiAhcHJvcC5wZXJOb2RlID8gdGhpcy50eXBlLnByb3AocHJvcCkgOiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1twcm9wLmlkXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5vZGUncyBbcGVyLW5vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3AucGVyTm9kZSkgaW4gYVxuICAgIC8vLyBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgLy8vIGNvbnN0cnVjdG9yLlxuICAgIGdldCBwcm9wVmFsdWVzKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5wcm9wcylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbK2lkLCB0aGlzLnByb3BzW2lkXV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIC8vLyB3aGljaCBtYXkgaGF2ZSBjaGlsZHJlbiBncm91cGVkIGludG8gc3VidHJlZXMgd2l0aCB0eXBlXG4gICAgLy8vIFtgTm9kZVR5cGUubm9uZWBdKCNjb21tb24uTm9kZVR5cGVebm9uZSkuXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCcmFuY2hGYWN0b3IgKi8gPyB0aGlzIDpcbiAgICAgICAgICAgIGJhbGFuY2VSYW5nZSh0aGlzLnR5cGUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgdGhpcy5sZW5ndGgsIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLnByb3BWYWx1ZXMpLCBjb25maWcubWFrZVRyZWUgfHwgKChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkpKTtcbiAgICB9XG4gICAgLy8vIEJ1aWxkIGEgdHJlZSBmcm9tIGEgcG9zdGZpeC1vcmRlcmVkIGJ1ZmZlciBvZiBub2RlIGluZm9ybWF0aW9uLFxuICAgIC8vLyBvciBhIGN1cnNvciBvdmVyIHN1Y2ggYSBidWZmZXIuXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxufVxuLy8vIFRoZSBlbXB0eSB0cmVlXG5UcmVlLmVtcHR5ID0gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCAwKTtcbmNsYXNzIEZsYXRCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIHRoaXMuaW5kZXg7IH1cbiAgICBuZXh0KCkgeyB0aGlzLmluZGV4IC09IDQ7IH1cbiAgICBmb3JrKCkgeyByZXR1cm4gbmV3IEZsYXRCdWZmZXJDdXJzb3IodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgpOyB9XG59XG4vLy8gVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxuLy8vIG5vZGUuIEluIHN1Y2ggYSBidWZmZXIsIG5vZGVzIGFyZSBzdG9yZWQgaW4gcHJlZml4IG9yZGVyIChwYXJlbnRzXG4vLy8gYmVmb3JlIGNoaWxkcmVuLCB3aXRoIHRoZSBlbmRJbmRleCBvZiB0aGUgcGFyZW50IGluZGljYXRpbmcgd2hpY2hcbi8vLyBjaGlsZHJlbiBiZWxvbmcgdG8gaXQpXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdHJlZSBidWZmZXIuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBidWZmZXIncyBjb250ZW50LlxuICAgIGJ1ZmZlciwgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gVGhlIG5vZGUgc2V0IHVzZWQgaW4gdGhpcyBidWZmZXIuXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIE5vZGVUeXBlLm5vbmU7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZpbmRDaGlsZChzdGFydEluZGV4LCBlbmRJbmRleCwgZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLCBwaWNrID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpICE9IGVuZEluZGV4OyBpID0gYnVmZmVyW2kgKyAzXSkge1xuICAgICAgICAgICAgaWYgKGNoZWNrU2lkZShzaWRlLCBwb3MsIGJ1ZmZlcltpICsgMV0sIGJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgYiA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgY29weSA9IG5ldyBVaW50MTZBcnJheShlbmRJIC0gc3RhcnRJKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SSwgaiA9IDA7IGkgPCBlbmRJOykge1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gZnJvbTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBzdGFydEk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQnVmZmVyKGNvcHksIHRvIC0gZnJvbSwgdGhpcy5zZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2lkZShzaWRlLCBwb3MsIGZyb20sIHRvKSB7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgLTIgLyogQmVmb3JlICovOiByZXR1cm4gZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAtMSAvKiBBdE9yQmVmb3JlICovOiByZXR1cm4gdG8gPj0gcG9zICYmIGZyb20gPCBwb3M7XG4gICAgICAgIGNhc2UgMCAvKiBBcm91bmQgKi86IHJldHVybiBmcm9tIDwgcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDEgLyogQXRPckFmdGVyICovOiByZXR1cm4gZnJvbSA8PSBwb3MgJiYgdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgMiAvKiBBZnRlciAqLzogcmV0dXJuIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDQgLyogRG9udENhcmUgKi86IHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmNsYXNzIFRyZWVOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBfZnJvbSwgXG4gICAgLy8gSW5kZXggaW4gcGFyZW50IG5vZGUsIHNldCB0byAtMSBpZiB0aGUgbm9kZSBpcyBub3QgYSBkaXJlY3QgY2hpbGQgb2YgX3BhcmVudC5ub2RlIChvdmVybGF5KVxuICAgIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuX2Zyb20gPSBfZnJvbTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMubm9kZS50eXBlOyB9XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLm5vZGUudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLl9mcm9tOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5fZnJvbSArIHRoaXMubm9kZS5sZW5ndGg7IH1cbiAgICBuZXh0Q2hpbGQoaSwgZGlyLCBwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXM7Oykge1xuICAgICAgICAgICAgZm9yIChsZXQgeyBjaGlsZHJlbiwgcG9zaXRpb25zIH0gPSBwYXJlbnQubm9kZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50Ll9mcm9tO1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2tTaWRlKHNpZGUsIHBvcywgc3RhcnQsIHN0YXJ0ICsgbmV4dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgJiAyIC8qIE5vRW50ZXJCdWZmZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbmV4dC5maW5kQ2hpbGQoMCwgbmV4dC5idWZmZXIubGVuZ3RoLCBkaXIsIHBvcyAtIHN0YXJ0LCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUobmV3IEJ1ZmZlckNvbnRleHQocGFyZW50LCBuZXh0LCBpLCBzdGFydCksIG51bGwsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG1vZGUgJiAxIC8qIEZ1bGwgKi8pIHx8ICghbmV4dC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQucHJvcHMgJiYgKG1vdW50ZWQgPSBuZXh0LnByb3AoTm9kZVByb3AubW91bnRlZCkpICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IG5ldyBUcmVlTm9kZShuZXh0LCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtb2RlICYgMSAvKiBGdWxsICovKSB8fCAhaW5uZXIudHlwZS5pc0Fub255bW91cyA/IGlubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobW9kZSAmIDEgLyogRnVsbCAqLykgfHwgIXBhcmVudC50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5pbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgIGkgPSBwYXJlbnQuaW5kZXggKyBkaXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fcGFyZW50Lm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCBwb3MsIC0yIC8qIEJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG92ZXJsYXlzID0gdHJ1ZSwgYnVmZmVycyA9IHRydWUpIHtcbiAgICAgICAgbGV0IG1vdW50ZWQ7XG4gICAgICAgIGlmIChvdmVybGF5cyAmJiAobW91bnRlZCA9IHRoaXMubm9kZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIGJ1ZmZlcnMgPyAwIDogMiAvKiBOb0VudGVyQnVmZmVyICovKTtcbiAgICB9XG4gICAgbmV4dFNpZ25pZmljYW50UGFyZW50KCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHZhbC50eXBlLmlzQW5vbnltb3VzICYmIHZhbC5fcGFyZW50KVxuICAgICAgICAgICAgdmFsID0gdmFsLl9wYXJlbnQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4ICsgMSwgMSwgMCwgNCAvKiBEb250Q2FyZSAqLykgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4IC0gMSwgLTEsIDAsIDQgLyogRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IGN1cnNvcigpIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMpOyB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiB0aGlzLm5vZGU7IH1cbiAgICB0b1RyZWUoKSB7IHJldHVybiB0aGlzLm5vZGU7IH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpLm5vZGU7XG4gICAgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5ub2RlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IsIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIHdoaWxlICghY3VyLnR5cGUuaXMoYmVmb3JlKSlcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChhZnRlciAhPSBudWxsICYmIGN1ci50eXBlLmlzKGFmdGVyKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cywgYnVmZmVycyA9IHRydWUpIHtcbiAgICAgICAgaWYgKCFidWZmZXJzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgc2lkZSA+IDAgPyAxIDogLTEsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICB9XG4gICAgZXh0ZXJuYWxTaWJsaW5nKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gbnVsbCA6IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dENoaWxkKHRoaXMuY29udGV4dC5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIERvbnRDYXJlICovKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgY3Vyc29yKCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcyk7IH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXSwgdG8gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xuICAgIH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpLm5vZGU7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxufVxuLy8vIEEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuLy8vIGFsbG93cyB5b3UgdG8gbW92ZSB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgbW9kZSA9IDApIHtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBTaG9ydGhhbmQgZm9yIGAudHlwZS5uYW1lYC5cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgeWllbGROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLl90cmVlID0gbm9kZTtcbiAgICAgICAgdGhpcy50eXBlID0gbm9kZS50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSBub2RlLmZyb207XG4gICAgICAgIHRoaXMudG8gPSBub2RlLnRvO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGRCdWYoaW5kZXgsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgeyBzdGFydCwgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBidWZmZXIuc2V0LnR5cGVzW2J1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICAgICAgdGhpcy5mcm9tID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMV07XG4gICAgICAgIHRoaXMudG8gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAyXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpIDogdGhpcy5fdHJlZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZW50ZXJDaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5uZXh0Q2hpbGQoZGlyIDwgMCA/IHRoaXMuX3RyZWUubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLiBXaGVuIHRoaXMgcmV0dXJuc1xuICAgIC8vLyBmYWxzZSwgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBhbmQgdGhlIGN1cnNvciBoYXMgbm90IGJlZW4gbW92ZWQuXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgbGFzdCBjaGlsZC5cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgZmlyc3QgY2hpbGQgdGhhdCBlbmRzIGFmdGVyIGBwb3NgLlxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBsYXN0IGNoaWxkIHRoYXQgc3RhcnRzIGJlZm9yZSBgcG9zYC5cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgY2hpbGQgYXJvdW5kIGBwb3NgLiBJZiBzaWRlIGlzIC0xIHRoZVxuICAgIC8vLyBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcbiAgICAvLy8gd2lsbCBhbHNvIGVudGVyIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KVxuICAgIC8vLyBbbW91bnRlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0cmVlcyB1bmxlc3MgYG92ZXJsYXlzYCBpc1xuICAgIC8vLyBzZXQgdG8gZmFsc2UuXG4gICAgZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cyA9IHRydWUsIGJ1ZmZlcnMgPSB0cnVlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLmVudGVyKHBvcywgc2lkZSwgb3ZlcmxheXMsIGJ1ZmZlcnMpKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnMgPyB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgICBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUoKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLykgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaWJsaW5nKGRpcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl90cmVlLl9wYXJlbnQgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy55aWVsZCh0aGlzLl90cmVlLmluZGV4IDwgMCA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl90cmVlLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuX3RyZWUuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLywgdGhpcy5tb2RlKSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBwcmV2aW91cyBzaWJsaW5nLCBpZiBhbnkuXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5ub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQubm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLm1vZGUgJiAxIC8qIEZ1bGwgKi8pIHx8IGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCAhY2hpbGQudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogRG9udENhcmUgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpYmxpbmcoZGlyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0TGFzdE5vZGUoZGlyKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhXG4gICAgLy8vIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcl8oTkxSKSlcbiAgICAvLy8gdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIC8vLyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgbmV4dChlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgxLCBlbnRlcik7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICAvLy8gbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIC8vLyBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgLy8vIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICAvLy8gaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICAvLy8gcG9zaXRpb24uXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIC8vLyBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgLy8vIGJ1ZmZlcl0oI2NvbW1vbi5UcmVlQnVmZmVyKS5cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUubm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDaGlsZCh0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUuY2hpbGRyZW4uc29tZShjaCA9PiBjaCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgIWNoLnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQoY2gpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVHJlZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IGJ1ZmZlciwgbm9kZVNldCwgbWF4QnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aCwgcmV1c2VkID0gW10sIG1pblJlcGVhdFR5cGUgPSBub2RlU2V0LnR5cGVzLmxlbmd0aCB9ID0gZGF0YTtcbiAgICBsZXQgY3Vyc29yID0gQXJyYXkuaXNBcnJheShidWZmZXIpID8gbmV3IEZsYXRCdWZmZXJDdXJzb3IoYnVmZmVyLCBidWZmZXIubGVuZ3RoKSA6IGJ1ZmZlcjtcbiAgICBsZXQgdHlwZXMgPSBub2RlU2V0LnR5cGVzO1xuICAgIGxldCBjb250ZXh0SGFzaCA9IDAsIGxvb2tBaGVhZCA9IDA7XG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgbGV0IGxvb2tBaGVhZEF0U3RhcnQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHdoaWxlIChzaXplIDwgMCkge1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChzaXplID09IC0xIC8qIFJldXNlICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSByZXVzZWRbaWRdO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIExvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnJlY29nbml6ZWQgcmVjb3JkIHNpemU6ICR7c2l6ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2lkXSwgbm9kZSwgYnVmZmVyO1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBzdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICBpZiAoZW5kIC0gc3RhcnQgPD0gbWF4QnVmZmVyTGVuZ3RoICYmIChidWZmZXIgPSBmaW5kQnVmZmVyU2l6ZShjdXJzb3IucG9zIC0gbWluUG9zLCBpblJlcGVhdCkpKSB7XG4gICAgICAgICAgICAvLyBTbWFsbCBlbm91Z2ggZm9yIGEgYnVmZmVyLCBhbmQgbm8gcmV1c2VkIG5vZGVzIGluc2lkZVxuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNpemUgLSBidWZmZXIuc2tpcCk7XG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIGJ1ZmZlci5zaXplLCBpbmRleCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyLnN0YXJ0LCBkYXRhLCBpbmRleCk7XG4gICAgICAgICAgICBub2RlID0gbmV3IFRyZWVCdWZmZXIoZGF0YSwgZW5kIC0gYnVmZmVyLnN0YXJ0LCBub2RlU2V0KTtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gYnVmZmVyLnN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE1ha2UgaXQgYSBub2RlXG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIHNpemU7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBsb2NhbEluUmVwZWF0ID0gaWQgPj0gbWluUmVwZWF0VHlwZSA/IGlkIDogLTE7XG4gICAgICAgICAgICBsZXQgbGFzdEdyb3VwID0gMCwgbGFzdEVuZCA9IGVuZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBjdXJzb3IuaWQgPT0gbG9jYWxJblJlcGVhdCAmJiBjdXJzb3Iuc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZW5kIDw9IGxhc3RFbmQgLSBtYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBjdXJzb3IuZW5kLCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHcm91cCA9IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVuZCA9IGN1cnNvci5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VOb2RlKHN0YXJ0LCBlbmRQb3MsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsb2NhbEluUmVwZWF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGxhc3RHcm91cCA+IDAgJiYgbGFzdEdyb3VwIDwgbG9jYWxDaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIHN0YXJ0LCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsYXN0R3JvdXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ha2UgPSBtYWtlQmFsYW5jZWQodHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUJhbGFuY2VkKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSAwLCBsYXN0SSA9IGNoaWxkcmVuLmxlbmd0aCAtIDEsIGxhc3QsIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICBpZiAobGFzdEkgPj0gMCAmJiAobGFzdCA9IGNoaWxkcmVuW2xhc3RJXSkgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0SSAmJiBsYXN0LnR5cGUgPT0gdHlwZSAmJiBsYXN0Lmxlbmd0aCA9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICAgICAgICAgIGlmIChsb29rQWhlYWRQcm9wID0gbGFzdC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCkpXG4gICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IHBvc2l0aW9uc1tsYXN0SV0gKyBsYXN0Lmxlbmd0aCArIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUmVwZWF0TGVhZihjaGlsZHJlbiwgcG9zaXRpb25zLCBiYXNlLCBpLCBmcm9tLCB0bywgdHlwZSwgbG9va0FoZWFkKSB7XG4gICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGggPiBpKSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW4ucG9wKCkpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnMucG9wKCkgKyBiYXNlIC0gZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVHJlZShub2RlU2V0LnR5cGVzW3R5cGVdLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgdG8gLSBmcm9tLCBsb29rQWhlYWQgLSB0bykpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gYmFzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkID0gMCwgcHJvcHMpIHtcbiAgICAgICAgaWYgKGNvbnRleHRIYXNoKSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5jb250ZXh0SGFzaCwgY29udGV4dEhhc2hdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiAyNSkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AubG9va0FoZWFkLCBsb29rQWhlYWRdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHByb3BzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEJ1ZmZlclNpemUobWF4U2l6ZSwgaW5SZXBlYXQpIHtcbiAgICAgICAgLy8gU2NhbiB0aHJvdWdoIHRoZSBidWZmZXIgdG8gZmluZCBwcmV2aW91cyBzaWJsaW5ncyB0aGF0IGZpdFxuICAgICAgICAvLyB0b2dldGhlciBpbiBhIFRyZWVCdWZmZXIsIGFuZCBkb24ndCBjb250YWluIGFueSByZXVzZWQgbm9kZXNcbiAgICAgICAgLy8gKHdoaWNoIGNhbid0IGJlIHN0b3JlZCBpbiBhIGJ1ZmZlcikuXG4gICAgICAgIC8vIElmIGBpblJlcGVhdGAgaXMgPiAtMSwgaWdub3JlIG5vZGUgYm91bmRhcmllcyBvZiB0aGF0IHR5cGUgZm9yXG4gICAgICAgIC8vIG5lc3RpbmcsIGJ1dCBtYWtlIHN1cmUgdGhlIGVuZCBmYWxscyBlaXRoZXIgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vIChgbWF4U2l6ZWApIG9yIGJlZm9yZSBzdWNoIGEgbm9kZS5cbiAgICAgICAgbGV0IGZvcmsgPSBjdXJzb3IuZm9yaygpO1xuICAgICAgICBsZXQgc2l6ZSA9IDAsIHN0YXJ0ID0gMCwgc2tpcCA9IDAsIG1pblN0YXJ0ID0gZm9yay5lbmQgLSBtYXhCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHNpemU6IDAsIHN0YXJ0OiAwLCBza2lwOiAwIH07XG4gICAgICAgIHNjYW46IGZvciAobGV0IG1pblBvcyA9IGZvcmsucG9zIC0gbWF4U2l6ZTsgZm9yay5wb3MgPiBtaW5Qb3M7KSB7XG4gICAgICAgICAgICBsZXQgbm9kZVNpemUgPSBmb3JrLnNpemU7XG4gICAgICAgICAgICAvLyBQcmV0ZW5kIG5lc3RlZCByZXBlYXQgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZSBkb24ndCBleGlzdFxuICAgICAgICAgICAgaWYgKGZvcmsuaWQgPT0gaW5SZXBlYXQgJiYgbm9kZVNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCB0aGF0IHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIGFzIGEgdmFsaWQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgICAgICAgICBza2lwICs9IDQ7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0UG9zID0gZm9yay5wb3MgLSBub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChub2RlU2l6ZSA8IDAgfHwgc3RhcnRQb3MgPCBtaW5Qb3MgfHwgZm9yay5zdGFydCA8IG1pblN0YXJ0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGxvY2FsU2tpcHBlZCA9IGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSA/IDQgOiAwO1xuICAgICAgICAgICAgbGV0IG5vZGVTdGFydCA9IGZvcmsuc3RhcnQ7XG4gICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlIChmb3JrLnBvcyA+IHN0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChzaXplID49IDAgJiYgaWQgPCBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXG4gICAgICAgIHRha2VOb2RlKGRhdGEuc3RhcnQgfHwgMCwgZGF0YS5idWZmZXJTdGFydCB8fCAwLCBjaGlsZHJlbiwgcG9zaXRpb25zLCAtMSk7XG4gICAgbGV0IGxlbmd0aCA9IChfYSA9IGRhdGEubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoY2hpbGRyZW4ubGVuZ3RoID8gcG9zaXRpb25zWzBdICsgY2hpbGRyZW5bMF0ubGVuZ3RoIDogMCk7XG4gICAgcmV0dXJuIG5ldyBUcmVlKHR5cGVzW2RhdGEudG9wSURdLCBjaGlsZHJlbi5yZXZlcnNlKCksIHBvc2l0aW9ucy5yZXZlcnNlKCksIGxlbmd0aCk7XG59XG5jb25zdCBub2RlU2l6ZUNhY2hlID0gbmV3IFdlYWtNYXA7XG5mdW5jdGlvbiBub2RlU2l6ZShiYWxhbmNlVHlwZSwgbm9kZSkge1xuICAgIGlmICghYmFsYW5jZVR5cGUuaXNBbm9ueW1vdXMgfHwgbm9kZSBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgbm9kZS50eXBlICE9IGJhbGFuY2VUeXBlKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgc2l6ZSA9IG5vZGVTaXplQ2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChzaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IG5vZGUuY2hpbGRyZW4ucmVkdWNlKChzLCBjaCkgPT4gcyArIG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaCksIDEpO1xuICAgICAgICBub2RlU2l6ZUNhY2hlLnNldChub2RlLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBiYWxhbmNlUmFuZ2UoXG4vLyBUaGUgdHlwZSB0byB0YWcgdGhlIHJlc3VsdGluZyB0cmVlIHdpdGguIFdpbGwgYWxzbyBiZSB1c2VkIGZvclxuLy8gaW50ZXJuYWwgbm9kZXMgd2hlbiBpdCBpcyBhbiBhbm9ueW1vdXMgdHlwZVxudHlwZSwgXG4vLyBUaGUgZGlyZWN0IGNoaWxkcmVuIGFuZCB0aGVpciBwb3NpdGlvbnNcbmNoaWxkcmVuLCBwb3NpdGlvbnMsIFxuLy8gVGhlIGluZGV4IHJhbmdlIGluIGNoaWxkcmVuL3Bvc2l0aW9ucyB0byB1c2VcbmZyb20sIHRvLCBcbi8vIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgbm9kZXMsIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudC5cbnN0YXJ0LCBcbi8vIExlbmd0aCBvZiB0aGUgb3V0ZXIgbm9kZVxubGVuZ3RoLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIHRoZSB0b3Agbm9kZSBvZiB0aGUgYmFsYW5jZWQgdHJlZVxubWtUb3AsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgaW50ZXJuYWwgbm9kZXMgZm9yIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RyZWUpIHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgICAgdG90YWwgKz0gbm9kZVNpemUodHlwZSwgY2hpbGRyZW5baV0pO1xuICAgIGxldCBtYXhDaGlsZCA9IE1hdGguY2VpbCgodG90YWwgKiAxLjUpIC8gOCAvKiBCcmFuY2hGYWN0b3IgKi8pO1xuICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgZnVuY3Rpb24gZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCBncm91cEZyb20gPSBpLCBncm91cFN0YXJ0ID0gcG9zaXRpb25zW2ldLCBncm91cFNpemUgPSBub2RlU2l6ZSh0eXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFNpemUgPSBub2RlU2l6ZSh0eXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSArIG5leHRTaXplID49IG1heENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBncm91cFNpemUgKz0gbmV4dFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSA+IG1heENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTtcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlKG9ubHkuY2hpbGRyZW4sIG9ubHkucG9zaXRpb25zLCAwLCBvbmx5LmNoaWxkcmVuLmxlbmd0aCwgcG9zaXRpb25zW2dyb3VwRnJvbV0gKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuW2dyb3VwRnJvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHBvc2l0aW9uc1tpIC0gMV0gKyBjaGlsZHJlbltpIC0gMV0ubGVuZ3RoIC0gZ3JvdXBTdGFydDtcbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goYmFsYW5jZVJhbmdlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbGVuZ3RoLCBudWxsLCBta1RyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCArIG9mZnNldCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIDApO1xuICAgIHJldHVybiAobWtUb3AgfHwgbWtUcmVlKShsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cblxuLy8vIFRyZWUgZnJhZ21lbnRzIGFyZSB1c2VkIGR1cmluZyBbaW5jcmVtZW50YWxcbi8vLyBwYXJzaW5nXSgjY29tbW9uLlBhcnNlci5zdGFydFBhcnNlKSB0byB0cmFjayBwYXJ0cyBvZiBvbGQgdHJlZXNcbi8vLyB0aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG4vLy8gdG8gdHJhY2sgcmVnaW9ucyBvZiBhbiBvbGQgdHJlZSB3aG9zZSBub2RlcyBtaWdodCBiZSByZXVzZWQgaW4gbmV3XG4vLy8gcGFyc2VzLiBVc2UgdGhlIHN0YXRpY1xuLy8vIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbi8vLyB1cGRhdGUgZnJhZ21lbnRzIGZvciBkb2N1bWVudCBjaGFuZ2VzLlxuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvLy8gQ29uc3RydWN0IGEgdHJlZSBmcmFnbWVudC5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIC8vLyBUaGlzIHJlZmVycyB0byBhbiBvZmZzZXQgaW4gdGhlIF91cGRhdGVkXyBkb2N1bWVudCAoYXMgb3Bwb3NlZFxuICAgIC8vLyB0byB0aGUgb3JpZ2luYWwgdHJlZSkuXG4gICAgZnJvbSwgXG4gICAgLy8vIFRoZSBlbmQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZS5cbiAgICB0bywgXG4gICAgLy8vIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICB0cmVlLCBcbiAgICAvLy8gVGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBmcmFnbWVudCdzIHRyZWUgYW5kIHRoZSBkb2N1bWVudCB0aGF0XG4gICAgLy8vIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgLy8vIGRvY3VtZW50IHRvIHRyZWUgcG9zaXRpb25zLCBzdWJ0cmFjdCBpdCB0byBnbyBmcm9tIHRyZWUgdG9cbiAgICAvLy8gZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBTdGFydCAqLyA6IDApIHwgKG9wZW5FbmQgPyAyIC8qIEVuZCAqLyA6IDApO1xuICAgIH1cbiAgICAvLy8gV2hldGhlciB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGFcbiAgICAvLy8gcGFyc2UsIG9yIHRoZSBlbmQgb2YgYSBjaGFuZ2UuIChJbiB0aGUgc2Vjb25kIGNhc2UsIGl0IG1heSBub3RcbiAgICAvLy8gYmUgc2FmZSB0byByZXVzZSBzb21lIG5vZGVzIGF0IHRoZSBzdGFydCwgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vLyBwYXJzaW5nIGFsZ29yaXRobS4pXG4gICAgZ2V0IG9wZW5TdGFydCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAxIC8qIFN0YXJ0ICovKSA+IDA7IH1cbiAgICAvLy8gV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIC8vLyBmdWxsLWRvY3VtZW50IHBhcnNlLCBvciB0aGUgc3RhcnQgb2YgYSBjaGFuZ2UuXG4gICAgZ2V0IG9wZW5FbmQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMiAvKiBFbmQgKi8pID4gMDsgfVxuICAgIC8vLyBDcmVhdGUgYSBzZXQgb2YgZnJhZ21lbnRzIGZyb20gYSBmcmVzaGx5IHBhcnNlZCB0cmVlLCBvciB1cGRhdGVcbiAgICAvLy8gYW4gZXhpc3Rpbmcgc2V0IG9mIGZyYWdtZW50cyBieSByZXBsYWNpbmcgdGhlIG9uZXMgdGhhdCBvdmVybGFwXG4gICAgLy8vIHdpdGggYSB0cmVlIHdpdGggY29udGVudCBmcm9tIHRoZSBuZXcgdHJlZS4gV2hlbiBgcGFydGlhbGAgaXNcbiAgICAvLy8gdHJ1ZSwgdGhlIHBhcnNlIGlzIHRyZWF0ZWQgYXMgaW5jb21wbGV0ZSwgYW5kIHRoZSByZXN1bHRpbmdcbiAgICAvLy8gZnJhZ21lbnQgaGFzIFtgb3BlbkVuZGBdKCNjb21tb24uVHJlZUZyYWdtZW50Lm9wZW5FbmQpIHNldCB0b1xuICAgIC8vLyB0cnVlLlxuICAgIHN0YXRpYyBhZGRUcmVlKHRyZWUsIGZyYWdtZW50cyA9IFtdLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtuZXcgVHJlZUZyYWdtZW50KDAsIHRyZWUubGVuZ3RoLCB0cmVlLCAwLCBmYWxzZSwgcGFydGlhbCldO1xuICAgICAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cylcbiAgICAgICAgICAgIGlmIChmLnRvID4gdHJlZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBBcHBseSBhIHNldCBvZiBlZGl0cyB0byBhbiBhcnJheSBvZiBmcmFnbWVudHMsIHJlbW92aW5nIG9yXG4gICAgLy8vIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICAvLy8gYWRqdXN0aW5nIG9mZnNldHMgZm9yIGZyYWdtZW50cyB0aGF0IG1vdmVkLlxuICAgIHN0YXRpYyBhcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBjaGFuZ2VzLCBtaW5HYXAgPSAxMjgpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGZJID0gMSwgbmV4dEYgPSBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgY0kgPSAwLCBwb3MgPSAwLCBvZmYgPSAwOzsgY0krKykge1xuICAgICAgICAgICAgbGV0IG5leHRDID0gY0kgPCBjaGFuZ2VzLmxlbmd0aCA/IGNoYW5nZXNbY0ldIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dEMgPyBuZXh0Qy5mcm9tQSA6IDFlOTtcbiAgICAgICAgICAgIGlmIChuZXh0UG9zIC0gcG9zID49IG1pbkdhcClcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dEYgJiYgbmV4dEYuZnJvbSA8IG5leHRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1dCA9IG5leHRGO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID49IGN1dC5mcm9tIHx8IG5leHRQb3MgPD0gY3V0LnRvIHx8IG9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZGcm9tID0gTWF0aC5tYXgoY3V0LmZyb20sIHBvcykgLSBvZmYsIGZUbyA9IE1hdGgubWluKGN1dC50bywgbmV4dFBvcykgLSBvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXQgPSBmRnJvbSA+PSBmVG8gPyBudWxsIDogbmV3IFRyZWVGcmFnbWVudChmRnJvbSwgZlRvLCBjdXQudHJlZSwgY3V0Lm9mZnNldCArIG9mZiwgY0kgPiAwLCAhIW5leHRDKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRGLnRvID4gbmV4dFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBuZXh0RiA9IGZJIDwgZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1tmSSsrXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0QylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHRDLnRvQTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRDLnRvQSAtIG5leHRDLnRvQjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vLyBBIHN1cGVyY2xhc3MgdGhhdCBwYXJzZXJzIHNob3VsZCBleHRlbmQuXG5jbGFzcyBQYXJzZXIge1xuICAgIC8vLyBTdGFydCBhIHBhcnNlLCByZXR1cm5pbmcgYSBbcGFydGlhbCBwYXJzZV0oI2NvbW1vbi5QYXJ0aWFsUGFyc2UpXG4gICAgLy8vIG9iamVjdC4gW2BmcmFnbWVudHNgXSgjY29tbW9uLlRyZWVGcmFnbWVudCkgY2FuIGJlIHBhc3NlZCBpbiB0b1xuICAgIC8vLyBtYWtlIHRoZSBwYXJzZSBpbmNyZW1lbnRhbC5cbiAgICAvLy9cbiAgICAvLy8gQnkgZGVmYXVsdCwgdGhlIGVudGlyZSBpbnB1dCBpcyBwYXJzZWQuIFlvdSBjYW4gcGFzcyBgcmFuZ2VzYCxcbiAgICAvLy8gd2hpY2ggc2hvdWxkIGJlIGEgc29ydGVkIGFycmF5IG9mIG5vbi1lbXB0eSwgbm9uLW92ZXJsYXBwaW5nXG4gICAgLy8vIHJhbmdlcywgdG8gcGFyc2Ugb25seSB0aG9zZSByYW5nZXMuIFRoZSB0cmVlIHJldHVybmVkIGluIHRoYXRcbiAgICAvLy8gY2FzZSB3aWxsIHN0YXJ0IGF0IGByYW5nZXNbMF0uZnJvbWAuXG4gICAgc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5wdXQgPSBuZXcgU3RyaW5nSW5wdXQoaW5wdXQpO1xuICAgICAgICByYW5nZXMgPSAhcmFuZ2VzID8gW25ldyBSYW5nZSgwLCBpbnB1dC5sZW5ndGgpXSA6IHJhbmdlcy5sZW5ndGggPyByYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSwgci50bykpIDogW25ldyBSYW5nZSgwLCAwKV07XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMgfHwgW10sIHJhbmdlcyk7XG4gICAgfVxuICAgIC8vLyBSdW4gYSBmdWxsIHBhcnNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgIHBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBsZXQgcGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBwYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFN0cmluZ0lucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICBjaHVuayhmcm9tKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tKTsgfVxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICByZWFkKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tLCB0byk7IH1cbn1cblxuLy8vIENyZWF0ZSBhIHBhcnNlIHdyYXBwZXIgdGhhdCwgYWZ0ZXIgdGhlIGlubmVyIHBhcnNlIGNvbXBsZXRlcyxcbi8vLyBzY2FucyBpdHMgdHJlZSBmb3IgbWl4ZWQgbGFuZ3VhZ2UgcmVnaW9ucyB3aXRoIHRoZSBgbmVzdGBcbi8vLyBmdW5jdGlvbiwgcnVucyB0aGUgcmVzdWx0aW5nIFtpbm5lciBwYXJzZXNdKCNjb21tb24uTmVzdGVkUGFyc2UpLFxuLy8vIGFuZCB0aGVuIFttb3VudHNdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdGhlaXIgcmVzdWx0cyBvbnRvIHRoZVxuLy8vIHRyZWUuXG4vLy9cbi8vLyBUaGUgbmVzdGluZyBmdW5jdGlvbiBpcyBwYXNzZWQgYSBjdXJzb3IgdG8gcHJvdmlkZSBjb250ZXh0IGZvciBhXG4vLy8gbm9kZSwgYnV0IF9zaG91bGQgbm90XyBtb3ZlIHRoYXQgY3Vyc29yLCBvbmx5IGluc3BlY3QgaXRzXG4vLy8gcHJvcGVydGllcyBhbmQgb3B0aW9uYWxseSBhY2Nlc3MgaXRzXG4vLy8gW25vZGUgb2JqZWN0XSgjY29tbW9uLlRyZWVDdXJzb3Iubm9kZSkuXG5mdW5jdGlvbiBwYXJzZU1peGVkKG5lc3QpIHtcbiAgICByZXR1cm4gKHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IG5ldyBNaXhlZFBhcnNlKHBhcnNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xufVxuY2xhc3MgSW5uZXJQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJzZSwgb3ZlcmxheSwgdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnBhcnNlID0gcGFyc2U7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH1cbn1cbmNsYXNzIEFjdGl2ZU92ZXJsYXkge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcHJlZGljYXRlLCBtb3VudHMsIGluZGV4LCBzdGFydCwgdGFyZ2V0LCBwcmV2KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5tb3VudHMgPSBtb3VudHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgfVxufVxuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbm5lckRvbmUgPT0gdGhpcy5pbm5lci5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5pbm5lclt0aGlzLmlubmVyRG9uZV0sIGRvbmUgPSBpbm5lci5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyRG9uZSsrO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNvbWV3aGF0IGRvZGd5IGJ1dCBzdXBlciBoZWxwZnVsIGhhY2sgd2hlcmUgd2VcbiAgICAgICAgICAgIC8vIHBhdGNoIHVwIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIGlubmVyIHBhcnNlIChhbmQgdGh1c1xuICAgICAgICAgICAgLy8gcHJlc3VtYWJseSBub3QgYWxpYXNlZCBhbnl3aGVyZSBlbHNlKSB0byBob2xkIHRoZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gYWJvdXQgdGhlIGlubmVyIHBhcnNlLlxuICAgICAgICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBpbm5lci50YXJnZXQucHJvcHMpO1xuICAgICAgICAgICAgcHJvcHNbTm9kZVByb3AubW91bnRlZC5pZF0gPSBuZXcgTW91bnRlZFRyZWUoZG9uZSwgaW5uZXIub3ZlcmxheSwgaW5uZXIucGFyc2VyKTtcbiAgICAgICAgICAgIGlubmVyLnRhcmdldC5wcm9wcyA9IHByb3BzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXTtcbiAgICAgICAgcmV0dXJuIG5leHQgPyBuZXh0LnBhcnNlLnBhcnNlZFBvcyA6IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICB0aGlzLmJhc2VQYXJzZS5zdG9wQXQocG9zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5uZXJEb25lOyBpIDwgdGhpcy5pbm5lci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyW2ldLnBhcnNlLnN0b3BBdChwb3MpO1xuICAgIH1cbiAgICBzdGFydElubmVyKCkge1xuICAgICAgICBsZXQgZnJhZ21lbnRDdXJzb3IgPSBuZXcgRnJhZ21lbnRDdXJzb3IodGhpcy5mcmFnbWVudHMpO1xuICAgICAgICBsZXQgb3ZlcmxheSA9IG51bGw7XG4gICAgICAgIGxldCBjb3ZlcmVkID0gbnVsbDtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgY3Vyc29yID0gdGhpcy5iYXNlVHJlZS5mdWxsQ3Vyc29yKCksIG5lc3QsIGlzQ292ZXJlZDs7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXIgPSB0cnVlLCByYW5nZTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudEN1cnNvci5oYXNOb2RlKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBvdmVybGF5Lm1vdW50cy5maW5kKG0gPT4gbS5mcmFnLmZyb20gPD0gY3Vyc29yLmZyb20gJiYgbS5mcmFnLnRvID49IGN1cnNvci50byAmJiBtLm1vdW50Lm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHIuZnJvbSArIG1hdGNoLnBvcywgdG8gPSByLnRvICsgbWF0Y2gucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGN1cnNvci5mcm9tICYmIHRvIDw9IGN1cnNvci50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZCAmJiAoaXNDb3ZlcmVkID0gY2hlY2tDb3Zlcihjb3ZlcmVkLnJhbmdlcywgY3Vyc29yLmZyb20sIGN1cnNvci50bykpKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBGdWxsICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci50eXBlLmlzQW5vbnltb3VzICYmIGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvICYmIChuZXN0ID0gdGhpcy5uZXN0KGN1cnNvciwgdGhpcy5pbnB1dCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkTW91bnRzID0gZnJhZ21lbnRDdXJzb3IuZmluZE1vdW50cyhjdXJzb3IuZnJvbSwgbmVzdC5wYXJzZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVzdC5vdmVybGF5ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gbmV3IEFjdGl2ZU92ZXJsYXkobmVzdC5wYXJzZXIsIG5lc3Qub3ZlcmxheSwgb2xkTW91bnRzLCB0aGlzLmlubmVyLmxlbmd0aCwgY3Vyc29yLmZyb20sIGN1cnNvci50cmVlLCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgbmVzdC5vdmVybGF5IHx8IFtuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob2xkTW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBuZXN0Lm92ZXJsYXkgPyBuZXN0Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIGN1cnNvci5mcm9tLCByLnRvIC0gY3Vyc29yLmZyb20pKSA6IG51bGwsIGN1cnNvci50cmVlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmVzdC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSB7IHJhbmdlcywgZGVwdGg6IDAsIHByZXY6IGNvdmVyZWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdmVybGF5ICYmIChyYW5nZSA9IG92ZXJsYXkucHJlZGljYXRlKGN1cnNvcikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA8IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRlciAmJiBjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZGVwdGgrKztcbiAgICAgICAgICAgICAgICBpZiAoY292ZXJlZClcbiAgICAgICAgICAgICAgICAgICAgY292ZXJlZC5kZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAmJiAhLS1vdmVybGF5LmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG92ZXJsYXkucmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIuc3BsaWNlKG92ZXJsYXkuaW5kZXgsIDAsIG5ldyBJbm5lclBhcnNlKG92ZXJsYXkucGFyc2VyLCBvdmVybGF5LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG92ZXJsYXkubW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBvdmVybGF5LnJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gb3ZlcmxheS5zdGFydCwgci50byAtIG92ZXJsYXkuc3RhcnQpKSwgb3ZlcmxheS50YXJnZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5LnByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQgJiYgIS0tY292ZXJlZC5kZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSBjb3ZlcmVkLnByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tDb3Zlcihjb3ZlcmVkLCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIGNvdmVyZWQpIHtcbiAgICAgICAgaWYgKHJhbmdlLmZyb20gPj0gdG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZnJvbSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8gPyAyIC8qIEZ1bGwgKi8gOiAxIC8qIFBhcnRpYWwgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59XG4vLyBUYWtlIGEgcGllY2Ugb2YgYnVmZmVyIGFuZCBjb252ZXJ0IGl0IGludG8gYSBzdGFuZC1hbG9uZVxuLy8gVHJlZUJ1ZmZlci5cbmZ1bmN0aW9uIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBlbmRJLCBub2RlcywgcG9zaXRpb25zLCBvZmYpIHtcbiAgICBpZiAoc3RhcnRJIDwgZW5kSSkge1xuICAgICAgICBsZXQgZnJvbSA9IGJ1Zi5idWZmZXJbc3RhcnRJICsgMV0sIHRvID0gYnVmLmJ1ZmZlcltlbmRJIC0gMl07XG4gICAgICAgIG5vZGVzLnB1c2goYnVmLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBkZXB0aCA9IDA7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIGRlcHRoKys7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBpID0gMCwgYmFzZSA9IGN1cnNvci50cmVlLCBvZmYgPSAwO1xuICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgIG9mZiA9IGJhc2UucG9zaXRpb25zW2ldICsgY3Vyc29yLmZyb207XG4gICAgICAgIGlmIChvZmYgPD0gbm9kZS5mcm9tICYmIG9mZiArIGJhc2UuY2hpbGRyZW5baV0ubGVuZ3RoID49IG5vZGUudG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQpIHtcbiAgICAgICAgbGV0IGkgPSBzdGFydEk7XG4gICAgICAgIHdoaWxlIChiW2kgKyAyXSArIG9mZiA8PSBub2RlLmZyb20pXG4gICAgICAgICAgICBpID0gYltpICsgM107XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBzdGFydEksIGksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgbGV0IGlzVGFyZ2V0ID0gYltpICsgMV0gKyBvZmYgPT0gbm9kZS5mcm9tICYmIGJbaSArIDJdICsgb2ZmID09IG5vZGUudG8gJiYgYltpXSA9PSBub2RlLnR5cGUuaWQ7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goaXNUYXJnZXQgPyBub2RlLnRvVHJlZSgpIDogc3BsaXQoaSArIDQsIGJbaSArIDNdLCBidWYuc2V0LnR5cGVzW2JbaV1dLCBiW2kgKyAxXSkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChiW2kgKyAxXSAtIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBiW2kgKyAzXSwgZW5kSSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgbGFzdCA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBwb3NpdGlvbnNbbGFzdF0gKyBjaGlsZHJlbltsYXN0XS5sZW5ndGgpO1xuICAgIH1cbiAgICBiYXNlLmNoaWxkcmVuW2ldID0gc3BsaXQoMCwgYi5sZW5ndGgsIE5vZGVUeXBlLm5vbmUsIDApO1xuICAgIC8vIE1vdmUgdGhlIGN1cnNvciBiYWNrIHRvIHRoZSB0YXJnZXQgbm9kZVxuICAgIGZvciAobGV0IGQgPSAwOyBkIDw9IGRlcHRoOyBkKyspXG4gICAgICAgIGN1cnNvci5jaGlsZEFmdGVyKG5vZGUuZnJvbSk7XG59XG5jbGFzcyBTdHJ1Y3R1cmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJvb3QsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gcm9vdC5mdWxsQ3Vyc29yKCk7XG4gICAgfVxuICAgIC8vIE1vdmUgdG8gdGhlIGZpcnN0IG5vZGUgKGluIHByZS1vcmRlcikgdGhhdCBzdGFydHMgYXQgb3IgYWZ0ZXIgYHBvc2AuXG4gICAgbW92ZVRvKHBvcykge1xuICAgICAgICBsZXQgeyBjdXJzb3IgfSA9IHRoaXMsIHAgPSBwb3MgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmRvbmUgJiYgY3Vyc29yLmZyb20gPCBwKSB7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnRvID49IHBvcyAmJiBjdXJzb3IuZW50ZXIocCwgMSwgZmFsc2UsIGZhbHNlKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci5uZXh0KGZhbHNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUoY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKGN1cnNvci5mcm9tKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbmUgJiYgdGhpcy5jdXJzb3IuZnJvbSArIHRoaXMub2Zmc2V0ID09IGN1cnNvci5mcm9tKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0cmVlID0gdGhpcy5jdXJzb3IudHJlZTs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUgPT0gY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmNoaWxkcmVuLmxlbmd0aCAmJiB0cmVlLnBvc2l0aW9uc1swXSA9PSAwICYmIHRyZWUuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBUcmVlKVxuICAgICAgICAgICAgICAgICAgICB0cmVlID0gdHJlZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmZyYWdJID0gMDtcbiAgICAgICAgaWYgKGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRoaXMuY3VyRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZpcnN0LnRyZWUsIC1maXJzdC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShub2RlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmN1ckZyYWcgJiYgbm9kZS5mcm9tID49IHRoaXMuY3VyRnJhZy50bylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyRnJhZyAmJiB0aGlzLmN1ckZyYWcuZnJvbSA8PSBub2RlLmZyb20gJiYgdGhpcy5jdXJGcmFnLnRvID49IG5vZGUudG8gJiYgdGhpcy5pbm5lci5oYXNOb2RlKG5vZGUpO1xuICAgIH1cbiAgICBuZXh0RnJhZygpIHtcbiAgICAgICAgdGhpcy5mcmFnSSsrO1xuICAgICAgICBpZiAodGhpcy5mcmFnSSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmN1ckZyYWcgPSB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdJXTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZyYWcudHJlZSwgLWZyYWcub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTW91bnRzKHBvcywgcGFyc2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgICAgICAgdGhpcy5pbm5lci5jdXJzb3IubW92ZVRvKHBvcywgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLmlubmVyLmN1cnNvci5ub2RlOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW91bnQgPSAoX2EgPSBwb3MudHJlZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LnBhcnNlciA9PSBwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJhZ0k7IGkgPCB0aGlzLmZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmZyb20gPj0gcG9zLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcudHJlZSA9PSB0aGlzLmN1ckZyYWcudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcG9zLmZyb20gLSBmcmFnLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1bmNoUmFuZ2VzKG91dGVyLCByYW5nZXMpIHtcbiAgICBsZXQgY29weSA9IG51bGwsIGN1cnJlbnQgPSByYW5nZXM7XG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBpIDwgb3V0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGdhcEZyb20gPSBvdXRlcltpIC0gMV0udG8sIGdhcFRvID0gb3V0ZXJbaV0uZnJvbTtcbiAgICAgICAgZm9yICg7IGogPCBjdXJyZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgciA9IGN1cnJlbnRbal07XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IGdhcFRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPD0gZ2FwRnJvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29weSA9IHJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA8IGdhcEZyb20pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2pdID0gbmV3IFJhbmdlKHIuZnJvbSwgZ2FwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHIudG8gPiBnYXBUbylcbiAgICAgICAgICAgICAgICAgICAgY29weS5zcGxpY2UoaiArIDEsIDAsIG5ldyBSYW5nZShnYXBUbywgci50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoci50byA+IGdhcFRvKSB7XG4gICAgICAgICAgICAgICAgY29weVtqLS1dID0gbmV3IFJhbmdlKGdhcFRvLCByLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBmaW5kQ292ZXJDaGFuZ2VzKGEsIGIsIGZyb20sIHRvKSB7XG4gICAgbGV0IGlBID0gMCwgaUIgPSAwLCBpbkEgPSBmYWxzZSwgaW5CID0gZmFsc2UsIHBvcyA9IC0xZTk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG5leHRBID0gaUEgPT0gYS5sZW5ndGggPyAxZTkgOiBpbkEgPyBhW2lBXS50byA6IGFbaUFdLmZyb207XG4gICAgICAgIGxldCBuZXh0QiA9IGlCID09IGIubGVuZ3RoID8gMWU5IDogaW5CID8gYltpQl0udG8gOiBiW2lCXS5mcm9tO1xuICAgICAgICBpZiAoaW5BICE9IGluQikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4obmV4dEEsIG5leHRCLCB0byk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIpO1xuICAgICAgICBpZiAocG9zID09IDFlOSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dEEgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQSlcbiAgICAgICAgICAgICAgICBpbkEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5BID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dEIgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQilcbiAgICAgICAgICAgICAgICBpbkIgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5CID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gR2l2ZW4gYSBudW1iZXIgb2YgZnJhZ21lbnRzIGZvciB0aGUgb3V0ZXIgdHJlZSwgYW5kIGEgc2V0IG9mIHJhbmdlc1xuLy8gdG8gcGFyc2UsIGZpbmQgZnJhZ21lbnRzIGZvciBpbm5lciB0cmVlcyBtb3VudGVkIGFyb3VuZCB0aG9zZVxuLy8gcmFuZ2VzLCBpZiBhbnkuXG5mdW5jdGlvbiBlbnRlckZyYWdtZW50cyhtb3VudHMsIHJhbmdlcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IHBvcywgbW91bnQsIGZyYWcgfSBvZiBtb3VudHMpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gcG9zICsgKG1vdW50Lm92ZXJsYXkgPyBtb3VudC5vdmVybGF5WzBdLmZyb20gOiAwKSwgZW5kUG9zID0gc3RhcnRQb3MgKyBtb3VudC50cmVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChmcmFnLmZyb20sIHN0YXJ0UG9zKSwgdG8gPSBNYXRoLm1pbihmcmFnLnRvLCBlbmRQb3MpO1xuICAgICAgICBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IG92ZXJsYXkgPSBtb3VudC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gKyBwb3MsIHIudG8gKyBwb3MpKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gZmluZENvdmVyQ2hhbmdlcyhyYW5nZXMsIG92ZXJsYXksIGZyb20sIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBmcm9tOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGNoYW5nZXMubGVuZ3RoLCBlbmQgPSBsYXN0ID8gdG8gOiBjaGFuZ2VzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChwb3MsIGVuZCwgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gcG9zLCBmcmFnLnRvIDw9IGVuZCkpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBjaGFuZ2VzW2ldLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChmcm9tLCB0bywgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gc3RhcnRQb3MsIGZyYWcudG8gPD0gZW5kUG9zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgTW91bnRlZFRyZWUsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgUGFyc2VyLCBUcmVlLCBUcmVlQnVmZmVyLCBUcmVlQ3Vyc29yLCBUcmVlRnJhZ21lbnQsIHBhcnNlTWl4ZWQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "./node_modules/crelt/index.es.js":
/*!****************************************!*\
  !*** ./node_modules/crelt/index.es.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ crelt; }\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction crelt() {\n  var elt = arguments[0];\n  if (typeof elt == \"string\") elt = document.createElement(elt);\n  var i = 1,\n      next = arguments[1];\n\n  if (next && _typeof(next) == \"object\" && next.nodeType == null && !Array.isArray(next)) {\n    for (var name in next) {\n      if (Object.prototype.hasOwnProperty.call(next, name)) {\n        var value = next[name];\n        if (typeof value == \"string\") elt.setAttribute(name, value);else if (value != null) elt[name] = value;\n      }\n    }\n\n    i++;\n  }\n\n  for (; i < arguments.length; i++) {\n    add(elt, arguments[i]);\n  }\n\n  return elt;\n}\n\nfunction add(elt, child) {\n  if (typeof child == \"string\") {\n    elt.appendChild(document.createTextNode(child));\n  } else if (child == null) {} else if (child.nodeType != null) {\n    elt.appendChild(child);\n  } else if (Array.isArray(child)) {\n    for (var i = 0; i < child.length; i++) {\n      add(elt, child[i]);\n    }\n  } else {\n    throw new RangeError(\"Unsupported child node: \" + child);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3JlbHQvaW5kZXguZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFKQTs7QUFLQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvY3JlbHQvaW5kZXguZXMuanM/Mjk1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVsdCgpIHtcbiAgdmFyIGVsdCA9IGFyZ3VtZW50c1swXVxuICBpZiAodHlwZW9mIGVsdCA9PSBcInN0cmluZ1wiKSBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsdClcbiAgdmFyIGkgPSAxLCBuZXh0ID0gYXJndW1lbnRzWzFdXG4gIGlmIChuZXh0ICYmIHR5cGVvZiBuZXh0ID09IFwib2JqZWN0XCIgJiYgbmV4dC5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBuZXh0KSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHQsIG5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXh0W25hbWVdXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIGVsdC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSBlbHRbbmFtZV0gPSB2YWx1ZVxuICAgIH1cbiAgICBpKytcbiAgfVxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYWRkKGVsdCwgYXJndW1lbnRzW2ldKVxuICByZXR1cm4gZWx0XG59XG5cbmZ1bmN0aW9uIGFkZChlbHQsIGNoaWxkKSB7XG4gIGlmICh0eXBlb2YgY2hpbGQgPT0gXCJzdHJpbmdcIikge1xuICAgIGVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZCkpXG4gIH0gZWxzZSBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlICE9IG51bGwpIHtcbiAgICBlbHQuYXBwZW5kQ2hpbGQoY2hpbGQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmxlbmd0aDsgaSsrKSBhZGQoZWx0LCBjaGlsZFtpXSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVuc3VwcG9ydGVkIGNoaWxkIG5vZGU6IFwiICsgY2hpbGQpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crelt/index.es.js\n");

/***/ })

}]);