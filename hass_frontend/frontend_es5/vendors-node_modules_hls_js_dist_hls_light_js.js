/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_hls_js_dist_hls_light_js"],{

/***/ "./node_modules/hls.js/dist/hls.light.js":
/*!***********************************************!*\
  !*** ./node_modules/hls.js/dist/hls.light.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = (__webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\n(function __HLS_WORKER_BUNDLE__(__IN_WORKER__) {\n  (function (global, factory) {\n    ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n  })(this, function () {\n    'use strict';\n\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread2(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n      });\n      return Constructor;\n    }\n    function _defineProperty(obj, key, value) {\n      key = _toPropertyKey(key);\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function _extends() {\n      _extends = Object.assign ? Object.assign.bind() : function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function _inheritsLoose(subClass, superClass) {\n      subClass.prototype = Object.create(superClass.prototype);\n      subClass.prototype.constructor = subClass;\n      _setPrototypeOf(subClass, superClass);\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n      if (Reflect.construct.sham) return false;\n      if (typeof Proxy === \"function\") return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _construct(Parent, args, Class) {\n      if (_isNativeReflectConstruct()) {\n        _construct = Reflect.construct.bind();\n      } else {\n        _construct = function _construct(Parent, args, Class) {\n          var a = [null];\n          a.push.apply(a, args);\n          var Constructor = Function.bind.apply(Parent, a);\n          var instance = new Constructor();\n          if (Class) _setPrototypeOf(instance, Class.prototype);\n          return instance;\n        };\n      }\n      return _construct.apply(null, arguments);\n    }\n    function _isNativeFunction(fn) {\n      return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n    }\n    function _wrapNativeSuper(Class) {\n      var _cache = typeof Map === \"function\" ? new Map() : undefined;\n      _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (Class === null || !_isNativeFunction(Class)) return Class;\n        if (typeof Class !== \"function\") {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n          if (_cache.has(Class)) return _cache.get(Class);\n          _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n          return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n          constructor: {\n            value: Wrapper,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n      };\n      return _wrapNativeSuper(Class);\n    }\n    function _assertThisInitialized(self) {\n      if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self;\n    }\n    function _toPrimitive(input, hint) {\n      if (_typeof(input) !== \"object\" || input === null) return input;\n      var prim = input[Symbol.toPrimitive];\n      if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (_typeof(res) !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n      }\n      return (hint === \"string\" ? String : Number)(input);\n    }\n    function _toPropertyKey(arg) {\n      var key = _toPrimitive(arg, \"string\");\n      return _typeof(key) === \"symbol\" ? key : String(key);\n    }\n    function getDefaultExportFromCjs(x) {\n      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n    }\n    var urlToolkit = {\n      exports: {}\n    };\n    (function (module, exports) {\n      // see https://tools.ietf.org/html/rfc1808\n\n      (function (root) {\n        var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n        var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n        var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n        var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n        var URLToolkit = {\n          // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n          // E.g\n          // With opts.alwaysNormalize = false (default, spec compliant)\n          // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n          // With opts.alwaysNormalize = true (not spec compliant)\n          // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n          buildAbsoluteURL: function buildAbsoluteURL(baseURL, relativeURL, opts) {\n            opts = opts || {};\n            // remove any remaining space and CRLF\n            baseURL = baseURL.trim();\n            relativeURL = relativeURL.trim();\n            if (!relativeURL) {\n              // 2a) If the embedded URL is entirely empty, it inherits the\n              // entire base URL (i.e., is set equal to the base URL)\n              // and we are done.\n              if (!opts.alwaysNormalize) {\n                return baseURL;\n              }\n              var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n              if (!basePartsForNormalise) {\n                throw new Error('Error trying to parse base URL.');\n              }\n              basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\n              return URLToolkit.buildURLFromParts(basePartsForNormalise);\n            }\n            var relativeParts = URLToolkit.parseURL(relativeURL);\n            if (!relativeParts) {\n              throw new Error('Error trying to parse relative URL.');\n            }\n            if (relativeParts.scheme) {\n              // 2b) If the embedded URL starts with a scheme name, it is\n              // interpreted as an absolute URL and we are done.\n              if (!opts.alwaysNormalize) {\n                return relativeURL;\n              }\n              relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n              return URLToolkit.buildURLFromParts(relativeParts);\n            }\n            var baseParts = URLToolkit.parseURL(baseURL);\n            if (!baseParts) {\n              throw new Error('Error trying to parse base URL.');\n            }\n            if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n              // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n              // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n              var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n              baseParts.netLoc = pathParts[1];\n              baseParts.path = pathParts[2];\n            }\n            if (baseParts.netLoc && !baseParts.path) {\n              baseParts.path = '/';\n            }\n            var builtParts = {\n              // 2c) Otherwise, the embedded URL inherits the scheme of\n              // the base URL.\n              scheme: baseParts.scheme,\n              netLoc: relativeParts.netLoc,\n              path: null,\n              params: relativeParts.params,\n              query: relativeParts.query,\n              fragment: relativeParts.fragment\n            };\n            if (!relativeParts.netLoc) {\n              // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n              // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n              // (if any) of the base URL.\n              builtParts.netLoc = baseParts.netLoc;\n              // 4) If the embedded URL path is preceded by a slash \"/\", the\n              // path is not relative and we skip to Step 7.\n              if (relativeParts.path[0] !== '/') {\n                if (!relativeParts.path) {\n                  // 5) If the embedded URL path is empty (and not preceded by a\n                  // slash), then the embedded URL inherits the base URL path\n                  builtParts.path = baseParts.path;\n                  // 5a) if the embedded URL's <params> is non-empty, we skip to\n                  // step 7; otherwise, it inherits the <params> of the base\n                  // URL (if any) and\n                  if (!relativeParts.params) {\n                    builtParts.params = baseParts.params;\n                    // 5b) if the embedded URL's <query> is non-empty, we skip to\n                    // step 7; otherwise, it inherits the <query> of the base\n                    // URL (if any) and we skip to step 7.\n                    if (!relativeParts.query) {\n                      builtParts.query = baseParts.query;\n                    }\n                  }\n                } else {\n                  // 6) The last segment of the base URL's path (anything\n                  // following the rightmost slash \"/\", or the entire path if no\n                  // slash is present) is removed and the embedded URL's path is\n                  // appended in its place.\n                  var baseURLPath = baseParts.path;\n                  var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;\n                  builtParts.path = URLToolkit.normalizePath(newPath);\n                }\n              }\n            }\n            if (builtParts.path === null) {\n              builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\n            }\n            return URLToolkit.buildURLFromParts(builtParts);\n          },\n          parseURL: function parseURL(url) {\n            var parts = URL_REGEX.exec(url);\n            if (!parts) {\n              return null;\n            }\n            return {\n              scheme: parts[1] || '',\n              netLoc: parts[2] || '',\n              path: parts[3] || '',\n              params: parts[4] || '',\n              query: parts[5] || '',\n              fragment: parts[6] || ''\n            };\n          },\n          normalizePath: function normalizePath(path) {\n            // The following operations are\n            // then applied, in order, to the new path:\n            // 6a) All occurrences of \"./\", where \".\" is a complete path\n            // segment, are removed.\n            // 6b) If the path ends with \".\" as a complete path segment,\n            // that \".\" is removed.\n            path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n            // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n            // complete path segment not equal to \"..\", are removed.\n            // Removal of these path segments is performed iteratively,\n            // removing the leftmost matching pattern on each iteration,\n            // until no matching pattern remains.\n            // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n            // complete path segment not equal to \"..\", that\n            // \"<segment>/..\" is removed.\n            while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {}\n            return path.split('').reverse().join('');\n          },\n          buildURLFromParts: function buildURLFromParts(parts) {\n            return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\n          }\n        };\n        module.exports = URLToolkit;\n      })();\n    })(urlToolkit);\n    var urlToolkitExports = urlToolkit.exports;\n    var isFiniteNumber = Number.isFinite || function (value) {\n      return typeof value === 'number' && isFinite(value);\n    };\n    var Events = /*#__PURE__*/function (Events) {\n      Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n      Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n      Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n      Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n      Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n      Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n      Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n      Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n      Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n      Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n      Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n      Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n      Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n      Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n      Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n      Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n      Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n      Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n      Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n      Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n      Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n      Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n      Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n      Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n      Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n      Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n      Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n      Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n      Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n      Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n      Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n      Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n      Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n      Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n      Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n      Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n      Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n      Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n      Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n      Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n      Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n      Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n      Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n      Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n      Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n      Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n      Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n      Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n      Events[\"ERROR\"] = \"hlsError\";\n      Events[\"DESTROYING\"] = \"hlsDestroying\";\n      Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n      Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n      Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n      Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n      return Events;\n    }({});\n\n    /**\n     * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n     */\n\n    var ErrorTypes = /*#__PURE__*/function (ErrorTypes) {\n      ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n      ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n      ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n      ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n      ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n      return ErrorTypes;\n    }({});\n    var ErrorDetails = /*#__PURE__*/function (ErrorDetails) {\n      ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n      ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n      ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n      ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n      ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n      ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n      ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n      ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n      ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n      ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n      ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n      ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n      ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n      ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n      ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n      ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n      ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n      ErrorDetails[\"LEVEL_PARSING_ERROR\"] = \"levelParsingError\";\n      ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n      ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n      ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n      ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n      ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n      ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n      ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n      ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n      ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n      ErrorDetails[\"FRAG_GAP\"] = \"fragGap\";\n      ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n      ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n      ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n      ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n      ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n      ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n      ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n      ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n      ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n      ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n      ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n      ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n      ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n      ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n      return ErrorDetails;\n    }({});\n    var noop = function noop() {};\n    var fakeLogger = {\n      trace: noop,\n      debug: noop,\n      log: noop,\n      warn: noop,\n      info: noop,\n      error: noop\n    };\n    var exportedLogger = fakeLogger;\n\n    // let lastCallTime;\n    // function formatMsgWithTimeInfo(type, msg) {\n    //   const now = Date.now();\n    //   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n    //   lastCallTime = now;\n    //   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n    //   return msg;\n    // }\n\n    function consolePrintFn(type) {\n      var func = self.console[type];\n      if (func) {\n        return func.bind(self.console, \"[\" + type + \"] >\");\n      }\n      return noop;\n    }\n    function exportLoggerFunctions(debugConfig) {\n      for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        functions[_key - 1] = arguments[_key];\n      }\n      functions.forEach(function (type) {\n        exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n      });\n    }\n    function enableLogs(debugConfig, id) {\n      // check that console is available\n      if (self.console && debugConfig === true || _typeof(debugConfig) === 'object') {\n        exportLoggerFunctions(debugConfig,\n        // Remove out from list here to hard-disable a log-level\n        // 'trace',\n        'debug', 'log', 'info', 'warn', 'error');\n        // Some browsers don't allow to use bind on console object anyway\n        // fallback to default if needed\n        try {\n          exportedLogger.log(\"Debug logs enabled for \\\"\" + id + \"\\\" in hls.js version \" + \"1.4.4\");\n        } catch (e) {\n          exportedLogger = fakeLogger;\n        }\n      } else {\n        exportedLogger = fakeLogger;\n      }\n    }\n    var logger = exportedLogger;\n    var DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\n    var ATTR_LIST_REGEX = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\n\n    // adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\n    var AttrList = /*#__PURE__*/function () {\n      function AttrList(attrs) {\n        if (typeof attrs === 'string') {\n          attrs = AttrList.parseAttrList(attrs);\n        }\n        for (var attr in attrs) {\n          if (attrs.hasOwnProperty(attr)) {\n            if (attr.substring(0, 2) === 'X-') {\n              this.clientAttrs = this.clientAttrs || [];\n              this.clientAttrs.push(attr);\n            }\n            this[attr] = attrs[attr];\n          }\n        }\n      }\n      var _proto = AttrList.prototype;\n      _proto.decimalInteger = function decimalInteger(attrName) {\n        var intValue = parseInt(this[attrName], 10);\n        if (intValue > Number.MAX_SAFE_INTEGER) {\n          return Infinity;\n        }\n        return intValue;\n      };\n      _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {\n        if (this[attrName]) {\n          var stringValue = (this[attrName] || '0x').slice(2);\n          stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n          var value = new Uint8Array(stringValue.length / 2);\n          for (var i = 0; i < stringValue.length / 2; i++) {\n            value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n          }\n          return value;\n        } else {\n          return null;\n        }\n      };\n      _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {\n        var intValue = parseInt(this[attrName], 16);\n        if (intValue > Number.MAX_SAFE_INTEGER) {\n          return Infinity;\n        }\n        return intValue;\n      };\n      _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {\n        return parseFloat(this[attrName]);\n      };\n      _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {\n        var value = this[attrName];\n        return value ? parseFloat(value) : defaultValue;\n      };\n      _proto.enumeratedString = function enumeratedString(attrName) {\n        return this[attrName];\n      };\n      _proto.bool = function bool(attrName) {\n        return this[attrName] === 'YES';\n      };\n      _proto.decimalResolution = function decimalResolution(attrName) {\n        var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n        if (res === null) {\n          return undefined;\n        }\n        return {\n          width: parseInt(res[1], 10),\n          height: parseInt(res[2], 10)\n        };\n      };\n      AttrList.parseAttrList = function parseAttrList(input) {\n        var match;\n        var attrs = {};\n        var quote = '\"';\n        ATTR_LIST_REGEX.lastIndex = 0;\n        while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n          var value = match[2];\n          if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n            value = value.slice(1, -1);\n          }\n          var name = match[1].trim();\n          attrs[name] = value;\n        }\n        return attrs;\n      };\n      return AttrList;\n    }();\n\n    // Avoid exporting const enum so that these values can be inlined\n\n    function isDateRangeCueAttribute(attrName) {\n      return attrName !== \"ID\" && attrName !== \"CLASS\" && attrName !== \"START-DATE\" && attrName !== \"DURATION\" && attrName !== \"END-DATE\" && attrName !== \"END-ON-NEXT\";\n    }\n    function isSCTE35Attribute(attrName) {\n      return attrName === \"SCTE35-OUT\" || attrName === \"SCTE35-IN\";\n    }\n    var DateRange = /*#__PURE__*/function () {\n      function DateRange(dateRangeAttr, dateRangeWithSameId) {\n        this.attr = void 0;\n        this._startDate = void 0;\n        this._endDate = void 0;\n        this._badValueForSameId = void 0;\n        if (dateRangeWithSameId) {\n          var previousAttr = dateRangeWithSameId.attr;\n          for (var key in previousAttr) {\n            if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n              logger.warn(\"DATERANGE tag attribute: \\\"\" + key + \"\\\" does not match for tags with ID: \\\"\" + dateRangeAttr.ID + \"\\\"\");\n              this._badValueForSameId = key;\n              break;\n            }\n          }\n          // Merge DateRange tags with the same ID\n          dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);\n        }\n        this.attr = dateRangeAttr;\n        this._startDate = new Date(dateRangeAttr[\"START-DATE\"]);\n        if (\"END-DATE\" in this.attr) {\n          var endDate = new Date(this.attr[\"END-DATE\"]);\n          if (isFiniteNumber(endDate.getTime())) {\n            this._endDate = endDate;\n          }\n        }\n      }\n      _createClass(DateRange, [{\n        key: \"id\",\n        get: function get() {\n          return this.attr.ID;\n        }\n      }, {\n        key: \"class\",\n        get: function get() {\n          return this.attr.CLASS;\n        }\n      }, {\n        key: \"startDate\",\n        get: function get() {\n          return this._startDate;\n        }\n      }, {\n        key: \"endDate\",\n        get: function get() {\n          if (this._endDate) {\n            return this._endDate;\n          }\n          var duration = this.duration;\n          if (duration !== null) {\n            return new Date(this._startDate.getTime() + duration * 1000);\n          }\n          return null;\n        }\n      }, {\n        key: \"duration\",\n        get: function get() {\n          if (\"DURATION\" in this.attr) {\n            var duration = this.attr.decimalFloatingPoint(\"DURATION\");\n            if (isFiniteNumber(duration)) {\n              return duration;\n            }\n          } else if (this._endDate) {\n            return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n          }\n          return null;\n        }\n      }, {\n        key: \"plannedDuration\",\n        get: function get() {\n          if (\"PLANNED-DURATION\" in this.attr) {\n            return this.attr.decimalFloatingPoint(\"PLANNED-DURATION\");\n          }\n          return null;\n        }\n      }, {\n        key: \"endOnNext\",\n        get: function get() {\n          return this.attr.bool(\"END-ON-NEXT\");\n        }\n      }, {\n        key: \"isValid\",\n        get: function get() {\n          return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);\n        }\n      }]);\n      return DateRange;\n    }();\n    var LoadStats = function LoadStats() {\n      this.aborted = false;\n      this.loaded = 0;\n      this.retry = 0;\n      this.total = 0;\n      this.chunkCount = 0;\n      this.bwEstimate = 0;\n      this.loading = {\n        start: 0,\n        first: 0,\n        end: 0\n      };\n      this.parsing = {\n        start: 0,\n        end: 0\n      };\n      this.buffering = {\n        start: 0,\n        first: 0,\n        end: 0\n      };\n    };\n    var ElementaryStreamTypes = {\n      AUDIO: \"audio\",\n      VIDEO: \"video\",\n      AUDIOVIDEO: \"audiovideo\"\n    };\n    var BaseSegment = /*#__PURE__*/function () {\n      // baseurl is the URL to the playlist\n\n      // relurl is the portion of the URL that comes from inside the playlist.\n\n      // Holds the types of data this fragment supports\n\n      function BaseSegment(baseurl) {\n        var _this$elementaryStrea;\n        this._byteRange = null;\n        this._url = null;\n        this.baseurl = void 0;\n        this.relurl = void 0;\n        this.elementaryStreams = (_this$elementaryStrea = {}, _this$elementaryStrea[ElementaryStreamTypes.AUDIO] = null, _this$elementaryStrea[ElementaryStreamTypes.VIDEO] = null, _this$elementaryStrea[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$elementaryStrea);\n        this.baseurl = baseurl;\n      }\n\n      // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n      var _proto = BaseSegment.prototype;\n      _proto.setByteRange = function setByteRange(value, previous) {\n        var params = value.split('@', 2);\n        var byteRange = [];\n        if (params.length === 1) {\n          byteRange[0] = previous ? previous.byteRangeEndOffset : 0;\n        } else {\n          byteRange[0] = parseInt(params[1]);\n        }\n        byteRange[1] = parseInt(params[0]) + byteRange[0];\n        this._byteRange = byteRange;\n      };\n      _createClass(BaseSegment, [{\n        key: \"byteRange\",\n        get: function get() {\n          if (!this._byteRange) {\n            return [];\n          }\n          return this._byteRange;\n        }\n      }, {\n        key: \"byteRangeStartOffset\",\n        get: function get() {\n          return this.byteRange[0];\n        }\n      }, {\n        key: \"byteRangeEndOffset\",\n        get: function get() {\n          return this.byteRange[1];\n        }\n      }, {\n        key: \"url\",\n        get: function get() {\n          if (!this._url && this.baseurl && this.relurl) {\n            this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {\n              alwaysNormalize: true\n            });\n          }\n          return this._url || '';\n        },\n        set: function set(value) {\n          this._url = value;\n        }\n      }]);\n      return BaseSegment;\n    }();\n\n    /**\n     * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n     */\n    var Fragment = /*#__PURE__*/function (_BaseSegment) {\n      _inheritsLoose(Fragment, _BaseSegment);\n      // EXTINF has to be present for a m3u8 to be considered valid\n\n      // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n\n      // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n      // core difference from the private field _decryptdata is the lack of the initialized IV\n      // _decryptdata will set the IV for this segment based on the segment number in the fragment\n\n      // A string representing the fragment type\n\n      // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n\n      // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n\n      // The level/track index to which the fragment belongs\n\n      // The continuity counter of the fragment\n\n      // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n\n      // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n\n      // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n\n      // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n\n      // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n\n      // Set by `updateFragPTSDTS` in level-helper\n\n      // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n\n      // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n\n      // Load/parse timing information\n\n      // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n\n      // #EXTINF  segment title\n\n      // The Media Initialization Section for this segment\n\n      // Fragment is the last fragment in the media playlist\n\n      // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n\n      function Fragment(type, baseurl) {\n        var _this;\n        _this = _BaseSegment.call(this, baseurl) || this;\n        _this._decryptdata = null;\n        _this.rawProgramDateTime = null;\n        _this.programDateTime = null;\n        _this.tagList = [];\n        _this.duration = 0;\n        _this.sn = 0;\n        _this.levelkeys = void 0;\n        _this.type = void 0;\n        _this.loader = null;\n        _this.keyLoader = null;\n        _this.level = -1;\n        _this.cc = 0;\n        _this.startPTS = void 0;\n        _this.endPTS = void 0;\n        _this.startDTS = void 0;\n        _this.endDTS = void 0;\n        _this.start = 0;\n        _this.deltaPTS = void 0;\n        _this.maxStartPTS = void 0;\n        _this.minEndPTS = void 0;\n        _this.stats = new LoadStats();\n        _this.urlId = 0;\n        _this.data = void 0;\n        _this.bitrateTest = false;\n        _this.title = null;\n        _this.initSegment = null;\n        _this.endList = void 0;\n        _this.gap = void 0;\n        _this.type = type;\n        return _this;\n      }\n      var _proto2 = Fragment.prototype;\n      _proto2.setKeyFormat = function setKeyFormat(keyFormat) {\n        if (this.levelkeys) {\n          var _key = this.levelkeys[keyFormat];\n          if (_key && !this._decryptdata) {\n            this._decryptdata = _key.getDecryptData(this.sn);\n          }\n        }\n      };\n      _proto2.abortRequests = function abortRequests() {\n        var _this$loader, _this$keyLoader;\n        (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();\n        (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();\n      };\n      _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {\n        if (partial === void 0) {\n          partial = false;\n        }\n        var elementaryStreams = this.elementaryStreams;\n        var info = elementaryStreams[type];\n        if (!info) {\n          elementaryStreams[type] = {\n            startPTS: startPTS,\n            endPTS: endPTS,\n            startDTS: startDTS,\n            endDTS: endDTS,\n            partial: partial\n          };\n          return;\n        }\n        info.startPTS = Math.min(info.startPTS, startPTS);\n        info.endPTS = Math.max(info.endPTS, endPTS);\n        info.startDTS = Math.min(info.startDTS, startDTS);\n        info.endDTS = Math.max(info.endDTS, endDTS);\n      };\n      _proto2.clearElementaryStreamInfo = function clearElementaryStreamInfo() {\n        var elementaryStreams = this.elementaryStreams;\n        elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n        elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n        elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n      };\n      _createClass(Fragment, [{\n        key: \"decryptdata\",\n        get: function get() {\n          var levelkeys = this.levelkeys;\n          if (!levelkeys && !this._decryptdata) {\n            return null;\n          }\n          if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n            var _key2 = this.levelkeys.identity;\n            if (_key2) {\n              this._decryptdata = _key2.getDecryptData(this.sn);\n            } else {\n              var keyFormats = Object.keys(this.levelkeys);\n              if (keyFormats.length === 1) {\n                return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);\n              }\n            }\n          }\n          return this._decryptdata;\n        }\n      }, {\n        key: \"end\",\n        get: function get() {\n          return this.start + this.duration;\n        }\n      }, {\n        key: \"endProgramDateTime\",\n        get: function get() {\n          if (this.programDateTime === null) {\n            return null;\n          }\n          if (!isFiniteNumber(this.programDateTime)) {\n            return null;\n          }\n          var duration = !isFiniteNumber(this.duration) ? 0 : this.duration;\n          return this.programDateTime + duration * 1000;\n        }\n      }, {\n        key: \"encrypted\",\n        get: function get() {\n          var _this$_decryptdata;\n          // At the m3u8-parser level we need to add support for manifest signalled keyformats\n          // when we want the fragment to start reporting that it is encrypted.\n          // Currently, keyFormat will only be set for identity keys\n          if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {\n            return true;\n          } else if (this.levelkeys) {\n            var keyFormats = Object.keys(this.levelkeys);\n            var len = keyFormats.length;\n            if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }]);\n      return Fragment;\n    }(BaseSegment);\n\n    /**\n     * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n     */\n    var Part = /*#__PURE__*/function (_BaseSegment2) {\n      _inheritsLoose(Part, _BaseSegment2);\n      function Part(partAttrs, frag, baseurl, index, previous) {\n        var _this2;\n        _this2 = _BaseSegment2.call(this, baseurl) || this;\n        _this2.fragOffset = 0;\n        _this2.duration = 0;\n        _this2.gap = false;\n        _this2.independent = false;\n        _this2.relurl = void 0;\n        _this2.fragment = void 0;\n        _this2.index = void 0;\n        _this2.stats = new LoadStats();\n        _this2.duration = partAttrs.decimalFloatingPoint('DURATION');\n        _this2.gap = partAttrs.bool('GAP');\n        _this2.independent = partAttrs.bool('INDEPENDENT');\n        _this2.relurl = partAttrs.enumeratedString('URI');\n        _this2.fragment = frag;\n        _this2.index = index;\n        var byteRange = partAttrs.enumeratedString('BYTERANGE');\n        if (byteRange) {\n          _this2.setByteRange(byteRange, previous);\n        }\n        if (previous) {\n          _this2.fragOffset = previous.fragOffset + previous.duration;\n        }\n        return _this2;\n      }\n      _createClass(Part, [{\n        key: \"start\",\n        get: function get() {\n          return this.fragment.start + this.fragOffset;\n        }\n      }, {\n        key: \"end\",\n        get: function get() {\n          return this.start + this.duration;\n        }\n      }, {\n        key: \"loaded\",\n        get: function get() {\n          var elementaryStreams = this.elementaryStreams;\n          return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n        }\n      }]);\n      return Part;\n    }(BaseSegment);\n    var DEFAULT_TARGET_DURATION = 10;\n\n    /**\n     * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.\n     */\n    var LevelDetails = /*#__PURE__*/function () {\n      // Manifest reload synchronization\n\n      function LevelDetails(baseUrl) {\n        this.PTSKnown = false;\n        this.alignedSliding = false;\n        this.averagetargetduration = void 0;\n        this.endCC = 0;\n        this.endSN = 0;\n        this.fragments = void 0;\n        this.fragmentHint = void 0;\n        this.partList = null;\n        this.dateRanges = void 0;\n        this.live = true;\n        this.ageHeader = 0;\n        this.advancedDateTime = void 0;\n        this.updated = true;\n        this.advanced = true;\n        this.availabilityDelay = void 0;\n        this.misses = 0;\n        this.startCC = 0;\n        this.startSN = 0;\n        this.startTimeOffset = null;\n        this.targetduration = 0;\n        this.totalduration = 0;\n        this.type = null;\n        this.url = void 0;\n        this.m3u8 = '';\n        this.version = null;\n        this.canBlockReload = false;\n        this.canSkipUntil = 0;\n        this.canSkipDateRanges = false;\n        this.skippedSegments = 0;\n        this.recentlyRemovedDateranges = void 0;\n        this.partHoldBack = 0;\n        this.holdBack = 0;\n        this.partTarget = 0;\n        this.preloadHint = void 0;\n        this.renditionReports = void 0;\n        this.tuneInGoal = 0;\n        this.deltaUpdateFailed = void 0;\n        this.driftStartTime = 0;\n        this.driftEndTime = 0;\n        this.driftStart = 0;\n        this.driftEnd = 0;\n        this.encryptedFragments = void 0;\n        this.playlistParsingError = null;\n        this.variableList = null;\n        this.hasVariableRefs = false;\n        this.fragments = [];\n        this.encryptedFragments = [];\n        this.dateRanges = {};\n        this.url = baseUrl;\n      }\n      var _proto = LevelDetails.prototype;\n      _proto.reloaded = function reloaded(previous) {\n        if (!previous) {\n          this.advanced = true;\n          this.updated = true;\n          return;\n        }\n        var partSnDiff = this.lastPartSn - previous.lastPartSn;\n        var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n        this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff;\n        this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n        if (this.updated || this.advanced) {\n          this.misses = Math.floor(previous.misses * 0.6);\n        } else {\n          this.misses = previous.misses + 1;\n        }\n        this.availabilityDelay = previous.availabilityDelay;\n      };\n      _createClass(LevelDetails, [{\n        key: \"hasProgramDateTime\",\n        get: function get() {\n          if (this.fragments.length) {\n            return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);\n          }\n          return false;\n        }\n      }, {\n        key: \"levelTargetDuration\",\n        get: function get() {\n          return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n        }\n      }, {\n        key: \"drift\",\n        get: function get() {\n          var runTime = this.driftEndTime - this.driftStartTime;\n          if (runTime > 0) {\n            var runDuration = this.driftEnd - this.driftStart;\n            return runDuration * 1000 / runTime;\n          }\n          return 1;\n        }\n      }, {\n        key: \"edge\",\n        get: function get() {\n          return this.partEnd || this.fragmentEnd;\n        }\n      }, {\n        key: \"partEnd\",\n        get: function get() {\n          var _this$partList;\n          if ((_this$partList = this.partList) != null && _this$partList.length) {\n            return this.partList[this.partList.length - 1].end;\n          }\n          return this.fragmentEnd;\n        }\n      }, {\n        key: \"fragmentEnd\",\n        get: function get() {\n          var _this$fragments;\n          if ((_this$fragments = this.fragments) != null && _this$fragments.length) {\n            return this.fragments[this.fragments.length - 1].end;\n          }\n          return 0;\n        }\n      }, {\n        key: \"age\",\n        get: function get() {\n          if (this.advancedDateTime) {\n            return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n          }\n          return 0;\n        }\n      }, {\n        key: \"lastPartIndex\",\n        get: function get() {\n          var _this$partList2;\n          if ((_this$partList2 = this.partList) != null && _this$partList2.length) {\n            return this.partList[this.partList.length - 1].index;\n          }\n          return -1;\n        }\n      }, {\n        key: \"lastPartSn\",\n        get: function get() {\n          var _this$partList3;\n          if ((_this$partList3 = this.partList) != null && _this$partList3.length) {\n            return this.partList[this.partList.length - 1].fragment.sn;\n          }\n          return this.endSN;\n        }\n      }]);\n      return LevelDetails;\n    }();\n\n    // This file is inserted as a shim for modules which we do not want to include into the distro.\n    // This replacement is done in the \"alias\" plugin of the rollup config.\n    var empty = undefined;\n    var Cues = /*@__PURE__*/getDefaultExportFromCjs(empty);\n    function sliceUint8(array, start, end) {\n      // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n      // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n      return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));\n    }\n\n    // breaking up those two types in order to clarify what is happening in the decoding path.\n\n    /**\n     * Returns true if an ID3 header can be found at offset in data\n     * @param data - The data to search\n     * @param offset - The offset at which to start searching\n     */\n    var isHeader$2 = function isHeader(data, offset) {\n      /*\n       * http://id3.org/id3v2.3.0\n       * [0]     = 'I'\n       * [1]     = 'D'\n       * [2]     = '3'\n       * [3,4]   = {Version}\n       * [5]     = {Flags}\n       * [6-9]   = {ID3 Size}\n       *\n       * An ID3v2 tag can be detected with the following pattern:\n       *  $49 44 33 yy yy xx zz zz zz zz\n       * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n       */\n      if (offset + 10 <= data.length) {\n        // look for 'ID3' identifier\n        if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n          // check version is within range\n          if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n            // check size is within range\n            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n\n    /**\n     * Returns true if an ID3 footer can be found at offset in data\n     * @param data - The data to search\n     * @param offset - The offset at which to start searching\n     */\n    var isFooter = function isFooter(data, offset) {\n      /*\n       * The footer is a copy of the header, but with a different identifier\n       */\n      if (offset + 10 <= data.length) {\n        // look for '3DI' identifier\n        if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n          // check version is within range\n          if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n            // check size is within range\n            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n\n    /**\n     * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n     * @param data - The data to search in\n     * @param offset - The offset at which to start searching\n     * @returns the block of data containing any ID3 tags found\n     * or *undefined* if no header is found at the starting offset\n     */\n    var getID3Data = function getID3Data(data, offset) {\n      var front = offset;\n      var length = 0;\n      while (isHeader$2(data, offset)) {\n        // ID3 header is 10 bytes\n        length += 10;\n        var size = readSize(data, offset + 6);\n        length += size;\n        if (isFooter(data, offset + 10)) {\n          // ID3 footer is 10 bytes\n          length += 10;\n        }\n        offset += length;\n      }\n      if (length > 0) {\n        return data.subarray(front, front + length);\n      }\n      return undefined;\n    };\n    var readSize = function readSize(data, offset) {\n      var size = 0;\n      size = (data[offset] & 0x7f) << 21;\n      size |= (data[offset + 1] & 0x7f) << 14;\n      size |= (data[offset + 2] & 0x7f) << 7;\n      size |= data[offset + 3] & 0x7f;\n      return size;\n    };\n    var canParse$2 = function canParse(data, offset) {\n      return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;\n    };\n\n    /**\n     * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n     * @param data - Block of data containing one or more ID3 tags\n     */\n    var getTimeStamp = function getTimeStamp(data) {\n      var frames = getID3Frames(data);\n      for (var i = 0; i < frames.length; i++) {\n        var frame = frames[i];\n        if (isTimeStampFrame(frame)) {\n          return readTimeStamp(frame);\n        }\n      }\n      return undefined;\n    };\n\n    /**\n     * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n     */\n    var isTimeStampFrame = function isTimeStampFrame(frame) {\n      return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n    };\n    var getFrameData = function getFrameData(data) {\n      /*\n      Frame ID       $xx xx xx xx (four characters)\n      Size           $xx xx xx xx\n      Flags          $xx xx\n      */\n      var type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n      var size = readSize(data, 4);\n\n      // skip frame id, size, and flags\n      var offset = 10;\n      return {\n        type: type,\n        size: size,\n        data: data.subarray(offset, offset + size)\n      };\n    };\n\n    /**\n     * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n     * @param id3Data - The ID3 data containing one or more ID3 tags\n     */\n    var getID3Frames = function getID3Frames(id3Data) {\n      var offset = 0;\n      var frames = [];\n      while (isHeader$2(id3Data, offset)) {\n        var size = readSize(id3Data, offset + 6);\n        // skip past ID3 header\n        offset += 10;\n        var end = offset + size;\n        // loop through frames in the ID3 tag\n        while (offset + 8 < end) {\n          var frameData = getFrameData(id3Data.subarray(offset));\n          var frame = decodeFrame(frameData);\n          if (frame) {\n            frames.push(frame);\n          }\n\n          // skip frame header and frame data\n          offset += frameData.size + 10;\n        }\n        if (isFooter(id3Data, offset)) {\n          offset += 10;\n        }\n      }\n      return frames;\n    };\n    var decodeFrame = function decodeFrame(frame) {\n      if (frame.type === 'PRIV') {\n        return decodePrivFrame(frame);\n      } else if (frame.type[0] === 'W') {\n        return decodeURLFrame(frame);\n      }\n      return decodeTextFrame(frame);\n    };\n    var decodePrivFrame = function decodePrivFrame(frame) {\n      /*\n      Format: <text string>\\0<binary data>\n      */\n      if (frame.size < 2) {\n        return undefined;\n      }\n      var owner = utf8ArrayToStr(frame.data, true);\n      var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n      return {\n        key: frame.type,\n        info: owner,\n        data: privateData.buffer\n      };\n    };\n    var decodeTextFrame = function decodeTextFrame(frame) {\n      if (frame.size < 2) {\n        return undefined;\n      }\n      if (frame.type === 'TXXX') {\n        /*\n        Format:\n        [0]   = {Text Encoding}\n        [1-?] = {Description}\\0{Value}\n        */\n        var index = 1;\n        var description = utf8ArrayToStr(frame.data.subarray(index), true);\n        index += description.length + 1;\n        var value = utf8ArrayToStr(frame.data.subarray(index));\n        return {\n          key: frame.type,\n          info: description,\n          data: value\n        };\n      }\n      /*\n      Format:\n      [0]   = {Text Encoding}\n      [1-?] = {Value}\n      */\n      var text = utf8ArrayToStr(frame.data.subarray(1));\n      return {\n        key: frame.type,\n        data: text\n      };\n    };\n    var decodeURLFrame = function decodeURLFrame(frame) {\n      if (frame.type === 'WXXX') {\n        /*\n        Format:\n        [0]   = {Text Encoding}\n        [1-?] = {Description}\\0{URL}\n        */\n        if (frame.size < 2) {\n          return undefined;\n        }\n        var index = 1;\n        var description = utf8ArrayToStr(frame.data.subarray(index), true);\n        index += description.length + 1;\n        var value = utf8ArrayToStr(frame.data.subarray(index));\n        return {\n          key: frame.type,\n          info: description,\n          data: value\n        };\n      }\n      /*\n      Format:\n      [0-?] = {URL}\n      */\n      var url = utf8ArrayToStr(frame.data);\n      return {\n        key: frame.type,\n        data: url\n      };\n    };\n    var readTimeStamp = function readTimeStamp(timeStampFrame) {\n      if (timeStampFrame.data.byteLength === 8) {\n        var data = new Uint8Array(timeStampFrame.data);\n        // timestamp is 33 bit expressed as a big-endian eight-octet number,\n        // with the upper 31 bits set to zero.\n        var pts33Bit = data[3] & 0x1;\n        var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n        timestamp /= 45;\n        if (pts33Bit) {\n          timestamp += 47721858.84;\n        } // 2^32 / 90\n\n        return Math.round(timestamp);\n      }\n      return undefined;\n    };\n\n    // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n    // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n    /* utf.js - UTF-8 <=> UTF-16 convertion\n     *\n     * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n     * Version: 1.0\n     * LastModified: Dec 25 1999\n     * This library is free.  You can redistribute it and/or modify it.\n     */\n    var utf8ArrayToStr = function utf8ArrayToStr(array, exitOnNull) {\n      if (exitOnNull === void 0) {\n        exitOnNull = false;\n      }\n      var decoder = getTextDecoder();\n      if (decoder) {\n        var decoded = decoder.decode(array);\n        if (exitOnNull) {\n          // grab up to the first null\n          var idx = decoded.indexOf('\\0');\n          return idx !== -1 ? decoded.substring(0, idx) : decoded;\n        }\n\n        // remove any null characters\n        return decoded.replace(/\\0/g, '');\n      }\n      var len = array.length;\n      var c;\n      var char2;\n      var char3;\n      var out = '';\n      var i = 0;\n      while (i < len) {\n        c = array[i++];\n        if (c === 0x00 && exitOnNull) {\n          return out;\n        } else if (c === 0x00 || c === 0x03) {\n          // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n          continue;\n        }\n        switch (c >> 4) {\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n            // 0xxxxxxx\n            out += String.fromCharCode(c);\n            break;\n          case 12:\n          case 13:\n            // 110x xxxx   10xx xxxx\n            char2 = array[i++];\n            out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n            break;\n          case 14:\n            // 1110 xxxx  10xx xxxx  10xx xxxx\n            char2 = array[i++];\n            char3 = array[i++];\n            out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n            break;\n        }\n      }\n      return out;\n    };\n    var decoder;\n    function getTextDecoder() {\n      if (!decoder && typeof self.TextDecoder !== 'undefined') {\n        decoder = new self.TextDecoder('utf-8');\n      }\n      return decoder;\n    }\n\n    /**\n     *  hex dump helper class\n     */\n\n    var Hex = {\n      hexDump: function hexDump(array) {\n        var str = '';\n        for (var i = 0; i < array.length; i++) {\n          var h = array[i].toString(16);\n          if (h.length < 2) {\n            h = '0' + h;\n          }\n          str += h;\n        }\n        return str;\n      }\n    };\n    var UINT32_MAX$1 = Math.pow(2, 32) - 1;\n    var push = [].push;\n\n    // We are using fixed track IDs for driving the MP4 remuxer\n    // instead of following the TS PIDs.\n    // There is no reason not to do this and some browsers/SourceBuffer-demuxers\n    // may not like if there are TrackID \"switches\"\n    // See https://github.com/video-dev/hls.js/issues/1331\n    // Here we are mapping our internal track types to constant MP4 track IDs\n    // With MSE currently one can only have one track of each, and we are muxing\n    // whatever video/audio rendition in them.\n    var RemuxerTrackIdConfig = {\n      video: 1,\n      audio: 2,\n      id3: 3,\n      text: 4\n    };\n    function bin2str(data) {\n      return String.fromCharCode.apply(null, data);\n    }\n    function readUint16(buffer, offset) {\n      var val = buffer[offset] << 8 | buffer[offset + 1];\n      return val < 0 ? 65536 + val : val;\n    }\n    function readUint32(buffer, offset) {\n      var val = readSint32(buffer, offset);\n      return val < 0 ? 4294967296 + val : val;\n    }\n    function readSint32(buffer, offset) {\n      return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n    }\n    function writeUint32(buffer, offset, value) {\n      buffer[offset] = value >> 24;\n      buffer[offset + 1] = value >> 16 & 0xff;\n      buffer[offset + 2] = value >> 8 & 0xff;\n      buffer[offset + 3] = value & 0xff;\n    }\n\n    // Find the data for a box specified by its path\n    function findBox(data, path) {\n      var results = [];\n      if (!path.length) {\n        // short-circuit the search for empty paths\n        return results;\n      }\n      var end = data.byteLength;\n      for (var i = 0; i < end;) {\n        var size = readUint32(data, i);\n        var type = bin2str(data.subarray(i + 4, i + 8));\n        var endbox = size > 1 ? i + size : end;\n        if (type === path[0]) {\n          if (path.length === 1) {\n            // this is the end of the path and we've found the box we were\n            // looking for\n            results.push(data.subarray(i + 8, endbox));\n          } else {\n            // recursively search for the next box along the path\n            var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n            if (subresults.length) {\n              push.apply(results, subresults);\n            }\n          }\n        }\n        i = endbox;\n      }\n\n      // we've finished searching all of data\n      return results;\n    }\n    function parseSegmentIndex(sidx) {\n      var references = [];\n      var version = sidx[0];\n\n      // set initial offset, we skip the reference ID (not needed)\n      var index = 8;\n      var timescale = readUint32(sidx, index);\n      index += 4;\n\n      // TODO: parse earliestPresentationTime and firstOffset\n      // usually zero in our case\n      var earliestPresentationTime = 0;\n      var firstOffset = 0;\n      if (version === 0) {\n        index += 8;\n      } else {\n        index += 16;\n      }\n\n      // skip reserved\n      index += 2;\n      var startByte = sidx.length + firstOffset;\n      var referencesCount = readUint16(sidx, index);\n      index += 2;\n      for (var i = 0; i < referencesCount; i++) {\n        var referenceIndex = index;\n        var referenceInfo = readUint32(sidx, referenceIndex);\n        referenceIndex += 4;\n        var referenceSize = referenceInfo & 0x7fffffff;\n        var referenceType = (referenceInfo & 0x80000000) >>> 31;\n        if (referenceType === 1) {\n          logger.warn('SIDX has hierarchical references (not supported)');\n          return null;\n        }\n        var subsegmentDuration = readUint32(sidx, referenceIndex);\n        referenceIndex += 4;\n        references.push({\n          referenceSize: referenceSize,\n          subsegmentDuration: subsegmentDuration,\n          // unscaled\n          info: {\n            duration: subsegmentDuration / timescale,\n            start: startByte,\n            end: startByte + referenceSize - 1\n          }\n        });\n        startByte += referenceSize;\n\n        // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n        // for |sapDelta|.\n        referenceIndex += 4;\n\n        // skip to next ref\n        index = referenceIndex;\n      }\n      return {\n        earliestPresentationTime: earliestPresentationTime,\n        timescale: timescale,\n        version: version,\n        referencesCount: referencesCount,\n        references: references\n      };\n    }\n\n    /**\n     * Parses an MP4 initialization segment and extracts stream type and\n     * timescale values for any declared tracks. Timescale values indicate the\n     * number of clock ticks per second to assume for time-based values\n     * elsewhere in the MP4.\n     *\n     * To determine the start time of an MP4, you need two pieces of\n     * information: the timescale unit and the earliest base media decode\n     * time. Multiple timescales can be specified within an MP4 but the\n     * base media decode time is always expressed in the timescale from\n     * the media header box for the track:\n     * ```\n     * moov > trak > mdia > mdhd.timescale\n     * moov > trak > mdia > hdlr\n     * ```\n     * @param initSegment the bytes of the init segment\n     * @returns a hash of track type to timescale values or null if\n     * the init segment is malformed.\n     */\n\n    function parseInitSegment(initSegment) {\n      var result = [];\n      var traks = findBox(initSegment, ['moov', 'trak']);\n      for (var i = 0; i < traks.length; i++) {\n        var trak = traks[i];\n        var tkhd = findBox(trak, ['tkhd'])[0];\n        if (tkhd) {\n          var version = tkhd[0];\n          var _index = version === 0 ? 12 : 20;\n          var trackId = readUint32(tkhd, _index);\n          var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n          if (mdhd) {\n            version = mdhd[0];\n            _index = version === 0 ? 12 : 20;\n            var timescale = readUint32(mdhd, _index);\n            var hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n            if (hdlr) {\n              var hdlrType = bin2str(hdlr.subarray(8, 12));\n              var type = {\n                soun: ElementaryStreamTypes.AUDIO,\n                vide: ElementaryStreamTypes.VIDEO\n              }[hdlrType];\n              if (type) {\n                // Parse codec details\n                var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n                var codec = void 0;\n                if (stsd) {\n                  codec = bin2str(stsd.subarray(12, 16));\n                  // TODO: Parse codec details to be able to build MIME type.\n                  // stsd.start += 8;\n                  // const codecBox = findBox(stsd, [codec])[0];\n                  // if (codecBox) {\n                  //   TODO: Codec parsing support for avc1, mp4a, hevc, av01...\n                  // }\n                }\n\n                result[trackId] = {\n                  timescale: timescale,\n                  type: type\n                };\n                result[type] = {\n                  timescale: timescale,\n                  id: trackId,\n                  codec: codec\n                };\n              }\n            }\n          }\n        }\n      }\n      var trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n      trex.forEach(function (trex) {\n        var trackId = readUint32(trex, 4);\n        var track = result[trackId];\n        if (track) {\n          track.default = {\n            duration: readUint32(trex, 12),\n            flags: readUint32(trex, 20)\n          };\n        }\n      });\n      return result;\n    }\n    function patchEncyptionData(initSegment, decryptdata) {\n      if (!initSegment || !decryptdata) {\n        return initSegment;\n      }\n      var keyId = decryptdata.keyId;\n      if (keyId && decryptdata.isCommonEncryption) {\n        var traks = findBox(initSegment, ['moov', 'trak']);\n        traks.forEach(function (trak) {\n          var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n          // skip the sample entry count\n          var sampleEntries = stsd.subarray(8);\n          var encBoxes = findBox(sampleEntries, ['enca']);\n          var isAudio = encBoxes.length > 0;\n          if (!isAudio) {\n            encBoxes = findBox(sampleEntries, ['encv']);\n          }\n          encBoxes.forEach(function (enc) {\n            var encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n            var sinfBoxes = findBox(encBoxChildren, ['sinf']);\n            sinfBoxes.forEach(function (sinf) {\n              var tenc = parseSinf(sinf);\n              if (tenc) {\n                // Look for default key id (keyID offset is always 8 within the tenc box):\n                var tencKeyId = tenc.subarray(8, 24);\n                if (!tencKeyId.some(function (b) {\n                  return b !== 0;\n                })) {\n                  logger.log(\"[eme] Patching keyId in 'enc\" + (isAudio ? 'a' : 'v') + \">sinf>>tenc' box: \" + Hex.hexDump(tencKeyId) + \" -> \" + Hex.hexDump(keyId));\n                  tenc.set(keyId, 8);\n                }\n              }\n            });\n          });\n        });\n      }\n      return initSegment;\n    }\n    function parseSinf(sinf) {\n      var schm = findBox(sinf, ['schm'])[0];\n      if (schm) {\n        var scheme = bin2str(schm.subarray(4, 8));\n        if (scheme === 'cbcs' || scheme === 'cenc') {\n          return findBox(sinf, ['schi', 'tenc'])[0];\n        }\n      }\n      logger.error(\"[eme] missing 'schm' box\");\n      return null;\n    }\n\n    /**\n     * Determine the base media decode start time, in seconds, for an MP4\n     * fragment. If multiple fragments are specified, the earliest time is\n     * returned.\n     *\n     * The base media decode time can be parsed from track fragment\n     * metadata:\n     * ```\n     * moof > traf > tfdt.baseMediaDecodeTime\n     * ```\n     * It requires the timescale value from the mdhd to interpret.\n     *\n     * @param initData - a hash of track type to timescale values\n     * @param fmp4 - the bytes of the mp4 fragment\n     * @returns the earliest base media decode start time for the\n     * fragment, in seconds\n     */\n    function getStartDTS(initData, fmp4) {\n      // we need info from two children of each track fragment box\n      return findBox(fmp4, ['moof', 'traf']).reduce(function (result, traf) {\n        var tfdt = findBox(traf, ['tfdt'])[0];\n        var version = tfdt[0];\n        var start = findBox(traf, ['tfhd']).reduce(function (result, tfhd) {\n          // get the track id from the tfhd\n          var id = readUint32(tfhd, 4);\n          var track = initData[id];\n          if (track) {\n            var baseTime = readUint32(tfdt, 4);\n            if (version === 1) {\n              // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n              // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n              // https://github.com/video-dev/hls.js/issues/5303\n              if (baseTime === UINT32_MAX$1) {\n                logger.warn(\"[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time\");\n                return result;\n              }\n              baseTime *= UINT32_MAX$1 + 1;\n              baseTime += readUint32(tfdt, 8);\n            }\n            // assume a 90kHz clock if no timescale was specified\n            var scale = track.timescale || 90e3;\n            // convert base time to seconds\n            var startTime = baseTime / scale;\n            if (isFinite(startTime) && (result === null || startTime < result)) {\n              return startTime;\n            }\n          }\n          return result;\n        }, null);\n        if (start !== null && isFinite(start) && (result === null || start < result)) {\n          return start;\n        }\n        return result;\n      }, null);\n    }\n\n    /*\n      For Reference:\n      aligned(8) class TrackFragmentHeaderBox\n               extends FullBox(tfhd, 0, tf_flags){\n         unsigned int(32)  track_ID;\n         // all the following are optional fields\n         unsigned int(64)  base_data_offset;\n         unsigned int(32)  sample_description_index;\n         unsigned int(32)  default_sample_duration;\n         unsigned int(32)  default_sample_size;\n         unsigned int(32)  default_sample_flags\n      }\n     */\n    function getDuration(data, initData) {\n      var rawDuration = 0;\n      var videoDuration = 0;\n      var audioDuration = 0;\n      var trafs = findBox(data, ['moof', 'traf']);\n      for (var i = 0; i < trafs.length; i++) {\n        var traf = trafs[i];\n        // There is only one tfhd & trun per traf\n        // This is true for CMAF style content, and we should perhaps check the ftyp\n        // and only look for a single trun then, but for ISOBMFF we should check\n        // for multiple track runs.\n        var tfhd = findBox(traf, ['tfhd'])[0];\n        // get the track id from the tfhd\n        var id = readUint32(tfhd, 4);\n        var track = initData[id];\n        if (!track) {\n          continue;\n        }\n        var trackDefault = track.default;\n        var tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);\n        var sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;\n        if (tfhdFlags & 0x000008) {\n          // 0x000008 indicates the presence of the default_sample_duration field\n          if (tfhdFlags & 0x000002) {\n            // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n            // If present, the default_sample_duration exists at byte offset 12\n            sampleDuration = readUint32(tfhd, 12);\n          } else {\n            // Otherwise, the duration is at byte offset 8\n            sampleDuration = readUint32(tfhd, 8);\n          }\n        }\n        // assume a 90kHz clock if no timescale was specified\n        var timescale = track.timescale || 90e3;\n        var truns = findBox(traf, ['trun']);\n        for (var j = 0; j < truns.length; j++) {\n          rawDuration = computeRawDurationFromSamples(truns[j]);\n          if (!rawDuration && sampleDuration) {\n            var sampleCount = readUint32(truns[j], 4);\n            rawDuration = sampleDuration * sampleCount;\n          }\n          if (track.type === ElementaryStreamTypes.VIDEO) {\n            videoDuration += rawDuration / timescale;\n          } else if (track.type === ElementaryStreamTypes.AUDIO) {\n            audioDuration += rawDuration / timescale;\n          }\n        }\n      }\n      if (videoDuration === 0 && audioDuration === 0) {\n        // If duration samples are not available in the traf use sidx subsegment_duration\n        var sidxDuration = 0;\n        var sidxs = findBox(data, ['sidx']);\n        for (var _i = 0; _i < sidxs.length; _i++) {\n          var sidx = parseSegmentIndex(sidxs[_i]);\n          if (sidx != null && sidx.references) {\n            sidxDuration += sidx.references.reduce(function (dur, ref) {\n              return dur + ref.info.duration || 0;\n            }, 0);\n          }\n        }\n        return sidxDuration;\n      }\n      if (videoDuration) {\n        return videoDuration;\n      }\n      return audioDuration;\n    }\n\n    /*\n      For Reference:\n      aligned(8) class TrackRunBox\n               extends FullBox(trun, version, tr_flags) {\n         unsigned int(32)  sample_count;\n         // the following are optional fields\n         signed int(32) data_offset;\n         unsigned int(32)  first_sample_flags;\n         // all fields in the following array are optional\n         {\n            unsigned int(32)  sample_duration;\n            unsigned int(32)  sample_size;\n            unsigned int(32)  sample_flags\n            if (version == 0)\n               { unsigned int(32)\n            else\n               { signed int(32)\n         }[ sample_count ]\n      }\n     */\n    function computeRawDurationFromSamples(trun) {\n      var flags = readUint32(trun, 0);\n      // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n      // Each field is an int32, which is 4 bytes\n      var offset = 8;\n      // data-offset-present flag\n      if (flags & 0x000001) {\n        offset += 4;\n      }\n      // first-sample-flags-present flag\n      if (flags & 0x000004) {\n        offset += 4;\n      }\n      var duration = 0;\n      var sampleCount = readUint32(trun, 4);\n      for (var i = 0; i < sampleCount; i++) {\n        // sample-duration-present flag\n        if (flags & 0x000100) {\n          var sampleDuration = readUint32(trun, offset);\n          duration += sampleDuration;\n          offset += 4;\n        }\n        // sample-size-present flag\n        if (flags & 0x000200) {\n          offset += 4;\n        }\n        // sample-flags-present flag\n        if (flags & 0x000400) {\n          offset += 4;\n        }\n        // sample-composition-time-offsets-present flag\n        if (flags & 0x000800) {\n          offset += 4;\n        }\n      }\n      return duration;\n    }\n    function offsetStartDTS(initData, fmp4, timeOffset) {\n      findBox(fmp4, ['moof', 'traf']).forEach(function (traf) {\n        findBox(traf, ['tfhd']).forEach(function (tfhd) {\n          // get the track id from the tfhd\n          var id = readUint32(tfhd, 4);\n          var track = initData[id];\n          if (!track) {\n            return;\n          }\n          // assume a 90kHz clock if no timescale was specified\n          var timescale = track.timescale || 90e3;\n          // get the base media decode time from the tfdt\n          findBox(traf, ['tfdt']).forEach(function (tfdt) {\n            var version = tfdt[0];\n            var baseMediaDecodeTime = readUint32(tfdt, 4);\n            if (version === 0) {\n              baseMediaDecodeTime -= timeOffset * timescale;\n              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n              writeUint32(tfdt, 4, baseMediaDecodeTime);\n            } else {\n              baseMediaDecodeTime *= Math.pow(2, 32);\n              baseMediaDecodeTime += readUint32(tfdt, 8);\n              baseMediaDecodeTime -= timeOffset * timescale;\n              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n              var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));\n              var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));\n              writeUint32(tfdt, 4, upper);\n              writeUint32(tfdt, 8, lower);\n            }\n          });\n        });\n      });\n    }\n\n    // TODO: Check if the last moof+mdat pair is part of the valid range\n    function segmentValidRange(data) {\n      var segmentedRange = {\n        valid: null,\n        remainder: null\n      };\n      var moofs = findBox(data, ['moof']);\n      if (!moofs) {\n        return segmentedRange;\n      } else if (moofs.length < 2) {\n        segmentedRange.remainder = data;\n        return segmentedRange;\n      }\n      var last = moofs[moofs.length - 1];\n      // Offset by 8 bytes; findBox offsets the start by as much\n      segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);\n      segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);\n      return segmentedRange;\n    }\n    function appendUint8Array(data1, data2) {\n      var temp = new Uint8Array(data1.length + data2.length);\n      temp.set(data1);\n      temp.set(data2, data1.length);\n      return temp;\n    }\n    function parseSamples(timeOffset, track) {\n      var seiSamples = [];\n      var videoData = track.samples;\n      var timescale = track.timescale;\n      var trackId = track.id;\n      var isHEVCFlavor = false;\n      var moofs = findBox(videoData, ['moof']);\n      moofs.map(function (moof) {\n        var moofOffset = moof.byteOffset - 8;\n        var trafs = findBox(moof, ['traf']);\n        trafs.map(function (traf) {\n          // get the base media decode time from the tfdt\n          var baseTime = findBox(traf, ['tfdt']).map(function (tfdt) {\n            var version = tfdt[0];\n            var result = readUint32(tfdt, 4);\n            if (version === 1) {\n              result *= Math.pow(2, 32);\n              result += readUint32(tfdt, 8);\n            }\n            return result / timescale;\n          })[0];\n          if (baseTime !== undefined) {\n            timeOffset = baseTime;\n          }\n          return findBox(traf, ['tfhd']).map(function (tfhd) {\n            var id = readUint32(tfhd, 4);\n            var tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n            var baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n            var sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n            var defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n            var defaultSampleDuration = 0;\n            var defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n            var defaultSampleSize = 0;\n            var defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n            var tfhdOffset = 8;\n            if (id === trackId) {\n              if (baseDataOffsetPresent) {\n                tfhdOffset += 8;\n              }\n              if (sampleDescriptionIndexPresent) {\n                tfhdOffset += 4;\n              }\n              if (defaultSampleDurationPresent) {\n                defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n                tfhdOffset += 4;\n              }\n              if (defaultSampleSizePresent) {\n                defaultSampleSize = readUint32(tfhd, tfhdOffset);\n                tfhdOffset += 4;\n              }\n              if (defaultSampleFlagsPresent) {\n                tfhdOffset += 4;\n              }\n              if (track.type === 'video') {\n                isHEVCFlavor = isHEVC(track.codec);\n              }\n              findBox(traf, ['trun']).map(function (trun) {\n                var version = trun[0];\n                var flags = readUint32(trun, 0) & 0xffffff;\n                var dataOffsetPresent = (flags & 0x000001) !== 0;\n                var dataOffset = 0;\n                var firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n                var sampleDurationPresent = (flags & 0x000100) !== 0;\n                var sampleDuration = 0;\n                var sampleSizePresent = (flags & 0x000200) !== 0;\n                var sampleSize = 0;\n                var sampleFlagsPresent = (flags & 0x000400) !== 0;\n                var sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n                var compositionOffset = 0;\n                var sampleCount = readUint32(trun, 4);\n                var trunOffset = 8; // past version, flags, and sample count\n\n                if (dataOffsetPresent) {\n                  dataOffset = readUint32(trun, trunOffset);\n                  trunOffset += 4;\n                }\n                if (firstSampleFlagsPresent) {\n                  trunOffset += 4;\n                }\n                var sampleOffset = dataOffset + moofOffset;\n                for (var ix = 0; ix < sampleCount; ix++) {\n                  if (sampleDurationPresent) {\n                    sampleDuration = readUint32(trun, trunOffset);\n                    trunOffset += 4;\n                  } else {\n                    sampleDuration = defaultSampleDuration;\n                  }\n                  if (sampleSizePresent) {\n                    sampleSize = readUint32(trun, trunOffset);\n                    trunOffset += 4;\n                  } else {\n                    sampleSize = defaultSampleSize;\n                  }\n                  if (sampleFlagsPresent) {\n                    trunOffset += 4;\n                  }\n                  if (sampleCompositionOffsetsPresent) {\n                    if (version === 0) {\n                      compositionOffset = readUint32(trun, trunOffset);\n                    } else {\n                      compositionOffset = readSint32(trun, trunOffset);\n                    }\n                    trunOffset += 4;\n                  }\n                  if (track.type === ElementaryStreamTypes.VIDEO) {\n                    var naluTotalSize = 0;\n                    while (naluTotalSize < sampleSize) {\n                      var naluSize = readUint32(videoData, sampleOffset);\n                      sampleOffset += 4;\n                      if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                        var data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                        parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                      }\n                      sampleOffset += naluSize;\n                      naluTotalSize += naluSize + 4;\n                    }\n                  }\n                  timeOffset += sampleDuration / timescale;\n                }\n              });\n            }\n          });\n        });\n      });\n      return seiSamples;\n    }\n    function isHEVC(codec) {\n      if (!codec) {\n        return false;\n      }\n      var delimit = codec.indexOf('.');\n      var baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\n      return baseCodec === 'hvc1' || baseCodec === 'hev1' ||\n      // Dolby Vision\n      baseCodec === 'dvh1' || baseCodec === 'dvhe';\n    }\n    function isSEIMessage(isHEVCFlavor, naluHeader) {\n      if (isHEVCFlavor) {\n        var naluType = naluHeader >> 1 & 0x3f;\n        return naluType === 39 || naluType === 40;\n      } else {\n        var _naluType = naluHeader & 0x1f;\n        return _naluType === 6;\n      }\n    }\n    function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n      var data = discardEPB(unescapedData);\n      var seiPtr = 0;\n      // skip nal header\n      seiPtr += headerSize;\n      var payloadType = 0;\n      var payloadSize = 0;\n      var endOfCaptions = false;\n      var b = 0;\n      while (seiPtr < data.length) {\n        payloadType = 0;\n        do {\n          if (seiPtr >= data.length) {\n            break;\n          }\n          b = data[seiPtr++];\n          payloadType += b;\n        } while (b === 0xff);\n\n        // Parse payload size.\n        payloadSize = 0;\n        do {\n          if (seiPtr >= data.length) {\n            break;\n          }\n          b = data[seiPtr++];\n          payloadSize += b;\n        } while (b === 0xff);\n        var leftOver = data.length - seiPtr;\n        if (!endOfCaptions && payloadType === 4 && seiPtr < data.length) {\n          endOfCaptions = true;\n          var countryCode = data[seiPtr++];\n          if (countryCode === 181) {\n            var providerCode = readUint16(data, seiPtr);\n            seiPtr += 2;\n            if (providerCode === 49) {\n              var userStructure = readUint32(data, seiPtr);\n              seiPtr += 4;\n              if (userStructure === 0x47413934) {\n                var userDataType = data[seiPtr++];\n\n                // Raw CEA-608 bytes wrapped in CEA-708 packet\n                if (userDataType === 3) {\n                  var firstByte = data[seiPtr++];\n                  var totalCCs = 0x1f & firstByte;\n                  var enabled = 0x40 & firstByte;\n                  var totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n                  var byteArray = new Uint8Array(totalBytes);\n                  if (enabled) {\n                    byteArray[0] = firstByte;\n                    for (var i = 1; i < totalBytes; i++) {\n                      byteArray[i] = data[seiPtr++];\n                    }\n                  }\n                  samples.push({\n                    type: userDataType,\n                    payloadType: payloadType,\n                    pts: pts,\n                    bytes: byteArray\n                  });\n                }\n              }\n            }\n          }\n        } else if (payloadType === 5 && payloadSize < leftOver) {\n          endOfCaptions = true;\n          if (payloadSize > 16) {\n            var uuidStrArray = [];\n            for (var _i2 = 0; _i2 < 16; _i2++) {\n              var _b = data[seiPtr++].toString(16);\n              uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);\n              if (_i2 === 3 || _i2 === 5 || _i2 === 7 || _i2 === 9) {\n                uuidStrArray.push('-');\n              }\n            }\n            var length = payloadSize - 16;\n            var userDataBytes = new Uint8Array(length);\n            for (var _i3 = 0; _i3 < length; _i3++) {\n              userDataBytes[_i3] = data[seiPtr++];\n            }\n            samples.push({\n              payloadType: payloadType,\n              pts: pts,\n              uuid: uuidStrArray.join(''),\n              userData: utf8ArrayToStr(userDataBytes),\n              userDataBytes: userDataBytes\n            });\n          }\n        } else if (payloadSize < leftOver) {\n          seiPtr += payloadSize;\n        } else if (payloadSize > leftOver) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * remove Emulation Prevention bytes from a RBSP\n     */\n    function discardEPB(data) {\n      var length = data.byteLength;\n      var EPBPositions = [];\n      var i = 1;\n\n      // Find all `Emulation Prevention Bytes`\n      while (i < length - 2) {\n        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n          EPBPositions.push(i + 2);\n          i += 2;\n        } else {\n          i++;\n        }\n      }\n\n      // If no Emulation Prevention Bytes were found just return the original\n      // array\n      if (EPBPositions.length === 0) {\n        return data;\n      }\n\n      // Create a new array to hold the NAL unit data\n      var newLength = length - EPBPositions.length;\n      var newData = new Uint8Array(newLength);\n      var sourceIndex = 0;\n      for (i = 0; i < newLength; sourceIndex++, i++) {\n        if (sourceIndex === EPBPositions[0]) {\n          // Skip this byte\n          sourceIndex++;\n          // Remove this position index\n          EPBPositions.shift();\n        }\n        newData[i] = data[sourceIndex];\n      }\n      return newData;\n    }\n    function parseEmsg(data) {\n      var version = data[0];\n      var schemeIdUri = '';\n      var value = '';\n      var timeScale = 0;\n      var presentationTimeDelta = 0;\n      var presentationTime = 0;\n      var eventDuration = 0;\n      var id = 0;\n      var offset = 0;\n      if (version === 0) {\n        while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n          schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n          offset += 1;\n        }\n        schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n        while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n          value += bin2str(data.subarray(offset, offset + 1));\n          offset += 1;\n        }\n        value += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n        timeScale = readUint32(data, 12);\n        presentationTimeDelta = readUint32(data, 16);\n        eventDuration = readUint32(data, 20);\n        id = readUint32(data, 24);\n        offset = 28;\n      } else if (version === 1) {\n        offset += 4;\n        timeScale = readUint32(data, offset);\n        offset += 4;\n        var leftPresentationTime = readUint32(data, offset);\n        offset += 4;\n        var rightPresentationTime = readUint32(data, offset);\n        offset += 4;\n        presentationTime = Math.pow(2, 32) * leftPresentationTime + rightPresentationTime;\n        if (!Number.isSafeInteger(presentationTime)) {\n          presentationTime = Number.MAX_SAFE_INTEGER;\n          logger.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');\n        }\n        eventDuration = readUint32(data, offset);\n        offset += 4;\n        id = readUint32(data, offset);\n        offset += 4;\n        while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n          schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n          offset += 1;\n        }\n        schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n        while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n          value += bin2str(data.subarray(offset, offset + 1));\n          offset += 1;\n        }\n        value += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n      }\n      var payload = data.subarray(offset, data.byteLength);\n      return {\n        schemeIdUri: schemeIdUri,\n        value: value,\n        timeScale: timeScale,\n        presentationTime: presentationTime,\n        presentationTimeDelta: presentationTimeDelta,\n        eventDuration: eventDuration,\n        id: id,\n        payload: payload\n      };\n    }\n    var LevelKey = /*#__PURE__*/function () {\n      LevelKey.clearKeyUriToKeyIdMap = function clearKeyUriToKeyIdMap() {};\n      function LevelKey(method, uri, format, formatversions, iv) {\n        if (formatversions === void 0) {\n          formatversions = [1];\n        }\n        if (iv === void 0) {\n          iv = null;\n        }\n        this.uri = void 0;\n        this.method = void 0;\n        this.keyFormat = void 0;\n        this.keyFormatVersions = void 0;\n        this.encrypted = void 0;\n        this.isCommonEncryption = void 0;\n        this.iv = null;\n        this.key = null;\n        this.keyId = null;\n        this.pssh = null;\n        this.method = method;\n        this.uri = uri;\n        this.keyFormat = format;\n        this.keyFormatVersions = formatversions;\n        this.iv = iv;\n        this.encrypted = method ? method !== 'NONE' : false;\n        this.isCommonEncryption = this.encrypted && method !== 'AES-128';\n      }\n      var _proto = LevelKey.prototype;\n      _proto.isSupported = function isSupported() {\n        // If it's Segment encryption or No encryption, just select that key system\n        if (this.method) {\n          if (this.method === 'AES-128' || this.method === 'NONE') {\n            return true;\n          }\n          if (this.keyFormat === 'identity') {\n            // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n            return this.method === 'SAMPLE-AES';\n          }\n        }\n        return false;\n      };\n      _proto.getDecryptData = function getDecryptData(sn) {\n        if (!this.encrypted || !this.uri) {\n          return null;\n        }\n        if (this.method === 'AES-128' && this.uri && !this.iv) {\n          if (typeof sn !== 'number') {\n            // We are fetching decryption data for a initialization segment\n            // If the segment was encrypted with AES-128\n            // It must have an IV defined. We cannot substitute the Segment Number in.\n            if (this.method === 'AES-128' && !this.iv) {\n              logger.warn(\"missing IV for initialization segment with method=\\\"\" + this.method + \"\\\" - compliance issue\");\n            }\n            // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n            sn = 0;\n          }\n          var iv = createInitializationVector(sn);\n          var decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);\n          return decryptdata;\n        }\n        {\n          return this;\n        }\n      };\n      return LevelKey;\n    }();\n    function createInitializationVector(segmentNumber) {\n      var uint8View = new Uint8Array(16);\n      for (var i = 12; i < 16; i++) {\n        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n      }\n      return uint8View;\n    }\n\n    /**\n     * MediaSource helper\n     */\n\n    function getMediaSource() {\n      if (typeof self === 'undefined') return undefined;\n      return self.MediaSource || self.WebKitMediaSource;\n    }\n\n    // from http://mp4ra.org/codecs.html\n    var sampleEntryCodesISO = {\n      audio: {\n        a3ds: true,\n        'ac-3': true,\n        'ac-4': true,\n        alac: true,\n        alaw: true,\n        dra1: true,\n        'dts+': true,\n        'dts-': true,\n        dtsc: true,\n        dtse: true,\n        dtsh: true,\n        'ec-3': true,\n        enca: true,\n        g719: true,\n        g726: true,\n        m4ae: true,\n        mha1: true,\n        mha2: true,\n        mhm1: true,\n        mhm2: true,\n        mlpa: true,\n        mp4a: true,\n        'raw ': true,\n        Opus: true,\n        opus: true,\n        // browsers expect this to be lowercase despite MP4RA says 'Opus'\n        samr: true,\n        sawb: true,\n        sawp: true,\n        sevc: true,\n        sqcp: true,\n        ssmv: true,\n        twos: true,\n        ulaw: true\n      },\n      video: {\n        avc1: true,\n        avc2: true,\n        avc3: true,\n        avc4: true,\n        avcp: true,\n        av01: true,\n        drac: true,\n        dva1: true,\n        dvav: true,\n        dvh1: true,\n        dvhe: true,\n        encv: true,\n        hev1: true,\n        hvc1: true,\n        mjp2: true,\n        mp4v: true,\n        mvc1: true,\n        mvc2: true,\n        mvc3: true,\n        mvc4: true,\n        resv: true,\n        rv60: true,\n        s263: true,\n        svc1: true,\n        svc2: true,\n        'vc-1': true,\n        vp08: true,\n        vp09: true\n      },\n      text: {\n        stpp: true,\n        wvtt: true\n      }\n    };\n    var MediaSource$2 = getMediaSource();\n    function isCodecType(codec, type) {\n      var typeCodes = sampleEntryCodesISO[type];\n      return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;\n    }\n    function isCodecSupportedInMp4(codec, type) {\n      var _MediaSource$isTypeSu;\n      return (_MediaSource$isTypeSu = MediaSource$2 == null ? void 0 : MediaSource$2.isTypeSupported((type || 'video') + \"/mp4;codecs=\\\"\" + codec + \"\\\"\")) != null ? _MediaSource$isTypeSu : false;\n    }\n    var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g;\n    var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\n    var IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)\n\n    var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n    // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n    /(?!#) *(\\S[\\S ]*)/.source,\n    // segment URI, group 3 => the URI (note newline is not eaten)\n    /#EXT-X-BYTERANGE:*(.+)/.source,\n    // next segment's byterange, group 4 => range spec (x@y)\n    /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,\n    // next segment's program date/time group 5 => the datetime spec\n    /#.*/.source // All other non-segment oriented tags will match with all groups empty\n    ].join('|'), 'g');\n    var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\n    var M3U8Parser = /*#__PURE__*/function () {\n      function M3U8Parser() {}\n      M3U8Parser.findGroup = function findGroup(groups, mediaGroupId) {\n        for (var i = 0; i < groups.length; i++) {\n          var group = groups[i];\n          if (group.id === mediaGroupId) {\n            return group;\n          }\n        }\n      };\n      M3U8Parser.convertAVC1ToAVCOTI = function convertAVC1ToAVCOTI(codec) {\n        // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n        var avcdata = codec.split('.');\n        if (avcdata.length > 2) {\n          var result = avcdata.shift() + '.';\n          result += parseInt(avcdata.shift()).toString(16);\n          result += ('000' + parseInt(avcdata.shift()).toString(16)).slice(-4);\n          return result;\n        }\n        return codec;\n      };\n      M3U8Parser.resolve = function resolve(url, baseUrl) {\n        return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {\n          alwaysNormalize: true\n        });\n      };\n      M3U8Parser.isMediaPlaylist = function isMediaPlaylist(str) {\n        return IS_MEDIA_PLAYLIST.test(str);\n      };\n      M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {\n        var hasVariableRefs = false;\n        var parsed = {\n          contentSteering: null,\n          levels: [],\n          playlistParsingError: null,\n          sessionData: null,\n          sessionKeys: null,\n          startTimeOffset: null,\n          variableList: null,\n          hasVariableRefs: hasVariableRefs\n        };\n        var levelsWithKnownCodecs = [];\n        MASTER_PLAYLIST_REGEX.lastIndex = 0;\n        var result;\n        while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n          if (result[1]) {\n            var _level$unknownCodecs;\n            // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n            var attrs = new AttrList(result[1]);\n            var uri = result[2];\n            var level = {\n              attrs: attrs,\n              bitrate: attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH'),\n              name: attrs.NAME,\n              url: M3U8Parser.resolve(uri, baseurl)\n            };\n            var resolution = attrs.decimalResolution('RESOLUTION');\n            if (resolution) {\n              level.width = resolution.width;\n              level.height = resolution.height;\n            }\n            setCodecs((attrs.CODECS || '').split(/[ ,]+/).filter(function (c) {\n              return c;\n            }), level);\n            if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {\n              level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);\n            }\n            if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {\n              levelsWithKnownCodecs.push(level);\n            }\n            parsed.levels.push(level);\n          } else if (result[3]) {\n            var tag = result[3];\n            var attributes = result[4];\n            switch (tag) {\n              case 'SESSION-DATA':\n                {\n                  // #EXT-X-SESSION-DATA\n                  var sessionAttrs = new AttrList(attributes);\n                  var dataId = sessionAttrs['DATA-ID'];\n                  if (dataId) {\n                    if (parsed.sessionData === null) {\n                      parsed.sessionData = {};\n                    }\n                    parsed.sessionData[dataId] = sessionAttrs;\n                  }\n                  break;\n                }\n              case 'SESSION-KEY':\n                {\n                  // #EXT-X-SESSION-KEY\n                  var sessionKey = parseKey(attributes, baseurl);\n                  if (sessionKey.encrypted && sessionKey.isSupported()) {\n                    if (parsed.sessionKeys === null) {\n                      parsed.sessionKeys = [];\n                    }\n                    parsed.sessionKeys.push(sessionKey);\n                  } else {\n                    logger.warn(\"[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \\\"\" + attributes + \"\\\"\");\n                  }\n                  break;\n                }\n              case 'DEFINE':\n                {\n                  break;\n                }\n              case 'CONTENT-STEERING':\n                {\n                  // #EXT-X-CONTENT-STEERING\n                  var contentSteeringAttributes = new AttrList(attributes);\n                  parsed.contentSteering = {\n                    uri: M3U8Parser.resolve(contentSteeringAttributes['SERVER-URI'], baseurl),\n                    pathwayId: contentSteeringAttributes['PATHWAY-ID'] || '.'\n                  };\n                  break;\n                }\n              case 'START':\n                {\n                  // #EXT-X-START\n                  parsed.startTimeOffset = parseStartTimeOffset(attributes);\n                  break;\n                }\n            }\n          }\n        }\n        // Filter out levels with unknown codecs if it does not remove all levels\n        var stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;\n        parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;\n        if (parsed.levels.length === 0) {\n          parsed.playlistParsingError = new Error('no levels found in manifest');\n        }\n        return parsed;\n      };\n      M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, parsed) {\n        var result;\n        var results = {};\n        var levels = parsed.levels;\n        var groupsByType = {\n          AUDIO: levels.map(function (level) {\n            return {\n              id: level.attrs.AUDIO,\n              audioCodec: level.audioCodec\n            };\n          }),\n          SUBTITLES: levels.map(function (level) {\n            return {\n              id: level.attrs.SUBTITLES,\n              textCodec: level.textCodec\n            };\n          }),\n          'CLOSED-CAPTIONS': []\n        };\n        var id = 0;\n        MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n        while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n          var attrs = new AttrList(result[1]);\n          var type = attrs.TYPE;\n          if (type) {\n            var groups = groupsByType[type];\n            var medias = results[type] || [];\n            results[type] = medias;\n            var media = {\n              attrs: attrs,\n              bitrate: 0,\n              id: id++,\n              groupId: attrs['GROUP-ID'] || '',\n              instreamId: attrs['INSTREAM-ID'],\n              name: attrs.NAME || attrs.LANGUAGE || '',\n              type: type,\n              default: attrs.bool('DEFAULT'),\n              autoselect: attrs.bool('AUTOSELECT'),\n              forced: attrs.bool('FORCED'),\n              lang: attrs.LANGUAGE,\n              url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n            };\n            if (groups != null && groups.length) {\n              // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n              // If we don't find the track signalled, lets use the first audio groups codec we have\n              // Acting as a best guess\n              var groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n              assignCodec(media, groupCodec, 'audioCodec');\n              assignCodec(media, groupCodec, 'textCodec');\n            }\n            medias.push(media);\n          }\n        }\n        return results;\n      };\n      M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {\n        var level = new LevelDetails(baseurl);\n        var fragments = level.fragments;\n        // The most recent init segment seen (applies to all subsequent segments)\n        var currentInitSegment = null;\n        var currentSN = 0;\n        var currentPart = 0;\n        var totalduration = 0;\n        var discontinuityCounter = 0;\n        var prevFrag = null;\n        var frag = new Fragment(type, baseurl);\n        var result;\n        var i;\n        var levelkeys;\n        var firstPdtIndex = -1;\n        var createNextFrag = false;\n        LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n        level.m3u8 = string;\n        level.hasVariableRefs = false;\n        while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n          if (createNextFrag) {\n            createNextFrag = false;\n            frag = new Fragment(type, baseurl);\n            // setup the next fragment for part loading\n            frag.start = totalduration;\n            frag.sn = currentSN;\n            frag.cc = discontinuityCounter;\n            frag.level = id;\n            if (currentInitSegment) {\n              frag.initSegment = currentInitSegment;\n              frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n              currentInitSegment.rawProgramDateTime = null;\n            }\n          }\n          var duration = result[1];\n          if (duration) {\n            // INF\n            frag.duration = parseFloat(duration);\n            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n            var title = (' ' + result[2]).slice(1);\n            frag.title = title || null;\n            frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n          } else if (result[3]) {\n            // url\n            if (isFiniteNumber(frag.duration)) {\n              frag.start = totalduration;\n              if (levelkeys) {\n                setFragLevelKeys(frag, levelkeys, level);\n              }\n              frag.sn = currentSN;\n              frag.level = id;\n              frag.cc = discontinuityCounter;\n              frag.urlId = levelUrlId;\n              fragments.push(frag);\n              // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n              var uri = (' ' + result[3]).slice(1);\n              frag.relurl = uri;\n              assignProgramDateTime(frag, prevFrag);\n              prevFrag = frag;\n              totalduration += frag.duration;\n              currentSN++;\n              currentPart = 0;\n              createNextFrag = true;\n            }\n          } else if (result[4]) {\n            // X-BYTERANGE\n            var data = (' ' + result[4]).slice(1);\n            if (prevFrag) {\n              frag.setByteRange(data, prevFrag);\n            } else {\n              frag.setByteRange(data);\n            }\n          } else if (result[5]) {\n            // PROGRAM-DATE-TIME\n            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n            frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n            frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n            if (firstPdtIndex === -1) {\n              firstPdtIndex = fragments.length;\n            }\n          } else {\n            result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n            if (!result) {\n              logger.warn('No matches on slow regex match for level playlist!');\n              continue;\n            }\n            for (i = 1; i < result.length; i++) {\n              if (typeof result[i] !== 'undefined') {\n                break;\n              }\n            }\n\n            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n            var tag = (' ' + result[i]).slice(1);\n            var value1 = (' ' + result[i + 1]).slice(1);\n            var value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';\n            switch (tag) {\n              case 'PLAYLIST-TYPE':\n                level.type = value1.toUpperCase();\n                break;\n              case 'MEDIA-SEQUENCE':\n                currentSN = level.startSN = parseInt(value1);\n                break;\n              case 'SKIP':\n                {\n                  var skipAttrs = new AttrList(value1);\n                  var skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n                  if (isFiniteNumber(skippedSegments)) {\n                    level.skippedSegments = skippedSegments;\n                    // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                    for (var _i = skippedSegments; _i--;) {\n                      fragments.unshift(null);\n                    }\n                    currentSN += skippedSegments;\n                  }\n                  var recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n                  if (recentlyRemovedDateranges) {\n                    level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\\t');\n                  }\n                  break;\n                }\n              case 'TARGETDURATION':\n                level.targetduration = Math.max(parseInt(value1), 1);\n                break;\n              case 'VERSION':\n                level.version = parseInt(value1);\n                break;\n              case 'EXTM3U':\n                break;\n              case 'ENDLIST':\n                level.live = false;\n                break;\n              case '#':\n                if (value1 || value2) {\n                  frag.tagList.push(value2 ? [value1, value2] : [value1]);\n                }\n                break;\n              case 'DISCONTINUITY':\n                discontinuityCounter++;\n                frag.tagList.push(['DIS']);\n                break;\n              case 'GAP':\n                frag.gap = true;\n                frag.tagList.push([tag]);\n                break;\n              case 'BITRATE':\n                frag.tagList.push([tag, value1]);\n                break;\n              case 'DATERANGE':\n                {\n                  var dateRangeAttr = new AttrList(value1);\n                  var dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);\n                  if (dateRange.isValid || level.skippedSegments) {\n                    level.dateRanges[dateRange.id] = dateRange;\n                  } else {\n                    logger.warn(\"Ignoring invalid DATERANGE tag: \\\"\" + value1 + \"\\\"\");\n                  }\n                  // Add to fragment tag list for backwards compatibility (< v1.2.0)\n                  frag.tagList.push(['EXT-X-DATERANGE', value1]);\n                  break;\n                }\n              case 'DEFINE':\n                {\n                  break;\n                }\n              case 'DISCONTINUITY-SEQUENCE':\n                discontinuityCounter = parseInt(value1);\n                break;\n              case 'KEY':\n                {\n                  var levelKey = parseKey(value1, baseurl);\n                  if (levelKey.isSupported()) {\n                    if (levelKey.method === 'NONE') {\n                      levelkeys = undefined;\n                      break;\n                    }\n                    if (!levelkeys) {\n                      levelkeys = {};\n                    }\n                    if (levelkeys[levelKey.keyFormat]) {\n                      levelkeys = _extends({}, levelkeys);\n                    }\n                    levelkeys[levelKey.keyFormat] = levelKey;\n                  } else {\n                    logger.warn(\"[Keys] Ignoring invalid EXT-X-KEY tag: \\\"\" + value1 + \"\\\"\");\n                  }\n                  break;\n                }\n              case 'START':\n                level.startTimeOffset = parseStartTimeOffset(value1);\n                break;\n              case 'MAP':\n                {\n                  var mapAttrs = new AttrList(value1);\n                  if (frag.duration) {\n                    // Initial segment tag is after segment duration tag.\n                    //   #EXTINF: 6.0\n                    //   #EXT-X-MAP:URI=\"init.mp4\n                    var init = new Fragment(type, baseurl);\n                    setInitSegment(init, mapAttrs, id, levelkeys);\n                    currentInitSegment = init;\n                    frag.initSegment = currentInitSegment;\n                    if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                      frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                    }\n                  } else {\n                    // Initial segment tag is before segment duration tag\n                    setInitSegment(frag, mapAttrs, id, levelkeys);\n                    currentInitSegment = frag;\n                    createNextFrag = true;\n                  }\n                  break;\n                }\n              case 'SERVER-CONTROL':\n                {\n                  var serverControlAttrs = new AttrList(value1);\n                  level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n                  level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n                  level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n                  level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n                  level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n                  break;\n                }\n              case 'PART-INF':\n                {\n                  var partInfAttrs = new AttrList(value1);\n                  level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n                  break;\n                }\n              case 'PART':\n                {\n                  var partList = level.partList;\n                  if (!partList) {\n                    partList = level.partList = [];\n                  }\n                  var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n                  var index = currentPart++;\n                  var partAttrs = new AttrList(value1);\n                  var part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);\n                  partList.push(part);\n                  frag.duration += part.duration;\n                  break;\n                }\n              case 'PRELOAD-HINT':\n                {\n                  var preloadHintAttrs = new AttrList(value1);\n                  level.preloadHint = preloadHintAttrs;\n                  break;\n                }\n              case 'RENDITION-REPORT':\n                {\n                  var renditionReportAttrs = new AttrList(value1);\n                  level.renditionReports = level.renditionReports || [];\n                  level.renditionReports.push(renditionReportAttrs);\n                  break;\n                }\n              default:\n                logger.warn(\"line parsed but not handled: \" + result);\n                break;\n            }\n          }\n        }\n        if (prevFrag && !prevFrag.relurl) {\n          fragments.pop();\n          totalduration -= prevFrag.duration;\n          if (level.partList) {\n            level.fragmentHint = prevFrag;\n          }\n        } else if (level.partList) {\n          assignProgramDateTime(frag, prevFrag);\n          frag.cc = discontinuityCounter;\n          level.fragmentHint = frag;\n          if (levelkeys) {\n            setFragLevelKeys(frag, levelkeys, level);\n          }\n        }\n        var fragmentLength = fragments.length;\n        var firstFragment = fragments[0];\n        var lastFragment = fragments[fragmentLength - 1];\n        totalduration += level.skippedSegments * level.targetduration;\n        if (totalduration > 0 && fragmentLength && lastFragment) {\n          level.averagetargetduration = totalduration / fragmentLength;\n          var lastSn = lastFragment.sn;\n          level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n          if (!level.live) {\n            lastFragment.endList = true;\n          }\n          if (firstFragment) {\n            level.startCC = firstFragment.cc;\n          }\n        } else {\n          level.endSN = 0;\n          level.startCC = 0;\n        }\n        if (level.fragmentHint) {\n          totalduration += level.fragmentHint.duration;\n        }\n        level.totalduration = totalduration;\n        level.endCC = discontinuityCounter;\n\n        /**\n         * Backfill any missing PDT values\n         * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n         * one or more Media Segment URIs, the client SHOULD extrapolate\n         * backward from that tag (using EXTINF durations and/or media\n         * timestamps) to associate dates with those segments.\"\n         * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n         * computed.\n         */\n        if (firstPdtIndex > 0) {\n          backfillProgramDateTimes(fragments, firstPdtIndex);\n        }\n        return level;\n      };\n      return M3U8Parser;\n    }();\n    function parseKey(keyTagAttributes, baseurl, parsed) {\n      var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;\n      // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n      var keyAttrs = new AttrList(keyTagAttributes);\n      var decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : '';\n      var decrypturi = keyAttrs.URI;\n      var decryptiv = keyAttrs.hexadecimalInteger('IV');\n      var decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;\n      // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n      var decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : 'identity';\n      if (decrypturi && keyAttrs.IV && !decryptiv) {\n        logger.error(\"Invalid IV: \" + keyAttrs.IV);\n      }\n      // If decrypturi is a URI with a scheme, then baseurl will be ignored\n      // No uri is allowed when METHOD is NONE\n      var resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';\n      var keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);\n      return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);\n    }\n    function parseStartTimeOffset(startAttributes) {\n      var startAttrs = new AttrList(startAttributes);\n      var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n      if (isFiniteNumber(startTimeOffset)) {\n        return startTimeOffset;\n      }\n      return null;\n    }\n    function setCodecs(codecs, level) {\n      ['video', 'audio', 'text'].forEach(function (type) {\n        var filtered = codecs.filter(function (codec) {\n          return isCodecType(codec, type);\n        });\n        if (filtered.length) {\n          var preferred = filtered.filter(function (codec) {\n            return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;\n          });\n          level[type + \"Codec\"] = preferred.length > 0 ? preferred[0] : filtered[0];\n\n          // remove from list\n          codecs = codecs.filter(function (codec) {\n            return filtered.indexOf(codec) === -1;\n          });\n        }\n      });\n      level.unknownCodecs = codecs;\n    }\n    function assignCodec(media, groupItem, codecProperty) {\n      var codecValue = groupItem[codecProperty];\n      if (codecValue) {\n        media[codecProperty] = codecValue;\n      }\n    }\n    function backfillProgramDateTimes(fragments, firstPdtIndex) {\n      var fragPrev = fragments[firstPdtIndex];\n      for (var i = firstPdtIndex; i--;) {\n        var frag = fragments[i];\n        // Exit on delta-playlist skipped segments\n        if (!frag) {\n          return;\n        }\n        frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n        fragPrev = frag;\n      }\n    }\n    function assignProgramDateTime(frag, prevFrag) {\n      if (frag.rawProgramDateTime) {\n        frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n      } else if (prevFrag != null && prevFrag.programDateTime) {\n        frag.programDateTime = prevFrag.endProgramDateTime;\n      }\n      if (!isFiniteNumber(frag.programDateTime)) {\n        frag.programDateTime = null;\n        frag.rawProgramDateTime = null;\n      }\n    }\n    function setInitSegment(frag, mapAttrs, id, levelkeys) {\n      frag.relurl = mapAttrs.URI;\n      if (mapAttrs.BYTERANGE) {\n        frag.setByteRange(mapAttrs.BYTERANGE);\n      }\n      frag.level = id;\n      frag.sn = 'initSegment';\n      if (levelkeys) {\n        frag.levelkeys = levelkeys;\n      }\n      frag.initSegment = null;\n    }\n    function setFragLevelKeys(frag, levelkeys, level) {\n      frag.levelkeys = levelkeys;\n      var encryptedFragments = level.encryptedFragments;\n      if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(function (format) {\n        return levelkeys[format].isCommonEncryption;\n      })) {\n        encryptedFragments.push(frag);\n      }\n    }\n    var PlaylistContextType = {\n      MANIFEST: \"manifest\",\n      LEVEL: \"level\",\n      AUDIO_TRACK: \"audioTrack\",\n      SUBTITLE_TRACK: \"subtitleTrack\"\n    };\n    var PlaylistLevelType = {\n      MAIN: \"main\",\n      AUDIO: \"audio\",\n      SUBTITLE: \"subtitle\"\n    };\n    function mapContextToLevelType(context) {\n      var type = context.type;\n      switch (type) {\n        case PlaylistContextType.AUDIO_TRACK:\n          return PlaylistLevelType.AUDIO;\n        case PlaylistContextType.SUBTITLE_TRACK:\n          return PlaylistLevelType.SUBTITLE;\n        default:\n          return PlaylistLevelType.MAIN;\n      }\n    }\n    function getResponseUrl(response, context) {\n      var url = response.url;\n      // responseURL not supported on some browsers (it is used to detect URL redirection)\n      // data-uri mode also not supported (but no need to detect redirection)\n      if (url === undefined || url.indexOf('data:') === 0) {\n        // fallback to initial URL\n        url = context.url;\n      }\n      return url;\n    }\n    var PlaylistLoader = /*#__PURE__*/function () {\n      function PlaylistLoader(hls) {\n        this.hls = void 0;\n        this.loaders = Object.create(null);\n        this.variableList = null;\n        this.hls = hls;\n        this.registerListeners();\n      }\n      var _proto = PlaylistLoader.prototype;\n      _proto.startLoad = function startLoad(startPosition) {};\n      _proto.stopLoad = function stopLoad() {\n        this.destroyInternalLoaders();\n      };\n      _proto.registerListeners = function registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n        hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n      };\n      _proto.unregisterListeners = function unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n        hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n      }\n\n      /**\n       * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n       */;\n      _proto.createInternalLoader = function createInternalLoader(context) {\n        var config = this.hls.config;\n        var PLoader = config.pLoader;\n        var Loader = config.loader;\n        var InternalLoader = PLoader || Loader;\n        var loader = new InternalLoader(config);\n        this.loaders[context.type] = loader;\n        return loader;\n      };\n      _proto.getInternalLoader = function getInternalLoader(context) {\n        return this.loaders[context.type];\n      };\n      _proto.resetInternalLoader = function resetInternalLoader(contextType) {\n        if (this.loaders[contextType]) {\n          delete this.loaders[contextType];\n        }\n      }\n\n      /**\n       * Call `destroy` on all internal loader instances mapped (one per context type)\n       */;\n      _proto.destroyInternalLoaders = function destroyInternalLoaders() {\n        for (var contextType in this.loaders) {\n          var loader = this.loaders[contextType];\n          if (loader) {\n            loader.destroy();\n          }\n          this.resetInternalLoader(contextType);\n        }\n      };\n      _proto.destroy = function destroy() {\n        this.variableList = null;\n        this.unregisterListeners();\n        this.destroyInternalLoaders();\n      };\n      _proto.onManifestLoading = function onManifestLoading(event, data) {\n        var url = data.url;\n        this.variableList = null;\n        this.load({\n          id: null,\n          level: 0,\n          responseType: 'text',\n          type: PlaylistContextType.MANIFEST,\n          url: url,\n          deliveryDirectives: null\n        });\n      };\n      _proto.onLevelLoading = function onLevelLoading(event, data) {\n        var id = data.id,\n          level = data.level,\n          url = data.url,\n          deliveryDirectives = data.deliveryDirectives;\n        this.load({\n          id: id,\n          level: level,\n          responseType: 'text',\n          type: PlaylistContextType.LEVEL,\n          url: url,\n          deliveryDirectives: deliveryDirectives\n        });\n      };\n      _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {\n        var id = data.id,\n          groupId = data.groupId,\n          url = data.url,\n          deliveryDirectives = data.deliveryDirectives;\n        this.load({\n          id: id,\n          groupId: groupId,\n          level: null,\n          responseType: 'text',\n          type: PlaylistContextType.AUDIO_TRACK,\n          url: url,\n          deliveryDirectives: deliveryDirectives\n        });\n      };\n      _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {\n        var id = data.id,\n          groupId = data.groupId,\n          url = data.url,\n          deliveryDirectives = data.deliveryDirectives;\n        this.load({\n          id: id,\n          groupId: groupId,\n          level: null,\n          responseType: 'text',\n          type: PlaylistContextType.SUBTITLE_TRACK,\n          url: url,\n          deliveryDirectives: deliveryDirectives\n        });\n      };\n      _proto.load = function load(context) {\n        var _context$deliveryDire,\n          _this = this;\n        var config = this.hls.config;\n\n        // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n\n        // Check if a loader for this context already exists\n        var loader = this.getInternalLoader(context);\n        if (loader) {\n          var loaderContext = loader.context;\n          if (loaderContext && loaderContext.url === context.url) {\n            // same URL can't overlap\n            logger.trace('[playlist-loader]: playlist request ongoing');\n            return;\n          }\n          logger.log(\"[playlist-loader]: aborting previous loader for type: \" + context.type);\n          loader.abort();\n        }\n\n        // apply different configs for retries depending on\n        // context (manifest, level, audio/subs playlist)\n        var loadPolicy;\n        if (context.type === PlaylistContextType.MANIFEST) {\n          loadPolicy = config.manifestLoadPolicy.default;\n        } else {\n          loadPolicy = _extends({}, config.playlistLoadPolicy.default, {\n            timeoutRetry: null,\n            errorRetry: null\n          });\n        }\n        loader = this.createInternalLoader(context);\n\n        // Override level/track timeout for LL-HLS requests\n        // (the default of 10000ms is counter productive to blocking playlist reload requests)\n        if ((_context$deliveryDire = context.deliveryDirectives) != null && _context$deliveryDire.part) {\n          var levelDetails;\n          if (context.type === PlaylistContextType.LEVEL && context.level !== null) {\n            levelDetails = this.hls.levels[context.level].details;\n          } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n            levelDetails = this.hls.audioTracks[context.id].details;\n          } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n            levelDetails = this.hls.subtitleTracks[context.id].details;\n          }\n          if (levelDetails) {\n            var partTarget = levelDetails.partTarget;\n            var targetDuration = levelDetails.targetduration;\n            if (partTarget && targetDuration) {\n              var maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;\n              loadPolicy = _extends({}, loadPolicy, {\n                maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),\n                maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)\n              });\n            }\n          }\n        }\n        var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n        var loaderConfig = {\n          loadPolicy: loadPolicy,\n          timeout: loadPolicy.maxLoadTimeMs,\n          maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n          retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n          maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n        };\n        var loaderCallbacks = {\n          onSuccess: function onSuccess(response, stats, context, networkDetails) {\n            var loader = _this.getInternalLoader(context);\n            _this.resetInternalLoader(context.type);\n            var string = response.data;\n\n            // Validate if it is an M3U8 at all\n            if (string.indexOf('#EXTM3U') !== 0) {\n              _this.handleManifestParsingError(response, context, new Error('no EXTM3U delimiter'), networkDetails || null, stats);\n              return;\n            }\n            stats.parsing.start = performance.now();\n            if (M3U8Parser.isMediaPlaylist(string)) {\n              _this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);\n            } else {\n              _this.handleMasterPlaylist(response, stats, context, networkDetails);\n            }\n          },\n          onError: function onError(response, context, networkDetails, stats) {\n            _this.handleNetworkError(context, networkDetails, false, response, stats);\n          },\n          onTimeout: function onTimeout(stats, context, networkDetails) {\n            _this.handleNetworkError(context, networkDetails, true, undefined, stats);\n          }\n        };\n\n        // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n        loader.load(context, loaderConfig, loaderCallbacks);\n      };\n      _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {\n        var hls = this.hls;\n        var string = response.data;\n        var url = getResponseUrl(response, context);\n        var parsedResult = M3U8Parser.parseMasterPlaylist(string, url);\n        if (parsedResult.playlistParsingError) {\n          this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);\n          return;\n        }\n        var contentSteering = parsedResult.contentSteering,\n          levels = parsedResult.levels,\n          sessionData = parsedResult.sessionData,\n          sessionKeys = parsedResult.sessionKeys,\n          startTimeOffset = parsedResult.startTimeOffset,\n          variableList = parsedResult.variableList;\n        this.variableList = variableList;\n        var _M3U8Parser$parseMast = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult),\n          _M3U8Parser$parseMast2 = _M3U8Parser$parseMast.AUDIO,\n          audioTracks = _M3U8Parser$parseMast2 === void 0 ? [] : _M3U8Parser$parseMast2,\n          subtitles = _M3U8Parser$parseMast.SUBTITLES,\n          captions = _M3U8Parser$parseMast['CLOSED-CAPTIONS'];\n        if (audioTracks.length) {\n          // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n          var embeddedAudioFound = audioTracks.some(function (audioTrack) {\n            return !audioTrack.url;\n          });\n\n          // if no embedded audio track defined, but audio codec signaled in quality level,\n          // we need to signal this main audio track this could happen with playlists with\n          // alt audio rendition in which quality levels (main)\n          // contains both audio+video. but with mixed audio track not signaled\n          if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n            logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n            audioTracks.unshift({\n              type: 'main',\n              name: 'main',\n              groupId: 'main',\n              default: false,\n              autoselect: false,\n              forced: false,\n              id: -1,\n              attrs: new AttrList({}),\n              bitrate: 0,\n              url: ''\n            });\n          }\n        }\n        hls.trigger(Events.MANIFEST_LOADED, {\n          levels: levels,\n          audioTracks: audioTracks,\n          subtitles: subtitles,\n          captions: captions,\n          contentSteering: contentSteering,\n          url: url,\n          stats: stats,\n          networkDetails: networkDetails,\n          sessionData: sessionData,\n          sessionKeys: sessionKeys,\n          startTimeOffset: startTimeOffset,\n          variableList: variableList\n        });\n      };\n      _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {\n        var hls = this.hls;\n        var id = context.id,\n          level = context.level,\n          type = context.type;\n        var url = getResponseUrl(response, context);\n        var levelUrlId = isFiniteNumber(id) ? id : 0;\n        var levelId = isFiniteNumber(level) ? level : levelUrlId;\n        var levelType = mapContextToLevelType(context);\n        var levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);\n\n        // We have done our first request (Manifest-type) and receive\n        // not a master playlist but a chunk-list (track/level)\n        // We fire the manifest-loaded event anyway with the parsed level-details\n        // by creating a single-level structure for it.\n        if (type === PlaylistContextType.MANIFEST) {\n          var singleLevel = {\n            attrs: new AttrList({}),\n            bitrate: 0,\n            details: levelDetails,\n            name: '',\n            url: url\n          };\n          hls.trigger(Events.MANIFEST_LOADED, {\n            levels: [singleLevel],\n            audioTracks: [],\n            url: url,\n            stats: stats,\n            networkDetails: networkDetails,\n            sessionData: null,\n            sessionKeys: null,\n            contentSteering: null,\n            startTimeOffset: null,\n            variableList: null\n          });\n        }\n\n        // save parsing time\n        stats.parsing.end = performance.now();\n\n        // extend the context with the new levelDetails property\n        context.levelDetails = levelDetails;\n        this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);\n      };\n      _proto.handleManifestParsingError = function handleManifestParsingError(response, context, error, networkDetails, stats) {\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.NETWORK_ERROR,\n          details: ErrorDetails.MANIFEST_PARSING_ERROR,\n          fatal: context.type === PlaylistContextType.MANIFEST,\n          url: response.url,\n          err: error,\n          error: error,\n          reason: error.message,\n          response: response,\n          context: context,\n          networkDetails: networkDetails,\n          stats: stats\n        });\n      };\n      _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response, stats) {\n        if (timeout === void 0) {\n          timeout = false;\n        }\n        var message = \"A network \" + (timeout ? 'timeout' : 'error' + (response ? ' (status ' + response.code + ')' : '')) + \" occurred while loading \" + context.type;\n        if (context.type === PlaylistContextType.LEVEL) {\n          message += \": \" + context.level + \" id: \" + context.id;\n        } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {\n          message += \" id: \" + context.id + \" group-id: \\\"\" + context.groupId + \"\\\"\";\n        }\n        var error = new Error(message);\n        logger.warn(\"[playlist-loader]: \" + message);\n        var details = ErrorDetails.UNKNOWN;\n        var fatal = false;\n        var loader = this.getInternalLoader(context);\n        switch (context.type) {\n          case PlaylistContextType.MANIFEST:\n            details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;\n            fatal = true;\n            break;\n          case PlaylistContextType.LEVEL:\n            details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;\n            fatal = false;\n            break;\n          case PlaylistContextType.AUDIO_TRACK:\n            details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n            fatal = false;\n            break;\n          case PlaylistContextType.SUBTITLE_TRACK:\n            details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;\n            fatal = false;\n            break;\n        }\n        if (loader) {\n          this.resetInternalLoader(context.type);\n        }\n        var errorData = {\n          type: ErrorTypes.NETWORK_ERROR,\n          details: details,\n          fatal: fatal,\n          url: context.url,\n          loader: loader,\n          context: context,\n          error: error,\n          networkDetails: networkDetails,\n          stats: stats\n        };\n        if (response) {\n          var url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;\n          errorData.response = _objectSpread2({\n            url: url,\n            data: undefined\n          }, response);\n        }\n        this.hls.trigger(Events.ERROR, errorData);\n      };\n      _proto.handlePlaylistLoaded = function handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {\n        var hls = this.hls;\n        var type = context.type,\n          level = context.level,\n          id = context.id,\n          groupId = context.groupId,\n          deliveryDirectives = context.deliveryDirectives;\n        var url = getResponseUrl(response, context);\n        var parent = mapContextToLevelType(context);\n        var levelIndex = typeof context.level === 'number' && parent === PlaylistLevelType.MAIN ? level : undefined;\n        if (!levelDetails.fragments.length) {\n          var _error = new Error('No Segments found in Playlist');\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.LEVEL_EMPTY_ERROR,\n            fatal: false,\n            url: url,\n            error: _error,\n            reason: _error.message,\n            response: response,\n            context: context,\n            level: levelIndex,\n            parent: parent,\n            networkDetails: networkDetails,\n            stats: stats\n          });\n          return;\n        }\n        if (!levelDetails.targetduration) {\n          levelDetails.playlistParsingError = new Error('Missing Target Duration');\n        }\n        var error = levelDetails.playlistParsingError;\n        if (error) {\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.LEVEL_PARSING_ERROR,\n            fatal: false,\n            url: url,\n            error: error,\n            reason: error.message,\n            response: response,\n            context: context,\n            level: levelIndex,\n            parent: parent,\n            networkDetails: networkDetails,\n            stats: stats\n          });\n          return;\n        }\n        if (levelDetails.live && loader) {\n          if (loader.getCacheAge) {\n            levelDetails.ageHeader = loader.getCacheAge() || 0;\n          }\n          if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n            levelDetails.ageHeader = 0;\n          }\n        }\n        switch (type) {\n          case PlaylistContextType.MANIFEST:\n          case PlaylistContextType.LEVEL:\n            hls.trigger(Events.LEVEL_LOADED, {\n              details: levelDetails,\n              level: levelIndex || 0,\n              id: id || 0,\n              stats: stats,\n              networkDetails: networkDetails,\n              deliveryDirectives: deliveryDirectives\n            });\n            break;\n          case PlaylistContextType.AUDIO_TRACK:\n            hls.trigger(Events.AUDIO_TRACK_LOADED, {\n              details: levelDetails,\n              id: id || 0,\n              groupId: groupId || '',\n              stats: stats,\n              networkDetails: networkDetails,\n              deliveryDirectives: deliveryDirectives\n            });\n            break;\n          case PlaylistContextType.SUBTITLE_TRACK:\n            hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n              details: levelDetails,\n              id: id || 0,\n              groupId: groupId || '',\n              stats: stats,\n              networkDetails: networkDetails,\n              deliveryDirectives: deliveryDirectives\n            });\n            break;\n        }\n      };\n      return PlaylistLoader;\n    }();\n    function sendAddTrackEvent(track, videoEl) {\n      var event;\n      try {\n        event = new Event('addtrack');\n      } catch (err) {\n        // for IE11\n        event = document.createEvent('Event');\n        event.initEvent('addtrack', false, false);\n      }\n      event.track = track;\n      videoEl.dispatchEvent(event);\n    }\n    function clearCurrentCues(track) {\n      // When track.mode is disabled, track.cues will be null.\n      // To guarantee the removal of cues, we need to temporarily\n      // change the mode to hidden\n      var mode = track.mode;\n      if (mode === 'disabled') {\n        track.mode = 'hidden';\n      }\n      if (track.cues) {\n        for (var i = track.cues.length; i--;) {\n          track.removeCue(track.cues[i]);\n        }\n      }\n      if (mode === 'disabled') {\n        track.mode = mode;\n      }\n    }\n    function removeCuesInRange(track, start, end, predicate) {\n      var mode = track.mode;\n      if (mode === 'disabled') {\n        track.mode = 'hidden';\n      }\n      if (track.cues && track.cues.length > 0) {\n        var cues = getCuesInRange(track.cues, start, end);\n        for (var i = 0; i < cues.length; i++) {\n          if (!predicate || predicate(cues[i])) {\n            track.removeCue(cues[i]);\n          }\n        }\n      }\n      if (mode === 'disabled') {\n        track.mode = mode;\n      }\n    }\n\n    // Find first cue starting after given time.\n    // Modified version of binary search O(log(n)).\n    function getFirstCueIndexAfterTime(cues, time) {\n      // If first cue starts after time, start there\n      if (time < cues[0].startTime) {\n        return 0;\n      }\n      // If the last cue ends before time there is no overlap\n      var len = cues.length - 1;\n      if (time > cues[len].endTime) {\n        return -1;\n      }\n      var left = 0;\n      var right = len;\n      while (left <= right) {\n        var mid = Math.floor((right + left) / 2);\n        if (time < cues[mid].startTime) {\n          right = mid - 1;\n        } else if (time > cues[mid].startTime && left < len) {\n          left = mid + 1;\n        } else {\n          // If it's not lower or higher, it must be equal.\n          return mid;\n        }\n      }\n      // At this point, left and right have swapped.\n      // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n      return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n    }\n    function getCuesInRange(cues, start, end) {\n      var cuesFound = [];\n      var firstCueInRange = getFirstCueIndexAfterTime(cues, start);\n      if (firstCueInRange > -1) {\n        for (var i = firstCueInRange, len = cues.length; i < len; i++) {\n          var _cue = cues[i];\n          if (_cue.startTime >= start && _cue.endTime <= end) {\n            cuesFound.push(_cue);\n          } else if (_cue.startTime > end) {\n            return cuesFound;\n          }\n        }\n      }\n      return cuesFound;\n    }\n    var MetadataSchema = {\n      audioId3: \"org.id3\",\n      dateRange: \"com.apple.quicktime.HLS\",\n      emsg: \"https://aomedia.org/emsg/ID3\"\n    };\n    var MIN_CUE_DURATION = 0.25;\n    function getCueClass() {\n      if (typeof self === 'undefined') return undefined;\n\n      // Attempt to recreate Safari functionality by creating\n      // WebKitDataCue objects when available and store the decoded\n      // ID3 data in the value property of the cue\n      return self.WebKitDataCue || self.VTTCue || self.TextTrackCue;\n    }\n\n    // VTTCue latest draft allows an infinite duration, fallback\n    // to MAX_VALUE if necessary\n    var MAX_CUE_ENDTIME = function () {\n      var Cue = getCueClass();\n      try {\n        new Cue(0, Number.POSITIVE_INFINITY, '');\n      } catch (e) {\n        return Number.MAX_VALUE;\n      }\n      return Number.POSITIVE_INFINITY;\n    }();\n    function dateRangeDateToTimelineSeconds(date, offset) {\n      return date.getTime() / 1000 - offset;\n    }\n    function hexToArrayBuffer(str) {\n      return Uint8Array.from(str.replace(/^0x/, '').replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;\n    }\n    var ID3TrackController = /*#__PURE__*/function () {\n      function ID3TrackController(hls) {\n        this.hls = void 0;\n        this.id3Track = null;\n        this.media = null;\n        this.dateRangeCuesAppended = {};\n        this.hls = hls;\n        this._registerListeners();\n      }\n      var _proto = ID3TrackController.prototype;\n      _proto.destroy = function destroy() {\n        this._unregisterListeners();\n        this.id3Track = null;\n        this.media = null;\n        this.dateRangeCuesAppended = {};\n        // @ts-ignore\n        this.hls = null;\n      };\n      _proto._registerListeners = function _registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      };\n      _proto._unregisterListeners = function _unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      }\n\n      // Add ID3 metatadata text track.\n      ;\n\n      _proto.onMediaAttached = function onMediaAttached(event, data) {\n        this.media = data.media;\n      };\n      _proto.onMediaDetaching = function onMediaDetaching() {\n        if (!this.id3Track) {\n          return;\n        }\n        clearCurrentCues(this.id3Track);\n        this.id3Track = null;\n        this.media = null;\n        this.dateRangeCuesAppended = {};\n      };\n      _proto.onManifestLoading = function onManifestLoading() {\n        this.dateRangeCuesAppended = {};\n      };\n      _proto.createTrack = function createTrack(media) {\n        var track = this.getID3Track(media.textTracks);\n        track.mode = 'hidden';\n        return track;\n      };\n      _proto.getID3Track = function getID3Track(textTracks) {\n        if (!this.media) {\n          return;\n        }\n        for (var i = 0; i < textTracks.length; i++) {\n          var textTrack = textTracks[i];\n          if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n            // send 'addtrack' when reusing the textTrack for metadata,\n            // same as what we do for captions\n            sendAddTrackEvent(textTrack, this.media);\n            return textTrack;\n          }\n        }\n        return this.media.addTextTrack('metadata', 'id3');\n      };\n      _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {\n        if (!this.media) {\n          return;\n        }\n        var _this$hls$config = this.hls.config,\n          enableEmsgMetadataCues = _this$hls$config.enableEmsgMetadataCues,\n          enableID3MetadataCues = _this$hls$config.enableID3MetadataCues;\n        if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n          return;\n        }\n        var samples = data.samples;\n\n        // create track dynamically\n        if (!this.id3Track) {\n          this.id3Track = this.createTrack(this.media);\n        }\n        var Cue = getCueClass();\n        for (var i = 0; i < samples.length; i++) {\n          var type = samples[i].type;\n          if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n            continue;\n          }\n          var frames = getID3Frames(samples[i].data);\n          if (frames) {\n            var startTime = samples[i].pts;\n            var endTime = startTime + samples[i].duration;\n            if (endTime > MAX_CUE_ENDTIME) {\n              endTime = MAX_CUE_ENDTIME;\n            }\n            var timeDiff = endTime - startTime;\n            if (timeDiff <= 0) {\n              endTime = startTime + MIN_CUE_DURATION;\n            }\n            for (var j = 0; j < frames.length; j++) {\n              var frame = frames[j];\n              // Safari doesn't put the timestamp frame in the TextTrack\n              if (!isTimeStampFrame(frame)) {\n                // add a bounds to any unbounded cues\n                this.updateId3CueEnds(startTime);\n                var cue = new Cue(startTime, endTime, '');\n                cue.value = frame;\n                if (type) {\n                  cue.type = type;\n                }\n                this.id3Track.addCue(cue);\n              }\n            }\n          }\n        }\n      };\n      _proto.updateId3CueEnds = function updateId3CueEnds(startTime) {\n        var _this$id3Track;\n        var cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;\n        if (cues) {\n          for (var i = cues.length; i--;) {\n            var cue = cues[i];\n            if (cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n              cue.endTime = startTime;\n            }\n          }\n        }\n      };\n      _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {\n        var startOffset = _ref.startOffset,\n          endOffset = _ref.endOffset,\n          type = _ref.type;\n        var id3Track = this.id3Track,\n          hls = this.hls;\n        if (!hls) {\n          return;\n        }\n        var _hls$config = hls.config,\n          enableEmsgMetadataCues = _hls$config.enableEmsgMetadataCues,\n          enableID3MetadataCues = _hls$config.enableID3MetadataCues;\n        if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n          var predicate;\n          if (type === 'audio') {\n            predicate = function predicate(cue) {\n              return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;\n            };\n          } else if (type === 'video') {\n            predicate = function predicate(cue) {\n              return cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n            };\n          } else {\n            predicate = function predicate(cue) {\n              return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n            };\n          }\n          removeCuesInRange(id3Track, startOffset, endOffset, predicate);\n        }\n      };\n      _proto.onLevelUpdated = function onLevelUpdated(event, _ref2) {\n        var _this = this;\n        var details = _ref2.details;\n        if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n          return;\n        }\n        var dateRangeCuesAppended = this.dateRangeCuesAppended,\n          id3Track = this.id3Track;\n        var dateRanges = details.dateRanges;\n        var ids = Object.keys(dateRanges);\n        // Remove cues from track not found in details.dateRanges\n        if (id3Track) {\n          var idsToRemove = Object.keys(dateRangeCuesAppended).filter(function (id) {\n            return !ids.includes(id);\n          });\n          var _loop = function _loop() {\n            var id = idsToRemove[i];\n            Object.keys(dateRangeCuesAppended[id].cues).forEach(function (key) {\n              id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);\n            });\n            delete dateRangeCuesAppended[id];\n          };\n          for (var i = idsToRemove.length; i--;) {\n            _loop();\n          }\n        }\n        // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n        var lastFragment = details.fragments[details.fragments.length - 1];\n        if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {\n          return;\n        }\n        if (!this.id3Track) {\n          this.id3Track = this.createTrack(this.media);\n        }\n        var dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;\n        var Cue = getCueClass();\n        var _loop2 = function _loop2() {\n          var id = ids[_i];\n          var dateRange = dateRanges[id];\n          var appendedDateRangeCues = dateRangeCuesAppended[id];\n          var cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};\n          var durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;\n          var startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);\n          var endTime = MAX_CUE_ENDTIME;\n          var endDate = dateRange.endDate;\n          if (endDate) {\n            endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);\n            durationKnown = true;\n          } else if (dateRange.endOnNext && !durationKnown) {\n            var nextDateRangeWithSameClass = ids.reduce(function (filterMapArray, id) {\n              var candidate = dateRanges[id];\n              if (candidate.class === dateRange.class && candidate.id !== id && candidate.startDate > dateRange.startDate) {\n                filterMapArray.push(candidate);\n              }\n              return filterMapArray;\n            }, []).sort(function (a, b) {\n              return a.startDate.getTime() - b.startDate.getTime();\n            })[0];\n            if (nextDateRangeWithSameClass) {\n              endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);\n              durationKnown = true;\n            }\n          }\n          var attributes = Object.keys(dateRange.attr);\n          for (var j = 0; j < attributes.length; j++) {\n            var key = attributes[j];\n            if (!isDateRangeCueAttribute(key)) {\n              continue;\n            }\n            var cue = cues[key];\n            if (cue) {\n              if (durationKnown && !appendedDateRangeCues.durationKnown) {\n                cue.endTime = endTime;\n              }\n            } else {\n              var data = dateRange.attr[key];\n              cue = new Cue(startTime, endTime, '');\n              if (isSCTE35Attribute(key)) {\n                data = hexToArrayBuffer(data);\n              }\n              cue.value = {\n                key: key,\n                data: data\n              };\n              cue.type = MetadataSchema.dateRange;\n              cue.id = id;\n              _this.id3Track.addCue(cue);\n              cues[key] = cue;\n            }\n          }\n          dateRangeCuesAppended[id] = {\n            cues: cues,\n            dateRange: dateRange,\n            durationKnown: durationKnown\n          };\n        };\n        for (var _i = 0; _i < ids.length; _i++) {\n          _loop2();\n        }\n      };\n      return ID3TrackController;\n    }();\n    var LatencyController = /*#__PURE__*/function () {\n      function LatencyController(hls) {\n        var _this = this;\n        this.hls = void 0;\n        this.config = void 0;\n        this.media = null;\n        this.levelDetails = null;\n        this.currentTime = 0;\n        this.stallCount = 0;\n        this._latency = null;\n        this.timeupdateHandler = function () {\n          return _this.timeupdate();\n        };\n        this.hls = hls;\n        this.config = hls.config;\n        this.registerListeners();\n      }\n      var _proto = LatencyController.prototype;\n      _proto.destroy = function destroy() {\n        this.unregisterListeners();\n        this.onMediaDetaching();\n        this.levelDetails = null;\n        // @ts-ignore\n        this.hls = this.timeupdateHandler = null;\n      };\n      _proto.registerListeners = function registerListeners() {\n        this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        this.hls.on(Events.ERROR, this.onError, this);\n      };\n      _proto.unregisterListeners = function unregisterListeners() {\n        this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        this.hls.off(Events.ERROR, this.onError, this);\n      };\n      _proto.onMediaAttached = function onMediaAttached(event, data) {\n        this.media = data.media;\n        this.media.addEventListener('timeupdate', this.timeupdateHandler);\n      };\n      _proto.onMediaDetaching = function onMediaDetaching() {\n        if (this.media) {\n          this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n          this.media = null;\n        }\n      };\n      _proto.onManifestLoading = function onManifestLoading() {\n        this.levelDetails = null;\n        this._latency = null;\n        this.stallCount = 0;\n      };\n      _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n        var details = _ref.details;\n        this.levelDetails = details;\n        if (details.advanced) {\n          this.timeupdate();\n        }\n        if (!details.live && this.media) {\n          this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n        }\n      };\n      _proto.onError = function onError(event, data) {\n        var _this$levelDetails;\n        if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {\n          return;\n        }\n        this.stallCount++;\n        if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {\n          logger.warn('[playback-rate-controller]: Stall detected, adjusting target latency');\n        }\n      };\n      _proto.timeupdate = function timeupdate() {\n        var media = this.media,\n          levelDetails = this.levelDetails;\n        if (!media || !levelDetails) {\n          return;\n        }\n        this.currentTime = media.currentTime;\n        var latency = this.computeLatency();\n        if (latency === null) {\n          return;\n        }\n        this._latency = latency;\n\n        // Adapt playbackRate to meet target latency in low-latency mode\n        var _this$config = this.config,\n          lowLatencyMode = _this$config.lowLatencyMode,\n          maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;\n        if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1) {\n          return;\n        }\n        var targetLatency = this.targetLatency;\n        if (targetLatency === null) {\n          return;\n        }\n        var distanceFromTarget = latency - targetLatency;\n        // Only adjust playbackRate when within one target duration of targetLatency\n        // and more than one second from under-buffering.\n        // Playback further than one target duration from target can be considered DVR playback.\n        var liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n        var inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n        if (levelDetails.live && inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n          var max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n          var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n          media.playbackRate = Math.min(max, Math.max(1, rate));\n        } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n          media.playbackRate = 1;\n        }\n      };\n      _proto.estimateLiveEdge = function estimateLiveEdge() {\n        var levelDetails = this.levelDetails;\n        if (levelDetails === null) {\n          return null;\n        }\n        return levelDetails.edge + levelDetails.age;\n      };\n      _proto.computeLatency = function computeLatency() {\n        var liveEdge = this.estimateLiveEdge();\n        if (liveEdge === null) {\n          return null;\n        }\n        return liveEdge - this.currentTime;\n      };\n      _createClass(LatencyController, [{\n        key: \"latency\",\n        get: function get() {\n          return this._latency || 0;\n        }\n      }, {\n        key: \"maxLatency\",\n        get: function get() {\n          var config = this.config,\n            levelDetails = this.levelDetails;\n          if (config.liveMaxLatencyDuration !== undefined) {\n            return config.liveMaxLatencyDuration;\n          }\n          return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n        }\n      }, {\n        key: \"targetLatency\",\n        get: function get() {\n          var levelDetails = this.levelDetails;\n          if (levelDetails === null) {\n            return null;\n          }\n          var holdBack = levelDetails.holdBack,\n            partHoldBack = levelDetails.partHoldBack,\n            targetduration = levelDetails.targetduration;\n          var _this$config2 = this.config,\n            liveSyncDuration = _this$config2.liveSyncDuration,\n            liveSyncDurationCount = _this$config2.liveSyncDurationCount,\n            lowLatencyMode = _this$config2.lowLatencyMode;\n          var userConfig = this.hls.userConfig;\n          var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n          if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n            targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n          }\n          var maxLiveSyncOnStallIncrease = targetduration;\n          var liveSyncOnStallIncrease = 1.0;\n          return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n        }\n      }, {\n        key: \"liveSyncPosition\",\n        get: function get() {\n          var liveEdge = this.estimateLiveEdge();\n          var targetLatency = this.targetLatency;\n          var levelDetails = this.levelDetails;\n          if (liveEdge === null || targetLatency === null || levelDetails === null) {\n            return null;\n          }\n          var edge = levelDetails.edge;\n          var syncPosition = liveEdge - targetLatency - this.edgeStalled;\n          var min = edge - levelDetails.totalduration;\n          var max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n          return Math.min(Math.max(min, syncPosition), max);\n        }\n      }, {\n        key: \"drift\",\n        get: function get() {\n          var levelDetails = this.levelDetails;\n          if (levelDetails === null) {\n            return 1;\n          }\n          return levelDetails.drift;\n        }\n      }, {\n        key: \"edgeStalled\",\n        get: function get() {\n          var levelDetails = this.levelDetails;\n          if (levelDetails === null) {\n            return 0;\n          }\n          var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n          return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n        }\n      }, {\n        key: \"forwardBufferLength\",\n        get: function get() {\n          var media = this.media,\n            levelDetails = this.levelDetails;\n          if (!media || !levelDetails) {\n            return 0;\n          }\n          var bufferedRanges = media.buffered.length;\n          return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n        }\n      }]);\n      return LatencyController;\n    }();\n    var HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', null];\n    var HlsSkip = {\n      No: \"\",\n      Yes: \"YES\",\n      v2: \"v2\"\n    };\n    function getSkipValue(details, msn) {\n      var canSkipUntil = details.canSkipUntil,\n        canSkipDateRanges = details.canSkipDateRanges,\n        endSN = details.endSN;\n      var snChangeGoal = msn !== undefined ? msn - endSN : 0;\n      if (canSkipUntil && snChangeGoal < canSkipUntil) {\n        if (canSkipDateRanges) {\n          return HlsSkip.v2;\n        }\n        return HlsSkip.Yes;\n      }\n      return HlsSkip.No;\n    }\n    var HlsUrlParameters = /*#__PURE__*/function () {\n      function HlsUrlParameters(msn, part, skip) {\n        this.msn = void 0;\n        this.part = void 0;\n        this.skip = void 0;\n        this.msn = msn;\n        this.part = part;\n        this.skip = skip;\n      }\n      var _proto = HlsUrlParameters.prototype;\n      _proto.addDirectives = function addDirectives(uri) {\n        var url = new self.URL(uri);\n        if (this.msn !== undefined) {\n          url.searchParams.set('_HLS_msn', this.msn.toString());\n        }\n        if (this.part !== undefined) {\n          url.searchParams.set('_HLS_part', this.part.toString());\n        }\n        if (this.skip) {\n          url.searchParams.set('_HLS_skip', this.skip);\n        }\n        return url.href;\n      };\n      return HlsUrlParameters;\n    }();\n    var Level = /*#__PURE__*/function () {\n      function Level(data) {\n        this._attrs = void 0;\n        this.audioCodec = void 0;\n        this.bitrate = void 0;\n        this.codecSet = void 0;\n        this.height = void 0;\n        this.id = void 0;\n        this.name = void 0;\n        this.videoCodec = void 0;\n        this.width = void 0;\n        this.unknownCodecs = void 0;\n        this.audioGroupIds = void 0;\n        this.details = void 0;\n        this.fragmentError = 0;\n        this.loadError = 0;\n        this.loaded = void 0;\n        this.realBitrate = 0;\n        this.textGroupIds = void 0;\n        this.url = void 0;\n        this._urlId = 0;\n        this.url = [data.url];\n        this._attrs = [data.attrs];\n        this.bitrate = data.bitrate;\n        if (data.details) {\n          this.details = data.details;\n        }\n        this.id = data.id || 0;\n        this.name = data.name;\n        this.width = data.width || 0;\n        this.height = data.height || 0;\n        this.audioCodec = data.audioCodec;\n        this.videoCodec = data.videoCodec;\n        this.unknownCodecs = data.unknownCodecs;\n        this.codecSet = [data.videoCodec, data.audioCodec].filter(function (c) {\n          return c;\n        }).join(',').replace(/\\.[^.,]+/g, '');\n      }\n      var _proto2 = Level.prototype;\n      _proto2.addFallback = function addFallback(data) {\n        this.url.push(data.url);\n        this._attrs.push(data.attrs);\n      };\n      _createClass(Level, [{\n        key: \"maxBitrate\",\n        get: function get() {\n          return Math.max(this.realBitrate, this.bitrate);\n        }\n      }, {\n        key: \"attrs\",\n        get: function get() {\n          return this._attrs[this._urlId];\n        }\n      }, {\n        key: \"pathwayId\",\n        get: function get() {\n          return this.attrs['PATHWAY-ID'] || '.';\n        }\n      }, {\n        key: \"uri\",\n        get: function get() {\n          return this.url[this._urlId] || '';\n        }\n      }, {\n        key: \"urlId\",\n        get: function get() {\n          return this._urlId;\n        },\n        set: function set(value) {\n          var newValue = value % this.url.length;\n          if (this._urlId !== newValue) {\n            this.fragmentError = 0;\n            this.loadError = 0;\n            this.details = undefined;\n            this._urlId = newValue;\n          }\n        }\n      }, {\n        key: \"audioGroupId\",\n        get: function get() {\n          var _this$audioGroupIds;\n          return (_this$audioGroupIds = this.audioGroupIds) == null ? void 0 : _this$audioGroupIds[this.urlId];\n        }\n      }, {\n        key: \"textGroupId\",\n        get: function get() {\n          var _this$textGroupIds;\n          return (_this$textGroupIds = this.textGroupIds) == null ? void 0 : _this$textGroupIds[this.urlId];\n        }\n      }]);\n      return Level;\n    }();\n    function updateFromToPTS(fragFrom, fragTo) {\n      var fragToPTS = fragTo.startPTS;\n      // if we know startPTS[toIdx]\n      if (isFiniteNumber(fragToPTS)) {\n        // update fragment duration.\n        // it helps to fix drifts between playlist reported duration and fragment real duration\n        var duration = 0;\n        var frag;\n        if (fragTo.sn > fragFrom.sn) {\n          duration = fragToPTS - fragFrom.start;\n          frag = fragFrom;\n        } else {\n          duration = fragFrom.start - fragToPTS;\n          frag = fragTo;\n        }\n        if (frag.duration !== duration) {\n          frag.duration = duration;\n        }\n        // we dont know startPTS[toIdx]\n      } else if (fragTo.sn > fragFrom.sn) {\n        var contiguous = fragFrom.cc === fragTo.cc;\n        // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n        if (contiguous && fragFrom.minEndPTS) {\n          fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);\n        } else {\n          fragTo.start = fragFrom.start + fragFrom.duration;\n        }\n      } else {\n        fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);\n      }\n    }\n    function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n      var parsedMediaDuration = endPTS - startPTS;\n      if (parsedMediaDuration <= 0) {\n        logger.warn('Fragment should have a positive duration', frag);\n        endPTS = startPTS + frag.duration;\n        endDTS = startDTS + frag.duration;\n      }\n      var maxStartPTS = startPTS;\n      var minEndPTS = endPTS;\n      var fragStartPts = frag.startPTS;\n      var fragEndPts = frag.endPTS;\n      if (isFiniteNumber(fragStartPts)) {\n        // delta PTS between audio and video\n        var deltaPTS = Math.abs(fragStartPts - startPTS);\n        if (!isFiniteNumber(frag.deltaPTS)) {\n          frag.deltaPTS = deltaPTS;\n        } else {\n          frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n        }\n        maxStartPTS = Math.max(startPTS, fragStartPts);\n        startPTS = Math.min(startPTS, fragStartPts);\n        startDTS = Math.min(startDTS, frag.startDTS);\n        minEndPTS = Math.min(endPTS, fragEndPts);\n        endPTS = Math.max(endPTS, fragEndPts);\n        endDTS = Math.max(endDTS, frag.endDTS);\n      }\n      var drift = startPTS - frag.start;\n      if (frag.start !== 0) {\n        frag.start = startPTS;\n      }\n      frag.duration = endPTS - frag.start;\n      frag.startPTS = startPTS;\n      frag.maxStartPTS = maxStartPTS;\n      frag.startDTS = startDTS;\n      frag.endPTS = endPTS;\n      frag.minEndPTS = minEndPTS;\n      frag.endDTS = endDTS;\n      var sn = frag.sn; // 'initSegment'\n      // exit if sn out of range\n      if (!details || sn < details.startSN || sn > details.endSN) {\n        return 0;\n      }\n      var i;\n      var fragIdx = sn - details.startSN;\n      var fragments = details.fragments;\n      // update frag reference in fragments array\n      // rationale is that fragments array might not contain this frag object.\n      // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n      // if we don't update frag, we won't be able to propagate PTS info on the playlist\n      // resulting in invalid sliding computation\n      fragments[fragIdx] = frag;\n      // adjust fragment PTS/duration from seqnum-1 to frag 0\n      for (i = fragIdx; i > 0; i--) {\n        updateFromToPTS(fragments[i], fragments[i - 1]);\n      }\n\n      // adjust fragment PTS/duration from seqnum to last frag\n      for (i = fragIdx; i < fragments.length - 1; i++) {\n        updateFromToPTS(fragments[i], fragments[i + 1]);\n      }\n      if (details.fragmentHint) {\n        updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n      }\n      details.PTSKnown = details.alignedSliding = true;\n      return drift;\n    }\n    function mergeDetails(oldDetails, newDetails) {\n      // Track the last initSegment processed. Initialize it to the last one on the timeline.\n      var currentInitSegment = null;\n      var oldFragments = oldDetails.fragments;\n      for (var i = oldFragments.length - 1; i >= 0; i--) {\n        var oldInit = oldFragments[i].initSegment;\n        if (oldInit) {\n          currentInitSegment = oldInit;\n          break;\n        }\n      }\n      if (oldDetails.fragmentHint) {\n        // prevent PTS and duration from being adjusted on the next hint\n        delete oldDetails.fragmentHint.endPTS;\n      }\n      // check if old/new playlists have fragments in common\n      // loop through overlapping SN and update startPTS , cc, and duration if any found\n      var ccOffset = 0;\n      var PTSFrag;\n      mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {\n        if (oldFrag.relurl) {\n          // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.\n          // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end\n          // of the playlist.\n          ccOffset = oldFrag.cc - newFrag.cc;\n        }\n        if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {\n          newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n          newFrag.startDTS = oldFrag.startDTS;\n          newFrag.maxStartPTS = oldFrag.maxStartPTS;\n          newFrag.endPTS = oldFrag.endPTS;\n          newFrag.endDTS = oldFrag.endDTS;\n          newFrag.minEndPTS = oldFrag.minEndPTS;\n          newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;\n          if (newFrag.duration) {\n            PTSFrag = newFrag;\n          }\n\n          // PTS is known when any segment has startPTS and endPTS\n          newDetails.PTSKnown = newDetails.alignedSliding = true;\n        }\n        newFrag.elementaryStreams = oldFrag.elementaryStreams;\n        newFrag.loader = oldFrag.loader;\n        newFrag.stats = oldFrag.stats;\n        newFrag.urlId = oldFrag.urlId;\n        if (oldFrag.initSegment) {\n          newFrag.initSegment = oldFrag.initSegment;\n          currentInitSegment = oldFrag.initSegment;\n        }\n      });\n      if (currentInitSegment) {\n        var fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n        fragmentsToCheck.forEach(function (frag) {\n          var _currentInitSegment;\n          if (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl)) {\n            frag.initSegment = currentInitSegment;\n          }\n        });\n      }\n      if (newDetails.skippedSegments) {\n        newDetails.deltaUpdateFailed = newDetails.fragments.some(function (frag) {\n          return !frag;\n        });\n        if (newDetails.deltaUpdateFailed) {\n          logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n          for (var _i = newDetails.skippedSegments; _i--;) {\n            newDetails.fragments.shift();\n          }\n          newDetails.startSN = newDetails.fragments[0].sn;\n          newDetails.startCC = newDetails.fragments[0].cc;\n        } else if (newDetails.canSkipDateRanges) {\n          newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);\n        }\n      }\n      var newFragments = newDetails.fragments;\n      if (ccOffset) {\n        logger.warn('discontinuity sliding from playlist, take drift into account');\n        for (var _i2 = 0; _i2 < newFragments.length; _i2++) {\n          newFragments[_i2].cc += ccOffset;\n        }\n      }\n      if (newDetails.skippedSegments) {\n        newDetails.startCC = newDetails.fragments[0].cc;\n      }\n\n      // Merge parts\n      mapPartIntersection(oldDetails.partList, newDetails.partList, function (oldPart, newPart) {\n        newPart.elementaryStreams = oldPart.elementaryStreams;\n        newPart.stats = oldPart.stats;\n      });\n\n      // if at least one fragment contains PTS info, recompute PTS information for all fragments\n      if (PTSFrag) {\n        updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n      } else {\n        // ensure that delta is within oldFragments range\n        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n        // in that case we also need to adjust start offset of all fragments\n        adjustSliding(oldDetails, newDetails);\n      }\n      if (newFragments.length) {\n        newDetails.totalduration = newDetails.edge - newFragments[0].start;\n      }\n      newDetails.driftStartTime = oldDetails.driftStartTime;\n      newDetails.driftStart = oldDetails.driftStart;\n      var advancedDateTime = newDetails.advancedDateTime;\n      if (newDetails.advanced && advancedDateTime) {\n        var edge = newDetails.edge;\n        if (!newDetails.driftStart) {\n          newDetails.driftStartTime = advancedDateTime;\n          newDetails.driftStart = edge;\n        }\n        newDetails.driftEndTime = advancedDateTime;\n        newDetails.driftEnd = edge;\n      } else {\n        newDetails.driftEndTime = oldDetails.driftEndTime;\n        newDetails.driftEnd = oldDetails.driftEnd;\n        newDetails.advancedDateTime = oldDetails.advancedDateTime;\n      }\n    }\n    function mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {\n      var dateRanges = _extends({}, oldDateRanges);\n      if (recentlyRemovedDateranges) {\n        recentlyRemovedDateranges.forEach(function (id) {\n          delete dateRanges[id];\n        });\n      }\n      Object.keys(deltaDateRanges).forEach(function (id) {\n        var dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);\n        if (dateRange.isValid) {\n          dateRanges[id] = dateRange;\n        } else {\n          logger.warn(\"Ignoring invalid Playlist Delta Update DATERANGE tag: \\\"\" + JSON.stringify(deltaDateRanges[id].attr) + \"\\\"\");\n        }\n      });\n      return dateRanges;\n    }\n    function mapPartIntersection(oldParts, newParts, intersectionFn) {\n      if (oldParts && newParts) {\n        var delta = 0;\n        for (var i = 0, len = oldParts.length; i <= len; i++) {\n          var _oldPart = oldParts[i];\n          var _newPart = newParts[i + delta];\n          if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {\n            intersectionFn(_oldPart, _newPart);\n          } else {\n            delta--;\n          }\n        }\n      }\n    }\n    function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n      var skippedSegments = newDetails.skippedSegments;\n      var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n      var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n      var delta = newDetails.startSN - oldDetails.startSN;\n      var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n      var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n      for (var i = start; i <= end; i++) {\n        var _oldFrag = oldFrags[delta + i];\n        var _newFrag = newFrags[i];\n        if (skippedSegments && !_newFrag && i < skippedSegments) {\n          // Fill in skipped segments in delta playlist\n          _newFrag = newDetails.fragments[i] = _oldFrag;\n        }\n        if (_oldFrag && _newFrag) {\n          intersectionFn(_oldFrag, _newFrag);\n        }\n      }\n    }\n    function adjustSliding(oldDetails, newDetails) {\n      var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n      var oldFragments = oldDetails.fragments;\n      if (delta < 0 || delta >= oldFragments.length) {\n        return;\n      }\n      addSliding(newDetails, oldFragments[delta].start);\n    }\n    function addSliding(details, start) {\n      if (start) {\n        var fragments = details.fragments;\n        for (var i = details.skippedSegments; i < fragments.length; i++) {\n          fragments[i].start += start;\n        }\n        if (details.fragmentHint) {\n          details.fragmentHint.start += start;\n        }\n      }\n    }\n    function computeReloadInterval(newDetails, distanceToLiveEdgeMs) {\n      if (distanceToLiveEdgeMs === void 0) {\n        distanceToLiveEdgeMs = Infinity;\n      }\n      var reloadInterval = 1000 * newDetails.targetduration;\n      if (newDetails.updated) {\n        // Use last segment duration when shorter than target duration and near live edge\n        var fragments = newDetails.fragments;\n        var liveEdgeMaxTargetDurations = 4;\n        if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n          var lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n          if (lastSegmentDuration < reloadInterval) {\n            reloadInterval = lastSegmentDuration;\n          }\n        }\n      } else {\n        // estimate = 'miss half average';\n        // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n        // changed then it MUST wait for a period of one-half the target\n        // duration before retrying.\n        reloadInterval /= 2;\n      }\n      return Math.round(reloadInterval);\n    }\n    function getFragmentWithSN(level, sn, fragCurrent) {\n      if (!(level != null && level.details)) {\n        return null;\n      }\n      var levelDetails = level.details;\n      var fragment = levelDetails.fragments[sn - levelDetails.startSN];\n      if (fragment) {\n        return fragment;\n      }\n      fragment = levelDetails.fragmentHint;\n      if (fragment && fragment.sn === sn) {\n        return fragment;\n      }\n      if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {\n        return fragCurrent;\n      }\n      return null;\n    }\n    function getPartWith(level, sn, partIndex) {\n      var _level$details;\n      if (!(level != null && level.details)) {\n        return null;\n      }\n      return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);\n    }\n    function findPart(partList, sn, partIndex) {\n      if (partList) {\n        for (var i = partList.length; i--;) {\n          var part = partList[i];\n          if (part.index === partIndex && part.fragment.sn === sn) {\n            return part;\n          }\n        }\n      }\n      return null;\n    }\n    function isTimeoutError(error) {\n      switch (error.details) {\n        case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case ErrorDetails.KEY_LOAD_TIMEOUT:\n        case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        case ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n          return true;\n      }\n      return false;\n    }\n    function getRetryConfig(loadPolicy, error) {\n      var isTimeout = isTimeoutError(error);\n      return loadPolicy.default[(isTimeout ? 'timeout' : 'error') + \"Retry\"];\n    }\n    function getRetryDelay(retryConfig, retryCount) {\n      // exponential backoff capped to max retry delay\n      var backoffFactor = retryConfig.backoff === 'linear' ? 1 : Math.pow(2, retryCount);\n      return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);\n    }\n    function getLoaderConfigWithoutReties(loderConfig) {\n      return _objectSpread2(_objectSpread2({}, loderConfig), {\n        errorRetry: null,\n        timeoutRetry: null\n      });\n    }\n    function shouldRetry(retryConfig, retryCount, isTimeout, httpStatus) {\n      return !!retryConfig && retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);\n    }\n    function retryForHttpStatus(httpStatus) {\n      // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)\n      return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);\n    }\n    var BinarySearch = {\n      /**\n       * Searches for an item in an array which matches a certain condition.\n       * This requires the condition to only match one item in the array,\n       * and for the array to be ordered.\n       *\n       * @param list The array to search.\n       * @param comparisonFn\n       *      Called and provided a candidate item as the first argument.\n       *      Should return:\n       *          > -1 if the item should be located at a lower index than the provided item.\n       *          > 1 if the item should be located at a higher index than the provided item.\n       *          > 0 if the item is the item you're looking for.\n       *\n       * @returns the object if found, otherwise returns null\n       */\n      search: function search(list, comparisonFn) {\n        var minIndex = 0;\n        var maxIndex = list.length - 1;\n        var currentIndex = null;\n        var currentElement = null;\n        while (minIndex <= maxIndex) {\n          currentIndex = (minIndex + maxIndex) / 2 | 0;\n          currentElement = list[currentIndex];\n          var comparisonResult = comparisonFn(currentElement);\n          if (comparisonResult > 0) {\n            minIndex = currentIndex + 1;\n          } else if (comparisonResult < 0) {\n            maxIndex = currentIndex - 1;\n          } else {\n            return currentElement;\n          }\n        }\n        return null;\n      }\n    };\n\n    /**\n     * Returns first fragment whose endPdt value exceeds the given PDT, or null.\n     * @param fragments - The array of candidate fragments\n     * @param PDTValue - The PDT value which must be exceeded\n     * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n     */\n    function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n      if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {\n        return null;\n      }\n\n      // if less than start\n      var startPDT = fragments[0].programDateTime;\n      if (PDTValue < (startPDT || 0)) {\n        return null;\n      }\n      var endPDT = fragments[fragments.length - 1].endProgramDateTime;\n      if (PDTValue >= (endPDT || 0)) {\n        return null;\n      }\n      maxFragLookUpTolerance = maxFragLookUpTolerance || 0;\n      for (var seg = 0; seg < fragments.length; ++seg) {\n        var frag = fragments[seg];\n        if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n          return frag;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n     * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n     * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n     * @param fragPrevious - The last frag successfully appended\n     * @param fragments - The array of candidate fragments\n     * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within\n     * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n     * @returns a matching fragment or null\n     */\n    function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {\n      if (bufferEnd === void 0) {\n        bufferEnd = 0;\n      }\n      if (maxFragLookUpTolerance === void 0) {\n        maxFragLookUpTolerance = 0;\n      }\n      var fragNext = null;\n      if (fragPrevious) {\n        fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;\n      } else if (bufferEnd === 0 && fragments[0].start === 0) {\n        fragNext = fragments[0];\n      }\n      // Prefer the next fragment if it's within tolerance\n      if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {\n        return fragNext;\n      }\n      // We might be seeking past the tolerance so find the best match\n      var foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n      if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n        return foundFragment;\n      }\n      // If no match was found return the next fragment after fragPrevious, or null\n      return fragNext;\n    }\n\n    /**\n     * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n     * @param candidate - The fragment to test\n     * @param bufferEnd - The end of the current buffered range the playhead is currently within\n     * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n     * @returns 0 if it matches, 1 if too low, -1 if too high\n     */\n    function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {\n      if (bufferEnd === void 0) {\n        bufferEnd = 0;\n      }\n      if (maxFragLookUpTolerance === void 0) {\n        maxFragLookUpTolerance = 0;\n      }\n      // eagerly accept an accurate match (no tolerance)\n      if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n        return 0;\n      }\n      // offset should be within fragment boundary - config.maxFragLookUpTolerance\n      // this is to cope with situations like\n      // bufferEnd = 9.991\n      // frag[] : [0,10]\n      // frag[1] : [10,20]\n      // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n      //              frag start               frag start+duration\n      //                  |-----------------------------|\n      //              <--->                         <--->\n      //  ...--------><-----------------------------><---------....\n      // previous frag         matching fragment         next frag\n      //  return -1             return 0                 return 1\n      // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n      // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n      var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n      if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n        return 1;\n      } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n        // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n        return -1;\n      }\n      return 0;\n    }\n\n    /**\n     * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n     * This function tests the candidate's program date time values, as represented in Unix time\n     * @param candidate - The fragment to test\n     * @param pdtBufferEnd - The Unix time representing the end of the current buffered range\n     * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n     * @returns true if contiguous, false otherwise\n     */\n    function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n      var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n\n      // endProgramDateTime can be null, default to zero\n      var endProgramDateTime = candidate.endProgramDateTime || 0;\n      return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n    }\n    function findFragWithCC(fragments, cc) {\n      return BinarySearch.search(fragments, function (candidate) {\n        if (candidate.cc < cc) {\n          return 1;\n        } else if (candidate.cc > cc) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n    }\n    var RENDITION_PENALTY_DURATION_MS = 300000;\n    var NetworkErrorAction = {\n      DoNothing: 0,\n      SendEndCallback: 1,\n      SendAlternateToPenaltyBox: 2,\n      RemoveAlternatePermanently: 3,\n      InsertDiscontinuity: 4,\n      RetryRequest: 5\n    };\n    var ErrorActionFlags = {\n      None: 0,\n      MoveAllAlternatesMatchingHost: 1,\n      MoveAllAlternatesMatchingHDCP: 2,\n      SwitchToSDR: 4\n    }; // Reserved for future use\n    var ErrorController = /*#__PURE__*/function () {\n      function ErrorController(hls) {\n        this.hls = void 0;\n        this.playlistError = 0;\n        this.penalizedRenditions = {};\n        this.log = void 0;\n        this.warn = void 0;\n        this.error = void 0;\n        this.hls = hls;\n        this.log = logger.log.bind(logger, \"[info]:\");\n        this.warn = logger.warn.bind(logger, \"[warning]:\");\n        this.error = logger.error.bind(logger, \"[error]:\");\n        this.registerListeners();\n      }\n      var _proto = ErrorController.prototype;\n      _proto.registerListeners = function registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      };\n      _proto.unregisterListeners = function unregisterListeners() {\n        var hls = this.hls;\n        if (!hls) {\n          return;\n        }\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.ERROR, this.onErrorOut, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      };\n      _proto.destroy = function destroy() {\n        this.unregisterListeners();\n        // @ts-ignore\n        this.hls = null;\n        this.penalizedRenditions = {};\n      };\n      _proto.startLoad = function startLoad(startPosition) {\n        this.playlistError = 0;\n      };\n      _proto.stopLoad = function stopLoad() {};\n      _proto.getVariantLevelIndex = function getVariantLevelIndex(frag) {\n        return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;\n      };\n      _proto.onManifestLoading = function onManifestLoading() {\n        this.playlistError = 0;\n        this.penalizedRenditions = {};\n      };\n      _proto.onLevelUpdated = function onLevelUpdated() {\n        this.playlistError = 0;\n      };\n      _proto.onError = function onError(event, data) {\n        var _data$level;\n        if (data.fatal) {\n          return;\n        }\n        var hls = this.hls;\n        var context = data.context;\n        switch (data.details) {\n          case ErrorDetails.FRAG_LOAD_ERROR:\n          case ErrorDetails.FRAG_LOAD_TIMEOUT:\n          case ErrorDetails.KEY_LOAD_ERROR:\n          case ErrorDetails.KEY_LOAD_TIMEOUT:\n            data.errorAction = this.getFragRetryOrSwitchAction(data);\n            return;\n          case ErrorDetails.FRAG_GAP:\n          case ErrorDetails.FRAG_PARSING_ERROR:\n          case ErrorDetails.FRAG_DECRYPT_ERROR:\n            {\n              // Switch level if possible, otherwise allow retry count to reach max error retries\n              data.errorAction = this.getFragRetryOrSwitchAction(data);\n              data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n              return;\n            }\n          case ErrorDetails.LEVEL_EMPTY_ERROR:\n          case ErrorDetails.LEVEL_PARSING_ERROR:\n            {\n              var _data$context, _data$context$levelDe;\n              // Only retry when empty and live\n              var levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n              if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {\n                data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);\n              } else {\n                // Escalate to fatal if not retrying or switching\n                data.levelRetry = false;\n                data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n              }\n            }\n            return;\n          case ErrorDetails.LEVEL_LOAD_ERROR:\n          case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n            if (typeof (context == null ? void 0 : context.level) === 'number') {\n              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);\n            }\n            return;\n          case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n          case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n          case ErrorDetails.SUBTITLE_LOAD_ERROR:\n          case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:\n            if (context) {\n              var level = hls.levels[hls.loadLevel];\n              if (level && (context.type === PlaylistContextType.AUDIO_TRACK && context.groupId === level.audioGroupId || context.type === PlaylistContextType.SUBTITLE_TRACK && context.groupId === level.textGroupId)) {\n                // Perform Pathway switch or Redundant failover if possible for fastest recovery\n                // otherwise allow playlist retry count to reach max error retries\n                data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);\n                data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n                data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;\n                return;\n              }\n            }\n            return;\n          case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n            {\n              var _level = hls.levels[hls.loadLevel];\n              var restrictedHdcpLevel = _level == null ? void 0 : _level.attrs['HDCP-LEVEL'];\n              if (restrictedHdcpLevel) {\n                data.errorAction = {\n                  action: NetworkErrorAction.SendAlternateToPenaltyBox,\n                  flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,\n                  hdcpLevel: restrictedHdcpLevel\n                };\n              }\n            }\n            return;\n          case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n          case ErrorDetails.REMUX_ALLOC_ERROR:\n            data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);\n            return;\n          case ErrorDetails.INTERNAL_EXCEPTION:\n          case ErrorDetails.BUFFER_APPENDING_ERROR:\n          case ErrorDetails.BUFFER_APPEND_ERROR:\n          case ErrorDetails.BUFFER_FULL_ERROR:\n          case ErrorDetails.LEVEL_SWITCH_ERROR:\n          case ErrorDetails.BUFFER_STALLED_ERROR:\n          case ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n          case ErrorDetails.BUFFER_NUDGE_ON_STALL:\n            data.errorAction = {\n              action: NetworkErrorAction.DoNothing,\n              flags: ErrorActionFlags.None\n            };\n            return;\n        }\n        if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n          var _levelIndex = this.getVariantLevelIndex(data.frag);\n          // Do not retry level. Escalate to fatal if switching levels fails.\n          data.levelRetry = false;\n          data.errorAction = this.getLevelSwitchAction(data, _levelIndex);\n          return;\n        }\n      };\n      _proto.getPlaylistRetryOrSwitchAction = function getPlaylistRetryOrSwitchAction(data, levelIndex) {\n        var _data$response;\n        var hls = this.hls;\n        var retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);\n        var retryCount = this.playlistError++;\n        var httpStatus = (_data$response = data.response) == null ? void 0 : _data$response.code;\n        var retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), httpStatus);\n        if (retry) {\n          return {\n            action: NetworkErrorAction.RetryRequest,\n            flags: ErrorActionFlags.None,\n            retryConfig: retryConfig,\n            retryCount: retryCount\n          };\n        }\n        var errorAction = this.getLevelSwitchAction(data, levelIndex);\n        if (retryConfig) {\n          errorAction.retryConfig = retryConfig;\n          errorAction.retryCount = retryCount;\n        }\n        return errorAction;\n      };\n      _proto.getFragRetryOrSwitchAction = function getFragRetryOrSwitchAction(data) {\n        var hls = this.hls;\n        // Share fragment error count accross media options (main, audio, subs)\n        // This allows for level based rendition switching when media option assets fail\n        var variantLevelIndex = this.getVariantLevelIndex(data.frag);\n        var level = hls.levels[variantLevelIndex];\n        var _hls$config = hls.config,\n          fragLoadPolicy = _hls$config.fragLoadPolicy,\n          keyLoadPolicy = _hls$config.keyLoadPolicy;\n        var retryConfig = getRetryConfig(data.details.startsWith('key') ? keyLoadPolicy : fragLoadPolicy, data);\n        var fragmentErrors = hls.levels.reduce(function (acc, level) {\n          return acc + level.fragmentError;\n        }, 0);\n        // Switch levels when out of retried or level index out of bounds\n        if (level) {\n          var _data$response2;\n          if (data.details !== ErrorDetails.FRAG_GAP) {\n            level.fragmentError++;\n          }\n          var httpStatus = (_data$response2 = data.response) == null ? void 0 : _data$response2.code;\n          var retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), httpStatus);\n          if (retry) {\n            return {\n              action: NetworkErrorAction.RetryRequest,\n              flags: ErrorActionFlags.None,\n              retryConfig: retryConfig,\n              retryCount: fragmentErrors\n            };\n          }\n        }\n        // Reach max retry count, or Missing level reference\n        // Switch to valid index\n        var errorAction = this.getLevelSwitchAction(data, variantLevelIndex);\n        // Add retry details to allow skipping of FRAG_PARSING_ERROR\n        if (retryConfig) {\n          errorAction.retryConfig = retryConfig;\n          errorAction.retryCount = fragmentErrors;\n        }\n        return errorAction;\n      };\n      _proto.getLevelSwitchAction = function getLevelSwitchAction(data, levelIndex) {\n        var hls = this.hls;\n        if (levelIndex === null || levelIndex === undefined) {\n          levelIndex = hls.loadLevel;\n        }\n        var level = this.hls.levels[levelIndex];\n        if (level) {\n          level.loadError++;\n          if (hls.autoLevelEnabled) {\n            var _data$frag, _data$context2;\n            // Search for next level to retry\n            var nextLevel = -1;\n            var levels = hls.levels;\n            var fragErrorType = (_data$frag = data.frag) == null ? void 0 : _data$frag.type;\n            var _ref = (_data$context2 = data.context) != null ? _data$context2 : {},\n              playlistErrorType = _ref.type,\n              playlistErrorGroupId = _ref.groupId;\n            for (var i = levels.length; i--;) {\n              var candidate = (i + hls.loadLevel) % levels.length;\n              if (candidate !== hls.loadLevel && levels[candidate].loadError === 0) {\n                var levelCandidate = levels[candidate];\n                // Skip level switch if GAP tag is found in next level at same position\n                if (data.details === ErrorDetails.FRAG_GAP && data.frag) {\n                  var levelDetails = levels[candidate].details;\n                  if (levelDetails) {\n                    var fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);\n                    if (fragCandidate != null && fragCandidate.gap) {\n                      continue;\n                    }\n                  }\n                } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && playlistErrorGroupId === levelCandidate.audioGroupId || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && playlistErrorGroupId === levelCandidate.textGroupId) {\n                  // For audio/subs playlist errors find another group ID or fallthrough to redundant fail-over\n                  continue;\n                } else if (fragErrorType === PlaylistLevelType.AUDIO && level.audioGroupId === levelCandidate.audioGroupId || fragErrorType === PlaylistLevelType.SUBTITLE && level.textGroupId === levelCandidate.textGroupId) {\n                  // For audio/subs frag errors find another group ID or fallthrough to redundant fail-over\n                  continue;\n                }\n                nextLevel = candidate;\n                break;\n              }\n            }\n            if (nextLevel > -1 && hls.loadLevel !== nextLevel) {\n              data.levelRetry = true;\n              this.playlistError = 0;\n              return {\n                action: NetworkErrorAction.SendAlternateToPenaltyBox,\n                flags: ErrorActionFlags.None,\n                nextAutoLevel: nextLevel\n              };\n            }\n          }\n        }\n        // No levels to switch / Manual level selection / Level not found\n        // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level\n        return {\n          action: NetworkErrorAction.SendAlternateToPenaltyBox,\n          flags: ErrorActionFlags.MoveAllAlternatesMatchingHost\n        };\n      };\n      _proto.onErrorOut = function onErrorOut(event, data) {\n        var _data$errorAction;\n        switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {\n          case NetworkErrorAction.DoNothing:\n            break;\n          case NetworkErrorAction.SendAlternateToPenaltyBox:\n            this.sendAlternateToPenaltyBox(data);\n            if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {\n              data.fatal = true;\n            }\n            break;\n        }\n        if (data.fatal) {\n          this.hls.stopLoad();\n          return;\n        }\n      };\n      _proto.sendAlternateToPenaltyBox = function sendAlternateToPenaltyBox(data) {\n        var hls = this.hls;\n        var errorAction = data.errorAction;\n        if (!errorAction) {\n          return;\n        }\n        var flags = errorAction.flags,\n          hdcpLevel = errorAction.hdcpLevel,\n          nextAutoLevel = errorAction.nextAutoLevel;\n        switch (flags) {\n          case ErrorActionFlags.None:\n            this.switchLevel(data, nextAutoLevel);\n            break;\n          case ErrorActionFlags.MoveAllAlternatesMatchingHost:\n            {\n              // Handle Redundant Levels here. Pathway switching is handled by content-steering-controller\n              if (!errorAction.resolved) {\n                errorAction.resolved = this.redundantFailover(data);\n              }\n            }\n            break;\n          case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:\n            if (hdcpLevel) {\n              hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];\n              errorAction.resolved = true;\n            }\n            this.warn(\"Restricting playback to HDCP-LEVEL of \\\"\" + hls.maxHdcpLevel + \"\\\" or lower\");\n            break;\n        }\n        // If not resolved by previous actions try to switch to next level\n        if (!errorAction.resolved) {\n          this.switchLevel(data, nextAutoLevel);\n        }\n      };\n      _proto.switchLevel = function switchLevel(data, levelIndex) {\n        if (levelIndex !== undefined && data.errorAction) {\n          this.warn(\"switching to level \" + levelIndex + \" after \" + data.details);\n          this.hls.nextAutoLevel = levelIndex;\n          data.errorAction.resolved = true;\n          // Stream controller is responsible for this but won't switch on false start\n          this.hls.nextLoadLevel = this.hls.nextAutoLevel;\n        }\n      };\n      _proto.redundantFailover = function redundantFailover(data) {\n        var _this = this;\n        var hls = this.hls,\n          penalizedRenditions = this.penalizedRenditions;\n        var levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n        var level = hls.levels[levelIndex];\n        var redundantLevels = level.url.length;\n        var errorUrlId = data.frag ? data.frag.urlId : level.urlId;\n        if (level.urlId === errorUrlId && (!data.frag || level.details)) {\n          this.penalizeRendition(level, data);\n        }\n        var _loop = function _loop() {\n          var newUrlId = (errorUrlId + i) % redundantLevels;\n          var penalizedRendition = penalizedRenditions[newUrlId];\n          // Check if rendition is penalized and skip if it is a bad fit for failover\n          if (!penalizedRendition || checkExpired(penalizedRendition, data, penalizedRenditions[errorUrlId])) {\n            // delete penalizedRenditions[newUrlId];\n            // Update the url id of all levels so that we stay on the same set of variants when level switching\n            _this.warn(\"Switching to Redundant Stream \" + (newUrlId + 1) + \"/\" + redundantLevels + \": \\\"\" + level.url[newUrlId] + \"\\\" after \" + data.details);\n            _this.playlistError = 0;\n            hls.levels.forEach(function (lv) {\n              lv.urlId = newUrlId;\n            });\n            hls.nextLoadLevel = levelIndex;\n            return {\n              v: true\n            };\n          }\n        };\n        for (var i = 1; i < redundantLevels; i++) {\n          var _ret = _loop();\n          if (_typeof(_ret) === \"object\") return _ret.v;\n        }\n        return false;\n      };\n      _proto.penalizeRendition = function penalizeRendition(level, data) {\n        var penalizedRenditions = this.penalizedRenditions;\n        var penalizedRendition = penalizedRenditions[level.urlId] || {\n          lastErrorPerfMs: 0,\n          errors: [],\n          details: undefined\n        };\n        penalizedRendition.lastErrorPerfMs = performance.now();\n        penalizedRendition.errors.push(data);\n        penalizedRendition.details = level.details;\n        penalizedRenditions[level.urlId] = penalizedRendition;\n      };\n      return ErrorController;\n    }();\n    function checkExpired(penalizedRendition, data, currentPenaltyState) {\n      // Expire penalty for switching back to rendition after RENDITION_PENALTY_DURATION_MS\n      if (performance.now() - penalizedRendition.lastErrorPerfMs > RENDITION_PENALTY_DURATION_MS) {\n        return true;\n      }\n      // Expire penalty on GAP tag error if rendition has no GAP at position (does not cover media tracks)\n      var lastErrorDetails = penalizedRendition.details;\n      if (data.details === ErrorDetails.FRAG_GAP && lastErrorDetails && data.frag) {\n        var position = data.frag.start;\n        var candidateFrag = findFragmentByPTS(null, lastErrorDetails.fragments, position);\n        if (candidateFrag && !candidateFrag.gap) {\n          return true;\n        }\n      }\n      // Expire penalty if there are more errors in currentLevel than in penalizedRendition\n      if (currentPenaltyState && penalizedRendition.errors.length < currentPenaltyState.errors.length) {\n        var lastCandidateError = penalizedRendition.errors[penalizedRendition.errors.length - 1];\n        if (lastErrorDetails && lastCandidateError.frag && data.frag && Math.abs(lastCandidateError.frag.start - data.frag.start) > lastErrorDetails.targetduration * 3) {\n          return true;\n        }\n      }\n      return false;\n    }\n    var BasePlaylistController = /*#__PURE__*/function () {\n      function BasePlaylistController(hls, logPrefix) {\n        this.hls = void 0;\n        this.timer = -1;\n        this.requestScheduled = -1;\n        this.canLoad = false;\n        this.log = void 0;\n        this.warn = void 0;\n        this.log = logger.log.bind(logger, logPrefix + \":\");\n        this.warn = logger.warn.bind(logger, logPrefix + \":\");\n        this.hls = hls;\n      }\n      var _proto = BasePlaylistController.prototype;\n      _proto.destroy = function destroy() {\n        this.clearTimer();\n        // @ts-ignore\n        this.hls = this.log = this.warn = null;\n      };\n      _proto.clearTimer = function clearTimer() {\n        clearTimeout(this.timer);\n        this.timer = -1;\n      };\n      _proto.startLoad = function startLoad() {\n        this.canLoad = true;\n        this.requestScheduled = -1;\n        this.loadPlaylist();\n      };\n      _proto.stopLoad = function stopLoad() {\n        this.canLoad = false;\n        this.clearTimer();\n      };\n      _proto.switchParams = function switchParams(playlistUri, previous) {\n        var renditionReports = previous == null ? void 0 : previous.renditionReports;\n        if (renditionReports) {\n          var foundIndex = -1;\n          for (var i = 0; i < renditionReports.length; i++) {\n            var attr = renditionReports[i];\n            var uri = void 0;\n            try {\n              uri = new self.URL(attr.URI, previous.url).href;\n            } catch (error) {\n              logger.warn(\"Could not construct new URL for Rendition Report: \" + error);\n              uri = attr.URI || '';\n            }\n            // Use exact match. Otherwise, the last partial match, if any, will be used\n            // (Playlist URI includes a query string that the Rendition Report does not)\n            if (uri === playlistUri) {\n              foundIndex = i;\n              break;\n            } else if (uri === playlistUri.substring(0, uri.length)) {\n              foundIndex = i;\n            }\n          }\n          if (foundIndex !== -1) {\n            var _attr = renditionReports[foundIndex];\n            var msn = parseInt(_attr['LAST-MSN']) || (previous == null ? void 0 : previous.lastPartSn);\n            var part = parseInt(_attr['LAST-PART']) || (previous == null ? void 0 : previous.lastPartIndex);\n            if (this.hls.config.lowLatencyMode) {\n              var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n              if (part >= 0 && currentGoal > previous.partTarget) {\n                part += 1;\n              }\n            }\n            return new HlsUrlParameters(msn, part >= 0 ? part : undefined, HlsSkip.No);\n          }\n        }\n      };\n      _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n        if (this.requestScheduled === -1) {\n          this.requestScheduled = self.performance.now();\n        }\n        // Loading is handled by the subclasses\n      };\n\n      _proto.shouldLoadPlaylist = function shouldLoadPlaylist(playlist) {\n        return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);\n      };\n      _proto.shouldReloadPlaylist = function shouldReloadPlaylist(playlist) {\n        return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);\n      };\n      _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {\n        var _this = this;\n        var details = data.details,\n          stats = data.stats;\n\n        // Set last updated date-time\n        var now = self.performance.now();\n        var elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n        details.advancedDateTime = Date.now() - elapsed;\n\n        // if current playlist is a live playlist, arm a timer to reload it\n        if (details.live || previousDetails != null && previousDetails.live) {\n          details.reloaded(previousDetails);\n          if (previousDetails) {\n            this.log(\"live playlist \" + index + \" \" + (details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : 'MISSED'));\n          }\n          // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n          if (previousDetails && details.fragments.length > 0) {\n            mergeDetails(previousDetails, details);\n          }\n          if (!this.canLoad || !details.live) {\n            return;\n          }\n          var deliveryDirectives;\n          var msn = undefined;\n          var part = undefined;\n          if (details.canBlockReload && details.endSN && details.advanced) {\n            // Load level with LL-HLS delivery directives\n            var lowLatencyMode = this.hls.config.lowLatencyMode;\n            var lastPartSn = details.lastPartSn;\n            var endSn = details.endSN;\n            var lastPartIndex = details.lastPartIndex;\n            var hasParts = lastPartIndex !== -1;\n            var lastPart = lastPartSn === endSn;\n            // When low latency mode is disabled, we'll skip part requests once the last part index is found\n            var nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;\n            if (hasParts) {\n              msn = lastPart ? endSn + 1 : lastPartSn;\n              part = lastPart ? nextSnStartIndex : lastPartIndex + 1;\n            } else {\n              msn = endSn + 1;\n            }\n            // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n            // Update directives to obtain the Playlist that has the estimated additional duration of media\n            var lastAdvanced = details.age;\n            var cdnAge = lastAdvanced + details.ageHeader;\n            var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n            if (currentGoal > 0) {\n              if (previousDetails && currentGoal > previousDetails.tuneInGoal) {\n                // If we attempted to get the next or latest playlist update, but currentGoal increased,\n                // then we either can't catchup, or the \"age\" header cannot be trusted.\n                this.warn(\"CDN Tune-in goal increased from: \" + previousDetails.tuneInGoal + \" to: \" + currentGoal + \" with playlist age: \" + details.age);\n                currentGoal = 0;\n              } else {\n                var segments = Math.floor(currentGoal / details.targetduration);\n                msn += segments;\n                if (part !== undefined) {\n                  var parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n                  part += parts;\n                }\n                this.log(\"CDN Tune-in age: \" + details.ageHeader + \"s last advanced \" + lastAdvanced.toFixed(2) + \"s goal: \" + currentGoal + \" skip sn \" + segments + \" to part \" + part);\n              }\n              details.tuneInGoal = currentGoal;\n            }\n            deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n            if (lowLatencyMode || !lastPart) {\n              this.loadPlaylist(deliveryDirectives);\n              return;\n            }\n          } else if (details.canBlockReload) {\n            deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n          }\n          var bufferInfo = this.hls.mainForwardBufferInfo;\n          var position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n          var distanceToLiveEdgeMs = (details.edge - position) * 1000;\n          var reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);\n          if (details.updated && now > this.requestScheduled + reloadInterval) {\n            this.requestScheduled = stats.loading.start;\n          }\n          if (msn !== undefined && details.canBlockReload) {\n            this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);\n          } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now) {\n            this.requestScheduled = now;\n          } else if (this.requestScheduled - now <= 0) {\n            this.requestScheduled += reloadInterval;\n          }\n          var estimatedTimeUntilUpdate = this.requestScheduled - now;\n          estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);\n          this.log(\"reload live playlist \" + index + \" in \" + Math.round(estimatedTimeUntilUpdate) + \" ms\");\n          // this.log(\n          //   `live reload ${details.updated ? 'REFRESHED' : 'MISSED'}\n          // reload in ${estimatedTimeUntilUpdate / 1000}\n          // round trip ${(stats.loading.end - stats.loading.start) / 1000}\n          // diff ${\n          //   (reloadInterval -\n          //     (estimatedTimeUntilUpdate +\n          //       stats.loading.end -\n          //       stats.loading.start)) /\n          //   1000\n          // }\n          // reload interval ${reloadInterval / 1000}\n          // target duration ${details.targetduration}\n          // distance to edge ${distanceToLiveEdgeMs / 1000}`\n          // );\n\n          this.timer = self.setTimeout(function () {\n            return _this.loadPlaylist(deliveryDirectives);\n          }, estimatedTimeUntilUpdate);\n        } else {\n          this.clearTimer();\n        }\n      };\n      _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n        var skip = getSkipValue(details, msn);\n        if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n          msn = previousDeliveryDirectives.msn;\n          part = previousDeliveryDirectives.part;\n          skip = HlsSkip.No;\n        }\n        return new HlsUrlParameters(msn, part, skip);\n      };\n      _proto.checkRetry = function checkRetry(errorEvent) {\n        var _this2 = this;\n        var errorDetails = errorEvent.details;\n        var isTimeout = isTimeoutError(errorEvent);\n        var errorAction = errorEvent.errorAction;\n        var _ref = errorAction || {},\n          action = _ref.action,\n          _ref$retryCount = _ref.retryCount,\n          retryCount = _ref$retryCount === void 0 ? 0 : _ref$retryCount,\n          retryConfig = _ref.retryConfig;\n        var retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);\n        if (retry) {\n          var _errorEvent$context;\n          this.requestScheduled = -1;\n          if (retryCount >= retryConfig.maxNumRetry) {\n            return false;\n          }\n          if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {\n            // The LL-HLS request already timed out so retry immediately\n            this.warn(\"Retrying playlist loading \" + (retryCount + 1) + \"/\" + retryConfig.maxNumRetry + \" after \\\"\" + errorDetails + \"\\\" without delivery-directives\");\n            this.loadPlaylist();\n          } else {\n            var delay = getRetryDelay(retryConfig, retryCount);\n            // Schedule level/track reload\n            this.timer = self.setTimeout(function () {\n              return _this2.loadPlaylist();\n            }, delay);\n            this.warn(\"Retrying playlist loading \" + (retryCount + 1) + \"/\" + retryConfig.maxNumRetry + \" after \\\"\" + errorDetails + \"\\\" in \" + delay + \"ms\");\n          }\n          // `levelRetry = true` used to inform other controllers that a retry is happening\n          errorEvent.levelRetry = true;\n          errorAction.resolved = true;\n        }\n        return retry;\n      };\n      return BasePlaylistController;\n    }();\n    var chromeOrFirefox;\n    var LevelController = /*#__PURE__*/function (_BasePlaylistControll) {\n      _inheritsLoose(LevelController, _BasePlaylistControll);\n      function LevelController(hls, contentSteeringController) {\n        var _this;\n        _this = _BasePlaylistControll.call(this, hls, '[level-controller]') || this;\n        _this._levels = [];\n        _this._firstLevel = -1;\n        _this._startLevel = void 0;\n        _this.currentLevel = null;\n        _this.currentLevelIndex = -1;\n        _this.manualLevelIndex = -1;\n        _this.steering = void 0;\n        _this.onParsedComplete = void 0;\n        _this.steering = contentSteeringController;\n        _this._registerListeners();\n        return _this;\n      }\n      var _proto = LevelController.prototype;\n      _proto._registerListeners = function _registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.on(Events.ERROR, this.onError, this);\n      };\n      _proto._unregisterListeners = function _unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.off(Events.ERROR, this.onError, this);\n      };\n      _proto.destroy = function destroy() {\n        this._unregisterListeners();\n        this.steering = null;\n        this.resetLevels();\n        _BasePlaylistControll.prototype.destroy.call(this);\n      };\n      _proto.startLoad = function startLoad() {\n        var levels = this._levels;\n\n        // clean up live level details to force reload them, and reset load errors\n        levels.forEach(function (level) {\n          level.loadError = 0;\n          level.fragmentError = 0;\n        });\n        _BasePlaylistControll.prototype.startLoad.call(this);\n      };\n      _proto.resetLevels = function resetLevels() {\n        this._startLevel = undefined;\n        this.manualLevelIndex = -1;\n        this.currentLevelIndex = -1;\n        this.currentLevel = null;\n        this._levels = [];\n      };\n      _proto.onManifestLoading = function onManifestLoading(event, data) {\n        this.resetLevels();\n      };\n      _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n        var levels = [];\n        var levelSet = {};\n        var levelFromSet;\n\n        // regroup redundant levels together\n        data.levels.forEach(function (levelParsed) {\n          var _levelParsed$audioCod;\n          var attributes = levelParsed.attrs;\n\n          // erase audio codec info if browser does not support mp4a.40.34.\n          // demuxer will autodetect codec and fallback to mpeg/audio\n          if (((_levelParsed$audioCod = levelParsed.audioCodec) == null ? void 0 : _levelParsed$audioCod.indexOf('mp4a.40.34')) !== -1) {\n            chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));\n            if (chromeOrFirefox) {\n              levelParsed.audioCodec = undefined;\n            }\n          }\n          var AUDIO = attributes.AUDIO,\n            CODECS = attributes.CODECS,\n            FRAMERATE = attributes['FRAME-RATE'];\n          attributes['PATHWAY-ID'];\n          var RESOLUTION = attributes.RESOLUTION,\n            SUBTITLES = attributes.SUBTITLES;\n          var contentSteeringPrefix = '';\n          var levelKey = \"\" + contentSteeringPrefix + levelParsed.bitrate + \"-\" + RESOLUTION + \"-\" + FRAMERATE + \"-\" + CODECS;\n          levelFromSet = levelSet[levelKey];\n          if (!levelFromSet) {\n            levelFromSet = new Level(levelParsed);\n            levelSet[levelKey] = levelFromSet;\n            levels.push(levelFromSet);\n          } else {\n            levelFromSet.addFallback(levelParsed);\n          }\n          addGroupId(levelFromSet, 'audio', AUDIO);\n          addGroupId(levelFromSet, 'text', SUBTITLES);\n        });\n        this.filterAndSortMediaOptions(levels, data);\n      };\n      _proto.filterAndSortMediaOptions = function filterAndSortMediaOptions(unfilteredLevels, data) {\n        var _this2 = this;\n        var audioTracks = [];\n        var subtitleTracks = [];\n        var resolutionFound = false;\n        var videoCodecFound = false;\n        var audioCodecFound = false;\n\n        // only keep levels with supported audio/video codecs\n        var levels = unfilteredLevels.filter(function (_ref) {\n          var audioCodec = _ref.audioCodec,\n            videoCodec = _ref.videoCodec,\n            width = _ref.width,\n            height = _ref.height,\n            unknownCodecs = _ref.unknownCodecs;\n          resolutionFound || (resolutionFound = !!(width && height));\n          videoCodecFound || (videoCodecFound = !!videoCodec);\n          audioCodecFound || (audioCodecFound = !!audioCodec);\n          return !(unknownCodecs != null && unknownCodecs.length) && (!audioCodec || isCodecSupportedInMp4(audioCodec, 'audio')) && (!videoCodec || isCodecSupportedInMp4(videoCodec, 'video'));\n        });\n\n        // remove audio-only level if we also have levels with video codecs or RESOLUTION signalled\n        if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n          levels = levels.filter(function (_ref2) {\n            var videoCodec = _ref2.videoCodec,\n              width = _ref2.width,\n              height = _ref2.height;\n            return !!videoCodec || !!(width && height);\n          });\n        }\n        if (levels.length === 0) {\n          // Dispatch error after MANIFEST_LOADED is done propagating\n          Promise.resolve().then(function () {\n            if (_this2.hls) {\n              var error = new Error('no level with compatible codecs found in manifest');\n              _this2.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n                fatal: true,\n                url: data.url,\n                error: error,\n                reason: error.message\n              });\n            }\n          });\n          return;\n        }\n        if (data.audioTracks) {\n          audioTracks = data.audioTracks.filter(function (track) {\n            return !track.audioCodec || isCodecSupportedInMp4(track.audioCodec, 'audio');\n          });\n          // Assign ids after filtering as array indices by group-id\n          assignTrackIdsByGroup(audioTracks);\n        }\n        if (data.subtitles) {\n          subtitleTracks = data.subtitles;\n          assignTrackIdsByGroup(subtitleTracks);\n        }\n        // start bitrate is the first bitrate of the manifest\n        var unsortedLevels = levels.slice(0);\n        // sort levels from lowest to highest\n        levels.sort(function (a, b) {\n          if (a.attrs['HDCP-LEVEL'] !== b.attrs['HDCP-LEVEL']) {\n            return (a.attrs['HDCP-LEVEL'] || '') > (b.attrs['HDCP-LEVEL'] || '') ? 1 : -1;\n          }\n          if (a.bitrate !== b.bitrate) {\n            return a.bitrate - b.bitrate;\n          }\n          if (a.attrs['FRAME-RATE'] !== b.attrs['FRAME-RATE']) {\n            return a.attrs.decimalFloatingPoint('FRAME-RATE') - b.attrs.decimalFloatingPoint('FRAME-RATE');\n          }\n          if (a.attrs.SCORE !== b.attrs.SCORE) {\n            return a.attrs.decimalFloatingPoint('SCORE') - b.attrs.decimalFloatingPoint('SCORE');\n          }\n          if (resolutionFound && a.height !== b.height) {\n            return a.height - b.height;\n          }\n          return 0;\n        });\n        var firstLevelInPlaylist = unsortedLevels[0];\n        if (this.steering) {\n          levels = this.steering.filterParsedLevels(levels);\n          if (levels.length !== unsortedLevels.length) {\n            for (var i = 0; i < unsortedLevels.length; i++) {\n              if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {\n                firstLevelInPlaylist = unsortedLevels[i];\n                break;\n              }\n            }\n          }\n        }\n        this._levels = levels;\n\n        // find index of first level in sorted levels\n        for (var _i = 0; _i < levels.length; _i++) {\n          if (levels[_i] === firstLevelInPlaylist) {\n            this._firstLevel = _i;\n            this.log(\"manifest loaded, \" + levels.length + \" level(s) found, first bitrate: \" + firstLevelInPlaylist.bitrate);\n            break;\n          }\n        }\n\n        // Audio is only alternate if manifest include a URI along with the audio group tag,\n        // and this is not an audio-only stream where levels contain audio-only\n        var audioOnly = audioCodecFound && !videoCodecFound;\n        var edata = {\n          levels: levels,\n          audioTracks: audioTracks,\n          subtitleTracks: subtitleTracks,\n          sessionData: data.sessionData,\n          sessionKeys: data.sessionKeys,\n          firstLevel: this._firstLevel,\n          stats: data.stats,\n          audio: audioCodecFound,\n          video: videoCodecFound,\n          altAudio: !audioOnly && audioTracks.some(function (t) {\n            return !!t.url;\n          })\n        };\n        this.hls.trigger(Events.MANIFEST_PARSED, edata);\n\n        // Initiate loading after all controllers have received MANIFEST_PARSED\n        if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {\n          this.hls.startLoad(this.hls.config.startPosition);\n        }\n      };\n      _proto.onError = function onError(event, data) {\n        if (data.fatal || !data.context) {\n          return;\n        }\n        if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {\n          this.checkRetry(data);\n        }\n      }\n\n      // reset errors on the successful load of a fragment\n      ;\n\n      _proto.onFragLoaded = function onFragLoaded(event, _ref3) {\n        var frag = _ref3.frag;\n        if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {\n          var level = this._levels[frag.level];\n          if (level !== undefined) {\n            level.loadError = 0;\n          }\n        }\n      };\n      _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n        var _data$deliveryDirecti2;\n        var level = data.level,\n          details = data.details;\n        var curLevel = this._levels[level];\n        if (!curLevel) {\n          var _data$deliveryDirecti;\n          this.warn(\"Invalid level index \" + level);\n          if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {\n            details.deltaUpdateFailed = true;\n          }\n          return;\n        }\n\n        // only process level loaded events matching with expected level\n        if (level === this.currentLevelIndex) {\n          // reset level load error counter on successful level loaded only if there is no issues with fragments\n          if (curLevel.fragmentError === 0) {\n            curLevel.loadError = 0;\n          }\n          this.playlistLoaded(level, data, curLevel.details);\n        } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {\n          // received a delta playlist update that cannot be merged\n          details.deltaUpdateFailed = true;\n        }\n      };\n      _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {\n        var currentLevel = this.currentLevel;\n        if (!currentLevel) {\n          return;\n        }\n        var audioGroupId = this.hls.audioTracks[data.id].groupId;\n        if (currentLevel.audioGroupIds && currentLevel.audioGroupId !== audioGroupId) {\n          var urlId = -1;\n          for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {\n            if (currentLevel.audioGroupIds[i] === audioGroupId) {\n              urlId = i;\n              break;\n            }\n          }\n          if (urlId !== -1 && urlId !== currentLevel.urlId) {\n            currentLevel.urlId = urlId;\n            if (this.canLoad) {\n              this.startLoad();\n            }\n          }\n        }\n      };\n      _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n        _BasePlaylistControll.prototype.loadPlaylist.call(this);\n        var currentLevelIndex = this.currentLevelIndex;\n        var currentLevel = this.currentLevel;\n        if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {\n          var id = currentLevel.urlId;\n          var url = currentLevel.uri;\n          if (hlsUrlParameters) {\n            try {\n              url = hlsUrlParameters.addDirectives(url);\n            } catch (error) {\n              this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n            }\n          }\n          var pathwayId = currentLevel.attrs['PATHWAY-ID'];\n          this.log(\"Loading level index \" + currentLevelIndex + ((hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : '') + \" with\" + (pathwayId ? ' Pathway ' + pathwayId : '') + \" URI \" + (id + 1) + \"/\" + currentLevel.url.length + \" \" + url);\n\n          // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);\n          // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);\n          this.clearTimer();\n          this.hls.trigger(Events.LEVEL_LOADING, {\n            url: url,\n            level: currentLevelIndex,\n            id: id,\n            deliveryDirectives: hlsUrlParameters || null\n          });\n        }\n      };\n      _proto.removeLevel = function removeLevel(levelIndex, urlId) {\n        var _this3 = this;\n        var filterLevelAndGroupByIdIndex = function filterLevelAndGroupByIdIndex(url, id) {\n          return id !== urlId;\n        };\n        var levels = this._levels.filter(function (level, index) {\n          if (index !== levelIndex) {\n            return true;\n          }\n          if (level.url.length > 1 && urlId !== undefined) {\n            level.url = level.url.filter(filterLevelAndGroupByIdIndex);\n            if (level.audioGroupIds) {\n              level.audioGroupIds = level.audioGroupIds.filter(filterLevelAndGroupByIdIndex);\n            }\n            if (level.textGroupIds) {\n              level.textGroupIds = level.textGroupIds.filter(filterLevelAndGroupByIdIndex);\n            }\n            level.urlId = 0;\n            return true;\n          }\n          if (_this3.steering) {\n            _this3.steering.removeLevel(level);\n          }\n          return false;\n        });\n        this.hls.trigger(Events.LEVELS_UPDATED, {\n          levels: levels\n        });\n      };\n      _proto.onLevelsUpdated = function onLevelsUpdated(event, _ref4) {\n        var levels = _ref4.levels;\n        levels.forEach(function (level, index) {\n          var details = level.details;\n          if (details != null && details.fragments) {\n            details.fragments.forEach(function (fragment) {\n              fragment.level = index;\n            });\n          }\n        });\n        this._levels = levels;\n      };\n      _createClass(LevelController, [{\n        key: \"levels\",\n        get: function get() {\n          if (this._levels.length === 0) {\n            return null;\n          }\n          return this._levels;\n        }\n      }, {\n        key: \"level\",\n        get: function get() {\n          return this.currentLevelIndex;\n        },\n        set: function set(newLevel) {\n          var levels = this._levels;\n          if (levels.length === 0) {\n            return;\n          }\n          // check if level idx is valid\n          if (newLevel < 0 || newLevel >= levels.length) {\n            // invalid level id given, trigger error\n            var error = new Error('invalid level idx');\n            var fatal = newLevel < 0;\n            this.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.OTHER_ERROR,\n              details: ErrorDetails.LEVEL_SWITCH_ERROR,\n              level: newLevel,\n              fatal: fatal,\n              error: error,\n              reason: error.message\n            });\n            if (fatal) {\n              return;\n            }\n            newLevel = Math.min(newLevel, levels.length - 1);\n          }\n          var lastLevelIndex = this.currentLevelIndex;\n          var lastLevel = this.currentLevel;\n          var lastPathwayId = lastLevel ? lastLevel.attrs['PATHWAY-ID'] : undefined;\n          var level = levels[newLevel];\n          var pathwayId = level.attrs['PATHWAY-ID'];\n          this.currentLevelIndex = newLevel;\n          this.currentLevel = level;\n          if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {\n            return;\n          }\n          this.log(\"Switching to level \" + newLevel + (pathwayId ? ' with Pathway ' + pathwayId : '') + \" from level \" + lastLevelIndex + (lastPathwayId ? ' with Pathway ' + lastPathwayId : ''));\n          var levelSwitchingData = _extends({}, level, {\n            level: newLevel,\n            maxBitrate: level.maxBitrate,\n            attrs: level.attrs,\n            uri: level.uri,\n            urlId: level.urlId\n          });\n          // @ts-ignore\n          delete levelSwitchingData._attrs;\n          // @ts-ignore\n          delete levelSwitchingData._urlId;\n          this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);\n          // check if we need to load playlist for this level\n          var levelDetails = level.details;\n          if (!levelDetails || levelDetails.live) {\n            // level not retrieved yet, or live playlist we need to (re)load it\n            var hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details);\n            this.loadPlaylist(hlsUrlParameters);\n          }\n        }\n      }, {\n        key: \"manualLevel\",\n        get: function get() {\n          return this.manualLevelIndex;\n        },\n        set: function set(newLevel) {\n          this.manualLevelIndex = newLevel;\n          if (this._startLevel === undefined) {\n            this._startLevel = newLevel;\n          }\n          if (newLevel !== -1) {\n            this.level = newLevel;\n          }\n        }\n      }, {\n        key: \"firstLevel\",\n        get: function get() {\n          return this._firstLevel;\n        },\n        set: function set(newLevel) {\n          this._firstLevel = newLevel;\n        }\n      }, {\n        key: \"startLevel\",\n        get: function get() {\n          // hls.startLevel takes precedence over config.startLevel\n          // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)\n          if (this._startLevel === undefined) {\n            var configStartLevel = this.hls.config.startLevel;\n            if (configStartLevel !== undefined) {\n              return configStartLevel;\n            } else {\n              return this._firstLevel;\n            }\n          } else {\n            return this._startLevel;\n          }\n        },\n        set: function set(newLevel) {\n          this._startLevel = newLevel;\n        }\n      }, {\n        key: \"nextLoadLevel\",\n        get: function get() {\n          if (this.manualLevelIndex !== -1) {\n            return this.manualLevelIndex;\n          } else {\n            return this.hls.nextAutoLevel;\n          }\n        },\n        set: function set(nextLevel) {\n          this.level = nextLevel;\n          if (this.manualLevelIndex === -1) {\n            this.hls.nextAutoLevel = nextLevel;\n          }\n        }\n      }]);\n      return LevelController;\n    }(BasePlaylistController);\n    function addGroupId(level, type, id) {\n      if (!id) {\n        return;\n      }\n      if (type === 'audio') {\n        if (!level.audioGroupIds) {\n          level.audioGroupIds = [];\n        }\n        level.audioGroupIds[level.url.length - 1] = id;\n      } else if (type === 'text') {\n        if (!level.textGroupIds) {\n          level.textGroupIds = [];\n        }\n        level.textGroupIds[level.url.length - 1] = id;\n      }\n    }\n    function assignTrackIdsByGroup(tracks) {\n      var groups = {};\n      tracks.forEach(function (track) {\n        var groupId = track.groupId || '';\n        track.id = groups[groupId] = groups[groupId] || 0;\n        groups[groupId]++;\n      });\n    }\n    var FragmentState = {\n      NOT_LOADED: \"NOT_LOADED\",\n      APPENDING: \"APPENDING\",\n      PARTIAL: \"PARTIAL\",\n      OK: \"OK\"\n    };\n    var FragmentTracker = /*#__PURE__*/function () {\n      function FragmentTracker(hls) {\n        this.activePartLists = Object.create(null);\n        this.endListFragments = Object.create(null);\n        this.fragments = Object.create(null);\n        this.timeRanges = Object.create(null);\n        this.bufferPadding = 0.2;\n        this.hls = void 0;\n        this.hasGaps = false;\n        this.hls = hls;\n        this._registerListeners();\n      }\n      var _proto = FragmentTracker.prototype;\n      _proto._registerListeners = function _registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n      };\n      _proto._unregisterListeners = function _unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n      };\n      _proto.destroy = function destroy() {\n        this._unregisterListeners();\n        // @ts-ignore\n        this.fragments =\n        // @ts-ignore\n        this.activePartLists =\n        // @ts-ignore\n        this.endListFragments = this.timeRanges = null;\n      }\n\n      /**\n       * Return a Fragment or Part with an appended range that matches the position and levelType\n       * Otherwise, return null\n       */;\n      _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {\n        var activeParts = this.activePartLists[levelType];\n        if (activeParts) {\n          for (var i = activeParts.length; i--;) {\n            var activePart = activeParts[i];\n            if (!activePart) {\n              break;\n            }\n            var appendedPTS = activePart.end;\n            if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {\n              return activePart;\n            }\n          }\n        }\n        return this.getBufferedFrag(position, levelType);\n      }\n\n      /**\n       * Return a buffered Fragment that matches the position and levelType.\n       * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n       * If not found any Fragment, return null\n       */;\n      _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {\n        var fragments = this.fragments;\n        var keys = Object.keys(fragments);\n        for (var i = keys.length; i--;) {\n          var fragmentEntity = fragments[keys[i]];\n          if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {\n            var frag = fragmentEntity.body;\n            if (frag.start <= position && position <= frag.end) {\n              return frag;\n            }\n          }\n        }\n        return null;\n      }\n\n      /**\n       * Partial fragments effected by coded frame eviction will be removed\n       * The browser will unload parts of the buffer to free up memory for new buffer data\n       * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n       */;\n      _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {\n        var _this = this;\n        if (this.timeRanges) {\n          this.timeRanges[elementaryStream] = timeRange;\n        }\n        // Check if any flagged fragments have been unloaded\n        // excluding anything newer than appendedPartSn\n        var appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;\n        Object.keys(this.fragments).forEach(function (key) {\n          var fragmentEntity = _this.fragments[key];\n          if (!fragmentEntity) {\n            return;\n          }\n          if (appendedPartSn >= fragmentEntity.body.sn) {\n            return;\n          }\n          if (!fragmentEntity.buffered && !fragmentEntity.loaded) {\n            if (fragmentEntity.body.type === playlistType) {\n              _this.removeFragment(fragmentEntity.body);\n            }\n            return;\n          }\n          var esData = fragmentEntity.range[elementaryStream];\n          if (!esData) {\n            return;\n          }\n          esData.time.some(function (time) {\n            var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n            if (isNotBuffered) {\n              // Unregister partial fragment as it needs to load again to be reused\n              _this.removeFragment(fragmentEntity.body);\n            }\n            return isNotBuffered;\n          });\n        });\n      }\n\n      /**\n       * Checks if the fragment passed in is loaded in the buffer properly\n       * Partially loaded fragments will be registered as a partial fragment\n       */;\n      _proto.detectPartialFragments = function detectPartialFragments(data) {\n        var _this2 = this;\n        var timeRanges = this.timeRanges;\n        var frag = data.frag,\n          part = data.part;\n        if (!timeRanges || frag.sn === 'initSegment') {\n          return;\n        }\n        var fragKey = getFragmentKey(frag);\n        var fragmentEntity = this.fragments[fragKey];\n        if (!fragmentEntity) {\n          return;\n        }\n        var isFragHint = !frag.relurl;\n        Object.keys(timeRanges).forEach(function (elementaryStream) {\n          var streamInfo = frag.elementaryStreams[elementaryStream];\n          if (!streamInfo) {\n            return;\n          }\n          var timeRange = timeRanges[elementaryStream];\n          var partial = isFragHint || streamInfo.partial === true;\n          fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, part, partial, timeRange);\n        });\n        fragmentEntity.loaded = null;\n        if (Object.keys(fragmentEntity.range).length) {\n          fragmentEntity.buffered = true;\n          if (fragmentEntity.body.endList) {\n            this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n          }\n          if (!isPartial(fragmentEntity)) {\n            // Remove older fragment parts from lookup after frag is tracked as buffered\n            this.removeParts(frag.sn - 1, frag.type);\n          }\n        } else {\n          // remove fragment if nothing was appended\n          this.removeFragment(fragmentEntity.body);\n        }\n      };\n      _proto.removeParts = function removeParts(snToKeep, levelType) {\n        var activeParts = this.activePartLists[levelType];\n        if (!activeParts) {\n          return;\n        }\n        this.activePartLists[levelType] = activeParts.filter(function (part) {\n          return part.fragment.sn >= snToKeep;\n        });\n      };\n      _proto.fragBuffered = function fragBuffered(frag, force) {\n        var fragKey = getFragmentKey(frag);\n        var fragmentEntity = this.fragments[fragKey];\n        if (!fragmentEntity && force) {\n          fragmentEntity = this.fragments[fragKey] = {\n            body: frag,\n            appendedPTS: null,\n            loaded: null,\n            buffered: false,\n            range: Object.create(null)\n          };\n          if (frag.gap) {\n            this.hasGaps = true;\n          }\n        }\n        if (fragmentEntity) {\n          fragmentEntity.loaded = null;\n          fragmentEntity.buffered = true;\n        }\n      };\n      _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {\n        var buffered = {\n          time: [],\n          partial: partial\n        };\n        var startPTS = fragment.start;\n        var endPTS = fragment.end;\n        var minEndPTS = fragment.minEndPTS || endPTS;\n        var maxStartPTS = fragment.maxStartPTS || startPTS;\n        for (var i = 0; i < timeRange.length; i++) {\n          var startTime = timeRange.start(i) - this.bufferPadding;\n          var endTime = timeRange.end(i) + this.bufferPadding;\n          if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n            // Fragment is entirely contained in buffer\n            // No need to check the other timeRange times since it's completely playable\n            buffered.time.push({\n              startPTS: Math.max(startPTS, timeRange.start(i)),\n              endPTS: Math.min(endPTS, timeRange.end(i))\n            });\n            break;\n          } else if (startPTS < endTime && endPTS > startTime) {\n            buffered.partial = true;\n            // Check for intersection with buffer\n            // Get playable sections of the fragment\n            buffered.time.push({\n              startPTS: Math.max(startPTS, timeRange.start(i)),\n              endPTS: Math.min(endPTS, timeRange.end(i))\n            });\n          } else if (endPTS <= startTime) {\n            // No need to check the rest of the timeRange as it is in order\n            break;\n          }\n        }\n        return buffered;\n      }\n\n      /**\n       * Gets the partial fragment for a certain time\n       */;\n      _proto.getPartialFragment = function getPartialFragment(time) {\n        var bestFragment = null;\n        var timePadding;\n        var startTime;\n        var endTime;\n        var bestOverlap = 0;\n        var bufferPadding = this.bufferPadding,\n          fragments = this.fragments;\n        Object.keys(fragments).forEach(function (key) {\n          var fragmentEntity = fragments[key];\n          if (!fragmentEntity) {\n            return;\n          }\n          if (isPartial(fragmentEntity)) {\n            startTime = fragmentEntity.body.start - bufferPadding;\n            endTime = fragmentEntity.body.end + bufferPadding;\n            if (time >= startTime && time <= endTime) {\n              // Use the fragment that has the most padding from start and end time\n              timePadding = Math.min(time - startTime, endTime - time);\n              if (bestOverlap <= timePadding) {\n                bestFragment = fragmentEntity.body;\n                bestOverlap = timePadding;\n              }\n            }\n          }\n        });\n        return bestFragment;\n      };\n      _proto.isEndListAppended = function isEndListAppended(type) {\n        var lastFragmentEntity = this.endListFragments[type];\n        return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n      };\n      _proto.getState = function getState(fragment) {\n        var fragKey = getFragmentKey(fragment);\n        var fragmentEntity = this.fragments[fragKey];\n        if (fragmentEntity) {\n          if (!fragmentEntity.buffered) {\n            return FragmentState.APPENDING;\n          } else if (isPartial(fragmentEntity)) {\n            return FragmentState.PARTIAL;\n          } else {\n            return FragmentState.OK;\n          }\n        }\n        return FragmentState.NOT_LOADED;\n      };\n      _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {\n        var startTime;\n        var endTime;\n        for (var i = 0; i < timeRange.length; i++) {\n          startTime = timeRange.start(i) - this.bufferPadding;\n          endTime = timeRange.end(i) + this.bufferPadding;\n          if (startPTS >= startTime && endPTS <= endTime) {\n            return true;\n          }\n          if (endPTS <= startTime) {\n            // No need to check the rest of the timeRange as it is in order\n            return false;\n          }\n        }\n        return false;\n      };\n      _proto.onFragLoaded = function onFragLoaded(event, data) {\n        var frag = data.frag,\n          part = data.part;\n        // don't track initsegment (for which sn is not a number)\n        // don't track frags used for bitrateTest, they're irrelevant.\n        if (frag.sn === 'initSegment' || frag.bitrateTest) {\n          return;\n        }\n\n        // Fragment entity `loaded` FragLoadedData is null when loading parts\n        var loaded = part ? null : data;\n        var fragKey = getFragmentKey(frag);\n        this.fragments[fragKey] = {\n          body: frag,\n          appendedPTS: null,\n          loaded: loaded,\n          buffered: false,\n          range: Object.create(null)\n        };\n      };\n      _proto.onBufferAppended = function onBufferAppended(event, data) {\n        var _this3 = this;\n        var frag = data.frag,\n          part = data.part,\n          timeRanges = data.timeRanges;\n        if (frag.sn === 'initSegment') {\n          return;\n        }\n        var playlistType = frag.type;\n        if (part) {\n          var activeParts = this.activePartLists[playlistType];\n          if (!activeParts) {\n            this.activePartLists[playlistType] = activeParts = [];\n          }\n          activeParts.push(part);\n        }\n        // Store the latest timeRanges loaded in the buffer\n        this.timeRanges = timeRanges;\n        Object.keys(timeRanges).forEach(function (elementaryStream) {\n          var timeRange = timeRanges[elementaryStream];\n          _this3.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);\n        });\n      };\n      _proto.onFragBuffered = function onFragBuffered(event, data) {\n        this.detectPartialFragments(data);\n      };\n      _proto.hasFragment = function hasFragment(fragment) {\n        var fragKey = getFragmentKey(fragment);\n        return !!this.fragments[fragKey];\n      };\n      _proto.hasParts = function hasParts(type) {\n        var _this$activePartLists;\n        return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);\n      };\n      _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {\n        var _this4 = this;\n        if (withGapOnly && !this.hasGaps) {\n          return;\n        }\n        Object.keys(this.fragments).forEach(function (key) {\n          var fragmentEntity = _this4.fragments[key];\n          if (!fragmentEntity) {\n            return;\n          }\n          var frag = fragmentEntity.body;\n          if (frag.type !== playlistType || withGapOnly && !frag.gap) {\n            return;\n          }\n          if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {\n            _this4.removeFragment(frag);\n          }\n        });\n      };\n      _proto.removeFragment = function removeFragment(fragment) {\n        var fragKey = getFragmentKey(fragment);\n        fragment.stats.loaded = 0;\n        fragment.clearElementaryStreamInfo();\n        var activeParts = this.activePartLists[fragment.type];\n        if (activeParts) {\n          var snToRemove = fragment.sn;\n          this.activePartLists[fragment.type] = activeParts.filter(function (part) {\n            return part.fragment.sn !== snToRemove;\n          });\n        }\n        delete this.fragments[fragKey];\n        if (fragment.endList) {\n          delete this.endListFragments[fragment.type];\n        }\n      };\n      _proto.removeAllFragments = function removeAllFragments() {\n        this.fragments = Object.create(null);\n        this.endListFragments = Object.create(null);\n        this.activePartLists = Object.create(null);\n        this.hasGaps = false;\n      };\n      return FragmentTracker;\n    }();\n    function isPartial(fragmentEntity) {\n      var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;\n      return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));\n    }\n    function getFragmentKey(fragment) {\n      return fragment.type + \"_\" + fragment.level + \"_\" + fragment.urlId + \"_\" + fragment.sn;\n    }\n    var MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\n    var FragmentLoader = /*#__PURE__*/function () {\n      function FragmentLoader(config) {\n        this.config = void 0;\n        this.loader = null;\n        this.partLoadTimeout = -1;\n        this.config = config;\n      }\n      var _proto = FragmentLoader.prototype;\n      _proto.destroy = function destroy() {\n        if (this.loader) {\n          this.loader.destroy();\n          this.loader = null;\n        }\n      };\n      _proto.abort = function abort() {\n        if (this.loader) {\n          // Abort the loader for current fragment. Only one may load at any given time\n          this.loader.abort();\n        }\n      };\n      _proto.load = function load(frag, _onProgress) {\n        var _this = this;\n        var url = frag.url;\n        if (!url) {\n          return Promise.reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag: frag,\n            error: new Error(\"Fragment does not have a \" + (url ? 'part list' : 'url')),\n            networkDetails: null\n          }));\n        }\n        this.abort();\n        var config = this.config;\n        var FragmentILoader = config.fLoader;\n        var DefaultILoader = config.loader;\n        return new Promise(function (resolve, reject) {\n          if (_this.loader) {\n            _this.loader.destroy();\n          }\n          if (frag.gap) {\n            reject(createGapLoadError(frag));\n            return;\n          }\n          var loader = _this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n          var loaderContext = createLoaderContext(frag);\n          var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n          var loaderConfig = {\n            loadPolicy: loadPolicy,\n            timeout: loadPolicy.maxLoadTimeMs,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: 0,\n            highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE\n          };\n          // Assign frag stats to the loader's stats reference\n          frag.stats = loader.stats;\n          loader.load(loaderContext, loaderConfig, {\n            onSuccess: function onSuccess(response, stats, context, networkDetails) {\n              _this.resetLoader(frag, loader);\n              var payload = response.data;\n              if (context.resetIV && frag.decryptdata) {\n                frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n                payload = payload.slice(16);\n              }\n              resolve({\n                frag: frag,\n                part: null,\n                payload: payload,\n                networkDetails: networkDetails\n              });\n            },\n            onError: function onError(response, context, networkDetails, stats) {\n              _this.resetLoader(frag, loader);\n              reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.FRAG_LOAD_ERROR,\n                fatal: false,\n                frag: frag,\n                response: _objectSpread2({\n                  url: url,\n                  data: undefined\n                }, response),\n                error: new Error(\"HTTP Error \" + response.code + \" \" + response.text),\n                networkDetails: networkDetails,\n                stats: stats\n              }));\n            },\n            onAbort: function onAbort(stats, context, networkDetails) {\n              _this.resetLoader(frag, loader);\n              reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.INTERNAL_ABORTED,\n                fatal: false,\n                frag: frag,\n                error: new Error('Aborted'),\n                networkDetails: networkDetails,\n                stats: stats\n              }));\n            },\n            onTimeout: function onTimeout(stats, context, networkDetails) {\n              _this.resetLoader(frag, loader);\n              reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n                fatal: false,\n                frag: frag,\n                error: new Error(\"Timeout after \" + loaderConfig.timeout + \"ms\"),\n                networkDetails: networkDetails,\n                stats: stats\n              }));\n            },\n            onProgress: function onProgress(stats, context, data, networkDetails) {\n              if (_onProgress) {\n                _onProgress({\n                  frag: frag,\n                  part: null,\n                  payload: data,\n                  networkDetails: networkDetails\n                });\n              }\n            }\n          });\n        });\n      };\n      _proto.loadPart = function loadPart(frag, part, onProgress) {\n        var _this2 = this;\n        this.abort();\n        var config = this.config;\n        var FragmentILoader = config.fLoader;\n        var DefaultILoader = config.loader;\n        return new Promise(function (resolve, reject) {\n          if (_this2.loader) {\n            _this2.loader.destroy();\n          }\n          if (frag.gap || part.gap) {\n            reject(createGapLoadError(frag, part));\n            return;\n          }\n          var loader = _this2.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n          var loaderContext = createLoaderContext(frag, part);\n          // Should we define another load policy for parts?\n          var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n          var loaderConfig = {\n            loadPolicy: loadPolicy,\n            timeout: loadPolicy.maxLoadTimeMs,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: 0,\n            highWaterMark: MIN_CHUNK_SIZE\n          };\n          // Assign part stats to the loader's stats reference\n          part.stats = loader.stats;\n          loader.load(loaderContext, loaderConfig, {\n            onSuccess: function onSuccess(response, stats, context, networkDetails) {\n              _this2.resetLoader(frag, loader);\n              _this2.updateStatsFromPart(frag, part);\n              var partLoadedData = {\n                frag: frag,\n                part: part,\n                payload: response.data,\n                networkDetails: networkDetails\n              };\n              onProgress(partLoadedData);\n              resolve(partLoadedData);\n            },\n            onError: function onError(response, context, networkDetails, stats) {\n              _this2.resetLoader(frag, loader);\n              reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.FRAG_LOAD_ERROR,\n                fatal: false,\n                frag: frag,\n                part: part,\n                response: _objectSpread2({\n                  url: loaderContext.url,\n                  data: undefined\n                }, response),\n                error: new Error(\"HTTP Error \" + response.code + \" \" + response.text),\n                networkDetails: networkDetails,\n                stats: stats\n              }));\n            },\n            onAbort: function onAbort(stats, context, networkDetails) {\n              frag.stats.aborted = part.stats.aborted;\n              _this2.resetLoader(frag, loader);\n              reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.INTERNAL_ABORTED,\n                fatal: false,\n                frag: frag,\n                part: part,\n                error: new Error('Aborted'),\n                networkDetails: networkDetails,\n                stats: stats\n              }));\n            },\n            onTimeout: function onTimeout(stats, context, networkDetails) {\n              _this2.resetLoader(frag, loader);\n              reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n                fatal: false,\n                frag: frag,\n                part: part,\n                error: new Error(\"Timeout after \" + loaderConfig.timeout + \"ms\"),\n                networkDetails: networkDetails,\n                stats: stats\n              }));\n            }\n          });\n        });\n      };\n      _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {\n        var fragStats = frag.stats;\n        var partStats = part.stats;\n        var partTotal = partStats.total;\n        fragStats.loaded += partStats.loaded;\n        if (partTotal) {\n          var estTotalParts = Math.round(frag.duration / part.duration);\n          var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n          var estRemainingParts = estTotalParts - estLoadedParts;\n          var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n          fragStats.total = fragStats.loaded + estRemainingBytes;\n        } else {\n          fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n        }\n        var fragLoading = fragStats.loading;\n        var partLoading = partStats.loading;\n        if (fragLoading.start) {\n          // add to fragment loader latency\n          fragLoading.first += partLoading.first - partLoading.start;\n        } else {\n          fragLoading.start = partLoading.start;\n          fragLoading.first = partLoading.first;\n        }\n        fragLoading.end = partLoading.end;\n      };\n      _proto.resetLoader = function resetLoader(frag, loader) {\n        frag.loader = null;\n        if (this.loader === loader) {\n          self.clearTimeout(this.partLoadTimeout);\n          this.loader = null;\n        }\n        loader.destroy();\n      };\n      return FragmentLoader;\n    }();\n    function createLoaderContext(frag, part) {\n      if (part === void 0) {\n        part = null;\n      }\n      var segment = part || frag;\n      var loaderContext = {\n        frag: frag,\n        part: part,\n        responseType: 'arraybuffer',\n        url: segment.url,\n        headers: {},\n        rangeStart: 0,\n        rangeEnd: 0\n      };\n      var start = segment.byteRangeStartOffset;\n      var end = segment.byteRangeEndOffset;\n      if (isFiniteNumber(start) && isFiniteNumber(end)) {\n        var _frag$decryptdata;\n        var byteRangeStart = start;\n        var byteRangeEnd = end;\n        if (frag.sn === 'initSegment' && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === 'AES-128') {\n          // MAP segment encrypted with method 'AES-128', when served with HTTP Range,\n          // has the unencrypted size specified in the range.\n          // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n          var fragmentLen = end - start;\n          if (fragmentLen % 16) {\n            byteRangeEnd = end + (16 - fragmentLen % 16);\n          }\n          if (start !== 0) {\n            loaderContext.resetIV = true;\n            byteRangeStart = start - 16;\n          }\n        }\n        loaderContext.rangeStart = byteRangeStart;\n        loaderContext.rangeEnd = byteRangeEnd;\n      }\n      return loaderContext;\n    }\n    function createGapLoadError(frag, part) {\n      var error = new Error(\"GAP \" + (frag.gap ? 'tag' : 'attribute') + \" found\");\n      var errorData = {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_GAP,\n        fatal: false,\n        frag: frag,\n        error: error,\n        networkDetails: null\n      };\n      if (part) {\n        errorData.part = part;\n      }\n      (part ? part : frag).stats.aborted = true;\n      return new LoadError(errorData);\n    }\n    var LoadError = /*#__PURE__*/function (_Error) {\n      _inheritsLoose(LoadError, _Error);\n      function LoadError(data) {\n        var _this3;\n        _this3 = _Error.call(this, data.error.message) || this;\n        _this3.data = void 0;\n        _this3.data = data;\n        return _this3;\n      }\n      return LoadError;\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n    var KeyLoader = /*#__PURE__*/function () {\n      function KeyLoader(config) {\n        this.config = void 0;\n        this.keyUriToKeyInfo = {};\n        this.emeController = null;\n        this.config = config;\n      }\n      var _proto = KeyLoader.prototype;\n      _proto.abort = function abort(type) {\n        for (var uri in this.keyUriToKeyInfo) {\n          var loader = this.keyUriToKeyInfo[uri].loader;\n          if (loader) {\n            if (type && type !== loader.context.frag.type) {\n              return;\n            }\n            loader.abort();\n          }\n        }\n      };\n      _proto.detach = function detach() {\n        for (var uri in this.keyUriToKeyInfo) {\n          var keyInfo = this.keyUriToKeyInfo[uri];\n          // Remove cached EME keys on detach\n          if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n            delete this.keyUriToKeyInfo[uri];\n          }\n        }\n      };\n      _proto.destroy = function destroy() {\n        this.detach();\n        for (var uri in this.keyUriToKeyInfo) {\n          var loader = this.keyUriToKeyInfo[uri].loader;\n          if (loader) {\n            loader.destroy();\n          }\n        }\n        this.keyUriToKeyInfo = {};\n      };\n      _proto.createKeyLoadError = function createKeyLoadError(frag, details, error, networkDetails, response) {\n        if (details === void 0) {\n          details = ErrorDetails.KEY_LOAD_ERROR;\n        }\n        return new LoadError({\n          type: ErrorTypes.NETWORK_ERROR,\n          details: details,\n          fatal: false,\n          frag: frag,\n          response: response,\n          error: error,\n          networkDetails: networkDetails\n        });\n      };\n      _proto.loadClear = function loadClear(loadingFrag, encryptedFragments) {\n        var _this = this;\n        if (this.emeController && this.config.emeEnabled) {\n          // access key-system with nearest key on start (loaidng frag is unencrypted)\n          var sn = loadingFrag.sn,\n            cc = loadingFrag.cc;\n          var _loop = function _loop() {\n            var frag = encryptedFragments[i];\n            if (cc <= frag.cc && (sn === 'initSegment' || frag.sn === 'initSegment' || sn < frag.sn)) {\n              _this.emeController.selectKeySystemFormat(frag).then(function (keySystemFormat) {\n                frag.setKeyFormat(keySystemFormat);\n              });\n              return \"break\";\n            }\n          };\n          for (var i = 0; i < encryptedFragments.length; i++) {\n            var _ret = _loop();\n            if (_ret === \"break\") break;\n          }\n        }\n      };\n      _proto.load = function load(frag) {\n        var _this2 = this;\n        if (!frag.decryptdata && frag.encrypted && this.emeController) {\n          // Multiple keys, but none selected, resolve in eme-controller\n          return this.emeController.selectKeySystemFormat(frag).then(function (keySystemFormat) {\n            return _this2.loadInternal(frag, keySystemFormat);\n          });\n        }\n        return this.loadInternal(frag);\n      };\n      _proto.loadInternal = function loadInternal(frag, keySystemFormat) {\n        var _keyInfo, _keyInfo2;\n        if (keySystemFormat) {\n          frag.setKeyFormat(keySystemFormat);\n        }\n        var decryptdata = frag.decryptdata;\n        if (!decryptdata) {\n          var error = new Error(keySystemFormat ? \"Expected frag.decryptdata to be defined after setting format \" + keySystemFormat : 'Missing decryption data on fragment in onKeyLoading');\n          return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));\n        }\n        var uri = decryptdata.uri;\n        if (!uri) {\n          return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"Invalid key URI: \\\"\" + uri + \"\\\"\")));\n        }\n        var keyInfo = this.keyUriToKeyInfo[uri];\n        if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {\n          decryptdata.key = keyInfo.decryptdata.key;\n          return Promise.resolve({\n            frag: frag,\n            keyInfo: keyInfo\n          });\n        }\n        // Return key load promise as long as it does not have a mediakey session with an unusable key status\n        if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {\n          var _keyInfo$mediaKeySess;\n          switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {\n            case undefined:\n            case 'status-pending':\n            case 'usable':\n            case 'usable-in-future':\n              return keyInfo.keyLoadPromise.then(function (keyLoadedData) {\n                // Return the correct fragment with updated decryptdata key and loaded keyInfo\n                decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;\n                return {\n                  frag: frag,\n                  keyInfo: keyInfo\n                };\n              });\n          }\n          // If we have a key session and status and it is not pending or usable, continue\n          // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n        }\n\n        // Load the key or return the loading promise\n        keyInfo = this.keyUriToKeyInfo[uri] = {\n          decryptdata: decryptdata,\n          keyLoadPromise: null,\n          loader: null,\n          mediaKeySessionContext: null\n        };\n        switch (decryptdata.method) {\n          case 'ISO-23001-7':\n          case 'SAMPLE-AES':\n          case 'SAMPLE-AES-CENC':\n          case 'SAMPLE-AES-CTR':\n            if (decryptdata.keyFormat === 'identity') {\n              // loadKeyHTTP handles http(s) and data URLs\n              return this.loadKeyHTTP(keyInfo, frag);\n            }\n            return this.loadKeyEME(keyInfo, frag);\n          case 'AES-128':\n            return this.loadKeyHTTP(keyInfo, frag);\n          default:\n            return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"Key supplied with unsupported METHOD: \\\"\" + decryptdata.method + \"\\\"\")));\n        }\n      };\n      _proto.loadKeyEME = function loadKeyEME(keyInfo, frag) {\n        var keyLoadedData = {\n          frag: frag,\n          keyInfo: keyInfo\n        };\n        if (this.emeController && this.config.emeEnabled) {\n          var keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n          if (keySessionContextPromise) {\n            return (keyInfo.keyLoadPromise = keySessionContextPromise.then(function (keySessionContext) {\n              keyInfo.mediaKeySessionContext = keySessionContext;\n              return keyLoadedData;\n            })).catch(function (error) {\n              // Remove promise for license renewal or retry\n              keyInfo.keyLoadPromise = null;\n              throw error;\n            });\n          }\n        }\n        return Promise.resolve(keyLoadedData);\n      };\n      _proto.loadKeyHTTP = function loadKeyHTTP(keyInfo, frag) {\n        var _this3 = this;\n        var config = this.config;\n        var Loader = config.loader;\n        var keyLoader = new Loader(config);\n        frag.keyLoader = keyInfo.loader = keyLoader;\n        return keyInfo.keyLoadPromise = new Promise(function (resolve, reject) {\n          var loaderContext = {\n            keyInfo: keyInfo,\n            frag: frag,\n            responseType: 'arraybuffer',\n            url: keyInfo.decryptdata.uri\n          };\n\n          // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n          // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n          // this will also align retry logic with fragment-loader\n          var loadPolicy = config.keyLoadPolicy.default;\n          var loaderConfig = {\n            loadPolicy: loadPolicy,\n            timeout: loadPolicy.maxLoadTimeMs,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: 0\n          };\n          var loaderCallbacks = {\n            onSuccess: function onSuccess(response, stats, context, networkDetails) {\n              var frag = context.frag,\n                keyInfo = context.keyInfo,\n                uri = context.url;\n              if (!frag.decryptdata || keyInfo !== _this3.keyUriToKeyInfo[uri]) {\n                return reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('after key load, decryptdata unset or changed'), networkDetails));\n              }\n              keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n\n              // detach fragment key loader on load success\n              frag.keyLoader = null;\n              keyInfo.loader = null;\n              resolve({\n                frag: frag,\n                keyInfo: keyInfo\n              });\n            },\n            onError: function onError(response, context, networkDetails, stats) {\n              _this3.resetLoader(context);\n              reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"HTTP Error \" + response.code + \" loading key \" + response.text), networkDetails, _objectSpread2({\n                url: loaderContext.url,\n                data: undefined\n              }, response)));\n            },\n            onTimeout: function onTimeout(stats, context, networkDetails) {\n              _this3.resetLoader(context);\n              reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error('key loading timed out'), networkDetails));\n            },\n            onAbort: function onAbort(stats, context, networkDetails) {\n              _this3.resetLoader(context);\n              reject(_this3.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error('key loading aborted'), networkDetails));\n            }\n          };\n          keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n        });\n      };\n      _proto.resetLoader = function resetLoader(context) {\n        var frag = context.frag,\n          keyInfo = context.keyInfo,\n          uri = context.url;\n        var loader = keyInfo.loader;\n        if (frag.keyLoader === loader) {\n          frag.keyLoader = null;\n          keyInfo.loader = null;\n        }\n        delete this.keyUriToKeyInfo[uri];\n        if (loader) {\n          loader.destroy();\n        }\n      };\n      return KeyLoader;\n    }();\n\n    /**\n     * @ignore\n     * Sub-class specialization of EventHandler base class.\n     *\n     * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n     * scheduled asynchroneously, avoiding recursive calls in the same tick.\n     *\n     * The task itself is implemented in `doTick`. It can be requested and called for single execution\n     * using the `tick` method.\n     *\n     * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n     * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n     *\n     * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n     * and cancelled with `clearNextTick`.\n     *\n     * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n     *\n     * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n     *\n     * Further explanations:\n     *\n     * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n     * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n     *\n     * When the task execution (`tick` method) is called in re-entrant way this is detected and\n     * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n     * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n     */\n    var TaskLoop = /*#__PURE__*/function () {\n      function TaskLoop() {\n        this._boundTick = void 0;\n        this._tickTimer = null;\n        this._tickInterval = null;\n        this._tickCallCount = 0;\n        this._boundTick = this.tick.bind(this);\n      }\n      var _proto = TaskLoop.prototype;\n      _proto.destroy = function destroy() {\n        this.onHandlerDestroying();\n        this.onHandlerDestroyed();\n      };\n      _proto.onHandlerDestroying = function onHandlerDestroying() {\n        // clear all timers before unregistering from event bus\n        this.clearNextTick();\n        this.clearInterval();\n      };\n      _proto.onHandlerDestroyed = function onHandlerDestroyed() {};\n      _proto.hasInterval = function hasInterval() {\n        return !!this._tickInterval;\n      };\n      _proto.hasNextTick = function hasNextTick() {\n        return !!this._tickTimer;\n      }\n\n      /**\n       * @param millis - Interval time (ms)\n       * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n       */;\n      _proto.setInterval = function setInterval(millis) {\n        if (!this._tickInterval) {\n          this._tickCallCount = 0;\n          this._tickInterval = self.setInterval(this._boundTick, millis);\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * @returns True when interval was cleared, false when none was set (no effect)\n       */;\n      _proto.clearInterval = function clearInterval() {\n        if (this._tickInterval) {\n          self.clearInterval(this._tickInterval);\n          this._tickInterval = null;\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * @returns True when timeout was cleared, false when none was set (no effect)\n       */;\n      _proto.clearNextTick = function clearNextTick() {\n        if (this._tickTimer) {\n          self.clearTimeout(this._tickTimer);\n          this._tickTimer = null;\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * Will call the subclass doTick implementation in this main loop tick\n       * or in the next one (via setTimeout(,0)) in case it has already been called\n       * in this tick (in case this is a re-entrant call).\n       */;\n      _proto.tick = function tick() {\n        this._tickCallCount++;\n        if (this._tickCallCount === 1) {\n          this.doTick();\n          // re-entrant call to tick from previous doTick call stack\n          // -> schedule a call on the next main loop iteration to process this task processing request\n          if (this._tickCallCount > 1) {\n            // make sure only one timer exists at any time at max\n            this.tickImmediate();\n          }\n          this._tickCallCount = 0;\n        }\n      };\n      _proto.tickImmediate = function tickImmediate() {\n        this.clearNextTick();\n        this._tickTimer = self.setTimeout(this._boundTick, 0);\n      }\n\n      /**\n       * For subclass to implement task logic\n       * @abstract\n       */;\n      _proto.doTick = function doTick() {};\n      return TaskLoop;\n    }();\n\n    /**\n     * Provides methods dealing with buffer length retrieval for example.\n     *\n     * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n     *\n     * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n     */\n\n    var noopBuffered = {\n      length: 0,\n      start: function start() {\n        return 0;\n      },\n      end: function end() {\n        return 0;\n      }\n    };\n    var BufferHelper = /*#__PURE__*/function () {\n      function BufferHelper() {}\n      /**\n       * Return true if `media`'s buffered include `position`\n       */\n      BufferHelper.isBuffered = function isBuffered(media, position) {\n        try {\n          if (media) {\n            var buffered = BufferHelper.getBuffered(media);\n            for (var i = 0; i < buffered.length; i++) {\n              if (position >= buffered.start(i) && position <= buffered.end(i)) {\n                return true;\n              }\n            }\n          }\n        } catch (error) {\n          // this is to catch\n          // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n          // This SourceBuffer has been removed from the parent media source\n        }\n        return false;\n      };\n      BufferHelper.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {\n        try {\n          if (media) {\n            var vbuffered = BufferHelper.getBuffered(media);\n            var buffered = [];\n            var i;\n            for (i = 0; i < vbuffered.length; i++) {\n              buffered.push({\n                start: vbuffered.start(i),\n                end: vbuffered.end(i)\n              });\n            }\n            return this.bufferedInfo(buffered, pos, maxHoleDuration);\n          }\n        } catch (error) {\n          // this is to catch\n          // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n          // This SourceBuffer has been removed from the parent media source\n        }\n        return {\n          len: 0,\n          start: pos,\n          end: pos,\n          nextStart: undefined\n        };\n      };\n      BufferHelper.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {\n        pos = Math.max(0, pos);\n        // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n        buffered.sort(function (a, b) {\n          var diff = a.start - b.start;\n          if (diff) {\n            return diff;\n          } else {\n            return b.end - a.end;\n          }\n        });\n        var buffered2 = [];\n        if (maxHoleDuration) {\n          // there might be some small holes between buffer time range\n          // consider that holes smaller than maxHoleDuration are irrelevant and build another\n          // buffer time range representations that discards those holes\n          for (var i = 0; i < buffered.length; i++) {\n            var buf2len = buffered2.length;\n            if (buf2len) {\n              var buf2end = buffered2[buf2len - 1].end;\n              // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n              if (buffered[i].start - buf2end < maxHoleDuration) {\n                // merge overlapping time ranges\n                // update lastRange.end only if smaller than item.end\n                // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n                // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n                if (buffered[i].end > buf2end) {\n                  buffered2[buf2len - 1].end = buffered[i].end;\n                }\n              } else {\n                // big hole\n                buffered2.push(buffered[i]);\n              }\n            } else {\n              // first value\n              buffered2.push(buffered[i]);\n            }\n          }\n        } else {\n          buffered2 = buffered;\n        }\n        var bufferLen = 0;\n\n        // bufferStartNext can possibly be undefined based on the conditional logic below\n        var bufferStartNext;\n\n        // bufferStart and bufferEnd are buffer boundaries around current video position\n        var bufferStart = pos;\n        var bufferEnd = pos;\n        for (var _i = 0; _i < buffered2.length; _i++) {\n          var start = buffered2[_i].start;\n          var end = buffered2[_i].end;\n          // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n          if (pos + maxHoleDuration >= start && pos < end) {\n            // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n            bufferStart = start;\n            bufferEnd = end;\n            bufferLen = bufferEnd - pos;\n          } else if (pos + maxHoleDuration < start) {\n            bufferStartNext = start;\n            break;\n          }\n        }\n        return {\n          len: bufferLen,\n          start: bufferStart || 0,\n          end: bufferEnd || 0,\n          nextStart: bufferStartNext\n        };\n      }\n\n      /**\n       * Safe method to get buffered property.\n       * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n       */;\n      BufferHelper.getBuffered = function getBuffered(media) {\n        try {\n          return media.buffered;\n        } catch (e) {\n          logger.log('failed to get media.buffered', e);\n          return noopBuffered;\n        }\n      };\n      return BufferHelper;\n    }();\n    var ChunkMetadata = function ChunkMetadata(level, sn, id, size, part, partial) {\n      if (size === void 0) {\n        size = 0;\n      }\n      if (part === void 0) {\n        part = -1;\n      }\n      if (partial === void 0) {\n        partial = false;\n      }\n      this.level = void 0;\n      this.sn = void 0;\n      this.part = void 0;\n      this.id = void 0;\n      this.size = void 0;\n      this.partial = void 0;\n      this.transmuxing = getNewPerformanceTiming();\n      this.buffering = {\n        audio: getNewPerformanceTiming(),\n        video: getNewPerformanceTiming(),\n        audiovideo: getNewPerformanceTiming()\n      };\n      this.level = level;\n      this.sn = sn;\n      this.id = id;\n      this.size = size;\n      this.part = part;\n      this.partial = partial;\n    };\n    function getNewPerformanceTiming() {\n      return {\n        start: 0,\n        executeStart: 0,\n        executeEnd: 0,\n        end: 0\n      };\n    }\n    function findFirstFragWithCC(fragments, cc) {\n      var firstFrag = null;\n      for (var i = 0, len = fragments.length; i < len; i++) {\n        var currentFrag = fragments[i];\n        if (currentFrag && currentFrag.cc === cc) {\n          firstFrag = currentFrag;\n          break;\n        }\n      }\n      return firstFrag;\n    }\n    function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {\n      if (lastLevel.details) {\n        if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // Find the first frag in the previous level which matches the CC of the first frag of the new level\n    function findDiscontinuousReferenceFrag(prevDetails, curDetails, referenceIndex) {\n      var prevFrags = prevDetails.fragments;\n      var curFrags = curDetails.fragments;\n      if (!curFrags.length || !prevFrags.length) {\n        logger.log('No fragments to align');\n        return;\n      }\n      var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);\n      if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {\n        logger.log('No frag in previous level to align on');\n        return;\n      }\n      return prevStartFrag;\n    }\n    function adjustFragmentStart(frag, sliding) {\n      if (frag) {\n        var start = frag.start + sliding;\n        frag.start = frag.startPTS = start;\n        frag.endPTS = start + frag.duration;\n      }\n    }\n    function adjustSlidingStart(sliding, details) {\n      // Update segments\n      var fragments = details.fragments;\n      for (var i = 0, len = fragments.length; i < len; i++) {\n        adjustFragmentStart(fragments[i], sliding);\n      }\n      // Update LL-HLS parts at the end of the playlist\n      if (details.fragmentHint) {\n        adjustFragmentStart(details.fragmentHint, sliding);\n      }\n      details.alignedSliding = true;\n    }\n\n    /**\n     * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n     * contiguous stream with the last fragments.\n     * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n     * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n     * and an extra download.\n     * @param lastFrag\n     * @param lastLevel\n     * @param details\n     */\n    function alignStream(lastFrag, lastLevel, details) {\n      if (!lastLevel) {\n        return;\n      }\n      alignDiscontinuities(lastFrag, details, lastLevel);\n      if (!details.alignedSliding && lastLevel.details) {\n        // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n        // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n        // discontinuity sequence.\n        alignPDT(details, lastLevel.details);\n      }\n      if (!details.alignedSliding && lastLevel.details && !details.skippedSegments) {\n        // Try to align on sn so that we pick a better start fragment.\n        // Do not perform this on playlists with delta updates as this is only to align levels on switch\n        // and adjustSliding only adjusts fragments after skippedSegments.\n        adjustSliding(lastLevel.details, details);\n      }\n    }\n\n    /**\n     * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same\n     * discontinuity sequence.\n     * @param lastFrag - The last Fragment which shares the same discontinuity sequence\n     * @param lastLevel - The details of the last loaded level\n     * @param details - The details of the new level\n     */\n    function alignDiscontinuities(lastFrag, details, lastLevel) {\n      if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {\n        var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);\n        if (referenceFrag && isFiniteNumber(referenceFrag.start)) {\n          logger.log(\"Adjusting PTS using last level due to CC increase within current level \" + details.url);\n          adjustSlidingStart(referenceFrag.start, details);\n        }\n      }\n    }\n\n    /**\n     * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.\n     * @param details - The details of the new level\n     * @param lastDetails - The details of the last loaded level\n     */\n    function alignPDT(details, lastDetails) {\n      // This check protects the unsafe \"!\" usage below for null program date time access.\n      if (!lastDetails.fragments.length || !details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {\n        return;\n      }\n      // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM\n      // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM\n      // then we can deduce that playlist B sliding is 1000+8 = 1008s\n      var lastPDT = lastDetails.fragments[0].programDateTime; // hasProgramDateTime check above makes this safe.\n      var newPDT = details.fragments[0].programDateTime;\n      // date diff is in ms. frag.start is in seconds\n      var sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;\n      if (sliding && isFiniteNumber(sliding)) {\n        logger.log(\"Adjusting PTS using programDateTime delta \" + (newPDT - lastPDT) + \"ms, sliding:\" + sliding.toFixed(3) + \" \" + details.url + \" \");\n        adjustSlidingStart(sliding, details);\n      }\n    }\n    var AESCrypto = /*#__PURE__*/function () {\n      function AESCrypto(subtle, iv) {\n        this.subtle = void 0;\n        this.aesIV = void 0;\n        this.subtle = subtle;\n        this.aesIV = iv;\n      }\n      var _proto = AESCrypto.prototype;\n      _proto.decrypt = function decrypt(data, key) {\n        return this.subtle.decrypt({\n          name: 'AES-CBC',\n          iv: this.aesIV\n        }, key, data);\n      };\n      return AESCrypto;\n    }();\n    var FastAESKey = /*#__PURE__*/function () {\n      function FastAESKey(subtle, key) {\n        this.subtle = void 0;\n        this.key = void 0;\n        this.subtle = subtle;\n        this.key = key;\n      }\n      var _proto = FastAESKey.prototype;\n      _proto.expandKey = function expandKey() {\n        return this.subtle.importKey('raw', this.key, {\n          name: 'AES-CBC'\n        }, false, ['encrypt', 'decrypt']);\n      };\n      return FastAESKey;\n    }();\n\n    // PKCS7\n    function removePadding(array) {\n      var outputBytes = array.byteLength;\n      var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n      if (paddingBytes) {\n        return sliceUint8(array, 0, outputBytes - paddingBytes);\n      }\n      return array;\n    }\n    var AESDecryptor = /*#__PURE__*/function () {\n      function AESDecryptor() {\n        this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n        this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n        this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n        this.sBox = new Uint32Array(256);\n        this.invSBox = new Uint32Array(256);\n        this.key = new Uint32Array(0);\n        this.ksRows = 0;\n        this.keySize = 0;\n        this.keySchedule = void 0;\n        this.invKeySchedule = void 0;\n        this.initTable();\n      }\n\n      // Using view.getUint32() also swaps the byte order.\n      var _proto = AESDecryptor.prototype;\n      _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {\n        var view = new DataView(arrayBuffer);\n        var newArray = new Uint32Array(4);\n        for (var i = 0; i < 4; i++) {\n          newArray[i] = view.getUint32(i * 4);\n        }\n        return newArray;\n      };\n      _proto.initTable = function initTable() {\n        var sBox = this.sBox;\n        var invSBox = this.invSBox;\n        var subMix = this.subMix;\n        var subMix0 = subMix[0];\n        var subMix1 = subMix[1];\n        var subMix2 = subMix[2];\n        var subMix3 = subMix[3];\n        var invSubMix = this.invSubMix;\n        var invSubMix0 = invSubMix[0];\n        var invSubMix1 = invSubMix[1];\n        var invSubMix2 = invSubMix[2];\n        var invSubMix3 = invSubMix[3];\n        var d = new Uint32Array(256);\n        var x = 0;\n        var xi = 0;\n        var i = 0;\n        for (i = 0; i < 256; i++) {\n          if (i < 128) {\n            d[i] = i << 1;\n          } else {\n            d[i] = i << 1 ^ 0x11b;\n          }\n        }\n        for (i = 0; i < 256; i++) {\n          var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n          sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n          sBox[x] = sx;\n          invSBox[sx] = x;\n\n          // Compute multiplication\n          var x2 = d[x];\n          var x4 = d[x2];\n          var x8 = d[x4];\n\n          // Compute sub/invSub bytes, mix columns tables\n          var t = d[sx] * 0x101 ^ sx * 0x1010100;\n          subMix0[x] = t << 24 | t >>> 8;\n          subMix1[x] = t << 16 | t >>> 16;\n          subMix2[x] = t << 8 | t >>> 24;\n          subMix3[x] = t;\n\n          // Compute inv sub bytes, inv mix columns tables\n          t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n          invSubMix0[sx] = t << 24 | t >>> 8;\n          invSubMix1[sx] = t << 16 | t >>> 16;\n          invSubMix2[sx] = t << 8 | t >>> 24;\n          invSubMix3[sx] = t;\n\n          // Compute next counter\n          if (!x) {\n            x = xi = 1;\n          } else {\n            x = x2 ^ d[d[d[x8 ^ x2]]];\n            xi ^= d[d[xi]];\n          }\n        }\n      };\n      _proto.expandKey = function expandKey(keyBuffer) {\n        // convert keyBuffer to Uint32Array\n        var key = this.uint8ArrayToUint32Array_(keyBuffer);\n        var sameKey = true;\n        var offset = 0;\n        while (offset < key.length && sameKey) {\n          sameKey = key[offset] === this.key[offset];\n          offset++;\n        }\n        if (sameKey) {\n          return;\n        }\n        this.key = key;\n        var keySize = this.keySize = key.length;\n        if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n          throw new Error('Invalid aes key size=' + keySize);\n        }\n        var ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n        var ksRow;\n        var invKsRow;\n        var keySchedule = this.keySchedule = new Uint32Array(ksRows);\n        var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n        var sbox = this.sBox;\n        var rcon = this.rcon;\n        var invSubMix = this.invSubMix;\n        var invSubMix0 = invSubMix[0];\n        var invSubMix1 = invSubMix[1];\n        var invSubMix2 = invSubMix[2];\n        var invSubMix3 = invSubMix[3];\n        var prev;\n        var t;\n        for (ksRow = 0; ksRow < ksRows; ksRow++) {\n          if (ksRow < keySize) {\n            prev = keySchedule[ksRow] = key[ksRow];\n            continue;\n          }\n          t = prev;\n          if (ksRow % keySize === 0) {\n            // Rot word\n            t = t << 8 | t >>> 24;\n\n            // Sub word\n            t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n            // Mix Rcon\n            t ^= rcon[ksRow / keySize | 0] << 24;\n          } else if (keySize > 6 && ksRow % keySize === 4) {\n            // Sub word\n            t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n          }\n          keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n        }\n        for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n          ksRow = ksRows - invKsRow;\n          if (invKsRow & 3) {\n            t = keySchedule[ksRow];\n          } else {\n            t = keySchedule[ksRow - 4];\n          }\n          if (invKsRow < 4 || ksRow <= 4) {\n            invKeySchedule[invKsRow] = t;\n          } else {\n            invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n          }\n          invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n        }\n      }\n\n      // Adding this as a method greatly improves performance.\n      ;\n\n      _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {\n        return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n      };\n      _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {\n        var nRounds = this.keySize + 6;\n        var invKeySchedule = this.invKeySchedule;\n        var invSBOX = this.invSBox;\n        var invSubMix = this.invSubMix;\n        var invSubMix0 = invSubMix[0];\n        var invSubMix1 = invSubMix[1];\n        var invSubMix2 = invSubMix[2];\n        var invSubMix3 = invSubMix[3];\n        var initVector = this.uint8ArrayToUint32Array_(aesIV);\n        var initVector0 = initVector[0];\n        var initVector1 = initVector[1];\n        var initVector2 = initVector[2];\n        var initVector3 = initVector[3];\n        var inputInt32 = new Int32Array(inputArrayBuffer);\n        var outputInt32 = new Int32Array(inputInt32.length);\n        var t0, t1, t2, t3;\n        var s0, s1, s2, s3;\n        var inputWords0, inputWords1, inputWords2, inputWords3;\n        var ksRow, i;\n        var swapWord = this.networkToHostOrderSwap;\n        while (offset < inputInt32.length) {\n          inputWords0 = swapWord(inputInt32[offset]);\n          inputWords1 = swapWord(inputInt32[offset + 1]);\n          inputWords2 = swapWord(inputInt32[offset + 2]);\n          inputWords3 = swapWord(inputInt32[offset + 3]);\n          s0 = inputWords0 ^ invKeySchedule[0];\n          s1 = inputWords3 ^ invKeySchedule[1];\n          s2 = inputWords2 ^ invKeySchedule[2];\n          s3 = inputWords1 ^ invKeySchedule[3];\n          ksRow = 4;\n\n          // Iterate through the rounds of decryption\n          for (i = 1; i < nRounds; i++) {\n            t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n            t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n            t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n            t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n            // Update state\n            s0 = t0;\n            s1 = t1;\n            s2 = t2;\n            s3 = t3;\n            ksRow = ksRow + 4;\n          }\n\n          // Shift rows, sub bytes, add round key\n          t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n          t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n          t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n          t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n\n          // Write\n          outputInt32[offset] = swapWord(t0 ^ initVector0);\n          outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n          outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n          outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n          // reset initVector to last 4 unsigned int\n          initVector0 = inputWords0;\n          initVector1 = inputWords1;\n          initVector2 = inputWords2;\n          initVector3 = inputWords3;\n          offset = offset + 4;\n        }\n        return outputInt32.buffer;\n      };\n      return AESDecryptor;\n    }();\n    var CHUNK_SIZE = 16; // 16 bytes, 128 bits\n    var Decrypter = /*#__PURE__*/function () {\n      function Decrypter(config, _temp) {\n        var _ref = _temp === void 0 ? {} : _temp,\n          _ref$removePKCS7Paddi = _ref.removePKCS7Padding,\n          removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;\n        this.logEnabled = true;\n        this.removePKCS7Padding = void 0;\n        this.subtle = null;\n        this.softwareDecrypter = null;\n        this.key = null;\n        this.fastAesKey = null;\n        this.remainderData = null;\n        this.currentIV = null;\n        this.currentResult = null;\n        this.useSoftware = void 0;\n        this.useSoftware = config.enableSoftwareAES;\n        this.removePKCS7Padding = removePKCS7Padding;\n        // built in decryptor expects PKCS7 padding\n        if (removePKCS7Padding) {\n          try {\n            var browserCrypto = self.crypto;\n            if (browserCrypto) {\n              this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n            }\n          } catch (e) {\n            /* no-op */\n          }\n        }\n        if (this.subtle === null) {\n          this.useSoftware = true;\n        }\n      }\n      var _proto = Decrypter.prototype;\n      _proto.destroy = function destroy() {\n        this.subtle = null;\n        this.softwareDecrypter = null;\n        this.key = null;\n        this.fastAesKey = null;\n        this.remainderData = null;\n        this.currentIV = null;\n        this.currentResult = null;\n      };\n      _proto.isSync = function isSync() {\n        return this.useSoftware;\n      };\n      _proto.flush = function flush() {\n        var currentResult = this.currentResult,\n          remainderData = this.remainderData;\n        if (!currentResult || remainderData) {\n          this.reset();\n          return null;\n        }\n        var data = new Uint8Array(currentResult);\n        this.reset();\n        if (this.removePKCS7Padding) {\n          return removePadding(data);\n        }\n        return data;\n      };\n      _proto.reset = function reset() {\n        this.currentResult = null;\n        this.currentIV = null;\n        this.remainderData = null;\n        if (this.softwareDecrypter) {\n          this.softwareDecrypter = null;\n        }\n      };\n      _proto.decrypt = function decrypt(data, key, iv) {\n        var _this = this;\n        if (this.useSoftware) {\n          return new Promise(function (resolve, reject) {\n            _this.softwareDecrypt(new Uint8Array(data), key, iv);\n            var decryptResult = _this.flush();\n            if (decryptResult) {\n              resolve(decryptResult.buffer);\n            } else {\n              reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n            }\n          });\n        }\n        return this.webCryptoDecrypt(new Uint8Array(data), key, iv);\n      }\n\n      // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n      // data is handled in the flush() call\n      ;\n\n      _proto.softwareDecrypt = function softwareDecrypt(data, key, iv) {\n        var currentIV = this.currentIV,\n          currentResult = this.currentResult,\n          remainderData = this.remainderData;\n        this.logOnce('JS AES decrypt');\n        // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n        // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n        // the end on flush(), but by that time we have already received all bytes for the segment.\n        // Progressive decryption does not work with WebCrypto\n\n        if (remainderData) {\n          data = appendUint8Array(remainderData, data);\n          this.remainderData = null;\n        }\n\n        // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n        var currentChunk = this.getValidChunk(data);\n        if (!currentChunk.length) {\n          return null;\n        }\n        if (currentIV) {\n          iv = currentIV;\n        }\n        var softwareDecrypter = this.softwareDecrypter;\n        if (!softwareDecrypter) {\n          softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n        }\n        softwareDecrypter.expandKey(key);\n        var result = currentResult;\n        this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n        this.currentIV = sliceUint8(currentChunk, -16).buffer;\n        if (!result) {\n          return null;\n        }\n        return result;\n      };\n      _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv) {\n        var _this2 = this;\n        var subtle = this.subtle;\n        if (this.key !== key || !this.fastAesKey) {\n          this.key = key;\n          this.fastAesKey = new FastAESKey(subtle, key);\n        }\n        return this.fastAesKey.expandKey().then(function (aesKey) {\n          // decrypt using web crypto\n          if (!subtle) {\n            return Promise.reject(new Error('web crypto not initialized'));\n          }\n          _this2.logOnce('WebCrypto AES decrypt');\n          var crypto = new AESCrypto(subtle, new Uint8Array(iv));\n          return crypto.decrypt(data.buffer, aesKey);\n        }).catch(function (err) {\n          logger.warn(\"[decrypter]: WebCrypto Error, disable WebCrypto API, \" + err.name + \": \" + err.message);\n          return _this2.onWebCryptoError(data, key, iv);\n        });\n      };\n      _proto.onWebCryptoError = function onWebCryptoError(data, key, iv) {\n        this.useSoftware = true;\n        this.logEnabled = true;\n        this.softwareDecrypt(data, key, iv);\n        var decryptResult = this.flush();\n        if (decryptResult) {\n          return decryptResult.buffer;\n        }\n        throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data');\n      };\n      _proto.getValidChunk = function getValidChunk(data) {\n        var currentChunk = data;\n        var splitPoint = data.length - data.length % CHUNK_SIZE;\n        if (splitPoint !== data.length) {\n          currentChunk = sliceUint8(data, 0, splitPoint);\n          this.remainderData = sliceUint8(data, splitPoint);\n        }\n        return currentChunk;\n      };\n      _proto.logOnce = function logOnce(msg) {\n        if (!this.logEnabled) {\n          return;\n        }\n        logger.log(\"[decrypter]: \" + msg);\n        this.logEnabled = false;\n      };\n      return Decrypter;\n    }();\n\n    /**\n     *  TimeRanges to string helper\n     */\n\n    var TimeRanges = {\n      toString: function toString(r) {\n        var log = '';\n        var len = r.length;\n        for (var i = 0; i < len; i++) {\n          log += \"[\" + r.start(i).toFixed(3) + \"-\" + r.end(i).toFixed(3) + \"]\";\n        }\n        return log;\n      }\n    };\n    var State = {\n      STOPPED: 'STOPPED',\n      IDLE: 'IDLE',\n      KEY_LOADING: 'KEY_LOADING',\n      FRAG_LOADING: 'FRAG_LOADING',\n      FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n      WAITING_TRACK: 'WAITING_TRACK',\n      PARSING: 'PARSING',\n      PARSED: 'PARSED',\n      ENDED: 'ENDED',\n      ERROR: 'ERROR',\n      WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n      WAITING_LEVEL: 'WAITING_LEVEL'\n    };\n    var BaseStreamController = /*#__PURE__*/function (_TaskLoop) {\n      _inheritsLoose(BaseStreamController, _TaskLoop);\n      function BaseStreamController(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {\n        var _this;\n        _this = _TaskLoop.call(this) || this;\n        _this.hls = void 0;\n        _this.fragPrevious = null;\n        _this.fragCurrent = null;\n        _this.fragmentTracker = void 0;\n        _this.transmuxer = null;\n        _this._state = State.STOPPED;\n        _this.playlistType = void 0;\n        _this.media = null;\n        _this.mediaBuffer = null;\n        _this.config = void 0;\n        _this.bitrateTest = false;\n        _this.lastCurrentTime = 0;\n        _this.nextLoadPosition = 0;\n        _this.startPosition = 0;\n        _this.startTimeOffset = null;\n        _this.loadedmetadata = false;\n        _this.retryDate = 0;\n        _this.levels = null;\n        _this.fragmentLoader = void 0;\n        _this.keyLoader = void 0;\n        _this.levelLastLoaded = null;\n        _this.startFragRequested = false;\n        _this.decrypter = void 0;\n        _this.initPTS = [];\n        _this.onvseeking = null;\n        _this.onvended = null;\n        _this.logPrefix = '';\n        _this.log = void 0;\n        _this.warn = void 0;\n        _this.playlistType = playlistType;\n        _this.logPrefix = logPrefix;\n        _this.log = logger.log.bind(logger, logPrefix + \":\");\n        _this.warn = logger.warn.bind(logger, logPrefix + \":\");\n        _this.hls = hls;\n        _this.fragmentLoader = new FragmentLoader(hls.config);\n        _this.keyLoader = keyLoader;\n        _this.fragmentTracker = fragmentTracker;\n        _this.config = hls.config;\n        _this.decrypter = new Decrypter(hls.config);\n        hls.on(Events.MANIFEST_LOADED, _this.onManifestLoaded, _assertThisInitialized(_this));\n        return _this;\n      }\n      var _proto = BaseStreamController.prototype;\n      _proto.doTick = function doTick() {\n        this.onTickEnd();\n      };\n      _proto.onTickEnd = function onTickEnd() {}\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      ;\n\n      _proto.startLoad = function startLoad(startPosition) {};\n      _proto.stopLoad = function stopLoad() {\n        this.fragmentLoader.abort();\n        this.keyLoader.abort(this.playlistType);\n        var frag = this.fragCurrent;\n        if (frag != null && frag.loader) {\n          frag.abortRequests();\n          this.fragmentTracker.removeFragment(frag);\n        }\n        this.resetTransmuxer();\n        this.fragCurrent = null;\n        this.fragPrevious = null;\n        this.clearInterval();\n        this.clearNextTick();\n        this.state = State.STOPPED;\n      };\n      _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {\n        // If playlist is live, there is another buffered range after the current range, nothing buffered, media is detached,\n        // of nothing loading/loaded return false\n        if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {\n          return false;\n        }\n        var partList = levelDetails.partList;\n        // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n        // check instead if the last part is buffered.\n        if (partList != null && partList.length) {\n          var lastPart = partList[partList.length - 1];\n\n          // Checking the midpoint of the part for potential margin of error and related issues.\n          // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n          // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n          // part mismatches for independent audio and video playlists/segments.\n          var lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n          return lastPartBuffered;\n        }\n        var playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n        return this.fragmentTracker.isEndListAppended(playlistType);\n      };\n      _proto.getLevelDetails = function getLevelDetails() {\n        if (this.levels && this.levelLastLoaded !== null) {\n          var _this$levels$this$lev;\n          return (_this$levels$this$lev = this.levels[this.levelLastLoaded]) == null ? void 0 : _this$levels$this$lev.details;\n        }\n      };\n      _proto.onMediaAttached = function onMediaAttached(event, data) {\n        var media = this.media = this.mediaBuffer = data.media;\n        this.onvseeking = this.onMediaSeeking.bind(this);\n        this.onvended = this.onMediaEnded.bind(this);\n        media.addEventListener('seeking', this.onvseeking);\n        media.addEventListener('ended', this.onvended);\n        var config = this.config;\n        if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n          this.startLoad(config.startPosition);\n        }\n      };\n      _proto.onMediaDetaching = function onMediaDetaching() {\n        var media = this.media;\n        if (media != null && media.ended) {\n          this.log('MSE detaching and video ended, reset startPosition');\n          this.startPosition = this.lastCurrentTime = 0;\n        }\n\n        // remove video listeners\n        if (media && this.onvseeking && this.onvended) {\n          media.removeEventListener('seeking', this.onvseeking);\n          media.removeEventListener('ended', this.onvended);\n          this.onvseeking = this.onvended = null;\n        }\n        if (this.keyLoader) {\n          this.keyLoader.detach();\n        }\n        this.media = this.mediaBuffer = null;\n        this.loadedmetadata = false;\n        this.fragmentTracker.removeAllFragments();\n        this.stopLoad();\n      };\n      _proto.onMediaSeeking = function onMediaSeeking() {\n        var config = this.config,\n          fragCurrent = this.fragCurrent,\n          media = this.media,\n          mediaBuffer = this.mediaBuffer,\n          state = this.state;\n        var currentTime = media ? media.currentTime : 0;\n        var bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n        this.log(\"media seeking to \" + (isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime) + \", state: \" + state);\n        if (this.state === State.ENDED) {\n          this.resetLoadingState();\n        } else if (fragCurrent) {\n          // Seeking while frag load is in progress\n          var tolerance = config.maxFragLookUpTolerance;\n          var fragStartOffset = fragCurrent.start - tolerance;\n          var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n          // if seeking out of buffered range or into new one\n          if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n            var pastFragment = currentTime > fragEndOffset;\n            // if the seek position is outside the current fragment range\n            if (currentTime < fragStartOffset || pastFragment) {\n              if (pastFragment && fragCurrent.loader) {\n                this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');\n                fragCurrent.abortRequests();\n                this.resetLoadingState();\n              }\n              this.fragPrevious = null;\n            }\n          }\n        }\n        if (media) {\n          // Remove gap fragments\n          this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);\n          this.lastCurrentTime = currentTime;\n        }\n\n        // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n        if (!this.loadedmetadata && !bufferInfo.len) {\n          this.nextLoadPosition = this.startPosition = currentTime;\n        }\n\n        // Async tick to speed up processing\n        this.tickImmediate();\n      };\n      _proto.onMediaEnded = function onMediaEnded() {\n        // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n        this.startPosition = this.lastCurrentTime = 0;\n      };\n      _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n        this.startTimeOffset = data.startTimeOffset;\n        this.initPTS = [];\n      };\n      _proto.onHandlerDestroying = function onHandlerDestroying() {\n        this.stopLoad();\n        _TaskLoop.prototype.onHandlerDestroying.call(this);\n      };\n      _proto.onHandlerDestroyed = function onHandlerDestroyed() {\n        this.state = State.STOPPED;\n        if (this.fragmentLoader) {\n          this.fragmentLoader.destroy();\n        }\n        if (this.keyLoader) {\n          this.keyLoader.destroy();\n        }\n        if (this.decrypter) {\n          this.decrypter.destroy();\n        }\n        this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n        _TaskLoop.prototype.onHandlerDestroyed.call(this);\n      };\n      _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {\n        this._loadFragForPlayback(frag, level, targetBufferTime);\n      };\n      _proto._loadFragForPlayback = function _loadFragForPlayback(frag, level, targetBufferTime) {\n        var _this2 = this;\n        var progressCallback = function progressCallback(data) {\n          if (_this2.fragContextChanged(frag)) {\n            _this2.warn(\"Fragment \" + frag.sn + (data.part ? ' p: ' + data.part.index : '') + \" of level \" + frag.level + \" was dropped during download.\");\n            _this2.fragmentTracker.removeFragment(frag);\n            return;\n          }\n          frag.stats.chunkCount++;\n          _this2._handleFragmentLoadProgress(data);\n        };\n        this._doFragLoad(frag, level, targetBufferTime, progressCallback).then(function (data) {\n          if (!data) {\n            // if we're here we probably needed to backtrack or are waiting for more parts\n            return;\n          }\n          var state = _this2.state;\n          if (_this2.fragContextChanged(frag)) {\n            if (state === State.FRAG_LOADING || !_this2.fragCurrent && state === State.PARSING) {\n              _this2.fragmentTracker.removeFragment(frag);\n              _this2.state = State.IDLE;\n            }\n            return;\n          }\n          if ('payload' in data) {\n            _this2.log(\"Loaded fragment \" + frag.sn + \" of level \" + frag.level);\n            _this2.hls.trigger(Events.FRAG_LOADED, data);\n          }\n\n          // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n          _this2._handleFragmentLoadComplete(data);\n        }).catch(function (reason) {\n          if (_this2.state === State.STOPPED || _this2.state === State.ERROR) {\n            return;\n          }\n          _this2.warn(reason);\n          _this2.resetFragmentLoading(frag);\n        });\n      };\n      _proto.clearTrackerIfNeeded = function clearTrackerIfNeeded(frag) {\n        var _this$mediaBuffer;\n        var fragmentTracker = this.fragmentTracker;\n        var fragState = fragmentTracker.getState(frag);\n        if (fragState === FragmentState.APPENDING) {\n          // Lower the buffer size and try again\n          var playlistType = frag.type;\n          var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n          var minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);\n          if (this.reduceMaxBufferLength(minForwardBufferLength)) {\n            fragmentTracker.removeFragment(frag);\n          }\n        } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {\n          // Stop gap for bad tracker / buffer flush behavior\n          fragmentTracker.removeAllFragments();\n        } else if (fragmentTracker.hasParts(frag.type)) {\n          // In low latency mode, remove fragments for which only some parts were buffered\n          fragmentTracker.detectPartialFragments({\n            frag: frag,\n            part: null,\n            stats: frag.stats,\n            id: frag.type\n          });\n          if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {\n            fragmentTracker.removeFragment(frag);\n          }\n        }\n      };\n      _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {\n        if (type === void 0) {\n          type = null;\n        }\n        if (!(startOffset - endOffset)) {\n          return;\n        }\n        // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n        // passing a null type flushes both buffers\n        var flushScope = {\n          startOffset: startOffset,\n          endOffset: endOffset,\n          type: type\n        };\n        this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);\n      };\n      _proto._loadInitSegment = function _loadInitSegment(frag, level) {\n        var _this3 = this;\n        this._doFragLoad(frag, level).then(function (data) {\n          if (!data || _this3.fragContextChanged(frag) || !_this3.levels) {\n            throw new Error('init load aborted');\n          }\n          return data;\n        }).then(function (data) {\n          var hls = _this3.hls;\n          var payload = data.payload;\n          var decryptData = frag.decryptdata;\n\n          // check to see if the payload needs to be decrypted\n          if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n            var startTime = self.performance.now();\n            // decrypt init segment data\n            return _this3.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(function (err) {\n              hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.FRAG_DECRYPT_ERROR,\n                fatal: false,\n                error: err,\n                reason: err.message,\n                frag: frag\n              });\n              throw err;\n            }).then(function (decryptedData) {\n              var endTime = self.performance.now();\n              hls.trigger(Events.FRAG_DECRYPTED, {\n                frag: frag,\n                payload: decryptedData,\n                stats: {\n                  tstart: startTime,\n                  tdecrypt: endTime\n                }\n              });\n              data.payload = decryptedData;\n              return data;\n            });\n          }\n          return data;\n        }).then(function (data) {\n          var fragCurrent = _this3.fragCurrent,\n            hls = _this3.hls,\n            levels = _this3.levels;\n          if (!levels) {\n            throw new Error('init load aborted, missing levels');\n          }\n          var stats = frag.stats;\n          _this3.state = State.IDLE;\n          level.fragmentError = 0;\n          frag.data = new Uint8Array(data.payload);\n          stats.parsing.start = stats.buffering.start = self.performance.now();\n          stats.parsing.end = stats.buffering.end = self.performance.now();\n\n          // Silence FRAG_BUFFERED event if fragCurrent is null\n          if (data.frag === fragCurrent) {\n            hls.trigger(Events.FRAG_BUFFERED, {\n              stats: stats,\n              frag: fragCurrent,\n              part: null,\n              id: frag.type\n            });\n          }\n          _this3.tick();\n        }).catch(function (reason) {\n          if (_this3.state === State.STOPPED || _this3.state === State.ERROR) {\n            return;\n          }\n          _this3.warn(reason);\n          _this3.resetFragmentLoading(frag);\n        });\n      };\n      _proto.fragContextChanged = function fragContextChanged(frag) {\n        var fragCurrent = this.fragCurrent;\n        return !frag || !fragCurrent || frag.level !== fragCurrent.level || frag.sn !== fragCurrent.sn || frag.urlId !== fragCurrent.urlId;\n      };\n      _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {\n        var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;\n        var media = this.mediaBuffer ? this.mediaBuffer : this.media;\n        this.log(\"Buffered \" + frag.type + \" sn: \" + frag.sn + (part ? ' part: ' + part.index : '') + \" of \" + (this.playlistType === PlaylistLevelType.MAIN ? 'level' : 'track') + \" \" + frag.level + \" (frag:[\" + ((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3) + \"-\" + ((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3) + \"] > buffer:\" + (media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : '(detached)') + \")\");\n        this.state = State.IDLE;\n        if (!media) {\n          return;\n        }\n        if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {\n          this.loadedmetadata = true;\n          this.seekToStartPos();\n        }\n        this.tick();\n      };\n      _proto.seekToStartPos = function seekToStartPos() {};\n      _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {\n        var transmuxer = this.transmuxer;\n        if (!transmuxer) {\n          return;\n        }\n        var frag = fragLoadedEndData.frag,\n          part = fragLoadedEndData.part,\n          partsLoaded = fragLoadedEndData.partsLoaded;\n        // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n        var complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(function (fragLoaded) {\n          return !fragLoaded;\n        });\n        var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n        transmuxer.flush(chunkMeta);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      ;\n\n      _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {};\n      _proto._doFragLoad = function _doFragLoad(frag, level, targetBufferTime, progressCallback) {\n        var _frag$decryptdata,\n          _this4 = this;\n        if (targetBufferTime === void 0) {\n          targetBufferTime = null;\n        }\n        var details = level == null ? void 0 : level.details;\n        if (!this.levels || !details) {\n          throw new Error(\"frag load aborted, missing level\" + (details ? '' : ' detail') + \"s\");\n        }\n        var keyLoadingPromise = null;\n        if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {\n          this.log(\"Loading key for \" + frag.sn + \" of [\" + details.startSN + \"-\" + details.endSN + \"], \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \" \" + frag.level);\n          this.state = State.KEY_LOADING;\n          this.fragCurrent = frag;\n          keyLoadingPromise = this.keyLoader.load(frag).then(function (keyLoadedData) {\n            if (!_this4.fragContextChanged(keyLoadedData.frag)) {\n              _this4.hls.trigger(Events.KEY_LOADED, keyLoadedData);\n              if (_this4.state === State.KEY_LOADING) {\n                _this4.state = State.IDLE;\n              }\n              return keyLoadedData;\n            }\n          });\n          this.hls.trigger(Events.KEY_LOADING, {\n            frag: frag\n          });\n          if (this.fragCurrent === null) {\n            keyLoadingPromise = Promise.reject(new Error(\"frag load aborted, context changed in KEY_LOADING\"));\n          }\n        } else if (!frag.encrypted && details.encryptedFragments.length) {\n          this.keyLoader.loadClear(frag, details.encryptedFragments);\n        }\n        targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n        if (this.config.lowLatencyMode && frag.sn !== 'initSegment') {\n          var partList = details.partList;\n          if (partList && progressCallback) {\n            if (targetBufferTime > frag.end && details.fragmentHint) {\n              frag = details.fragmentHint;\n            }\n            var partIndex = this.getNextPart(partList, frag, targetBufferTime);\n            if (partIndex > -1) {\n              var part = partList[partIndex];\n              this.log(\"Loading part sn: \" + frag.sn + \" p: \" + part.index + \" cc: \" + frag.cc + \" of playlist [\" + details.startSN + \"-\" + details.endSN + \"] parts [0-\" + partIndex + \"-\" + (partList.length - 1) + \"] \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \": \" + frag.level + \", target: \" + parseFloat(targetBufferTime.toFixed(3)));\n              this.nextLoadPosition = part.start + part.duration;\n              this.state = State.FRAG_LOADING;\n              var _result;\n              if (keyLoadingPromise) {\n                _result = keyLoadingPromise.then(function (keyLoadedData) {\n                  if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData.frag)) {\n                    return null;\n                  }\n                  return _this4.doFragPartsLoad(frag, part, level, progressCallback);\n                }).catch(function (error) {\n                  return _this4.handleFragLoadError(error);\n                });\n              } else {\n                _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(function (error) {\n                  return _this4.handleFragLoadError(error);\n                });\n              }\n              this.hls.trigger(Events.FRAG_LOADING, {\n                frag: frag,\n                part: part,\n                targetBufferTime: targetBufferTime\n              });\n              if (this.fragCurrent === null) {\n                return Promise.reject(new Error(\"frag load aborted, context changed in FRAG_LOADING parts\"));\n              }\n              return _result;\n            } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n              // Fragment hint has no parts\n              return Promise.resolve(null);\n            }\n          }\n        }\n        this.log(\"Loading fragment \" + frag.sn + \" cc: \" + frag.cc + \" \" + (details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : '') + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \": \" + frag.level + \", target: \" + parseFloat(targetBufferTime.toFixed(3)));\n        // Don't update nextLoadPosition for fragments which are not buffered\n        if (isFiniteNumber(frag.sn) && !this.bitrateTest) {\n          this.nextLoadPosition = frag.start + frag.duration;\n        }\n        this.state = State.FRAG_LOADING;\n\n        // Load key before streaming fragment data\n        var dataOnProgress = this.config.progressive;\n        var result;\n        if (dataOnProgress && keyLoadingPromise) {\n          result = keyLoadingPromise.then(function (keyLoadedData) {\n            if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {\n              return null;\n            }\n            return _this4.fragmentLoader.load(frag, progressCallback);\n          }).catch(function (error) {\n            return _this4.handleFragLoadError(error);\n          });\n        } else {\n          // load unencrypted fragment data with progress event,\n          // or handle fragment result after key and fragment are finished loading\n          result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(function (_ref) {\n            var fragLoadedData = _ref[0];\n            if (!dataOnProgress && fragLoadedData && progressCallback) {\n              progressCallback(fragLoadedData);\n            }\n            return fragLoadedData;\n          }).catch(function (error) {\n            return _this4.handleFragLoadError(error);\n          });\n        }\n        this.hls.trigger(Events.FRAG_LOADING, {\n          frag: frag,\n          targetBufferTime: targetBufferTime\n        });\n        if (this.fragCurrent === null) {\n          return Promise.reject(new Error(\"frag load aborted, context changed in FRAG_LOADING\"));\n        }\n        return result;\n      };\n      _proto.doFragPartsLoad = function doFragPartsLoad(frag, fromPart, level, progressCallback) {\n        var _this5 = this;\n        return new Promise(function (resolve, reject) {\n          var _level$details;\n          var partsLoaded = [];\n          var initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;\n          var loadPart = function loadPart(part) {\n            _this5.fragmentLoader.loadPart(frag, part, progressCallback).then(function (partLoadedData) {\n              partsLoaded[part.index] = partLoadedData;\n              var loadedPart = partLoadedData.part;\n              _this5.hls.trigger(Events.FRAG_LOADED, partLoadedData);\n              var nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);\n              if (nextPart) {\n                loadPart(nextPart);\n              } else {\n                return resolve({\n                  frag: frag,\n                  part: loadedPart,\n                  partsLoaded: partsLoaded\n                });\n              }\n            }).catch(reject);\n          };\n          loadPart(fromPart);\n        });\n      };\n      _proto.handleFragLoadError = function handleFragLoadError(error) {\n        if ('data' in error) {\n          var data = error.data;\n          if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {\n            this.handleFragLoadAborted(data.frag, data.part);\n          } else {\n            this.hls.trigger(Events.ERROR, data);\n          }\n        } else {\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.OTHER_ERROR,\n            details: ErrorDetails.INTERNAL_EXCEPTION,\n            err: error,\n            error: error,\n            fatal: true\n          });\n        }\n        return null;\n      };\n      _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {\n        var context = this.getCurrentContext(chunkMeta);\n        if (!context || this.state !== State.PARSING) {\n          if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n            this.state = State.IDLE;\n          }\n          return;\n        }\n        var frag = context.frag,\n          part = context.part,\n          level = context.level;\n        var now = self.performance.now();\n        frag.stats.parsing.end = now;\n        if (part) {\n          part.stats.parsing.end = now;\n        }\n        this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n      };\n      _proto.getCurrentContext = function getCurrentContext(chunkMeta) {\n        var levels = this.levels,\n          fragCurrent = this.fragCurrent;\n        var levelIndex = chunkMeta.level,\n          sn = chunkMeta.sn,\n          partIndex = chunkMeta.part;\n        if (!(levels != null && levels[levelIndex])) {\n          this.warn(\"Levels object was unset while buffering fragment \" + sn + \" of level \" + levelIndex + \". The current chunk will not be buffered.\");\n          return null;\n        }\n        var level = levels[levelIndex];\n        var part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;\n        var frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);\n        if (!frag) {\n          return null;\n        }\n        if (fragCurrent && fragCurrent !== frag) {\n          frag.stats = fragCurrent.stats;\n        }\n        return {\n          frag: frag,\n          part: part,\n          level: level\n        };\n      };\n      _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta) {\n        var _buffer;\n        if (!data || this.state !== State.PARSING) {\n          return;\n        }\n        var data1 = data.data1,\n          data2 = data.data2;\n        var buffer = data1;\n        if (data1 && data2) {\n          // Combine the moof + mdat so that we buffer with a single append\n          buffer = appendUint8Array(data1, data2);\n        }\n        if (!((_buffer = buffer) != null && _buffer.length)) {\n          return;\n        }\n        var segment = {\n          type: data.type,\n          frag: frag,\n          part: part,\n          chunkMeta: chunkMeta,\n          parent: frag.type,\n          data: buffer\n        };\n        this.hls.trigger(Events.BUFFER_APPENDING, segment);\n        if (data.dropped && data.independent && !part) {\n          // Clear buffer so that we reload previous segments sequentially if required\n          this.flushBufferGap(frag);\n        }\n      };\n      _proto.flushBufferGap = function flushBufferGap(frag) {\n        var media = this.media;\n        if (!media) {\n          return;\n        }\n        // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n        if (!BufferHelper.isBuffered(media, media.currentTime)) {\n          this.flushMainBuffer(0, frag.start);\n          return;\n        }\n        // Remove back-buffer without interrupting playback to allow back tracking\n        var currentTime = media.currentTime;\n        var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n        var fragDuration = frag.duration;\n        var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n        var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n        if (frag.start - start > segmentFraction) {\n          this.flushMainBuffer(start, frag.start);\n        }\n      };\n      _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {\n        var pos = this.getLoadPosition();\n        if (!isFiniteNumber(pos)) {\n          return null;\n        }\n        return this.getFwdBufferInfoAtPos(bufferable, pos, type);\n      };\n      _proto.getFwdBufferInfoAtPos = function getFwdBufferInfoAtPos(bufferable, pos, type) {\n        var maxBufferHole = this.config.maxBufferHole;\n        var bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);\n        // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n        if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n          var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n          if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {\n            return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));\n          }\n        }\n        return bufferInfo;\n      };\n      _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {\n        var config = this.config;\n        var maxBufLen;\n        if (levelBitrate) {\n          maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n        } else {\n          maxBufLen = config.maxBufferLength;\n        }\n        return Math.min(maxBufLen, config.maxMaxBufferLength);\n      };\n      _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold) {\n        var config = this.config;\n        var minLength = threshold || config.maxBufferLength;\n        if (config.maxMaxBufferLength >= minLength) {\n          // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n          config.maxMaxBufferLength /= 2;\n          this.warn(\"Reduce max buffer length to \" + config.maxMaxBufferLength + \"s\");\n          return true;\n        }\n        return false;\n      };\n      _proto.getAppendedFrag = function getAppendedFrag(position, playlistType) {\n        var fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);\n        if (fragOrPart && 'fragment' in fragOrPart) {\n          return fragOrPart.fragment;\n        }\n        return fragOrPart;\n      };\n      _proto.getNextFragment = function getNextFragment(pos, levelDetails) {\n        var fragments = levelDetails.fragments;\n        var fragLen = fragments.length;\n        if (!fragLen) {\n          return null;\n        }\n\n        // find fragment index, contiguous with end of buffer position\n        var config = this.config;\n        var start = fragments[0].start;\n        var frag;\n        if (levelDetails.live) {\n          var initialLiveManifestSize = config.initialLiveManifestSize;\n          if (fragLen < initialLiveManifestSize) {\n            this.warn(\"Not enough fragments to start playback (have: \" + fragLen + \", need: \" + initialLiveManifestSize + \")\");\n            return null;\n          }\n          // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n          // In order to discover the range, we load the best matching fragment for that level and demux it.\n          // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n          // we get the fragment matching that start time\n          if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1) {\n            frag = this.getInitialLiveFragment(levelDetails, fragments);\n            this.startPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;\n          }\n        } else if (pos <= start) {\n          // VoD playlist: if loadPosition before start of playlist, load first fragment\n          frag = fragments[0];\n        }\n\n        // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n        if (!frag) {\n          var end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;\n          frag = this.getFragmentAtPosition(pos, end, levelDetails);\n        }\n        return this.mapToInitFragWhenRequired(frag);\n      };\n      _proto.isLoopLoading = function isLoopLoading(frag, targetBufferTime) {\n        var trackerState = this.fragmentTracker.getState(frag);\n        return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;\n      };\n      _proto.getNextFragmentLoopLoading = function getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {\n        var gapStart = frag.gap;\n        var nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);\n        if (nextFragment === null) {\n          return nextFragment;\n        }\n        frag = nextFragment;\n        if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {\n          // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length\n          var nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);\n          if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {\n            // Returning here might result in not finding an audio and video candiate to skip to\n            this.log(\"buffer full after gaps in \\\"\" + playlistType + \"\\\" playlist starting at sn: \" + frag.sn);\n            return null;\n          }\n        }\n        return frag;\n      };\n      _proto.mapToInitFragWhenRequired = function mapToInitFragWhenRequired(frag) {\n        // If an initSegment is present, it must be buffered first\n        if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {\n          return frag.initSegment;\n        }\n        return frag;\n      };\n      _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {\n        var nextPart = -1;\n        var contiguous = false;\n        var independentAttrOmitted = true;\n        for (var i = 0, len = partList.length; i < len; i++) {\n          var part = partList[i];\n          independentAttrOmitted = independentAttrOmitted && !part.independent;\n          if (nextPart > -1 && targetBufferTime < part.start) {\n            break;\n          }\n          var loaded = part.loaded;\n          if (loaded) {\n            nextPart = -1;\n          } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n            nextPart = i;\n          }\n          contiguous = loaded;\n        }\n        return nextPart;\n      };\n      _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {\n        var lastPart = partList[partList.length - 1];\n        return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n      }\n\n      /*\n       This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n       \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n       start and end times for each fragment in the playlist (after which this method will not need to be called).\n      */;\n      _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails, fragments) {\n        var fragPrevious = this.fragPrevious;\n        var frag = null;\n        if (fragPrevious) {\n          if (levelDetails.hasProgramDateTime) {\n            // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n            this.log(\"Live playlist, switching playlist, load frag with same PDT: \" + fragPrevious.programDateTime);\n            frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n          }\n          if (!frag) {\n            // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n            var targetSN = fragPrevious.sn + 1;\n            if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n              var fragNext = fragments[targetSN - levelDetails.startSN];\n              // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n              if (fragPrevious.cc === fragNext.cc) {\n                frag = fragNext;\n                this.log(\"Live playlist, switching playlist, load frag with next SN: \" + frag.sn);\n              }\n            }\n            // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n            // will have the wrong start times\n            if (!frag) {\n              frag = findFragWithCC(fragments, fragPrevious.cc);\n              if (frag) {\n                this.log(\"Live playlist, switching playlist, load frag with same CC: \" + frag.sn);\n              }\n            }\n          }\n        } else {\n          // Find a new start fragment when fragPrevious is null\n          var liveStart = this.hls.liveSyncPosition;\n          if (liveStart !== null) {\n            frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n          }\n        }\n        return frag;\n      }\n\n      /*\n      This method finds the best matching fragment given the provided position.\n       */;\n      _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {\n        var config = this.config;\n        var fragPrevious = this.fragPrevious;\n        var fragments = levelDetails.fragments,\n          endSN = levelDetails.endSN;\n        var fragmentHint = levelDetails.fragmentHint;\n        var tolerance = config.maxFragLookUpTolerance;\n        var partList = levelDetails.partList;\n        var loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);\n        if (loadingParts && fragmentHint && !this.bitrateTest) {\n          // Include incomplete fragment with parts at end\n          fragments = fragments.concat(fragmentHint);\n          endSN = fragmentHint.sn;\n        }\n        var frag;\n        if (bufferEnd < end) {\n          var lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;\n          // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n          // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n          frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);\n        } else {\n          // reach end of playlist\n          frag = fragments[fragments.length - 1];\n        }\n        if (frag) {\n          var curSNIdx = frag.sn - levelDetails.startSN;\n          // Move fragPrevious forward to support forcing the next fragment to load\n          // when the buffer catches up to a previously buffered range.\n          var fragState = this.fragmentTracker.getState(frag);\n          if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {\n            fragPrevious = frag;\n          }\n          if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {\n            // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n            // non-uniform fragment durations\n            var sameLevel = fragPrevious && frag.level === fragPrevious.level;\n            if (sameLevel) {\n              var nextFrag = fragments[curSNIdx + 1];\n              if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {\n                frag = nextFrag;\n              } else {\n                frag = null;\n              }\n            }\n          }\n        }\n        return frag;\n      };\n      _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {\n        var config = this.config,\n          media = this.media;\n        if (!media) {\n          return;\n        }\n        var liveSyncPosition = this.hls.liveSyncPosition;\n        var currentTime = media.currentTime;\n        var start = levelDetails.fragments[0].start;\n        var end = levelDetails.edge;\n        var withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n        // Continue if we can seek forward to sync position or if current time is outside of sliding window\n        if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n          // Continue if buffer is starving or if current time is behind max latency\n          var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n          if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n            if (!this.loadedmetadata) {\n              this.nextLoadPosition = liveSyncPosition;\n            }\n            // Only seek if ready and there is not a significant forward buffer available for playback\n            if (media.readyState) {\n              this.warn(\"Playback: \" + currentTime.toFixed(3) + \" is located too far from the end of live sliding playlist: \" + end + \", reset currentTime to : \" + liveSyncPosition.toFixed(3));\n              media.currentTime = liveSyncPosition;\n            }\n          }\n        }\n      };\n      _proto.alignPlaylists = function alignPlaylists(details, previousDetails) {\n        var levels = this.levels,\n          levelLastLoaded = this.levelLastLoaded,\n          fragPrevious = this.fragPrevious;\n        var lastLevel = levelLastLoaded !== null ? levels[levelLastLoaded] : null;\n\n        // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n        //  this could all go in level-helper mergeDetails()\n        var length = details.fragments.length;\n        if (!length) {\n          this.warn(\"No fragments in live playlist\");\n          return 0;\n        }\n        var slidingStart = details.fragments[0].start;\n        var firstLevelLoad = !previousDetails;\n        var aligned = details.alignedSliding && isFiniteNumber(slidingStart);\n        if (firstLevelLoad || !aligned && !slidingStart) {\n          alignStream(fragPrevious, lastLevel, details);\n          var alignedSlidingStart = details.fragments[0].start;\n          this.log(\"Live playlist sliding: \" + alignedSlidingStart.toFixed(2) + \" start-sn: \" + (previousDetails ? previousDetails.startSN : 'na') + \"->\" + details.startSN + \" prev-sn: \" + (fragPrevious ? fragPrevious.sn : 'na') + \" fragments: \" + length);\n          return alignedSlidingStart;\n        }\n        return slidingStart;\n      };\n      _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {\n        // Wait for Low-Latency CDN Tune-in to get an updated playlist\n        var advancePartLimit = 3;\n        return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n      };\n      _proto.setStartPosition = function setStartPosition(details, sliding) {\n        // compute start position if set to -1. use it straight away if value is defined\n        var startPosition = this.startPosition;\n        if (startPosition < sliding) {\n          startPosition = -1;\n        }\n        if (startPosition === -1 || this.lastCurrentTime === -1) {\n          // Use Playlist EXT-X-START:TIME-OFFSET when set\n          // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match\n          var offsetInMultivariantPlaylist = this.startTimeOffset !== null;\n          var startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;\n          if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {\n            startPosition = sliding + startTimeOffset;\n            if (startTimeOffset < 0) {\n              startPosition += details.totalduration;\n            }\n            startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n            this.log(\"Start time offset \" + startTimeOffset + \" found in \" + (offsetInMultivariantPlaylist ? 'multivariant' : 'media') + \" playlist, adjust startPosition to \" + startPosition);\n            this.startPosition = startPosition;\n          } else if (details.live) {\n            // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n            // not been specified via the config or an as an argument to startLoad (#3736).\n            startPosition = this.hls.liveSyncPosition || sliding;\n          } else {\n            this.startPosition = startPosition = 0;\n          }\n          this.lastCurrentTime = startPosition;\n        }\n        this.nextLoadPosition = startPosition;\n      };\n      _proto.getLoadPosition = function getLoadPosition() {\n        var media = this.media;\n        // if we have not yet loaded any fragment, start loading from start position\n        var pos = 0;\n        if (this.loadedmetadata && media) {\n          pos = media.currentTime;\n        } else if (this.nextLoadPosition) {\n          pos = this.nextLoadPosition;\n        }\n        return pos;\n      };\n      _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {\n        if (this.transmuxer && frag.sn !== 'initSegment' && frag.stats.aborted) {\n          this.warn(\"Fragment \" + frag.sn + (part ? ' part ' + part.index : '') + \" of level \" + frag.level + \" was aborted\");\n          this.resetFragmentLoading(frag);\n        }\n      };\n      _proto.resetFragmentLoading = function resetFragmentLoading(frag) {\n        if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n          this.state = State.IDLE;\n        }\n      };\n      _proto.onFragmentOrKeyLoadError = function onFragmentOrKeyLoadError(filterType, data) {\n        if (data.chunkMeta && !data.frag) {\n          var context = this.getCurrentContext(data.chunkMeta);\n          if (context) {\n            data.frag = context.frag;\n          }\n        }\n        var frag = data.frag;\n        // Handle frag error related to caller's filterType\n        if (!frag || frag.type !== filterType || !this.levels) {\n          return;\n        }\n        if (this.fragContextChanged(frag)) {\n          var _this$fragCurrent2;\n          this.warn(\"Frag load error must match current frag to retry \" + frag.url + \" > \" + ((_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url));\n          return;\n        }\n        var gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;\n        if (gapTagEncountered) {\n          this.fragmentTracker.fragBuffered(frag, true);\n        }\n        // keep retrying until the limit will be reached\n        var errorAction = data.errorAction;\n        var _ref2 = errorAction || {},\n          action = _ref2.action,\n          _ref2$retryCount = _ref2.retryCount,\n          retryCount = _ref2$retryCount === void 0 ? 0 : _ref2$retryCount,\n          retryConfig = _ref2.retryConfig;\n        if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {\n          if (!this.loadedmetadata) {\n            this.startFragRequested = false;\n            this.nextLoadPosition = this.startPosition;\n          }\n          var delay = getRetryDelay(retryConfig, retryCount);\n          this.warn(\"Fragment \" + frag.sn + \" of \" + filterType + \" \" + frag.level + \" errored with \" + data.details + \", retrying loading \" + (retryCount + 1) + \"/\" + retryConfig.maxNumRetry + \" in \" + delay + \"ms\");\n          errorAction.resolved = true;\n          this.retryDate = self.performance.now() + delay;\n          this.state = State.FRAG_LOADING_WAITING_RETRY;\n        } else if (retryConfig && errorAction) {\n          this.resetFragmentErrors(filterType);\n          if (retryCount < retryConfig.maxNumRetry) {\n            // Network retry is skipped when level switch is preferred\n            if (!gapTagEncountered) {\n              errorAction.resolved = true;\n            }\n          } else {\n            logger.warn(data.details + \" reached or exceeded max retry (\" + retryCount + \")\");\n          }\n        } else {\n          this.state = State.ERROR;\n        }\n        // Perform next async tick sooner to speed up error action resolution\n        this.tickImmediate();\n      };\n      _proto.reduceLengthAndFlushBuffer = function reduceLengthAndFlushBuffer(data) {\n        // if in appending state\n        if (this.state === State.PARSING || this.state === State.PARSED) {\n          var playlistType = data.parent;\n          var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n          // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n          // reduce max buf len if current position is buffered\n          var buffered = bufferedInfo && bufferedInfo.len > 0.5;\n          if (buffered) {\n            this.reduceMaxBufferLength(bufferedInfo.len);\n          }\n          var flushBuffer = !buffered;\n          if (flushBuffer) {\n            // current position is not buffered, but browser is still complaining about buffer full error\n            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n            // in that case flush the whole audio buffer to recover\n            this.warn(\"Buffer full error while media.currentTime is not buffered, flush \" + playlistType + \" buffer\");\n          }\n          if (data.frag) {\n            this.fragmentTracker.removeFragment(data.frag);\n            this.nextLoadPosition = data.frag.start;\n          }\n          this.resetLoadingState();\n          return flushBuffer;\n        }\n        return false;\n      };\n      _proto.resetFragmentErrors = function resetFragmentErrors(filterType) {\n        if (filterType === PlaylistLevelType.AUDIO) {\n          // Reset current fragment since audio track audio is essential and may not have a fail-over track\n          this.fragCurrent = null;\n        }\n        // Fragment errors that result in a level switch or redundant fail-over\n        // should reset the stream controller state to idle\n        if (!this.loadedmetadata) {\n          this.startFragRequested = false;\n        }\n        if (this.state !== State.STOPPED) {\n          this.state = State.IDLE;\n        }\n      };\n      _proto.afterBufferFlushed = function afterBufferFlushed(media, bufferType, playlistType) {\n        if (!media) {\n          return;\n        }\n        // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n        // (so that we will check against video.buffered ranges in case of alt audio track)\n        var bufferedTimeRanges = BufferHelper.getBuffered(media);\n        this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n        if (this.state === State.ENDED) {\n          this.resetLoadingState();\n        }\n      };\n      _proto.resetLoadingState = function resetLoadingState() {\n        this.log('Reset loading state');\n        this.fragCurrent = null;\n        this.fragPrevious = null;\n        this.state = State.IDLE;\n      };\n      _proto.resetStartWhenNotLoaded = function resetStartWhenNotLoaded(level) {\n        // if loadedmetadata is not set, it means that first frag request failed\n        // in that case, reset startFragRequested flag\n        if (!this.loadedmetadata) {\n          this.startFragRequested = false;\n          var details = this.levels ? this.levels[level].details : null;\n          if (details != null && details.live) {\n            // Update the start position and return to IDLE to recover live start\n            this.startPosition = -1;\n            this.setStartPosition(details, 0);\n            this.resetLoadingState();\n          } else {\n            this.nextLoadPosition = this.startPosition;\n          }\n        }\n      };\n      _proto.resetWhenMissingContext = function resetWhenMissingContext(chunkMeta) {\n        this.warn(\"The loading context changed while buffering fragment \" + chunkMeta.sn + \" of level \" + chunkMeta.level + \". This chunk will not be buffered.\");\n        this.removeUnbufferedFrags();\n        this.resetStartWhenNotLoaded(chunkMeta.level);\n        this.resetLoadingState();\n      };\n      _proto.removeUnbufferedFrags = function removeUnbufferedFrags(start) {\n        if (start === void 0) {\n          start = 0;\n        }\n        this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);\n      };\n      _proto.updateLevelTiming = function updateLevelTiming(frag, part, level, partial) {\n        var _this6 = this,\n          _this$transmuxer;\n        var details = level.details;\n        if (!details) {\n          this.warn('level.details undefined');\n          return;\n        }\n        var parsed = Object.keys(frag.elementaryStreams).reduce(function (result, type) {\n          var info = frag.elementaryStreams[type];\n          if (info) {\n            var parsedDuration = info.endPTS - info.startPTS;\n            if (parsedDuration <= 0) {\n              // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n              // The new transmuxer will be configured with a time offset matching the next fragment start,\n              // preventing the timeline from shifting.\n              _this6.warn(\"Could not parse fragment \" + frag.sn + \" \" + type + \" duration reliably (\" + parsedDuration + \")\");\n              return result || false;\n            }\n            var drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n            _this6.hls.trigger(Events.LEVEL_PTS_UPDATED, {\n              details: details,\n              level: level,\n              drift: drift,\n              type: type,\n              frag: frag,\n              start: info.startPTS,\n              end: info.endPTS\n            });\n            return true;\n          }\n          return result;\n        }, false);\n        if (parsed) {\n          level.fragmentError = 0;\n        } else if (((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {\n          var error = new Error(\"Found no media in fragment \" + frag.sn + \" of level \" + level.id + \" resetting transmuxer to fallback to playlist timing\");\n          this.warn(error.message);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: false,\n            error: error,\n            frag: frag,\n            reason: \"Found no media in msn \" + frag.sn + \" of level \\\"\" + level.url + \"\\\"\"\n          });\n          if (!this.hls) {\n            return;\n          }\n          this.resetTransmuxer();\n          // For this error fallthrough. Marking parsed will allow advancing to next fragment.\n        }\n\n        this.state = State.PARSED;\n        this.hls.trigger(Events.FRAG_PARSED, {\n          frag: frag,\n          part: part\n        });\n      };\n      _proto.resetTransmuxer = function resetTransmuxer() {\n        if (this.transmuxer) {\n          this.transmuxer.destroy();\n          this.transmuxer = null;\n        }\n      };\n      _proto.recoverWorkerError = function recoverWorkerError(data) {\n        if (data.event === 'demuxerWorker') {\n          this.resetTransmuxer();\n          this.resetLoadingState();\n        }\n      };\n      _createClass(BaseStreamController, [{\n        key: \"state\",\n        get: function get() {\n          return this._state;\n        },\n        set: function set(nextState) {\n          var previousState = this._state;\n          if (previousState !== nextState) {\n            this._state = nextState;\n            this.log(previousState + \"->\" + nextState);\n          }\n        }\n      }]);\n      return BaseStreamController;\n    }(TaskLoop);\n    function getSourceBuffer() {\n      return self.SourceBuffer || self.WebKitSourceBuffer;\n    }\n\n    /**\n     * @ignore\n     */\n    function isSupported() {\n      var mediaSource = getMediaSource();\n      if (!mediaSource) {\n        return false;\n      }\n      var sourceBuffer = getSourceBuffer();\n      var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n\n      // if SourceBuffer is exposed ensure its API is valid\n      // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n      var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n      return !!isTypeSupported && !!sourceBufferValidAPI;\n    }\n\n    /**\n     * @ignore\n     */\n    function changeTypeSupported() {\n      var _sourceBuffer$prototy;\n      var sourceBuffer = getSourceBuffer();\n      return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n    }\n    function dummyTrack(type, inputTimeScale) {\n      if (type === void 0) {\n        type = '';\n      }\n      if (inputTimeScale === void 0) {\n        inputTimeScale = 90000;\n      }\n      return {\n        type: type,\n        id: -1,\n        pid: -1,\n        inputTimeScale: inputTimeScale,\n        sequenceNumber: -1,\n        samples: [],\n        dropped: 0\n      };\n    }\n    var BaseAudioDemuxer = /*#__PURE__*/function () {\n      function BaseAudioDemuxer() {\n        this._audioTrack = void 0;\n        this._id3Track = void 0;\n        this.frameIndex = 0;\n        this.cachedData = null;\n        this.basePTS = null;\n        this.initPTS = null;\n        this.lastPTS = null;\n      }\n      var _proto = BaseAudioDemuxer.prototype;\n      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        this._id3Track = {\n          type: 'id3',\n          id: 3,\n          pid: -1,\n          inputTimeScale: 90000,\n          sequenceNumber: 0,\n          samples: [],\n          dropped: 0\n        };\n      };\n      _proto.resetTimeStamp = function resetTimeStamp(deaultTimestamp) {\n        this.initPTS = deaultTimestamp;\n        this.resetContiguity();\n      };\n      _proto.resetContiguity = function resetContiguity() {\n        this.basePTS = null;\n        this.lastPTS = null;\n        this.frameIndex = 0;\n      };\n      _proto.canParse = function canParse(data, offset) {\n        return false;\n      };\n      _proto.appendFrame = function appendFrame(track, data, offset) {}\n\n      // feed incoming data to the front of the parsing pipeline\n      ;\n\n      _proto.demux = function demux(data, timeOffset) {\n        if (this.cachedData) {\n          data = appendUint8Array(this.cachedData, data);\n          this.cachedData = null;\n        }\n        var id3Data = getID3Data(data, 0);\n        var offset = id3Data ? id3Data.length : 0;\n        var lastDataIndex;\n        var track = this._audioTrack;\n        var id3Track = this._id3Track;\n        var timestamp = id3Data ? getTimeStamp(id3Data) : undefined;\n        var length = data.length;\n        if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {\n          this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n          this.lastPTS = this.basePTS;\n        }\n        if (this.lastPTS === null) {\n          this.lastPTS = this.basePTS;\n        }\n\n        // more expressive than alternative: id3Data?.length\n        if (id3Data && id3Data.length > 0) {\n          id3Track.samples.push({\n            pts: this.lastPTS,\n            dts: this.lastPTS,\n            data: id3Data,\n            type: MetadataSchema.audioId3,\n            duration: Number.POSITIVE_INFINITY\n          });\n        }\n        while (offset < length) {\n          if (this.canParse(data, offset)) {\n            var frame = this.appendFrame(track, data, offset);\n            if (frame) {\n              this.frameIndex++;\n              this.lastPTS = frame.sample.pts;\n              offset += frame.length;\n              lastDataIndex = offset;\n            } else {\n              offset = length;\n            }\n          } else if (canParse$2(data, offset)) {\n            // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n            id3Data = getID3Data(data, offset);\n            id3Track.samples.push({\n              pts: this.lastPTS,\n              dts: this.lastPTS,\n              data: id3Data,\n              type: MetadataSchema.audioId3,\n              duration: Number.POSITIVE_INFINITY\n            });\n            offset += id3Data.length;\n            lastDataIndex = offset;\n          } else {\n            offset++;\n          }\n          if (offset === length && lastDataIndex !== length) {\n            var partialData = sliceUint8(data, lastDataIndex);\n            if (this.cachedData) {\n              this.cachedData = appendUint8Array(this.cachedData, partialData);\n            } else {\n              this.cachedData = partialData;\n            }\n          }\n        }\n        return {\n          audioTrack: track,\n          videoTrack: dummyTrack(),\n          id3Track: id3Track,\n          textTrack: dummyTrack()\n        };\n      };\n      _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n        return Promise.reject(new Error(\"[\" + this + \"] This demuxer does not support Sample-AES decryption\"));\n      };\n      _proto.flush = function flush(timeOffset) {\n        // Parse cache in case of remaining frames.\n        var cachedData = this.cachedData;\n        if (cachedData) {\n          this.cachedData = null;\n          this.demux(cachedData, 0);\n        }\n        return {\n          audioTrack: this._audioTrack,\n          videoTrack: dummyTrack(),\n          id3Track: this._id3Track,\n          textTrack: dummyTrack()\n        };\n      };\n      _proto.destroy = function destroy() {};\n      return BaseAudioDemuxer;\n    }();\n    /**\n     * Initialize PTS\n     * <p>\n     *    use timestamp unless it is undefined, NaN or Infinity\n     * </p>\n     */\n    var initPTSFn = function initPTSFn(timestamp, timeOffset, initPTS) {\n      if (isFiniteNumber(timestamp)) {\n        return timestamp * 90;\n      }\n      var init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;\n      return timeOffset * 90000 + init90kHz;\n    };\n\n    /**\n     * ADTS parser helper\n     * @link https://wiki.multimedia.cx/index.php?title=ADTS\n     */\n    function getAudioConfig(observer, data, offset, audioCodec) {\n      var adtsObjectType;\n      var adtsExtensionSamplingIndex;\n      var adtsChannelConfig;\n      var config;\n      var userAgent = navigator.userAgent.toLowerCase();\n      var manifestCodec = audioCodec;\n      var adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n      // byte 2\n      adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n      var adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\n      if (adtsSamplingIndex > adtsSamplingRates.length - 1) {\n        observer.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: true,\n          reason: \"invalid ADTS sampling index:\" + adtsSamplingIndex\n        });\n        return;\n      }\n      adtsChannelConfig = (data[offset + 2] & 0x01) << 2;\n      // byte 3\n      adtsChannelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n      logger.log(\"manifest codec:\" + audioCodec + \", ADTS type:\" + adtsObjectType + \", samplingIndex:\" + adtsSamplingIndex);\n      // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n      if (/firefox/i.test(userAgent)) {\n        if (adtsSamplingIndex >= 6) {\n          adtsObjectType = 5;\n          config = new Array(4);\n          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n          // there is a factor 2 between frame sample rate and output sample rate\n          // multiply frequency by 2 (see table below, equivalent to substract 3)\n          adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n        } else {\n          adtsObjectType = 2;\n          config = new Array(2);\n          adtsExtensionSamplingIndex = adtsSamplingIndex;\n        }\n        // Android : always use AAC\n      } else if (userAgent.indexOf('android') !== -1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n        adtsExtensionSamplingIndex = adtsSamplingIndex;\n      } else {\n        /*  for other browsers (Chrome/Vivaldi/Opera ...)\n            always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n        */\n        adtsObjectType = 5;\n        config = new Array(4);\n        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n        if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSamplingIndex >= 6) {\n          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n          // there is a factor 2 between frame sample rate and output sample rate\n          // multiply frequency by 2 (see table below, equivalent to substract 3)\n          adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n        } else {\n          // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n          // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n          if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {\n            adtsObjectType = 2;\n            config = new Array(2);\n          }\n          adtsExtensionSamplingIndex = adtsSamplingIndex;\n        }\n      }\n      /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n          ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()\n        Audio Profile / Audio Object Type\n        0: Null\n        1: AAC Main\n        2: AAC LC (Low Complexity)\n        3: AAC SSR (Scalable Sample Rate)\n        4: AAC LTP (Long Term Prediction)\n        5: SBR (Spectral Band Replication)\n        6: AAC Scalable\n       sampling freq\n        0: 96000 Hz\n        1: 88200 Hz\n        2: 64000 Hz\n        3: 48000 Hz\n        4: 44100 Hz\n        5: 32000 Hz\n        6: 24000 Hz\n        7: 22050 Hz\n        8: 16000 Hz\n        9: 12000 Hz\n        10: 11025 Hz\n        11: 8000 Hz\n        12: 7350 Hz\n        13: Reserved\n        14: Reserved\n        15: frequency is written explictly\n        Channel Configurations\n        These are the channel configurations:\n        0: Defined in AOT Specifc Config\n        1: 1 channel: front-center\n        2: 2 channels: front-left, front-right\n      */\n      // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n      config[0] = adtsObjectType << 3;\n      // samplingFrequencyIndex\n      config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\n      config[1] |= (adtsSamplingIndex & 0x01) << 7;\n      // channelConfiguration\n      config[1] |= adtsChannelConfig << 3;\n      if (adtsObjectType === 5) {\n        // adtsExtensionSamplingIndex\n        config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\n        config[2] = (adtsExtensionSamplingIndex & 0x01) << 7;\n        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n        config[2] |= 2 << 2;\n        config[3] = 0;\n      }\n      return {\n        config: config,\n        samplerate: adtsSamplingRates[adtsSamplingIndex],\n        channelCount: adtsChannelConfig,\n        codec: 'mp4a.40.' + adtsObjectType,\n        manifestCodec: manifestCodec\n      };\n    }\n    function isHeaderPattern$1(data, offset) {\n      return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n    }\n    function getHeaderLength(data, offset) {\n      return data[offset + 1] & 0x01 ? 7 : 9;\n    }\n    function getFullFrameLength(data, offset) {\n      return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n    }\n    function canGetFrameLength(data, offset) {\n      return offset + 5 < data.length;\n    }\n    function isHeader$1(data, offset) {\n      // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n      // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n      // More info https://wiki.multimedia.cx/index.php?title=ADTS\n      return offset + 1 < data.length && isHeaderPattern$1(data, offset);\n    }\n    function canParse$1(data, offset) {\n      return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n    }\n    function probe$1(data, offset) {\n      // same as isHeader but we also check that ADTS frame follows last ADTS frame\n      // or end of data is reached\n      if (isHeader$1(data, offset)) {\n        // ADTS header Length\n        var headerLength = getHeaderLength(data, offset);\n        if (offset + headerLength >= data.length) {\n          return false;\n        }\n        // ADTS frame Length\n        var frameLength = getFullFrameLength(data, offset);\n        if (frameLength <= headerLength) {\n          return false;\n        }\n        var newOffset = offset + frameLength;\n        return newOffset === data.length || isHeader$1(data, newOffset);\n      }\n      return false;\n    }\n    function initTrackConfig(track, observer, data, offset, audioCodec) {\n      if (!track.samplerate) {\n        var config = getAudioConfig(observer, data, offset, audioCodec);\n        if (!config) {\n          return;\n        }\n        track.config = config.config;\n        track.samplerate = config.samplerate;\n        track.channelCount = config.channelCount;\n        track.codec = config.codec;\n        track.manifestCodec = config.manifestCodec;\n        logger.log(\"parsed codec:\" + track.codec + \", rate:\" + config.samplerate + \", channels:\" + config.channelCount);\n      }\n    }\n    function getFrameDuration(samplerate) {\n      return 1024 * 90000 / samplerate;\n    }\n    function parseFrameHeader(data, offset) {\n      // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n      var headerLength = getHeaderLength(data, offset);\n      if (offset + headerLength <= data.length) {\n        // retrieve frame size\n        var frameLength = getFullFrameLength(data, offset) - headerLength;\n        if (frameLength > 0) {\n          // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n          return {\n            headerLength: headerLength,\n            frameLength: frameLength\n          };\n        }\n      }\n    }\n    function appendFrame$1(track, data, offset, pts, frameIndex) {\n      var frameDuration = getFrameDuration(track.samplerate);\n      var stamp = pts + frameIndex * frameDuration;\n      var header = parseFrameHeader(data, offset);\n      var unit;\n      if (header) {\n        var frameLength = header.frameLength,\n          headerLength = header.headerLength;\n        var _length = headerLength + frameLength;\n        var missing = Math.max(0, offset + _length - data.length);\n        // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n        if (missing) {\n          unit = new Uint8Array(_length - headerLength);\n          unit.set(data.subarray(offset + headerLength, data.length), 0);\n        } else {\n          unit = data.subarray(offset + headerLength, offset + _length);\n        }\n        var _sample = {\n          unit: unit,\n          pts: stamp\n        };\n        if (!missing) {\n          track.samples.push(_sample);\n        }\n        return {\n          sample: _sample,\n          length: _length,\n          missing: missing\n        };\n      }\n      // overflow incomplete header\n      var length = data.length - offset;\n      unit = new Uint8Array(length);\n      unit.set(data.subarray(offset, data.length), 0);\n      var sample = {\n        unit: unit,\n        pts: stamp\n      };\n      return {\n        sample: sample,\n        length: length,\n        missing: -1\n      };\n    }\n    var AACDemuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n      _inheritsLoose(AACDemuxer, _BaseAudioDemuxer);\n      function AACDemuxer(observer, config) {\n        var _this;\n        _this = _BaseAudioDemuxer.call(this) || this;\n        _this.observer = void 0;\n        _this.config = void 0;\n        _this.observer = observer;\n        _this.config = config;\n        return _this;\n      }\n      var _proto = AACDemuxer.prototype;\n      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n        this._audioTrack = {\n          container: 'audio/adts',\n          type: 'audio',\n          id: 2,\n          pid: -1,\n          sequenceNumber: 0,\n          segmentCodec: 'aac',\n          samples: [],\n          manifestCodec: audioCodec,\n          duration: trackDuration,\n          inputTimeScale: 90000,\n          dropped: 0\n        };\n      }\n\n      // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n      ;\n\n      AACDemuxer.probe = function probe(data) {\n        if (!data) {\n          return false;\n        }\n\n        // Check for the ADTS sync word\n        // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n        // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n        // More info https://wiki.multimedia.cx/index.php?title=ADTS\n        var id3Data = getID3Data(data, 0) || [];\n        var offset = id3Data.length;\n        for (var length = data.length; offset < length; offset++) {\n          if (probe$1(data, offset)) {\n            logger.log('ADTS sync word found !');\n            return true;\n          }\n        }\n        return false;\n      };\n      _proto.canParse = function canParse(data, offset) {\n        return canParse$1(data, offset);\n      };\n      _proto.appendFrame = function appendFrame(track, data, offset) {\n        initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n        var frame = appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);\n        if (frame && frame.missing === 0) {\n          return frame;\n        }\n      };\n      return AACDemuxer;\n    }(BaseAudioDemuxer);\n    var emsgSchemePattern = /\\/emsg[-/]ID3/i;\n    var MP4Demuxer = /*#__PURE__*/function () {\n      function MP4Demuxer(observer, config) {\n        this.remainderData = null;\n        this.timeOffset = 0;\n        this.config = void 0;\n        this.videoTrack = void 0;\n        this.audioTrack = void 0;\n        this.id3Track = void 0;\n        this.txtTrack = void 0;\n        this.config = config;\n      }\n      var _proto = MP4Demuxer.prototype;\n      _proto.resetTimeStamp = function resetTimeStamp() {};\n      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        var videoTrack = this.videoTrack = dummyTrack('video', 1);\n        var audioTrack = this.audioTrack = dummyTrack('audio', 1);\n        var captionTrack = this.txtTrack = dummyTrack('text', 1);\n        this.id3Track = dummyTrack('id3', 1);\n        this.timeOffset = 0;\n        if (!(initSegment != null && initSegment.byteLength)) {\n          return;\n        }\n        var initData = parseInitSegment(initSegment);\n        if (initData.video) {\n          var _initData$video = initData.video,\n            id = _initData$video.id,\n            timescale = _initData$video.timescale,\n            codec = _initData$video.codec;\n          videoTrack.id = id;\n          videoTrack.timescale = captionTrack.timescale = timescale;\n          videoTrack.codec = codec;\n        }\n        if (initData.audio) {\n          var _initData$audio = initData.audio,\n            _id = _initData$audio.id,\n            _timescale = _initData$audio.timescale,\n            _codec = _initData$audio.codec;\n          audioTrack.id = _id;\n          audioTrack.timescale = _timescale;\n          audioTrack.codec = _codec;\n        }\n        captionTrack.id = RemuxerTrackIdConfig.text;\n        videoTrack.sampleDuration = 0;\n        videoTrack.duration = audioTrack.duration = trackDuration;\n      };\n      _proto.resetContiguity = function resetContiguity() {\n        this.remainderData = null;\n      };\n      MP4Demuxer.probe = function probe(data) {\n        // ensure we find a moof box in the first 16 kB\n        data = data.length > 16384 ? data.subarray(0, 16384) : data;\n        return findBox(data, ['moof']).length > 0;\n      };\n      _proto.demux = function demux(data, timeOffset) {\n        this.timeOffset = timeOffset;\n        // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n        var videoSamples = data;\n        var videoTrack = this.videoTrack;\n        var textTrack = this.txtTrack;\n        if (this.config.progressive) {\n          // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n          // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n          // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n          if (this.remainderData) {\n            videoSamples = appendUint8Array(this.remainderData, data);\n          }\n          var segmentedData = segmentValidRange(videoSamples);\n          this.remainderData = segmentedData.remainder;\n          videoTrack.samples = segmentedData.valid || new Uint8Array();\n        } else {\n          videoTrack.samples = videoSamples;\n        }\n        var id3Track = this.extractID3Track(videoTrack, timeOffset);\n        textTrack.samples = parseSamples(timeOffset, videoTrack);\n        return {\n          videoTrack: videoTrack,\n          audioTrack: this.audioTrack,\n          id3Track: id3Track,\n          textTrack: this.txtTrack\n        };\n      };\n      _proto.flush = function flush() {\n        var timeOffset = this.timeOffset;\n        var videoTrack = this.videoTrack;\n        var textTrack = this.txtTrack;\n        videoTrack.samples = this.remainderData || new Uint8Array();\n        this.remainderData = null;\n        var id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n        textTrack.samples = parseSamples(timeOffset, videoTrack);\n        return {\n          videoTrack: videoTrack,\n          audioTrack: dummyTrack(),\n          id3Track: id3Track,\n          textTrack: dummyTrack()\n        };\n      };\n      _proto.extractID3Track = function extractID3Track(videoTrack, timeOffset) {\n        var id3Track = this.id3Track;\n        if (videoTrack.samples.length) {\n          var emsgs = findBox(videoTrack.samples, ['emsg']);\n          if (emsgs) {\n            emsgs.forEach(function (data) {\n              var emsgInfo = parseEmsg(data);\n              if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n                var pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n                var duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n                // Safari takes anything <= 0.001 seconds and maps it to Infinity\n                if (duration <= 0.001) {\n                  duration = Number.POSITIVE_INFINITY;\n                }\n                var payload = emsgInfo.payload;\n                id3Track.samples.push({\n                  data: payload,\n                  len: payload.byteLength,\n                  dts: pts,\n                  pts: pts,\n                  type: MetadataSchema.emsg,\n                  duration: duration\n                });\n              }\n            });\n          }\n        }\n        return id3Track;\n      };\n      _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n        return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n      };\n      _proto.destroy = function destroy() {};\n      return MP4Demuxer;\n    }();\n\n    /**\n     *  MPEG parser helper\n     */\n\n    var chromeVersion$1 = null;\n    var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\n    var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\n    var SamplesCoefficients = [\n    // MPEG 2.5\n    [0,\n    // Reserved\n    72,\n    // Layer3\n    144,\n    // Layer2\n    12 // Layer1\n    ],\n    // Reserved\n    [0,\n    // Reserved\n    0,\n    // Layer3\n    0,\n    // Layer2\n    0 // Layer1\n    ],\n    // MPEG 2\n    [0,\n    // Reserved\n    72,\n    // Layer3\n    144,\n    // Layer2\n    12 // Layer1\n    ],\n    // MPEG 1\n    [0,\n    // Reserved\n    144,\n    // Layer3\n    144,\n    // Layer2\n    12 // Layer1\n    ]];\n\n    var BytesInSlot = [0,\n    // Reserved\n    1,\n    // Layer3\n    1,\n    // Layer2\n    4 // Layer1\n    ];\n\n    function appendFrame(track, data, offset, pts, frameIndex) {\n      // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n      if (offset + 24 > data.length) {\n        return;\n      }\n      var header = parseHeader(data, offset);\n      if (header && offset + header.frameLength <= data.length) {\n        var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n        var stamp = pts + frameIndex * frameDuration;\n        var sample = {\n          unit: data.subarray(offset, offset + header.frameLength),\n          pts: stamp,\n          dts: stamp\n        };\n        track.config = [];\n        track.channelCount = header.channelCount;\n        track.samplerate = header.sampleRate;\n        track.samples.push(sample);\n        return {\n          sample: sample,\n          length: header.frameLength,\n          missing: 0\n        };\n      }\n    }\n    function parseHeader(data, offset) {\n      var mpegVersion = data[offset + 1] >> 3 & 3;\n      var mpegLayer = data[offset + 1] >> 1 & 3;\n      var bitRateIndex = data[offset + 2] >> 4 & 15;\n      var sampleRateIndex = data[offset + 2] >> 2 & 3;\n      if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n        var paddingBit = data[offset + 2] >> 1 & 1;\n        var channelMode = data[offset + 3] >> 6;\n        var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n        var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n        var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n        var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n        var channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n        var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n        var bytesInSlot = BytesInSlot[mpegLayer];\n        var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n        var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n        if (chromeVersion$1 === null) {\n          var userAgent = navigator.userAgent || '';\n          var result = userAgent.match(/Chrome\\/(\\d+)/i);\n          chromeVersion$1 = result ? parseInt(result[1]) : 0;\n        }\n        var needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;\n        if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n          // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n          data[offset + 3] = data[offset + 3] | 0x80;\n        }\n        return {\n          sampleRate: sampleRate,\n          channelCount: channelCount,\n          frameLength: frameLength,\n          samplesPerFrame: samplesPerFrame\n        };\n      }\n    }\n    function isHeaderPattern(data, offset) {\n      return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n    }\n    function isHeader(data, offset) {\n      // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n      // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n      // More info http://www.mp3-tech.org/programmer/frame_header.html\n      return offset + 1 < data.length && isHeaderPattern(data, offset);\n    }\n    function canParse(data, offset) {\n      var headerSize = 4;\n      return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n    }\n    function probe(data, offset) {\n      // same as isHeader but we also check that MPEG frame follows last MPEG frame\n      // or end of data is reached\n      if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n        // MPEG header Length\n        var headerLength = 4;\n        // MPEG frame Length\n        var header = parseHeader(data, offset);\n        var frameLength = headerLength;\n        if (header != null && header.frameLength) {\n          frameLength = header.frameLength;\n        }\n        var newOffset = offset + frameLength;\n        return newOffset === data.length || isHeader(data, newOffset);\n      }\n      return false;\n    }\n\n    /**\n     * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n     */\n\n    var ExpGolomb = /*#__PURE__*/function () {\n      function ExpGolomb(data) {\n        this.data = void 0;\n        this.bytesAvailable = void 0;\n        this.word = void 0;\n        this.bitsAvailable = void 0;\n        this.data = data;\n        // the number of bytes left to examine in this.data\n        this.bytesAvailable = data.byteLength;\n        // the current word being examined\n        this.word = 0; // :uint\n        // the number of bits left to examine in the current word\n        this.bitsAvailable = 0; // :uint\n      }\n\n      // ():void\n      var _proto = ExpGolomb.prototype;\n      _proto.loadWord = function loadWord() {\n        var data = this.data;\n        var bytesAvailable = this.bytesAvailable;\n        var position = data.byteLength - bytesAvailable;\n        var workingBytes = new Uint8Array(4);\n        var availableBytes = Math.min(4, bytesAvailable);\n        if (availableBytes === 0) {\n          throw new Error('no bytes available');\n        }\n        workingBytes.set(data.subarray(position, position + availableBytes));\n        this.word = new DataView(workingBytes.buffer).getUint32(0);\n        // track the amount of this.data that has been processed\n        this.bitsAvailable = availableBytes * 8;\n        this.bytesAvailable -= availableBytes;\n      }\n\n      // (count:int):void\n      ;\n\n      _proto.skipBits = function skipBits(count) {\n        var skipBytes; // :int\n        count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n        if (this.bitsAvailable > count) {\n          this.word <<= count;\n          this.bitsAvailable -= count;\n        } else {\n          count -= this.bitsAvailable;\n          skipBytes = count >> 3;\n          count -= skipBytes << 3;\n          this.bytesAvailable -= skipBytes;\n          this.loadWord();\n          this.word <<= count;\n          this.bitsAvailable -= count;\n        }\n      }\n\n      // (size:int):uint\n      ;\n\n      _proto.readBits = function readBits(size) {\n        var bits = Math.min(this.bitsAvailable, size); // :uint\n        var valu = this.word >>> 32 - bits; // :uint\n        if (size > 32) {\n          logger.error('Cannot read more than 32 bits at a time');\n        }\n        this.bitsAvailable -= bits;\n        if (this.bitsAvailable > 0) {\n          this.word <<= bits;\n        } else if (this.bytesAvailable > 0) {\n          this.loadWord();\n        } else {\n          throw new Error('no bits available');\n        }\n        bits = size - bits;\n        if (bits > 0 && this.bitsAvailable) {\n          return valu << bits | this.readBits(bits);\n        } else {\n          return valu;\n        }\n      }\n\n      // ():uint\n      ;\n\n      _proto.skipLZ = function skipLZ() {\n        var leadingZeroCount; // :uint\n        for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n          if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n            // the first bit of working word is 1\n            this.word <<= leadingZeroCount;\n            this.bitsAvailable -= leadingZeroCount;\n            return leadingZeroCount;\n          }\n        }\n        // we exhausted word and still have not found a 1\n        this.loadWord();\n        return leadingZeroCount + this.skipLZ();\n      }\n\n      // ():void\n      ;\n\n      _proto.skipUEG = function skipUEG() {\n        this.skipBits(1 + this.skipLZ());\n      }\n\n      // ():void\n      ;\n\n      _proto.skipEG = function skipEG() {\n        this.skipBits(1 + this.skipLZ());\n      }\n\n      // ():uint\n      ;\n\n      _proto.readUEG = function readUEG() {\n        var clz = this.skipLZ(); // :uint\n        return this.readBits(clz + 1) - 1;\n      }\n\n      // ():int\n      ;\n\n      _proto.readEG = function readEG() {\n        var valu = this.readUEG(); // :int\n        if (0x01 & valu) {\n          // the number is odd if the low order bit is set\n          return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n        } else {\n          return -1 * (valu >>> 1); // divide by two then make it negative\n        }\n      }\n\n      // Some convenience functions\n      // :Boolean\n      ;\n\n      _proto.readBoolean = function readBoolean() {\n        return this.readBits(1) === 1;\n      }\n\n      // ():int\n      ;\n\n      _proto.readUByte = function readUByte() {\n        return this.readBits(8);\n      }\n\n      // ():int\n      ;\n\n      _proto.readUShort = function readUShort() {\n        return this.readBits(16);\n      }\n\n      // ():int\n      ;\n\n      _proto.readUInt = function readUInt() {\n        return this.readBits(32);\n      }\n\n      /**\n       * Advance the ExpGolomb decoder past a scaling list. The scaling\n       * list is optionally transmitted as part of a sequence parameter\n       * set and is not relevant to transmuxing.\n       * @param count the number of entries in this scaling list\n       * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n       */;\n      _proto.skipScalingList = function skipScalingList(count) {\n        var lastScale = 8;\n        var nextScale = 8;\n        var deltaScale;\n        for (var j = 0; j < count; j++) {\n          if (nextScale !== 0) {\n            deltaScale = this.readEG();\n            nextScale = (lastScale + deltaScale + 256) % 256;\n          }\n          lastScale = nextScale === 0 ? lastScale : nextScale;\n        }\n      }\n\n      /**\n       * Read a sequence parameter set and return some interesting video\n       * properties. A sequence parameter set is the H264 metadata that\n       * describes the properties of upcoming video frames.\n       * @returns an object with configuration parsed from the\n       * sequence parameter set, including the dimensions of the\n       * associated video frames.\n       */;\n      _proto.readSPS = function readSPS() {\n        var frameCropLeftOffset = 0;\n        var frameCropRightOffset = 0;\n        var frameCropTopOffset = 0;\n        var frameCropBottomOffset = 0;\n        var numRefFramesInPicOrderCntCycle;\n        var scalingListCount;\n        var i;\n        var readUByte = this.readUByte.bind(this);\n        var readBits = this.readBits.bind(this);\n        var readUEG = this.readUEG.bind(this);\n        var readBoolean = this.readBoolean.bind(this);\n        var skipBits = this.skipBits.bind(this);\n        var skipEG = this.skipEG.bind(this);\n        var skipUEG = this.skipUEG.bind(this);\n        var skipScalingList = this.skipScalingList.bind(this);\n        readUByte();\n        var profileIdc = readUByte(); // profile_idc\n        readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n        skipBits(3); // reserved_zero_3bits u(3),\n        readUByte(); // level_idc u(8)\n        skipUEG(); // seq_parameter_set_id\n        // some profiles have more optional data we don't need\n        if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n          var chromaFormatIdc = readUEG();\n          if (chromaFormatIdc === 3) {\n            skipBits(1);\n          } // separate_colour_plane_flag\n\n          skipUEG(); // bit_depth_luma_minus8\n          skipUEG(); // bit_depth_chroma_minus8\n          skipBits(1); // qpprime_y_zero_transform_bypass_flag\n          if (readBoolean()) {\n            // seq_scaling_matrix_present_flag\n            scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n            for (i = 0; i < scalingListCount; i++) {\n              if (readBoolean()) {\n                // seq_scaling_list_present_flag[ i ]\n                if (i < 6) {\n                  skipScalingList(16);\n                } else {\n                  skipScalingList(64);\n                }\n              }\n            }\n          }\n        }\n        skipUEG(); // log2_max_frame_num_minus4\n        var picOrderCntType = readUEG();\n        if (picOrderCntType === 0) {\n          readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n        } else if (picOrderCntType === 1) {\n          skipBits(1); // delta_pic_order_always_zero_flag\n          skipEG(); // offset_for_non_ref_pic\n          skipEG(); // offset_for_top_to_bottom_field\n          numRefFramesInPicOrderCntCycle = readUEG();\n          for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n            skipEG();\n          } // offset_for_ref_frame[ i ]\n        }\n\n        skipUEG(); // max_num_ref_frames\n        skipBits(1); // gaps_in_frame_num_value_allowed_flag\n        var picWidthInMbsMinus1 = readUEG();\n        var picHeightInMapUnitsMinus1 = readUEG();\n        var frameMbsOnlyFlag = readBits(1);\n        if (frameMbsOnlyFlag === 0) {\n          skipBits(1);\n        } // mb_adaptive_frame_field_flag\n\n        skipBits(1); // direct_8x8_inference_flag\n        if (readBoolean()) {\n          // frame_cropping_flag\n          frameCropLeftOffset = readUEG();\n          frameCropRightOffset = readUEG();\n          frameCropTopOffset = readUEG();\n          frameCropBottomOffset = readUEG();\n        }\n        var pixelRatio = [1, 1];\n        if (readBoolean()) {\n          // vui_parameters_present_flag\n          if (readBoolean()) {\n            // aspect_ratio_info_present_flag\n            var aspectRatioIdc = readUByte();\n            switch (aspectRatioIdc) {\n              case 1:\n                pixelRatio = [1, 1];\n                break;\n              case 2:\n                pixelRatio = [12, 11];\n                break;\n              case 3:\n                pixelRatio = [10, 11];\n                break;\n              case 4:\n                pixelRatio = [16, 11];\n                break;\n              case 5:\n                pixelRatio = [40, 33];\n                break;\n              case 6:\n                pixelRatio = [24, 11];\n                break;\n              case 7:\n                pixelRatio = [20, 11];\n                break;\n              case 8:\n                pixelRatio = [32, 11];\n                break;\n              case 9:\n                pixelRatio = [80, 33];\n                break;\n              case 10:\n                pixelRatio = [18, 11];\n                break;\n              case 11:\n                pixelRatio = [15, 11];\n                break;\n              case 12:\n                pixelRatio = [64, 33];\n                break;\n              case 13:\n                pixelRatio = [160, 99];\n                break;\n              case 14:\n                pixelRatio = [4, 3];\n                break;\n              case 15:\n                pixelRatio = [3, 2];\n                break;\n              case 16:\n                pixelRatio = [2, 1];\n                break;\n              case 255:\n                {\n                  pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n                  break;\n                }\n            }\n          }\n        }\n        return {\n          width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n          height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n          pixelRatio: pixelRatio\n        };\n      };\n      _proto.readSliceType = function readSliceType() {\n        // skip NALu type\n        this.readUByte();\n        // discard first_mb_in_slice\n        this.readUEG();\n        // return slice_type\n        return this.readUEG();\n      };\n      return ExpGolomb;\n    }();\n\n    /**\n     * SAMPLE-AES decrypter\n     */\n\n    var SampleAesDecrypter = /*#__PURE__*/function () {\n      function SampleAesDecrypter(observer, config, keyData) {\n        this.keyData = void 0;\n        this.decrypter = void 0;\n        this.keyData = keyData;\n        this.decrypter = new Decrypter(config, {\n          removePKCS7Padding: false\n        });\n      }\n      var _proto = SampleAesDecrypter.prototype;\n      _proto.decryptBuffer = function decryptBuffer(encryptedData) {\n        return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);\n      }\n\n      // AAC - encrypt all full 16 bytes blocks starting from offset 16\n      ;\n\n      _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback) {\n        var _this = this;\n        var curUnit = samples[sampleIndex].unit;\n        if (curUnit.length <= 16) {\n          // No encrypted portion in this sample (first 16 bytes is not\n          // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n          return;\n        }\n        var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n        var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n        this.decryptBuffer(encryptedBuffer).then(function (decryptedBuffer) {\n          var decryptedData = new Uint8Array(decryptedBuffer);\n          curUnit.set(decryptedData, 16);\n          if (!_this.decrypter.isSync()) {\n            _this.decryptAacSamples(samples, sampleIndex + 1, callback);\n          }\n        });\n      };\n      _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {\n        for (;; sampleIndex++) {\n          if (sampleIndex >= samples.length) {\n            callback();\n            return;\n          }\n          if (samples[sampleIndex].unit.length < 32) {\n            continue;\n          }\n          this.decryptAacSample(samples, sampleIndex, callback);\n          if (!this.decrypter.isSync()) {\n            return;\n          }\n        }\n      }\n\n      // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n      ;\n\n      _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {\n        var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n        var encryptedData = new Int8Array(encryptedDataLen);\n        var outputPos = 0;\n        for (var inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n          encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n        }\n        return encryptedData;\n      };\n      _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {\n        var uint8DecryptedData = new Uint8Array(decryptedData);\n        var inputPos = 0;\n        for (var outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n          decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n        }\n        return decodedData;\n      };\n      _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n        var _this2 = this;\n        var decodedData = discardEPB(curUnit.data);\n        var encryptedData = this.getAvcEncryptedData(decodedData);\n        this.decryptBuffer(encryptedData.buffer).then(function (decryptedBuffer) {\n          curUnit.data = _this2.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n          if (!_this2.decrypter.isSync()) {\n            _this2.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n          }\n        });\n      };\n      _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n        if (samples instanceof Uint8Array) {\n          throw new Error('Cannot decrypt samples of type Uint8Array');\n        }\n        for (;; sampleIndex++, unitIndex = 0) {\n          if (sampleIndex >= samples.length) {\n            callback();\n            return;\n          }\n          var curUnits = samples[sampleIndex].units;\n          for (;; unitIndex++) {\n            if (unitIndex >= curUnits.length) {\n              break;\n            }\n            var curUnit = curUnits[unitIndex];\n            if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n              continue;\n            }\n            this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n            if (!this.decrypter.isSync()) {\n              return;\n            }\n          }\n        }\n      };\n      return SampleAesDecrypter;\n    }();\n    var PACKET_LENGTH = 188;\n    var TSDemuxer = /*#__PURE__*/function () {\n      function TSDemuxer(observer, config, typeSupported) {\n        this.observer = void 0;\n        this.config = void 0;\n        this.typeSupported = void 0;\n        this.sampleAes = null;\n        this.pmtParsed = false;\n        this.audioCodec = void 0;\n        this.videoCodec = void 0;\n        this._duration = 0;\n        this._pmtId = -1;\n        this._avcTrack = void 0;\n        this._audioTrack = void 0;\n        this._id3Track = void 0;\n        this._txtTrack = void 0;\n        this.aacOverFlow = null;\n        this.avcSample = null;\n        this.remainderData = null;\n        this.observer = observer;\n        this.config = config;\n        this.typeSupported = typeSupported;\n      }\n      TSDemuxer.probe = function probe(data) {\n        var syncOffset = TSDemuxer.syncOffset(data);\n        if (syncOffset > 0) {\n          logger.warn(\"MPEG2-TS detected but first sync word found @ offset \" + syncOffset);\n        }\n        return syncOffset !== -1;\n      };\n      TSDemuxer.syncOffset = function syncOffset(data) {\n        var length = data.length;\n        var scanwindow = Math.min(PACKET_LENGTH * 5, data.length - PACKET_LENGTH) + 1;\n        var i = 0;\n        while (i < scanwindow) {\n          // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n          var foundPat = false;\n          var packetStart = -1;\n          var tsPackets = 0;\n          for (var j = i; j < length; j += PACKET_LENGTH) {\n            if (data[j] === 0x47) {\n              tsPackets++;\n              if (packetStart === -1) {\n                packetStart = j;\n                // First sync word found at offset, increase scan length (#5251)\n                if (packetStart !== 0) {\n                  scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;\n                }\n              }\n              if (!foundPat) {\n                foundPat = parsePID(data, j) === 0;\n              }\n              // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n              if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {\n                return packetStart;\n              }\n            } else if (tsPackets) {\n              // Exit if sync word found, but does not contain contiguous packets (#5501)\n              return -1;\n            } else {\n              break;\n            }\n          }\n          i++;\n        }\n        return -1;\n      }\n\n      /**\n       * Creates a track model internal to demuxer used to drive remuxing input\n       */;\n      TSDemuxer.createTrack = function createTrack(type, duration) {\n        return {\n          container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n          type: type,\n          id: RemuxerTrackIdConfig[type],\n          pid: -1,\n          inputTimeScale: 90000,\n          sequenceNumber: 0,\n          samples: [],\n          dropped: 0,\n          duration: type === 'audio' ? duration : undefined\n        };\n      }\n\n      /**\n       * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n       * Resets all internal track instances of the demuxer.\n       */;\n      var _proto = TSDemuxer.prototype;\n      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        this.pmtParsed = false;\n        this._pmtId = -1;\n        this._avcTrack = TSDemuxer.createTrack('video');\n        this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);\n        this._id3Track = TSDemuxer.createTrack('id3');\n        this._txtTrack = TSDemuxer.createTrack('text');\n        this._audioTrack.segmentCodec = 'aac';\n\n        // flush any partial content\n        this.aacOverFlow = null;\n        this.avcSample = null;\n        this.remainderData = null;\n        this.audioCodec = audioCodec;\n        this.videoCodec = videoCodec;\n        this._duration = trackDuration;\n      };\n      _proto.resetTimeStamp = function resetTimeStamp() {};\n      _proto.resetContiguity = function resetContiguity() {\n        var _audioTrack = this._audioTrack,\n          _avcTrack = this._avcTrack,\n          _id3Track = this._id3Track;\n        if (_audioTrack) {\n          _audioTrack.pesData = null;\n        }\n        if (_avcTrack) {\n          _avcTrack.pesData = null;\n        }\n        if (_id3Track) {\n          _id3Track.pesData = null;\n        }\n        this.aacOverFlow = null;\n        this.avcSample = null;\n        this.remainderData = null;\n      };\n      _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {\n        if (isSampleAes === void 0) {\n          isSampleAes = false;\n        }\n        if (flush === void 0) {\n          flush = false;\n        }\n        if (!isSampleAes) {\n          this.sampleAes = null;\n        }\n        var pes;\n        var videoTrack = this._avcTrack;\n        var audioTrack = this._audioTrack;\n        var id3Track = this._id3Track;\n        var textTrack = this._txtTrack;\n        var avcId = videoTrack.pid;\n        var avcData = videoTrack.pesData;\n        var audioId = audioTrack.pid;\n        var id3Id = id3Track.pid;\n        var audioData = audioTrack.pesData;\n        var id3Data = id3Track.pesData;\n        var unknownPID = null;\n        var pmtParsed = this.pmtParsed;\n        var pmtId = this._pmtId;\n        var len = data.length;\n        if (this.remainderData) {\n          data = appendUint8Array(this.remainderData, data);\n          len = data.length;\n          this.remainderData = null;\n        }\n        if (len < PACKET_LENGTH && !flush) {\n          this.remainderData = data;\n          return {\n            audioTrack: audioTrack,\n            videoTrack: videoTrack,\n            id3Track: id3Track,\n            textTrack: textTrack\n          };\n        }\n        var syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n        len -= (len - syncOffset) % PACKET_LENGTH;\n        if (len < data.byteLength && !flush) {\n          this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n        }\n\n        // loop through TS packets\n        var tsPacketErrors = 0;\n        for (var start = syncOffset; start < len; start += PACKET_LENGTH) {\n          if (data[start] === 0x47) {\n            var stt = !!(data[start + 1] & 0x40);\n            var pid = parsePID(data, start);\n            var atf = (data[start + 3] & 0x30) >> 4;\n\n            // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n            var offset = void 0;\n            if (atf > 1) {\n              offset = start + 5 + data[start + 4];\n              // continue if there is only adaptation field\n              if (offset === start + PACKET_LENGTH) {\n                continue;\n              }\n            } else {\n              offset = start + 4;\n            }\n            switch (pid) {\n              case avcId:\n                if (stt) {\n                  if (avcData && (pes = parsePES(avcData))) {\n                    this.parseAVCPES(videoTrack, textTrack, pes, false);\n                  }\n                  avcData = {\n                    data: [],\n                    size: 0\n                  };\n                }\n                if (avcData) {\n                  avcData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                  avcData.size += start + PACKET_LENGTH - offset;\n                }\n                break;\n              case audioId:\n                if (stt) {\n                  if (audioData && (pes = parsePES(audioData))) {\n                    switch (audioTrack.segmentCodec) {\n                      case 'aac':\n                        this.parseAACPES(audioTrack, pes);\n                        break;\n                      case 'mp3':\n                        this.parseMPEGPES(audioTrack, pes);\n                        break;\n                    }\n                  }\n                  audioData = {\n                    data: [],\n                    size: 0\n                  };\n                }\n                if (audioData) {\n                  audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                  audioData.size += start + PACKET_LENGTH - offset;\n                }\n                break;\n              case id3Id:\n                if (stt) {\n                  if (id3Data && (pes = parsePES(id3Data))) {\n                    this.parseID3PES(id3Track, pes);\n                  }\n                  id3Data = {\n                    data: [],\n                    size: 0\n                  };\n                }\n                if (id3Data) {\n                  id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                  id3Data.size += start + PACKET_LENGTH - offset;\n                }\n                break;\n              case 0:\n                if (stt) {\n                  offset += data[offset] + 1;\n                }\n                pmtId = this._pmtId = parsePAT(data, offset);\n                // logger.log('PMT PID:'  + this._pmtId);\n                break;\n              case pmtId:\n                {\n                  if (stt) {\n                    offset += data[offset] + 1;\n                  }\n                  var parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes);\n\n                  // only update track id if track PID found while parsing PMT\n                  // this is to avoid resetting the PID to -1 in case\n                  // track PID transiently disappears from the stream\n                  // this could happen in case of transient missing audio samples for example\n                  // NOTE this is only the PID of the track as found in TS,\n                  // but we are not using this for MP4 track IDs.\n                  avcId = parsedPIDs.avc;\n                  if (avcId > 0) {\n                    videoTrack.pid = avcId;\n                  }\n                  audioId = parsedPIDs.audio;\n                  if (audioId > 0) {\n                    audioTrack.pid = audioId;\n                    audioTrack.segmentCodec = parsedPIDs.segmentCodec;\n                  }\n                  id3Id = parsedPIDs.id3;\n                  if (id3Id > 0) {\n                    id3Track.pid = id3Id;\n                  }\n                  if (unknownPID !== null && !pmtParsed) {\n                    logger.warn(\"MPEG-TS PMT found at \" + start + \" after unknown PID '\" + unknownPID + \"'. Backtracking to sync byte @\" + syncOffset + \" to parse all TS packets.\");\n                    unknownPID = null;\n                    // we set it to -188, the += 188 in the for loop will reset start to 0\n                    start = syncOffset - 188;\n                  }\n                  pmtParsed = this.pmtParsed = true;\n                  break;\n                }\n              case 0x11:\n              case 0x1fff:\n                break;\n              default:\n                unknownPID = pid;\n                break;\n            }\n          } else {\n            tsPacketErrors++;\n          }\n        }\n        if (tsPacketErrors > 0) {\n          var error = new Error(\"Found \" + tsPacketErrors + \" TS packet/s that do not start with 0x47\");\n          this.observer.emit(Events.ERROR, Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: false,\n            error: error,\n            reason: error.message\n          });\n        }\n        videoTrack.pesData = avcData;\n        audioTrack.pesData = audioData;\n        id3Track.pesData = id3Data;\n        var demuxResult = {\n          audioTrack: audioTrack,\n          videoTrack: videoTrack,\n          id3Track: id3Track,\n          textTrack: textTrack\n        };\n        if (flush) {\n          this.extractRemainingSamples(demuxResult);\n        }\n        return demuxResult;\n      };\n      _proto.flush = function flush() {\n        var remainderData = this.remainderData;\n        this.remainderData = null;\n        var result;\n        if (remainderData) {\n          result = this.demux(remainderData, -1, false, true);\n        } else {\n          result = {\n            videoTrack: this._avcTrack,\n            audioTrack: this._audioTrack,\n            id3Track: this._id3Track,\n            textTrack: this._txtTrack\n          };\n        }\n        this.extractRemainingSamples(result);\n        if (this.sampleAes) {\n          return this.decrypt(result, this.sampleAes);\n        }\n        return result;\n      };\n      _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {\n        var audioTrack = demuxResult.audioTrack,\n          videoTrack = demuxResult.videoTrack,\n          id3Track = demuxResult.id3Track,\n          textTrack = demuxResult.textTrack;\n        var avcData = videoTrack.pesData;\n        var audioData = audioTrack.pesData;\n        var id3Data = id3Track.pesData;\n        // try to parse last PES packets\n        var pes;\n        if (avcData && (pes = parsePES(avcData))) {\n          this.parseAVCPES(videoTrack, textTrack, pes, true);\n          videoTrack.pesData = null;\n        } else {\n          // either avcData null or PES truncated, keep it for next frag parsing\n          videoTrack.pesData = avcData;\n        }\n        if (audioData && (pes = parsePES(audioData))) {\n          switch (audioTrack.segmentCodec) {\n            case 'aac':\n              this.parseAACPES(audioTrack, pes);\n              break;\n            case 'mp3':\n              this.parseMPEGPES(audioTrack, pes);\n              break;\n          }\n          audioTrack.pesData = null;\n        } else {\n          if (audioData != null && audioData.size) {\n            logger.log('last AAC PES packet truncated,might overlap between fragments');\n          }\n\n          // either audioData null or PES truncated, keep it for next frag parsing\n          audioTrack.pesData = audioData;\n        }\n        if (id3Data && (pes = parsePES(id3Data))) {\n          this.parseID3PES(id3Track, pes);\n          id3Track.pesData = null;\n        } else {\n          // either id3Data null or PES truncated, keep it for next frag parsing\n          id3Track.pesData = id3Data;\n        }\n      };\n      _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n        var demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n        var sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);\n        return this.decrypt(demuxResult, sampleAes);\n      };\n      _proto.decrypt = function decrypt(demuxResult, sampleAes) {\n        return new Promise(function (resolve) {\n          var audioTrack = demuxResult.audioTrack,\n            videoTrack = demuxResult.videoTrack;\n          if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n            sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {\n              if (videoTrack.samples) {\n                sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n                  resolve(demuxResult);\n                });\n              } else {\n                resolve(demuxResult);\n              }\n            });\n          } else if (videoTrack.samples) {\n            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n              resolve(demuxResult);\n            });\n          }\n        });\n      };\n      _proto.destroy = function destroy() {\n        this._duration = 0;\n      };\n      _proto.parseAVCPES = function parseAVCPES(track, textTrack, pes, last) {\n        var _this = this;\n        var units = this.parseAVCNALu(track, pes.data);\n        var avcSample = this.avcSample;\n        var push;\n        var spsfound = false;\n        // free pes.data to save up some memory\n        pes.data = null;\n\n        // if new NAL units found and last sample still there, let's push ...\n        // this helps parsing streams with missing AUD (only do this if AUD never found)\n        if (avcSample && units.length && !track.audFound) {\n          pushAccessUnit(avcSample, track);\n          avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n        }\n        units.forEach(function (unit) {\n          switch (unit.type) {\n            // NDR\n            case 1:\n              {\n                push = true;\n                if (!avcSample) {\n                  avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n                }\n                avcSample.frame = true;\n                var data = unit.data;\n                // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n                if (spsfound && data.length > 4) {\n                  // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n                  var sliceType = new ExpGolomb(data).readSliceType();\n                  // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n                  // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n                  // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n                  // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n                  // if (sliceType === 2 || sliceType === 7) {\n                  if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                    avcSample.key = true;\n                  }\n                }\n                break;\n                // IDR\n              }\n\n            case 5:\n              push = true;\n              // handle PES not starting with AUD\n              if (!avcSample) {\n                avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n              }\n              avcSample.key = true;\n              avcSample.frame = true;\n              break;\n            // SEI\n            case 6:\n              {\n                push = true;\n                parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);\n                break;\n                // SPS\n              }\n\n            case 7:\n              push = true;\n              spsfound = true;\n              if (!track.sps) {\n                var sps = unit.data;\n                var expGolombDecoder = new ExpGolomb(sps);\n                var config = expGolombDecoder.readSPS();\n                track.width = config.width;\n                track.height = config.height;\n                track.pixelRatio = config.pixelRatio;\n                track.sps = [sps];\n                track.duration = _this._duration;\n                var codecarray = sps.subarray(1, 4);\n                var codecstring = 'avc1.';\n                for (var i = 0; i < 3; i++) {\n                  var h = codecarray[i].toString(16);\n                  if (h.length < 2) {\n                    h = '0' + h;\n                  }\n                  codecstring += h;\n                }\n                track.codec = codecstring;\n              }\n              break;\n            // PPS\n            case 8:\n              push = true;\n              if (!track.pps) {\n                track.pps = [unit.data];\n              }\n              break;\n            // AUD\n            case 9:\n              push = false;\n              track.audFound = true;\n              if (avcSample) {\n                pushAccessUnit(avcSample, track);\n              }\n              avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n              break;\n            // Filler Data\n            case 12:\n              push = true;\n              break;\n            default:\n              push = false;\n              if (avcSample) {\n                avcSample.debug += 'unknown NAL ' + unit.type + ' ';\n              }\n              break;\n          }\n          if (avcSample && push) {\n            var _units = avcSample.units;\n            _units.push(unit);\n          }\n        });\n        // if last PES packet, push samples\n        if (last && avcSample) {\n          pushAccessUnit(avcSample, track);\n          this.avcSample = null;\n        }\n      };\n      _proto.getLastNalUnit = function getLastNalUnit(samples) {\n        var _avcSample;\n        var avcSample = this.avcSample;\n        var lastUnit;\n        // try to fallback to previous sample if current one is empty\n        if (!avcSample || avcSample.units.length === 0) {\n          avcSample = samples[samples.length - 1];\n        }\n        if ((_avcSample = avcSample) != null && _avcSample.units) {\n          var units = avcSample.units;\n          lastUnit = units[units.length - 1];\n        }\n        return lastUnit;\n      };\n      _proto.parseAVCNALu = function parseAVCNALu(track, array) {\n        var len = array.byteLength;\n        var state = track.naluState || 0;\n        var lastState = state;\n        var units = [];\n        var i = 0;\n        var value;\n        var overflow;\n        var unitType;\n        var lastUnitStart = -1;\n        var lastUnitType = 0;\n        // logger.log('PES:' + Hex.hexDump(array));\n\n        if (state === -1) {\n          // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n          lastUnitStart = 0;\n          // NALu type is value read from offset 0\n          lastUnitType = array[0] & 0x1f;\n          state = 0;\n          i = 1;\n        }\n        while (i < len) {\n          value = array[i++];\n          // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n          if (!state) {\n            state = value ? 0 : 1;\n            continue;\n          }\n          if (state === 1) {\n            state = value ? 0 : 2;\n            continue;\n          }\n          // here we have state either equal to 2 or 3\n          if (!value) {\n            state = 3;\n          } else if (value === 1) {\n            if (lastUnitStart >= 0) {\n              var unit = {\n                data: array.subarray(lastUnitStart, i - state - 1),\n                type: lastUnitType\n              };\n              // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n              units.push(unit);\n            } else {\n              // lastUnitStart is undefined => this is the first start code found in this PES packet\n              // first check if start code delimiter is overlapping between 2 PES packets,\n              // ie it started in last packet (lastState not zero)\n              // and ended at the beginning of this PES packet (i <= 4 - lastState)\n              var lastUnit = this.getLastNalUnit(track.samples);\n              if (lastUnit) {\n                if (lastState && i <= 4 - lastState) {\n                  // start delimiter overlapping between PES packets\n                  // strip start delimiter bytes from the end of last NAL unit\n                  // check if lastUnit had a state different from zero\n                  if (lastUnit.state) {\n                    // strip last bytes\n                    lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n                  }\n                }\n                // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n                overflow = i - state - 1;\n                if (overflow > 0) {\n                  // logger.log('first NALU found with overflow:' + overflow);\n                  var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);\n                  tmp.set(lastUnit.data, 0);\n                  tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);\n                  lastUnit.data = tmp;\n                  lastUnit.state = 0;\n                }\n              }\n            }\n            // check if we can read unit type\n            if (i < len) {\n              unitType = array[i] & 0x1f;\n              // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n              lastUnitStart = i;\n              lastUnitType = unitType;\n              state = 0;\n            } else {\n              // not enough byte to read unit type. let's read it on next PES parsing\n              state = -1;\n            }\n          } else {\n            state = 0;\n          }\n        }\n        if (lastUnitStart >= 0 && state >= 0) {\n          var _unit = {\n            data: array.subarray(lastUnitStart, len),\n            type: lastUnitType,\n            state: state\n          };\n          units.push(_unit);\n          // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n        }\n        // no NALu found\n        if (units.length === 0) {\n          // append pes.data to previous NAL unit\n          var _lastUnit = this.getLastNalUnit(track.samples);\n          if (_lastUnit) {\n            var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);\n            _tmp.set(_lastUnit.data, 0);\n            _tmp.set(array, _lastUnit.data.byteLength);\n            _lastUnit.data = _tmp;\n          }\n        }\n        track.naluState = state;\n        return units;\n      };\n      _proto.parseAACPES = function parseAACPES(track, pes) {\n        var startOffset = 0;\n        var aacOverFlow = this.aacOverFlow;\n        var data = pes.data;\n        if (aacOverFlow) {\n          this.aacOverFlow = null;\n          var frameMissingBytes = aacOverFlow.missing;\n          var sampleLength = aacOverFlow.sample.unit.byteLength;\n          // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n          if (frameMissingBytes === -1) {\n            var tmp = new Uint8Array(sampleLength + data.byteLength);\n            tmp.set(aacOverFlow.sample.unit, 0);\n            tmp.set(data, sampleLength);\n            data = tmp;\n          } else {\n            var frameOverflowBytes = sampleLength - frameMissingBytes;\n            aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n            track.samples.push(aacOverFlow.sample);\n            startOffset = aacOverFlow.missing;\n          }\n        }\n        // look for ADTS header (0xFFFx)\n        var offset;\n        var len;\n        for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n          if (isHeader$1(data, offset)) {\n            break;\n          }\n        }\n        // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n        if (offset !== startOffset) {\n          var reason;\n          var recoverable = offset < len - 1;\n          if (recoverable) {\n            reason = \"AAC PES did not start with ADTS header,offset:\" + offset;\n          } else {\n            reason = 'No ADTS header found in AAC PES';\n          }\n          var error = new Error(reason);\n          logger.warn(\"parsing error: \" + reason);\n          this.observer.emit(Events.ERROR, Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: false,\n            levelRetry: recoverable,\n            error: error,\n            reason: reason\n          });\n          if (!recoverable) {\n            return;\n          }\n        }\n        initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n        var pts;\n        if (pes.pts !== undefined) {\n          pts = pes.pts;\n        } else if (aacOverFlow) {\n          // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n          // first sample PTS should be equal to last sample PTS + frameDuration\n          var frameDuration = getFrameDuration(track.samplerate);\n          pts = aacOverFlow.sample.pts + frameDuration;\n        } else {\n          logger.warn('[tsdemuxer]: AAC PES unknown PTS');\n          return;\n        }\n\n        // scan for aac samples\n        var frameIndex = 0;\n        var frame;\n        while (offset < len) {\n          frame = appendFrame$1(track, data, offset, pts, frameIndex);\n          offset += frame.length;\n          if (!frame.missing) {\n            frameIndex++;\n            for (; offset < len - 1; offset++) {\n              if (isHeader$1(data, offset)) {\n                break;\n              }\n            }\n          } else {\n            this.aacOverFlow = frame;\n            break;\n          }\n        }\n      };\n      _proto.parseMPEGPES = function parseMPEGPES(track, pes) {\n        var data = pes.data;\n        var length = data.length;\n        var frameIndex = 0;\n        var offset = 0;\n        var pts = pes.pts;\n        if (pts === undefined) {\n          logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\n          return;\n        }\n        while (offset < length) {\n          if (isHeader(data, offset)) {\n            var frame = appendFrame(track, data, offset, pts, frameIndex);\n            if (frame) {\n              offset += frame.length;\n              frameIndex++;\n            } else {\n              // logger.log('Unable to parse Mpeg audio frame');\n              break;\n            }\n          } else {\n            // nothing found, keep looking\n            offset++;\n          }\n        }\n      };\n      _proto.parseID3PES = function parseID3PES(id3Track, pes) {\n        if (pes.pts === undefined) {\n          logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\n          return;\n        }\n        var id3Sample = _extends({}, pes, {\n          type: this._avcTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY\n        });\n        id3Track.samples.push(id3Sample);\n      };\n      return TSDemuxer;\n    }();\n    function createAVCSample(key, pts, dts, debug) {\n      return {\n        key: key,\n        frame: false,\n        pts: pts,\n        dts: dts,\n        units: [],\n        debug: debug,\n        length: 0\n      };\n    }\n    function parsePID(data, offset) {\n      // pid is a 13-bit field starting at the last bit of TS[1]\n      return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n    }\n    function parsePAT(data, offset) {\n      // skip the PSI header and parse the first PMT entry\n      return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n    }\n    function parsePMT(data, offset, typeSupported, isSampleAes) {\n      var result = {\n        audio: -1,\n        avc: -1,\n        id3: -1,\n        segmentCodec: 'aac'\n      };\n      var sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n      var tableEnd = offset + 3 + sectionLength - 4;\n      // to determine where the table is, we have to figure out how\n      // long the program info descriptors are\n      var programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n      // advance the offset to the first entry in the mapping table\n      offset += 12 + programInfoLength;\n      while (offset < tableEnd) {\n        var pid = parsePID(data, offset);\n        switch (data[offset]) {\n          case 0xcf:\n            // SAMPLE-AES AAC\n            if (!isSampleAes) {\n              logger.log('ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream');\n              break;\n            }\n          /* falls through */\n          case 0x0f:\n            // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n            // logger.log('AAC PID:'  + pid);\n            if (result.audio === -1) {\n              result.audio = pid;\n            }\n            break;\n\n          // Packetized metadata (ID3)\n          case 0x15:\n            // logger.log('ID3 PID:'  + pid);\n            if (result.id3 === -1) {\n              result.id3 = pid;\n            }\n            break;\n          case 0xdb:\n            // SAMPLE-AES AVC\n            if (!isSampleAes) {\n              logger.log('H.264 with AES-128-CBC slice encryption found in unencrypted stream');\n              break;\n            }\n          /* falls through */\n          case 0x1b:\n            // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n            // logger.log('AVC PID:'  + pid);\n            if (result.avc === -1) {\n              result.avc = pid;\n            }\n            break;\n\n          // ISO/IEC 11172-3 (MPEG-1 audio)\n          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n          case 0x03:\n          case 0x04:\n            // logger.log('MPEG PID:'  + pid);\n            if (typeSupported.mpeg !== true && typeSupported.mp3 !== true) {\n              logger.log('MPEG audio found, not supported in this browser');\n            } else if (result.audio === -1) {\n              result.audio = pid;\n              result.segmentCodec = 'mp3';\n            }\n            break;\n          case 0x24:\n            logger.warn('Unsupported HEVC stream type found');\n            break;\n        }\n        // move to the next table entry\n        // skip past the elementary stream descriptors, if present\n        offset += ((data[offset + 3] & 0x0f) << 8 | data[offset + 4]) + 5;\n      }\n      return result;\n    }\n    function parsePES(stream) {\n      var i = 0;\n      var frag;\n      var pesLen;\n      var pesHdrLen;\n      var pesPts;\n      var pesDts;\n      var data = stream.data;\n      // safety check\n      if (!stream || stream.size === 0) {\n        return null;\n      }\n\n      // we might need up to 19 bytes to read PES header\n      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n      // usually only one merge is needed (and this is rare ...)\n      while (data[0].length < 19 && data.length > 1) {\n        var newData = new Uint8Array(data[0].length + data[1].length);\n        newData.set(data[0]);\n        newData.set(data[1], data[0].length);\n        data[0] = newData;\n        data.splice(1, 1);\n      }\n      // retrieve PTS/DTS from first fragment\n      frag = data[0];\n      var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n      if (pesPrefix === 1) {\n        pesLen = (frag[4] << 8) + frag[5];\n        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n        // minus 6 : PES header size\n        if (pesLen && pesLen > stream.size - 6) {\n          return null;\n        }\n        var pesFlags = frag[7];\n        if (pesFlags & 0xc0) {\n          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n              as Bitwise operators treat their operands as a sequence of 32 bits */\n          pesPts = (frag[9] & 0x0e) * 536870912 +\n          // 1 << 29\n          (frag[10] & 0xff) * 4194304 +\n          // 1 << 22\n          (frag[11] & 0xfe) * 16384 +\n          // 1 << 14\n          (frag[12] & 0xff) * 128 +\n          // 1 << 7\n          (frag[13] & 0xfe) / 2;\n          if (pesFlags & 0x40) {\n            pesDts = (frag[14] & 0x0e) * 536870912 +\n            // 1 << 29\n            (frag[15] & 0xff) * 4194304 +\n            // 1 << 22\n            (frag[16] & 0xfe) * 16384 +\n            // 1 << 14\n            (frag[17] & 0xff) * 128 +\n            // 1 << 7\n            (frag[18] & 0xfe) / 2;\n            if (pesPts - pesDts > 60 * 90000) {\n              logger.warn(Math.round((pesPts - pesDts) / 90000) + \"s delta between PTS and DTS, align them\");\n              pesPts = pesDts;\n            }\n          } else {\n            pesDts = pesPts;\n          }\n        }\n        pesHdrLen = frag[8];\n        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n        var payloadStartOffset = pesHdrLen + 9;\n        if (stream.size <= payloadStartOffset) {\n          return null;\n        }\n        stream.size -= payloadStartOffset;\n        // reassemble PES packet\n        var pesData = new Uint8Array(stream.size);\n        for (var j = 0, dataLen = data.length; j < dataLen; j++) {\n          frag = data[j];\n          var len = frag.byteLength;\n          if (payloadStartOffset) {\n            if (payloadStartOffset > len) {\n              // trim full frag if PES header bigger than frag\n              payloadStartOffset -= len;\n              continue;\n            } else {\n              // trim partial frag if PES header smaller than frag\n              frag = frag.subarray(payloadStartOffset);\n              len -= payloadStartOffset;\n              payloadStartOffset = 0;\n            }\n          }\n          pesData.set(frag, i);\n          i += len;\n        }\n        if (pesLen) {\n          // payload size : remove PES header + PES extension\n          pesLen -= pesHdrLen + 3;\n        }\n        return {\n          data: pesData,\n          pts: pesPts,\n          dts: pesDts,\n          len: pesLen\n        };\n      }\n      return null;\n    }\n    function pushAccessUnit(avcSample, avcTrack) {\n      if (avcSample.units.length && avcSample.frame) {\n        // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n        if (avcSample.pts === undefined) {\n          var samples = avcTrack.samples;\n          var nbSamples = samples.length;\n          if (nbSamples) {\n            var lastSample = samples[nbSamples - 1];\n            avcSample.pts = lastSample.pts;\n            avcSample.dts = lastSample.dts;\n          } else {\n            // dropping samples, no timestamp found\n            avcTrack.dropped++;\n            return;\n          }\n        }\n        avcTrack.samples.push(avcSample);\n      }\n      if (avcSample.debug.length) {\n        logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);\n      }\n    }\n    var MP3Demuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n      _inheritsLoose(MP3Demuxer, _BaseAudioDemuxer);\n      function MP3Demuxer() {\n        return _BaseAudioDemuxer.apply(this, arguments) || this;\n      }\n      var _proto = MP3Demuxer.prototype;\n      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n        this._audioTrack = {\n          container: 'audio/mpeg',\n          type: 'audio',\n          id: 2,\n          pid: -1,\n          sequenceNumber: 0,\n          segmentCodec: 'mp3',\n          samples: [],\n          manifestCodec: audioCodec,\n          duration: trackDuration,\n          inputTimeScale: 90000,\n          dropped: 0\n        };\n      };\n      MP3Demuxer.probe = function probe$1(data) {\n        if (!data) {\n          return false;\n        }\n\n        // check if data contains ID3 timestamp and MPEG sync word\n        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n        // More info http://www.mp3-tech.org/programmer/frame_header.html\n        var id3Data = getID3Data(data, 0) || [];\n        var offset = id3Data.length;\n        for (var length = data.length; offset < length; offset++) {\n          if (probe(data, offset)) {\n            logger.log('MPEG Audio sync word found !');\n            return true;\n          }\n        }\n        return false;\n      };\n      _proto.canParse = function canParse$1(data, offset) {\n        return canParse(data, offset);\n      };\n      _proto.appendFrame = function appendFrame$1(track, data, offset) {\n        if (this.basePTS === null) {\n          return;\n        }\n        return appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n      };\n      return MP3Demuxer;\n    }(BaseAudioDemuxer);\n\n    /**\n     *  AAC helper\n     */\n    var AAC = /*#__PURE__*/function () {\n      function AAC() {}\n      AAC.getSilentFrame = function getSilentFrame(codec, channelCount) {\n        switch (codec) {\n          case 'mp4a.40.2':\n            if (channelCount === 1) {\n              return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n            } else if (channelCount === 2) {\n              return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n            } else if (channelCount === 3) {\n              return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n            } else if (channelCount === 4) {\n              return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n            } else if (channelCount === 5) {\n              return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n            } else if (channelCount === 6) {\n              return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n            }\n            break;\n          // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n          default:\n            if (channelCount === 1) {\n              // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n              return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n            } else if (channelCount === 2) {\n              // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n              return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n            } else if (channelCount === 3) {\n              // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n              return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n            }\n            break;\n        }\n        return undefined;\n      };\n      return AAC;\n    }();\n\n    /**\n     * Generate MP4 Box\n     */\n\n    var UINT32_MAX = Math.pow(2, 32) - 1;\n    var MP4 = /*#__PURE__*/function () {\n      function MP4() {}\n      MP4.init = function init() {\n        MP4.types = {\n          avc1: [],\n          // codingname\n          avcC: [],\n          btrt: [],\n          dinf: [],\n          dref: [],\n          esds: [],\n          ftyp: [],\n          hdlr: [],\n          mdat: [],\n          mdhd: [],\n          mdia: [],\n          mfhd: [],\n          minf: [],\n          moof: [],\n          moov: [],\n          mp4a: [],\n          '.mp3': [],\n          mvex: [],\n          mvhd: [],\n          pasp: [],\n          sdtp: [],\n          stbl: [],\n          stco: [],\n          stsc: [],\n          stsd: [],\n          stsz: [],\n          stts: [],\n          tfdt: [],\n          tfhd: [],\n          traf: [],\n          trak: [],\n          trun: [],\n          trex: [],\n          tkhd: [],\n          vmhd: [],\n          smhd: []\n        };\n        var i;\n        for (i in MP4.types) {\n          if (MP4.types.hasOwnProperty(i)) {\n            MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n          }\n        }\n        var videoHdlr = new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x00,\n        // pre_defined\n        0x76, 0x69, 0x64, 0x65,\n        // handler_type: 'vide'\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n        ]);\n\n        var audioHdlr = new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x00,\n        // pre_defined\n        0x73, 0x6f, 0x75, 0x6e,\n        // handler_type: 'soun'\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n        ]);\n\n        MP4.HDLR_TYPES = {\n          video: videoHdlr,\n          audio: audioHdlr\n        };\n        var dref = new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x01,\n        // entry_count\n        0x00, 0x00, 0x00, 0x0c,\n        // entry_size\n        0x75, 0x72, 0x6c, 0x20,\n        // 'url' type\n        0x00,\n        // version 0\n        0x00, 0x00, 0x01 // entry_flags\n        ]);\n\n        var stco = new Uint8Array([0x00,\n        // version\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x00 // entry_count\n        ]);\n\n        MP4.STTS = MP4.STSC = MP4.STCO = stco;\n        MP4.STSZ = new Uint8Array([0x00,\n        // version\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x00,\n        // sample_size\n        0x00, 0x00, 0x00, 0x00 // sample_count\n        ]);\n\n        MP4.VMHD = new Uint8Array([0x00,\n        // version\n        0x00, 0x00, 0x01,\n        // flags\n        0x00, 0x00,\n        // graphicsmode\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n        ]);\n\n        MP4.SMHD = new Uint8Array([0x00,\n        // version\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00,\n        // balance\n        0x00, 0x00 // reserved\n        ]);\n\n        MP4.STSD = new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x01]); // entry_count\n\n        var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n        var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n        var minorVersion = new Uint8Array([0, 0, 0, 1]);\n        MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n        MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n      };\n      MP4.box = function box(type) {\n        var size = 8;\n        for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          payload[_key - 1] = arguments[_key];\n        }\n        var i = payload.length;\n        var len = i;\n        // calculate the total size we need to allocate\n        while (i--) {\n          size += payload[i].byteLength;\n        }\n        var result = new Uint8Array(size);\n        result[0] = size >> 24 & 0xff;\n        result[1] = size >> 16 & 0xff;\n        result[2] = size >> 8 & 0xff;\n        result[3] = size & 0xff;\n        result.set(type, 4);\n        // copy the payload into the result\n        for (i = 0, size = 8; i < len; i++) {\n          // copy payload[i] array @ offset size\n          result.set(payload[i], size);\n          size += payload[i].byteLength;\n        }\n        return result;\n      };\n      MP4.hdlr = function hdlr(type) {\n        return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n      };\n      MP4.mdat = function mdat(data) {\n        return MP4.box(MP4.types.mdat, data);\n      };\n      MP4.mdhd = function mdhd(timescale, duration) {\n        duration *= timescale;\n        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        return MP4.box(MP4.types.mdhd, new Uint8Array([0x01,\n        // version 1\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n        // creation_time\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n        // modification_time\n        timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n        // timescale\n        upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4,\n        // 'und' language (undetermined)\n        0x00, 0x00]));\n      };\n      MP4.mdia = function mdia(track) {\n        return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n      };\n      MP4.mfhd = function mfhd(sequenceNumber) {\n        return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n        // flags\n        sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n        ]));\n      };\n\n      MP4.minf = function minf(track) {\n        if (track.type === 'audio') {\n          return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n        } else {\n          return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n        }\n      };\n      MP4.moof = function moof(sn, baseMediaDecodeTime, track) {\n        return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n      };\n      MP4.moov = function moov(tracks) {\n        var i = tracks.length;\n        var boxes = [];\n        while (i--) {\n          boxes[i] = MP4.trak(tracks[i]);\n        }\n        return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n      };\n      MP4.mvex = function mvex(tracks) {\n        var i = tracks.length;\n        var boxes = [];\n        while (i--) {\n          boxes[i] = MP4.trex(tracks[i]);\n        }\n        return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));\n      };\n      MP4.mvhd = function mvhd(timescale, duration) {\n        duration *= timescale;\n        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        var bytes = new Uint8Array([0x01,\n        // version 1\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n        // creation_time\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n        // modification_time\n        timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n        // timescale\n        upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00,\n        // 1.0 rate\n        0x01, 0x00,\n        // 1.0 volume\n        0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n        // transformation: unity matrix\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // pre_defined\n        0xff, 0xff, 0xff, 0xff // next_track_ID\n        ]);\n\n        return MP4.box(MP4.types.mvhd, bytes);\n      };\n      MP4.sdtp = function sdtp(track) {\n        var samples = track.samples || [];\n        var bytes = new Uint8Array(4 + samples.length);\n        var i;\n        var flags;\n        // leave the full box header (4 bytes) all zero\n        // write the sample table\n        for (i = 0; i < samples.length; i++) {\n          flags = samples[i].flags;\n          bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n        }\n        return MP4.box(MP4.types.sdtp, bytes);\n      };\n      MP4.stbl = function stbl(track) {\n        return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n      };\n      MP4.avc1 = function avc1(track) {\n        var sps = [];\n        var pps = [];\n        var i;\n        var data;\n        var len;\n        // assemble the SPSs\n\n        for (i = 0; i < track.sps.length; i++) {\n          data = track.sps[i];\n          len = data.byteLength;\n          sps.push(len >>> 8 & 0xff);\n          sps.push(len & 0xff);\n\n          // SPS\n          sps = sps.concat(Array.prototype.slice.call(data));\n        }\n\n        // assemble the PPSs\n        for (i = 0; i < track.pps.length; i++) {\n          data = track.pps[i];\n          len = data.byteLength;\n          pps.push(len >>> 8 & 0xff);\n          pps.push(len & 0xff);\n          pps = pps.concat(Array.prototype.slice.call(data));\n        }\n        var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01,\n        // version\n        sps[3],\n        // profile\n        sps[4],\n        // profile compat\n        sps[5],\n        // level\n        0xfc | 3,\n        // lengthSizeMinusOne, hard-coded to 4 bytes\n        0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n        ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n        ]).concat(pps))); // \"PPS\"\n        var width = track.width;\n        var height = track.height;\n        var hSpacing = track.pixelRatio[0];\n        var vSpacing = track.pixelRatio[1];\n        return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01,\n        // data_reference_index\n        0x00, 0x00,\n        // pre_defined\n        0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // pre_defined\n        width >> 8 & 0xff, width & 0xff,\n        // width\n        height >> 8 & 0xff, height & 0xff,\n        // height\n        0x00, 0x48, 0x00, 0x00,\n        // horizresolution\n        0x00, 0x48, 0x00, 0x00,\n        // vertresolution\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01,\n        // frame_count\n        0x12, 0x64, 0x61, 0x69, 0x6c,\n        // dailymotion/hls.js\n        0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // compressorname\n        0x00, 0x18,\n        // depth = 24\n        0x11, 0x11]),\n        // pre_defined = -1\n        avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n        // bufferSizeDB\n        0x00, 0x2d, 0xc6, 0xc0,\n        // maxBitrate\n        0x00, 0x2d, 0xc6, 0xc0])),\n        // avgBitrate\n        MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n        // hSpacing\n        hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n        // vSpacing\n        vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n      };\n      MP4.esds = function esds(track) {\n        var configlen = track.config.length;\n        return new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n\n        0x03,\n        // descriptor_type\n        0x17 + configlen,\n        // length\n        0x00, 0x01,\n        // es_id\n        0x00,\n        // stream_priority\n\n        0x04,\n        // descriptor_type\n        0x0f + configlen,\n        // length\n        0x40,\n        // codec : mpeg4_audio\n        0x15,\n        // stream_type\n        0x00, 0x00, 0x00,\n        // buffer_size\n        0x00, 0x00, 0x00, 0x00,\n        // maxBitrate\n        0x00, 0x00, 0x00, 0x00,\n        // avgBitrate\n\n        0x05 // descriptor_type\n        ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n      };\n\n      MP4.mp4a = function mp4a(track) {\n        var samplerate = track.samplerate;\n        return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01,\n        // data_reference_index\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, track.channelCount,\n        // channelcount\n        0x00, 0x10,\n        // sampleSize:16bits\n        0x00, 0x00, 0x00, 0x00,\n        // reserved2\n        samplerate >> 8 & 0xff, samplerate & 0xff,\n        //\n        0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));\n      };\n      MP4.mp3 = function mp3(track) {\n        var samplerate = track.samplerate;\n        return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01,\n        // data_reference_index\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, track.channelCount,\n        // channelcount\n        0x00, 0x10,\n        // sampleSize:16bits\n        0x00, 0x00, 0x00, 0x00,\n        // reserved2\n        samplerate >> 8 & 0xff, samplerate & 0xff,\n        //\n        0x00, 0x00]));\n      };\n      MP4.stsd = function stsd(track) {\n        if (track.type === 'audio') {\n          if (track.segmentCodec === 'mp3' && track.codec === 'mp3') {\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n          }\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n        } else {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n        }\n      };\n      MP4.tkhd = function tkhd(track) {\n        var id = track.id;\n        var duration = track.duration * track.timescale;\n        var width = track.width;\n        var height = track.height;\n        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        return MP4.box(MP4.types.tkhd, new Uint8Array([0x01,\n        // version 1\n        0x00, 0x00, 0x07,\n        // flags\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n        // creation_time\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n        // modification_time\n        id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n        // track_ID\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00,\n        // layer\n        0x00, 0x00,\n        // alternate_group\n        0x00, 0x00,\n        // non-audio track volume\n        0x00, 0x00,\n        // reserved\n        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n        // transformation: unity matrix\n        width >> 8 & 0xff, width & 0xff, 0x00, 0x00,\n        // width\n        height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n        ]));\n      };\n\n      MP4.traf = function traf(track, baseMediaDecodeTime) {\n        var sampleDependencyTable = MP4.sdtp(track);\n        var id = track.id;\n        var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n        var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n        return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n        ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01,\n        // version 1\n        0x00, 0x00, 0x00,\n        // flags\n        upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 +\n        // tfhd\n        20 +\n        // tfdt\n        8 +\n        // traf header\n        16 +\n        // mfhd\n        8 +\n        // moof header\n        8),\n        // mdat header\n        sampleDependencyTable);\n      }\n\n      /**\n       * Generate a track box.\n       * @param track a track definition\n       */;\n      MP4.trak = function trak(track) {\n        track.duration = track.duration || 0xffffffff;\n        return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n      };\n      MP4.trex = function trex(track) {\n        var id = track.id;\n        return MP4.box(MP4.types.trex, new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n        // track_ID\n        0x00, 0x00, 0x00, 0x01,\n        // default_sample_description_index\n        0x00, 0x00, 0x00, 0x00,\n        // default_sample_duration\n        0x00, 0x00, 0x00, 0x00,\n        // default_sample_size\n        0x00, 0x01, 0x00, 0x01 // default_sample_flags\n        ]));\n      };\n\n      MP4.trun = function trun(track, offset) {\n        var samples = track.samples || [];\n        var len = samples.length;\n        var arraylen = 12 + 16 * len;\n        var array = new Uint8Array(arraylen);\n        var i;\n        var sample;\n        var duration;\n        var size;\n        var flags;\n        var cts;\n        offset += 8 + arraylen;\n        array.set([track.type === 'video' ? 0x01 : 0x00,\n        // version 1 for video with signed-int sample_composition_time_offset\n        0x00, 0x0f, 0x01,\n        // flags\n        len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff,\n        // sample_count\n        offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n        ], 0);\n        for (i = 0; i < len; i++) {\n          sample = samples[i];\n          duration = sample.duration;\n          size = sample.size;\n          flags = sample.flags;\n          cts = sample.cts;\n          array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff,\n          // sample_duration\n          size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff,\n          // sample_size\n          flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f,\n          // sample_flags\n          cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n          ], 12 + 16 * i);\n        }\n        return MP4.box(MP4.types.trun, array);\n      };\n      MP4.initSegment = function initSegment(tracks) {\n        if (!MP4.types) {\n          MP4.init();\n        }\n        var movie = MP4.moov(tracks);\n        var result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\n        result.set(MP4.FTYP);\n        result.set(movie, MP4.FTYP.byteLength);\n        return result;\n      };\n      return MP4;\n    }();\n    MP4.types = void 0;\n    MP4.HDLR_TYPES = void 0;\n    MP4.STTS = void 0;\n    MP4.STSC = void 0;\n    MP4.STCO = void 0;\n    MP4.STSZ = void 0;\n    MP4.VMHD = void 0;\n    MP4.SMHD = void 0;\n    MP4.STSD = void 0;\n    MP4.FTYP = void 0;\n    MP4.DINF = void 0;\n    var MPEG_TS_CLOCK_FREQ_HZ = 90000;\n    function toTimescaleFromBase(baseTime, destScale, srcBase, round) {\n      if (srcBase === void 0) {\n        srcBase = 1;\n      }\n      if (round === void 0) {\n        round = false;\n      }\n      var result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n      return round ? Math.round(result) : result;\n    }\n    function toMsFromMpegTsClock(baseTime, round) {\n      if (round === void 0) {\n        round = false;\n      }\n      return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n    }\n    var MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\n    var AAC_SAMPLES_PER_FRAME = 1024;\n    var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\n    var chromeVersion = null;\n    var safariWebkitVersion = null;\n    var MP4Remuxer = /*#__PURE__*/function () {\n      function MP4Remuxer(observer, config, typeSupported, vendor) {\n        this.observer = void 0;\n        this.config = void 0;\n        this.typeSupported = void 0;\n        this.ISGenerated = false;\n        this._initPTS = null;\n        this._initDTS = null;\n        this.nextAvcDts = null;\n        this.nextAudioPts = null;\n        this.videoSampleDuration = null;\n        this.isAudioContiguous = false;\n        this.isVideoContiguous = false;\n        this.observer = observer;\n        this.config = config;\n        this.typeSupported = typeSupported;\n        this.ISGenerated = false;\n        if (chromeVersion === null) {\n          var userAgent = navigator.userAgent || '';\n          var result = userAgent.match(/Chrome\\/(\\d+)/i);\n          chromeVersion = result ? parseInt(result[1]) : 0;\n        }\n        if (safariWebkitVersion === null) {\n          var _result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n          safariWebkitVersion = _result ? parseInt(_result[1]) : 0;\n        }\n      }\n      var _proto = MP4Remuxer.prototype;\n      _proto.destroy = function destroy() {};\n      _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {\n        logger.log('[mp4-remuxer]: initPTS & initDTS reset');\n        this._initPTS = this._initDTS = defaultTimeStamp;\n      };\n      _proto.resetNextTimestamp = function resetNextTimestamp() {\n        logger.log('[mp4-remuxer]: reset next timestamp');\n        this.isVideoContiguous = false;\n        this.isAudioContiguous = false;\n      };\n      _proto.resetInitSegment = function resetInitSegment() {\n        logger.log('[mp4-remuxer]: ISGenerated flag reset');\n        this.ISGenerated = false;\n      };\n      _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {\n        var rolloverDetected = false;\n        var startPTS = videoSamples.reduce(function (minPTS, sample) {\n          var delta = sample.pts - minPTS;\n          if (delta < -4294967296) {\n            // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n            rolloverDetected = true;\n            return normalizePts(minPTS, sample.pts);\n          } else if (delta > 0) {\n            return minPTS;\n          } else {\n            return sample.pts;\n          }\n        }, videoSamples[0].pts);\n        if (rolloverDetected) {\n          logger.debug('PTS rollover detected');\n        }\n        return startPTS;\n      };\n      _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n        var video;\n        var audio;\n        var initSegment;\n        var text;\n        var id3;\n        var independent;\n        var audioTimeOffset = timeOffset;\n        var videoTimeOffset = timeOffset;\n\n        // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n        // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n        // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n        // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n        // then we can remux one track without waiting for the other.\n        var hasAudio = audioTrack.pid > -1;\n        var hasVideo = videoTrack.pid > -1;\n        var length = videoTrack.samples.length;\n        var enoughAudioSamples = audioTrack.samples.length > 0;\n        var enoughVideoSamples = flush && length > 0 || length > 1;\n        var canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n        if (canRemuxAvc) {\n          if (!this.ISGenerated) {\n            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n          }\n          var isVideoContiguous = this.isVideoContiguous;\n          var firstKeyFrameIndex = -1;\n          var firstKeyFramePTS;\n          if (enoughVideoSamples) {\n            firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n            if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n              independent = true;\n              if (firstKeyFrameIndex > 0) {\n                logger.warn(\"[mp4-remuxer]: Dropped \" + firstKeyFrameIndex + \" out of \" + length + \" video samples due to a missing keyframe\");\n                var startPTS = this.getVideoStartPts(videoTrack.samples);\n                videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n                videoTrack.dropped += firstKeyFrameIndex;\n                videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n                firstKeyFramePTS = videoTimeOffset;\n              } else if (firstKeyFrameIndex === -1) {\n                logger.warn(\"[mp4-remuxer]: No keyframe found out of \" + length + \" video samples\");\n                independent = false;\n              }\n            }\n          }\n          if (this.ISGenerated) {\n            if (enoughAudioSamples && enoughVideoSamples) {\n              // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n              // if first audio DTS is not aligned with first video DTS then we need to take that into account\n              // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n              // drift between audio and video streams\n              var _startPTS = this.getVideoStartPts(videoTrack.samples);\n              var tsDelta = normalizePts(audioTrack.samples[0].pts, _startPTS) - _startPTS;\n              var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n              audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n              videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n            }\n\n            // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n            if (enoughAudioSamples) {\n              // if initSegment was generated without audio samples, regenerate it again\n              if (!audioTrack.samplerate) {\n                logger.warn('[mp4-remuxer]: regenerate InitSegment as audio detected');\n                initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n              }\n              audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n              if (enoughVideoSamples) {\n                var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n                // if initSegment was generated without video samples, regenerate it again\n                if (!videoTrack.inputTimeScale) {\n                  logger.warn('[mp4-remuxer]: regenerate InitSegment as video detected');\n                  initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n                }\n                video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n              }\n            } else if (enoughVideoSamples) {\n              video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n            }\n            if (video) {\n              video.firstKeyFrame = firstKeyFrameIndex;\n              video.independent = firstKeyFrameIndex !== -1;\n              video.firstKeyFramePTS = firstKeyFramePTS;\n            }\n          }\n        }\n\n        // Allow ID3 and text to remux, even if more audio/video samples are required\n        if (this.ISGenerated && this._initPTS && this._initDTS) {\n          if (id3Track.samples.length) {\n            id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n          }\n          if (textTrack.samples.length) {\n            text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n          }\n        }\n        return {\n          audio: audio,\n          video: video,\n          initSegment: initSegment,\n          independent: independent,\n          text: text,\n          id3: id3\n        };\n      };\n      _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {\n        var audioSamples = audioTrack.samples;\n        var videoSamples = videoTrack.samples;\n        var typeSupported = this.typeSupported;\n        var tracks = {};\n        var _initPTS = this._initPTS;\n        var computePTSDTS = !_initPTS || accurateTimeOffset;\n        var container = 'audio/mp4';\n        var initPTS;\n        var initDTS;\n        var timescale;\n        if (computePTSDTS) {\n          initPTS = initDTS = Infinity;\n        }\n        if (audioTrack.config && audioSamples.length) {\n          // let's use audio sampling rate as MP4 time scale.\n          // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n          // using audio sampling rate here helps having an integer MP4 frame duration\n          // this avoids potential rounding issue and AV sync issue\n          audioTrack.timescale = audioTrack.samplerate;\n          switch (audioTrack.segmentCodec) {\n            case 'mp3':\n              if (typeSupported.mpeg) {\n                // Chrome and Safari\n                container = 'audio/mpeg';\n                audioTrack.codec = '';\n              } else if (typeSupported.mp3) {\n                // Firefox\n                audioTrack.codec = 'mp3';\n              }\n              break;\n          }\n          tracks.audio = {\n            id: 'audio',\n            container: container,\n            codec: audioTrack.codec,\n            initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),\n            metadata: {\n              channelCount: audioTrack.channelCount\n            }\n          };\n          if (computePTSDTS) {\n            timescale = audioTrack.inputTimeScale;\n            if (!_initPTS || timescale !== _initPTS.timescale) {\n              // remember first PTS of this demuxing context. for audio, PTS = DTS\n              initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n            } else {\n              computePTSDTS = false;\n            }\n          }\n        }\n        if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n          // let's use input time scale as MP4 video timescale\n          // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n          videoTrack.timescale = videoTrack.inputTimeScale;\n          tracks.video = {\n            id: 'main',\n            container: 'video/mp4',\n            codec: videoTrack.codec,\n            initSegment: MP4.initSegment([videoTrack]),\n            metadata: {\n              width: videoTrack.width,\n              height: videoTrack.height\n            }\n          };\n          if (computePTSDTS) {\n            timescale = videoTrack.inputTimeScale;\n            if (!_initPTS || timescale !== _initPTS.timescale) {\n              var startPTS = this.getVideoStartPts(videoSamples);\n              var startOffset = Math.round(timescale * timeOffset);\n              initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n              initPTS = Math.min(initPTS, startPTS - startOffset);\n            } else {\n              computePTSDTS = false;\n            }\n          }\n        }\n        if (Object.keys(tracks).length) {\n          this.ISGenerated = true;\n          if (computePTSDTS) {\n            this._initPTS = {\n              baseTime: initPTS,\n              timescale: timescale\n            };\n            this._initDTS = {\n              baseTime: initDTS,\n              timescale: timescale\n            };\n          } else {\n            initPTS = timescale = undefined;\n          }\n          return {\n            tracks: tracks,\n            initPTS: initPTS,\n            timescale: timescale\n          };\n        }\n      };\n      _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n        var timeScale = track.inputTimeScale;\n        var inputSamples = track.samples;\n        var outputSamples = [];\n        var nbSamples = inputSamples.length;\n        var initPTS = this._initPTS;\n        var nextAvcDts = this.nextAvcDts;\n        var offset = 8;\n        var mp4SampleDuration = this.videoSampleDuration;\n        var firstDTS;\n        var lastDTS;\n        var minPTS = Number.POSITIVE_INFINITY;\n        var maxPTS = Number.NEGATIVE_INFINITY;\n        var sortSamples = false;\n\n        // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n        if (!contiguous || nextAvcDts === null) {\n          var pts = timeOffset * timeScale;\n          var cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n          // if not contiguous, let's use target timeOffset\n          nextAvcDts = pts - cts;\n        }\n\n        // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n        // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n        var initTime = initPTS.baseTime * timeScale / initPTS.timescale;\n        for (var i = 0; i < nbSamples; i++) {\n          var sample = inputSamples[i];\n          sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);\n          sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);\n          if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n            sortSamples = true;\n          }\n        }\n\n        // sort video samples by DTS then PTS then demux id order\n        if (sortSamples) {\n          inputSamples.sort(function (a, b) {\n            var deltadts = a.dts - b.dts;\n            var deltapts = a.pts - b.pts;\n            return deltadts || deltapts;\n          });\n        }\n\n        // Get first/last DTS\n        firstDTS = inputSamples[0].dts;\n        lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n        // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n        // set this constant duration as being the avg delta between consecutive DTS.\n        var inputDuration = lastDTS - firstDTS;\n        var averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n\n        // if fragment are contiguous, detect hole/overlapping between fragments\n        if (contiguous) {\n          // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n          var delta = firstDTS - nextAvcDts;\n          var foundHole = delta > averageSampleDuration;\n          var foundOverlap = delta < -1;\n          if (foundHole || foundOverlap) {\n            if (foundHole) {\n              logger.warn(\"AVC: \" + toMsFromMpegTsClock(delta, true) + \" ms (\" + delta + \"dts) hole between fragments detected, filling it\");\n            } else {\n              logger.warn(\"AVC: \" + toMsFromMpegTsClock(-delta, true) + \" ms (\" + delta + \"dts) overlapping between fragments detected\");\n            }\n            if (!foundOverlap || nextAvcDts >= inputSamples[0].pts) {\n              firstDTS = nextAvcDts;\n              var firstPTS = inputSamples[0].pts - delta;\n              inputSamples[0].dts = firstDTS;\n              inputSamples[0].pts = firstPTS;\n              logger.log(\"Video: First PTS/DTS adjusted: \" + toMsFromMpegTsClock(firstPTS, true) + \"/\" + toMsFromMpegTsClock(firstDTS, true) + \", delta: \" + toMsFromMpegTsClock(delta, true) + \" ms\");\n            }\n          }\n        }\n        firstDTS = Math.max(0, firstDTS);\n        var nbNalu = 0;\n        var naluLen = 0;\n        for (var _i = 0; _i < nbSamples; _i++) {\n          // compute total/avc sample length and nb of NAL units\n          var _sample = inputSamples[_i];\n          var units = _sample.units;\n          var nbUnits = units.length;\n          var sampleLen = 0;\n          for (var j = 0; j < nbUnits; j++) {\n            sampleLen += units[j].data.length;\n          }\n          naluLen += sampleLen;\n          nbNalu += nbUnits;\n          _sample.length = sampleLen;\n\n          // ensure sample monotonic DTS\n          _sample.dts = Math.max(_sample.dts, firstDTS);\n          minPTS = Math.min(_sample.pts, minPTS);\n          maxPTS = Math.max(_sample.pts, maxPTS);\n        }\n        lastDTS = inputSamples[nbSamples - 1].dts;\n\n        /* concatenate the video data and construct the mdat in place\n          (need 8 more bytes to fill length and mpdat type) */\n        var mdatSize = naluLen + 4 * nbNalu + 8;\n        var mdat;\n        try {\n          mdat = new Uint8Array(mdatSize);\n        } catch (err) {\n          this.observer.emit(Events.ERROR, Events.ERROR, {\n            type: ErrorTypes.MUX_ERROR,\n            details: ErrorDetails.REMUX_ALLOC_ERROR,\n            fatal: false,\n            error: err,\n            bytes: mdatSize,\n            reason: \"fail allocating video mdat \" + mdatSize\n          });\n          return;\n        }\n        var view = new DataView(mdat.buffer);\n        view.setUint32(0, mdatSize);\n        mdat.set(MP4.types.mdat, 4);\n        var stretchedLastFrame = false;\n        var minDtsDelta = Number.POSITIVE_INFINITY;\n        var minPtsDelta = Number.POSITIVE_INFINITY;\n        var maxDtsDelta = Number.NEGATIVE_INFINITY;\n        var maxPtsDelta = Number.NEGATIVE_INFINITY;\n        for (var _i2 = 0; _i2 < nbSamples; _i2++) {\n          var avcSample = inputSamples[_i2];\n          var avcSampleUnits = avcSample.units;\n          var mp4SampleLength = 0;\n          // convert NALU bitstream to MP4 format (prepend NALU with size field)\n          for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {\n            var unit = avcSampleUnits[_j];\n            var unitData = unit.data;\n            var unitDataLen = unit.data.byteLength;\n            view.setUint32(offset, unitDataLen);\n            offset += 4;\n            mdat.set(unitData, offset);\n            offset += unitDataLen;\n            mp4SampleLength += 4 + unitDataLen;\n          }\n\n          // expected sample duration is the Decoding Timestamp diff of consecutive samples\n          var ptsDelta = void 0;\n          if (_i2 < nbSamples - 1) {\n            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;\n            ptsDelta = inputSamples[_i2 + 1].pts - avcSample.pts;\n          } else {\n            var config = this.config;\n            var lastFrameDuration = _i2 > 0 ? avcSample.dts - inputSamples[_i2 - 1].dts : averageSampleDuration;\n            ptsDelta = _i2 > 0 ? avcSample.pts - inputSamples[_i2 - 1].pts : averageSampleDuration;\n            if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n              // In some cases, a segment's audio track duration may exceed the video track duration.\n              // Since we've already remuxed audio, and we know how long the audio track is, we look to\n              // see if the delta to the next segment is longer than maxBufferHole.\n              // If so, playback would potentially get stuck, so we artificially inflate\n              // the duration of the last frame to minimize any potential gap between segments.\n              var gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n              var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;\n              if (deltaToFrameEnd > gapTolerance) {\n                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n                // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n                if (mp4SampleDuration < 0) {\n                  mp4SampleDuration = lastFrameDuration;\n                } else {\n                  stretchedLastFrame = true;\n                }\n                logger.log(\"[mp4-remuxer]: It is approximately \" + deltaToFrameEnd / 90 + \" ms to the next segment; using duration \" + mp4SampleDuration / 90 + \" ms for the last video frame.\");\n              } else {\n                mp4SampleDuration = lastFrameDuration;\n              }\n            } else {\n              mp4SampleDuration = lastFrameDuration;\n            }\n          }\n          var compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);\n          minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n          maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n          minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n          maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n          outputSamples.push(new Mp4Sample(avcSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n        }\n        if (outputSamples.length) {\n          if (chromeVersion) {\n            if (chromeVersion < 70) {\n              // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n              // https://code.google.com/p/chromium/issues/detail?id=229412\n              var flags = outputSamples[0].flags;\n              flags.dependsOn = 2;\n              flags.isNonSync = 0;\n            }\n          } else if (safariWebkitVersion) {\n            // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n            // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n            if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n              logger.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.');\n              var dts = firstDTS;\n              for (var _i3 = 0, len = outputSamples.length; _i3 < len; _i3++) {\n                var nextDts = dts + outputSamples[_i3].duration;\n                var _pts = dts + outputSamples[_i3].cts;\n                if (_i3 < len - 1) {\n                  var nextPts = nextDts + outputSamples[_i3 + 1].cts;\n                  outputSamples[_i3].duration = nextPts - _pts;\n                } else {\n                  outputSamples[_i3].duration = _i3 ? outputSamples[_i3 - 1].duration : averageSampleDuration;\n                }\n                outputSamples[_i3].cts = 0;\n                dts = nextDts;\n              }\n            }\n          }\n        }\n        // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n        mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n        this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n        this.videoSampleDuration = mp4SampleDuration;\n        this.isVideoContiguous = true;\n        var moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {\n          samples: outputSamples\n        }));\n        var type = 'video';\n        var data = {\n          data1: moof,\n          data2: mdat,\n          startPTS: minPTS / timeScale,\n          endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n          startDTS: firstDTS / timeScale,\n          endDTS: nextAvcDts / timeScale,\n          type: type,\n          hasAudio: false,\n          hasVideo: true,\n          nb: outputSamples.length,\n          dropped: track.dropped\n        };\n        track.samples = [];\n        track.dropped = 0;\n        return data;\n      };\n      _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n        var inputTimeScale = track.inputTimeScale;\n        var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n        var scaleFactor = inputTimeScale / mp4timeScale;\n        var mp4SampleDuration = track.segmentCodec === 'aac' ? AAC_SAMPLES_PER_FRAME : MPEG_AUDIO_SAMPLE_PER_FRAME;\n        var inputSampleDuration = mp4SampleDuration * scaleFactor;\n        var initPTS = this._initPTS;\n        var rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n        var outputSamples = [];\n        var alignedWithVideo = videoTimeOffset !== undefined;\n        var inputSamples = track.samples;\n        var offset = rawMPEG ? 0 : 8;\n        var nextAudioPts = this.nextAudioPts || -1;\n\n        // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n        // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n        // for sake of clarity:\n        // consecutive fragments are frags with\n        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n        //  - less than 20 audio frames distance\n        // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n        // this helps ensuring audio continuity\n        // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n        var timeOffsetMpegTS = timeOffset * inputTimeScale;\n        var initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;\n        this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);\n\n        // compute normalized PTS\n        inputSamples.forEach(function (sample) {\n          sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);\n        });\n        if (!contiguous || nextAudioPts < 0) {\n          // filter out sample with negative PTS that are not playable anyway\n          // if we don't remove these negative samples, they will shift all audio samples forward.\n          // leading to audio overlap between current / next fragment\n          inputSamples = inputSamples.filter(function (sample) {\n            return sample.pts >= 0;\n          });\n\n          // in case all samples have negative PTS, and have been filtered out, return now\n          if (!inputSamples.length) {\n            return;\n          }\n          if (videoTimeOffset === 0) {\n            // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n            nextAudioPts = 0;\n          } else if (accurateTimeOffset && !alignedWithVideo) {\n            // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n            nextAudioPts = Math.max(0, timeOffsetMpegTS);\n          } else {\n            // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n            nextAudioPts = inputSamples[0].pts;\n          }\n        }\n\n        // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n        // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n        // In an effort to prevent this from happening, we inject frames here where there are gaps.\n        // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n        // frame.\n\n        if (track.segmentCodec === 'aac') {\n          var maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n          for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {\n            // First, let's see how far off this frame is from where we expect it to be\n            var sample = inputSamples[i];\n            var pts = sample.pts;\n            var delta = pts - nextPts;\n            var duration = Math.abs(1000 * delta / inputTimeScale);\n\n            // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n            if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n              if (i === 0) {\n                logger.warn(\"Audio frame @ \" + (pts / inputTimeScale).toFixed(3) + \"s overlaps nextAudioPts by \" + Math.round(1000 * delta / inputTimeScale) + \" ms.\");\n                this.nextAudioPts = nextAudioPts = nextPts = pts;\n              }\n            } // eslint-disable-line brace-style\n\n            // Insert missing frames if:\n            // 1: We're more than maxAudioFramesDrift frame away\n            // 2: Not more than MAX_SILENT_FRAME_DURATION away\n            // 3: currentTime (aka nextPtsNorm) is not 0\n            // 4: remuxing with video (videoTimeOffset !== undefined)\n            else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n              var missing = Math.round(delta / inputSampleDuration);\n              // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n              // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n              nextPts = pts - missing * inputSampleDuration;\n              if (nextPts < 0) {\n                missing--;\n                nextPts += inputSampleDuration;\n              }\n              if (i === 0) {\n                this.nextAudioPts = nextAudioPts = nextPts;\n              }\n              logger.warn(\"[mp4-remuxer]: Injecting \" + missing + \" audio frame @ \" + (nextPts / inputTimeScale).toFixed(3) + \"s due to \" + Math.round(1000 * delta / inputTimeScale) + \" ms gap.\");\n              for (var j = 0; j < missing; j++) {\n                var newStamp = Math.max(nextPts, 0);\n                var fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                if (!fillFrame) {\n                  logger.log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.');\n                  fillFrame = sample.unit.subarray();\n                }\n                inputSamples.splice(i, 0, {\n                  unit: fillFrame,\n                  pts: newStamp\n                });\n                nextPts += inputSampleDuration;\n                i++;\n              }\n            }\n            sample.pts = nextPts;\n            nextPts += inputSampleDuration;\n          }\n        }\n        var firstPTS = null;\n        var lastPTS = null;\n        var mdat;\n        var mdatSize = 0;\n        var sampleLength = inputSamples.length;\n        while (sampleLength--) {\n          mdatSize += inputSamples[sampleLength].unit.byteLength;\n        }\n        for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {\n          var audioSample = inputSamples[_j2];\n          var unit = audioSample.unit;\n          var _pts2 = audioSample.pts;\n          if (lastPTS !== null) {\n            // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n            // the previous sample\n            var prevSample = outputSamples[_j2 - 1];\n            prevSample.duration = Math.round((_pts2 - lastPTS) / scaleFactor);\n          } else {\n            if (contiguous && track.segmentCodec === 'aac') {\n              // set PTS/DTS to expected PTS/DTS\n              _pts2 = nextAudioPts;\n            }\n            // remember first PTS of our audioSamples\n            firstPTS = _pts2;\n            if (mdatSize > 0) {\n              /* concatenate the audio data and construct the mdat in place\n                (need 8 more bytes to fill length and mdat type) */\n              mdatSize += offset;\n              try {\n                mdat = new Uint8Array(mdatSize);\n              } catch (err) {\n                this.observer.emit(Events.ERROR, Events.ERROR, {\n                  type: ErrorTypes.MUX_ERROR,\n                  details: ErrorDetails.REMUX_ALLOC_ERROR,\n                  fatal: false,\n                  error: err,\n                  bytes: mdatSize,\n                  reason: \"fail allocating audio mdat \" + mdatSize\n                });\n                return;\n              }\n              if (!rawMPEG) {\n                var view = new DataView(mdat.buffer);\n                view.setUint32(0, mdatSize);\n                mdat.set(MP4.types.mdat, 4);\n              }\n            } else {\n              // no audio samples\n              return;\n            }\n          }\n          mdat.set(unit, offset);\n          var unitLen = unit.byteLength;\n          offset += unitLen;\n          // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n          // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n          // becomes the PTS diff with the previous sample\n          outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n          lastPTS = _pts2;\n        }\n\n        // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n        var nbSamples = outputSamples.length;\n        if (!nbSamples) {\n          return;\n        }\n\n        // The next audio sample PTS should be equal to last sample PTS + duration\n        var lastSample = outputSamples[outputSamples.length - 1];\n        this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;\n\n        // Set the track samples from inputSamples to outputSamples before remuxing\n        var moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n          samples: outputSamples\n        }));\n\n        // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n        track.samples = [];\n        var start = firstPTS / inputTimeScale;\n        var end = nextAudioPts / inputTimeScale;\n        var type = 'audio';\n        var audioData = {\n          data1: moof,\n          data2: mdat,\n          startPTS: start,\n          endPTS: end,\n          startDTS: start,\n          endDTS: end,\n          type: type,\n          hasAudio: true,\n          hasVideo: false,\n          nb: nbSamples\n        };\n        this.isAudioContiguous = true;\n        return audioData;\n      };\n      _proto.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n        var inputTimeScale = track.inputTimeScale;\n        var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n        var scaleFactor = inputTimeScale / mp4timeScale;\n        var nextAudioPts = this.nextAudioPts;\n        // sync with video's timestamp\n        var initDTS = this._initDTS;\n        var init90kHz = initDTS.baseTime * 90000 / initDTS.timescale;\n        var startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;\n        var endDTS = videoData.endDTS * inputTimeScale + init90kHz;\n        // one sample's duration value\n        var frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;\n        // samples count of this segment's duration\n        var nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);\n        // silent frame\n        var silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n        logger.warn('[mp4-remuxer]: remux empty Audio');\n        // Can't remux if we can't generate a silent frame...\n        if (!silentFrame) {\n          logger.trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec');\n          return;\n        }\n        var samples = [];\n        for (var i = 0; i < nbSamples; i++) {\n          var stamp = startDTS + i * frameDuration;\n          samples.push({\n            unit: silentFrame,\n            pts: stamp,\n            dts: stamp\n          });\n        }\n        track.samples = samples;\n        return this.remuxAudio(track, timeOffset, contiguous, false);\n      };\n      return MP4Remuxer;\n    }();\n    function normalizePts(value, reference) {\n      var offset;\n      if (reference === null) {\n        return value;\n      }\n      if (reference < value) {\n        // - 2^33\n        offset = -8589934592;\n      } else {\n        // + 2^33\n        offset = 8589934592;\n      }\n      /* PTS is 33bit (from 0 to 2^33 -1)\n        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n        PTS looping occured. fill the gap */\n      while (Math.abs(value - reference) > 4294967296) {\n        value += offset;\n      }\n      return value;\n    }\n    function findKeyframeIndex(samples) {\n      for (var i = 0; i < samples.length; i++) {\n        if (samples[i].key) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n      var length = track.samples.length;\n      if (!length) {\n        return;\n      }\n      var inputTimeScale = track.inputTimeScale;\n      for (var index = 0; index < length; index++) {\n        var sample = track.samples[index];\n        // setting id3 pts, dts to relative time\n        // using this._initPTS and this._initDTS to calculate relative time\n        sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n        sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n      }\n      var samples = track.samples;\n      track.samples = [];\n      return {\n        samples: samples\n      };\n    }\n    function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n      var length = track.samples.length;\n      if (!length) {\n        return;\n      }\n      var inputTimeScale = track.inputTimeScale;\n      for (var index = 0; index < length; index++) {\n        var sample = track.samples[index];\n        // setting text pts, dts to relative time\n        // using this._initPTS and this._initDTS to calculate relative time\n        sample.pts = normalizePts(sample.pts - initPTS.baseTime * 90000 / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n      }\n      track.samples.sort(function (a, b) {\n        return a.pts - b.pts;\n      });\n      var samples = track.samples;\n      track.samples = [];\n      return {\n        samples: samples\n      };\n    }\n    var Mp4Sample = function Mp4Sample(isKeyframe, duration, size, cts) {\n      this.size = void 0;\n      this.duration = void 0;\n      this.cts = void 0;\n      this.flags = void 0;\n      this.duration = duration;\n      this.size = size;\n      this.cts = cts;\n      this.flags = new Mp4SampleFlags(isKeyframe);\n    };\n    var Mp4SampleFlags = function Mp4SampleFlags(isKeyframe) {\n      this.isLeading = 0;\n      this.isDependedOn = 0;\n      this.hasRedundancy = 0;\n      this.degradPrio = 0;\n      this.dependsOn = 1;\n      this.isNonSync = 1;\n      this.dependsOn = isKeyframe ? 2 : 1;\n      this.isNonSync = isKeyframe ? 0 : 1;\n    };\n    var PassThroughRemuxer = /*#__PURE__*/function () {\n      function PassThroughRemuxer() {\n        this.emitInitSegment = false;\n        this.audioCodec = void 0;\n        this.videoCodec = void 0;\n        this.initData = void 0;\n        this.initPTS = null;\n        this.initTracks = void 0;\n        this.lastEndTime = null;\n      }\n      var _proto = PassThroughRemuxer.prototype;\n      _proto.destroy = function destroy() {};\n      _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {\n        this.initPTS = defaultInitPTS;\n        this.lastEndTime = null;\n      };\n      _proto.resetNextTimestamp = function resetNextTimestamp() {\n        this.lastEndTime = null;\n      };\n      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n        this.audioCodec = audioCodec;\n        this.videoCodec = videoCodec;\n        this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));\n        this.emitInitSegment = true;\n      };\n      _proto.generateInitSegment = function generateInitSegment(initSegment) {\n        var audioCodec = this.audioCodec,\n          videoCodec = this.videoCodec;\n        if (!(initSegment != null && initSegment.byteLength)) {\n          this.initTracks = undefined;\n          this.initData = undefined;\n          return;\n        }\n        var initData = this.initData = parseInitSegment(initSegment);\n\n        // Get codec from initSegment or fallback to default\n        if (!audioCodec) {\n          audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);\n        }\n        if (!videoCodec) {\n          videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);\n        }\n        var tracks = {};\n        if (initData.audio && initData.video) {\n          tracks.audiovideo = {\n            container: 'video/mp4',\n            codec: audioCodec + ',' + videoCodec,\n            initSegment: initSegment,\n            id: 'main'\n          };\n        } else if (initData.audio) {\n          tracks.audio = {\n            container: 'audio/mp4',\n            codec: audioCodec,\n            initSegment: initSegment,\n            id: 'audio'\n          };\n        } else if (initData.video) {\n          tracks.video = {\n            container: 'video/mp4',\n            codec: videoCodec,\n            initSegment: initSegment,\n            id: 'main'\n          };\n        } else {\n          logger.warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.');\n        }\n        this.initTracks = tracks;\n      };\n      _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {\n        var _initData, _initData2;\n        var initPTS = this.initPTS,\n          lastEndTime = this.lastEndTime;\n        var result = {\n          audio: undefined,\n          video: undefined,\n          text: textTrack,\n          id3: id3Track,\n          initSegment: undefined\n        };\n\n        // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n        // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n        // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n        if (!isFiniteNumber(lastEndTime)) {\n          lastEndTime = this.lastEndTime = timeOffset || 0;\n        }\n\n        // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n        // audio or video (or both); adding it to video was an arbitrary choice.\n        var data = videoTrack.samples;\n        if (!(data != null && data.length)) {\n          return result;\n        }\n        var initSegment = {\n          initPTS: undefined,\n          timescale: 1\n        };\n        var initData = this.initData;\n        if (!((_initData = initData) != null && _initData.length)) {\n          this.generateInitSegment(data);\n          initData = this.initData;\n        }\n        if (!((_initData2 = initData) != null && _initData2.length)) {\n          // We can't remux if the initSegment could not be generated\n          logger.warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');\n          return result;\n        }\n        if (this.emitInitSegment) {\n          initSegment.tracks = this.initTracks;\n          this.emitInitSegment = false;\n        }\n        var duration = getDuration(data, initData);\n        var startDTS = getStartDTS(initData, data);\n        var decodeTime = startDTS === null ? timeOffset : startDTS;\n        if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {\n          initSegment.initPTS = decodeTime - timeOffset;\n          if (initPTS && initPTS.timescale === 1) {\n            logger.warn(\"Adjusting initPTS by \" + (initSegment.initPTS - initPTS.baseTime));\n          }\n          this.initPTS = initPTS = {\n            baseTime: initSegment.initPTS,\n            timescale: 1\n          };\n        }\n        var startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;\n        var endTime = startTime + duration;\n        offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);\n        if (duration > 0) {\n          this.lastEndTime = endTime;\n        } else {\n          logger.warn('Duration parsed from mp4 should be greater than zero');\n          this.resetNextTimestamp();\n        }\n        var hasAudio = !!initData.audio;\n        var hasVideo = !!initData.video;\n        var type = '';\n        if (hasAudio) {\n          type += 'audio';\n        }\n        if (hasVideo) {\n          type += 'video';\n        }\n        var track = {\n          data1: data,\n          startPTS: startTime,\n          startDTS: startTime,\n          endPTS: endTime,\n          endDTS: endTime,\n          type: type,\n          hasAudio: hasAudio,\n          hasVideo: hasVideo,\n          nb: 1,\n          dropped: 0\n        };\n        result.audio = track.type === 'audio' ? track : undefined;\n        result.video = track.type !== 'audio' ? track : undefined;\n        result.initSegment = initSegment;\n        result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);\n        if (textTrack.samples.length) {\n          result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);\n        }\n        return result;\n      };\n      return PassThroughRemuxer;\n    }();\n    function isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {\n      if (initPTS === null) {\n        return true;\n      }\n      // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n      var minDuration = Math.max(duration, 1);\n      var startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n      return Math.abs(startTime - timeOffset) > minDuration;\n    }\n    function getParsedTrackCodec(track, type) {\n      var parsedCodec = track == null ? void 0 : track.codec;\n      if (parsedCodec && parsedCodec.length > 4) {\n        return parsedCodec;\n      }\n      // Since mp4-tools cannot parse full codec string (see 'TODO: Parse codec details'... in mp4-tools)\n      // Provide defaults based on codec type\n      // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n      if (parsedCodec === 'hvc1' || parsedCodec === 'hev1') {\n        return 'hvc1.1.6.L120.90';\n      }\n      if (parsedCodec === 'av01') {\n        return 'av01.0.04M.08';\n      }\n      if (parsedCodec === 'avc1' || type === ElementaryStreamTypes.VIDEO) {\n        return 'avc1.42e01e';\n      }\n      return 'mp4a.40.5';\n    }\n    var now;\n    // performance.now() not available on WebWorker, at least on Safari Desktop\n    try {\n      now = self.performance.now.bind(self.performance);\n    } catch (err) {\n      logger.debug('Unable to use Performance API on this environment');\n      now = typeof self !== 'undefined' && self.Date.now;\n    }\n    var muxConfig = [{\n      demux: MP4Demuxer,\n      remux: PassThroughRemuxer\n    }, {\n      demux: TSDemuxer,\n      remux: MP4Remuxer\n    }, {\n      demux: AACDemuxer,\n      remux: MP4Remuxer\n    }, {\n      demux: MP3Demuxer,\n      remux: MP4Remuxer\n    }];\n    var Transmuxer = /*#__PURE__*/function () {\n      function Transmuxer(observer, typeSupported, config, vendor, id) {\n        this.async = false;\n        this.observer = void 0;\n        this.typeSupported = void 0;\n        this.config = void 0;\n        this.vendor = void 0;\n        this.id = void 0;\n        this.demuxer = void 0;\n        this.remuxer = void 0;\n        this.decrypter = void 0;\n        this.probe = void 0;\n        this.decryptionPromise = null;\n        this.transmuxConfig = void 0;\n        this.currentTransmuxState = void 0;\n        this.observer = observer;\n        this.typeSupported = typeSupported;\n        this.config = config;\n        this.vendor = vendor;\n        this.id = id;\n      }\n      var _proto = Transmuxer.prototype;\n      _proto.configure = function configure(transmuxConfig) {\n        this.transmuxConfig = transmuxConfig;\n        if (this.decrypter) {\n          this.decrypter.reset();\n        }\n      };\n      _proto.push = function push(data, decryptdata, chunkMeta, state) {\n        var _this = this;\n        var stats = chunkMeta.transmuxing;\n        stats.executeStart = now();\n        var uintData = new Uint8Array(data);\n        var currentTransmuxState = this.currentTransmuxState,\n          transmuxConfig = this.transmuxConfig;\n        if (state) {\n          this.currentTransmuxState = state;\n        }\n        var _ref = state || currentTransmuxState,\n          contiguous = _ref.contiguous,\n          discontinuity = _ref.discontinuity,\n          trackSwitch = _ref.trackSwitch,\n          accurateTimeOffset = _ref.accurateTimeOffset,\n          timeOffset = _ref.timeOffset,\n          initSegmentChange = _ref.initSegmentChange;\n        var audioCodec = transmuxConfig.audioCodec,\n          videoCodec = transmuxConfig.videoCodec,\n          defaultInitPts = transmuxConfig.defaultInitPts,\n          duration = transmuxConfig.duration,\n          initSegmentData = transmuxConfig.initSegmentData;\n        var keyData = getEncryptionType(uintData, decryptdata);\n        if (keyData && keyData.method === 'AES-128') {\n          var decrypter = this.getDecrypter();\n          // Software decryption is synchronous; webCrypto is not\n          if (decrypter.isSync()) {\n            // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n            // data is handled in the flush() call\n            var decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);\n            // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n            var loadingParts = chunkMeta.part > -1;\n            if (loadingParts) {\n              decryptedData = decrypter.flush();\n            }\n            if (!decryptedData) {\n              stats.executeEnd = now();\n              return emptyResult(chunkMeta);\n            }\n            uintData = new Uint8Array(decryptedData);\n          } else {\n            this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(function (decryptedData) {\n              // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n              // the decrypted data has been transmuxed\n              var result = _this.push(decryptedData, null, chunkMeta);\n              _this.decryptionPromise = null;\n              return result;\n            });\n            return this.decryptionPromise;\n          }\n        }\n        var resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n        if (resetMuxers) {\n          var error = this.configureTransmuxer(uintData);\n          if (error) {\n            logger.warn(\"[transmuxer] \" + error.message);\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.FRAG_PARSING_ERROR,\n              fatal: false,\n              error: error,\n              reason: error.message\n            });\n            stats.executeEnd = now();\n            return emptyResult(chunkMeta);\n          }\n        }\n        if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n          this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n        }\n        if (discontinuity || initSegmentChange || resetMuxers) {\n          this.resetInitialTimestamp(defaultInitPts);\n        }\n        if (!contiguous) {\n          this.resetContiguity();\n        }\n        var result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n        var currentState = this.currentTransmuxState;\n        currentState.contiguous = true;\n        currentState.discontinuity = false;\n        currentState.trackSwitch = false;\n        stats.executeEnd = now();\n        return result;\n      }\n\n      // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n      ;\n\n      _proto.flush = function flush(chunkMeta) {\n        var _this2 = this;\n        var stats = chunkMeta.transmuxing;\n        stats.executeStart = now();\n        var decrypter = this.decrypter,\n          currentTransmuxState = this.currentTransmuxState,\n          decryptionPromise = this.decryptionPromise;\n        if (decryptionPromise) {\n          // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n          // only flushing is required for async decryption\n          return decryptionPromise.then(function () {\n            return _this2.flush(chunkMeta);\n          });\n        }\n        var transmuxResults = [];\n        var timeOffset = currentTransmuxState.timeOffset;\n        if (decrypter) {\n          // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n          // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n          // or for progressive downloads with small segments)\n          var decryptedData = decrypter.flush();\n          if (decryptedData) {\n            // Push always returns a TransmuxerResult if decryptdata is null\n            transmuxResults.push(this.push(decryptedData, null, chunkMeta));\n          }\n        }\n        var demuxer = this.demuxer,\n          remuxer = this.remuxer;\n        if (!demuxer || !remuxer) {\n          // If probing failed, then Hls.js has been given content its not able to handle\n          stats.executeEnd = now();\n          return [emptyResult(chunkMeta)];\n        }\n        var demuxResultOrPromise = demuxer.flush(timeOffset);\n        if (isPromise(demuxResultOrPromise)) {\n          // Decrypt final SAMPLE-AES samples\n          return demuxResultOrPromise.then(function (demuxResult) {\n            _this2.flushRemux(transmuxResults, demuxResult, chunkMeta);\n            return transmuxResults;\n          });\n        }\n        this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n        return transmuxResults;\n      };\n      _proto.flushRemux = function flushRemux(transmuxResults, demuxResult, chunkMeta) {\n        var audioTrack = demuxResult.audioTrack,\n          videoTrack = demuxResult.videoTrack,\n          id3Track = demuxResult.id3Track,\n          textTrack = demuxResult.textTrack;\n        var _this$currentTransmux = this.currentTransmuxState,\n          accurateTimeOffset = _this$currentTransmux.accurateTimeOffset,\n          timeOffset = _this$currentTransmux.timeOffset;\n        logger.log(\"[transmuxer.ts]: Flushed fragment \" + chunkMeta.sn + (chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : '') + \" of level \" + chunkMeta.level);\n        var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n        transmuxResults.push({\n          remuxResult: remuxResult,\n          chunkMeta: chunkMeta\n        });\n        chunkMeta.transmuxing.executeEnd = now();\n      };\n      _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {\n        var demuxer = this.demuxer,\n          remuxer = this.remuxer;\n        if (!demuxer || !remuxer) {\n          return;\n        }\n        demuxer.resetTimeStamp(defaultInitPts);\n        remuxer.resetTimeStamp(defaultInitPts);\n      };\n      _proto.resetContiguity = function resetContiguity() {\n        var demuxer = this.demuxer,\n          remuxer = this.remuxer;\n        if (!demuxer || !remuxer) {\n          return;\n        }\n        demuxer.resetContiguity();\n        remuxer.resetNextTimestamp();\n      };\n      _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n        var demuxer = this.demuxer,\n          remuxer = this.remuxer;\n        if (!demuxer || !remuxer) {\n          return;\n        }\n        demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n        remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n      };\n      _proto.destroy = function destroy() {\n        if (this.demuxer) {\n          this.demuxer.destroy();\n          this.demuxer = undefined;\n        }\n        if (this.remuxer) {\n          this.remuxer.destroy();\n          this.remuxer = undefined;\n        }\n      };\n      _proto.transmux = function transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n        var result;\n        if (keyData && keyData.method === 'SAMPLE-AES') {\n          result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n        } else {\n          result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n        }\n        return result;\n      };\n      _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n        var _demux = this.demuxer.demux(data, timeOffset, false, !this.config.progressive),\n          audioTrack = _demux.audioTrack,\n          videoTrack = _demux.videoTrack,\n          id3Track = _demux.id3Track,\n          textTrack = _demux.textTrack;\n        var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n        return {\n          remuxResult: remuxResult,\n          chunkMeta: chunkMeta\n        };\n      };\n      _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n        var _this3 = this;\n        return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function (demuxResult) {\n          var remuxResult = _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, _this3.id);\n          return {\n            remuxResult: remuxResult,\n            chunkMeta: chunkMeta\n          };\n        });\n      };\n      _proto.configureTransmuxer = function configureTransmuxer(data) {\n        var config = this.config,\n          observer = this.observer,\n          typeSupported = this.typeSupported,\n          vendor = this.vendor;\n        // probe for content type\n        var mux;\n        for (var i = 0, len = muxConfig.length; i < len; i++) {\n          if (muxConfig[i].demux.probe(data)) {\n            mux = muxConfig[i];\n            break;\n          }\n        }\n        if (!mux) {\n          return new Error('Failed to find demuxer by probing fragment data');\n        }\n        // so let's check that current remuxer and demuxer are still valid\n        var demuxer = this.demuxer;\n        var remuxer = this.remuxer;\n        var Remuxer = mux.remux;\n        var Demuxer = mux.demux;\n        if (!remuxer || !(remuxer instanceof Remuxer)) {\n          this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n        }\n        if (!demuxer || !(demuxer instanceof Demuxer)) {\n          this.demuxer = new Demuxer(observer, config, typeSupported);\n          this.probe = Demuxer.probe;\n        }\n      };\n      _proto.needsProbing = function needsProbing(discontinuity, trackSwitch) {\n        // in case of continuity change, or track switch\n        // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n        return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n      };\n      _proto.getDecrypter = function getDecrypter() {\n        var decrypter = this.decrypter;\n        if (!decrypter) {\n          decrypter = this.decrypter = new Decrypter(this.config);\n        }\n        return decrypter;\n      };\n      return Transmuxer;\n    }();\n    function getEncryptionType(data, decryptData) {\n      var encryptionType = null;\n      if (data.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.iv !== null && decryptData.method != null) {\n        encryptionType = decryptData;\n      }\n      return encryptionType;\n    }\n    var emptyResult = function emptyResult(chunkMeta) {\n      return {\n        remuxResult: {},\n        chunkMeta: chunkMeta\n      };\n    };\n    function isPromise(p) {\n      return 'then' in p && p.then instanceof Function;\n    }\n    var TransmuxConfig = function TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n      this.audioCodec = void 0;\n      this.videoCodec = void 0;\n      this.initSegmentData = void 0;\n      this.duration = void 0;\n      this.defaultInitPts = void 0;\n      this.audioCodec = audioCodec;\n      this.videoCodec = videoCodec;\n      this.initSegmentData = initSegmentData;\n      this.duration = duration;\n      this.defaultInitPts = defaultInitPts || null;\n    };\n    var TransmuxState = function TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n      this.discontinuity = void 0;\n      this.contiguous = void 0;\n      this.accurateTimeOffset = void 0;\n      this.trackSwitch = void 0;\n      this.timeOffset = void 0;\n      this.initSegmentChange = void 0;\n      this.discontinuity = discontinuity;\n      this.contiguous = contiguous;\n      this.accurateTimeOffset = accurateTimeOffset;\n      this.trackSwitch = trackSwitch;\n      this.timeOffset = timeOffset;\n      this.initSegmentChange = initSegmentChange;\n    };\n    var eventemitter3 = {\n      exports: {}\n    };\n    (function (module) {\n      var has = Object.prototype.hasOwnProperty,\n        prefix = '~';\n\n      /**\n       * Constructor to create a storage for our `EE` objects.\n       * An `Events` instance is a plain object whose properties are event names.\n       *\n       * @constructor\n       * @private\n       */\n      function Events() {}\n\n      //\n      // We try to not inherit from `Object.prototype`. In some engines creating an\n      // instance in this way is faster than calling `Object.create(null)` directly.\n      // If `Object.create(null)` is not supported we prefix the event names with a\n      // character to make sure that the built-in object properties are not\n      // overridden or used as an attack vector.\n      //\n      if (Object.create) {\n        Events.prototype = Object.create(null);\n\n        //\n        // This hack is needed because the `__proto__` property is still inherited in\n        // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n        //\n        if (!new Events().__proto__) prefix = false;\n      }\n\n      /**\n       * Representation of a single event listener.\n       *\n       * @param {Function} fn The listener function.\n       * @param {*} context The context to invoke the listener with.\n       * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n       * @constructor\n       * @private\n       */\n      function EE(fn, context, once) {\n        this.fn = fn;\n        this.context = context;\n        this.once = once || false;\n      }\n\n      /**\n       * Add a listener for a given event.\n       *\n       * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n       * @param {(String|Symbol)} event The event name.\n       * @param {Function} fn The listener function.\n       * @param {*} context The context to invoke the listener with.\n       * @param {Boolean} once Specify if the listener is a one-time listener.\n       * @returns {EventEmitter}\n       * @private\n       */\n      function addListener(emitter, event, fn, context, once) {\n        if (typeof fn !== 'function') {\n          throw new TypeError('The listener must be a function');\n        }\n        var listener = new EE(fn, context || emitter, once),\n          evt = prefix ? prefix + event : event;\n        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];\n        return emitter;\n      }\n\n      /**\n       * Clear event by name.\n       *\n       * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n       * @param {(String|Symbol)} evt The Event name.\n       * @private\n       */\n      function clearEvent(emitter, evt) {\n        if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];\n      }\n\n      /**\n       * Minimal `EventEmitter` interface that is molded against the Node.js\n       * `EventEmitter` interface.\n       *\n       * @constructor\n       * @public\n       */\n      function EventEmitter() {\n        this._events = new Events();\n        this._eventsCount = 0;\n      }\n\n      /**\n       * Return an array listing the events for which the emitter has registered\n       * listeners.\n       *\n       * @returns {Array}\n       * @public\n       */\n      EventEmitter.prototype.eventNames = function eventNames() {\n        var names = [],\n          events,\n          name;\n        if (this._eventsCount === 0) return names;\n        for (name in events = this._events) {\n          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n        }\n        if (Object.getOwnPropertySymbols) {\n          return names.concat(Object.getOwnPropertySymbols(events));\n        }\n        return names;\n      };\n\n      /**\n       * Return the listeners registered for a given event.\n       *\n       * @param {(String|Symbol)} event The event name.\n       * @returns {Array} The registered listeners.\n       * @public\n       */\n      EventEmitter.prototype.listeners = function listeners(event) {\n        var evt = prefix ? prefix + event : event,\n          handlers = this._events[evt];\n        if (!handlers) return [];\n        if (handlers.fn) return [handlers.fn];\n        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n          ee[i] = handlers[i].fn;\n        }\n        return ee;\n      };\n\n      /**\n       * Return the number of listeners listening to a given event.\n       *\n       * @param {(String|Symbol)} event The event name.\n       * @returns {Number} The number of listeners.\n       * @public\n       */\n      EventEmitter.prototype.listenerCount = function listenerCount(event) {\n        var evt = prefix ? prefix + event : event,\n          listeners = this._events[evt];\n        if (!listeners) return 0;\n        if (listeners.fn) return 1;\n        return listeners.length;\n      };\n\n      /**\n       * Calls each of the listeners registered for a given event.\n       *\n       * @param {(String|Symbol)} event The event name.\n       * @returns {Boolean} `true` if the event had listeners, else `false`.\n       * @public\n       */\n      EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n        var evt = prefix ? prefix + event : event;\n        if (!this._events[evt]) return false;\n        var listeners = this._events[evt],\n          len = arguments.length,\n          args,\n          i;\n        if (listeners.fn) {\n          if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n          switch (len) {\n            case 1:\n              return listeners.fn.call(listeners.context), true;\n            case 2:\n              return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n              return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n              return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n          }\n          for (i = 1, args = new Array(len - 1); i < len; i++) {\n            args[i - 1] = arguments[i];\n          }\n          listeners.fn.apply(listeners.context, args);\n        } else {\n          var length = listeners.length,\n            j;\n          for (i = 0; i < length; i++) {\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch (len) {\n              case 1:\n                listeners[i].fn.call(listeners[i].context);\n                break;\n              case 2:\n                listeners[i].fn.call(listeners[i].context, a1);\n                break;\n              case 3:\n                listeners[i].fn.call(listeners[i].context, a1, a2);\n                break;\n              case 4:\n                listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                break;\n              default:\n                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n                  args[j - 1] = arguments[j];\n                }\n                listeners[i].fn.apply(listeners[i].context, args);\n            }\n          }\n        }\n        return true;\n      };\n\n      /**\n       * Add a listener for a given event.\n       *\n       * @param {(String|Symbol)} event The event name.\n       * @param {Function} fn The listener function.\n       * @param {*} [context=this] The context to invoke the listener with.\n       * @returns {EventEmitter} `this`.\n       * @public\n       */\n      EventEmitter.prototype.on = function on(event, fn, context) {\n        return addListener(this, event, fn, context, false);\n      };\n\n      /**\n       * Add a one-time listener for a given event.\n       *\n       * @param {(String|Symbol)} event The event name.\n       * @param {Function} fn The listener function.\n       * @param {*} [context=this] The context to invoke the listener with.\n       * @returns {EventEmitter} `this`.\n       * @public\n       */\n      EventEmitter.prototype.once = function once(event, fn, context) {\n        return addListener(this, event, fn, context, true);\n      };\n\n      /**\n       * Remove the listeners of a given event.\n       *\n       * @param {(String|Symbol)} event The event name.\n       * @param {Function} fn Only remove the listeners that match this function.\n       * @param {*} context Only remove the listeners that have this context.\n       * @param {Boolean} once Only remove one-time listeners.\n       * @returns {EventEmitter} `this`.\n       * @public\n       */\n      EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n        var evt = prefix ? prefix + event : event;\n        if (!this._events[evt]) return this;\n        if (!fn) {\n          clearEvent(this, evt);\n          return this;\n        }\n        var listeners = this._events[evt];\n        if (listeners.fn) {\n          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n            clearEvent(this, evt);\n          }\n        } else {\n          for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n              events.push(listeners[i]);\n            }\n          }\n\n          //\n          // Reset the array, or remove it completely if we have no more listeners.\n          //\n          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);\n        }\n        return this;\n      };\n\n      /**\n       * Remove all listeners, or those of the specified event.\n       *\n       * @param {(String|Symbol)} [event] The event name.\n       * @returns {EventEmitter} `this`.\n       * @public\n       */\n      EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n        var evt;\n        if (event) {\n          evt = prefix ? prefix + event : event;\n          if (this._events[evt]) clearEvent(this, evt);\n        } else {\n          this._events = new Events();\n          this._eventsCount = 0;\n        }\n        return this;\n      };\n\n      //\n      // Alias methods names because people roll like that.\n      //\n      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n      EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n      //\n      // Expose the prefix.\n      //\n      EventEmitter.prefixed = prefix;\n\n      //\n      // Allow `EventEmitter` to be imported as module namespace.\n      //\n      EventEmitter.EventEmitter = EventEmitter;\n\n      //\n      // Expose the module.\n      //\n      {\n        module.exports = EventEmitter;\n      }\n    })(eventemitter3);\n    var eventemitter3Exports = eventemitter3.exports;\n    var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);\n    if (typeof __IN_WORKER__ !== 'undefined' && __IN_WORKER__) {\n      startWorker(self);\n    }\n    function startWorker(self) {\n      var observer = new EventEmitter();\n      var forwardMessage = function forwardMessage(ev, data) {\n        self.postMessage({\n          event: ev,\n          data: data\n        });\n      };\n\n      // forward events to main thread\n      observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n      observer.on(Events.ERROR, forwardMessage);\n\n      // forward logger events to main thread\n      var forwardWorkerLogs = function forwardWorkerLogs() {\n        var _loop = function _loop(logFn) {\n          var func = function func(message) {\n            forwardMessage('workerLog', {\n              logType: logFn,\n              message: message\n            });\n          };\n          logger[logFn] = func;\n        };\n        for (var logFn in logger) {\n          _loop(logFn);\n        }\n      };\n      self.addEventListener('message', function (ev) {\n        var data = ev.data;\n        switch (data.cmd) {\n          case 'init':\n            {\n              var config = JSON.parse(data.config);\n              self.transmuxer = new Transmuxer(observer, data.typeSupported, config, data.vendor, data.id);\n              enableLogs(config.debug, data.id);\n              forwardWorkerLogs();\n              forwardMessage('init', null);\n              break;\n            }\n          case 'configure':\n            {\n              self.transmuxer.configure(data.config);\n              break;\n            }\n          case 'demux':\n            {\n              var transmuxResult = self.transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);\n              if (isPromise(transmuxResult)) {\n                self.transmuxer.async = true;\n                transmuxResult.then(function (data) {\n                  emitTransmuxComplete(self, data);\n                }).catch(function (error) {\n                  forwardMessage(Events.ERROR, {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    details: ErrorDetails.FRAG_PARSING_ERROR,\n                    chunkMeta: data.chunkMeta,\n                    fatal: false,\n                    error: error,\n                    err: error,\n                    reason: \"transmuxer-worker push error\"\n                  });\n                });\n              } else {\n                self.transmuxer.async = false;\n                emitTransmuxComplete(self, transmuxResult);\n              }\n              break;\n            }\n          case 'flush':\n            {\n              var id = data.chunkMeta;\n              var _transmuxResult = self.transmuxer.flush(id);\n              var asyncFlush = isPromise(_transmuxResult);\n              if (asyncFlush || self.transmuxer.async) {\n                if (!isPromise(_transmuxResult)) {\n                  _transmuxResult = Promise.resolve(_transmuxResult);\n                }\n                _transmuxResult.then(function (results) {\n                  handleFlushResult(self, results, id);\n                }).catch(function (error) {\n                  forwardMessage(Events.ERROR, {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    details: ErrorDetails.FRAG_PARSING_ERROR,\n                    chunkMeta: data.chunkMeta,\n                    fatal: false,\n                    error: error,\n                    err: error,\n                    reason: \"transmuxer-worker flush error\"\n                  });\n                });\n              } else {\n                handleFlushResult(self, _transmuxResult, id);\n              }\n              break;\n            }\n        }\n      });\n    }\n    function emitTransmuxComplete(self, transmuxResult) {\n      if (isEmptyResult(transmuxResult.remuxResult)) {\n        return false;\n      }\n      var transferable = [];\n      var _transmuxResult$remux = transmuxResult.remuxResult,\n        audio = _transmuxResult$remux.audio,\n        video = _transmuxResult$remux.video;\n      if (audio) {\n        addToTransferable(transferable, audio);\n      }\n      if (video) {\n        addToTransferable(transferable, video);\n      }\n      self.postMessage({\n        event: 'transmuxComplete',\n        data: transmuxResult\n      }, transferable);\n      return true;\n    }\n\n    // Converts data to a transferable object https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast)\n    // in order to minimize message passing overhead\n    function addToTransferable(transferable, track) {\n      if (track.data1) {\n        transferable.push(track.data1.buffer);\n      }\n      if (track.data2) {\n        transferable.push(track.data2.buffer);\n      }\n    }\n    function handleFlushResult(self, results, chunkMeta) {\n      var parsed = results.reduce(function (parsed, result) {\n        return emitTransmuxComplete(self, result) || parsed;\n      }, false);\n      if (!parsed) {\n        // Emit at least one \"transmuxComplete\" message even if media is not found to update stream-controller state to PARSING\n        self.postMessage({\n          event: 'transmuxComplete',\n          data: results[0]\n        });\n      }\n      self.postMessage({\n        event: 'flush',\n        data: chunkMeta\n      });\n    }\n    function isEmptyResult(remuxResult) {\n      return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;\n    }\n\n    // ensure the worker ends up in the bundle\n    // If the worker should not be included this gets aliased to empty.js\n    function hasUMDWorker() {\n      return typeof __HLS_WORKER_BUNDLE__ === 'function';\n    }\n    function injectWorker() {\n      var blob = new self.Blob([\"var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(\" + __HLS_WORKER_BUNDLE__.toString() + \")(true);\"], {\n        type: 'text/javascript'\n      });\n      var objectURL = self.URL.createObjectURL(blob);\n      var worker = new self.Worker(objectURL);\n      return {\n        worker: worker,\n        objectURL: objectURL\n      };\n    }\n    function loadWorker(path) {\n      var scriptURL = new self.URL(path, self.location.href).href;\n      var worker = new self.Worker(scriptURL);\n      return {\n        worker: worker,\n        scriptURL: scriptURL\n      };\n    }\n    var MediaSource$1 = getMediaSource() || {\n      isTypeSupported: function isTypeSupported() {\n        return false;\n      }\n    };\n    var TransmuxerInterface = /*#__PURE__*/function () {\n      function TransmuxerInterface(hls, id, onTransmuxComplete, onFlush) {\n        var _this = this;\n        this.error = null;\n        this.hls = void 0;\n        this.id = void 0;\n        this.observer = void 0;\n        this.frag = null;\n        this.part = null;\n        this.useWorker = void 0;\n        this.workerContext = null;\n        this.onwmsg = void 0;\n        this.transmuxer = null;\n        this.onTransmuxComplete = void 0;\n        this.onFlush = void 0;\n        var config = hls.config;\n        this.hls = hls;\n        this.id = id;\n        this.useWorker = !!config.enableWorker;\n        this.onTransmuxComplete = onTransmuxComplete;\n        this.onFlush = onFlush;\n        var forwardMessage = function forwardMessage(ev, data) {\n          data = data || {};\n          data.frag = _this.frag;\n          data.id = _this.id;\n          if (ev === Events.ERROR) {\n            _this.error = data.error;\n          }\n          _this.hls.trigger(ev, data);\n        };\n\n        // forward events to main thread\n        this.observer = new EventEmitter();\n        this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n        this.observer.on(Events.ERROR, forwardMessage);\n        var typeSupported = {\n          mp4: MediaSource$1.isTypeSupported('video/mp4'),\n          mpeg: MediaSource$1.isTypeSupported('audio/mpeg'),\n          mp3: MediaSource$1.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n        };\n        // navigator.vendor is not always available in Web Worker\n        // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator\n        var vendor = navigator.vendor;\n        if (this.useWorker && typeof Worker !== 'undefined') {\n          var canCreateWorker = config.workerPath || hasUMDWorker();\n          if (canCreateWorker) {\n            try {\n              if (config.workerPath) {\n                logger.log(\"loading Web Worker \" + config.workerPath + \" for \\\"\" + id + \"\\\"\");\n                this.workerContext = loadWorker(config.workerPath);\n              } else {\n                logger.log(\"injecting Web Worker for \\\"\" + id + \"\\\"\");\n                this.workerContext = injectWorker();\n              }\n              this.onwmsg = function (ev) {\n                return _this.onWorkerMessage(ev);\n              };\n              var worker = this.workerContext.worker;\n              worker.addEventListener('message', this.onwmsg);\n              worker.onerror = function (event) {\n                var error = new Error(event.message + \"  (\" + event.filename + \":\" + event.lineno + \")\");\n                config.enableWorker = false;\n                logger.warn(\"Error in \\\"\" + id + \"\\\" Web Worker, fallback to inline\");\n                _this.hls.trigger(Events.ERROR, {\n                  type: ErrorTypes.OTHER_ERROR,\n                  details: ErrorDetails.INTERNAL_EXCEPTION,\n                  fatal: false,\n                  event: 'demuxerWorker',\n                  error: error\n                });\n              };\n              worker.postMessage({\n                cmd: 'init',\n                typeSupported: typeSupported,\n                vendor: vendor,\n                id: id,\n                config: JSON.stringify(config)\n              });\n            } catch (err) {\n              logger.warn(\"Error setting up \\\"\" + id + \"\\\" Web Worker, fallback to inline\", err);\n              this.resetWorker();\n              this.error = null;\n              this.transmuxer = new Transmuxer(this.observer, typeSupported, config, vendor, id);\n            }\n            return;\n          }\n        }\n        this.transmuxer = new Transmuxer(this.observer, typeSupported, config, vendor, id);\n      }\n      var _proto = TransmuxerInterface.prototype;\n      _proto.resetWorker = function resetWorker() {\n        if (this.workerContext) {\n          var _this$workerContext = this.workerContext,\n            worker = _this$workerContext.worker,\n            objectURL = _this$workerContext.objectURL;\n          if (objectURL) {\n            // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n            self.URL.revokeObjectURL(objectURL);\n          }\n          worker.removeEventListener('message', this.onwmsg);\n          worker.onerror = null;\n          worker.terminate();\n          this.workerContext = null;\n        }\n      };\n      _proto.destroy = function destroy() {\n        if (this.workerContext) {\n          this.resetWorker();\n          this.onwmsg = undefined;\n        } else {\n          var transmuxer = this.transmuxer;\n          if (transmuxer) {\n            transmuxer.destroy();\n            this.transmuxer = null;\n          }\n        }\n        var observer = this.observer;\n        if (observer) {\n          observer.removeAllListeners();\n        }\n        this.frag = null;\n        // @ts-ignore\n        this.observer = null;\n        // @ts-ignore\n        this.hls = null;\n      };\n      _proto.push = function push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n        var _frag$initSegment,\n          _lastFrag$initSegment,\n          _this2 = this;\n        chunkMeta.transmuxing.start = self.performance.now();\n        var transmuxer = this.transmuxer;\n        var timeOffset = part ? part.start : frag.start;\n        // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n        var decryptdata = frag.decryptdata;\n        var lastFrag = this.frag;\n        var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n        var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n        var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n        var partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n        var progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);\n        var contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n        var now = self.performance.now();\n        if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n          frag.stats.parsing.start = now;\n        }\n        if (part && (partDiff || !contiguous)) {\n          part.stats.parsing.start = now;\n        }\n        var initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));\n        var state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n        if (!contiguous || discontinuity || initSegmentChange) {\n          logger.log(\"[transmuxer-interface, \" + frag.type + \"]: Starting new transmux session for sn: \" + chunkMeta.sn + \" p: \" + chunkMeta.part + \" level: \" + chunkMeta.level + \" id: \" + chunkMeta.id + \"\\n        discontinuity: \" + discontinuity + \"\\n        trackSwitch: \" + trackSwitch + \"\\n        contiguous: \" + contiguous + \"\\n        accurateTimeOffset: \" + accurateTimeOffset + \"\\n        timeOffset: \" + timeOffset + \"\\n        initSegmentChange: \" + initSegmentChange);\n          var config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n          this.configureTransmuxer(config);\n        }\n        this.frag = frag;\n        this.part = part;\n\n        // Frags with sn of 'initSegment' are not transmuxed\n        if (this.workerContext) {\n          // post fragment payload as transferable objects for ArrayBuffer (no copy)\n          this.workerContext.worker.postMessage({\n            cmd: 'demux',\n            data: data,\n            decryptdata: decryptdata,\n            chunkMeta: chunkMeta,\n            state: state\n          }, data instanceof ArrayBuffer ? [data] : []);\n        } else if (transmuxer) {\n          var _transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n          if (isPromise(_transmuxResult)) {\n            transmuxer.async = true;\n            _transmuxResult.then(function (data) {\n              _this2.handleTransmuxComplete(data);\n            }).catch(function (error) {\n              _this2.transmuxerError(error, chunkMeta, 'transmuxer-interface push error');\n            });\n          } else {\n            transmuxer.async = false;\n            this.handleTransmuxComplete(_transmuxResult);\n          }\n        }\n      };\n      _proto.flush = function flush(chunkMeta) {\n        var _this3 = this;\n        chunkMeta.transmuxing.start = self.performance.now();\n        var transmuxer = this.transmuxer;\n        if (this.workerContext) {\n          this.workerContext.worker.postMessage({\n            cmd: 'flush',\n            chunkMeta: chunkMeta\n          });\n        } else if (transmuxer) {\n          var _transmuxResult2 = transmuxer.flush(chunkMeta);\n          var asyncFlush = isPromise(_transmuxResult2);\n          if (asyncFlush || transmuxer.async) {\n            if (!isPromise(_transmuxResult2)) {\n              _transmuxResult2 = Promise.resolve(_transmuxResult2);\n            }\n            _transmuxResult2.then(function (data) {\n              _this3.handleFlushResult(data, chunkMeta);\n            }).catch(function (error) {\n              _this3.transmuxerError(error, chunkMeta, 'transmuxer-interface flush error');\n            });\n          } else {\n            this.handleFlushResult(_transmuxResult2, chunkMeta);\n          }\n        }\n      };\n      _proto.transmuxerError = function transmuxerError(error, chunkMeta, reason) {\n        if (!this.hls) {\n          return;\n        }\n        this.error = error;\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          chunkMeta: chunkMeta,\n          fatal: false,\n          error: error,\n          err: error,\n          reason: reason\n        });\n      };\n      _proto.handleFlushResult = function handleFlushResult(results, chunkMeta) {\n        var _this4 = this;\n        results.forEach(function (result) {\n          _this4.handleTransmuxComplete(result);\n        });\n        this.onFlush(chunkMeta);\n      };\n      _proto.onWorkerMessage = function onWorkerMessage(ev) {\n        var data = ev.data;\n        var hls = this.hls;\n        switch (data.event) {\n          case 'init':\n            {\n              var _this$workerContext2;\n              var objectURL = (_this$workerContext2 = this.workerContext) == null ? void 0 : _this$workerContext2.objectURL;\n              if (objectURL) {\n                // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n                self.URL.revokeObjectURL(objectURL);\n              }\n              break;\n            }\n          case 'transmuxComplete':\n            {\n              this.handleTransmuxComplete(data.data);\n              break;\n            }\n          case 'flush':\n            {\n              this.onFlush(data.data);\n              break;\n            }\n\n          // pass logs from the worker thread to the main logger\n          case 'workerLog':\n            if (logger[data.data.logType]) {\n              logger[data.data.logType](data.data.message);\n            }\n            break;\n          default:\n            {\n              data.data = data.data || {};\n              data.data.frag = this.frag;\n              data.data.id = this.id;\n              hls.trigger(data.event, data.data);\n              break;\n            }\n        }\n      };\n      _proto.configureTransmuxer = function configureTransmuxer(config) {\n        var transmuxer = this.transmuxer;\n        if (this.workerContext) {\n          this.workerContext.worker.postMessage({\n            cmd: 'configure',\n            config: config\n          });\n        } else if (transmuxer) {\n          transmuxer.configure(config);\n        }\n      };\n      _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {\n        result.chunkMeta.transmuxing.end = self.performance.now();\n        this.onTransmuxComplete(result);\n      };\n      return TransmuxerInterface;\n    }();\n    var STALL_MINIMUM_DURATION_MS = 250;\n    var MAX_START_GAP_JUMP = 2.0;\n    var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\n    var SKIP_BUFFER_RANGE_START = 0.05;\n    var GapController = /*#__PURE__*/function () {\n      function GapController(config, media, fragmentTracker, hls) {\n        this.config = void 0;\n        this.media = null;\n        this.fragmentTracker = void 0;\n        this.hls = void 0;\n        this.nudgeRetry = 0;\n        this.stallReported = false;\n        this.stalled = null;\n        this.moved = false;\n        this.seeking = false;\n        this.config = config;\n        this.media = media;\n        this.fragmentTracker = fragmentTracker;\n        this.hls = hls;\n      }\n      var _proto = GapController.prototype;\n      _proto.destroy = function destroy() {\n        this.media = null;\n        // @ts-ignore\n        this.hls = this.fragmentTracker = null;\n      }\n\n      /**\n       * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n       * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n       *\n       * @param lastCurrentTime - Previously read playhead position\n       */;\n      _proto.poll = function poll(lastCurrentTime, activeFrag) {\n        var config = this.config,\n          media = this.media,\n          stalled = this.stalled;\n        if (media === null) {\n          return;\n        }\n        var currentTime = media.currentTime,\n          seeking = media.seeking;\n        var seeked = this.seeking && !seeking;\n        var beginSeek = !this.seeking && seeking;\n        this.seeking = seeking;\n\n        // The playhead is moving, no-op\n        if (currentTime !== lastCurrentTime) {\n          this.moved = true;\n          if (stalled !== null) {\n            // The playhead is now moving, but was previously stalled\n            if (this.stallReported) {\n              var _stalledDuration = self.performance.now() - stalled;\n              logger.warn(\"playback not stuck anymore @\" + currentTime + \", after \" + Math.round(_stalledDuration) + \"ms\");\n              this.stallReported = false;\n            }\n            this.stalled = null;\n            this.nudgeRetry = 0;\n          }\n          return;\n        }\n\n        // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n        if (beginSeek || seeked) {\n          this.stalled = null;\n          return;\n        }\n\n        // The playhead should not be moving\n        if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {\n          return;\n        }\n        var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n        var isBuffered = bufferInfo.len > 0;\n        var nextStart = bufferInfo.nextStart || 0;\n\n        // There is no playable buffer (seeked, waiting for buffer)\n        if (!isBuffered && !nextStart) {\n          return;\n        }\n        if (seeking) {\n          // Waiting for seeking in a buffered range to complete\n          var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n          // Next buffered range is too far ahead to jump to while still seeking\n          var noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);\n          if (hasEnoughBuffer || noBufferGap) {\n            return;\n          }\n          // Reset moved state when seeking to a point in or before a gap\n          this.moved = false;\n        }\n\n        // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n        // The addition poll gives the browser a chance to jump the gap for us\n        if (!this.moved && this.stalled !== null) {\n          var _level$details;\n          // Jump start gaps within jump threshold\n          var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n\n          // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n          // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n          // that begins over 1 target duration after the video start position.\n          var level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;\n          var isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;\n          var maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;\n          var partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);\n          if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {\n            this._trySkipBufferHole(partialOrGap);\n            return;\n          }\n        }\n\n        // Start tracking stall time\n        var tnow = self.performance.now();\n        if (stalled === null) {\n          this.stalled = tnow;\n          return;\n        }\n        var stalledDuration = tnow - stalled;\n        if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {\n          // Report stalling after trying to fix\n          this._reportStall(bufferInfo);\n          if (!this.media) {\n            return;\n          }\n        }\n        var bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n        this._tryFixBufferStall(bufferedWithHoles, stalledDuration);\n      }\n\n      /**\n       * Detects and attempts to fix known buffer stalling issues.\n       * @param bufferInfo - The properties of the current buffer.\n       * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n       * @private\n       */;\n      _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {\n        var config = this.config,\n          fragmentTracker = this.fragmentTracker,\n          media = this.media;\n        if (media === null) {\n          return;\n        }\n        var currentTime = media.currentTime;\n        var partial = fragmentTracker.getPartialFragment(currentTime);\n        if (partial) {\n          // Try to skip over the buffer hole caused by a partial fragment\n          // This method isn't limited by the size of the gap between buffered ranges\n          var targetTime = this._trySkipBufferHole(partial);\n          // we return here in this case, meaning\n          // the branch below only executes when we haven't seeked to a new position\n          if (targetTime || !this.media) {\n            return;\n          }\n        }\n\n        // if we haven't had to skip over a buffer hole of a partial fragment\n        // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n        // needs to cross some sort of threshold covering all source-buffers content\n        // to start playing properly.\n        if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {\n          logger.warn('Trying to nudge playhead over buffer-hole');\n          // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n          // We only try to jump the hole if it's under the configured size\n          // Reset stalled so to rearm watchdog timer\n          this.stalled = null;\n          this._tryNudgeBuffer();\n        }\n      }\n\n      /**\n       * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n       * @param bufferLen - The playhead distance from the end of the current buffer segment.\n       * @private\n       */;\n      _proto._reportStall = function _reportStall(bufferInfo) {\n        var hls = this.hls,\n          media = this.media,\n          stallReported = this.stallReported;\n        if (!stallReported && media) {\n          // Report stalled error once\n          this.stallReported = true;\n          var error = new Error(\"Playback stalling at @\" + media.currentTime + \" due to low buffer (\" + JSON.stringify(bufferInfo) + \")\");\n          logger.warn(error.message);\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_STALLED_ERROR,\n            fatal: false,\n            error: error,\n            buffer: bufferInfo.len\n          });\n        }\n      }\n\n      /**\n       * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n       * @param partial - The partial fragment found at the current time (where playback is stalling).\n       * @private\n       */;\n      _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {\n        var config = this.config,\n          hls = this.hls,\n          media = this.media;\n        if (media === null) {\n          return 0;\n        }\n\n        // Check if currentTime is between unbuffered regions of partial fragments\n        var currentTime = media.currentTime;\n        var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n        var startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;\n        if (startTime) {\n          var bufferStarved = bufferInfo.len <= config.maxBufferHole;\n          var waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;\n          var gapLength = startTime - currentTime;\n          if (gapLength > 0 && (bufferStarved || waiting)) {\n            // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial\n            if (gapLength > config.maxBufferHole) {\n              var fragmentTracker = this.fragmentTracker;\n              var startGap = false;\n              if (currentTime === 0) {\n                var startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);\n                if (startFrag && startTime < startFrag.end) {\n                  startGap = true;\n                }\n              }\n              if (!startGap) {\n                var startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);\n                if (startProvisioned) {\n                  var moreToLoad = false;\n                  var pos = startProvisioned.end;\n                  while (pos < startTime) {\n                    var provisioned = fragmentTracker.getPartialFragment(pos);\n                    if (provisioned) {\n                      pos += provisioned.duration;\n                    } else {\n                      moreToLoad = true;\n                      break;\n                    }\n                  }\n                  if (moreToLoad) {\n                    return 0;\n                  }\n                }\n              }\n            }\n            var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n            logger.warn(\"skipping hole, adjusting currentTime from \" + currentTime + \" to \" + targetTime);\n            this.moved = true;\n            this.stalled = null;\n            media.currentTime = targetTime;\n            if (partial && !partial.gap) {\n              var error = new Error(\"fragment loaded with buffer holes, seeking from \" + currentTime + \" to \" + targetTime);\n              hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n                fatal: false,\n                error: error,\n                reason: error.message,\n                frag: partial\n              });\n            }\n            return targetTime;\n          }\n        }\n        return 0;\n      }\n\n      /**\n       * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n       * @private\n       */;\n      _proto._tryNudgeBuffer = function _tryNudgeBuffer() {\n        var config = this.config,\n          hls = this.hls,\n          media = this.media,\n          nudgeRetry = this.nudgeRetry;\n        if (media === null) {\n          return;\n        }\n        var currentTime = media.currentTime;\n        this.nudgeRetry++;\n        if (nudgeRetry < config.nudgeMaxRetry) {\n          var targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n          // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n          var error = new Error(\"Nudging 'currentTime' from \" + currentTime + \" to \" + targetTime);\n          logger.warn(error.message);\n          media.currentTime = targetTime;\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n            error: error,\n            fatal: false\n          });\n        } else {\n          var _error = new Error(\"Playhead still not moving while enough data buffered @\" + currentTime + \" after \" + config.nudgeMaxRetry + \" nudges\");\n          logger.error(_error.message);\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_STALLED_ERROR,\n            error: _error,\n            fatal: true\n          });\n        }\n      };\n      return GapController;\n    }();\n    var TICK_INTERVAL = 100; // how often to tick in ms\n    var StreamController = /*#__PURE__*/function (_BaseStreamController) {\n      _inheritsLoose(StreamController, _BaseStreamController);\n      function StreamController(hls, fragmentTracker, keyLoader) {\n        var _this;\n        _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, '[stream-controller]', PlaylistLevelType.MAIN) || this;\n        _this.audioCodecSwap = false;\n        _this.gapController = null;\n        _this.level = -1;\n        _this._forceStartLoad = false;\n        _this.altAudio = false;\n        _this.audioOnly = false;\n        _this.fragPlaying = null;\n        _this.onvplaying = null;\n        _this.onvseeked = null;\n        _this.fragLastKbps = 0;\n        _this.couldBacktrack = false;\n        _this.backtrackFragment = null;\n        _this.audioCodecSwitch = false;\n        _this.videoBuffer = null;\n        _this._registerListeners();\n        return _this;\n      }\n      var _proto = StreamController.prototype;\n      _proto._registerListeners = function _registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n        hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n        hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      };\n      _proto._unregisterListeners = function _unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n        hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n        hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      };\n      _proto.onHandlerDestroying = function onHandlerDestroying() {\n        this._unregisterListeners();\n        this.onMediaDetaching();\n      };\n      _proto.startLoad = function startLoad(startPosition) {\n        if (this.levels) {\n          var lastCurrentTime = this.lastCurrentTime,\n            hls = this.hls;\n          this.stopLoad();\n          this.setInterval(TICK_INTERVAL);\n          this.level = -1;\n          if (!this.startFragRequested) {\n            // determine load level\n            var startLevel = hls.startLevel;\n            if (startLevel === -1) {\n              if (hls.config.testBandwidth && this.levels.length > 1) {\n                // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n                startLevel = 0;\n                this.bitrateTest = true;\n              } else {\n                startLevel = hls.nextAutoLevel;\n              }\n            }\n            // set new level to playlist loader : this will trigger start level load\n            // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n            this.level = hls.nextLoadLevel = startLevel;\n            this.loadedmetadata = false;\n          }\n          // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n          if (lastCurrentTime > 0 && startPosition === -1) {\n            this.log(\"Override startPosition with lastCurrentTime @\" + lastCurrentTime.toFixed(3));\n            startPosition = lastCurrentTime;\n          }\n          this.state = State.IDLE;\n          this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n          this.tick();\n        } else {\n          this._forceStartLoad = true;\n          this.state = State.STOPPED;\n        }\n      };\n      _proto.stopLoad = function stopLoad() {\n        this._forceStartLoad = false;\n        _BaseStreamController.prototype.stopLoad.call(this);\n      };\n      _proto.doTick = function doTick() {\n        switch (this.state) {\n          case State.WAITING_LEVEL:\n            {\n              var _levels$level;\n              var levels = this.levels,\n                level = this.level;\n              var details = levels == null ? void 0 : (_levels$level = levels[level]) == null ? void 0 : _levels$level.details;\n              if (details && (!details.live || this.levelLastLoaded === this.level)) {\n                if (this.waitForCdnTuneIn(details)) {\n                  break;\n                }\n                this.state = State.IDLE;\n                break;\n              }\n              break;\n            }\n          case State.FRAG_LOADING_WAITING_RETRY:\n            {\n              var _this$media;\n              var now = self.performance.now();\n              var retryDate = this.retryDate;\n              // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n              if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n                this.resetStartWhenNotLoaded(this.level);\n                this.state = State.IDLE;\n              }\n            }\n            break;\n        }\n        if (this.state === State.IDLE) {\n          this.doTickIdle();\n        }\n        this.onTickEnd();\n      };\n      _proto.onTickEnd = function onTickEnd() {\n        _BaseStreamController.prototype.onTickEnd.call(this);\n        this.checkBuffer();\n        this.checkFragmentChanged();\n      };\n      _proto.doTickIdle = function doTickIdle() {\n        var hls = this.hls,\n          levelLastLoaded = this.levelLastLoaded,\n          levels = this.levels,\n          media = this.media;\n        var config = hls.config,\n          level = hls.nextLoadLevel;\n\n        // if start level not parsed yet OR\n        // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n        // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n        if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {\n          return;\n        }\n\n        // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n        if (this.altAudio && this.audioOnly) {\n          return;\n        }\n        if (!(levels != null && levels[level])) {\n          return;\n        }\n        var levelInfo = levels[level];\n\n        // if buffer length is less than maxBufLen try to load a new fragment\n\n        var bufferInfo = this.getMainFwdBufferInfo();\n        if (bufferInfo === null) {\n          return;\n        }\n        var lastDetails = this.getLevelDetails();\n        if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n          var data = {};\n          if (this.altAudio) {\n            data.type = 'video';\n          }\n          this.hls.trigger(Events.BUFFER_EOS, data);\n          this.state = State.ENDED;\n          return;\n        }\n\n        // set next load level : this will trigger a playlist load if needed\n        if (hls.loadLevel !== level && hls.manualLevel === -1) {\n          this.log(\"Adapting to level \" + level + \" from level \" + this.level);\n        }\n        this.level = hls.nextLoadLevel = level;\n        var levelDetails = levelInfo.details;\n        // if level info not retrieved yet, switch state and wait for level retrieval\n        // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n        // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n        if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== level) {\n          this.level = level;\n          this.state = State.WAITING_LEVEL;\n          return;\n        }\n        var bufferLen = bufferInfo.len;\n\n        // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n        var maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n\n        // Stay idle if we are still with buffer margins\n        if (bufferLen >= maxBufLen) {\n          return;\n        }\n        if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n          this.backtrackFragment = null;\n        }\n        var targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n        var frag = this.getNextFragment(targetBufferTime, levelDetails);\n        // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n        if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== 'initSegment' && this.fragmentTracker.getState(frag) !== FragmentState.OK) {\n          var _this$backtrackFragme;\n          var backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n          var fragIdx = backtrackSn - levelDetails.startSN;\n          var backtrackFrag = levelDetails.fragments[fragIdx - 1];\n          if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n            frag = backtrackFrag;\n            this.fragmentTracker.removeFragment(backtrackFrag);\n          }\n        } else if (this.backtrackFragment && bufferInfo.len) {\n          this.backtrackFragment = null;\n        }\n        // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n        if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n          var gapStart = frag.gap;\n          if (!gapStart) {\n            // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n            var type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;\n            var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n            if (mediaBuffer) {\n              this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n            }\n          }\n          frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n        }\n        if (!frag) {\n          return;\n        }\n        if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n          frag = frag.initSegment;\n        }\n        this.loadFragment(frag, levelInfo, targetBufferTime);\n      };\n      _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {\n        // Check if fragment is not loaded\n        var fragState = this.fragmentTracker.getState(frag);\n        this.fragCurrent = frag;\n        if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n          if (frag.sn === 'initSegment') {\n            this._loadInitSegment(frag, level);\n          } else if (this.bitrateTest) {\n            this.log(\"Fragment \" + frag.sn + \" of level \" + frag.level + \" is being downloaded to test bitrate and will not be buffered\");\n            this._loadBitrateTestFrag(frag, level);\n          } else {\n            this.startFragRequested = true;\n            _BaseStreamController.prototype.loadFragment.call(this, frag, level, targetBufferTime);\n          }\n        } else {\n          this.clearTrackerIfNeeded(frag);\n        }\n      };\n      _proto.getBufferedFrag = function getBufferedFrag(position) {\n        return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);\n      };\n      _proto.followingBufferedFrag = function followingBufferedFrag(frag) {\n        if (frag) {\n          // try to get range of next fragment (500ms after this range)\n          return this.getBufferedFrag(frag.end + 0.5);\n        }\n        return null;\n      }\n\n      /*\n        on immediate level switch :\n         - pause playback if playing\n         - cancel any pending load request\n         - and trigger a buffer flush\n      */;\n      _proto.immediateLevelSwitch = function immediateLevelSwitch() {\n        this.abortCurrentFrag();\n        this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n      }\n\n      /**\n       * try to switch ASAP without breaking video playback:\n       * in order to ensure smooth but quick level switching,\n       * we need to find the next flushable buffer range\n       * we should take into account new segment fetch time\n       */;\n      _proto.nextLevelSwitch = function nextLevelSwitch() {\n        var levels = this.levels,\n          media = this.media;\n        // ensure that media is defined and that metadata are available (to retrieve currentTime)\n        if (media != null && media.readyState) {\n          var fetchdelay;\n          var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n          if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n            // flush buffer preceding current fragment (flush until current fragment start offset)\n            // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n            this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n          }\n          var levelDetails = this.getLevelDetails();\n          if (levelDetails != null && levelDetails.live) {\n            var bufferInfo = this.getMainFwdBufferInfo();\n            // Do not flush in live stream with low buffer\n            if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {\n              return;\n            }\n          }\n          if (!media.paused && levels) {\n            // add a safety delay of 1s\n            var nextLevelId = this.hls.nextLoadLevel;\n            var nextLevel = levels[nextLevelId];\n            var fragLastKbps = this.fragLastKbps;\n            if (fragLastKbps && this.fragCurrent) {\n              fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n            } else {\n              fetchdelay = 0;\n            }\n          } else {\n            fetchdelay = 0;\n          }\n          // this.log('fetchdelay:'+fetchdelay);\n          // find buffer range that will be reached once new fragment will be fetched\n          var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n          if (bufferedFrag) {\n            // we can flush buffer range following this one without stalling playback\n            var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n            if (nextBufferedFrag) {\n              // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n              this.abortCurrentFrag();\n              // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n              var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n              var fragDuration = nextBufferedFrag.duration;\n              var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * 0.5), fragDuration * 0.75));\n              this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n            }\n          }\n        }\n      };\n      _proto.abortCurrentFrag = function abortCurrentFrag() {\n        var fragCurrent = this.fragCurrent;\n        this.fragCurrent = null;\n        this.backtrackFragment = null;\n        if (fragCurrent) {\n          fragCurrent.abortRequests();\n          this.fragmentTracker.removeFragment(fragCurrent);\n        }\n        switch (this.state) {\n          case State.KEY_LOADING:\n          case State.FRAG_LOADING:\n          case State.FRAG_LOADING_WAITING_RETRY:\n          case State.PARSING:\n          case State.PARSED:\n            this.state = State.IDLE;\n            break;\n        }\n        this.nextLoadPosition = this.getLoadPosition();\n      };\n      _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {\n        _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio ? 'video' : null);\n      };\n      _proto.onMediaAttached = function onMediaAttached(event, data) {\n        _BaseStreamController.prototype.onMediaAttached.call(this, event, data);\n        var media = data.media;\n        this.onvplaying = this.onMediaPlaying.bind(this);\n        this.onvseeked = this.onMediaSeeked.bind(this);\n        media.addEventListener('playing', this.onvplaying);\n        media.addEventListener('seeked', this.onvseeked);\n        this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);\n      };\n      _proto.onMediaDetaching = function onMediaDetaching() {\n        var media = this.media;\n        if (media && this.onvplaying && this.onvseeked) {\n          media.removeEventListener('playing', this.onvplaying);\n          media.removeEventListener('seeked', this.onvseeked);\n          this.onvplaying = this.onvseeked = null;\n          this.videoBuffer = null;\n        }\n        this.fragPlaying = null;\n        if (this.gapController) {\n          this.gapController.destroy();\n          this.gapController = null;\n        }\n        _BaseStreamController.prototype.onMediaDetaching.call(this);\n      };\n      _proto.onMediaPlaying = function onMediaPlaying() {\n        // tick to speed up FRAG_CHANGED triggering\n        this.tick();\n      };\n      _proto.onMediaSeeked = function onMediaSeeked() {\n        var media = this.media;\n        var currentTime = media ? media.currentTime : null;\n        if (isFiniteNumber(currentTime)) {\n          this.log(\"Media seeked to \" + currentTime.toFixed(3));\n        }\n\n        // If seeked was issued before buffer was appended do not tick immediately\n        var bufferInfo = this.getMainFwdBufferInfo();\n        if (bufferInfo === null || bufferInfo.len === 0) {\n          this.warn(\"Main forward buffer length on \\\"seeked\\\" event \" + (bufferInfo ? bufferInfo.len : 'empty') + \")\");\n          return;\n        }\n\n        // tick to speed up FRAG_CHANGED triggering\n        this.tick();\n      };\n      _proto.onManifestLoading = function onManifestLoading() {\n        // reset buffer on manifest loading\n        this.log('Trigger BUFFER_RESET');\n        this.hls.trigger(Events.BUFFER_RESET, undefined);\n        this.fragmentTracker.removeAllFragments();\n        this.couldBacktrack = false;\n        this.startPosition = this.lastCurrentTime = 0;\n        this.levels = this.fragPlaying = this.backtrackFragment = null;\n        this.altAudio = this.audioOnly = false;\n      };\n      _proto.onManifestParsed = function onManifestParsed(event, data) {\n        var aac = false;\n        var heaac = false;\n        var codec;\n        data.levels.forEach(function (level) {\n          // detect if we have different kind of audio codecs used amongst playlists\n          codec = level.audioCodec;\n          if (codec) {\n            if (codec.indexOf('mp4a.40.2') !== -1) {\n              aac = true;\n            }\n            if (codec.indexOf('mp4a.40.5') !== -1) {\n              heaac = true;\n            }\n          }\n        });\n        this.audioCodecSwitch = aac && heaac && !changeTypeSupported();\n        if (this.audioCodecSwitch) {\n          this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n        }\n        this.levels = data.levels;\n        this.startFragRequested = false;\n      };\n      _proto.onLevelLoading = function onLevelLoading(event, data) {\n        var levels = this.levels;\n        if (!levels || this.state !== State.IDLE) {\n          return;\n        }\n        var level = levels[data.level];\n        if (!level.details || level.details.live && this.levelLastLoaded !== data.level || this.waitForCdnTuneIn(level.details)) {\n          this.state = State.WAITING_LEVEL;\n        }\n      };\n      _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n        var _curLevel$details;\n        var levels = this.levels;\n        var newLevelId = data.level;\n        var newDetails = data.details;\n        var duration = newDetails.totalduration;\n        if (!levels) {\n          this.warn(\"Levels were reset while loading level \" + newLevelId);\n          return;\n        }\n        this.log(\"Level \" + newLevelId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"]\" + (newDetails.lastPartSn ? \"[part-\" + newDetails.lastPartSn + \"-\" + newDetails.lastPartIndex + \"]\" : '') + \", cc [\" + newDetails.startCC + \", \" + newDetails.endCC + \"] duration:\" + duration);\n        var curLevel = levels[newLevelId];\n        var fragCurrent = this.fragCurrent;\n        if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {\n          if ((fragCurrent.level !== data.level || fragCurrent.urlId !== curLevel.urlId) && fragCurrent.loader) {\n            this.abortCurrentFrag();\n          }\n        }\n        var sliding = 0;\n        if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {\n          if (!newDetails.fragments[0]) {\n            newDetails.deltaUpdateFailed = true;\n          }\n          if (newDetails.deltaUpdateFailed) {\n            return;\n          }\n          sliding = this.alignPlaylists(newDetails, curLevel.details);\n        }\n        // override level info\n        curLevel.details = newDetails;\n        this.levelLastLoaded = newLevelId;\n        this.hls.trigger(Events.LEVEL_UPDATED, {\n          details: newDetails,\n          level: newLevelId\n        });\n\n        // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n        if (this.state === State.WAITING_LEVEL) {\n          if (this.waitForCdnTuneIn(newDetails)) {\n            // Wait for Low-Latency CDN Tune-in\n            return;\n          }\n          this.state = State.IDLE;\n        }\n        if (!this.startFragRequested) {\n          this.setStartPosition(newDetails, sliding);\n        } else if (newDetails.live) {\n          this.synchronizeToLiveEdge(newDetails);\n        }\n\n        // trigger handler right now\n        this.tick();\n      };\n      _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {\n        var _frag$initSegment;\n        var frag = data.frag,\n          part = data.part,\n          payload = data.payload;\n        var levels = this.levels;\n        if (!levels) {\n          this.warn(\"Levels were reset while fragment load was in progress. Fragment \" + frag.sn + \" of level \" + frag.level + \" will not be buffered\");\n          return;\n        }\n        var currentLevel = levels[frag.level];\n        var details = currentLevel.details;\n        if (!details) {\n          this.warn(\"Dropping fragment \" + frag.sn + \" of level \" + frag.level + \" after level details were reset\");\n          this.fragmentTracker.removeFragment(frag);\n          return;\n        }\n        var videoCodec = currentLevel.videoCodec;\n\n        // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n        var accurateTimeOffset = details.PTSKnown || !details.live;\n        var initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n        var audioCodec = this._getAudioCodec(currentLevel);\n\n        // transmux the MPEG-TS data to ISO-BMFF segments\n        // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n        var transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n        var partIndex = part ? part.index : -1;\n        var partial = partIndex !== -1;\n        var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n        var initPTS = this.initPTS[frag.cc];\n        transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n      };\n      _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n        // if any URL found on new audio track, it is an alternate audio track\n        var fromAltAudio = this.altAudio;\n        var altAudio = !!data.url;\n        // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n        // don't do anything if we switch to alt audio: audio stream controller is handling it.\n        // we will just have to change buffer scheduling on audioTrackSwitched\n        if (!altAudio) {\n          if (this.mediaBuffer !== this.media) {\n            this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n            this.mediaBuffer = this.media;\n            var fragCurrent = this.fragCurrent;\n            // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n            if (fragCurrent) {\n              this.log('Switching to main audio track, cancel main fragment load');\n              fragCurrent.abortRequests();\n              this.fragmentTracker.removeFragment(fragCurrent);\n            }\n            // destroy transmuxer to force init segment generation (following audio switch)\n            this.resetTransmuxer();\n            // switch to IDLE state to load new fragment\n            this.resetLoadingState();\n          } else if (this.audioOnly) {\n            // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n            this.resetTransmuxer();\n          }\n          var hls = this.hls;\n          // If switching from alt to main audio, flush all audio and trigger track switched\n          if (fromAltAudio) {\n            hls.trigger(Events.BUFFER_FLUSHING, {\n              startOffset: 0,\n              endOffset: Number.POSITIVE_INFINITY,\n              type: null\n            });\n            this.fragmentTracker.removeAllFragments();\n          }\n          hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n        }\n      };\n      _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {\n        var trackId = data.id;\n        var altAudio = !!this.hls.audioTracks[trackId].url;\n        if (altAudio) {\n          var videoBuffer = this.videoBuffer;\n          // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n          if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n            this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n            this.mediaBuffer = videoBuffer;\n          }\n        }\n        this.altAudio = altAudio;\n        this.tick();\n      };\n      _proto.onBufferCreated = function onBufferCreated(event, data) {\n        var tracks = data.tracks;\n        var mediaTrack;\n        var name;\n        var alternate = false;\n        for (var type in tracks) {\n          var track = tracks[type];\n          if (track.id === 'main') {\n            name = type;\n            mediaTrack = track;\n            // keep video source buffer reference\n            if (type === 'video') {\n              var videoTrack = tracks[type];\n              if (videoTrack) {\n                this.videoBuffer = videoTrack.buffer;\n              }\n            }\n          } else {\n            alternate = true;\n          }\n        }\n        if (alternate && mediaTrack) {\n          this.log(\"Alternate track found, use \" + name + \".buffered to schedule main fragment loading\");\n          this.mediaBuffer = mediaTrack.buffer;\n        } else {\n          this.mediaBuffer = this.media;\n        }\n      };\n      _proto.onFragBuffered = function onFragBuffered(event, data) {\n        var frag = data.frag,\n          part = data.part;\n        if (frag && frag.type !== PlaylistLevelType.MAIN) {\n          return;\n        }\n        if (this.fragContextChanged(frag)) {\n          // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n          // Avoid setting state back to IDLE, since that will interfere with a level switch\n          this.warn(\"Fragment \" + frag.sn + (part ? ' p: ' + part.index : '') + \" of level \" + frag.level + \" finished buffering, but was aborted. state: \" + this.state);\n          if (this.state === State.PARSED) {\n            this.state = State.IDLE;\n          }\n          return;\n        }\n        var stats = part ? part.stats : frag.stats;\n        this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n        if (frag.sn !== 'initSegment') {\n          this.fragPrevious = frag;\n        }\n        this.fragBufferedComplete(frag, part);\n      };\n      _proto.onError = function onError(event, data) {\n        var _data$context;\n        if (data.fatal) {\n          this.state = State.ERROR;\n          return;\n        }\n        switch (data.details) {\n          case ErrorDetails.FRAG_GAP:\n          case ErrorDetails.FRAG_PARSING_ERROR:\n          case ErrorDetails.FRAG_DECRYPT_ERROR:\n          case ErrorDetails.FRAG_LOAD_ERROR:\n          case ErrorDetails.FRAG_LOAD_TIMEOUT:\n          case ErrorDetails.KEY_LOAD_ERROR:\n          case ErrorDetails.KEY_LOAD_TIMEOUT:\n            this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);\n            break;\n          case ErrorDetails.LEVEL_LOAD_ERROR:\n          case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n          case ErrorDetails.LEVEL_PARSING_ERROR:\n            // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE\n            if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {\n              this.state = State.IDLE;\n            }\n            break;\n          case ErrorDetails.BUFFER_FULL_ERROR:\n            if (!data.parent || data.parent !== 'main') {\n              return;\n            }\n            if (this.reduceLengthAndFlushBuffer(data)) {\n              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n            }\n            break;\n          case ErrorDetails.INTERNAL_EXCEPTION:\n            this.recoverWorkerError(data);\n            break;\n        }\n      }\n\n      // Checks the health of the buffer and attempts to resolve playback stalls.\n      ;\n\n      _proto.checkBuffer = function checkBuffer() {\n        var media = this.media,\n          gapController = this.gapController;\n        if (!media || !gapController || !media.readyState) {\n          // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n          return;\n        }\n        if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {\n          // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n          var activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;\n          gapController.poll(this.lastCurrentTime, activeFrag);\n        }\n        this.lastCurrentTime = media.currentTime;\n      };\n      _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {\n        this.state = State.IDLE;\n        // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n        // in that case, reset startFragRequested flag\n        if (!this.loadedmetadata) {\n          this.startFragRequested = false;\n          this.nextLoadPosition = this.startPosition;\n        }\n        this.tickImmediate();\n      };\n      _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {\n        var type = _ref.type;\n        if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {\n          var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n        }\n      };\n      _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {\n        this.levels = data.levels;\n      };\n      _proto.swapAudioCodec = function swapAudioCodec() {\n        this.audioCodecSwap = !this.audioCodecSwap;\n      }\n\n      /**\n       * Seeks to the set startPosition if not equal to the mediaElement's current time.\n       */;\n      _proto.seekToStartPos = function seekToStartPos() {\n        var media = this.media;\n        if (!media) {\n          return;\n        }\n        var currentTime = media.currentTime;\n        var startPosition = this.startPosition;\n        // only adjust currentTime if different from startPosition or if startPosition not buffered\n        // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n        if (startPosition >= 0 && currentTime < startPosition) {\n          if (media.seeking) {\n            this.log(\"could not seek to \" + startPosition + \", already seeking at \" + currentTime);\n            return;\n          }\n          var buffered = BufferHelper.getBuffered(media);\n          var bufferStart = buffered.length ? buffered.start(0) : 0;\n          var delta = bufferStart - startPosition;\n          if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {\n            this.log(\"adjusting start position by \" + delta + \" to match buffer start\");\n            startPosition += delta;\n            this.startPosition = startPosition;\n          }\n          this.log(\"seek to target start position \" + startPosition + \" from current time \" + currentTime);\n          media.currentTime = startPosition;\n        }\n      };\n      _proto._getAudioCodec = function _getAudioCodec(currentLevel) {\n        var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n        if (this.audioCodecSwap && audioCodec) {\n          this.log('Swapping audio codec');\n          if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n          } else {\n            audioCodec = 'mp4a.40.5';\n          }\n        }\n        return audioCodec;\n      };\n      _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(frag, level) {\n        var _this2 = this;\n        frag.bitrateTest = true;\n        this._doFragLoad(frag, level).then(function (data) {\n          var hls = _this2.hls;\n          if (!data || _this2.fragContextChanged(frag)) {\n            return;\n          }\n          level.fragmentError = 0;\n          _this2.state = State.IDLE;\n          _this2.startFragRequested = false;\n          _this2.bitrateTest = false;\n          var stats = frag.stats;\n          // Bitrate tests fragments are neither parsed nor buffered\n          stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n          hls.trigger(Events.FRAG_LOADED, data);\n          frag.bitrateTest = false;\n        });\n      };\n      _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {\n        var _id3$samples;\n        var id = 'main';\n        var hls = this.hls;\n        var remuxResult = transmuxResult.remuxResult,\n          chunkMeta = transmuxResult.chunkMeta;\n        var context = this.getCurrentContext(chunkMeta);\n        if (!context) {\n          this.resetWhenMissingContext(chunkMeta);\n          return;\n        }\n        var frag = context.frag,\n          part = context.part,\n          level = context.level;\n        var video = remuxResult.video,\n          text = remuxResult.text,\n          id3 = remuxResult.id3,\n          initSegment = remuxResult.initSegment;\n        var details = level.details;\n        // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n        var audio = this.altAudio ? undefined : remuxResult.audio;\n\n        // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n        // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n        if (this.fragContextChanged(frag)) {\n          this.fragmentTracker.removeFragment(frag);\n          return;\n        }\n        this.state = State.PARSING;\n        if (initSegment) {\n          if (initSegment != null && initSegment.tracks) {\n            var mapFragment = frag.initSegment || frag;\n            this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n            hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n              frag: mapFragment,\n              id: id,\n              tracks: initSegment.tracks\n            });\n          }\n\n          // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n          var initPTS = initSegment.initPTS;\n          var timescale = initSegment.timescale;\n          if (isFiniteNumber(initPTS)) {\n            this.initPTS[frag.cc] = {\n              baseTime: initPTS,\n              timescale: timescale\n            };\n            hls.trigger(Events.INIT_PTS_FOUND, {\n              frag: frag,\n              id: id,\n              initPTS: initPTS,\n              timescale: timescale\n            });\n          }\n        }\n\n        // Avoid buffering if backtracking this fragment\n        if (video && remuxResult.independent !== false) {\n          if (details) {\n            var startPTS = video.startPTS,\n              endPTS = video.endPTS,\n              startDTS = video.startDTS,\n              endDTS = video.endDTS;\n            if (part) {\n              part.elementaryStreams[video.type] = {\n                startPTS: startPTS,\n                endPTS: endPTS,\n                startDTS: startDTS,\n                endDTS: endDTS\n              };\n            } else {\n              if (video.firstKeyFrame && video.independent && chunkMeta.id === 1) {\n                this.couldBacktrack = true;\n              }\n              if (video.dropped && video.independent) {\n                // Backtrack if dropped frames create a gap after currentTime\n\n                var bufferInfo = this.getMainFwdBufferInfo();\n                var targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n                var startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n                if (targetBufferTime < startTime - this.config.maxBufferHole) {\n                  this.backtrack(frag);\n                  return;\n                }\n                // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n                frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n              }\n            }\n            frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n            if (this.backtrackFragment) {\n              this.backtrackFragment = frag;\n            }\n            this.bufferFragmentData(video, frag, part, chunkMeta);\n          }\n        } else if (remuxResult.independent === false) {\n          this.backtrack(frag);\n          return;\n        }\n        if (audio) {\n          var _startPTS = audio.startPTS,\n            _endPTS = audio.endPTS,\n            _startDTS = audio.startDTS,\n            _endDTS = audio.endDTS;\n          if (part) {\n            part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n              startPTS: _startPTS,\n              endPTS: _endPTS,\n              startDTS: _startDTS,\n              endDTS: _endDTS\n            };\n          }\n          frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);\n          this.bufferFragmentData(audio, frag, part, chunkMeta);\n        }\n        if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n          var emittedID3 = {\n            id: id,\n            frag: frag,\n            details: details,\n            samples: id3.samples\n          };\n          hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n        }\n        if (details && text) {\n          var emittedText = {\n            id: id,\n            frag: frag,\n            details: details,\n            samples: text.samples\n          };\n          hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n        }\n      };\n      _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n        var _this3 = this;\n        if (this.state !== State.PARSING) {\n          return;\n        }\n        this.audioOnly = !!tracks.audio && !tracks.video;\n\n        // if audio track is expected to come from audio stream controller, discard any coming from main\n        if (this.altAudio && !this.audioOnly) {\n          delete tracks.audio;\n        }\n        // include levelCodec in audio and video tracks\n        var audio = tracks.audio,\n          video = tracks.video,\n          audiovideo = tracks.audiovideo;\n        if (audio) {\n          var audioCodec = currentLevel.audioCodec;\n          var ua = navigator.userAgent.toLowerCase();\n          if (this.audioCodecSwitch) {\n            if (audioCodec) {\n              if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n                audioCodec = 'mp4a.40.2';\n              } else {\n                audioCodec = 'mp4a.40.5';\n              }\n            }\n            // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n            // force HE-AAC, as it seems that most browsers prefers it.\n            // don't force HE-AAC if mono stream, or in Firefox\n            if (audio.metadata.channelCount !== 1 && ua.indexOf('firefox') === -1) {\n              audioCodec = 'mp4a.40.5';\n            }\n          }\n          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n          if (ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n            // Exclude mpeg audio\n            audioCodec = 'mp4a.40.2';\n            this.log(\"Android: force audio codec to \" + audioCodec);\n          }\n          if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {\n            this.log(\"Swapping manifest audio codec \\\"\" + currentLevel.audioCodec + \"\\\" for \\\"\" + audioCodec + \"\\\"\");\n          }\n          audio.levelCodec = audioCodec;\n          audio.id = 'main';\n          this.log(\"Init audio buffer, container:\" + audio.container + \", codecs[selected/level/parsed]=[\" + (audioCodec || '') + \"/\" + (currentLevel.audioCodec || '') + \"/\" + audio.codec + \"]\");\n        }\n        if (video) {\n          video.levelCodec = currentLevel.videoCodec;\n          video.id = 'main';\n          this.log(\"Init video buffer, container:\" + video.container + \", codecs[level/parsed]=[\" + (currentLevel.videoCodec || '') + \"/\" + video.codec + \"]\");\n        }\n        if (audiovideo) {\n          this.log(\"Init audiovideo buffer, container:\" + audiovideo.container + \", codecs[level/parsed]=[\" + (currentLevel.attrs.CODECS || '') + \"/\" + audiovideo.codec + \"]\");\n        }\n        this.hls.trigger(Events.BUFFER_CODECS, tracks);\n        // loop through tracks that are going to be provided to bufferController\n        Object.keys(tracks).forEach(function (trackName) {\n          var track = tracks[trackName];\n          var initSegment = track.initSegment;\n          if (initSegment != null && initSegment.byteLength) {\n            _this3.hls.trigger(Events.BUFFER_APPENDING, {\n              type: trackName,\n              data: initSegment,\n              frag: frag,\n              part: null,\n              chunkMeta: chunkMeta,\n              parent: frag.type\n            });\n          }\n        });\n        // trigger handler right now\n        this.tick();\n      };\n      _proto.getMainFwdBufferInfo = function getMainFwdBufferInfo() {\n        return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);\n      };\n      _proto.backtrack = function backtrack(frag) {\n        this.couldBacktrack = true;\n        // Causes findFragments to backtrack through fragments to find the keyframe\n        this.backtrackFragment = frag;\n        this.resetTransmuxer();\n        this.flushBufferGap(frag);\n        this.fragmentTracker.removeFragment(frag);\n        this.fragPrevious = null;\n        this.nextLoadPosition = frag.start;\n        this.state = State.IDLE;\n      };\n      _proto.checkFragmentChanged = function checkFragmentChanged() {\n        var video = this.media;\n        var fragPlayingCurrent = null;\n        if (video && video.readyState > 1 && video.seeking === false) {\n          var currentTime = video.currentTime;\n          /* if video element is in seeked state, currentTime can only increase.\n            (assuming that playback rate is positive ...)\n            As sometimes currentTime jumps back to zero after a\n            media decode error, check this, to avoid seeking back to\n            wrong position after a media decode error\n          */\n\n          if (BufferHelper.isBuffered(video, currentTime)) {\n            fragPlayingCurrent = this.getAppendedFrag(currentTime);\n          } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {\n            /* ensure that FRAG_CHANGED event is triggered at startup,\n              when first video frame is displayed and playback is paused.\n              add a tolerance of 100ms, in case current position is not buffered,\n              check if current pos+100ms is buffered and use that buffer range\n              for FRAG_CHANGED event reporting */\n            fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n          }\n          if (fragPlayingCurrent) {\n            this.backtrackFragment = null;\n            var fragPlaying = this.fragPlaying;\n            var fragCurrentLevel = fragPlayingCurrent.level;\n            if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel || fragPlayingCurrent.urlId !== fragPlaying.urlId) {\n              this.fragPlaying = fragPlayingCurrent;\n              this.hls.trigger(Events.FRAG_CHANGED, {\n                frag: fragPlayingCurrent\n              });\n              if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n                this.hls.trigger(Events.LEVEL_SWITCHED, {\n                  level: fragCurrentLevel\n                });\n              }\n            }\n          }\n        }\n      };\n      _createClass(StreamController, [{\n        key: \"nextLevel\",\n        get: function get() {\n          var frag = this.nextBufferedFrag;\n          if (frag) {\n            return frag.level;\n          }\n          return -1;\n        }\n      }, {\n        key: \"currentFrag\",\n        get: function get() {\n          var media = this.media;\n          if (media) {\n            return this.fragPlaying || this.getAppendedFrag(media.currentTime);\n          }\n          return null;\n        }\n      }, {\n        key: \"currentProgramDateTime\",\n        get: function get() {\n          var media = this.media;\n          if (media) {\n            var currentTime = media.currentTime;\n            var frag = this.currentFrag;\n            if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {\n              var epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;\n              return new Date(epocMs);\n            }\n          }\n          return null;\n        }\n      }, {\n        key: \"currentLevel\",\n        get: function get() {\n          var frag = this.currentFrag;\n          if (frag) {\n            return frag.level;\n          }\n          return -1;\n        }\n      }, {\n        key: \"nextBufferedFrag\",\n        get: function get() {\n          var frag = this.currentFrag;\n          if (frag) {\n            return this.followingBufferedFrag(frag);\n          }\n          return null;\n        }\n      }, {\n        key: \"forceStartLoad\",\n        get: function get() {\n          return this._forceStartLoad;\n        }\n      }]);\n      return StreamController;\n    }(BaseStreamController);\n\n    /*\n     * compute an Exponential Weighted moving average\n     * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n     *  - heavily inspired from shaka-player\n     */\n    var EWMA = /*#__PURE__*/function () {\n      //  About half of the estimated value will be from the last |halfLife| samples by weight.\n      function EWMA(halfLife, estimate, weight) {\n        if (estimate === void 0) {\n          estimate = 0;\n        }\n        if (weight === void 0) {\n          weight = 0;\n        }\n        this.halfLife = void 0;\n        this.alpha_ = void 0;\n        this.estimate_ = void 0;\n        this.totalWeight_ = void 0;\n        this.halfLife = halfLife;\n        // Larger values of alpha expire historical data more slowly.\n        this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n        this.estimate_ = estimate;\n        this.totalWeight_ = weight;\n      }\n      var _proto = EWMA.prototype;\n      _proto.sample = function sample(weight, value) {\n        var adjAlpha = Math.pow(this.alpha_, weight);\n        this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n        this.totalWeight_ += weight;\n      };\n      _proto.getTotalWeight = function getTotalWeight() {\n        return this.totalWeight_;\n      };\n      _proto.getEstimate = function getEstimate() {\n        if (this.alpha_) {\n          var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n          if (zeroFactor) {\n            return this.estimate_ / zeroFactor;\n          }\n        }\n        return this.estimate_;\n      };\n      return EWMA;\n    }();\n\n    /*\n     * EWMA Bandwidth Estimator\n     *  - heavily inspired from shaka-player\n     * Tracks bandwidth samples and estimates available bandwidth.\n     * Based on the minimum of two exponentially-weighted moving averages with\n     * different half-lives.\n     */\n\n    var EwmaBandWidthEstimator = /*#__PURE__*/function () {\n      function EwmaBandWidthEstimator(slow, fast, defaultEstimate, defaultTTFB) {\n        if (defaultTTFB === void 0) {\n          defaultTTFB = 100;\n        }\n        this.defaultEstimate_ = void 0;\n        this.minWeight_ = void 0;\n        this.minDelayMs_ = void 0;\n        this.slow_ = void 0;\n        this.fast_ = void 0;\n        this.defaultTTFB_ = void 0;\n        this.ttfb_ = void 0;\n        this.defaultEstimate_ = defaultEstimate;\n        this.minWeight_ = 0.001;\n        this.minDelayMs_ = 50;\n        this.slow_ = new EWMA(slow);\n        this.fast_ = new EWMA(fast);\n        this.defaultTTFB_ = defaultTTFB;\n        this.ttfb_ = new EWMA(slow);\n      }\n      var _proto = EwmaBandWidthEstimator.prototype;\n      _proto.update = function update(slow, fast) {\n        var slow_ = this.slow_,\n          fast_ = this.fast_,\n          ttfb_ = this.ttfb_;\n        if (slow_.halfLife !== slow) {\n          this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());\n        }\n        if (fast_.halfLife !== fast) {\n          this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());\n        }\n        if (ttfb_.halfLife !== slow) {\n          this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());\n        }\n      };\n      _proto.sample = function sample(durationMs, numBytes) {\n        durationMs = Math.max(durationMs, this.minDelayMs_);\n        var numBits = 8 * numBytes;\n        // weight is duration in seconds\n        var durationS = durationMs / 1000;\n        // value is bandwidth in bits/s\n        var bandwidthInBps = numBits / durationS;\n        this.fast_.sample(durationS, bandwidthInBps);\n        this.slow_.sample(durationS, bandwidthInBps);\n      };\n      _proto.sampleTTFB = function sampleTTFB(ttfb) {\n        // weight is frequency curve applied to TTFB in seconds\n        // (longer times have less weight with expected input under 1 second)\n        var seconds = ttfb / 1000;\n        var weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);\n        this.ttfb_.sample(weight, Math.max(ttfb, 5));\n      };\n      _proto.canEstimate = function canEstimate() {\n        return this.fast_.getTotalWeight() >= this.minWeight_;\n      };\n      _proto.getEstimate = function getEstimate() {\n        if (this.canEstimate()) {\n          // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n          // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n          // Take the minimum of these two estimates.  This should have the effect of\n          // adapting down quickly, but up more slowly.\n          return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n        } else {\n          return this.defaultEstimate_;\n        }\n      };\n      _proto.getEstimateTTFB = function getEstimateTTFB() {\n        if (this.ttfb_.getTotalWeight() >= this.minWeight_) {\n          return this.ttfb_.getEstimate();\n        } else {\n          return this.defaultTTFB_;\n        }\n      };\n      _proto.destroy = function destroy() {};\n      return EwmaBandWidthEstimator;\n    }();\n    var AbrController = /*#__PURE__*/function () {\n      function AbrController(hls) {\n        this.hls = void 0;\n        this.lastLevelLoadSec = 0;\n        this.lastLoadedFragLevel = 0;\n        this._nextAutoLevel = -1;\n        this.timer = -1;\n        this.onCheck = this._abandonRulesCheck.bind(this);\n        this.fragCurrent = null;\n        this.partCurrent = null;\n        this.bitrateTestDelay = 0;\n        this.bwEstimator = void 0;\n        this.hls = hls;\n        var config = hls.config;\n        this.bwEstimator = new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n        this.registerListeners();\n      }\n      var _proto = AbrController.prototype;\n      _proto.registerListeners = function registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      };\n      _proto.unregisterListeners = function unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      };\n      _proto.destroy = function destroy() {\n        this.unregisterListeners();\n        this.clearTimer();\n        // @ts-ignore\n        this.hls = this.onCheck = null;\n        this.fragCurrent = this.partCurrent = null;\n      };\n      _proto.onFragLoading = function onFragLoading(event, data) {\n        var _data$part;\n        var frag = data.frag;\n        if (this.ignoreFragment(frag)) {\n          return;\n        }\n        this.fragCurrent = frag;\n        this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n        this.clearTimer();\n        this.timer = self.setInterval(this.onCheck, 100);\n      };\n      _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n        this.clearTimer();\n      };\n      _proto.getTimeToLoadFrag = function getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {\n        var fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;\n        var playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;\n        return fragLoadSec + playlistLoadSec;\n      };\n      _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n        var config = this.hls.config;\n        var _data$stats = data.stats,\n          total = _data$stats.total,\n          bwEstimate = _data$stats.bwEstimate;\n        // Total is the bytelength and bwEstimate in bits/sec\n        if (isFiniteNumber(total) && isFiniteNumber(bwEstimate)) {\n          this.lastLevelLoadSec = 8 * total / bwEstimate;\n        }\n        if (data.details.live) {\n          this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n        } else {\n          this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n        }\n      }\n\n      /*\n          This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n          quickly enough to prevent underbuffering\n        */;\n      _proto._abandonRulesCheck = function _abandonRulesCheck() {\n        var frag = this.fragCurrent,\n          part = this.partCurrent,\n          hls = this.hls;\n        var autoLevelEnabled = hls.autoLevelEnabled,\n          media = hls.media;\n        if (!frag || !media) {\n          return;\n        }\n        var now = performance.now();\n        var stats = part ? part.stats : frag.stats;\n        var duration = part ? part.duration : frag.duration;\n        var timeLoading = now - stats.loading.start;\n        // If frag loading is aborted, complete, or from lowest level, stop timer and return\n        if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level === 0) {\n          this.clearTimer();\n          // reset forced auto level value so that next level will be selected\n          this._nextAutoLevel = -1;\n          return;\n        }\n\n        // This check only runs if we're in ABR mode and actually playing\n        if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {\n          return;\n        }\n        var bufferInfo = hls.mainForwardBufferInfo;\n        if (bufferInfo === null) {\n          return;\n        }\n        var ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n        var playbackRate = Math.abs(media.playbackRate);\n        // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed\n        if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {\n          return;\n        }\n\n        // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n        var bufferStarvationDelay = bufferInfo.len / playbackRate;\n        // Only downswitch if less than 2 fragment lengths are buffered\n        if (bufferStarvationDelay >= 2 * duration / playbackRate) {\n          return;\n        }\n        var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n        var loadedFirstByte = stats.loaded && ttfb > -1;\n        var bwEstimate = this.bwEstimator.getEstimate();\n        var levels = hls.levels,\n          minAutoLevel = hls.minAutoLevel;\n        var level = levels[frag.level];\n        var expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.maxBitrate / 8));\n        var timeStreaming = timeLoading - ttfb;\n        if (timeStreaming < 1 && loadedFirstByte) {\n          timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);\n        }\n        var loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;\n        // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n        var fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;\n        // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n        if (fragLoadedDelay <= bufferStarvationDelay) {\n          return;\n        }\n        var bwe = loadRate ? loadRate * 8 : bwEstimate;\n        var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n        var nextLoadLevel;\n        // Iterate through lower level and try to find the largest one that avoids rebuffering\n        for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n          // compute time to load next fragment at lower level\n          // 8 = bits per byte (bps/Bps)\n          var levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n          fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);\n          if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n            break;\n          }\n        }\n        // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n        // to load the current one\n        if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n          return;\n        }\n\n        // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down\n        if (fragLevelNextLoadedDelay > duration * 10) {\n          return;\n        }\n        hls.nextLoadLevel = nextLoadLevel;\n        if (loadedFirstByte) {\n          // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time\n          this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n        } else {\n          // If there has been no loading progress, sample TTFB\n          this.bwEstimator.sampleTTFB(timeLoading);\n        }\n        this.clearTimer();\n        logger.warn(\"[abr] Fragment \" + frag.sn + (part ? ' part ' + part.index : '') + \" of level \" + frag.level + \" is loading too slowly;\\n      Time to underbuffer: \" + bufferStarvationDelay.toFixed(3) + \" s\\n      Estimated load time for current fragment: \" + fragLoadedDelay.toFixed(3) + \" s\\n      Estimated load time for down switch fragment: \" + fragLevelNextLoadedDelay.toFixed(3) + \" s\\n      TTFB estimate: \" + ttfb + \"\\n      Current BW estimate: \" + (isFiniteNumber(bwEstimate) ? (bwEstimate / 1024).toFixed(3) : 'Unknown') + \" Kb/s\\n      New BW estimate: \" + (this.bwEstimator.getEstimate() / 1024).toFixed(3) + \" Kb/s\\n      Aborting and switching to level \" + nextLoadLevel);\n        if (frag.loader) {\n          this.fragCurrent = this.partCurrent = null;\n          frag.abortRequests();\n        }\n        hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n          frag: frag,\n          part: part,\n          stats: stats\n        });\n      };\n      _proto.onFragLoaded = function onFragLoaded(event, _ref) {\n        var frag = _ref.frag,\n          part = _ref.part;\n        var stats = part ? part.stats : frag.stats;\n        if (frag.type === PlaylistLevelType.MAIN) {\n          this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);\n        }\n        if (this.ignoreFragment(frag)) {\n          return;\n        }\n        // stop monitoring bw once frag loaded\n        this.clearTimer();\n        // store level id after successful fragment load\n        this.lastLoadedFragLevel = frag.level;\n        // reset forced auto level value so that next level will be selected\n        this._nextAutoLevel = -1;\n\n        // compute level average bitrate\n        if (this.hls.config.abrMaxWithRealBitrate) {\n          var duration = part ? part.duration : frag.duration;\n          var level = this.hls.levels[frag.level];\n          var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n          var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n          level.loaded = {\n            bytes: loadedBytes,\n            duration: loadedDuration\n          };\n          level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n        }\n        if (frag.bitrateTest) {\n          var fragBufferedData = {\n            stats: stats,\n            frag: frag,\n            part: part,\n            id: frag.type\n          };\n          this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);\n          frag.bitrateTest = false;\n        }\n      };\n      _proto.onFragBuffered = function onFragBuffered(event, data) {\n        var frag = data.frag,\n          part = data.part;\n        var stats = part != null && part.stats.loaded ? part.stats : frag.stats;\n        if (stats.aborted) {\n          return;\n        }\n        if (this.ignoreFragment(frag)) {\n          return;\n        }\n        // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n        // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n        // is used. If we used buffering in that case, our BW estimate sample will be very large.\n        var processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());\n        this.bwEstimator.sample(processingMs, stats.loaded);\n        stats.bwEstimate = this.bwEstimator.getEstimate();\n        if (frag.bitrateTest) {\n          this.bitrateTestDelay = processingMs / 1000;\n        } else {\n          this.bitrateTestDelay = 0;\n        }\n      };\n      _proto.ignoreFragment = function ignoreFragment(frag) {\n        // Only count non-alt-audio frags which were actually buffered in our BW calculations\n        return frag.type !== PlaylistLevelType.MAIN || frag.sn === 'initSegment';\n      };\n      _proto.clearTimer = function clearTimer() {\n        self.clearInterval(this.timer);\n      }\n\n      // return next auto level\n      ;\n\n      _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {\n        var fragCurrent = this.fragCurrent,\n          partCurrent = this.partCurrent,\n          hls = this.hls;\n        var maxAutoLevel = hls.maxAutoLevel,\n          config = hls.config,\n          minAutoLevel = hls.minAutoLevel,\n          media = hls.media;\n        var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n\n        // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n        // if we're playing back at the normal rate.\n        var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n        var avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate;\n        // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n        var bufferInfo = hls.mainForwardBufferInfo;\n        var bufferStarvationDelay = (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n\n        // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n        var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor);\n        if (bestLevel >= 0) {\n          return bestLevel;\n        }\n        logger.trace(\"[abr] \" + (bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty') + \", finding optimal quality level\");\n        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering\n        // if no matching level found, logic will return 0\n        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n        var bwFactor = config.abrBandWidthFactor;\n        var bwUpFactor = config.abrBandWidthUpFactor;\n        if (!bufferStarvationDelay) {\n          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n          var bitrateTestDelay = this.bitrateTestDelay;\n          if (bitrateTestDelay) {\n            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n            // max video loading delay used in  automatic start level selection :\n            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n            logger.trace(\"[abr] bitrate test took \" + Math.round(1000 * bitrateTestDelay) + \"ms, set first fragment max fetchDuration to \" + Math.round(1000 * maxStarvationDelay) + \" ms\");\n            // don't use conservative factor on bitrate test\n            bwFactor = bwUpFactor = 1;\n          }\n        }\n        bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor);\n        return Math.max(bestLevel, 0);\n      };\n      _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor) {\n        var _level$details;\n        var fragCurrent = this.fragCurrent,\n          partCurrent = this.partCurrent,\n          currentLevel = this.lastLoadedFragLevel;\n        var levels = this.hls.levels;\n        var level = levels[currentLevel];\n        var live = !!(level != null && (_level$details = level.details) != null && _level$details.live);\n        var currentCodecSet = level == null ? void 0 : level.codecSet;\n        var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n        var ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;\n        var levelSkippedMin = minAutoLevel;\n        var levelSkippedMax = -1;\n        for (var i = maxAutoLevel; i >= minAutoLevel; i--) {\n          var levelInfo = levels[i];\n          if (!levelInfo || currentCodecSet && levelInfo.codecSet !== currentCodecSet) {\n            if (levelInfo) {\n              levelSkippedMin = Math.min(i, levelSkippedMin);\n              levelSkippedMax = Math.max(i, levelSkippedMax);\n            }\n            continue;\n          }\n          if (levelSkippedMax !== -1) {\n            logger.trace(\"[abr] Skipped level(s) \" + levelSkippedMin + \"-\" + levelSkippedMax + \" with CODECS:\\\"\" + levels[levelSkippedMax].attrs.CODECS + \"\\\"; not compatible with \\\"\" + level.attrs.CODECS + \"\\\"\");\n          }\n          var levelDetails = levelInfo.details;\n          var avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n          var adjustedbw = void 0;\n          // follow algorithm captured from stagefright :\n          // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n          // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n          // consider only 80% of the available bandwidth, but if we are switching up,\n          // be even more conservative (70%) to avoid overestimating and immediately\n          // switching back.\n          if (i <= currentLevel) {\n            adjustedbw = bwFactor * currentBw;\n          } else {\n            adjustedbw = bwUpFactor * currentBw;\n          }\n          var bitrate = levels[i].maxBitrate;\n          var fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);\n          logger.trace(\"[abr] level:\" + i + \" adjustedbw-bitrate:\" + Math.round(adjustedbw - bitrate) + \" avgDuration:\" + avgDuration.toFixed(1) + \" maxFetchDuration:\" + maxFetchDuration.toFixed(1) + \" fetchDuration:\" + fetchDuration.toFixed(1));\n          // if adjusted bw is greater than level bitrate AND\n          if (adjustedbw > bitrate && (\n          // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n          // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n          // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n          fetchDuration === 0 || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {\n            // as we are looping from highest to lowest, this will return the best achievable quality level\n            return i;\n          }\n        }\n        // not enough time budget even with quality level 0 ... rebuffering might happen\n        return -1;\n      };\n      _createClass(AbrController, [{\n        key: \"nextAutoLevel\",\n        get: function get() {\n          var forcedAutoLevel = this._nextAutoLevel;\n          var bwEstimator = this.bwEstimator;\n          // in case next auto level has been forced, and bw not available or not reliable, return forced value\n          if (forcedAutoLevel !== -1 && !bwEstimator.canEstimate()) {\n            return forcedAutoLevel;\n          }\n\n          // compute next level using ABR logic\n          var nextABRAutoLevel = this.getNextABRAutoLevel();\n          // use forced auto level when ABR selected level has errored\n          if (forcedAutoLevel !== -1) {\n            var levels = this.hls.levels;\n            if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {\n              return forcedAutoLevel;\n            }\n          }\n          // if forced auto level has been defined, use it to cap ABR computed quality level\n          if (forcedAutoLevel !== -1) {\n            nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);\n          }\n          return nextABRAutoLevel;\n        },\n        set: function set(nextLevel) {\n          this._nextAutoLevel = nextLevel;\n        }\n      }]);\n      return AbrController;\n    }();\n    var BufferOperationQueue = /*#__PURE__*/function () {\n      function BufferOperationQueue(sourceBufferReference) {\n        this.buffers = void 0;\n        this.queues = {\n          video: [],\n          audio: [],\n          audiovideo: []\n        };\n        this.buffers = sourceBufferReference;\n      }\n      var _proto = BufferOperationQueue.prototype;\n      _proto.append = function append(operation, type) {\n        var queue = this.queues[type];\n        queue.push(operation);\n        if (queue.length === 1 && this.buffers[type]) {\n          this.executeNext(type);\n        }\n      };\n      _proto.insertAbort = function insertAbort(operation, type) {\n        var queue = this.queues[type];\n        queue.unshift(operation);\n        this.executeNext(type);\n      };\n      _proto.appendBlocker = function appendBlocker(type) {\n        var execute;\n        var promise = new Promise(function (resolve) {\n          execute = resolve;\n        });\n        var operation = {\n          execute: execute,\n          onStart: function onStart() {},\n          onComplete: function onComplete() {},\n          onError: function onError() {}\n        };\n        this.append(operation, type);\n        return promise;\n      };\n      _proto.executeNext = function executeNext(type) {\n        var buffers = this.buffers,\n          queues = this.queues;\n        var sb = buffers[type];\n        var queue = queues[type];\n        if (queue.length) {\n          var operation = queue[0];\n          try {\n            // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n            // which do not end with this event must call _onSBUpdateEnd manually\n            operation.execute();\n          } catch (e) {\n            logger.warn('[buffer-operation-queue]: Unhandled exception executing the current operation');\n            operation.onError(e);\n\n            // Only shift the current operation off, otherwise the updateend handler will do this for us\n            if (!(sb != null && sb.updating)) {\n              queue.shift();\n              this.executeNext(type);\n            }\n          }\n        }\n      };\n      _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {\n        this.queues[type].shift();\n        this.executeNext(type);\n      };\n      _proto.current = function current(type) {\n        return this.queues[type][0];\n      };\n      return BufferOperationQueue;\n    }();\n    var MediaSource = getMediaSource();\n    var VIDEO_CODEC_PROFILE_REPACE = /([ha]vc.)(?:\\.[^.,]+)+/;\n    var BufferController = /*#__PURE__*/function () {\n      // The level details used to determine duration, target-duration and live\n\n      // cache the self generated object url to detect hijack of video tag\n\n      // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n\n      // References to event listeners for each SourceBuffer, so that they can be referenced for event removal\n\n      // The number of BUFFER_CODEC events received before any sourceBuffers are created\n\n      // The total number of BUFFER_CODEC events received\n\n      // A reference to the attached media element\n\n      // A reference to the active media source\n\n      // Last MP3 audio chunk appended\n\n      // counters\n\n      function BufferController(hls) {\n        var _this = this;\n        this.details = null;\n        this._objectUrl = null;\n        this.operationQueue = void 0;\n        this.listeners = void 0;\n        this.hls = void 0;\n        this.bufferCodecEventsExpected = 0;\n        this._bufferCodecEventsTotal = 0;\n        this.media = null;\n        this.mediaSource = null;\n        this.lastMpegAudioChunk = null;\n        this.appendError = 0;\n        this.tracks = {};\n        this.pendingTracks = {};\n        this.sourceBuffer = void 0;\n        // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n        this._onMediaSourceOpen = function () {\n          var media = _this.media,\n            mediaSource = _this.mediaSource;\n          logger.log('[buffer-controller]: Media source opened');\n          if (media) {\n            media.removeEventListener('emptied', _this._onMediaEmptied);\n            _this.updateMediaElementDuration();\n            _this.hls.trigger(Events.MEDIA_ATTACHED, {\n              media: media\n            });\n          }\n          if (mediaSource) {\n            // once received, don't listen anymore to sourceopen event\n            mediaSource.removeEventListener('sourceopen', _this._onMediaSourceOpen);\n          }\n          _this.checkPendingTracks();\n        };\n        this._onMediaSourceClose = function () {\n          logger.log('[buffer-controller]: Media source closed');\n        };\n        this._onMediaSourceEnded = function () {\n          logger.log('[buffer-controller]: Media source ended');\n        };\n        this._onMediaEmptied = function () {\n          var media = _this.media,\n            _objectUrl = _this._objectUrl;\n          if (media && media.src !== _objectUrl) {\n            logger.error(\"Media element src was set while attaching MediaSource (\" + _objectUrl + \" > \" + media.src + \")\");\n          }\n        };\n        this.hls = hls;\n        this._initSourceBuffer();\n        this.registerListeners();\n      }\n      var _proto = BufferController.prototype;\n      _proto.hasSourceTypes = function hasSourceTypes() {\n        return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n      };\n      _proto.destroy = function destroy() {\n        this.unregisterListeners();\n        this.details = null;\n        this.lastMpegAudioChunk = null;\n      };\n      _proto.registerListeners = function registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n        hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n        hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.on(Events.BUFFER_EOS, this.onBufferEos, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        hls.on(Events.FRAG_PARSED, this.onFragParsed, this);\n        hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);\n      };\n      _proto.unregisterListeners = function unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n        hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n        hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.off(Events.BUFFER_EOS, this.onBufferEos, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        hls.off(Events.FRAG_PARSED, this.onFragParsed, this);\n        hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);\n      };\n      _proto._initSourceBuffer = function _initSourceBuffer() {\n        this.sourceBuffer = {};\n        this.operationQueue = new BufferOperationQueue(this.sourceBuffer);\n        this.listeners = {\n          audio: [],\n          video: [],\n          audiovideo: []\n        };\n        this.lastMpegAudioChunk = null;\n      };\n      _proto.onManifestLoading = function onManifestLoading() {\n        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;\n        this.details = null;\n      };\n      _proto.onManifestParsed = function onManifestParsed(event, data) {\n        // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n        // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n        // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n        // it will contain the expected nb of source buffers, no need to compute it\n        var codecEvents = 2;\n        if (data.audio && !data.video || !data.altAudio || !false) {\n          codecEvents = 1;\n        }\n        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;\n        logger.log(this.bufferCodecEventsExpected + \" bufferCodec event(s) expected\");\n      };\n      _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n        var media = this.media = data.media;\n        if (media && MediaSource) {\n          var ms = this.mediaSource = new MediaSource();\n          // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n          ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n          ms.addEventListener('sourceended', this._onMediaSourceEnded);\n          ms.addEventListener('sourceclose', this._onMediaSourceClose);\n          // link video and media Source\n          media.src = self.URL.createObjectURL(ms);\n          // cache the locally generated object url\n          this._objectUrl = media.src;\n          media.addEventListener('emptied', this._onMediaEmptied);\n        }\n      };\n      _proto.onMediaDetaching = function onMediaDetaching() {\n        var media = this.media,\n          mediaSource = this.mediaSource,\n          _objectUrl = this._objectUrl;\n        if (mediaSource) {\n          logger.log('[buffer-controller]: media source detaching');\n          if (mediaSource.readyState === 'open') {\n            try {\n              // endOfStream could trigger exception if any sourcebuffer is in updating state\n              // we don't really care about checking sourcebuffer state here,\n              // as we are anyway detaching the MediaSource\n              // let's just avoid this exception to propagate\n              mediaSource.endOfStream();\n            } catch (err) {\n              logger.warn(\"[buffer-controller]: onMediaDetaching: \" + err.message + \" while calling endOfStream\");\n            }\n          }\n          // Clean up the SourceBuffers by invoking onBufferReset\n          this.onBufferReset();\n          mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n          mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n          mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose);\n\n          // Detach properly the MediaSource from the HTMLMediaElement as\n          // suggested in https://github.com/w3c/media-source/issues/53.\n          if (media) {\n            media.removeEventListener('emptied', this._onMediaEmptied);\n            if (_objectUrl) {\n              self.URL.revokeObjectURL(_objectUrl);\n            }\n\n            // clean up video tag src only if it's our own url. some external libraries might\n            // hijack the video tag and change its 'src' without destroying the Hls instance first\n            if (media.src === _objectUrl) {\n              media.removeAttribute('src');\n              media.load();\n            } else {\n              logger.warn('[buffer-controller]: media.src was changed by a third party - skip cleanup');\n            }\n          }\n          this.mediaSource = null;\n          this.media = null;\n          this._objectUrl = null;\n          this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;\n          this.pendingTracks = {};\n          this.tracks = {};\n        }\n        this.hls.trigger(Events.MEDIA_DETACHED, undefined);\n      };\n      _proto.onBufferReset = function onBufferReset() {\n        var _this2 = this;\n        this.getSourceBufferTypes().forEach(function (type) {\n          var sb = _this2.sourceBuffer[type];\n          try {\n            if (sb) {\n              _this2.removeBufferListeners(type);\n              if (_this2.mediaSource) {\n                _this2.mediaSource.removeSourceBuffer(sb);\n              }\n              // Synchronously remove the SB from the map before the next call in order to prevent an async function from\n              // accessing it\n              _this2.sourceBuffer[type] = undefined;\n            }\n          } catch (err) {\n            logger.warn(\"[buffer-controller]: Failed to reset the \" + type + \" buffer\", err);\n          }\n        });\n        this._initSourceBuffer();\n      };\n      _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n        var _this3 = this;\n        var sourceBufferCount = this.getSourceBufferTypes().length;\n        Object.keys(data).forEach(function (trackName) {\n          if (sourceBufferCount) {\n            // check if SourceBuffer codec needs to change\n            var track = _this3.tracks[trackName];\n            if (track && typeof track.buffer.changeType === 'function') {\n              var _data$trackName = data[trackName],\n                id = _data$trackName.id,\n                codec = _data$trackName.codec,\n                levelCodec = _data$trackName.levelCodec,\n                container = _data$trackName.container,\n                metadata = _data$trackName.metadata;\n              var currentCodec = (track.levelCodec || track.codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n              var nextCodec = (levelCodec || codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n              if (currentCodec !== nextCodec) {\n                var mimeType = container + \";codecs=\" + (levelCodec || codec);\n                _this3.appendChangeType(trackName, mimeType);\n                logger.log(\"[buffer-controller]: switching codec \" + currentCodec + \" to \" + nextCodec);\n                _this3.tracks[trackName] = {\n                  buffer: track.buffer,\n                  codec: codec,\n                  container: container,\n                  levelCodec: levelCodec,\n                  metadata: metadata,\n                  id: id\n                };\n              }\n            }\n          } else {\n            // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n            _this3.pendingTracks[trackName] = data[trackName];\n          }\n        });\n\n        // if sourcebuffers already created, do nothing ...\n        if (sourceBufferCount) {\n          return;\n        }\n        this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);\n        if (this.mediaSource && this.mediaSource.readyState === 'open') {\n          this.checkPendingTracks();\n        }\n      };\n      _proto.appendChangeType = function appendChangeType(type, mimeType) {\n        var _this4 = this;\n        var operationQueue = this.operationQueue;\n        var operation = {\n          execute: function execute() {\n            var sb = _this4.sourceBuffer[type];\n            if (sb) {\n              logger.log(\"[buffer-controller]: changing \" + type + \" sourceBuffer type to \" + mimeType);\n              sb.changeType(mimeType);\n            }\n            operationQueue.shiftAndExecuteNext(type);\n          },\n          onStart: function onStart() {},\n          onComplete: function onComplete() {},\n          onError: function onError(e) {\n            logger.warn(\"[buffer-controller]: Failed to change \" + type + \" SourceBuffer type\", e);\n          }\n        };\n        operationQueue.append(operation, type);\n      };\n      _proto.onBufferAppending = function onBufferAppending(event, eventData) {\n        var _this5 = this;\n        var hls = this.hls,\n          operationQueue = this.operationQueue,\n          tracks = this.tracks;\n        var data = eventData.data,\n          type = eventData.type,\n          frag = eventData.frag,\n          part = eventData.part,\n          chunkMeta = eventData.chunkMeta;\n        var chunkStats = chunkMeta.buffering[type];\n        var bufferAppendingStart = self.performance.now();\n        chunkStats.start = bufferAppendingStart;\n        var fragBuffering = frag.stats.buffering;\n        var partBuffering = part ? part.stats.buffering : null;\n        if (fragBuffering.start === 0) {\n          fragBuffering.start = bufferAppendingStart;\n        }\n        if (partBuffering && partBuffering.start === 0) {\n          partBuffering.start = bufferAppendingStart;\n        }\n\n        // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n        // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n        // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n        // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n        // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n        var audioTrack = tracks.audio;\n        var checkTimestampOffset = false;\n        if (type === 'audio' && (audioTrack == null ? void 0 : audioTrack.container) === 'audio/mpeg') {\n          checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n          this.lastMpegAudioChunk = chunkMeta;\n        }\n        var fragStart = frag.start;\n        var operation = {\n          execute: function execute() {\n            chunkStats.executeStart = self.performance.now();\n            if (checkTimestampOffset) {\n              var sb = _this5.sourceBuffer[type];\n              if (sb) {\n                var delta = fragStart - sb.timestampOffset;\n                if (Math.abs(delta) >= 0.1) {\n                  logger.log(\"[buffer-controller]: Updating audio SourceBuffer timestampOffset to \" + fragStart + \" (delta: \" + delta + \") sn: \" + frag.sn + \")\");\n                  sb.timestampOffset = fragStart;\n                }\n              }\n            }\n            _this5.appendExecutor(data, type);\n          },\n          onStart: function onStart() {\n            // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n          },\n          onComplete: function onComplete() {\n            // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n            var end = self.performance.now();\n            chunkStats.executeEnd = chunkStats.end = end;\n            if (fragBuffering.first === 0) {\n              fragBuffering.first = end;\n            }\n            if (partBuffering && partBuffering.first === 0) {\n              partBuffering.first = end;\n            }\n            var sourceBuffer = _this5.sourceBuffer;\n            var timeRanges = {};\n            for (var _type in sourceBuffer) {\n              timeRanges[_type] = BufferHelper.getBuffered(sourceBuffer[_type]);\n            }\n            _this5.appendError = 0;\n            _this5.hls.trigger(Events.BUFFER_APPENDED, {\n              type: type,\n              frag: frag,\n              part: part,\n              chunkMeta: chunkMeta,\n              parent: frag.type,\n              timeRanges: timeRanges\n            });\n          },\n          onError: function onError(err) {\n            // in case any error occured while appending, put back segment in segments table\n            logger.error(\"[buffer-controller]: Error encountered while trying to append to the \" + type + \" SourceBuffer\", err);\n            var event = {\n              type: ErrorTypes.MEDIA_ERROR,\n              parent: frag.type,\n              details: ErrorDetails.BUFFER_APPEND_ERROR,\n              frag: frag,\n              part: part,\n              chunkMeta: chunkMeta,\n              error: err,\n              err: err,\n              fatal: false\n            };\n            if (err.code === DOMException.QUOTA_EXCEEDED_ERR) {\n              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n              // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n              event.details = ErrorDetails.BUFFER_FULL_ERROR;\n            } else {\n              _this5.appendError++;\n              event.details = ErrorDetails.BUFFER_APPEND_ERROR;\n              /* with UHD content, we could get loop of quota exceeded error until\n                browser is able to evict some data from sourcebuffer. Retrying can help recover.\n              */\n              if (_this5.appendError > hls.config.appendErrorMaxRetry) {\n                logger.error(\"[buffer-controller]: Failed \" + hls.config.appendErrorMaxRetry + \" times to append segment in sourceBuffer\");\n                event.fatal = true;\n              }\n            }\n            hls.trigger(Events.ERROR, event);\n          }\n        };\n        operationQueue.append(operation, type);\n      };\n      _proto.onBufferFlushing = function onBufferFlushing(event, data) {\n        var _this6 = this;\n        var operationQueue = this.operationQueue;\n        var flushOperation = function flushOperation(type) {\n          return {\n            execute: _this6.removeExecutor.bind(_this6, type, data.startOffset, data.endOffset),\n            onStart: function onStart() {\n              // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n            },\n            onComplete: function onComplete() {\n              // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n              _this6.hls.trigger(Events.BUFFER_FLUSHED, {\n                type: type\n              });\n            },\n            onError: function onError(e) {\n              logger.warn(\"[buffer-controller]: Failed to remove from \" + type + \" SourceBuffer\", e);\n            }\n          };\n        };\n        if (data.type) {\n          operationQueue.append(flushOperation(data.type), data.type);\n        } else {\n          this.getSourceBufferTypes().forEach(function (type) {\n            operationQueue.append(flushOperation(type), type);\n          });\n        }\n      };\n      _proto.onFragParsed = function onFragParsed(event, data) {\n        var _this7 = this;\n        var frag = data.frag,\n          part = data.part;\n        var buffersAppendedTo = [];\n        var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n        if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {\n          buffersAppendedTo.push('audiovideo');\n        } else {\n          if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {\n            buffersAppendedTo.push('audio');\n          }\n          if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {\n            buffersAppendedTo.push('video');\n          }\n        }\n        var onUnblocked = function onUnblocked() {\n          var now = self.performance.now();\n          frag.stats.buffering.end = now;\n          if (part) {\n            part.stats.buffering.end = now;\n          }\n          var stats = part ? part.stats : frag.stats;\n          _this7.hls.trigger(Events.FRAG_BUFFERED, {\n            frag: frag,\n            part: part,\n            stats: stats,\n            id: frag.type\n          });\n        };\n        if (buffersAppendedTo.length === 0) {\n          logger.warn(\"Fragments must have at least one ElementaryStreamType set. type: \" + frag.type + \" level: \" + frag.level + \" sn: \" + frag.sn);\n        }\n        this.blockBuffers(onUnblocked, buffersAppendedTo);\n      };\n      _proto.onFragChanged = function onFragChanged(event, data) {\n        this.flushBackBuffer();\n      }\n\n      // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n      // an undefined data.type will mark all buffers as EOS.\n      ;\n\n      _proto.onBufferEos = function onBufferEos(event, data) {\n        var _this8 = this;\n        var ended = this.getSourceBufferTypes().reduce(function (acc, type) {\n          var sb = _this8.sourceBuffer[type];\n          if (sb && (!data.type || data.type === type)) {\n            sb.ending = true;\n            if (!sb.ended) {\n              sb.ended = true;\n              logger.log(\"[buffer-controller]: \" + type + \" sourceBuffer now EOS\");\n            }\n          }\n          return acc && !!(!sb || sb.ended);\n        }, true);\n        if (ended) {\n          logger.log(\"[buffer-controller]: Queueing mediaSource.endOfStream()\");\n          this.blockBuffers(function () {\n            _this8.getSourceBufferTypes().forEach(function (type) {\n              var sb = _this8.sourceBuffer[type];\n              if (sb) {\n                sb.ending = false;\n              }\n            });\n            var mediaSource = _this8.mediaSource;\n            if (!mediaSource || mediaSource.readyState !== 'open') {\n              if (mediaSource) {\n                logger.info(\"[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: \" + mediaSource.readyState);\n              }\n              return;\n            }\n            logger.log(\"[buffer-controller]: Calling mediaSource.endOfStream()\");\n            // Allow this to throw and be caught by the enqueueing function\n            mediaSource.endOfStream();\n          });\n        }\n      };\n      _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n        var details = _ref.details;\n        if (!details.fragments.length) {\n          return;\n        }\n        this.details = details;\n        if (this.getSourceBufferTypes().length) {\n          this.blockBuffers(this.updateMediaElementDuration.bind(this));\n        } else {\n          this.updateMediaElementDuration();\n        }\n      };\n      _proto.flushBackBuffer = function flushBackBuffer() {\n        var hls = this.hls,\n          details = this.details,\n          media = this.media,\n          sourceBuffer = this.sourceBuffer;\n        if (!media || details === null) {\n          return;\n        }\n        var sourceBufferTypes = this.getSourceBufferTypes();\n        if (!sourceBufferTypes.length) {\n          return;\n        }\n\n        // Support for deprecated liveBackBufferLength\n        var backBufferLength = details.live && hls.config.liveBackBufferLength !== null ? hls.config.liveBackBufferLength : hls.config.backBufferLength;\n        if (!isFiniteNumber(backBufferLength) || backBufferLength < 0) {\n          return;\n        }\n        var currentTime = media.currentTime;\n        var targetDuration = details.levelTargetDuration;\n        var maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n        var targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n        sourceBufferTypes.forEach(function (type) {\n          var sb = sourceBuffer[type];\n          if (sb) {\n            var buffered = BufferHelper.getBuffered(sb);\n            // when target buffer start exceeds actual buffer start\n            if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n              hls.trigger(Events.BACK_BUFFER_REACHED, {\n                bufferEnd: targetBackBufferPosition\n              });\n\n              // Support for deprecated event:\n              if (details.live) {\n                hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {\n                  bufferEnd: targetBackBufferPosition\n                });\n              } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {\n                logger.info(\"[buffer-controller]: Cannot flush \" + type + \" back buffer while SourceBuffer is in ended state\");\n                return;\n              }\n              hls.trigger(Events.BUFFER_FLUSHING, {\n                startOffset: 0,\n                endOffset: targetBackBufferPosition,\n                type: type\n              });\n            }\n          }\n        });\n      }\n\n      /**\n       * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n       * 'liveDurationInfinity` is set to `true`\n       * More details: https://github.com/video-dev/hls.js/issues/355\n       */;\n      _proto.updateMediaElementDuration = function updateMediaElementDuration() {\n        if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') {\n          return;\n        }\n        var details = this.details,\n          hls = this.hls,\n          media = this.media,\n          mediaSource = this.mediaSource;\n        var levelDuration = details.fragments[0].start + details.totalduration;\n        var mediaDuration = media.duration;\n        var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;\n        if (details.live && hls.config.liveDurationInfinity) {\n          // Override duration to Infinity\n          logger.log('[buffer-controller]: Media Source duration is set to Infinity');\n          mediaSource.duration = Infinity;\n          this.updateSeekableRange(details);\n        } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {\n          // levelDuration was the last value we set.\n          // not using mediaSource.duration as the browser may tweak this value\n          // only update Media Source duration if its value increase, this is to avoid\n          // flushing already buffered portion when switching between quality level\n          logger.log(\"[buffer-controller]: Updating Media Source duration to \" + levelDuration.toFixed(3));\n          mediaSource.duration = levelDuration;\n        }\n      };\n      _proto.updateSeekableRange = function updateSeekableRange(levelDetails) {\n        var mediaSource = this.mediaSource;\n        var fragments = levelDetails.fragments;\n        var len = fragments.length;\n        if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {\n          var start = Math.max(0, fragments[0].start);\n          var end = Math.max(start, start + levelDetails.totalduration);\n          mediaSource.setLiveSeekableRange(start, end);\n        }\n      };\n      _proto.checkPendingTracks = function checkPendingTracks() {\n        var bufferCodecEventsExpected = this.bufferCodecEventsExpected,\n          operationQueue = this.operationQueue,\n          pendingTracks = this.pendingTracks;\n\n        // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n        // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n        // data has been appended to existing ones.\n        // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n        var pendingTracksCount = Object.keys(pendingTracks).length;\n        if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {\n          // ok, let's create them now !\n          this.createSourceBuffers(pendingTracks);\n          this.pendingTracks = {};\n          // append any pending segments now !\n          var buffers = this.getSourceBufferTypes();\n          if (buffers.length) {\n            this.hls.trigger(Events.BUFFER_CREATED, {\n              tracks: this.tracks\n            });\n            buffers.forEach(function (type) {\n              operationQueue.executeNext(type);\n            });\n          } else {\n            var error = new Error('could not create source buffer for media codec(s)');\n            this.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n              fatal: true,\n              error: error,\n              reason: error.message\n            });\n          }\n        }\n      };\n      _proto.createSourceBuffers = function createSourceBuffers(tracks) {\n        var sourceBuffer = this.sourceBuffer,\n          mediaSource = this.mediaSource;\n        if (!mediaSource) {\n          throw Error('createSourceBuffers called when mediaSource was null');\n        }\n        for (var trackName in tracks) {\n          if (!sourceBuffer[trackName]) {\n            var track = tracks[trackName];\n            if (!track) {\n              throw Error(\"source buffer exists for track \" + trackName + \", however track does not\");\n            }\n            // use levelCodec as first priority\n            var codec = track.levelCodec || track.codec;\n            var mimeType = track.container + \";codecs=\" + codec;\n            logger.log(\"[buffer-controller]: creating sourceBuffer(\" + mimeType + \")\");\n            try {\n              var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n              var sbName = trackName;\n              this.addBufferListener(sbName, 'updatestart', this._onSBUpdateStart);\n              this.addBufferListener(sbName, 'updateend', this._onSBUpdateEnd);\n              this.addBufferListener(sbName, 'error', this._onSBUpdateError);\n              this.tracks[trackName] = {\n                buffer: sb,\n                codec: codec,\n                container: track.container,\n                levelCodec: track.levelCodec,\n                metadata: track.metadata,\n                id: track.id\n              };\n            } catch (err) {\n              logger.error(\"[buffer-controller]: error while trying to add sourceBuffer: \" + err.message);\n              this.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n                fatal: false,\n                error: err,\n                mimeType: mimeType\n              });\n            }\n          }\n        }\n      };\n      _proto._onSBUpdateStart = function _onSBUpdateStart(type) {\n        var operationQueue = this.operationQueue;\n        var operation = operationQueue.current(type);\n        operation.onStart();\n      };\n      _proto._onSBUpdateEnd = function _onSBUpdateEnd(type) {\n        var operationQueue = this.operationQueue;\n        var operation = operationQueue.current(type);\n        operation.onComplete();\n        operationQueue.shiftAndExecuteNext(type);\n      };\n      _proto._onSBUpdateError = function _onSBUpdateError(type, event) {\n        var error = new Error(type + \" SourceBuffer error\");\n        logger.error(\"[buffer-controller]: \" + error, event);\n        // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n        // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_APPENDING_ERROR,\n          error: error,\n          fatal: false\n        });\n        // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n        var operation = this.operationQueue.current(type);\n        if (operation) {\n          operation.onError(event);\n        }\n      }\n\n      // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually\n      ;\n\n      _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {\n        var media = this.media,\n          mediaSource = this.mediaSource,\n          operationQueue = this.operationQueue,\n          sourceBuffer = this.sourceBuffer;\n        var sb = sourceBuffer[type];\n        if (!media || !mediaSource || !sb) {\n          logger.warn(\"[buffer-controller]: Attempting to remove from the \" + type + \" SourceBuffer, but it does not exist\");\n          operationQueue.shiftAndExecuteNext(type);\n          return;\n        }\n        var mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;\n        var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;\n        var removeStart = Math.max(0, startOffset);\n        var removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n        if (removeEnd > removeStart && !sb.ending) {\n          sb.ended = false;\n          logger.log(\"[buffer-controller]: Removing [\" + removeStart + \",\" + removeEnd + \"] from the \" + type + \" SourceBuffer\");\n          sb.remove(removeStart, removeEnd);\n        } else {\n          // Cycle the queue\n          operationQueue.shiftAndExecuteNext(type);\n        }\n      }\n\n      // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually\n      ;\n\n      _proto.appendExecutor = function appendExecutor(data, type) {\n        var operationQueue = this.operationQueue,\n          sourceBuffer = this.sourceBuffer;\n        var sb = sourceBuffer[type];\n        if (!sb) {\n          logger.warn(\"[buffer-controller]: Attempting to append to the \" + type + \" SourceBuffer, but it does not exist\");\n          operationQueue.shiftAndExecuteNext(type);\n          return;\n        }\n        sb.ended = false;\n        sb.appendBuffer(data);\n      }\n\n      // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n      // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n      // upon completion, since we already do it here\n      ;\n\n      _proto.blockBuffers = function blockBuffers(onUnblocked, buffers) {\n        var _this9 = this;\n        if (buffers === void 0) {\n          buffers = this.getSourceBufferTypes();\n        }\n        if (!buffers.length) {\n          logger.log('[buffer-controller]: Blocking operation requested, but no SourceBuffers exist');\n          Promise.resolve().then(onUnblocked);\n          return;\n        }\n        var operationQueue = this.operationQueue;\n\n        // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n        var blockingOperations = buffers.map(function (type) {\n          return operationQueue.appendBlocker(type);\n        });\n        Promise.all(blockingOperations).then(function () {\n          // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n          onUnblocked();\n          buffers.forEach(function (type) {\n            var sb = _this9.sourceBuffer[type];\n            // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n            // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n            // While this is a workaround, it's probably useful to have around\n            if (!(sb != null && sb.updating)) {\n              operationQueue.shiftAndExecuteNext(type);\n            }\n          });\n        });\n      };\n      _proto.getSourceBufferTypes = function getSourceBufferTypes() {\n        return Object.keys(this.sourceBuffer);\n      };\n      _proto.addBufferListener = function addBufferListener(type, event, fn) {\n        var buffer = this.sourceBuffer[type];\n        if (!buffer) {\n          return;\n        }\n        var listener = fn.bind(this, type);\n        this.listeners[type].push({\n          event: event,\n          listener: listener\n        });\n        buffer.addEventListener(event, listener);\n      };\n      _proto.removeBufferListeners = function removeBufferListeners(type) {\n        var buffer = this.sourceBuffer[type];\n        if (!buffer) {\n          return;\n        }\n        this.listeners[type].forEach(function (l) {\n          buffer.removeEventListener(l.event, l.listener);\n        });\n      };\n      return BufferController;\n    }();\n    var CapLevelController = /*#__PURE__*/function () {\n      function CapLevelController(hls) {\n        this.hls = void 0;\n        this.autoLevelCapping = void 0;\n        this.firstLevel = void 0;\n        this.media = void 0;\n        this.restrictedLevels = void 0;\n        this.timer = void 0;\n        this.clientRect = void 0;\n        this.streamController = void 0;\n        this.hls = hls;\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        this.firstLevel = -1;\n        this.media = null;\n        this.restrictedLevels = [];\n        this.timer = undefined;\n        this.clientRect = null;\n        this.registerListeners();\n      }\n      var _proto = CapLevelController.prototype;\n      _proto.setStreamController = function setStreamController(streamController) {\n        this.streamController = streamController;\n      };\n      _proto.destroy = function destroy() {\n        this.unregisterListener();\n        if (this.hls.config.capLevelToPlayerSize) {\n          this.stopCapping();\n        }\n        this.media = null;\n        this.clientRect = null;\n        // @ts-ignore\n        this.hls = this.streamController = null;\n      };\n      _proto.registerListeners = function registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      };\n      _proto.unregisterListener = function unregisterListener() {\n        var hls = this.hls;\n        hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      };\n      _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {\n        // Don't add a restricted level more than once\n        var level = this.hls.levels[data.droppedLevel];\n        if (this.isLevelAllowed(level)) {\n          this.restrictedLevels.push({\n            bitrate: level.bitrate,\n            height: level.height,\n            width: level.width\n          });\n        }\n      };\n      _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n        this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n        this.clientRect = null;\n      };\n      _proto.onManifestParsed = function onManifestParsed(event, data) {\n        var hls = this.hls;\n        this.restrictedLevels = [];\n        this.firstLevel = data.firstLevel;\n        if (hls.config.capLevelToPlayerSize && data.video) {\n          // Start capping immediately if the manifest has signaled video codecs\n          this.startCapping();\n        }\n      }\n\n      // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n      // to the first level\n      ;\n\n      _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n        var hls = this.hls;\n        if (hls.config.capLevelToPlayerSize && data.video) {\n          // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n          this.startCapping();\n        }\n      };\n      _proto.onMediaDetaching = function onMediaDetaching() {\n        this.stopCapping();\n      };\n      _proto.detectPlayerSize = function detectPlayerSize() {\n        if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {\n          var levels = this.hls.levels;\n          if (levels.length) {\n            var hls = this.hls;\n            hls.autoLevelCapping = this.getMaxLevel(levels.length - 1);\n            if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n              // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n              // usually happen when the user go to the fullscreen mode.\n              this.streamController.nextLevelSwitch();\n            }\n            this.autoLevelCapping = hls.autoLevelCapping;\n          }\n        }\n      }\n\n      /*\n       * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n       */;\n      _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {\n        var _this = this;\n        var levels = this.hls.levels;\n        if (!levels.length) {\n          return -1;\n        }\n        var validLevels = levels.filter(function (level, index) {\n          return _this.isLevelAllowed(level) && index <= capLevelIndex;\n        });\n        this.clientRect = null;\n        return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n      };\n      _proto.startCapping = function startCapping() {\n        if (this.timer) {\n          // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n          return;\n        }\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        this.hls.firstLevel = this.getMaxLevel(this.firstLevel);\n        self.clearInterval(this.timer);\n        this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n        this.detectPlayerSize();\n      };\n      _proto.stopCapping = function stopCapping() {\n        this.restrictedLevels = [];\n        this.firstLevel = -1;\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        if (this.timer) {\n          self.clearInterval(this.timer);\n          this.timer = undefined;\n        }\n      };\n      _proto.getDimensions = function getDimensions() {\n        if (this.clientRect) {\n          return this.clientRect;\n        }\n        var media = this.media;\n        var boundsRect = {\n          width: 0,\n          height: 0\n        };\n        if (media) {\n          var clientRect = media.getBoundingClientRect();\n          boundsRect.width = clientRect.width;\n          boundsRect.height = clientRect.height;\n          if (!boundsRect.width && !boundsRect.height) {\n            // When the media element has no width or height (equivalent to not being in the DOM),\n            // then use its width and height attributes (media.width, media.height)\n            boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n            boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n          }\n        }\n        this.clientRect = boundsRect;\n        return boundsRect;\n      };\n      _proto.isLevelAllowed = function isLevelAllowed(level) {\n        var restrictedLevels = this.restrictedLevels;\n        return !restrictedLevels.some(function (restrictedLevel) {\n          return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;\n        });\n      };\n      CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {\n        if (!(levels != null && levels.length)) {\n          return -1;\n        }\n\n        // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n        // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n        var atGreatestBandwidth = function atGreatestBandwidth(curLevel, nextLevel) {\n          if (!nextLevel) {\n            return true;\n          }\n          return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n        };\n\n        // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n        // the max level\n        var maxLevelIndex = levels.length - 1;\n        for (var i = 0; i < levels.length; i += 1) {\n          var level = levels[i];\n          if ((level.width >= width || level.height >= height) && atGreatestBandwidth(level, levels[i + 1])) {\n            maxLevelIndex = i;\n            break;\n          }\n        }\n        return maxLevelIndex;\n      };\n      _createClass(CapLevelController, [{\n        key: \"mediaWidth\",\n        get: function get() {\n          return this.getDimensions().width * this.contentScaleFactor;\n        }\n      }, {\n        key: \"mediaHeight\",\n        get: function get() {\n          return this.getDimensions().height * this.contentScaleFactor;\n        }\n      }, {\n        key: \"contentScaleFactor\",\n        get: function get() {\n          var pixelRatio = 1;\n          if (!this.hls.config.ignoreDevicePixelRatio) {\n            try {\n              pixelRatio = self.devicePixelRatio;\n            } catch (e) {\n              /* no-op */\n            }\n          }\n          return pixelRatio;\n        }\n      }]);\n      return CapLevelController;\n    }();\n    var FPSController = /*#__PURE__*/function () {\n      // stream controller must be provided as a dependency!\n\n      function FPSController(hls) {\n        this.hls = void 0;\n        this.isVideoPlaybackQualityAvailable = false;\n        this.timer = void 0;\n        this.media = null;\n        this.lastTime = void 0;\n        this.lastDroppedFrames = 0;\n        this.lastDecodedFrames = 0;\n        this.streamController = void 0;\n        this.hls = hls;\n        this.registerListeners();\n      }\n      var _proto = FPSController.prototype;\n      _proto.setStreamController = function setStreamController(streamController) {\n        this.streamController = streamController;\n      };\n      _proto.registerListeners = function registerListeners() {\n        this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      };\n      _proto.unregisterListeners = function unregisterListeners() {\n        this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      };\n      _proto.destroy = function destroy() {\n        if (this.timer) {\n          clearInterval(this.timer);\n        }\n        this.unregisterListeners();\n        this.isVideoPlaybackQualityAvailable = false;\n        this.media = null;\n      };\n      _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n        var config = this.hls.config;\n        if (config.capLevelOnFPSDrop) {\n          var media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n          this.media = media;\n          if (media && typeof media.getVideoPlaybackQuality === 'function') {\n            this.isVideoPlaybackQualityAvailable = true;\n          }\n          self.clearInterval(this.timer);\n          this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n        }\n      };\n      _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {\n        var currentTime = performance.now();\n        if (decodedFrames) {\n          if (this.lastTime) {\n            var currentPeriod = currentTime - this.lastTime;\n            var currentDropped = droppedFrames - this.lastDroppedFrames;\n            var currentDecoded = decodedFrames - this.lastDecodedFrames;\n            var droppedFPS = 1000 * currentDropped / currentPeriod;\n            var hls = this.hls;\n            hls.trigger(Events.FPS_DROP, {\n              currentDropped: currentDropped,\n              currentDecoded: currentDecoded,\n              totalDroppedFrames: droppedFrames\n            });\n            if (droppedFPS > 0) {\n              // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n              if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n                var currentLevel = hls.currentLevel;\n                logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n                if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n                  currentLevel = currentLevel - 1;\n                  hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {\n                    level: currentLevel,\n                    droppedLevel: hls.currentLevel\n                  });\n                  hls.autoLevelCapping = currentLevel;\n                  this.streamController.nextLevelSwitch();\n                }\n              }\n            }\n          }\n          this.lastTime = currentTime;\n          this.lastDroppedFrames = droppedFrames;\n          this.lastDecodedFrames = decodedFrames;\n        }\n      };\n      _proto.checkFPSInterval = function checkFPSInterval() {\n        var video = this.media;\n        if (video) {\n          if (this.isVideoPlaybackQualityAvailable) {\n            var videoPlaybackQuality = video.getVideoPlaybackQuality();\n            this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n          } else {\n            // HTMLVideoElement doesn't include the webkit types\n            this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n          }\n        }\n      };\n      return FPSController;\n    }();\n    var AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/im;\n    var XhrLoader = /*#__PURE__*/function () {\n      function XhrLoader(config) {\n        this.xhrSetup = void 0;\n        this.requestTimeout = void 0;\n        this.retryTimeout = void 0;\n        this.retryDelay = void 0;\n        this.config = null;\n        this.callbacks = null;\n        this.context = void 0;\n        this.loader = null;\n        this.stats = void 0;\n        this.xhrSetup = config ? config.xhrSetup || null : null;\n        this.stats = new LoadStats();\n        this.retryDelay = 0;\n      }\n      var _proto = XhrLoader.prototype;\n      _proto.destroy = function destroy() {\n        this.callbacks = null;\n        this.abortInternal();\n        this.loader = null;\n        this.config = null;\n      };\n      _proto.abortInternal = function abortInternal() {\n        var loader = this.loader;\n        self.clearTimeout(this.requestTimeout);\n        self.clearTimeout(this.retryTimeout);\n        if (loader) {\n          loader.onreadystatechange = null;\n          loader.onprogress = null;\n          if (loader.readyState !== 4) {\n            this.stats.aborted = true;\n            loader.abort();\n          }\n        }\n      };\n      _proto.abort = function abort() {\n        var _this$callbacks;\n        this.abortInternal();\n        if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n          this.callbacks.onAbort(this.stats, this.context, this.loader);\n        }\n      };\n      _proto.load = function load(context, config, callbacks) {\n        if (this.stats.loading.start) {\n          throw new Error('Loader can only be used once.');\n        }\n        this.stats.loading.start = self.performance.now();\n        this.context = context;\n        this.config = config;\n        this.callbacks = callbacks;\n        this.loadInternal();\n      };\n      _proto.loadInternal = function loadInternal() {\n        var _this = this;\n        var config = this.config,\n          context = this.context;\n        if (!config) {\n          return;\n        }\n        var xhr = this.loader = new self.XMLHttpRequest();\n        var stats = this.stats;\n        stats.loading.first = 0;\n        stats.loaded = 0;\n        var xhrSetup = this.xhrSetup;\n        if (xhrSetup) {\n          Promise.resolve().then(function () {\n            if (_this.stats.aborted) return;\n            return xhrSetup(xhr, context.url);\n          }).catch(function (error) {\n            xhr.open('GET', context.url, true);\n            return xhrSetup(xhr, context.url);\n          }).then(function () {\n            if (_this.stats.aborted) return;\n            _this.openAndSendXhr(xhr, context, config);\n          }).catch(function (error) {\n            // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n            _this.callbacks.onError({\n              code: xhr.status,\n              text: error.message\n            }, context, xhr, stats);\n            return;\n          });\n        } else {\n          this.openAndSendXhr(xhr, context, config);\n        }\n      };\n      _proto.openAndSendXhr = function openAndSendXhr(xhr, context, config) {\n        if (!xhr.readyState) {\n          xhr.open('GET', context.url, true);\n        }\n        var headers = this.context.headers;\n        var _config$loadPolicy = config.loadPolicy,\n          maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs,\n          maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;\n        if (headers) {\n          for (var header in headers) {\n            xhr.setRequestHeader(header, headers[header]);\n          }\n        }\n        if (context.rangeEnd) {\n          xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n        }\n        xhr.onreadystatechange = this.readystatechange.bind(this);\n        xhr.onprogress = this.loadprogress.bind(this);\n        xhr.responseType = context.responseType;\n        // setup timeout before we perform request\n        self.clearTimeout(this.requestTimeout);\n        config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n        xhr.send();\n      };\n      _proto.readystatechange = function readystatechange() {\n        var context = this.context,\n          xhr = this.loader,\n          stats = this.stats;\n        if (!context || !xhr) {\n          return;\n        }\n        var readyState = xhr.readyState;\n        var config = this.config;\n\n        // don't proceed if xhr has been aborted\n        if (stats.aborted) {\n          return;\n        }\n\n        // >= HEADERS_RECEIVED\n        if (readyState >= 2) {\n          if (stats.loading.first === 0) {\n            stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n            // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n            if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {\n              self.clearTimeout(this.requestTimeout);\n              config.timeout = config.loadPolicy.maxLoadTimeMs;\n              this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));\n            }\n          }\n          if (readyState === 4) {\n            self.clearTimeout(this.requestTimeout);\n            xhr.onreadystatechange = null;\n            xhr.onprogress = null;\n            var _status = xhr.status;\n            // http status between 200 to 299 are all successful\n            var useResponse = xhr.responseType !== 'text';\n            if (_status >= 200 && _status < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {\n              stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n              var data = useResponse ? xhr.response : xhr.responseText;\n              var len = xhr.responseType === 'arraybuffer' ? data.byteLength : data.length;\n              stats.loaded = stats.total = len;\n              stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);\n              if (!this.callbacks) {\n                return;\n              }\n              var onProgress = this.callbacks.onProgress;\n              if (onProgress) {\n                onProgress(stats, context, data, xhr);\n              }\n              if (!this.callbacks) {\n                return;\n              }\n              var response = {\n                url: xhr.responseURL,\n                data: data,\n                code: _status\n              };\n              this.callbacks.onSuccess(response, stats, context, xhr);\n            } else {\n              var retryConfig = config.loadPolicy.errorRetry;\n              var retryCount = stats.retry;\n              // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n              if (shouldRetry(retryConfig, retryCount, false, _status)) {\n                this.retry(retryConfig);\n              } else {\n                logger.error(_status + \" while loading \" + context.url);\n                this.callbacks.onError({\n                  code: _status,\n                  text: xhr.statusText\n                }, context, xhr, stats);\n              }\n            }\n          }\n        }\n      };\n      _proto.loadtimeout = function loadtimeout() {\n        var _this$config;\n        var retryConfig = (_this$config = this.config) == null ? void 0 : _this$config.loadPolicy.timeoutRetry;\n        var retryCount = this.stats.retry;\n        if (shouldRetry(retryConfig, retryCount, true)) {\n          this.retry(retryConfig);\n        } else {\n          logger.warn(\"timeout while loading \" + this.context.url);\n          var callbacks = this.callbacks;\n          if (callbacks) {\n            this.abortInternal();\n            callbacks.onTimeout(this.stats, this.context, this.loader);\n          }\n        }\n      };\n      _proto.retry = function retry(retryConfig) {\n        var context = this.context,\n          stats = this.stats;\n        this.retryDelay = getRetryDelay(retryConfig, stats.retry);\n        stats.retry++;\n        logger.warn((status ? 'HTTP Status ' + status : 'Timeout') + \" while loading \" + context.url + \", retrying \" + stats.retry + \"/\" + retryConfig.maxNumRetry + \" in \" + this.retryDelay + \"ms\");\n        // abort and reset internal state\n        this.abortInternal();\n        this.loader = null;\n        // schedule retry\n        self.clearTimeout(this.retryTimeout);\n        this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n      };\n      _proto.loadprogress = function loadprogress(event) {\n        var stats = this.stats;\n        stats.loaded = event.loaded;\n        if (event.lengthComputable) {\n          stats.total = event.total;\n        }\n      };\n      _proto.getCacheAge = function getCacheAge() {\n        var result = null;\n        if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n          var ageHeader = this.loader.getResponseHeader('age');\n          result = ageHeader ? parseFloat(ageHeader) : null;\n        }\n        return result;\n      };\n      _proto.getResponseHeader = function getResponseHeader(name) {\n        if (this.loader && new RegExp(\"^\" + name + \":\\\\s*[\\\\d.]+\\\\s*$\", 'im').test(this.loader.getAllResponseHeaders())) {\n          return this.loader.getResponseHeader(name);\n        }\n        return null;\n      };\n      return XhrLoader;\n    }();\n    var ChunkCache = /*#__PURE__*/function () {\n      function ChunkCache() {\n        this.chunks = [];\n        this.dataLength = 0;\n      }\n      var _proto = ChunkCache.prototype;\n      _proto.push = function push(chunk) {\n        this.chunks.push(chunk);\n        this.dataLength += chunk.length;\n      };\n      _proto.flush = function flush() {\n        var chunks = this.chunks,\n          dataLength = this.dataLength;\n        var result;\n        if (!chunks.length) {\n          return new Uint8Array(0);\n        } else if (chunks.length === 1) {\n          result = chunks[0];\n        } else {\n          result = concatUint8Arrays(chunks, dataLength);\n        }\n        this.reset();\n        return result;\n      };\n      _proto.reset = function reset() {\n        this.chunks.length = 0;\n        this.dataLength = 0;\n      };\n      return ChunkCache;\n    }();\n    function concatUint8Arrays(chunks, dataLength) {\n      var result = new Uint8Array(dataLength);\n      var offset = 0;\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i];\n        result.set(chunk, offset);\n        offset += chunk.length;\n      }\n      return result;\n    }\n    function fetchSupported() {\n      if (\n      // @ts-ignore\n      self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n        try {\n          new self.ReadableStream({}); // eslint-disable-line no-new\n          return true;\n        } catch (e) {\n          /* noop */\n        }\n      }\n      return false;\n    }\n    var BYTERANGE = /(\\d+)-(\\d+)\\/(\\d+)/;\n    var FetchLoader = /*#__PURE__*/function () {\n      function FetchLoader(config /* HlsConfig */) {\n        this.fetchSetup = void 0;\n        this.requestTimeout = void 0;\n        this.request = void 0;\n        this.response = void 0;\n        this.controller = void 0;\n        this.context = void 0;\n        this.config = null;\n        this.callbacks = null;\n        this.stats = void 0;\n        this.loader = null;\n        this.fetchSetup = config.fetchSetup || getRequest;\n        this.controller = new self.AbortController();\n        this.stats = new LoadStats();\n      }\n      var _proto = FetchLoader.prototype;\n      _proto.destroy = function destroy() {\n        this.loader = this.callbacks = null;\n        this.abortInternal();\n      };\n      _proto.abortInternal = function abortInternal() {\n        var response = this.response;\n        if (!(response != null && response.ok)) {\n          this.stats.aborted = true;\n          this.controller.abort();\n        }\n      };\n      _proto.abort = function abort() {\n        var _this$callbacks;\n        this.abortInternal();\n        if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n          this.callbacks.onAbort(this.stats, this.context, this.response);\n        }\n      };\n      _proto.load = function load(context, config, callbacks) {\n        var _this = this;\n        var stats = this.stats;\n        if (stats.loading.start) {\n          throw new Error('Loader can only be used once.');\n        }\n        stats.loading.start = self.performance.now();\n        var initParams = getRequestParameters(context, this.controller.signal);\n        var onProgress = callbacks.onProgress;\n        var isArrayBuffer = context.responseType === 'arraybuffer';\n        var LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n        var _config$loadPolicy = config.loadPolicy,\n          maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs,\n          maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;\n        this.context = context;\n        this.config = config;\n        this.callbacks = callbacks;\n        this.request = this.fetchSetup(context, initParams);\n        self.clearTimeout(this.requestTimeout);\n        config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n        this.requestTimeout = self.setTimeout(function () {\n          _this.abortInternal();\n          callbacks.onTimeout(stats, context, _this.response);\n        }, config.timeout);\n        self.fetch(this.request).then(function (response) {\n          _this.response = _this.loader = response;\n          var first = Math.max(self.performance.now(), stats.loading.start);\n          self.clearTimeout(_this.requestTimeout);\n          config.timeout = maxLoadTimeMs;\n          _this.requestTimeout = self.setTimeout(function () {\n            _this.abortInternal();\n            callbacks.onTimeout(stats, context, _this.response);\n          }, maxLoadTimeMs - (first - stats.loading.start));\n          if (!response.ok) {\n            var status = response.status,\n              statusText = response.statusText;\n            throw new FetchError(statusText || 'fetch, bad network response', status, response);\n          }\n          stats.loading.first = first;\n          stats.total = getContentLength(response.headers) || stats.total;\n          if (onProgress && isFiniteNumber(config.highWaterMark)) {\n            return _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n          }\n          if (isArrayBuffer) {\n            return response.arrayBuffer();\n          }\n          if (context.responseType === 'json') {\n            return response.json();\n          }\n          return response.text();\n        }).then(function (responseData) {\n          var response = _this.response;\n          self.clearTimeout(_this.requestTimeout);\n          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n          var total = responseData[LENGTH];\n          if (total) {\n            stats.loaded = stats.total = total;\n          }\n          var loaderResponse = {\n            url: response.url,\n            data: responseData,\n            code: response.status\n          };\n          if (onProgress && !isFiniteNumber(config.highWaterMark)) {\n            onProgress(stats, context, responseData, response);\n          }\n          callbacks.onSuccess(loaderResponse, stats, context, response);\n        }).catch(function (error) {\n          self.clearTimeout(_this.requestTimeout);\n          if (stats.aborted) {\n            return;\n          }\n          // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n          // when destroying, 'error' itself can be undefined\n          var code = !error ? 0 : error.code || 0;\n          var text = !error ? null : error.message;\n          callbacks.onError({\n            code: code,\n            text: text\n          }, context, error ? error.details : null, stats);\n        });\n      };\n      _proto.getCacheAge = function getCacheAge() {\n        var result = null;\n        if (this.response) {\n          var ageHeader = this.response.headers.get('age');\n          result = ageHeader ? parseFloat(ageHeader) : null;\n        }\n        return result;\n      };\n      _proto.getResponseHeader = function getResponseHeader(name) {\n        return this.response ? this.response.headers.get(name) : null;\n      };\n      _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {\n        if (highWaterMark === void 0) {\n          highWaterMark = 0;\n        }\n        var chunkCache = new ChunkCache();\n        var reader = response.body.getReader();\n        var pump = function pump() {\n          return reader.read().then(function (data) {\n            if (data.done) {\n              if (chunkCache.dataLength) {\n                onProgress(stats, context, chunkCache.flush(), response);\n              }\n              return Promise.resolve(new ArrayBuffer(0));\n            }\n            var chunk = data.value;\n            var len = chunk.length;\n            stats.loaded += len;\n            if (len < highWaterMark || chunkCache.dataLength) {\n              // The current chunk is too small to to be emitted or the cache already has data\n              // Push it to the cache\n              chunkCache.push(chunk);\n              if (chunkCache.dataLength >= highWaterMark) {\n                // flush in order to join the typed arrays\n                onProgress(stats, context, chunkCache.flush(), response);\n              }\n            } else {\n              // If there's nothing cached already, and the chache is large enough\n              // just emit the progress event\n              onProgress(stats, context, chunk, response);\n            }\n            return pump();\n          }).catch(function () {\n            /* aborted */\n            return Promise.reject();\n          });\n        };\n        return pump();\n      };\n      return FetchLoader;\n    }();\n    function getRequestParameters(context, signal) {\n      var initParams = {\n        method: 'GET',\n        mode: 'cors',\n        credentials: 'same-origin',\n        signal: signal,\n        headers: new self.Headers(_extends({}, context.headers))\n      };\n      if (context.rangeEnd) {\n        initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n      }\n      return initParams;\n    }\n    function getByteRangeLength(byteRangeHeader) {\n      var result = BYTERANGE.exec(byteRangeHeader);\n      if (result) {\n        return parseInt(result[2]) - parseInt(result[1]) + 1;\n      }\n    }\n    function getContentLength(headers) {\n      var contentRange = headers.get('Content-Range');\n      if (contentRange) {\n        var byteRangeLength = getByteRangeLength(contentRange);\n        if (isFiniteNumber(byteRangeLength)) {\n          return byteRangeLength;\n        }\n      }\n      var contentLength = headers.get('Content-Length');\n      if (contentLength) {\n        return parseInt(contentLength);\n      }\n    }\n    function getRequest(context, initParams) {\n      return new self.Request(context.url, initParams);\n    }\n    var FetchError = /*#__PURE__*/function (_Error) {\n      _inheritsLoose(FetchError, _Error);\n      function FetchError(message, code, details) {\n        var _this2;\n        _this2 = _Error.call(this, message) || this;\n        _this2.code = void 0;\n        _this2.details = void 0;\n        _this2.code = code;\n        _this2.details = details;\n        return _this2;\n      }\n      return FetchError;\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n    /**\n     * @deprecated use fragLoadPolicy.default\n     */\n\n    /**\n     * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default\n     */\n\n    var defaultLoadPolicy = {\n      maxTimeToFirstByteMs: 8000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: null,\n      errorRetry: null\n    };\n\n    /**\n     * @ignore\n     * If possible, keep hlsDefaultConfig shallow\n     * It is cloned whenever a new Hls instance is created, by keeping the config\n     * shallow the properties are cloned, and we don't end up manipulating the default\n     */\n    var hlsDefaultConfig = _objectSpread2(_objectSpread2({\n      autoStartLoad: true,\n      // used by stream-controller\n      startPosition: -1,\n      // used by stream-controller\n      defaultAudioCodec: undefined,\n      // used by stream-controller\n      debug: false,\n      // used by logger\n      capLevelOnFPSDrop: false,\n      // used by fps-controller\n      capLevelToPlayerSize: false,\n      // used by cap-level-controller\n      ignoreDevicePixelRatio: false,\n      // used by cap-level-controller\n      initialLiveManifestSize: 1,\n      // used by stream-controller\n      maxBufferLength: 30,\n      // used by stream-controller\n      backBufferLength: Infinity,\n      // used by buffer-controller\n      maxBufferSize: 60 * 1000 * 1000,\n      // used by stream-controller\n      maxBufferHole: 0.1,\n      // used by stream-controller\n      highBufferWatchdogPeriod: 2,\n      // used by stream-controller\n      nudgeOffset: 0.1,\n      // used by stream-controller\n      nudgeMaxRetry: 3,\n      // used by stream-controller\n      maxFragLookUpTolerance: 0.25,\n      // used by stream-controller\n      liveSyncDurationCount: 3,\n      // used by latency-controller\n      liveMaxLatencyDurationCount: Infinity,\n      // used by latency-controller\n      liveSyncDuration: undefined,\n      // used by latency-controller\n      liveMaxLatencyDuration: undefined,\n      // used by latency-controller\n      maxLiveSyncPlaybackRate: 1,\n      // used by latency-controller\n      liveDurationInfinity: false,\n      // used by buffer-controller\n      /**\n       * @deprecated use backBufferLength\n       */\n      liveBackBufferLength: null,\n      // used by buffer-controller\n      maxMaxBufferLength: 600,\n      // used by stream-controller\n      enableWorker: true,\n      // used by transmuxer\n      workerPath: null,\n      // used by transmuxer\n      enableSoftwareAES: true,\n      // used by decrypter\n      startLevel: undefined,\n      // used by level-controller\n      startFragPrefetch: false,\n      // used by stream-controller\n      fpsDroppedMonitoringPeriod: 5000,\n      // used by fps-controller\n      fpsDroppedMonitoringThreshold: 0.2,\n      // used by fps-controller\n      appendErrorMaxRetry: 3,\n      // used by buffer-controller\n      loader: XhrLoader,\n      // loader: FetchLoader,\n      fLoader: undefined,\n      // used by fragment-loader\n      pLoader: undefined,\n      // used by playlist-loader\n      xhrSetup: undefined,\n      // used by xhr-loader\n      licenseXhrSetup: undefined,\n      // used by eme-controller\n      licenseResponseCallback: undefined,\n      // used by eme-controller\n      abrController: AbrController,\n      bufferController: BufferController,\n      capLevelController: CapLevelController,\n      errorController: ErrorController,\n      fpsController: FPSController,\n      stretchShortVideoTrack: false,\n      // used by mp4-remuxer\n      maxAudioFramesDrift: 1,\n      // used by mp4-remuxer\n      forceKeyFrameOnDiscontinuity: true,\n      // used by ts-demuxer\n      abrEwmaFastLive: 3,\n      // used by abr-controller\n      abrEwmaSlowLive: 9,\n      // used by abr-controller\n      abrEwmaFastVoD: 3,\n      // used by abr-controller\n      abrEwmaSlowVoD: 9,\n      // used by abr-controller\n      abrEwmaDefaultEstimate: 5e5,\n      // 500 kbps  // used by abr-controller\n      abrBandWidthFactor: 0.95,\n      // used by abr-controller\n      abrBandWidthUpFactor: 0.7,\n      // used by abr-controller\n      abrMaxWithRealBitrate: false,\n      // used by abr-controller\n      maxStarvationDelay: 4,\n      // used by abr-controller\n      maxLoadingDelay: 4,\n      // used by abr-controller\n      minAutoBitrate: 0,\n      // used by hls\n      emeEnabled: false,\n      // used by eme-controller\n      widevineLicenseUrl: undefined,\n      // used by eme-controller\n      drmSystems: {},\n      // used by eme-controller\n      drmSystemOptions: {},\n      // used by eme-controller\n      requestMediaKeySystemAccessFunc: null,\n      // used by eme-controller\n      testBandwidth: true,\n      progressive: false,\n      lowLatencyMode: true,\n      cmcd: undefined,\n      enableDateRangeMetadataCues: true,\n      enableEmsgMetadataCues: true,\n      enableID3MetadataCues: true,\n      certLoadPolicy: {\n        default: defaultLoadPolicy\n      },\n      keyLoadPolicy: {\n        default: {\n          maxTimeToFirstByteMs: 8000,\n          maxLoadTimeMs: 20000,\n          timeoutRetry: {\n            maxNumRetry: 1,\n            retryDelayMs: 1000,\n            maxRetryDelayMs: 20000,\n            backoff: 'linear'\n          },\n          errorRetry: {\n            maxNumRetry: 8,\n            retryDelayMs: 1000,\n            maxRetryDelayMs: 20000,\n            backoff: 'linear'\n          }\n        }\n      },\n      manifestLoadPolicy: {\n        default: {\n          maxTimeToFirstByteMs: Infinity,\n          maxLoadTimeMs: 20000,\n          timeoutRetry: {\n            maxNumRetry: 2,\n            retryDelayMs: 0,\n            maxRetryDelayMs: 0\n          },\n          errorRetry: {\n            maxNumRetry: 1,\n            retryDelayMs: 1000,\n            maxRetryDelayMs: 8000\n          }\n        }\n      },\n      playlistLoadPolicy: {\n        default: {\n          maxTimeToFirstByteMs: 10000,\n          maxLoadTimeMs: 20000,\n          timeoutRetry: {\n            maxNumRetry: 2,\n            retryDelayMs: 0,\n            maxRetryDelayMs: 0\n          },\n          errorRetry: {\n            maxNumRetry: 2,\n            retryDelayMs: 1000,\n            maxRetryDelayMs: 8000\n          }\n        }\n      },\n      fragLoadPolicy: {\n        default: {\n          maxTimeToFirstByteMs: 10000,\n          maxLoadTimeMs: 120000,\n          timeoutRetry: {\n            maxNumRetry: 4,\n            retryDelayMs: 0,\n            maxRetryDelayMs: 0\n          },\n          errorRetry: {\n            maxNumRetry: 6,\n            retryDelayMs: 1000,\n            maxRetryDelayMs: 8000\n          }\n        }\n      },\n      steeringManifestLoadPolicy: {\n        default: defaultLoadPolicy\n      },\n      // These default settings are deprecated in favor of the above policies\n      // and are maintained for backwards compatibility\n      manifestLoadingTimeOut: 10000,\n      manifestLoadingMaxRetry: 1,\n      manifestLoadingRetryDelay: 1000,\n      manifestLoadingMaxRetryTimeout: 64000,\n      levelLoadingTimeOut: 10000,\n      levelLoadingMaxRetry: 4,\n      levelLoadingRetryDelay: 1000,\n      levelLoadingMaxRetryTimeout: 64000,\n      fragLoadingTimeOut: 20000,\n      fragLoadingMaxRetry: 6,\n      fragLoadingRetryDelay: 1000,\n      fragLoadingMaxRetryTimeout: 64000\n    }, timelineConfig()), {}, {\n      subtitleStreamController: undefined,\n      subtitleTrackController: undefined,\n      timelineController: undefined,\n      audioStreamController: undefined,\n      audioTrackController: undefined,\n      emeController: undefined,\n      cmcdController: undefined,\n      contentSteeringController: undefined\n    });\n    function timelineConfig() {\n      return {\n        cueHandler: Cues,\n        // used by timeline-controller\n        enableWebVTT: false,\n        // used by timeline-controller\n        enableIMSC1: false,\n        // used by timeline-controller\n        enableCEA708Captions: false,\n        // used by timeline-controller\n        captionsTextTrack1Label: 'English',\n        // used by timeline-controller\n        captionsTextTrack1LanguageCode: 'en',\n        // used by timeline-controller\n        captionsTextTrack2Label: 'Spanish',\n        // used by timeline-controller\n        captionsTextTrack2LanguageCode: 'es',\n        // used by timeline-controller\n        captionsTextTrack3Label: 'Unknown CC',\n        // used by timeline-controller\n        captionsTextTrack3LanguageCode: '',\n        // used by timeline-controller\n        captionsTextTrack4Label: 'Unknown CC',\n        // used by timeline-controller\n        captionsTextTrack4LanguageCode: '',\n        // used by timeline-controller\n        renderTextTracksNatively: true\n      };\n    }\n\n    /**\n     * @ignore\n     */\n    function mergeConfig(defaultConfig, userConfig) {\n      if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n        throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n      }\n      if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n        throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n      }\n      if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n        throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n      }\n      var defaultsCopy = deepCpy(defaultConfig);\n\n      // Backwards compatibility with deprecated config values\n      var deprecatedSettingTypes = ['manifest', 'level', 'frag'];\n      var deprecatedSettings = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout'];\n      deprecatedSettingTypes.forEach(function (type) {\n        var policyName = (type === 'level' ? 'playlist' : type) + \"LoadPolicy\";\n        var policyNotSet = userConfig[policyName] === undefined;\n        var report = [];\n        deprecatedSettings.forEach(function (setting) {\n          var deprecatedSetting = type + \"Loading\" + setting;\n          var value = userConfig[deprecatedSetting];\n          if (value !== undefined && policyNotSet) {\n            report.push(deprecatedSetting);\n            var settings = defaultsCopy[policyName].default;\n            userConfig[policyName] = {\n              default: settings\n            };\n            switch (setting) {\n              case 'TimeOut':\n                settings.maxLoadTimeMs = value;\n                settings.maxTimeToFirstByteMs = value;\n                break;\n              case 'MaxRetry':\n                settings.errorRetry.maxNumRetry = value;\n                settings.timeoutRetry.maxNumRetry = value;\n                break;\n              case 'RetryDelay':\n                settings.errorRetry.retryDelayMs = value;\n                settings.timeoutRetry.retryDelayMs = value;\n                break;\n              case 'MaxRetryTimeout':\n                settings.errorRetry.maxRetryDelayMs = value;\n                settings.timeoutRetry.maxRetryDelayMs = value;\n                break;\n            }\n          }\n        });\n        if (report.length) {\n          logger.warn(\"hls.js config: \\\"\" + report.join('\", \"') + \"\\\" setting(s) are deprecated, use \\\"\" + policyName + \"\\\": \" + JSON.stringify(userConfig[policyName]));\n        }\n      });\n      return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);\n    }\n    function deepCpy(obj) {\n      if (obj && _typeof(obj) === 'object') {\n        if (Array.isArray(obj)) {\n          return obj.map(deepCpy);\n        }\n        return Object.keys(obj).reduce(function (result, key) {\n          result[key] = deepCpy(obj[key]);\n          return result;\n        }, {});\n      }\n      return obj;\n    }\n\n    /**\n     * @ignore\n     */\n    function enableStreamingMode(config) {\n      var currentLoader = config.loader;\n      if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {\n        // If a developer has configured their own loader, respect that choice\n        logger.log('[config]: Custom loader detected, cannot enable progressive streaming');\n        config.progressive = false;\n      } else {\n        var canStreamProgressively = fetchSupported();\n        if (canStreamProgressively) {\n          config.loader = FetchLoader;\n          config.progressive = true;\n          config.enableSoftwareAES = true;\n          logger.log('[config]: Progressive streaming enabled, using FetchLoader');\n        }\n      }\n    }\n\n    /**\n     * The `Hls` class is the core of the HLS.js library used to instantiate player instances.\n     * @public\n     */\n    var Hls = /*#__PURE__*/function () {\n      /**\n       * Check if the required MediaSource Extensions are available.\n       */\n      Hls.isSupported = function isSupported$1() {\n        return isSupported();\n      };\n      /**\n       * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n       * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n       */\n      function Hls(userConfig) {\n        if (userConfig === void 0) {\n          userConfig = {};\n        }\n        /**\n         * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.\n         */\n        this.config = void 0;\n        /**\n         * The configuration object provided on player instantiation.\n         */\n        this.userConfig = void 0;\n        this.coreComponents = void 0;\n        this.networkControllers = void 0;\n        this._emitter = new EventEmitter();\n        this._autoLevelCapping = void 0;\n        this._maxHdcpLevel = null;\n        this.abrController = void 0;\n        this.bufferController = void 0;\n        this.capLevelController = void 0;\n        this.latencyController = void 0;\n        this.levelController = void 0;\n        this.streamController = void 0;\n        this.audioTrackController = void 0;\n        this.subtitleTrackController = void 0;\n        this.emeController = void 0;\n        this.cmcdController = void 0;\n        this._media = null;\n        this.url = null;\n        enableLogs(userConfig.debug || false, 'Hls instance');\n        var config = this.config = mergeConfig(Hls.DefaultConfig, userConfig);\n        this.userConfig = userConfig;\n        this._autoLevelCapping = -1;\n        if (config.progressive) {\n          enableStreamingMode(config);\n        }\n\n        // core controllers and network loaders\n        var ConfigAbrController = config.abrController,\n          ConfigBufferController = config.bufferController,\n          ConfigCapLevelController = config.capLevelController,\n          ConfigErrorController = config.errorController,\n          ConfigFpsController = config.fpsController;\n        var errorController = new ConfigErrorController(this);\n        var abrController = this.abrController = new ConfigAbrController(this);\n        var bufferController = this.bufferController = new ConfigBufferController(this);\n        var capLevelController = this.capLevelController = new ConfigCapLevelController(this);\n        var fpsController = new ConfigFpsController(this);\n        var playListLoader = new PlaylistLoader(this);\n        var id3TrackController = new ID3TrackController(this);\n        var ConfigContentSteeringController = config.contentSteeringController;\n        // ConentSteeringController is defined before LevelController to receive Multivariant Playlist events first\n        var contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;\n        var levelController = this.levelController = new LevelController(this, contentSteering);\n        // FragmentTracker must be defined before StreamController because the order of event handling is important\n        var fragmentTracker = new FragmentTracker(this);\n        var keyLoader = new KeyLoader(this.config);\n        var streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);\n\n        // Cap level controller uses streamController to flush the buffer\n        capLevelController.setStreamController(streamController);\n        // fpsController uses streamController to switch when frames are being dropped\n        fpsController.setStreamController(streamController);\n        var networkControllers = [playListLoader, levelController, streamController];\n        if (contentSteering) {\n          networkControllers.splice(1, 0, contentSteering);\n        }\n        this.networkControllers = networkControllers;\n        var coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n        this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n        var AudioStreamControllerClass = config.audioStreamController;\n        if (AudioStreamControllerClass) {\n          networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n        }\n        // subtitleTrackController must be defined before subtitleStreamController because the order of event handling is important\n        this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n        var SubtitleStreamControllerClass = config.subtitleStreamController;\n        if (SubtitleStreamControllerClass) {\n          networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n        }\n        this.createController(config.timelineController, coreComponents);\n        keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n        this.cmcdController = this.createController(config.cmcdController, coreComponents);\n        this.latencyController = this.createController(LatencyController, coreComponents);\n        this.coreComponents = coreComponents;\n\n        // Error controller handles errors before and after all other controllers\n        // This listener will be invoked after all other controllers error listeners\n        networkControllers.push(errorController);\n        var onErrorOut = errorController.onErrorOut;\n        if (typeof onErrorOut === 'function') {\n          this.on(Events.ERROR, onErrorOut, errorController);\n        }\n      }\n      var _proto = Hls.prototype;\n      _proto.createController = function createController(ControllerClass, components) {\n        if (ControllerClass) {\n          var controllerInstance = new ControllerClass(this);\n          if (components) {\n            components.push(controllerInstance);\n          }\n          return controllerInstance;\n        }\n        return null;\n      }\n\n      // Delegate the EventEmitter through the public API of Hls.js\n      ;\n\n      _proto.on = function on(event, listener, context) {\n        if (context === void 0) {\n          context = this;\n        }\n        this._emitter.on(event, listener, context);\n      };\n      _proto.once = function once(event, listener, context) {\n        if (context === void 0) {\n          context = this;\n        }\n        this._emitter.once(event, listener, context);\n      };\n      _proto.removeAllListeners = function removeAllListeners(event) {\n        this._emitter.removeAllListeners(event);\n      };\n      _proto.off = function off(event, listener, context, once) {\n        if (context === void 0) {\n          context = this;\n        }\n        this._emitter.off(event, listener, context, once);\n      };\n      _proto.listeners = function listeners(event) {\n        return this._emitter.listeners(event);\n      };\n      _proto.emit = function emit(event, name, eventObject) {\n        return this._emitter.emit(event, name, eventObject);\n      };\n      _proto.trigger = function trigger(event, eventObject) {\n        if (this.config.debug) {\n          return this.emit(event, event, eventObject);\n        } else {\n          try {\n            return this.emit(event, event, eventObject);\n          } catch (e) {\n            logger.error('An internal error happened while handling event ' + event + '. Error message: \"' + e.message + '\". Here is a stacktrace:', e);\n            this.trigger(Events.ERROR, {\n              type: ErrorTypes.OTHER_ERROR,\n              details: ErrorDetails.INTERNAL_EXCEPTION,\n              fatal: false,\n              event: event,\n              error: e\n            });\n          }\n        }\n        return false;\n      };\n      _proto.listenerCount = function listenerCount(event) {\n        return this._emitter.listenerCount(event);\n      }\n\n      /**\n       * Dispose of the instance\n       */;\n      _proto.destroy = function destroy() {\n        logger.log('destroy');\n        this.trigger(Events.DESTROYING, undefined);\n        this.detachMedia();\n        this.removeAllListeners();\n        this._autoLevelCapping = -1;\n        this.url = null;\n        this.networkControllers.forEach(function (component) {\n          return component.destroy();\n        });\n        this.networkControllers.length = 0;\n        this.coreComponents.forEach(function (component) {\n          return component.destroy();\n        });\n        this.coreComponents.length = 0;\n        // Remove any references that could be held in config options or callbacks\n        var config = this.config;\n        config.xhrSetup = config.fetchSetup = undefined;\n        // @ts-ignore\n        this.userConfig = null;\n      }\n\n      /**\n       * Attaches Hls.js to a media element\n       */;\n      _proto.attachMedia = function attachMedia(media) {\n        logger.log('attachMedia');\n        this._media = media;\n        this.trigger(Events.MEDIA_ATTACHING, {\n          media: media\n        });\n      }\n\n      /**\n       * Detach Hls.js from the media\n       */;\n      _proto.detachMedia = function detachMedia() {\n        logger.log('detachMedia');\n        this.trigger(Events.MEDIA_DETACHING, undefined);\n        this._media = null;\n      }\n\n      /**\n       * Set the source URL. Can be relative or absolute.\n       */;\n      _proto.loadSource = function loadSource(url) {\n        this.stopLoad();\n        var media = this.media;\n        var loadedSource = this.url;\n        var loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {\n          alwaysNormalize: true\n        });\n        logger.log(\"loadSource:\" + loadingSource);\n        if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {\n          this.detachMedia();\n          this.attachMedia(media);\n        }\n        // when attaching to a source URL, trigger a playlist load\n        this.trigger(Events.MANIFEST_LOADING, {\n          url: url\n        });\n      }\n\n      /**\n       * Start loading data from the stream source.\n       * Depending on default config, client starts loading automatically when a source is set.\n       *\n       * @param startPosition - Set the start position to stream from.\n       * Defaults to -1 (None: starts from earliest point)\n       */;\n      _proto.startLoad = function startLoad(startPosition) {\n        if (startPosition === void 0) {\n          startPosition = -1;\n        }\n        logger.log(\"startLoad(\" + startPosition + \")\");\n        this.networkControllers.forEach(function (controller) {\n          controller.startLoad(startPosition);\n        });\n      }\n\n      /**\n       * Stop loading of any stream data.\n       */;\n      _proto.stopLoad = function stopLoad() {\n        logger.log('stopLoad');\n        this.networkControllers.forEach(function (controller) {\n          controller.stopLoad();\n        });\n      }\n\n      /**\n       * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n       */;\n      _proto.swapAudioCodec = function swapAudioCodec() {\n        logger.log('swapAudioCodec');\n        this.streamController.swapAudioCodec();\n      }\n\n      /**\n       * When the media-element fails, this allows to detach and then re-attach it\n       * as one call (convenience method).\n       *\n       * Automatic recovery of media-errors by this process is configurable.\n       */;\n      _proto.recoverMediaError = function recoverMediaError() {\n        logger.log('recoverMediaError');\n        var media = this._media;\n        this.detachMedia();\n        if (media) {\n          this.attachMedia(media);\n        }\n      };\n      _proto.removeLevel = function removeLevel(levelIndex, urlId) {\n        if (urlId === void 0) {\n          urlId = 0;\n        }\n        this.levelController.removeLevel(levelIndex, urlId);\n      }\n\n      /**\n       * @returns an array of levels (variants) sorted by HDCP-LEVEL, BANDWIDTH, SCORE, and RESOLUTION (height)\n       */;\n      _createClass(Hls, [{\n        key: \"levels\",\n        get: function get() {\n          var levels = this.levelController.levels;\n          return levels ? levels : [];\n        }\n\n        /**\n         * Index of quality level (variant) currently played\n         */\n      }, {\n        key: \"currentLevel\",\n        get: function get() {\n          return this.streamController.currentLevel;\n        }\n\n        /**\n         * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n         */,\n        set: function set(newLevel) {\n          logger.log(\"set currentLevel:\" + newLevel);\n          this.loadLevel = newLevel;\n          this.abrController.clearTimer();\n          this.streamController.immediateLevelSwitch();\n        }\n\n        /**\n         * Index of next quality level loaded as scheduled by stream controller.\n         */\n      }, {\n        key: \"nextLevel\",\n        get: function get() {\n          return this.streamController.nextLevel;\n        }\n\n        /**\n         * Set quality level index for next loaded data.\n         * This will switch the video quality asap, without interrupting playback.\n         * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n         * @param newLevel - Pass -1 for automatic level selection\n         */,\n        set: function set(newLevel) {\n          logger.log(\"set nextLevel:\" + newLevel);\n          this.levelController.manualLevel = newLevel;\n          this.streamController.nextLevelSwitch();\n        }\n\n        /**\n         * Return the quality level of the currently or last (of none is loaded currently) segment\n         */\n      }, {\n        key: \"loadLevel\",\n        get: function get() {\n          return this.levelController.level;\n        }\n\n        /**\n         * Set quality level index for next loaded data in a conservative way.\n         * This will switch the quality without flushing, but interrupt current loading.\n         * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n         * @param newLevel - Pass -1 for automatic level selection\n         */,\n        set: function set(newLevel) {\n          logger.log(\"set loadLevel:\" + newLevel);\n          this.levelController.manualLevel = newLevel;\n        }\n\n        /**\n         * get next quality level loaded\n         */\n      }, {\n        key: \"nextLoadLevel\",\n        get: function get() {\n          return this.levelController.nextLoadLevel;\n        }\n\n        /**\n         * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n         * Same as `loadLevel` but will wait for next switch (until current loading is done).\n         */,\n        set: function set(level) {\n          this.levelController.nextLoadLevel = level;\n        }\n\n        /**\n         * Return \"first level\": like a default level, if not set,\n         * falls back to index of first level referenced in manifest\n         */\n      }, {\n        key: \"firstLevel\",\n        get: function get() {\n          return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n        }\n\n        /**\n         * Sets \"first-level\", see getter.\n         */,\n        set: function set(newLevel) {\n          logger.log(\"set firstLevel:\" + newLevel);\n          this.levelController.firstLevel = newLevel;\n        }\n\n        /**\n         * Return start level (level of first fragment that will be played back)\n         * if not overrided by user, first level appearing in manifest will be used as start level\n         * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n         * (determined from download of first segment)\n         */\n      }, {\n        key: \"startLevel\",\n        get: function get() {\n          return this.levelController.startLevel;\n        }\n\n        /**\n         * set  start level (level of first fragment that will be played back)\n         * if not overrided by user, first level appearing in manifest will be used as start level\n         * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n         * (determined from download of first segment)\n         */,\n        set: function set(newLevel) {\n          logger.log(\"set startLevel:\" + newLevel);\n          // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n          if (newLevel !== -1) {\n            newLevel = Math.max(newLevel, this.minAutoLevel);\n          }\n          this.levelController.startLevel = newLevel;\n        }\n\n        /**\n         * Whether level capping is enabled.\n         * Default value is set via `config.capLevelToPlayerSize`.\n         */\n      }, {\n        key: \"capLevelToPlayerSize\",\n        get: function get() {\n          return this.config.capLevelToPlayerSize;\n        }\n\n        /**\n         * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n         */,\n        set: function set(shouldStartCapping) {\n          var newCapLevelToPlayerSize = !!shouldStartCapping;\n          if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n            if (newCapLevelToPlayerSize) {\n              this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n            } else {\n              this.capLevelController.stopCapping();\n              this.autoLevelCapping = -1;\n              this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n            }\n\n            this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n          }\n        }\n\n        /**\n         * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n         */\n      }, {\n        key: \"autoLevelCapping\",\n        get: function get() {\n          return this._autoLevelCapping;\n        }\n\n        /**\n         * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n         */,\n        set:\n        /**\n         * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n         */\n        function set(newLevel) {\n          if (this._autoLevelCapping !== newLevel) {\n            logger.log(\"set autoLevelCapping:\" + newLevel);\n            this._autoLevelCapping = newLevel;\n          }\n        }\n      }, {\n        key: \"bandwidthEstimate\",\n        get: function get() {\n          var bwEstimator = this.abrController.bwEstimator;\n          if (!bwEstimator) {\n            return NaN;\n          }\n          return bwEstimator.getEstimate();\n        }\n\n        /**\n         * get time to first byte estimate\n         * @type {number}\n         */\n      }, {\n        key: \"ttfbEstimate\",\n        get: function get() {\n          var bwEstimator = this.abrController.bwEstimator;\n          if (!bwEstimator) {\n            return NaN;\n          }\n          return bwEstimator.getEstimateTTFB();\n        }\n      }, {\n        key: \"maxHdcpLevel\",\n        get: function get() {\n          return this._maxHdcpLevel;\n        },\n        set: function set(value) {\n          if (HdcpLevels.indexOf(value) > -1) {\n            this._maxHdcpLevel = value;\n          }\n        }\n\n        /**\n         * True when automatic level selection enabled\n         */\n      }, {\n        key: \"autoLevelEnabled\",\n        get: function get() {\n          return this.levelController.manualLevel === -1;\n        }\n\n        /**\n         * Level set manually (if any)\n         */\n      }, {\n        key: \"manualLevel\",\n        get: function get() {\n          return this.levelController.manualLevel;\n        }\n\n        /**\n         * min level selectable in auto mode according to config.minAutoBitrate\n         */\n      }, {\n        key: \"minAutoLevel\",\n        get: function get() {\n          var levels = this.levels,\n            minAutoBitrate = this.config.minAutoBitrate;\n          if (!levels) return 0;\n          var len = levels.length;\n          for (var i = 0; i < len; i++) {\n            if (levels[i].maxBitrate >= minAutoBitrate) {\n              return i;\n            }\n          }\n          return 0;\n        }\n\n        /**\n         * max level selectable in auto mode according to autoLevelCapping\n         */\n      }, {\n        key: \"maxAutoLevel\",\n        get: function get() {\n          var levels = this.levels,\n            autoLevelCapping = this.autoLevelCapping,\n            maxHdcpLevel = this.maxHdcpLevel;\n          var maxAutoLevel;\n          if (autoLevelCapping === -1 && levels && levels.length) {\n            maxAutoLevel = levels.length - 1;\n          } else {\n            maxAutoLevel = autoLevelCapping;\n          }\n          if (maxHdcpLevel) {\n            for (var i = maxAutoLevel; i--;) {\n              var hdcpLevel = levels[i].attrs['HDCP-LEVEL'];\n              if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n                return i;\n              }\n            }\n          }\n          return maxAutoLevel;\n        }\n\n        /**\n         * next automatically selected quality level\n         */\n      }, {\n        key: \"nextAutoLevel\",\n        get: function get() {\n          // ensure next auto level is between  min and max auto level\n          return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);\n        }\n\n        /**\n         * this setter is used to force next auto level.\n         * this is useful to force a switch down in auto mode:\n         * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n         * forced value is valid for one fragment. upon successful frag loading at forced level,\n         * this value will be resetted to -1 by ABR controller.\n         */,\n        set: function set(nextLevel) {\n          this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);\n        }\n\n        /**\n         * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n         */\n      }, {\n        key: \"playingDate\",\n        get: function get() {\n          return this.streamController.currentProgramDateTime;\n        }\n      }, {\n        key: \"mainForwardBufferInfo\",\n        get: function get() {\n          return this.streamController.getMainFwdBufferInfo();\n        }\n\n        /**\n         * Get the list of selectable audio tracks\n         */\n      }, {\n        key: \"audioTracks\",\n        get: function get() {\n          var audioTrackController = this.audioTrackController;\n          return audioTrackController ? audioTrackController.audioTracks : [];\n        }\n\n        /**\n         * index of the selected audio track (index in audio track lists)\n         */\n      }, {\n        key: \"audioTrack\",\n        get: function get() {\n          var audioTrackController = this.audioTrackController;\n          return audioTrackController ? audioTrackController.audioTrack : -1;\n        }\n\n        /**\n         * selects an audio track, based on its index in audio track lists\n         */,\n        set: function set(audioTrackId) {\n          var audioTrackController = this.audioTrackController;\n          if (audioTrackController) {\n            audioTrackController.audioTrack = audioTrackId;\n          }\n        }\n\n        /**\n         * get alternate subtitle tracks list from playlist\n         */\n      }, {\n        key: \"subtitleTracks\",\n        get: function get() {\n          var subtitleTrackController = this.subtitleTrackController;\n          return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n        }\n\n        /**\n         * index of the selected subtitle track (index in subtitle track lists)\n         */\n      }, {\n        key: \"subtitleTrack\",\n        get: function get() {\n          var subtitleTrackController = this.subtitleTrackController;\n          return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n        },\n        set:\n        /**\n         * select an subtitle track, based on its index in subtitle track lists\n         */\n        function set(subtitleTrackId) {\n          var subtitleTrackController = this.subtitleTrackController;\n          if (subtitleTrackController) {\n            subtitleTrackController.subtitleTrack = subtitleTrackId;\n          }\n        }\n\n        /**\n         * Whether subtitle display is enabled or not\n         */\n      }, {\n        key: \"media\",\n        get: function get() {\n          return this._media;\n        }\n      }, {\n        key: \"subtitleDisplay\",\n        get: function get() {\n          var subtitleTrackController = this.subtitleTrackController;\n          return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n        }\n\n        /**\n         * Enable/disable subtitle display rendering\n         */,\n        set: function set(value) {\n          var subtitleTrackController = this.subtitleTrackController;\n          if (subtitleTrackController) {\n            subtitleTrackController.subtitleDisplay = value;\n          }\n        }\n\n        /**\n         * get mode for Low-Latency HLS loading\n         */\n      }, {\n        key: \"lowLatencyMode\",\n        get: function get() {\n          return this.config.lowLatencyMode;\n        }\n\n        /**\n         * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n         */,\n        set: function set(mode) {\n          this.config.lowLatencyMode = mode;\n        }\n\n        /**\n         * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n         * @returns null prior to loading live Playlist\n         */\n      }, {\n        key: \"liveSyncPosition\",\n        get: function get() {\n          return this.latencyController.liveSyncPosition;\n        }\n\n        /**\n         * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n         * @returns 0 before first playlist is loaded\n         */\n      }, {\n        key: \"latency\",\n        get: function get() {\n          return this.latencyController.latency;\n        }\n\n        /**\n         * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n         * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n         * @returns 0 before first playlist is loaded\n         */\n      }, {\n        key: \"maxLatency\",\n        get: function get() {\n          return this.latencyController.maxLatency;\n        }\n\n        /**\n         * target distance from the edge as calculated by the latency controller\n         */\n      }, {\n        key: \"targetLatency\",\n        get: function get() {\n          return this.latencyController.targetLatency;\n        }\n\n        /**\n         * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n         */\n      }, {\n        key: \"drift\",\n        get: function get() {\n          return this.latencyController.drift;\n        }\n\n        /**\n         * set to true when startLoad is called before MANIFEST_PARSED event\n         */\n      }, {\n        key: \"forceStartLoad\",\n        get: function get() {\n          return this.streamController.forceStartLoad;\n        }\n      }], [{\n        key: \"version\",\n        get:\n        /**\n         * Get the video-dev/hls.js package version.\n         */\n        function get() {\n          return \"1.4.4\";\n        }\n      }, {\n        key: \"Events\",\n        get: function get() {\n          return Events;\n        }\n      }, {\n        key: \"ErrorTypes\",\n        get: function get() {\n          return ErrorTypes;\n        }\n      }, {\n        key: \"ErrorDetails\",\n        get: function get() {\n          return ErrorDetails;\n        }\n\n        /**\n         * Get the default configuration applied to new instances.\n         */\n      }, {\n        key: \"DefaultConfig\",\n        get: function get() {\n          if (!Hls.defaultConfig) {\n            return hlsDefaultConfig;\n          }\n          return Hls.defaultConfig;\n        }\n\n        /**\n         * Replace the default configuration applied to new instances.\n         */,\n        set: function set(defaultConfig) {\n          Hls.defaultConfig = defaultConfig;\n        }\n      }]);\n      return Hls;\n    }();\n    Hls.defaultConfig = void 0;\n    return Hls;\n  });\n})(false);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGxzLmpzL2Rpc3QvaGxzLmxpZ2h0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7OztBQUlBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFTQTtBQUdBO0FBT0E7OztBQzdLQTtBQUdBO0FBQ0E7QUMrQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQW1IQTs7OztBQ3RLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBYUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FDQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFEQTtBQUFBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQ3BGQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUMxR0E7O0FBYUE7QUFDQTtBQVFBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFNQTtBQUFBO0FBTEE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUM1SEE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUNIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBbUJBO0FBSUE7O0FBRUE7O0FBRUE7O0FBT0E7QUFBQTtBQUFBO0FBZEE7QUFDQTtBQUdBO0FBRUE7QUFTQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBR0E7OztBQUdBO0FBQUE7QUFPQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBR0E7QUFBQTtBQUNBO0FBQUE7QUF4REE7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBSUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQStEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVNBO0FBREE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUF6R0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBbURBOzs7QUFHQTtBQUFBO0FBVUE7QUFNQTtBQUNBO0FBQUE7QUFoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQ3ZUQTs7QUFFQTs7O0FBR0E7QUFlQTs7QUFnQ0E7QUFBQTtBQTlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUN0SkE7QUFDQTtBQUNBOztBQ0ZBO0FBS0E7QUFDQTtBQUNBO0FBR0E7O0FDUkE7O0FBSUE7Ozs7O0FBS0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQU9BO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBS0E7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUdBO0FBREE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FDcFpBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNUQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFhQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMy9CQTtBQUFBO0FBZ0JBO0FBTUE7QUFGQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWlCQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQW9GQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFJQTtBQzVDQTtBQUVBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFLQTtBQVdBO0FBRUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQU1BO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBZUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFXQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBaUJBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQW1CQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBS0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQ2p1QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQ3pJQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVNBO0FBQUE7QUFOQTtBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBT0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFRQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUlBO0FBSEE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFTQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFRQTtBQUFBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFIQTtBQUFBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQVVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUMvckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUM5REE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUFBO0FBVUE7QUFBQTtBQVJBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBS0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBREE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuRUE7QUFBQTtBQUFBO0FBb0VBO0FBQUE7QUFBQTtBQzVXQTtBQWVBO0FBQUE7QUFBQTtBQVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQWlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFNQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFsT0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQ25GQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFBQTtBQUpBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFxQkE7QUFBQTtBQXBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQXlDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUF4Q0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFEQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9kQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBTUE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FDakVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FDeENBOzs7Ozs7QUFNQTtBQUtBO0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUtBO0FBRkE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQU9BO0FBSUE7QUFIQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQVFBO0FBS0E7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEtBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBNEJBO0FBQUE7QUFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFHQTtBQUdBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUF0QkE7QUFBQTtBQUFBO0FBQUE7QUF1QkE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMWlCQTtBQWlCQTtBQUFBO0FBUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFLQTtBQU1BO0FBQUE7QUFLQTtBQUtBO0FBQUE7QUFNQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQzlUQTtBQUFBO0FBRUE7QUFXQTtBQUdBO0FBQ0E7QUFBQTtBQWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBSUE7QUFGQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBOEhBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFpQkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFoVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFFQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBOEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQWlEQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6bUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBaUJBO0FBQUE7QUFmQTtBQUVBO0FBRUE7QUFLQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFFQTs7O0FBQUE7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUFBO0FBQUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUFBO0FBQUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBSUE7QUFBQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUNyZUE7QUFBQTtBQU9BO0FBQUE7QUFKQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUdBO0FBREE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FDNVdBO0FBcUJBO0FBQUE7QUFKQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFRQTtBQUpBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQWJBO0FBQUE7QUFBQTtBQVdBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBUUE7QUFFQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBUUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUtBO0FBQ0E7QUFRQTtBQUVBO0FBS0E7QUFDQTtBQVFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUNsV0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFtQ0E7QUFBQTtBQUxBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUlBO0FBQUE7O0FDN0hBOzs7Ozs7OztBQTBCQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7OztBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FDbEtBO0FBd0JBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUNyQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQy9LQTtBQUlBO0FBQUE7QUFIQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQ1hBO0FBSUE7QUFBQTtBQUhBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFBQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQTJCQTtBQUFBO0FBdEJBO0FBTUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFFQTtBQU1BO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBTUE7QUFNQTtBQU1BO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQU1BO0FBTUE7QUFNQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUN2VUE7QUFBQTtBQWNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7O0FBQUE7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUMxTUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQ3lDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQW9DQTtBQU1BO0FBQ0E7QUFBQTtBQXZDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTs7QUFJQTtBQUFBOztBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFNQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUUE7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBREE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQU9BO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFRQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFHQTtBQU9BO0FBQUE7QUFBQTtBQUZBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBT0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBS0E7QUFBQTtBQVNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUFBO0FBQUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFPQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQUE7QUFPQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBV0E7QUFDQTtBQUFBO0FBVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FDL3NEQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUN0Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0VBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7O0FBUUE7QUFBQTs7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBT0E7QUFHQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFHQTs7Ozs7O0FBTUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FDak1BOzs7O0FBMkJBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FDbFRBO0FBSUE7QUFJQTtBQUFBO0FBQ0E7QUFBQTtBQUpBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFPQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQzVEQTtBQUFBO0FBV0E7QUFBQTtBQVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFRQTtBQUlBO0FBSUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBR0E7QUFBQTtBQUVBO0FBQUE7O0FDck1BOzs7O0FBS0E7QUFFQTtBQVFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7QUFHQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBOzs7O0FBSUE7QUFRQTtBQUFBO0FBTEE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFFQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFFQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBOztBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBRUE7QUFDQTs7QUFFQTs7Ozs7O0FBQUE7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFBQTtBQUFBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQ3JXQTs7OztBQWNBO0FBTUE7QUFBQTtBQUhBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUtBOztBQUVBO0FBQUE7O0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBSUE7QUFFQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFLQTtBQUlBO0FBRUE7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUN2SUE7QUFBQTtBQXNCQTtBQUlBO0FBdkJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFVQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUZBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQU1BO0FBS0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFNQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4dENBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUFBO0FBQUE7O0FDbkVBOzs7QUFBQTtBQUlBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUM3RUE7Ozs7QUFTQTtBQUFBO0FBRUE7QUFBQTtBQWNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQVlBOztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQVlBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQURBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQU9BO0FBQ0E7QUFHQTtBQUNBO0FBU0E7QUFDQTtBQUlBO0FBQUE7QUFHQTtBQU1BO0FBQUE7QUFHQTtBQU1BO0FBQ0E7QUFHQTtBQUdBOztBQUFBO0FBR0E7QUFDQTtBQU1BO0FBQ0E7QUFNQTtBQUNBO0FBQUE7QUFHQTtBQUtBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUNBO0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQW1DQTtBQUNBO0FBdUJBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBUUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQU1BO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTs7QUFFQTtBQUFBO0FBTUE7O0FBQUE7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUFBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1DQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBR0E7O0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBYUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7OztBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUdBOztBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBTUE7QUFDQTtBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBMW1DQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FDWEE7QUFPQTtBQUtBO0FBRkE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQVdBO0FBR0E7QUFEQTtBQUFBO0FBRUE7QUFDQTtBQ0NBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQWVBO0FBSUE7QUFoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFNQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBTUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFLQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQVFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBYUE7QUFWQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFXQTtBQVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUNsbkNBO0FBaUJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDelFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBaUJBO0FBTUE7QUFwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBTUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBU0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUdBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUlBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBYUE7QUFaQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBZUE7QUFkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN2dCQTtBQUNBOztBQUVBOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFFQTtBQUlBOzs7QUFHQTs7Ozs7OztBQU9BO0FBQ0E7OztBQUlBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7QUFHQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7Ozs7QUFLQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUVBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFLQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2VUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVRBO0FBQUE7QUFBQTtBQVVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFPQTs7QUMxTEE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWdCQTtBQUtBO0FBQUE7QUFsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFhQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFRQTtBQUNBO0FBT0E7QUFPQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUM1WUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQWFBO0FBQUE7QUFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFBQTtBQUFBO0FBT0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBOztBQUVBOzs7OztBQUFBO0FBQUE7QUFVQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFBQTtBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUFBO0FBQUE7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBS0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUN4VUE7QUFBQTtBQUVBO0FBbUJBO0FBSUE7QUFDQTtBQU1BO0FBMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBSUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUFBO0FBQUE7QUFPQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBS0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBS0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFRQTtBQUVBO0FBWUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUlBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUNwNENBOzs7OztBQUFBO0FBWUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTkE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUN2Q0E7Ozs7Ozs7O0FBUUE7QUFXQTtBQUtBO0FBREE7QUFBQTtBQUFBO0FBWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUN2RkE7QUEyQkE7QUFBQTtBQVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUtBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBOEJBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQUE7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUEvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBeUxBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUNoakJBO0FBZ0JBO0FBQUE7QUFQQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQ3BEQTtBQUNBO0FBQUE7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFLQTs7QUFHQTs7QUFHQTs7QUFHQTs7QUFHQTs7QUFHQTs7QUFPQTtBQUFBO0FBQUE7QUFoQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUVBO0FBQ0E7QUE0dEJBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBeHZCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUlBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFBQTtBQUFBO0FBTUE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTs7QUFBQTtBQUlBO0FBQUE7QUFEQTtBQUFBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUN6OEJBO0FBdUJBO0FBQUE7QUFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7O0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBS0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBd0JBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQXJFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FDeE9BO0FBY0E7O0FBR0E7QUFBQTtBQVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQzVIQTtBQUFBO0FBZ0JBO0FBQUE7QUFiQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FDOVRBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQWNBO0FBQUE7QUFYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFRQTtBQUZBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBSEE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7O0FDcExBOzs7O0FBNkJBOzs7O0FBZ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWdCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBSUE7QUFLQTtBQUdBO0FBRUE7QUFNQTtBQUdBO0FBRUE7QUFLQTtBQUdBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6bUJBOzs7O0FBQUE7QUEwQ0E7OztBQUFBO0FBSUE7QUFDQTtBQWdDQTs7OztBQUlBO0FBQUE7QUFBQTtBQUFBO0FBNUVBOzs7QUFBQTtBQUtBOzs7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvREE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBU0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUtBO0FBREE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQU1BO0FBREE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQU9BO0FBRkE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7Ozs7OztBQUFBO0FBQUE7QUFPQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBOztBQUVBOzs7OztBQUFBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFFQTs7Ozs7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBS0E7QUFDQTs7QUFFQTs7OztBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBT0E7QUFDQTs7QUFFQTs7Ozs7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7Ozs7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUF1QkE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQTNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFhQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFJQTs7QUFFQTs7Ozs7O0FBQUE7QUFBQTtBQVFBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUdBOztBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQU1BOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQWJBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFnQkE7QUFDQTtBQUdBOztBQUVBOztBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFJQTtBQUNBOztBQUVBOzs7O0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTs7QUFFQTs7OztBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7O0FBRUE7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQTV4QkE7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQVVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQXpFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanM/MDFiNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcG9seWZpbGxzL251bWJlci50cz83MmNkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9ldmVudHMudHM/MzE1MiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZXJyb3JzLnRzP2I2YjEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL2xvZ2dlci50cz85ZGQzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy9hdHRyLWxpc3QudHM/MzZmOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvbG9hZGVyL2RhdGUtcmFuZ2UudHM/NDE5ZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHM/ODQ2YyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzP2ZmYjMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2xvYWRlci9sZXZlbC1kZXRhaWxzLnRzP2NiZGQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2VtcHR5LmpzPzIwMzQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL3R5cGVkLWFycmF5LnRzP2RmZTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L2lkMy50cz9iMTg0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy9oZXgudHM/OTJjNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvbXA0LXRvb2xzLnRzPzEzMTkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2xvYWRlci9sZXZlbC1rZXkudHM/ODMyZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyLnRzPzBhZjciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL2NvZGVjcy50cz9mZmMxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9sb2FkZXIvbTN1OC1wYXJzZXIudHM/NWIzNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdHlwZXMvbG9hZGVyLnRzPzNhZWEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIudHM/Njg1OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvdGV4dHRyYWNrLXV0aWxzLnRzP2M4YTMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3R5cGVzL2RlbXV4ZXIudHM/ODAwYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlci50cz85ZTI0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2xhdGVuY3ktY29udHJvbGxlci50cz9jYWU0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy90eXBlcy9sZXZlbC50cz80Nzc1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci50cz9jNGRhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy9lcnJvci1oZWxwZXIudHM/ZTY0NSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvYmluYXJ5LXNlYXJjaC50cz9lYmJhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMudHM/YWM2OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9lcnJvci1jb250cm9sbGVyLnRzP2RiNzQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyLnRzPzQ3ZGQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlci50cz80MThmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIudHM/MDcwZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci50cz81NGM0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9sb2FkZXIva2V5LWxvYWRlci50cz80NjVkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy90YXNrLWxvb3AudHM/Nzg0MiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50cz80NjU5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy90eXBlcy90cmFuc211eGVyLnRzPzdhZDAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy50cz9kYTUyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jcnlwdC9hZXMtY3J5cHRvLnRzPzQwZDIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NyeXB0L2Zhc3QtYWVzLWtleS50cz8zMWE1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jcnlwdC9hZXMtZGVjcnlwdG9yLnRzP2QxYzAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NyeXB0L2RlY3J5cHRlci50cz9kMTE4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy90aW1lLXJhbmdlcy50cz85MTMxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIudHM/N2Q3OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaXMtc3VwcG9ydGVkLnRzP2I5OTkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L2R1bW15LWRlbXV4ZWQtdHJhY2sudHM/YjA1MCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvYmFzZS1hdWRpby1kZW11eGVyLnRzPzA2MTYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L2FkdHMudHM/OTFmYiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvYWFjZGVtdXhlci50cz8yNTZlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9tcDRkZW11eGVyLnRzPzRlMmQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L21wZWdhdWRpby50cz9lNDNjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9leHAtZ29sb21iLnRzP2RmMmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L3NhbXBsZS1hZXMudHM/ZTBiOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvdHNkZW11eGVyLnRzP2RkM2YiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L21wM2RlbXV4ZXIudHM/MWJmMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcmVtdXgvYWFjLWhlbHBlci50cz83ZjI3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZW11eC9tcDQtZ2VuZXJhdG9yLnRzPzJlNjkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uLnRzP2M2MjciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3JlbXV4L21wNC1yZW11eGVyLnRzPzIzZTgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3JlbXV4L3Bhc3N0aHJvdWdoLXJlbXV4ZXIudHM/MzE0MiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvdHJhbnNtdXhlci50cz8yMTljIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzPzRiYWMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L3RyYW5zbXV4ZXItd29ya2VyLnRzPzdkZjIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L2luamVjdC13b3JrZXIudHM/Yjk2MiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvdHJhbnNtdXhlci1pbnRlcmZhY2UudHM/NzBiNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9nYXAtY29udHJvbGxlci50cz84MGVhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyLnRzPzE2NmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL2V3bWEudHM/ZmJjOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLnRzPzZhMGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIudHM/MjJkOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9idWZmZXItb3BlcmF0aW9uLXF1ZXVlLnRzP2EzOTAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXIudHM/MjA1YSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlci50cz81YzczIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyLnRzP2U0MGMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL3hoci1sb2FkZXIudHM/MjM5NCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvY2h1bmstY2FjaGUudHM/MWNjOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvZmV0Y2gtbG9hZGVyLnRzPzhjZjIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbmZpZy50cz9lYTc2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9obHMudHM/MjBkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE4MDhcblxuKGZ1bmN0aW9uIChyb290KSB7XG4gIHZhciBVUkxfUkVHRVggPVxuICAgIC9eKD89KCg/OlthLXpBLVowLTkrXFwtLl0rOik/KSlcXDEoPz0oKD86XFwvXFwvW15cXC8/I10qKT8pKVxcMig/PSgoPzooPzpbXj8jXFwvXSpcXC8pKlteOz8jXFwvXSopPykpXFwzKCg/OjtbXj8jXSopPykoXFw/W14jXSopPygjW15dKik/JC87XG4gIHZhciBGSVJTVF9TRUdNRU5UX1JFR0VYID0gL14oPz0oW15cXC8/I10qKSlcXDEoW15dKikkLztcbiAgdmFyIFNMQVNIX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC4oPz1cXC8pL2c7XG4gIHZhciBTTEFTSF9ET1RfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLlxcLlxcLyg/IVxcLlxcLlxcLylbXlxcL10qKD89XFwvKS9nO1xuXG4gIHZhciBVUkxUb29sa2l0ID0ge1xuICAgIC8vIElmIG9wdHMuYWx3YXlzTm9ybWFsaXplIGlzIHRydWUgdGhlbiB0aGUgcGF0aCB3aWxsIGFsd2F5cyBiZSBub3JtYWxpemVkIGV2ZW4gd2hlbiBpdCBzdGFydHMgd2l0aCAvIG9yIC8vXG4gICAgLy8gRS5nXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IGZhbHNlIChkZWZhdWx0LCBzcGVjIGNvbXBsaWFudClcbiAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9mLy4uL2dcbiAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gdHJ1ZSAobm90IHNwZWMgY29tcGxpYW50KVxuICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2dcbiAgICBidWlsZEFic29sdXRlVVJMOiBmdW5jdGlvbiAoYmFzZVVSTCwgcmVsYXRpdmVVUkwsIG9wdHMpIHtcbiAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgLy8gcmVtb3ZlIGFueSByZW1haW5pbmcgc3BhY2UgYW5kIENSTEZcbiAgICAgIGJhc2VVUkwgPSBiYXNlVVJMLnRyaW0oKTtcbiAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xuICAgICAgaWYgKCFyZWxhdGl2ZVVSTCkge1xuICAgICAgICAvLyAyYSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBpcyBlbnRpcmVseSBlbXB0eSwgaXQgaW5oZXJpdHMgdGhlXG4gICAgICAgIC8vIGVudGlyZSBiYXNlIFVSTCAoaS5lLiwgaXMgc2V0IGVxdWFsIHRvIHRoZSBiYXNlIFVSTClcbiAgICAgICAgLy8gYW5kIHdlIGFyZSBkb25lLlxuICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG4gICAgICAgIGlmICghYmFzZVBhcnRzRm9yTm9ybWFsaXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgoXG4gICAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGhcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYmFzZVBhcnRzRm9yTm9ybWFsaXNlKTtcbiAgICAgIH1cbiAgICAgIHZhciByZWxhdGl2ZVBhcnRzID0gVVJMVG9vbGtpdC5wYXJzZVVSTChyZWxhdGl2ZVVSTCk7XG4gICAgICBpZiAoIXJlbGF0aXZlUGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgcmVsYXRpdmUgVVJMLicpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbGF0aXZlUGFydHMuc2NoZW1lKSB7XG4gICAgICAgIC8vIDJiKSBJZiB0aGUgZW1iZWRkZWQgVVJMIHN0YXJ0cyB3aXRoIGEgc2NoZW1lIG5hbWUsIGl0IGlzXG4gICAgICAgIC8vIGludGVycHJldGVkIGFzIGFuIGFic29sdXRlIFVSTCBhbmQgd2UgYXJlIGRvbmUuXG4gICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcbiAgICAgICAgICByZXR1cm4gcmVsYXRpdmVVUkw7XG4gICAgICAgIH1cbiAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aCk7XG4gICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKHJlbGF0aXZlUGFydHMpO1xuICAgICAgfVxuICAgICAgdmFyIGJhc2VQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG4gICAgICBpZiAoIWJhc2VQYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcbiAgICAgIH1cbiAgICAgIGlmICghYmFzZVBhcnRzLm5ldExvYyAmJiBiYXNlUGFydHMucGF0aCAmJiBiYXNlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICAgIC8vIElmIG5ldExvYyBtaXNzaW5nIGFuZCBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCAnLycsIGFzc3VtZSBldmVydGhpbmcgYmVmb3JlIHRoZSBmaXJzdCAnLycgaXMgdGhlIG5ldExvY1xuICAgICAgICAvLyBUaGlzIGNhdXNlcyAnZXhhbXBsZS5jb20vYScgdG8gYmUgaGFuZGxlZCBhcyAnLy9leGFtcGxlLmNvbS9hJyBpbnN0ZWFkIG9mICcvZXhhbXBsZS5jb20vYSdcbiAgICAgICAgdmFyIHBhdGhQYXJ0cyA9IEZJUlNUX1NFR01FTlRfUkVHRVguZXhlYyhiYXNlUGFydHMucGF0aCk7XG4gICAgICAgIGJhc2VQYXJ0cy5uZXRMb2MgPSBwYXRoUGFydHNbMV07XG4gICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gcGF0aFBhcnRzWzJdO1xuICAgICAgfVxuICAgICAgaWYgKGJhc2VQYXJ0cy5uZXRMb2MgJiYgIWJhc2VQYXJ0cy5wYXRoKSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gJy8nO1xuICAgICAgfVxuICAgICAgdmFyIGJ1aWx0UGFydHMgPSB7XG4gICAgICAgIC8vIDJjKSBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIHNjaGVtZSBvZlxuICAgICAgICAvLyB0aGUgYmFzZSBVUkwuXG4gICAgICAgIHNjaGVtZTogYmFzZVBhcnRzLnNjaGVtZSxcbiAgICAgICAgbmV0TG9jOiByZWxhdGl2ZVBhcnRzLm5ldExvYyxcbiAgICAgICAgcGF0aDogbnVsbCxcbiAgICAgICAgcGFyYW1zOiByZWxhdGl2ZVBhcnRzLnBhcmFtcyxcbiAgICAgICAgcXVlcnk6IHJlbGF0aXZlUGFydHMucXVlcnksXG4gICAgICAgIGZyYWdtZW50OiByZWxhdGl2ZVBhcnRzLmZyYWdtZW50LFxuICAgICAgfTtcbiAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5uZXRMb2MpIHtcbiAgICAgICAgLy8gMykgSWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxuZXRfbG9jPiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgLy8gU3RlcCA3LiAgT3RoZXJ3aXNlLCB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSA8bmV0X2xvYz5cbiAgICAgICAgLy8gKGlmIGFueSkgb2YgdGhlIGJhc2UgVVJMLlxuICAgICAgICBidWlsdFBhcnRzLm5ldExvYyA9IGJhc2VQYXJ0cy5uZXRMb2M7XG4gICAgICAgIC8vIDQpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBwcmVjZWRlZCBieSBhIHNsYXNoIFwiL1wiLCB0aGVcbiAgICAgICAgLy8gcGF0aCBpcyBub3QgcmVsYXRpdmUgYW5kIHdlIHNraXAgdG8gU3RlcCA3LlxuICAgICAgICBpZiAocmVsYXRpdmVQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucGF0aCkge1xuICAgICAgICAgICAgLy8gNSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIGVtcHR5IChhbmQgbm90IHByZWNlZGVkIGJ5IGFcbiAgICAgICAgICAgIC8vIHNsYXNoKSwgdGhlbiB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSBiYXNlIFVSTCBwYXRoXG4gICAgICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBiYXNlUGFydHMucGF0aDtcbiAgICAgICAgICAgIC8vIDVhKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHBhcmFtcz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxwYXJhbXM+IG9mIHRoZSBiYXNlXG4gICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kXG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucGFyYW1zKSB7XG4gICAgICAgICAgICAgIGJ1aWx0UGFydHMucGFyYW1zID0gYmFzZVBhcnRzLnBhcmFtcztcbiAgICAgICAgICAgICAgLy8gNWIpIGlmIHRoZSBlbWJlZGRlZCBVUkwncyA8cXVlcnk+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxxdWVyeT4gb2YgdGhlIGJhc2VcbiAgICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZCB3ZSBza2lwIHRvIHN0ZXAgNy5cbiAgICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5xdWVyeSA9IGJhc2VQYXJ0cy5xdWVyeTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyA2KSBUaGUgbGFzdCBzZWdtZW50IG9mIHRoZSBiYXNlIFVSTCdzIHBhdGggKGFueXRoaW5nXG4gICAgICAgICAgICAvLyBmb2xsb3dpbmcgdGhlIHJpZ2h0bW9zdCBzbGFzaCBcIi9cIiwgb3IgdGhlIGVudGlyZSBwYXRoIGlmIG5vXG4gICAgICAgICAgICAvLyBzbGFzaCBpcyBwcmVzZW50KSBpcyByZW1vdmVkIGFuZCB0aGUgZW1iZWRkZWQgVVJMJ3MgcGF0aCBpc1xuICAgICAgICAgICAgLy8gYXBwZW5kZWQgaW4gaXRzIHBsYWNlLlxuICAgICAgICAgICAgdmFyIGJhc2VVUkxQYXRoID0gYmFzZVBhcnRzLnBhdGg7XG4gICAgICAgICAgICB2YXIgbmV3UGF0aCA9XG4gICAgICAgICAgICAgIGJhc2VVUkxQYXRoLnN1YnN0cmluZygwLCBiYXNlVVJMUGF0aC5sYXN0SW5kZXhPZignLycpICsgMSkgK1xuICAgICAgICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGg7XG4gICAgICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgobmV3UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYnVpbHRQYXJ0cy5wYXRoID09PSBudWxsKSB7XG4gICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IG9wdHMuYWx3YXlzTm9ybWFsaXplXG4gICAgICAgICAgPyBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKVxuICAgICAgICAgIDogcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYnVpbHRQYXJ0cyk7XG4gICAgfSxcbiAgICBwYXJzZVVSTDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgdmFyIHBhcnRzID0gVVJMX1JFR0VYLmV4ZWModXJsKTtcbiAgICAgIGlmICghcGFydHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHBhcnRzWzFdIHx8ICcnLFxuICAgICAgICBuZXRMb2M6IHBhcnRzWzJdIHx8ICcnLFxuICAgICAgICBwYXRoOiBwYXJ0c1szXSB8fCAnJyxcbiAgICAgICAgcGFyYW1zOiBwYXJ0c1s0XSB8fCAnJyxcbiAgICAgICAgcXVlcnk6IHBhcnRzWzVdIHx8ICcnLFxuICAgICAgICBmcmFnbWVudDogcGFydHNbNl0gfHwgJycsXG4gICAgICB9O1xuICAgIH0sXG4gICAgbm9ybWFsaXplUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgb3BlcmF0aW9ucyBhcmVcbiAgICAgIC8vIHRoZW4gYXBwbGllZCwgaW4gb3JkZXIsIHRvIHRoZSBuZXcgcGF0aDpcbiAgICAgIC8vIDZhKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCIuL1wiLCB3aGVyZSBcIi5cIiBpcyBhIGNvbXBsZXRlIHBhdGhcbiAgICAgIC8vIHNlZ21lbnQsIGFyZSByZW1vdmVkLlxuICAgICAgLy8gNmIpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIi5cIiBhcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCxcbiAgICAgIC8vIHRoYXQgXCIuXCIgaXMgcmVtb3ZlZC5cbiAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykucmVwbGFjZShTTEFTSF9ET1RfUkVHRVgsICcnKTtcbiAgICAgIC8vIDZjKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCI8c2VnbWVudD4vLi4vXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgYXJlIHJlbW92ZWQuXG4gICAgICAvLyBSZW1vdmFsIG9mIHRoZXNlIHBhdGggc2VnbWVudHMgaXMgcGVyZm9ybWVkIGl0ZXJhdGl2ZWx5LFxuICAgICAgLy8gcmVtb3ZpbmcgdGhlIGxlZnRtb3N0IG1hdGNoaW5nIHBhdHRlcm4gb24gZWFjaCBpdGVyYXRpb24sXG4gICAgICAvLyB1bnRpbCBubyBtYXRjaGluZyBwYXR0ZXJuIHJlbWFpbnMuXG4gICAgICAvLyA2ZCkgSWYgdGhlIHBhdGggZW5kcyB3aXRoIFwiPHNlZ21lbnQ+Ly4uXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgdGhhdFxuICAgICAgLy8gXCI8c2VnbWVudD4vLi5cIiBpcyByZW1vdmVkLlxuICAgICAgd2hpbGUgKFxuICAgICAgICBwYXRoLmxlbmd0aCAhPT0gKHBhdGggPSBwYXRoLnJlcGxhY2UoU0xBU0hfRE9UX0RPVF9SRUdFWCwgJycpKS5sZW5ndGhcbiAgICAgICkge31cbiAgICAgIHJldHVybiBwYXRoLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG4gICAgfSxcbiAgICBidWlsZFVSTEZyb21QYXJ0czogZnVuY3Rpb24gKHBhcnRzKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwYXJ0cy5zY2hlbWUgK1xuICAgICAgICBwYXJ0cy5uZXRMb2MgK1xuICAgICAgICBwYXJ0cy5wYXRoICtcbiAgICAgICAgcGFydHMucGFyYW1zICtcbiAgICAgICAgcGFydHMucXVlcnkgK1xuICAgICAgICBwYXJ0cy5mcmFnbWVudFxuICAgICAgKTtcbiAgICB9LFxuICB9O1xuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBVUkxUb29sa2l0O1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gVVJMVG9vbGtpdDtcbiAgICB9KTtcbiAgZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSBleHBvcnRzWydVUkxUb29sa2l0J10gPSBVUkxUb29sa2l0O1xuICBlbHNlIHJvb3RbJ1VSTFRvb2xraXQnXSA9IFVSTFRvb2xraXQ7XG59KSh0aGlzKTtcbiIsImV4cG9ydCBjb25zdCBpc0Zpbml0ZU51bWJlciA9XG4gIE51bWJlci5pc0Zpbml0ZSB8fFxuICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG4gIH07XG5cbmV4cG9ydCBjb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcbiIsImltcG9ydCB7XG4gIE1hbmlmZXN0TG9hZGVkRGF0YSxcbiAgTWFuaWZlc3RMb2FkaW5nRGF0YSxcbiAgTWVkaWFBdHRhY2hlZERhdGEsXG4gIE1lZGlhQXR0YWNoaW5nRGF0YSxcbiAgTGV2ZWxMb2FkaW5nRGF0YSxcbiAgTGV2ZWxMb2FkZWREYXRhLFxuICBNYW5pZmVzdFBhcnNlZERhdGEsXG4gIExldmVsVXBkYXRlZERhdGEsXG4gIExldmVsc1VwZGF0ZWREYXRhLFxuICBGcmFnUGFyc2luZ1VzZXJkYXRhRGF0YSxcbiAgRnJhZ0RlY3J5cHRlZERhdGEsXG4gIEZyYWdMb2FkZWREYXRhLFxuICBJbml0UFRTRm91bmREYXRhLFxuICBDdWVzUGFyc2VkRGF0YSxcbiAgU3VidGl0bGVGcmFnUHJvY2Vzc2VkRGF0YSxcbiAgTm9uTmF0aXZlVGV4dFRyYWNrc0RhdGEsXG4gIEZyYWdMb2FkaW5nRGF0YSxcbiAgQXVkaW9UcmFja0xvYWRlZERhdGEsXG4gIFN1YnRpdGxlVHJhY2tMb2FkZWREYXRhLFxuICBFcnJvckRhdGEsXG4gIEF1ZGlvVHJhY2tTd2l0Y2hpbmdEYXRhLFxuICBBdWRpb1RyYWNrU3dpdGNoZWREYXRhLFxuICBLZXlMb2FkZWREYXRhLFxuICBLZXlMb2FkaW5nRGF0YSxcbiAgU3VidGl0bGVUcmFja1N3aXRjaERhdGEsXG4gIFN1YnRpdGxlVHJhY2tzVXBkYXRlZERhdGEsXG4gIExldmVsU3dpdGNoZWREYXRhLFxuICBGcmFnQ2hhbmdlZERhdGEsXG4gIEJ1ZmZlckFwcGVuZGluZ0RhdGEsXG4gIEJ1ZmZlckNvZGVjc0RhdGEsXG4gIEZyYWdQYXJzaW5nTWV0YWRhdGFEYXRhLFxuICBGcmFnUGFyc2luZ0luaXRTZWdtZW50RGF0YSxcbiAgRnJhZ0J1ZmZlcmVkRGF0YSxcbiAgQnVmZmVyRmx1c2hpbmdEYXRhLFxuICBCdWZmZXJFT1NEYXRhLFxuICBMZXZlbFN3aXRjaGluZ0RhdGEsXG4gIEZQU0Ryb3BMZXZlbENhcHBpbmdEYXRhLFxuICBGUFNEcm9wRGF0YSxcbiAgQnVmZmVyQ3JlYXRlZERhdGEsXG4gIEJ1ZmZlckFwcGVuZGVkRGF0YSxcbiAgTGV2ZWxQVFNVcGRhdGVkRGF0YSxcbiAgRnJhZ1BhcnNlZERhdGEsXG4gIEF1ZGlvVHJhY2tzVXBkYXRlZERhdGEsXG4gIEZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZERhdGEsXG4gIEJhY2tCdWZmZXJEYXRhLFxuICBMaXZlQmFja0J1ZmZlckRhdGEsXG4gIFRyYWNrTG9hZGluZ0RhdGEsXG4gIEJ1ZmZlckZsdXNoZWREYXRhLFxufSBmcm9tICcuL3R5cGVzL2V2ZW50cyc7XG5cbmV4cG9ydCBlbnVtIEV2ZW50cyB7XG4gIC8vIEZpcmVkIGJlZm9yZSBNZWRpYVNvdXJjZSBpcyBhdHRhY2hpbmcgdG8gbWVkaWEgZWxlbWVudFxuICBNRURJQV9BVFRBQ0hJTkcgPSAnaGxzTWVkaWFBdHRhY2hpbmcnLFxuICAvLyBGaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50XG4gIE1FRElBX0FUVEFDSEVEID0gJ2hsc01lZGlhQXR0YWNoZWQnLFxuICAvLyBGaXJlZCBiZWZvcmUgZGV0YWNoaW5nIE1lZGlhU291cmNlIGZyb20gbWVkaWEgZWxlbWVudFxuICBNRURJQV9ERVRBQ0hJTkcgPSAnaGxzTWVkaWFEZXRhY2hpbmcnLFxuICAvLyBGaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gbWVkaWEgZWxlbWVudFxuICBNRURJQV9ERVRBQ0hFRCA9ICdobHNNZWRpYURldGFjaGVkJyxcbiAgLy8gRmlyZWQgd2hlbiB0aGUgYnVmZmVyIGlzIGdvaW5nIHRvIGJlIHJlc2V0XG4gIEJVRkZFUl9SRVNFVCA9ICdobHNCdWZmZXJSZXNldCcsXG4gIC8vIEZpcmVkIHdoZW4gd2Uga25vdyBhYm91dCB0aGUgY29kZWNzIHRoYXQgd2UgbmVlZCBidWZmZXJzIGZvciB0byBwdXNoIGludG8gLSBkYXRhOiB7dHJhY2tzIDogeyBjb250YWluZXIsIGNvZGVjLCBsZXZlbENvZGVjLCBpbml0U2VnbWVudCwgbWV0YWRhdGEgfX1cbiAgQlVGRkVSX0NPREVDUyA9ICdobHNCdWZmZXJDb2RlY3MnLFxuICAvLyBmaXJlZCB3aGVuIHNvdXJjZWJ1ZmZlcnMgaGF2ZSBiZWVuIGNyZWF0ZWQgLSBkYXRhOiB7IHRyYWNrcyA6IHRyYWNrcyB9XG4gIEJVRkZFUl9DUkVBVEVEID0gJ2hsc0J1ZmZlckNyZWF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGFwcGVuZCBhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGE6IHsgc2VnbWVudDogc2VnbWVudCBvYmplY3QgfVxuICBCVUZGRVJfQVBQRU5ESU5HID0gJ2hsc0J1ZmZlckFwcGVuZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYXJlIGRvbmUgd2l0aCBhcHBlbmRpbmcgYSBtZWRpYSBzZWdtZW50IHRvIHRoZSBidWZmZXIgLSBkYXRhIDogeyBwYXJlbnQgOiBzZWdtZW50IHBhcmVudCB0aGF0IHRyaWdnZXJlZCBCVUZGRVJfQVBQRU5ESU5HLCBwZW5kaW5nIDogbmIgb2Ygc2VnbWVudHMgd2FpdGluZyBmb3IgYXBwZW5kaW5nIGZvciB0aGlzIHNlZ21lbnQgcGFyZW50fVxuICBCVUZGRVJfQVBQRU5ERUQgPSAnaGxzQnVmZmVyQXBwZW5kZWQnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBzdHJlYW0gaXMgZmluaXNoZWQgYW5kIHdlIHdhbnQgdG8gbm90aWZ5IHRoZSBtZWRpYSBidWZmZXIgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIG1vcmUgZGF0YSAtIGRhdGE6IHsgfVxuICBCVUZGRVJfRU9TID0gJ2hsc0J1ZmZlckVvcycsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGJ1ZmZlciBzaG91bGQgYmUgZmx1c2hlZCAtIGRhdGEgeyBzdGFydE9mZnNldCwgZW5kT2Zmc2V0IH1cbiAgQlVGRkVSX0ZMVVNISU5HID0gJ2hsc0J1ZmZlckZsdXNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgYnVmZmVyIGhhcyBiZWVuIGZsdXNoZWQgLSBkYXRhOiB7IH1cbiAgQlVGRkVSX0ZMVVNIRUQgPSAnaGxzQnVmZmVyRmx1c2hlZCcsXG4gIC8vIGZpcmVkIHRvIHNpZ25hbCB0aGF0IGEgbWFuaWZlc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IG1hbmlmZXN0VVJMfVxuICBNQU5JRkVTVF9MT0FESU5HID0gJ2hsc01hbmlmZXN0TG9hZGluZycsXG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGF1ZGlvVHJhY2tzIDogWyBhdmFpbGFibGUgYXVkaW8gdHJhY2tzIF0sIHVybCA6IG1hbmlmZXN0VVJMLCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgTUFOSUZFU1RfTE9BREVEID0gJ2hsc01hbmlmZXN0TG9hZGVkJyxcbiAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gcGFyc2VkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSwgZmlyc3RMZXZlbCA6IGluZGV4IG9mIGZpcnN0IHF1YWxpdHkgbGV2ZWwgYXBwZWFyaW5nIGluIE1hbmlmZXN0fVxuICBNQU5JRkVTVF9QQVJTRUQgPSAnaGxzTWFuaWZlc3RQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxuICBMRVZFTF9TV0lUQ0hJTkcgPSAnaGxzTGV2ZWxTd2l0Y2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIGVmZmVjdGl2ZSAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxuICBMRVZFTF9TV0lUQ0hFRCA9ICdobHNMZXZlbFN3aXRjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBsZXZlbCBVUkwsIGxldmVsIDogaWQgb2YgbGV2ZWwgYmVpbmcgbG9hZGVkfVxuICBMRVZFTF9MT0FESU5HID0gJ2hsc0xldmVsTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiBsb2FkZWQgbGV2ZWwsIHN0YXRzIDogTG9hZGVyU3RhdHMgfVxuICBMRVZFTF9MT0FERUQgPSAnaGxzTGV2ZWxMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBkZXRhaWxzIGhhdmUgYmVlbiB1cGRhdGVkIGJhc2VkIG9uIHByZXZpb3VzIGRldGFpbHMsIGFmdGVyIGl0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCB9XG4gIExFVkVMX1VQREFURUQgPSAnaGxzTGV2ZWxVcGRhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsJ3MgUFRTIGluZm9ybWF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQgYWZ0ZXIgcGFyc2luZyBhIGZyYWdtZW50IC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsLCBkcmlmdDogUFRTIGRyaWZ0IG9ic2VydmVkIHdoZW4gcGFyc2luZyBsYXN0IGZyYWdtZW50IH1cbiAgTEVWRUxfUFRTX1VQREFURUQgPSAnaGxzTGV2ZWxQdHNVcGRhdGVkJyxcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgbGV2ZWxzIGhhdmUgY2hhbmdlZCBhZnRlciByZW1vdmluZyBhIGxldmVsIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSB9XG4gIExFVkVMU19VUERBVEVEID0gJ2hsc0xldmVsc1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBhdWRpbyB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBhdWRpb1RyYWNrcyA6IGF1ZGlvVHJhY2tzIH1cbiAgQVVESU9fVFJBQ0tTX1VQREFURUQgPSAnaGxzQXVkaW9UcmFja3NVcGRhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2hpbmcgaXMgcmVxdWVzdGVkIC0gZGF0YTogeyBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cbiAgQVVESU9fVFJBQ0tfU1dJVENISU5HID0gJ2hsc0F1ZGlvVHJhY2tTd2l0Y2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaCBhY3R1YWxseSBvY2N1cnMgLSBkYXRhOiB7IGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICBBVURJT19UUkFDS19TV0lUQ0hFRCA9ICdobHNBdWRpb1RyYWNrU3dpdGNoZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBhdWRpbyB0cmFjayBVUkwsIGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICBBVURJT19UUkFDS19MT0FESU5HID0gJ2hsc0F1ZGlvVHJhY2tMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBhdWRpbyB0cmFjayBpZCwgc3RhdHMgOiBMb2FkZXJTdGF0cyB9XG4gIEFVRElPX1RSQUNLX0xPQURFRCA9ICdobHNBdWRpb1RyYWNrTG9hZGVkJyxcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgc3VidGl0bGUgdHJhY2sgbGlzdHMgaGFzIGJlZW4gdXBkYXRlZCAtIGRhdGE6IHsgc3VidGl0bGVUcmFja3MgOiBzdWJ0aXRsZVRyYWNrcyB9XG4gIFNVQlRJVExFX1RSQUNLU19VUERBVEVEID0gJ2hsc1N1YnRpdGxlVHJhY2tzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IHN1YnRpdGxlIHRyYWNrcyB3ZXJlIGNsZWFyZWQgYXMgYSByZXN1bHQgb2Ygc3RvcHBpbmcgdGhlIG1lZGlhXG4gIFNVQlRJVExFX1RSQUNLU19DTEVBUkVEID0gJ2hsc1N1YnRpdGxlVHJhY2tzQ2xlYXJlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gc3VidGl0bGUgdHJhY2sgc3dpdGNoIG9jY3VycyAtIGRhdGE6IHsgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCB9XG4gIFNVQlRJVExFX1RSQUNLX1NXSVRDSCA9ICdobHNTdWJ0aXRsZVRyYWNrU3dpdGNoJyxcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBzdWJ0aXRsZSB0cmFjayBVUkwsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQgfVxuICBTVUJUSVRMRV9UUkFDS19MT0FESU5HID0gJ2hsc1N1YnRpdGxlVHJhY2tMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkLCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgU1VCVElUTEVfVFJBQ0tfTE9BREVEID0gJ2hsc1N1YnRpdGxlVHJhY2tMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgZnJhZ21lbnQgaGFzIGJlZW4gcHJvY2Vzc2VkIC0gZGF0YTogeyBzdWNjZXNzIDogYm9vbGVhbiwgZnJhZyA6IHRoZSBwcm9jZXNzZWQgZnJhZyB9XG4gIFNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEID0gJ2hsc1N1YnRpdGxlRnJhZ1Byb2Nlc3NlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBzZXQgb2YgVlRUQ3VlcyB0byBiZSBtYW5hZ2VkIGV4dGVybmFsbHkgaGFzIGJlZW4gcGFyc2VkIC0gZGF0YTogeyB0eXBlOiBzdHJpbmcsIHRyYWNrOiBzdHJpbmcsIGN1ZXM6IFsgVlRUQ3VlIF0gfVxuICBDVUVTX1BBUlNFRCA9ICdobHNDdWVzUGFyc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIHRleHQgdHJhY2sgdG8gYmUgbWFuYWdlZCBleHRlcm5hbGx5IGlzIGZvdW5kIC0gZGF0YTogeyB0cmFja3M6IFsgeyBsYWJlbDogc3RyaW5nLCBraW5kOiBzdHJpbmcsIGRlZmF1bHQ6IGJvb2xlYW4gfSBdIH1cbiAgTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORCA9ICdobHNOb25OYXRpdmVUZXh0VHJhY2tzRm91bmQnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBmaXJzdCB0aW1lc3RhbXAgaXMgZm91bmQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgaW5pdFBUUzogaW5pdFBUUywgdGltZXNjYWxlOiB0aW1lc2NhbGUsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBJTklUX1BUU19GT1VORCA9ICdobHNJbml0UHRzRm91bmQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX0xPQURJTkcgPSAnaGxzRnJhZ0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBwcm9ncmVzc2luZyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgeyB0cmVxdWVzdCwgdGZpcnN0LCBsb2FkZWQgfSB9XG4gIC8vIEZSQUdfTE9BRF9QUk9HUkVTUyA9ICdobHNGcmFnTG9hZFByb2dyZXNzJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBhYm9ydGluZyBmb3IgZW1lcmdlbmN5IHN3aXRjaCBkb3duIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVEID0gJ2hsc0ZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGZyYWdtZW50IHBheWxvYWQsIHN0YXRzIDogTG9hZGVyU3RhdHMgfVxuICBGUkFHX0xPQURFRCA9ICdobHNGcmFnTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGhhcyBmaW5pc2hlZCBkZWNyeXB0aW5nIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGZyYWdtZW50IHBheWxvYWQsIHN0YXRzIDogeyB0c3RhcnQsIHRkZWNyeXB0IH0gfVxuICBGUkFHX0RFQ1JZUFRFRCA9ICdobHNGcmFnRGVjcnlwdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBJbml0IFNlZ21lbnQgaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBtb292IDogbW9vdiBNUDQgYm94LCBjb2RlY3MgOiBjb2RlY3MgZm91bmQgd2hpbGUgcGFyc2luZyBmcmFnbWVudCB9XG4gIEZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQgPSAnaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudCcsXG4gIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBzZWkgdGV4dCBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBzZWkgc2FtcGxlcyBwZXMgXSB9XG4gIEZSQUdfUEFSU0lOR19VU0VSREFUQSA9ICdobHNGcmFnUGFyc2luZ1VzZXJkYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIGlkMyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBpZDMgc2FtcGxlcyBwZXMgXSB9XG4gIEZSQUdfUEFSU0lOR19NRVRBREFUQSA9ICdobHNGcmFnUGFyc2luZ01ldGFkYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBkYXRhIGhhdmUgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIGRhdGExIDogbW9vZiBNUDQgYm94IG9yIFRTIGZyYWdtZW50cywgZGF0YTIgOiBtZGF0IE1QNCBib3ggb3IgbnVsbH1cbiAgLy8gRlJBR19QQVJTSU5HX0RBVEEgPSAnaGxzRnJhZ1BhcnNpbmdEYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBwYXJzaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX1BBUlNFRCA9ICdobHNGcmFnUGFyc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCByZW11eGVkIE1QNCBib3hlcyBoYXZlIGFsbCBiZWVuIGFwcGVuZGVkIGludG8gU291cmNlQnVmZmVyIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHN0YXRzIDogTG9hZGVyU3RhdHMgfVxuICBGUkFHX0JVRkZFUkVEID0gJ2hsc0ZyYWdCdWZmZXJlZCcsXG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgbWF0Y2hpbmcgd2l0aCBjdXJyZW50IG1lZGlhIHBvc2l0aW9uIGlzIGNoYW5naW5nIC0gZGF0YSA6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRlJBR19DSEFOR0VEID0gJ2hsc0ZyYWdDaGFuZ2VkJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBGUFMgZHJvcCBldmVudCAtIGRhdGE6IHsgY3VycmVudERyb3BwZWQsIGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXMgfVxuICBGUFNfRFJPUCA9ICdobHNGcHNEcm9wJyxcbiAgLy8gdHJpZ2dlcmVkIHdoZW4gRlBTIGRyb3AgdHJpZ2dlcnMgYXV0byBsZXZlbCBjYXBwaW5nIC0gZGF0YTogeyBsZXZlbCwgZHJvcHBlZExldmVsIH1cbiAgRlBTX0RST1BfTEVWRUxfQ0FQUElORyA9ICdobHNGcHNEcm9wTGV2ZWxDYXBwaW5nJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gZXJyb3IgZXZlbnQgLSBkYXRhOiB7IHR5cGUgOiBlcnJvciB0eXBlLCBkZXRhaWxzIDogZXJyb3IgZGV0YWlscywgZmF0YWwgOiBpZiB0cnVlLCBobHMuanMgY2Fubm90L3dpbGwgbm90IHRyeSB0byByZWNvdmVyLCBpZiBmYWxzZSwgaGxzLmpzIHdpbGwgdHJ5IHRvIHJlY292ZXIsb3RoZXIgZXJyb3Igc3BlY2lmaWMgZGF0YSB9XG4gIEVSUk9SID0gJ2hsc0Vycm9yJyxcbiAgLy8gZmlyZWQgd2hlbiBobHMuanMgaW5zdGFuY2Ugc3RhcnRzIGRlc3Ryb3lpbmcuIERpZmZlcmVudCBmcm9tIE1FRElBX0RFVEFDSEVEIGFzIG9uZSBjb3VsZCB3YW50IHRvIGRldGFjaCBhbmQgcmVhdHRhY2ggYSBtZWRpYSB0byB0aGUgaW5zdGFuY2Ugb2YgaGxzLmpzIHRvIGhhbmRsZSBtaWQtcm9sbHMgZm9yIGV4YW1wbGUgLSBkYXRhOiB7IH1cbiAgREVTVFJPWUlORyA9ICdobHNEZXN0cm95aW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgS0VZX0xPQURJTkcgPSAnaGxzS2V5TG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwga2V5SW5mbyA6IEtleUxvYWRlckluZm8gfVxuICBLRVlfTE9BREVEID0gJ2hsc0tleUxvYWRlZCcsXG4gIC8vIGRlcHJlY2F0ZWQ7IHBsZWFzZSB1c2UgQkFDS19CVUZGRVJfUkVBQ0hFRCAtIGRhdGEgOiB7IGJ1ZmZlckVuZDogbnVtYmVyIH1cbiAgTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVEID0gJ2hsc0xpdmVCYWNrQnVmZmVyUmVhY2hlZCcsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIGJhY2sgYnVmZmVyIGlzIHJlYWNoZWQgYXMgZGVmaW5lZCBieSB0aGUgYmFja0J1ZmZlckxlbmd0aCBjb25maWcgb3B0aW9uIC0gZGF0YSA6IHsgYnVmZmVyRW5kOiBudW1iZXIgfVxuICBCQUNLX0JVRkZFUl9SRUFDSEVEID0gJ2hsc0JhY2tCdWZmZXJSZWFjaGVkJyxcbn1cblxuLyoqXG4gKiBEZWZpbmVzIGVhY2ggRXZlbnQgdHlwZSBhbmQgcGF5bG9hZCBieSBFdmVudCBuYW1lLiBVc2VkIGluIHtAbGluayBobHMuanMjSGxzRXZlbnRFbWl0dGVyfSB0byBzdHJvbmdseSB0eXBlIHRoZSBldmVudCBsaXN0ZW5lciBBUEkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGxzTGlzdGVuZXJzIHtcbiAgW0V2ZW50cy5NRURJQV9BVFRBQ0hJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsXG4gICAgZGF0YTogTWVkaWFBdHRhY2hpbmdEYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5NRURJQV9BVFRBQ0hFRF06IChcbiAgICBldmVudDogRXZlbnRzLk1FRElBX0FUVEFDSEVELFxuICAgIGRhdGE6IE1lZGlhQXR0YWNoZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5NRURJQV9ERVRBQ0hJTkddOiAoZXZlbnQ6IEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcpID0+IHZvaWQ7XG4gIFtFdmVudHMuTUVESUFfREVUQUNIRURdOiAoZXZlbnQ6IEV2ZW50cy5NRURJQV9ERVRBQ0hFRCkgPT4gdm9pZDtcbiAgW0V2ZW50cy5CVUZGRVJfUkVTRVRdOiAoZXZlbnQ6IEV2ZW50cy5CVUZGRVJfUkVTRVQpID0+IHZvaWQ7XG4gIFtFdmVudHMuQlVGRkVSX0NPREVDU106IChcbiAgICBldmVudDogRXZlbnRzLkJVRkZFUl9DT0RFQ1MsXG4gICAgZGF0YTogQnVmZmVyQ29kZWNzRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQlVGRkVSX0NSRUFURURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCxcbiAgICBkYXRhOiBCdWZmZXJDcmVhdGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQlVGRkVSX0FQUEVORElOR106IChcbiAgICBldmVudDogRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsXG4gICAgZGF0YTogQnVmZmVyQXBwZW5kaW5nRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQlVGRkVSX0FQUEVOREVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0FQUEVOREVELFxuICAgIGRhdGE6IEJ1ZmZlckFwcGVuZGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQlVGRkVSX0VPU106IChldmVudDogRXZlbnRzLkJVRkZFUl9FT1MsIGRhdGE6IEJ1ZmZlckVPU0RhdGEpID0+IHZvaWQ7XG4gIFtFdmVudHMuQlVGRkVSX0ZMVVNISU5HXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0ZMVVNISU5HLFxuICAgIGRhdGE6IEJ1ZmZlckZsdXNoaW5nRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQlVGRkVSX0ZMVVNIRURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfRkxVU0hFRCxcbiAgICBkYXRhOiBCdWZmZXJGbHVzaGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTUFOSUZFU1RfTE9BRElOR106IChcbiAgICBldmVudDogRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsXG4gICAgZGF0YTogTWFuaWZlc3RMb2FkaW5nRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTUFOSUZFU1RfTE9BREVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuTUFOSUZFU1RfTE9BREVELFxuICAgIGRhdGE6IE1hbmlmZXN0TG9hZGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTUFOSUZFU1RfUEFSU0VEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuTUFOSUZFU1RfUEFSU0VELFxuICAgIGRhdGE6IE1hbmlmZXN0UGFyc2VkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTEVWRUxfU1dJVENISU5HXTogKFxuICAgIGV2ZW50OiBFdmVudHMuTEVWRUxfU1dJVENISU5HLFxuICAgIGRhdGE6IExldmVsU3dpdGNoaW5nRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTEVWRUxfU1dJVENIRURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTF9TV0lUQ0hFRCxcbiAgICBkYXRhOiBMZXZlbFN3aXRjaGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTEVWRUxfTE9BRElOR106IChcbiAgICBldmVudDogRXZlbnRzLkxFVkVMX0xPQURJTkcsXG4gICAgZGF0YTogTGV2ZWxMb2FkaW5nRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTEVWRUxfTE9BREVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuTEVWRUxfTE9BREVELFxuICAgIGRhdGE6IExldmVsTG9hZGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTEVWRUxfVVBEQVRFRF06IChcbiAgICBldmVudDogRXZlbnRzLkxFVkVMX1VQREFURUQsXG4gICAgZGF0YTogTGV2ZWxVcGRhdGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTEVWRUxfUFRTX1VQREFURURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTF9QVFNfVVBEQVRFRCxcbiAgICBkYXRhOiBMZXZlbFBUU1VwZGF0ZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5MRVZFTFNfVVBEQVRFRF06IChcbiAgICBldmVudDogRXZlbnRzLkxFVkVMU19VUERBVEVELFxuICAgIGRhdGE6IExldmVsc1VwZGF0ZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5BVURJT19UUkFDS1NfVVBEQVRFRF06IChcbiAgICBldmVudDogRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELFxuICAgIGRhdGE6IEF1ZGlvVHJhY2tzVXBkYXRlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElOR106IChcbiAgICBldmVudDogRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORyxcbiAgICBkYXRhOiBBdWRpb1RyYWNrU3dpdGNoaW5nRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCxcbiAgICBkYXRhOiBBdWRpb1RyYWNrU3dpdGNoZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5BVURJT19UUkFDS19MT0FESU5HXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORyxcbiAgICBkYXRhOiBUcmFja0xvYWRpbmdEYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5BVURJT19UUkFDS19MT0FERURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsXG4gICAgZGF0YTogQXVkaW9UcmFja0xvYWRlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsXG4gICAgZGF0YTogU3VidGl0bGVUcmFja3NVcGRhdGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuU1VCVElUTEVfVFJBQ0tTX0NMRUFSRURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENIXTogKFxuICAgIGV2ZW50OiBFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILFxuICAgIGRhdGE6IFN1YnRpdGxlVHJhY2tTd2l0Y2hEYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HXTogKFxuICAgIGV2ZW50OiBFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORyxcbiAgICBkYXRhOiBUcmFja0xvYWRpbmdEYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsXG4gICAgZGF0YTogU3VidGl0bGVUcmFja0xvYWRlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsXG4gICAgZGF0YTogU3VidGl0bGVGcmFnUHJvY2Vzc2VkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQ1VFU19QQVJTRURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5DVUVTX1BBUlNFRCxcbiAgICBkYXRhOiBDdWVzUGFyc2VkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORF06IChcbiAgICBldmVudDogRXZlbnRzLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQsXG4gICAgZGF0YTogTm9uTmF0aXZlVGV4dFRyYWNrc0RhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLklOSVRfUFRTX0ZPVU5EXTogKFxuICAgIGV2ZW50OiBFdmVudHMuSU5JVF9QVFNfRk9VTkQsXG4gICAgZGF0YTogSW5pdFBUU0ZvdW5kRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuRlJBR19MT0FESU5HXTogKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19MT0FESU5HLFxuICAgIGRhdGE6IEZyYWdMb2FkaW5nRGF0YVxuICApID0+IHZvaWQ7XG4gIC8vIFtFdmVudHMuRlJBR19MT0FEX1BST0dSRVNTXTogVG9kb0V2ZW50VHlwZVxuICBbRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRF06IChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCxcbiAgICBkYXRhOiBGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5GUkFHX0xPQURFRF06IChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfTE9BREVELFxuICAgIGRhdGE6IEZyYWdMb2FkZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5GUkFHX0RFQ1JZUFRFRF06IChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfREVDUllQVEVELFxuICAgIGRhdGE6IEZyYWdEZWNyeXB0ZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UXTogKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxcbiAgICBkYXRhOiBGcmFnUGFyc2luZ0luaXRTZWdtZW50RGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBXTogKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBLFxuICAgIGRhdGE6IEZyYWdQYXJzaW5nVXNlcmRhdGFEYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEFdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsXG4gICAgZGF0YTogRnJhZ1BhcnNpbmdNZXRhZGF0YURhdGFcbiAgKSA9PiB2b2lkO1xuICAvLyBbRXZlbnRzLkZSQUdfUEFSU0lOR19EQVRBXTogVG9kb0V2ZW50VHlwZVxuICBbRXZlbnRzLkZSQUdfUEFSU0VEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19QQVJTRUQsXG4gICAgZGF0YTogRnJhZ1BhcnNlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkZSQUdfQlVGRkVSRURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX0JVRkZFUkVELFxuICAgIGRhdGE6IEZyYWdCdWZmZXJlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkZSQUdfQ0hBTkdFRF06IChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfQ0hBTkdFRCxcbiAgICBkYXRhOiBGcmFnQ2hhbmdlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkZQU19EUk9QXTogKGV2ZW50OiBFdmVudHMuRlBTX0RST1AsIGRhdGE6IEZQU0Ryb3BEYXRhKSA9PiB2b2lkO1xuICBbRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLFxuICAgIGRhdGE6IEZQU0Ryb3BMZXZlbENhcHBpbmdEYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5FUlJPUl06IChldmVudDogRXZlbnRzLkVSUk9SLCBkYXRhOiBFcnJvckRhdGEpID0+IHZvaWQ7XG4gIFtFdmVudHMuREVTVFJPWUlOR106IChldmVudDogRXZlbnRzLkRFU1RST1lJTkcpID0+IHZvaWQ7XG4gIFtFdmVudHMuS0VZX0xPQURJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5LRVlfTE9BRElORyxcbiAgICBkYXRhOiBLZXlMb2FkaW5nRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuS0VZX0xPQURFRF06IChldmVudDogRXZlbnRzLktFWV9MT0FERUQsIGRhdGE6IEtleUxvYWRlZERhdGEpID0+IHZvaWQ7XG4gIFtFdmVudHMuTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVELFxuICAgIGRhdGE6IExpdmVCYWNrQnVmZmVyRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQkFDS19CVUZGRVJfUkVBQ0hFRF06IChcbiAgICBldmVudDogRXZlbnRzLkJBQ0tfQlVGRkVSX1JFQUNIRUQsXG4gICAgZGF0YTogQmFja0J1ZmZlckRhdGFcbiAgKSA9PiB2b2lkO1xufVxuZXhwb3J0IGludGVyZmFjZSBIbHNFdmVudEVtaXR0ZXIge1xuICBvbjxFIGV4dGVuZHMga2V5b2YgSGxzTGlzdGVuZXJzLCBDb250ZXh0ID0gdW5kZWZpbmVkPihcbiAgICBldmVudDogRSxcbiAgICBsaXN0ZW5lcjogSGxzTGlzdGVuZXJzW0VdLFxuICAgIGNvbnRleHQ/OiBDb250ZXh0XG4gICk6IHZvaWQ7XG4gIG9uY2U8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycywgQ29udGV4dCA9IHVuZGVmaW5lZD4oXG4gICAgZXZlbnQ6IEUsXG4gICAgbGlzdGVuZXI6IEhsc0xpc3RlbmVyc1tFXSxcbiAgICBjb250ZXh0PzogQ29udGV4dFxuICApOiB2b2lkO1xuXG4gIHJlbW92ZUFsbExpc3RlbmVyczxFIGV4dGVuZHMga2V5b2YgSGxzTGlzdGVuZXJzPihldmVudD86IEUpOiB2b2lkO1xuICBvZmY8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycywgQ29udGV4dCA9IHVuZGVmaW5lZD4oXG4gICAgZXZlbnQ6IEUsXG4gICAgbGlzdGVuZXI/OiBIbHNMaXN0ZW5lcnNbRV0sXG4gICAgY29udGV4dD86IENvbnRleHQsXG4gICAgb25jZT86IGJvb2xlYW5cbiAgKTogdm9pZDtcblxuICBsaXN0ZW5lcnM8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oZXZlbnQ6IEUpOiBIbHNMaXN0ZW5lcnNbRV1bXTtcbiAgZW1pdDxFIGV4dGVuZHMga2V5b2YgSGxzTGlzdGVuZXJzPihcbiAgICBldmVudDogRSxcbiAgICBuYW1lOiBFLFxuICAgIGV2ZW50T2JqZWN0OiBQYXJhbWV0ZXJzPEhsc0xpc3RlbmVyc1tFXT5bMV1cbiAgKTogYm9vbGVhbjtcbiAgbGlzdGVuZXJDb3VudDxFIGV4dGVuZHMga2V5b2YgSGxzTGlzdGVuZXJzPihldmVudDogRSk6IG51bWJlcjtcbn1cbiIsImV4cG9ydCBlbnVtIEVycm9yVHlwZXMge1xuICAvLyBJZGVudGlmaWVyIGZvciBhIG5ldHdvcmsgZXJyb3IgKGxvYWRpbmcgZXJyb3IgLyB0aW1lb3V0IC4uLilcbiAgTkVUV09SS19FUlJPUiA9ICduZXR3b3JrRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1lZGlhIEVycm9yICh2aWRlby9wYXJzaW5nL21lZGlhc291cmNlIGVycm9yKVxuICBNRURJQV9FUlJPUiA9ICdtZWRpYUVycm9yJyxcbiAgLy8gRU1FIChlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucykgZXJyb3JzXG4gIEtFWV9TWVNURU1fRVJST1IgPSAna2V5U3lzdGVtRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG11eCBFcnJvciAoZGVtdXhpbmcvcmVtdXhpbmcpXG4gIE1VWF9FUlJPUiA9ICdtdXhFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFsbCBvdGhlciBlcnJvcnNcbiAgT1RIRVJfRVJST1IgPSAnb3RoZXJFcnJvcicsXG59XG5cbmV4cG9ydCBlbnVtIEVycm9yRGV0YWlscyB7XG4gIEtFWV9TWVNURU1fTk9fS0VZUyA9ICdrZXlTeXN0ZW1Ob0tleXMnLFxuICBLRVlfU1lTVEVNX05PX0FDQ0VTUyA9ICdrZXlTeXN0ZW1Ob0FjY2VzcycsXG4gIEtFWV9TWVNURU1fTk9fU0VTU0lPTiA9ICdrZXlTeXN0ZW1Ob1Nlc3Npb24nLFxuICBLRVlfU1lTVEVNX05PX0NPTkZJR1VSRURfTElDRU5TRSA9ICdrZXlTeXN0ZW1Ob0NvbmZpZ3VyZWRMaWNlbnNlJyxcbiAgS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVEID0gJ2tleVN5c3RlbUxpY2Vuc2VSZXF1ZXN0RmFpbGVkJyxcbiAgS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRUQgPSAna2V5U3lzdGVtU2VydmVyQ2VydGlmaWNhdGVSZXF1ZXN0RmFpbGVkJyxcbiAgS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfVVBEQVRFX0ZBSUxFRCA9ICdrZXlTeXN0ZW1TZXJ2ZXJDZXJ0aWZpY2F0ZVVwZGF0ZUZhaWxlZCcsXG4gIEtFWV9TWVNURU1fU0VTU0lPTl9VUERBVEVfRkFJTEVEID0gJ2tleVN5c3RlbVNlc3Npb25VcGRhdGVGYWlsZWQnLFxuICBLRVlfU1lTVEVNX1NUQVRVU19PVVRQVVRfUkVTVFJJQ1RFRCA9ICdrZXlTeXN0ZW1TdGF0dXNPdXRwdXRSZXN0cmljdGVkJyxcbiAgS0VZX1NZU1RFTV9TVEFUVVNfSU5URVJOQUxfRVJST1IgPSAna2V5U3lzdGVtU3RhdHVzSW50ZXJuYWxFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTUFOSUZFU1RfTE9BRF9FUlJPUiA9ICdtYW5pZmVzdExvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBNQU5JRkVTVF9MT0FEX1RJTUVPVVQgPSAnbWFuaWZlc3RMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgcGFyc2luZyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICBNQU5JRkVTVF9QQVJTSU5HX0VSUk9SID0gJ21hbmlmZXN0UGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCB3aXRoIG9ubHkgaW5jb21wYXRpYmxlIGNvZGVjcyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICBNQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SID0gJ21hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHdoaWNoIGNvbnRhaW5zIG5vIGZyYWdtZW50cyAtIGRhdGE6IHsgdXJsOiBmYXVsdHkgVVJMLCByZWFzb246IFwibm8gZnJhZ21lbnRzIGZvdW5kIGluIGxldmVsXCIsIGxldmVsOiBpbmRleCBvZiB0aGUgYmFkIGxldmVsIH1cbiAgTEVWRUxfRU1QVFlfRVJST1IgPSAnbGV2ZWxFbXB0eUVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBMRVZFTF9MT0FEX0VSUk9SID0gJ2xldmVsTG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIExFVkVMX0xPQURfVElNRU9VVCA9ICdsZXZlbExvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBwYXJzZSBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgZXJyb3I6IEVycm9yLCByZWFzb246IGVycm9yIG1lc3NhZ2UgfVxuICBMRVZFTF9QQVJTSU5HX0VSUk9SID0gJ2xldmVsUGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBzd2l0Y2ggZXJyb3IgLSBkYXRhOiB7IGxldmVsIDogZmF1bHR5IGxldmVsIElkLCBldmVudCA6IGVycm9yIGRlc2NyaXB0aW9ufVxuICBMRVZFTF9TV0lUQ0hfRVJST1IgPSAnbGV2ZWxTd2l0Y2hFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEFVRElPX1RSQUNLX0xPQURfRVJST1IgPSAnYXVkaW9UcmFja0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUID0gJ2F1ZGlvVHJhY2tMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgc3VidGl0bGUgdHJhY2sgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgU1VCVElUTEVfTE9BRF9FUlJPUiA9ICdzdWJ0aXRsZVRyYWNrTG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBzdWJ0aXRsZSB0cmFjayBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIFNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVCA9ICdzdWJ0aXRsZVRyYWNrTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBGUkFHX0xPQURfRVJST1IgPSAnZnJhZ0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT0FEX1RJTUVPVVQgPSAnZnJhZ0xvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBkZWNyeXB0aW9uIGVycm9yIGV2ZW50IC0gZGF0YToge2lkIDogZGVtdXhlciBJZCxmcmFnOiBmcmFnbWVudCBvYmplY3QsIHJlYXNvbiA6IHBhcnNpbmcgZXJyb3IgZGVzY3JpcHRpb24gfVxuICBGUkFHX0RFQ1JZUFRfRVJST1IgPSAnZnJhZ0RlY3J5cHRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgcGFyc2luZyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cbiAgLy8gd2lsbCBiZSByZW5hbWVkIERFTVVYX1BBUlNJTkdfRVJST1IgYW5kIHN3aXRjaGVkIHRvIE1VWF9FUlJPUiBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG4gIEZSQUdfUEFSU0lOR19FUlJPUiA9ICdmcmFnUGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBvciBwYXJ0IGxvYWQgc2tpcHBlZCBiZWNhdXNlIG9mIGEgR0FQIHRhZyBvciBhdHRyaWJ1dGVcbiAgRlJBR19HQVAgPSAnZnJhZ0dhcCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgcmVtdXggYWxsb2MgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgYnl0ZXMgOiBuYiBvZiBieXRlcyBvbiB3aGljaCBhbGxvY2F0aW9uIGZhaWxlZCAsIHJlYXNvbiA6IGVycm9yIHRleHQgfVxuICBSRU1VWF9BTExPQ19FUlJPUiA9ICdyZW11eEFsbG9jRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBLRVlfTE9BRF9FUlJPUiA9ICdrZXlMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEtFWV9MT0FEX1RJTUVPVVQgPSAna2V5TG9hZFRpbWVPdXQnLFxuICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBleGNlcHRpb24gb2NjdXJzIHdoaWxlIGFkZGluZyBhIHNvdXJjZUJ1ZmZlciB0byBNZWRpYVNvdXJjZSAtIGRhdGEgOiB7IGVycm9yIDogZXhjZXB0aW9uICwgbWltZVR5cGUgOiBtaW1lVHlwZSB9XG4gIEJVRkZFUl9BRERfQ09ERUNfRVJST1IgPSAnYnVmZmVyQWRkQ29kZWNFcnJvcicsXG4gIC8vIFRyaWdnZXJlZCB3aGVuIHNvdXJjZSBidWZmZXIocykgY291bGQgbm90IGJlIGNyZWF0ZWQgdXNpbmcgbGV2ZWwgKG1hbmlmZXN0IENPREVDUyBhdHRyaWJ1dGUpLCBwYXJzZWQgbWVkaWEsIG9yIGJlc3QgZ3Vlc3MgY29kZWMocykgLSBkYXRhOiB7IHJlYXNvbiA6IGVycm9yIHJlYXNvbiB9XG4gIEJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SID0gJ2J1ZmZlckluY29tcGF0aWJsZUNvZGVjc0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgYXBwZW5kIGVycm9yIC0gZGF0YTogYXBwZW5kIGVycm9yIGRlc2NyaXB0aW9uXG4gIEJVRkZFUl9BUFBFTkRfRVJST1IgPSAnYnVmZmVyQXBwZW5kRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmRpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiBhcHBlbmRpbmcgZXJyb3IgZGVzY3JpcHRpb25cbiAgQlVGRkVSX0FQUEVORElOR19FUlJPUiA9ICdidWZmZXJBcHBlbmRpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHN0YWxsZWQgZXJyb3IgZXZlbnRcbiAgQlVGRkVSX1NUQUxMRURfRVJST1IgPSAnYnVmZmVyU3RhbGxlZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgZnVsbCBldmVudFxuICBCVUZGRVJfRlVMTF9FUlJPUiA9ICdidWZmZXJGdWxsRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzZWVrIG92ZXIgaG9sZSBldmVudFxuICBCVUZGRVJfU0VFS19PVkVSX0hPTEUgPSAnYnVmZmVyU2Vla092ZXJIb2xlJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgbnVkZ2Ugb24gc3RhbGwgKHBsYXliYWNrIGlzIHN0dWNrIGFsdGhvdWdoIGN1cnJlbnRUaW1lIGlzIGluIGEgYnVmZmVyZWQgYXJlYSlcbiAgQlVGRkVSX05VREdFX09OX1NUQUxMID0gJ2J1ZmZlck51ZGdlT25TdGFsbCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGludGVybmFsIGV4Y2VwdGlvbiBoYXBwZW5pbmcgaW5zaWRlIGhscy5qcyB3aGlsZSBoYW5kbGluZyBhbiBldmVudFxuICBJTlRFUk5BTF9FWENFUFRJT04gPSAnaW50ZXJuYWxFeGNlcHRpb24nLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBjYWxsIHRvIGFib3J0IGEgbG9hZGVyXG4gIElOVEVSTkFMX0FCT1JURUQgPSAnYWJvcnRlZCcsXG4gIC8vIFVuY2F0ZWdvcml6ZWQgZXJyb3JcbiAgVU5LTk9XTiA9ICd1bmtub3duJyxcbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgSUxvZ0Z1bmN0aW9uIHtcbiAgKG1lc3NhZ2U/OiBhbnksIC4uLm9wdGlvbmFsUGFyYW1zOiBhbnlbXSk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUxvZ2dlciB7XG4gIHRyYWNlOiBJTG9nRnVuY3Rpb247XG4gIGRlYnVnOiBJTG9nRnVuY3Rpb247XG4gIGxvZzogSUxvZ0Z1bmN0aW9uO1xuICB3YXJuOiBJTG9nRnVuY3Rpb247XG4gIGluZm86IElMb2dGdW5jdGlvbjtcbiAgZXJyb3I6IElMb2dGdW5jdGlvbjtcbn1cblxuY29uc3Qgbm9vcDogSUxvZ0Z1bmN0aW9uID0gZnVuY3Rpb24gKCkge307XG5cbmNvbnN0IGZha2VMb2dnZXI6IElMb2dnZXIgPSB7XG4gIHRyYWNlOiBub29wLFxuICBkZWJ1Zzogbm9vcCxcbiAgbG9nOiBub29wLFxuICB3YXJuOiBub29wLFxuICBpbmZvOiBub29wLFxuICBlcnJvcjogbm9vcCxcbn07XG5cbmxldCBleHBvcnRlZExvZ2dlcjogSUxvZ2dlciA9IGZha2VMb2dnZXI7XG5cbi8vIGxldCBsYXN0Q2FsbFRpbWU7XG4vLyBmdW5jdGlvbiBmb3JtYXRNc2dXaXRoVGltZUluZm8odHlwZSwgbXNnKSB7XG4vLyAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4vLyAgIGNvbnN0IGRpZmYgPSBsYXN0Q2FsbFRpbWUgPyAnKycgKyAobm93IC0gbGFzdENhbGxUaW1lKSA6ICcwJztcbi8vICAgbGFzdENhbGxUaW1lID0gbm93O1xuLy8gICBtc2cgPSAobmV3IERhdGUobm93KSkudG9JU09TdHJpbmcoKSArICcgfCBbJyArICB0eXBlICsgJ10gPiAnICsgbXNnICsgJyAoICcgKyBkaWZmICsgJyBtcyApJztcbi8vICAgcmV0dXJuIG1zZztcbi8vIH1cblxuZnVuY3Rpb24gY29uc29sZVByaW50Rm4odHlwZTogc3RyaW5nKTogSUxvZ0Z1bmN0aW9uIHtcbiAgY29uc3QgZnVuYzogSUxvZ0Z1bmN0aW9uID0gc2VsZi5jb25zb2xlW3R5cGVdO1xuICBpZiAoZnVuYykge1xuICAgIHJldHVybiBmdW5jLmJpbmQoc2VsZi5jb25zb2xlLCBgWyR7dHlwZX1dID5gKTtcbiAgfVxuICByZXR1cm4gbm9vcDtcbn1cblxuZnVuY3Rpb24gZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKFxuICBkZWJ1Z0NvbmZpZzogYm9vbGVhbiB8IElMb2dnZXIsXG4gIC4uLmZ1bmN0aW9uczogc3RyaW5nW11cbik6IHZvaWQge1xuICBmdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV1cbiAgICAgID8gZGVidWdDb25maWdbdHlwZV0uYmluZChkZWJ1Z0NvbmZpZylcbiAgICAgIDogY29uc29sZVByaW50Rm4odHlwZSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlTG9ncyhkZWJ1Z0NvbmZpZzogYm9vbGVhbiB8IElMb2dnZXIsIGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgLy8gY2hlY2sgdGhhdCBjb25zb2xlIGlzIGF2YWlsYWJsZVxuICBpZiAoXG4gICAgKHNlbGYuY29uc29sZSAmJiBkZWJ1Z0NvbmZpZyA9PT0gdHJ1ZSkgfHxcbiAgICB0eXBlb2YgZGVidWdDb25maWcgPT09ICdvYmplY3QnXG4gICkge1xuICAgIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhcbiAgICAgIGRlYnVnQ29uZmlnLFxuICAgICAgLy8gUmVtb3ZlIG91dCBmcm9tIGxpc3QgaGVyZSB0byBoYXJkLWRpc2FibGUgYSBsb2ctbGV2ZWxcbiAgICAgIC8vICd0cmFjZScsXG4gICAgICAnZGVidWcnLFxuICAgICAgJ2xvZycsXG4gICAgICAnaW5mbycsXG4gICAgICAnd2FybicsXG4gICAgICAnZXJyb3InXG4gICAgKTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IGFsbG93IHRvIHVzZSBiaW5kIG9uIGNvbnNvbGUgb2JqZWN0IGFueXdheVxuICAgIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgdHJ5IHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyLmxvZyhcbiAgICAgICAgYERlYnVnIGxvZ3MgZW5hYmxlZCBmb3IgXCIke2lkfVwiIGluIGhscy5qcyB2ZXJzaW9uICR7X19WRVJTSU9OX199YFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbG9nZ2VyOiBJTG9nZ2VyID0gZXhwb3J0ZWRMb2dnZXI7XG4iLCJjb25zdCBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLztcbmNvbnN0IEFUVFJfTElTVF9SRUdFWCA9IC8oLis/KT0oXCIuKj9cInwuKj8pKD86LHwkKS9nO1xuXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2thbm9uZ2lsL25vZGUtbTN1OHBhcnNlL2Jsb2IvbWFzdGVyL2F0dHJsaXN0LmpzXG5leHBvcnQgY2xhc3MgQXR0ckxpc3Qge1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoYXR0cnM6IHN0cmluZyB8IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgYXR0cnMgPSBBdHRyTGlzdC5wYXJzZUF0dHJMaXN0KGF0dHJzKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICBpZiAoYXR0ci5zdWJzdHJpbmcoMCwgMikgPT09ICdYLScpIHtcbiAgICAgICAgICB0aGlzLmNsaWVudEF0dHJzID0gdGhpcy5jbGllbnRBdHRycyB8fCBbXTtcbiAgICAgICAgICB0aGlzLmNsaWVudEF0dHJzLnB1c2goYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1thdHRyXSA9IGF0dHJzW2F0dHJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfVxuXG4gIGhleGFkZWNpbWFsSW50ZWdlcihhdHRyTmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXNbYXR0ck5hbWVdKSB7XG4gICAgICBsZXQgc3RyaW5nVmFsdWUgPSAodGhpc1thdHRyTmFtZV0gfHwgJzB4Jykuc2xpY2UoMik7XG4gICAgICBzdHJpbmdWYWx1ZSA9IChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IHBhcnNlSW50KHN0cmluZ1ZhbHVlLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIoYXR0ck5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUludCh0aGlzW2F0dHJOYW1lXSwgMTYpO1xuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9XG5cbiAgZGVjaW1hbEZsb2F0aW5nUG9pbnQoYXR0ck5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpc1thdHRyTmFtZV0pO1xuICB9XG5cbiAgb3B0aW9uYWxGbG9hdChhdHRyTmFtZTogc3RyaW5nLCBkZWZhdWx0VmFsdWU6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzW2F0dHJOYW1lXTtcbiAgICByZXR1cm4gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIGVudW1lcmF0ZWRTdHJpbmcoYXR0ck5hbWU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdO1xuICB9XG5cbiAgYm9vbChhdHRyTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdID09PSAnWUVTJztcbiAgfVxuXG4gIGRlY2ltYWxSZXNvbHV0aW9uKGF0dHJOYW1lOiBzdHJpbmcpOlxuICAgIHwge1xuICAgICAgICB3aWR0aDogbnVtYmVyO1xuICAgICAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICAgIH1cbiAgICB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcmVzID0gREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYLmV4ZWModGhpc1thdHRyTmFtZV0pO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBwYXJzZUludChyZXNbMV0sIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQocmVzWzJdLCAxMCksXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUF0dHJMaXN0KGlucHV0OiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICBjb25zdCBxdW90ZSA9ICdcIic7XG4gICAgQVRUUl9MSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgIGxldCB2YWx1ZSA9IG1hdGNoWzJdO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlLmluZGV4T2YocXVvdGUpID09PSAwICYmXG4gICAgICAgIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gdmFsdWUubGVuZ3RoIC0gMVxuICAgICAgKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmFtZSA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbiAgfVxufVxuIiwiaW1wb3J0IHsgQXR0ckxpc3QgfSBmcm9tICcuLi91dGlscy9hdHRyLWxpc3QnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuLy8gQXZvaWQgZXhwb3J0aW5nIGNvbnN0IGVudW0gc28gdGhhdCB0aGVzZSB2YWx1ZXMgY2FuIGJlIGlubGluZWRcbmNvbnN0IGVudW0gRGF0ZVJhbmdlQXR0cmlidXRlIHtcbiAgSUQgPSAnSUQnLFxuICBDTEFTUyA9ICdDTEFTUycsXG4gIFNUQVJUX0RBVEUgPSAnU1RBUlQtREFURScsXG4gIERVUkFUSU9OID0gJ0RVUkFUSU9OJyxcbiAgRU5EX0RBVEUgPSAnRU5ELURBVEUnLFxuICBFTkRfT05fTkVYVCA9ICdFTkQtT04tTkVYVCcsXG4gIFBMQU5ORURfRFVSQVRJT04gPSAnUExBTk5FRC1EVVJBVElPTicsXG4gIFNDVEUzNV9PVVQgPSAnU0NURTM1LU9VVCcsXG4gIFNDVEUzNV9JTiA9ICdTQ1RFMzUtSU4nLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUoYXR0ck5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGF0dHJOYW1lICE9PSBEYXRlUmFuZ2VBdHRyaWJ1dGUuSUQgJiZcbiAgICBhdHRyTmFtZSAhPT0gRGF0ZVJhbmdlQXR0cmlidXRlLkNMQVNTICYmXG4gICAgYXR0ck5hbWUgIT09IERhdGVSYW5nZUF0dHJpYnV0ZS5TVEFSVF9EQVRFICYmXG4gICAgYXR0ck5hbWUgIT09IERhdGVSYW5nZUF0dHJpYnV0ZS5EVVJBVElPTiAmJlxuICAgIGF0dHJOYW1lICE9PSBEYXRlUmFuZ2VBdHRyaWJ1dGUuRU5EX0RBVEUgJiZcbiAgICBhdHRyTmFtZSAhPT0gRGF0ZVJhbmdlQXR0cmlidXRlLkVORF9PTl9ORVhUXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NDVEUzNUF0dHJpYnV0ZShhdHRyTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgYXR0ck5hbWUgPT09IERhdGVSYW5nZUF0dHJpYnV0ZS5TQ1RFMzVfT1VUIHx8XG4gICAgYXR0ck5hbWUgPT09IERhdGVSYW5nZUF0dHJpYnV0ZS5TQ1RFMzVfSU5cbiAgKTtcbn1cblxuZXhwb3J0IGNsYXNzIERhdGVSYW5nZSB7XG4gIHB1YmxpYyBhdHRyOiBBdHRyTGlzdDtcbiAgcHJpdmF0ZSBfc3RhcnREYXRlOiBEYXRlO1xuICBwcml2YXRlIF9lbmREYXRlPzogRGF0ZTtcbiAgcHJpdmF0ZSBfYmFkVmFsdWVGb3JTYW1lSWQ/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoZGF0ZVJhbmdlQXR0cjogQXR0ckxpc3QsIGRhdGVSYW5nZVdpdGhTYW1lSWQ/OiBEYXRlUmFuZ2UpIHtcbiAgICBpZiAoZGF0ZVJhbmdlV2l0aFNhbWVJZCkge1xuICAgICAgY29uc3QgcHJldmlvdXNBdHRyID0gZGF0ZVJhbmdlV2l0aFNhbWVJZC5hdHRyO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldmlvdXNBdHRyKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0ZVJhbmdlQXR0ciwga2V5KSAmJlxuICAgICAgICAgIGRhdGVSYW5nZUF0dHJba2V5XSAhPT0gcHJldmlvdXNBdHRyW2tleV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgREFURVJBTkdFIHRhZyBhdHRyaWJ1dGU6IFwiJHtrZXl9XCIgZG9lcyBub3QgbWF0Y2ggZm9yIHRhZ3Mgd2l0aCBJRDogXCIke2RhdGVSYW5nZUF0dHIuSUR9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLl9iYWRWYWx1ZUZvclNhbWVJZCA9IGtleTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTWVyZ2UgRGF0ZVJhbmdlIHRhZ3Mgd2l0aCB0aGUgc2FtZSBJRFxuICAgICAgZGF0ZVJhbmdlQXR0ciA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIG5ldyBBdHRyTGlzdCh7fSksXG4gICAgICAgIHByZXZpb3VzQXR0cixcbiAgICAgICAgZGF0ZVJhbmdlQXR0clxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5hdHRyID0gZGF0ZVJhbmdlQXR0cjtcbiAgICB0aGlzLl9zdGFydERhdGUgPSBuZXcgRGF0ZShkYXRlUmFuZ2VBdHRyW0RhdGVSYW5nZUF0dHJpYnV0ZS5TVEFSVF9EQVRFXSk7XG4gICAgaWYgKERhdGVSYW5nZUF0dHJpYnV0ZS5FTkRfREFURSBpbiB0aGlzLmF0dHIpIHtcbiAgICAgIGNvbnN0IGVuZERhdGUgPSBuZXcgRGF0ZSh0aGlzLmF0dHJbRGF0ZVJhbmdlQXR0cmlidXRlLkVORF9EQVRFXSk7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGVuZERhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICB0aGlzLl9lbmREYXRlID0gZW5kRGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyLklEO1xuICB9XG5cbiAgZ2V0IGNsYXNzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYXR0ci5DTEFTUztcbiAgfVxuXG4gIGdldCBzdGFydERhdGUoKTogRGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0RGF0ZTtcbiAgfVxuXG4gIGdldCBlbmREYXRlKCk6IERhdGUgfCBudWxsIHtcbiAgICBpZiAodGhpcy5fZW5kRGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuZERhdGU7XG4gICAgfVxuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICBpZiAoZHVyYXRpb24gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9zdGFydERhdGUuZ2V0VGltZSgpICsgZHVyYXRpb24gKiAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgZHVyYXRpb24oKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKERhdGVSYW5nZUF0dHJpYnV0ZS5EVVJBVElPTiBpbiB0aGlzLmF0dHIpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5hdHRyLmRlY2ltYWxGbG9hdGluZ1BvaW50KFxuICAgICAgICBEYXRlUmFuZ2VBdHRyaWJ1dGUuRFVSQVRJT05cbiAgICAgICk7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9lbmREYXRlKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2VuZERhdGUuZ2V0VGltZSgpIC0gdGhpcy5fc3RhcnREYXRlLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBwbGFubmVkRHVyYXRpb24oKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKERhdGVSYW5nZUF0dHJpYnV0ZS5QTEFOTkVEX0RVUkFUSU9OIGluIHRoaXMuYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ci5kZWNpbWFsRmxvYXRpbmdQb2ludChcbiAgICAgICAgRGF0ZVJhbmdlQXR0cmlidXRlLlBMQU5ORURfRFVSQVRJT05cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IGVuZE9uTmV4dCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyLmJvb2woRGF0ZVJhbmdlQXR0cmlidXRlLkVORF9PTl9ORVhUKTtcbiAgfVxuXG4gIGdldCBpc1ZhbGlkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICAhIXRoaXMuaWQgJiZcbiAgICAgICF0aGlzLl9iYWRWYWx1ZUZvclNhbWVJZCAmJlxuICAgICAgTnVtYmVyLmlzRmluaXRlKHRoaXMuc3RhcnREYXRlLmdldFRpbWUoKSkgJiZcbiAgICAgICh0aGlzLmR1cmF0aW9uID09PSBudWxsIHx8IHRoaXMuZHVyYXRpb24gPj0gMCkgJiZcbiAgICAgICghdGhpcy5lbmRPbk5leHQgfHwgISF0aGlzLmNsYXNzKVxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHtcbiAgSGxzUGVyZm9ybWFuY2VUaW1pbmcsXG4gIEhsc1Byb2dyZXNzaXZlUGVyZm9ybWFuY2VUaW1pbmcsXG4gIExvYWRlclN0YXRzLFxufSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuXG5leHBvcnQgY2xhc3MgTG9hZFN0YXRzIGltcGxlbWVudHMgTG9hZGVyU3RhdHMge1xuICBhYm9ydGVkOiBib29sZWFuID0gZmFsc2U7XG4gIGxvYWRlZDogbnVtYmVyID0gMDtcbiAgcmV0cnk6IG51bWJlciA9IDA7XG4gIHRvdGFsOiBudW1iZXIgPSAwO1xuICBjaHVua0NvdW50OiBudW1iZXIgPSAwO1xuICBid0VzdGltYXRlOiBudW1iZXIgPSAwO1xuICBsb2FkaW5nOiBIbHNQcm9ncmVzc2l2ZVBlcmZvcm1hbmNlVGltaW5nID0geyBzdGFydDogMCwgZmlyc3Q6IDAsIGVuZDogMCB9O1xuICBwYXJzaW5nOiBIbHNQZXJmb3JtYW5jZVRpbWluZyA9IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICBidWZmZXJpbmc6IEhsc1Byb2dyZXNzaXZlUGVyZm9ybWFuY2VUaW1pbmcgPSB7IHN0YXJ0OiAwLCBmaXJzdDogMCwgZW5kOiAwIH07XG59XG4iLCJpbXBvcnQgeyBidWlsZEFic29sdXRlVVJMIH0gZnJvbSAndXJsLXRvb2xraXQnO1xuaW1wb3J0IHsgTGV2ZWxLZXkgfSBmcm9tICcuL2xldmVsLWtleSc7XG5pbXBvcnQgeyBMb2FkU3RhdHMgfSBmcm9tICcuL2xvYWQtc3RhdHMnO1xuaW1wb3J0IHsgQXR0ckxpc3QgfSBmcm9tICcuLi91dGlscy9hdHRyLWxpc3QnO1xuaW1wb3J0IHR5cGUge1xuICBGcmFnbWVudExvYWRlckNvbnRleHQsXG4gIEtleUxvYWRlckNvbnRleHQsXG4gIExvYWRlcixcbiAgUGxheWxpc3RMZXZlbFR5cGUsXG59IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgdHlwZSB7IEtleVN5c3RlbUZvcm1hdHMgfSBmcm9tICcuLi91dGlscy9tZWRpYWtleXMtaGVscGVyJztcblxuZXhwb3J0IGNvbnN0IGVudW0gRWxlbWVudGFyeVN0cmVhbVR5cGVzIHtcbiAgQVVESU8gPSAnYXVkaW8nLFxuICBWSURFTyA9ICd2aWRlbycsXG4gIEFVRElPVklERU8gPSAnYXVkaW92aWRlbycsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWxlbWVudGFyeVN0cmVhbUluZm8ge1xuICBzdGFydFBUUzogbnVtYmVyO1xuICBlbmRQVFM6IG51bWJlcjtcbiAgc3RhcnREVFM6IG51bWJlcjtcbiAgZW5kRFRTOiBudW1iZXI7XG4gIHBhcnRpYWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBFbGVtZW50YXJ5U3RyZWFtcyA9IFJlY29yZDxcbiAgRWxlbWVudGFyeVN0cmVhbVR5cGVzLFxuICBFbGVtZW50YXJ5U3RyZWFtSW5mbyB8IG51bGxcbj47XG5cbmV4cG9ydCBjbGFzcyBCYXNlU2VnbWVudCB7XG4gIHByaXZhdGUgX2J5dGVSYW5nZTogbnVtYmVyW10gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfdXJsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICAvLyBiYXNldXJsIGlzIHRoZSBVUkwgdG8gdGhlIHBsYXlsaXN0XG4gIHB1YmxpYyByZWFkb25seSBiYXNldXJsOiBzdHJpbmc7XG4gIC8vIHJlbHVybCBpcyB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHRoYXQgY29tZXMgZnJvbSBpbnNpZGUgdGhlIHBsYXlsaXN0LlxuICBwdWJsaWMgcmVsdXJsPzogc3RyaW5nO1xuICAvLyBIb2xkcyB0aGUgdHlwZXMgb2YgZGF0YSB0aGlzIGZyYWdtZW50IHN1cHBvcnRzXG4gIHB1YmxpYyBlbGVtZW50YXJ5U3RyZWFtczogRWxlbWVudGFyeVN0cmVhbXMgPSB7XG4gICAgW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT106IG51bGwsXG4gICAgW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT106IG51bGwsXG4gICAgW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXTogbnVsbCxcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihiYXNldXJsOiBzdHJpbmcpIHtcbiAgICB0aGlzLmJhc2V1cmwgPSBiYXNldXJsO1xuICB9XG5cbiAgLy8gc2V0Qnl0ZVJhbmdlIGNvbnZlcnRzIGEgRVhULVgtQllURVJBTkdFIGF0dHJpYnV0ZSBpbnRvIGEgdHdvIGVsZW1lbnQgYXJyYXlcbiAgc2V0Qnl0ZVJhbmdlKHZhbHVlOiBzdHJpbmcsIHByZXZpb3VzPzogQmFzZVNlZ21lbnQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB2YWx1ZS5zcGxpdCgnQCcsIDIpO1xuICAgIGNvbnN0IGJ5dGVSYW5nZTogbnVtYmVyW10gPSBbXTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgYnl0ZVJhbmdlWzBdID0gcHJldmlvdXMgPyBwcmV2aW91cy5ieXRlUmFuZ2VFbmRPZmZzZXQgOiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBieXRlUmFuZ2VbMF0gPSBwYXJzZUludChwYXJhbXNbMV0pO1xuICAgIH1cbiAgICBieXRlUmFuZ2VbMV0gPSBwYXJzZUludChwYXJhbXNbMF0pICsgYnl0ZVJhbmdlWzBdO1xuICAgIHRoaXMuX2J5dGVSYW5nZSA9IGJ5dGVSYW5nZTtcbiAgfVxuXG4gIGdldCBieXRlUmFuZ2UoKTogbnVtYmVyW10ge1xuICAgIGlmICghdGhpcy5fYnl0ZVJhbmdlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2J5dGVSYW5nZTtcbiAgfVxuXG4gIGdldCBieXRlUmFuZ2VTdGFydE9mZnNldCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVswXTtcbiAgfVxuXG4gIGdldCBieXRlUmFuZ2VFbmRPZmZzZXQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMV07XG4gIH1cblxuICBnZXQgdXJsKCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5iYXNldXJsICYmIHRoaXMucmVsdXJsKSB7XG4gICAgICB0aGlzLl91cmwgPSBidWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVybCwgdGhpcy5yZWx1cmwsIHtcbiAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91cmwgfHwgJyc7XG4gIH1cblxuICBzZXQgdXJsKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl91cmwgPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIGRhdGEgZnJvbSBhbiBITFMgU2VnbWVudC4gRm91bmQgaW4ge0BsaW5rIGhscy5qcyNMZXZlbERldGFpbHMuZnJhZ21lbnRzfS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZyYWdtZW50IGV4dGVuZHMgQmFzZVNlZ21lbnQge1xuICBwcml2YXRlIF9kZWNyeXB0ZGF0YTogTGV2ZWxLZXkgfCBudWxsID0gbnVsbDtcblxuICBwdWJsaWMgcmF3UHJvZ3JhbURhdGVUaW1lOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIHByb2dyYW1EYXRlVGltZTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyB0YWdMaXN0OiBBcnJheTxzdHJpbmdbXT4gPSBbXTtcblxuICAvLyBFWFRJTkYgaGFzIHRvIGJlIHByZXNlbnQgZm9yIGEgbTN1OCB0byBiZSBjb25zaWRlcmVkIHZhbGlkXG4gIHB1YmxpYyBkdXJhdGlvbjogbnVtYmVyID0gMDtcbiAgLy8gc24gbm90YXRlcyB0aGUgc2VxdWVuY2UgbnVtYmVyIGZvciBhIHNlZ21lbnQsIGFuZCBpZiBzZXQgdG8gYSBzdHJpbmcgY2FuIGJlICdpbml0U2VnbWVudCdcbiAgcHVibGljIHNuOiBudW1iZXIgfCAnaW5pdFNlZ21lbnQnID0gMDtcbiAgLy8gbGV2ZWxrZXlzIGFyZSB0aGUgRVhULVgtS0VZIHRhZ3MgdGhhdCBhcHBseSB0byB0aGlzIHNlZ21lbnQgZm9yIGRlY3J5cHRpb25cbiAgLy8gY29yZSBkaWZmZXJlbmNlIGZyb20gdGhlIHByaXZhdGUgZmllbGQgX2RlY3J5cHRkYXRhIGlzIHRoZSBsYWNrIG9mIHRoZSBpbml0aWFsaXplZCBJVlxuICAvLyBfZGVjcnlwdGRhdGEgd2lsbCBzZXQgdGhlIElWIGZvciB0aGlzIHNlZ21lbnQgYmFzZWQgb24gdGhlIHNlZ21lbnQgbnVtYmVyIGluIHRoZSBmcmFnbWVudFxuICBwdWJsaWMgbGV2ZWxrZXlzPzogeyBba2V5OiBzdHJpbmddOiBMZXZlbEtleSB9O1xuICAvLyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZyYWdtZW50IHR5cGVcbiAgcHVibGljIHJlYWRvbmx5IHR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlO1xuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgbG9hZGVyLiBTZXQgd2hpbGUgdGhlIGZyYWdtZW50IGlzIGxvYWRpbmcsIGFuZCByZW1vdmVkIGFmdGVyd2FyZHMuIFVzZWQgdG8gYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xuICBwdWJsaWMgbG9hZGVyOiBMb2FkZXI8RnJhZ21lbnRMb2FkZXJDb250ZXh0PiB8IG51bGwgPSBudWxsO1xuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUga2V5IGxvYWRlci4gU2V0IHdoaWxlIHRoZSBrZXkgaXMgbG9hZGluZywgYW5kIHJlbW92ZWQgYWZ0ZXJ3YXJkcy4gVXNlZCB0byBhYm9ydCBrZXkgbG9hZGluZ1xuICBwdWJsaWMga2V5TG9hZGVyOiBMb2FkZXI8S2V5TG9hZGVyQ29udGV4dD4gfCBudWxsID0gbnVsbDtcbiAgLy8gVGhlIGxldmVsL3RyYWNrIGluZGV4IHRvIHdoaWNoIHRoZSBmcmFnbWVudCBiZWxvbmdzXG4gIHB1YmxpYyBsZXZlbDogbnVtYmVyID0gLTE7XG4gIC8vIFRoZSBjb250aW51aXR5IGNvdW50ZXIgb2YgdGhlIGZyYWdtZW50XG4gIHB1YmxpYyBjYzogbnVtYmVyID0gMDtcbiAgLy8gVGhlIHN0YXJ0aW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICBwdWJsaWMgc3RhcnRQVFM/OiBudW1iZXI7XG4gIC8vIFRoZSBlbmRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIHB1YmxpYyBlbmRQVFM/OiBudW1iZXI7XG4gIC8vIFRoZSBzdGFydGluZyBEZWNvZGUgVGltZSBTdGFtcCAoRFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgcHVibGljIHN0YXJ0RFRTITogbnVtYmVyO1xuICAvLyBUaGUgZW5kaW5nIERlY29kZSBUaW1lIFN0YW1wIChEVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICBwdWJsaWMgZW5kRFRTITogbnVtYmVyO1xuICAvLyBUaGUgc3RhcnQgdGltZSBvZiB0aGUgZnJhZ21lbnQsIGFzIGxpc3RlZCBpbiB0aGUgbWFuaWZlc3QuIFVwZGF0ZWQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIHB1YmxpYyBzdGFydDogbnVtYmVyID0gMDtcbiAgLy8gU2V0IGJ5IGB1cGRhdGVGcmFnUFRTRFRTYCBpbiBsZXZlbC1oZWxwZXJcbiAgcHVibGljIGRlbHRhUFRTPzogbnVtYmVyO1xuICAvLyBUaGUgbWF4aW11bSBzdGFydGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoYXVkaW8vdmlkZW8gUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgcHVibGljIG1heFN0YXJ0UFRTPzogbnVtYmVyO1xuICAvLyBUaGUgbWluaW11bSBlbmRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIHB1YmxpYyBtaW5FbmRQVFM/OiBudW1iZXI7XG4gIC8vIExvYWQvcGFyc2UgdGltaW5nIGluZm9ybWF0aW9uXG4gIHB1YmxpYyBzdGF0czogTG9hZFN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICBwdWJsaWMgdXJsSWQ6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBkYXRhPzogVWludDhBcnJheTtcbiAgLy8gQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgc2VnbWVudCB3YXMgZG93bmxvYWRlZCBpbiBvcmRlciB0byB0ZXN0IGJpdHJhdGUsIGFuZCB3YXMgbm90IGJ1ZmZlcmVkXG4gIHB1YmxpYyBiaXRyYXRlVGVzdDogYm9vbGVhbiA9IGZhbHNlO1xuICAvLyAjRVhUSU5GICBzZWdtZW50IHRpdGxlXG4gIHB1YmxpYyB0aXRsZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIC8vIFRoZSBNZWRpYSBJbml0aWFsaXphdGlvbiBTZWN0aW9uIGZvciB0aGlzIHNlZ21lbnRcbiAgcHVibGljIGluaXRTZWdtZW50OiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICAvLyBGcmFnbWVudCBpcyB0aGUgbGFzdCBmcmFnbWVudCBpbiB0aGUgbWVkaWEgcGxheWxpc3RcbiAgcHVibGljIGVuZExpc3Q/OiBib29sZWFuO1xuICAvLyBGcmFnbWVudCBpcyBtYXJrZWQgYnkgYW4gRVhULVgtR0FQIHRhZyBpbmRpY2F0aW5nIHRoYXQgaXQgZG9lcyBub3QgY29udGFpbiBtZWRpYSBkYXRhIGFuZCBzaG91bGQgbm90IGJlIGxvYWRlZFxuICBwdWJsaWMgZ2FwPzogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcih0eXBlOiBQbGF5bGlzdExldmVsVHlwZSwgYmFzZXVybDogc3RyaW5nKSB7XG4gICAgc3VwZXIoYmFzZXVybCk7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIGdldCBkZWNyeXB0ZGF0YSgpOiBMZXZlbEtleSB8IG51bGwge1xuICAgIGNvbnN0IHsgbGV2ZWxrZXlzIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxrZXlzICYmICF0aGlzLl9kZWNyeXB0ZGF0YSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSAmJiB0aGlzLmxldmVsa2V5cyAmJiAhdGhpcy5sZXZlbGtleXMuTk9ORSkge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5sZXZlbGtleXMuaWRlbnRpdHk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0ga2V5LmdldERlY3J5cHREYXRhKHRoaXMuc24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgICAgaWYgKGtleUZvcm1hdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLl9kZWNyeXB0ZGF0YSA9IHRoaXMubGV2ZWxrZXlzW1xuICAgICAgICAgICAga2V5Rm9ybWF0c1swXVxuICAgICAgICAgIF0uZ2V0RGVjcnlwdERhdGEodGhpcy5zbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE11bHRpcGxlIGtleXMuIGtleS1sb2FkZXIgdG8gY2FsbCBGcmFnbWVudC5zZXRLZXlGb3JtYXQgYmFzZWQgb24gc2VsZWN0ZWQga2V5LXN5c3RlbS5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kZWNyeXB0ZGF0YTtcbiAgfVxuXG4gIGdldCBlbmQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gIH1cblxuICBnZXQgZW5kUHJvZ3JhbURhdGVUaW1lKCkge1xuICAgIGlmICh0aGlzLnByb2dyYW1EYXRlVGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodGhpcy5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBkdXJhdGlvbiA9ICFOdW1iZXIuaXNGaW5pdGUodGhpcy5kdXJhdGlvbikgPyAwIDogdGhpcy5kdXJhdGlvbjtcblxuICAgIHJldHVybiB0aGlzLnByb2dyYW1EYXRlVGltZSArIGR1cmF0aW9uICogMTAwMDtcbiAgfVxuXG4gIGdldCBlbmNyeXB0ZWQoKSB7XG4gICAgLy8gQXQgdGhlIG0zdTgtcGFyc2VyIGxldmVsIHdlIG5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG1hbmlmZXN0IHNpZ25hbGxlZCBrZXlmb3JtYXRzXG4gICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBmcmFnbWVudCB0byBzdGFydCByZXBvcnRpbmcgdGhhdCBpdCBpcyBlbmNyeXB0ZWQuXG4gICAgLy8gQ3VycmVudGx5LCBrZXlGb3JtYXQgd2lsbCBvbmx5IGJlIHNldCBmb3IgaWRlbnRpdHkga2V5c1xuICAgIGlmICh0aGlzLl9kZWNyeXB0ZGF0YT8uZW5jcnlwdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGV2ZWxrZXlzKSB7XG4gICAgICBjb25zdCBrZXlGb3JtYXRzID0gT2JqZWN0LmtleXModGhpcy5sZXZlbGtleXMpO1xuICAgICAgY29uc3QgbGVuID0ga2V5Rm9ybWF0cy5sZW5ndGg7XG4gICAgICBpZiAobGVuID4gMSB8fCAobGVuID09PSAxICYmIHRoaXMubGV2ZWxrZXlzW2tleUZvcm1hdHNbMF1dLmVuY3J5cHRlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc2V0S2V5Rm9ybWF0KGtleUZvcm1hdDogS2V5U3lzdGVtRm9ybWF0cykge1xuICAgIGlmICh0aGlzLmxldmVsa2V5cykge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0XTtcbiAgICAgIGlmIChrZXkgJiYgIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0ga2V5LmdldERlY3J5cHREYXRhKHRoaXMuc24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFib3J0UmVxdWVzdHMoKTogdm9pZCB7XG4gICAgdGhpcy5sb2FkZXI/LmFib3J0KCk7XG4gICAgdGhpcy5rZXlMb2FkZXI/LmFib3J0KCk7XG4gIH1cblxuICBzZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhcbiAgICB0eXBlOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMsXG4gICAgc3RhcnRQVFM6IG51bWJlcixcbiAgICBlbmRQVFM6IG51bWJlcixcbiAgICBzdGFydERUUzogbnVtYmVyLFxuICAgIGVuZERUUzogbnVtYmVyLFxuICAgIHBhcnRpYWw6IGJvb2xlYW4gPSBmYWxzZVxuICApIHtcbiAgICBjb25zdCB7IGVsZW1lbnRhcnlTdHJlYW1zIH0gPSB0aGlzO1xuICAgIGNvbnN0IGluZm8gPSBlbGVtZW50YXJ5U3RyZWFtc1t0eXBlXTtcbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zW3R5cGVdID0ge1xuICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgZW5kUFRTLFxuICAgICAgICBzdGFydERUUyxcbiAgICAgICAgZW5kRFRTLFxuICAgICAgICBwYXJ0aWFsLFxuICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmZvLnN0YXJ0UFRTID0gTWF0aC5taW4oaW5mby5zdGFydFBUUywgc3RhcnRQVFMpO1xuICAgIGluZm8uZW5kUFRTID0gTWF0aC5tYXgoaW5mby5lbmRQVFMsIGVuZFBUUyk7XG4gICAgaW5mby5zdGFydERUUyA9IE1hdGgubWluKGluZm8uc3RhcnREVFMsIHN0YXJ0RFRTKTtcbiAgICBpbmZvLmVuZERUUyA9IE1hdGgubWF4KGluZm8uZW5kRFRTLCBlbmREVFMpO1xuICB9XG5cbiAgY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpIHtcbiAgICBjb25zdCB7IGVsZW1lbnRhcnlTdHJlYW1zIH0gPSB0aGlzO1xuICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT10gPSBudWxsO1xuICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10gPSBudWxsO1xuICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXSA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIFBhcnRpYWwgU2VnbWVudC4gRm91bmQgaW4ge0BsaW5rIGhscy5qcyNMZXZlbERldGFpbHMucGFydExpc3R9LlxuICovXG5leHBvcnQgY2xhc3MgUGFydCBleHRlbmRzIEJhc2VTZWdtZW50IHtcbiAgcHVibGljIHJlYWRvbmx5IGZyYWdPZmZzZXQ6IG51bWJlciA9IDA7XG4gIHB1YmxpYyByZWFkb25seSBkdXJhdGlvbjogbnVtYmVyID0gMDtcbiAgcHVibGljIHJlYWRvbmx5IGdhcDogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgcmVhZG9ubHkgaW5kZXBlbmRlbnQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIHJlYWRvbmx5IHJlbHVybDogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgZnJhZ21lbnQ6IEZyYWdtZW50O1xuICBwdWJsaWMgcmVhZG9ubHkgaW5kZXg6IG51bWJlcjtcbiAgcHVibGljIHN0YXRzOiBMb2FkU3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcGFydEF0dHJzOiBBdHRyTGlzdCxcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBiYXNldXJsOiBzdHJpbmcsXG4gICAgaW5kZXg6IG51bWJlcixcbiAgICBwcmV2aW91cz86IFBhcnRcbiAgKSB7XG4gICAgc3VwZXIoYmFzZXVybCk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IHBhcnRBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnRFVSQVRJT04nKTtcbiAgICB0aGlzLmdhcCA9IHBhcnRBdHRycy5ib29sKCdHQVAnKTtcbiAgICB0aGlzLmluZGVwZW5kZW50ID0gcGFydEF0dHJzLmJvb2woJ0lOREVQRU5ERU5UJyk7XG4gICAgdGhpcy5yZWx1cmwgPSBwYXJ0QXR0cnMuZW51bWVyYXRlZFN0cmluZygnVVJJJykgYXMgc3RyaW5nO1xuICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICBjb25zdCBieXRlUmFuZ2UgPSBwYXJ0QXR0cnMuZW51bWVyYXRlZFN0cmluZygnQllURVJBTkdFJyk7XG4gICAgaWYgKGJ5dGVSYW5nZSkge1xuICAgICAgdGhpcy5zZXRCeXRlUmFuZ2UoYnl0ZVJhbmdlLCBwcmV2aW91cyk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91cykge1xuICAgICAgdGhpcy5mcmFnT2Zmc2V0ID0gcHJldmlvdXMuZnJhZ09mZnNldCArIHByZXZpb3VzLmR1cmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzdGFydCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50LnN0YXJ0ICsgdGhpcy5mcmFnT2Zmc2V0O1xuICB9XG5cbiAgZ2V0IGVuZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvbjtcbiAgfVxuXG4gIGdldCBsb2FkZWQoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyBlbGVtZW50YXJ5U3RyZWFtcyB9ID0gdGhpcztcbiAgICByZXR1cm4gISEoXG4gICAgICBlbGVtZW50YXJ5U3RyZWFtcy5hdWRpbyB8fFxuICAgICAgZWxlbWVudGFyeVN0cmVhbXMudmlkZW8gfHxcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zLmF1ZGlvdmlkZW9cbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBQYXJ0IH0gZnJvbSAnLi9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IEZyYWdtZW50IH0gZnJvbSAnLi9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IEF0dHJMaXN0IH0gZnJvbSAnLi4vdXRpbHMvYXR0ci1saXN0JztcbmltcG9ydCB0eXBlIHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi9kYXRlLXJhbmdlJztcbmltcG9ydCB0eXBlIHsgVmFyaWFibGVNYXAgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5cbmNvbnN0IERFRkFVTFRfVEFSR0VUX0RVUkFUSU9OID0gMTA7XG5cbi8qKlxuICogT2JqZWN0IHJlcHJlc2VudGluZyBwYXJzZWQgZGF0YSBmcm9tIGFuIEhMUyBNZWRpYSBQbGF5bGlzdC4gRm91bmQgaW4ge0BsaW5rIGhscy5qcyNMZXZlbC5kZXRhaWxzfS5cbiAqL1xuZXhwb3J0IGNsYXNzIExldmVsRGV0YWlscyB7XG4gIHB1YmxpYyBQVFNLbm93bjogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgYWxpZ25lZFNsaWRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIGF2ZXJhZ2V0YXJnZXRkdXJhdGlvbj86IG51bWJlcjtcbiAgcHVibGljIGVuZENDOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgZW5kU046IG51bWJlciA9IDA7XG4gIHB1YmxpYyBmcmFnbWVudHM6IEZyYWdtZW50W107XG4gIHB1YmxpYyBmcmFnbWVudEhpbnQ/OiBGcmFnbWVudDtcbiAgcHVibGljIHBhcnRMaXN0OiBQYXJ0W10gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGRhdGVSYW5nZXM6IFJlY29yZDxzdHJpbmcsIERhdGVSYW5nZT47XG4gIHB1YmxpYyBsaXZlOiBib29sZWFuID0gdHJ1ZTtcbiAgcHVibGljIGFnZUhlYWRlcjogbnVtYmVyID0gMDtcbiAgcHVibGljIGFkdmFuY2VkRGF0ZVRpbWU/OiBudW1iZXI7XG4gIHB1YmxpYyB1cGRhdGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgcHVibGljIGFkdmFuY2VkOiBib29sZWFuID0gdHJ1ZTtcbiAgcHVibGljIGF2YWlsYWJpbGl0eURlbGF5PzogbnVtYmVyOyAvLyBNYW5pZmVzdCByZWxvYWQgc3luY2hyb25pemF0aW9uXG4gIHB1YmxpYyBtaXNzZXM6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBzdGFydENDOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgc3RhcnRTTjogbnVtYmVyID0gMDtcbiAgcHVibGljIHN0YXJ0VGltZU9mZnNldDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyB0YXJnZXRkdXJhdGlvbjogbnVtYmVyID0gMDtcbiAgcHVibGljIHRvdGFsZHVyYXRpb246IG51bWJlciA9IDA7XG4gIHB1YmxpYyB0eXBlOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIHVybDogc3RyaW5nO1xuICBwdWJsaWMgbTN1ODogc3RyaW5nID0gJyc7XG4gIHB1YmxpYyB2ZXJzaW9uOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNhbkJsb2NrUmVsb2FkOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBjYW5Ta2lwVW50aWw6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBjYW5Ta2lwRGF0ZVJhbmdlczogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgc2tpcHBlZFNlZ21lbnRzOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcz86IHN0cmluZ1tdO1xuICBwdWJsaWMgcGFydEhvbGRCYWNrOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgaG9sZEJhY2s6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBwYXJ0VGFyZ2V0OiBudW1iZXIgPSAwO1xuICBwdWJsaWMgcHJlbG9hZEhpbnQ/OiBBdHRyTGlzdDtcbiAgcHVibGljIHJlbmRpdGlvblJlcG9ydHM/OiBBdHRyTGlzdFtdO1xuICBwdWJsaWMgdHVuZUluR29hbDogbnVtYmVyID0gMDtcbiAgcHVibGljIGRlbHRhVXBkYXRlRmFpbGVkPzogYm9vbGVhbjtcbiAgcHVibGljIGRyaWZ0U3RhcnRUaW1lOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgZHJpZnRFbmRUaW1lOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgZHJpZnRTdGFydDogbnVtYmVyID0gMDtcbiAgcHVibGljIGRyaWZ0RW5kOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgZW5jcnlwdGVkRnJhZ21lbnRzOiBGcmFnbWVudFtdO1xuICBwdWJsaWMgcGxheWxpc3RQYXJzaW5nRXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyB2YXJpYWJsZUxpc3Q6IFZhcmlhYmxlTWFwIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBoYXNWYXJpYWJsZVJlZnMgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihiYXNlVXJsKSB7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBbXTtcbiAgICB0aGlzLmVuY3J5cHRlZEZyYWdtZW50cyA9IFtdO1xuICAgIHRoaXMuZGF0ZVJhbmdlcyA9IHt9O1xuICAgIHRoaXMudXJsID0gYmFzZVVybDtcbiAgfVxuXG4gIHJlbG9hZGVkKHByZXZpb3VzOiBMZXZlbERldGFpbHMgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoIXByZXZpb3VzKSB7XG4gICAgICB0aGlzLmFkdmFuY2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnRTbkRpZmYgPSB0aGlzLmxhc3RQYXJ0U24gLSBwcmV2aW91cy5sYXN0UGFydFNuO1xuICAgIGNvbnN0IHBhcnRJbmRleERpZmYgPSB0aGlzLmxhc3RQYXJ0SW5kZXggLSBwcmV2aW91cy5sYXN0UGFydEluZGV4O1xuICAgIHRoaXMudXBkYXRlZCA9XG4gICAgICB0aGlzLmVuZFNOICE9PSBwcmV2aW91cy5lbmRTTiB8fCAhIXBhcnRJbmRleERpZmYgfHwgISFwYXJ0U25EaWZmO1xuICAgIHRoaXMuYWR2YW5jZWQgPVxuICAgICAgdGhpcy5lbmRTTiA+IHByZXZpb3VzLmVuZFNOIHx8XG4gICAgICBwYXJ0U25EaWZmID4gMCB8fFxuICAgICAgKHBhcnRTbkRpZmYgPT09IDAgJiYgcGFydEluZGV4RGlmZiA+IDApO1xuICAgIGlmICh0aGlzLnVwZGF0ZWQgfHwgdGhpcy5hZHZhbmNlZCkge1xuICAgICAgdGhpcy5taXNzZXMgPSBNYXRoLmZsb29yKHByZXZpb3VzLm1pc3NlcyAqIDAuNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWlzc2VzID0gcHJldmlvdXMubWlzc2VzICsgMTtcbiAgICB9XG4gICAgdGhpcy5hdmFpbGFiaWxpdHlEZWxheSA9IHByZXZpb3VzLmF2YWlsYWJpbGl0eURlbGF5O1xuICB9XG5cbiAgZ2V0IGhhc1Byb2dyYW1EYXRlVGltZSgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKFxuICAgICAgICB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5wcm9ncmFtRGF0ZVRpbWUgYXMgbnVtYmVyXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXQgbGV2ZWxUYXJnZXREdXJhdGlvbigpOiBudW1iZXIge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiB8fFxuICAgICAgdGhpcy50YXJnZXRkdXJhdGlvbiB8fFxuICAgICAgREVGQVVMVF9UQVJHRVRfRFVSQVRJT05cbiAgICApO1xuICB9XG5cbiAgZ2V0IGRyaWZ0KCk6IG51bWJlciB7XG4gICAgY29uc3QgcnVuVGltZSA9IHRoaXMuZHJpZnRFbmRUaW1lIC0gdGhpcy5kcmlmdFN0YXJ0VGltZTtcbiAgICBpZiAocnVuVGltZSA+IDApIHtcbiAgICAgIGNvbnN0IHJ1bkR1cmF0aW9uID0gdGhpcy5kcmlmdEVuZCAtIHRoaXMuZHJpZnRTdGFydDtcbiAgICAgIHJldHVybiAocnVuRHVyYXRpb24gKiAxMDAwKSAvIHJ1blRpbWU7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgZ2V0IGVkZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0RW5kIHx8IHRoaXMuZnJhZ21lbnRFbmQ7XG4gIH1cblxuICBnZXQgcGFydEVuZCgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLnBhcnRMaXN0Py5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZW5kO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudEVuZDtcbiAgfVxuXG4gIGdldCBmcmFnbWVudEVuZCgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmZyYWdtZW50cz8ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldCBhZ2UoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5hZHZhbmNlZERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoRGF0ZS5ub3coKSAtIHRoaXMuYWR2YW5jZWREYXRlVGltZSwgMCkgLyAxMDAwO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldCBsYXN0UGFydEluZGV4KCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMucGFydExpc3Q/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5pbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZ2V0IGxhc3RQYXJ0U24oKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5wYXJ0TGlzdD8ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmZyYWdtZW50LnNuIGFzIG51bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW5kU047XG4gIH1cbn1cbiIsIi8vIFRoaXMgZmlsZSBpcyBpbnNlcnRlZCBhcyBhIHNoaW0gZm9yIG1vZHVsZXMgd2hpY2ggd2UgZG8gbm90IHdhbnQgdG8gaW5jbHVkZSBpbnRvIHRoZSBkaXN0cm8uXG4vLyBUaGlzIHJlcGxhY2VtZW50IGlzIGRvbmUgaW4gdGhlIFwiYWxpYXNcIiBwbHVnaW4gb2YgdGhlIHJvbGx1cCBjb25maWcuXG5tb2R1bGUuZXhwb3J0cyA9IHVuZGVmaW5lZDtcbiIsImV4cG9ydCBmdW5jdGlvbiBzbGljZVVpbnQ4KFxuICBhcnJheTogVWludDhBcnJheSxcbiAgc3RhcnQ/OiBudW1iZXIsXG4gIGVuZD86IG51bWJlclxuKTogVWludDhBcnJheSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBwb2x5ZmlsbHMgSUUxMSB1c2FnZSBvZiBVaW50OEFycmF5IHNsaWNlLlxuICAvLyBJdCBhbHdheXMgZXhpc3RzIGluIHRoZSBUeXBlU2NyaXB0IGRlZmluaXRpb24gc28gZmFpbHMsIGJ1dCBpdCBmYWlscyBhdCBydW50aW1lIG9uIElFMTEuXG4gIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgID8gYXJyYXkuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICA6IG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5LCBzdGFydCwgZW5kKSk7XG59XG4iLCJ0eXBlIFJhd0ZyYW1lID0geyB0eXBlOiBzdHJpbmc7IHNpemU6IG51bWJlcjsgZGF0YTogVWludDhBcnJheSB9O1xuXG4vLyBicmVha2luZyB1cCB0aG9zZSB0d28gdHlwZXMgaW4gb3JkZXIgdG8gY2xhcmlmeSB3aGF0IGlzIGhhcHBlbmluZyBpbiB0aGUgZGVjb2RpbmcgcGF0aC5cbnR5cGUgRGVjb2RlZEZyYW1lPFQ+ID0geyBrZXk6IHN0cmluZzsgZGF0YTogVDsgaW5mbz86IGFueSB9O1xuZXhwb3J0IHR5cGUgRnJhbWUgPSBEZWNvZGVkRnJhbWU8QXJyYXlCdWZmZXIgfCBzdHJpbmc+O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2hcbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICovXG5leHBvcnQgY29uc3QgaXNIZWFkZXIgPSAoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgLypcbiAgICogaHR0cDovL2lkMy5vcmcvaWQzdjIuMy4wXG4gICAqIFswXSAgICAgPSAnSSdcbiAgICogWzFdICAgICA9ICdEJ1xuICAgKiBbMl0gICAgID0gJzMnXG4gICAqIFszLDRdICAgPSB7VmVyc2lvbn1cbiAgICogWzVdICAgICA9IHtGbGFnc31cbiAgICogWzYtOV0gICA9IHtJRDMgU2l6ZX1cbiAgICpcbiAgICogQW4gSUQzdjIgdGFnIGNhbiBiZSBkZXRlY3RlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcGF0dGVybjpcbiAgICogICQ0OSA0NCAzMyB5eSB5eSB4eCB6eiB6eiB6eiB6elxuICAgKiBXaGVyZSB5eSBpcyBsZXNzIHRoYW4gJEZGLCB4eCBpcyB0aGUgJ2ZsYWdzJyBieXRlIGFuZCB6eiBpcyBsZXNzIHRoYW4gJDgwXG4gICAqL1xuICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBsb29rIGZvciAnSUQzJyBpZGVudGlmaWVyXG4gICAgaWYgKFxuICAgICAgZGF0YVtvZmZzZXRdID09PSAweDQ5ICYmXG4gICAgICBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmXG4gICAgICBkYXRhW29mZnNldCArIDJdID09PSAweDMzXG4gICAgKSB7XG4gICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweGZmICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweGZmKSB7XG4gICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChcbiAgICAgICAgICBkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJlxuICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmXG4gICAgICAgICAgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiZcbiAgICAgICAgICBkYXRhW29mZnNldCArIDldIDwgMHg4MFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBmb290ZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaFxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Zvb3RlciA9IChkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICAvKlxuICAgKiBUaGUgZm9vdGVyIGlzIGEgY29weSBvZiB0aGUgaGVhZGVyLCBidXQgd2l0aCBhIGRpZmZlcmVudCBpZGVudGlmaWVyXG4gICAqL1xuICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBsb29rIGZvciAnM0RJJyBpZGVudGlmaWVyXG4gICAgaWYgKFxuICAgICAgZGF0YVtvZmZzZXRdID09PSAweDMzICYmXG4gICAgICBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmXG4gICAgICBkYXRhW29mZnNldCArIDJdID09PSAweDQ5XG4gICAgKSB7XG4gICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweGZmICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweGZmKSB7XG4gICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChcbiAgICAgICAgICBkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJlxuICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmXG4gICAgICAgICAgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiZcbiAgICAgICAgICBkYXRhW29mZnNldCArIDldIDwgMHg4MFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbnkgYWRqYWNlbnQgSUQzIHRhZ3MgZm91bmQgaW4gZGF0YSBzdGFydGluZyBhdCBvZmZzZXQsIGFzIG9uZSBibG9jayBvZiBkYXRhXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gKiBAcmV0dXJucyB0aGUgYmxvY2sgb2YgZGF0YSBjb250YWluaW5nIGFueSBJRDMgdGFncyBmb3VuZFxuICogb3IgKnVuZGVmaW5lZCogaWYgbm8gaGVhZGVyIGlzIGZvdW5kIGF0IHRoZSBzdGFydGluZyBvZmZzZXRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldElEM0RhdGEgPSAoXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4gIG9mZnNldDogbnVtYmVyXG4pOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkID0+IHtcbiAgY29uc3QgZnJvbnQgPSBvZmZzZXQ7XG4gIGxldCBsZW5ndGggPSAwO1xuXG4gIHdoaWxlIChpc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gSUQzIGhlYWRlciBpcyAxMCBieXRlc1xuICAgIGxlbmd0aCArPSAxMDtcblxuICAgIGNvbnN0IHNpemUgPSByZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KTtcbiAgICBsZW5ndGggKz0gc2l6ZTtcblxuICAgIGlmIChpc0Zvb3RlcihkYXRhLCBvZmZzZXQgKyAxMCkpIHtcbiAgICAgIC8vIElEMyBmb290ZXIgaXMgMTAgYnl0ZXNcbiAgICAgIGxlbmd0aCArPSAxMDtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZGF0YS5zdWJhcnJheShmcm9udCwgZnJvbnQgKyBsZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IHJlYWRTaXplID0gKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgbGV0IHNpemUgPSAwO1xuICBzaXplID0gKGRhdGFbb2Zmc2V0XSAmIDB4N2YpIDw8IDIxO1xuICBzaXplIHw9IChkYXRhW29mZnNldCArIDFdICYgMHg3ZikgPDwgMTQ7XG4gIHNpemUgfD0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDdmKSA8PCA3O1xuICBzaXplIHw9IGRhdGFbb2Zmc2V0ICsgM10gJiAweDdmO1xuICByZXR1cm4gc2l6ZTtcbn07XG5cbmV4cG9ydCBjb25zdCBjYW5QYXJzZSA9IChkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gKFxuICAgIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkgJiZcbiAgICByZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KSArIDEwIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0XG4gICk7XG59O1xuXG4vKipcbiAqIFNlYXJjaGVzIGZvciB0aGUgRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZvdW5kIGluIHRoZSBJRDMgZGF0YSBjaHVua1xuICogQHBhcmFtIGRhdGEgLSBCbG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFRpbWVTdGFtcCA9IChkYXRhOiBVaW50OEFycmF5KTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgY29uc3QgZnJhbWVzOiBGcmFtZVtdID0gZ2V0SUQzRnJhbWVzKGRhdGEpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbaV07XG5cbiAgICBpZiAoaXNUaW1lU3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgIHJldHVybiByZWFkVGltZVN0YW1wKGZyYW1lIGFzIERlY29kZWRGcmFtZTxBcnJheUJ1ZmZlcj4pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxuICovXG5leHBvcnQgY29uc3QgaXNUaW1lU3RhbXBGcmFtZSA9IChmcmFtZTogRnJhbWUpOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIChcbiAgICBmcmFtZSAmJlxuICAgIGZyYW1lLmtleSA9PT0gJ1BSSVYnICYmXG4gICAgZnJhbWUuaW5mbyA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJ1xuICApO1xufTtcblxuY29uc3QgZ2V0RnJhbWVEYXRhID0gKGRhdGE6IFVpbnQ4QXJyYXkpOiBSYXdGcmFtZSA9PiB7XG4gIC8qXG4gIEZyYW1lIElEICAgICAgICR4eCB4eCB4eCB4eCAoZm91ciBjaGFyYWN0ZXJzKVxuICBTaXplICAgICAgICAgICAkeHggeHggeHggeHhcbiAgRmxhZ3MgICAgICAgICAgJHh4IHh4XG4gICovXG4gIGNvbnN0IHR5cGU6IHN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSk7XG4gIGNvbnN0IHNpemU6IG51bWJlciA9IHJlYWRTaXplKGRhdGEsIDQpO1xuXG4gIC8vIHNraXAgZnJhbWUgaWQsIHNpemUsIGFuZCBmbGFnc1xuICBjb25zdCBvZmZzZXQgPSAxMDtcblxuICByZXR1cm4geyB0eXBlLCBzaXplLCBkYXRhOiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSkgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBJRDMgZnJhbWVzIGZvdW5kIGluIGFsbCB0aGUgSUQzIHRhZ3MgaW4gdGhlIGlkM0RhdGFcbiAqIEBwYXJhbSBpZDNEYXRhIC0gVGhlIElEMyBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IGdldElEM0ZyYW1lcyA9IChpZDNEYXRhOiBVaW50OEFycmF5KTogRnJhbWVbXSA9PiB7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCBmcmFtZXM6IEZyYW1lW10gPSBbXTtcblxuICB3aGlsZSAoaXNIZWFkZXIoaWQzRGF0YSwgb2Zmc2V0KSkge1xuICAgIGNvbnN0IHNpemUgPSByZWFkU2l6ZShpZDNEYXRhLCBvZmZzZXQgKyA2KTtcbiAgICAvLyBza2lwIHBhc3QgSUQzIGhlYWRlclxuICAgIG9mZnNldCArPSAxMDtcbiAgICBjb25zdCBlbmQgPSBvZmZzZXQgKyBzaXplO1xuICAgIC8vIGxvb3AgdGhyb3VnaCBmcmFtZXMgaW4gdGhlIElEMyB0YWdcbiAgICB3aGlsZSAob2Zmc2V0ICsgOCA8IGVuZCkge1xuICAgICAgY29uc3QgZnJhbWVEYXRhOiBSYXdGcmFtZSA9IGdldEZyYW1lRGF0YShpZDNEYXRhLnN1YmFycmF5KG9mZnNldCkpO1xuICAgICAgY29uc3QgZnJhbWU6IEZyYW1lIHwgdW5kZWZpbmVkID0gZGVjb2RlRnJhbWUoZnJhbWVEYXRhKTtcbiAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXAgZnJhbWUgaGVhZGVyIGFuZCBmcmFtZSBkYXRhXG4gICAgICBvZmZzZXQgKz0gZnJhbWVEYXRhLnNpemUgKyAxMDtcbiAgICB9XG5cbiAgICBpZiAoaXNGb290ZXIoaWQzRGF0YSwgb2Zmc2V0KSkge1xuICAgICAgb2Zmc2V0ICs9IDEwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmcmFtZXM7XG59O1xuXG5leHBvcnQgY29uc3QgZGVjb2RlRnJhbWUgPSAoZnJhbWU6IFJhd0ZyYW1lKTogRnJhbWUgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAoZnJhbWUudHlwZSA9PT0gJ1BSSVYnKSB7XG4gICAgcmV0dXJuIGRlY29kZVByaXZGcmFtZShmcmFtZSk7XG4gIH0gZWxzZSBpZiAoZnJhbWUudHlwZVswXSA9PT0gJ1cnKSB7XG4gICAgcmV0dXJuIGRlY29kZVVSTEZyYW1lKGZyYW1lKTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVUZXh0RnJhbWUoZnJhbWUpO1xufTtcblxuY29uc3QgZGVjb2RlUHJpdkZyYW1lID0gKFxuICBmcmFtZTogUmF3RnJhbWVcbik6IERlY29kZWRGcmFtZTxBcnJheUJ1ZmZlcj4gfCB1bmRlZmluZWQgPT4ge1xuICAvKlxuICBGb3JtYXQ6IDx0ZXh0IHN0cmluZz5cXDA8YmluYXJ5IGRhdGE+XG4gICovXG4gIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBvd25lciA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEsIHRydWUpO1xuICBjb25zdCBwcml2YXRlRGF0YSA9IG5ldyBVaW50OEFycmF5KGZyYW1lLmRhdGEuc3ViYXJyYXkob3duZXIubGVuZ3RoICsgMSkpO1xuXG4gIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgaW5mbzogb3duZXIsIGRhdGE6IHByaXZhdGVEYXRhLmJ1ZmZlciB9O1xufTtcblxuY29uc3QgZGVjb2RlVGV4dEZyYW1lID0gKGZyYW1lOiBSYXdGcmFtZSk6IERlY29kZWRGcmFtZTxzdHJpbmc+IHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChmcmFtZS50eXBlID09PSAnVFhYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtWYWx1ZX1cbiAgICAqL1xuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG5cbiAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHZhbHVlID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuXG4gICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBkZXNjcmlwdGlvbiwgZGF0YTogdmFsdWUgfTtcbiAgfVxuICAvKlxuICBGb3JtYXQ6XG4gIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gIFsxLT9dID0ge1ZhbHVlfVxuICAqL1xuICBjb25zdCB0ZXh0ID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheSgxKSk7XG4gIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgZGF0YTogdGV4dCB9O1xufTtcblxuY29uc3QgZGVjb2RlVVJMRnJhbWUgPSAoZnJhbWU6IFJhd0ZyYW1lKTogRGVjb2RlZEZyYW1lPHN0cmluZz4gfCB1bmRlZmluZWQgPT4ge1xuICBpZiAoZnJhbWUudHlwZSA9PT0gJ1dYWFgnKSB7XG4gICAgLypcbiAgICBGb3JtYXQ6XG4gICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VVJMfVxuICAgICovXG4gICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb246IHN0cmluZyA9IHV0ZjhBcnJheVRvU3RyKFxuICAgICAgZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCksXG4gICAgICB0cnVlXG4gICAgKTtcblxuICAgIGluZGV4ICs9IGRlc2NyaXB0aW9uLmxlbmd0aCArIDE7XG4gICAgY29uc3QgdmFsdWU6IHN0cmluZyA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcblxuICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgaW5mbzogZGVzY3JpcHRpb24sIGRhdGE6IHZhbHVlIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMC0/XSA9IHtVUkx9XG4gICovXG4gIGNvbnN0IHVybDogc3RyaW5nID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YSk7XG4gIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgZGF0YTogdXJsIH07XG59O1xuXG5jb25zdCByZWFkVGltZVN0YW1wID0gKFxuICB0aW1lU3RhbXBGcmFtZTogRGVjb2RlZEZyYW1lPEFycmF5QnVmZmVyPlxuKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHRpbWVTdGFtcEZyYW1lLmRhdGEuYnl0ZUxlbmd0aCA9PT0gOCkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0aW1lU3RhbXBGcmFtZS5kYXRhKTtcbiAgICAvLyB0aW1lc3RhbXAgaXMgMzMgYml0IGV4cHJlc3NlZCBhcyBhIGJpZy1lbmRpYW4gZWlnaHQtb2N0ZXQgbnVtYmVyLFxuICAgIC8vIHdpdGggdGhlIHVwcGVyIDMxIGJpdHMgc2V0IHRvIHplcm8uXG4gICAgY29uc3QgcHRzMzNCaXQgPSBkYXRhWzNdICYgMHgxO1xuICAgIGxldCB0aW1lc3RhbXAgPVxuICAgICAgKGRhdGFbNF0gPDwgMjMpICsgKGRhdGFbNV0gPDwgMTUpICsgKGRhdGFbNl0gPDwgNykgKyBkYXRhWzddO1xuICAgIHRpbWVzdGFtcCAvPSA0NTtcblxuICAgIGlmIChwdHMzM0JpdCkge1xuICAgICAgdGltZXN0YW1wICs9IDQ3NzIxODU4Ljg0O1xuICAgIH0gLy8gMl4zMiAvIDkwXG5cbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lc3RhbXApO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkzNjk4NC91aW50OGFycmF5LXRvLXN0cmluZy1pbi1qYXZhc2NyaXB0LzIyMzczMTk3XG4vLyBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovYW11c2UvamF2YXNjcmlwdC9leHBlcnQvdXRmLnR4dFxuLyogdXRmLmpzIC0gVVRGLTggPD0+IFVURi0xNiBjb252ZXJ0aW9uXG4gKlxuICogQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cbiAqIFZlcnNpb246IDEuMFxuICogTGFzdE1vZGlmaWVkOiBEZWMgMjUgMTk5OVxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUuICBZb3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0LlxuICovXG5leHBvcnQgY29uc3QgdXRmOEFycmF5VG9TdHIgPSAoXG4gIGFycmF5OiBVaW50OEFycmF5LFxuICBleGl0T25OdWxsOiBib29sZWFuID0gZmFsc2Vcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBnZXRUZXh0RGVjb2RlcigpO1xuICBpZiAoZGVjb2Rlcikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShhcnJheSk7XG5cbiAgICBpZiAoZXhpdE9uTnVsbCkge1xuICAgICAgLy8gZ3JhYiB1cCB0byB0aGUgZmlyc3QgbnVsbFxuICAgICAgY29uc3QgaWR4ID0gZGVjb2RlZC5pbmRleE9mKCdcXDAnKTtcbiAgICAgIHJldHVybiBpZHggIT09IC0xID8gZGVjb2RlZC5zdWJzdHJpbmcoMCwgaWR4KSA6IGRlY29kZWQ7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFueSBudWxsIGNoYXJhY3RlcnNcbiAgICByZXR1cm4gZGVjb2RlZC5yZXBsYWNlKC9cXDAvZywgJycpO1xuICB9XG5cbiAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoO1xuICBsZXQgYztcbiAgbGV0IGNoYXIyO1xuICBsZXQgY2hhcjM7XG4gIGxldCBvdXQgPSAnJztcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGMgPSBhcnJheVtpKytdO1xuICAgIGlmIChjID09PSAweDAwICYmIGV4aXRPbk51bGwpIHtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIGlmIChjID09PSAweDAwIHx8IGMgPT09IDB4MDMpIHtcbiAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgMyAoRU5EX09GX1RFWFQpIG9yIDAgKE5VTEwpIHRoZW4gc2tpcCBpdFxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHN3aXRjaCAoYyA+PiA0KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDE6XG4gICAgICBjYXNlIDI6XG4gICAgICBjYXNlIDM6XG4gICAgICBjYXNlIDQ6XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIDY6XG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8vIDB4eHh4eHh4XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI6XG4gICAgICBjYXNlIDEzOlxuICAgICAgICAvLyAxMTB4IHh4eHggICAxMHh4IHh4eHhcbiAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDFmKSA8PCA2KSB8IChjaGFyMiAmIDB4M2YpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE0OlxuICAgICAgICAvLyAxMTEwIHh4eHggIDEweHggeHh4eCAgMTB4eCB4eHh4XG4gICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgY2hhcjMgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgICAoKGMgJiAweDBmKSA8PCAxMikgfCAoKGNoYXIyICYgMHgzZikgPDwgNikgfCAoKGNoYXIzICYgMHgzZikgPDwgMClcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuZXhwb3J0IGNvbnN0IHRlc3RhYmxlcyA9IHtcbiAgZGVjb2RlVGV4dEZyYW1lOiBkZWNvZGVUZXh0RnJhbWUsXG59O1xuXG5sZXQgZGVjb2RlcjogVGV4dERlY29kZXI7XG5cbmZ1bmN0aW9uIGdldFRleHREZWNvZGVyKCkge1xuICBpZiAoIWRlY29kZXIgJiYgdHlwZW9mIHNlbGYuVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVjb2RlciA9IG5ldyBzZWxmLlRleHREZWNvZGVyKCd1dGYtOCcpO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZXI7XG59XG4iLCIvKipcbiAqICBoZXggZHVtcCBoZWxwZXIgY2xhc3NcbiAqL1xuXG5jb25zdCBIZXggPSB7XG4gIGhleER1bXA6IGZ1bmN0aW9uIChhcnJheTogVWludDhBcnJheSkge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaCA9IGFycmF5W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICB9XG5cbiAgICAgIHN0ciArPSBoO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgSGV4O1xuIiwiaW1wb3J0IHsgRWxlbWVudGFyeVN0cmVhbVR5cGVzIH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB7IHNsaWNlVWludDggfSBmcm9tICcuL3R5cGVkLWFycmF5JztcbmltcG9ydCB7IHV0ZjhBcnJheVRvU3RyIH0gZnJvbSAnLi4vZGVtdXgvaWQzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgSGV4IGZyb20gJy4vaGV4JztcbmltcG9ydCB0eXBlIHsgUGFzc3Rocm91Z2hUcmFjaywgVXNlcmRhdGFTYW1wbGUgfSBmcm9tICcuLi90eXBlcy9kZW11eGVyJztcbmltcG9ydCB0eXBlIHsgRGVjcnlwdERhdGEgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwta2V5JztcblxuY29uc3QgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5jb25zdCBwdXNoID0gW10ucHVzaDtcblxuLy8gV2UgYXJlIHVzaW5nIGZpeGVkIHRyYWNrIElEcyBmb3IgZHJpdmluZyB0aGUgTVA0IHJlbXV4ZXJcbi8vIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBUUyBQSURzLlxuLy8gVGhlcmUgaXMgbm8gcmVhc29uIG5vdCB0byBkbyB0aGlzIGFuZCBzb21lIGJyb3dzZXJzL1NvdXJjZUJ1ZmZlci1kZW11eGVyc1xuLy8gbWF5IG5vdCBsaWtlIGlmIHRoZXJlIGFyZSBUcmFja0lEIFwic3dpdGNoZXNcIlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8xMzMxXG4vLyBIZXJlIHdlIGFyZSBtYXBwaW5nIG91ciBpbnRlcm5hbCB0cmFjayB0eXBlcyB0byBjb25zdGFudCBNUDQgdHJhY2sgSURzXG4vLyBXaXRoIE1TRSBjdXJyZW50bHkgb25lIGNhbiBvbmx5IGhhdmUgb25lIHRyYWNrIG9mIGVhY2gsIGFuZCB3ZSBhcmUgbXV4aW5nXG4vLyB3aGF0ZXZlciB2aWRlby9hdWRpbyByZW5kaXRpb24gaW4gdGhlbS5cbmV4cG9ydCBjb25zdCBSZW11eGVyVHJhY2tJZENvbmZpZyA9IHtcbiAgdmlkZW86IDEsXG4gIGF1ZGlvOiAyLFxuICBpZDM6IDMsXG4gIHRleHQ6IDQsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYmluMnN0cihkYXRhOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0YSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkVWludDE2KGJ1ZmZlcjogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB2YWwgPSAoYnVmZmVyW29mZnNldF0gPDwgOCkgfCBidWZmZXJbb2Zmc2V0ICsgMV07XG4gIHJldHVybiB2YWwgPCAwID8gNjU1MzYgKyB2YWwgOiB2YWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkVWludDMyKGJ1ZmZlcjogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB2YWwgPSByZWFkU2ludDMyKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFNpbnQzMihidWZmZXI6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIChcbiAgICAoYnVmZmVyW29mZnNldF0gPDwgMjQpIHxcbiAgICAoYnVmZmVyW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKGJ1ZmZlcltvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgYnVmZmVyW29mZnNldCArIDNdXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVVpbnQzMihidWZmZXI6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKSB7XG4gIGJ1ZmZlcltvZmZzZXRdID0gdmFsdWUgPj4gMjQ7XG4gIGJ1ZmZlcltvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+PiAxNikgJiAweGZmO1xuICBidWZmZXJbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4gOCkgJiAweGZmO1xuICBidWZmZXJbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4ZmY7XG59XG5cbi8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRCb3goZGF0YTogVWludDhBcnJheSwgcGF0aDogc3RyaW5nW10pOiBVaW50OEFycmF5W10ge1xuICBjb25zdCByZXN1bHRzID0gW10gYXMgVWludDhBcnJheVtdO1xuICBpZiAoIXBhdGgubGVuZ3RoKSB7XG4gICAgLy8gc2hvcnQtY2lyY3VpdCB0aGUgc2VhcmNoIGZvciBlbXB0eSBwYXRoc1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIGNvbnN0IGVuZCA9IGRhdGEuYnl0ZUxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZDsgKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRVaW50MzIoZGF0YSwgaSk7XG4gICAgY29uc3QgdHlwZSA9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShpICsgNCwgaSArIDgpKTtcbiAgICBjb25zdCBlbmRib3ggPSBzaXplID4gMSA/IGkgKyBzaXplIDogZW5kO1xuXG4gICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxuICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICByZXN1bHRzLnB1c2goZGF0YS5zdWJhcnJheShpICsgOCwgZW5kYm94KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHRoZSBuZXh0IGJveCBhbG9uZyB0aGUgcGF0aFxuICAgICAgICBjb25zdCBzdWJyZXN1bHRzID0gZmluZEJveChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmRib3gpLCBwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgaWYgKHN1YnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBzdWJyZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpID0gZW5kYm94O1xuICB9XG5cbiAgLy8gd2UndmUgZmluaXNoZWQgc2VhcmNoaW5nIGFsbCBvZiBkYXRhXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG50eXBlIFNpZHhJbmZvID0ge1xuICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWU6IG51bWJlcjtcbiAgdGltZXNjYWxlOiBudW1iZXI7XG4gIHZlcnNpb246IG51bWJlcjtcbiAgcmVmZXJlbmNlc0NvdW50OiBudW1iZXI7XG4gIHJlZmVyZW5jZXM6IGFueVtdO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2VnbWVudEluZGV4KHNpZHg6IFVpbnQ4QXJyYXkpOiBTaWR4SW5mbyB8IG51bGwge1xuICBjb25zdCByZWZlcmVuY2VzOiBhbnlbXSA9IFtdO1xuXG4gIGNvbnN0IHZlcnNpb24gPSBzaWR4WzBdO1xuXG4gIC8vIHNldCBpbml0aWFsIG9mZnNldCwgd2Ugc2tpcCB0aGUgcmVmZXJlbmNlIElEIChub3QgbmVlZGVkKVxuICBsZXQgaW5kZXggPSA4O1xuXG4gIGNvbnN0IHRpbWVzY2FsZSA9IHJlYWRVaW50MzIoc2lkeCwgaW5kZXgpO1xuICBpbmRleCArPSA0O1xuXG4gIC8vIFRPRE86IHBhcnNlIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSBhbmQgZmlyc3RPZmZzZXRcbiAgLy8gdXN1YWxseSB6ZXJvIGluIG91ciBjYXNlXG4gIGNvbnN0IGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSA9IDA7XG4gIGNvbnN0IGZpcnN0T2Zmc2V0ID0gMDtcblxuICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgIGluZGV4ICs9IDg7XG4gIH0gZWxzZSB7XG4gICAgaW5kZXggKz0gMTY7XG4gIH1cblxuICAvLyBza2lwIHJlc2VydmVkXG4gIGluZGV4ICs9IDI7XG5cbiAgbGV0IHN0YXJ0Qnl0ZSA9IHNpZHgubGVuZ3RoICsgZmlyc3RPZmZzZXQ7XG5cbiAgY29uc3QgcmVmZXJlbmNlc0NvdW50ID0gcmVhZFVpbnQxNihzaWR4LCBpbmRleCk7XG4gIGluZGV4ICs9IDI7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWZlcmVuY2VzQ291bnQ7IGkrKykge1xuICAgIGxldCByZWZlcmVuY2VJbmRleCA9IGluZGV4O1xuXG4gICAgY29uc3QgcmVmZXJlbmNlSW5mbyA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG5cbiAgICBjb25zdCByZWZlcmVuY2VTaXplID0gcmVmZXJlbmNlSW5mbyAmIDB4N2ZmZmZmZmY7XG4gICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IChyZWZlcmVuY2VJbmZvICYgMHg4MDAwMDAwMCkgPj4+IDMxO1xuXG4gICAgaWYgKHJlZmVyZW5jZVR5cGUgPT09IDEpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdTSURYIGhhcyBoaWVyYXJjaGljYWwgcmVmZXJlbmNlcyAobm90IHN1cHBvcnRlZCknKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHN1YnNlZ21lbnREdXJhdGlvbiA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG5cbiAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgcmVmZXJlbmNlU2l6ZSxcbiAgICAgIHN1YnNlZ21lbnREdXJhdGlvbiwgLy8gdW5zY2FsZWRcbiAgICAgIGluZm86IHtcbiAgICAgICAgZHVyYXRpb246IHN1YnNlZ21lbnREdXJhdGlvbiAvIHRpbWVzY2FsZSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0Qnl0ZSxcbiAgICAgICAgZW5kOiBzdGFydEJ5dGUgKyByZWZlcmVuY2VTaXplIC0gMSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBzdGFydEJ5dGUgKz0gcmVmZXJlbmNlU2l6ZTtcblxuICAgIC8vIFNraXBwaW5nIDEgYml0IGZvciB8c3RhcnRzV2l0aFNhcHwsIDMgYml0cyBmb3IgfHNhcFR5cGV8LCBhbmQgMjggYml0c1xuICAgIC8vIGZvciB8c2FwRGVsdGF8LlxuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG5cbiAgICAvLyBza2lwIHRvIG5leHQgcmVmXG4gICAgaW5kZXggPSByZWZlcmVuY2VJbmRleDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZWFybGllc3RQcmVzZW50YXRpb25UaW1lLFxuICAgIHRpbWVzY2FsZSxcbiAgICB2ZXJzaW9uLFxuICAgIHJlZmVyZW5jZXNDb3VudCxcbiAgICByZWZlcmVuY2VzLFxuICB9O1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBNUDQgaW5pdGlhbGl6YXRpb24gc2VnbWVudCBhbmQgZXh0cmFjdHMgc3RyZWFtIHR5cGUgYW5kXG4gKiB0aW1lc2NhbGUgdmFsdWVzIGZvciBhbnkgZGVjbGFyZWQgdHJhY2tzLiBUaW1lc2NhbGUgdmFsdWVzIGluZGljYXRlIHRoZVxuICogbnVtYmVyIG9mIGNsb2NrIHRpY2tzIHBlciBzZWNvbmQgdG8gYXNzdW1lIGZvciB0aW1lLWJhc2VkIHZhbHVlc1xuICogZWxzZXdoZXJlIGluIHRoZSBNUDQuXG4gKlxuICogVG8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lIG9mIGFuIE1QNCwgeW91IG5lZWQgdHdvIHBpZWNlcyBvZlxuICogaW5mb3JtYXRpb246IHRoZSB0aW1lc2NhbGUgdW5pdCBhbmQgdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlXG4gKiB0aW1lLiBNdWx0aXBsZSB0aW1lc2NhbGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aGluIGFuIE1QNCBidXQgdGhlXG4gKiBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGlzIGFsd2F5cyBleHByZXNzZWQgaW4gdGhlIHRpbWVzY2FsZSBmcm9tXG4gKiB0aGUgbWVkaWEgaGVhZGVyIGJveCBmb3IgdGhlIHRyYWNrOlxuICogYGBgXG4gKiBtb292ID4gdHJhayA+IG1kaWEgPiBtZGhkLnRpbWVzY2FsZVxuICogbW9vdiA+IHRyYWsgPiBtZGlhID4gaGRsclxuICogYGBgXG4gKiBAcGFyYW0gaW5pdFNlZ21lbnQgdGhlIGJ5dGVzIG9mIHRoZSBpbml0IHNlZ21lbnRcbiAqIEByZXR1cm5zIGEgaGFzaCBvZiB0cmFjayB0eXBlIHRvIHRpbWVzY2FsZSB2YWx1ZXMgb3IgbnVsbCBpZlxuICogdGhlIGluaXQgc2VnbWVudCBpcyBtYWxmb3JtZWQuXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBJbml0RGF0YVRyYWNrIHtcbiAgdGltZXNjYWxlOiBudW1iZXI7XG4gIGlkOiBudW1iZXI7XG4gIGNvZGVjOiBzdHJpbmc7XG59XG5cbnR5cGUgSGRsclR5cGUgPSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8gfCBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU87XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdERhdGEgZXh0ZW5kcyBBcnJheTxhbnk+IHtcbiAgW2luZGV4OiBudW1iZXJdOlxuICAgIHwge1xuICAgICAgICB0aW1lc2NhbGU6IG51bWJlcjtcbiAgICAgICAgdHlwZTogSGRsclR5cGU7XG4gICAgICAgIGRlZmF1bHQ/OiB7XG4gICAgICAgICAgZHVyYXRpb246IG51bWJlcjtcbiAgICAgICAgICBmbGFnczogbnVtYmVyO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIHwgdW5kZWZpbmVkO1xuICBhdWRpbz86IEluaXREYXRhVHJhY2s7XG4gIHZpZGVvPzogSW5pdERhdGFUcmFjaztcbiAgY2FwdGlvbj86IEluaXREYXRhVHJhY2s7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50OiBVaW50OEFycmF5KTogSW5pdERhdGEge1xuICBjb25zdCByZXN1bHQ6IEluaXREYXRhID0gW107XG4gIGNvbnN0IHRyYWtzID0gZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJha3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0cmFrID0gdHJha3NbaV07XG4gICAgY29uc3QgdGtoZCA9IGZpbmRCb3godHJhaywgWyd0a2hkJ10pWzBdO1xuICAgIGlmICh0a2hkKSB7XG4gICAgICBsZXQgdmVyc2lvbiA9IHRraGRbMF07XG4gICAgICBsZXQgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcbiAgICAgIGNvbnN0IHRyYWNrSWQgPSByZWFkVWludDMyKHRraGQsIGluZGV4KTtcbiAgICAgIGNvbnN0IG1kaGQgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtZGhkJ10pWzBdO1xuICAgICAgaWYgKG1kaGQpIHtcbiAgICAgICAgdmVyc2lvbiA9IG1kaGRbMF07XG4gICAgICAgIGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XG4gICAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IHJlYWRVaW50MzIobWRoZCwgaW5kZXgpO1xuICAgICAgICBjb25zdCBoZGxyID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnaGRsciddKVswXTtcbiAgICAgICAgaWYgKGhkbHIpIHtcbiAgICAgICAgICBjb25zdCBoZGxyVHlwZSA9IGJpbjJzdHIoaGRsci5zdWJhcnJheSg4LCAxMikpO1xuICAgICAgICAgIGNvbnN0IHR5cGU6IEhkbHJUeXBlIHwgdW5kZWZpbmVkID0ge1xuICAgICAgICAgICAgc291bjogRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPIGFzIGNvbnN0LFxuICAgICAgICAgICAgdmlkZTogRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPIGFzIGNvbnN0LFxuICAgICAgICAgIH1baGRsclR5cGVdO1xuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBjb2RlYyBkZXRhaWxzXG4gICAgICAgICAgICBjb25zdCBzdHNkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSlbMF07XG4gICAgICAgICAgICBsZXQgY29kZWM7XG4gICAgICAgICAgICBpZiAoc3RzZCkge1xuICAgICAgICAgICAgICBjb2RlYyA9IGJpbjJzdHIoc3RzZC5zdWJhcnJheSgxMiwgMTYpKTtcbiAgICAgICAgICAgICAgLy8gVE9ETzogUGFyc2UgY29kZWMgZGV0YWlscyB0byBiZSBhYmxlIHRvIGJ1aWxkIE1JTUUgdHlwZS5cbiAgICAgICAgICAgICAgLy8gc3RzZC5zdGFydCArPSA4O1xuICAgICAgICAgICAgICAvLyBjb25zdCBjb2RlY0JveCA9IGZpbmRCb3goc3RzZCwgW2NvZGVjXSlbMF07XG4gICAgICAgICAgICAgIC8vIGlmIChjb2RlY0JveCkge1xuICAgICAgICAgICAgICAvLyAgIFRPRE86IENvZGVjIHBhcnNpbmcgc3VwcG9ydCBmb3IgYXZjMSwgbXA0YSwgaGV2YywgYXYwMS4uLlxuICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbdHJhY2tJZF0gPSB7IHRpbWVzY2FsZSwgdHlwZSB9O1xuICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0geyB0aW1lc2NhbGUsIGlkOiB0cmFja0lkLCBjb2RlYyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRyZXggPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAnbXZleCcsICd0cmV4J10pO1xuICB0cmV4LmZvckVhY2goKHRyZXgpID0+IHtcbiAgICBjb25zdCB0cmFja0lkID0gcmVhZFVpbnQzMih0cmV4LCA0KTtcbiAgICBjb25zdCB0cmFjayA9IHJlc3VsdFt0cmFja0lkXTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLmRlZmF1bHQgPSB7XG4gICAgICAgIGR1cmF0aW9uOiByZWFkVWludDMyKHRyZXgsIDEyKSxcbiAgICAgICAgZmxhZ3M6IHJlYWRVaW50MzIodHJleCwgMjApLFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaEVuY3lwdGlvbkRhdGEoXG4gIGluaXRTZWdtZW50OiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICBkZWNyeXB0ZGF0YTogRGVjcnlwdERhdGEgfCBudWxsXG4pOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFpbml0U2VnbWVudCB8fCAhZGVjcnlwdGRhdGEpIHtcbiAgICByZXR1cm4gaW5pdFNlZ21lbnQ7XG4gIH1cbiAgY29uc3Qga2V5SWQgPSBkZWNyeXB0ZGF0YS5rZXlJZDtcbiAgaWYgKGtleUlkICYmIGRlY3J5cHRkYXRhLmlzQ29tbW9uRW5jcnlwdGlvbikge1xuICAgIGNvbnN0IHRyYWtzID0gZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XG4gICAgdHJha3MuZm9yRWFjaCgodHJhaykgPT4ge1xuICAgICAgY29uc3Qgc3RzZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21pbmYnLCAnc3RibCcsICdzdHNkJ10pWzBdO1xuXG4gICAgICAvLyBza2lwIHRoZSBzYW1wbGUgZW50cnkgY291bnRcbiAgICAgIGNvbnN0IHNhbXBsZUVudHJpZXMgPSBzdHNkLnN1YmFycmF5KDgpO1xuICAgICAgbGV0IGVuY0JveGVzID0gZmluZEJveChzYW1wbGVFbnRyaWVzLCBbJ2VuY2EnXSk7XG4gICAgICBjb25zdCBpc0F1ZGlvID0gZW5jQm94ZXMubGVuZ3RoID4gMDtcbiAgICAgIGlmICghaXNBdWRpbykge1xuICAgICAgICBlbmNCb3hlcyA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgWydlbmN2J10pO1xuICAgICAgfVxuICAgICAgZW5jQm94ZXMuZm9yRWFjaCgoZW5jKSA9PiB7XG4gICAgICAgIGNvbnN0IGVuY0JveENoaWxkcmVuID0gaXNBdWRpbyA/IGVuYy5zdWJhcnJheSgyOCkgOiBlbmMuc3ViYXJyYXkoNzgpO1xuICAgICAgICBjb25zdCBzaW5mQm94ZXMgPSBmaW5kQm94KGVuY0JveENoaWxkcmVuLCBbJ3NpbmYnXSk7XG4gICAgICAgIHNpbmZCb3hlcy5mb3JFYWNoKChzaW5mKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGVuYyA9IHBhcnNlU2luZihzaW5mKTtcbiAgICAgICAgICBpZiAodGVuYykge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgZGVmYXVsdCBrZXkgaWQgKGtleUlEIG9mZnNldCBpcyBhbHdheXMgOCB3aXRoaW4gdGhlIHRlbmMgYm94KTpcbiAgICAgICAgICAgIGNvbnN0IHRlbmNLZXlJZCA9IHRlbmMuc3ViYXJyYXkoOCwgMjQpO1xuICAgICAgICAgICAgaWYgKCF0ZW5jS2V5SWQuc29tZSgoYikgPT4gYiAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgICAgICBgW2VtZV0gUGF0Y2hpbmcga2V5SWQgaW4gJ2VuYyR7XG4gICAgICAgICAgICAgICAgICBpc0F1ZGlvID8gJ2EnIDogJ3YnXG4gICAgICAgICAgICAgICAgfT5zaW5mPj50ZW5jJyBib3g6ICR7SGV4LmhleER1bXAodGVuY0tleUlkKX0gLT4gJHtIZXguaGV4RHVtcChcbiAgICAgICAgICAgICAgICAgIGtleUlkXG4gICAgICAgICAgICAgICAgKX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRlbmMuc2V0KGtleUlkLCA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gaW5pdFNlZ21lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNpbmYoc2luZjogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgY29uc3Qgc2NobSA9IGZpbmRCb3goc2luZiwgWydzY2htJ10pWzBdO1xuICBpZiAoc2NobSkge1xuICAgIGNvbnN0IHNjaGVtZSA9IGJpbjJzdHIoc2NobS5zdWJhcnJheSg0LCA4KSk7XG4gICAgaWYgKHNjaGVtZSA9PT0gJ2NiY3MnIHx8IHNjaGVtZSA9PT0gJ2NlbmMnKSB7XG4gICAgICByZXR1cm4gZmluZEJveChzaW5mLCBbJ3NjaGknLCAndGVuYyddKVswXTtcbiAgICB9XG4gIH1cbiAgbG9nZ2VyLmVycm9yKGBbZW1lXSBtaXNzaW5nICdzY2htJyBib3hgKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lLCBpbiBzZWNvbmRzLCBmb3IgYW4gTVA0XG4gKiBmcmFnbWVudC4gSWYgbXVsdGlwbGUgZnJhZ21lbnRzIGFyZSBzcGVjaWZpZWQsIHRoZSBlYXJsaWVzdCB0aW1lIGlzXG4gKiByZXR1cm5lZC5cbiAqXG4gKiBUaGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBjYW4gYmUgcGFyc2VkIGZyb20gdHJhY2sgZnJhZ21lbnRcbiAqIG1ldGFkYXRhOlxuICogYGBgXG4gKiBtb29mID4gdHJhZiA+IHRmZHQuYmFzZU1lZGlhRGVjb2RlVGltZVxuICogYGBgXG4gKiBJdCByZXF1aXJlcyB0aGUgdGltZXNjYWxlIHZhbHVlIGZyb20gdGhlIG1kaGQgdG8gaW50ZXJwcmV0LlxuICpcbiAqIEBwYXJhbSBpbml0RGF0YSAtIGEgaGFzaCBvZiB0cmFjayB0eXBlIHRvIHRpbWVzY2FsZSB2YWx1ZXNcbiAqIEBwYXJhbSBmbXA0IC0gdGhlIGJ5dGVzIG9mIHRoZSBtcDQgZnJhZ21lbnRcbiAqIEByZXR1cm5zIHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lIGZvciB0aGVcbiAqIGZyYWdtZW50LCBpbiBzZWNvbmRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGFydERUUyhcbiAgaW5pdERhdGE6IEluaXREYXRhLFxuICBmbXA0OiBVaW50OEFycmF5XG4pOiBudW1iZXIgfCBudWxsIHtcbiAgLy8gd2UgbmVlZCBpbmZvIGZyb20gdHdvIGNoaWxkcmVuIG9mIGVhY2ggdHJhY2sgZnJhZ21lbnQgYm94XG4gIHJldHVybiBmaW5kQm94KGZtcDQsIFsnbW9vZicsICd0cmFmJ10pLnJlZHVjZShcbiAgICAocmVzdWx0OiBudW1iZXIgfCBudWxsLCB0cmFmKSA9PiB7XG4gICAgICBjb25zdCB0ZmR0ID0gZmluZEJveCh0cmFmLCBbJ3RmZHQnXSlbMF07XG4gICAgICBjb25zdCB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkucmVkdWNlKFxuICAgICAgICAocmVzdWx0OiBudW1iZXIgfCBudWxsLCB0ZmhkKSA9PiB7XG4gICAgICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICAgICAgY29uc3QgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgICAgIGNvbnN0IHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgbGV0IGJhc2VUaW1lID0gcmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICAgIC8vIElmIHZhbHVlIGlzIHRvbyBsYXJnZSwgYXNzdW1lIHNpZ25lZCA2NC1iaXQuIE5lZ2F0aXZlIHRyYWNrIGZyYWdtZW50IGRlY29kZSB0aW1lcyBhcmUgaW52YWxpZCwgYnV0IHRoZXkgZXhpc3QgaW4gdGhlIHdpbGQuXG4gICAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgbGFyZ2UgdmFsdWVzIGZyb20gYmVpbmcgdXNlZCBmb3IgaW5pdFBUUywgd2hpY2ggY2FuIGNhdXNlIHBsYXlsaXN0IHN5bmMgaXNzdWVzLlxuICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvNTMwM1xuICAgICAgICAgICAgICBpZiAoYmFzZVRpbWUgPT09IFVJTlQzMl9NQVgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICAgIGBbbXA0LWRlbXV4ZXJdOiBJZ25vcmluZyBhc3N1bWVkIGludmFsaWQgc2lnbmVkIDY0LWJpdCB0cmFjayBmcmFnbWVudCBkZWNvZGUgdGltZWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYmFzZVRpbWUgKj0gVUlOVDMyX01BWCArIDE7XG4gICAgICAgICAgICAgIGJhc2VUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0cmFjay50aW1lc2NhbGUgfHwgOTBlMztcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgYmFzZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGJhc2VUaW1lIC8gc2NhbGU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGlzRmluaXRlKHN0YXJ0VGltZSkgJiZcbiAgICAgICAgICAgICAgKHJlc3VsdCA9PT0gbnVsbCB8fCBzdGFydFRpbWUgPCByZXN1bHQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0VGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgc3RhcnQgIT09IG51bGwgJiZcbiAgICAgICAgaXNGaW5pdGUoc3RhcnQpICYmXG4gICAgICAgIChyZXN1bHQgPT09IG51bGwgfHwgc3RhcnQgPCByZXN1bHQpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIG51bGxcbiAgKTtcbn1cblxuLypcbiAgRm9yIFJlZmVyZW5jZTpcbiAgYWxpZ25lZCg4KSBjbGFzcyBUcmFja0ZyYWdtZW50SGVhZGVyQm94XG4gICAgICAgICAgIGV4dGVuZHMgRnVsbEJveCjigJh0Zmhk4oCZLCAwLCB0Zl9mbGFncyl7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHRyYWNrX0lEO1xuICAgICAvLyBhbGwgdGhlIGZvbGxvd2luZyBhcmUgb3B0aW9uYWwgZmllbGRzXG4gICAgIHVuc2lnbmVkIGludCg2NCkgIGJhc2VfZGF0YV9vZmZzZXQ7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleDtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb247XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX3NpemU7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldER1cmF0aW9uKGRhdGE6IFVpbnQ4QXJyYXksIGluaXREYXRhOiBJbml0RGF0YSkge1xuICBsZXQgcmF3RHVyYXRpb24gPSAwO1xuICBsZXQgdmlkZW9EdXJhdGlvbiA9IDA7XG4gIGxldCBhdWRpb0R1cmF0aW9uID0gMDtcbiAgY29uc3QgdHJhZnMgPSBmaW5kQm94KGRhdGEsIFsnbW9vZicsICd0cmFmJ10pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdHJhZiA9IHRyYWZzW2ldO1xuICAgIC8vIFRoZXJlIGlzIG9ubHkgb25lIHRmaGQgJiB0cnVuIHBlciB0cmFmXG4gICAgLy8gVGhpcyBpcyB0cnVlIGZvciBDTUFGIHN0eWxlIGNvbnRlbnQsIGFuZCB3ZSBzaG91bGQgcGVyaGFwcyBjaGVjayB0aGUgZnR5cFxuICAgIC8vIGFuZCBvbmx5IGxvb2sgZm9yIGEgc2luZ2xlIHRydW4gdGhlbiwgYnV0IGZvciBJU09CTUZGIHdlIHNob3VsZCBjaGVja1xuICAgIC8vIGZvciBtdWx0aXBsZSB0cmFjayBydW5zLlxuICAgIGNvbnN0IHRmaGQgPSBmaW5kQm94KHRyYWYsIFsndGZoZCddKVswXTtcbiAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICBjb25zdCBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgY29uc3QgdHJhY2sgPSBpbml0RGF0YVtpZF07XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrRGVmYXVsdCA9IHRyYWNrLmRlZmF1bHQ7XG4gICAgY29uc3QgdGZoZEZsYWdzID0gcmVhZFVpbnQzMih0ZmhkLCAwKSB8IHRyYWNrRGVmYXVsdD8uZmxhZ3MhO1xuICAgIGxldCBzYW1wbGVEdXJhdGlvbjogbnVtYmVyIHwgdW5kZWZpbmVkID0gdHJhY2tEZWZhdWx0Py5kdXJhdGlvbjtcbiAgICBpZiAodGZoZEZsYWdzICYgMHgwMDAwMDgpIHtcbiAgICAgIC8vIDB4MDAwMDA4IGluZGljYXRlcyB0aGUgcHJlc2VuY2Ugb2YgdGhlIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uIGZpZWxkXG4gICAgICBpZiAodGZoZEZsYWdzICYgMHgwMDAwMDIpIHtcbiAgICAgICAgLy8gMHgwMDAwMDIgaW5kaWNhdGVzIHRoZSBwcmVzZW5jZSBvZiB0aGUgc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4IGZpZWxkLCB3aGljaCBwcmVjZWRlcyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgICAgICAvLyBJZiBwcmVzZW50LCB0aGUgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gZXhpc3RzIGF0IGJ5dGUgb2Zmc2V0IDEyXG4gICAgICAgIHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0ZmhkLCAxMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBkdXJhdGlvbiBpcyBhdCBieXRlIG9mZnNldCA4XG4gICAgICAgIHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0ZmhkLCA4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcbiAgICBjb25zdCB0aW1lc2NhbGUgPSB0cmFjay50aW1lc2NhbGUgfHwgOTBlMztcbiAgICBjb25zdCB0cnVucyA9IGZpbmRCb3godHJhZiwgWyd0cnVuJ10pO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdHJ1bnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHJhd0R1cmF0aW9uID0gY29tcHV0ZVJhd0R1cmF0aW9uRnJvbVNhbXBsZXModHJ1bnNbal0pO1xuICAgICAgaWYgKCFyYXdEdXJhdGlvbiAmJiBzYW1wbGVEdXJhdGlvbikge1xuICAgICAgICBjb25zdCBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1bnNbal0sIDQpO1xuICAgICAgICByYXdEdXJhdGlvbiA9IHNhbXBsZUR1cmF0aW9uICogc2FtcGxlQ291bnQ7XG4gICAgICB9XG4gICAgICBpZiAodHJhY2sudHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgICAgIHZpZGVvRHVyYXRpb24gKz0gcmF3RHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLnR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTykge1xuICAgICAgICBhdWRpb0R1cmF0aW9uICs9IHJhd0R1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmlkZW9EdXJhdGlvbiA9PT0gMCAmJiBhdWRpb0R1cmF0aW9uID09PSAwKSB7XG4gICAgLy8gSWYgZHVyYXRpb24gc2FtcGxlcyBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgdHJhZiB1c2Ugc2lkeCBzdWJzZWdtZW50X2R1cmF0aW9uXG4gICAgbGV0IHNpZHhEdXJhdGlvbiA9IDA7XG4gICAgY29uc3Qgc2lkeHMgPSBmaW5kQm94KGRhdGEsIFsnc2lkeCddKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzaWR4ID0gcGFyc2VTZWdtZW50SW5kZXgoc2lkeHNbaV0pO1xuICAgICAgaWYgKHNpZHg/LnJlZmVyZW5jZXMpIHtcbiAgICAgICAgc2lkeER1cmF0aW9uICs9IHNpZHgucmVmZXJlbmNlcy5yZWR1Y2UoXG4gICAgICAgICAgKGR1ciwgcmVmKSA9PiBkdXIgKyByZWYuaW5mby5kdXJhdGlvbiB8fCAwLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2lkeER1cmF0aW9uO1xuICB9XG4gIGlmICh2aWRlb0R1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHZpZGVvRHVyYXRpb247XG4gIH1cbiAgcmV0dXJuIGF1ZGlvRHVyYXRpb247XG59XG5cbi8qXG4gIEZvciBSZWZlcmVuY2U6XG4gIGFsaWduZWQoOCkgY2xhc3MgVHJhY2tSdW5Cb3hcbiAgICAgICAgICAgZXh0ZW5kcyBGdWxsQm94KOKAmHRydW7igJksIHZlcnNpb24sIHRyX2ZsYWdzKSB7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9jb3VudDtcbiAgICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgb3B0aW9uYWwgZmllbGRzXG4gICAgIHNpZ25lZCBpbnQoMzIpIGRhdGFfb2Zmc2V0O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBmaXJzdF9zYW1wbGVfZmxhZ3M7XG4gICAgIC8vIGFsbCBmaWVsZHMgaW4gdGhlIGZvbGxvd2luZyBhcnJheSBhcmUgb3B0aW9uYWxcbiAgICAge1xuICAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZHVyYXRpb247XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9zaXplO1xuICAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZmxhZ3NcbiAgICAgICAgaWYgKHZlcnNpb24gPT0gMClcbiAgICAgICAgICAgeyB1bnNpZ25lZCBpbnQoMzIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgeyBzaWduZWQgaW50KDMyKVxuICAgICB9WyBzYW1wbGVfY291bnQgXVxuICB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUmF3RHVyYXRpb25Gcm9tU2FtcGxlcyh0cnVuKTogbnVtYmVyIHtcbiAgY29uc3QgZmxhZ3MgPSByZWFkVWludDMyKHRydW4sIDApO1xuICAvLyBGbGFncyBhcmUgYXQgb2Zmc2V0IDAsIG5vbi1vcHRpb25hbCBzYW1wbGVfY291bnQgaXMgYXQgb2Zmc2V0IDQuIFRoZXJlZm9yZSB3ZSBzdGFydCA4IGJ5dGVzIGluLlxuICAvLyBFYWNoIGZpZWxkIGlzIGFuIGludDMyLCB3aGljaCBpcyA0IGJ5dGVzXG4gIGxldCBvZmZzZXQgPSA4O1xuICAvLyBkYXRhLW9mZnNldC1wcmVzZW50IGZsYWdcbiAgaWYgKGZsYWdzICYgMHgwMDAwMDEpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgfVxuICAvLyBmaXJzdC1zYW1wbGUtZmxhZ3MtcHJlc2VudCBmbGFnXG4gIGlmIChmbGFncyAmIDB4MDAwMDA0KSB7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gIH1cblxuICBsZXQgZHVyYXRpb24gPSAwO1xuICBjb25zdCBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1biwgNCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlQ291bnQ7IGkrKykge1xuICAgIC8vIHNhbXBsZS1kdXJhdGlvbi1wcmVzZW50IGZsYWdcbiAgICBpZiAoZmxhZ3MgJiAweDAwMDEwMCkge1xuICAgICAgY29uc3Qgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRydW4sIG9mZnNldCk7XG4gICAgICBkdXJhdGlvbiArPSBzYW1wbGVEdXJhdGlvbjtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgICAvLyBzYW1wbGUtc2l6ZS1wcmVzZW50IGZsYWdcbiAgICBpZiAoZmxhZ3MgJiAweDAwMDIwMCkge1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuICAgIC8vIHNhbXBsZS1mbGFncy1wcmVzZW50IGZsYWdcbiAgICBpZiAoZmxhZ3MgJiAweDAwMDQwMCkge1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuICAgIC8vIHNhbXBsZS1jb21wb3NpdGlvbi10aW1lLW9mZnNldHMtcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDA4MDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHVyYXRpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvZmZzZXRTdGFydERUUyhcbiAgaW5pdERhdGE6IEluaXREYXRhLFxuICBmbXA0OiBVaW50OEFycmF5LFxuICB0aW1lT2Zmc2V0OiBudW1iZXJcbikge1xuICBmaW5kQm94KGZtcDQsIFsnbW9vZicsICd0cmFmJ10pLmZvckVhY2goKHRyYWYpID0+IHtcbiAgICBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5mb3JFYWNoKCh0ZmhkKSA9PiB7XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgIGNvbnN0IGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgIGNvbnN0IHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgY29uc3QgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkuZm9yRWFjaCgodGZkdCkgPT4ge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgICAgbGV0IGJhc2VNZWRpYURlY29kZVRpbWUgPSByZWFkVWludDMyKHRmZHQsIDQpO1xuXG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAtPSB0aW1lT2Zmc2V0ICogdGltZXNjYWxlO1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLm1heChiYXNlTWVkaWFEZWNvZGVUaW1lLCAwKTtcbiAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA0LCBiYXNlTWVkaWFEZWNvZGVUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAtPSB0aW1lT2Zmc2V0ICogdGltZXNjYWxlO1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLm1heChiYXNlTWVkaWFEZWNvZGVUaW1lLCAwKTtcbiAgICAgICAgICBjb25zdCB1cHBlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICAgIGNvbnN0IGxvd2VyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgICAgd3JpdGVVaW50MzIodGZkdCwgNCwgdXBwZXIpO1xuICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDgsIGxvd2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBUT0RPOiBDaGVjayBpZiB0aGUgbGFzdCBtb29mK21kYXQgcGFpciBpcyBwYXJ0IG9mIHRoZSB2YWxpZCByYW5nZVxuZXhwb3J0IGZ1bmN0aW9uIHNlZ21lbnRWYWxpZFJhbmdlKGRhdGE6IFVpbnQ4QXJyYXkpOiBTZWdtZW50ZWRSYW5nZSB7XG4gIGNvbnN0IHNlZ21lbnRlZFJhbmdlOiBTZWdtZW50ZWRSYW5nZSA9IHtcbiAgICB2YWxpZDogbnVsbCxcbiAgICByZW1haW5kZXI6IG51bGwsXG4gIH07XG5cbiAgY29uc3QgbW9vZnMgPSBmaW5kQm94KGRhdGEsIFsnbW9vZiddKTtcbiAgaWYgKCFtb29mcykge1xuICAgIHJldHVybiBzZWdtZW50ZWRSYW5nZTtcbiAgfSBlbHNlIGlmIChtb29mcy5sZW5ndGggPCAyKSB7XG4gICAgc2VnbWVudGVkUmFuZ2UucmVtYWluZGVyID0gZGF0YTtcbiAgICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG4gIH1cbiAgY29uc3QgbGFzdCA9IG1vb2ZzW21vb2ZzLmxlbmd0aCAtIDFdO1xuICAvLyBPZmZzZXQgYnkgOCBieXRlczsgZmluZEJveCBvZmZzZXRzIHRoZSBzdGFydCBieSBhcyBtdWNoXG4gIHNlZ21lbnRlZFJhbmdlLnZhbGlkID0gc2xpY2VVaW50OChkYXRhLCAwLCBsYXN0LmJ5dGVPZmZzZXQgLSA4KTtcbiAgc2VnbWVudGVkUmFuZ2UucmVtYWluZGVyID0gc2xpY2VVaW50OChkYXRhLCBsYXN0LmJ5dGVPZmZzZXQgLSA4KTtcbiAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlZ21lbnRlZFJhbmdlIHtcbiAgdmFsaWQ6IFVpbnQ4QXJyYXkgfCBudWxsO1xuICByZW1haW5kZXI6IFVpbnQ4QXJyYXkgfCBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kVWludDhBcnJheShcbiAgZGF0YTE6IFVpbnQ4QXJyYXksXG4gIGRhdGEyOiBVaW50OEFycmF5XG4pOiBVaW50OEFycmF5IHtcbiAgY29uc3QgdGVtcCA9IG5ldyBVaW50OEFycmF5KGRhdGExLmxlbmd0aCArIGRhdGEyLmxlbmd0aCk7XG4gIHRlbXAuc2V0KGRhdGExKTtcbiAgdGVtcC5zZXQoZGF0YTIsIGRhdGExLmxlbmd0aCk7XG5cbiAgcmV0dXJuIHRlbXA7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUVtc2dQYXJzaW5nRGF0YSB7XG4gIHNjaGVtZUlkVXJpOiBzdHJpbmc7XG4gIHZhbHVlOiBzdHJpbmc7XG4gIHRpbWVTY2FsZTogbnVtYmVyO1xuICBwcmVzZW50YXRpb25UaW1lRGVsdGE/OiBudW1iZXI7XG4gIHByZXNlbnRhdGlvblRpbWU/OiBudW1iZXI7XG4gIGV2ZW50RHVyYXRpb246IG51bWJlcjtcbiAgaWQ6IG51bWJlcjtcbiAgcGF5bG9hZDogVWludDhBcnJheTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2FtcGxlcyhcbiAgdGltZU9mZnNldDogbnVtYmVyLFxuICB0cmFjazogUGFzc3Rocm91Z2hUcmFja1xuKTogVXNlcmRhdGFTYW1wbGVbXSB7XG4gIGNvbnN0IHNlaVNhbXBsZXMgPSBbXSBhcyBVc2VyZGF0YVNhbXBsZVtdO1xuICBjb25zdCB2aWRlb0RhdGEgPSB0cmFjay5zYW1wbGVzO1xuICBjb25zdCB0aW1lc2NhbGUgPSB0cmFjay50aW1lc2NhbGU7XG4gIGNvbnN0IHRyYWNrSWQgPSB0cmFjay5pZDtcbiAgbGV0IGlzSEVWQ0ZsYXZvciA9IGZhbHNlO1xuXG4gIGNvbnN0IG1vb2ZzID0gZmluZEJveCh2aWRlb0RhdGEsIFsnbW9vZiddKTtcbiAgbW9vZnMubWFwKChtb29mKSA9PiB7XG4gICAgY29uc3QgbW9vZk9mZnNldCA9IG1vb2YuYnl0ZU9mZnNldCAtIDg7XG4gICAgY29uc3QgdHJhZnMgPSBmaW5kQm94KG1vb2YsIFsndHJhZiddKTtcbiAgICB0cmFmcy5tYXAoKHRyYWYpID0+IHtcbiAgICAgIC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XG4gICAgICBjb25zdCBiYXNlVGltZSA9IGZpbmRCb3godHJhZiwgWyd0ZmR0J10pLm1hcCgodGZkdCkgPT4ge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgICByZXN1bHQgKz0gcmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0IC8gdGltZXNjYWxlO1xuICAgICAgfSlbMF07XG5cbiAgICAgIGlmIChiYXNlVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRpbWVPZmZzZXQgPSBiYXNlVGltZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLm1hcCgodGZoZCkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICAgIGNvbnN0IHRmaGRGbGFncyA9IHJlYWRVaW50MzIodGZoZCwgMCkgJiAweGZmZmZmZjtcbiAgICAgICAgY29uc3QgYmFzZURhdGFPZmZzZXRQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDAxKSAhPT0gMDtcbiAgICAgICAgY29uc3Qgc2FtcGxlRGVzY3JpcHRpb25JbmRleFByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDIpICE9PSAwO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2FtcGxlRHVyYXRpb25QcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDA4KSAhPT0gMDtcbiAgICAgICAgbGV0IGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTYW1wbGVTaXplUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAxMCkgIT09IDA7XG4gICAgICAgIGxldCBkZWZhdWx0U2FtcGxlU2l6ZSA9IDA7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMjApICE9PSAwO1xuICAgICAgICBsZXQgdGZoZE9mZnNldCA9IDg7XG5cbiAgICAgICAgaWYgKGlkID09PSB0cmFja0lkKSB7XG4gICAgICAgICAgaWYgKGJhc2VEYXRhT2Zmc2V0UHJlc2VudCkge1xuICAgICAgICAgICAgdGZoZE9mZnNldCArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtcGxlRGVzY3JpcHRpb25JbmRleFByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlZmF1bHRTYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlU2l6ZVByZXNlbnQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRTYW1wbGVTaXplID0gcmVhZFVpbnQzMih0ZmhkLCB0ZmhkT2Zmc2V0KTtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYWNrLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIGlzSEVWQ0ZsYXZvciA9IGlzSEVWQyh0cmFjay5jb2RlYyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmluZEJveCh0cmFmLCBbJ3RydW4nXSkubWFwKCh0cnVuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gdHJ1blswXTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gcmVhZFVpbnQzMih0cnVuLCAwKSAmIDB4ZmZmZmZmO1xuICAgICAgICAgICAgY29uc3QgZGF0YU9mZnNldFByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDAwMSkgIT09IDA7XG4gICAgICAgICAgICBsZXQgZGF0YU9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMDA0KSAhPT0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUR1cmF0aW9uUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMTAwKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBzYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVTaXplUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMjAwKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBzYW1wbGVTaXplID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwNDAwKSAhPT0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUNvbXBvc2l0aW9uT2Zmc2V0c1ByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDgwMCkgIT09IDA7XG4gICAgICAgICAgICBsZXQgY29tcG9zaXRpb25PZmZzZXQgPSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW4sIDQpO1xuICAgICAgICAgICAgbGV0IHRydW5PZmZzZXQgPSA4OyAvLyBwYXN0IHZlcnNpb24sIGZsYWdzLCBhbmQgc2FtcGxlIGNvdW50XG5cbiAgICAgICAgICAgIGlmIChkYXRhT2Zmc2V0UHJlc2VudCkge1xuICAgICAgICAgICAgICBkYXRhT2Zmc2V0ID0gcmVhZFVpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHNhbXBsZU9mZnNldCA9IGRhdGFPZmZzZXQgKyBtb29mT2Zmc2V0O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpeCA9IDA7IGl4IDwgc2FtcGxlQ291bnQ7IGl4KyspIHtcbiAgICAgICAgICAgICAgaWYgKHNhbXBsZUR1cmF0aW9uUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSBkZWZhdWx0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNhbXBsZVNpemVQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlU2l6ZSA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbXBsZVNpemUgPSBkZWZhdWx0U2FtcGxlU2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVDb21wb3NpdGlvbk9mZnNldHNQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uT2Zmc2V0ID0gcmVhZFVpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29tcG9zaXRpb25PZmZzZXQgPSByZWFkU2ludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRyYWNrLnR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTykge1xuICAgICAgICAgICAgICAgIGxldCBuYWx1VG90YWxTaXplID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmFsdVRvdGFsU2l6ZSA8IHNhbXBsZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbHVTaXplID0gcmVhZFVpbnQzMih2aWRlb0RhdGEsIHNhbXBsZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICBzYW1wbGVPZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1NFSU1lc3NhZ2UoaXNIRVZDRmxhdm9yLCB2aWRlb0RhdGFbc2FtcGxlT2Zmc2V0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHZpZGVvRGF0YS5zdWJhcnJheShcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICsgbmFsdVNpemVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTRUlNZXNzYWdlRnJvbU5BTHUoXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBpc0hFVkNGbGF2b3IgPyAyIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICB0aW1lT2Zmc2V0ICsgY29tcG9zaXRpb25PZmZzZXQgLyB0aW1lc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgc2VpU2FtcGxlc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICs9IG5hbHVTaXplO1xuICAgICAgICAgICAgICAgICAgbmFsdVRvdGFsU2l6ZSArPSBuYWx1U2l6ZSArIDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGltZU9mZnNldCArPSBzYW1wbGVEdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc2VpU2FtcGxlcztcbn1cblxuZnVuY3Rpb24gaXNIRVZDKGNvZGVjOiBzdHJpbmcpIHtcbiAgaWYgKCFjb2RlYykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBkZWxpbWl0ID0gY29kZWMuaW5kZXhPZignLicpO1xuICBjb25zdCBiYXNlQ29kZWMgPSBkZWxpbWl0IDwgMCA/IGNvZGVjIDogY29kZWMuc3Vic3RyaW5nKDAsIGRlbGltaXQpO1xuICByZXR1cm4gKFxuICAgIGJhc2VDb2RlYyA9PT0gJ2h2YzEnIHx8XG4gICAgYmFzZUNvZGVjID09PSAnaGV2MScgfHxcbiAgICAvLyBEb2xieSBWaXNpb25cbiAgICBiYXNlQ29kZWMgPT09ICdkdmgxJyB8fFxuICAgIGJhc2VDb2RlYyA9PT0gJ2R2aGUnXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzU0VJTWVzc2FnZShpc0hFVkNGbGF2b3I6IGJvb2xlYW4sIG5hbHVIZWFkZXI6IG51bWJlcikge1xuICBpZiAoaXNIRVZDRmxhdm9yKSB7XG4gICAgY29uc3QgbmFsdVR5cGUgPSAobmFsdUhlYWRlciA+PiAxKSAmIDB4M2Y7XG4gICAgcmV0dXJuIG5hbHVUeXBlID09PSAzOSB8fCBuYWx1VHlwZSA9PT0gNDA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmFsdVR5cGUgPSBuYWx1SGVhZGVyICYgMHgxZjtcbiAgICByZXR1cm4gbmFsdVR5cGUgPT09IDY7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KFxuICB1bmVzY2FwZWREYXRhOiBVaW50OEFycmF5LFxuICBoZWFkZXJTaXplOiBudW1iZXIsXG4gIHB0czogbnVtYmVyLFxuICBzYW1wbGVzOiBVc2VyZGF0YVNhbXBsZVtdXG4pIHtcbiAgY29uc3QgZGF0YSA9IGRpc2NhcmRFUEIodW5lc2NhcGVkRGF0YSk7XG4gIGxldCBzZWlQdHIgPSAwO1xuICAvLyBza2lwIG5hbCBoZWFkZXJcbiAgc2VpUHRyICs9IGhlYWRlclNpemU7XG4gIGxldCBwYXlsb2FkVHlwZSA9IDA7XG4gIGxldCBwYXlsb2FkU2l6ZSA9IDA7XG4gIGxldCBlbmRPZkNhcHRpb25zID0gZmFsc2U7XG4gIGxldCBiID0gMDtcblxuICB3aGlsZSAoc2VpUHRyIDwgZGF0YS5sZW5ndGgpIHtcbiAgICBwYXlsb2FkVHlwZSA9IDA7XG4gICAgZG8ge1xuICAgICAgaWYgKHNlaVB0ciA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGIgPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgIHBheWxvYWRUeXBlICs9IGI7XG4gICAgfSB3aGlsZSAoYiA9PT0gMHhmZik7XG5cbiAgICAvLyBQYXJzZSBwYXlsb2FkIHNpemUuXG4gICAgcGF5bG9hZFNpemUgPSAwO1xuICAgIGRvIHtcbiAgICAgIGlmIChzZWlQdHIgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBiID0gZGF0YVtzZWlQdHIrK107XG4gICAgICBwYXlsb2FkU2l6ZSArPSBiO1xuICAgIH0gd2hpbGUgKGIgPT09IDB4ZmYpO1xuXG4gICAgY29uc3QgbGVmdE92ZXIgPSBkYXRhLmxlbmd0aCAtIHNlaVB0cjtcblxuICAgIGlmICghZW5kT2ZDYXB0aW9ucyAmJiBwYXlsb2FkVHlwZSA9PT0gNCAmJiBzZWlQdHIgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XG5cbiAgICAgIGNvbnN0IGNvdW50cnlDb2RlID0gZGF0YVtzZWlQdHIrK107XG4gICAgICBpZiAoY291bnRyeUNvZGUgPT09IDE4MSkge1xuICAgICAgICBjb25zdCBwcm92aWRlckNvZGUgPSByZWFkVWludDE2KGRhdGEsIHNlaVB0cik7XG4gICAgICAgIHNlaVB0ciArPSAyO1xuXG4gICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XG4gICAgICAgICAgY29uc3QgdXNlclN0cnVjdHVyZSA9IHJlYWRVaW50MzIoZGF0YSwgc2VpUHRyKTtcbiAgICAgICAgICBzZWlQdHIgKz0gNDtcblxuICAgICAgICAgIGlmICh1c2VyU3RydWN0dXJlID09PSAweDQ3NDEzOTM0KSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyRGF0YVR5cGUgPSBkYXRhW3NlaVB0cisrXTtcblxuICAgICAgICAgICAgLy8gUmF3IENFQS02MDggYnl0ZXMgd3JhcHBlZCBpbiBDRUEtNzA4IHBhY2tldFxuICAgICAgICAgICAgaWYgKHVzZXJEYXRhVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgICAgICAgICAgY29uc3QgdG90YWxDQ3MgPSAweDFmICYgZmlyc3RCeXRlO1xuICAgICAgICAgICAgICBjb25zdCBlbmFibGVkID0gMHg0MCAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgY29uc3QgdG90YWxCeXRlcyA9IGVuYWJsZWQgPyAyICsgdG90YWxDQ3MgKiAzIDogMDtcbiAgICAgICAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlcyk7XG4gICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgYnl0ZUFycmF5WzBdID0gZmlyc3RCeXRlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdG90YWxCeXRlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBieXRlQXJyYXlbaV0gPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IHVzZXJEYXRhVHlwZSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICBwdHMsXG4gICAgICAgICAgICAgICAgYnl0ZXM6IGJ5dGVBcnJheSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkVHlwZSA9PT0gNSAmJiBwYXlsb2FkU2l6ZSA8IGxlZnRPdmVyKSB7XG4gICAgICBlbmRPZkNhcHRpb25zID0gdHJ1ZTtcblxuICAgICAgaWYgKHBheWxvYWRTaXplID4gMTYpIHtcbiAgICAgICAgY29uc3QgdXVpZFN0ckFycmF5OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGIgPSBkYXRhW3NlaVB0cisrXS50b1N0cmluZygxNik7XG4gICAgICAgICAgdXVpZFN0ckFycmF5LnB1c2goYi5sZW5ndGggPT0gMSA/ICcwJyArIGIgOiBiKTtcblxuICAgICAgICAgIGlmIChpID09PSAzIHx8IGkgPT09IDUgfHwgaSA9PT0gNyB8fCBpID09PSA5KSB7XG4gICAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBwYXlsb2FkU2l6ZSAtIDE2O1xuICAgICAgICBjb25zdCB1c2VyRGF0YUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHVzZXJEYXRhQnl0ZXNbaV0gPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgcHRzLFxuICAgICAgICAgIHV1aWQ6IHV1aWRTdHJBcnJheS5qb2luKCcnKSxcbiAgICAgICAgICB1c2VyRGF0YTogdXRmOEFycmF5VG9TdHIodXNlckRhdGFCeXRlcyksXG4gICAgICAgICAgdXNlckRhdGFCeXRlcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSA8IGxlZnRPdmVyKSB7XG4gICAgICBzZWlQdHIgKz0gcGF5bG9hZFNpemU7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSA+IGxlZnRPdmVyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiByZW1vdmUgRW11bGF0aW9uIFByZXZlbnRpb24gYnl0ZXMgZnJvbSBhIFJCU1BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2NhcmRFUEIoZGF0YTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gIGNvbnN0IEVQQlBvc2l0aW9ucyA9IFtdIGFzIEFycmF5PG51bWJlcj47XG4gIGxldCBpID0gMTtcblxuICAvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXG4gIHdoaWxlIChpIDwgbGVuZ3RoIC0gMikge1xuICAgIGlmIChkYXRhW2ldID09PSAwICYmIGRhdGFbaSArIDFdID09PSAwICYmIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG4gICAgICBFUEJQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICAvLyBJZiBubyBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB3ZXJlIGZvdW5kIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAvLyBhcnJheVxuICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcbiAgY29uc3QgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcbiAgY29uc3QgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gIGxldCBzb3VyY2VJbmRleCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4ID09PSBFUEJQb3NpdGlvbnNbMF0pIHtcbiAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICBzb3VyY2VJbmRleCsrO1xuICAgICAgLy8gUmVtb3ZlIHRoaXMgcG9zaXRpb24gaW5kZXhcbiAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgIH1cbiAgICBuZXdEYXRhW2ldID0gZGF0YVtzb3VyY2VJbmRleF07XG4gIH1cbiAgcmV0dXJuIG5ld0RhdGE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUVtc2coZGF0YTogVWludDhBcnJheSk6IElFbXNnUGFyc2luZ0RhdGEge1xuICBjb25zdCB2ZXJzaW9uID0gZGF0YVswXTtcbiAgbGV0IHNjaGVtZUlkVXJpOiBzdHJpbmcgPSAnJztcbiAgbGV0IHZhbHVlOiBzdHJpbmcgPSAnJztcbiAgbGV0IHRpbWVTY2FsZTogbnVtYmVyID0gMDtcbiAgbGV0IHByZXNlbnRhdGlvblRpbWVEZWx0YTogbnVtYmVyID0gMDtcbiAgbGV0IHByZXNlbnRhdGlvblRpbWU6IG51bWJlciA9IDA7XG4gIGxldCBldmVudER1cmF0aW9uOiBudW1iZXIgPSAwO1xuICBsZXQgaWQ6IG51bWJlciA9IDA7XG4gIGxldCBvZmZzZXQ6IG51bWJlciA9IDA7XG5cbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuXG4gICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuXG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cblxuICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcblxuICAgIHRpbWVTY2FsZSA9IHJlYWRVaW50MzIoZGF0YSwgMTIpO1xuICAgIHByZXNlbnRhdGlvblRpbWVEZWx0YSA9IHJlYWRVaW50MzIoZGF0YSwgMTYpO1xuICAgIGV2ZW50RHVyYXRpb24gPSByZWFkVWludDMyKGRhdGEsIDIwKTtcbiAgICBpZCA9IHJlYWRVaW50MzIoZGF0YSwgMjQpO1xuICAgIG9mZnNldCA9IDI4O1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB0aW1lU2NhbGUgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgY29uc3QgbGVmdFByZXNlbnRhdGlvblRpbWUgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgY29uc3QgcmlnaHRQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHByZXNlbnRhdGlvblRpbWUgPSAyICoqIDMyICogbGVmdFByZXNlbnRhdGlvblRpbWUgKyByaWdodFByZXNlbnRhdGlvblRpbWU7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihwcmVzZW50YXRpb25UaW1lKSkge1xuICAgICAgcHJlc2VudGF0aW9uVGltZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICdQcmVzZW50YXRpb24gdGltZSBleGNlZWRzIHNhZmUgaW50ZWdlciBsaW1pdCBhbmQgd3JhcHBlZCB0byBtYXggc2FmZSBpbnRlZ2VyIGluIHBhcnNpbmcgZW1zZyBib3gnXG4gICAgICApO1xuICAgIH1cblxuICAgIGV2ZW50RHVyYXRpb24gPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgaWQgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuXG4gICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuXG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cblxuICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gZGF0YS5zdWJhcnJheShvZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWVJZFVyaSxcbiAgICB2YWx1ZSxcbiAgICB0aW1lU2NhbGUsXG4gICAgcHJlc2VudGF0aW9uVGltZSxcbiAgICBwcmVzZW50YXRpb25UaW1lRGVsdGEsXG4gICAgZXZlbnREdXJhdGlvbixcbiAgICBpZCxcbiAgICBwYXlsb2FkLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXA0Qm94KHR5cGU6IEFycmF5TGlrZTxudW1iZXI+LCAuLi5wYXlsb2FkOiBVaW50OEFycmF5W10pIHtcbiAgY29uc3QgbGVuID0gcGF5bG9hZC5sZW5ndGg7XG4gIGxldCBzaXplID0gODtcbiAgbGV0IGkgPSBsZW47XG4gIHdoaWxlIChpLS0pIHtcbiAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgcmVzdWx0WzBdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgcmVzdWx0WzFdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgcmVzdWx0WzJdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgcmVzdWx0LnNldCh0eXBlLCA0KTtcbiAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1wNHBzc2goXG4gIHN5c3RlbUlkOiBVaW50OEFycmF5LFxuICBrZXlpZHM6IEFycmF5PFVpbnQ4QXJyYXk+IHwgbnVsbCxcbiAgZGF0YTogVWludDhBcnJheVxuKSB7XG4gIGlmIChzeXN0ZW1JZC5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN5c3RlbSBpZCcpO1xuICB9XG4gIGxldCB2ZXJzaW9uO1xuICBsZXQga2lkcztcbiAgaWYgKGtleWlkcykge1xuICAgIHZlcnNpb24gPSAxO1xuICAgIGtpZHMgPSBuZXcgVWludDhBcnJheShrZXlpZHMubGVuZ3RoICogMTYpO1xuICAgIGZvciAobGV0IGl4ID0gMDsgaXggPCBrZXlpZHMubGVuZ3RoOyBpeCsrKSB7XG4gICAgICBjb25zdCBrID0ga2V5aWRzW2l4XTsgLy8gdWludDhhcnJheVxuICAgICAgaWYgKGsuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICB9XG4gICAgICBraWRzLnNldChrLCBpeCAqIDE2KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmVyc2lvbiA9IDA7XG4gICAga2lkcyA9IG5ldyBVaW50OEFycmF5KCk7XG4gIH1cbiAgbGV0IGtpZENvdW50O1xuICBpZiAodmVyc2lvbiA+IDApIHtcbiAgICBraWRDb3VudCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGlmIChrZXlpZHMhLmxlbmd0aCA+IDApIHtcbiAgICAgIG5ldyBEYXRhVmlldyhraWRDb3VudC5idWZmZXIpLnNldFVpbnQzMigwLCBrZXlpZHMhLmxlbmd0aCwgZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBraWRDb3VudCA9IG5ldyBVaW50OEFycmF5KCk7XG4gIH1cbiAgY29uc3QgZGF0YVNpemUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgaWYgKGRhdGEgJiYgZGF0YS5ieXRlTGVuZ3RoID4gMCkge1xuICAgIG5ldyBEYXRhVmlldyhkYXRhU2l6ZS5idWZmZXIpLnNldFVpbnQzMigwLCBkYXRhLmJ5dGVMZW5ndGgsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gbXA0Qm94KFxuICAgIFsxMTIsIDExNSwgMTE1LCAxMDRdLFxuICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIHZlcnNpb24sXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIEZsYWdzXG4gICAgXSksXG4gICAgc3lzdGVtSWQsIC8vIDE2IGJ5dGVzXG4gICAga2lkQ291bnQsXG4gICAga2lkcyxcbiAgICBkYXRhU2l6ZSxcbiAgICBkYXRhIHx8IG5ldyBVaW50OEFycmF5KClcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHNzaChpbml0RGF0YTogQXJyYXlCdWZmZXIpIHtcbiAgaWYgKCEoaW5pdERhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgaW5pdERhdGEuYnl0ZUxlbmd0aCA8IDMyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHZlcnNpb246IDAsXG4gICAgc3lzdGVtSWQ6ICcnLFxuICAgIGtpZHM6IG51bGwgYXMgbnVsbCB8IFVpbnQ4QXJyYXlbXSxcbiAgICBkYXRhOiBudWxsIGFzIG51bGwgfCBVaW50OEFycmF5LFxuICB9O1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGluaXREYXRhKTtcbiAgY29uc3QgYm94U2l6ZSA9IHZpZXcuZ2V0VWludDMyKDApO1xuICBpZiAoaW5pdERhdGEuYnl0ZUxlbmd0aCAhPT0gYm94U2l6ZSAmJiBib3hTaXplID4gNDQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB0eXBlID0gdmlldy5nZXRVaW50MzIoNCk7XG4gIGlmICh0eXBlICE9PSAweDcwNzM3MzY4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVzdWx0LnZlcnNpb24gPSB2aWV3LmdldFVpbnQzMig4KSA+Pj4gMjQ7XG4gIGlmIChyZXN1bHQudmVyc2lvbiA+IDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXN1bHQuc3lzdGVtSWQgPSBIZXguaGV4RHVtcChuZXcgVWludDhBcnJheShpbml0RGF0YSwgMTIsIDE2KSk7XG4gIGNvbnN0IGRhdGFTaXplT3JLaWRDb3VudCA9IHZpZXcuZ2V0VWludDMyKDI4KTtcbiAgaWYgKHJlc3VsdC52ZXJzaW9uID09PSAwKSB7XG4gICAgaWYgKGJveFNpemUgLSAzMiA8IGRhdGFTaXplT3JLaWRDb3VudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEsIDMyLCBkYXRhU2l6ZU9yS2lkQ291bnQpO1xuICB9IGVsc2UgaWYgKHJlc3VsdC52ZXJzaW9uID09PSAxKSB7XG4gICAgcmVzdWx0LmtpZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFTaXplT3JLaWRDb3VudDsgaSsrKSB7XG4gICAgICByZXN1bHQua2lkcy5wdXNoKG5ldyBVaW50OEFycmF5KGluaXREYXRhLCAzMiArIGkgKiAxNiwgMTYpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7XG4gIGNoYW5nZUVuZGlhbm5lc3MsXG4gIGNvbnZlcnREYXRhVXJpVG9BcnJheUJ5dGVzLFxufSBmcm9tICcuLi91dGlscy9rZXlzeXN0ZW0tdXRpbCc7XG5pbXBvcnQgeyBLZXlTeXN0ZW1Gb3JtYXRzIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFrZXlzLWhlbHBlcic7XG5pbXBvcnQgeyBtcDRwc3NoIH0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBiYXNlNjREZWNvZGUgfSBmcm9tICcuLi91dGlscy9udW1lcmljLWVuY29kaW5nLXV0aWxzJztcblxubGV0IGtleVVyaVRvS2V5SWRNYXA6IHsgW3VyaTogc3RyaW5nXTogVWludDhBcnJheSB9ID0ge307XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVjcnlwdERhdGEge1xuICB1cmk6IHN0cmluZztcbiAgbWV0aG9kOiBzdHJpbmc7XG4gIGtleUZvcm1hdDogc3RyaW5nO1xuICBrZXlGb3JtYXRWZXJzaW9uczogbnVtYmVyW107XG4gIGl2OiBVaW50OEFycmF5IHwgbnVsbDtcbiAga2V5OiBVaW50OEFycmF5IHwgbnVsbDtcbiAga2V5SWQ6IFVpbnQ4QXJyYXkgfCBudWxsO1xuICBwc3NoOiBVaW50OEFycmF5IHwgbnVsbDtcbiAgZW5jcnlwdGVkOiBib29sZWFuO1xuICBpc0NvbW1vbkVuY3J5cHRpb246IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBMZXZlbEtleSBpbXBsZW1lbnRzIERlY3J5cHREYXRhIHtcbiAgcHVibGljIHJlYWRvbmx5IHVyaTogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgbWV0aG9kOiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBrZXlGb3JtYXQ6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGtleUZvcm1hdFZlcnNpb25zOiBudW1iZXJbXTtcbiAgcHVibGljIHJlYWRvbmx5IGVuY3J5cHRlZDogYm9vbGVhbjtcbiAgcHVibGljIHJlYWRvbmx5IGlzQ29tbW9uRW5jcnlwdGlvbjogYm9vbGVhbjtcbiAgcHVibGljIGl2OiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBrZXk6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGtleUlkOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBwc3NoOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG5cbiAgc3RhdGljIGNsZWFyS2V5VXJpVG9LZXlJZE1hcCgpIHtcbiAgICBrZXlVcmlUb0tleUlkTWFwID0ge307XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBtZXRob2Q6IHN0cmluZyxcbiAgICB1cmk6IHN0cmluZyxcbiAgICBmb3JtYXQ6IHN0cmluZyxcbiAgICBmb3JtYXR2ZXJzaW9uczogbnVtYmVyW10gPSBbMV0sXG4gICAgaXY6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbFxuICApIHtcbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICB0aGlzLmtleUZvcm1hdCA9IGZvcm1hdDtcbiAgICB0aGlzLmtleUZvcm1hdFZlcnNpb25zID0gZm9ybWF0dmVyc2lvbnM7XG4gICAgdGhpcy5pdiA9IGl2O1xuICAgIHRoaXMuZW5jcnlwdGVkID0gbWV0aG9kID8gbWV0aG9kICE9PSAnTk9ORScgOiBmYWxzZTtcbiAgICB0aGlzLmlzQ29tbW9uRW5jcnlwdGlvbiA9IHRoaXMuZW5jcnlwdGVkICYmIG1ldGhvZCAhPT0gJ0FFUy0xMjgnO1xuICB9XG5cbiAgcHVibGljIGlzU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xuICAgIC8vIElmIGl0J3MgU2VnbWVudCBlbmNyeXB0aW9uIG9yIE5vIGVuY3J5cHRpb24sIGp1c3Qgc2VsZWN0IHRoYXQga2V5IHN5c3RlbVxuICAgIGlmICh0aGlzLm1ldGhvZCkge1xuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnQUVTLTEyOCcgfHwgdGhpcy5tZXRob2QgPT09ICdOT05FJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmtleUZvcm1hdCA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAvLyBNYWludGFpbiBzdXBwb3J0IGZvciBjbGVhciBTQU1QTEUtQUVTIHdpdGggTVBFRy0zIFRTXG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZCA9PT0gJ1NBTVBMRS1BRVMnO1xuICAgICAgfSBlbHNlIGlmIChfX1VTRV9FTUVfRFJNX18pIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmtleUZvcm1hdCkge1xuICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTpcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuV0lERVZJTkU6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLlBMQVlSRUFEWTpcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuQ0xFQVJLRVk6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ0lTTy0yMzAwMS03JyxcbiAgICAgICAgICAgICAgICAnU0FNUExFLUFFUycsXG4gICAgICAgICAgICAgICAgJ1NBTVBMRS1BRVMtQ0VOQycsXG4gICAgICAgICAgICAgICAgJ1NBTVBMRS1BRVMtQ1RSJyxcbiAgICAgICAgICAgICAgXS5pbmRleE9mKHRoaXMubWV0aG9kKSAhPT0gLTFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGdldERlY3J5cHREYXRhKHNuOiBudW1iZXIgfCAnaW5pdFNlZ21lbnQnKTogTGV2ZWxLZXkgfCBudWxsIHtcbiAgICBpZiAoIXRoaXMuZW5jcnlwdGVkIHx8ICF0aGlzLnVyaSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWV0aG9kID09PSAnQUVTLTEyOCcgJiYgdGhpcy51cmkgJiYgIXRoaXMuaXYpIHtcbiAgICAgIGlmICh0eXBlb2Ygc24gIT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIFdlIGFyZSBmZXRjaGluZyBkZWNyeXB0aW9uIGRhdGEgZm9yIGEgaW5pdGlhbGl6YXRpb24gc2VnbWVudFxuICAgICAgICAvLyBJZiB0aGUgc2VnbWVudCB3YXMgZW5jcnlwdGVkIHdpdGggQUVTLTEyOFxuICAgICAgICAvLyBJdCBtdXN0IGhhdmUgYW4gSVYgZGVmaW5lZC4gV2UgY2Fubm90IHN1YnN0aXR1dGUgdGhlIFNlZ21lbnQgTnVtYmVyIGluLlxuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09ICdBRVMtMTI4JyAmJiAhdGhpcy5pdikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYG1pc3NpbmcgSVYgZm9yIGluaXRpYWxpemF0aW9uIHNlZ21lbnQgd2l0aCBtZXRob2Q9XCIke3RoaXMubWV0aG9kfVwiIC0gY29tcGxpYW5jZSBpc3N1ZWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHNuIHRvIHJlc3VsdGluZyB2YWx1ZSBmcm9tIGltcGxpY2l0IGNvbnZlcnNpb25zICdpbml0U2VnbWVudCcgdmFsdWVzIGZvciBJViBnZW5lcmF0aW9uLlxuICAgICAgICBzbiA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBpdiA9IGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNuKTtcbiAgICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gbmV3IExldmVsS2V5KFxuICAgICAgICB0aGlzLm1ldGhvZCxcbiAgICAgICAgdGhpcy51cmksXG4gICAgICAgICdpZGVudGl0eScsXG4gICAgICAgIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMsXG4gICAgICAgIGl2XG4gICAgICApO1xuICAgICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICAgIH1cblxuICAgIGlmICghX19VU0VfRU1FX0RSTV9fKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIGtleUlkIGlmIHBvc3NpYmxlXG4gICAgY29uc3Qga2V5Qnl0ZXMgPSBjb252ZXJ0RGF0YVVyaVRvQXJyYXlCeXRlcyh0aGlzLnVyaSk7XG4gICAgaWYgKGtleUJ5dGVzKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMua2V5Rm9ybWF0KSB7XG4gICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORTpcbiAgICAgICAgICB0aGlzLnBzc2ggPSBrZXlCeXRlcztcbiAgICAgICAgICAvLyBJbiBjYXNlIG9mIHdpZGV2aW5lIGtleUlEIGlzIGVtYmVkZGVkIGluIFBTU0ggYm94LiBSZWFkIEtleSBJRC5cbiAgICAgICAgICBpZiAoa2V5Qnl0ZXMubGVuZ3RoID49IDIyKSB7XG4gICAgICAgICAgICB0aGlzLmtleUlkID0ga2V5Qnl0ZXMuc3ViYXJyYXkoXG4gICAgICAgICAgICAgIGtleUJ5dGVzLmxlbmd0aCAtIDIyLFxuICAgICAgICAgICAgICBrZXlCeXRlcy5sZW5ndGggLSA2XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLlBMQVlSRUFEWToge1xuICAgICAgICAgIGNvbnN0IFBsYXlSZWFkeUtleVN5c3RlbVVVSUQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDlhLCAweDA0LCAweGYwLCAweDc5LCAweDk4LCAweDQwLCAweDQyLCAweDg2LCAweGFiLCAweDkyLCAweGU2LFxuICAgICAgICAgICAgMHg1YiwgMHhlMCwgMHg4OCwgMHg1ZiwgMHg5NSxcbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIHRoaXMucHNzaCA9IG1wNHBzc2goUGxheVJlYWR5S2V5U3lzdGVtVVVJRCwgbnVsbCwga2V5Qnl0ZXMpO1xuXG4gICAgICAgICAgY29uc3Qga2V5Qnl0ZXNVdGYxNiA9IG5ldyBVaW50MTZBcnJheShcbiAgICAgICAgICAgIGtleUJ5dGVzLmJ1ZmZlcixcbiAgICAgICAgICAgIGtleUJ5dGVzLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICBrZXlCeXRlcy5ieXRlTGVuZ3RoIC8gMlxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qga2V5Qnl0ZVN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgQXJyYXkuZnJvbShrZXlCeXRlc1V0ZjE2KVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBQYXJzZSBQbGF5cmVhZHkgV1JNSGVhZGVyIFhNTFxuICAgICAgICAgIGNvbnN0IHhtbEtleUJ5dGVzID0ga2V5Qnl0ZVN0ci5zdWJzdHJpbmcoXG4gICAgICAgICAgICBrZXlCeXRlU3RyLmluZGV4T2YoJzwnKSxcbiAgICAgICAgICAgIGtleUJ5dGVTdHIubGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgICAgY29uc3QgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWxLZXlCeXRlcywgJ3RleHQveG1sJyk7XG4gICAgICAgICAgY29uc3Qga2V5RGF0YSA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnS0lEJylbMF07XG4gICAgICAgICAgaWYgKGtleURhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleUlkID0ga2V5RGF0YS5jaGlsZE5vZGVzWzBdXG4gICAgICAgICAgICAgID8ga2V5RGF0YS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZVxuICAgICAgICAgICAgICA6IGtleURhdGEuZ2V0QXR0cmlidXRlKCdWQUxVRScpO1xuICAgICAgICAgICAgaWYgKGtleUlkKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtleUlkQXJyYXkgPSBiYXNlNjREZWNvZGUoa2V5SWQpLnN1YmFycmF5KDAsIDE2KTtcbiAgICAgICAgICAgICAgLy8gS0lEIHZhbHVlIGluIFBSTyBpcyBhIGJhc2U2NC1lbmNvZGVkIGxpdHRsZSBlbmRpYW4gR1VJRCBpbnRlcnByZXRhdGlvbiBvZiBVVUlEXG4gICAgICAgICAgICAgIC8vIEtJRCB2YWx1ZSBpbiDigJh0ZW5j4oCZIGlzIGEgYmlnIGVuZGlhbiBVVUlEIEdVSUQgaW50ZXJwcmV0YXRpb24gb2YgVVVJRFxuICAgICAgICAgICAgICBjaGFuZ2VFbmRpYW5uZXNzKGtleUlkQXJyYXkpO1xuICAgICAgICAgICAgICB0aGlzLmtleUlkID0ga2V5SWRBcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGxldCBrZXlkYXRhID0ga2V5Qnl0ZXMuc3ViYXJyYXkoMCwgMTYpO1xuICAgICAgICAgIGlmIChrZXlkYXRhLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZGRlZCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgICAgIHBhZGRlZC5zZXQoa2V5ZGF0YSwgMTYgLSBrZXlkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBrZXlkYXRhID0gcGFkZGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmtleUlkID0ga2V5ZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3I6IGFzc2lnbiBhIG5ldyBrZXlJZCBmb3IgZWFjaCB1cmlcbiAgICBpZiAoIXRoaXMua2V5SWQgfHwgdGhpcy5rZXlJZC5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgbGV0IGtleUlkID0ga2V5VXJpVG9LZXlJZE1hcFt0aGlzLnVyaV07XG4gICAgICBpZiAoIWtleUlkKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9XG4gICAgICAgICAgT2JqZWN0LmtleXMoa2V5VXJpVG9LZXlJZE1hcCkubGVuZ3RoICUgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIGtleUlkID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhrZXlJZC5idWZmZXIsIDEyLCA0KTsgLy8gSnVzdCBzZXQgdGhlIGxhc3QgNCBieXRlc1xuICAgICAgICBkdi5zZXRVaW50MzIoMCwgdmFsKTtcbiAgICAgICAga2V5VXJpVG9LZXlJZE1hcFt0aGlzLnVyaV0gPSBrZXlJZDtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5SWQgPSBrZXlJZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyOiBudW1iZXIpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBmb3IgKGxldCBpID0gMTI7IGkgPCAxNjsgaSsrKSB7XG4gICAgdWludDhWaWV3W2ldID0gKHNlZ21lbnROdW1iZXIgPj4gKDggKiAoMTUgLSBpKSkpICYgMHhmZjtcbiAgfVxuICByZXR1cm4gdWludDhWaWV3O1xufVxuIiwiLyoqXG4gKiBNZWRpYVNvdXJjZSBoZWxwZXJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVkaWFTb3VyY2UoKTogdHlwZW9mIE1lZGlhU291cmNlIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIHNlbGYuTWVkaWFTb3VyY2UgfHwgKChzZWxmIGFzIGFueSkuV2ViS2l0TWVkaWFTb3VyY2UgYXMgTWVkaWFTb3VyY2UpO1xufVxuIiwiaW1wb3J0IHsgZ2V0TWVkaWFTb3VyY2UgfSBmcm9tICcuL21lZGlhc291cmNlLWhlbHBlcic7XG5cbi8vIGZyb20gaHR0cDovL21wNHJhLm9yZy9jb2RlY3MuaHRtbFxuY29uc3Qgc2FtcGxlRW50cnlDb2Rlc0lTTyA9IHtcbiAgYXVkaW86IHtcbiAgICBhM2RzOiB0cnVlLFxuICAgICdhYy0zJzogdHJ1ZSxcbiAgICAnYWMtNCc6IHRydWUsXG4gICAgYWxhYzogdHJ1ZSxcbiAgICBhbGF3OiB0cnVlLFxuICAgIGRyYTE6IHRydWUsXG4gICAgJ2R0cysnOiB0cnVlLFxuICAgICdkdHMtJzogdHJ1ZSxcbiAgICBkdHNjOiB0cnVlLFxuICAgIGR0c2U6IHRydWUsXG4gICAgZHRzaDogdHJ1ZSxcbiAgICAnZWMtMyc6IHRydWUsXG4gICAgZW5jYTogdHJ1ZSxcbiAgICBnNzE5OiB0cnVlLFxuICAgIGc3MjY6IHRydWUsXG4gICAgbTRhZTogdHJ1ZSxcbiAgICBtaGExOiB0cnVlLFxuICAgIG1oYTI6IHRydWUsXG4gICAgbWhtMTogdHJ1ZSxcbiAgICBtaG0yOiB0cnVlLFxuICAgIG1scGE6IHRydWUsXG4gICAgbXA0YTogdHJ1ZSxcbiAgICAncmF3ICc6IHRydWUsXG4gICAgT3B1czogdHJ1ZSxcbiAgICBvcHVzOiB0cnVlLCAvLyBicm93c2VycyBleHBlY3QgdGhpcyB0byBiZSBsb3dlcmNhc2UgZGVzcGl0ZSBNUDRSQSBzYXlzICdPcHVzJ1xuICAgIHNhbXI6IHRydWUsXG4gICAgc2F3YjogdHJ1ZSxcbiAgICBzYXdwOiB0cnVlLFxuICAgIHNldmM6IHRydWUsXG4gICAgc3FjcDogdHJ1ZSxcbiAgICBzc212OiB0cnVlLFxuICAgIHR3b3M6IHRydWUsXG4gICAgdWxhdzogdHJ1ZSxcbiAgfSxcbiAgdmlkZW86IHtcbiAgICBhdmMxOiB0cnVlLFxuICAgIGF2YzI6IHRydWUsXG4gICAgYXZjMzogdHJ1ZSxcbiAgICBhdmM0OiB0cnVlLFxuICAgIGF2Y3A6IHRydWUsXG4gICAgYXYwMTogdHJ1ZSxcbiAgICBkcmFjOiB0cnVlLFxuICAgIGR2YTE6IHRydWUsXG4gICAgZHZhdjogdHJ1ZSxcbiAgICBkdmgxOiB0cnVlLFxuICAgIGR2aGU6IHRydWUsXG4gICAgZW5jdjogdHJ1ZSxcbiAgICBoZXYxOiB0cnVlLFxuICAgIGh2YzE6IHRydWUsXG4gICAgbWpwMjogdHJ1ZSxcbiAgICBtcDR2OiB0cnVlLFxuICAgIG12YzE6IHRydWUsXG4gICAgbXZjMjogdHJ1ZSxcbiAgICBtdmMzOiB0cnVlLFxuICAgIG12YzQ6IHRydWUsXG4gICAgcmVzdjogdHJ1ZSxcbiAgICBydjYwOiB0cnVlLFxuICAgIHMyNjM6IHRydWUsXG4gICAgc3ZjMTogdHJ1ZSxcbiAgICBzdmMyOiB0cnVlLFxuICAgICd2Yy0xJzogdHJ1ZSxcbiAgICB2cDA4OiB0cnVlLFxuICAgIHZwMDk6IHRydWUsXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBzdHBwOiB0cnVlLFxuICAgIHd2dHQ6IHRydWUsXG4gIH0sXG59O1xuXG5jb25zdCBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKCk7XG5cbmV4cG9ydCB0eXBlIENvZGVjVHlwZSA9ICdhdWRpbycgfCAndmlkZW8nO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDb2RlY1R5cGUoY29kZWM6IHN0cmluZywgdHlwZTogQ29kZWNUeXBlKTogYm9vbGVhbiB7XG4gIGNvbnN0IHR5cGVDb2RlcyA9IHNhbXBsZUVudHJ5Q29kZXNJU09bdHlwZV07XG4gIHJldHVybiAhIXR5cGVDb2RlcyAmJiB0eXBlQ29kZXNbY29kZWMuc2xpY2UoMCwgNCldID09PSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDb2RlY1N1cHBvcnRlZEluTXA0KGNvZGVjOiBzdHJpbmcsIHR5cGU6IENvZGVjVHlwZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIE1lZGlhU291cmNlPy5pc1R5cGVTdXBwb3J0ZWQoYCR7dHlwZSB8fCAndmlkZW8nfS9tcDQ7Y29kZWNzPVwiJHtjb2RlY31cImApID8/XG4gICAgZmFsc2VcbiAgKTtcbn1cbiIsImltcG9ydCB7IGJ1aWxkQWJzb2x1dGVVUkwgfSBmcm9tICd1cmwtdG9vbGtpdCc7XG5pbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuL2RhdGUtcmFuZ2UnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFBhcnQgfSBmcm9tICcuL2ZyYWdtZW50JztcbmltcG9ydCB7IExldmVsRGV0YWlscyB9IGZyb20gJy4vbGV2ZWwtZGV0YWlscyc7XG5pbXBvcnQgeyBMZXZlbEtleSB9IGZyb20gJy4vbGV2ZWwta2V5JztcbmltcG9ydCB7IEF0dHJMaXN0IH0gZnJvbSAnLi4vdXRpbHMvYXR0ci1saXN0JztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQge1xuICBhZGRWYXJpYWJsZURlZmluaXRpb24sXG4gIGhhc1ZhcmlhYmxlUmVmZXJlbmNlcyxcbiAgaW1wb3J0VmFyaWFibGVEZWZpbml0aW9uLFxuICBzdWJzdGl0dXRlVmFyaWFibGVzLFxuICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzLFxufSBmcm9tICcuLi91dGlscy92YXJpYWJsZS1zdWJzdGl0dXRpb24nO1xuaW1wb3J0IHsgaXNDb2RlY1R5cGUgfSBmcm9tICcuLi91dGlscy9jb2RlY3MnO1xuaW1wb3J0IHR5cGUgeyBDb2RlY1R5cGUgfSBmcm9tICcuLi91dGlscy9jb2RlY3MnO1xuaW1wb3J0IHR5cGUge1xuICBNZWRpYVBsYXlsaXN0LFxuICBBdWRpb0dyb3VwLFxuICBNZWRpYVBsYXlsaXN0VHlwZSxcbiAgTWVkaWFBdHRyaWJ1dGVzLFxufSBmcm9tICcuLi90eXBlcy9tZWRpYS1wbGF5bGlzdCc7XG5pbXBvcnQgdHlwZSB7IFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB0eXBlIHsgTGV2ZWxBdHRyaWJ1dGVzLCBMZXZlbFBhcnNlZCwgVmFyaWFibGVNYXAgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgdHlwZSB7IENvbnRlbnRTdGVlcmluZ09wdGlvbnMgfSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuXG50eXBlIE0zVThQYXJzZXJGcmFnbWVudHMgPSBBcnJheTxGcmFnbWVudCB8IG51bGw+O1xuXG5leHBvcnQgdHlwZSBQYXJzZWRNdWx0aXZhcmlhbnRQbGF5bGlzdCA9IHtcbiAgY29udGVudFN0ZWVyaW5nOiBDb250ZW50U3RlZXJpbmdPcHRpb25zIHwgbnVsbDtcbiAgbGV2ZWxzOiBMZXZlbFBhcnNlZFtdO1xuICBwbGF5bGlzdFBhcnNpbmdFcnJvcjogRXJyb3IgfCBudWxsO1xuICBzZXNzaW9uRGF0YTogUmVjb3JkPHN0cmluZywgQXR0ckxpc3Q+IHwgbnVsbDtcbiAgc2Vzc2lvbktleXM6IExldmVsS2V5W10gfCBudWxsO1xuICBzdGFydFRpbWVPZmZzZXQ6IG51bWJlciB8IG51bGw7XG4gIHZhcmlhYmxlTGlzdDogVmFyaWFibGVNYXAgfCBudWxsO1xuICBoYXNWYXJpYWJsZVJlZnM6IGJvb2xlYW47XG59O1xuXG50eXBlIFBhcnNlZE11bHRpdmFyaWFudE1lZGlhT3B0aW9ucyA9IHtcbiAgQVVESU8/OiBNZWRpYVBsYXlsaXN0W107XG4gIFNVQlRJVExFUz86IE1lZGlhUGxheWxpc3RbXTtcbiAgJ0NMT1NFRC1DQVBUSU9OUyc/OiBNZWRpYVBsYXlsaXN0W107XG59O1xuXG5jb25zdCBNQVNURVJfUExBWUxJU1RfUkVHRVggPVxuICAvI0VYVC1YLVNUUkVBTS1JTkY6KFteXFxyXFxuXSopKD86W1xcclxcbl0oPzojW15cXHJcXG5dKik/KSooW15cXHJcXG5dKyl8I0VYVC1YLShTRVNTSU9OLURBVEF8U0VTU0lPTi1LRVl8REVGSU5FfENPTlRFTlQtU1RFRVJJTkd8U1RBUlQpOihbXlxcclxcbl0qKVtcXHJcXG5dKy9nO1xuY29uc3QgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYID0gLyNFWFQtWC1NRURJQTooLiopL2c7XG5cbmNvbnN0IElTX01FRElBX1BMQVlMSVNUID0gL14jRVhUKD86SU5GfC1YLVRBUkdFVERVUkFUSU9OKTovbTsgLy8gSGFuZGxlIGVtcHR5IE1lZGlhIFBsYXlsaXN0IChmaXJzdCBFWFRJTkYgbm90IHNpZ25hbGVkLCBidXQgVEFSR0VURFVSQVRJT04gcHJlc2VudClcblxuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVCA9IG5ldyBSZWdFeHAoXG4gIFtcbiAgICAvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSwgLy8gZHVyYXRpb24gKCNFWFRJTkY6PGR1cmF0aW9uPiw8dGl0bGU+KSwgZ3JvdXAgMSA9PiBkdXJhdGlvbiwgZ3JvdXAgMiA9PiB0aXRsZVxuICAgIC8oPyEjKSAqKFxcU1tcXFMgXSopLy5zb3VyY2UsIC8vIHNlZ21lbnQgVVJJLCBncm91cCAzID0+IHRoZSBVUkkgKG5vdGUgbmV3bGluZSBpcyBub3QgZWF0ZW4pXG4gICAgLyNFWFQtWC1CWVRFUkFOR0U6KiguKykvLnNvdXJjZSwgLy8gbmV4dCBzZWdtZW50J3MgYnl0ZXJhbmdlLCBncm91cCA0ID0+IHJhbmdlIHNwZWMgKHhAeSlcbiAgICAvI0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKykvLnNvdXJjZSwgLy8gbmV4dCBzZWdtZW50J3MgcHJvZ3JhbSBkYXRlL3RpbWUgZ3JvdXAgNSA9PiB0aGUgZGF0ZXRpbWUgc3BlY1xuICAgIC8jLiovLnNvdXJjZSwgLy8gQWxsIG90aGVyIG5vbi1zZWdtZW50IG9yaWVudGVkIHRhZ3Mgd2lsbCBtYXRjaCB3aXRoIGFsbCBncm91cHMgZW1wdHlcbiAgXS5qb2luKCd8JyksXG4gICdnJ1xuKTtcblxuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyA9IG5ldyBSZWdFeHAoXG4gIFtcbiAgICAvIyhFWFRNM1UpLy5zb3VyY2UsXG4gICAgLyNFWFQtWC0oREFURVJBTkdFfERFRklORXxLRVl8TUFQfFBBUlR8UEFSVC1JTkZ8UExBWUxJU1QtVFlQRXxQUkVMT0FELUhJTlR8UkVORElUSU9OLVJFUE9SVHxTRVJWRVItQ09OVFJPTHxTS0lQfFNUQVJUKTooLispL1xuICAgICAgLnNvdXJjZSxcbiAgICAvI0VYVC1YLShCSVRSQVRFfERJU0NPTlRJTlVJVFktU0VRVUVOQ0V8TUVESUEtU0VRVUVOQ0V8VEFSR0VURFVSQVRJT058VkVSU0lPTik6ICooXFxkKykvXG4gICAgICAuc291cmNlLFxuICAgIC8jRVhULVgtKERJU0NPTlRJTlVJVFl8RU5ETElTVHxHQVApLy5zb3VyY2UsXG4gICAgLygjKShbXjpdKik6KC4qKS8uc291cmNlLFxuICAgIC8oIykoLiopKD86LiopXFxyP1xcbj8vLnNvdXJjZSxcbiAgXS5qb2luKCd8Jylcbik7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE0zVThQYXJzZXIge1xuICBzdGF0aWMgZmluZEdyb3VwKFxuICAgIGdyb3VwczogQXJyYXk8QXVkaW9Hcm91cD4sXG4gICAgbWVkaWFHcm91cElkOiBzdHJpbmdcbiAgKTogQXVkaW9Hcm91cCB8IHVuZGVmaW5lZCB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgaWYgKGdyb3VwLmlkID09PSBtZWRpYUdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBjb252ZXJ0QVZDMVRvQVZDT1RJKGNvZGVjKSB7XG4gICAgLy8gQ29udmVydCBhdmMxIGNvZGVjIHN0cmluZyBmcm9tIFJGQy00MjgxIHRvIFJGQy02MzgxIGZvciBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWRcbiAgICBjb25zdCBhdmNkYXRhID0gY29kZWMuc3BsaXQoJy4nKTtcbiAgICBpZiAoYXZjZGF0YS5sZW5ndGggPiAyKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gYXZjZGF0YS5zaGlmdCgpICsgJy4nO1xuICAgICAgcmVzdWx0ICs9IHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpO1xuICAgICAgcmVzdWx0ICs9ICgnMDAwJyArIHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gY29kZWM7XG4gIH1cblxuICBzdGF0aWMgcmVzb2x2ZSh1cmwsIGJhc2VVcmwpIHtcbiAgICByZXR1cm4gYnVpbGRBYnNvbHV0ZVVSTChiYXNlVXJsLCB1cmwsIHsgYWx3YXlzTm9ybWFsaXplOiB0cnVlIH0pO1xuICB9XG5cbiAgc3RhdGljIGlzTWVkaWFQbGF5bGlzdChzdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBJU19NRURJQV9QTEFZTElTVC50ZXN0KHN0cik7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VNYXN0ZXJQbGF5bGlzdChcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICBiYXNldXJsOiBzdHJpbmdcbiAgKTogUGFyc2VkTXVsdGl2YXJpYW50UGxheWxpc3Qge1xuICAgIGNvbnN0IGhhc1ZhcmlhYmxlUmVmcyA9IF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fXG4gICAgICA/IGhhc1ZhcmlhYmxlUmVmZXJlbmNlcyhzdHJpbmcpXG4gICAgICA6IGZhbHNlO1xuICAgIGNvbnN0IHBhcnNlZDogUGFyc2VkTXVsdGl2YXJpYW50UGxheWxpc3QgPSB7XG4gICAgICBjb250ZW50U3RlZXJpbmc6IG51bGwsXG4gICAgICBsZXZlbHM6IFtdLFxuICAgICAgcGxheWxpc3RQYXJzaW5nRXJyb3I6IG51bGwsXG4gICAgICBzZXNzaW9uRGF0YTogbnVsbCxcbiAgICAgIHNlc3Npb25LZXlzOiBudWxsLFxuICAgICAgc3RhcnRUaW1lT2Zmc2V0OiBudWxsLFxuICAgICAgdmFyaWFibGVMaXN0OiBudWxsLFxuICAgICAgaGFzVmFyaWFibGVSZWZzLFxuICAgIH07XG4gICAgY29uc3QgbGV2ZWxzV2l0aEtub3duQ29kZWNzOiBMZXZlbFBhcnNlZFtdID0gW107XG5cbiAgICBNQVNURVJfUExBWUxJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcblxuICAgIGxldCByZXN1bHQ6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGw7XG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKSB7XG4gICAgICBpZiAocmVzdWx0WzFdKSB7XG4gICAgICAgIC8vICcjRVhULVgtU1RSRUFNLUlORicgaXMgZm91bmQsIHBhcnNlIGxldmVsIHRhZyAgaW4gZ3JvdXAgMVxuICAgICAgICBjb25zdCBhdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pIGFzIExldmVsQXR0cmlidXRlcztcbiAgICAgICAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIGF0dHJzLCBbXG4gICAgICAgICAgICAnQ09ERUNTJyxcbiAgICAgICAgICAgICdTVVBQTEVNRU5UQUwtQ09ERUNTJyxcbiAgICAgICAgICAgICdBTExPV0VELUNQQycsXG4gICAgICAgICAgICAnUEFUSFdBWS1JRCcsXG4gICAgICAgICAgICAnU1RBQkxFLVZBUklBTlQtSUQnLFxuICAgICAgICAgICAgJ0FVRElPJyxcbiAgICAgICAgICAgICdWSURFTycsXG4gICAgICAgICAgICAnU1VCVElUTEVTJyxcbiAgICAgICAgICAgICdDTE9TRUQtQ0FQVElPTlMnLFxuICAgICAgICAgICAgJ05BTUUnLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fXG4gICAgICAgICAgPyBzdWJzdGl0dXRlVmFyaWFibGVzKHBhcnNlZCwgcmVzdWx0WzJdKVxuICAgICAgICAgIDogcmVzdWx0WzJdO1xuICAgICAgICBjb25zdCBsZXZlbDogTGV2ZWxQYXJzZWQgPSB7XG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgYml0cmF0ZTpcbiAgICAgICAgICAgIGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdBVkVSQUdFLUJBTkRXSURUSCcpIHx8XG4gICAgICAgICAgICBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyksXG4gICAgICAgICAgbmFtZTogYXR0cnMuTkFNRSxcbiAgICAgICAgICB1cmw6IE0zVThQYXJzZXIucmVzb2x2ZSh1cmksIGJhc2V1cmwpLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xuICAgICAgICBpZiAocmVzb2x1dGlvbikge1xuICAgICAgICAgIGxldmVsLndpZHRoID0gcmVzb2x1dGlvbi53aWR0aDtcbiAgICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldENvZGVjcyhcbiAgICAgICAgICAoKGF0dHJzLkNPREVDUyBhcyBzdHJpbmcpIHx8ICcnKS5zcGxpdCgvWyAsXSsvKS5maWx0ZXIoKGMpID0+IGMpLFxuICAgICAgICAgIGxldmVsXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGxldmVsLnZpZGVvQ29kZWMgJiYgbGV2ZWwudmlkZW9Db2RlYy5pbmRleE9mKCdhdmMxJykgIT09IC0xKSB7XG4gICAgICAgICAgbGV2ZWwudmlkZW9Db2RlYyA9IE0zVThQYXJzZXIuY29udmVydEFWQzFUb0FWQ09USShsZXZlbC52aWRlb0NvZGVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGV2ZWwudW5rbm93bkNvZGVjcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgbGV2ZWxzV2l0aEtub3duQ29kZWNzLnB1c2gobGV2ZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHJlc3VsdFszXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHJlc3VsdFs0XTtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICBjYXNlICdTRVNTSU9OLURBVEEnOiB7XG4gICAgICAgICAgICAvLyAjRVhULVgtU0VTU0lPTi1EQVRBXG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uQXR0cnMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICBpZiAoX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX18pIHtcbiAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIHNlc3Npb25BdHRycywgW1xuICAgICAgICAgICAgICAgICdEQVRBLUlEJyxcbiAgICAgICAgICAgICAgICAnTEFOR1VBR0UnLFxuICAgICAgICAgICAgICAgICdWQUxVRScsXG4gICAgICAgICAgICAgICAgJ1VSSScsXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YUlkID0gc2Vzc2lvbkF0dHJzWydEQVRBLUlEJ107XG4gICAgICAgICAgICBpZiAoZGF0YUlkKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJzZWQuc2Vzc2lvbkRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbkRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbkRhdGFbZGF0YUlkXSA9IHNlc3Npb25BdHRycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTRVNTSU9OLUtFWSc6IHtcbiAgICAgICAgICAgIC8vICNFWFQtWC1TRVNTSU9OLUtFWVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbktleSA9IHBhcnNlS2V5KGF0dHJpYnV0ZXMsIGJhc2V1cmwsIHBhcnNlZCk7XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbktleS5lbmNyeXB0ZWQgJiYgc2Vzc2lvbktleS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJzZWQuc2Vzc2lvbktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbktleXMgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbktleXMucHVzaChzZXNzaW9uS2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgIGBbS2V5c10gSWdub3JpbmcgaW52YWxpZCBFWFQtWC1TRVNTSU9OLUtFWSB0YWc6IFwiJHthdHRyaWJ1dGVzfVwiYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0RFRklORSc6IHtcbiAgICAgICAgICAgIC8vICNFWFQtWC1ERUZJTkVcbiAgICAgICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZUF0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIFtcbiAgICAgICAgICAgICAgICAnTkFNRScsXG4gICAgICAgICAgICAgICAgJ1ZBTFVFJyxcbiAgICAgICAgICAgICAgICAnUVVFUllQQVJBTScsXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICBhZGRWYXJpYWJsZURlZmluaXRpb24ocGFyc2VkLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIGJhc2V1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0NPTlRFTlQtU1RFRVJJTkcnOiB7XG4gICAgICAgICAgICAvLyAjRVhULVgtQ09OVEVOVC1TVEVFUklOR1xuICAgICAgICAgICAgY29uc3QgY29udGVudFN0ZWVyaW5nQXR0cmlidXRlcyA9IG5ldyBBdHRyTGlzdChhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHBhcnNlZCxcbiAgICAgICAgICAgICAgICBjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFsnU0VSVkVSLVVSSScsICdQQVRIV0FZLUlEJ11cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlZC5jb250ZW50U3RlZXJpbmcgPSB7XG4gICAgICAgICAgICAgIHVyaTogTTNVOFBhcnNlci5yZXNvbHZlKFxuICAgICAgICAgICAgICAgIGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXNbJ1NFUlZFUi1VUkknXSxcbiAgICAgICAgICAgICAgICBiYXNldXJsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHBhdGh3YXlJZDogY29udGVudFN0ZWVyaW5nQXR0cmlidXRlc1snUEFUSFdBWS1JRCddIHx8ICcuJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU1RBUlQnOiB7XG4gICAgICAgICAgICAvLyAjRVhULVgtU1RBUlRcbiAgICAgICAgICAgIHBhcnNlZC5zdGFydFRpbWVPZmZzZXQgPSBwYXJzZVN0YXJ0VGltZU9mZnNldChhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRmlsdGVyIG91dCBsZXZlbHMgd2l0aCB1bmtub3duIGNvZGVjcyBpZiBpdCBkb2VzIG5vdCByZW1vdmUgYWxsIGxldmVsc1xuICAgIGNvbnN0IHN0cmlwVW5rbm93bkNvZGVjTGV2ZWxzID1cbiAgICAgIGxldmVsc1dpdGhLbm93bkNvZGVjcy5sZW5ndGggPiAwICYmXG4gICAgICBsZXZlbHNXaXRoS25vd25Db2RlY3MubGVuZ3RoIDwgcGFyc2VkLmxldmVscy5sZW5ndGg7XG5cbiAgICBwYXJzZWQubGV2ZWxzID0gc3RyaXBVbmtub3duQ29kZWNMZXZlbHNcbiAgICAgID8gbGV2ZWxzV2l0aEtub3duQ29kZWNzXG4gICAgICA6IHBhcnNlZC5sZXZlbHM7XG4gICAgaWYgKHBhcnNlZC5sZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoJ25vIGxldmVscyBmb3VuZCBpbiBtYW5pZmVzdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKFxuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIGJhc2V1cmw6IHN0cmluZyxcbiAgICBwYXJzZWQ6IFBhcnNlZE11bHRpdmFyaWFudFBsYXlsaXN0XG4gICk6IFBhcnNlZE11bHRpdmFyaWFudE1lZGlhT3B0aW9ucyB7XG4gICAgbGV0IHJlc3VsdDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbDtcbiAgICBjb25zdCByZXN1bHRzOiBQYXJzZWRNdWx0aXZhcmlhbnRNZWRpYU9wdGlvbnMgPSB7fTtcbiAgICBjb25zdCBsZXZlbHMgPSBwYXJzZWQubGV2ZWxzO1xuICAgIGNvbnN0IGdyb3Vwc0J5VHlwZSA9IHtcbiAgICAgIEFVRElPOiBsZXZlbHMubWFwKChsZXZlbDogTGV2ZWxQYXJzZWQpID0+ICh7XG4gICAgICAgIGlkOiBsZXZlbC5hdHRycy5BVURJTyxcbiAgICAgICAgYXVkaW9Db2RlYzogbGV2ZWwuYXVkaW9Db2RlYyxcbiAgICAgIH0pKSxcbiAgICAgIFNVQlRJVExFUzogbGV2ZWxzLm1hcCgobGV2ZWw6IExldmVsUGFyc2VkKSA9PiAoe1xuICAgICAgICBpZDogbGV2ZWwuYXR0cnMuU1VCVElUTEVTLFxuICAgICAgICB0ZXh0Q29kZWM6IGxldmVsLnRleHRDb2RlYyxcbiAgICAgIH0pKSxcbiAgICAgICdDTE9TRUQtQ0FQVElPTlMnOiBbXSxcbiAgICB9O1xuICAgIGxldCBpZCA9IDA7XG4gICAgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVguZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgYXR0cnMgPSBuZXcgQXR0ckxpc3QocmVzdWx0WzFdKSBhcyBNZWRpYUF0dHJpYnV0ZXM7XG4gICAgICBjb25zdCB0eXBlOiBNZWRpYVBsYXlsaXN0VHlwZSB8IHVuZGVmaW5lZCA9IGF0dHJzLlRZUEUgYXNcbiAgICAgICAgfCBNZWRpYVBsYXlsaXN0VHlwZVxuICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IGdyb3Vwc0J5VHlwZVt0eXBlXTtcbiAgICAgICAgY29uc3QgbWVkaWFzOiBNZWRpYVBsYXlsaXN0W10gPSByZXN1bHRzW3R5cGVdIHx8IFtdO1xuICAgICAgICByZXN1bHRzW3R5cGVdID0gbWVkaWFzO1xuICAgICAgICBpZiAoX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX18pIHtcbiAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgYXR0cnMsIFtcbiAgICAgICAgICAgICdVUkknLFxuICAgICAgICAgICAgJ0dST1VQLUlEJyxcbiAgICAgICAgICAgICdMQU5HVUFHRScsXG4gICAgICAgICAgICAnQVNTT0MtTEFOR1VBR0UnLFxuICAgICAgICAgICAgJ1NUQUJMRS1SRU5ESVRJT04tSUQnLFxuICAgICAgICAgICAgJ05BTUUnLFxuICAgICAgICAgICAgJ0lOU1RSRUFNLUlEJyxcbiAgICAgICAgICAgICdDSEFSQUNURVJJU1RJQ1MnLFxuICAgICAgICAgICAgJ0NIQU5ORUxTJyxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZWRpYTogTWVkaWFQbGF5bGlzdCA9IHtcbiAgICAgICAgICBhdHRycyxcbiAgICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICAgIGlkOiBpZCsrLFxuICAgICAgICAgIGdyb3VwSWQ6IGF0dHJzWydHUk9VUC1JRCddIHx8ICcnLFxuICAgICAgICAgIGluc3RyZWFtSWQ6IGF0dHJzWydJTlNUUkVBTS1JRCddLFxuICAgICAgICAgIG5hbWU6IGF0dHJzLk5BTUUgfHwgYXR0cnMuTEFOR1VBR0UgfHwgJycsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBkZWZhdWx0OiBhdHRycy5ib29sKCdERUZBVUxUJyksXG4gICAgICAgICAgYXV0b3NlbGVjdDogYXR0cnMuYm9vbCgnQVVUT1NFTEVDVCcpLFxuICAgICAgICAgIGZvcmNlZDogYXR0cnMuYm9vbCgnRk9SQ0VEJyksXG4gICAgICAgICAgbGFuZzogYXR0cnMuTEFOR1VBR0UsXG4gICAgICAgICAgdXJsOiBhdHRycy5VUkkgPyBNM1U4UGFyc2VyLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKSA6ICcnLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChncm91cHM/Lmxlbmd0aCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhdWRpbyBvciB0ZXh0IGdyb3VwcyBzaWduYWxsZWQgaW4gdGhlIG1hbmlmZXN0LCBsZXQncyBsb29rIGZvciBhIG1hdGNoaW5nIGNvZGVjIHN0cmluZyBmb3IgdGhpcyB0cmFja1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGZpbmQgdGhlIHRyYWNrIHNpZ25hbGxlZCwgbGV0cyB1c2UgdGhlIGZpcnN0IGF1ZGlvIGdyb3VwcyBjb2RlYyB3ZSBoYXZlXG4gICAgICAgICAgLy8gQWN0aW5nIGFzIGEgYmVzdCBndWVzc1xuICAgICAgICAgIGNvbnN0IGdyb3VwQ29kZWMgPVxuICAgICAgICAgICAgTTNVOFBhcnNlci5maW5kR3JvdXAoZ3JvdXBzLCBtZWRpYS5ncm91cElkIGFzIHN0cmluZykgfHwgZ3JvdXBzWzBdO1xuICAgICAgICAgIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cENvZGVjLCAnYXVkaW9Db2RlYycpO1xuICAgICAgICAgIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cENvZGVjLCAndGV4dENvZGVjJyk7XG4gICAgICAgIH1cblxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlTGV2ZWxQbGF5bGlzdChcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICBiYXNldXJsOiBzdHJpbmcsXG4gICAgaWQ6IG51bWJlcixcbiAgICB0eXBlOiBQbGF5bGlzdExldmVsVHlwZSxcbiAgICBsZXZlbFVybElkOiBudW1iZXIsXG4gICAgbXVsdGl2YXJpYW50VmFyaWFibGVMaXN0OiBWYXJpYWJsZU1hcCB8IG51bGxcbiAgKTogTGV2ZWxEZXRhaWxzIHtcbiAgICBjb25zdCBsZXZlbCA9IG5ldyBMZXZlbERldGFpbHMoYmFzZXVybCk7XG4gICAgY29uc3QgZnJhZ21lbnRzOiBNM1U4UGFyc2VyRnJhZ21lbnRzID0gbGV2ZWwuZnJhZ21lbnRzO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBpbml0IHNlZ21lbnQgc2VlbiAoYXBwbGllcyB0byBhbGwgc3Vic2VxdWVudCBzZWdtZW50cylcbiAgICBsZXQgY3VycmVudEluaXRTZWdtZW50OiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICAgIGxldCBjdXJyZW50U04gPSAwO1xuICAgIGxldCBjdXJyZW50UGFydCA9IDA7XG4gICAgbGV0IHRvdGFsZHVyYXRpb24gPSAwO1xuICAgIGxldCBkaXNjb250aW51aXR5Q291bnRlciA9IDA7XG4gICAgbGV0IHByZXZGcmFnOiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICAgIGxldCBmcmFnOiBGcmFnbWVudCA9IG5ldyBGcmFnbWVudCh0eXBlLCBiYXNldXJsKTtcbiAgICBsZXQgcmVzdWx0OiBSZWdFeHBFeGVjQXJyYXkgfCBSZWdFeHBNYXRjaEFycmF5IHwgbnVsbDtcbiAgICBsZXQgaTogbnVtYmVyO1xuICAgIGxldCBsZXZlbGtleXM6IHsgW2tleTogc3RyaW5nXTogTGV2ZWxLZXkgfSB8IHVuZGVmaW5lZDtcbiAgICBsZXQgZmlyc3RQZHRJbmRleCA9IC0xO1xuICAgIGxldCBjcmVhdGVOZXh0RnJhZyA9IGZhbHNlO1xuXG4gICAgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5sYXN0SW5kZXggPSAwO1xuICAgIGxldmVsLm0zdTggPSBzdHJpbmc7XG4gICAgbGV2ZWwuaGFzVmFyaWFibGVSZWZzID0gX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX19cbiAgICAgID8gaGFzVmFyaWFibGVSZWZlcmVuY2VzKHN0cmluZylcbiAgICAgIDogZmFsc2U7XG5cbiAgICB3aGlsZSAoKHJlc3VsdCA9IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QuZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNyZWF0ZU5leHRGcmFnKSB7XG4gICAgICAgIGNyZWF0ZU5leHRGcmFnID0gZmFsc2U7XG4gICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQodHlwZSwgYmFzZXVybCk7XG4gICAgICAgIC8vIHNldHVwIHRoZSBuZXh0IGZyYWdtZW50IGZvciBwYXJ0IGxvYWRpbmdcbiAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgIGZyYWcuc24gPSBjdXJyZW50U047XG4gICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICBpZiAoY3VycmVudEluaXRTZWdtZW50KSB7XG4gICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWU7XG4gICAgICAgICAgY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZHVyYXRpb24gPSByZXN1bHRbMV07XG4gICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgLy8gSU5GXG4gICAgICAgIGZyYWcuZHVyYXRpb24gPSBwYXJzZUZsb2F0KGR1cmF0aW9uKTtcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBjb25zdCB0aXRsZSA9ICgnICcgKyByZXN1bHRbMl0pLnNsaWNlKDEpO1xuICAgICAgICBmcmFnLnRpdGxlID0gdGl0bGUgfHwgbnVsbDtcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godGl0bGUgPyBbJ0lORicsIGR1cmF0aW9uLCB0aXRsZV0gOiBbJ0lORicsIGR1cmF0aW9uXSk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkge1xuICAgICAgICAvLyB1cmxcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICAgIGlmIChsZXZlbGtleXMpIHtcbiAgICAgICAgICAgIHNldEZyYWdMZXZlbEtleXMoZnJhZywgbGV2ZWxrZXlzLCBsZXZlbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyYWcuc24gPSBjdXJyZW50U047XG4gICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgICBmcmFnLnVybElkID0gbGV2ZWxVcmxJZDtcbiAgICAgICAgICBmcmFnbWVudHMucHVzaChmcmFnKTtcbiAgICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgICAgY29uc3QgdXJpID0gKCcgJyArIHJlc3VsdFszXSkuc2xpY2UoMSk7XG4gICAgICAgICAgZnJhZy5yZWx1cmwgPSBfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fX1xuICAgICAgICAgICAgPyBzdWJzdGl0dXRlVmFyaWFibGVzKGxldmVsLCB1cmkpXG4gICAgICAgICAgICA6IHVyaTtcbiAgICAgICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpO1xuICAgICAgICAgIHByZXZGcmFnID0gZnJhZztcbiAgICAgICAgICB0b3RhbGR1cmF0aW9uICs9IGZyYWcuZHVyYXRpb247XG4gICAgICAgICAgY3VycmVudFNOKys7XG4gICAgICAgICAgY3VycmVudFBhcnQgPSAwO1xuICAgICAgICAgIGNyZWF0ZU5leHRGcmFnID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNF0pIHtcbiAgICAgICAgLy8gWC1CWVRFUkFOR0VcbiAgICAgICAgY29uc3QgZGF0YSA9ICgnICcgKyByZXN1bHRbNF0pLnNsaWNlKDEpO1xuICAgICAgICBpZiAocHJldkZyYWcpIHtcbiAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShkYXRhLCBwcmV2RnJhZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzVdKSB7XG4gICAgICAgIC8vIFBST0dSQU0tREFURS1USU1FXG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSAoJyAnICsgcmVzdWx0WzVdKS5zbGljZSgxKTtcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydQUk9HUkFNLURBVEUtVElNRScsIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lXSk7XG4gICAgICAgIGlmIChmaXJzdFBkdEluZGV4ID09PSAtMSkge1xuICAgICAgICAgIGZpcnN0UGR0SW5kZXggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRbMF0ubWF0Y2goTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ05vIG1hdGNoZXMgb24gc2xvdyByZWdleCBtYXRjaCBmb3IgbGV2ZWwgcGxheWxpc3QhJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBjb25zdCB0YWcgPSAoJyAnICsgcmVzdWx0W2ldKS5zbGljZSgxKTtcbiAgICAgICAgY29uc3QgdmFsdWUxID0gKCcgJyArIHJlc3VsdFtpICsgMV0pLnNsaWNlKDEpO1xuICAgICAgICBjb25zdCB2YWx1ZTIgPSByZXN1bHRbaSArIDJdID8gKCcgJyArIHJlc3VsdFtpICsgMl0pLnNsaWNlKDEpIDogJyc7XG5cbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICBjYXNlICdQTEFZTElTVC1UWVBFJzpcbiAgICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ01FRElBLVNFUVVFTkNFJzpcbiAgICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnU0tJUCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHNraXBBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHNraXBBdHRycywgW1xuICAgICAgICAgICAgICAgICdSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnLFxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNraXBwZWRTZWdtZW50cyA9XG4gICAgICAgICAgICAgIHNraXBBdHRycy5kZWNpbWFsSW50ZWdlcignU0tJUFBFRC1TRUdNRU5UUycpO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShza2lwcGVkU2VnbWVudHMpKSB7XG4gICAgICAgICAgICAgIGxldmVsLnNraXBwZWRTZWdtZW50cyA9IHNraXBwZWRTZWdtZW50cztcbiAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHJlc3VsdCBpbiBmcmFnbWVudHNbXSBjb250YWluaW5nIHVuZGVmaW5lZCB2YWx1ZXMsIHdoaWNoIHdlIHdpbGwgZmlsbCBpbiB3aXRoIGBtZXJnZURldGFpbHNgXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSBza2lwcGVkU2VnbWVudHM7IGktLTsgKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnRzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudFNOICs9IHNraXBwZWRTZWdtZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSBza2lwQXR0cnMuZW51bWVyYXRlZFN0cmluZyhcbiAgICAgICAgICAgICAgJ1JFQ0VOVExZLVJFTU9WRUQtREFURVJBTkdFUydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgICAgICAgICAgICBsZXZlbC5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzID1cbiAgICAgICAgICAgICAgICByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzLnNwbGl0KCdcXHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdUQVJHRVREVVJBVElPTic6XG4gICAgICAgICAgICBsZXZlbC50YXJnZXRkdXJhdGlvbiA9IE1hdGgubWF4KHBhcnNlSW50KHZhbHVlMSksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnVkVSU0lPTic6XG4gICAgICAgICAgICBsZXZlbC52ZXJzaW9uID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0VYVE0zVSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdFTkRMSVNUJzpcbiAgICAgICAgICAgIGxldmVsLmxpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgaWYgKHZhbHVlMSB8fCB2YWx1ZTIpIHtcbiAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godmFsdWUyID8gW3ZhbHVlMSwgdmFsdWUyXSA6IFt2YWx1ZTFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFknOlxuICAgICAgICAgICAgZGlzY29udGludWl0eUNvdW50ZXIrKztcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnRElTJ10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnR0FQJzpcbiAgICAgICAgICAgIGZyYWcuZ2FwID0gdHJ1ZTtcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFt0YWddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0JJVFJBVEUnOlxuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goW3RhZywgdmFsdWUxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdEQVRFUkFOR0UnOiB7XG4gICAgICAgICAgICBjb25zdCBkYXRlUmFuZ2VBdHRyID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICBpZiAoX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX18pIHtcbiAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgZGF0ZVJhbmdlQXR0ciwgW1xuICAgICAgICAgICAgICAgICdJRCcsXG4gICAgICAgICAgICAgICAgJ0NMQVNTJyxcbiAgICAgICAgICAgICAgICAnU1RBUlQtREFURScsXG4gICAgICAgICAgICAgICAgJ0VORC1EQVRFJyxcbiAgICAgICAgICAgICAgICAnU0NURTM1LUNNRCcsXG4gICAgICAgICAgICAgICAgJ1NDVEUzNS1PVVQnLFxuICAgICAgICAgICAgICAgICdTQ1RFMzUtSU4nLFxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgICAgICBkYXRlUmFuZ2VBdHRyLFxuICAgICAgICAgICAgICAgIGRhdGVSYW5nZUF0dHIuY2xpZW50QXR0cnNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGVSYW5nZSA9IG5ldyBEYXRlUmFuZ2UoXG4gICAgICAgICAgICAgIGRhdGVSYW5nZUF0dHIsXG4gICAgICAgICAgICAgIGxldmVsLmRhdGVSYW5nZXNbZGF0ZVJhbmdlQXR0ci5JRF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLmlzVmFsaWQgfHwgbGV2ZWwuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgIGxldmVsLmRhdGVSYW5nZXNbZGF0ZVJhbmdlLmlkXSA9IGRhdGVSYW5nZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBJZ25vcmluZyBpbnZhbGlkIERBVEVSQU5HRSB0YWc6IFwiJHt2YWx1ZTF9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0byBmcmFnbWVudCB0YWcgbGlzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKDwgdjEuMi4wKVxuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydFWFQtWC1EQVRFUkFOR0UnLCB2YWx1ZTFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdERUZJTkUnOiB7XG4gICAgICAgICAgICBpZiAoX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX18pIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGVBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHZhcmlhYmxlQXR0cmlidXRlcywgW1xuICAgICAgICAgICAgICAgICdOQU1FJyxcbiAgICAgICAgICAgICAgICAnVkFMVUUnLFxuICAgICAgICAgICAgICAgICdJTVBPUlQnLFxuICAgICAgICAgICAgICAgICdRVUVSWVBBUkFNJyxcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIGlmICgnSU1QT1JUJyBpbiB2YXJpYWJsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRWYXJpYWJsZURlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgICAgICAgIHZhcmlhYmxlQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIG11bHRpdmFyaWFudFZhcmlhYmxlTGlzdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkVmFyaWFibGVEZWZpbml0aW9uKGxldmVsLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZLVNFUVVFTkNFJzpcbiAgICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0tFWSc6IHtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsS2V5ID0gcGFyc2VLZXkodmFsdWUxLCBiYXNldXJsLCBsZXZlbCk7XG4gICAgICAgICAgICBpZiAobGV2ZWxLZXkuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgICBpZiAobGV2ZWxLZXkubWV0aG9kID09PSAnTk9ORScpIHtcbiAgICAgICAgICAgICAgICBsZXZlbGtleXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFsZXZlbGtleXMpIHtcbiAgICAgICAgICAgICAgICBsZXZlbGtleXMgPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGV2ZWxrZXlzW2xldmVsS2V5LmtleUZvcm1hdF0pIHtcbiAgICAgICAgICAgICAgICBsZXZlbGtleXMgPSBPYmplY3QuYXNzaWduKHt9LCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldmVsa2V5c1tsZXZlbEtleS5rZXlGb3JtYXRdID0gbGV2ZWxLZXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybihgW0tleXNdIElnbm9yaW5nIGludmFsaWQgRVhULVgtS0VZIHRhZzogXCIke3ZhbHVlMX1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICAgIGxldmVsLnN0YXJ0VGltZU9mZnNldCA9IHBhcnNlU3RhcnRUaW1lT2Zmc2V0KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNQVAnOiB7XG4gICAgICAgICAgICBjb25zdCBtYXBBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIG1hcEF0dHJzLCBbXG4gICAgICAgICAgICAgICAgJ0JZVEVSQU5HRScsXG4gICAgICAgICAgICAgICAgJ1VSSScsXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyYWcuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzZWdtZW50IHRhZyBpcyBhZnRlciBzZWdtZW50IGR1cmF0aW9uIHRhZy5cbiAgICAgICAgICAgICAgLy8gICAjRVhUSU5GOiA2LjBcbiAgICAgICAgICAgICAgLy8gICAjRVhULVgtTUFQOlVSST1cImluaXQubXA0XG4gICAgICAgICAgICAgIGNvbnN0IGluaXQgPSBuZXcgRnJhZ21lbnQodHlwZSwgYmFzZXVybCk7XG4gICAgICAgICAgICAgIHNldEluaXRTZWdtZW50KGluaXQsIG1hcEF0dHJzLCBpZCwgbGV2ZWxrZXlzKTtcbiAgICAgICAgICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gaW5pdDtcbiAgICAgICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWUgJiZcbiAgICAgICAgICAgICAgICAhZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWVcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJbml0aWFsIHNlZ21lbnQgdGFnIGlzIGJlZm9yZSBzZWdtZW50IGR1cmF0aW9uIHRhZ1xuICAgICAgICAgICAgICBzZXRJbml0U2VnbWVudChmcmFnLCBtYXBBdHRycywgaWQsIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGZyYWc7XG4gICAgICAgICAgICAgIGNyZWF0ZU5leHRGcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTRVJWRVItQ09OVFJPTCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlckNvbnRyb2xBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgbGV2ZWwuY2FuQmxvY2tSZWxvYWQgPSBzZXJ2ZXJDb250cm9sQXR0cnMuYm9vbCgnQ0FOLUJMT0NLLVJFTE9BRCcpO1xuICAgICAgICAgICAgbGV2ZWwuY2FuU2tpcFVudGlsID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoXG4gICAgICAgICAgICAgICdDQU4tU0tJUC1VTlRJTCcsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXZlbC5jYW5Ta2lwRGF0ZVJhbmdlcyA9XG4gICAgICAgICAgICAgIGxldmVsLmNhblNraXBVbnRpbCA+IDAgJiZcbiAgICAgICAgICAgICAgc2VydmVyQ29udHJvbEF0dHJzLmJvb2woJ0NBTi1TS0lQLURBVEVSQU5HRVMnKTtcbiAgICAgICAgICAgIGxldmVsLnBhcnRIb2xkQmFjayA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KFxuICAgICAgICAgICAgICAnUEFSVC1IT0xELUJBQ0snLFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV2ZWwuaG9sZEJhY2sgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnSE9MRC1CQUNLJywgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUEFSVC1JTkYnOiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0SW5mQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgIGxldmVsLnBhcnRUYXJnZXQgPSBwYXJ0SW5mQXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1BBUlQtVEFSR0VUJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUEFSVCc6IHtcbiAgICAgICAgICAgIGxldCBwYXJ0TGlzdCA9IGxldmVsLnBhcnRMaXN0O1xuICAgICAgICAgICAgaWYgKCFwYXJ0TGlzdCkge1xuICAgICAgICAgICAgICBwYXJ0TGlzdCA9IGxldmVsLnBhcnRMaXN0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0ZyYWdtZW50UGFydCA9XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJ0ID4gMCA/IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjdXJyZW50UGFydCsrO1xuICAgICAgICAgICAgY29uc3QgcGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICBpZiAoX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX18pIHtcbiAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgcGFydEF0dHJzLCBbXG4gICAgICAgICAgICAgICAgJ0JZVEVSQU5HRScsXG4gICAgICAgICAgICAgICAgJ1VSSScsXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFydCA9IG5ldyBQYXJ0KFxuICAgICAgICAgICAgICBwYXJ0QXR0cnMsXG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIGJhc2V1cmwsXG4gICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICBwcmV2aW91c0ZyYWdtZW50UGFydFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBhcnRMaXN0LnB1c2gocGFydCk7XG4gICAgICAgICAgICBmcmFnLmR1cmF0aW9uICs9IHBhcnQuZHVyYXRpb247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUFJFTE9BRC1ISU5UJzoge1xuICAgICAgICAgICAgY29uc3QgcHJlbG9hZEhpbnRBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHByZWxvYWRIaW50QXR0cnMsIFsnVVJJJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWwucHJlbG9hZEhpbnQgPSBwcmVsb2FkSGludEF0dHJzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1JFTkRJVElPTi1SRVBPUlQnOiB7XG4gICAgICAgICAgICBjb25zdCByZW5kaXRpb25SZXBvcnRBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHJlbmRpdGlvblJlcG9ydEF0dHJzLCBbXG4gICAgICAgICAgICAgICAgJ1VSSScsXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cyA9IGxldmVsLnJlbmRpdGlvblJlcG9ydHMgfHwgW107XG4gICAgICAgICAgICBsZXZlbC5yZW5kaXRpb25SZXBvcnRzLnB1c2gocmVuZGl0aW9uUmVwb3J0QXR0cnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBsb2dnZXIud2FybihgbGluZSBwYXJzZWQgYnV0IG5vdCBoYW5kbGVkOiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2RnJhZyAmJiAhcHJldkZyYWcucmVsdXJsKSB7XG4gICAgICBmcmFnbWVudHMucG9wKCk7XG4gICAgICB0b3RhbGR1cmF0aW9uIC09IHByZXZGcmFnLmR1cmF0aW9uO1xuICAgICAgaWYgKGxldmVsLnBhcnRMaXN0KSB7XG4gICAgICAgIGxldmVsLmZyYWdtZW50SGludCA9IHByZXZGcmFnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGV2ZWwucGFydExpc3QpIHtcbiAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZyk7XG4gICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICBsZXZlbC5mcmFnbWVudEhpbnQgPSBmcmFnO1xuICAgICAgaWYgKGxldmVsa2V5cykge1xuICAgICAgICBzZXRGcmFnTGV2ZWxLZXlzKGZyYWcsIGxldmVsa2V5cywgbGV2ZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcmFnbWVudExlbmd0aCA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgZmlyc3RGcmFnbWVudCA9IGZyYWdtZW50c1swXTtcbiAgICBjb25zdCBsYXN0RnJhZ21lbnQgPSBmcmFnbWVudHNbZnJhZ21lbnRMZW5ndGggLSAxXTtcbiAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLnNraXBwZWRTZWdtZW50cyAqIGxldmVsLnRhcmdldGR1cmF0aW9uO1xuICAgIGlmICh0b3RhbGR1cmF0aW9uID4gMCAmJiBmcmFnbWVudExlbmd0aCAmJiBsYXN0RnJhZ21lbnQpIHtcbiAgICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBmcmFnbWVudExlbmd0aDtcbiAgICAgIGNvbnN0IGxhc3RTbiA9IGxhc3RGcmFnbWVudC5zbjtcbiAgICAgIGxldmVsLmVuZFNOID0gbGFzdFNuICE9PSAnaW5pdFNlZ21lbnQnID8gbGFzdFNuIDogMDtcbiAgICAgIGlmICghbGV2ZWwubGl2ZSkge1xuICAgICAgICBsYXN0RnJhZ21lbnQuZW5kTGlzdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RGcmFnbWVudCkge1xuICAgICAgICBsZXZlbC5zdGFydENDID0gZmlyc3RGcmFnbWVudC5jYztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV2ZWwuZW5kU04gPSAwO1xuICAgICAgbGV2ZWwuc3RhcnRDQyA9IDA7XG4gICAgfVxuICAgIGlmIChsZXZlbC5mcmFnbWVudEhpbnQpIHtcbiAgICAgIHRvdGFsZHVyYXRpb24gKz0gbGV2ZWwuZnJhZ21lbnRIaW50LmR1cmF0aW9uO1xuICAgIH1cbiAgICBsZXZlbC50b3RhbGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbjtcbiAgICBsZXZlbC5lbmRDQyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuXG4gICAgLyoqXG4gICAgICogQmFja2ZpbGwgYW55IG1pc3NpbmcgUERUIHZhbHVlc1xuICAgICAqIFwiSWYgdGhlIGZpcnN0IEVYVC1YLVBST0dSQU0tREFURS1USU1FIHRhZyBpbiBhIFBsYXlsaXN0IGFwcGVhcnMgYWZ0ZXJcbiAgICAgKiBvbmUgb3IgbW9yZSBNZWRpYSBTZWdtZW50IFVSSXMsIHRoZSBjbGllbnQgU0hPVUxEIGV4dHJhcG9sYXRlXG4gICAgICogYmFja3dhcmQgZnJvbSB0aGF0IHRhZyAodXNpbmcgRVhUSU5GIGR1cmF0aW9ucyBhbmQvb3IgbWVkaWFcbiAgICAgKiB0aW1lc3RhbXBzKSB0byBhc3NvY2lhdGUgZGF0ZXMgd2l0aCB0aG9zZSBzZWdtZW50cy5cIlxuICAgICAqIFdlIGhhdmUgYWxyZWFkeSBleHRyYXBvbGF0ZWQgZm9yd2FyZCwgYnV0IGFsbCBmcmFnbWVudHMgdXAgdG8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIFBEVCBkbyBub3QgaGF2ZSB0aGVpciBQRFRzXG4gICAgICogY29tcHV0ZWQuXG4gICAgICovXG4gICAgaWYgKGZpcnN0UGR0SW5kZXggPiAwKSB7XG4gICAgICBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMoZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VLZXkoXG4gIGtleVRhZ0F0dHJpYnV0ZXM6IHN0cmluZyxcbiAgYmFzZXVybDogc3RyaW5nLFxuICBwYXJzZWQ6IFBhcnNlZE11bHRpdmFyaWFudFBsYXlsaXN0IHwgTGV2ZWxEZXRhaWxzXG4pOiBMZXZlbEtleSB7XG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4MjE2I3NlY3Rpb24tNC4zLjIuNFxuICBjb25zdCBrZXlBdHRycyA9IG5ldyBBdHRyTGlzdChrZXlUYWdBdHRyaWJ1dGVzKTtcbiAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIGtleUF0dHJzLCBbXG4gICAgICAnS0VZRk9STUFUJyxcbiAgICAgICdLRVlGT1JNQVRWRVJTSU9OUycsXG4gICAgICAnVVJJJyxcbiAgICAgICdJVicsXG4gICAgICAnVVJJJyxcbiAgICBdKTtcbiAgfVxuICBjb25zdCBkZWNyeXB0bWV0aG9kID0ga2V5QXR0cnMuTUVUSE9EID8/ICcnO1xuICBjb25zdCBkZWNyeXB0dXJpID0ga2V5QXR0cnMuVVJJO1xuICBjb25zdCBkZWNyeXB0aXYgPSBrZXlBdHRycy5oZXhhZGVjaW1hbEludGVnZXIoJ0lWJyk7XG4gIGNvbnN0IGRlY3J5cHRrZXlmb3JtYXR2ZXJzaW9ucyA9IGtleUF0dHJzLktFWUZPUk1BVFZFUlNJT05TO1xuICAvLyBGcm9tIFJGQzogVGhpcyBhdHRyaWJ1dGUgaXMgT1BUSU9OQUw7IGl0cyBhYnNlbmNlIGluZGljYXRlcyBhbiBpbXBsaWNpdCB2YWx1ZSBvZiBcImlkZW50aXR5XCIuXG4gIGNvbnN0IGRlY3J5cHRrZXlmb3JtYXQgPSBrZXlBdHRycy5LRVlGT1JNQVQgPz8gJ2lkZW50aXR5JztcblxuICBpZiAoZGVjcnlwdHVyaSAmJiBrZXlBdHRycy5JViAmJiAhZGVjcnlwdGl2KSB7XG4gICAgbG9nZ2VyLmVycm9yKGBJbnZhbGlkIElWOiAke2tleUF0dHJzLklWfWApO1xuICB9XG4gIC8vIElmIGRlY3J5cHR1cmkgaXMgYSBVUkkgd2l0aCBhIHNjaGVtZSwgdGhlbiBiYXNldXJsIHdpbGwgYmUgaWdub3JlZFxuICAvLyBObyB1cmkgaXMgYWxsb3dlZCB3aGVuIE1FVEhPRCBpcyBOT05FXG4gIGNvbnN0IHJlc29sdmVkVXJpID0gZGVjcnlwdHVyaSA/IE0zVThQYXJzZXIucmVzb2x2ZShkZWNyeXB0dXJpLCBiYXNldXJsKSA6ICcnO1xuICBjb25zdCBrZXlGb3JtYXRWZXJzaW9ucyA9IChcbiAgICBkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnMgPyBkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnMgOiAnMSdcbiAgKVxuICAgIC5zcGxpdCgnLycpXG4gICAgLm1hcChOdW1iZXIpXG4gICAgLmZpbHRlcihOdW1iZXIuaXNGaW5pdGUpO1xuXG4gIHJldHVybiBuZXcgTGV2ZWxLZXkoXG4gICAgZGVjcnlwdG1ldGhvZCxcbiAgICByZXNvbHZlZFVyaSxcbiAgICBkZWNyeXB0a2V5Zm9ybWF0LFxuICAgIGtleUZvcm1hdFZlcnNpb25zLFxuICAgIGRlY3J5cHRpdlxuICApO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0YXJ0VGltZU9mZnNldChzdGFydEF0dHJpYnV0ZXM6IHN0cmluZyk6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBzdGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHN0YXJ0QXR0cmlidXRlcyk7XG4gIGNvbnN0IHN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1RJTUUtT0ZGU0VUJyk7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgIHJldHVybiBzdGFydFRpbWVPZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldENvZGVjcyhjb2RlY3M6IEFycmF5PHN0cmluZz4sIGxldmVsOiBMZXZlbFBhcnNlZCkge1xuICBbJ3ZpZGVvJywgJ2F1ZGlvJywgJ3RleHQnXS5mb3JFYWNoKCh0eXBlOiBDb2RlY1R5cGUpID0+IHtcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGNvZGVjcy5maWx0ZXIoKGNvZGVjKSA9PiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSkpO1xuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHByZWZlcnJlZCA9IGZpbHRlcmVkLmZpbHRlcigoY29kZWMpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb2RlYy5sYXN0SW5kZXhPZignYXZjMScsIDApID09PSAwIHx8XG4gICAgICAgICAgY29kZWMubGFzdEluZGV4T2YoJ21wNGEnLCAwKSA9PT0gMFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICBsZXZlbFtgJHt0eXBlfUNvZGVjYF0gPSBwcmVmZXJyZWQubGVuZ3RoID4gMCA/IHByZWZlcnJlZFswXSA6IGZpbHRlcmVkWzBdO1xuXG4gICAgICAvLyByZW1vdmUgZnJvbSBsaXN0XG4gICAgICBjb2RlY3MgPSBjb2RlY3MuZmlsdGVyKChjb2RlYykgPT4gZmlsdGVyZWQuaW5kZXhPZihjb2RlYykgPT09IC0xKTtcbiAgICB9XG4gIH0pO1xuXG4gIGxldmVsLnVua25vd25Db2RlY3MgPSBjb2RlY3M7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cEl0ZW0sIGNvZGVjUHJvcGVydHkpIHtcbiAgY29uc3QgY29kZWNWYWx1ZSA9IGdyb3VwSXRlbVtjb2RlY1Byb3BlcnR5XTtcbiAgaWYgKGNvZGVjVmFsdWUpIHtcbiAgICBtZWRpYVtjb2RlY1Byb3BlcnR5XSA9IGNvZGVjVmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKFxuICBmcmFnbWVudHM6IE0zVThQYXJzZXJGcmFnbWVudHMsXG4gIGZpcnN0UGR0SW5kZXg6IG51bWJlclxuKSB7XG4gIGxldCBmcmFnUHJldiA9IGZyYWdtZW50c1tmaXJzdFBkdEluZGV4XSBhcyBGcmFnbWVudDtcbiAgZm9yIChsZXQgaSA9IGZpcnN0UGR0SW5kZXg7IGktLTsgKSB7XG4gICAgY29uc3QgZnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICAvLyBFeGl0IG9uIGRlbHRhLXBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPVxuICAgICAgKGZyYWdQcmV2LnByb2dyYW1EYXRlVGltZSBhcyBudW1iZXIpIC0gZnJhZy5kdXJhdGlvbiAqIDEwMDA7XG4gICAgZnJhZ1ByZXYgPSBmcmFnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZykge1xuICBpZiAoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IERhdGUucGFyc2UoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpO1xuICB9IGVsc2UgaWYgKHByZXZGcmFnPy5wcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IHByZXZGcmFnLmVuZFByb2dyYW1EYXRlVGltZTtcbiAgfVxuXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYWcucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0SW5pdFNlZ21lbnQoXG4gIGZyYWc6IEZyYWdtZW50LFxuICBtYXBBdHRyczogQXR0ckxpc3QsXG4gIGlkOiBudW1iZXIsXG4gIGxldmVsa2V5czogeyBba2V5OiBzdHJpbmddOiBMZXZlbEtleSB9IHwgdW5kZWZpbmVkXG4pIHtcbiAgZnJhZy5yZWx1cmwgPSBtYXBBdHRycy5VUkk7XG4gIGlmIChtYXBBdHRycy5CWVRFUkFOR0UpIHtcbiAgICBmcmFnLnNldEJ5dGVSYW5nZShtYXBBdHRycy5CWVRFUkFOR0UpO1xuICB9XG4gIGZyYWcubGV2ZWwgPSBpZDtcbiAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XG4gIGlmIChsZXZlbGtleXMpIHtcbiAgICBmcmFnLmxldmVsa2V5cyA9IGxldmVsa2V5cztcbiAgfVxuICBmcmFnLmluaXRTZWdtZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0RnJhZ0xldmVsS2V5cyhcbiAgZnJhZzogRnJhZ21lbnQsXG4gIGxldmVsa2V5czogeyBba2V5OiBzdHJpbmddOiBMZXZlbEtleSB9LFxuICBsZXZlbDogTGV2ZWxEZXRhaWxzXG4pIHtcbiAgZnJhZy5sZXZlbGtleXMgPSBsZXZlbGtleXM7XG4gIGNvbnN0IHsgZW5jcnlwdGVkRnJhZ21lbnRzIH0gPSBsZXZlbDtcbiAgaWYgKFxuICAgICghZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCB8fFxuICAgICAgZW5jcnlwdGVkRnJhZ21lbnRzW2VuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGggLSAxXS5sZXZlbGtleXMgIT09XG4gICAgICAgIGxldmVsa2V5cykgJiZcbiAgICBPYmplY3Qua2V5cyhsZXZlbGtleXMpLnNvbWUoXG4gICAgICAoZm9ybWF0KSA9PiBsZXZlbGtleXMhW2Zvcm1hdF0uaXNDb21tb25FbmNyeXB0aW9uXG4gICAgKVxuICApIHtcbiAgICBlbmNyeXB0ZWRGcmFnbWVudHMucHVzaChmcmFnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBMb2FkZXJDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IFBhcnQgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBLZXlMb2FkZXJJbmZvIH0gZnJvbSAnLi4vbG9hZGVyL2tleS1sb2FkZXInO1xuaW1wb3J0IHR5cGUgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwtZGV0YWlscyc7XG5pbXBvcnQgdHlwZSB7IEhsc1VybFBhcmFtZXRlcnMgfSBmcm9tICcuL2xldmVsJztcblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZXJDb250ZXh0IHtcbiAgLy8gdGFyZ2V0IFVSTFxuICB1cmw6IHN0cmluZztcbiAgLy8gbG9hZGVyIHJlc3BvbnNlIHR5cGUgKGFycmF5YnVmZmVyIG9yIGRlZmF1bHQgcmVzcG9uc2UgdHlwZSBmb3IgcGxheWxpc3QpXG4gIHJlc3BvbnNlVHlwZTogc3RyaW5nO1xuICAvLyBoZWFkZXJzXG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAvLyBzdGFydCBieXRlIHJhbmdlIG9mZnNldFxuICByYW5nZVN0YXJ0PzogbnVtYmVyO1xuICAvLyBlbmQgYnl0ZSByYW5nZSBvZmZzZXRcbiAgcmFuZ2VFbmQ/OiBudW1iZXI7XG4gIC8vIHRydWUgaWYgb25Qcm9ncmVzcyBzaG91bGQgcmVwb3J0IHBhcnRpYWwgY2h1bmsgb2YgbG9hZGVkIGNvbnRlbnRcbiAgcHJvZ3Jlc3NEYXRhPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGcmFnbWVudExvYWRlckNvbnRleHQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0IHtcbiAgZnJhZzogRnJhZ21lbnQ7XG4gIHBhcnQ6IFBhcnQgfCBudWxsO1xuICByZXNldElWPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBLZXlMb2FkZXJDb250ZXh0IGV4dGVuZHMgTG9hZGVyQ29udGV4dCB7XG4gIGtleUluZm86IEtleUxvYWRlckluZm87XG4gIGZyYWc6IEZyYWdtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlckNvbmZpZ3VyYXRpb24ge1xuICAvLyBMb2FkZXJDb25maWcgcG9saWN5IHRoYXQgb3ZlcnJpZGVzIHJlcXVpcmVkIHNldHRpbmdzXG4gIGxvYWRQb2xpY3k6IExvYWRlckNvbmZpZztcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBMb2FkZXJDb25maWcgdGltZW91dFJldHJ5IGFuZCBlcnJvclJldHJ5IG1heE51bVJldHJ5XG4gICAqL1xuICAvLyBNYXggbnVtYmVyIG9mIGxvYWQgcmV0cmllc1xuICBtYXhSZXRyeTogbnVtYmVyO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIExvYWRlckNvbmZpZyBtYXhUaW1lVG9GaXJzdEJ5dGVNcyBhbmQgbWF4TG9hZFRpbWVNc1xuICAgKi9cbiAgLy8gVGltZW91dCBhZnRlciB3aGljaCBgb25UaW1lT3V0YCBjYWxsYmFjayB3aWxsIGJlIHRyaWdnZXJlZFxuICAvLyAgd2hlbiBsb2FkaW5nIGhhcyBub3QgZmluaXNoZWQgYWZ0ZXIgdGhhdCBkZWxheVxuICB0aW1lb3V0OiBudW1iZXI7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgTG9hZGVyQ29uZmlnIHRpbWVvdXRSZXRyeSBhbmQgZXJyb3JSZXRyeSByZXRyeURlbGF5TXNcbiAgICovXG4gIC8vIERlbGF5IGJldHdlZW4gYW4gSS9PIGVycm9yIGFuZCBmb2xsb3dpbmcgY29ubmVjdGlvbiByZXRyeSAobXMpLlxuICAvLyBUaGlzIHRvIGF2b2lkIHNwYW1taW5nIHRoZSBzZXJ2ZXJcbiAgcmV0cnlEZWxheTogbnVtYmVyO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIExvYWRlckNvbmZpZyB0aW1lb3V0UmV0cnkgYW5kIGVycm9yUmV0cnkgbWF4UmV0cnlEZWxheU1zXG4gICAqL1xuICAvLyBtYXggY29ubmVjdGlvbiByZXRyeSBkZWxheSAobXMpXG4gIG1heFJldHJ5RGVsYXk6IG51bWJlcjtcbiAgLy8gV2hlbiBzdHJlYW1pbmcgcHJvZ3Jlc3NpdmVseSwgdGhpcyBpcyB0aGUgbWluaW11bSBjaHVuayBzaXplIHJlcXVpcmVkIHRvIGVtaXQgYSBQUk9HUkVTUyBldmVudFxuICBoaWdoV2F0ZXJNYXJrPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlclJlc3BvbnNlIHtcbiAgdXJsOiBzdHJpbmc7XG4gIGRhdGE/OiBzdHJpbmcgfCBBcnJheUJ1ZmZlciB8IE9iamVjdDtcbiAgLy8gRXJyb3JzIGNhbiBpbmNsdWRlIEhUVFAgc3RhdHVzIGNvZGUgYW5kIGVycm9yIG1lc3NhZ2VcbiAgLy8gU3VjY2Vzc2Z1bCByZXNwb25zZXMgc2hvdWxkIGluY2x1ZGUgc3RhdHVzIGNvZGUgMjAwXG4gIGNvZGU/OiBudW1iZXI7XG4gIHRleHQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyU3RhdHMge1xuICBhYm9ydGVkOiBib29sZWFuO1xuICBsb2FkZWQ6IG51bWJlcjtcbiAgcmV0cnk6IG51bWJlcjtcbiAgdG90YWw6IG51bWJlcjtcbiAgY2h1bmtDb3VudDogbnVtYmVyO1xuICBid0VzdGltYXRlOiBudW1iZXI7XG4gIGxvYWRpbmc6IEhsc1Byb2dyZXNzaXZlUGVyZm9ybWFuY2VUaW1pbmc7XG4gIHBhcnNpbmc6IEhsc1BlcmZvcm1hbmNlVGltaW5nO1xuICBidWZmZXJpbmc6IEhsc1Byb2dyZXNzaXZlUGVyZm9ybWFuY2VUaW1pbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGxzUGVyZm9ybWFuY2VUaW1pbmcge1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIbHNDaHVua1BlcmZvcm1hbmNlVGltaW5nIGV4dGVuZHMgSGxzUGVyZm9ybWFuY2VUaW1pbmcge1xuICBleGVjdXRlU3RhcnQ6IG51bWJlcjtcbiAgZXhlY3V0ZUVuZDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhsc1Byb2dyZXNzaXZlUGVyZm9ybWFuY2VUaW1pbmcgZXh0ZW5kcyBIbHNQZXJmb3JtYW5jZVRpbWluZyB7XG4gIGZpcnN0OiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIExvYWRlck9uU3VjY2VzczxUIGV4dGVuZHMgTG9hZGVyQ29udGV4dD4gPSAoXG4gIHJlc3BvbnNlOiBMb2FkZXJSZXNwb25zZSxcbiAgc3RhdHM6IExvYWRlclN0YXRzLFxuICBjb250ZXh0OiBULFxuICBuZXR3b3JrRGV0YWlsczogYW55XG4pID0+IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIExvYWRlck9uUHJvZ3Jlc3M8VCBleHRlbmRzIExvYWRlckNvbnRleHQ+ID0gKFxuICBzdGF0czogTG9hZGVyU3RhdHMsXG4gIGNvbnRleHQ6IFQsXG4gIGRhdGE6IHN0cmluZyB8IEFycmF5QnVmZmVyLFxuICBuZXR3b3JrRGV0YWlsczogYW55XG4pID0+IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIExvYWRlck9uRXJyb3I8VCBleHRlbmRzIExvYWRlckNvbnRleHQ+ID0gKFxuICBlcnJvcjoge1xuICAgIC8vIGVycm9yIHN0YXR1cyBjb2RlXG4gICAgY29kZTogbnVtYmVyO1xuICAgIC8vIGVycm9yIGRlc2NyaXB0aW9uXG4gICAgdGV4dDogc3RyaW5nO1xuICB9LFxuICBjb250ZXh0OiBULFxuICBuZXR3b3JrRGV0YWlsczogYW55LFxuICBzdGF0czogTG9hZGVyU3RhdHNcbikgPT4gdm9pZDtcblxuZXhwb3J0IHR5cGUgTG9hZGVyT25UaW1lb3V0PFQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0PiA9IChcbiAgc3RhdHM6IExvYWRlclN0YXRzLFxuICBjb250ZXh0OiBULFxuICBuZXR3b3JrRGV0YWlsczogYW55XG4pID0+IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIExvYWRlck9uQWJvcnQ8VCBleHRlbmRzIExvYWRlckNvbnRleHQ+ID0gKFxuICBzdGF0czogTG9hZGVyU3RhdHMsXG4gIGNvbnRleHQ6IFQsXG4gIG5ldHdvcmtEZXRhaWxzOiBhbnlcbikgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZXJDYWxsYmFja3M8VCBleHRlbmRzIExvYWRlckNvbnRleHQ+IHtcbiAgb25TdWNjZXNzOiBMb2FkZXJPblN1Y2Nlc3M8VD47XG4gIG9uRXJyb3I6IExvYWRlck9uRXJyb3I8VD47XG4gIG9uVGltZW91dDogTG9hZGVyT25UaW1lb3V0PFQ+O1xuICBvbkFib3J0PzogTG9hZGVyT25BYm9ydDxUPjtcbiAgb25Qcm9ncmVzcz86IExvYWRlck9uUHJvZ3Jlc3M8VD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyPFQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0PiB7XG4gIGRlc3Ryb3koKTogdm9pZDtcbiAgYWJvcnQoKTogdm9pZDtcbiAgbG9hZChcbiAgICBjb250ZXh0OiBMb2FkZXJDb250ZXh0LFxuICAgIGNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbixcbiAgICBjYWxsYmFja3M6IExvYWRlckNhbGxiYWNrczxUPlxuICApOiB2b2lkO1xuICAvKipcbiAgICogYGdldENhY2hlQWdlKClgIGlzIGNhbGxlZCBieSBobHMuanMgdG8gZ2V0IHRoZSBkdXJhdGlvbiB0aGF0IGEgZ2l2ZW4gb2JqZWN0XG4gICAqIGhhcyBiZWVuIHNpdHRpbmcgaW4gYSBjYWNoZSBwcm94eSB3aGVuIHBsYXlpbmcgbGl2ZS4gIElmIGltcGxlbWVudGVkLFxuICAgKiB0aGlzIHNob3VsZCByZXR1cm4gYSB2YWx1ZSBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBGb3IgSFRUUCBiYXNlZCBsb2FkZXJzLCB0aGlzIHNob3VsZCByZXR1cm4gdGhlIGNvbnRlbnRzIG9mIHRoZSBcImFnZVwiIGhlYWRlci5cbiAgICpcbiAgICogQHJldHVybnMgdGltZSBvYmplY3QgYmVpbmcgbG9kYWRlZFxuICAgKi9cbiAgZ2V0Q2FjaGVBZ2U/OiAoKSA9PiBudW1iZXIgfCBudWxsO1xuICBnZXRSZXNwb25zZUhlYWRlcj86IChuYW1lOiBzdHJpbmcpID0+IHN0cmluZyB8IG51bGw7XG4gIGNvbnRleHQ6IFQ7XG4gIHN0YXRzOiBMb2FkZXJTdGF0cztcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gUGxheWxpc3RDb250ZXh0VHlwZSB7XG4gIE1BTklGRVNUID0gJ21hbmlmZXN0JyxcbiAgTEVWRUwgPSAnbGV2ZWwnLFxuICBBVURJT19UUkFDSyA9ICdhdWRpb1RyYWNrJyxcbiAgU1VCVElUTEVfVFJBQ0sgPSAnc3VidGl0bGVUcmFjaycsXG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIFBsYXlsaXN0TGV2ZWxUeXBlIHtcbiAgTUFJTiA9ICdtYWluJyxcbiAgQVVESU8gPSAnYXVkaW8nLFxuICBTVUJUSVRMRSA9ICdzdWJ0aXRsZScsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxheWxpc3RMb2FkZXJDb250ZXh0IGV4dGVuZHMgTG9hZGVyQ29udGV4dCB7XG4gIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGU7XG4gIC8vIHRoZSBsZXZlbCBpbmRleCB0byBsb2FkXG4gIGxldmVsOiBudW1iZXIgfCBudWxsO1xuICAvLyBsZXZlbCBvciB0cmFjayBpZCBmcm9tIExldmVsTG9hZGluZ0RhdGEgLyBUcmFja0xvYWRpbmdEYXRhXG4gIGlkOiBudW1iZXIgfCBudWxsO1xuICAvLyB0cmFjayBncm91cCBpZFxuICBncm91cElkPzogc3RyaW5nO1xuICAvLyBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIHBhcnNlZCBtM3U4IGxldmVsIHBsYXlsaXN0XG4gIGxldmVsRGV0YWlscz86IExldmVsRGV0YWlscztcbiAgLy8gQmxvY2tpbmcgcGxheWxpc3QgcmVxdWVzdCBkZWxpdmVyeSBkaXJlY3RpdmVzIChvciBudWxsIGlkIG5vbmUgd2VyZSBhZGRlZCB0byBwbGF5bGlzdCB1cmxcbiAgZGVsaXZlcnlEaXJlY3RpdmVzOiBIbHNVcmxQYXJhbWV0ZXJzIHwgbnVsbDtcbn1cbiIsIi8qKlxuICogUGxheWxpc3RMb2FkZXIgLSBkZWxlZ2F0ZSBmb3IgbWVkaWEgbWFuaWZlc3QvcGxheWxpc3QgbG9hZGluZyB0YXNrcy4gVGFrZXMgY2FyZSBvZiBwYXJzaW5nIG1lZGlhIHRvIGludGVybmFsIGRhdGEtbW9kZWxzLlxuICpcbiAqIE9uY2UgbG9hZGVkLCBkaXNwYXRjaGVzIGV2ZW50cyB3aXRoIHBhcnNlZCBkYXRhLW1vZGVscyBvZiBtYW5pZmVzdC9sZXZlbHMvYXVkaW8vc3VidGl0bGUgdHJhY2tzLlxuICpcbiAqIFVzZXMgbG9hZGVyKHMpIHNldCBpbiBjb25maWcgdG8gZG8gYWN0dWFsIGludGVybmFsIGxvYWRpbmcgb2YgcmVzb3VyY2UgdGFza3MuXG4gKi9cblxuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEVycm9yRGV0YWlscywgRXJyb3JUeXBlcyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IE0zVThQYXJzZXIgZnJvbSAnLi9tM3U4LXBhcnNlcic7XG5pbXBvcnQgdHlwZSB7IExldmVsUGFyc2VkLCBWYXJpYWJsZU1hcCB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB0eXBlIHtcbiAgTG9hZGVyLFxuICBMb2FkZXJDYWxsYmFja3MsXG4gIExvYWRlckNvbmZpZ3VyYXRpb24sXG4gIExvYWRlckNvbnRleHQsXG4gIExvYWRlclJlc3BvbnNlLFxuICBMb2FkZXJTdGF0cyxcbiAgUGxheWxpc3RMb2FkZXJDb250ZXh0LFxufSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHsgUGxheWxpc3RDb250ZXh0VHlwZSwgUGxheWxpc3RMZXZlbFR5cGUgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi9sZXZlbC1kZXRhaWxzJztcbmltcG9ydCB7IEF0dHJMaXN0IH0gZnJvbSAnLi4vdXRpbHMvYXR0ci1saXN0JztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuaW1wb3J0IHR5cGUge1xuICBFcnJvckRhdGEsXG4gIExldmVsTG9hZGluZ0RhdGEsXG4gIE1hbmlmZXN0TG9hZGluZ0RhdGEsXG4gIFRyYWNrTG9hZGluZ0RhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IE5ldHdvcmtDb21wb25lbnRBUEkgfSBmcm9tICcuLi90eXBlcy9jb21wb25lbnQtYXBpJztcbmltcG9ydCB0eXBlIHsgTWVkaWFBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vdHlwZXMvbWVkaWEtcGxheWxpc3QnO1xuaW1wb3J0IHR5cGUgeyBMb2FkZXJDb25maWcsIFJldHJ5Q29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcblxuZnVuY3Rpb24gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKFxuICBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHRcbik6IFBsYXlsaXN0TGV2ZWxUeXBlIHtcbiAgY29uc3QgeyB0eXBlIH0gPSBjb250ZXh0O1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgIHJldHVybiBQbGF5bGlzdExldmVsVHlwZS5BVURJTztcbiAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBQbGF5bGlzdExldmVsVHlwZS5NQUlOO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlc3BvbnNlVXJsKFxuICByZXNwb25zZTogTG9hZGVyUmVzcG9uc2UsXG4gIGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dFxuKTogc3RyaW5nIHtcbiAgbGV0IHVybCA9IHJlc3BvbnNlLnVybDtcbiAgLy8gcmVzcG9uc2VVUkwgbm90IHN1cHBvcnRlZCBvbiBzb21lIGJyb3dzZXJzIChpdCBpcyB1c2VkIHRvIGRldGVjdCBVUkwgcmVkaXJlY3Rpb24pXG4gIC8vIGRhdGEtdXJpIG1vZGUgYWxzbyBub3Qgc3VwcG9ydGVkIChidXQgbm8gbmVlZCB0byBkZXRlY3QgcmVkaXJlY3Rpb24pXG4gIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCB1cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgIC8vIGZhbGxiYWNrIHRvIGluaXRpYWwgVVJMXG4gICAgdXJsID0gY29udGV4dC51cmw7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuY2xhc3MgUGxheWxpc3RMb2FkZXIgaW1wbGVtZW50cyBOZXR3b3JrQ29tcG9uZW50QVBJIHtcbiAgcHJpdmF0ZSByZWFkb25seSBobHM6IEhscztcbiAgcHJpdmF0ZSByZWFkb25seSBsb2FkZXJzOiB7XG4gICAgW2tleTogc3RyaW5nXTogTG9hZGVyPExvYWRlckNvbnRleHQ+O1xuICB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcHJpdmF0ZSB2YXJpYWJsZUxpc3Q6IFZhcmlhYmxlTWFwIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoaGxzOiBIbHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb246IG51bWJlcik6IHZvaWQge31cblxuICBwdWJsaWMgc3RvcExvYWQoKTogdm9pZCB7XG4gICAgdGhpcy5kZXN0cm95SW50ZXJuYWxMb2FkZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX0xPQURJTkcsIHRoaXMub25BdWRpb1RyYWNrTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURJTkcsIHRoaXMub25BdWRpb1RyYWNrTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGRlZmF1bHRzIG9yIGNvbmZpZ3VyZWQgbG9hZGVyLXR5cGUgb3ZlcmxvYWRzIChwTG9hZGVyIGFuZCBsb2FkZXIgY29uZmlnIHBhcmFtcylcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlSW50ZXJuYWxMb2FkZXIoXG4gICAgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0XG4gICk6IExvYWRlcjxMb2FkZXJDb250ZXh0PiB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IFBMb2FkZXIgPSBjb25maWcucExvYWRlcjtcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IEludGVybmFsTG9hZGVyID0gUExvYWRlciB8fCBMb2FkZXI7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEludGVybmFsTG9hZGVyKGNvbmZpZykgYXMgTG9hZGVyPFBsYXlsaXN0TG9hZGVyQ29udGV4dD47XG5cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IGxvYWRlcjtcbiAgICByZXR1cm4gbG9hZGVyO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRJbnRlcm5hbExvYWRlcihcbiAgICBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHRcbiAgKTogTG9hZGVyPExvYWRlckNvbnRleHQ+IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV07XG4gIH1cblxuICBwcml2YXRlIHJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXSkge1xuICAgICAgZGVsZXRlIHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYGRlc3Ryb3lgIG9uIGFsbCBpbnRlcm5hbCBsb2FkZXIgaW5zdGFuY2VzIG1hcHBlZCAob25lIHBlciBjb250ZXh0IHR5cGUpXG4gICAqL1xuICBwcml2YXRlIGRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBjb250ZXh0VHlwZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0VHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0TG9hZGluZyhcbiAgICBldmVudDogRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsXG4gICAgZGF0YTogTWFuaWZlc3RMb2FkaW5nRGF0YVxuICApIHtcbiAgICBjb25zdCB7IHVybCB9ID0gZGF0YTtcbiAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGw7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkOiBudWxsLFxuICAgICAgbGV2ZWw6IDAsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IG51bGwsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uTGV2ZWxMb2FkaW5nKGV2ZW50OiBFdmVudHMuTEVWRUxfTE9BRElORywgZGF0YTogTGV2ZWxMb2FkaW5nRGF0YSkge1xuICAgIGNvbnN0IHsgaWQsIGxldmVsLCB1cmwsIGRlbGl2ZXJ5RGlyZWN0aXZlcyB9ID0gZGF0YTtcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQsXG4gICAgICBsZXZlbCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25BdWRpb1RyYWNrTG9hZGluZyhcbiAgICBldmVudDogRXZlbnRzLkFVRElPX1RSQUNLX0xPQURJTkcsXG4gICAgZGF0YTogVHJhY2tMb2FkaW5nRGF0YVxuICApIHtcbiAgICBjb25zdCB7IGlkLCBncm91cElkLCB1cmwsIGRlbGl2ZXJ5RGlyZWN0aXZlcyB9ID0gZGF0YTtcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgbGV2ZWw6IG51bGwsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0ssXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uU3VidGl0bGVUcmFja0xvYWRpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLFxuICAgIGRhdGE6IFRyYWNrTG9hZGluZ0RhdGFcbiAgKSB7XG4gICAgY29uc3QgeyBpZCwgZ3JvdXBJZCwgdXJsLCBkZWxpdmVyeURpcmVjdGl2ZXMgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGxldmVsOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBsb2FkKGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dCk6IHZvaWQge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IExvYWRpbmcgcGxheWxpc3Qgb2YgdHlwZSAke2NvbnRleHQudHlwZX0sIGxldmVsOiAke2NvbnRleHQubGV2ZWx9LCBpZDogJHtjb250ZXh0LmlkfWApO1xuXG4gICAgLy8gQ2hlY2sgaWYgYSBsb2FkZXIgZm9yIHRoaXMgY29udGV4dCBhbHJlYWR5IGV4aXN0c1xuICAgIGxldCBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSBsb2FkZXIuY29udGV4dDtcbiAgICAgIGlmIChsb2FkZXJDb250ZXh0ICYmIGxvYWRlckNvbnRleHQudXJsID09PSBjb250ZXh0LnVybCkge1xuICAgICAgICAvLyBzYW1lIFVSTCBjYW4ndCBvdmVybGFwXG4gICAgICAgIGxvZ2dlci50cmFjZSgnW3BsYXlsaXN0LWxvYWRlcl06IHBsYXlsaXN0IHJlcXVlc3Qgb25nb2luZycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2dnZXIubG9nKFxuICAgICAgICBgW3BsYXlsaXN0LWxvYWRlcl06IGFib3J0aW5nIHByZXZpb3VzIGxvYWRlciBmb3IgdHlwZTogJHtjb250ZXh0LnR5cGV9YFxuICAgICAgKTtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGRpZmZlcmVudCBjb25maWdzIGZvciByZXRyaWVzIGRlcGVuZGluZyBvblxuICAgIC8vIGNvbnRleHQgKG1hbmlmZXN0LCBsZXZlbCwgYXVkaW8vc3VicyBwbGF5bGlzdClcbiAgICBsZXQgbG9hZFBvbGljeTogTG9hZGVyQ29uZmlnO1xuICAgIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QpIHtcbiAgICAgIGxvYWRQb2xpY3kgPSBjb25maWcubWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRQb2xpY3kgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcucGxheWxpc3RMb2FkUG9saWN5LmRlZmF1bHQsIHtcbiAgICAgICAgdGltZW91dFJldHJ5OiBudWxsLFxuICAgICAgICBlcnJvclJldHJ5OiBudWxsLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWRlciA9IHRoaXMuY3JlYXRlSW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG5cbiAgICAvLyBPdmVycmlkZSBsZXZlbC90cmFjayB0aW1lb3V0IGZvciBMTC1ITFMgcmVxdWVzdHNcbiAgICAvLyAodGhlIGRlZmF1bHQgb2YgMTAwMDBtcyBpcyBjb3VudGVyIHByb2R1Y3RpdmUgdG8gYmxvY2tpbmcgcGxheWxpc3QgcmVsb2FkIHJlcXVlc3RzKVxuICAgIGlmIChjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcz8ucGFydCkge1xuICAgICAgbGV0IGxldmVsRGV0YWlsczogTGV2ZWxEZXRhaWxzIHwgdW5kZWZpbmVkO1xuICAgICAgaWYgKFxuICAgICAgICBjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwgJiZcbiAgICAgICAgY29udGV4dC5sZXZlbCAhPT0gbnVsbFxuICAgICAgKSB7XG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLmxldmVsc1tjb250ZXh0LmxldmVsXS5kZXRhaWxzO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmXG4gICAgICAgIGNvbnRleHQuaWQgIT09IG51bGxcbiAgICAgICkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5hdWRpb1RyYWNrc1tjb250ZXh0LmlkXS5kZXRhaWxzO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmXG4gICAgICAgIGNvbnRleHQuaWQgIT09IG51bGxcbiAgICAgICkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5zdWJ0aXRsZVRyYWNrc1tjb250ZXh0LmlkXS5kZXRhaWxzO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICBjb25zdCBwYXJ0VGFyZ2V0ID0gbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQ7XG4gICAgICAgIGNvbnN0IHRhcmdldER1cmF0aW9uID0gbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgICBpZiAocGFydFRhcmdldCAmJiB0YXJnZXREdXJhdGlvbikge1xuICAgICAgICAgIGNvbnN0IG1heExvd0xhdGVuY3lQbGF5bGlzdFJlZnJlc2ggPVxuICAgICAgICAgICAgTWF0aC5tYXgocGFydFRhcmdldCAqIDMsIHRhcmdldER1cmF0aW9uICogMC44KSAqIDEwMDA7XG4gICAgICAgICAgbG9hZFBvbGljeSA9IE9iamVjdC5hc3NpZ24oe30sIGxvYWRQb2xpY3ksIHtcbiAgICAgICAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiBNYXRoLm1pbihcbiAgICAgICAgICAgICAgbWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCxcbiAgICAgICAgICAgICAgbG9hZFBvbGljeS5tYXhUaW1lVG9GaXJzdEJ5dGVNc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG1heExvYWRUaW1lTXM6IE1hdGgubWluKFxuICAgICAgICAgICAgICBtYXhMb3dMYXRlbmN5UGxheWxpc3RSZWZyZXNoLFxuICAgICAgICAgICAgICBsb2FkUG9saWN5Lm1heFRpbWVUb0ZpcnN0Qnl0ZU1zXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5OiBSZXRyeUNvbmZpZyB8IFJlY29yZDxzdHJpbmcsIHZvaWQ+ID1cbiAgICAgIGxvYWRQb2xpY3kuZXJyb3JSZXRyeSB8fCBsb2FkUG9saWN5LnRpbWVvdXRSZXRyeSB8fCB7fTtcbiAgICBjb25zdCBsb2FkZXJDb25maWc6IExvYWRlckNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICBsb2FkUG9saWN5LFxuICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgbWF4UmV0cnk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhOdW1SZXRyeSB8fCAwLFxuICAgICAgcmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5LnJldHJ5RGVsYXlNcyB8fCAwLFxuICAgICAgbWF4UmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heFJldHJ5RGVsYXlNcyB8fCAwLFxuICAgIH07XG5cbiAgICBjb25zdCBsb2FkZXJDYWxsYmFja3M6IExvYWRlckNhbGxiYWNrczxQbGF5bGlzdExvYWRlckNvbnRleHQ+ID0ge1xuICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpIGFzXG4gICAgICAgICAgfCBMb2FkZXI8UGxheWxpc3RMb2FkZXJDb250ZXh0PlxuICAgICAgICAgIHwgdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcblxuICAgICAgICBjb25zdCBzdHJpbmcgPSByZXNwb25zZS5kYXRhIGFzIHN0cmluZztcblxuICAgICAgICAvLyBWYWxpZGF0ZSBpZiBpdCBpcyBhbiBNM1U4IGF0IGFsbFxuICAgICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRNM1UnKSAhPT0gMCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ25vIEVYVE0zVSBkZWxpbWl0ZXInKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzIHx8IG51bGwsXG4gICAgICAgICAgICBzdGF0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBpZiAoTTNVOFBhcnNlci5pc01lZGlhUGxheWxpc3Qoc3RyaW5nKSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzIHx8IG51bGwsXG4gICAgICAgICAgICBsb2FkZXJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaGFuZGxlTWFzdGVyUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZU5ldHdvcmtFcnJvcihcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIHN0YXRzXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlTmV0d29ya0Vycm9yKFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgc3RhdHNcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IENhbGxpbmcgaW50ZXJuYWwgbG9hZGVyIGRlbGVnYXRlIGZvciBVUkw6ICR7Y29udGV4dC51cmx9YCk7XG5cbiAgICBsb2FkZXIubG9hZChjb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU1hc3RlclBsYXlsaXN0KFxuICAgIHJlc3BvbnNlOiBMb2FkZXJSZXNwb25zZSxcbiAgICBzdGF0czogTG9hZGVyU3RhdHMsXG4gICAgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0LFxuICAgIG5ldHdvcmtEZXRhaWxzOiBhbnlcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3Qgc3RyaW5nID0gcmVzcG9uc2UuZGF0YSBhcyBzdHJpbmc7XG5cbiAgICBjb25zdCB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG5cbiAgICBjb25zdCBwYXJzZWRSZXN1bHQgPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCB1cmwpO1xuXG4gICAgaWYgKHBhcnNlZFJlc3VsdC5wbGF5bGlzdFBhcnNpbmdFcnJvcikge1xuICAgICAgdGhpcy5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHBhcnNlZFJlc3VsdC5wbGF5bGlzdFBhcnNpbmdFcnJvcixcbiAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgIHN0YXRzXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRlbnRTdGVlcmluZyxcbiAgICAgIGxldmVscyxcbiAgICAgIHNlc3Npb25EYXRhLFxuICAgICAgc2Vzc2lvbktleXMsXG4gICAgICBzdGFydFRpbWVPZmZzZXQsXG4gICAgICB2YXJpYWJsZUxpc3QsXG4gICAgfSA9IHBhcnNlZFJlc3VsdDtcblxuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gdmFyaWFibGVMaXN0O1xuXG4gICAgY29uc3Qge1xuICAgICAgQVVESU86IGF1ZGlvVHJhY2tzID0gW10sXG4gICAgICBTVUJUSVRMRVM6IHN1YnRpdGxlcyxcbiAgICAgICdDTE9TRUQtQ0FQVElPTlMnOiBjYXB0aW9ucyxcbiAgICB9ID0gTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsIHBhcnNlZFJlc3VsdCk7XG5cbiAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgIGNvbnN0IGVtYmVkZGVkQXVkaW9Gb3VuZDogYm9vbGVhbiA9IGF1ZGlvVHJhY2tzLnNvbWUoXG4gICAgICAgIChhdWRpb1RyYWNrKSA9PiAhYXVkaW9UcmFjay51cmxcbiAgICAgICk7XG5cbiAgICAgIC8vIGlmIG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIGRlZmluZWQsIGJ1dCBhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLFxuICAgICAgLy8gd2UgbmVlZCB0byBzaWduYWwgdGhpcyBtYWluIGF1ZGlvIHRyYWNrIHRoaXMgY291bGQgaGFwcGVuIHdpdGggcGxheWxpc3RzIHdpdGhcbiAgICAgIC8vIGFsdCBhdWRpbyByZW5kaXRpb24gaW4gd2hpY2ggcXVhbGl0eSBsZXZlbHMgKG1haW4pXG4gICAgICAvLyBjb250YWlucyBib3RoIGF1ZGlvK3ZpZGVvLiBidXQgd2l0aCBtaXhlZCBhdWRpbyB0cmFjayBub3Qgc2lnbmFsZWRcbiAgICAgIGlmIChcbiAgICAgICAgIWVtYmVkZGVkQXVkaW9Gb3VuZCAmJlxuICAgICAgICBsZXZlbHNbMF0uYXVkaW9Db2RlYyAmJlxuICAgICAgICAhbGV2ZWxzWzBdLmF0dHJzLkFVRElPXG4gICAgICApIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAnW3BsYXlsaXN0LWxvYWRlcl06IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIGJ1dCBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBzaWduYWxlZCwgY3JlYXRlIG9uZSdcbiAgICAgICAgKTtcbiAgICAgICAgYXVkaW9UcmFja3MudW5zaGlmdCh7XG4gICAgICAgICAgdHlwZTogJ21haW4nLFxuICAgICAgICAgIG5hbWU6ICdtYWluJyxcbiAgICAgICAgICBncm91cElkOiAnbWFpbicsXG4gICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgYXV0b3NlbGVjdDogZmFsc2UsXG4gICAgICAgICAgZm9yY2VkOiBmYWxzZSxcbiAgICAgICAgICBpZDogLTEsXG4gICAgICAgICAgYXR0cnM6IG5ldyBBdHRyTGlzdCh7fSkgYXMgTWVkaWFBdHRyaWJ1dGVzLFxuICAgICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgICAgdXJsOiAnJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGxzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgbGV2ZWxzLFxuICAgICAgYXVkaW9UcmFja3MsXG4gICAgICBzdWJ0aXRsZXMsXG4gICAgICBjYXB0aW9ucyxcbiAgICAgIGNvbnRlbnRTdGVlcmluZyxcbiAgICAgIHVybCxcbiAgICAgIHN0YXRzLFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBzZXNzaW9uRGF0YSxcbiAgICAgIHNlc3Npb25LZXlzLFxuICAgICAgc3RhcnRUaW1lT2Zmc2V0LFxuICAgICAgdmFyaWFibGVMaXN0LFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdChcbiAgICByZXNwb25zZTogTG9hZGVyUmVzcG9uc2UsXG4gICAgc3RhdHM6IExvYWRlclN0YXRzLFxuICAgIGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dCxcbiAgICBuZXR3b3JrRGV0YWlsczogYW55LFxuICAgIGxvYWRlcjogTG9hZGVyPFBsYXlsaXN0TG9hZGVyQ29udGV4dD4gfCB1bmRlZmluZWRcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgeyBpZCwgbGV2ZWwsIHR5cGUgfSA9IGNvbnRleHQ7XG5cbiAgICBjb25zdCB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgY29uc3QgbGV2ZWxVcmxJZCA9IE51bWJlci5pc0Zpbml0ZShpZCBhcyBudW1iZXIpID8gKGlkIGFzIG51bWJlcikgOiAwO1xuICAgIGNvbnN0IGxldmVsSWQgPSBOdW1iZXIuaXNGaW5pdGUobGV2ZWwgYXMgbnVtYmVyKVxuICAgICAgPyAobGV2ZWwgYXMgbnVtYmVyKVxuICAgICAgOiBsZXZlbFVybElkO1xuICAgIGNvbnN0IGxldmVsVHlwZSA9IG1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KTtcbiAgICBjb25zdCBsZXZlbERldGFpbHM6IExldmVsRGV0YWlscyA9IE0zVThQYXJzZXIucGFyc2VMZXZlbFBsYXlsaXN0KFxuICAgICAgcmVzcG9uc2UuZGF0YSBhcyBzdHJpbmcsXG4gICAgICB1cmwsXG4gICAgICBsZXZlbElkLFxuICAgICAgbGV2ZWxUeXBlLFxuICAgICAgbGV2ZWxVcmxJZCxcbiAgICAgIHRoaXMudmFyaWFibGVMaXN0XG4gICAgKTtcblxuICAgIC8vIFdlIGhhdmUgZG9uZSBvdXIgZmlyc3QgcmVxdWVzdCAoTWFuaWZlc3QtdHlwZSkgYW5kIHJlY2VpdmVcbiAgICAvLyBub3QgYSBtYXN0ZXIgcGxheWxpc3QgYnV0IGEgY2h1bmstbGlzdCAodHJhY2svbGV2ZWwpXG4gICAgLy8gV2UgZmlyZSB0aGUgbWFuaWZlc3QtbG9hZGVkIGV2ZW50IGFueXdheSB3aXRoIHRoZSBwYXJzZWQgbGV2ZWwtZGV0YWlsc1xuICAgIC8vIGJ5IGNyZWF0aW5nIGEgc2luZ2xlLWxldmVsIHN0cnVjdHVyZSBmb3IgaXQuXG4gICAgaWYgKHR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QpIHtcbiAgICAgIGNvbnN0IHNpbmdsZUxldmVsOiBMZXZlbFBhcnNlZCA9IHtcbiAgICAgICAgYXR0cnM6IG5ldyBBdHRyTGlzdCh7fSksXG4gICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIHVybCxcbiAgICAgIH07XG5cbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgICAgbGV2ZWxzOiBbc2luZ2xlTGV2ZWxdLFxuICAgICAgICBhdWRpb1RyYWNrczogW10sXG4gICAgICAgIHVybCxcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzZXNzaW9uRGF0YTogbnVsbCxcbiAgICAgICAgc2Vzc2lvbktleXM6IG51bGwsXG4gICAgICAgIGNvbnRlbnRTdGVlcmluZzogbnVsbCxcbiAgICAgICAgc3RhcnRUaW1lT2Zmc2V0OiBudWxsLFxuICAgICAgICB2YXJpYWJsZUxpc3Q6IG51bGwsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzYXZlIHBhcnNpbmcgdGltZVxuICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAvLyBleHRlbmQgdGhlIGNvbnRleHQgd2l0aCB0aGUgbmV3IGxldmVsRGV0YWlscyBwcm9wZXJ0eVxuICAgIGNvbnRleHQubGV2ZWxEZXRhaWxzID0gbGV2ZWxEZXRhaWxzO1xuXG4gICAgdGhpcy5oYW5kbGVQbGF5bGlzdExvYWRlZChcbiAgICAgIGxldmVsRGV0YWlscyxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgc3RhdHMsXG4gICAgICBjb250ZXh0LFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBsb2FkZXJcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihcbiAgICByZXNwb25zZTogTG9hZGVyUmVzcG9uc2UsXG4gICAgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0LFxuICAgIGVycm9yOiBFcnJvcixcbiAgICBuZXR3b3JrRGV0YWlsczogYW55LFxuICAgIHN0YXRzOiBMb2FkZXJTdGF0c1xuICApOiB2b2lkIHtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsXG4gICAgICBmYXRhbDogY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNULFxuICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICBlcnI6IGVycm9yLFxuICAgICAgZXJyb3IsXG4gICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICByZXNwb25zZSxcbiAgICAgIGNvbnRleHQsXG4gICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgIHN0YXRzLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVOZXR3b3JrRXJyb3IoXG4gICAgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0LFxuICAgIG5ldHdvcmtEZXRhaWxzOiBhbnksXG4gICAgdGltZW91dCA9IGZhbHNlLFxuICAgIHJlc3BvbnNlOiB7IGNvZGU6IG51bWJlcjsgdGV4dDogc3RyaW5nIH0gfCB1bmRlZmluZWQsXG4gICAgc3RhdHM6IExvYWRlclN0YXRzXG4gICk6IHZvaWQge1xuICAgIGxldCBtZXNzYWdlID0gYEEgbmV0d29yayAke1xuICAgICAgdGltZW91dFxuICAgICAgICA/ICd0aW1lb3V0J1xuICAgICAgICA6ICdlcnJvcicgKyAocmVzcG9uc2UgPyAnIChzdGF0dXMgJyArIHJlc3BvbnNlLmNvZGUgKyAnKScgOiAnJylcbiAgICB9IG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnR5cGV9YDtcbiAgICBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMKSB7XG4gICAgICBtZXNzYWdlICs9IGA6ICR7Y29udGV4dC5sZXZlbH0gaWQ6ICR7Y29udGV4dC5pZH1gO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgfHxcbiAgICAgIGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDS1xuICAgICkge1xuICAgICAgbWVzc2FnZSArPSBgIGlkOiAke2NvbnRleHQuaWR9IGdyb3VwLWlkOiBcIiR7Y29udGV4dC5ncm91cElkfVwiYDtcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgbG9nZ2VyLndhcm4oYFtwbGF5bGlzdC1sb2FkZXJdOiAke21lc3NhZ2V9YCk7XG4gICAgbGV0IGRldGFpbHMgPSBFcnJvckRldGFpbHMuVU5LTk9XTjtcbiAgICBsZXQgZmF0YWwgPSBmYWxzZTtcblxuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG5cbiAgICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dFxuICAgICAgICAgID8gRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVFxuICAgICAgICAgIDogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUw6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0XG4gICAgICAgICAgPyBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUXG4gICAgICAgICAgOiBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0XG4gICAgICAgICAgPyBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUXG4gICAgICAgICAgOiBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0XG4gICAgICAgICAgPyBFcnJvckRldGFpbHMuU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUXG4gICAgICAgICAgOiBFcnJvckRldGFpbHMuU1VCVElUTEVfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHQudHlwZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JEYXRhOiBFcnJvckRhdGEgPSB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzLFxuICAgICAgZmF0YWwsXG4gICAgICB1cmw6IGNvbnRleHQudXJsLFxuICAgICAgbG9hZGVyLFxuICAgICAgY29udGV4dCxcbiAgICAgIGVycm9yLFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBzdGF0cyxcbiAgICB9O1xuXG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXR3b3JrRGV0YWlscz8udXJsIHx8IGNvbnRleHQudXJsO1xuICAgICAgZXJyb3JEYXRhLnJlc3BvbnNlID0geyB1cmwsIGRhdGE6IHVuZGVmaW5lZCBhcyBhbnksIC4uLnJlc3BvbnNlIH07XG4gICAgfVxuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGVycm9yRGF0YSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVBsYXlsaXN0TG9hZGVkKFxuICAgIGxldmVsRGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICAgIHJlc3BvbnNlOiBMb2FkZXJSZXNwb25zZSxcbiAgICBzdGF0czogTG9hZGVyU3RhdHMsXG4gICAgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0LFxuICAgIG5ldHdvcmtEZXRhaWxzOiBhbnksXG4gICAgbG9hZGVyOiBMb2FkZXI8UGxheWxpc3RMb2FkZXJDb250ZXh0PiB8IHVuZGVmaW5lZFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCB7IHR5cGUsIGxldmVsLCBpZCwgZ3JvdXBJZCwgZGVsaXZlcnlEaXJlY3RpdmVzIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICBjb25zdCBwYXJlbnQgPSBtYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCk7XG4gICAgY29uc3QgbGV2ZWxJbmRleCA9XG4gICAgICB0eXBlb2YgY29udGV4dC5sZXZlbCA9PT0gJ251bWJlcicgJiYgcGFyZW50ID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOXG4gICAgICAgID8gKGxldmVsIGFzIG51bWJlcilcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFsZXZlbERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ05vIFNlZ21lbnRzIGZvdW5kIGluIFBsYXlsaXN0Jyk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfRU1QVFlfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgdXJsLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbGV2ZWw6IGxldmVsSW5kZXgsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgIHN0YXRzLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSB7XG4gICAgICBsZXZlbERldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoJ01pc3NpbmcgVGFyZ2V0IER1cmF0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gbGV2ZWxEZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgdXJsLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbGV2ZWw6IGxldmVsSW5kZXgsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgIHN0YXRzLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlICYmIGxvYWRlcikge1xuICAgICAgaWYgKGxvYWRlci5nZXRDYWNoZUFnZSkge1xuICAgICAgICBsZXZlbERldGFpbHMuYWdlSGVhZGVyID0gbG9hZGVyLmdldENhY2hlQWdlKCkgfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmICghbG9hZGVyLmdldENhY2hlQWdlIHx8IGlzTmFOKGxldmVsRGV0YWlscy5hZ2VIZWFkZXIpKSB7XG4gICAgICAgIGxldmVsRGV0YWlscy5hZ2VIZWFkZXIgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUOlxuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuTEVWRUxfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGxldmVsOiBsZXZlbEluZGV4IHx8IDAsXG4gICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBncm91cElkOiBncm91cElkIHx8ICcnLFxuICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGF5bGlzdExvYWRlcjtcbiIsImltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNlbmRBZGRUcmFja0V2ZW50KHRyYWNrOiBUZXh0VHJhY2ssIHZpZGVvRWw6IEhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgbGV0IGV2ZW50OiBFdmVudDtcbiAgdHJ5IHtcbiAgICBldmVudCA9IG5ldyBFdmVudCgnYWRkdHJhY2snKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gZm9yIElFMTFcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xuICB9XG4gIChldmVudCBhcyBhbnkpLnRyYWNrID0gdHJhY2s7XG4gIHZpZGVvRWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRDdWVUb1RyYWNrKHRyYWNrOiBUZXh0VHJhY2ssIGN1ZTogVlRUQ3VlKSB7XG4gIC8vIFNvbWV0aW1lcyB0aGVyZSBhcmUgY3VlIG92ZXJsYXBzIG9uIHNlZ21lbnRlZCB2dHRzIHNvIHRoZSBzYW1lXG4gIC8vIGN1ZSBjYW4gYXBwZWFyIG1vcmUgdGhhbiBvbmNlIGluIGRpZmZlcmVudCB2dHQgZmlsZXMuXG4gIC8vIFRoaXMgYXZvaWQgc2hvd2luZyBkdXBsaWNhdGVkIGN1ZXMgd2l0aCBzYW1lIHRpbWVjb2RlIGFuZCB0ZXh0LlxuICBjb25zdCBtb2RlID0gdHJhY2subW9kZTtcbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gIH1cbiAgaWYgKHRyYWNrLmN1ZXMgJiYgIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgaWYgKCF0cmFjay5jdWVzLmdldEN1ZUJ5SWQoY3VlLmlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFkZEN1ZSBpcyBmYWlsZWQgZm9yOiAke2N1ZX1gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgW3RleHR0cmFjay11dGlsc106ICR7ZXJyfWApO1xuICAgICAgY29uc3QgdGV4dFRyYWNrQ3VlID0gbmV3IChzZWxmLlRleHRUcmFja0N1ZSBhcyBhbnkpKFxuICAgICAgICBjdWUuc3RhcnRUaW1lLFxuICAgICAgICBjdWUuZW5kVGltZSxcbiAgICAgICAgY3VlLnRleHRcbiAgICAgICk7XG4gICAgICB0ZXh0VHJhY2tDdWUuaWQgPSBjdWUuaWQ7XG4gICAgICB0cmFjay5hZGRDdWUodGV4dFRyYWNrQ3VlKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3Vlcyh0cmFjazogVGV4dFRyYWNrKSB7XG4gIC8vIFdoZW4gdHJhY2subW9kZSBpcyBkaXNhYmxlZCwgdHJhY2suY3VlcyB3aWxsIGJlIG51bGwuXG4gIC8vIFRvIGd1YXJhbnRlZSB0aGUgcmVtb3ZhbCBvZiBjdWVzLCB3ZSBuZWVkIHRvIHRlbXBvcmFyaWx5XG4gIC8vIGNoYW5nZSB0aGUgbW9kZSB0byBoaWRkZW5cbiAgY29uc3QgbW9kZSA9IHRyYWNrLm1vZGU7XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICB9XG4gIGlmICh0cmFjay5jdWVzKSB7XG4gICAgZm9yIChsZXQgaSA9IHRyYWNrLmN1ZXMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbaV0pO1xuICAgIH1cbiAgfVxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDdWVzSW5SYW5nZShcbiAgdHJhY2s6IFRleHRUcmFjayxcbiAgc3RhcnQ6IG51bWJlcixcbiAgZW5kOiBudW1iZXIsXG4gIHByZWRpY2F0ZT86IChjdWU6IFRleHRUcmFja0N1ZSkgPT4gYm9vbGVhblxuKSB7XG4gIGNvbnN0IG1vZGUgPSB0cmFjay5tb2RlO1xuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuXG4gIGlmICh0cmFjay5jdWVzICYmIHRyYWNrLmN1ZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGN1ZXMgPSBnZXRDdWVzSW5SYW5nZSh0cmFjay5jdWVzLCBzdGFydCwgZW5kKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZShjdWVzW2ldKSkge1xuICAgICAgICB0cmFjay5yZW1vdmVDdWUoY3Vlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9IG1vZGU7XG4gIH1cbn1cblxuLy8gRmluZCBmaXJzdCBjdWUgc3RhcnRpbmcgYWZ0ZXIgZ2l2ZW4gdGltZS5cbi8vIE1vZGlmaWVkIHZlcnNpb24gb2YgYmluYXJ5IHNlYXJjaCBPKGxvZyhuKSkuXG5mdW5jdGlvbiBnZXRGaXJzdEN1ZUluZGV4QWZ0ZXJUaW1lKFxuICBjdWVzOiBUZXh0VHJhY2tDdWVMaXN0IHwgVGV4dFRyYWNrQ3VlW10sXG4gIHRpbWU6IG51bWJlclxuKTogbnVtYmVyIHtcbiAgLy8gSWYgZmlyc3QgY3VlIHN0YXJ0cyBhZnRlciB0aW1lLCBzdGFydCB0aGVyZVxuICBpZiAodGltZSA8IGN1ZXNbMF0uc3RhcnRUaW1lKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gSWYgdGhlIGxhc3QgY3VlIGVuZHMgYmVmb3JlIHRpbWUgdGhlcmUgaXMgbm8gb3ZlcmxhcFxuICBjb25zdCBsZW4gPSBjdWVzLmxlbmd0aCAtIDE7XG4gIGlmICh0aW1lID4gY3Vlc1tsZW5dLmVuZFRpbWUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBsZXQgbGVmdCA9IDA7XG4gIGxldCByaWdodCA9IGxlbjtcblxuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKHJpZ2h0ICsgbGVmdCkgLyAyKTtcblxuICAgIGlmICh0aW1lIDwgY3Vlc1ttaWRdLnN0YXJ0VGltZSkge1xuICAgICAgcmlnaHQgPSBtaWQgLSAxO1xuICAgIH0gZWxzZSBpZiAodGltZSA+IGN1ZXNbbWlkXS5zdGFydFRpbWUgJiYgbGVmdCA8IGxlbikge1xuICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGl0J3Mgbm90IGxvd2VyIG9yIGhpZ2hlciwgaXQgbXVzdCBiZSBlcXVhbC5cbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICB9XG4gIC8vIEF0IHRoaXMgcG9pbnQsIGxlZnQgYW5kIHJpZ2h0IGhhdmUgc3dhcHBlZC5cbiAgLy8gTm8gZGlyZWN0IG1hdGNoIHdhcyBmb3VuZCwgbGVmdCBvciByaWdodCBlbGVtZW50IG11c3QgYmUgdGhlIGNsb3Nlc3QuIENoZWNrIHdoaWNoIG9uZSBoYXMgdGhlIHNtYWxsZXN0IGRpZmYuXG4gIHJldHVybiBjdWVzW2xlZnRdLnN0YXJ0VGltZSAtIHRpbWUgPCB0aW1lIC0gY3Vlc1tyaWdodF0uc3RhcnRUaW1lXG4gICAgPyBsZWZ0XG4gICAgOiByaWdodDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1ZXNJblJhbmdlKFxuICBjdWVzOiBUZXh0VHJhY2tDdWVMaXN0IHwgVGV4dFRyYWNrQ3VlW10sXG4gIHN0YXJ0OiBudW1iZXIsXG4gIGVuZDogbnVtYmVyXG4pOiBUZXh0VHJhY2tDdWVbXSB7XG4gIGNvbnN0IGN1ZXNGb3VuZDogVGV4dFRyYWNrQ3VlW10gPSBbXTtcbiAgY29uc3QgZmlyc3RDdWVJblJhbmdlID0gZ2V0Rmlyc3RDdWVJbmRleEFmdGVyVGltZShjdWVzLCBzdGFydCk7XG4gIGlmIChmaXJzdEN1ZUluUmFuZ2UgPiAtMSkge1xuICAgIGZvciAobGV0IGkgPSBmaXJzdEN1ZUluUmFuZ2UsIGxlbiA9IGN1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1ZSA9IGN1ZXNbaV07XG4gICAgICBpZiAoY3VlLnN0YXJ0VGltZSA+PSBzdGFydCAmJiBjdWUuZW5kVGltZSA8PSBlbmQpIHtcbiAgICAgICAgY3Vlc0ZvdW5kLnB1c2goY3VlKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VlLnN0YXJ0VGltZSA+IGVuZCkge1xuICAgICAgICByZXR1cm4gY3Vlc0ZvdW5kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY3Vlc0ZvdW5kO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXRpb25hbFRpbWVzdGFtcCB9IGZyb20gJy4uL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBEZW11eGVyIHtcbiAgZGVtdXgoXG4gICAgZGF0YTogVWludDhBcnJheSxcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gICAgaXNTYW1wbGVBZXM/OiBib29sZWFuLFxuICAgIGZsdXNoPzogYm9vbGVhblxuICApOiBEZW11eGVyUmVzdWx0O1xuICBkZW11eFNhbXBsZUFlcyhcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtleURhdGE6IEtleURhdGEsXG4gICAgdGltZU9mZnNldDogbnVtYmVyXG4gICk6IFByb21pc2U8RGVtdXhlclJlc3VsdD47XG4gIGZsdXNoKHRpbWVPZmZzZXQ/OiBudW1iZXIpOiBEZW11eGVyUmVzdWx0IHwgUHJvbWlzZTxEZW11eGVyUmVzdWx0PjtcbiAgZGVzdHJveSgpOiB2b2lkO1xuICByZXNldEluaXRTZWdtZW50KFxuICAgIGluaXRTZWdtZW50OiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICAgIGF1ZGlvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2aWRlb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdHJhY2tEdXJhdGlvbjogbnVtYmVyXG4gICk7XG4gIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UFRTPzogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsKTogdm9pZDtcbiAgcmVzZXRDb250aWd1aXR5KCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVtdXhlclJlc3VsdCB7XG4gIGF1ZGlvVHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrO1xuICB2aWRlb1RyYWNrOiBEZW11eGVkVmlkZW9UcmFjaztcbiAgaWQzVHJhY2s6IERlbXV4ZWRNZXRhZGF0YVRyYWNrO1xuICB0ZXh0VHJhY2s6IERlbXV4ZWRVc2VyZGF0YVRyYWNrO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlbXV4ZWRUcmFjayB7XG4gIHR5cGU6IHN0cmluZztcbiAgaWQ6IG51bWJlcjtcbiAgcGlkOiBudW1iZXI7XG4gIGlucHV0VGltZVNjYWxlOiBudW1iZXI7XG4gIHNlcXVlbmNlTnVtYmVyOiBudW1iZXI7XG4gIHNhbXBsZXM6XG4gICAgfCBBdWRpb1NhbXBsZVtdXG4gICAgfCBBdmNTYW1wbGVbXVxuICAgIHwgTWV0YWRhdGFTYW1wbGVbXVxuICAgIHwgVXNlcmRhdGFTYW1wbGVbXVxuICAgIHwgVWludDhBcnJheTtcbiAgdGltZXNjYWxlPzogbnVtYmVyO1xuICBjb250YWluZXI/OiBzdHJpbmc7XG4gIGRyb3BwZWQ6IG51bWJlcjtcbiAgZHVyYXRpb24/OiBudW1iZXI7XG4gIHBlc0RhdGE/OiBFbGVtZW50YXJ5U3RyZWFtRGF0YSB8IG51bGw7XG4gIGNvZGVjPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhc3N0aHJvdWdoVHJhY2sgZXh0ZW5kcyBEZW11eGVkVHJhY2sge1xuICBzYW1wbGVEdXJhdGlvbjogbnVtYmVyO1xuICBzYW1wbGVzOiBVaW50OEFycmF5O1xuICB0aW1lc2NhbGU6IG51bWJlcjtcbiAgZHVyYXRpb246IG51bWJlcjtcbiAgY29kZWM6IHN0cmluZztcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRGVtdXhlZEF1ZGlvVHJhY2sgZXh0ZW5kcyBEZW11eGVkVHJhY2sge1xuICBjb25maWc/OiBudW1iZXJbXTtcbiAgc2FtcGxlcmF0ZT86IG51bWJlcjtcbiAgc2VnbWVudENvZGVjPzogc3RyaW5nO1xuICBjaGFubmVsQ291bnQ/OiBudW1iZXI7XG4gIG1hbmlmZXN0Q29kZWM/OiBzdHJpbmc7XG4gIHNhbXBsZXM6IEF1ZGlvU2FtcGxlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVtdXhlZFZpZGVvVHJhY2sgZXh0ZW5kcyBEZW11eGVkVHJhY2sge1xuICB3aWR0aD86IG51bWJlcjtcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICBwaXhlbFJhdGlvPzogW251bWJlciwgbnVtYmVyXTtcbiAgYXVkRm91bmQ/OiBib29sZWFuO1xuICBwcHM/OiBVaW50OEFycmF5W107XG4gIHNwcz86IFVpbnQ4QXJyYXlbXTtcbiAgbmFsdVN0YXRlPzogbnVtYmVyO1xuICBzYW1wbGVzOiBBdmNTYW1wbGVbXSB8IFVpbnQ4QXJyYXk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVtdXhlZEF2Y1RyYWNrIGV4dGVuZHMgRGVtdXhlZFZpZGVvVHJhY2sge1xuICBzYW1wbGVzOiBBdmNTYW1wbGVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZW11eGVkTWV0YWRhdGFUcmFjayBleHRlbmRzIERlbXV4ZWRUcmFjayB7XG4gIHNhbXBsZXM6IE1ldGFkYXRhU2FtcGxlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVtdXhlZFVzZXJkYXRhVHJhY2sgZXh0ZW5kcyBEZW11eGVkVHJhY2sge1xuICBzYW1wbGVzOiBVc2VyZGF0YVNhbXBsZVtdO1xufVxuXG5leHBvcnQgY29uc3QgZW51bSBNZXRhZGF0YVNjaGVtYSB7XG4gIGF1ZGlvSWQzID0gJ29yZy5pZDMnLFxuICBkYXRlUmFuZ2UgPSAnY29tLmFwcGxlLnF1aWNrdGltZS5ITFMnLFxuICBlbXNnID0gJ2h0dHBzOi8vYW9tZWRpYS5vcmcvZW1zZy9JRDMnLFxufVxuZXhwb3J0IGludGVyZmFjZSBNZXRhZGF0YVNhbXBsZSB7XG4gIHB0czogbnVtYmVyO1xuICBkdHM6IG51bWJlcjtcbiAgZHVyYXRpb246IG51bWJlcjtcbiAgbGVuPzogbnVtYmVyO1xuICBkYXRhOiBVaW50OEFycmF5O1xuICB0eXBlOiBNZXRhZGF0YVNjaGVtYTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyZGF0YVNhbXBsZSB7XG4gIHB0czogbnVtYmVyO1xuICBieXRlcz86IFVpbnQ4QXJyYXk7XG4gIHR5cGU/OiBudW1iZXI7XG4gIHBheWxvYWRUeXBlPzogbnVtYmVyO1xuICB1dWlkPzogc3RyaW5nO1xuICB1c2VyRGF0YT86IHN0cmluZztcbiAgdXNlckRhdGFCeXRlcz86IFVpbnQ4QXJyYXk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXZjU2FtcGxlIHtcbiAgZHRzOiBudW1iZXI7XG4gIHB0czogbnVtYmVyO1xuICBrZXk6IGJvb2xlYW47XG4gIGZyYW1lOiBib29sZWFuO1xuICB1bml0czogQXZjU2FtcGxlVW5pdFtdO1xuICBkZWJ1Zzogc3RyaW5nO1xuICBsZW5ndGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdmNTYW1wbGVVbml0IHtcbiAgZGF0YTogVWludDhBcnJheTtcbiAgdHlwZTogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBBdWRpb1NhbXBsZSA9IHtcbiAgdW5pdDogVWludDhBcnJheTtcbiAgcHRzOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBBdWRpb0ZyYW1lID0ge1xuICBzYW1wbGU6IEF1ZGlvU2FtcGxlO1xuICBsZW5ndGg6IG51bWJlcjtcbiAgbWlzc2luZzogbnVtYmVyO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50YXJ5U3RyZWFtRGF0YSB7XG4gIGRhdGE6IFVpbnQ4QXJyYXlbXTtcbiAgc2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEtleURhdGEge1xuICBtZXRob2Q6IHN0cmluZztcbiAga2V5OiBVaW50OEFycmF5O1xuICBpdjogVWludDhBcnJheTtcbn1cbiIsImltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQge1xuICBzZW5kQWRkVHJhY2tFdmVudCxcbiAgY2xlYXJDdXJyZW50Q3VlcyxcbiAgcmVtb3ZlQ3Vlc0luUmFuZ2UsXG59IGZyb20gJy4uL3V0aWxzL3RleHR0cmFjay11dGlscyc7XG5pbXBvcnQgKiBhcyBJRDMgZnJvbSAnLi4vZGVtdXgvaWQzJztcbmltcG9ydCB7XG4gIERhdGVSYW5nZSxcbiAgaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUsXG4gIGlzU0NURTM1QXR0cmlidXRlLFxufSBmcm9tICcuLi9sb2FkZXIvZGF0ZS1yYW5nZSc7XG5pbXBvcnQgeyBNZXRhZGF0YVNjaGVtYSB9IGZyb20gJy4uL3R5cGVzL2RlbXV4ZXInO1xuaW1wb3J0IHR5cGUge1xuICBCdWZmZXJGbHVzaGluZ0RhdGEsXG4gIEZyYWdQYXJzaW5nTWV0YWRhdGFEYXRhLFxuICBMZXZlbFVwZGF0ZWREYXRhLFxuICBNZWRpYUF0dGFjaGVkRGF0YSxcbn0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBXZWJLaXREYXRhQ3VlOiBWVFRDdWUgfCB2b2lkO1xuICB9XG59XG5cbnR5cGUgQ3VlID0gVlRUQ3VlIHwgVGV4dFRyYWNrQ3VlO1xuXG5jb25zdCBNSU5fQ1VFX0RVUkFUSU9OID0gMC4yNTtcblxuZnVuY3Rpb24gZ2V0Q3VlQ2xhc3MoKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgLy8gQXR0ZW1wdCB0byByZWNyZWF0ZSBTYWZhcmkgZnVuY3Rpb25hbGl0eSBieSBjcmVhdGluZ1xuICAvLyBXZWJLaXREYXRhQ3VlIG9iamVjdHMgd2hlbiBhdmFpbGFibGUgYW5kIHN0b3JlIHRoZSBkZWNvZGVkXG4gIC8vIElEMyBkYXRhIGluIHRoZSB2YWx1ZSBwcm9wZXJ0eSBvZiB0aGUgY3VlXG4gIHJldHVybiAoc2VsZi5XZWJLaXREYXRhQ3VlIHx8IHNlbGYuVlRUQ3VlIHx8IHNlbGYuVGV4dFRyYWNrQ3VlKSBhcyBhbnk7XG59XG5cbi8vIFZUVEN1ZSBsYXRlc3QgZHJhZnQgYWxsb3dzIGFuIGluZmluaXRlIGR1cmF0aW9uLCBmYWxsYmFja1xuLy8gdG8gTUFYX1ZBTFVFIGlmIG5lY2Vzc2FyeVxuY29uc3QgTUFYX0NVRV9FTkRUSU1FID0gKCgpID0+IHtcbiAgY29uc3QgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcbiAgdHJ5IHtcbiAgICBuZXcgQ3VlKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhkYXRlOiBEYXRlLCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBkYXRlLmdldFRpbWUoKSAvIDEwMDAgLSBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGhleFRvQXJyYXlCdWZmZXIoc3RyKTogQXJyYXlCdWZmZXIge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKFxuICAgIHN0clxuICAgICAgLnJlcGxhY2UoL14weC8sICcnKVxuICAgICAgLnJlcGxhY2UoLyhbXFxkYS1mQS1GXXsyfSkgPy9nLCAnMHgkMSAnKVxuICAgICAgLnJlcGxhY2UoLyArJC8sICcnKVxuICAgICAgLnNwbGl0KCcgJylcbiAgKS5idWZmZXI7XG59XG5jbGFzcyBJRDNUcmFja0NvbnRyb2xsZXIgaW1wbGVtZW50cyBDb21wb25lbnRBUEkge1xuICBwcml2YXRlIGhsczogSGxzO1xuICBwcml2YXRlIGlkM1RyYWNrOiBUZXh0VHJhY2sgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBtZWRpYTogSFRNTE1lZGlhRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZDogUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICB7IGN1ZXM6IFJlY29yZDxzdHJpbmcsIEN1ZT47IGRhdGVSYW5nZTogRGF0ZVJhbmdlOyBkdXJhdGlvbktub3duOiBib29sZWFuIH1cbiAgPiA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IG51bGw7XG4gIH1cblxuICBwcml2YXRlIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gIH1cblxuICBwcml2YXRlIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuXG4gIC8vIEFkZCBJRDMgbWV0YXRhZGF0YSB0ZXh0IHRyYWNrLlxuICBwcm90ZWN0ZWQgb25NZWRpYUF0dGFjaGVkKFxuICAgIGV2ZW50OiBFdmVudHMuTUVESUFfQVRUQUNIRUQsXG4gICAgZGF0YTogTWVkaWFBdHRhY2hlZERhdGFcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NZWRpYURldGFjaGluZygpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLmlkM1RyYWNrKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICB9XG5cbiAgY3JlYXRlVHJhY2sobWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQpOiBUZXh0VHJhY2sge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5nZXRJRDNUcmFjayhtZWRpYS50ZXh0VHJhY2tzKSBhcyBUZXh0VHJhY2s7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgIHJldHVybiB0cmFjaztcbiAgfVxuXG4gIGdldElEM1RyYWNrKHRleHRUcmFja3M6IFRleHRUcmFja0xpc3QpOiBUZXh0VHJhY2sgfCB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0VHJhY2s6IFRleHRUcmFjayA9IHRleHRUcmFja3NbaV07XG4gICAgICBpZiAodGV4dFRyYWNrLmtpbmQgPT09ICdtZXRhZGF0YScgJiYgdGV4dFRyYWNrLmxhYmVsID09PSAnaWQzJykge1xuICAgICAgICAvLyBzZW5kICdhZGR0cmFjaycgd2hlbiByZXVzaW5nIHRoZSB0ZXh0VHJhY2sgZm9yIG1ldGFkYXRhLFxuICAgICAgICAvLyBzYW1lIGFzIHdoYXQgd2UgZG8gZm9yIGNhcHRpb25zXG4gICAgICAgIHNlbmRBZGRUcmFja0V2ZW50KHRleHRUcmFjaywgdGhpcy5tZWRpYSk7XG5cbiAgICAgICAgcmV0dXJuIHRleHRUcmFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVkaWEuYWRkVGV4dFRyYWNrKCdtZXRhZGF0YScsICdpZDMnKTtcbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdNZXRhZGF0YShcbiAgICBldmVudDogRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSxcbiAgICBkYXRhOiBGcmFnUGFyc2luZ01ldGFkYXRhRGF0YVxuICApIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBobHM6IHtcbiAgICAgICAgY29uZmlnOiB7IGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMsIGVuYWJsZUlEM01ldGFkYXRhQ3VlcyB9LFxuICAgICAgfSxcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgJiYgIWVuYWJsZUlEM01ldGFkYXRhQ3Vlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgc2FtcGxlcyB9ID0gZGF0YTtcblxuICAgIC8vIGNyZWF0ZSB0cmFjayBkeW5hbWljYWxseVxuICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgdGhpcy5pZDNUcmFjayA9IHRoaXMuY3JlYXRlVHJhY2sodGhpcy5tZWRpYSk7XG4gICAgfVxuXG4gICAgY29uc3QgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdHlwZSA9IHNhbXBsZXNbaV0udHlwZTtcbiAgICAgIGlmIChcbiAgICAgICAgKHR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmVtc2cgJiYgIWVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMpIHx8XG4gICAgICAgICFlbmFibGVJRDNNZXRhZGF0YUN1ZXNcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZnJhbWVzID0gSUQzLmdldElEM0ZyYW1lcyhzYW1wbGVzW2ldLmRhdGEpO1xuICAgICAgaWYgKGZyYW1lcykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBzYW1wbGVzW2ldLnB0cztcbiAgICAgICAgbGV0IGVuZFRpbWU6IG51bWJlciA9IHN0YXJ0VGltZSArIHNhbXBsZXNbaV0uZHVyYXRpb247XG5cbiAgICAgICAgaWYgKGVuZFRpbWUgPiBNQVhfQ1VFX0VORFRJTUUpIHtcbiAgICAgICAgICBlbmRUaW1lID0gTUFYX0NVRV9FTkRUSU1FO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZURpZmYgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICBpZiAodGltZURpZmYgPD0gMCkge1xuICAgICAgICAgIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBNSU5fQ1VFX0RVUkFUSU9OO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmcmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tqXTtcbiAgICAgICAgICAvLyBTYWZhcmkgZG9lc24ndCBwdXQgdGhlIHRpbWVzdGFtcCBmcmFtZSBpbiB0aGUgVGV4dFRyYWNrXG4gICAgICAgICAgaWYgKCFJRDMuaXNUaW1lU3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhIGJvdW5kcyB0byBhbnkgdW5ib3VuZGVkIGN1ZXNcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSWQzQ3VlRW5kcyhzdGFydFRpbWUpO1xuXG4gICAgICAgICAgICBjb25zdCBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgJycpO1xuICAgICAgICAgICAgY3VlLnZhbHVlID0gZnJhbWU7XG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICBjdWUudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUlkM0N1ZUVuZHMoc3RhcnRUaW1lOiBudW1iZXIpIHtcbiAgICBjb25zdCBjdWVzID0gdGhpcy5pZDNUcmFjaz8uY3VlcztcbiAgICBpZiAoY3Vlcykge1xuICAgICAgZm9yIChsZXQgaSA9IGN1ZXMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICBjb25zdCBjdWUgPSBjdWVzW2ldIGFzIGFueTtcbiAgICAgICAgaWYgKGN1ZS5zdGFydFRpbWUgPCBzdGFydFRpbWUgJiYgY3VlLmVuZFRpbWUgPT09IE1BWF9DVUVfRU5EVElNRSkge1xuICAgICAgICAgIGN1ZS5lbmRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJGbHVzaGluZyhcbiAgICBldmVudDogRXZlbnRzLkJVRkZFUl9GTFVTSElORyxcbiAgICB7IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHR5cGUgfTogQnVmZmVyRmx1c2hpbmdEYXRhXG4gICkge1xuICAgIGNvbnN0IHsgaWQzVHJhY2ssIGhscyB9ID0gdGhpcztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZzogeyBlbmFibGVFbXNnTWV0YWRhdGFDdWVzLCBlbmFibGVJRDNNZXRhZGF0YUN1ZXMgfSxcbiAgICB9ID0gaGxzO1xuICAgIGlmIChpZDNUcmFjayAmJiAoZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyB8fCBlbmFibGVJRDNNZXRhZGF0YUN1ZXMpKSB7XG4gICAgICBsZXQgcHJlZGljYXRlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBwcmVkaWNhdGUgPSAoY3VlKSA9PlxuICAgICAgICAgIChjdWUgYXMgYW55KS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyAmJlxuICAgICAgICAgIGVuYWJsZUlEM01ldGFkYXRhQ3VlcztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICBwcmVkaWNhdGUgPSAoY3VlKSA9PlxuICAgICAgICAgIChjdWUgYXMgYW55KS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5lbXNnICYmIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVkaWNhdGUgPSAoY3VlKSA9PlxuICAgICAgICAgICgoY3VlIGFzIGFueSkudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMgJiZcbiAgICAgICAgICAgIGVuYWJsZUlEM01ldGFkYXRhQ3VlcykgfHxcbiAgICAgICAgICAoKGN1ZSBhcyBhbnkpLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmVtc2cgJiYgZW5hYmxlRW1zZ01ldGFkYXRhQ3Vlcyk7XG4gICAgICB9XG4gICAgICByZW1vdmVDdWVzSW5SYW5nZShpZDNUcmFjaywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgcHJlZGljYXRlKTtcbiAgICB9XG4gIH1cblxuICBvbkxldmVsVXBkYXRlZChldmVudDogRXZlbnRzLkxFVkVMX1VQREFURUQsIHsgZGV0YWlscyB9OiBMZXZlbFVwZGF0ZWREYXRhKSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMubWVkaWEgfHxcbiAgICAgICFkZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSB8fFxuICAgICAgIXRoaXMuaGxzLmNvbmZpZy5lbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXNcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRlUmFuZ2VDdWVzQXBwZW5kZWQsIGlkM1RyYWNrIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZGF0ZVJhbmdlcyB9ID0gZGV0YWlscztcbiAgICBjb25zdCBpZHMgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2VzKTtcbiAgICAvLyBSZW1vdmUgY3VlcyBmcm9tIHRyYWNrIG5vdCBmb3VuZCBpbiBkZXRhaWxzLmRhdGVSYW5nZXNcbiAgICBpZiAoaWQzVHJhY2spIHtcbiAgICAgIGNvbnN0IGlkc1RvUmVtb3ZlID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkKS5maWx0ZXIoXG4gICAgICAgIChpZCkgPT4gIWlkcy5pbmNsdWRlcyhpZClcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBpID0gaWRzVG9SZW1vdmUubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICBjb25zdCBpZCA9IGlkc1RvUmVtb3ZlW2ldO1xuICAgICAgICBPYmplY3Qua2V5cyhkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdLmN1ZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgIGlkM1RyYWNrLnJlbW92ZUN1ZShkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdLmN1ZXNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXhpdCBpZiB0aGUgcGxheWxpc3QgZG9lcyBub3QgaGF2ZSBEYXRlIFJhbmdlcyBvciBkb2VzIG5vdCBoYXZlIFByb2dyYW0gRGF0ZSBUaW1lXG4gICAgY29uc3QgbGFzdEZyYWdtZW50ID0gZGV0YWlscy5mcmFnbWVudHNbZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlkcy5sZW5ndGggPT09IDAgfHwgIU51bWJlci5pc0Zpbml0ZShsYXN0RnJhZ21lbnQ/LnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmNyZWF0ZVRyYWNrKHRoaXMubWVkaWEpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGVUaW1lT2Zmc2V0ID1cbiAgICAgIChsYXN0RnJhZ21lbnQucHJvZ3JhbURhdGVUaW1lIGFzIG51bWJlcikgLyAxMDAwIC0gbGFzdEZyYWdtZW50LnN0YXJ0O1xuICAgIGNvbnN0IEN1ZSA9IGdldEN1ZUNsYXNzKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaWQgPSBpZHNbaV07XG4gICAgICBjb25zdCBkYXRlUmFuZ2UgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgIGNvbnN0IGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9IGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF07XG4gICAgICBjb25zdCBjdWVzID0gYXBwZW5kZWREYXRlUmFuZ2VDdWVzPy5jdWVzIHx8IHt9O1xuICAgICAgbGV0IGR1cmF0aW9uS25vd24gPSBhcHBlbmRlZERhdGVSYW5nZUN1ZXM/LmR1cmF0aW9uS25vd24gfHwgZmFsc2U7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMoXG4gICAgICAgIGRhdGVSYW5nZS5zdGFydERhdGUsXG4gICAgICAgIGRhdGVUaW1lT2Zmc2V0XG4gICAgICApO1xuICAgICAgbGV0IGVuZFRpbWUgPSBNQVhfQ1VFX0VORFRJTUU7XG4gICAgICBjb25zdCBlbmREYXRlID0gZGF0ZVJhbmdlLmVuZERhdGU7XG4gICAgICBpZiAoZW5kRGF0ZSkge1xuICAgICAgICBlbmRUaW1lID0gZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzKGVuZERhdGUsIGRhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgZHVyYXRpb25Lbm93biA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRhdGVSYW5nZS5lbmRPbk5leHQgJiYgIWR1cmF0aW9uS25vd24pIHtcbiAgICAgICAgY29uc3QgbmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3MgPSBpZHNcbiAgICAgICAgICAucmVkdWNlKChmaWx0ZXJNYXBBcnJheSwgaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGRhdGVSYW5nZXNbaWRdO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBjYW5kaWRhdGUuY2xhc3MgPT09IGRhdGVSYW5nZS5jbGFzcyAmJlxuICAgICAgICAgICAgICBjYW5kaWRhdGUuaWQgIT09IGlkICYmXG4gICAgICAgICAgICAgIGNhbmRpZGF0ZS5zdGFydERhdGUgPiBkYXRlUmFuZ2Uuc3RhcnREYXRlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgZmlsdGVyTWFwQXJyYXkucHVzaChjYW5kaWRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlck1hcEFycmF5O1xuICAgICAgICAgIH0sIFtdIGFzIERhdGVSYW5nZVtdKVxuICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0RGF0ZS5nZXRUaW1lKCkgLSBiLnN0YXJ0RGF0ZS5nZXRUaW1lKCkpWzBdO1xuICAgICAgICBpZiAobmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3MpIHtcbiAgICAgICAgICBlbmRUaW1lID0gZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzKFxuICAgICAgICAgICAgbmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3Muc3RhcnREYXRlLFxuICAgICAgICAgICAgZGF0ZVRpbWVPZmZzZXRcbiAgICAgICAgICApO1xuICAgICAgICAgIGR1cmF0aW9uS25vd24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2UuYXR0cik7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXR0cmlidXRlc1tqXTtcbiAgICAgICAgaWYgKCFpc0RhdGVSYW5nZUN1ZUF0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1ZSA9IGN1ZXNba2V5XSBhcyBhbnk7XG4gICAgICAgIGlmIChjdWUpIHtcbiAgICAgICAgICBpZiAoZHVyYXRpb25Lbm93biAmJiAhYXBwZW5kZWREYXRlUmFuZ2VDdWVzLmR1cmF0aW9uS25vd24pIHtcbiAgICAgICAgICAgIGN1ZS5lbmRUaW1lID0gZW5kVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGRhdGEgPSBkYXRlUmFuZ2UuYXR0cltrZXldO1xuICAgICAgICAgIGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCAnJyk7XG4gICAgICAgICAgaWYgKGlzU0NURTM1QXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBoZXhUb0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdWUudmFsdWUgPSB7IGtleSwgZGF0YSB9O1xuICAgICAgICAgIGN1ZS50eXBlID0gTWV0YWRhdGFTY2hlbWEuZGF0ZVJhbmdlO1xuICAgICAgICAgIGN1ZS5pZCA9IGlkO1xuICAgICAgICAgIHRoaXMuaWQzVHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgICAgY3Vlc1trZXldID0gY3VlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdID0ge1xuICAgICAgICBjdWVzLFxuICAgICAgICBkYXRlUmFuZ2UsXG4gICAgICAgIGR1cmF0aW9uS25vd24sXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJRDNUcmFja0NvbnRyb2xsZXI7XG4iLCJpbXBvcnQgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwtZGV0YWlscyc7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHtcbiAgRXJyb3JEYXRhLFxuICBMZXZlbFVwZGF0ZWREYXRhLFxuICBNZWRpYUF0dGFjaGluZ0RhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRBUEkgfSBmcm9tICcuLi90eXBlcy9jb21wb25lbnQtYXBpJztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXRlbmN5Q29udHJvbGxlciBpbXBsZW1lbnRzIENvbXBvbmVudEFQSSB7XG4gIHByaXZhdGUgaGxzOiBIbHM7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBIbHNDb25maWc7XG4gIHByaXZhdGUgbWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBsZXZlbERldGFpbHM6IExldmVsRGV0YWlscyB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGN1cnJlbnRUaW1lOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIHN0YWxsQ291bnQ6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgX2xhdGVuY3k6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHRpbWV1cGRhdGVIYW5kbGVyID0gKCkgPT4gdGhpcy50aW1ldXBkYXRlKCk7XG5cbiAgY29uc3RydWN0b3IoaGxzOiBIbHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgZ2V0IGxhdGVuY3koKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fbGF0ZW5jeSB8fCAwO1xuICB9XG5cbiAgZ2V0IG1heExhdGVuY3koKTogbnVtYmVyIHtcbiAgICBjb25zdCB7IGNvbmZpZywgbGV2ZWxEZXRhaWxzIH0gPSB0aGlzO1xuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb247XG4gICAgfVxuICAgIHJldHVybiBsZXZlbERldGFpbHNcbiAgICAgID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvblxuICAgICAgOiAwO1xuICB9XG5cbiAgZ2V0IHRhcmdldExhdGVuY3koKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgY29uc3QgeyBsZXZlbERldGFpbHMgfSA9IHRoaXM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgaG9sZEJhY2ssIHBhcnRIb2xkQmFjaywgdGFyZ2V0ZHVyYXRpb24gfSA9IGxldmVsRGV0YWlscztcbiAgICBjb25zdCB7IGxpdmVTeW5jRHVyYXRpb24sIGxpdmVTeW5jRHVyYXRpb25Db3VudCwgbG93TGF0ZW5jeU1vZGUgfSA9XG4gICAgICB0aGlzLmNvbmZpZztcbiAgICBjb25zdCB1c2VyQ29uZmlnID0gdGhpcy5obHMudXNlckNvbmZpZztcbiAgICBsZXQgdGFyZ2V0TGF0ZW5jeSA9IGxvd0xhdGVuY3lNb2RlID8gcGFydEhvbGRCYWNrIHx8IGhvbGRCYWNrIDogaG9sZEJhY2s7XG4gICAgaWYgKFxuICAgICAgdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8XG4gICAgICB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fFxuICAgICAgdGFyZ2V0TGF0ZW5jeSA9PT0gMFxuICAgICkge1xuICAgICAgdGFyZ2V0TGF0ZW5jeSA9XG4gICAgICAgIGxpdmVTeW5jRHVyYXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gbGl2ZVN5bmNEdXJhdGlvblxuICAgICAgICAgIDogbGl2ZVN5bmNEdXJhdGlvbkNvdW50ICogdGFyZ2V0ZHVyYXRpb247XG4gICAgfVxuICAgIGNvbnN0IG1heExpdmVTeW5jT25TdGFsbEluY3JlYXNlID0gdGFyZ2V0ZHVyYXRpb247XG4gICAgY29uc3QgbGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UgPSAxLjA7XG4gICAgcmV0dXJuIChcbiAgICAgIHRhcmdldExhdGVuY3kgK1xuICAgICAgTWF0aC5taW4oXG4gICAgICAgIHRoaXMuc3RhbGxDb3VudCAqIGxpdmVTeW5jT25TdGFsbEluY3JlYXNlLFxuICAgICAgICBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpOiBudW1iZXIgfCBudWxsIHtcbiAgICBjb25zdCBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgIGNvbnN0IHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgaWYgKGxpdmVFZGdlID09PSBudWxsIHx8IHRhcmdldExhdGVuY3kgPT09IG51bGwgfHwgbGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZWRnZSA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgIGNvbnN0IHN5bmNQb3NpdGlvbiA9IGxpdmVFZGdlIC0gdGFyZ2V0TGF0ZW5jeSAtIHRoaXMuZWRnZVN0YWxsZWQ7XG4gICAgY29uc3QgbWluID0gZWRnZSAtIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgIGNvbnN0IG1heCA9XG4gICAgICBlZGdlIC1cbiAgICAgICgodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQpIHx8XG4gICAgICAgIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgc3luY1Bvc2l0aW9uKSwgbWF4KTtcbiAgfVxuXG4gIGdldCBkcmlmdCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgbGV2ZWxEZXRhaWxzIH0gPSB0aGlzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxEZXRhaWxzLmRyaWZ0O1xuICB9XG5cbiAgZ2V0IGVkZ2VTdGFsbGVkKCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBsZXZlbERldGFpbHMgfSA9IHRoaXM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IG1heExldmVsVXBkYXRlQWdlID1cbiAgICAgICgodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQpIHx8XG4gICAgICAgIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikgKiAzO1xuICAgIHJldHVybiBNYXRoLm1heChsZXZlbERldGFpbHMuYWdlIC0gbWF4TGV2ZWxVcGRhdGVBZ2UsIDApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgZm9yd2FyZEJ1ZmZlckxlbmd0aCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgbWVkaWEsIGxldmVsRGV0YWlscyB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhIHx8ICFsZXZlbERldGFpbHMpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJlZFJhbmdlcyA9IG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aDtcbiAgICByZXR1cm4gKFxuICAgICAgKGJ1ZmZlcmVkUmFuZ2VzXG4gICAgICAgID8gbWVkaWEuYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkUmFuZ2VzIC0gMSlcbiAgICAgICAgOiBsZXZlbERldGFpbHMuZWRnZSkgLSB0aGlzLmN1cnJlbnRUaW1lXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMub25NZWRpYURldGFjaGluZygpO1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyID0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cblxuICBwcml2YXRlIG9uTWVkaWFBdHRhY2hlZChcbiAgICBldmVudDogRXZlbnRzLk1FRElBX0FUVEFDSEVELFxuICAgIGRhdGE6IE1lZGlhQXR0YWNoaW5nRGF0YVxuICApIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgfVxuXG4gIHByaXZhdGUgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy50aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLl9sYXRlbmN5ID0gbnVsbDtcbiAgICB0aGlzLnN0YWxsQ291bnQgPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkxldmVsVXBkYXRlZChcbiAgICBldmVudDogRXZlbnRzLkxFVkVMX1VQREFURUQsXG4gICAgeyBkZXRhaWxzIH06IExldmVsVXBkYXRlZERhdGFcbiAgKSB7XG4gICAgdGhpcy5sZXZlbERldGFpbHMgPSBkZXRhaWxzO1xuICAgIGlmIChkZXRhaWxzLmFkdmFuY2VkKSB7XG4gICAgICB0aGlzLnRpbWV1cGRhdGUoKTtcbiAgICB9XG4gICAgaWYgKCFkZXRhaWxzLmxpdmUgJiYgdGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy50aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkVycm9yKGV2ZW50OiBFdmVudHMuRVJST1IsIGRhdGE6IEVycm9yRGF0YSkge1xuICAgIGlmIChkYXRhLmRldGFpbHMgIT09IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YWxsQ291bnQrKztcbiAgICBpZiAodGhpcy5sZXZlbERldGFpbHM/LmxpdmUpIHtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAnW3BsYXliYWNrLXJhdGUtY29udHJvbGxlcl06IFN0YWxsIGRldGVjdGVkLCBhZGp1c3RpbmcgdGFyZ2V0IGxhdGVuY3knXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdGltZXVwZGF0ZSgpIHtcbiAgICBjb25zdCB7IG1lZGlhLCBsZXZlbERldGFpbHMgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSB8fCAhbGV2ZWxEZXRhaWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcblxuICAgIGNvbnN0IGxhdGVuY3kgPSB0aGlzLmNvbXB1dGVMYXRlbmN5KCk7XG4gICAgaWYgKGxhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbGF0ZW5jeSA9IGxhdGVuY3k7XG5cbiAgICAvLyBBZGFwdCBwbGF5YmFja1JhdGUgdG8gbWVldCB0YXJnZXQgbGF0ZW5jeSBpbiBsb3ctbGF0ZW5jeSBtb2RlXG4gICAgY29uc3QgeyBsb3dMYXRlbmN5TW9kZSwgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGUgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghbG93TGF0ZW5jeU1vZGUgfHwgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGUgPT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0TGF0ZW5jeSA9IHRoaXMudGFyZ2V0TGF0ZW5jeTtcbiAgICBpZiAodGFyZ2V0TGF0ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXN0YW5jZUZyb21UYXJnZXQgPSBsYXRlbmN5IC0gdGFyZ2V0TGF0ZW5jeTtcbiAgICAvLyBPbmx5IGFkanVzdCBwbGF5YmFja1JhdGUgd2hlbiB3aXRoaW4gb25lIHRhcmdldCBkdXJhdGlvbiBvZiB0YXJnZXRMYXRlbmN5XG4gICAgLy8gYW5kIG1vcmUgdGhhbiBvbmUgc2Vjb25kIGZyb20gdW5kZXItYnVmZmVyaW5nLlxuICAgIC8vIFBsYXliYWNrIGZ1cnRoZXIgdGhhbiBvbmUgdGFyZ2V0IGR1cmF0aW9uIGZyb20gdGFyZ2V0IGNhbiBiZSBjb25zaWRlcmVkIERWUiBwbGF5YmFjay5cbiAgICBjb25zdCBsaXZlTWluTGF0ZW5jeUR1cmF0aW9uID0gTWF0aC5taW4oXG4gICAgICB0aGlzLm1heExhdGVuY3ksXG4gICAgICB0YXJnZXRMYXRlbmN5ICsgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uXG4gICAgKTtcbiAgICBjb25zdCBpbkxpdmVSYW5nZSA9IGRpc3RhbmNlRnJvbVRhcmdldCA8IGxpdmVNaW5MYXRlbmN5RHVyYXRpb247XG4gICAgaWYgKFxuICAgICAgbGV2ZWxEZXRhaWxzLmxpdmUgJiZcbiAgICAgIGluTGl2ZVJhbmdlICYmXG4gICAgICBkaXN0YW5jZUZyb21UYXJnZXQgPiAwLjA1ICYmXG4gICAgICB0aGlzLmZvcndhcmRCdWZmZXJMZW5ndGggPiAxXG4gICAgKSB7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1pbigyLCBNYXRoLm1heCgxLjAsIG1heExpdmVTeW5jUGxheWJhY2tSYXRlKSk7XG4gICAgICBjb25zdCByYXRlID1cbiAgICAgICAgTWF0aC5yb3VuZChcbiAgICAgICAgICAoMiAvICgxICsgTWF0aC5leHAoLTAuNzUgKiBkaXN0YW5jZUZyb21UYXJnZXQgLSB0aGlzLmVkZ2VTdGFsbGVkKSkpICpcbiAgICAgICAgICAgIDIwXG4gICAgICAgICkgLyAyMDtcbiAgICAgIG1lZGlhLnBsYXliYWNrUmF0ZSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMSwgcmF0ZSkpO1xuICAgIH0gZWxzZSBpZiAobWVkaWEucGxheWJhY2tSYXRlICE9PSAxICYmIG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMCkge1xuICAgICAgbWVkaWEucGxheWJhY2tSYXRlID0gMTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVzdGltYXRlTGl2ZUVkZ2UoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgY29uc3QgeyBsZXZlbERldGFpbHMgfSA9IHRoaXM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbERldGFpbHMuZWRnZSArIGxldmVsRGV0YWlscy5hZ2U7XG4gIH1cblxuICBwcml2YXRlIGNvbXB1dGVMYXRlbmN5KCk6IG51bWJlciB8IG51bGwge1xuICAgIGNvbnN0IGxpdmVFZGdlID0gdGhpcy5lc3RpbWF0ZUxpdmVFZGdlKCk7XG4gICAgaWYgKGxpdmVFZGdlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVFZGdlIC0gdGhpcy5jdXJyZW50VGltZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWRldGFpbHMnO1xuaW1wb3J0IHsgQXR0ckxpc3QgfSBmcm9tICcuLi91dGlscy9hdHRyLWxpc3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExldmVsUGFyc2VkIHtcbiAgYXR0cnM6IExldmVsQXR0cmlidXRlcztcbiAgYXVkaW9Db2RlYz86IHN0cmluZztcbiAgYml0cmF0ZTogbnVtYmVyO1xuICBkZXRhaWxzPzogTGV2ZWxEZXRhaWxzO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIGlkPzogbnVtYmVyO1xuICBsZXZlbD86IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICB0ZXh0Q29kZWM/OiBzdHJpbmc7XG4gIHVua25vd25Db2RlY3M/OiBzdHJpbmdbXTtcbiAgdXJsOiBzdHJpbmc7XG4gIHZpZGVvQ29kZWM/OiBzdHJpbmc7XG4gIHdpZHRoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExldmVsQXR0cmlidXRlcyBleHRlbmRzIEF0dHJMaXN0IHtcbiAgJ0FMTE9XRUQtQ1BDJz86IHN0cmluZztcbiAgQVVESU8/OiBzdHJpbmc7XG4gICdBVkVSQUdFLUJBTkRXSURUSCc/OiBzdHJpbmc7XG4gIEJBTkRXSURUSD86IHN0cmluZztcbiAgJ0NMT1NFRC1DQVBUSU9OUyc/OiBzdHJpbmc7XG4gIENPREVDUz86IHN0cmluZztcbiAgJ0ZSQU1FLVJBVEUnPzogc3RyaW5nO1xuICAnSERDUC1MRVZFTCc/OiAnVFlQRS0wJyB8ICdUWVBFLTEnIHwgJ05PTkUnO1xuICAnUEFUSFdBWS1JRCc/OiBzdHJpbmc7XG4gIFJFU09MVVRJT04/OiBzdHJpbmc7XG4gIFNDT1JFPzogc3RyaW5nO1xuICAnU1RBQkxFLVZBUklBTlQtSUQnPzogc3RyaW5nO1xuICBTVUJUSVRMRVM/OiBzdHJpbmc7XG4gICdTVVBQTEVNRU5UQUwtQ09ERUNTJz86IHN0cmluZztcbiAgVklERU8/OiBzdHJpbmc7XG4gICdWSURFTy1SQU5HRSc/OiAnU0RSJyB8ICdITEcnIHwgJ1BRJztcbn1cblxuZXhwb3J0IGNvbnN0IEhkY3BMZXZlbHMgPSBbJ05PTkUnLCAnVFlQRS0wJywgJ1RZUEUtMScsIG51bGxdIGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgSGRjcExldmVsID0gKHR5cGVvZiBIZGNwTGV2ZWxzKVtudW1iZXJdO1xuXG5leHBvcnQgdHlwZSBWYXJpYWJsZU1hcCA9IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cbmV4cG9ydCBjb25zdCBlbnVtIEhsc1NraXAge1xuICBObyA9ICcnLFxuICBZZXMgPSAnWUVTJyxcbiAgdjIgPSAndjInLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2tpcFZhbHVlKGRldGFpbHM6IExldmVsRGV0YWlscywgbXNuPzogbnVtYmVyKTogSGxzU2tpcCB7XG4gIGNvbnN0IHsgY2FuU2tpcFVudGlsLCBjYW5Ta2lwRGF0ZVJhbmdlcywgZW5kU04gfSA9IGRldGFpbHM7XG4gIGNvbnN0IHNuQ2hhbmdlR29hbCA9IG1zbiAhPT0gdW5kZWZpbmVkID8gbXNuIC0gZW5kU04gOiAwO1xuICBpZiAoY2FuU2tpcFVudGlsICYmIHNuQ2hhbmdlR29hbCA8IGNhblNraXBVbnRpbCkge1xuICAgIGlmIChjYW5Ta2lwRGF0ZVJhbmdlcykge1xuICAgICAgcmV0dXJuIEhsc1NraXAudjI7XG4gICAgfVxuICAgIHJldHVybiBIbHNTa2lwLlllcztcbiAgfVxuICByZXR1cm4gSGxzU2tpcC5Obztcbn1cblxuZXhwb3J0IGNsYXNzIEhsc1VybFBhcmFtZXRlcnMge1xuICBtc24/OiBudW1iZXI7XG4gIHBhcnQ/OiBudW1iZXI7XG4gIHNraXA/OiBIbHNTa2lwO1xuXG4gIGNvbnN0cnVjdG9yKG1zbj86IG51bWJlciwgcGFydD86IG51bWJlciwgc2tpcD86IEhsc1NraXApIHtcbiAgICB0aGlzLm1zbiA9IG1zbjtcbiAgICB0aGlzLnBhcnQgPSBwYXJ0O1xuICAgIHRoaXMuc2tpcCA9IHNraXA7XG4gIH1cblxuICBhZGREaXJlY3RpdmVzKHVyaTogc3RyaW5nKTogc3RyaW5nIHwgbmV2ZXIge1xuICAgIGNvbnN0IHVybDogVVJMID0gbmV3IHNlbGYuVVJMKHVyaSk7XG4gICAgaWYgKHRoaXMubXNuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX21zbicsIHRoaXMubXNuLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3BhcnQnLCB0aGlzLnBhcnQudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNraXApIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3NraXAnLCB0aGlzLnNraXApO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLmhyZWY7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIExldmVsIHtcbiAgcHVibGljIHJlYWRvbmx5IF9hdHRyczogTGV2ZWxBdHRyaWJ1dGVzW107XG4gIHB1YmxpYyByZWFkb25seSBhdWRpb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHB1YmxpYyByZWFkb25seSBiaXRyYXRlOiBudW1iZXI7XG4gIHB1YmxpYyByZWFkb25seSBjb2RlY1NldDogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgaGVpZ2h0OiBudW1iZXI7XG4gIHB1YmxpYyByZWFkb25seSBpZDogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBwdWJsaWMgcmVhZG9ubHkgdmlkZW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBwdWJsaWMgcmVhZG9ubHkgd2lkdGg6IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IHVua25vd25Db2RlY3M6IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xuICBwdWJsaWMgYXVkaW9Hcm91cElkcz86IChzdHJpbmcgfCB1bmRlZmluZWQpW107XG4gIHB1YmxpYyBkZXRhaWxzPzogTGV2ZWxEZXRhaWxzO1xuICBwdWJsaWMgZnJhZ21lbnRFcnJvcjogbnVtYmVyID0gMDtcbiAgcHVibGljIGxvYWRFcnJvcjogbnVtYmVyID0gMDtcbiAgcHVibGljIGxvYWRlZD86IHsgYnl0ZXM6IG51bWJlcjsgZHVyYXRpb246IG51bWJlciB9O1xuICBwdWJsaWMgcmVhbEJpdHJhdGU6IG51bWJlciA9IDA7XG4gIHB1YmxpYyB0ZXh0R3JvdXBJZHM/OiAoc3RyaW5nIHwgdW5kZWZpbmVkKVtdO1xuICBwdWJsaWMgdXJsOiBzdHJpbmdbXTtcbiAgcHJpdmF0ZSBfdXJsSWQ6IG51bWJlciA9IDA7XG5cbiAgY29uc3RydWN0b3IoZGF0YTogTGV2ZWxQYXJzZWQpIHtcbiAgICB0aGlzLnVybCA9IFtkYXRhLnVybF07XG4gICAgdGhpcy5fYXR0cnMgPSBbZGF0YS5hdHRyc107XG4gICAgdGhpcy5iaXRyYXRlID0gZGF0YS5iaXRyYXRlO1xuICAgIGlmIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIHRoaXMuZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB9XG4gICAgdGhpcy5pZCA9IGRhdGEuaWQgfHwgMDtcbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGggfHwgMDtcbiAgICB0aGlzLmhlaWdodCA9IGRhdGEuaGVpZ2h0IHx8IDA7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gZGF0YS5hdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IGRhdGEudmlkZW9Db2RlYztcbiAgICB0aGlzLnVua25vd25Db2RlY3MgPSBkYXRhLnVua25vd25Db2RlY3M7XG4gICAgdGhpcy5jb2RlY1NldCA9IFtkYXRhLnZpZGVvQ29kZWMsIGRhdGEuYXVkaW9Db2RlY11cbiAgICAgIC5maWx0ZXIoKGMpID0+IGMpXG4gICAgICAuam9pbignLCcpXG4gICAgICAucmVwbGFjZSgvXFwuW14uLF0rL2csICcnKTtcbiAgfVxuXG4gIGdldCBtYXhCaXRyYXRlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucmVhbEJpdHJhdGUsIHRoaXMuYml0cmF0ZSk7XG4gIH1cblxuICBnZXQgYXR0cnMoKTogTGV2ZWxBdHRyaWJ1dGVzIHtcbiAgICByZXR1cm4gdGhpcy5fYXR0cnNbdGhpcy5fdXJsSWRdO1xuICB9XG5cbiAgZ2V0IHBhdGh3YXlJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmF0dHJzWydQQVRIV0FZLUlEJ10gfHwgJy4nO1xuICB9XG5cbiAgZ2V0IHVyaSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnVybFt0aGlzLl91cmxJZF0gfHwgJyc7XG4gIH1cblxuICBnZXQgdXJsSWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsSWQ7XG4gIH1cblxuICBzZXQgdXJsSWQodmFsdWU6IG51bWJlcikge1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgJSB0aGlzLnVybC5sZW5ndGg7XG4gICAgaWYgKHRoaXMuX3VybElkICE9PSBuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgIHRoaXMubG9hZEVycm9yID0gMDtcbiAgICAgIHRoaXMuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3VybElkID0gbmV3VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGF1ZGlvR3JvdXBJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmF1ZGlvR3JvdXBJZHM/Llt0aGlzLnVybElkXTtcbiAgfVxuXG4gIGdldCB0ZXh0R3JvdXBJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnRleHRHcm91cElkcz8uW3RoaXMudXJsSWRdO1xuICB9XG5cbiAgYWRkRmFsbGJhY2soZGF0YTogTGV2ZWxQYXJzZWQpIHtcbiAgICB0aGlzLnVybC5wdXNoKGRhdGEudXJsKTtcbiAgICB0aGlzLl9hdHRycy5wdXNoKGRhdGEuYXR0cnMpO1xuICB9XG59XG4iLCIvKipcbiAqIFByb3ZpZGVzIG1ldGhvZHMgZGVhbGluZyB3aXRoIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGRyaWZ0XG4gKi9cblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEZyYWdtZW50LCBQYXJ0IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB7IExldmVsRGV0YWlscyB9IGZyb20gJy4uL2xvYWRlci9sZXZlbC1kZXRhaWxzJztcbmltcG9ydCB0eXBlIHsgTGV2ZWwgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9sb2FkZXIvZGF0ZS1yYW5nZSc7XG5cbnR5cGUgRnJhZ21lbnRJbnRlcnNlY3Rpb24gPSAob2xkRnJhZzogRnJhZ21lbnQsIG5ld0ZyYWc6IEZyYWdtZW50KSA9PiB2b2lkO1xudHlwZSBQYXJ0SW50ZXJzZWN0aW9uID0gKG9sZFBhcnQ6IFBhcnQsIG5ld1BhcnQ6IFBhcnQpID0+IHZvaWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVQVFMoXG4gIGZyYWdtZW50czogRnJhZ21lbnRbXSxcbiAgZnJvbUlkeDogbnVtYmVyLFxuICB0b0lkeDogbnVtYmVyXG4pOiB2b2lkIHtcbiAgY29uc3QgZnJhZ0Zyb20gPSBmcmFnbWVudHNbZnJvbUlkeF07XG4gIGNvbnN0IGZyYWdUbyA9IGZyYWdtZW50c1t0b0lkeF07XG4gIHVwZGF0ZUZyb21Ub1BUUyhmcmFnRnJvbSwgZnJhZ1RvKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRnJvbVRvUFRTKGZyYWdGcm9tOiBGcmFnbWVudCwgZnJhZ1RvOiBGcmFnbWVudCkge1xuICBjb25zdCBmcmFnVG9QVFMgPSBmcmFnVG8uc3RhcnRQVFMgYXMgbnVtYmVyO1xuICAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICBpZiAoTnVtYmVyLmlzRmluaXRlKGZyYWdUb1BUUykpIHtcbiAgICAvLyB1cGRhdGUgZnJhZ21lbnQgZHVyYXRpb24uXG4gICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXG4gICAgbGV0IGR1cmF0aW9uOiBudW1iZXIgPSAwO1xuICAgIGxldCBmcmFnOiBGcmFnbWVudDtcbiAgICBpZiAoZnJhZ1RvLnNuID4gZnJhZ0Zyb20uc24pIHtcbiAgICAgIGR1cmF0aW9uID0gZnJhZ1RvUFRTIC0gZnJhZ0Zyb20uc3RhcnQ7XG4gICAgICBmcmFnID0gZnJhZ0Zyb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cmF0aW9uID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG9QVFM7XG4gICAgICBmcmFnID0gZnJhZ1RvO1xuICAgIH1cbiAgICBpZiAoZnJhZy5kdXJhdGlvbiAhPT0gZHVyYXRpb24pIHtcbiAgICAgIGZyYWcuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB9XG4gICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICB9IGVsc2UgaWYgKGZyYWdUby5zbiA+IGZyYWdGcm9tLnNuKSB7XG4gICAgY29uc3QgY29udGlndW91cyA9IGZyYWdGcm9tLmNjID09PSBmcmFnVG8uY2M7XG4gICAgLy8gVE9ETzogV2l0aCBwYXJ0LWxvYWRpbmcgZW5kL2R1cmF0aW9ucyB3ZSBuZWVkIHRvIGNvbmZpcm0gdGhlIHdob2xlIGZyYWdtZW50IGlzIGxvYWRlZCBiZWZvcmUgdXNpbmcgKG9yIHNldHRpbmcpIG1pbkVuZFBUU1xuICAgIGlmIChjb250aWd1b3VzICYmIGZyYWdGcm9tLm1pbkVuZFBUUykge1xuICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgKyAoZnJhZ0Zyb20ubWluRW5kUFRTIC0gZnJhZ0Zyb20uc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmcmFnVG8uc3RhcnQgPSBNYXRoLm1heChmcmFnRnJvbS5zdGFydCAtIGZyYWdUby5kdXJhdGlvbiwgMCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUZyYWdQVFNEVFMoXG4gIGRldGFpbHM6IExldmVsRGV0YWlscyB8IHVuZGVmaW5lZCxcbiAgZnJhZzogRnJhZ21lbnQsXG4gIHN0YXJ0UFRTOiBudW1iZXIsXG4gIGVuZFBUUzogbnVtYmVyLFxuICBzdGFydERUUzogbnVtYmVyLFxuICBlbmREVFM6IG51bWJlclxuKTogbnVtYmVyIHtcbiAgY29uc3QgcGFyc2VkTWVkaWFEdXJhdGlvbiA9IGVuZFBUUyAtIHN0YXJ0UFRTO1xuICBpZiAocGFyc2VkTWVkaWFEdXJhdGlvbiA8PSAwKSB7XG4gICAgbG9nZ2VyLndhcm4oJ0ZyYWdtZW50IHNob3VsZCBoYXZlIGEgcG9zaXRpdmUgZHVyYXRpb24nLCBmcmFnKTtcbiAgICBlbmRQVFMgPSBzdGFydFBUUyArIGZyYWcuZHVyYXRpb247XG4gICAgZW5kRFRTID0gc3RhcnREVFMgKyBmcmFnLmR1cmF0aW9uO1xuICB9XG4gIGxldCBtYXhTdGFydFBUUyA9IHN0YXJ0UFRTO1xuICBsZXQgbWluRW5kUFRTID0gZW5kUFRTO1xuICBjb25zdCBmcmFnU3RhcnRQdHMgPSBmcmFnLnN0YXJ0UFRTIGFzIG51bWJlcjtcbiAgY29uc3QgZnJhZ0VuZFB0cyA9IGZyYWcuZW5kUFRTIGFzIG51bWJlcjtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnU3RhcnRQdHMpKSB7XG4gICAgLy8gZGVsdGEgUFRTIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvXG4gICAgY29uc3QgZGVsdGFQVFMgPSBNYXRoLmFicyhmcmFnU3RhcnRQdHMgLSBzdGFydFBUUyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhZy5kZWx0YVBUUyBhcyBudW1iZXIpKSB7XG4gICAgICBmcmFnLmRlbHRhUFRTID0gZGVsdGFQVFM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcuZGVsdGFQVFMgPSBNYXRoLm1heChkZWx0YVBUUywgZnJhZy5kZWx0YVBUUyBhcyBudW1iZXIpO1xuICAgIH1cblxuICAgIG1heFN0YXJ0UFRTID0gTWF0aC5tYXgoc3RhcnRQVFMsIGZyYWdTdGFydFB0cyk7XG4gICAgc3RhcnRQVFMgPSBNYXRoLm1pbihzdGFydFBUUywgZnJhZ1N0YXJ0UHRzKTtcbiAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLCBmcmFnLnN0YXJ0RFRTKTtcblxuICAgIG1pbkVuZFBUUyA9IE1hdGgubWluKGVuZFBUUywgZnJhZ0VuZFB0cyk7XG4gICAgZW5kUFRTID0gTWF0aC5tYXgoZW5kUFRTLCBmcmFnRW5kUHRzKTtcbiAgICBlbmREVFMgPSBNYXRoLm1heChlbmREVFMsIGZyYWcuZW5kRFRTKTtcbiAgfVxuXG4gIGNvbnN0IGRyaWZ0ID0gc3RhcnRQVFMgLSBmcmFnLnN0YXJ0O1xuICBpZiAoZnJhZy5zdGFydCAhPT0gMCkge1xuICAgIGZyYWcuc3RhcnQgPSBzdGFydFBUUztcbiAgfVxuICBmcmFnLmR1cmF0aW9uID0gZW5kUFRTIC0gZnJhZy5zdGFydDtcbiAgZnJhZy5zdGFydFBUUyA9IHN0YXJ0UFRTO1xuICBmcmFnLm1heFN0YXJ0UFRTID0gbWF4U3RhcnRQVFM7XG4gIGZyYWcuc3RhcnREVFMgPSBzdGFydERUUztcbiAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XG4gIGZyYWcubWluRW5kUFRTID0gbWluRW5kUFRTO1xuICBmcmFnLmVuZERUUyA9IGVuZERUUztcblxuICBjb25zdCBzbiA9IGZyYWcuc24gYXMgbnVtYmVyOyAvLyAnaW5pdFNlZ21lbnQnXG4gIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXG4gIGlmICghZGV0YWlscyB8fCBzbiA8IGRldGFpbHMuc3RhcnRTTiB8fCBzbiA+IGRldGFpbHMuZW5kU04pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgaTtcbiAgY29uc3QgZnJhZ0lkeCA9IHNuIC0gZGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgLy8gdXBkYXRlIGZyYWcgcmVmZXJlbmNlIGluIGZyYWdtZW50cyBhcnJheVxuICAvLyByYXRpb25hbGUgaXMgdGhhdCBmcmFnbWVudHMgYXJyYXkgbWlnaHQgbm90IGNvbnRhaW4gdGhpcyBmcmFnIG9iamVjdC5cbiAgLy8gdGhpcyB3aWxsIGhhcHBlbiBpZiBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgYmV0d2VlbiBmcmFnIGxvYWRpbmcgYW5kIGNhbGwgdG8gdXBkYXRlRnJhZ1BUU0RUUygpXG4gIC8vIGlmIHdlIGRvbid0IHVwZGF0ZSBmcmFnLCB3ZSB3b24ndCBiZSBhYmxlIHRvIHByb3BhZ2F0ZSBQVFMgaW5mbyBvbiB0aGUgcGxheWxpc3RcbiAgLy8gcmVzdWx0aW5nIGluIGludmFsaWQgc2xpZGluZyBjb21wdXRhdGlvblxuICBmcmFnbWVudHNbZnJhZ0lkeF0gPSBmcmFnO1xuICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPiAwOyBpLS0pIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ldLCBmcmFnbWVudHNbaSAtIDFdKTtcbiAgfVxuXG4gIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0gdG8gbGFzdCBmcmFnXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPCBmcmFnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tpXSwgZnJhZ21lbnRzW2kgKyAxXSk7XG4gIH1cbiAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0sIGRldGFpbHMuZnJhZ21lbnRIaW50KTtcbiAgfVxuXG4gIGRldGFpbHMuUFRTS25vd24gPSBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbiAgcmV0dXJuIGRyaWZ0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VEZXRhaWxzKFxuICBvbGREZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIG5ld0RldGFpbHM6IExldmVsRGV0YWlsc1xuKTogdm9pZCB7XG4gIC8vIFRyYWNrIHRoZSBsYXN0IGluaXRTZWdtZW50IHByb2Nlc3NlZC4gSW5pdGlhbGl6ZSBpdCB0byB0aGUgbGFzdCBvbmUgb24gdGhlIHRpbWVsaW5lLlxuICBsZXQgY3VycmVudEluaXRTZWdtZW50OiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICBjb25zdCBvbGRGcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgZm9yIChsZXQgaSA9IG9sZEZyYWdtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG9sZEluaXQgPSBvbGRGcmFnbWVudHNbaV0uaW5pdFNlZ21lbnQ7XG4gICAgaWYgKG9sZEluaXQpIHtcbiAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IG9sZEluaXQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAob2xkRGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAvLyBwcmV2ZW50IFBUUyBhbmQgZHVyYXRpb24gZnJvbSBiZWluZyBhZGp1c3RlZCBvbiB0aGUgbmV4dCBoaW50XG4gICAgZGVsZXRlIG9sZERldGFpbHMuZnJhZ21lbnRIaW50LmVuZFBUUztcbiAgfVxuICAvLyBjaGVjayBpZiBvbGQvbmV3IHBsYXlsaXN0cyBoYXZlIGZyYWdtZW50cyBpbiBjb21tb25cbiAgLy8gbG9vcCB0aHJvdWdoIG92ZXJsYXBwaW5nIFNOIGFuZCB1cGRhdGUgc3RhcnRQVFMgLCBjYywgYW5kIGR1cmF0aW9uIGlmIGFueSBmb3VuZFxuICBsZXQgY2NPZmZzZXQgPSAwO1xuICBsZXQgUFRTRnJhZztcbiAgbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24oXG4gICAgb2xkRGV0YWlscyxcbiAgICBuZXdEZXRhaWxzLFxuICAgIChvbGRGcmFnOiBGcmFnbWVudCwgbmV3RnJhZzogRnJhZ21lbnQpID0+IHtcbiAgICAgIGlmIChvbGRGcmFnLnJlbHVybCkge1xuICAgICAgICAvLyBEbyBub3QgY29tcGFyZSBDQyBpZiB0aGUgb2xkIGZyYWdtZW50IGhhcyBubyB1cmwuIFRoaXMgaXMgYSBsZXZlbC5mcmFnbWVudEhpbnQgdXNlZCBieSBMTC1ITFMgcGFydHMuXG4gICAgICAgIC8vIEl0IG1heWJlIGJlIG9mZiBieSAxIGlmIGl0IHdhcyBjcmVhdGVkIGJlZm9yZSBhbnkgcGFydHMgb3IgZGlzY29udGludWl0eSB0YWdzIHdlcmUgYXBwZW5kZWQgdG8gdGhlIGVuZFxuICAgICAgICAvLyBvZiB0aGUgcGxheWxpc3QuXG4gICAgICAgIGNjT2Zmc2V0ID0gb2xkRnJhZy5jYyAtIG5ld0ZyYWcuY2M7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIE51bWJlci5pc0Zpbml0ZShvbGRGcmFnLnN0YXJ0UFRTKSAmJlxuICAgICAgICBOdW1iZXIuaXNGaW5pdGUob2xkRnJhZy5lbmRQVFMpXG4gICAgICApIHtcbiAgICAgICAgbmV3RnJhZy5zdGFydCA9IG5ld0ZyYWcuc3RhcnRQVFMgPSBvbGRGcmFnLnN0YXJ0UFRTIGFzIG51bWJlcjtcbiAgICAgICAgbmV3RnJhZy5zdGFydERUUyA9IG9sZEZyYWcuc3RhcnREVFM7XG4gICAgICAgIG5ld0ZyYWcubWF4U3RhcnRQVFMgPSBvbGRGcmFnLm1heFN0YXJ0UFRTO1xuXG4gICAgICAgIG5ld0ZyYWcuZW5kUFRTID0gb2xkRnJhZy5lbmRQVFM7XG4gICAgICAgIG5ld0ZyYWcuZW5kRFRTID0gb2xkRnJhZy5lbmREVFM7XG4gICAgICAgIG5ld0ZyYWcubWluRW5kUFRTID0gb2xkRnJhZy5taW5FbmRQVFM7XG4gICAgICAgIG5ld0ZyYWcuZHVyYXRpb24gPVxuICAgICAgICAgIChvbGRGcmFnLmVuZFBUUyBhcyBudW1iZXIpIC0gKG9sZEZyYWcuc3RhcnRQVFMgYXMgbnVtYmVyKTtcblxuICAgICAgICBpZiAobmV3RnJhZy5kdXJhdGlvbikge1xuICAgICAgICAgIFBUU0ZyYWcgPSBuZXdGcmFnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUFRTIGlzIGtub3duIHdoZW4gYW55IHNlZ21lbnQgaGFzIHN0YXJ0UFRTIGFuZCBlbmRQVFNcbiAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IG5ld0RldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbmV3RnJhZy5lbGVtZW50YXJ5U3RyZWFtcyA9IG9sZEZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICBuZXdGcmFnLmxvYWRlciA9IG9sZEZyYWcubG9hZGVyO1xuICAgICAgbmV3RnJhZy5zdGF0cyA9IG9sZEZyYWcuc3RhdHM7XG4gICAgICBuZXdGcmFnLnVybElkID0gb2xkRnJhZy51cmxJZDtcbiAgICAgIGlmIChvbGRGcmFnLmluaXRTZWdtZW50KSB7XG4gICAgICAgIG5ld0ZyYWcuaW5pdFNlZ21lbnQgPSBvbGRGcmFnLmluaXRTZWdtZW50O1xuICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBvbGRGcmFnLmluaXRTZWdtZW50O1xuICAgICAgfVxuICAgIH1cbiAgKTtcblxuICBpZiAoY3VycmVudEluaXRTZWdtZW50KSB7XG4gICAgY29uc3QgZnJhZ21lbnRzVG9DaGVjayA9IG5ld0RldGFpbHMuZnJhZ21lbnRIaW50XG4gICAgICA/IG5ld0RldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChuZXdEZXRhaWxzLmZyYWdtZW50SGludClcbiAgICAgIDogbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gICAgZnJhZ21lbnRzVG9DaGVjay5mb3JFYWNoKChmcmFnKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICFmcmFnLmluaXRTZWdtZW50IHx8XG4gICAgICAgIGZyYWcuaW5pdFNlZ21lbnQucmVsdXJsID09PSBjdXJyZW50SW5pdFNlZ21lbnQ/LnJlbHVybFxuICAgICAgKSB7XG4gICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAobmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICBuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gbmV3RGV0YWlscy5mcmFnbWVudHMuc29tZSgoZnJhZykgPT4gIWZyYWcpO1xuICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICBsb2dnZXIud2FybihcbiAgICAgICAgJ1tsZXZlbC1oZWxwZXJdIFByZXZpb3VzIHBsYXlsaXN0IG1pc3Npbmcgc2VnbWVudHMgc2tpcHBlZCBpbiBkZWx0YSBwbGF5bGlzdCdcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBpID0gbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHM7IGktLTsgKSB7XG4gICAgICAgIG5ld0RldGFpbHMuZnJhZ21lbnRzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICBuZXdEZXRhaWxzLnN0YXJ0U04gPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zbiBhcyBudW1iZXI7XG4gICAgICBuZXdEZXRhaWxzLnN0YXJ0Q0MgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5jYztcbiAgICB9IGVsc2UgaWYgKG5ld0RldGFpbHMuY2FuU2tpcERhdGVSYW5nZXMpIHtcbiAgICAgIG5ld0RldGFpbHMuZGF0ZVJhbmdlcyA9IG1lcmdlRGF0ZVJhbmdlcyhcbiAgICAgICAgb2xkRGV0YWlscy5kYXRlUmFuZ2VzLFxuICAgICAgICBuZXdEZXRhaWxzLmRhdGVSYW5nZXMsXG4gICAgICAgIG5ld0RldGFpbHMucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlc1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBuZXdGcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgaWYgKGNjT2Zmc2V0KSB7XG4gICAgbG9nZ2VyLndhcm4oJ2Rpc2NvbnRpbnVpdHkgc2xpZGluZyBmcm9tIHBsYXlsaXN0LCB0YWtlIGRyaWZ0IGludG8gYWNjb3VudCcpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3RnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdGcmFnbWVudHNbaV0uY2MgKz0gY2NPZmZzZXQ7XG4gICAgfVxuICB9XG4gIGlmIChuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgIG5ld0RldGFpbHMuc3RhcnRDQyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLmNjO1xuICB9XG5cbiAgLy8gTWVyZ2UgcGFydHNcbiAgbWFwUGFydEludGVyc2VjdGlvbihcbiAgICBvbGREZXRhaWxzLnBhcnRMaXN0LFxuICAgIG5ld0RldGFpbHMucGFydExpc3QsXG4gICAgKG9sZFBhcnQ6IFBhcnQsIG5ld1BhcnQ6IFBhcnQpID0+IHtcbiAgICAgIG5ld1BhcnQuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRQYXJ0LmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgbmV3UGFydC5zdGF0cyA9IG9sZFBhcnQuc3RhdHM7XG4gICAgfVxuICApO1xuXG4gIC8vIGlmIGF0IGxlYXN0IG9uZSBmcmFnbWVudCBjb250YWlucyBQVFMgaW5mbywgcmVjb21wdXRlIFBUUyBpbmZvcm1hdGlvbiBmb3IgYWxsIGZyYWdtZW50c1xuICBpZiAoUFRTRnJhZykge1xuICAgIHVwZGF0ZUZyYWdQVFNEVFMoXG4gICAgICBuZXdEZXRhaWxzLFxuICAgICAgUFRTRnJhZyxcbiAgICAgIFBUU0ZyYWcuc3RhcnRQVFMsXG4gICAgICBQVFNGcmFnLmVuZFBUUyxcbiAgICAgIFBUU0ZyYWcuc3RhcnREVFMsXG4gICAgICBQVFNGcmFnLmVuZERUU1xuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZGVsdGEgaXMgd2l0aGluIG9sZEZyYWdtZW50cyByYW5nZVxuICAgIC8vIGFsc28gYWRqdXN0IHNsaWRpbmcgaW4gY2FzZSBkZWx0YSBpcyAwICh3ZSBjb3VsZCBoYXZlIG9sZD1bNTAtNjBdIGFuZCBuZXc9b2xkPVs1MC02MV0pXG4gICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMpO1xuICB9XG5cbiAgaWYgKG5ld0ZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24gPSBuZXdEZXRhaWxzLmVkZ2UgLSBuZXdGcmFnbWVudHNbMF0uc3RhcnQ7XG4gIH1cblxuICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnRUaW1lID0gb2xkRGV0YWlscy5kcmlmdFN0YXJ0VGltZTtcbiAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0ID0gb2xkRGV0YWlscy5kcmlmdFN0YXJ0O1xuICBjb25zdCBhZHZhbmNlZERhdGVUaW1lID0gbmV3RGV0YWlscy5hZHZhbmNlZERhdGVUaW1lO1xuICBpZiAobmV3RGV0YWlscy5hZHZhbmNlZCAmJiBhZHZhbmNlZERhdGVUaW1lKSB7XG4gICAgY29uc3QgZWRnZSA9IG5ld0RldGFpbHMuZWRnZTtcbiAgICBpZiAoIW5ld0RldGFpbHMuZHJpZnRTdGFydCkge1xuICAgICAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0VGltZSA9IGFkdmFuY2VkRGF0ZVRpbWU7XG4gICAgICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnQgPSBlZGdlO1xuICAgIH1cbiAgICBuZXdEZXRhaWxzLmRyaWZ0RW5kVGltZSA9IGFkdmFuY2VkRGF0ZVRpbWU7XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZCA9IGVkZ2U7XG4gIH0gZWxzZSB7XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZFRpbWUgPSBvbGREZXRhaWxzLmRyaWZ0RW5kVGltZTtcbiAgICBuZXdEZXRhaWxzLmRyaWZ0RW5kID0gb2xkRGV0YWlscy5kcmlmdEVuZDtcbiAgICBuZXdEZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWUgPSBvbGREZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VEYXRlUmFuZ2VzKFxuICBvbGREYXRlUmFuZ2VzOiBSZWNvcmQ8c3RyaW5nLCBEYXRlUmFuZ2U+LFxuICBkZWx0YURhdGVSYW5nZXM6IFJlY29yZDxzdHJpbmcsIERhdGVSYW5nZT4sXG4gIHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkXG4pOiBSZWNvcmQ8c3RyaW5nLCBEYXRlUmFuZ2U+IHtcbiAgY29uc3QgZGF0ZVJhbmdlcyA9IE9iamVjdC5hc3NpZ24oe30sIG9sZERhdGVSYW5nZXMpO1xuICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgIHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgIGRlbGV0ZSBkYXRlUmFuZ2VzW2lkXTtcbiAgICB9KTtcbiAgfVxuICBPYmplY3Qua2V5cyhkZWx0YURhdGVSYW5nZXMpLmZvckVhY2goKGlkKSA9PiB7XG4gICAgY29uc3QgZGF0ZVJhbmdlID0gbmV3IERhdGVSYW5nZShkZWx0YURhdGVSYW5nZXNbaWRdLmF0dHIsIGRhdGVSYW5nZXNbaWRdKTtcbiAgICBpZiAoZGF0ZVJhbmdlLmlzVmFsaWQpIHtcbiAgICAgIGRhdGVSYW5nZXNbaWRdID0gZGF0ZVJhbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybihcbiAgICAgICAgYElnbm9yaW5nIGludmFsaWQgUGxheWxpc3QgRGVsdGEgVXBkYXRlIERBVEVSQU5HRSB0YWc6IFwiJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBkZWx0YURhdGVSYW5nZXNbaWRdLmF0dHJcbiAgICAgICAgKX1cImBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGVSYW5nZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBQYXJ0SW50ZXJzZWN0aW9uKFxuICBvbGRQYXJ0czogUGFydFtdIHwgbnVsbCxcbiAgbmV3UGFydHM6IFBhcnRbXSB8IG51bGwsXG4gIGludGVyc2VjdGlvbkZuOiBQYXJ0SW50ZXJzZWN0aW9uXG4pIHtcbiAgaWYgKG9sZFBhcnRzICYmIG5ld1BhcnRzKSB7XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb2xkUGFydHMubGVuZ3RoOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBvbGRQYXJ0ID0gb2xkUGFydHNbaV07XG4gICAgICBjb25zdCBuZXdQYXJ0ID0gbmV3UGFydHNbaSArIGRlbHRhXTtcbiAgICAgIGlmIChcbiAgICAgICAgb2xkUGFydCAmJlxuICAgICAgICBuZXdQYXJ0ICYmXG4gICAgICAgIG9sZFBhcnQuaW5kZXggPT09IG5ld1BhcnQuaW5kZXggJiZcbiAgICAgICAgb2xkUGFydC5mcmFnbWVudC5zbiA9PT0gbmV3UGFydC5mcmFnbWVudC5zblxuICAgICAgKSB7XG4gICAgICAgIGludGVyc2VjdGlvbkZuKG9sZFBhcnQsIG5ld1BhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGEtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKFxuICBvbGREZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIG5ld0RldGFpbHM6IExldmVsRGV0YWlscyxcbiAgaW50ZXJzZWN0aW9uRm46IEZyYWdtZW50SW50ZXJzZWN0aW9uXG4pOiB2b2lkIHtcbiAgY29uc3Qgc2tpcHBlZFNlZ21lbnRzID0gbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHM7XG4gIGNvbnN0IHN0YXJ0ID1cbiAgICBNYXRoLm1heChvbGREZXRhaWxzLnN0YXJ0U04sIG5ld0RldGFpbHMuc3RhcnRTTikgLSBuZXdEZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IGVuZCA9XG4gICAgKG9sZERldGFpbHMuZnJhZ21lbnRIaW50ID8gMSA6IDApICtcbiAgICAoc2tpcHBlZFNlZ21lbnRzXG4gICAgICA/IG5ld0RldGFpbHMuZW5kU05cbiAgICAgIDogTWF0aC5taW4ob2xkRGV0YWlscy5lbmRTTiwgbmV3RGV0YWlscy5lbmRTTikpIC1cbiAgICBuZXdEZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IGRlbHRhID0gbmV3RGV0YWlscy5zdGFydFNOIC0gb2xkRGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBuZXdGcmFncyA9IG5ld0RldGFpbHMuZnJhZ21lbnRIaW50XG4gICAgPyBuZXdEZXRhaWxzLmZyYWdtZW50cy5jb25jYXQobmV3RGV0YWlscy5mcmFnbWVudEhpbnQpXG4gICAgOiBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgY29uc3Qgb2xkRnJhZ3MgPSBvbGREZXRhaWxzLmZyYWdtZW50SGludFxuICAgID8gb2xkRGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG9sZERldGFpbHMuZnJhZ21lbnRIaW50KVxuICAgIDogb2xkRGV0YWlscy5mcmFnbWVudHM7XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgY29uc3Qgb2xkRnJhZyA9IG9sZEZyYWdzW2RlbHRhICsgaV07XG4gICAgbGV0IG5ld0ZyYWcgPSBuZXdGcmFnc1tpXTtcbiAgICBpZiAoc2tpcHBlZFNlZ21lbnRzICYmICFuZXdGcmFnICYmIGkgPCBza2lwcGVkU2VnbWVudHMpIHtcbiAgICAgIC8vIEZpbGwgaW4gc2tpcHBlZCBzZWdtZW50cyBpbiBkZWx0YSBwbGF5bGlzdFxuICAgICAgbmV3RnJhZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzW2ldID0gb2xkRnJhZztcbiAgICB9XG4gICAgaWYgKG9sZEZyYWcgJiYgbmV3RnJhZykge1xuICAgICAgaW50ZXJzZWN0aW9uRm4ob2xkRnJhZywgbmV3RnJhZyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RTbGlkaW5nKFxuICBvbGREZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIG5ld0RldGFpbHM6IExldmVsRGV0YWlsc1xuKTogdm9pZCB7XG4gIGNvbnN0IGRlbHRhID1cbiAgICBuZXdEZXRhaWxzLnN0YXJ0U04gKyBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cyAtIG9sZERldGFpbHMuc3RhcnRTTjtcbiAgY29uc3Qgb2xkRnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHM7XG4gIGlmIChkZWx0YSA8IDAgfHwgZGVsdGEgPj0gb2xkRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhZGRTbGlkaW5nKG5ld0RldGFpbHMsIG9sZEZyYWdtZW50c1tkZWx0YV0uc3RhcnQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkU2xpZGluZyhkZXRhaWxzOiBMZXZlbERldGFpbHMsIHN0YXJ0OiBudW1iZXIpIHtcbiAgaWYgKHN0YXJ0KSB7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgZm9yIChsZXQgaSA9IGRldGFpbHMuc2tpcHBlZFNlZ21lbnRzOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFnbWVudHNbaV0uc3RhcnQgKz0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgZGV0YWlscy5mcmFnbWVudEhpbnQuc3RhcnQgKz0gc3RhcnQ7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUmVsb2FkSW50ZXJ2YWwoXG4gIG5ld0RldGFpbHM6IExldmVsRGV0YWlscyxcbiAgZGlzdGFuY2VUb0xpdmVFZGdlTXM6IG51bWJlciA9IEluZmluaXR5XG4pOiBudW1iZXIge1xuICBsZXQgcmVsb2FkSW50ZXJ2YWwgPSAxMDAwICogbmV3RGV0YWlscy50YXJnZXRkdXJhdGlvbjtcblxuICBpZiAobmV3RGV0YWlscy51cGRhdGVkKSB7XG4gICAgLy8gVXNlIGxhc3Qgc2VnbWVudCBkdXJhdGlvbiB3aGVuIHNob3J0ZXIgdGhhbiB0YXJnZXQgZHVyYXRpb24gYW5kIG5lYXIgbGl2ZSBlZGdlXG4gICAgY29uc3QgZnJhZ21lbnRzID0gbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3QgbGl2ZUVkZ2VNYXhUYXJnZXREdXJhdGlvbnMgPSA0O1xuICAgIGlmIChcbiAgICAgIGZyYWdtZW50cy5sZW5ndGggJiZcbiAgICAgIHJlbG9hZEludGVydmFsICogbGl2ZUVkZ2VNYXhUYXJnZXREdXJhdGlvbnMgPiBkaXN0YW5jZVRvTGl2ZUVkZ2VNc1xuICAgICkge1xuICAgICAgY29uc3QgbGFzdFNlZ21lbnREdXJhdGlvbiA9XG4gICAgICAgIGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZHVyYXRpb24gKiAxMDAwO1xuICAgICAgaWYgKGxhc3RTZWdtZW50RHVyYXRpb24gPCByZWxvYWRJbnRlcnZhbCkge1xuICAgICAgICByZWxvYWRJbnRlcnZhbCA9IGxhc3RTZWdtZW50RHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGVzdGltYXRlID0gJ21pc3MgaGFsZiBhdmVyYWdlJztcbiAgICAvLyBmb2xsb3cgSExTIFNwZWMsIElmIHRoZSBjbGllbnQgcmVsb2FkcyBhIFBsYXlsaXN0IGZpbGUgYW5kIGZpbmRzIHRoYXQgaXQgaGFzIG5vdFxuICAgIC8vIGNoYW5nZWQgdGhlbiBpdCBNVVNUIHdhaXQgZm9yIGEgcGVyaW9kIG9mIG9uZS1oYWxmIHRoZSB0YXJnZXRcbiAgICAvLyBkdXJhdGlvbiBiZWZvcmUgcmV0cnlpbmcuXG4gICAgcmVsb2FkSW50ZXJ2YWwgLz0gMjtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnJvdW5kKHJlbG9hZEludGVydmFsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50V2l0aFNOKFxuICBsZXZlbDogTGV2ZWwsXG4gIHNuOiBudW1iZXIsXG4gIGZyYWdDdXJyZW50OiBGcmFnbWVudCB8IG51bGxcbik6IEZyYWdtZW50IHwgbnVsbCB7XG4gIGlmICghbGV2ZWw/LmRldGFpbHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICBsZXQgZnJhZ21lbnQ6IEZyYWdtZW50IHwgdW5kZWZpbmVkID1cbiAgICBsZXZlbERldGFpbHMuZnJhZ21lbnRzW3NuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICBpZiAoZnJhZ21lbnQpIHtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgZnJhZ21lbnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRIaW50O1xuICBpZiAoZnJhZ21lbnQgJiYgZnJhZ21lbnQuc24gPT09IHNuKSB7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG4gIGlmIChzbiA8IGxldmVsRGV0YWlscy5zdGFydFNOICYmIGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LnNuID09PSBzbikge1xuICAgIHJldHVybiBmcmFnQ3VycmVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcnRXaXRoKFxuICBsZXZlbDogTGV2ZWwsXG4gIHNuOiBudW1iZXIsXG4gIHBhcnRJbmRleDogbnVtYmVyXG4pOiBQYXJ0IHwgbnVsbCB7XG4gIGlmICghbGV2ZWw/LmRldGFpbHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZmluZFBhcnQobGV2ZWwuZGV0YWlscz8ucGFydExpc3QsIHNuLCBwYXJ0SW5kZXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFBhcnQoXG4gIHBhcnRMaXN0OiBQYXJ0W10gfCBudWxsIHwgdW5kZWZpbmVkLFxuICBzbjogbnVtYmVyLFxuICBwYXJ0SW5kZXg6IG51bWJlclxuKTogUGFydCB8IG51bGwge1xuICBpZiAocGFydExpc3QpIHtcbiAgICBmb3IgKGxldCBpID0gcGFydExpc3QubGVuZ3RoOyBpLS07ICkge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRMaXN0W2ldO1xuICAgICAgaWYgKHBhcnQuaW5kZXggPT09IHBhcnRJbmRleCAmJiBwYXJ0LmZyYWdtZW50LnNuID09PSBzbikge1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJpbXBvcnQgeyBMb2FkUG9saWN5LCBMb2FkZXJDb25maWcsIFJldHJ5Q29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB7IEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBFcnJvckRhdGEgfSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNUaW1lb3V0RXJyb3IoZXJyb3I6IEVycm9yRGF0YSk6IGJvb2xlYW4ge1xuICBzd2l0Y2ggKGVycm9yLmRldGFpbHMpIHtcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXRyeUNvbmZpZyhcbiAgbG9hZFBvbGljeTogTG9hZFBvbGljeSxcbiAgZXJyb3I6IEVycm9yRGF0YVxuKTogUmV0cnlDb25maWcgfCBudWxsIHtcbiAgY29uc3QgaXNUaW1lb3V0ID0gaXNUaW1lb3V0RXJyb3IoZXJyb3IpO1xuICByZXR1cm4gbG9hZFBvbGljeS5kZWZhdWx0W2Ake2lzVGltZW91dCA/ICd0aW1lb3V0JyA6ICdlcnJvcid9UmV0cnlgXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJldHJ5RGVsYXkoXG4gIHJldHJ5Q29uZmlnOiBSZXRyeUNvbmZpZyxcbiAgcmV0cnlDb3VudDogbnVtYmVyXG4pOiBudW1iZXIge1xuICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBtYXggcmV0cnkgZGVsYXlcbiAgY29uc3QgYmFja29mZkZhY3RvciA9XG4gICAgcmV0cnlDb25maWcuYmFja29mZiA9PT0gJ2xpbmVhcicgPyAxIDogTWF0aC5wb3coMiwgcmV0cnlDb3VudCk7XG4gIHJldHVybiBNYXRoLm1pbihcbiAgICBiYWNrb2ZmRmFjdG9yICogcmV0cnlDb25maWcucmV0cnlEZWxheU1zLFxuICAgIHJldHJ5Q29uZmlnLm1heFJldHJ5RGVsYXlNc1xuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhcbiAgbG9kZXJDb25maWc6IExvYWRlckNvbmZpZ1xuKTogTG9hZGVyQ29uZmlnIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5sb2RlckNvbmZpZyxcbiAgICAuLi57XG4gICAgICBlcnJvclJldHJ5OiBudWxsLFxuICAgICAgdGltZW91dFJldHJ5OiBudWxsLFxuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRSZXRyeShcbiAgcmV0cnlDb25maWc6IFJldHJ5Q29uZmlnIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgcmV0cnlDb3VudDogbnVtYmVyLFxuICBpc1RpbWVvdXQ6IGJvb2xlYW4sXG4gIGh0dHBTdGF0dXM/OiBudW1iZXIgfCB1bmRlZmluZWRcbik6IHJldHJ5Q29uZmlnIGlzIFJldHJ5Q29uZmlnICYgYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgISFyZXRyeUNvbmZpZyAmJlxuICAgIHJldHJ5Q291bnQgPCByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSAmJlxuICAgIChyZXRyeUZvckh0dHBTdGF0dXMoaHR0cFN0YXR1cykgfHwgISFpc1RpbWVvdXQpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXRyeUZvckh0dHBTdGF0dXMoaHR0cFN0YXR1czogbnVtYmVyIHwgdW5kZWZpbmVkKSB7XG4gIC8vIERvIG5vdCByZXRyeSBvbiBzdGF0dXMgNHh4LCBzdGF0dXMgMCAoQ09SUyBlcnJvciksIG9yIHVuZGVmaW5lZCAoZGVjcnlwdC9nYXAvcGFyc2UgZXJyb3IpXG4gIHJldHVybiAoXG4gICAgKGh0dHBTdGF0dXMgPT09IDAgJiYgbmF2aWdhdG9yLm9uTGluZSA9PT0gZmFsc2UpIHx8XG4gICAgKCEhaHR0cFN0YXR1cyAmJiAoaHR0cFN0YXR1cyA8IDQwMCB8fCBodHRwU3RhdHVzID4gNDk5KSlcbiAgKTtcbn1cbiIsInR5cGUgQmluYXJ5U2VhcmNoQ29tcGFyaXNvbjxUPiA9IChjYW5kaWRhdGU6IFQpID0+IC0xIHwgMCB8IDE7XG5cbmNvbnN0IEJpbmFyeVNlYXJjaCA9IHtcbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciBhbiBpdGVtIGluIGFuIGFycmF5IHdoaWNoIG1hdGNoZXMgYSBjZXJ0YWluIGNvbmRpdGlvbi5cbiAgICogVGhpcyByZXF1aXJlcyB0aGUgY29uZGl0aW9uIHRvIG9ubHkgbWF0Y2ggb25lIGl0ZW0gaW4gdGhlIGFycmF5LFxuICAgKiBhbmQgZm9yIHRoZSBhcnJheSB0byBiZSBvcmRlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0gbGlzdCBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0gY29tcGFyaXNvbkZuXG4gICAqICAgICAgQ2FsbGVkIGFuZCBwcm92aWRlZCBhIGNhbmRpZGF0ZSBpdGVtIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICogICAgICBTaG91bGQgcmV0dXJuOlxuICAgKiAgICAgICAgICA+IC0xIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgbG93ZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICogICAgICAgICAgPiAxIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgaGlnaGVyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAqICAgICAgICAgID4gMCBpZiB0aGUgaXRlbSBpcyB0aGUgaXRlbSB5b3UncmUgbG9va2luZyBmb3IuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBvYmplY3QgaWYgZm91bmQsIG90aGVyd2lzZSByZXR1cm5zIG51bGxcbiAgICovXG4gIHNlYXJjaDogZnVuY3Rpb24gPFQ+KFxuICAgIGxpc3Q6IFRbXSxcbiAgICBjb21wYXJpc29uRm46IEJpbmFyeVNlYXJjaENvbXBhcmlzb248VD5cbiAgKTogVCB8IG51bGwge1xuICAgIGxldCBtaW5JbmRleDogbnVtYmVyID0gMDtcbiAgICBsZXQgbWF4SW5kZXg6IG51bWJlciA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICBsZXQgY3VycmVudEluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgY3VycmVudEVsZW1lbnQ6IFQgfCBudWxsID0gbnVsbDtcblxuICAgIHdoaWxlIChtaW5JbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgY3VycmVudEluZGV4ID0gKChtaW5JbmRleCArIG1heEluZGV4KSAvIDIpIHwgMDtcbiAgICAgIGN1cnJlbnRFbGVtZW50ID0gbGlzdFtjdXJyZW50SW5kZXhdO1xuXG4gICAgICBjb25zdCBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyaXNvbkZuKGN1cnJlbnRFbGVtZW50KTtcbiAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJpbmFyeVNlYXJjaDtcbiIsImltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5cbi8qKlxuICogUmV0dXJucyBmaXJzdCBmcmFnbWVudCB3aG9zZSBlbmRQZHQgdmFsdWUgZXhjZWVkcyB0aGUgZ2l2ZW4gUERULCBvciBudWxsLlxuICogQHBhcmFtIGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0gUERUVmFsdWUgLSBUaGUgUERUIHZhbHVlIHdoaWNoIG11c3QgYmUgZXhjZWVkZWRcbiAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQRFQoXG4gIGZyYWdtZW50czogQXJyYXk8RnJhZ21lbnQ+LFxuICBQRFRWYWx1ZTogbnVtYmVyIHwgbnVsbCxcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogbnVtYmVyXG4pOiBGcmFnbWVudCB8IG51bGwge1xuICBpZiAoXG4gICAgUERUVmFsdWUgPT09IG51bGwgfHxcbiAgICAhQXJyYXkuaXNBcnJheShmcmFnbWVudHMpIHx8XG4gICAgIWZyYWdtZW50cy5sZW5ndGggfHxcbiAgICAhTnVtYmVyLmlzRmluaXRlKFBEVFZhbHVlKVxuICApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGlmIGxlc3MgdGhhbiBzdGFydFxuICBjb25zdCBzdGFydFBEVCA9IGZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChQRFRWYWx1ZSA8IChzdGFydFBEVCB8fCAwKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZW5kUERUID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChQRFRWYWx1ZSA+PSAoZW5kUERUIHx8IDApKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB8fCAwO1xuICBmb3IgKGxldCBzZWcgPSAwOyBzZWcgPCBmcmFnbWVudHMubGVuZ3RoOyArK3NlZykge1xuICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudHNbc2VnXTtcbiAgICBpZiAocGR0V2l0aGluVG9sZXJhbmNlVGVzdChQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZykpIHtcbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgZnJhZ21lbnQgYmFzZWQgb24gdGhlIFNOIG9mIHRoZSBwcmV2aW91cyBmcmFnbWVudDsgb3IgYmFzZWQgb24gdGhlIG5lZWRzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAqIFRoaXMgbWV0aG9kIGNvbXBlbnNhdGVzIGZvciBzbWFsbCBidWZmZXIgZ2FwcyBieSBhcHBseWluZyBhIHRvbGVyYW5jZSB0byB0aGUgc3RhcnQgb2YgYW55IGNhbmRpZGF0ZSBmcmFnbWVudCwgdGh1c1xuICogYnJlYWtpbmcgYW55IHRyYXBzIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSBzYW1lIGZyYWdtZW50IHRvIGJlIGNvbnRpbnVvdXNseSBzZWxlY3RlZCB3aXRoaW4gYSBzbWFsbCByYW5nZS5cbiAqIEBwYXJhbSBmcmFnUHJldmlvdXMgLSBUaGUgbGFzdCBmcmFnIHN1Y2Nlc3NmdWxseSBhcHBlbmRlZFxuICogQHBhcmFtIGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0gYnVmZmVyRW5kIC0gVGhlIGVuZCBvZiB0aGUgY29udGlndW91cyBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyBhIG1hdGNoaW5nIGZyYWdtZW50IG9yIG51bGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGcmFnbWVudEJ5UFRTKFxuICBmcmFnUHJldmlvdXM6IEZyYWdtZW50IHwgbnVsbCxcbiAgZnJhZ21lbnRzOiBBcnJheTxGcmFnbWVudD4sXG4gIGJ1ZmZlckVuZDogbnVtYmVyID0gMCxcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogbnVtYmVyID0gMFxuKTogRnJhZ21lbnQgfCBudWxsIHtcbiAgbGV0IGZyYWdOZXh0OiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICBpZiAoZnJhZ1ByZXZpb3VzKSB7XG4gICAgZnJhZ05leHQgPVxuICAgICAgZnJhZ21lbnRzW1xuICAgICAgICAoZnJhZ1ByZXZpb3VzLnNuIGFzIG51bWJlcikgLSAoZnJhZ21lbnRzWzBdLnNuIGFzIG51bWJlcikgKyAxXG4gICAgICBdIHx8IG51bGw7XG4gIH0gZWxzZSBpZiAoYnVmZmVyRW5kID09PSAwICYmIGZyYWdtZW50c1swXS5zdGFydCA9PT0gMCkge1xuICAgIGZyYWdOZXh0ID0gZnJhZ21lbnRzWzBdO1xuICB9XG4gIC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcbiAgaWYgKFxuICAgIGZyYWdOZXh0ICYmXG4gICAgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZ05leHQpID09PVxuICAgICAgMFxuICApIHtcbiAgICByZXR1cm4gZnJhZ05leHQ7XG4gIH1cbiAgLy8gV2UgbWlnaHQgYmUgc2Vla2luZyBwYXN0IHRoZSB0b2xlcmFuY2Ugc28gZmluZCB0aGUgYmVzdCBtYXRjaFxuICBjb25zdCBmb3VuZEZyYWdtZW50ID0gQmluYXJ5U2VhcmNoLnNlYXJjaChcbiAgICBmcmFnbWVudHMsXG4gICAgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0LmJpbmQobnVsbCwgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKVxuICApO1xuICBpZiAoZm91bmRGcmFnbWVudCAmJiAoZm91bmRGcmFnbWVudCAhPT0gZnJhZ1ByZXZpb3VzIHx8ICFmcmFnTmV4dCkpIHtcbiAgICByZXR1cm4gZm91bmRGcmFnbWVudDtcbiAgfVxuICAvLyBJZiBubyBtYXRjaCB3YXMgZm91bmQgcmV0dXJuIHRoZSBuZXh0IGZyYWdtZW50IGFmdGVyIGZyYWdQcmV2aW91cywgb3IgbnVsbFxuICByZXR1cm4gZnJhZ05leHQ7XG59XG5cbi8qKlxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlTbidzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIEBwYXJhbSBjYW5kaWRhdGUgLSBUaGUgZnJhZ21lbnQgdG8gdGVzdFxuICogQHBhcmFtIGJ1ZmZlckVuZCAtIFRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0IGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyAwIGlmIGl0IG1hdGNoZXMsIDEgaWYgdG9vIGxvdywgLTEgaWYgdG9vIGhpZ2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChcbiAgYnVmZmVyRW5kID0gMCxcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDAsXG4gIGNhbmRpZGF0ZTogRnJhZ21lbnRcbikge1xuICAvLyBlYWdlcmx5IGFjY2VwdCBhbiBhY2N1cmF0ZSBtYXRjaCAobm8gdG9sZXJhbmNlKVxuICBpZiAoXG4gICAgY2FuZGlkYXRlLnN0YXJ0IDw9IGJ1ZmZlckVuZCAmJlxuICAgIGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiA+IGJ1ZmZlckVuZFxuICApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAvLyBidWZmZXJFbmQgPSA5Ljk5MVxuICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAvLyBidWZmZXJFbmQgaXMgd2l0aGluIGZyYWdbMF0gcmFuZ2UgLi4uIGFsdGhvdWdoIHdoYXQgd2UgYXJlIGV4cGVjdGluZyBpcyB0byByZXR1cm4gZnJhZ1sxXSBoZXJlXG4gIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgLy8gICAgICAgICAgICAgIDwtLS0+ICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0+XG4gIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gIC8vICByZXR1cm4gLTEgICAgICAgICAgICAgcmV0dXJuIDAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gIC8vIGxvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXG4gIGNvbnN0IGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKFxuICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsXG4gICAgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApXG4gICk7XG4gIGlmIChcbiAgICBjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPD1cbiAgICBidWZmZXJFbmRcbiAgKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoXG4gICAgY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmXG4gICAgY2FuZGlkYXRlLnN0YXJ0XG4gICkge1xuICAgIC8vIGlmIG1heEZyYWdMb29rVXBUb2xlcmFuY2Ugd2lsbCBoYXZlIG5lZ2F0aXZlIHZhbHVlIHRoZW4gZG9uJ3QgcmV0dXJuIC0xIGZvciBmaXJzdCBlbGVtZW50XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlQZHQncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBUaGlzIGZ1bmN0aW9uIHRlc3RzIHRoZSBjYW5kaWRhdGUncyBwcm9ncmFtIGRhdGUgdGltZSB2YWx1ZXMsIGFzIHJlcHJlc2VudGVkIGluIFVuaXggdGltZVxuICogQHBhcmFtIGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0gcGR0QnVmZmVyRW5kIC0gVGhlIFVuaXggdGltZSByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZVxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHRydWUgaWYgY29udGlndW91cywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KFxuICBwZHRCdWZmZXJFbmQ6IG51bWJlcixcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogbnVtYmVyLFxuICBjYW5kaWRhdGU6IEZyYWdtZW50XG4pOiBib29sZWFuIHtcbiAgY29uc3QgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID1cbiAgICBNYXRoLm1pbihcbiAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsXG4gICAgICBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMClcbiAgICApICogMTAwMDtcblxuICAvLyBlbmRQcm9ncmFtRGF0ZVRpbWUgY2FuIGJlIG51bGwsIGRlZmF1bHQgdG8gemVyb1xuICBjb25zdCBlbmRQcm9ncmFtRGF0ZVRpbWUgPSBjYW5kaWRhdGUuZW5kUHJvZ3JhbURhdGVUaW1lIHx8IDA7XG4gIHJldHVybiBlbmRQcm9ncmFtRGF0ZVRpbWUgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBwZHRCdWZmZXJFbmQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnJhZ1dpdGhDQyhcbiAgZnJhZ21lbnRzOiBGcmFnbWVudFtdLFxuICBjYzogbnVtYmVyXG4pOiBGcmFnbWVudCB8IG51bGwge1xuICByZXR1cm4gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIChjYW5kaWRhdGUpID0+IHtcbiAgICBpZiAoY2FuZGlkYXRlLmNjIDwgY2MpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlLmNjID4gY2MpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMsIEVycm9yVHlwZXMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgUGxheWxpc3RDb250ZXh0VHlwZSwgUGxheWxpc3RMZXZlbFR5cGUgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHtcbiAgZ2V0UmV0cnlDb25maWcsXG4gIGlzVGltZW91dEVycm9yLFxuICBzaG91bGRSZXRyeSxcbn0gZnJvbSAnLi4vdXRpbHMvZXJyb3ItaGVscGVyJztcbmltcG9ydCB7IGZpbmRGcmFnbWVudEJ5UFRTIH0gZnJvbSAnLi9mcmFnbWVudC1maW5kZXJzJztcbmltcG9ydCB7IEhkY3BMZXZlbCwgSGRjcExldmVscywgdHlwZSBMZXZlbCB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgUmV0cnlDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBOZXR3b3JrQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSB7IEVycm9yRGF0YSB9IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IEZyYWdtZW50IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB0eXBlIHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi4vaGxzJztcblxuY29uc3QgUkVORElUSU9OX1BFTkFMVFlfRFVSQVRJT05fTVMgPSAzMDAwMDA7XG5cbmV4cG9ydCBjb25zdCBlbnVtIE5ldHdvcmtFcnJvckFjdGlvbiB7XG4gIERvTm90aGluZyA9IDAsXG4gIFNlbmRFbmRDYWxsYmFjayA9IDEsIC8vIFJlc2VydmVkIGZvciBmdXR1cmUgdXNlXG4gIFNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3ggPSAyLFxuICBSZW1vdmVBbHRlcm5hdGVQZXJtYW5lbnRseSA9IDMsIC8vIFJlc2VydmVkIGZvciBmdXR1cmUgdXNlXG4gIEluc2VydERpc2NvbnRpbnVpdHkgPSA0LCAvLyBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZVxuICBSZXRyeVJlcXVlc3QgPSA1LFxufVxuXG5leHBvcnQgY29uc3QgZW51bSBFcnJvckFjdGlvbkZsYWdzIHtcbiAgTm9uZSA9IDAsXG4gIE1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0ID0gMSxcbiAgTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1AgPSAxIDw8IDEsXG4gIFN3aXRjaFRvU0RSID0gMSA8PCAyLCAvLyBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZVxufVxuXG5leHBvcnQgdHlwZSBJRXJyb3JBY3Rpb24gPSB7XG4gIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uO1xuICBmbGFnczogRXJyb3JBY3Rpb25GbGFncztcbiAgcmV0cnlDb3VudD86IG51bWJlcjtcbiAgcmV0cnlDb25maWc/OiBSZXRyeUNvbmZpZztcbiAgaGRjcExldmVsPzogSGRjcExldmVsO1xuICBuZXh0QXV0b0xldmVsPzogbnVtYmVyO1xuICByZXNvbHZlZD86IGJvb2xlYW47XG59O1xuXG50eXBlIFBlbmFsaXplZFJlbmRpdGlvbiA9IHtcbiAgbGFzdEVycm9yUGVyZk1zOiBudW1iZXI7XG4gIGVycm9yczogRXJyb3JEYXRhW107XG4gIGRldGFpbHM/OiBMZXZlbERldGFpbHM7XG59O1xuXG50eXBlIFBlbmFsaXplZFJlbmRpdGlvbnMgPSB7IFtrZXk6IG51bWJlcl06IFBlbmFsaXplZFJlbmRpdGlvbiB9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcnJvckNvbnRyb2xsZXIgaW1wbGVtZW50cyBOZXR3b3JrQ29tcG9uZW50QVBJIHtcbiAgcHJpdmF0ZSByZWFkb25seSBobHM6IEhscztcbiAgcHJpdmF0ZSBwbGF5bGlzdEVycm9yOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIHBlbmFsaXplZFJlbmRpdGlvbnM6IFBlbmFsaXplZFJlbmRpdGlvbnMgPSB7fTtcbiAgcHJpdmF0ZSBsb2c6IChtc2c6IGFueSkgPT4gdm9pZDtcbiAgcHJpdmF0ZSB3YXJuOiAobXNnOiBhbnkpID0+IHZvaWQ7XG4gIHByaXZhdGUgZXJyb3I6IChtc2c6IGFueSkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihobHM6IEhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMubG9nID0gbG9nZ2VyLmxvZy5iaW5kKGxvZ2dlciwgYFtpbmZvXTpgKTtcbiAgICB0aGlzLndhcm4gPSBsb2dnZXIud2Fybi5iaW5kKGxvZ2dlciwgYFt3YXJuaW5nXTpgKTtcbiAgICB0aGlzLmVycm9yID0gbG9nZ2VyLmVycm9yLmJpbmQobG9nZ2VyLCBgW2Vycm9yXTpgKTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3JPdXQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICAgIHRoaXMucGVuYWxpemVkUmVuZGl0aW9ucyA9IHt9O1xuICB9XG5cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb246IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gIH1cblxuICBzdG9wTG9hZCgpOiB2b2lkIHt9XG5cbiAgcHJpdmF0ZSBnZXRWYXJpYW50TGV2ZWxJbmRleChmcmFnOiBGcmFnbWVudCB8IHVuZGVmaW5lZCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGZyYWc/LnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU5cbiAgICAgID8gZnJhZy5sZXZlbFxuICAgICAgOiB0aGlzLmhscy5sb2FkTGV2ZWw7XG4gIH1cblxuICBwcml2YXRlIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgdGhpcy5wZW5hbGl6ZWRSZW5kaXRpb25zID0ge307XG4gIH1cblxuICBwcml2YXRlIG9uTGV2ZWxVcGRhdGVkKCkge1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gIH1cblxuICBwcml2YXRlIG9uRXJyb3IoZXZlbnQ6IEV2ZW50cy5FUlJPUiwgZGF0YTogRXJyb3JEYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgY29udGV4dCA9IGRhdGEuY29udGV4dDtcblxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0RnJhZ1JldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfR0FQOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SOiB7XG4gICAgICAgIC8vIFN3aXRjaCBsZXZlbCBpZiBwb3NzaWJsZSwgb3RoZXJ3aXNlIGFsbG93IHJldHJ5IGNvdW50IHRvIHJlYWNoIG1heCBlcnJvciByZXRyaWVzXG4gICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEpO1xuICAgICAgICBkYXRhLmVycm9yQWN0aW9uLmFjdGlvbiA9IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBPbmx5IHJldHJ5IHdoZW4gZW1wdHkgYW5kIGxpdmVcbiAgICAgICAgICBjb25zdCBsZXZlbEluZGV4ID1cbiAgICAgICAgICAgIGRhdGEucGFyZW50ID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOXG4gICAgICAgICAgICAgID8gKGRhdGEubGV2ZWwgYXMgbnVtYmVyKVxuICAgICAgICAgICAgICA6IGhscy5sb2FkTGV2ZWw7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuTEVWRUxfRU1QVFlfRVJST1IgJiZcbiAgICAgICAgICAgICEhZGF0YS5jb250ZXh0Py5sZXZlbERldGFpbHM/LmxpdmVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgbGV2ZWxJbmRleFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRXNjYWxhdGUgdG8gZmF0YWwgaWYgbm90IHJldHJ5aW5nIG9yIHN3aXRjaGluZ1xuICAgICAgICAgICAgZGF0YS5sZXZlbFJldHJ5ID0gZmFsc2U7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0Py5sZXZlbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgY29udGV4dC5sZXZlbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlNVQlRJVExFX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgY29uc3QgbGV2ZWwgPSBobHMubGV2ZWxzW2hscy5sb2FkTGV2ZWxdO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGxldmVsICYmXG4gICAgICAgICAgICAoKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJlxuICAgICAgICAgICAgICBjb250ZXh0Lmdyb3VwSWQgPT09IGxldmVsLmF1ZGlvR3JvdXBJZCkgfHxcbiAgICAgICAgICAgICAgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJlxuICAgICAgICAgICAgICAgIGNvbnRleHQuZ3JvdXBJZCA9PT0gbGV2ZWwudGV4dEdyb3VwSWQpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gUGVyZm9ybSBQYXRod2F5IHN3aXRjaCBvciBSZWR1bmRhbnQgZmFpbG92ZXIgaWYgcG9zc2libGUgZm9yIGZhc3Rlc3QgcmVjb3ZlcnlcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBhbGxvdyBwbGF5bGlzdCByZXRyeSBjb3VudCB0byByZWFjaCBtYXggZXJyb3IgcmV0cmllc1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uKFxuICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICBobHMubG9hZExldmVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5hY3Rpb24gPVxuICAgICAgICAgICAgICBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24uZmxhZ3MgPVxuICAgICAgICAgICAgICBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NUQVRVU19PVVRQVVRfUkVTVFJJQ1RFRDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxldmVsID0gaGxzLmxldmVsc1tobHMubG9hZExldmVsXTtcbiAgICAgICAgICBjb25zdCByZXN0cmljdGVkSGRjcExldmVsID0gbGV2ZWw/LmF0dHJzWydIRENQLUxFVkVMJ107XG4gICAgICAgICAgaWYgKHJlc3RyaWN0ZWRIZGNwTGV2ZWwpIHtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB7XG4gICAgICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gsXG4gICAgICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIRENQLFxuICAgICAgICAgICAgICBoZGNwTGV2ZWw6IHJlc3RyaWN0ZWRIZGNwTGV2ZWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1I6XG4gICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgZGF0YS5sZXZlbCA/PyBobHMubG9hZExldmVsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9TV0lUQ0hfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRTpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTDpcbiAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHtcbiAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5Eb05vdGhpbmcsXG4gICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnR5cGUgPT09IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUikge1xuICAgICAgY29uc3QgbGV2ZWxJbmRleCA9IHRoaXMuZ2V0VmFyaWFudExldmVsSW5kZXgoZGF0YS5mcmFnKTtcbiAgICAgIC8vIERvIG5vdCByZXRyeSBsZXZlbC4gRXNjYWxhdGUgdG8gZmF0YWwgaWYgc3dpdGNoaW5nIGxldmVscyBmYWlscy5cbiAgICAgIGRhdGEubGV2ZWxSZXRyeSA9IGZhbHNlO1xuICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oXG4gICAgZGF0YTogRXJyb3JEYXRhLFxuICAgIGxldmVsSW5kZXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWRcbiAgKTogSUVycm9yQWN0aW9uIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCByZXRyeUNvbmZpZyA9IGdldFJldHJ5Q29uZmlnKGhscy5jb25maWcucGxheWxpc3RMb2FkUG9saWN5LCBkYXRhKTtcbiAgICBjb25zdCByZXRyeUNvdW50ID0gdGhpcy5wbGF5bGlzdEVycm9yKys7XG4gICAgY29uc3QgaHR0cFN0YXR1cyA9IGRhdGEucmVzcG9uc2U/LmNvZGU7XG4gICAgY29uc3QgcmV0cnkgPSBzaG91bGRSZXRyeShcbiAgICAgIHJldHJ5Q29uZmlnLFxuICAgICAgcmV0cnlDb3VudCxcbiAgICAgIGlzVGltZW91dEVycm9yKGRhdGEpLFxuICAgICAgaHR0cFN0YXR1c1xuICAgICk7XG4gICAgaWYgKHJldHJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QsXG4gICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmUsXG4gICAgICAgIHJldHJ5Q29uZmlnLFxuICAgICAgICByZXRyeUNvdW50LFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpO1xuICAgIGlmIChyZXRyeUNvbmZpZykge1xuICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb25maWcgPSByZXRyeUNvbmZpZztcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q291bnQgPSByZXRyeUNvdW50O1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JBY3Rpb247XG4gIH1cblxuICBwcml2YXRlIGdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGE6IEVycm9yRGF0YSk6IElFcnJvckFjdGlvbiB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgLy8gU2hhcmUgZnJhZ21lbnQgZXJyb3IgY291bnQgYWNjcm9zcyBtZWRpYSBvcHRpb25zIChtYWluLCBhdWRpbywgc3VicylcbiAgICAvLyBUaGlzIGFsbG93cyBmb3IgbGV2ZWwgYmFzZWQgcmVuZGl0aW9uIHN3aXRjaGluZyB3aGVuIG1lZGlhIG9wdGlvbiBhc3NldHMgZmFpbFxuICAgIGNvbnN0IHZhcmlhbnRMZXZlbEluZGV4ID0gdGhpcy5nZXRWYXJpYW50TGV2ZWxJbmRleChkYXRhLmZyYWcpO1xuICAgIGNvbnN0IGxldmVsID0gaGxzLmxldmVsc1t2YXJpYW50TGV2ZWxJbmRleF07XG4gICAgY29uc3QgeyBmcmFnTG9hZFBvbGljeSwga2V5TG9hZFBvbGljeSB9ID0gaGxzLmNvbmZpZztcbiAgICBjb25zdCByZXRyeUNvbmZpZyA9IGdldFJldHJ5Q29uZmlnKFxuICAgICAgZGF0YS5kZXRhaWxzLnN0YXJ0c1dpdGgoJ2tleScpID8ga2V5TG9hZFBvbGljeSA6IGZyYWdMb2FkUG9saWN5LFxuICAgICAgZGF0YVxuICAgICk7XG4gICAgY29uc3QgZnJhZ21lbnRFcnJvcnMgPSBobHMubGV2ZWxzLnJlZHVjZShcbiAgICAgIChhY2MsIGxldmVsKSA9PiBhY2MgKyBsZXZlbC5mcmFnbWVudEVycm9yLFxuICAgICAgMFxuICAgICk7XG4gICAgLy8gU3dpdGNoIGxldmVscyB3aGVuIG91dCBvZiByZXRyaWVkIG9yIGxldmVsIGluZGV4IG91dCBvZiBib3VuZHNcbiAgICBpZiAobGV2ZWwpIHtcbiAgICAgIGlmIChkYXRhLmRldGFpbHMgIT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCkge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yKys7XG4gICAgICB9XG4gICAgICBjb25zdCBodHRwU3RhdHVzID0gZGF0YS5yZXNwb25zZT8uY29kZTtcbiAgICAgIGNvbnN0IHJldHJ5ID0gc2hvdWxkUmV0cnkoXG4gICAgICAgIHJldHJ5Q29uZmlnLFxuICAgICAgICBmcmFnbWVudEVycm9ycyxcbiAgICAgICAgaXNUaW1lb3V0RXJyb3IoZGF0YSksXG4gICAgICAgIGh0dHBTdGF0dXNcbiAgICAgICk7XG4gICAgICBpZiAocmV0cnkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QsXG4gICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZSxcbiAgICAgICAgICByZXRyeUNvbmZpZyxcbiAgICAgICAgICByZXRyeUNvdW50OiBmcmFnbWVudEVycm9ycyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVhY2ggbWF4IHJldHJ5IGNvdW50LCBvciBNaXNzaW5nIGxldmVsIHJlZmVyZW5jZVxuICAgIC8vIFN3aXRjaCB0byB2YWxpZCBpbmRleFxuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCB2YXJpYW50TGV2ZWxJbmRleCk7XG4gICAgLy8gQWRkIHJldHJ5IGRldGFpbHMgdG8gYWxsb3cgc2tpcHBpbmcgb2YgRlJBR19QQVJTSU5HX0VSUk9SXG4gICAgaWYgKHJldHJ5Q29uZmlnKSB7XG4gICAgICBlcnJvckFjdGlvbi5yZXRyeUNvbmZpZyA9IHJldHJ5Q29uZmlnO1xuICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb3VudCA9IGZyYWdtZW50RXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JBY3Rpb247XG4gIH1cblxuICBwcml2YXRlIGdldExldmVsU3dpdGNoQWN0aW9uKFxuICAgIGRhdGE6IEVycm9yRGF0YSxcbiAgICBsZXZlbEluZGV4OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkXG4gICk6IElFcnJvckFjdGlvbiB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKGxldmVsSW5kZXggPT09IG51bGwgfHwgbGV2ZWxJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXZlbEluZGV4ID0gaGxzLmxvYWRMZXZlbDtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgaWYgKGxldmVsKSB7XG4gICAgICBsZXZlbC5sb2FkRXJyb3IrKztcbiAgICAgIGlmIChobHMuYXV0b0xldmVsRW5hYmxlZCkge1xuICAgICAgICAvLyBTZWFyY2ggZm9yIG5leHQgbGV2ZWwgdG8gcmV0cnlcbiAgICAgICAgbGV0IG5leHRMZXZlbCA9IC0xO1xuICAgICAgICBjb25zdCBsZXZlbHMgPSBobHMubGV2ZWxzO1xuICAgICAgICBjb25zdCBmcmFnRXJyb3JUeXBlID0gZGF0YS5mcmFnPy50eXBlO1xuICAgICAgICBjb25zdCB7IHR5cGU6IHBsYXlsaXN0RXJyb3JUeXBlLCBncm91cElkOiBwbGF5bGlzdEVycm9yR3JvdXBJZCB9ID1cbiAgICAgICAgICBkYXRhLmNvbnRleHQgPz8ge307XG4gICAgICAgIGZvciAobGV0IGkgPSBsZXZlbHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IChpICsgaGxzLmxvYWRMZXZlbCkgJSBsZXZlbHMubGVuZ3RoO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGNhbmRpZGF0ZSAhPT0gaGxzLmxvYWRMZXZlbCAmJlxuICAgICAgICAgICAgbGV2ZWxzW2NhbmRpZGF0ZV0ubG9hZEVycm9yID09PSAwXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbENhbmRpZGF0ZSA9IGxldmVsc1tjYW5kaWRhdGVdO1xuICAgICAgICAgICAgLy8gU2tpcCBsZXZlbCBzd2l0Y2ggaWYgR0FQIHRhZyBpcyBmb3VuZCBpbiBuZXh0IGxldmVsIGF0IHNhbWUgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCAmJiBkYXRhLmZyYWcpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxzW2NhbmRpZGF0ZV0uZGV0YWlscztcbiAgICAgICAgICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyYWdDYW5kaWRhdGUgPSBmaW5kRnJhZ21lbnRCeVBUUyhcbiAgICAgICAgICAgICAgICAgIGRhdGEuZnJhZyxcbiAgICAgICAgICAgICAgICAgIGxldmVsRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgICAgICAgICAgICBkYXRhLmZyYWcuc3RhcnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChmcmFnQ2FuZGlkYXRlPy5nYXApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgKHBsYXlsaXN0RXJyb3JUeXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmXG4gICAgICAgICAgICAgICAgcGxheWxpc3RFcnJvckdyb3VwSWQgPT09IGxldmVsQ2FuZGlkYXRlLmF1ZGlvR3JvdXBJZCkgfHxcbiAgICAgICAgICAgICAgKHBsYXlsaXN0RXJyb3JUeXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmXG4gICAgICAgICAgICAgICAgcGxheWxpc3RFcnJvckdyb3VwSWQgPT09IGxldmVsQ2FuZGlkYXRlLnRleHRHcm91cElkKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIEZvciBhdWRpby9zdWJzIHBsYXlsaXN0IGVycm9ycyBmaW5kIGFub3RoZXIgZ3JvdXAgSUQgb3IgZmFsbHRocm91Z2ggdG8gcmVkdW5kYW50IGZhaWwtb3ZlclxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIChmcmFnRXJyb3JUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTyAmJlxuICAgICAgICAgICAgICAgIGxldmVsLmF1ZGlvR3JvdXBJZCA9PT0gbGV2ZWxDYW5kaWRhdGUuYXVkaW9Hcm91cElkKSB8fFxuICAgICAgICAgICAgICAoZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUgJiZcbiAgICAgICAgICAgICAgICBsZXZlbC50ZXh0R3JvdXBJZCA9PT0gbGV2ZWxDYW5kaWRhdGUudGV4dEdyb3VwSWQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gRm9yIGF1ZGlvL3N1YnMgZnJhZyBlcnJvcnMgZmluZCBhbm90aGVyIGdyb3VwIElEIG9yIGZhbGx0aHJvdWdoIHRvIHJlZHVuZGFudCBmYWlsLW92ZXJcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0TGV2ZWwgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRMZXZlbCA+IC0xICYmIGhscy5sb2FkTGV2ZWwgIT09IG5leHRMZXZlbCkge1xuICAgICAgICAgIGRhdGEubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmUsXG4gICAgICAgICAgICBuZXh0QXV0b0xldmVsOiBuZXh0TGV2ZWwsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBObyBsZXZlbHMgdG8gc3dpdGNoIC8gTWFudWFsIGxldmVsIHNlbGVjdGlvbiAvIExldmVsIG5vdCBmb3VuZFxuICAgIC8vIFJlc29sdmUgd2l0aCBQYXRod2F5IHN3aXRjaCwgUmVkdW5kYW50IGZhaWwtb3Zlciwgb3Igc3RheSBvbiBsb3dlc3QgTGV2ZWxcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0LFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgb25FcnJvck91dChldmVudDogRXZlbnRzLkVSUk9SLCBkYXRhOiBFcnJvckRhdGEpIHtcbiAgICBzd2l0Y2ggKGRhdGEuZXJyb3JBY3Rpb24/LmFjdGlvbikge1xuICAgICAgY2FzZSBOZXR3b3JrRXJyb3JBY3Rpb24uRG9Ob3RoaW5nOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g6XG4gICAgICAgIHRoaXMuc2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveChkYXRhKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkYXRhLmVycm9yQWN0aW9uLnJlc29sdmVkICYmXG4gICAgICAgICAgZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuRlJBR19HQVBcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3Q6XG4gICAgICAgIC8vIGhhbmRsZWQgYnkgc3RyZWFtIGFuZCBwbGF5bGlzdC9sZXZlbCBjb250cm9sbGVyc1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgdGhpcy5obHMuc3RvcExvYWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YTogRXJyb3JEYXRhKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSBkYXRhLmVycm9yQWN0aW9uO1xuICAgIGlmICghZXJyb3JBY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBmbGFncywgaGRjcExldmVsLCBuZXh0QXV0b0xldmVsIH0gPSBlcnJvckFjdGlvbjtcblxuICAgIHN3aXRjaCAoZmxhZ3MpIHtcbiAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Ob25lOlxuICAgICAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEsIG5leHRBdXRvTGV2ZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEhhbmRsZSBSZWR1bmRhbnQgTGV2ZWxzIGhlcmUuIFBhdGh3YXkgc3dpdGNoaW5nIGlzIGhhbmRsZWQgYnkgY29udGVudC1zdGVlcmluZy1jb250cm9sbGVyXG4gICAgICAgICAgaWYgKCFlcnJvckFjdGlvbi5yZXNvbHZlZCkge1xuICAgICAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0aGlzLnJlZHVuZGFudEZhaWxvdmVyKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUDpcbiAgICAgICAgaWYgKGhkY3BMZXZlbCkge1xuICAgICAgICAgIGhscy5tYXhIZGNwTGV2ZWwgPSBIZGNwTGV2ZWxzW0hkY3BMZXZlbHMuaW5kZXhPZihoZGNwTGV2ZWwpIC0gMV07XG4gICAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICBgUmVzdHJpY3RpbmcgcGxheWJhY2sgdG8gSERDUC1MRVZFTCBvZiBcIiR7aGxzLm1heEhkY3BMZXZlbH1cIiBvciBsb3dlcmBcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIElmIG5vdCByZXNvbHZlZCBieSBwcmV2aW91cyBhY3Rpb25zIHRyeSB0byBzd2l0Y2ggdG8gbmV4dCBsZXZlbFxuICAgIGlmICghZXJyb3JBY3Rpb24ucmVzb2x2ZWQpIHtcbiAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YSwgbmV4dEF1dG9MZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzd2l0Y2hMZXZlbChkYXRhOiBFcnJvckRhdGEsIGxldmVsSW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChsZXZlbEluZGV4ICE9PSB1bmRlZmluZWQgJiYgZGF0YS5lcnJvckFjdGlvbikge1xuICAgICAgdGhpcy53YXJuKGBzd2l0Y2hpbmcgdG8gbGV2ZWwgJHtsZXZlbEluZGV4fSBhZnRlciAke2RhdGEuZGV0YWlsc31gKTtcbiAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBsZXZlbEluZGV4O1xuICAgICAgZGF0YS5lcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAvLyBTdHJlYW0gY29udHJvbGxlciBpcyByZXNwb25zaWJsZSBmb3IgdGhpcyBidXQgd29uJ3Qgc3dpdGNoIG9uIGZhbHNlIHN0YXJ0XG4gICAgICB0aGlzLmhscy5uZXh0TG9hZExldmVsID0gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlZHVuZGFudEZhaWxvdmVyKGRhdGE6IEVycm9yRGF0YSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHsgaGxzLCBwZW5hbGl6ZWRSZW5kaXRpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxldmVsSW5kZXg6IG51bWJlciA9XG4gICAgICBkYXRhLnBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTlxuICAgICAgICA/IChkYXRhLmxldmVsIGFzIG51bWJlcilcbiAgICAgICAgOiBobHMubG9hZExldmVsO1xuICAgIGNvbnN0IGxldmVsID0gaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcbiAgICBjb25zdCByZWR1bmRhbnRMZXZlbHMgPSBsZXZlbC51cmwubGVuZ3RoO1xuICAgIGNvbnN0IGVycm9yVXJsSWQgPSBkYXRhLmZyYWcgPyBkYXRhLmZyYWcudXJsSWQgOiBsZXZlbC51cmxJZDtcbiAgICBpZiAobGV2ZWwudXJsSWQgPT09IGVycm9yVXJsSWQgJiYgKCFkYXRhLmZyYWcgfHwgbGV2ZWwuZGV0YWlscykpIHtcbiAgICAgIHRoaXMucGVuYWxpemVSZW5kaXRpb24obGV2ZWwsIGRhdGEpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJlZHVuZGFudExldmVsczsgaSsrKSB7XG4gICAgICBjb25zdCBuZXdVcmxJZCA9IChlcnJvclVybElkICsgaSkgJSByZWR1bmRhbnRMZXZlbHM7XG4gICAgICBjb25zdCBwZW5hbGl6ZWRSZW5kaXRpb24gPSBwZW5hbGl6ZWRSZW5kaXRpb25zW25ld1VybElkXTtcbiAgICAgIC8vIENoZWNrIGlmIHJlbmRpdGlvbiBpcyBwZW5hbGl6ZWQgYW5kIHNraXAgaWYgaXQgaXMgYSBiYWQgZml0IGZvciBmYWlsb3ZlclxuICAgICAgaWYgKFxuICAgICAgICAhcGVuYWxpemVkUmVuZGl0aW9uIHx8XG4gICAgICAgIGNoZWNrRXhwaXJlZChwZW5hbGl6ZWRSZW5kaXRpb24sIGRhdGEsIHBlbmFsaXplZFJlbmRpdGlvbnNbZXJyb3JVcmxJZF0pXG4gICAgICApIHtcbiAgICAgICAgLy8gZGVsZXRlIHBlbmFsaXplZFJlbmRpdGlvbnNbbmV3VXJsSWRdO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHVybCBpZCBvZiBhbGwgbGV2ZWxzIHNvIHRoYXQgd2Ugc3RheSBvbiB0aGUgc2FtZSBzZXQgb2YgdmFyaWFudHMgd2hlbiBsZXZlbCBzd2l0Y2hpbmdcbiAgICAgICAgdGhpcy53YXJuKFxuICAgICAgICAgIGBTd2l0Y2hpbmcgdG8gUmVkdW5kYW50IFN0cmVhbSAke25ld1VybElkICsgMX0vJHtyZWR1bmRhbnRMZXZlbHN9OiBcIiR7XG4gICAgICAgICAgICBsZXZlbC51cmxbbmV3VXJsSWRdXG4gICAgICAgICAgfVwiIGFmdGVyICR7ZGF0YS5kZXRhaWxzfWBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgICAgICAgaGxzLmxldmVscy5mb3JFYWNoKChsdikgPT4ge1xuICAgICAgICAgIGx2LnVybElkID0gbmV3VXJsSWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsSW5kZXg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIHBlbmFsaXplUmVuZGl0aW9uKGxldmVsOiBMZXZlbCwgZGF0YTogRXJyb3JEYXRhKSB7XG4gICAgY29uc3QgeyBwZW5hbGl6ZWRSZW5kaXRpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBlbmFsaXplZFJlbmRpdGlvbiA9IHBlbmFsaXplZFJlbmRpdGlvbnNbbGV2ZWwudXJsSWRdIHx8IHtcbiAgICAgIGxhc3RFcnJvclBlcmZNczogMCxcbiAgICAgIGVycm9yczogW10sXG4gICAgICBkZXRhaWxzOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBwZW5hbGl6ZWRSZW5kaXRpb24ubGFzdEVycm9yUGVyZk1zID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgcGVuYWxpemVkUmVuZGl0aW9uLmVycm9ycy5wdXNoKGRhdGEpO1xuICAgIHBlbmFsaXplZFJlbmRpdGlvbi5kZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICBwZW5hbGl6ZWRSZW5kaXRpb25zW2xldmVsLnVybElkXSA9IHBlbmFsaXplZFJlbmRpdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cGlyZWQoXG4gIHBlbmFsaXplZFJlbmRpdGlvbjogUGVuYWxpemVkUmVuZGl0aW9uLFxuICBkYXRhOiBFcnJvckRhdGEsXG4gIGN1cnJlbnRQZW5hbHR5U3RhdGU6IFBlbmFsaXplZFJlbmRpdGlvbiB8IHVuZGVmaW5lZFxuKTogYm9vbGVhbiB7XG4gIC8vIEV4cGlyZSBwZW5hbHR5IGZvciBzd2l0Y2hpbmcgYmFjayB0byByZW5kaXRpb24gYWZ0ZXIgUkVORElUSU9OX1BFTkFMVFlfRFVSQVRJT05fTVNcbiAgaWYgKFxuICAgIHBlcmZvcm1hbmNlLm5vdygpIC0gcGVuYWxpemVkUmVuZGl0aW9uLmxhc3RFcnJvclBlcmZNcyA+XG4gICAgUkVORElUSU9OX1BFTkFMVFlfRFVSQVRJT05fTVNcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gRXhwaXJlIHBlbmFsdHkgb24gR0FQIHRhZyBlcnJvciBpZiByZW5kaXRpb24gaGFzIG5vIEdBUCBhdCBwb3NpdGlvbiAoZG9lcyBub3QgY292ZXIgbWVkaWEgdHJhY2tzKVxuICBjb25zdCBsYXN0RXJyb3JEZXRhaWxzID0gcGVuYWxpemVkUmVuZGl0aW9uLmRldGFpbHM7XG4gIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCAmJiBsYXN0RXJyb3JEZXRhaWxzICYmIGRhdGEuZnJhZykge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZGF0YS5mcmFnLnN0YXJ0O1xuICAgIGNvbnN0IGNhbmRpZGF0ZUZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhcbiAgICAgIG51bGwsXG4gICAgICBsYXN0RXJyb3JEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgIHBvc2l0aW9uXG4gICAgKTtcbiAgICBpZiAoY2FuZGlkYXRlRnJhZyAmJiAhY2FuZGlkYXRlRnJhZy5nYXApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBFeHBpcmUgcGVuYWx0eSBpZiB0aGVyZSBhcmUgbW9yZSBlcnJvcnMgaW4gY3VycmVudExldmVsIHRoYW4gaW4gcGVuYWxpemVkUmVuZGl0aW9uXG4gIGlmIChcbiAgICBjdXJyZW50UGVuYWx0eVN0YXRlICYmXG4gICAgcGVuYWxpemVkUmVuZGl0aW9uLmVycm9ycy5sZW5ndGggPCBjdXJyZW50UGVuYWx0eVN0YXRlLmVycm9ycy5sZW5ndGhcbiAgKSB7XG4gICAgY29uc3QgbGFzdENhbmRpZGF0ZUVycm9yID1cbiAgICAgIHBlbmFsaXplZFJlbmRpdGlvbi5lcnJvcnNbcGVuYWxpemVkUmVuZGl0aW9uLmVycm9ycy5sZW5ndGggLSAxXTtcbiAgICBpZiAoXG4gICAgICBsYXN0RXJyb3JEZXRhaWxzICYmXG4gICAgICBsYXN0Q2FuZGlkYXRlRXJyb3IuZnJhZyAmJlxuICAgICAgZGF0YS5mcmFnICYmXG4gICAgICBNYXRoLmFicyhsYXN0Q2FuZGlkYXRlRXJyb3IuZnJhZy5zdGFydCAtIGRhdGEuZnJhZy5zdGFydCkgPlxuICAgICAgICBsYXN0RXJyb3JEZXRhaWxzLnRhcmdldGR1cmF0aW9uICogM1xuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuaW1wb3J0IHR5cGUgeyBOZXR3b3JrQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgeyBnZXRTa2lwVmFsdWUsIEhsc1NraXAsIEhsc1VybFBhcmFtZXRlcnMsIExldmVsIH0gZnJvbSAnLi4vdHlwZXMvbGV2ZWwnO1xuaW1wb3J0IHsgY29tcHV0ZVJlbG9hZEludGVydmFsLCBtZXJnZURldGFpbHMgfSBmcm9tICcuL2xldmVsLWhlbHBlcic7XG5pbXBvcnQgeyBFcnJvckRhdGEgfSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHsgZ2V0UmV0cnlEZWxheSwgaXNUaW1lb3V0RXJyb3IgfSBmcm9tICcuLi91dGlscy9lcnJvci1oZWxwZXInO1xuaW1wb3J0IHsgTmV0d29ya0Vycm9yQWN0aW9uIH0gZnJvbSAnLi9lcnJvci1jb250cm9sbGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSB7IExldmVsRGV0YWlscyB9IGZyb20gJy4uL2xvYWRlci9sZXZlbC1kZXRhaWxzJztcbmltcG9ydCB0eXBlIHsgTWVkaWFQbGF5bGlzdCB9IGZyb20gJy4uL3R5cGVzL21lZGlhLXBsYXlsaXN0JztcbmltcG9ydCB0eXBlIHtcbiAgQXVkaW9UcmFja0xvYWRlZERhdGEsXG4gIExldmVsTG9hZGVkRGF0YSxcbiAgVHJhY2tMb2FkZWREYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlUGxheWxpc3RDb250cm9sbGVyIGltcGxlbWVudHMgTmV0d29ya0NvbXBvbmVudEFQSSB7XG4gIHByb3RlY3RlZCBobHM6IEhscztcbiAgcHJvdGVjdGVkIHRpbWVyOiBudW1iZXIgPSAtMTtcbiAgcHJvdGVjdGVkIHJlcXVlc3RTY2hlZHVsZWQ6IG51bWJlciA9IC0xO1xuICBwcm90ZWN0ZWQgY2FuTG9hZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgbG9nOiAobXNnOiBhbnkpID0+IHZvaWQ7XG4gIHByb3RlY3RlZCB3YXJuOiAobXNnOiBhbnkpID0+IHZvaWQ7XG5cbiAgY29uc3RydWN0b3IoaGxzOiBIbHMsIGxvZ1ByZWZpeDogc3RyaW5nKSB7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBgJHtsb2dQcmVmaXh9OmApO1xuICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBgJHtsb2dQcmVmaXh9OmApO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5sb2cgPSB0aGlzLndhcm4gPSBudWxsO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNsZWFyVGltZXIoKTogdm9pZCB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgfVxuXG4gIHB1YmxpYyBzdGFydExvYWQoKTogdm9pZCB7XG4gICAgdGhpcy5jYW5Mb2FkID0gdHJ1ZTtcbiAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICB9XG5cbiAgcHVibGljIHN0b3BMb2FkKCk6IHZvaWQge1xuICAgIHRoaXMuY2FuTG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN3aXRjaFBhcmFtcyhcbiAgICBwbGF5bGlzdFVyaTogc3RyaW5nLFxuICAgIHByZXZpb3VzOiBMZXZlbERldGFpbHMgfCB1bmRlZmluZWRcbiAgKTogSGxzVXJsUGFyYW1ldGVycyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcmVuZGl0aW9uUmVwb3J0cyA9IHByZXZpb3VzPy5yZW5kaXRpb25SZXBvcnRzO1xuICAgIGlmIChyZW5kaXRpb25SZXBvcnRzKSB7XG4gICAgICBsZXQgZm91bmRJbmRleCA9IC0xO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kaXRpb25SZXBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ldO1xuICAgICAgICBsZXQgdXJpOiBzdHJpbmc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJpID0gbmV3IHNlbGYuVVJMKGF0dHIuVVJJLCBwcmV2aW91cy51cmwpLmhyZWY7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIGZvciBSZW5kaXRpb24gUmVwb3J0OiAke2Vycm9yfWBcbiAgICAgICAgICApO1xuICAgICAgICAgIHVyaSA9IGF0dHIuVVJJIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBleGFjdCBtYXRjaC4gT3RoZXJ3aXNlLCB0aGUgbGFzdCBwYXJ0aWFsIG1hdGNoLCBpZiBhbnksIHdpbGwgYmUgdXNlZFxuICAgICAgICAvLyAoUGxheWxpc3QgVVJJIGluY2x1ZGVzIGEgcXVlcnkgc3RyaW5nIHRoYXQgdGhlIFJlbmRpdGlvbiBSZXBvcnQgZG9lcyBub3QpXG4gICAgICAgIGlmICh1cmkgPT09IHBsYXlsaXN0VXJpKSB7XG4gICAgICAgICAgZm91bmRJbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodXJpID09PSBwbGF5bGlzdFVyaS5zdWJzdHJpbmcoMCwgdXJpLmxlbmd0aCkpIHtcbiAgICAgICAgICBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ZvdW5kSW5kZXhdO1xuICAgICAgICBjb25zdCBtc24gPSBwYXJzZUludChhdHRyWydMQVNULU1TTiddKSB8fCBwcmV2aW91cz8ubGFzdFBhcnRTbjtcbiAgICAgICAgbGV0IHBhcnQgPSBwYXJzZUludChhdHRyWydMQVNULVBBUlQnXSkgfHwgcHJldmlvdXM/Lmxhc3RQYXJ0SW5kZXg7XG4gICAgICAgIGlmICh0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGUpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50R29hbCA9IE1hdGgubWluKFxuICAgICAgICAgICAgcHJldmlvdXMuYWdlIC0gcHJldmlvdXMucGFydFRhcmdldCxcbiAgICAgICAgICAgIHByZXZpb3VzLnRhcmdldGR1cmF0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAocGFydCA+PSAwICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXMucGFydFRhcmdldCkge1xuICAgICAgICAgICAgcGFydCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhsc1VybFBhcmFtZXRlcnMoXG4gICAgICAgICAgbXNuLFxuICAgICAgICAgIHBhcnQgPj0gMCA/IHBhcnQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgSGxzU2tpcC5Ob1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycz86IEhsc1VybFBhcmFtZXRlcnMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSkge1xuICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gICAgLy8gTG9hZGluZyBpcyBoYW5kbGVkIGJ5IHRoZSBzdWJjbGFzc2VzXG4gIH1cblxuICBwcm90ZWN0ZWQgc2hvdWxkTG9hZFBsYXlsaXN0KFxuICAgIHBsYXlsaXN0OiBMZXZlbCB8IE1lZGlhUGxheWxpc3QgfCBudWxsIHwgdW5kZWZpbmVkXG4gICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmNhbkxvYWQgJiZcbiAgICAgICEhcGxheWxpc3QgJiZcbiAgICAgICEhcGxheWxpc3QudXJsICYmXG4gICAgICAoIXBsYXlsaXN0LmRldGFpbHMgfHwgcGxheWxpc3QuZGV0YWlscy5saXZlKVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2hvdWxkUmVsb2FkUGxheWxpc3QoXG4gICAgcGxheWxpc3Q6IExldmVsIHwgTWVkaWFQbGF5bGlzdCB8IG51bGwgfCB1bmRlZmluZWRcbiAgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMudGltZXIgPT09IC0xICYmXG4gICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPT09IC0xICYmXG4gICAgICB0aGlzLnNob3VsZExvYWRQbGF5bGlzdChwbGF5bGlzdClcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIHBsYXlsaXN0TG9hZGVkKFxuICAgIGluZGV4OiBudW1iZXIsXG4gICAgZGF0YTogTGV2ZWxMb2FkZWREYXRhIHwgQXVkaW9UcmFja0xvYWRlZERhdGEgfCBUcmFja0xvYWRlZERhdGEsXG4gICAgcHJldmlvdXNEZXRhaWxzPzogTGV2ZWxEZXRhaWxzXG4gICkge1xuICAgIGNvbnN0IHsgZGV0YWlscywgc3RhdHMgfSA9IGRhdGE7XG5cbiAgICAvLyBTZXQgbGFzdCB1cGRhdGVkIGRhdGUtdGltZVxuICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZCA9IHN0YXRzLmxvYWRpbmcuZmlyc3RcbiAgICAgID8gTWF0aC5tYXgoMCwgbm93IC0gc3RhdHMubG9hZGluZy5maXJzdClcbiAgICAgIDogMDtcbiAgICBkZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWUgPSBEYXRlLm5vdygpIC0gZWxhcHNlZDtcblxuICAgIC8vIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0LCBhcm0gYSB0aW1lciB0byByZWxvYWQgaXRcbiAgICBpZiAoZGV0YWlscy5saXZlIHx8IHByZXZpb3VzRGV0YWlscz8ubGl2ZSkge1xuICAgICAgZGV0YWlscy5yZWxvYWRlZChwcmV2aW91c0RldGFpbHMpO1xuICAgICAgaWYgKHByZXZpb3VzRGV0YWlscykge1xuICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICBgbGl2ZSBwbGF5bGlzdCAke2luZGV4fSAke1xuICAgICAgICAgICAgZGV0YWlscy5hZHZhbmNlZFxuICAgICAgICAgICAgICA/ICdSRUZSRVNIRUQgJyArIGRldGFpbHMubGFzdFBhcnRTbiArICctJyArIGRldGFpbHMubGFzdFBhcnRJbmRleFxuICAgICAgICAgICAgICA6ICdNSVNTRUQnXG4gICAgICAgICAgfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIGxpdmUgcGxheWxpc3RzIHRvIGFkanVzdCBmcmFnbWVudCBzdGFydHMgYW5kIGZpbGwgaW4gZGVsdGEgcGxheWxpc3Qgc2tpcHBlZCBzZWdtZW50c1xuICAgICAgaWYgKHByZXZpb3VzRGV0YWlscyAmJiBkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1lcmdlRGV0YWlscyhwcmV2aW91c0RldGFpbHMsIGRldGFpbHMpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNhbkxvYWQgfHwgIWRldGFpbHMubGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZGVsaXZlcnlEaXJlY3RpdmVzOiBIbHNVcmxQYXJhbWV0ZXJzIHwgdW5kZWZpbmVkO1xuICAgICAgbGV0IG1zbjogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgbGV0IHBhcnQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChkZXRhaWxzLmNhbkJsb2NrUmVsb2FkICYmIGRldGFpbHMuZW5kU04gJiYgZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgICAvLyBMb2FkIGxldmVsIHdpdGggTEwtSExTIGRlbGl2ZXJ5IGRpcmVjdGl2ZXNcbiAgICAgICAgY29uc3QgbG93TGF0ZW5jeU1vZGUgPSB0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGU7XG4gICAgICAgIGNvbnN0IGxhc3RQYXJ0U24gPSBkZXRhaWxzLmxhc3RQYXJ0U247XG4gICAgICAgIGNvbnN0IGVuZFNuID0gZGV0YWlscy5lbmRTTjtcbiAgICAgICAgY29uc3QgbGFzdFBhcnRJbmRleCA9IGRldGFpbHMubGFzdFBhcnRJbmRleDtcbiAgICAgICAgY29uc3QgaGFzUGFydHMgPSBsYXN0UGFydEluZGV4ICE9PSAtMTtcbiAgICAgICAgY29uc3QgbGFzdFBhcnQgPSBsYXN0UGFydFNuID09PSBlbmRTbjtcbiAgICAgICAgLy8gV2hlbiBsb3cgbGF0ZW5jeSBtb2RlIGlzIGRpc2FibGVkLCB3ZSdsbCBza2lwIHBhcnQgcmVxdWVzdHMgb25jZSB0aGUgbGFzdCBwYXJ0IGluZGV4IGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IG5leHRTblN0YXJ0SW5kZXggPSBsb3dMYXRlbmN5TW9kZSA/IDAgOiBsYXN0UGFydEluZGV4O1xuICAgICAgICBpZiAoaGFzUGFydHMpIHtcbiAgICAgICAgICBtc24gPSBsYXN0UGFydCA/IGVuZFNuICsgMSA6IGxhc3RQYXJ0U247XG4gICAgICAgICAgcGFydCA9IGxhc3RQYXJ0ID8gbmV4dFNuU3RhcnRJbmRleCA6IGxhc3RQYXJ0SW5kZXggKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1zbiA9IGVuZFNuICsgMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbjogXCJhZ2VcIiBoZWFkZXIgYW5kIHRpbWUgc2luY2UgbG9hZCBpbmRpY2F0ZXMgd2UncmUgYmVoaW5kIGJ5IG1vcmUgdGhhbiBvbmUgcGFydFxuICAgICAgICAvLyBVcGRhdGUgZGlyZWN0aXZlcyB0byBvYnRhaW4gdGhlIFBsYXlsaXN0IHRoYXQgaGFzIHRoZSBlc3RpbWF0ZWQgYWRkaXRpb25hbCBkdXJhdGlvbiBvZiBtZWRpYVxuICAgICAgICBjb25zdCBsYXN0QWR2YW5jZWQgPSBkZXRhaWxzLmFnZTtcbiAgICAgICAgY29uc3QgY2RuQWdlID0gbGFzdEFkdmFuY2VkICsgZGV0YWlscy5hZ2VIZWFkZXI7XG4gICAgICAgIGxldCBjdXJyZW50R29hbCA9IE1hdGgubWluKFxuICAgICAgICAgIGNkbkFnZSAtIGRldGFpbHMucGFydFRhcmdldCxcbiAgICAgICAgICBkZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMS41XG4gICAgICAgICk7XG4gICAgICAgIGlmIChjdXJyZW50R29hbCA+IDApIHtcbiAgICAgICAgICBpZiAocHJldmlvdXNEZXRhaWxzICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXNEZXRhaWxzLnR1bmVJbkdvYWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGF0dGVtcHRlZCB0byBnZXQgdGhlIG5leHQgb3IgbGF0ZXN0IHBsYXlsaXN0IHVwZGF0ZSwgYnV0IGN1cnJlbnRHb2FsIGluY3JlYXNlZCxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgZWl0aGVyIGNhbid0IGNhdGNodXAsIG9yIHRoZSBcImFnZVwiIGhlYWRlciBjYW5ub3QgYmUgdHJ1c3RlZC5cbiAgICAgICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICAgICAgYENETiBUdW5lLWluIGdvYWwgaW5jcmVhc2VkIGZyb206ICR7cHJldmlvdXNEZXRhaWxzLnR1bmVJbkdvYWx9IHRvOiAke2N1cnJlbnRHb2FsfSB3aXRoIHBsYXlsaXN0IGFnZTogJHtkZXRhaWxzLmFnZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3VycmVudEdvYWwgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IE1hdGguZmxvb3IoY3VycmVudEdvYWwgLyBkZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgICAgICAgIG1zbiArPSBzZWdtZW50cztcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgIChjdXJyZW50R29hbCAlIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24pIC8gZGV0YWlscy5wYXJ0VGFyZ2V0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHBhcnQgKz0gcGFydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICAgICAgYENETiBUdW5lLWluIGFnZTogJHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzLmFnZUhlYWRlclxuICAgICAgICAgICAgICB9cyBsYXN0IGFkdmFuY2VkICR7bGFzdEFkdmFuY2VkLnRvRml4ZWQoXG4gICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICApfXMgZ29hbDogJHtjdXJyZW50R29hbH0gc2tpcCBzbiAke3NlZ21lbnRzfSB0byBwYXJ0ICR7cGFydH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXRhaWxzLnR1bmVJbkdvYWwgPSBjdXJyZW50R29hbDtcbiAgICAgICAgfVxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSB0aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhcbiAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICAgIGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgICAgIG1zbixcbiAgICAgICAgICBwYXJ0XG4gICAgICAgICk7XG4gICAgICAgIGlmIChsb3dMYXRlbmN5TW9kZSB8fCAhbGFzdFBhcnQpIHtcbiAgICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdChkZWxpdmVyeURpcmVjdGl2ZXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmNhbkJsb2NrUmVsb2FkKSB7XG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IHRoaXMuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKFxuICAgICAgICAgIGRldGFpbHMsXG4gICAgICAgICAgZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgICAgICAgbXNuLFxuICAgICAgICAgIHBhcnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmVuZCAtIGJ1ZmZlckluZm8ubGVuIDogMDtcbiAgICAgIGNvbnN0IGRpc3RhbmNlVG9MaXZlRWRnZU1zID0gKGRldGFpbHMuZWRnZSAtIHBvc2l0aW9uKSAqIDEwMDA7XG4gICAgICBjb25zdCByZWxvYWRJbnRlcnZhbCA9IGNvbXB1dGVSZWxvYWRJbnRlcnZhbChcbiAgICAgICAgZGV0YWlscyxcbiAgICAgICAgZGlzdGFuY2VUb0xpdmVFZGdlTXNcbiAgICAgICk7XG4gICAgICBpZiAoZGV0YWlscy51cGRhdGVkICYmIG5vdyA+IHRoaXMucmVxdWVzdFNjaGVkdWxlZCArIHJlbG9hZEludGVydmFsKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChtc24gIT09IHVuZGVmaW5lZCAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9XG4gICAgICAgICAgc3RhdHMubG9hZGluZy5maXJzdCArXG4gICAgICAgICAgcmVsb2FkSW50ZXJ2YWwgLVxuICAgICAgICAgIChkZXRhaWxzLnBhcnRUYXJnZXQgKiAxMDAwIHx8IDEwMDApO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSB8fFxuICAgICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgKyByZWxvYWRJbnRlcnZhbCA8IG5vd1xuICAgICAgKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IG5vdztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXF1ZXN0U2NoZWR1bGVkIC0gbm93IDw9IDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkICs9IHJlbG9hZEludGVydmFsO1xuICAgICAgfVxuICAgICAgbGV0IGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSA9IHRoaXMucmVxdWVzdFNjaGVkdWxlZCAtIG5vdztcbiAgICAgIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSA9IE1hdGgubWF4KDAsIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSk7XG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgYHJlbG9hZCBsaXZlIHBsYXlsaXN0ICR7aW5kZXh9IGluICR7TWF0aC5yb3VuZChcbiAgICAgICAgICBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGVcbiAgICAgICAgKX0gbXNgXG4gICAgICApO1xuICAgICAgLy8gdGhpcy5sb2coXG4gICAgICAvLyAgIGBsaXZlIHJlbG9hZCAke2RldGFpbHMudXBkYXRlZCA/ICdSRUZSRVNIRUQnIDogJ01JU1NFRCd9XG4gICAgICAvLyByZWxvYWQgaW4gJHtlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgLyAxMDAwfVxuICAgICAgLy8gcm91bmQgdHJpcCAkeyhzdGF0cy5sb2FkaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQpIC8gMTAwMH1cbiAgICAgIC8vIGRpZmYgJHtcbiAgICAgIC8vICAgKHJlbG9hZEludGVydmFsIC1cbiAgICAgIC8vICAgICAoZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlICtcbiAgICAgIC8vICAgICAgIHN0YXRzLmxvYWRpbmcuZW5kIC1cbiAgICAgIC8vICAgICAgIHN0YXRzLmxvYWRpbmcuc3RhcnQpKSAvXG4gICAgICAvLyAgIDEwMDBcbiAgICAgIC8vIH1cbiAgICAgIC8vIHJlbG9hZCBpbnRlcnZhbCAke3JlbG9hZEludGVydmFsIC8gMTAwMH1cbiAgICAgIC8vIHRhcmdldCBkdXJhdGlvbiAke2RldGFpbHMudGFyZ2V0ZHVyYXRpb259XG4gICAgICAvLyBkaXN0YW5jZSB0byBlZGdlICR7ZGlzdGFuY2VUb0xpdmVFZGdlTXMgLyAxMDAwfWBcbiAgICAgIC8vICk7XG5cbiAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldFRpbWVvdXQoXG4gICAgICAgICgpID0+IHRoaXMubG9hZFBsYXlsaXN0KGRlbGl2ZXJ5RGlyZWN0aXZlcyksXG4gICAgICAgIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXREZWxpdmVyeURpcmVjdGl2ZXMoXG4gICAgZGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICAgIHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzOiBIbHNVcmxQYXJhbWV0ZXJzIHwgbnVsbCxcbiAgICBtc24/OiBudW1iZXIsXG4gICAgcGFydD86IG51bWJlclxuICApOiBIbHNVcmxQYXJhbWV0ZXJzIHtcbiAgICBsZXQgc2tpcCA9IGdldFNraXBWYWx1ZShkZXRhaWxzLCBtc24pO1xuICAgIGlmIChwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcz8uc2tpcCAmJiBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICBtc24gPSBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcy5tc247XG4gICAgICBwYXJ0ID0gcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMucGFydDtcbiAgICAgIHNraXAgPSBIbHNTa2lwLk5vO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhsc1VybFBhcmFtZXRlcnMobXNuLCBwYXJ0LCBza2lwKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja1JldHJ5KGVycm9yRXZlbnQ6IEVycm9yRGF0YSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGVycm9yRGV0YWlscyA9IGVycm9yRXZlbnQuZGV0YWlscztcbiAgICBjb25zdCBpc1RpbWVvdXQgPSBpc1RpbWVvdXRFcnJvcihlcnJvckV2ZW50KTtcbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IGVycm9yRXZlbnQuZXJyb3JBY3Rpb247XG4gICAgY29uc3QgeyBhY3Rpb24sIHJldHJ5Q291bnQgPSAwLCByZXRyeUNvbmZpZyB9ID0gZXJyb3JBY3Rpb24gfHwge307XG4gICAgY29uc3QgcmV0cnkgPVxuICAgICAgISFlcnJvckFjdGlvbiAmJlxuICAgICAgISFyZXRyeUNvbmZpZyAmJlxuICAgICAgKGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdCB8fFxuICAgICAgICAoIWVycm9yQWN0aW9uLnJlc29sdmVkICYmXG4gICAgICAgICAgYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCkpO1xuICAgIGlmIChyZXRyeSkge1xuICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTE7XG4gICAgICBpZiAocmV0cnlDb3VudCA+PSByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNUaW1lb3V0ICYmIGVycm9yRXZlbnQuY29udGV4dD8uZGVsaXZlcnlEaXJlY3RpdmVzKSB7XG4gICAgICAgIC8vIFRoZSBMTC1ITFMgcmVxdWVzdCBhbHJlYWR5IHRpbWVkIG91dCBzbyByZXRyeSBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgYFJldHJ5aW5nIHBsYXlsaXN0IGxvYWRpbmcgJHtyZXRyeUNvdW50ICsgMX0vJHtcbiAgICAgICAgICAgIHJldHJ5Q29uZmlnLm1heE51bVJldHJ5XG4gICAgICAgICAgfSBhZnRlciBcIiR7ZXJyb3JEZXRhaWxzfVwiIHdpdGhvdXQgZGVsaXZlcnktZGlyZWN0aXZlc2BcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5sb2FkUGxheWxpc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCk7XG4gICAgICAgIC8vIFNjaGVkdWxlIGxldmVsL3RyYWNrIHJlbG9hZFxuICAgICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHRoaXMubG9hZFBsYXlsaXN0KCksIGRlbGF5KTtcbiAgICAgICAgdGhpcy53YXJuKFxuICAgICAgICAgIGBSZXRyeWluZyBwbGF5bGlzdCBsb2FkaW5nICR7cmV0cnlDb3VudCArIDF9LyR7XG4gICAgICAgICAgICByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeVxuICAgICAgICAgIH0gYWZ0ZXIgXCIke2Vycm9yRGV0YWlsc31cIiBpbiAke2RlbGF5fW1zYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gYGxldmVsUmV0cnkgPSB0cnVlYCB1c2VkIHRvIGluZm9ybSBvdGhlciBjb250cm9sbGVycyB0aGF0IGEgcmV0cnkgaXMgaGFwcGVuaW5nXG4gICAgICBlcnJvckV2ZW50LmxldmVsUmV0cnkgPSB0cnVlO1xuICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0cnk7XG4gIH1cbn1cbiIsIi8qXG4gKiBMZXZlbCBDb250cm9sbGVyXG4gKi9cblxuaW1wb3J0IHtcbiAgTWFuaWZlc3RMb2FkZWREYXRhLFxuICBNYW5pZmVzdFBhcnNlZERhdGEsXG4gIExldmVsTG9hZGVkRGF0YSxcbiAgVHJhY2tTd2l0Y2hlZERhdGEsXG4gIEZyYWdMb2FkZWREYXRhLFxuICBFcnJvckRhdGEsXG4gIExldmVsU3dpdGNoaW5nRGF0YSxcbiAgTGV2ZWxzVXBkYXRlZERhdGEsXG4gIE1hbmlmZXN0TG9hZGluZ0RhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgeyBMZXZlbCB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgaXNDb2RlY1N1cHBvcnRlZEluTXA0IH0gZnJvbSAnLi4vdXRpbHMvY29kZWNzJztcbmltcG9ydCBCYXNlUGxheWxpc3RDb250cm9sbGVyIGZyb20gJy4vYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyJztcbmltcG9ydCB7IFBsYXlsaXN0Q29udGV4dFR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuaW1wb3J0IHR5cGUgeyBIbHNVcmxQYXJhbWV0ZXJzLCBMZXZlbFBhcnNlZCB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB0eXBlIHsgTWVkaWFQbGF5bGlzdCB9IGZyb20gJy4uL3R5cGVzL21lZGlhLXBsYXlsaXN0JztcbmltcG9ydCBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyIGZyb20gJy4vY29udGVudC1zdGVlcmluZy1jb250cm9sbGVyJztcblxubGV0IGNocm9tZU9yRmlyZWZveDogYm9vbGVhbjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgQmFzZVBsYXlsaXN0Q29udHJvbGxlciB7XG4gIHByaXZhdGUgX2xldmVsczogTGV2ZWxbXSA9IFtdO1xuICBwcml2YXRlIF9maXJzdExldmVsOiBudW1iZXIgPSAtMTtcbiAgcHJpdmF0ZSBfc3RhcnRMZXZlbD86IG51bWJlcjtcbiAgcHJpdmF0ZSBjdXJyZW50TGV2ZWw6IExldmVsIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY3VycmVudExldmVsSW5kZXg6IG51bWJlciA9IC0xO1xuICBwcml2YXRlIG1hbnVhbExldmVsSW5kZXg6IG51bWJlciA9IC0xO1xuICBwcml2YXRlIHN0ZWVyaW5nOiBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyIHwgbnVsbDtcblxuICBwdWJsaWMgb25QYXJzZWRDb21wbGV0ZSE6IEZ1bmN0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGhsczogSGxzLFxuICAgIGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI6IENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgfCBudWxsXG4gICkge1xuICAgIHN1cGVyKGhscywgJ1tsZXZlbC1jb250cm9sbGVyXScpO1xuICAgIHRoaXMuc3RlZXJpbmcgPSBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyO1xuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuc3RlZXJpbmcgPSBudWxsO1xuICAgIHRoaXMucmVzZXRMZXZlbHMoKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnRMb2FkKCk6IHZvaWQge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscztcblxuICAgIC8vIGNsZWFuIHVwIGxpdmUgbGV2ZWwgZGV0YWlscyB0byBmb3JjZSByZWxvYWQgdGhlbSwgYW5kIHJlc2V0IGxvYWQgZXJyb3JzXG4gICAgbGV2ZWxzLmZvckVhY2goKGxldmVsKSA9PiB7XG4gICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgfSk7XG5cbiAgICBzdXBlci5zdGFydExvYWQoKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXRMZXZlbHMoKSB7XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgIHRoaXMuX2xldmVscyA9IFtdO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0TG9hZGluZyhcbiAgICBldmVudDogRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsXG4gICAgZGF0YTogTWFuaWZlc3RMb2FkaW5nRGF0YVxuICApIHtcbiAgICB0aGlzLnJlc2V0TGV2ZWxzKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NYW5pZmVzdExvYWRlZChcbiAgICBldmVudDogRXZlbnRzLk1BTklGRVNUX0xPQURFRCxcbiAgICBkYXRhOiBNYW5pZmVzdExvYWRlZERhdGFcbiAgKSB7XG4gICAgY29uc3QgbGV2ZWxzOiBMZXZlbFtdID0gW107XG4gICAgY29uc3QgbGV2ZWxTZXQ6IHsgW2tleTogc3RyaW5nXTogTGV2ZWwgfSA9IHt9O1xuICAgIGxldCBsZXZlbEZyb21TZXQ6IExldmVsO1xuXG4gICAgLy8gcmVncm91cCByZWR1bmRhbnQgbGV2ZWxzIHRvZ2V0aGVyXG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaCgobGV2ZWxQYXJzZWQ6IExldmVsUGFyc2VkKSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbGV2ZWxQYXJzZWQuYXR0cnM7XG5cbiAgICAgIC8vIGVyYXNlIGF1ZGlvIGNvZGVjIGluZm8gaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1wNGEuNDAuMzQuXG4gICAgICAvLyBkZW11eGVyIHdpbGwgYXV0b2RldGVjdCBjb2RlYyBhbmQgZmFsbGJhY2sgdG8gbXBlZy9hdWRpb1xuICAgICAgaWYgKGxldmVsUGFyc2VkLmF1ZGlvQ29kZWM/LmluZGV4T2YoJ21wNGEuNDAuMzQnKSAhPT0gLTEpIHtcbiAgICAgICAgY2hyb21lT3JGaXJlZm94IHx8PSAvY2hyb21lfGZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICBpZiAoY2hyb21lT3JGaXJlZm94KSB7XG4gICAgICAgICAgbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIEFVRElPLFxuICAgICAgICBDT0RFQ1MsXG4gICAgICAgICdGUkFNRS1SQVRFJzogRlJBTUVSQVRFLFxuICAgICAgICAnUEFUSFdBWS1JRCc6IFBBVEhXQVksXG4gICAgICAgIFJFU09MVVRJT04sXG4gICAgICAgIFNVQlRJVExFUyxcbiAgICAgIH0gPSBhdHRyaWJ1dGVzO1xuICAgICAgY29uc3QgY29udGVudFN0ZWVyaW5nUHJlZml4ID0gX19VU0VfQ09OVEVOVF9TVEVFUklOR19fXG4gICAgICAgID8gYCR7UEFUSFdBWSB8fCAnLid9LWBcbiAgICAgICAgOiAnJztcbiAgICAgIGNvbnN0IGxldmVsS2V5ID0gYCR7Y29udGVudFN0ZWVyaW5nUHJlZml4fSR7bGV2ZWxQYXJzZWQuYml0cmF0ZX0tJHtSRVNPTFVUSU9OfS0ke0ZSQU1FUkFURX0tJHtDT0RFQ1N9YDtcbiAgICAgIGxldmVsRnJvbVNldCA9IGxldmVsU2V0W2xldmVsS2V5XTtcblxuICAgICAgaWYgKCFsZXZlbEZyb21TZXQpIHtcbiAgICAgICAgbGV2ZWxGcm9tU2V0ID0gbmV3IExldmVsKGxldmVsUGFyc2VkKTtcbiAgICAgICAgbGV2ZWxTZXRbbGV2ZWxLZXldID0gbGV2ZWxGcm9tU2V0O1xuICAgICAgICBsZXZlbHMucHVzaChsZXZlbEZyb21TZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxGcm9tU2V0LmFkZEZhbGxiYWNrKGxldmVsUGFyc2VkKTtcbiAgICAgIH1cblxuICAgICAgYWRkR3JvdXBJZChsZXZlbEZyb21TZXQsICdhdWRpbycsIEFVRElPKTtcbiAgICAgIGFkZEdyb3VwSWQobGV2ZWxGcm9tU2V0LCAndGV4dCcsIFNVQlRJVExFUyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMobGV2ZWxzLCBkYXRhKTtcbiAgfVxuXG4gIHByaXZhdGUgZmlsdGVyQW5kU29ydE1lZGlhT3B0aW9ucyhcbiAgICB1bmZpbHRlcmVkTGV2ZWxzOiBMZXZlbFtdLFxuICAgIGRhdGE6IE1hbmlmZXN0TG9hZGVkRGF0YVxuICApIHtcbiAgICBsZXQgYXVkaW9UcmFja3M6IE1lZGlhUGxheWxpc3RbXSA9IFtdO1xuICAgIGxldCBzdWJ0aXRsZVRyYWNrczogTWVkaWFQbGF5bGlzdFtdID0gW107XG5cbiAgICBsZXQgcmVzb2x1dGlvbkZvdW5kID0gZmFsc2U7XG4gICAgbGV0IHZpZGVvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgIGxldCBhdWRpb0NvZGVjRm91bmQgPSBmYWxzZTtcblxuICAgIC8vIG9ubHkga2VlcCBsZXZlbHMgd2l0aCBzdXBwb3J0ZWQgYXVkaW8vdmlkZW8gY29kZWNzXG4gICAgbGV0IGxldmVscyA9IHVuZmlsdGVyZWRMZXZlbHMuZmlsdGVyKFxuICAgICAgKHsgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgd2lkdGgsIGhlaWdodCwgdW5rbm93bkNvZGVjcyB9KSA9PiB7XG4gICAgICAgIHJlc29sdXRpb25Gb3VuZCB8fD0gISEod2lkdGggJiYgaGVpZ2h0KTtcbiAgICAgICAgdmlkZW9Db2RlY0ZvdW5kIHx8PSAhIXZpZGVvQ29kZWM7XG4gICAgICAgIGF1ZGlvQ29kZWNGb3VuZCB8fD0gISFhdWRpb0NvZGVjO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICF1bmtub3duQ29kZWNzPy5sZW5ndGggJiZcbiAgICAgICAgICAoIWF1ZGlvQ29kZWMgfHwgaXNDb2RlY1N1cHBvcnRlZEluTXA0KGF1ZGlvQ29kZWMsICdhdWRpbycpKSAmJlxuICAgICAgICAgICghdmlkZW9Db2RlYyB8fCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQodmlkZW9Db2RlYywgJ3ZpZGVvJykpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIHJlbW92ZSBhdWRpby1vbmx5IGxldmVsIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCB2aWRlbyBjb2RlY3Mgb3IgUkVTT0xVVElPTiBzaWduYWxsZWRcbiAgICBpZiAoKHJlc29sdXRpb25Gb3VuZCB8fCB2aWRlb0NvZGVjRm91bmQpICYmIGF1ZGlvQ29kZWNGb3VuZCkge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihcbiAgICAgICAgKHsgdmlkZW9Db2RlYywgd2lkdGgsIGhlaWdodCB9KSA9PiAhIXZpZGVvQ29kZWMgfHwgISEod2lkdGggJiYgaGVpZ2h0KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRGlzcGF0Y2ggZXJyb3IgYWZ0ZXIgTUFOSUZFU1RfTE9BREVEIGlzIGRvbmUgcHJvcGFnYXRpbmdcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5obHMpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0J1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgdXJsOiBkYXRhLnVybCxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5hdWRpb1RyYWNrcykge1xuICAgICAgYXVkaW9UcmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzLmZpbHRlcihcbiAgICAgICAgKHRyYWNrKSA9PlxuICAgICAgICAgICF0cmFjay5hdWRpb0NvZGVjIHx8IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCh0cmFjay5hdWRpb0NvZGVjLCAnYXVkaW8nKVxuICAgICAgKTtcbiAgICAgIC8vIEFzc2lnbiBpZHMgYWZ0ZXIgZmlsdGVyaW5nIGFzIGFycmF5IGluZGljZXMgYnkgZ3JvdXAtaWRcbiAgICAgIGFzc2lnblRyYWNrSWRzQnlHcm91cChhdWRpb1RyYWNrcyk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuc3VidGl0bGVzKSB7XG4gICAgICBzdWJ0aXRsZVRyYWNrcyA9IGRhdGEuc3VidGl0bGVzO1xuICAgICAgYXNzaWduVHJhY2tJZHNCeUdyb3VwKHN1YnRpdGxlVHJhY2tzKTtcbiAgICB9XG4gICAgLy8gc3RhcnQgYml0cmF0ZSBpcyB0aGUgZmlyc3QgYml0cmF0ZSBvZiB0aGUgbWFuaWZlc3RcbiAgICBjb25zdCB1bnNvcnRlZExldmVscyA9IGxldmVscy5zbGljZSgwKTtcbiAgICAvLyBzb3J0IGxldmVscyBmcm9tIGxvd2VzdCB0byBoaWdoZXN0XG4gICAgbGV2ZWxzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGlmIChhLmF0dHJzWydIRENQLUxFVkVMJ10gIT09IGIuYXR0cnNbJ0hEQ1AtTEVWRUwnXSkge1xuICAgICAgICByZXR1cm4gKGEuYXR0cnNbJ0hEQ1AtTEVWRUwnXSB8fCAnJykgPiAoYi5hdHRyc1snSERDUC1MRVZFTCddIHx8ICcnKVxuICAgICAgICAgID8gMVxuICAgICAgICAgIDogLTE7XG4gICAgICB9XG4gICAgICBpZiAoYS5iaXRyYXRlICE9PSBiLmJpdHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuYml0cmF0ZSAtIGIuYml0cmF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhLmF0dHJzWydGUkFNRS1SQVRFJ10gIT09IGIuYXR0cnNbJ0ZSQU1FLVJBVEUnXSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGEuYXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ0ZSQU1FLVJBVEUnKSAtXG4gICAgICAgICAgYi5hdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnRlJBTUUtUkFURScpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoYS5hdHRycy5TQ09SRSAhPT0gYi5hdHRycy5TQ09SRSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGEuYXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1NDT1JFJykgLVxuICAgICAgICAgIGIuYXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1NDT1JFJylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNvbHV0aW9uRm91bmQgJiYgYS5oZWlnaHQgIT09IGIuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBhLmhlaWdodCAtIGIuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG5cbiAgICBsZXQgZmlyc3RMZXZlbEluUGxheWxpc3QgPSB1bnNvcnRlZExldmVsc1swXTtcbiAgICBpZiAodGhpcy5zdGVlcmluZykge1xuICAgICAgbGV2ZWxzID0gdGhpcy5zdGVlcmluZy5maWx0ZXJQYXJzZWRMZXZlbHMobGV2ZWxzKTtcbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoICE9PSB1bnNvcnRlZExldmVscy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bnNvcnRlZExldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh1bnNvcnRlZExldmVsc1tpXS5wYXRod2F5SWQgPT09IGxldmVsc1swXS5wYXRod2F5SWQpIHtcbiAgICAgICAgICAgIGZpcnN0TGV2ZWxJblBsYXlsaXN0ID0gdW5zb3J0ZWRMZXZlbHNbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG5cbiAgICAvLyBmaW5kIGluZGV4IG9mIGZpcnN0IGxldmVsIGluIHNvcnRlZCBsZXZlbHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxldmVsc1tpXSA9PT0gZmlyc3RMZXZlbEluUGxheWxpc3QpIHtcbiAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IGk7XG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgIGBtYW5pZmVzdCBsb2FkZWQsICR7bGV2ZWxzLmxlbmd0aH0gbGV2ZWwocykgZm91bmQsIGZpcnN0IGJpdHJhdGU6ICR7Zmlyc3RMZXZlbEluUGxheWxpc3QuYml0cmF0ZX1gXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEF1ZGlvIGlzIG9ubHkgYWx0ZXJuYXRlIGlmIG1hbmlmZXN0IGluY2x1ZGUgYSBVUkkgYWxvbmcgd2l0aCB0aGUgYXVkaW8gZ3JvdXAgdGFnLFxuICAgIC8vIGFuZCB0aGlzIGlzIG5vdCBhbiBhdWRpby1vbmx5IHN0cmVhbSB3aGVyZSBsZXZlbHMgY29udGFpbiBhdWRpby1vbmx5XG4gICAgY29uc3QgYXVkaW9Pbmx5ID0gYXVkaW9Db2RlY0ZvdW5kICYmICF2aWRlb0NvZGVjRm91bmQ7XG4gICAgY29uc3QgZWRhdGE6IE1hbmlmZXN0UGFyc2VkRGF0YSA9IHtcbiAgICAgIGxldmVscyxcbiAgICAgIGF1ZGlvVHJhY2tzLFxuICAgICAgc3VidGl0bGVUcmFja3MsXG4gICAgICBzZXNzaW9uRGF0YTogZGF0YS5zZXNzaW9uRGF0YSxcbiAgICAgIHNlc3Npb25LZXlzOiBkYXRhLnNlc3Npb25LZXlzLFxuICAgICAgZmlyc3RMZXZlbDogdGhpcy5fZmlyc3RMZXZlbCxcbiAgICAgIHN0YXRzOiBkYXRhLnN0YXRzLFxuICAgICAgYXVkaW86IGF1ZGlvQ29kZWNGb3VuZCxcbiAgICAgIHZpZGVvOiB2aWRlb0NvZGVjRm91bmQsXG4gICAgICBhbHRBdWRpbzogIWF1ZGlvT25seSAmJiBhdWRpb1RyYWNrcy5zb21lKCh0KSA9PiAhIXQudXJsKSxcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgZWRhdGEpO1xuXG4gICAgLy8gSW5pdGlhdGUgbG9hZGluZyBhZnRlciBhbGwgY29udHJvbGxlcnMgaGF2ZSByZWNlaXZlZCBNQU5JRkVTVF9QQVJTRURcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmF1dG9TdGFydExvYWQgfHwgdGhpcy5obHMuZm9yY2VTdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZCh0aGlzLmhscy5jb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGxldmVscygpOiBMZXZlbFtdIHwgbnVsbCB7XG4gICAgaWYgKHRoaXMuX2xldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICB9XG5cbiAgZ2V0IGxldmVsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gIH1cblxuICBzZXQgbGV2ZWwobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3TGV2ZWwgPCAwIHx8IG5ld0xldmVsID49IGxldmVscy5sZW5ndGgpIHtcbiAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIGxldmVsIGlkeCcpO1xuICAgICAgY29uc3QgZmF0YWwgPSBuZXdMZXZlbCA8IDA7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfU1dJVENIX0VSUk9SLFxuICAgICAgICBsZXZlbDogbmV3TGV2ZWwsXG4gICAgICAgIGZhdGFsLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgfSk7XG4gICAgICBpZiAoZmF0YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1pbihuZXdMZXZlbCwgbGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3RMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICBjb25zdCBsYXN0TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbDtcbiAgICBjb25zdCBsYXN0UGF0aHdheUlkID0gbGFzdExldmVsID8gbGFzdExldmVsLmF0dHJzWydQQVRIV0FZLUlEJ10gOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdO1xuICAgIGNvbnN0IHBhdGh3YXlJZCA9IGxldmVsLmF0dHJzWydQQVRIV0FZLUlEJ107XG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbGV2ZWw7XG5cbiAgICBpZiAoXG4gICAgICBsYXN0TGV2ZWxJbmRleCA9PT0gbmV3TGV2ZWwgJiZcbiAgICAgIGxldmVsLmRldGFpbHMgJiZcbiAgICAgIGxhc3RMZXZlbCAmJlxuICAgICAgbGFzdFBhdGh3YXlJZCA9PT0gcGF0aHdheUlkXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb2coXG4gICAgICBgU3dpdGNoaW5nIHRvIGxldmVsICR7bmV3TGV2ZWx9JHtcbiAgICAgICAgcGF0aHdheUlkID8gJyB3aXRoIFBhdGh3YXkgJyArIHBhdGh3YXlJZCA6ICcnXG4gICAgICB9IGZyb20gbGV2ZWwgJHtsYXN0TGV2ZWxJbmRleH0ke1xuICAgICAgICBsYXN0UGF0aHdheUlkID8gJyB3aXRoIFBhdGh3YXkgJyArIGxhc3RQYXRod2F5SWQgOiAnJ1xuICAgICAgfWBcbiAgICApO1xuXG4gICAgY29uc3QgbGV2ZWxTd2l0Y2hpbmdEYXRhOiBMZXZlbFN3aXRjaGluZ0RhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBsZXZlbCwge1xuICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgbWF4Qml0cmF0ZTogbGV2ZWwubWF4Qml0cmF0ZSxcbiAgICAgIGF0dHJzOiBsZXZlbC5hdHRycyxcbiAgICAgIHVyaTogbGV2ZWwudXJpLFxuICAgICAgdXJsSWQ6IGxldmVsLnVybElkLFxuICAgIH0pO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBkZWxldGUgbGV2ZWxTd2l0Y2hpbmdEYXRhLl9hdHRycztcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZGVsZXRlIGxldmVsU3dpdGNoaW5nRGF0YS5fdXJsSWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENISU5HLCBsZXZlbFN3aXRjaGluZ0RhdGEpO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbFxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgIGNvbnN0IGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyhsZXZlbC51cmksIGxhc3RMZXZlbD8uZGV0YWlscyk7XG4gICAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cblxuICBnZXQgbWFudWFsTGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICB9XG5cbiAgc2V0IG1hbnVhbExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cblxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gIH1cblxuICBnZXQgZmlyc3RMZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICB9XG5cbiAgc2V0IGZpcnN0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICB0aGlzLl9maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICBnZXQgc3RhcnRMZXZlbCgpIHtcbiAgICAvLyBobHMuc3RhcnRMZXZlbCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY29uZmlnLnN0YXJ0TGV2ZWxcbiAgICAvLyBpZiBub25lIG9mIHRoZXNlIHZhbHVlcyBhcmUgZGVmaW5lZCwgZmFsbGJhY2sgb24gdGhpcy5fZmlyc3RMZXZlbCAoZmlyc3QgcXVhbGl0eSBsZXZlbCBhcHBlYXJpbmcgaW4gdmFyaWFudCBtYW5pZmVzdClcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjb25maWdTdGFydExldmVsID0gdGhpcy5obHMuY29uZmlnLnN0YXJ0TGV2ZWw7XG4gICAgICBpZiAoY29uZmlnU3RhcnRMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWdTdGFydExldmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICAgIH1cbiAgfVxuXG4gIHNldCBzdGFydExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRXJyb3IoZXZlbnQ6IEV2ZW50cy5FUlJPUiwgZGF0YTogRXJyb3JEYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGRhdGEuY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMICYmXG4gICAgICBkYXRhLmNvbnRleHQubGV2ZWwgPT09IHRoaXMubGV2ZWxcbiAgICApIHtcbiAgICAgIHRoaXMuY2hlY2tSZXRyeShkYXRhKTtcbiAgICB9XG4gIH1cblxuICAvLyByZXNldCBlcnJvcnMgb24gdGhlIHN1Y2Nlc3NmdWwgbG9hZCBvZiBhIGZyYWdtZW50XG4gIHByb3RlY3RlZCBvbkZyYWdMb2FkZWQoZXZlbnQ6IEV2ZW50cy5GUkFHX0xPQURFRCwgeyBmcmFnIH06IEZyYWdMb2FkZWREYXRhKSB7XG4gICAgaWYgKGZyYWcgIT09IHVuZGVmaW5lZCAmJiBmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5fbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25MZXZlbExvYWRlZChldmVudDogRXZlbnRzLkxFVkVMX0xPQURFRCwgZGF0YTogTGV2ZWxMb2FkZWREYXRhKSB7XG4gICAgY29uc3QgeyBsZXZlbCwgZGV0YWlscyB9ID0gZGF0YTtcbiAgICBjb25zdCBjdXJMZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbF07XG5cbiAgICBpZiAoIWN1ckxldmVsKSB7XG4gICAgICB0aGlzLndhcm4oYEludmFsaWQgbGV2ZWwgaW5kZXggJHtsZXZlbH1gKTtcbiAgICAgIGlmIChkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcz8uc2tpcCkge1xuICAgICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHByb2Nlc3MgbGV2ZWwgbG9hZGVkIGV2ZW50cyBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIGxldmVsXG4gICAgaWYgKGxldmVsID09PSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4KSB7XG4gICAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWQgb25seSBpZiB0aGVyZSBpcyBubyBpc3N1ZXMgd2l0aCBmcmFnbWVudHNcbiAgICAgIGlmIChjdXJMZXZlbC5mcmFnbWVudEVycm9yID09PSAwKSB7XG4gICAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGxldmVsLCBkYXRhLCBjdXJMZXZlbC5kZXRhaWxzKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzPy5za2lwKSB7XG4gICAgICAvLyByZWNlaXZlZCBhIGRlbHRhIHBsYXlsaXN0IHVwZGF0ZSB0aGF0IGNhbm5vdCBiZSBtZXJnZWRcbiAgICAgIGRldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvbkF1ZGlvVHJhY2tTd2l0Y2hlZChcbiAgICBldmVudDogRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELFxuICAgIGRhdGE6IFRyYWNrU3dpdGNoZWREYXRhXG4gICkge1xuICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IHRoaXMuY3VycmVudExldmVsO1xuICAgIGlmICghY3VycmVudExldmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXVkaW9Hcm91cElkID0gdGhpcy5obHMuYXVkaW9UcmFja3NbZGF0YS5pZF0uZ3JvdXBJZDtcbiAgICBpZiAoXG4gICAgICBjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkcyAmJlxuICAgICAgY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZCAhPT0gYXVkaW9Hcm91cElkXG4gICAgKSB7XG4gICAgICBsZXQgdXJsSWQgPSAtMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzW2ldID09PSBhdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICB1cmxJZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHVybElkICE9PSAtMSAmJiB1cmxJZCAhPT0gY3VycmVudExldmVsLnVybElkKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbC51cmxJZCA9IHVybElkO1xuICAgICAgICBpZiAodGhpcy5jYW5Mb2FkKSB7XG4gICAgICAgICAgdGhpcy5zdGFydExvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycz86IEhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICBzdXBlci5sb2FkUGxheWxpc3QoKTtcbiAgICBjb25zdCBjdXJyZW50TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgY29uc3QgY3VycmVudExldmVsID0gdGhpcy5jdXJyZW50TGV2ZWw7XG5cbiAgICBpZiAoY3VycmVudExldmVsICYmIHRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgIGNvbnN0IGlkID0gY3VycmVudExldmVsLnVybElkO1xuICAgICAgbGV0IHVybCA9IGN1cnJlbnRMZXZlbC51cmk7XG4gICAgICBpZiAoaGxzVXJsUGFyYW1ldGVycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybCA9IGhsc1VybFBhcmFtZXRlcnMuYWRkRGlyZWN0aXZlcyh1cmwpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICAgIGBDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogJHtlcnJvcn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXRod2F5SWQgPSBjdXJyZW50TGV2ZWwuYXR0cnNbJ1BBVEhXQVktSUQnXTtcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgTG9hZGluZyBsZXZlbCBpbmRleCAke2N1cnJlbnRMZXZlbEluZGV4fSR7XG4gICAgICAgICAgaGxzVXJsUGFyYW1ldGVycz8ubXNuICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gJyBhdCBzbiAnICtcbiAgICAgICAgICAgICAgaGxzVXJsUGFyYW1ldGVycy5tc24gK1xuICAgICAgICAgICAgICAnIHBhcnQgJyArXG4gICAgICAgICAgICAgIGhsc1VybFBhcmFtZXRlcnMucGFydFxuICAgICAgICAgICAgOiAnJ1xuICAgICAgICB9IHdpdGgke3BhdGh3YXlJZCA/ICcgUGF0aHdheSAnICsgcGF0aHdheUlkIDogJyd9IFVSSSAke2lkICsgMX0vJHtcbiAgICAgICAgICBjdXJyZW50TGV2ZWwudXJsLmxlbmd0aFxuICAgICAgICB9ICR7dXJsfWBcbiAgICAgICk7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdDdXJyZW50IGF1ZGlvIHRyYWNrIGdyb3VwIElEOicsIHRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RoaXMuaGxzLmF1ZGlvVHJhY2tdLmdyb3VwSWQpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ05ldyB2aWRlbyBxdWFsaXR5IGxldmVsIGF1ZGlvIGdyb3VwIGlkOicsIGxldmVsT2JqZWN0LmF0dHJzLkFVRElPLCBsZXZlbCk7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX0xPQURJTkcsIHtcbiAgICAgICAgdXJsLFxuICAgICAgICBsZXZlbDogY3VycmVudExldmVsSW5kZXgsXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBuZXh0TG9hZExldmVsKCkge1xuICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggIT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcbiAgICB9XG4gIH1cblxuICBzZXQgbmV4dExvYWRMZXZlbChuZXh0TGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsID0gbmV4dExldmVsO1xuICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPT09IC0xKSB7XG4gICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUxldmVsKGxldmVsSW5kZXgsIHVybElkKSB7XG4gICAgY29uc3QgZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleCA9ICh1cmwsIGlkKSA9PiBpZCAhPT0gdXJsSWQ7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzLmZpbHRlcigobGV2ZWwsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggIT09IGxldmVsSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZXZlbC51cmwubGVuZ3RoID4gMSAmJiB1cmxJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldmVsLnVybCA9IGxldmVsLnVybC5maWx0ZXIoZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleCk7XG4gICAgICAgIGlmIChsZXZlbC5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICAgICAgbGV2ZWwuYXVkaW9Hcm91cElkcyA9IGxldmVsLmF1ZGlvR3JvdXBJZHMuZmlsdGVyKFxuICAgICAgICAgICAgZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsLnRleHRHcm91cElkcykge1xuICAgICAgICAgIGxldmVsLnRleHRHcm91cElkcyA9IGxldmVsLnRleHRHcm91cElkcy5maWx0ZXIoXG4gICAgICAgICAgICBmaWx0ZXJMZXZlbEFuZEdyb3VwQnlJZEluZGV4XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXZlbC51cmxJZCA9IDA7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RlZXJpbmcpIHtcbiAgICAgICAgdGhpcy5zdGVlcmluZy5yZW1vdmVMZXZlbChsZXZlbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgeyBsZXZlbHMgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uTGV2ZWxzVXBkYXRlZChcbiAgICBldmVudDogRXZlbnRzLkxFVkVMU19VUERBVEVELFxuICAgIHsgbGV2ZWxzIH06IExldmVsc1VwZGF0ZWREYXRhXG4gICkge1xuICAgIGxldmVscy5mb3JFYWNoKChsZXZlbCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHsgZGV0YWlscyB9ID0gbGV2ZWw7XG4gICAgICBpZiAoZGV0YWlscz8uZnJhZ21lbnRzKSB7XG4gICAgICAgIGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50KSA9PiB7XG4gICAgICAgICAgZnJhZ21lbnQubGV2ZWwgPSBpbmRleDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRHcm91cElkKFxuICBsZXZlbDogTGV2ZWwsXG4gIHR5cGU6IHN0cmluZyxcbiAgaWQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuKTogdm9pZCB7XG4gIGlmICghaWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICBpZiAoIWxldmVsLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgIGxldmVsLmF1ZGlvR3JvdXBJZHMgPSBbXTtcbiAgICB9XG4gICAgbGV2ZWwuYXVkaW9Hcm91cElkc1tsZXZlbC51cmwubGVuZ3RoIC0gMV0gPSBpZDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICBpZiAoIWxldmVsLnRleHRHcm91cElkcykge1xuICAgICAgbGV2ZWwudGV4dEdyb3VwSWRzID0gW107XG4gICAgfVxuICAgIGxldmVsLnRleHRHcm91cElkc1tsZXZlbC51cmwubGVuZ3RoIC0gMV0gPSBpZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25UcmFja0lkc0J5R3JvdXAodHJhY2tzOiBNZWRpYVBsYXlsaXN0W10pOiB2b2lkIHtcbiAgY29uc3QgZ3JvdXBzID0ge307XG4gIHRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgIGNvbnN0IGdyb3VwSWQgPSB0cmFjay5ncm91cElkIHx8ICcnO1xuICAgIHRyYWNrLmlkID0gZ3JvdXBzW2dyb3VwSWRdID0gZ3JvdXBzW2dyb3VwSWRdIHx8IDA7XG4gICAgZ3JvdXBzW2dyb3VwSWRdKys7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEZyYWdtZW50LCBQYXJ0IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB7IFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB0eXBlIHsgU291cmNlQnVmZmVyTmFtZSB9IGZyb20gJy4uL3R5cGVzL2J1ZmZlcic7XG5pbXBvcnQgdHlwZSB7XG4gIEZyYWdtZW50QnVmZmVyZWRSYW5nZSxcbiAgRnJhZ21lbnRFbnRpdHksXG4gIEZyYWdtZW50VGltZVJhbmdlLFxufSBmcm9tICcuLi90eXBlcy9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSB7XG4gIEJ1ZmZlckFwcGVuZGVkRGF0YSxcbiAgRnJhZ0J1ZmZlcmVkRGF0YSxcbiAgRnJhZ0xvYWRlZERhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcblxuZXhwb3J0IGNvbnN0IGVudW0gRnJhZ21lbnRTdGF0ZSB7XG4gIE5PVF9MT0FERUQgPSAnTk9UX0xPQURFRCcsXG4gIEFQUEVORElORyA9ICdBUFBFTkRJTkcnLFxuICBQQVJUSUFMID0gJ1BBUlRJQUwnLFxuICBPSyA9ICdPSycsXG59XG5cbmV4cG9ydCBjbGFzcyBGcmFnbWVudFRyYWNrZXIgaW1wbGVtZW50cyBDb21wb25lbnRBUEkge1xuICBwcml2YXRlIGFjdGl2ZVBhcnRMaXN0czogeyBba2V5IGluIFBsYXlsaXN0TGV2ZWxUeXBlXT86IFBhcnRbXSB9ID1cbiAgICBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBwcml2YXRlIGVuZExpc3RGcmFnbWVudHM6IHsgW2tleSBpbiBQbGF5bGlzdExldmVsVHlwZV0/OiBGcmFnbWVudEVudGl0eSB9ID1cbiAgICBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBwcml2YXRlIGZyYWdtZW50czogUGFydGlhbDxSZWNvcmQ8c3RyaW5nLCBGcmFnbWVudEVudGl0eT4+ID1cbiAgICBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBwcml2YXRlIHRpbWVSYW5nZXM6XG4gICAgfCB7XG4gICAgICAgIFtrZXkgaW4gU291cmNlQnVmZmVyTmFtZV0/OiBUaW1lUmFuZ2VzO1xuICAgICAgfVxuICAgIHwgbnVsbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcHJpdmF0ZSBidWZmZXJQYWRkaW5nOiBudW1iZXIgPSAwLjI7XG4gIHByaXZhdGUgaGxzOiBIbHM7XG4gIHByaXZhdGUgaGFzR2FwczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGhsczogSGxzKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG5cbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gIH1cblxuICBwcml2YXRlIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmZyYWdtZW50cyA9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPVxuICAgICAgdGhpcy50aW1lUmFuZ2VzID1cbiAgICAgICAgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBGcmFnbWVudCBvciBQYXJ0IHdpdGggYW4gYXBwZW5kZWQgcmFuZ2UgdGhhdCBtYXRjaGVzIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlXG4gICAqIE90aGVyd2lzZSwgcmV0dXJuIG51bGxcbiAgICovXG4gIHB1YmxpYyBnZXRBcHBlbmRlZEZyYWcoXG4gICAgcG9zaXRpb246IG51bWJlcixcbiAgICBsZXZlbFR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlXG4gICk6IEZyYWdtZW50IHwgUGFydCB8IG51bGwge1xuICAgIGNvbnN0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbbGV2ZWxUeXBlXTtcbiAgICBpZiAoYWN0aXZlUGFydHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVQYXJ0cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVBhcnQgPSBhY3RpdmVQYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFhY3RpdmVQYXJ0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwZW5kZWRQVFMgPSBhY3RpdmVQYXJ0LmVuZDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGFjdGl2ZVBhcnQuc3RhcnQgPD0gcG9zaXRpb24gJiZcbiAgICAgICAgICBhcHBlbmRlZFBUUyAhPT0gbnVsbCAmJlxuICAgICAgICAgIHBvc2l0aW9uIDw9IGFwcGVuZGVkUFRTXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVQYXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBidWZmZXJlZCBGcmFnbWVudCB0aGF0IG1hdGNoZXMgdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGUuXG4gICAqIEEgYnVmZmVyZWQgRnJhZ21lbnQgaXMgb25lIHdob3NlIGxvYWRpbmcsIHBhcnNpbmcgYW5kIGFwcGVuZGluZyBpcyBkb25lIChjb21wbGV0ZWQgb3IgXCJwYXJ0aWFsXCIgbWVhbmluZyBhYm9ydGVkKS5cbiAgICogSWYgbm90IGZvdW5kIGFueSBGcmFnbWVudCwgcmV0dXJuIG51bGxcbiAgICovXG4gIHB1YmxpYyBnZXRCdWZmZXJlZEZyYWcoXG4gICAgcG9zaXRpb246IG51bWJlcixcbiAgICBsZXZlbFR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlXG4gICk6IEZyYWdtZW50IHwgbnVsbCB7XG4gICAgY29uc3QgeyBmcmFnbWVudHMgfSA9IHRoaXM7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50cyk7XG4gICAgZm9yIChsZXQgaSA9IGtleXMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSBmcmFnbWVudHNba2V5c1tpXV07XG4gICAgICBpZiAoZnJhZ21lbnRFbnRpdHk/LmJvZHkudHlwZSA9PT0gbGV2ZWxUeXBlICYmIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgICBpZiAoZnJhZy5zdGFydCA8PSBwb3NpdGlvbiAmJiBwb3NpdGlvbiA8PSBmcmFnLmVuZCkge1xuICAgICAgICAgIHJldHVybiBmcmFnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnRpYWwgZnJhZ21lbnRzIGVmZmVjdGVkIGJ5IGNvZGVkIGZyYW1lIGV2aWN0aW9uIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBUaGUgYnJvd3NlciB3aWxsIHVubG9hZCBwYXJ0cyBvZiB0aGUgYnVmZmVyIHRvIGZyZWUgdXAgbWVtb3J5IGZvciBuZXcgYnVmZmVyIGRhdGFcbiAgICogRnJhZ21lbnRzIHdpbGwgbmVlZCB0byBiZSByZWxvYWRlZCB3aGVuIHRoZSBidWZmZXIgaXMgZnJlZWQgdXAsIHJlbW92aW5nIHBhcnRpYWwgZnJhZ21lbnRzIHdpbGwgYWxsb3cgdGhlbSB0byByZWxvYWQoc2luY2UgdGhlcmUgbWlnaHQgYmUgcGFydHMgdGhhdCBhcmUgc3RpbGwgcGxheWFibGUpXG4gICAqL1xuICBwdWJsaWMgZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhcbiAgICBlbGVtZW50YXJ5U3RyZWFtOiBTb3VyY2VCdWZmZXJOYW1lLFxuICAgIHRpbWVSYW5nZTogVGltZVJhbmdlcyxcbiAgICBwbGF5bGlzdFR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlLFxuICAgIGFwcGVuZGVkUGFydD86IFBhcnQgfCBudWxsXG4gICkge1xuICAgIGlmICh0aGlzLnRpbWVSYW5nZXMpIHtcbiAgICAgIHRoaXMudGltZVJhbmdlc1tlbGVtZW50YXJ5U3RyZWFtXSA9IHRpbWVSYW5nZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYW55IGZsYWdnZWQgZnJhZ21lbnRzIGhhdmUgYmVlbiB1bmxvYWRlZFxuICAgIC8vIGV4Y2x1ZGluZyBhbnl0aGluZyBuZXdlciB0aGFuIGFwcGVuZGVkUGFydFNuXG4gICAgY29uc3QgYXBwZW5kZWRQYXJ0U24gPSAoYXBwZW5kZWRQYXJ0Py5mcmFnbWVudC5zbiB8fCAtMSkgYXMgbnVtYmVyO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNba2V5XTtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGFwcGVuZGVkUGFydFNuID49IChmcmFnbWVudEVudGl0eS5ib2R5LnNuIGFzIG51bWJlcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiAhZnJhZ21lbnRFbnRpdHkubG9hZGVkKSB7XG4gICAgICAgIGlmIChmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUgPT09IHBsYXlsaXN0VHlwZSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZXNEYXRhID0gZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICBpZiAoIWVzRGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlc0RhdGEudGltZS5zb21lKCh0aW1lOiBGcmFnbWVudFRpbWVSYW5nZSkgPT4ge1xuICAgICAgICBjb25zdCBpc05vdEJ1ZmZlcmVkID0gIXRoaXMuaXNUaW1lQnVmZmVyZWQoXG4gICAgICAgICAgdGltZS5zdGFydFBUUyxcbiAgICAgICAgICB0aW1lLmVuZFBUUyxcbiAgICAgICAgICB0aW1lUmFuZ2VcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGlzTm90QnVmZmVyZWQpIHtcbiAgICAgICAgICAvLyBVbnJlZ2lzdGVyIHBhcnRpYWwgZnJhZ21lbnQgYXMgaXQgbmVlZHMgdG8gbG9hZCBhZ2FpbiB0byBiZSByZXVzZWRcbiAgICAgICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05vdEJ1ZmZlcmVkO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBmcmFnbWVudCBwYXNzZWQgaW4gaXMgbG9hZGVkIGluIHRoZSBidWZmZXIgcHJvcGVybHlcbiAgICogUGFydGlhbGx5IGxvYWRlZCBmcmFnbWVudHMgd2lsbCBiZSByZWdpc3RlcmVkIGFzIGEgcGFydGlhbCBmcmFnbWVudFxuICAgKi9cbiAgcHVibGljIGRldGVjdFBhcnRpYWxGcmFnbWVudHMoZGF0YTogRnJhZ0J1ZmZlcmVkRGF0YSkge1xuICAgIGNvbnN0IHRpbWVSYW5nZXMgPSB0aGlzLnRpbWVSYW5nZXM7XG4gICAgY29uc3QgeyBmcmFnLCBwYXJ0IH0gPSBkYXRhO1xuICAgIGlmICghdGltZVJhbmdlcyB8fCBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKCFmcmFnbWVudEVudGl0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0ZyYWdIaW50ID0gIWZyYWcucmVsdXJsO1xuICAgIE9iamVjdC5rZXlzKHRpbWVSYW5nZXMpLmZvckVhY2goKGVsZW1lbnRhcnlTdHJlYW06IFNvdXJjZUJ1ZmZlck5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHN0cmVhbUluZm8gPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgaWYgKCFzdHJlYW1JbmZvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV0gYXMgVGltZVJhbmdlcztcbiAgICAgIGNvbnN0IHBhcnRpYWwgPSBpc0ZyYWdIaW50IHx8IHN0cmVhbUluZm8ucGFydGlhbCA9PT0gdHJ1ZTtcbiAgICAgIGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dID0gdGhpcy5nZXRCdWZmZXJlZFRpbWVzKFxuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0LFxuICAgICAgICBwYXJ0aWFsLFxuICAgICAgICB0aW1lUmFuZ2VcbiAgICAgICk7XG4gICAgfSk7XG4gICAgZnJhZ21lbnRFbnRpdHkubG9hZGVkID0gbnVsbDtcbiAgICBpZiAoT2JqZWN0LmtleXMoZnJhZ21lbnRFbnRpdHkucmFuZ2UpLmxlbmd0aCkge1xuICAgICAgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPSB0cnVlO1xuICAgICAgaWYgKGZyYWdtZW50RW50aXR5LmJvZHkuZW5kTGlzdCkge1xuICAgICAgICB0aGlzLmVuZExpc3RGcmFnbWVudHNbZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlXSA9IGZyYWdtZW50RW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgIC8vIFJlbW92ZSBvbGRlciBmcmFnbWVudCBwYXJ0cyBmcm9tIGxvb2t1cCBhZnRlciBmcmFnIGlzIHRyYWNrZWQgYXMgYnVmZmVyZWRcbiAgICAgICAgdGhpcy5yZW1vdmVQYXJ0cygoZnJhZy5zbiBhcyBudW1iZXIpIC0gMSwgZnJhZy50eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIGZyYWdtZW50IGlmIG5vdGhpbmcgd2FzIGFwcGVuZGVkXG4gICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlUGFydHMoc25Ub0tlZXA6IG51bWJlciwgbGV2ZWxUeXBlOiBQbGF5bGlzdExldmVsVHlwZSkge1xuICAgIGNvbnN0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbbGV2ZWxUeXBlXTtcbiAgICBpZiAoIWFjdGl2ZVBhcnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzW2xldmVsVHlwZV0gPSBhY3RpdmVQYXJ0cy5maWx0ZXIoXG4gICAgICAocGFydCkgPT4gKHBhcnQuZnJhZ21lbnQuc24gYXMgbnVtYmVyKSA+PSBzblRvS2VlcFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZnJhZ0J1ZmZlcmVkKGZyYWc6IEZyYWdtZW50LCBmb3JjZT86IHRydWUpIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgbGV0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKCFmcmFnbWVudEVudGl0eSAmJiBmb3JjZSkge1xuICAgICAgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XSA9IHtcbiAgICAgICAgYm9keTogZnJhZyxcbiAgICAgICAgYXBwZW5kZWRQVFM6IG51bGwsXG4gICAgICAgIGxvYWRlZDogbnVsbCxcbiAgICAgICAgYnVmZmVyZWQ6IGZhbHNlLFxuICAgICAgICByYW5nZTogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIH07XG4gICAgICBpZiAoZnJhZy5nYXApIHtcbiAgICAgICAgdGhpcy5oYXNHYXBzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZyYWdtZW50RW50aXR5KSB7XG4gICAgICBmcmFnbWVudEVudGl0eS5sb2FkZWQgPSBudWxsO1xuICAgICAgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0QnVmZmVyZWRUaW1lcyhcbiAgICBmcmFnbWVudDogRnJhZ21lbnQsXG4gICAgcGFydDogUGFydCB8IG51bGwsXG4gICAgcGFydGlhbDogYm9vbGVhbixcbiAgICB0aW1lUmFuZ2U6IFRpbWVSYW5nZXNcbiAgKTogRnJhZ21lbnRCdWZmZXJlZFJhbmdlIHtcbiAgICBjb25zdCBidWZmZXJlZDogRnJhZ21lbnRCdWZmZXJlZFJhbmdlID0ge1xuICAgICAgdGltZTogW10sXG4gICAgICBwYXJ0aWFsLFxuICAgIH07XG4gICAgY29uc3Qgc3RhcnRQVFMgPSBmcmFnbWVudC5zdGFydDtcbiAgICBjb25zdCBlbmRQVFMgPSBmcmFnbWVudC5lbmQ7XG4gICAgY29uc3QgbWluRW5kUFRTID0gZnJhZ21lbnQubWluRW5kUFRTIHx8IGVuZFBUUztcbiAgICBjb25zdCBtYXhTdGFydFBUUyA9IGZyYWdtZW50Lm1heFN0YXJ0UFRTIHx8IHN0YXJ0UFRTO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBjb25zdCBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGlmIChtYXhTdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgbWluRW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgLy8gRnJhZ21lbnQgaXMgZW50aXJlbHkgY29udGFpbmVkIGluIGJ1ZmZlclxuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSBvdGhlciB0aW1lUmFuZ2UgdGltZXMgc2luY2UgaXQncyBjb21wbGV0ZWx5IHBsYXlhYmxlXG4gICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgc3RhcnRQVFM6IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpLFxuICAgICAgICAgIGVuZFBUUzogTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFBUUyA8IGVuZFRpbWUgJiYgZW5kUFRTID4gc3RhcnRUaW1lKSB7XG4gICAgICAgIGJ1ZmZlcmVkLnBhcnRpYWwgPSB0cnVlO1xuICAgICAgICAvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9uIHdpdGggYnVmZmVyXG4gICAgICAgIC8vIEdldCBwbGF5YWJsZSBzZWN0aW9ucyBvZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgYnVmZmVyZWQudGltZS5wdXNoKHtcbiAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgZW5kUFRTOiBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXN0IG9mIHRoZSB0aW1lUmFuZ2UgYXMgaXQgaXMgaW4gb3JkZXJcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvciBhIGNlcnRhaW4gdGltZVxuICAgKi9cbiAgcHVibGljIGdldFBhcnRpYWxGcmFnbWVudCh0aW1lOiBudW1iZXIpOiBGcmFnbWVudCB8IG51bGwge1xuICAgIGxldCBiZXN0RnJhZ21lbnQ6IEZyYWdtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHRpbWVQYWRkaW5nOiBudW1iZXI7XG4gICAgbGV0IHN0YXJ0VGltZTogbnVtYmVyO1xuICAgIGxldCBlbmRUaW1lOiBudW1iZXI7XG4gICAgbGV0IGJlc3RPdmVybGFwOiBudW1iZXIgPSAwO1xuICAgIGNvbnN0IHsgYnVmZmVyUGFkZGluZywgZnJhZ21lbnRzIH0gPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKGZyYWdtZW50cykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXldO1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICBzdGFydFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LnN0YXJ0IC0gYnVmZmVyUGFkZGluZztcbiAgICAgICAgZW5kVGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kICsgYnVmZmVyUGFkZGluZztcbiAgICAgICAgaWYgKHRpbWUgPj0gc3RhcnRUaW1lICYmIHRpbWUgPD0gZW5kVGltZSkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgZnJhZ21lbnQgdGhhdCBoYXMgdGhlIG1vc3QgcGFkZGluZyBmcm9tIHN0YXJ0IGFuZCBlbmQgdGltZVxuICAgICAgICAgIHRpbWVQYWRkaW5nID0gTWF0aC5taW4odGltZSAtIHN0YXJ0VGltZSwgZW5kVGltZSAtIHRpbWUpO1xuICAgICAgICAgIGlmIChiZXN0T3ZlcmxhcCA8PSB0aW1lUGFkZGluZykge1xuICAgICAgICAgICAgYmVzdEZyYWdtZW50ID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgICAgIGJlc3RPdmVybGFwID0gdGltZVBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGJlc3RGcmFnbWVudDtcbiAgfVxuXG4gIHB1YmxpYyBpc0VuZExpc3RBcHBlbmRlZCh0eXBlOiBQbGF5bGlzdExldmVsVHlwZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGxhc3RGcmFnbWVudEVudGl0eSA9IHRoaXMuZW5kTGlzdEZyYWdtZW50c1t0eXBlXTtcbiAgICByZXR1cm4gKFxuICAgICAgbGFzdEZyYWdtZW50RW50aXR5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChsYXN0RnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgfHwgaXNQYXJ0aWFsKGxhc3RGcmFnbWVudEVudGl0eSkpXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRTdGF0ZShmcmFnbWVudDogRnJhZ21lbnQpOiBGcmFnbWVudFN0YXRlIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG5cbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HO1xuICAgICAgfSBlbHNlIGlmIChpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLlBBUlRJQUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5PSztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1RpbWVCdWZmZXJlZChcbiAgICBzdGFydFBUUzogbnVtYmVyLFxuICAgIGVuZFBUUzogbnVtYmVyLFxuICAgIHRpbWVSYW5nZTogVGltZVJhbmdlc1xuICApOiBib29sZWFuIHtcbiAgICBsZXQgc3RhcnRUaW1lO1xuICAgIGxldCBlbmRUaW1lO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGlmIChzdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgZW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkZyYWdMb2FkZWQoZXZlbnQ6IEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YTogRnJhZ0xvYWRlZERhdGEpIHtcbiAgICBjb25zdCB7IGZyYWcsIHBhcnQgfSA9IGRhdGE7XG4gICAgLy8gZG9uJ3QgdHJhY2sgaW5pdHNlZ21lbnQgKGZvciB3aGljaCBzbiBpcyBub3QgYSBudW1iZXIpXG4gICAgLy8gZG9uJ3QgdHJhY2sgZnJhZ3MgdXNlZCBmb3IgYml0cmF0ZVRlc3QsIHRoZXkncmUgaXJyZWxldmFudC5cbiAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyB8fCBmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRnJhZ21lbnQgZW50aXR5IGBsb2FkZWRgIEZyYWdMb2FkZWREYXRhIGlzIG51bGwgd2hlbiBsb2FkaW5nIHBhcnRzXG4gICAgY29uc3QgbG9hZGVkID0gcGFydCA/IG51bGwgOiBkYXRhO1xuXG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldID0ge1xuICAgICAgYm9keTogZnJhZyxcbiAgICAgIGFwcGVuZGVkUFRTOiBudWxsLFxuICAgICAgbG9hZGVkLFxuICAgICAgYnVmZmVyZWQ6IGZhbHNlLFxuICAgICAgcmFuZ2U6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgb25CdWZmZXJBcHBlbmRlZChcbiAgICBldmVudDogRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCxcbiAgICBkYXRhOiBCdWZmZXJBcHBlbmRlZERhdGFcbiAgKSB7XG4gICAgY29uc3QgeyBmcmFnLCBwYXJ0LCB0aW1lUmFuZ2VzIH0gPSBkYXRhO1xuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9IGZyYWcudHlwZTtcbiAgICBpZiAocGFydCkge1xuICAgICAgbGV0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbcGxheWxpc3RUeXBlXTtcbiAgICAgIGlmICghYWN0aXZlUGFydHMpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHNbcGxheWxpc3RUeXBlXSA9IGFjdGl2ZVBhcnRzID0gW107XG4gICAgICB9XG4gICAgICBhY3RpdmVQYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICAvLyBTdG9yZSB0aGUgbGF0ZXN0IHRpbWVSYW5nZXMgbG9hZGVkIGluIHRoZSBidWZmZXJcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSB0aW1lUmFuZ2VzO1xuICAgIE9iamVjdC5rZXlzKHRpbWVSYW5nZXMpLmZvckVhY2goKGVsZW1lbnRhcnlTdHJlYW06IFNvdXJjZUJ1ZmZlck5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV0gYXMgVGltZVJhbmdlcztcbiAgICAgIHRoaXMuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhcbiAgICAgICAgZWxlbWVudGFyeVN0cmVhbSxcbiAgICAgICAgdGltZVJhbmdlLFxuICAgICAgICBwbGF5bGlzdFR5cGUsXG4gICAgICAgIHBhcnRcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50OiBFdmVudHMuRlJBR19CVUZGRVJFRCwgZGF0YTogRnJhZ0J1ZmZlcmVkRGF0YSkge1xuICAgIHRoaXMuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyhkYXRhKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFzRnJhZ21lbnQoZnJhZ21lbnQ6IEZyYWdtZW50KTogYm9vbGVhbiB7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICByZXR1cm4gISF0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgfVxuXG4gIHB1YmxpYyBoYXNQYXJ0cyh0eXBlOiBQbGF5bGlzdExldmVsVHlwZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuYWN0aXZlUGFydExpc3RzW3R5cGVdPy5sZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIGVuZDogbnVtYmVyLFxuICAgIHBsYXlsaXN0VHlwZTogUGxheWxpc3RMZXZlbFR5cGUsXG4gICAgd2l0aEdhcE9ubHk/OiBib29sZWFuLFxuICAgIHVuYnVmZmVyZWRPbmx5PzogYm9vbGVhblxuICApIHtcbiAgICBpZiAod2l0aEdhcE9ubHkgJiYgIXRoaXMuaGFzR2Fwcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgaWYgKGZyYWcudHlwZSAhPT0gcGxheWxpc3RUeXBlIHx8ICh3aXRoR2FwT25seSAmJiAhZnJhZy5nYXApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgZnJhZy5zdGFydCA8IGVuZCAmJlxuICAgICAgICBmcmFnLmVuZCA+IHN0YXJ0ICYmXG4gICAgICAgIChmcmFnbWVudEVudGl0eS5idWZmZXJlZCB8fCB1bmJ1ZmZlcmVkT25seSlcbiAgICAgICkge1xuICAgICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUZyYWdtZW50KGZyYWdtZW50OiBGcmFnbWVudCkge1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgZnJhZ21lbnQuc3RhdHMubG9hZGVkID0gMDtcbiAgICBmcmFnbWVudC5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCk7XG4gICAgY29uc3QgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tmcmFnbWVudC50eXBlXTtcbiAgICBpZiAoYWN0aXZlUGFydHMpIHtcbiAgICAgIGNvbnN0IHNuVG9SZW1vdmUgPSBmcmFnbWVudC5zbjtcbiAgICAgIHRoaXMuYWN0aXZlUGFydExpc3RzW2ZyYWdtZW50LnR5cGVdID0gYWN0aXZlUGFydHMuZmlsdGVyKFxuICAgICAgICAocGFydCkgPT4gcGFydC5mcmFnbWVudC5zbiAhPT0gc25Ub1JlbW92ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIGlmIChmcmFnbWVudC5lbmRMaXN0KSB7XG4gICAgICBkZWxldGUgdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2ZyYWdtZW50LnR5cGVdO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVBbGxGcmFnbWVudHMoKSB7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZW5kTGlzdEZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuaGFzR2FwcyA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzUGFydGlhbChmcmFnbWVudEVudGl0eTogRnJhZ21lbnRFbnRpdHkpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJlxuICAgIChmcmFnbWVudEVudGl0eS5ib2R5LmdhcCB8fFxuICAgICAgZnJhZ21lbnRFbnRpdHkucmFuZ2UudmlkZW8/LnBhcnRpYWwgfHxcbiAgICAgIGZyYWdtZW50RW50aXR5LnJhbmdlLmF1ZGlvPy5wYXJ0aWFsIHx8XG4gICAgICBmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpb3ZpZGVvPy5wYXJ0aWFsKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRGcmFnbWVudEtleShmcmFnbWVudDogRnJhZ21lbnQpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7ZnJhZ21lbnQudHlwZX1fJHtmcmFnbWVudC5sZXZlbH1fJHtmcmFnbWVudC51cmxJZH1fJHtmcmFnbWVudC5zbn1gO1xufVxuIiwiaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi9mcmFnbWVudCc7XG5pbXBvcnQge1xuICBMb2FkZXIsXG4gIExvYWRlckNvbmZpZ3VyYXRpb24sXG4gIEZyYWdtZW50TG9hZGVyQ29udGV4dCxcbn0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7IGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMgfSBmcm9tICcuLi91dGlscy9lcnJvci1oZWxwZXInO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBCYXNlU2VnbWVudCwgUGFydCB9IGZyb20gJy4vZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUge1xuICBFcnJvckRhdGEsXG4gIEZyYWdMb2FkZWREYXRhLFxuICBQYXJ0c0xvYWRlZERhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5cbmNvbnN0IE1JTl9DSFVOS19TSVpFID0gTWF0aC5wb3coMiwgMTcpOyAvLyAxMjhrYlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGcmFnbWVudExvYWRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBIbHNDb25maWc7XG4gIHByaXZhdGUgbG9hZGVyOiBMb2FkZXI8RnJhZ21lbnRMb2FkZXJDb250ZXh0PiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHBhcnRMb2FkVGltZW91dDogbnVtYmVyID0gLTE7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBIbHNDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgYWJvcnQoKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAvLyBBYm9ydCB0aGUgbG9hZGVyIGZvciBjdXJyZW50IGZyYWdtZW50LiBPbmx5IG9uZSBtYXkgbG9hZCBhdCBhbnkgZ2l2ZW4gdGltZVxuICAgICAgdGhpcy5sb2FkZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cblxuICBsb2FkKFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIG9uUHJvZ3Jlc3M/OiBGcmFnbWVudExvYWRQcm9ncmVzc0NhbGxiYWNrXG4gICk6IFByb21pc2U8RnJhZ0xvYWRlZERhdGE+IHtcbiAgICBjb25zdCB1cmwgPSBmcmFnLnVybDtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZyYWdtZW50IGRvZXMgbm90IGhhdmUgYSAke3VybCA/ICdwYXJ0IGxpc3QnIDogJ3VybCd9YFxuICAgICAgICAgICksXG4gICAgICAgICAgbmV0d29ya0RldGFpbHM6IG51bGwsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmFib3J0KCk7XG5cbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBGcmFnbWVudElMb2FkZXIgPSBjb25maWcuZkxvYWRlcjtcbiAgICBjb25zdCBEZWZhdWx0SUxvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnLmdhcCkge1xuICAgICAgICByZWplY3QoY3JlYXRlR2FwTG9hZEVycm9yKGZyYWcpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVyID1cbiAgICAgICAgKHRoaXMubG9hZGVyID1cbiAgICAgICAgZnJhZy5sb2FkZXIgPVxuICAgICAgICAgIEZyYWdtZW50SUxvYWRlclxuICAgICAgICAgICAgPyBuZXcgRnJhZ21lbnRJTG9hZGVyKGNvbmZpZylcbiAgICAgICAgICAgIDogKG5ldyBEZWZhdWx0SUxvYWRlcihjb25maWcpIGFzIExvYWRlcjxGcmFnbWVudExvYWRlckNvbnRleHQ+KSk7XG4gICAgICBjb25zdCBsb2FkZXJDb250ZXh0ID0gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnKTtcbiAgICAgIGNvbnN0IGxvYWRQb2xpY3kgPSBnZXRMb2FkZXJDb25maWdXaXRob3V0UmV0aWVzKFxuICAgICAgICBjb25maWcuZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGxvYWRlckNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogMCxcbiAgICAgICAgaGlnaFdhdGVyTWFyazogZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyA/IEluZmluaXR5IDogTUlOX0NIVU5LX1NJWkUsXG4gICAgICB9O1xuICAgICAgLy8gQXNzaWduIGZyYWcgc3RhdHMgdG8gdGhlIGxvYWRlcidzIHN0YXRzIHJlZmVyZW5jZVxuICAgICAgZnJhZy5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywge1xuICAgICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIGxldCBwYXlsb2FkID0gcmVzcG9uc2UuZGF0YSBhcyBBcnJheUJ1ZmZlcjtcbiAgICAgICAgICBpZiAoY29udGV4dC5yZXNldElWICYmIGZyYWcuZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgICAgIGZyYWcuZGVjcnlwdGRhdGEuaXYgPSBuZXcgVWludDhBcnJheShwYXlsb2FkLnNsaWNlKDAsIDE2KSk7XG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5zbGljZSgxNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IHsgdXJsLCBkYXRhOiB1bmRlZmluZWQsIC4uLnJlc3BvbnNlIH0sXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYEhUVFAgRXJyb3IgJHtyZXNwb25zZS5jb2RlfSAke3Jlc3BvbnNlLnRleHR9YCksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCxcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdBYm9ydGVkJyksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBUaW1lb3V0IGFmdGVyICR7bG9hZGVyQ29uZmlnLnRpbWVvdXR9bXNgKSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzOiAoc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBkYXRhIGFzIEFycmF5QnVmZmVyLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGxvYWRQYXJ0KFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIHBhcnQ6IFBhcnQsXG4gICAgb25Qcm9ncmVzczogRnJhZ21lbnRMb2FkUHJvZ3Jlc3NDYWxsYmFja1xuICApOiBQcm9taXNlPEZyYWdMb2FkZWREYXRhPiB7XG4gICAgdGhpcy5hYm9ydCgpO1xuXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgRnJhZ21lbnRJTG9hZGVyID0gY29uZmlnLmZMb2FkZXI7XG4gICAgY29uc3QgRGVmYXVsdElMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5nYXAgfHwgcGFydC5nYXApIHtcbiAgICAgICAgcmVqZWN0KGNyZWF0ZUdhcExvYWRFcnJvcihmcmFnLCBwYXJ0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlciA9XG4gICAgICAgICh0aGlzLmxvYWRlciA9XG4gICAgICAgIGZyYWcubG9hZGVyID1cbiAgICAgICAgICBGcmFnbWVudElMb2FkZXJcbiAgICAgICAgICAgID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpXG4gICAgICAgICAgICA6IChuZXcgRGVmYXVsdElMb2FkZXIoY29uZmlnKSBhcyBMb2FkZXI8RnJhZ21lbnRMb2FkZXJDb250ZXh0PikpO1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZywgcGFydCk7XG4gICAgICAvLyBTaG91bGQgd2UgZGVmaW5lIGFub3RoZXIgbG9hZCBwb2xpY3kgZm9yIHBhcnRzP1xuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMoXG4gICAgICAgIGNvbmZpZy5mcmFnTG9hZFBvbGljeS5kZWZhdWx0XG4gICAgICApO1xuICAgICAgY29uc3QgbG9hZGVyQ29uZmlnOiBMb2FkZXJDb25maWd1cmF0aW9uID0ge1xuICAgICAgICBsb2FkUG9saWN5LFxuICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiAwLFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBNSU5fQ0hVTktfU0laRSxcbiAgICAgIH07XG4gICAgICAvLyBBc3NpZ24gcGFydCBzdGF0cyB0byB0aGUgbG9hZGVyJ3Mgc3RhdHMgcmVmZXJlbmNlXG4gICAgICBwYXJ0LnN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCB7XG4gICAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgdGhpcy51cGRhdGVTdGF0c0Zyb21QYXJ0KGZyYWcsIHBhcnQpO1xuICAgICAgICAgIGNvbnN0IHBhcnRMb2FkZWREYXRhOiBGcmFnTG9hZGVkRGF0YSA9IHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgcGF5bG9hZDogcmVzcG9uc2UuZGF0YSBhcyBBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIH07XG4gICAgICAgICAgb25Qcm9ncmVzcyhwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgICAgcmVzb2x2ZShwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICB1cmw6IGxvYWRlckNvbnRleHQudXJsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgSFRUUCBFcnJvciAke3Jlc3BvbnNlLmNvZGV9ICR7cmVzcG9uc2UudGV4dH1gKSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgZnJhZy5zdGF0cy5hYm9ydGVkID0gcGFydC5zdGF0cy5hYm9ydGVkO1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCxcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdBYm9ydGVkJyksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBUaW1lb3V0IGFmdGVyICR7bG9hZGVyQ29uZmlnLnRpbWVvdXR9bXNgKSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVN0YXRzRnJvbVBhcnQoZnJhZzogRnJhZ21lbnQsIHBhcnQ6IFBhcnQpIHtcbiAgICBjb25zdCBmcmFnU3RhdHMgPSBmcmFnLnN0YXRzO1xuICAgIGNvbnN0IHBhcnRTdGF0cyA9IHBhcnQuc3RhdHM7XG4gICAgY29uc3QgcGFydFRvdGFsID0gcGFydFN0YXRzLnRvdGFsO1xuICAgIGZyYWdTdGF0cy5sb2FkZWQgKz0gcGFydFN0YXRzLmxvYWRlZDtcbiAgICBpZiAocGFydFRvdGFsKSB7XG4gICAgICBjb25zdCBlc3RUb3RhbFBhcnRzID0gTWF0aC5yb3VuZChmcmFnLmR1cmF0aW9uIC8gcGFydC5kdXJhdGlvbik7XG4gICAgICBjb25zdCBlc3RMb2FkZWRQYXJ0cyA9IE1hdGgubWluKFxuICAgICAgICBNYXRoLnJvdW5kKGZyYWdTdGF0cy5sb2FkZWQgLyBwYXJ0VG90YWwpLFxuICAgICAgICBlc3RUb3RhbFBhcnRzXG4gICAgICApO1xuICAgICAgY29uc3QgZXN0UmVtYWluaW5nUGFydHMgPSBlc3RUb3RhbFBhcnRzIC0gZXN0TG9hZGVkUGFydHM7XG4gICAgICBjb25zdCBlc3RSZW1haW5pbmdCeXRlcyA9XG4gICAgICAgIGVzdFJlbWFpbmluZ1BhcnRzICogTWF0aC5yb3VuZChmcmFnU3RhdHMubG9hZGVkIC8gZXN0TG9hZGVkUGFydHMpO1xuICAgICAgZnJhZ1N0YXRzLnRvdGFsID0gZnJhZ1N0YXRzLmxvYWRlZCArIGVzdFJlbWFpbmluZ0J5dGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnU3RhdHMudG90YWwgPSBNYXRoLm1heChmcmFnU3RhdHMubG9hZGVkLCBmcmFnU3RhdHMudG90YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcmFnTG9hZGluZyA9IGZyYWdTdGF0cy5sb2FkaW5nO1xuICAgIGNvbnN0IHBhcnRMb2FkaW5nID0gcGFydFN0YXRzLmxvYWRpbmc7XG4gICAgaWYgKGZyYWdMb2FkaW5nLnN0YXJ0KSB7XG4gICAgICAvLyBhZGQgdG8gZnJhZ21lbnQgbG9hZGVyIGxhdGVuY3lcbiAgICAgIGZyYWdMb2FkaW5nLmZpcnN0ICs9IHBhcnRMb2FkaW5nLmZpcnN0IC0gcGFydExvYWRpbmcuc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdMb2FkaW5nLnN0YXJ0ID0gcGFydExvYWRpbmcuc3RhcnQ7XG4gICAgICBmcmFnTG9hZGluZy5maXJzdCA9IHBhcnRMb2FkaW5nLmZpcnN0O1xuICAgIH1cbiAgICBmcmFnTG9hZGluZy5lbmQgPSBwYXJ0TG9hZGluZy5lbmQ7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0TG9hZGVyKGZyYWc6IEZyYWdtZW50LCBsb2FkZXI6IExvYWRlcjxGcmFnbWVudExvYWRlckNvbnRleHQ+KSB7XG4gICAgZnJhZy5sb2FkZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLmxvYWRlciA9PT0gbG9hZGVyKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnBhcnRMb2FkVGltZW91dCk7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICAgIGxvYWRlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9hZGVyQ29udGV4dChcbiAgZnJhZzogRnJhZ21lbnQsXG4gIHBhcnQ6IFBhcnQgfCBudWxsID0gbnVsbFxuKTogRnJhZ21lbnRMb2FkZXJDb250ZXh0IHtcbiAgY29uc3Qgc2VnbWVudDogQmFzZVNlZ21lbnQgPSBwYXJ0IHx8IGZyYWc7XG4gIGNvbnN0IGxvYWRlckNvbnRleHQ6IEZyYWdtZW50TG9hZGVyQ29udGV4dCA9IHtcbiAgICBmcmFnLFxuICAgIHBhcnQsXG4gICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgIHVybDogc2VnbWVudC51cmwsXG4gICAgaGVhZGVyczoge30sXG4gICAgcmFuZ2VTdGFydDogMCxcbiAgICByYW5nZUVuZDogMCxcbiAgfTtcbiAgY29uc3Qgc3RhcnQgPSBzZWdtZW50LmJ5dGVSYW5nZVN0YXJ0T2Zmc2V0O1xuICBjb25zdCBlbmQgPSBzZWdtZW50LmJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShzdGFydCkgJiYgTnVtYmVyLmlzRmluaXRlKGVuZCkpIHtcbiAgICBsZXQgYnl0ZVJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICBsZXQgYnl0ZVJhbmdlRW5kID0gZW5kO1xuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnICYmIGZyYWcuZGVjcnlwdGRhdGE/Lm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICAvLyBNQVAgc2VnbWVudCBlbmNyeXB0ZWQgd2l0aCBtZXRob2QgJ0FFUy0xMjgnLCB3aGVuIHNlcnZlZCB3aXRoIEhUVFAgUmFuZ2UsXG4gICAgICAvLyBoYXMgdGhlIHVuZW5jcnlwdGVkIHNpemUgc3BlY2lmaWVkIGluIHRoZSByYW5nZS5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBhbnRvcy1obHMtcmZjODIxNmJpcy0wOCNzZWN0aW9uLTYuMy42XG4gICAgICBjb25zdCBmcmFnbWVudExlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgaWYgKGZyYWdtZW50TGVuICUgMTYpIHtcbiAgICAgICAgYnl0ZVJhbmdlRW5kID0gZW5kICsgKDE2IC0gKGZyYWdtZW50TGVuICUgMTYpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPT0gMCkge1xuICAgICAgICBsb2FkZXJDb250ZXh0LnJlc2V0SVYgPSB0cnVlO1xuICAgICAgICBieXRlUmFuZ2VTdGFydCA9IHN0YXJ0IC0gMTY7XG4gICAgICB9XG4gICAgfVxuICAgIGxvYWRlckNvbnRleHQucmFuZ2VTdGFydCA9IGJ5dGVSYW5nZVN0YXJ0O1xuICAgIGxvYWRlckNvbnRleHQucmFuZ2VFbmQgPSBieXRlUmFuZ2VFbmQ7XG4gIH1cbiAgcmV0dXJuIGxvYWRlckNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdhcExvYWRFcnJvcihmcmFnOiBGcmFnbWVudCwgcGFydD86IFBhcnQpOiBMb2FkRXJyb3Ige1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgR0FQICR7ZnJhZy5nYXAgPyAndGFnJyA6ICdhdHRyaWJ1dGUnfSBmb3VuZGApO1xuICBjb25zdCBlcnJvckRhdGE6IEZyYWdMb2FkRmFpbFJlc3VsdCA9IHtcbiAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0dBUCxcbiAgICBmYXRhbDogZmFsc2UsXG4gICAgZnJhZyxcbiAgICBlcnJvcixcbiAgICBuZXR3b3JrRGV0YWlsczogbnVsbCxcbiAgfTtcbiAgaWYgKHBhcnQpIHtcbiAgICBlcnJvckRhdGEucGFydCA9IHBhcnQ7XG4gIH1cbiAgKHBhcnQgPyBwYXJ0IDogZnJhZykuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gIHJldHVybiBuZXcgTG9hZEVycm9yKGVycm9yRGF0YSk7XG59XG5cbmV4cG9ydCBjbGFzcyBMb2FkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBkYXRhOiBGcmFnTG9hZEZhaWxSZXN1bHQ7XG4gIGNvbnN0cnVjdG9yKGRhdGE6IEZyYWdMb2FkRmFpbFJlc3VsdCkge1xuICAgIHN1cGVyKGRhdGEuZXJyb3IubWVzc2FnZSk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZyYWdMb2FkRmFpbFJlc3VsdCBleHRlbmRzIEVycm9yRGF0YSB7XG4gIGZyYWc6IEZyYWdtZW50O1xuICBwYXJ0PzogUGFydDtcbiAgcmVzcG9uc2U/OiB7XG4gICAgZGF0YTogYW55O1xuICAgIC8vIGVycm9yIHN0YXR1cyBjb2RlXG4gICAgY29kZTogbnVtYmVyO1xuICAgIC8vIGVycm9yIGRlc2NyaXB0aW9uXG4gICAgdGV4dDogc3RyaW5nO1xuICAgIHVybDogc3RyaW5nO1xuICB9O1xuICBuZXR3b3JrRGV0YWlsczogYW55O1xufVxuXG5leHBvcnQgdHlwZSBGcmFnbWVudExvYWRQcm9ncmVzc0NhbGxiYWNrID0gKFxuICByZXN1bHQ6IEZyYWdMb2FkZWREYXRhIHwgUGFydHNMb2FkZWREYXRhXG4pID0+IHZvaWQ7XG4iLCJpbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtcbiAgTG9hZGVyU3RhdHMsXG4gIExvYWRlclJlc3BvbnNlLFxuICBMb2FkZXJDb25maWd1cmF0aW9uLFxuICBMb2FkZXJDYWxsYmFja3MsXG4gIExvYWRlcixcbiAgS2V5TG9hZGVyQ29udGV4dCxcbiAgUGxheWxpc3RMZXZlbFR5cGUsXG59IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgeyBMb2FkRXJyb3IgfSBmcm9tICcuL2ZyYWdtZW50LWxvYWRlcic7XG5pbXBvcnQgdHlwZSB7IEhsc0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IEZyYWdtZW50IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSB7IEtleUxvYWRlZERhdGEgfSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBMZXZlbEtleSB9IGZyb20gJy4vbGV2ZWwta2V5JztcbmltcG9ydCB0eXBlIEVNRUNvbnRyb2xsZXIgZnJvbSAnLi4vY29udHJvbGxlci9lbWUtY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSB7IE1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgfSBmcm9tICcuLi9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIHsgS2V5U3lzdGVtRm9ybWF0cyB9IGZyb20gJy4uL3V0aWxzL21lZGlha2V5cy1oZWxwZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIEtleUxvYWRlckluZm8ge1xuICBkZWNyeXB0ZGF0YTogTGV2ZWxLZXk7XG4gIGtleUxvYWRQcm9taXNlOiBQcm9taXNlPEtleUxvYWRlZERhdGE+IHwgbnVsbDtcbiAgbG9hZGVyOiBMb2FkZXI8S2V5TG9hZGVyQ29udGV4dD4gfCBudWxsO1xuICBtZWRpYUtleVNlc3Npb25Db250ZXh0OiBNZWRpYUtleVNlc3Npb25Db250ZXh0IHwgbnVsbDtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtleUxvYWRlciBpbXBsZW1lbnRzIENvbXBvbmVudEFQSSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBIbHNDb25maWc7XG4gIHB1YmxpYyBrZXlVcmlUb0tleUluZm86IHsgW2tleXVyaTogc3RyaW5nXTogS2V5TG9hZGVySW5mbyB9ID0ge307XG4gIHB1YmxpYyBlbWVDb250cm9sbGVyOiBFTUVDb250cm9sbGVyIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBIbHNDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuXG4gIGFib3J0KHR5cGU/OiBQbGF5bGlzdExldmVsVHlwZSkge1xuICAgIGZvciAoY29uc3QgdXJpIGluIHRoaXMua2V5VXJpVG9LZXlJbmZvKSB7XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldLmxvYWRlcjtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgaWYgKHR5cGUgJiYgdHlwZSAhPT0gbG9hZGVyLmNvbnRleHQuZnJhZy50eXBlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICBmb3IgKGNvbnN0IHVyaSBpbiB0aGlzLmtleVVyaVRvS2V5SW5mbykge1xuICAgICAgY29uc3Qga2V5SW5mbyA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgICAvLyBSZW1vdmUgY2FjaGVkIEVNRSBrZXlzIG9uIGRldGFjaFxuICAgICAgaWYgKFxuICAgICAgICBrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgfHxcbiAgICAgICAga2V5SW5mby5kZWNyeXB0ZGF0YS5pc0NvbW1vbkVuY3J5cHRpb25cbiAgICAgICkge1xuICAgICAgICBkZWxldGUgdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0ubG9hZGVyO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmtleVVyaVRvS2V5SW5mbyA9IHt9O1xuICB9XG5cbiAgY3JlYXRlS2V5TG9hZEVycm9yKFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIGRldGFpbHM6IEVycm9yRGV0YWlscyA9IEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUixcbiAgICBlcnJvcjogRXJyb3IsXG4gICAgbmV0d29ya0RldGFpbHM/OiBhbnksXG4gICAgcmVzcG9uc2U/OiB7IHVybDogc3RyaW5nOyBkYXRhOiB1bmRlZmluZWQ7IGNvZGU6IG51bWJlcjsgdGV4dDogc3RyaW5nIH1cbiAgKTogTG9hZEVycm9yIHtcbiAgICByZXR1cm4gbmV3IExvYWRFcnJvcih7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZnJhZyxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgZXJyb3IsXG4gICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICB9KTtcbiAgfVxuXG4gIGxvYWRDbGVhcihcbiAgICBsb2FkaW5nRnJhZzogRnJhZ21lbnQsXG4gICAgZW5jcnlwdGVkRnJhZ21lbnRzOiBGcmFnbWVudFtdXG4gICk6IHZvaWQgfCBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgIC8vIGFjY2VzcyBrZXktc3lzdGVtIHdpdGggbmVhcmVzdCBrZXkgb24gc3RhcnQgKGxvYWlkbmcgZnJhZyBpcyB1bmVuY3J5cHRlZClcbiAgICAgIGNvbnN0IHsgc24sIGNjIH0gPSBsb2FkaW5nRnJhZztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZyYWcgPSBlbmNyeXB0ZWRGcmFnbWVudHNbaV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjYyA8PSBmcmFnLmNjICYmXG4gICAgICAgICAgKHNuID09PSAnaW5pdFNlZ21lbnQnIHx8IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgfHwgc24gPCBmcmFnLnNuKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmVtZUNvbnRyb2xsZXJcbiAgICAgICAgICAgIC5zZWxlY3RLZXlTeXN0ZW1Gb3JtYXQoZnJhZylcbiAgICAgICAgICAgIC50aGVuKChrZXlTeXN0ZW1Gb3JtYXQpID0+IHtcbiAgICAgICAgICAgICAgZnJhZy5zZXRLZXlGb3JtYXQoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9hZChmcmFnOiBGcmFnbWVudCk6IFByb21pc2U8S2V5TG9hZGVkRGF0YT4ge1xuICAgIGlmICghZnJhZy5kZWNyeXB0ZGF0YSAmJiBmcmFnLmVuY3J5cHRlZCAmJiB0aGlzLmVtZUNvbnRyb2xsZXIpIHtcbiAgICAgIC8vIE11bHRpcGxlIGtleXMsIGJ1dCBub25lIHNlbGVjdGVkLCByZXNvbHZlIGluIGVtZS1jb250cm9sbGVyXG4gICAgICByZXR1cm4gdGhpcy5lbWVDb250cm9sbGVyXG4gICAgICAgIC5zZWxlY3RLZXlTeXN0ZW1Gb3JtYXQoZnJhZylcbiAgICAgICAgLnRoZW4oKGtleVN5c3RlbUZvcm1hdCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRJbnRlcm5hbChmcmFnLCBrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sb2FkSW50ZXJuYWwoZnJhZyk7XG4gIH1cblxuICBsb2FkSW50ZXJuYWwoXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAga2V5U3lzdGVtRm9ybWF0PzogS2V5U3lzdGVtRm9ybWF0c1xuICApOiBQcm9taXNlPEtleUxvYWRlZERhdGE+IHtcbiAgICBpZiAoa2V5U3lzdGVtRm9ybWF0KSB7XG4gICAgICBmcmFnLnNldEtleUZvcm1hdChrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgaWYgKCFkZWNyeXB0ZGF0YSkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGtleVN5c3RlbUZvcm1hdFxuICAgICAgICAgID8gYEV4cGVjdGVkIGZyYWcuZGVjcnlwdGRhdGEgdG8gYmUgZGVmaW5lZCBhZnRlciBzZXR0aW5nIGZvcm1hdCAke2tleVN5c3RlbUZvcm1hdH1gXG4gICAgICAgICAgOiAnTWlzc2luZyBkZWNyeXB0aW9uIGRhdGEgb24gZnJhZ21lbnQgaW4gb25LZXlMb2FkaW5nJ1xuICAgICAgKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgdGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBlcnJvcilcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHVyaSA9IGRlY3J5cHRkYXRhLnVyaTtcbiAgICBpZiAoIXVyaSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICB0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUixcbiAgICAgICAgICBuZXcgRXJyb3IoYEludmFsaWQga2V5IFVSSTogXCIke3VyaX1cImApXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBrZXlJbmZvID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXTtcblxuICAgIGlmIChrZXlJbmZvPy5kZWNyeXB0ZGF0YS5rZXkpIHtcbiAgICAgIGRlY3J5cHRkYXRhLmtleSA9IGtleUluZm8uZGVjcnlwdGRhdGEua2V5O1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGZyYWcsIGtleUluZm8gfSk7XG4gICAgfVxuICAgIC8vIFJldHVybiBrZXkgbG9hZCBwcm9taXNlIGFzIGxvbmcgYXMgaXQgZG9lcyBub3QgaGF2ZSBhIG1lZGlha2V5IHNlc3Npb24gd2l0aCBhbiB1bnVzYWJsZSBrZXkgc3RhdHVzXG4gICAgaWYgKGtleUluZm8/LmtleUxvYWRQcm9taXNlKSB7XG4gICAgICBzd2l0Y2ggKGtleUluZm8ubWVkaWFLZXlTZXNzaW9uQ29udGV4dD8ua2V5U3RhdHVzKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICdzdGF0dXMtcGVuZGluZyc6XG4gICAgICAgIGNhc2UgJ3VzYWJsZSc6XG4gICAgICAgIGNhc2UgJ3VzYWJsZS1pbi1mdXR1cmUnOlxuICAgICAgICAgIHJldHVybiBrZXlJbmZvLmtleUxvYWRQcm9taXNlLnRoZW4oKGtleUxvYWRlZERhdGEpID0+IHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY29ycmVjdCBmcmFnbWVudCB3aXRoIHVwZGF0ZWQgZGVjcnlwdGRhdGEga2V5IGFuZCBsb2FkZWQga2V5SW5mb1xuICAgICAgICAgICAgZGVjcnlwdGRhdGEua2V5ID0ga2V5TG9hZGVkRGF0YS5rZXlJbmZvLmRlY3J5cHRkYXRhLmtleTtcbiAgICAgICAgICAgIHJldHVybiB7IGZyYWcsIGtleUluZm8gfTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGhhdmUgYSBrZXkgc2Vzc2lvbiBhbmQgc3RhdHVzIGFuZCBpdCBpcyBub3QgcGVuZGluZyBvciB1c2FibGUsIGNvbnRpbnVlXG4gICAgICAvLyBUaGlzIHdpbGwgZ28gYmFjayB0byB0aGUgZW1lLWNvbnRyb2xsZXIgZm9yIGV4cGlyZWQga2V5cyB0byBnZXQgYSBuZXcga2V5TG9hZFByb21pc2VcbiAgICB9XG5cbiAgICAvLyBMb2FkIHRoZSBrZXkgb3IgcmV0dXJuIHRoZSBsb2FkaW5nIHByb21pc2VcbiAgICBrZXlJbmZvID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXSA9IHtcbiAgICAgIGRlY3J5cHRkYXRhLFxuICAgICAga2V5TG9hZFByb21pc2U6IG51bGwsXG4gICAgICBsb2FkZXI6IG51bGwsXG4gICAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0OiBudWxsLFxuICAgIH07XG5cbiAgICBzd2l0Y2ggKGRlY3J5cHRkYXRhLm1ldGhvZCkge1xuICAgICAgY2FzZSAnSVNPLTIzMDAxLTcnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUyc6XG4gICAgICBjYXNlICdTQU1QTEUtQUVTLUNFTkMnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUy1DVFInOlxuICAgICAgICBpZiAoZGVjcnlwdGRhdGEua2V5Rm9ybWF0ID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgLy8gbG9hZEtleUhUVFAgaGFuZGxlcyBodHRwKHMpIGFuZCBkYXRhIFVSTHNcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5RU1FKGtleUluZm8sIGZyYWcpO1xuICAgICAgY2FzZSAnQUVTLTEyOCc6XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRLZXlIVFRQKGtleUluZm8sIGZyYWcpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgIHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUixcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEtleSBzdXBwbGllZCB3aXRoIHVuc3VwcG9ydGVkIE1FVEhPRDogXCIke2RlY3J5cHRkYXRhLm1ldGhvZH1cImBcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgbG9hZEtleUVNRShrZXlJbmZvOiBLZXlMb2FkZXJJbmZvLCBmcmFnOiBGcmFnbWVudCk6IFByb21pc2U8S2V5TG9hZGVkRGF0YT4ge1xuICAgIGNvbnN0IGtleUxvYWRlZERhdGE6IEtleUxvYWRlZERhdGEgPSB7IGZyYWcsIGtleUluZm8gfTtcbiAgICBpZiAodGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9XG4gICAgICAgIHRoaXMuZW1lQ29udHJvbGxlci5sb2FkS2V5KGtleUxvYWRlZERhdGEpO1xuICAgICAgaWYgKGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gKGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UudGhlbihcbiAgICAgICAgICAoa2V5U2Vzc2lvbkNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGtleUluZm8ubWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9IGtleVNlc3Npb25Db250ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIGtleUxvYWRlZERhdGE7XG4gICAgICAgICAgfVxuICAgICAgICApKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAvLyBSZW1vdmUgcHJvbWlzZSBmb3IgbGljZW5zZSByZW5ld2FsIG9yIHJldHJ5XG4gICAgICAgICAga2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleUxvYWRlZERhdGEpO1xuICB9XG5cbiAgbG9hZEtleUhUVFAoa2V5SW5mbzogS2V5TG9hZGVySW5mbywgZnJhZzogRnJhZ21lbnQpOiBQcm9taXNlPEtleUxvYWRlZERhdGE+IHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IGtleUxvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKSBhcyBMb2FkZXI8S2V5TG9hZGVyQ29udGV4dD47XG4gICAgZnJhZy5rZXlMb2FkZXIgPSBrZXlJbmZvLmxvYWRlciA9IGtleUxvYWRlcjtcblxuICAgIHJldHVybiAoa2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQ6IEtleUxvYWRlckNvbnRleHQgPSB7XG4gICAgICAgIGtleUluZm8sXG4gICAgICAgIGZyYWcsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgICAgdXJsOiBrZXlJbmZvLmRlY3J5cHRkYXRhLnVyaSxcbiAgICAgIH07XG5cbiAgICAgIC8vIG1heFJldHJ5IGlzIDAgc28gdGhhdCBpbnN0ZWFkIG9mIHJldHJ5aW5nIHRoZSBzYW1lIGtleSBvbiB0aGUgc2FtZSB2YXJpYW50IG11bHRpcGxlIHRpbWVzLFxuICAgICAgLy8ga2V5LWxvYWRlciB3aWxsIHRyaWdnZXIgYW4gZXJyb3IgYW5kIHJlbHkgb24gc3RyZWFtLWNvbnRyb2xsZXIgdG8gaGFuZGxlIHJldHJ5IGxvZ2ljLlxuICAgICAgLy8gdGhpcyB3aWxsIGFsc28gYWxpZ24gcmV0cnkgbG9naWMgd2l0aCBmcmFnbWVudC1sb2FkZXJcbiAgICAgIGNvbnN0IGxvYWRQb2xpY3kgPSBjb25maWcua2V5TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgICAgY29uc3QgbG9hZGVyQ29uZmlnOiBMb2FkZXJDb25maWd1cmF0aW9uID0ge1xuICAgICAgICBsb2FkUG9saWN5LFxuICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiAwLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbG9hZGVyQ2FsbGJhY2tzOiBMb2FkZXJDYWxsYmFja3M8S2V5TG9hZGVyQ29udGV4dD4gPSB7XG4gICAgICAgIG9uU3VjY2VzczogKFxuICAgICAgICAgIHJlc3BvbnNlOiBMb2FkZXJSZXNwb25zZSxcbiAgICAgICAgICBzdGF0czogTG9hZGVyU3RhdHMsXG4gICAgICAgICAgY29udGV4dDogS2V5TG9hZGVyQ29udGV4dCxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogYW55XG4gICAgICAgICkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZnJhZywga2V5SW5mbywgdXJsOiB1cmkgfSA9IGNvbnRleHQ7XG4gICAgICAgICAgaWYgKCFmcmFnLmRlY3J5cHRkYXRhIHx8IGtleUluZm8gIT09IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICAgIHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKFxuICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvcignYWZ0ZXIga2V5IGxvYWQsIGRlY3J5cHRkYXRhIHVuc2V0IG9yIGNoYW5nZWQnKSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleUluZm8uZGVjcnlwdGRhdGEua2V5ID0gZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgYXMgQXJyYXlCdWZmZXJcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gZGV0YWNoIGZyYWdtZW50IGtleSBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgICAgICAgZnJhZy5rZXlMb2FkZXIgPSBudWxsO1xuICAgICAgICAgIGtleUluZm8ubG9hZGVyID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlKHsgZnJhZywga2V5SW5mbyB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkVycm9yOiAoXG4gICAgICAgICAgcmVzcG9uc2U6IHsgY29kZTogbnVtYmVyOyB0ZXh0OiBzdHJpbmcgfSxcbiAgICAgICAgICBjb250ZXh0OiBLZXlMb2FkZXJDb250ZXh0LFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBhbnksXG4gICAgICAgICAgc3RhdHM6IExvYWRlclN0YXRzXG4gICAgICAgICkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgdGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoXG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUixcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBIVFRQIEVycm9yICR7cmVzcG9uc2UuY29kZX0gbG9hZGluZyBrZXkgJHtyZXNwb25zZS50ZXh0fWBcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICAgIHsgdXJsOiBsb2FkZXJDb250ZXh0LnVybCwgZGF0YTogdW5kZWZpbmVkLCAuLi5yZXNwb25zZSB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblRpbWVvdXQ6IChcbiAgICAgICAgICBzdGF0czogTG9hZGVyU3RhdHMsXG4gICAgICAgICAgY29udGV4dDogS2V5TG9hZGVyQ29udGV4dCxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogYW55XG4gICAgICAgICkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgdGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoXG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VULFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIHRpbWVkIG91dCcpLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25BYm9ydDogKFxuICAgICAgICAgIHN0YXRzOiBMb2FkZXJTdGF0cyxcbiAgICAgICAgICBjb250ZXh0OiBLZXlMb2FkZXJDb250ZXh0LFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBhbnlcbiAgICAgICAgKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQsXG4gICAgICAgICAgICAgIG5ldyBFcnJvcigna2V5IGxvYWRpbmcgYWJvcnRlZCcpLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBrZXlMb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgfSkpO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNldExvYWRlcihjb250ZXh0OiBLZXlMb2FkZXJDb250ZXh0KSB7XG4gICAgY29uc3QgeyBmcmFnLCBrZXlJbmZvLCB1cmw6IHVyaSB9ID0gY29udGV4dDtcbiAgICBjb25zdCBsb2FkZXIgPSBrZXlJbmZvLmxvYWRlcjtcbiAgICBpZiAoZnJhZy5rZXlMb2FkZXIgPT09IGxvYWRlcikge1xuICAgICAgZnJhZy5rZXlMb2FkZXIgPSBudWxsO1xuICAgICAga2V5SW5mby5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAaWdub3JlXG4gKiBTdWItY2xhc3Mgc3BlY2lhbGl6YXRpb24gb2YgRXZlbnRIYW5kbGVyIGJhc2UgY2xhc3MuXG4gKlxuICogVGFza0xvb3AgYWxsb3dzIHRvIHNjaGVkdWxlIGEgdGFzayBmdW5jdGlvbiBiZWluZyBjYWxsZWQgKG9wdGlvbm5hbHkgcmVwZWF0ZWRseSkgb24gdGhlIG1haW4gbG9vcCxcbiAqIHNjaGVkdWxlZCBhc3luY2hyb25lb3VzbHksIGF2b2lkaW5nIHJlY3Vyc2l2ZSBjYWxscyBpbiB0aGUgc2FtZSB0aWNrLlxuICpcbiAqIFRoZSB0YXNrIGl0c2VsZiBpcyBpbXBsZW1lbnRlZCBpbiBgZG9UaWNrYC4gSXQgY2FuIGJlIHJlcXVlc3RlZCBhbmQgY2FsbGVkIGZvciBzaW5nbGUgZXhlY3V0aW9uXG4gKiB1c2luZyB0aGUgYHRpY2tgIG1ldGhvZC5cbiAqXG4gKiBJdCB3aWxsIGJlIGFzc3VyZWQgdGhhdCB0aGUgdGFzayBleGVjdXRpb24gbWV0aG9kIChgdGlja2ApIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgbWFpbiBsb29wIFwidGlja1wiLFxuICogbm8gbWF0dGVyIGhvdyBvZnRlbiBpdCBnZXRzIHJlcXVlc3RlZCBmb3IgZXhlY3V0aW9uLiBFeGVjdXRpb24gaW4gZnVydGhlciB0aWNrcyB3aWxsIGJlIHNjaGVkdWxlZCBhY2NvcmRpbmdseS5cbiAqXG4gKiBJZiBmdXJ0aGVyIGV4ZWN1dGlvbiByZXF1ZXN0cyBoYXZlIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQgb24gdGhlIG5leHQgdGljaywgaXQgY2FuIGJlIGNoZWNrZWQgd2l0aCBgaGFzTmV4dFRpY2tgLFxuICogYW5kIGNhbmNlbGxlZCB3aXRoIGBjbGVhck5leHRUaWNrYC5cbiAqXG4gKiBUaGUgdGFzayBjYW4gYmUgc2NoZWR1bGVkIGFzIGFuIGludGVydmFsIHJlcGVhdGVkbHkgd2l0aCBhIHBlcmlvZCBhcyBwYXJhbWV0ZXIgKHNlZSBgc2V0SW50ZXJ2YWxgLCBgY2xlYXJJbnRlcnZhbGApLlxuICpcbiAqIFN1Yi1jbGFzc2VzIG5lZWQgdG8gaW1wbGVtZW50IHRoZSBgZG9UaWNrYCBtZXRob2Qgd2hpY2ggd2lsbCBlZmZlY3RpdmVseSBoYXZlIHRoZSB0YXNrIGV4ZWN1dGlvbiByb3V0aW5lLlxuICpcbiAqIEZ1cnRoZXIgZXhwbGFuYXRpb25zOlxuICpcbiAqIFRoZSBiYXNlY2xhc3MgaGFzIGEgYHRpY2tgIG1ldGhvZCB0aGF0IHdpbGwgc2NoZWR1bGUgdGhlIGRvVGljayBjYWxsLiBJdCBtYXkgYmUgY2FsbGVkIHN5bmNocm9uZW91c2x5XG4gKiBvbmx5IGZvciBhIHN0YWNrLWRlcHRoIG9mIG9uZS4gT24gcmUtZW50cmFudCBjYWxscywgc3ViLXNlcXVlbnQgY2FsbHMgYXJlIHNjaGVkdWxlZCBmb3IgbmV4dCBtYWluIGxvb3AgdGlja3MuXG4gKlxuICogV2hlbiB0aGUgdGFzayBleGVjdXRpb24gKGB0aWNrYCBtZXRob2QpIGlzIGNhbGxlZCBpbiByZS1lbnRyYW50IHdheSB0aGlzIGlzIGRldGVjdGVkIGFuZFxuICogd2UgYXJlIGxpbWl0aW5nIHRoZSB0YXNrIGV4ZWN1dGlvbiBwZXIgY2FsbCBzdGFjayB0byBleGFjdGx5IG9uZSwgYnV0IHNjaGVkdWxpbmcvcG9zdC1wb25pbmcgZnVydGhlclxuICogdGFzayBwcm9jZXNzaW5nIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gKGFsc28ga25vd24gYXMgXCJuZXh0IHRpY2tcIiBpbiB0aGUgTm9kZS9KUyBydW50aW1lIGxpbmdvKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFza0xvb3Age1xuICBwcml2YXRlIHJlYWRvbmx5IF9ib3VuZFRpY2s6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgX3RpY2tUaW1lcjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX3RpY2tJbnRlcnZhbDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX3RpY2tDYWxsQ291bnQgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2JvdW5kVGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95ZWQoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIC8vIGNsZWFyIGFsbCB0aW1lcnMgYmVmb3JlIHVucmVnaXN0ZXJpbmcgZnJvbSBldmVudCBidXNcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkhhbmRsZXJEZXN0cm95ZWQoKSB7fVxuXG4gIHB1YmxpYyBoYXNJbnRlcnZhbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLl90aWNrSW50ZXJ2YWw7XG4gIH1cblxuICBwdWJsaWMgaGFzTmV4dFRpY2soKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja1RpbWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBtaWxsaXMgLSBJbnRlcnZhbCB0aW1lIChtcylcbiAgICogQGV0dXJucyBUcnVlIHdoZW4gaW50ZXJ2YWwgaGFzIGJlZW4gc2NoZWR1bGVkLCBmYWxzZSB3aGVuIGFscmVhZHkgc2NoZWR1bGVkIChubyBlZmZlY3QpXG4gICAqL1xuICBwdWJsaWMgc2V0SW50ZXJ2YWwobWlsbGlzOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBzZWxmLnNldEludGVydmFsKHRoaXMuX2JvdW5kVGljaywgbWlsbGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgVHJ1ZSB3aGVuIGludGVydmFsIHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgKi9cbiAgcHVibGljIGNsZWFySW50ZXJ2YWwoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuX3RpY2tJbnRlcnZhbCk7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBUcnVlIHdoZW4gdGltZW91dCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIHB1YmxpYyBjbGVhck5leHRUaWNrKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLl90aWNrVGltZXIpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMuX3RpY2tUaW1lcik7XG4gICAgICB0aGlzLl90aWNrVGltZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIGNhbGwgdGhlIHN1YmNsYXNzIGRvVGljayBpbXBsZW1lbnRhdGlvbiBpbiB0aGlzIG1haW4gbG9vcCB0aWNrXG4gICAqIG9yIGluIHRoZSBuZXh0IG9uZSAodmlhIHNldFRpbWVvdXQoLDApKSBpbiBjYXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXG4gICAqIGluIHRoaXMgdGljayAoaW4gY2FzZSB0aGlzIGlzIGEgcmUtZW50cmFudCBjYWxsKS5cbiAgICovXG4gIHB1YmxpYyB0aWNrKCk6IHZvaWQge1xuICAgIHRoaXMuX3RpY2tDYWxsQ291bnQrKztcbiAgICBpZiAodGhpcy5fdGlja0NhbGxDb3VudCA9PT0gMSkge1xuICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgIC8vIHJlLWVudHJhbnQgY2FsbCB0byB0aWNrIGZyb20gcHJldmlvdXMgZG9UaWNrIGNhbGwgc3RhY2tcbiAgICAgIC8vIC0+IHNjaGVkdWxlIGEgY2FsbCBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIHRvIHByb2Nlc3MgdGhpcyB0YXNrIHByb2Nlc3NpbmcgcmVxdWVzdFxuICAgICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPiAxKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBvbmx5IG9uZSB0aW1lciBleGlzdHMgYXQgYW55IHRpbWUgYXQgbWF4XG4gICAgICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHRpY2tJbW1lZGlhdGUoKTogdm9pZCB7XG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5fdGlja1RpbWVyID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMuX2JvdW5kVGljaywgMCk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIHN1YmNsYXNzIHRvIGltcGxlbWVudCB0YXNrIGxvZ2ljXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgcHJvdGVjdGVkIGRvVGljaygpOiB2b2lkIHt9XG59XG4iLCIvKipcbiAqIFByb3ZpZGVzIG1ldGhvZHMgZGVhbGluZyB3aXRoIGJ1ZmZlciBsZW5ndGggcmV0cmlldmFsIGZvciBleGFtcGxlLlxuICpcbiAqIEluIGdlbmVyYWwsIGEgaGVscGVyIGFyb3VuZCBIVE1MNSBNZWRpYUVsZW1lbnQgVGltZVJhbmdlcyBnYXRoZXJlZCBmcm9tIGBidWZmZXJlZGAgcHJvcGVydHkuXG4gKlxuICogQWxzbyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L2J1ZmZlcmVkXG4gKi9cblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuXG50eXBlIEJ1ZmZlclRpbWVSYW5nZSA9IHtcbiAgc3RhcnQ6IG51bWJlcjtcbiAgZW5kOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBCdWZmZXJhYmxlID0ge1xuICBidWZmZXJlZDogVGltZVJhbmdlcztcbn07XG5cbmV4cG9ydCB0eXBlIEJ1ZmZlckluZm8gPSB7XG4gIGxlbjogbnVtYmVyO1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbiAgbmV4dFN0YXJ0PzogbnVtYmVyO1xufTtcblxuY29uc3Qgbm9vcEJ1ZmZlcmVkOiBUaW1lUmFuZ2VzID0ge1xuICBsZW5ndGg6IDAsXG4gIHN0YXJ0OiAoKSA9PiAwLFxuICBlbmQ6ICgpID0+IDAsXG59O1xuXG5leHBvcnQgY2xhc3MgQnVmZmVySGVscGVyIHtcbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGBtZWRpYWAncyBidWZmZXJlZCBpbmNsdWRlIGBwb3NpdGlvbmBcbiAgICovXG4gIHN0YXRpYyBpc0J1ZmZlcmVkKG1lZGlhOiBCdWZmZXJhYmxlLCBwb3NpdGlvbjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBjb25zdCBidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocG9zaXRpb24gPj0gYnVmZmVyZWQuc3RhcnQoaSkgJiYgcG9zaXRpb24gPD0gYnVmZmVyZWQuZW5kKGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gdGhpcyBpcyB0byBjYXRjaFxuICAgICAgLy8gSW52YWxpZFN0YXRlRXJyb3I6IEZhaWxlZCB0byByZWFkIHRoZSAnYnVmZmVyZWQnIHByb3BlcnR5IGZyb20gJ1NvdXJjZUJ1ZmZlcic6XG4gICAgICAvLyBUaGlzIFNvdXJjZUJ1ZmZlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudCBtZWRpYSBzb3VyY2VcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGJ1ZmZlckluZm8oXG4gICAgbWVkaWE6IEJ1ZmZlcmFibGUgfCBudWxsLFxuICAgIHBvczogbnVtYmVyLFxuICAgIG1heEhvbGVEdXJhdGlvbjogbnVtYmVyXG4gICk6IEJ1ZmZlckluZm8ge1xuICAgIHRyeSB7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgY29uc3QgdmJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgICAgY29uc3QgYnVmZmVyZWQ6IEJ1ZmZlclRpbWVSYW5nZVtdID0gW107XG4gICAgICAgIGxldCBpOiBudW1iZXI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWZmZXJlZC5wdXNoKHsgc3RhcnQ6IHZidWZmZXJlZC5zdGFydChpKSwgZW5kOiB2YnVmZmVyZWQuZW5kKGkpIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuICAgIHJldHVybiB7IGxlbjogMCwgc3RhcnQ6IHBvcywgZW5kOiBwb3MsIG5leHRTdGFydDogdW5kZWZpbmVkIH07XG4gIH1cblxuICBzdGF0aWMgYnVmZmVyZWRJbmZvKFxuICAgIGJ1ZmZlcmVkOiBCdWZmZXJUaW1lUmFuZ2VbXSxcbiAgICBwb3M6IG51bWJlcixcbiAgICBtYXhIb2xlRHVyYXRpb246IG51bWJlclxuICApOiB7XG4gICAgbGVuOiBudW1iZXI7XG4gICAgc3RhcnQ6IG51bWJlcjtcbiAgICBlbmQ6IG51bWJlcjtcbiAgICBuZXh0U3RhcnQ/OiBudW1iZXI7XG4gIH0ge1xuICAgIHBvcyA9IE1hdGgubWF4KDAsIHBvcyk7XG4gICAgLy8gc29ydCBvbiBidWZmZXIuc3RhcnQvc21hbGxlciBlbmQgKElFIGRvZXMgbm90IGFsd2F5cyByZXR1cm4gc29ydGVkIGJ1ZmZlcmVkIHJhbmdlKVxuICAgIGJ1ZmZlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGNvbnN0IGRpZmYgPSBhLnN0YXJ0IC0gYi5zdGFydDtcbiAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGIuZW5kIC0gYS5lbmQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgYnVmZmVyZWQyOiBCdWZmZXJUaW1lUmFuZ2VbXSA9IFtdO1xuICAgIGlmIChtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgIC8vIHRoZXJlIG1pZ2h0IGJlIHNvbWUgc21hbGwgaG9sZXMgYmV0d2VlbiBidWZmZXIgdGltZSByYW5nZVxuICAgICAgLy8gY29uc2lkZXIgdGhhdCBob2xlcyBzbWFsbGVyIHRoYW4gbWF4SG9sZUR1cmF0aW9uIGFyZSBpcnJlbGV2YW50IGFuZCBidWlsZCBhbm90aGVyXG4gICAgICAvLyBidWZmZXIgdGltZSByYW5nZSByZXByZXNlbnRhdGlvbnMgdGhhdCBkaXNjYXJkcyB0aG9zZSBob2xlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBidWYybGVuID0gYnVmZmVyZWQyLmxlbmd0aDtcbiAgICAgICAgaWYgKGJ1ZjJsZW4pIHtcbiAgICAgICAgICBjb25zdCBidWYyZW5kID0gYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQ7XG4gICAgICAgICAgLy8gaWYgc21hbGwgaG9sZSAodmFsdWUgYmV0d2VlbiAwIG9yIG1heEhvbGVEdXJhdGlvbiApIG9yIG92ZXJsYXBwaW5nIChuZWdhdGl2ZSlcbiAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uc3RhcnQgLSBidWYyZW5kIDwgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBtZXJnZSBvdmVybGFwcGluZyB0aW1lIHJhbmdlc1xuICAgICAgICAgICAgLy8gdXBkYXRlIGxhc3RSYW5nZS5lbmQgb25seSBpZiBzbWFsbGVyIHRoYW4gaXRlbS5lbmRcbiAgICAgICAgICAgIC8vIGUuZy4gIFsgMSwgMTVdIHdpdGggIFsgMiw4XSA9PiBbIDEsMTVdIChubyBuZWVkIHRvIG1vZGlmeSBsYXN0UmFuZ2UuZW5kKVxuICAgICAgICAgICAgLy8gd2hlcmVhcyBbIDEsIDhdIHdpdGggIFsgMiwxNV0gPT4gWyAxLDE1XSAoIGxhc3RSYW5nZSBzaG91bGQgc3dpdGNoIGZyb20gWzEsOF0gdG8gWzEsMTVdKVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLmVuZCA+IGJ1ZjJlbmQpIHtcbiAgICAgICAgICAgICAgYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQgPSBidWZmZXJlZFtpXS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJpZyBob2xlXG4gICAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZpcnN0IHZhbHVlXG4gICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlcmVkMiA9IGJ1ZmZlcmVkO1xuICAgIH1cblxuICAgIGxldCBidWZmZXJMZW4gPSAwO1xuXG4gICAgLy8gYnVmZmVyU3RhcnROZXh0IGNhbiBwb3NzaWJseSBiZSB1bmRlZmluZWQgYmFzZWQgb24gdGhlIGNvbmRpdGlvbmFsIGxvZ2ljIGJlbG93XG4gICAgbGV0IGJ1ZmZlclN0YXJ0TmV4dDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgLy8gYnVmZmVyU3RhcnQgYW5kIGJ1ZmZlckVuZCBhcmUgYnVmZmVyIGJvdW5kYXJpZXMgYXJvdW5kIGN1cnJlbnQgdmlkZW8gcG9zaXRpb25cbiAgICBsZXQgYnVmZmVyU3RhcnQ6IG51bWJlciA9IHBvcztcbiAgICBsZXQgYnVmZmVyRW5kOiBudW1iZXIgPSBwb3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gYnVmZmVyZWQyW2ldLnN0YXJ0O1xuICAgICAgY29uc3QgZW5kID0gYnVmZmVyZWQyW2ldLmVuZDtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ2J1ZiBzdGFydC9lbmQ6JyArIGJ1ZmZlcmVkLnN0YXJ0KGkpICsgJy8nICsgYnVmZmVyZWQuZW5kKGkpKTtcbiAgICAgIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPj0gc3RhcnQgJiYgcG9zIDwgZW5kKSB7XG4gICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxuICAgICAgICBidWZmZXJTdGFydCA9IHN0YXJ0O1xuICAgICAgICBidWZmZXJFbmQgPSBlbmQ7XG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcbiAgICAgIH0gZWxzZSBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uIDwgc3RhcnQpIHtcbiAgICAgICAgYnVmZmVyU3RhcnROZXh0ID0gc3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGVuOiBidWZmZXJMZW4sXG4gICAgICBzdGFydDogYnVmZmVyU3RhcnQgfHwgMCxcbiAgICAgIGVuZDogYnVmZmVyRW5kIHx8IDAsXG4gICAgICBuZXh0U3RhcnQ6IGJ1ZmZlclN0YXJ0TmV4dCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNhZmUgbWV0aG9kIHRvIGdldCBidWZmZXJlZCBwcm9wZXJ0eS5cbiAgICogU291cmNlQnVmZmVyLmJ1ZmZlcmVkIG1heSB0aHJvdyBpZiBTb3VyY2VCdWZmZXIgaXMgcmVtb3ZlZCBmcm9tIGl0J3MgTWVkaWFTb3VyY2VcbiAgICovXG4gIHN0YXRpYyBnZXRCdWZmZXJlZChtZWRpYTogQnVmZmVyYWJsZSk6IFRpbWVSYW5nZXMge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbWVkaWEuYnVmZmVyZWQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmxvZygnZmFpbGVkIHRvIGdldCBtZWRpYS5idWZmZXJlZCcsIGUpO1xuICAgICAgcmV0dXJuIG5vb3BCdWZmZXJlZDtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgUmVtdXhlclJlc3VsdCB9IGZyb20gJy4vcmVtdXhlcic7XG5pbXBvcnQgdHlwZSB7IEhsc0NodW5rUGVyZm9ybWFuY2VUaW1pbmcgfSBmcm9tICcuL2xvYWRlcic7XG5pbXBvcnQgdHlwZSB7IFNvdXJjZUJ1ZmZlck5hbWUgfSBmcm9tICcuL2J1ZmZlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNtdXhlclJlc3VsdCB7XG4gIHJlbXV4UmVzdWx0OiBSZW11eGVyUmVzdWx0O1xuICBjaHVua01ldGE6IENodW5rTWV0YWRhdGE7XG59XG5cbmV4cG9ydCBjbGFzcyBDaHVua01ldGFkYXRhIHtcbiAgcHVibGljIHJlYWRvbmx5IGxldmVsOiBudW1iZXI7XG4gIHB1YmxpYyByZWFkb25seSBzbjogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgcGFydDogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgaWQ6IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IHNpemU6IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IHBhcnRpYWw6IGJvb2xlYW47XG4gIHB1YmxpYyByZWFkb25seSB0cmFuc211eGluZzogSGxzQ2h1bmtQZXJmb3JtYW5jZVRpbWluZyA9XG4gICAgZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKTtcbiAgcHVibGljIHJlYWRvbmx5IGJ1ZmZlcmluZzoge1xuICAgIFtrZXkgaW4gU291cmNlQnVmZmVyTmFtZV06IEhsc0NodW5rUGVyZm9ybWFuY2VUaW1pbmc7XG4gIH0gPSB7XG4gICAgYXVkaW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCksXG4gICAgdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCksXG4gICAgYXVkaW92aWRlbzogZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKSxcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBsZXZlbDogbnVtYmVyLFxuICAgIHNuOiBudW1iZXIsXG4gICAgaWQ6IG51bWJlcixcbiAgICBzaXplID0gMCxcbiAgICBwYXJ0ID0gLTEsXG4gICAgcGFydGlhbCA9IGZhbHNlXG4gICkge1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLnNuID0gc247XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICB0aGlzLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCk6IEhsc0NodW5rUGVyZm9ybWFuY2VUaW1pbmcge1xuICByZXR1cm4geyBzdGFydDogMCwgZXhlY3V0ZVN0YXJ0OiAwLCBleGVjdXRlRW5kOiAwLCBlbmQ6IDAgfTtcbn1cbiIsImltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IGFkanVzdFNsaWRpbmcgfSBmcm9tICcuLi9jb250cm9sbGVyL2xldmVsLWhlbHBlcic7XG5cbmltcG9ydCB0eXBlIHsgRnJhZ21lbnQgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwtZGV0YWlscyc7XG5pbXBvcnQgdHlwZSB7IExldmVsIH0gZnJvbSAnLi4vdHlwZXMvbGV2ZWwnO1xuaW1wb3J0IHR5cGUgeyBSZXF1aXJlZFByb3BlcnRpZXMgfSBmcm9tICcuLi90eXBlcy9nZW5lcmFsJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdEZyYWdXaXRoQ0MoZnJhZ21lbnRzOiBGcmFnbWVudFtdLCBjYzogbnVtYmVyKSB7XG4gIGxldCBmaXJzdEZyYWc6IEZyYWdtZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnRGcmFnID0gZnJhZ21lbnRzW2ldO1xuICAgIGlmIChjdXJyZW50RnJhZyAmJiBjdXJyZW50RnJhZy5jYyA9PT0gY2MpIHtcbiAgICAgIGZpcnN0RnJhZyA9IGN1cnJlbnRGcmFnO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpcnN0RnJhZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMoXG4gIGxhc3RGcmFnOiBGcmFnbWVudCB8IG51bGwsXG4gIGxhc3RMZXZlbDogTGV2ZWwsXG4gIGRldGFpbHM6IExldmVsRGV0YWlsc1xuKTogbGFzdExldmVsIGlzIFJlcXVpcmVkUHJvcGVydGllczxMZXZlbCwgJ2RldGFpbHMnPiB7XG4gIGlmIChsYXN0TGV2ZWwuZGV0YWlscykge1xuICAgIGlmIChcbiAgICAgIGRldGFpbHMuZW5kQ0MgPiBkZXRhaWxzLnN0YXJ0Q0MgfHxcbiAgICAgIChsYXN0RnJhZyAmJiBsYXN0RnJhZy5jYyA8IGRldGFpbHMuc3RhcnRDQylcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEZpbmQgdGhlIGZpcnN0IGZyYWcgaW4gdGhlIHByZXZpb3VzIGxldmVsIHdoaWNoIG1hdGNoZXMgdGhlIENDIG9mIHRoZSBmaXJzdCBmcmFnIG9mIHRoZSBuZXcgbGV2ZWxcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcoXG4gIHByZXZEZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIGN1ckRldGFpbHM6IExldmVsRGV0YWlscyxcbiAgcmVmZXJlbmNlSW5kZXg6IG51bWJlciA9IDBcbikge1xuICBjb25zdCBwcmV2RnJhZ3MgPSBwcmV2RGV0YWlscy5mcmFnbWVudHM7XG4gIGNvbnN0IGN1ckZyYWdzID0gY3VyRGV0YWlscy5mcmFnbWVudHM7XG5cbiAgaWYgKCFjdXJGcmFncy5sZW5ndGggfHwgIXByZXZGcmFncy5sZW5ndGgpIHtcbiAgICBsb2dnZXIubG9nKCdObyBmcmFnbWVudHMgdG8gYWxpZ24nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwcmV2U3RhcnRGcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhwcmV2RnJhZ3MsIGN1ckZyYWdzWzBdLmNjKTtcblxuICBpZiAoIXByZXZTdGFydEZyYWcgfHwgKHByZXZTdGFydEZyYWcgJiYgIXByZXZTdGFydEZyYWcuc3RhcnRQVFMpKSB7XG4gICAgbG9nZ2VyLmxvZygnTm8gZnJhZyBpbiBwcmV2aW91cyBsZXZlbCB0byBhbGlnbiBvbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBwcmV2U3RhcnRGcmFnO1xufVxuXG5mdW5jdGlvbiBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWc6IEZyYWdtZW50LCBzbGlkaW5nOiBudW1iZXIpIHtcbiAgaWYgKGZyYWcpIHtcbiAgICBjb25zdCBzdGFydCA9IGZyYWcuc3RhcnQgKyBzbGlkaW5nO1xuICAgIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnQ7XG4gICAgZnJhZy5lbmRQVFMgPSBzdGFydCArIGZyYWcuZHVyYXRpb247XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFNsaWRpbmdTdGFydChzbGlkaW5nOiBudW1iZXIsIGRldGFpbHM6IExldmVsRGV0YWlscykge1xuICAvLyBVcGRhdGUgc2VnbWVudHNcbiAgY29uc3QgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWdtZW50c1tpXSwgc2xpZGluZyk7XG4gIH1cbiAgLy8gVXBkYXRlIExMLUhMUyBwYXJ0cyBhdCB0aGUgZW5kIG9mIHRoZSBwbGF5bGlzdFxuICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICBhZGp1c3RGcmFnbWVudFN0YXJ0KGRldGFpbHMuZnJhZ21lbnRIaW50LCBzbGlkaW5nKTtcbiAgfVxuICBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVc2luZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgbGFzdCBsZXZlbCwgdGhpcyBmdW5jdGlvbiBjb21wdXRlcyBQVFMnIG9mIHRoZSBuZXcgZnJhZ21lbnRzIHNvIHRoYXQgdGhleSBmb3JtIGFcbiAqIGNvbnRpZ3VvdXMgc3RyZWFtIHdpdGggdGhlIGxhc3QgZnJhZ21lbnRzLlxuICogVGhlIFBUUyBvZiBhIGZyYWdtZW50IGxldHMgSGxzLmpzIGtub3cgd2hlcmUgaXQgZml0cyBpbnRvIGEgc3RyZWFtIC0gYnkga25vd2luZyBldmVyeSBQVFMsIHdlIGtub3cgd2hpY2ggZnJhZ21lbnQgdG9cbiAqIGRvd25sb2FkIGF0IGFueSBnaXZlbiB0aW1lLiBQVFMgaXMgbm9ybWFsbHkgY29tcHV0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgaXMgZGVtdXhlZCwgc28gdGFraW5nIHRoaXMgc3RlcCBzYXZlcyB1cyB0aW1lXG4gKiBhbmQgYW4gZXh0cmEgZG93bmxvYWQuXG4gKiBAcGFyYW0gbGFzdEZyYWdcbiAqIEBwYXJhbSBsYXN0TGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGlnblN0cmVhbShcbiAgbGFzdEZyYWc6IEZyYWdtZW50IHwgbnVsbCxcbiAgbGFzdExldmVsOiBMZXZlbCB8IG51bGwsXG4gIGRldGFpbHM6IExldmVsRGV0YWlsc1xuKSB7XG4gIGlmICghbGFzdExldmVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFsaWduRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBkZXRhaWxzLCBsYXN0TGV2ZWwpO1xuICBpZiAoIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgbGFzdExldmVsLmRldGFpbHMpIHtcbiAgICAvLyBJZiB0aGUgUFRTIHdhc24ndCBmaWd1cmVkIG91dCB2aWEgZGlzY29udGludWl0eSBzZXF1ZW5jZSB0aGF0IG1lYW5zIHRoZXJlIHdhcyBubyBDQyBpbmNyZWFzZSB3aXRoaW4gdGhlIGxldmVsLlxuICAgIC8vIEFsaWduaW5nIHZpYSBQcm9ncmFtIERhdGUgVGltZSBzaG91bGQgdGhlcmVmb3JlIGJlIHJlbGlhYmxlLCBzaW5jZSBQRFQgc2hvdWxkIGJlIHRoZSBzYW1lIHdpdGhpbiB0aGUgc2FtZVxuICAgIC8vIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gICAgYWxpZ25QRFQoZGV0YWlscywgbGFzdExldmVsLmRldGFpbHMpO1xuICB9XG4gIGlmIChcbiAgICAhZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJlxuICAgIGxhc3RMZXZlbC5kZXRhaWxzICYmXG4gICAgIWRldGFpbHMuc2tpcHBlZFNlZ21lbnRzXG4gICkge1xuICAgIC8vIFRyeSB0byBhbGlnbiBvbiBzbiBzbyB0aGF0IHdlIHBpY2sgYSBiZXR0ZXIgc3RhcnQgZnJhZ21lbnQuXG4gICAgLy8gRG8gbm90IHBlcmZvcm0gdGhpcyBvbiBwbGF5bGlzdHMgd2l0aCBkZWx0YSB1cGRhdGVzIGFzIHRoaXMgaXMgb25seSB0byBhbGlnbiBsZXZlbHMgb24gc3dpdGNoXG4gICAgLy8gYW5kIGFkanVzdFNsaWRpbmcgb25seSBhZGp1c3RzIGZyYWdtZW50cyBhZnRlciBza2lwcGVkU2VnbWVudHMuXG4gICAgYWRqdXN0U2xpZGluZyhsYXN0TGV2ZWwuZGV0YWlscywgZGV0YWlscyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUFRTIGlmIGEgbmV3IGxldmVsJ3MgZnJhZ21lbnRzIHVzaW5nIHRoZSBQVFMgb2YgYSBmcmFnbWVudCBpbiB0aGUgbGFzdCBsZXZlbCB3aGljaCBzaGFyZXMgdGhlIHNhbWVcbiAqIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gKiBAcGFyYW0gbGFzdEZyYWcgLSBUaGUgbGFzdCBGcmFnbWVudCB3aGljaCBzaGFyZXMgdGhlIHNhbWUgZGlzY29udGludWl0eSBzZXF1ZW5jZVxuICogQHBhcmFtIGxhc3RMZXZlbCAtIFRoZSBkZXRhaWxzIG9mIHRoZSBsYXN0IGxvYWRlZCBsZXZlbFxuICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgbmV3IGxldmVsXG4gKi9cbmZ1bmN0aW9uIGFsaWduRGlzY29udGludWl0aWVzKFxuICBsYXN0RnJhZzogRnJhZ21lbnQgfCBudWxsLFxuICBkZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIGxhc3RMZXZlbDogTGV2ZWxcbikge1xuICBpZiAoc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSkge1xuICAgIGNvbnN0IHJlZmVyZW5jZUZyYWcgPSBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcoXG4gICAgICBsYXN0TGV2ZWwuZGV0YWlscyxcbiAgICAgIGRldGFpbHNcbiAgICApO1xuICAgIGlmIChyZWZlcmVuY2VGcmFnICYmIE51bWJlci5pc0Zpbml0ZShyZWZlcmVuY2VGcmFnLnN0YXJ0KSkge1xuICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgYEFkanVzdGluZyBQVFMgdXNpbmcgbGFzdCBsZXZlbCBkdWUgdG8gQ0MgaW5jcmVhc2Ugd2l0aGluIGN1cnJlbnQgbGV2ZWwgJHtkZXRhaWxzLnVybH1gXG4gICAgICApO1xuICAgICAgYWRqdXN0U2xpZGluZ1N0YXJ0KHJlZmVyZW5jZUZyYWcuc3RhcnQsIGRldGFpbHMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBQVFMgb2YgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIGRpZmZlcmVuY2UgaW4gUHJvZ3JhbSBEYXRlIFRpbWUgZnJvbSB0aGUgbGFzdCBsZXZlbC5cbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICogQHBhcmFtIGxhc3REZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGlnblBEVChkZXRhaWxzOiBMZXZlbERldGFpbHMsIGxhc3REZXRhaWxzOiBMZXZlbERldGFpbHMpIHtcbiAgLy8gVGhpcyBjaGVjayBwcm90ZWN0cyB0aGUgdW5zYWZlIFwiIVwiIHVzYWdlIGJlbG93IGZvciBudWxsIHByb2dyYW0gZGF0ZSB0aW1lIGFjY2Vzcy5cbiAgaWYgKFxuICAgICFsYXN0RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIHx8XG4gICAgIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8XG4gICAgIWxhc3REZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gaWYgbGFzdCBsZXZlbCBzbGlkaW5nIGlzIDEwMDAgYW5kIGl0cyBmaXJzdCBmcmFnIFBST0dSQU0tREFURS1USU1FIGlzIDIwMTctMDgtMjAgMToxMDowMCBBTVxuICAvLyBhbmQgaWYgbmV3IGRldGFpbHMgZmlyc3QgZnJhZyBQUk9HUkFNIERBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDggQU1cbiAgLy8gdGhlbiB3ZSBjYW4gZGVkdWNlIHRoYXQgcGxheWxpc3QgQiBzbGlkaW5nIGlzIDEwMDArOCA9IDEwMDhzXG4gIGNvbnN0IGxhc3RQRFQgPSBsYXN0RGV0YWlscy5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lITsgLy8gaGFzUHJvZ3JhbURhdGVUaW1lIGNoZWNrIGFib3ZlIG1ha2VzIHRoaXMgc2FmZS5cbiAgY29uc3QgbmV3UERUID0gZGV0YWlscy5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lITtcbiAgLy8gZGF0ZSBkaWZmIGlzIGluIG1zLiBmcmFnLnN0YXJ0IGlzIGluIHNlY29uZHNcbiAgY29uc3Qgc2xpZGluZyA9IChuZXdQRFQgLSBsYXN0UERUKSAvIDEwMDAgKyBsYXN0RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gIGlmIChzbGlkaW5nICYmIE51bWJlci5pc0Zpbml0ZShzbGlkaW5nKSkge1xuICAgIGxvZ2dlci5sb2coXG4gICAgICBgQWRqdXN0aW5nIFBUUyB1c2luZyBwcm9ncmFtRGF0ZVRpbWUgZGVsdGEgJHtcbiAgICAgICAgbmV3UERUIC0gbGFzdFBEVFxuICAgICAgfW1zLCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfSAke2RldGFpbHMudXJsfSBgXG4gICAgKTtcbiAgICBhZGp1c3RTbGlkaW5nU3RhcnQoc2xpZGluZywgZGV0YWlscyk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmVzIGFwcHJvcHJpYXRlIHRpbWUtYWxpZ25tZW50IGJldHdlZW4gcmVuZGl0aW9ucyBiYXNlZCBvbiBQRFQuIFVubGlrZSBgYWxpZ25QRFRgLCB3aGljaCBhZGp1c3RzXG4gKiB0aGUgdGltZWxpbmUgYmFzZWQgb24gdGhlIGRlbHRhIGJldHdlZW4gUERUcyBvZiB0aGUgMHRoIGZyYWdtZW50IG9mIHR3byBwbGF5bGlzdHMvYExldmVsRGV0YWlsc2AsXG4gKiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhlIHRpbWVsaW5lcyByZXByZXNlbnRlZCBpbiBgcmVmRGV0YWlsc2AgYXJlIGFjY3VyYXRlLCBpbmNsdWRpbmcgdGhlIFBEVHMsXG4gKiBhbmQgdXNlcyB0aGUgXCJ3YWxsY2xvY2tcIi9QRFQgdGltZWxpbmUgYXMgYSBjcm9zcy1yZWZlcmVuY2UgdG8gYGRldGFpbHNgLCBhZGp1c3RpbmcgdGhlIHByZXNlbnRhdGlvblxuICogdGltZXMvdGltZWxpbmVzIG9mIGBkZXRhaWxzYCBhY2NvcmRpbmdseS5cbiAqIEdpdmVuIHRoZSBhc3luY2hyb25vdXMgbmF0dXJlIG9mIGZldGNoZXMgYW5kIGluaXRpYWwgbG9hZHMgb2YgbGl2ZSBgbWFpbmAgYW5kIGF1ZGlvL3N1YnRpdGxlIHRyYWNrcyxcbiAqIHRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBlbnN1cmUgdGhlIFwibG9jYWwgdGltZWxpbmVzXCIgb2YgYXVkaW8vc3VidGl0bGUgdHJhY2tzXG4gKiBhcmUgYWxpZ25lZCB0byB0aGUgbWFpbi92aWRlbyB0aW1lbGluZSwgdXNpbmcgUERUIGFzIHRoZSBjcm9zcy1yZWZlcmVuY2UvXCJhbmNob3JcIiB0aGF0IHNob3VsZFxuICogYmUgY29uc2lzdGVudCBhY3Jvc3MgcGxheWxpc3RzLCBwZXIgdGhlIEhMUyBzcGVjLlxuICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgcmVuZGl0aW9uIHlvdSdkIGxpa2UgdG8gdGltZS1hbGlnbiAoZS5nLiBhbiBhdWRpbyByZW5kaXRpb24pLlxuICogQHBhcmFtIHJlZkRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgcmVmZXJlbmNlIHJlbmRpdGlvbiB3aXRoIHN0YXJ0IGFuZCBQRFQgdGltZXMgZm9yIGFsaWdubWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKFxuICBkZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIHJlZkRldGFpbHM6IExldmVsRGV0YWlsc1xuKSB7XG4gIGlmICghZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgfHwgIXJlZkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gIGNvbnN0IHJlZkZyYWdtZW50cyA9IHJlZkRldGFpbHMuZnJhZ21lbnRzO1xuICBpZiAoIWZyYWdtZW50cy5sZW5ndGggfHwgIXJlZkZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgYSBkZWx0YSB0byBhcHBseSB0byBhbGwgZnJhZ21lbnRzIGFjY29yZGluZyB0byB0aGUgZGVsdGEgaW4gUERUIHRpbWVzIGFuZCBzdGFydCB0aW1lc1xuICAvLyBvZiBhIGZyYWdtZW50IGluIHRoZSByZWZlcmVuY2UgZGV0YWlscywgYW5kIGEgZnJhZ21lbnQgaW4gdGhlIHRhcmdldCBkZXRhaWxzIG9mIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkuXG4gIC8vIElmIGEgZnJhZ21lbnQgb2YgdGhlIHNhbWUgZGlzY29udGludWl0eSB3YXMgbm90IGZvdW5kIHVzZSB0aGUgbWlkZGxlIGZyYWdtZW50IG9mIGJvdGguXG4gIGNvbnN0IG1pZGRsZUZyYWcgPSBNYXRoLnJvdW5kKHJlZkZyYWdtZW50cy5sZW5ndGggLyAyKSAtIDE7XG4gIGNvbnN0IHJlZkZyYWcgPSByZWZGcmFnbWVudHNbbWlkZGxlRnJhZ107XG4gIGNvbnN0IGZyYWcgPVxuICAgIGZpbmRGaXJzdEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCByZWZGcmFnLmNjKSB8fFxuICAgIGZyYWdtZW50c1tNYXRoLnJvdW5kKGZyYWdtZW50cy5sZW5ndGggLyAyKSAtIDFdO1xuXG4gIGNvbnN0IHJlZlBEVCA9IHJlZkZyYWcucHJvZ3JhbURhdGVUaW1lO1xuICBjb25zdCB0YXJnZXRQRFQgPSBmcmFnLnByb2dyYW1EYXRlVGltZTtcbiAgaWYgKHJlZlBEVCA9PT0gbnVsbCB8fCB0YXJnZXRQRFQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBkZWx0YSA9ICh0YXJnZXRQRFQgLSByZWZQRFQpIC8gMTAwMCAtIChmcmFnLnN0YXJ0IC0gcmVmRnJhZy5zdGFydCk7XG4gIGFkanVzdFNsaWRpbmdTdGFydChkZWx0YSwgZGV0YWlscyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBBRVNDcnlwdG8ge1xuICBwcml2YXRlIHN1YnRsZTogU3VidGxlQ3J5cHRvO1xuICBwcml2YXRlIGFlc0lWOiBVaW50OEFycmF5O1xuXG4gIGNvbnN0cnVjdG9yKHN1YnRsZTogU3VidGxlQ3J5cHRvLCBpdjogVWludDhBcnJheSkge1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMuYWVzSVYgPSBpdjtcbiAgfVxuXG4gIGRlY3J5cHQoZGF0YTogQXJyYXlCdWZmZXIsIGtleTogQ3J5cHRvS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGxlLmRlY3J5cHQoeyBuYW1lOiAnQUVTLUNCQycsIGl2OiB0aGlzLmFlc0lWIH0sIGtleSwgZGF0YSk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhc3RBRVNLZXkge1xuICBwcml2YXRlIHN1YnRsZTogYW55O1xuICBwcml2YXRlIGtleTogQXJyYXlCdWZmZXI7XG5cbiAgY29uc3RydWN0b3Ioc3VidGxlLCBrZXkpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgfVxuXG4gIGV4cGFuZEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleSwgeyBuYW1lOiAnQUVTLUNCQycgfSwgZmFsc2UsIFtcbiAgICAgICdlbmNyeXB0JyxcbiAgICAgICdkZWNyeXB0JyxcbiAgICBdKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgc2xpY2VVaW50OCB9IGZyb20gJy4uL3V0aWxzL3R5cGVkLWFycmF5JztcblxuLy8gUEtDUzdcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQYWRkaW5nKGFycmF5OiBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG4gIGNvbnN0IG91dHB1dEJ5dGVzID0gYXJyYXkuYnl0ZUxlbmd0aDtcbiAgY29uc3QgcGFkZGluZ0J5dGVzID1cbiAgICBvdXRwdXRCeXRlcyAmJiBuZXcgRGF0YVZpZXcoYXJyYXkuYnVmZmVyKS5nZXRVaW50OChvdXRwdXRCeXRlcyAtIDEpO1xuICBpZiAocGFkZGluZ0J5dGVzKSB7XG4gICAgcmV0dXJuIHNsaWNlVWludDgoYXJyYXksIDAsIG91dHB1dEJ5dGVzIC0gcGFkZGluZ0J5dGVzKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFFU0RlY3J5cHRvciB7XG4gIHByaXZhdGUgcmNvbjogQXJyYXk8bnVtYmVyPiA9IFtcbiAgICAweDAsIDB4MSwgMHgyLCAweDQsIDB4OCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNixcbiAgXTtcbiAgcHJpdmF0ZSBzdWJNaXg6IEFycmF5PFVpbnQzMkFycmF5PiA9IFtcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgXTtcbiAgcHJpdmF0ZSBpbnZTdWJNaXg6IEFycmF5PFVpbnQzMkFycmF5PiA9IFtcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgXTtcbiAgcHJpdmF0ZSBzQm94OiBVaW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICBwcml2YXRlIGludlNCb3g6IFVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gIHByaXZhdGUga2V5OiBVaW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSgwKTtcblxuICBwcml2YXRlIGtzUm93czogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBrZXlTaXplOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIGtleVNjaGVkdWxlITogVWludDMyQXJyYXk7XG4gIHByaXZhdGUgaW52S2V5U2NoZWR1bGUhOiBVaW50MzJBcnJheTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmluaXRUYWJsZSgpO1xuICB9XG5cbiAgLy8gVXNpbmcgdmlldy5nZXRVaW50MzIoKSBhbHNvIHN3YXBzIHRoZSBieXRlIG9yZGVyLlxuICB1aW50OEFycmF5VG9VaW50MzJBcnJheV8oYXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICBjb25zdCBuZXdBcnJheSA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgbmV3QXJyYXlbaV0gPSB2aWV3LmdldFVpbnQzMihpICogNCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgaW5pdFRhYmxlKCkge1xuICAgIGNvbnN0IHNCb3ggPSB0aGlzLnNCb3g7XG4gICAgY29uc3QgaW52U0JveCA9IHRoaXMuaW52U0JveDtcbiAgICBjb25zdCBzdWJNaXggPSB0aGlzLnN1Yk1peDtcbiAgICBjb25zdCBzdWJNaXgwID0gc3ViTWl4WzBdO1xuICAgIGNvbnN0IHN1Yk1peDEgPSBzdWJNaXhbMV07XG4gICAgY29uc3Qgc3ViTWl4MiA9IHN1Yk1peFsyXTtcbiAgICBjb25zdCBzdWJNaXgzID0gc3ViTWl4WzNdO1xuICAgIGNvbnN0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGNvbnN0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgY29uc3QgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICBjb25zdCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGNvbnN0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG5cbiAgICBjb25zdCBkID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB4aSA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgaWYgKGkgPCAxMjgpIHtcbiAgICAgICAgZFtpXSA9IGkgPDwgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgbGV0IHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XG4gICAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjM7XG4gICAgICBzQm94W3hdID0gc3g7XG4gICAgICBpbnZTQm94W3N4XSA9IHg7XG5cbiAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgICAgIGNvbnN0IHgyID0gZFt4XTtcbiAgICAgIGNvbnN0IHg0ID0gZFt4Ml07XG4gICAgICBjb25zdCB4OCA9IGRbeDRdO1xuXG4gICAgICAvLyBDb21wdXRlIHN1Yi9pbnZTdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgbGV0IHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuICAgICAgc3ViTWl4MFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcbiAgICAgIHN1Yk1peDFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICAgICAgc3ViTWl4Mlt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgICAgIHN1Yk1peDNbeF0gPSB0O1xuXG4gICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG4gICAgICBpbnZTdWJNaXgwW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcbiAgICAgIGludlN1Yk1peDFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcbiAgICAgIGludlN1Yk1peDJbc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgaW52U3ViTWl4M1tzeF0gPSB0O1xuXG4gICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuICAgICAgaWYgKCF4KSB7XG4gICAgICAgIHggPSB4aSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuICAgICAgICB4aSBePSBkW2RbeGldXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBleHBhbmRLZXkoa2V5QnVmZmVyOiBBcnJheUJ1ZmZlcikge1xuICAgIC8vIGNvbnZlcnQga2V5QnVmZmVyIHRvIFVpbnQzMkFycmF5XG4gICAgY29uc3Qga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICBsZXQgc2FtZUtleSA9IHRydWU7XG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICBzYW1lS2V5ID0ga2V5W29mZnNldF0gPT09IHRoaXMua2V5W29mZnNldF07XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG5cbiAgICBpZiAoc2FtZUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIGNvbnN0IGtleVNpemUgPSAodGhpcy5rZXlTaXplID0ga2V5Lmxlbmd0aCk7XG5cbiAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleVNpemUpO1xuICAgIH1cblxuICAgIGNvbnN0IGtzUm93cyA9ICh0aGlzLmtzUm93cyA9IChrZXlTaXplICsgNiArIDEpICogNCk7XG4gICAgbGV0IGtzUm93O1xuICAgIGxldCBpbnZLc1JvdztcblxuICAgIGNvbnN0IGtleVNjaGVkdWxlID0gKHRoaXMua2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKSk7XG4gICAgY29uc3QgaW52S2V5U2NoZWR1bGUgPSAodGhpcy5pbnZLZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpKTtcbiAgICBjb25zdCBzYm94ID0gdGhpcy5zQm94O1xuICAgIGNvbnN0IHJjb24gPSB0aGlzLnJjb247XG5cbiAgICBjb25zdCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBjb25zdCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGNvbnN0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgY29uc3QgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBjb25zdCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuXG4gICAgbGV0IHByZXY7XG4gICAgbGV0IHQ7XG5cbiAgICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcbiAgICAgICAgcHJldiA9IGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVtrc1Jvd107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdCA9IHByZXY7XG5cbiAgICAgIGlmIChrc1JvdyAlIGtleVNpemUgPT09IDApIHtcbiAgICAgICAgLy8gUm90IHdvcmRcbiAgICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcblxuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID1cbiAgICAgICAgICAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHxcbiAgICAgICAgICAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgICAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8XG4gICAgICAgICAgc2JveFt0ICYgMHhmZl07XG5cbiAgICAgICAgLy8gTWl4IFJjb25cbiAgICAgICAgdCBePSByY29uWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG4gICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkge1xuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID1cbiAgICAgICAgICAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHxcbiAgICAgICAgICAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgICAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8XG4gICAgICAgICAgc2JveFt0ICYgMHhmZl07XG4gICAgICB9XG5cbiAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IHByZXYgPSAoa2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQpID4+PiAwO1xuICAgIH1cblxuICAgIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcbiAgICAgIGlmIChpbnZLc1JvdyAmIDMpIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9XG4gICAgICAgICAgaW52U3ViTWl4MFtzYm94W3QgPj4+IDI0XV0gXlxuICAgICAgICAgIGludlN1Yk1peDFbc2JveFsodCA+Pj4gMTYpICYgMHhmZl1dIF5cbiAgICAgICAgICBpbnZTdWJNaXgyW3Nib3hbKHQgPj4+IDgpICYgMHhmZl1dIF5cbiAgICAgICAgICBpbnZTdWJNaXgzW3Nib3hbdCAmIDB4ZmZdXTtcbiAgICAgIH1cblxuICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID4+PiAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZGluZyB0aGlzIGFzIGEgbWV0aG9kIGdyZWF0bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2UuXG4gIG5ldHdvcmtUb0hvc3RPcmRlclN3YXAod29yZCkge1xuICAgIHJldHVybiAoXG4gICAgICAod29yZCA8PCAyNCkgfFxuICAgICAgKCh3b3JkICYgMHhmZjAwKSA8PCA4KSB8XG4gICAgICAoKHdvcmQgJiAweGZmMDAwMCkgPj4gOCkgfFxuICAgICAgKHdvcmQgPj4+IDI0KVxuICAgICk7XG4gIH1cblxuICBkZWNyeXB0KGlucHV0QXJyYXlCdWZmZXI6IEFycmF5QnVmZmVyLCBvZmZzZXQ6IG51bWJlciwgYWVzSVY6IEFycmF5QnVmZmVyKSB7XG4gICAgY29uc3QgblJvdW5kcyA9IHRoaXMua2V5U2l6ZSArIDY7XG4gICAgY29uc3QgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xuICAgIGNvbnN0IGludlNCT1ggPSB0aGlzLmludlNCb3g7XG5cbiAgICBjb25zdCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBjb25zdCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGNvbnN0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgY29uc3QgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBjb25zdCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuXG4gICAgY29uc3QgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcbiAgICBsZXQgaW5pdFZlY3RvcjAgPSBpbml0VmVjdG9yWzBdO1xuICAgIGxldCBpbml0VmVjdG9yMSA9IGluaXRWZWN0b3JbMV07XG4gICAgbGV0IGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcbiAgICBsZXQgaW5pdFZlY3RvcjMgPSBpbml0VmVjdG9yWzNdO1xuXG4gICAgY29uc3QgaW5wdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0QXJyYXlCdWZmZXIpO1xuICAgIGNvbnN0IG91dHB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRJbnQzMi5sZW5ndGgpO1xuXG4gICAgbGV0IHQwLCB0MSwgdDIsIHQzO1xuICAgIGxldCBzMCwgczEsIHMyLCBzMztcbiAgICBsZXQgaW5wdXRXb3JkczAsIGlucHV0V29yZHMxLCBpbnB1dFdvcmRzMiwgaW5wdXRXb3JkczM7XG5cbiAgICBsZXQga3NSb3csIGk7XG4gICAgY29uc3Qgc3dhcFdvcmQgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXRJbnQzMi5sZW5ndGgpIHtcbiAgICAgIGlucHV0V29yZHMwID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXRdKTtcbiAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XG4gICAgICBpbnB1dFdvcmRzMiA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMl0pO1xuICAgICAgaW5wdXRXb3JkczMgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDNdKTtcblxuICAgICAgczAgPSBpbnB1dFdvcmRzMCBeIGludktleVNjaGVkdWxlWzBdO1xuICAgICAgczEgPSBpbnB1dFdvcmRzMyBeIGludktleVNjaGVkdWxlWzFdO1xuICAgICAgczIgPSBpbnB1dFdvcmRzMiBeIGludktleVNjaGVkdWxlWzJdO1xuICAgICAgczMgPSBpbnB1dFdvcmRzMSBeIGludktleVNjaGVkdWxlWzNdO1xuXG4gICAgICBrc1JvdyA9IDQ7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcm91bmRzIG9mIGRlY3J5cHRpb25cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuUm91bmRzOyBpKyspIHtcbiAgICAgICAgdDAgPVxuICAgICAgICAgIGludlN1Yk1peDBbczAgPj4+IDI0XSBeXG4gICAgICAgICAgaW52U3ViTWl4MVsoczEgPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgIGludlN1Yk1peDJbKHMyID4+IDgpICYgMHhmZl0gXlxuICAgICAgICAgIGludlN1Yk1peDNbczMgJiAweGZmXSBeXG4gICAgICAgICAgaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICB0MSA9XG4gICAgICAgICAgaW52U3ViTWl4MFtzMSA+Pj4gMjRdIF5cbiAgICAgICAgICBpbnZTdWJNaXgxWyhzMiA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgaW52U3ViTWl4MlsoczMgPj4gOCkgJiAweGZmXSBeXG4gICAgICAgICAgaW52U3ViTWl4M1tzMCAmIDB4ZmZdIF5cbiAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgICB0MiA9XG4gICAgICAgICAgaW52U3ViTWl4MFtzMiA+Pj4gMjRdIF5cbiAgICAgICAgICBpbnZTdWJNaXgxWyhzMyA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgaW52U3ViTWl4MlsoczAgPj4gOCkgJiAweGZmXSBeXG4gICAgICAgICAgaW52U3ViTWl4M1tzMSAmIDB4ZmZdIF5cbiAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgICB0MyA9XG4gICAgICAgICAgaW52U3ViTWl4MFtzMyA+Pj4gMjRdIF5cbiAgICAgICAgICBpbnZTdWJNaXgxWyhzMCA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgaW52U3ViTWl4MlsoczEgPj4gOCkgJiAweGZmXSBeXG4gICAgICAgICAgaW52U3ViTWl4M1tzMiAmIDB4ZmZdIF5cbiAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgczAgPSB0MDtcbiAgICAgICAgczEgPSB0MTtcbiAgICAgICAgczIgPSB0MjtcbiAgICAgICAgczMgPSB0MztcblxuICAgICAgICBrc1JvdyA9IGtzUm93ICsgNDtcbiAgICAgIH1cblxuICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG4gICAgICB0MCA9XG4gICAgICAgIChpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQpIF5cbiAgICAgICAgKGludlNCT1hbKHMxID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeXG4gICAgICAgIChpbnZTQk9YWyhzMiA+PiA4KSAmIDB4ZmZdIDw8IDgpIF5cbiAgICAgICAgaW52U0JPWFtzMyAmIDB4ZmZdIF5cbiAgICAgICAgaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgdDEgPVxuICAgICAgICAoaW52U0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgICAgIChpbnZTQk9YWyhzMiA+PiAxNikgJiAweGZmXSA8PCAxNikgXlxuICAgICAgICAoaW52U0JPWFsoczMgPj4gOCkgJiAweGZmXSA8PCA4KSBeXG4gICAgICAgIGludlNCT1hbczAgJiAweGZmXSBeXG4gICAgICAgIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICB0MiA9XG4gICAgICAgIChpbnZTQk9YW3MyID4+PiAyNF0gPDwgMjQpIF5cbiAgICAgICAgKGludlNCT1hbKHMzID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeXG4gICAgICAgIChpbnZTQk9YWyhzMCA+PiA4KSAmIDB4ZmZdIDw8IDgpIF5cbiAgICAgICAgaW52U0JPWFtzMSAmIDB4ZmZdIF5cbiAgICAgICAgaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgIHQzID1cbiAgICAgICAgKGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCkgXlxuICAgICAgICAoaW52U0JPWFsoczAgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF5cbiAgICAgICAgKGludlNCT1hbKHMxID4+IDgpICYgMHhmZl0gPDwgOCkgXlxuICAgICAgICBpbnZTQk9YW3MyICYgMHhmZl0gXlxuICAgICAgICBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuXG4gICAgICAvLyBXcml0ZVxuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0XSA9IHN3YXBXb3JkKHQwIF4gaW5pdFZlY3RvcjApO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMV0gPSBzd2FwV29yZCh0MyBeIGluaXRWZWN0b3IxKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gc3dhcFdvcmQodDIgXiBpbml0VmVjdG9yMik7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAzXSA9IHN3YXBXb3JkKHQxIF4gaW5pdFZlY3RvcjMpO1xuXG4gICAgICAvLyByZXNldCBpbml0VmVjdG9yIHRvIGxhc3QgNCB1bnNpZ25lZCBpbnRcbiAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xuICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcbiAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG5cbiAgICAgIG9mZnNldCA9IG9mZnNldCArIDQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dEludDMyLmJ1ZmZlcjtcbiAgfVxufVxuIiwiaW1wb3J0IEFFU0NyeXB0byBmcm9tICcuL2Flcy1jcnlwdG8nO1xuaW1wb3J0IEZhc3RBRVNLZXkgZnJvbSAnLi9mYXN0LWFlcy1rZXknO1xuaW1wb3J0IEFFU0RlY3J5cHRvciwgeyByZW1vdmVQYWRkaW5nIH0gZnJvbSAnLi9hZXMtZGVjcnlwdG9yJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBhcHBlbmRVaW50OEFycmF5IH0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcbmltcG9ydCB7IHNsaWNlVWludDggfSBmcm9tICcuLi91dGlscy90eXBlZC1hcnJheSc7XG5pbXBvcnQgdHlwZSB7IEhsc0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5cbmNvbnN0IENIVU5LX1NJWkUgPSAxNjsgLy8gMTYgYnl0ZXMsIDEyOCBiaXRzXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlY3J5cHRlciB7XG4gIHByaXZhdGUgbG9nRW5hYmxlZDogYm9vbGVhbiA9IHRydWU7XG4gIHByaXZhdGUgcmVtb3ZlUEtDUzdQYWRkaW5nOiBib29sZWFuO1xuICBwcml2YXRlIHN1YnRsZTogU3VidGxlQ3J5cHRvIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc29mdHdhcmVEZWNyeXB0ZXI6IEFFU0RlY3J5cHRvciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGtleTogQXJyYXlCdWZmZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBmYXN0QWVzS2V5OiBGYXN0QUVTS2V5IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcmVtYWluZGVyRGF0YTogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGN1cnJlbnRJVjogQXJyYXlCdWZmZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjdXJyZW50UmVzdWx0OiBBcnJheUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHVzZVNvZnR3YXJlOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogSGxzQ29uZmlnLCB7IHJlbW92ZVBLQ1M3UGFkZGluZyA9IHRydWUgfSA9IHt9KSB7XG4gICAgdGhpcy51c2VTb2Z0d2FyZSA9IGNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUztcbiAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHJlbW92ZVBLQ1M3UGFkZGluZztcbiAgICAvLyBidWlsdCBpbiBkZWNyeXB0b3IgZXhwZWN0cyBQS0NTNyBwYWRkaW5nXG4gICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnJvd3NlckNyeXB0byA9IHNlbGYuY3J5cHRvO1xuICAgICAgICBpZiAoYnJvd3NlckNyeXB0bykge1xuICAgICAgICAgIHRoaXMuc3VidGxlID1cbiAgICAgICAgICAgIGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8XG4gICAgICAgICAgICAoKGJyb3dzZXJDcnlwdG8gYXMgYW55KS53ZWJraXRTdWJ0bGUgYXMgU3VidGxlQ3J5cHRvKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBuby1vcCAqL1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zdWJ0bGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudXNlU29mdHdhcmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJ0bGUgPSBudWxsO1xuICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLmZhc3RBZXNLZXkgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgaXNTeW5jKCkge1xuICAgIHJldHVybiB0aGlzLnVzZVNvZnR3YXJlO1xuICB9XG5cbiAgcHVibGljIGZsdXNoKCk6IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICBjb25zdCB7IGN1cnJlbnRSZXN1bHQsIHJlbWFpbmRlckRhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFjdXJyZW50UmVzdWx0IHx8IHJlbWFpbmRlckRhdGEpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoY3VycmVudFJlc3VsdCk7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIGlmICh0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgcmV0dXJuIHJlbW92ZVBhZGRpbmcoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcHVibGljIHJlc2V0KCkge1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgaWYgKHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIpIHtcbiAgICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZWNyeXB0KFxuICAgIGRhdGE6IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlcixcbiAgICBrZXk6IEFycmF5QnVmZmVyLFxuICAgIGl2OiBBcnJheUJ1ZmZlclxuICApOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gICAgaWYgKHRoaXMudXNlU29mdHdhcmUpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0KG5ldyBVaW50OEFycmF5KGRhdGEpLCBrZXksIGl2KTtcbiAgICAgICAgY29uc3QgZGVjcnlwdFJlc3VsdCA9IHRoaXMuZmx1c2goKTtcbiAgICAgICAgaWYgKGRlY3J5cHRSZXN1bHQpIHtcbiAgICAgICAgICByZXNvbHZlKGRlY3J5cHRSZXN1bHQuYnVmZmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdbc29mdHdhcmVEZWNyeXB0XSBGYWlsZWQgdG8gZGVjcnlwdCBkYXRhJykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2ViQ3J5cHRvRGVjcnlwdChuZXcgVWludDhBcnJheShkYXRhKSwga2V5LCBpdik7XG4gIH1cblxuICAvLyBTb2Z0d2FyZSBkZWNyeXB0aW9uIGlzIHByb2dyZXNzaXZlLiBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIG1heSBub3QgcmV0dXJuIGEgcmVzdWx0IG9uIGVhY2ggY2FsbC4gQW55IGNhY2hlZFxuICAvLyBkYXRhIGlzIGhhbmRsZWQgaW4gdGhlIGZsdXNoKCkgY2FsbFxuICBwdWJsaWMgc29mdHdhcmVEZWNyeXB0KFxuICAgIGRhdGE6IFVpbnQ4QXJyYXksXG4gICAga2V5OiBBcnJheUJ1ZmZlcixcbiAgICBpdjogQXJyYXlCdWZmZXJcbiAgKTogQXJyYXlCdWZmZXIgfCBudWxsIHtcbiAgICBjb25zdCB7IGN1cnJlbnRJViwgY3VycmVudFJlc3VsdCwgcmVtYWluZGVyRGF0YSB9ID0gdGhpcztcbiAgICB0aGlzLmxvZ09uY2UoJ0pTIEFFUyBkZWNyeXB0Jyk7XG4gICAgLy8gVGhlIG91dHB1dCBpcyBzdGFnZ2VyZWQgZHVyaW5nIHByb2dyZXNzaXZlIHBhcnNpbmcgLSB0aGUgY3VycmVudCByZXN1bHQgaXMgY2FjaGVkLCBhbmQgZW1pdHRlZCBvbiB0aGUgbmV4dCBjYWxsXG4gICAgLy8gVGhpcyBpcyBkb25lIGluIG9yZGVyIHRvIHN0cmlwIFBLQ1M3IHBhZGRpbmcsIHdoaWNoIGlzIGZvdW5kIGF0IHRoZSBlbmQgb2YgZWFjaCBzZWdtZW50LiBXZSBvbmx5IGtub3cgd2UndmUgcmVhY2hlZFxuICAgIC8vIHRoZSBlbmQgb24gZmx1c2goKSwgYnV0IGJ5IHRoYXQgdGltZSB3ZSBoYXZlIGFscmVhZHkgcmVjZWl2ZWQgYWxsIGJ5dGVzIGZvciB0aGUgc2VnbWVudC5cbiAgICAvLyBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBXZWJDcnlwdG9cblxuICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheShyZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2IChBRVMtMTI4ID0gMTI4IGJpdCBibG9ja3MgPSAxNiBieXRlcylcbiAgICBjb25zdCBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldFZhbGlkQ2h1bmsoZGF0YSk7XG4gICAgaWYgKCFjdXJyZW50Q2h1bmsubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudElWKSB7XG4gICAgICBpdiA9IGN1cnJlbnRJVjtcbiAgICB9XG5cbiAgICBsZXQgc29mdHdhcmVEZWNyeXB0ZXIgPSB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyO1xuICAgIGlmICghc29mdHdhcmVEZWNyeXB0ZXIpIHtcbiAgICAgIHNvZnR3YXJlRGVjcnlwdGVyID0gdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG5ldyBBRVNEZWNyeXB0b3IoKTtcbiAgICB9XG4gICAgc29mdHdhcmVEZWNyeXB0ZXIuZXhwYW5kS2V5KGtleSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBjdXJyZW50UmVzdWx0O1xuXG4gICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gc29mdHdhcmVEZWNyeXB0ZXIuZGVjcnlwdChjdXJyZW50Q2h1bmsuYnVmZmVyLCAwLCBpdik7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBzbGljZVVpbnQ4KGN1cnJlbnRDaHVuaywgLTE2KS5idWZmZXI7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwdWJsaWMgd2ViQ3J5cHRvRGVjcnlwdChcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtleTogQXJyYXlCdWZmZXIsXG4gICAgaXY6IEFycmF5QnVmZmVyXG4gICk6IFByb21pc2U8QXJyYXlCdWZmZXI+IHtcbiAgICBjb25zdCBzdWJ0bGUgPSB0aGlzLnN1YnRsZTtcbiAgICBpZiAodGhpcy5rZXkgIT09IGtleSB8fCAhdGhpcy5mYXN0QWVzS2V5KSB7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuZmFzdEFlc0tleSA9IG5ldyBGYXN0QUVTS2V5KHN1YnRsZSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmFzdEFlc0tleVxuICAgICAgLmV4cGFuZEtleSgpXG4gICAgICAudGhlbigoYWVzS2V5KSA9PiB7XG4gICAgICAgIC8vIGRlY3J5cHQgdXNpbmcgd2ViIGNyeXB0b1xuICAgICAgICBpZiAoIXN1YnRsZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ3dlYiBjcnlwdG8gbm90IGluaXRpYWxpemVkJykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nT25jZSgnV2ViQ3J5cHRvIEFFUyBkZWNyeXB0Jyk7XG4gICAgICAgIGNvbnN0IGNyeXB0byA9IG5ldyBBRVNDcnlwdG8oc3VidGxlLCBuZXcgVWludDhBcnJheShpdikpO1xuICAgICAgICByZXR1cm4gY3J5cHRvLmRlY3J5cHQoZGF0YS5idWZmZXIsIGFlc0tleSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYFtkZWNyeXB0ZXJdOiBXZWJDcnlwdG8gRXJyb3IsIGRpc2FibGUgV2ViQ3J5cHRvIEFQSSwgJHtlcnIubmFtZX06ICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm9uV2ViQ3J5cHRvRXJyb3IoZGF0YSwga2V5LCBpdik7XG4gICAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25XZWJDcnlwdG9FcnJvcihkYXRhLCBrZXksIGl2KTogQXJyYXlCdWZmZXIgfCBuZXZlciB7XG4gICAgdGhpcy51c2VTb2Z0d2FyZSA9IHRydWU7XG4gICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdChkYXRhLCBrZXksIGl2KTtcbiAgICBjb25zdCBkZWNyeXB0UmVzdWx0ID0gdGhpcy5mbHVzaCgpO1xuICAgIGlmIChkZWNyeXB0UmVzdWx0KSB7XG4gICAgICByZXR1cm4gZGVjcnlwdFJlc3VsdC5idWZmZXI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignV2ViQ3J5cHRvIGFuZCBzb2Z0d2FyZURlY3J5cHQ6IGZhaWxlZCB0byBkZWNyeXB0IGRhdGEnKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VmFsaWRDaHVuayhkYXRhOiBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG4gICAgbGV0IGN1cnJlbnRDaHVuayA9IGRhdGE7XG4gICAgY29uc3Qgc3BsaXRQb2ludCA9IGRhdGEubGVuZ3RoIC0gKGRhdGEubGVuZ3RoICUgQ0hVTktfU0laRSk7XG4gICAgaWYgKHNwbGl0UG9pbnQgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICBjdXJyZW50Q2h1bmsgPSBzbGljZVVpbnQ4KGRhdGEsIDAsIHNwbGl0UG9pbnQpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gc2xpY2VVaW50OChkYXRhLCBzcGxpdFBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRDaHVuaztcbiAgfVxuXG4gIHByaXZhdGUgbG9nT25jZShtc2c6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlci5sb2coYFtkZWNyeXB0ZXJdOiAke21zZ31gKTtcbiAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcbiAgfVxufVxuIiwiLyoqXG4gKiAgVGltZVJhbmdlcyB0byBzdHJpbmcgaGVscGVyXG4gKi9cblxuY29uc3QgVGltZVJhbmdlcyA9IHtcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uIChyOiBUaW1lUmFuZ2VzKSB7XG4gICAgbGV0IGxvZyA9ICcnO1xuICAgIGNvbnN0IGxlbiA9IHIubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxvZyArPSBgWyR7ci5zdGFydChpKS50b0ZpeGVkKDMpfS0ke3IuZW5kKGkpLnRvRml4ZWQoMyl9XWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvZztcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVSYW5nZXM7XG4iLCJpbXBvcnQgVGFza0xvb3AgZnJvbSAnLi4vdGFzay1sb29wJztcbmltcG9ydCB7IEZyYWdtZW50U3RhdGUgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IHsgQnVmZmVyYWJsZSwgQnVmZmVySGVscGVyLCBCdWZmZXJJbmZvIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEVycm9yRGV0YWlscywgRXJyb3JUeXBlcyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBDaHVua01ldGFkYXRhIH0gZnJvbSAnLi4vdHlwZXMvdHJhbnNtdXhlcic7XG5pbXBvcnQgeyBhcHBlbmRVaW50OEFycmF5IH0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcbmltcG9ydCB7IGFsaWduU3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvZGlzY29udGludWl0aWVzJztcbmltcG9ydCB7XG4gIGZpbmRGcmFnbWVudEJ5UERULFxuICBmaW5kRnJhZ21lbnRCeVBUUyxcbiAgZmluZEZyYWdXaXRoQ0MsXG59IGZyb20gJy4vZnJhZ21lbnQtZmluZGVycyc7XG5pbXBvcnQge1xuICBmaW5kUGFydCxcbiAgZ2V0RnJhZ21lbnRXaXRoU04sXG4gIGdldFBhcnRXaXRoLFxuICB1cGRhdGVGcmFnUFRTRFRTLFxufSBmcm9tICcuL2xldmVsLWhlbHBlcic7XG5pbXBvcnQgVHJhbnNtdXhlckludGVyZmFjZSBmcm9tICcuLi9kZW11eC90cmFuc211eGVyLWludGVyZmFjZSc7XG5pbXBvcnQgeyBGcmFnbWVudCwgUGFydCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgRnJhZ21lbnRMb2FkZXIsIHtcbiAgRnJhZ21lbnRMb2FkUHJvZ3Jlc3NDYWxsYmFjayxcbiAgTG9hZEVycm9yLFxufSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyJztcbmltcG9ydCBLZXlMb2FkZXIgZnJvbSAnLi4vbG9hZGVyL2tleS1sb2FkZXInO1xuaW1wb3J0IHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWRldGFpbHMnO1xuaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xuaW1wb3J0IFRpbWVSYW5nZXMgZnJvbSAnLi4vdXRpbHMvdGltZS1yYW5nZXMnO1xuaW1wb3J0IHsgUGxheWxpc3RMZXZlbFR5cGUgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHsgZ2V0UmV0cnlEZWxheSB9IGZyb20gJy4uL3V0aWxzL2Vycm9yLWhlbHBlcic7XG5pbXBvcnQgeyBOZXR3b3JrRXJyb3JBY3Rpb24gfSBmcm9tICcuL2Vycm9yLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUge1xuICBCdWZmZXJBcHBlbmRpbmdEYXRhLFxuICBFcnJvckRhdGEsXG4gIEZyYWdMb2FkZWREYXRhLFxuICBQYXJ0c0xvYWRlZERhdGEsXG4gIEtleUxvYWRlZERhdGEsXG4gIE1lZGlhQXR0YWNoZWREYXRhLFxuICBCdWZmZXJGbHVzaGluZ0RhdGEsXG4gIE1hbmlmZXN0TG9hZGVkRGF0YSxcbn0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgRnJhZ21lbnRUcmFja2VyIH0gZnJvbSAnLi9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCB0eXBlIHsgTGV2ZWwgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgdHlwZSB7IFJlbXV4ZWRUcmFjayB9IGZyb20gJy4uL3R5cGVzL3JlbXV4ZXInO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5pbXBvcnQgdHlwZSB7IEhsc0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IE5ldHdvcmtDb21wb25lbnRBUEkgfSBmcm9tICcuLi90eXBlcy9jb21wb25lbnQtYXBpJztcbmltcG9ydCB0eXBlIHsgU291cmNlQnVmZmVyTmFtZSB9IGZyb20gJy4uL3R5cGVzL2J1ZmZlcic7XG5pbXBvcnQgdHlwZSB7IFJhdGlvbmFsVGltZXN0YW1wIH0gZnJvbSAnLi4vdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24nO1xuXG50eXBlIFJlc29sdmVGcmFnTG9hZGVkID0gKEZyYWdMb2FkZWRFbmREYXRhKSA9PiB2b2lkO1xudHlwZSBSZWplY3RGcmFnTG9hZGVkID0gKExvYWRFcnJvcikgPT4gdm9pZDtcblxuZXhwb3J0IGNvbnN0IFN0YXRlID0ge1xuICBTVE9QUEVEOiAnU1RPUFBFRCcsXG4gIElETEU6ICdJRExFJyxcbiAgS0VZX0xPQURJTkc6ICdLRVlfTE9BRElORycsXG4gIEZSQUdfTE9BRElORzogJ0ZSQUdfTE9BRElORycsXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX1RSQUNLOiAnV0FJVElOR19UUkFDSycsXG4gIFBBUlNJTkc6ICdQQVJTSU5HJyxcbiAgUEFSU0VEOiAnUEFSU0VEJyxcbiAgRU5ERUQ6ICdFTkRFRCcsXG4gIEVSUk9SOiAnRVJST1InLFxuICBXQUlUSU5HX0lOSVRfUFRTOiAnV0FJVElOR19JTklUX1BUUycsXG4gIFdBSVRJTkdfTEVWRUw6ICdXQUlUSU5HX0xFVkVMJyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VTdHJlYW1Db250cm9sbGVyXG4gIGV4dGVuZHMgVGFza0xvb3BcbiAgaW1wbGVtZW50cyBOZXR3b3JrQ29tcG9uZW50QVBJXG57XG4gIHByb3RlY3RlZCBobHM6IEhscztcblxuICBwcm90ZWN0ZWQgZnJhZ1ByZXZpb3VzOiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgZnJhZ0N1cnJlbnQ6IEZyYWdtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBmcmFnbWVudFRyYWNrZXI6IEZyYWdtZW50VHJhY2tlcjtcbiAgcHJvdGVjdGVkIHRyYW5zbXV4ZXI6IFRyYW5zbXV4ZXJJbnRlcmZhY2UgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIF9zdGF0ZTogc3RyaW5nID0gU3RhdGUuU1RPUFBFRDtcbiAgcHJvdGVjdGVkIHBsYXlsaXN0VHlwZTogUGxheWxpc3RMZXZlbFR5cGU7XG4gIHByb3RlY3RlZCBtZWRpYTogSFRNTE1lZGlhRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgbWVkaWFCdWZmZXI6IEJ1ZmZlcmFibGUgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIGNvbmZpZzogSGxzQ29uZmlnO1xuICBwcm90ZWN0ZWQgYml0cmF0ZVRlc3Q6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJvdGVjdGVkIGxhc3RDdXJyZW50VGltZTogbnVtYmVyID0gMDtcbiAgcHJvdGVjdGVkIG5leHRMb2FkUG9zaXRpb246IG51bWJlciA9IDA7XG4gIHByb3RlY3RlZCBzdGFydFBvc2l0aW9uOiBudW1iZXIgPSAwO1xuICBwcm90ZWN0ZWQgc3RhcnRUaW1lT2Zmc2V0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIGxvYWRlZG1ldGFkYXRhOiBib29sZWFuID0gZmFsc2U7XG4gIHByb3RlY3RlZCByZXRyeURhdGU6IG51bWJlciA9IDA7XG4gIHByb3RlY3RlZCBsZXZlbHM6IEFycmF5PExldmVsPiB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgZnJhZ21lbnRMb2FkZXI6IEZyYWdtZW50TG9hZGVyO1xuICBwcm90ZWN0ZWQga2V5TG9hZGVyOiBLZXlMb2FkZXI7XG4gIHByb3RlY3RlZCBsZXZlbExhc3RMb2FkZWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgc3RhcnRGcmFnUmVxdWVzdGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByb3RlY3RlZCBkZWNyeXB0ZXI6IERlY3J5cHRlcjtcbiAgcHJvdGVjdGVkIGluaXRQVFM6IFJhdGlvbmFsVGltZXN0YW1wW10gPSBbXTtcbiAgcHJvdGVjdGVkIG9udnNlZWtpbmc6IEV2ZW50TGlzdGVuZXIgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIG9udmVuZGVkOiBFdmVudExpc3RlbmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBsb2dQcmVmaXg6IHN0cmluZyA9ICcnO1xuICBwcm90ZWN0ZWQgbG9nOiAobXNnOiBhbnkpID0+IHZvaWQ7XG4gIHByb3RlY3RlZCB3YXJuOiAobXNnOiBhbnkpID0+IHZvaWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgaGxzOiBIbHMsXG4gICAgZnJhZ21lbnRUcmFja2VyOiBGcmFnbWVudFRyYWNrZXIsXG4gICAga2V5TG9hZGVyOiBLZXlMb2FkZXIsXG4gICAgbG9nUHJlZml4OiBzdHJpbmcsXG4gICAgcGxheWxpc3RUeXBlOiBQbGF5bGlzdExldmVsVHlwZVxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucGxheWxpc3RUeXBlID0gcGxheWxpc3RUeXBlO1xuICAgIHRoaXMubG9nUHJlZml4ID0gbG9nUHJlZml4O1xuICAgIHRoaXMubG9nID0gbG9nZ2VyLmxvZy5iaW5kKGxvZ2dlciwgYCR7bG9nUHJlZml4fTpgKTtcbiAgICB0aGlzLndhcm4gPSBsb2dnZXIud2Fybi5iaW5kKGxvZ2dlciwgYCR7bG9nUHJlZml4fTpgKTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmZyYWdtZW50TG9hZGVyID0gbmV3IEZyYWdtZW50TG9hZGVyKGhscy5jb25maWcpO1xuICAgIHRoaXMua2V5TG9hZGVyID0ga2V5TG9hZGVyO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIoaGxzLmNvbmZpZyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZG9UaWNrKCkge1xuICAgIHRoaXMub25UaWNrRW5kKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25UaWNrRW5kKCkge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHB1YmxpYyBzdGFydExvYWQoc3RhcnRQb3NpdGlvbjogbnVtYmVyKTogdm9pZCB7fVxuXG4gIHB1YmxpYyBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmFib3J0KCk7XG4gICAgdGhpcy5rZXlMb2FkZXIuYWJvcnQodGhpcy5wbGF5bGlzdFR5cGUpO1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnPy5sb2FkZXIpIHtcbiAgICAgIGZyYWcuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgfVxuICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zdHJlYW1FbmRlZChcbiAgICBidWZmZXJJbmZvOiBCdWZmZXJJbmZvLFxuICAgIGxldmVsRGV0YWlsczogTGV2ZWxEZXRhaWxzXG4gICk6IGJvb2xlYW4ge1xuICAgIC8vIElmIHBsYXlsaXN0IGlzIGxpdmUsIHRoZXJlIGlzIGFub3RoZXIgYnVmZmVyZWQgcmFuZ2UgYWZ0ZXIgdGhlIGN1cnJlbnQgcmFuZ2UsIG5vdGhpbmcgYnVmZmVyZWQsIG1lZGlhIGlzIGRldGFjaGVkLFxuICAgIC8vIG9mIG5vdGhpbmcgbG9hZGluZy9sb2FkZWQgcmV0dXJuIGZhbHNlXG4gICAgaWYgKFxuICAgICAgbGV2ZWxEZXRhaWxzLmxpdmUgfHxcbiAgICAgIGJ1ZmZlckluZm8ubmV4dFN0YXJ0IHx8XG4gICAgICAhYnVmZmVySW5mby5lbmQgfHxcbiAgICAgICF0aGlzLm1lZGlhXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRMaXN0ID0gbGV2ZWxEZXRhaWxzLnBhcnRMaXN0O1xuICAgIC8vIFNpbmNlIHRoZSBsYXN0IHBhcnQgaXNuJ3QgZ3VhcmFudGVlZCB0byBjb3JyZXNwb25kIHRvIHRoZSBsYXN0IHBsYXlsaXN0IHNlZ21lbnQgZm9yIExvdy1MYXRlbmN5IEhMUyxcbiAgICAvLyBjaGVjayBpbnN0ZWFkIGlmIHRoZSBsYXN0IHBhcnQgaXMgYnVmZmVyZWQuXG4gICAgaWYgKHBhcnRMaXN0Py5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV07XG5cbiAgICAgIC8vIENoZWNraW5nIHRoZSBtaWRwb2ludCBvZiB0aGUgcGFydCBmb3IgcG90ZW50aWFsIG1hcmdpbiBvZiBlcnJvciBhbmQgcmVsYXRlZCBpc3N1ZXMuXG4gICAgICAvLyBOT1RFOiBUZWNobmljYWxseSBJIGJlbGlldmUgcGFydHMgY291bGQgeWllbGQgY29udGVudCB0aGF0IGlzIDwgdGhlIGNvbXB1dGVkIGR1cmF0aW9uIChpbmNsdWRpbmcgcG90ZW50aWFsIGEgZHVyYXRpb24gb2YgMClcbiAgICAgIC8vIGFuZCBzdGlsbCBiZSBzcGVjLWNvbXBsaWFudCwgc28gdGhlcmUgbWF5IHN0aWxsIGJlIGVkZ2UgY2FzZXMgaGVyZS4gTGlrZXdpc2UsIHRoZXJlIGNvdWxkIGJlIGlzc3VlcyBpbiBlbmQgb2Ygc3RyZWFtXG4gICAgICAvLyBwYXJ0IG1pc21hdGNoZXMgZm9yIGluZGVwZW5kZW50IGF1ZGlvIGFuZCB2aWRlbyBwbGF5bGlzdHMvc2VnbWVudHMuXG4gICAgICBjb25zdCBsYXN0UGFydEJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmlzQnVmZmVyZWQoXG4gICAgICAgIHRoaXMubWVkaWEsXG4gICAgICAgIGxhc3RQYXJ0LnN0YXJ0ICsgbGFzdFBhcnQuZHVyYXRpb24gLyAyXG4gICAgICApO1xuICAgICAgcmV0dXJuIGxhc3RQYXJ0QnVmZmVyZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgcGxheWxpc3RUeXBlID1cbiAgICAgIGxldmVsRGV0YWlscy5mcmFnbWVudHNbbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggLSAxXS50eXBlO1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50VHJhY2tlci5pc0VuZExpc3RBcHBlbmRlZChwbGF5bGlzdFR5cGUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldExldmVsRGV0YWlscygpOiBMZXZlbERldGFpbHMgfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLmxldmVscyAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxMYXN0TG9hZGVkXT8uZGV0YWlscztcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NZWRpYUF0dGFjaGVkKFxuICAgIGV2ZW50OiBFdmVudHMuTUVESUFfQVRUQUNIRUQsXG4gICAgZGF0YTogTWVkaWFBdHRhY2hlZERhdGFcbiAgKSB7XG4gICAgY29uc3QgbWVkaWEgPSAodGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhKTtcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcykgYXMgRXZlbnRMaXN0ZW5lcjtcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKSBhcyBFdmVudExpc3RlbmVyO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKHRoaXMubGV2ZWxzICYmIGNvbmZpZy5hdXRvU3RhcnRMb2FkICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgIHRoaXMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhPy5lbmRlZCkge1xuICAgICAgdGhpcy5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgIGlmIChtZWRpYSAmJiB0aGlzLm9udnNlZWtpbmcgJiYgdGhpcy5vbnZlbmRlZCkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmtleUxvYWRlcikge1xuICAgICAgdGhpcy5rZXlMb2FkZXIuZGV0YWNoKCk7XG4gICAgfVxuICAgIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFTZWVraW5nKCkge1xuICAgIGNvbnN0IHsgY29uZmlnLCBmcmFnQ3VycmVudCwgbWVkaWEsIG1lZGlhQnVmZmVyLCBzdGF0ZSB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VGltZTogbnVtYmVyID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IDA7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKFxuICAgICAgbWVkaWFCdWZmZXIgPyBtZWRpYUJ1ZmZlciA6IG1lZGlhLFxuICAgICAgY3VycmVudFRpbWUsXG4gICAgICBjb25maWcubWF4QnVmZmVySG9sZVxuICAgICk7XG5cbiAgICB0aGlzLmxvZyhcbiAgICAgIGBtZWRpYSBzZWVraW5nIHRvICR7XG4gICAgICAgIE51bWJlci5pc0Zpbml0ZShjdXJyZW50VGltZSkgPyBjdXJyZW50VGltZS50b0ZpeGVkKDMpIDogY3VycmVudFRpbWVcbiAgICAgIH0sIHN0YXRlOiAke3N0YXRlfWBcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgfSBlbHNlIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgLy8gU2Vla2luZyB3aGlsZSBmcmFnIGxvYWQgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgY29uc3QgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XG4gICAgICBjb25zdCBmcmFnRW5kT2Zmc2V0ID1cbiAgICAgICAgZnJhZ0N1cnJlbnQuc3RhcnQgKyBmcmFnQ3VycmVudC5kdXJhdGlvbiArIHRvbGVyYW5jZTtcbiAgICAgIC8vIGlmIHNlZWtpbmcgb3V0IG9mIGJ1ZmZlcmVkIHJhbmdlIG9yIGludG8gbmV3IG9uZVxuICAgICAgaWYgKFxuICAgICAgICAhYnVmZmVySW5mby5sZW4gfHxcbiAgICAgICAgZnJhZ0VuZE9mZnNldCA8IGJ1ZmZlckluZm8uc3RhcnQgfHxcbiAgICAgICAgZnJhZ1N0YXJ0T2Zmc2V0ID4gYnVmZmVySW5mby5lbmRcbiAgICAgICkge1xuICAgICAgICBjb25zdCBwYXN0RnJhZ21lbnQgPSBjdXJyZW50VGltZSA+IGZyYWdFbmRPZmZzZXQ7XG4gICAgICAgIC8vIGlmIHRoZSBzZWVrIHBvc2l0aW9uIGlzIG91dHNpZGUgdGhlIGN1cnJlbnQgZnJhZ21lbnQgcmFuZ2VcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZnJhZ1N0YXJ0T2Zmc2V0IHx8IHBhc3RGcmFnbWVudCkge1xuICAgICAgICAgIGlmIChwYXN0RnJhZ21lbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICAgICAgJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgd2hpbGUgZnJhZ21lbnQgbG9hZCBpbiBwcm9ncmVzcywgY2FuY2VsIGZyYWdtZW50IGxvYWQnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIC8vIFJlbW92ZSBnYXAgZnJhZ21lbnRzXG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKFxuICAgICAgICBjdXJyZW50VGltZSxcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIHRoaXMucGxheWxpc3RUeXBlLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuXG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cblxuICAgIC8vIGluIGNhc2Ugc2Vla2luZyBvY2N1cnMgYWx0aG91Z2ggbm8gbWVkaWEgYnVmZmVyZWQsIGFkanVzdCBzdGFydFBvc2l0aW9uIGFuZCBuZXh0TG9hZFBvc2l0aW9uIHRvIHNlZWsgdGFyZ2V0XG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmICFidWZmZXJJbmZvLmxlbikge1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLy8gQXN5bmMgdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG4gICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NZWRpYUVuZGVkKCkge1xuICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1hbmlmZXN0TG9hZGVkKFxuICAgIGV2ZW50OiBFdmVudHMuTUFOSUZFU1RfTE9BREVELFxuICAgIGRhdGE6IE1hbmlmZXN0TG9hZGVkRGF0YVxuICApOiB2b2lkIHtcbiAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IGRhdGEuc3RhcnRUaW1lT2Zmc2V0O1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkhhbmRsZXJEZXN0cm95ZWQoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgaWYgKHRoaXMuZnJhZ21lbnRMb2FkZXIpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5rZXlMb2FkZXIpIHtcbiAgICAgIHRoaXMua2V5TG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLmRlY3J5cHRlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5obHMgPVxuICAgICAgdGhpcy5sb2cgPVxuICAgICAgdGhpcy53YXJuID1cbiAgICAgIHRoaXMuZGVjcnlwdGVyID1cbiAgICAgIHRoaXMua2V5TG9hZGVyID1cbiAgICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIgPVxuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPVxuICAgICAgICBudWxsIGFzIGFueTtcbiAgICBzdXBlci5vbkhhbmRsZXJEZXN0cm95ZWQoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBsb2FkRnJhZ21lbnQoXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAgbGV2ZWw6IExldmVsLFxuICAgIHRhcmdldEJ1ZmZlclRpbWU6IG51bWJlclxuICApIHtcbiAgICB0aGlzLl9sb2FkRnJhZ0ZvclBsYXliYWNrKGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgX2xvYWRGcmFnRm9yUGxheWJhY2soXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAgbGV2ZWw6IExldmVsLFxuICAgIHRhcmdldEJ1ZmZlclRpbWU6IG51bWJlclxuICApIHtcbiAgICBjb25zdCBwcm9ncmVzc0NhbGxiYWNrOiBGcmFnbWVudExvYWRQcm9ncmVzc0NhbGxiYWNrID0gKFxuICAgICAgZGF0YTogRnJhZ0xvYWRlZERhdGFcbiAgICApID0+IHtcbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgYEZyYWdtZW50ICR7ZnJhZy5zbn0ke1xuICAgICAgICAgICAgZGF0YS5wYXJ0ID8gJyBwOiAnICsgZGF0YS5wYXJ0LmluZGV4IDogJydcbiAgICAgICAgICB9IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gd2FzIGRyb3BwZWQgZHVyaW5nIGRvd25sb2FkLmBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZyYWcuc3RhdHMuY2h1bmtDb3VudCsrO1xuICAgICAgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSk7XG4gICAgfTtcblxuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUsIHByb2dyZXNzQ2FsbGJhY2spXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAvLyBpZiB3ZSdyZSBoZXJlIHdlIHByb2JhYmx5IG5lZWRlZCB0byBiYWNrdHJhY2sgb3IgYXJlIHdhaXRpbmcgZm9yIG1vcmUgcGFydHNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HIHx8XG4gICAgICAgICAgICAoIXRoaXMuZnJhZ0N1cnJlbnQgJiYgc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ3BheWxvYWQnIGluIGRhdGEpIHtcbiAgICAgICAgICB0aGlzLmxvZyhgTG9hZGVkIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfWApO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BREVELCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgd2hvbGUgcGF5bG9hZDsgY29udHJvbGxlcnMgbm90IGltcGxlbWVudGluZyBwcm9ncmVzc2l2ZSBsb2FkaW5nIHJlY2VpdmUgZGF0YSBmcm9tIHRoaXMgY2FsbGJhY2tcbiAgICAgICAgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZGF0YSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlNUT1BQRUQgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXJuKHJlYXNvbik7XG4gICAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjbGVhclRyYWNrZXJJZk5lZWRlZChmcmFnOiBGcmFnbWVudCkge1xuICAgIGNvbnN0IHsgZnJhZ21lbnRUcmFja2VyIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZyYWdTdGF0ZSA9IGZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICBpZiAoZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLkFQUEVORElORykge1xuICAgICAgLy8gTG93ZXIgdGhlIGJ1ZmZlciBzaXplIGFuZCB0cnkgYWdhaW5cbiAgICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9IGZyYWcudHlwZSBhcyBQbGF5bGlzdExldmVsVHlwZTtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkSW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyhcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlcixcbiAgICAgICAgcGxheWxpc3RUeXBlXG4gICAgICApO1xuICAgICAgY29uc3QgbWluRm9yd2FyZEJ1ZmZlckxlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICBmcmFnLmR1cmF0aW9uLFxuICAgICAgICBidWZmZXJlZEluZm8gPyBidWZmZXJlZEluZm8ubGVuIDogdGhpcy5jb25maWcubWF4QnVmZmVyTGVuZ3RoXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKG1pbkZvcndhcmRCdWZmZXJMZW5ndGgpKSB7XG4gICAgICAgIGZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMubWVkaWFCdWZmZXI/LmJ1ZmZlcmVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gU3RvcCBnYXAgZm9yIGJhZCB0cmFja2VyIC8gYnVmZmVyIGZsdXNoIGJlaGF2aW9yXG4gICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgfSBlbHNlIGlmIChmcmFnbWVudFRyYWNrZXIuaGFzUGFydHMoZnJhZy50eXBlKSkge1xuICAgICAgLy8gSW4gbG93IGxhdGVuY3kgbW9kZSwgcmVtb3ZlIGZyYWdtZW50cyBmb3Igd2hpY2ggb25seSBzb21lIHBhcnRzIHdlcmUgYnVmZmVyZWRcbiAgICAgIGZyYWdtZW50VHJhY2tlci5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgc3RhdHM6IGZyYWcuc3RhdHMsXG4gICAgICAgIGlkOiBmcmFnLnR5cGUsXG4gICAgICB9KTtcbiAgICAgIGlmIChmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCkge1xuICAgICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGZsdXNoTWFpbkJ1ZmZlcihcbiAgICBzdGFydE9mZnNldDogbnVtYmVyLFxuICAgIGVuZE9mZnNldDogbnVtYmVyLFxuICAgIHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUgfCBudWxsID0gbnVsbFxuICApIHtcbiAgICBpZiAoIShzdGFydE9mZnNldCAtIGVuZE9mZnNldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2hlbiBhbHRlcm5hdGUgYXVkaW8gaXMgcGxheWluZywgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgYXVkaW8gYnVmZmVyLiBPdGhlcndpc2UsXG4gICAgLy8gcGFzc2luZyBhIG51bGwgdHlwZSBmbHVzaGVzIGJvdGggYnVmZmVyc1xuICAgIGNvbnN0IGZsdXNoU2NvcGU6IEJ1ZmZlckZsdXNoaW5nRGF0YSA9IHsgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZSB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2xvYWRJbml0U2VnbWVudChmcmFnOiBGcmFnbWVudCwgbGV2ZWw6IExldmVsKSB7XG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnLCBsZXZlbClcbiAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIGlmICghZGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB8fCAhdGhpcy5sZXZlbHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbG9hZCBhYm9ydGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoZGF0YTogRnJhZ0xvYWRlZERhdGEpID0+IHtcbiAgICAgICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gZGF0YTtcbiAgICAgICAgY29uc3QgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBkZWNyeXB0ZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBheWxvYWQgJiZcbiAgICAgICAgICBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmXG4gICAgICAgICAgZGVjcnlwdERhdGEgJiZcbiAgICAgICAgICBkZWNyeXB0RGF0YS5rZXkgJiZcbiAgICAgICAgICBkZWNyeXB0RGF0YS5pdiAmJlxuICAgICAgICAgIGRlY3J5cHREYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgLy8gZGVjcnlwdCBpbml0IHNlZ21lbnQgZGF0YVxuICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRlclxuICAgICAgICAgICAgLmRlY3J5cHQoXG4gICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHBheWxvYWQpLFxuICAgICAgICAgICAgICBkZWNyeXB0RGF0YS5rZXkuYnVmZmVyLFxuICAgICAgICAgICAgICBkZWNyeXB0RGF0YS5pdi5idWZmZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUixcbiAgICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICByZWFzb246IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRlY3J5cHRlZERhdGEpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogZGVjcnlwdGVkRGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgICAgICAgdHN0YXJ0OiBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICB0ZGVjcnlwdDogZW5kVGltZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZGF0YS5wYXlsb2FkID0gZGVjcnlwdGVkRGF0YTtcblxuICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGRhdGE6IEZyYWdMb2FkZWREYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZnJhZ0N1cnJlbnQsIGhscywgbGV2ZWxzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWxldmVscykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWxzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgICAgZnJhZy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5wYXlsb2FkKTtcbiAgICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHN0YXRzLmJ1ZmZlcmluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gc3RhdHMuYnVmZmVyaW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgICAgLy8gU2lsZW5jZSBGUkFHX0JVRkZFUkVEIGV2ZW50IGlmIGZyYWdDdXJyZW50IGlzIG51bGxcbiAgICAgICAgaWYgKGRhdGEuZnJhZyA9PT0gZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19CVUZGRVJFRCwge1xuICAgICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgICBmcmFnOiBmcmFnQ3VycmVudCxcbiAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICBpZDogZnJhZy50eXBlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FybihyZWFzb24pO1xuICAgICAgICB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpO1xuICAgICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWc6IEZyYWdtZW50IHwgbnVsbCkge1xuICAgIGNvbnN0IHsgZnJhZ0N1cnJlbnQgfSA9IHRoaXM7XG4gICAgcmV0dXJuIChcbiAgICAgICFmcmFnIHx8XG4gICAgICAhZnJhZ0N1cnJlbnQgfHxcbiAgICAgIGZyYWcubGV2ZWwgIT09IGZyYWdDdXJyZW50LmxldmVsIHx8XG4gICAgICBmcmFnLnNuICE9PSBmcmFnQ3VycmVudC5zbiB8fFxuICAgICAgZnJhZy51cmxJZCAhPT0gZnJhZ0N1cnJlbnQudXJsSWRcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWc6IEZyYWdtZW50LCBwYXJ0OiBQYXJ0IHwgbnVsbCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIHRoaXMubG9nKFxuICAgICAgYEJ1ZmZlcmVkICR7ZnJhZy50eXBlfSBzbjogJHtmcmFnLnNufSR7XG4gICAgICAgIHBhcnQgPyAnIHBhcnQ6ICcgKyBwYXJ0LmluZGV4IDogJydcbiAgICAgIH0gb2YgJHtcbiAgICAgICAgdGhpcy5wbGF5bGlzdFR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gPyAnbGV2ZWwnIDogJ3RyYWNrJ1xuICAgICAgfSAke2ZyYWcubGV2ZWx9IChmcmFnOlskeyhmcmFnLnN0YXJ0UFRTID8/IE5hTikudG9GaXhlZCgzKX0tJHsoXG4gICAgICAgIGZyYWcuZW5kUFRTID8/IE5hTlxuICAgICAgKS50b0ZpeGVkKDMpfV0gPiBidWZmZXI6JHtcbiAgICAgICAgbWVkaWFcbiAgICAgICAgICA/IFRpbWVSYW5nZXMudG9TdHJpbmcoQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKSlcbiAgICAgICAgICA6ICcoZGV0YWNoZWQpJ1xuICAgICAgfSlgXG4gICAgKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChcbiAgICAgICF0aGlzLmxvYWRlZG1ldGFkYXRhICYmXG4gICAgICBmcmFnLnR5cGUgPT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiAmJlxuICAgICAgbWVkaWEuYnVmZmVyZWQubGVuZ3RoICYmXG4gICAgICB0aGlzLmZyYWdDdXJyZW50Py5zbiA9PT0gdGhpcy5mcmFnUHJldmlvdXM/LnNuXG4gICAgKSB7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2Vla1RvU3RhcnRQb3MoKTtcbiAgICB9XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2Vla1RvU3RhcnRQb3MoKSB7fVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZEVuZERhdGE6IFBhcnRzTG9hZGVkRGF0YSkge1xuICAgIGNvbnN0IHsgdHJhbnNtdXhlciB9ID0gdGhpcztcbiAgICBpZiAoIXRyYW5zbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBmcmFnLCBwYXJ0LCBwYXJ0c0xvYWRlZCB9ID0gZnJhZ0xvYWRlZEVuZERhdGE7XG4gICAgLy8gSWYgd2UgZGlkIG5vdCBsb2FkIHBhcnRzLCBvciBsb2FkZWQgYWxsIHBhcnRzLCB3ZSBoYXZlIGNvbXBsZXRlIChub3QgcGFydGlhbCkgZnJhZ21lbnQgZGF0YVxuICAgIGNvbnN0IGNvbXBsZXRlID1cbiAgICAgICFwYXJ0c0xvYWRlZCB8fFxuICAgICAgcGFydHNMb2FkZWQubGVuZ3RoID09PSAwIHx8XG4gICAgICBwYXJ0c0xvYWRlZC5zb21lKChmcmFnTG9hZGVkKSA9PiAhZnJhZ0xvYWRlZCk7XG4gICAgY29uc3QgY2h1bmtNZXRhID0gbmV3IENodW5rTWV0YWRhdGEoXG4gICAgICBmcmFnLmxldmVsLFxuICAgICAgZnJhZy5zbiBhcyBudW1iZXIsXG4gICAgICBmcmFnLnN0YXRzLmNodW5rQ291bnQgKyAxLFxuICAgICAgMCxcbiAgICAgIHBhcnQgPyBwYXJ0LmluZGV4IDogLTEsXG4gICAgICAhY29tcGxldGVcbiAgICApO1xuICAgIHRyYW5zbXV4ZXIuZmx1c2goY2h1bmtNZXRhKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcHJvdGVjdGVkIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhcbiAgICBmcmFnOiBQYXJ0c0xvYWRlZERhdGEgfCBGcmFnTG9hZGVkRGF0YVxuICApIHt9XG5cbiAgcHJvdGVjdGVkIF9kb0ZyYWdMb2FkKFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIGxldmVsOiBMZXZlbCxcbiAgICB0YXJnZXRCdWZmZXJUaW1lOiBudW1iZXIgfCBudWxsID0gbnVsbCxcbiAgICBwcm9ncmVzc0NhbGxiYWNrPzogRnJhZ21lbnRMb2FkUHJvZ3Jlc3NDYWxsYmFja1xuICApOiBQcm9taXNlPFBhcnRzTG9hZGVkRGF0YSB8IEZyYWdMb2FkZWREYXRhIHwgbnVsbD4ge1xuICAgIGNvbnN0IGRldGFpbHMgPSBsZXZlbD8uZGV0YWlscztcbiAgICBpZiAoIXRoaXMubGV2ZWxzIHx8ICFkZXRhaWxzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBmcmFnIGxvYWQgYWJvcnRlZCwgbWlzc2luZyBsZXZlbCR7ZGV0YWlscyA/ICcnIDogJyBkZXRhaWwnfXNgXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBrZXlMb2FkaW5nUHJvbWlzZTogUHJvbWlzZTxLZXlMb2FkZWREYXRhIHwgdm9pZD4gfCBudWxsID0gbnVsbDtcbiAgICBpZiAoZnJhZy5lbmNyeXB0ZWQgJiYgIWZyYWcuZGVjcnlwdGRhdGE/LmtleSkge1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgIGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059LSR7ZGV0YWlscy5lbmRTTn1dLCAke1xuICAgICAgICAgIHRoaXMubG9nUHJlZml4ID09PSAnW3N0cmVhbS1jb250cm9sbGVyXScgPyAnbGV2ZWwnIDogJ3RyYWNrJ1xuICAgICAgICB9ICR7ZnJhZy5sZXZlbH1gXG4gICAgICApO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICBrZXlMb2FkaW5nUHJvbWlzZSA9IHRoaXMua2V5TG9hZGVyLmxvYWQoZnJhZykudGhlbigoa2V5TG9hZGVkRGF0YSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEuZnJhZykpIHtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5LRVlfTE9BREVELCBrZXlMb2FkZWREYXRhKTtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ga2V5TG9hZGVkRGF0YTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5LRVlfTE9BRElORywgeyBmcmFnIH0pO1xuICAgICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoYGZyYWcgbG9hZCBhYm9ydGVkLCBjb250ZXh0IGNoYW5nZWQgaW4gS0VZX0xPQURJTkdgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWZyYWcuZW5jcnlwdGVkICYmIGRldGFpbHMuZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5rZXlMb2FkZXIubG9hZENsZWFyKGZyYWcsIGRldGFpbHMuZW5jcnlwdGVkRnJhZ21lbnRzKTtcbiAgICB9XG5cbiAgICB0YXJnZXRCdWZmZXJUaW1lID0gTWF0aC5tYXgoZnJhZy5zdGFydCwgdGFyZ2V0QnVmZmVyVGltZSB8fCAwKTtcbiAgICBpZiAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgY29uc3QgcGFydExpc3QgPSBkZXRhaWxzLnBhcnRMaXN0O1xuICAgICAgaWYgKHBhcnRMaXN0ICYmIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRhcmdldEJ1ZmZlclRpbWUgPiBmcmFnLmVuZCAmJiBkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgICAgIGZyYWcgPSBkZXRhaWxzLmZyYWdtZW50SGludDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0SW5kZXggPSB0aGlzLmdldE5leHRQYXJ0KHBhcnRMaXN0LCBmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgICAgaWYgKHBhcnRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRMaXN0W3BhcnRJbmRleF07XG4gICAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgICBgTG9hZGluZyBwYXJ0IHNuOiAke2ZyYWcuc259IHA6ICR7cGFydC5pbmRleH0gY2M6ICR7XG4gICAgICAgICAgICAgIGZyYWcuY2NcbiAgICAgICAgICAgIH0gb2YgcGxheWxpc3QgWyR7ZGV0YWlscy5zdGFydFNOfS0ke1xuICAgICAgICAgICAgICBkZXRhaWxzLmVuZFNOXG4gICAgICAgICAgICB9XSBwYXJ0cyBbMC0ke3BhcnRJbmRleH0tJHtwYXJ0TGlzdC5sZW5ndGggLSAxfV0gJHtcbiAgICAgICAgICAgICAgdGhpcy5sb2dQcmVmaXggPT09ICdbc3RyZWFtLWNvbnRyb2xsZXJdJyA/ICdsZXZlbCcgOiAndHJhY2snXG4gICAgICAgICAgICB9OiAke2ZyYWcubGV2ZWx9LCB0YXJnZXQ6ICR7cGFyc2VGbG9hdChcbiAgICAgICAgICAgICAgdGFyZ2V0QnVmZmVyVGltZS50b0ZpeGVkKDMpXG4gICAgICAgICAgICApfWBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHBhcnQuc3RhcnQgKyBwYXJ0LmR1cmF0aW9uO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgbGV0IHJlc3VsdDogUHJvbWlzZTxQYXJ0c0xvYWRlZERhdGEgfCBGcmFnTG9hZGVkRGF0YSB8IG51bGw+O1xuICAgICAgICAgIGlmIChrZXlMb2FkaW5nUHJvbWlzZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0ga2V5TG9hZGluZ1Byb21pc2VcbiAgICAgICAgICAgICAgLnRoZW4oKGtleUxvYWRlZERhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAha2V5TG9hZGVkRGF0YSB8fFxuICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoa2V5TG9hZGVkRGF0YS5mcmFnKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvRnJhZ1BhcnRzTG9hZChcbiAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZG9GcmFnUGFydHNMb2FkKFxuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFja1xuICAgICAgICAgICAgKS5jYXRjaCgoZXJyb3I6IExvYWRFcnJvcikgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BRElORywge1xuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICB0YXJnZXRCdWZmZXJUaW1lLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgZnJhZyBsb2FkIGFib3J0ZWQsIGNvbnRleHQgY2hhbmdlZCBpbiBGUkFHX0xPQURJTkcgcGFydHNgXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgIWZyYWcudXJsIHx8XG4gICAgICAgICAgdGhpcy5sb2FkZWRFbmRPZlBhcnRzKHBhcnRMaXN0LCB0YXJnZXRCdWZmZXJUaW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBGcmFnbWVudCBoaW50IGhhcyBubyBwYXJ0c1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxvZyhcbiAgICAgIGBMb2FkaW5nIGZyYWdtZW50ICR7ZnJhZy5zbn0gY2M6ICR7ZnJhZy5jY30gJHtcbiAgICAgICAgZGV0YWlscyA/ICdvZiBbJyArIGRldGFpbHMuc3RhcnRTTiArICctJyArIGRldGFpbHMuZW5kU04gKyAnXSAnIDogJydcbiAgICAgIH0ke3RoaXMubG9nUHJlZml4ID09PSAnW3N0cmVhbS1jb250cm9sbGVyXScgPyAnbGV2ZWwnIDogJ3RyYWNrJ306ICR7XG4gICAgICAgIGZyYWcubGV2ZWxcbiAgICAgIH0sIHRhcmdldDogJHtwYXJzZUZsb2F0KHRhcmdldEJ1ZmZlclRpbWUudG9GaXhlZCgzKSl9YFxuICAgICk7XG4gICAgLy8gRG9uJ3QgdXBkYXRlIG5leHRMb2FkUG9zaXRpb24gZm9yIGZyYWdtZW50cyB3aGljaCBhcmUgbm90IGJ1ZmZlcmVkXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLnNuIGFzIG51bWJlcikgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuXG4gICAgLy8gTG9hZCBrZXkgYmVmb3JlIHN0cmVhbWluZyBmcmFnbWVudCBkYXRhXG4gICAgY29uc3QgZGF0YU9uUHJvZ3Jlc3MgPSB0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZTtcbiAgICBsZXQgcmVzdWx0OiBQcm9taXNlPFBhcnRzTG9hZGVkRGF0YSB8IEZyYWdMb2FkZWREYXRhIHwgbnVsbD47XG4gICAgaWYgKGRhdGFPblByb2dyZXNzICYmIGtleUxvYWRpbmdQcm9taXNlKSB7XG4gICAgICByZXN1bHQgPSBrZXlMb2FkaW5nUHJvbWlzZVxuICAgICAgICAudGhlbigoa2V5TG9hZGVkRGF0YSkgPT4ge1xuICAgICAgICAgIGlmICgha2V5TG9hZGVkRGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChrZXlMb2FkZWREYXRhPy5mcmFnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50TG9hZGVyLmxvYWQoZnJhZywgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2FkIHVuZW5jcnlwdGVkIGZyYWdtZW50IGRhdGEgd2l0aCBwcm9ncmVzcyBldmVudCxcbiAgICAgIC8vIG9yIGhhbmRsZSBmcmFnbWVudCByZXN1bHQgYWZ0ZXIga2V5IGFuZCBmcmFnbWVudCBhcmUgZmluaXNoZWQgbG9hZGluZ1xuICAgICAgcmVzdWx0ID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmxvYWQoXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBkYXRhT25Qcm9ncmVzcyA/IHByb2dyZXNzQ2FsbGJhY2sgOiB1bmRlZmluZWRcbiAgICAgICAgKSxcbiAgICAgICAga2V5TG9hZGluZ1Byb21pc2UsXG4gICAgICBdKVxuICAgICAgICAudGhlbigoW2ZyYWdMb2FkZWREYXRhXSkgPT4ge1xuICAgICAgICAgIGlmICghZGF0YU9uUHJvZ3Jlc3MgJiYgZnJhZ0xvYWRlZERhdGEgJiYgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhmcmFnTG9hZGVkRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcmFnTG9hZGVkRGF0YTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSk7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BRElORywgeyBmcmFnLCB0YXJnZXRCdWZmZXJUaW1lIH0pO1xuICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBFcnJvcihgZnJhZyBsb2FkIGFib3J0ZWQsIGNvbnRleHQgY2hhbmdlZCBpbiBGUkFHX0xPQURJTkdgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgZG9GcmFnUGFydHNMb2FkKFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIGZyb21QYXJ0OiBQYXJ0LFxuICAgIGxldmVsOiBMZXZlbCxcbiAgICBwcm9ncmVzc0NhbGxiYWNrOiBGcmFnbWVudExvYWRQcm9ncmVzc0NhbGxiYWNrXG4gICk6IFByb21pc2U8UGFydHNMb2FkZWREYXRhIHwgbnVsbD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShcbiAgICAgIChyZXNvbHZlOiBSZXNvbHZlRnJhZ0xvYWRlZCwgcmVqZWN0OiBSZWplY3RGcmFnTG9hZGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRzTG9hZGVkOiBGcmFnTG9hZGVkRGF0YVtdID0gW107XG4gICAgICAgIGNvbnN0IGluaXRpYWxQYXJ0TGlzdCA9IGxldmVsLmRldGFpbHM/LnBhcnRMaXN0O1xuICAgICAgICBjb25zdCBsb2FkUGFydCA9IChwYXJ0OiBQYXJ0KSA9PiB7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudExvYWRlclxuICAgICAgICAgICAgLmxvYWRQYXJ0KGZyYWcsIHBhcnQsIHByb2dyZXNzQ2FsbGJhY2spXG4gICAgICAgICAgICAudGhlbigocGFydExvYWRlZERhdGE6IEZyYWdMb2FkZWREYXRhKSA9PiB7XG4gICAgICAgICAgICAgIHBhcnRzTG9hZGVkW3BhcnQuaW5kZXhdID0gcGFydExvYWRlZERhdGE7XG4gICAgICAgICAgICAgIGNvbnN0IGxvYWRlZFBhcnQgPSBwYXJ0TG9hZGVkRGF0YS5wYXJ0IGFzIFBhcnQ7XG4gICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BREVELCBwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRQYXJ0ID1cbiAgICAgICAgICAgICAgICBnZXRQYXJ0V2l0aChsZXZlbCwgZnJhZy5zbiBhcyBudW1iZXIsIHBhcnQuaW5kZXggKyAxKSB8fFxuICAgICAgICAgICAgICAgIGZpbmRQYXJ0KGluaXRpYWxQYXJ0TGlzdCwgZnJhZy5zbiBhcyBudW1iZXIsIHBhcnQuaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgaWYgKG5leHRQYXJ0KSB7XG4gICAgICAgICAgICAgICAgbG9hZFBhcnQobmV4dFBhcnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICBwYXJ0OiBsb2FkZWRQYXJ0LFxuICAgICAgICAgICAgICAgICAgcGFydHNMb2FkZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgbG9hZFBhcnQoZnJvbVBhcnQpO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3I6IExvYWRFcnJvciB8IEVycm9yKSB7XG4gICAgaWYgKCdkYXRhJyBpbiBlcnJvcikge1xuICAgICAgY29uc3QgZGF0YSA9IGVycm9yLmRhdGE7XG4gICAgICBpZiAoZXJyb3IuZGF0YSAmJiBkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVEKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRnJhZ0xvYWRBYm9ydGVkKGRhdGEuZnJhZywgZGF0YS5wYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBkYXRhIGFzIEVycm9yRGF0YSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgIGVycjogZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlVHJhbnNtdXhlckZsdXNoKGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgaWYgKCFjb250ZXh0IHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIXRoaXMuZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCAmJlxuICAgICAgICB0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUlxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGZyYWcsIHBhcnQsIGxldmVsIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZnJhZy5zdGF0cy5wYXJzaW5nLmVuZCA9IG5vdztcbiAgICBpZiAocGFydCkge1xuICAgICAgcGFydC5zdGF0cy5wYXJzaW5nLmVuZCA9IG5vdztcbiAgICB9XG4gICAgdGhpcy51cGRhdGVMZXZlbFRpbWluZyhmcmFnLCBwYXJ0LCBsZXZlbCwgY2h1bmtNZXRhLnBhcnRpYWwpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldEN1cnJlbnRDb250ZXh0KFxuICAgIGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YVxuICApOiB7IGZyYWc6IEZyYWdtZW50OyBwYXJ0OiBQYXJ0IHwgbnVsbDsgbGV2ZWw6IExldmVsIH0gfCBudWxsIHtcbiAgICBjb25zdCB7IGxldmVscywgZnJhZ0N1cnJlbnQgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsZXZlbDogbGV2ZWxJbmRleCwgc24sIHBhcnQ6IHBhcnRJbmRleCB9ID0gY2h1bmtNZXRhO1xuICAgIGlmICghbGV2ZWxzPy5bbGV2ZWxJbmRleF0pIHtcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYExldmVscyBvYmplY3Qgd2FzIHVuc2V0IHdoaWxlIGJ1ZmZlcmluZyBmcmFnbWVudCAke3NufSBvZiBsZXZlbCAke2xldmVsSW5kZXh9LiBUaGUgY3VycmVudCBjaHVuayB3aWxsIG5vdCBiZSBidWZmZXJlZC5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGNvbnN0IHBhcnQgPSBwYXJ0SW5kZXggPiAtMSA/IGdldFBhcnRXaXRoKGxldmVsLCBzbiwgcGFydEluZGV4KSA6IG51bGw7XG4gICAgY29uc3QgZnJhZyA9IHBhcnRcbiAgICAgID8gcGFydC5mcmFnbWVudFxuICAgICAgOiBnZXRGcmFnbWVudFdpdGhTTihsZXZlbCwgc24sIGZyYWdDdXJyZW50KTtcbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQgIT09IGZyYWcpIHtcbiAgICAgIGZyYWcuc3RhdHMgPSBmcmFnQ3VycmVudC5zdGF0cztcbiAgICB9XG4gICAgcmV0dXJuIHsgZnJhZywgcGFydCwgbGV2ZWwgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBidWZmZXJGcmFnbWVudERhdGEoXG4gICAgZGF0YTogUmVtdXhlZFRyYWNrLFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIHBhcnQ6IFBhcnQgfCBudWxsLFxuICAgIGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YVxuICApIHtcbiAgICBpZiAoIWRhdGEgfHwgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgZGF0YTEsIGRhdGEyIH0gPSBkYXRhO1xuICAgIGxldCBidWZmZXIgPSBkYXRhMTtcbiAgICBpZiAoZGF0YTEgJiYgZGF0YTIpIHtcbiAgICAgIC8vIENvbWJpbmUgdGhlIG1vb2YgKyBtZGF0IHNvIHRoYXQgd2UgYnVmZmVyIHdpdGggYSBzaW5nbGUgYXBwZW5kXG4gICAgICBidWZmZXIgPSBhcHBlbmRVaW50OEFycmF5KGRhdGExLCBkYXRhMik7XG4gICAgfVxuXG4gICAgaWYgKCFidWZmZXI/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlZ21lbnQ6IEJ1ZmZlckFwcGVuZGluZ0RhdGEgPSB7XG4gICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIGNodW5rTWV0YSxcbiAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgZGF0YTogYnVmZmVyLFxuICAgIH07XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVORElORywgc2VnbWVudCk7XG5cbiAgICBpZiAoZGF0YS5kcm9wcGVkICYmIGRhdGEuaW5kZXBlbmRlbnQgJiYgIXBhcnQpIHtcbiAgICAgIC8vIENsZWFyIGJ1ZmZlciBzbyB0aGF0IHdlIHJlbG9hZCBwcmV2aW91cyBzZWdtZW50cyBzZXF1ZW50aWFsbHkgaWYgcmVxdWlyZWRcbiAgICAgIHRoaXMuZmx1c2hCdWZmZXJHYXAoZnJhZyk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGZsdXNoQnVmZmVyR2FwKGZyYWc6IEZyYWdtZW50KSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBjbGVhciB0aGUgYmFjayBidWZmZXIgc28gdGhhdCB3ZSBjYW4gYmFja3RyYWNrIGFzIG11Y2ggYXMgbmVlZGVkXG4gICAgaWYgKCFCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUpKSB7XG4gICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnLnN0YXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGJhY2stYnVmZmVyIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrIHRvIGFsbG93IGJhY2sgdHJhY2tpbmdcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IGZyYWdEdXJhdGlvbiA9IGZyYWcuZHVyYXRpb247XG4gICAgY29uc3Qgc2VnbWVudEZyYWN0aW9uID0gTWF0aC5taW4oXG4gICAgICB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlICogMixcbiAgICAgIGZyYWdEdXJhdGlvbiAqIDAuMjVcbiAgICApO1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoXG4gICAgICBNYXRoLm1pbihmcmFnLnN0YXJ0IC0gc2VnbWVudEZyYWN0aW9uLCBidWZmZXJJbmZvLmVuZCAtIHNlZ21lbnRGcmFjdGlvbiksXG4gICAgICBjdXJyZW50VGltZSArIHNlZ21lbnRGcmFjdGlvblxuICAgICk7XG4gICAgaWYgKGZyYWcuc3RhcnQgLSBzdGFydCA+IHNlZ21lbnRGcmFjdGlvbikge1xuICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoc3RhcnQsIGZyYWcuc3RhcnQpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRGd2RCdWZmZXJJbmZvKFxuICAgIGJ1ZmZlcmFibGU6IEJ1ZmZlcmFibGUgfCBudWxsLFxuICAgIHR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlXG4gICk6IEJ1ZmZlckluZm8gfCBudWxsIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHBvcykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGd2RCdWZmZXJJbmZvQXRQb3MoYnVmZmVyYWJsZSwgcG9zLCB0eXBlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRGd2RCdWZmZXJJbmZvQXRQb3MoXG4gICAgYnVmZmVyYWJsZTogQnVmZmVyYWJsZSB8IG51bGwsXG4gICAgcG9zOiBudW1iZXIsXG4gICAgdHlwZTogUGxheWxpc3RMZXZlbFR5cGVcbiAgKTogQnVmZmVySW5mbyB8IG51bGwge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZzogeyBtYXhCdWZmZXJIb2xlIH0sXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKGJ1ZmZlcmFibGUsIHBvcywgbWF4QnVmZmVySG9sZSk7XG4gICAgLy8gV29ya2Fyb3VuZCBmbGF3IGluIGdldHRpbmcgZm9yd2FyZCBidWZmZXIgd2hlbiBtYXhCdWZmZXJIb2xlIGlzIHNtYWxsZXIgdGhhbiBnYXAgYXQgY3VycmVudCBwb3NcbiAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDAgJiYgYnVmZmVySW5mby5uZXh0U3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgYnVmZmVyZWRGcmFnQXRQb3MgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRCdWZmZXJlZEZyYWcocG9zLCB0eXBlKTtcbiAgICAgIGlmIChidWZmZXJlZEZyYWdBdFBvcyAmJiBidWZmZXJJbmZvLm5leHRTdGFydCA8IGJ1ZmZlcmVkRnJhZ0F0UG9zLmVuZCkge1xuICAgICAgICByZXR1cm4gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8oXG4gICAgICAgICAgYnVmZmVyYWJsZSxcbiAgICAgICAgICBwb3MsXG4gICAgICAgICAgTWF0aC5tYXgoYnVmZmVySW5mby5uZXh0U3RhcnQsIG1heEJ1ZmZlckhvbGUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJJbmZvO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldE1heEJ1ZmZlckxlbmd0aChsZXZlbEJpdHJhdGU/OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgY29uZmlnIH0gPSB0aGlzO1xuICAgIGxldCBtYXhCdWZMZW47XG4gICAgaWYgKGxldmVsQml0cmF0ZSkge1xuICAgICAgbWF4QnVmTGVuID0gTWF0aC5tYXgoXG4gICAgICAgICg4ICogY29uZmlnLm1heEJ1ZmZlclNpemUpIC8gbGV2ZWxCaXRyYXRlLFxuICAgICAgICBjb25maWcubWF4QnVmZmVyTGVuZ3RoXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZWR1Y2VNYXhCdWZmZXJMZW5ndGgodGhyZXNob2xkOiBudW1iZXIpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBtaW5MZW5ndGggPSB0aHJlc2hvbGQgfHwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICBpZiAoY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAvPSAyO1xuICAgICAgdGhpcy53YXJuKGBSZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHtjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RofXNgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0QXBwZW5kZWRGcmFnKFxuICAgIHBvc2l0aW9uOiBudW1iZXIsXG4gICAgcGxheWxpc3RUeXBlOiBQbGF5bGlzdExldmVsVHlwZSA9IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU5cbiAgKTogRnJhZ21lbnQgfCBudWxsIHtcbiAgICBjb25zdCBmcmFnT3JQYXJ0ID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKFxuICAgICAgcG9zaXRpb24sXG4gICAgICBQbGF5bGlzdExldmVsVHlwZS5NQUlOXG4gICAgKTtcbiAgICBpZiAoZnJhZ09yUGFydCAmJiAnZnJhZ21lbnQnIGluIGZyYWdPclBhcnQpIHtcbiAgICAgIHJldHVybiBmcmFnT3JQYXJ0LmZyYWdtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ09yUGFydDtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXROZXh0RnJhZ21lbnQoXG4gICAgcG9zOiBudW1iZXIsXG4gICAgbGV2ZWxEZXRhaWxzOiBMZXZlbERldGFpbHNcbiAgKTogRnJhZ21lbnQgfCBudWxsIHtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzO1xuICAgIGNvbnN0IGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKCFmcmFnTGVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIGNvbnN0IHsgY29uZmlnIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGxldCBmcmFnO1xuXG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICBjb25zdCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSA9IGNvbmZpZy5pbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTtcbiAgICAgIGlmIChmcmFnTGVuIDwgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUpIHtcbiAgICAgICAgdGhpcy53YXJuKFxuICAgICAgICAgIGBOb3QgZW5vdWdoIGZyYWdtZW50cyB0byBzdGFydCBwbGF5YmFjayAoaGF2ZTogJHtmcmFnTGVufSwgbmVlZDogJHtpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZX0pYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZWFsIGZyYWdtZW50IHN0YXJ0IHRpbWVzIGZvciBhIGxpdmUgc3RyZWFtIGFyZSBvbmx5IGtub3duIGFmdGVyIHRoZSBQVFMgcmFuZ2UgZm9yIHRoYXQgbGV2ZWwgaXMga25vd24uXG4gICAgICAvLyBJbiBvcmRlciB0byBkaXNjb3ZlciB0aGUgcmFuZ2UsIHdlIGxvYWQgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZm9yIHRoYXQgbGV2ZWwgYW5kIGRlbXV4IGl0LlxuICAgICAgLy8gRG8gbm90IGxvYWQgdXNpbmcgbGl2ZSBsb2dpYyBpZiB0aGUgc3RhcnRpbmcgZnJhZyBpcyByZXF1ZXN0ZWQgLSB3ZSB3YW50IHRvIHVzZSBnZXRGcmFnbWVudEF0UG9zaXRpb24oKSBzbyB0aGF0XG4gICAgICAvLyB3ZSBnZXQgdGhlIGZyYWdtZW50IG1hdGNoaW5nIHRoYXQgc3RhcnQgdGltZVxuICAgICAgaWYgKFxuICAgICAgICAhbGV2ZWxEZXRhaWxzLlBUU0tub3duICYmXG4gICAgICAgICF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJlxuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xXG4gICAgICApIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0SW5pdGlhbExpdmVGcmFnbWVudChsZXZlbERldGFpbHMsIGZyYWdtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IGZyYWdcbiAgICAgICAgICA/IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24gfHwgZnJhZy5zdGFydFxuICAgICAgICAgIDogcG9zO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zIDw9IHN0YXJ0KSB7XG4gICAgICAvLyBWb0QgcGxheWxpc3Q6IGlmIGxvYWRQb3NpdGlvbiBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZW4ndCBydW4gaW50byBhbnkgc3BlY2lhbCBjYXNlcyBhbHJlYWR5LCBqdXN0IGxvYWQgdGhlIGZyYWdtZW50IG1vc3QgY2xvc2VseSBtYXRjaGluZyB0aGUgcmVxdWVzdGVkIHBvc2l0aW9uXG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICBjb25zdCBlbmQgPSBjb25maWcubG93TGF0ZW5jeU1vZGVcbiAgICAgICAgPyBsZXZlbERldGFpbHMucGFydEVuZFxuICAgICAgICA6IGxldmVsRGV0YWlscy5mcmFnbWVudEVuZDtcbiAgICAgIGZyYWcgPSB0aGlzLmdldEZyYWdtZW50QXRQb3NpdGlvbihwb3MsIGVuZCwgbGV2ZWxEZXRhaWxzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkKGZyYWcpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGlzTG9vcExvYWRpbmcoZnJhZzogRnJhZ21lbnQsIHRhcmdldEJ1ZmZlclRpbWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHRyYWNrZXJTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIHJldHVybiAoXG4gICAgICAodHJhY2tlclN0YXRlID09PSBGcmFnbWVudFN0YXRlLk9LIHx8XG4gICAgICAgICh0cmFja2VyU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCAmJiAhIWZyYWcuZ2FwKSkgJiZcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA+IHRhcmdldEJ1ZmZlclRpbWVcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIGxldmVsRGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICAgIGJ1ZmZlckluZm86IEJ1ZmZlckluZm8sXG4gICAgcGxheWxpc3RUeXBlOiBQbGF5bGlzdExldmVsVHlwZSxcbiAgICBtYXhCdWZMZW46IG51bWJlclxuICApOiBGcmFnbWVudCB8IG51bGwge1xuICAgIGNvbnN0IGdhcFN0YXJ0ID0gZnJhZy5nYXA7XG4gICAgY29uc3QgbmV4dEZyYWdtZW50ID0gdGhpcy5nZXROZXh0RnJhZ21lbnQoXG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24sXG4gICAgICBsZXZlbERldGFpbHNcbiAgICApO1xuICAgIGlmIChuZXh0RnJhZ21lbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXh0RnJhZ21lbnQ7XG4gICAgfVxuICAgIGZyYWcgPSBuZXh0RnJhZ21lbnQ7XG4gICAgaWYgKGdhcFN0YXJ0ICYmIGZyYWcgJiYgIWZyYWcuZ2FwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAvLyBNZWRpYSBidWZmZXJlZCBhZnRlciBHQVAgdGFncyBzaG91bGQgbm90IG1ha2UgdGhlIG5leHQgYnVmZmVyIHRpbWVyYW5nZSBleGNlZWQgZm9yd2FyZCBidWZmZXIgbGVuZ3RoXG4gICAgICBjb25zdCBuZXh0YnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mb0F0UG9zKFxuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsXG4gICAgICAgIGJ1ZmZlckluZm8ubmV4dFN0YXJ0LFxuICAgICAgICBwbGF5bGlzdFR5cGVcbiAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIG5leHRidWZmZXJJbmZvICE9PSBudWxsICYmXG4gICAgICAgIGJ1ZmZlckluZm8ubGVuICsgbmV4dGJ1ZmZlckluZm8ubGVuID49IG1heEJ1ZkxlblxuICAgICAgKSB7XG4gICAgICAgIC8vIFJldHVybmluZyBoZXJlIG1pZ2h0IHJlc3VsdCBpbiBub3QgZmluZGluZyBhbiBhdWRpbyBhbmQgdmlkZW8gY2FuZGlhdGUgdG8gc2tpcCB0b1xuICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICBgYnVmZmVyIGZ1bGwgYWZ0ZXIgZ2FwcyBpbiBcIiR7cGxheWxpc3RUeXBlfVwiIHBsYXlsaXN0IHN0YXJ0aW5nIGF0IHNuOiAke2ZyYWcuc259YFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICBtYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkKGZyYWc6IEZyYWdtZW50IHwgbnVsbCk6IHR5cGVvZiBmcmFnIHtcbiAgICAvLyBJZiBhbiBpbml0U2VnbWVudCBpcyBwcmVzZW50LCBpdCBtdXN0IGJlIGJ1ZmZlcmVkIGZpcnN0XG4gICAgaWYgKGZyYWc/LmluaXRTZWdtZW50ICYmICFmcmFnPy5pbml0U2VnbWVudC5kYXRhICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICByZXR1cm4gZnJhZy5pbml0U2VnbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIGdldE5leHRQYXJ0KFxuICAgIHBhcnRMaXN0OiBQYXJ0W10sXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAgdGFyZ2V0QnVmZmVyVGltZTogbnVtYmVyXG4gICk6IG51bWJlciB7XG4gICAgbGV0IG5leHRQYXJ0ID0gLTE7XG4gICAgbGV0IGNvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICBsZXQgaW5kZXBlbmRlbnRBdHRyT21pdHRlZCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcnRMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICBpbmRlcGVuZGVudEF0dHJPbWl0dGVkID0gaW5kZXBlbmRlbnRBdHRyT21pdHRlZCAmJiAhcGFydC5pbmRlcGVuZGVudDtcbiAgICAgIGlmIChuZXh0UGFydCA+IC0xICYmIHRhcmdldEJ1ZmZlclRpbWUgPCBwYXJ0LnN0YXJ0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVkID0gcGFydC5sb2FkZWQ7XG4gICAgICBpZiAobG9hZGVkKSB7XG4gICAgICAgIG5leHRQYXJ0ID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAoY29udGlndW91cyB8fCBwYXJ0LmluZGVwZW5kZW50IHx8IGluZGVwZW5kZW50QXR0ck9taXR0ZWQpICYmXG4gICAgICAgIHBhcnQuZnJhZ21lbnQgPT09IGZyYWdcbiAgICAgICkge1xuICAgICAgICBuZXh0UGFydCA9IGk7XG4gICAgICB9XG4gICAgICBjb250aWd1b3VzID0gbG9hZGVkO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFBhcnQ7XG4gIH1cblxuICBwcml2YXRlIGxvYWRlZEVuZE9mUGFydHMoXG4gICAgcGFydExpc3Q6IFBhcnRbXSxcbiAgICB0YXJnZXRCdWZmZXJUaW1lOiBudW1iZXJcbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3QgbGFzdFBhcnQgPSBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbGFzdFBhcnQgJiYgdGFyZ2V0QnVmZmVyVGltZSA+IGxhc3RQYXJ0LnN0YXJ0ICYmIGxhc3RQYXJ0LmxvYWRlZDtcbiAgfVxuXG4gIC8qXG4gICBUaGlzIG1ldGhvZCBpcyB1c2VkIGZpbmQgdGhlIGJlc3QgbWF0Y2hpbmcgZmlyc3QgZnJhZ21lbnQgZm9yIGEgbGl2ZSBwbGF5bGlzdC4gVGhpcyBmcmFnbWVudCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGVcbiAgIFwic2xpZGluZ1wiIG9mIHRoZSBwbGF5bGlzdCwgd2hpY2ggaXMgaXRzIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiBwbGF5YmFjay4gQWZ0ZXIgc2xpZGluZyB3ZSBjYW4gY29tcHV0ZSB0aGUgcmVhbFxuICAgc3RhcnQgYW5kIGVuZCB0aW1lcyBmb3IgZWFjaCBmcmFnbWVudCBpbiB0aGUgcGxheWxpc3QgKGFmdGVyIHdoaWNoIHRoaXMgbWV0aG9kIHdpbGwgbm90IG5lZWQgdG8gYmUgY2FsbGVkKS5cbiAgKi9cbiAgcHJvdGVjdGVkIGdldEluaXRpYWxMaXZlRnJhZ21lbnQoXG4gICAgbGV2ZWxEZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gICAgZnJhZ21lbnRzOiBBcnJheTxGcmFnbWVudD5cbiAgKTogRnJhZ21lbnQgfCBudWxsIHtcbiAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICBsZXQgZnJhZzogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgICBpZiAoZnJhZ1ByZXZpb3VzKSB7XG4gICAgICBpZiAobGV2ZWxEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAvLyBQcmVmZXIgdXNpbmcgUERULCBiZWNhdXNlIGl0IGNhbiBiZSBhY2N1cmF0ZSBlbm91Z2ggdG8gY2hvb3NlIHRoZSBjb3JyZWN0IGZyYWdtZW50IHdpdGhvdXQga25vd2luZyB0aGUgbGV2ZWwgc2xpZGluZ1xuICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICBgTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIFBEVDogJHtmcmFnUHJldmlvdXMucHJvZ3JhbURhdGVUaW1lfWBcbiAgICAgICAgKTtcbiAgICAgICAgZnJhZyA9IGZpbmRGcmFnbWVudEJ5UERUKFxuICAgICAgICAgIGZyYWdtZW50cyxcbiAgICAgICAgICBmcmFnUHJldmlvdXMuZW5kUHJvZ3JhbURhdGVUaW1lLFxuICAgICAgICAgIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghZnJhZykge1xuICAgICAgICAvLyBTTiBkb2VzIG5vdCBuZWVkIHRvIGJlIGFjY3VyYXRlIGJldHdlZW4gcmVuZGl0aW9ucywgYnV0IGRlcGVuZGluZyBvbiB0aGUgcGFja2FnaW5nIGl0IG1heSBiZSBzby5cbiAgICAgICAgY29uc3QgdGFyZ2V0U04gPSAoZnJhZ1ByZXZpb3VzLnNuIGFzIG51bWJlcikgKyAxO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGFyZ2V0U04gPj0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiZcbiAgICAgICAgICB0YXJnZXRTTiA8PSBsZXZlbERldGFpbHMuZW5kU05cbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgZnJhZ05leHQgPSBmcmFnbWVudHNbdGFyZ2V0U04gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07XG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UncmUgc3RheWluZyB3aXRoaW4gdGhlIGNvbnRpbnVpdHkgcmFuZ2UsIHNpbmNlIFBUUyByZXNldHMgdXBvbiBhIG5ldyByYW5nZVxuICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMuY2MgPT09IGZyYWdOZXh0LmNjKSB7XG4gICAgICAgICAgICBmcmFnID0gZnJhZ05leHQ7XG4gICAgICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICAgICAgYExpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggbmV4dCBTTjogJHtcbiAgICAgICAgICAgICAgICBmcmFnIS5zblxuICAgICAgICAgICAgICB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gc3RheSB3aXRoaW4gdGhlIGNvbnRpbnVpdHkgcmFuZ2UgaWYgYXZhaWxhYmxlOyBvdGhlcndpc2UgdGhlIGZyYWdtZW50cyBpbiB0aGUgcGxheWxpc3RcbiAgICAgICAgLy8gd2lsbCBoYXZlIHRoZSB3cm9uZyBzdGFydCB0aW1lc1xuICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICBmcmFnID0gZmluZEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBmcmFnUHJldmlvdXMuY2MpO1xuICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICAgICAgYExpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBDQzogJHtmcmFnLnNufWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgYSBuZXcgc3RhcnQgZnJhZ21lbnQgd2hlbiBmcmFnUHJldmlvdXMgaXMgbnVsbFxuICAgICAgY29uc3QgbGl2ZVN0YXJ0ID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgIGlmIChsaXZlU3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKFxuICAgICAgICAgIGxpdmVTdGFydCxcbiAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID8gbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kIDogbGV2ZWxEZXRhaWxzLmVkZ2UsXG4gICAgICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICAvKlxuICBUaGlzIG1ldGhvZCBmaW5kcyB0aGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudCBnaXZlbiB0aGUgcHJvdmlkZWQgcG9zaXRpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKFxuICAgIGJ1ZmZlckVuZDogbnVtYmVyLFxuICAgIGVuZDogbnVtYmVyLFxuICAgIGxldmVsRGV0YWlsczogTGV2ZWxEZXRhaWxzXG4gICk6IEZyYWdtZW50IHwgbnVsbCB7XG4gICAgY29uc3QgeyBjb25maWcgfSA9IHRoaXM7XG4gICAgbGV0IHsgZnJhZ1ByZXZpb3VzIH0gPSB0aGlzO1xuICAgIGxldCB7IGZyYWdtZW50cywgZW5kU04gfSA9IGxldmVsRGV0YWlscztcbiAgICBjb25zdCB7IGZyYWdtZW50SGludCB9ID0gbGV2ZWxEZXRhaWxzO1xuICAgIGNvbnN0IHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgIGNvbnN0IHBhcnRMaXN0ID0gbGV2ZWxEZXRhaWxzLnBhcnRMaXN0O1xuXG4gICAgY29uc3QgbG9hZGluZ1BhcnRzID0gISEoXG4gICAgICBjb25maWcubG93TGF0ZW5jeU1vZGUgJiZcbiAgICAgIHBhcnRMaXN0Py5sZW5ndGggJiZcbiAgICAgIGZyYWdtZW50SGludFxuICAgICk7XG4gICAgaWYgKGxvYWRpbmdQYXJ0cyAmJiBmcmFnbWVudEhpbnQgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIC8vIEluY2x1ZGUgaW5jb21wbGV0ZSBmcmFnbWVudCB3aXRoIHBhcnRzIGF0IGVuZFxuICAgICAgZnJhZ21lbnRzID0gZnJhZ21lbnRzLmNvbmNhdChmcmFnbWVudEhpbnQpO1xuICAgICAgZW5kU04gPSBmcmFnbWVudEhpbnQuc24gYXMgbnVtYmVyO1xuICAgIH1cblxuICAgIGxldCBmcmFnO1xuICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgIGNvbnN0IGxvb2t1cFRvbGVyYW5jZSA9IGJ1ZmZlckVuZCA+IGVuZCAtIHRvbGVyYW5jZSA/IDAgOiB0b2xlcmFuY2U7XG4gICAgICAvLyBSZW1vdmUgdGhlIHRvbGVyYW5jZSBpZiBpdCB3b3VsZCBwdXQgdGhlIGJ1ZmZlckVuZCBwYXN0IHRoZSBhY3R1YWwgZW5kIG9mIHN0cmVhbVxuICAgICAgLy8gVXNlcyBidWZmZXIgYW5kIHNlcXVlbmNlIG51bWJlciB0byBjYWxjdWxhdGUgc3dpdGNoIHNlZ21lbnQgKHJlcXVpcmVkIGlmIHVzaW5nIEVYVC1YLURJU0NPTlRJTlVJVFktU0VRVUVOQ0UpXG4gICAgICBmcmFnID0gZmluZEZyYWdtZW50QnlQVFMoXG4gICAgICAgIGZyYWdQcmV2aW91cyxcbiAgICAgICAgZnJhZ21lbnRzLFxuICAgICAgICBidWZmZXJFbmQsXG4gICAgICAgIGxvb2t1cFRvbGVyYW5jZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBpZiAoZnJhZykge1xuICAgICAgY29uc3QgY3VyU05JZHggPSBmcmFnLnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICAvLyBNb3ZlIGZyYWdQcmV2aW91cyBmb3J3YXJkIHRvIHN1cHBvcnQgZm9yY2luZyB0aGUgbmV4dCBmcmFnbWVudCB0byBsb2FkXG4gICAgICAvLyB3aGVuIHRoZSBidWZmZXIgY2F0Y2hlcyB1cCB0byBhIHByZXZpb3VzbHkgYnVmZmVyZWQgcmFuZ2UuXG4gICAgICBjb25zdCBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICAgIGlmIChcbiAgICAgICAgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk9LIHx8XG4gICAgICAgIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCAmJiBmcmFnLmdhcClcbiAgICAgICkge1xuICAgICAgICBmcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBmcmFnUHJldmlvdXMgJiZcbiAgICAgICAgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuICYmXG4gICAgICAgICghbG9hZGluZ1BhcnRzIHx8IHBhcnRMaXN0WzBdLmZyYWdtZW50LnNuID4gZnJhZy5zbilcbiAgICAgICkge1xuICAgICAgICAvLyBGb3JjZSB0aGUgbmV4dCBmcmFnbWVudCB0byBsb2FkIGlmIHRoZSBwcmV2aW91cyBvbmUgd2FzIGFscmVhZHkgc2VsZWN0ZWQuIFRoaXMgY2FuIG9jY2FzaW9uYWxseSBoYXBwZW4gd2l0aFxuICAgICAgICAvLyBub24tdW5pZm9ybSBmcmFnbWVudCBkdXJhdGlvbnNcbiAgICAgICAgY29uc3Qgc2FtZUxldmVsID0gZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbDtcbiAgICAgICAgaWYgKHNhbWVMZXZlbCkge1xuICAgICAgICAgIGNvbnN0IG5leHRGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4ICsgMV07XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZnJhZy5zbiA8IGVuZFNOICYmXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShuZXh0RnJhZykgIT09IEZyYWdtZW50U3RhdGUuT0tcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGZyYWcgPSBuZXh0RnJhZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN5bmNocm9uaXplVG9MaXZlRWRnZShsZXZlbERldGFpbHM6IExldmVsRGV0YWlscykge1xuICAgIGNvbnN0IHsgY29uZmlnLCBtZWRpYSB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3Qgc3RhcnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgIGNvbnN0IHdpdGhpblNsaWRpbmdXaW5kb3cgPVxuICAgICAgY3VycmVudFRpbWUgPj0gc3RhcnQgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAmJlxuICAgICAgY3VycmVudFRpbWUgPD0gZW5kO1xuICAgIC8vIENvbnRpbnVlIGlmIHdlIGNhbiBzZWVrIGZvcndhcmQgdG8gc3luYyBwb3NpdGlvbiBvciBpZiBjdXJyZW50IHRpbWUgaXMgb3V0c2lkZSBvZiBzbGlkaW5nIHdpbmRvd1xuICAgIGlmIChcbiAgICAgIGxpdmVTeW5jUG9zaXRpb24gIT09IG51bGwgJiZcbiAgICAgIG1lZGlhLmR1cmF0aW9uID4gbGl2ZVN5bmNQb3NpdGlvbiAmJlxuICAgICAgKGN1cnJlbnRUaW1lIDwgbGl2ZVN5bmNQb3NpdGlvbiB8fCAhd2l0aGluU2xpZGluZ1dpbmRvdylcbiAgICApIHtcbiAgICAgIC8vIENvbnRpbnVlIGlmIGJ1ZmZlciBpcyBzdGFydmluZyBvciBpZiBjdXJyZW50IHRpbWUgaXMgYmVoaW5kIG1heCBsYXRlbmN5XG4gICAgICBjb25zdCBtYXhMYXRlbmN5ID1cbiAgICAgICAgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25cbiAgICAgICAgICA6IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICBpZiAoXG4gICAgICAgICghd2l0aGluU2xpZGluZ1dpbmRvdyAmJiBtZWRpYS5yZWFkeVN0YXRlIDwgNCkgfHxcbiAgICAgICAgY3VycmVudFRpbWUgPCBlbmQgLSBtYXhMYXRlbmN5XG4gICAgICApIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHNlZWsgaWYgcmVhZHkgYW5kIHRoZXJlIGlzIG5vdCBhIHNpZ25pZmljYW50IGZvcndhcmQgYnVmZmVyIGF2YWlsYWJsZSBmb3IgcGxheWJhY2tcbiAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgICBgUGxheWJhY2s6ICR7Y3VycmVudFRpbWUudG9GaXhlZChcbiAgICAgICAgICAgICAgM1xuICAgICAgICAgICAgKX0gaXMgbG9jYXRlZCB0b28gZmFyIGZyb20gdGhlIGVuZCBvZiBsaXZlIHNsaWRpbmcgcGxheWxpc3Q6ICR7ZW5kfSwgcmVzZXQgY3VycmVudFRpbWUgdG8gOiAke2xpdmVTeW5jUG9zaXRpb24udG9GaXhlZChcbiAgICAgICAgICAgICAgM1xuICAgICAgICAgICAgKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgYWxpZ25QbGF5bGlzdHMoXG4gICAgZGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICAgIHByZXZpb3VzRGV0YWlscz86IExldmVsRGV0YWlsc1xuICApOiBudW1iZXIge1xuICAgIGNvbnN0IHsgbGV2ZWxzLCBsZXZlbExhc3RMb2FkZWQsIGZyYWdQcmV2aW91cyB9ID0gdGhpcztcbiAgICBjb25zdCBsYXN0TGV2ZWw6IExldmVsIHwgbnVsbCA9XG4gICAgICBsZXZlbExhc3RMb2FkZWQgIT09IG51bGwgPyBsZXZlbHMhW2xldmVsTGFzdExvYWRlZF0gOiBudWxsO1xuXG4gICAgLy8gRklYTUU6IElmIG5vdCBmb3IgYHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXNgIHJlcXVpcmluZyBmcmFnUHJldmlvdXMuY2MsXG4gICAgLy8gIHRoaXMgY291bGQgYWxsIGdvIGluIGxldmVsLWhlbHBlciBtZXJnZURldGFpbHMoKVxuICAgIGNvbnN0IGxlbmd0aCA9IGRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgdGhpcy53YXJuKGBObyBmcmFnbWVudHMgaW4gbGl2ZSBwbGF5bGlzdGApO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHNsaWRpbmdTdGFydCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGNvbnN0IGZpcnN0TGV2ZWxMb2FkID0gIXByZXZpb3VzRGV0YWlscztcbiAgICBjb25zdCBhbGlnbmVkID0gZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBOdW1iZXIuaXNGaW5pdGUoc2xpZGluZ1N0YXJ0KTtcbiAgICBpZiAoZmlyc3RMZXZlbExvYWQgfHwgKCFhbGlnbmVkICYmICFzbGlkaW5nU3RhcnQpKSB7XG4gICAgICBhbGlnblN0cmVhbShmcmFnUHJldmlvdXMsIGxhc3RMZXZlbCwgZGV0YWlscyk7XG4gICAgICBjb25zdCBhbGlnbmVkU2xpZGluZ1N0YXJ0ID0gZGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgYExpdmUgcGxheWxpc3Qgc2xpZGluZzogJHthbGlnbmVkU2xpZGluZ1N0YXJ0LnRvRml4ZWQoMil9IHN0YXJ0LXNuOiAke1xuICAgICAgICAgIHByZXZpb3VzRGV0YWlscyA/IHByZXZpb3VzRGV0YWlscy5zdGFydFNOIDogJ25hJ1xuICAgICAgICB9LT4ke2RldGFpbHMuc3RhcnRTTn0gcHJldi1zbjogJHtcbiAgICAgICAgICBmcmFnUHJldmlvdXMgPyBmcmFnUHJldmlvdXMuc24gOiAnbmEnXG4gICAgICAgIH0gZnJhZ21lbnRzOiAke2xlbmd0aH1gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFsaWduZWRTbGlkaW5nU3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBzbGlkaW5nU3RhcnQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgd2FpdEZvckNkblR1bmVJbihkZXRhaWxzOiBMZXZlbERldGFpbHMpIHtcbiAgICAvLyBXYWl0IGZvciBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbiB0byBnZXQgYW4gdXBkYXRlZCBwbGF5bGlzdFxuICAgIGNvbnN0IGFkdmFuY2VQYXJ0TGltaXQgPSAzO1xuICAgIHJldHVybiAoXG4gICAgICBkZXRhaWxzLmxpdmUgJiZcbiAgICAgIGRldGFpbHMuY2FuQmxvY2tSZWxvYWQgJiZcbiAgICAgIGRldGFpbHMucGFydFRhcmdldCAmJlxuICAgICAgZGV0YWlscy50dW5lSW5Hb2FsID5cbiAgICAgICAgTWF0aC5tYXgoZGV0YWlscy5wYXJ0SG9sZEJhY2ssIGRldGFpbHMucGFydFRhcmdldCAqIGFkdmFuY2VQYXJ0TGltaXQpXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzZXRTdGFydFBvc2l0aW9uKGRldGFpbHM6IExldmVsRGV0YWlscywgc2xpZGluZzogbnVtYmVyKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA8IHNsaWRpbmcpIHtcbiAgICAgIHN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IC0xIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lID09PSAtMSkge1xuICAgICAgLy8gVXNlIFBsYXlsaXN0IEVYVC1YLVNUQVJUOlRJTUUtT0ZGU0VUIHdoZW4gc2V0XG4gICAgICAvLyBQcmlvcml0aXplIE11bHRpdmFyaWFudCBQbGF5bGlzdCBvZmZzZXQgc28gdGhhdCBtYWluLCBhdWRpbywgYW5kIHN1YnRpdGxlIHN0cmVhbS1jb250cm9sbGVyIHN0YXJ0IHRpbWVzIG1hdGNoXG4gICAgICBjb25zdCBvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0ID0gdGhpcy5zdGFydFRpbWVPZmZzZXQgIT09IG51bGw7XG4gICAgICBjb25zdCBzdGFydFRpbWVPZmZzZXQgPSBvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0XG4gICAgICAgID8gdGhpcy5zdGFydFRpbWVPZmZzZXRcbiAgICAgICAgOiBkZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgIT09IG51bGwgJiYgTnVtYmVyLmlzRmluaXRlKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHNsaWRpbmcgKyBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgc3RhcnRQb3NpdGlvbiArPSBkZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IE1hdGgubWluKFxuICAgICAgICAgIE1hdGgubWF4KHNsaWRpbmcsIHN0YXJ0UG9zaXRpb24pLFxuICAgICAgICAgIHNsaWRpbmcgKyBkZXRhaWxzLnRvdGFsZHVyYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgYFN0YXJ0IHRpbWUgb2Zmc2V0ICR7c3RhcnRUaW1lT2Zmc2V0fSBmb3VuZCBpbiAke1xuICAgICAgICAgICAgb2Zmc2V0SW5NdWx0aXZhcmlhbnRQbGF5bGlzdCA/ICdtdWx0aXZhcmlhbnQnIDogJ21lZGlhJ1xuICAgICAgICAgIH0gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRQb3NpdGlvbn1gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB9IGVsc2UgaWYgKGRldGFpbHMubGl2ZSkge1xuICAgICAgICAvLyBMZWF2ZSB0aGlzLnN0YXJ0UG9zaXRpb24gYXQgLTEsIHNvIHRoYXQgd2UgY2FuIHVzZSBgZ2V0SW5pdGlhbExpdmVGcmFnbWVudGAgbG9naWMgd2hlbiBzdGFydFBvc2l0aW9uIGhhc1xuICAgICAgICAvLyBub3QgYmVlbiBzcGVjaWZpZWQgdmlhIHRoZSBjb25maWcgb3IgYW4gYXMgYW4gYXJndW1lbnQgdG8gc3RhcnRMb2FkICgjMzczNikuXG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uIHx8IHNsaWRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRMb2FkUG9zaXRpb24oKTogbnVtYmVyIHtcbiAgICBjb25zdCB7IG1lZGlhIH0gPSB0aGlzO1xuICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICBsZXQgcG9zID0gMDtcbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBtZWRpYSkge1xuICAgICAgcG9zID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5leHRMb2FkUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVGcmFnTG9hZEFib3J0ZWQoZnJhZzogRnJhZ21lbnQsIHBhcnQ6IFBhcnQgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy50cmFuc211eGVyICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcgJiYgZnJhZy5zdGF0cy5hYm9ydGVkKSB7XG4gICAgICB0aGlzLndhcm4oXG4gICAgICAgIGBGcmFnbWVudCAke2ZyYWcuc259JHtwYXJ0ID8gJyBwYXJ0ICcgKyBwYXJ0LmluZGV4IDogJyd9IG9mIGxldmVsICR7XG4gICAgICAgICAgZnJhZy5sZXZlbFxuICAgICAgICB9IHdhcyBhYm9ydGVkYFxuICAgICAgKTtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWc6IEZyYWdtZW50KSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuZnJhZ0N1cnJlbnQgfHxcbiAgICAgICghdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkpXG4gICAgKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25GcmFnbWVudE9yS2V5TG9hZEVycm9yKFxuICAgIGZpbHRlclR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlLFxuICAgIGRhdGE6IEVycm9yRGF0YVxuICApIHtcbiAgICBpZiAoZGF0YS5jaHVua01ldGEgJiYgIWRhdGEuZnJhZykge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoZGF0YS5jaHVua01ldGEpO1xuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgZGF0YS5mcmFnID0gY29udGV4dC5mcmFnO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIC8vIEhhbmRsZSBmcmFnIGVycm9yIHJlbGF0ZWQgdG8gY2FsbGVyJ3MgZmlsdGVyVHlwZVxuICAgIGlmICghZnJhZyB8fCBmcmFnLnR5cGUgIT09IGZpbHRlclR5cGUgfHwgIXRoaXMubGV2ZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgdGhpcy53YXJuKFxuICAgICAgICBgRnJhZyBsb2FkIGVycm9yIG11c3QgbWF0Y2ggY3VycmVudCBmcmFnIHRvIHJldHJ5ICR7ZnJhZy51cmx9ID4gJHt0aGlzLmZyYWdDdXJyZW50Py51cmx9YFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ2FwVGFnRW5jb3VudGVyZWQgPSBkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX0dBUDtcbiAgICBpZiAoZ2FwVGFnRW5jb3VudGVyZWQpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnLCB0cnVlKTtcbiAgICB9XG4gICAgLy8ga2VlcCByZXRyeWluZyB1bnRpbCB0aGUgbGltaXQgd2lsbCBiZSByZWFjaGVkXG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSBkYXRhLmVycm9yQWN0aW9uO1xuICAgIGNvbnN0IHsgYWN0aW9uLCByZXRyeUNvdW50ID0gMCwgcmV0cnlDb25maWcgfSA9IGVycm9yQWN0aW9uIHx8IHt9O1xuICAgIGlmIChcbiAgICAgIGVycm9yQWN0aW9uICYmXG4gICAgICBhY3Rpb24gPT09IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QgJiZcbiAgICAgIHJldHJ5Q29uZmlnXG4gICAgKSB7XG4gICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVsYXkgPSBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50KTtcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgJHtmaWx0ZXJUeXBlfSAke2ZyYWcubGV2ZWx9IGVycm9yZWQgd2l0aCAke1xuICAgICAgICAgIGRhdGEuZGV0YWlsc1xuICAgICAgICB9LCByZXRyeWluZyBsb2FkaW5nICR7cmV0cnlDb3VudCArIDF9LyR7XG4gICAgICAgICAgcmV0cnlDb25maWcubWF4TnVtUmV0cnlcbiAgICAgICAgfSBpbiAke2RlbGF5fW1zYFxuICAgICAgKTtcbiAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmV0cnlEYXRlID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5O1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgIH0gZWxzZSBpZiAocmV0cnlDb25maWcgJiYgZXJyb3JBY3Rpb24pIHtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudEVycm9ycyhmaWx0ZXJUeXBlKTtcbiAgICAgIGlmIChyZXRyeUNvdW50IDwgcmV0cnlDb25maWcubWF4TnVtUmV0cnkpIHtcbiAgICAgICAgLy8gTmV0d29yayByZXRyeSBpcyBza2lwcGVkIHdoZW4gbGV2ZWwgc3dpdGNoIGlzIHByZWZlcnJlZFxuICAgICAgICBpZiAoIWdhcFRhZ0VuY291bnRlcmVkKSB7XG4gICAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICBgJHtkYXRhLmRldGFpbHN9IHJlYWNoZWQgb3IgZXhjZWVkZWQgbWF4IHJldHJ5ICgke3JldHJ5Q291bnR9KWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgIH1cbiAgICAvLyBQZXJmb3JtIG5leHQgYXN5bmMgdGljayBzb29uZXIgdG8gc3BlZWQgdXAgZXJyb3IgYWN0aW9uIHJlc29sdXRpb25cbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZWR1Y2VMZW5ndGhBbmRGbHVzaEJ1ZmZlcihkYXRhOiBFcnJvckRhdGEpOiBib29sZWFuIHtcbiAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9IGRhdGEucGFyZW50IGFzIFBsYXlsaXN0TGV2ZWxUeXBlO1xuICAgICAgY29uc3QgYnVmZmVyZWRJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKFxuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyLFxuICAgICAgICBwbGF5bGlzdFR5cGVcbiAgICAgICk7XG4gICAgICAvLyAwLjUgOiB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCBlbmRcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG4gICAgICBjb25zdCBidWZmZXJlZCA9IGJ1ZmZlcmVkSW5mbyAmJiBidWZmZXJlZEluZm8ubGVuID4gMC41O1xuICAgICAgaWYgKGJ1ZmZlcmVkKSB7XG4gICAgICAgIHRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGJ1ZmZlcmVkSW5mby5sZW4pO1xuICAgICAgfVxuICAgICAgY29uc3QgZmx1c2hCdWZmZXIgPSAhYnVmZmVyZWQ7XG4gICAgICBpZiAoZmx1c2hCdWZmZXIpIHtcbiAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGF1ZGlvIGJ1ZmZlciB0byByZWNvdmVyXG4gICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICBgQnVmZmVyIGZ1bGwgZXJyb3Igd2hpbGUgbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCAke3BsYXlsaXN0VHlwZX0gYnVmZmVyYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuZnJhZykge1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChkYXRhLmZyYWcpO1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBkYXRhLmZyYWcuc3RhcnQ7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICByZXR1cm4gZmx1c2hCdWZmZXI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZXNldEZyYWdtZW50RXJyb3JzKGZpbHRlclR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlKSB7XG4gICAgaWYgKGZpbHRlclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKSB7XG4gICAgICAvLyBSZXNldCBjdXJyZW50IGZyYWdtZW50IHNpbmNlIGF1ZGlvIHRyYWNrIGF1ZGlvIGlzIGVzc2VudGlhbCBhbmQgbWF5IG5vdCBoYXZlIGEgZmFpbC1vdmVyIHRyYWNrXG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gRnJhZ21lbnQgZXJyb3JzIHRoYXQgcmVzdWx0IGluIGEgbGV2ZWwgc3dpdGNoIG9yIHJlZHVuZGFudCBmYWlsLW92ZXJcbiAgICAvLyBzaG91bGQgcmVzZXQgdGhlIHN0cmVhbSBjb250cm9sbGVyIHN0YXRlIHRvIGlkbGVcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgYWZ0ZXJCdWZmZXJGbHVzaGVkKFxuICAgIG1lZGlhOiBCdWZmZXJhYmxlLFxuICAgIGJ1ZmZlclR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUsXG4gICAgcGxheWxpc3RUeXBlOiBQbGF5bGlzdExldmVsVHlwZVxuICApIHtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCBmaWx0ZXIgZmx1c2hlZCBmcmFnbWVudHMgZnJvbSBidWZmZXJlZEZyYWdzIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWFcbiAgICAvLyAoc28gdGhhdCB3ZSB3aWxsIGNoZWNrIGFnYWluc3QgdmlkZW8uYnVmZmVyZWQgcmFuZ2VzIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIHRyYWNrKVxuICAgIGNvbnN0IGJ1ZmZlcmVkVGltZVJhbmdlcyA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhcbiAgICAgIGJ1ZmZlclR5cGUsXG4gICAgICBidWZmZXJlZFRpbWVSYW5nZXMsXG4gICAgICBwbGF5bGlzdFR5cGVcbiAgICApO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCByZXNldExvYWRpbmdTdGF0ZSgpIHtcbiAgICB0aGlzLmxvZygnUmVzZXQgbG9hZGluZyBzdGF0ZScpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZXNldFN0YXJ0V2hlbk5vdExvYWRlZChsZXZlbDogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCBmaXJzdCBmcmFnIHJlcXVlc3QgZmFpbGVkXG4gICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzW2xldmVsXS5kZXRhaWxzIDogbnVsbDtcbiAgICAgIGlmIChkZXRhaWxzPy5saXZlKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhcnQgcG9zaXRpb24gYW5kIHJldHVybiB0byBJRExFIHRvIHJlY292ZXIgbGl2ZSBzdGFydFxuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKGRldGFpbHMsIDApO1xuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YSkge1xuICAgIHRoaXMud2FybihcbiAgICAgIGBUaGUgbG9hZGluZyBjb250ZXh0IGNoYW5nZWQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50ICR7Y2h1bmtNZXRhLnNufSBvZiBsZXZlbCAke2NodW5rTWV0YS5sZXZlbH0uIFRoaXMgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuYFxuICAgICk7XG4gICAgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MoKTtcbiAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKGNodW5rTWV0YS5sZXZlbCk7XG4gICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlbW92ZVVuYnVmZmVyZWRGcmFncyhzdGFydDogbnVtYmVyID0gMCkge1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2UoXG4gICAgICBzdGFydCxcbiAgICAgIEluZmluaXR5LFxuICAgICAgdGhpcy5wbGF5bGlzdFR5cGUsXG4gICAgICBmYWxzZSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVMZXZlbFRpbWluZyhcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBwYXJ0OiBQYXJ0IHwgbnVsbCxcbiAgICBsZXZlbDogTGV2ZWwsXG4gICAgcGFydGlhbDogYm9vbGVhblxuICApIHtcbiAgICBjb25zdCBkZXRhaWxzID0gbGV2ZWwuZGV0YWlscyBhcyBMZXZlbERldGFpbHM7XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICB0aGlzLndhcm4oJ2xldmVsLmRldGFpbHMgdW5kZWZpbmVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZCA9IE9iamVjdC5rZXlzKGZyYWcuZWxlbWVudGFyeVN0cmVhbXMpLnJlZHVjZShcbiAgICAgIChyZXN1bHQsIHR5cGUpID0+IHtcbiAgICAgICAgY29uc3QgaW5mbyA9IGZyYWcuZWxlbWVudGFyeVN0cmVhbXNbdHlwZV07XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkRHVyYXRpb24gPSBpbmZvLmVuZFBUUyAtIGluZm8uc3RhcnRQVFM7XG4gICAgICAgICAgaWYgKHBhcnNlZER1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIHRyYW5zbXV4ZXIgYWZ0ZXIgaXQncyBuZXh0IHRpbWUgb2Zmc2V0IGZhaWxlZCB0byBhZHZhbmNlIGJlY2F1c2UgZHVyYXRpb24gd2FzIDw9IDAuXG4gICAgICAgICAgICAvLyBUaGUgbmV3IHRyYW5zbXV4ZXIgd2lsbCBiZSBjb25maWd1cmVkIHdpdGggYSB0aW1lIG9mZnNldCBtYXRjaGluZyB0aGUgbmV4dCBmcmFnbWVudCBzdGFydCxcbiAgICAgICAgICAgIC8vIHByZXZlbnRpbmcgdGhlIHRpbWVsaW5lIGZyb20gc2hpZnRpbmcuXG4gICAgICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgICAgIGBDb3VsZCBub3QgcGFyc2UgZnJhZ21lbnQgJHtmcmFnLnNufSAke3R5cGV9IGR1cmF0aW9uIHJlbGlhYmx5ICgke3BhcnNlZER1cmF0aW9ufSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZHJpZnQgPSBwYXJ0aWFsXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogdXBkYXRlRnJhZ1BUU0RUUyhcbiAgICAgICAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgaW5mby5zdGFydFBUUyxcbiAgICAgICAgICAgICAgICBpbmZvLmVuZFBUUyxcbiAgICAgICAgICAgICAgICBpbmZvLnN0YXJ0RFRTLFxuICAgICAgICAgICAgICAgIGluZm8uZW5kRFRTXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfUFRTX1VQREFURUQsIHtcbiAgICAgICAgICAgIGRldGFpbHMsXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIGRyaWZ0LFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBzdGFydDogaW5mby5zdGFydFBUUyxcbiAgICAgICAgICAgIGVuZDogaW5mby5lbmRQVFMsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zbXV4ZXI/LmVycm9yID09PSBudWxsKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgYEZvdW5kIG5vIG1lZGlhIGluIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtsZXZlbC5pZH0gcmVzZXR0aW5nIHRyYW5zbXV4ZXIgdG8gZmFsbGJhY2sgdG8gcGxheWxpc3QgdGltaW5nYFxuICAgICAgKTtcbiAgICAgIHRoaXMud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIHJlYXNvbjogYEZvdW5kIG5vIG1lZGlhIGluIG1zbiAke2ZyYWcuc259IG9mIGxldmVsIFwiJHtsZXZlbC51cmx9XCJgLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICAvLyBGb3IgdGhpcyBlcnJvciBmYWxsdGhyb3VnaC4gTWFya2luZyBwYXJzZWQgd2lsbCBhbGxvdyBhZHZhbmNpbmcgdG8gbmV4dCBmcmFnbWVudC5cbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNFRCwgeyBmcmFnLCBwYXJ0IH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlc2V0VHJhbnNtdXhlcigpIHtcbiAgICBpZiAodGhpcy50cmFuc211eGVyKSB7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVjb3ZlcldvcmtlckVycm9yKGRhdGE6IEVycm9yRGF0YSkge1xuICAgIGlmIChkYXRhLmV2ZW50ID09PSAnZGVtdXhlcldvcmtlcicpIHtcbiAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgc2V0IHN0YXRlKG5leHRTdGF0ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIHRoaXMubG9nKGAke3ByZXZpb3VzU3RhdGV9LT4ke25leHRTdGF0ZX1gKTtcbiAgICB9XG4gIH1cblxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG59XG4iLCJpbXBvcnQgeyBnZXRNZWRpYVNvdXJjZSB9IGZyb20gJy4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyJztcbmltcG9ydCB0eXBlIHsgRXh0ZW5kZWRTb3VyY2VCdWZmZXIgfSBmcm9tICcuL3R5cGVzL2J1ZmZlcic7XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUJ1ZmZlcigpOiB0eXBlb2Ygc2VsZi5Tb3VyY2VCdWZmZXIge1xuICByZXR1cm4gc2VsZi5Tb3VyY2VCdWZmZXIgfHwgKHNlbGYgYXMgYW55KS5XZWJLaXRTb3VyY2VCdWZmZXI7XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gIGNvbnN0IG1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcbiAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzb3VyY2VCdWZmZXIgPSBnZXRTb3VyY2VCdWZmZXIoKTtcbiAgY29uc3QgaXNUeXBlU3VwcG9ydGVkID1cbiAgICBtZWRpYVNvdXJjZSAmJlxuICAgIHR5cGVvZiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQgPT09ICdmdW5jdGlvbicgJiZcbiAgICBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUUsbXA0YS40MC4yXCInKTtcblxuICAvLyBpZiBTb3VyY2VCdWZmZXIgaXMgZXhwb3NlZCBlbnN1cmUgaXRzIEFQSSBpcyB2YWxpZFxuICAvLyBPbGRlciBicm93c2VycyBkbyBub3QgZXhwb3NlIFNvdXJjZUJ1ZmZlciBnbG9iYWxseSBzbyBjaGVja2luZyBTb3VyY2VCdWZmZXIucHJvdG90eXBlIGlzIGltcG9zc2libGVcbiAgY29uc3Qgc291cmNlQnVmZmVyVmFsaWRBUEkgPVxuICAgICFzb3VyY2VCdWZmZXIgfHxcbiAgICAoc291cmNlQnVmZmVyLnByb3RvdHlwZSAmJlxuICAgICAgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUuYXBwZW5kQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5yZW1vdmUgPT09ICdmdW5jdGlvbicpO1xuICByZXR1cm4gISFpc1R5cGVTdXBwb3J0ZWQgJiYgISFzb3VyY2VCdWZmZXJWYWxpZEFQSTtcbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VUeXBlU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xuICBjb25zdCBzb3VyY2VCdWZmZXIgPSBnZXRTb3VyY2VCdWZmZXIoKTtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgKHNvdXJjZUJ1ZmZlcj8ucHJvdG90eXBlIGFzIEV4dGVuZGVkU291cmNlQnVmZmVyKT8uY2hhbmdlVHlwZSA9PT1cbiAgICAnZnVuY3Rpb24nXG4gICk7XG59XG4iLCJpbXBvcnQgdHlwZSB7IERlbXV4ZWRUcmFjayB9IGZyb20gJy4uL3R5cGVzL2RlbXV4ZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gZHVtbXlUcmFjayh0eXBlID0gJycsIGlucHV0VGltZVNjYWxlID0gOTAwMDApOiBEZW11eGVkVHJhY2sge1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgaWQ6IC0xLFxuICAgIHBpZDogLTEsXG4gICAgaW5wdXRUaW1lU2NhbGUsXG4gICAgc2VxdWVuY2VOdW1iZXI6IC0xLFxuICAgIHNhbXBsZXM6IFtdLFxuICAgIGRyb3BwZWQ6IDAsXG4gIH07XG59XG4iLCJpbXBvcnQgKiBhcyBJRDMgZnJvbSAnLi4vZGVtdXgvaWQzJztcbmltcG9ydCB7XG4gIERlbXV4ZXJSZXN1bHQsXG4gIERlbXV4ZXIsXG4gIERlbXV4ZWRBdWRpb1RyYWNrLFxuICBBdWRpb0ZyYW1lLFxuICBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgRGVtdXhlZFZpZGVvVHJhY2ssXG4gIERlbXV4ZWRVc2VyZGF0YVRyYWNrLFxuICBLZXlEYXRhLFxuICBNZXRhZGF0YVNjaGVtYSxcbn0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5pbXBvcnQgeyBkdW1teVRyYWNrIH0gZnJvbSAnLi9kdW1teS1kZW11eGVkLXRyYWNrJztcbmltcG9ydCB7IGFwcGVuZFVpbnQ4QXJyYXkgfSBmcm9tICcuLi91dGlscy9tcDQtdG9vbHMnO1xuaW1wb3J0IHsgc2xpY2VVaW50OCB9IGZyb20gJy4uL3V0aWxzL3R5cGVkLWFycmF5JztcbmltcG9ydCB7IFJhdGlvbmFsVGltZXN0YW1wIH0gZnJvbSAnLi4vdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24nO1xuXG5jbGFzcyBCYXNlQXVkaW9EZW11eGVyIGltcGxlbWVudHMgRGVtdXhlciB7XG4gIHByb3RlY3RlZCBfYXVkaW9UcmFjayE6IERlbXV4ZWRBdWRpb1RyYWNrO1xuICBwcm90ZWN0ZWQgX2lkM1RyYWNrITogRGVtdXhlZE1ldGFkYXRhVHJhY2s7XG4gIHByb3RlY3RlZCBmcmFtZUluZGV4OiBudW1iZXIgPSAwO1xuICBwcm90ZWN0ZWQgY2FjaGVkRGF0YTogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgYmFzZVBUUzogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBpbml0UFRTOiBSYXRpb25hbFRpbWVzdGFtcCB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgbGFzdFBUUzogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgcmVzZXRJbml0U2VnbWVudChcbiAgICBpbml0U2VnbWVudDogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgICBhdWRpb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdmlkZW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHRyYWNrRHVyYXRpb246IG51bWJlclxuICApIHtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHtcbiAgICAgIHR5cGU6ICdpZDMnLFxuICAgICAgaWQ6IDMsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIGRyb3BwZWQ6IDAsXG4gICAgfTtcbiAgfVxuXG4gIHJlc2V0VGltZVN0YW1wKGRlYXVsdFRpbWVzdGFtcDogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsKSB7XG4gICAgdGhpcy5pbml0UFRTID0gZGVhdWx0VGltZXN0YW1wO1xuICAgIHRoaXMucmVzZXRDb250aWd1aXR5KCk7XG4gIH1cblxuICByZXNldENvbnRpZ3VpdHkoKTogdm9pZCB7XG4gICAgdGhpcy5iYXNlUFRTID0gbnVsbDtcbiAgICB0aGlzLmxhc3RQVFMgPSBudWxsO1xuICAgIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gIH1cblxuICBjYW5QYXJzZShkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGFwcGVuZEZyYW1lKFxuICAgIHRyYWNrOiBEZW11eGVkQXVkaW9UcmFjayxcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIG9mZnNldDogbnVtYmVyXG4gICk6IEF1ZGlvRnJhbWUgfCB2b2lkIHt9XG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBkZW11eChkYXRhOiBVaW50OEFycmF5LCB0aW1lT2Zmc2V0OiBudW1iZXIpOiBEZW11eGVyUmVzdWx0IHtcbiAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheSh0aGlzLmNhY2hlZERhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgaWQzRGF0YTogVWludDhBcnJheSB8IHVuZGVmaW5lZCA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApO1xuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhID8gaWQzRGF0YS5sZW5ndGggOiAwO1xuICAgIGxldCBsYXN0RGF0YUluZGV4O1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjaztcbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IGlkM0RhdGEgPyBJRDMuZ2V0VGltZVN0YW1wKGlkM0RhdGEpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5iYXNlUFRTID09PSBudWxsIHx8XG4gICAgICAodGhpcy5mcmFtZUluZGV4ID09PSAwICYmIE51bWJlci5pc0Zpbml0ZSh0aW1lc3RhbXApKVxuICAgICkge1xuICAgICAgdGhpcy5iYXNlUFRTID0gaW5pdFBUU0ZuKHRpbWVzdGFtcCwgdGltZU9mZnNldCwgdGhpcy5pbml0UFRTKTtcbiAgICAgIHRoaXMubGFzdFBUUyA9IHRoaXMuYmFzZVBUUztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sYXN0UFRTID09PSBudWxsKSB7XG4gICAgICB0aGlzLmxhc3RQVFMgPSB0aGlzLmJhc2VQVFM7XG4gICAgfVxuXG4gICAgLy8gbW9yZSBleHByZXNzaXZlIHRoYW4gYWx0ZXJuYXRpdmU6IGlkM0RhdGE/Lmxlbmd0aFxuICAgIGlmIChpZDNEYXRhICYmIGlkM0RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgcHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgIGR0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICBkYXRhOiBpZDNEYXRhLFxuICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyxcbiAgICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLmNhblBhcnNlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSB0aGlzLmFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpO1xuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICB0aGlzLmZyYW1lSW5kZXgrKztcbiAgICAgICAgICB0aGlzLmxhc3RQVFMgPSBmcmFtZS5zYW1wbGUucHRzO1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgbGFzdERhdGFJbmRleCA9IG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoSUQzLmNhblBhcnNlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgLy8gYWZ0ZXIgYSBJRDMuY2FuUGFyc2UsIGEgY2FsbCB0byBJRDMuZ2V0SUQzRGF0YSAqc2hvdWxkKiBhbHdheXMgcmV0dXJucyBzb21lIGRhdGFcbiAgICAgICAgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIG9mZnNldCkhO1xuICAgICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgIHB0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICAgIGR0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICAgIGRhdGE6IGlkM0RhdGEsXG4gICAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcbiAgICAgICAgbGFzdERhdGFJbmRleCA9IG9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoICYmIGxhc3REYXRhSW5kZXggIT09IGxlbmd0aCkge1xuICAgICAgICBjb25zdCBwYXJ0aWFsRGF0YSA9IHNsaWNlVWludDgoZGF0YSwgbGFzdERhdGFJbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZERhdGEpIHtcbiAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBhcHBlbmRVaW50OEFycmF5KHRoaXMuY2FjaGVkRGF0YSwgcGFydGlhbERhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IHBhcnRpYWxEYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRyYWNrLFxuICAgICAgdmlkZW9UcmFjazogZHVtbXlUcmFjaygpIGFzIERlbXV4ZWRWaWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKSBhcyBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICB9O1xuICB9XG5cbiAgZGVtdXhTYW1wbGVBZXMoXG4gICAgZGF0YTogVWludDhBcnJheSxcbiAgICBrZXlEYXRhOiBLZXlEYXRhLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlclxuICApOiBQcm9taXNlPERlbXV4ZXJSZXN1bHQ+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICBuZXcgRXJyb3IoYFske3RoaXN9XSBUaGlzIGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTYW1wbGUtQUVTIGRlY3J5cHRpb25gKVxuICAgICk7XG4gIH1cblxuICBmbHVzaCh0aW1lT2Zmc2V0OiBudW1iZXIpOiBEZW11eGVyUmVzdWx0IHtcbiAgICAvLyBQYXJzZSBjYWNoZSBpbiBjYXNlIG9mIHJlbWFpbmluZyBmcmFtZXMuXG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IHRoaXMuY2FjaGVkRGF0YTtcbiAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICAgIHRoaXMuZGVtdXgoY2FjaGVkRGF0YSwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrOiBkdW1teVRyYWNrKCkgYXMgRGVtdXhlZFZpZGVvVHJhY2ssXG4gICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKSBhcyBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICB9O1xuICB9XG5cbiAgZGVzdHJveSgpIHt9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBQVFNcbiAqIDxwPlxuICogICAgdXNlIHRpbWVzdGFtcCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBOYU4gb3IgSW5maW5pdHlcbiAqIDwvcD5cbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRQVFNGbiA9IChcbiAgdGltZXN0YW1wOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgaW5pdFBUUzogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsXG4pOiBudW1iZXIgPT4ge1xuICBpZiAoTnVtYmVyLmlzRmluaXRlKHRpbWVzdGFtcCBhcyBudW1iZXIpKSB7XG4gICAgcmV0dXJuIHRpbWVzdGFtcCEgKiA5MDtcbiAgfVxuICBjb25zdCBpbml0OTBrSHogPSBpbml0UFRTXG4gICAgPyAoaW5pdFBUUy5iYXNlVGltZSAqIDkwMDAwKSAvIGluaXRQVFMudGltZXNjYWxlXG4gICAgOiAwO1xuICByZXR1cm4gdGltZU9mZnNldCAqIDkwMDAwICsgaW5pdDkwa0h6O1xufTtcbmV4cG9ydCBkZWZhdWx0IEJhc2VBdWRpb0RlbXV4ZXI7XG4iLCIvKipcbiAqIEFEVFMgcGFyc2VyIGhlbHBlclxuICogQGxpbmsgaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAqL1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgdHlwZSB7IEhsc0V2ZW50RW1pdHRlciB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUge1xuICBEZW11eGVkQXVkaW9UcmFjayxcbiAgQXVkaW9GcmFtZSxcbiAgQXVkaW9TYW1wbGUsXG59IGZyb20gJy4uL3R5cGVzL2RlbXV4ZXInO1xuXG50eXBlIEF1ZGlvQ29uZmlnID0ge1xuICBjb25maWc6IG51bWJlcltdO1xuICBzYW1wbGVyYXRlOiBudW1iZXI7XG4gIGNoYW5uZWxDb3VudDogbnVtYmVyO1xuICBjb2RlYzogc3RyaW5nO1xuICBtYW5pZmVzdENvZGVjOiBzdHJpbmc7XG59O1xuXG50eXBlIEZyYW1lSGVhZGVyID0ge1xuICBoZWFkZXJMZW5ndGg6IG51bWJlcjtcbiAgZnJhbWVMZW5ndGg6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdWRpb0NvbmZpZyhcbiAgb2JzZXJ2ZXIsXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4gIG9mZnNldDogbnVtYmVyLFxuICBhdWRpb0NvZGVjOiBzdHJpbmdcbik6IEF1ZGlvQ29uZmlnIHwgdm9pZCB7XG4gIGxldCBhZHRzT2JqZWN0VHlwZTogbnVtYmVyO1xuICBsZXQgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXg6IG51bWJlcjtcbiAgbGV0IGFkdHNDaGFubmVsQ29uZmlnOiBudW1iZXI7XG4gIGxldCBjb25maWc6IG51bWJlcltdO1xuICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IG1hbmlmZXN0Q29kZWMgPSBhdWRpb0NvZGVjO1xuICBjb25zdCBhZHRzU2FtcGxpbmdSYXRlcyA9IFtcbiAgICA5NjAwMCwgODgyMDAsIDY0MDAwLCA0ODAwMCwgNDQxMDAsIDMyMDAwLCAyNDAwMCwgMjIwNTAsIDE2MDAwLCAxMjAwMCwgMTEwMjUsXG4gICAgODAwMCwgNzM1MCxcbiAgXTtcbiAgLy8gYnl0ZSAyXG4gIGFkdHNPYmplY3RUeXBlID0gKChkYXRhW29mZnNldCArIDJdICYgMHhjMCkgPj4+IDYpICsgMTtcbiAgY29uc3QgYWR0c1NhbXBsaW5nSW5kZXggPSAoZGF0YVtvZmZzZXQgKyAyXSAmIDB4M2MpID4+PiAyO1xuICBpZiAoYWR0c1NhbXBsaW5nSW5kZXggPiBhZHRzU2FtcGxpbmdSYXRlcy5sZW5ndGggLSAxKSB7XG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6IHRydWUsXG4gICAgICByZWFzb246IGBpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6JHthZHRzU2FtcGxpbmdJbmRleH1gLFxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBhZHRzQ2hhbm5lbENvbmZpZyA9IChkYXRhW29mZnNldCArIDJdICYgMHgwMSkgPDwgMjtcbiAgLy8gYnl0ZSAzXG4gIGFkdHNDaGFubmVsQ29uZmlnIHw9IChkYXRhW29mZnNldCArIDNdICYgMHhjMCkgPj4+IDY7XG4gIGxvZ2dlci5sb2coXG4gICAgYG1hbmlmZXN0IGNvZGVjOiR7YXVkaW9Db2RlY30sIEFEVFMgdHlwZToke2FkdHNPYmplY3RUeXBlfSwgc2FtcGxpbmdJbmRleDoke2FkdHNTYW1wbGluZ0luZGV4fWBcbiAgKTtcbiAgLy8gZmlyZWZveDogZnJlcSBsZXNzIHRoYW4gMjRrSHogPSBBQUMgU0JSIChIRS1BQUMpXG4gIGlmICgvZmlyZWZveC9pLnRlc3QodXNlckFnZW50KSkge1xuICAgIGlmIChhZHRzU2FtcGxpbmdJbmRleCA+PSA2KSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleCAtIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXg7XG4gICAgfVxuICAgIC8vIEFuZHJvaWQgOiBhbHdheXMgdXNlIEFBQ1xuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xKSB7XG4gICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICB9IGVsc2Uge1xuICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcbiAgICAqL1xuICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEhFLUFBQyBvciBIRS1BQUN2MikgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgQU5EIGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHopXG4gICAgaWYgKFxuICAgICAgKGF1ZGlvQ29kZWMgJiZcbiAgICAgICAgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSB8fFxuICAgICAgICAgIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSkgfHxcbiAgICAgICghYXVkaW9Db2RlYyAmJiBhZHRzU2FtcGxpbmdJbmRleCA+PSA2KVxuICAgICkge1xuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXggLSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAvLyBDaHJvbWUgZmFpbHMgdG8gcGxheSBiYWNrIHdpdGggbG93IGZyZXF1ZW5jeSBBQUMgTEMgbW9ubyB3aGVuIGluaXRpYWxpemVkIHdpdGggSEUtQUFDLiAgVGhpcyBpcyBub3QgYSBwcm9ibGVtIHdpdGggc3RlcmVvLlxuICAgICAgaWYgKFxuICAgICAgICAoYXVkaW9Db2RlYyAmJlxuICAgICAgICAgIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xICYmXG4gICAgICAgICAgKChhZHRzU2FtcGxpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFubmVsQ29uZmlnID09PSAxKSB8fFxuICAgICAgICAgICAgL3ZpdmFsZGkvaS50ZXN0KHVzZXJBZ2VudCkpKSB8fFxuICAgICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c0NoYW5uZWxDb25maWcgPT09IDEpXG4gICAgICApIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICB9XG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICAgIH1cbiAgfVxuICAvKiByZWZlciB0byBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1NUEVHLTRfQXVkaW8jQXVkaW9fU3BlY2lmaWNfQ29uZmlnXG4gICAgICBJU08gMTQ0OTYtMyAoQUFDKS5wZGYgLSBUYWJsZSAxLjEzIOKAlCBTeW50YXggb2YgQXVkaW9TcGVjaWZpY0NvbmZpZygpXG4gICAgQXVkaW8gUHJvZmlsZSAvIEF1ZGlvIE9iamVjdCBUeXBlXG4gICAgMDogTnVsbFxuICAgIDE6IEFBQyBNYWluXG4gICAgMjogQUFDIExDIChMb3cgQ29tcGxleGl0eSlcbiAgICAzOiBBQUMgU1NSIChTY2FsYWJsZSBTYW1wbGUgUmF0ZSlcbiAgICA0OiBBQUMgTFRQIChMb25nIFRlcm0gUHJlZGljdGlvbilcbiAgICA1OiBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pXG4gICAgNjogQUFDIFNjYWxhYmxlXG4gICBzYW1wbGluZyBmcmVxXG4gICAgMDogOTYwMDAgSHpcbiAgICAxOiA4ODIwMCBIelxuICAgIDI6IDY0MDAwIEh6XG4gICAgMzogNDgwMDAgSHpcbiAgICA0OiA0NDEwMCBIelxuICAgIDU6IDMyMDAwIEh6XG4gICAgNjogMjQwMDAgSHpcbiAgICA3OiAyMjA1MCBIelxuICAgIDg6IDE2MDAwIEh6XG4gICAgOTogMTIwMDAgSHpcbiAgICAxMDogMTEwMjUgSHpcbiAgICAxMTogODAwMCBIelxuICAgIDEyOiA3MzUwIEh6XG4gICAgMTM6IFJlc2VydmVkXG4gICAgMTQ6IFJlc2VydmVkXG4gICAgMTU6IGZyZXF1ZW5jeSBpcyB3cml0dGVuIGV4cGxpY3RseVxuICAgIENoYW5uZWwgQ29uZmlndXJhdGlvbnNcbiAgICBUaGVzZSBhcmUgdGhlIGNoYW5uZWwgY29uZmlndXJhdGlvbnM6XG4gICAgMDogRGVmaW5lZCBpbiBBT1QgU3BlY2lmYyBDb25maWdcbiAgICAxOiAxIGNoYW5uZWw6IGZyb250LWNlbnRlclxuICAgIDI6IDIgY2hhbm5lbHM6IGZyb250LWxlZnQsIGZyb250LXJpZ2h0XG4gICovXG4gIC8vIGF1ZGlvT2JqZWN0VHlwZSA9IHByb2ZpbGUgPT4gcHJvZmlsZSwgdGhlIE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZSBtaW51cyAxXG4gIGNvbmZpZ1swXSA9IGFkdHNPYmplY3RUeXBlIDw8IDM7XG4gIC8vIHNhbXBsaW5nRnJlcXVlbmN5SW5kZXhcbiAgY29uZmlnWzBdIHw9IChhZHRzU2FtcGxpbmdJbmRleCAmIDB4MGUpID4+IDE7XG4gIGNvbmZpZ1sxXSB8PSAoYWR0c1NhbXBsaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAvLyBjaGFubmVsQ29uZmlndXJhdGlvblxuICBjb25maWdbMV0gfD0gYWR0c0NoYW5uZWxDb25maWcgPDwgMztcbiAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1KSB7XG4gICAgLy8gYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXhcbiAgICBjb25maWdbMV0gfD0gKGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ICYgMHgwZSkgPj4gMTtcbiAgICBjb25maWdbMl0gPSAoYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgIC8vIGFkdHNPYmplY3RUeXBlIChmb3JjZSB0byAyLCBjaHJvbWUgaXMgY2hlY2tpbmcgdGhhdCBvYmplY3QgdHlwZSBpcyBsZXNzIHRoYW4gNSA/Pz9cbiAgICAvLyAgICBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLmdpdC8rL21hc3Rlci9tZWRpYS9mb3JtYXRzL21wNC9hYWMuY2NcbiAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgIGNvbmZpZ1szXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb25maWcsXG4gICAgc2FtcGxlcmF0ZTogYWR0c1NhbXBsaW5nUmF0ZXNbYWR0c1NhbXBsaW5nSW5kZXhdLFxuICAgIGNoYW5uZWxDb3VudDogYWR0c0NoYW5uZWxDb25maWcsXG4gICAgY29kZWM6ICdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZSxcbiAgICBtYW5pZmVzdENvZGVjLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGY2KSA9PT0gMHhmMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhlYWRlckxlbmd0aChkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBkYXRhW29mZnNldCArIDFdICYgMHgwMSA/IDcgOiA5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIChcbiAgICAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSkgfFxuICAgIChkYXRhW29mZnNldCArIDRdIDw8IDMpIHxcbiAgICAoKGRhdGFbb2Zmc2V0ICsgNV0gJiAweGUwKSA+Pj4gNSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbkdldEZyYW1lTGVuZ3RoKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiBvZmZzZXQgKyA1IDwgZGF0YS5sZW5ndGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hlYWRlcihkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICByZXR1cm4gb2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FuUGFyc2UoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBjYW5HZXRGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpICYmXG4gICAgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkgJiZcbiAgICBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvYmUoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IEFEVFMgZnJhbWUgZm9sbG93cyBsYXN0IEFEVFMgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAoaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIEFEVFMgaGVhZGVyIExlbmd0aFxuICAgIGNvbnN0IGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgKyBoZWFkZXJMZW5ndGggPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQURUUyBmcmFtZSBMZW5ndGhcbiAgICBjb25zdCBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIGlmIChmcmFtZUxlbmd0aCA8PSBoZWFkZXJMZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICByZXR1cm4gbmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCBpc0hlYWRlcihkYXRhLCBuZXdPZmZzZXQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRUcmFja0NvbmZpZyhcbiAgdHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLFxuICBvYnNlcnZlcjogSGxzRXZlbnRFbWl0dGVyLFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgYXVkaW9Db2RlYzogc3RyaW5nXG4pIHtcbiAgaWYgKCF0cmFjay5zYW1wbGVyYXRlKSB7XG4gICAgY29uc3QgY29uZmlnID0gZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYyk7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhY2suY29uZmlnID0gY29uZmlnLmNvbmZpZztcbiAgICB0cmFjay5zYW1wbGVyYXRlID0gY29uZmlnLnNhbXBsZXJhdGU7XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gY29uZmlnLmNoYW5uZWxDb3VudDtcbiAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICB0cmFjay5tYW5pZmVzdENvZGVjID0gY29uZmlnLm1hbmlmZXN0Q29kZWM7XG4gICAgbG9nZ2VyLmxvZyhcbiAgICAgIGBwYXJzZWQgY29kZWM6JHt0cmFjay5jb2RlY30sIHJhdGU6JHtjb25maWcuc2FtcGxlcmF0ZX0sIGNoYW5uZWxzOiR7Y29uZmlnLmNoYW5uZWxDb3VudH1gXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhbWVEdXJhdGlvbihzYW1wbGVyYXRlOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gKDEwMjQgKiA5MDAwMCkgLyBzYW1wbGVyYXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGcmFtZUhlYWRlcihcbiAgZGF0YTogVWludDhBcnJheSxcbiAgb2Zmc2V0OiBudW1iZXJcbik6IEZyYW1lSGVhZGVyIHwgdm9pZCB7XG4gIC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICBjb25zdCBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgaWYgKG9mZnNldCArIGhlYWRlckxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgICBjb25zdCBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIC0gaGVhZGVyTGVuZ3RoO1xuICAgIGlmIChmcmFtZUxlbmd0aCA+IDApIHtcbiAgICAgIC8vIGxvZ2dlci5sb2coYEFBQyBmcmFtZSwgb2Zmc2V0L2xlbmd0aC90b3RhbC9wdHM6JHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2ZyYW1lTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH1gKTtcbiAgICAgIHJldHVybiB7IGhlYWRlckxlbmd0aCwgZnJhbWVMZW5ndGggfTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZEZyYW1lKFxuICB0cmFjazogRGVtdXhlZEF1ZGlvVHJhY2ssXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4gIG9mZnNldDogbnVtYmVyLFxuICBwdHM6IG51bWJlcixcbiAgZnJhbWVJbmRleDogbnVtYmVyXG4pOiBBdWRpb0ZyYW1lIHtcbiAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSBhcyBudW1iZXIpO1xuICBjb25zdCBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICBjb25zdCBoZWFkZXIgPSBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gIGxldCB1bml0OiBVaW50OEFycmF5O1xuICBpZiAoaGVhZGVyKSB7XG4gICAgY29uc3QgeyBmcmFtZUxlbmd0aCwgaGVhZGVyTGVuZ3RoIH0gPSBoZWFkZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGg7XG4gICAgY29uc3QgbWlzc2luZyA9IE1hdGgubWF4KDAsIG9mZnNldCArIGxlbmd0aCAtIGRhdGEubGVuZ3RoKTtcbiAgICAvLyBsb2dnZXIubG9nKGBBQUMgZnJhbWUgJHtmcmFtZUluZGV4fSwgcHRzOiR7c3RhbXB9IGxlbmd0aEBvZmZzZXQvdG90YWw6ICR7ZnJhbWVMZW5ndGh9QCR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9IG1pc3Npbmc6ICR7bWlzc2luZ31gKTtcbiAgICBpZiAobWlzc2luZykge1xuICAgICAgdW5pdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCAtIGhlYWRlckxlbmd0aCk7XG4gICAgICB1bml0LnNldChkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgZGF0YS5sZW5ndGgpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdCA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgIH1cblxuICAgIGNvbnN0IHNhbXBsZTogQXVkaW9TYW1wbGUgPSB7XG4gICAgICB1bml0LFxuICAgICAgcHRzOiBzdGFtcCxcbiAgICB9O1xuICAgIGlmICghbWlzc2luZykge1xuICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKHNhbXBsZSBhcyBBdWRpb1NhbXBsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc2FtcGxlLCBsZW5ndGgsIG1pc3NpbmcgfTtcbiAgfVxuICAvLyBvdmVyZmxvdyBpbmNvbXBsZXRlIGhlYWRlclxuICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbiAgdW5pdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIHVuaXQuc2V0KGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmxlbmd0aCksIDApO1xuICBjb25zdCBzYW1wbGU6IEF1ZGlvU2FtcGxlID0ge1xuICAgIHVuaXQsXG4gICAgcHRzOiBzdGFtcCxcbiAgfTtcbiAgcmV0dXJuIHsgc2FtcGxlLCBsZW5ndGgsIG1pc3Npbmc6IC0xIH07XG59XG4iLCIvKipcbiAqIEFBQyBkZW11eGVyXG4gKi9cbmltcG9ydCBCYXNlQXVkaW9EZW11eGVyIGZyb20gJy4vYmFzZS1hdWRpby1kZW11eGVyJztcbmltcG9ydCAqIGFzIEFEVFMgZnJvbSAnLi9hZHRzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgKiBhcyBJRDMgZnJvbSAnLi4vZGVtdXgvaWQzJztcbmltcG9ydCB0eXBlIHsgSGxzRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgSGxzQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcblxuY2xhc3MgQUFDRGVtdXhlciBleHRlbmRzIEJhc2VBdWRpb0RlbXV4ZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBIbHNDb25maWc7XG5cbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgcmVzZXRJbml0U2VnbWVudChcbiAgICBpbml0U2VnbWVudDogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgICBhdWRpb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdmlkZW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHRyYWNrRHVyYXRpb246IG51bWJlclxuICApIHtcbiAgICBzdXBlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKTtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0ge1xuICAgICAgY29udGFpbmVyOiAnYXVkaW8vYWR0cycsXG4gICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgaWQ6IDIsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzZWdtZW50Q29kZWM6ICdhYWMnLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBtYW5pZmVzdENvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgZHVyYXRpb246IHRyYWNrRHVyYXRpb24sXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICBkcm9wcGVkOiAwLFxuICAgIH07XG4gIH1cblxuICAvLyBTb3VyY2UgZm9yIHByb2JlIGluZm8gLSBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICBzdGF0aWMgcHJvYmUoZGF0YSk6IGJvb2xlYW4ge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciB0aGUgQURUUyBzeW5jIHdvcmRcbiAgICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgICBjb25zdCBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgMCkgfHwgW107XG4gICAgbGV0IG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChBRFRTLnByb2JlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnQURUUyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIEFEVFMuY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgfVxuXG4gIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICBBRFRTLmluaXRUcmFja0NvbmZpZyhcbiAgICAgIHRyYWNrLFxuICAgICAgdGhpcy5vYnNlcnZlcixcbiAgICAgIGRhdGEsXG4gICAgICBvZmZzZXQsXG4gICAgICB0cmFjay5tYW5pZmVzdENvZGVjXG4gICAgKTtcbiAgICBjb25zdCBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUoXG4gICAgICB0cmFjayxcbiAgICAgIGRhdGEsXG4gICAgICBvZmZzZXQsXG4gICAgICB0aGlzLmJhc2VQVFMgYXMgbnVtYmVyLFxuICAgICAgdGhpcy5mcmFtZUluZGV4XG4gICAgKTtcbiAgICBpZiAoZnJhbWUgJiYgZnJhbWUubWlzc2luZyA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUNEZW11eGVyO1xuIiwiLyoqXG4gKiBNUDQgZGVtdXhlclxuICovXG5pbXBvcnQge1xuICBEZW11eGVyLFxuICBEZW11eGVyUmVzdWx0LFxuICBQYXNzdGhyb3VnaFRyYWNrLFxuICBEZW11eGVkQXVkaW9UcmFjayxcbiAgRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gIERlbXV4ZWRNZXRhZGF0YVRyYWNrLFxuICBLZXlEYXRhLFxuICBNZXRhZGF0YVNjaGVtYSxcbn0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5pbXBvcnQge1xuICBmaW5kQm94LFxuICBzZWdtZW50VmFsaWRSYW5nZSxcbiAgYXBwZW5kVWludDhBcnJheSxcbiAgcGFyc2VFbXNnLFxuICBwYXJzZVNhbXBsZXMsXG4gIHBhcnNlSW5pdFNlZ21lbnQsXG4gIFJlbXV4ZXJUcmFja0lkQ29uZmlnLFxufSBmcm9tICcuLi91dGlscy9tcDQtdG9vbHMnO1xuaW1wb3J0IHsgZHVtbXlUcmFjayB9IGZyb20gJy4vZHVtbXktZGVtdXhlZC10cmFjayc7XG5pbXBvcnQgdHlwZSB7IEhsc0V2ZW50RW1pdHRlciB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IEhsc0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5cbmNvbnN0IGVtc2dTY2hlbWVQYXR0ZXJuID0gL1xcL2Vtc2dbLS9dSUQzL2k7XG5cbmNsYXNzIE1QNERlbXV4ZXIgaW1wbGVtZW50cyBEZW11eGVyIHtcbiAgcHJpdmF0ZSByZW1haW5kZXJEYXRhOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgdGltZU9mZnNldDogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBjb25maWc6IEhsc0NvbmZpZztcbiAgcHJpdmF0ZSB2aWRlb1RyYWNrPzogUGFzc3Rocm91Z2hUcmFjaztcbiAgcHJpdmF0ZSBhdWRpb1RyYWNrPzogRGVtdXhlZEF1ZGlvVHJhY2s7XG4gIHByaXZhdGUgaWQzVHJhY2s/OiBEZW11eGVkTWV0YWRhdGFUcmFjaztcbiAgcHJpdmF0ZSB0eHRUcmFjaz86IERlbXV4ZWRVc2VyZGF0YVRyYWNrO1xuXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXIsIGNvbmZpZzogSGxzQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cblxuICBwdWJsaWMgcmVzZXRUaW1lU3RhbXAoKSB7fVxuXG4gIHB1YmxpYyByZXNldEluaXRTZWdtZW50KFxuICAgIGluaXRTZWdtZW50OiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICAgIGF1ZGlvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2aWRlb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdHJhY2tEdXJhdGlvbjogbnVtYmVyXG4gICkge1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSAodGhpcy52aWRlb1RyYWNrID0gZHVtbXlUcmFjayhcbiAgICAgICd2aWRlbycsXG4gICAgICAxXG4gICAgKSBhcyBQYXNzdGhyb3VnaFRyYWNrKTtcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gKHRoaXMuYXVkaW9UcmFjayA9IGR1bW15VHJhY2soXG4gICAgICAnYXVkaW8nLFxuICAgICAgMVxuICAgICkgYXMgRGVtdXhlZEF1ZGlvVHJhY2spO1xuICAgIGNvbnN0IGNhcHRpb25UcmFjayA9ICh0aGlzLnR4dFRyYWNrID0gZHVtbXlUcmFjayhcbiAgICAgICd0ZXh0JyxcbiAgICAgIDFcbiAgICApIGFzIERlbXV4ZWRVc2VyZGF0YVRyYWNrKTtcblxuICAgIHRoaXMuaWQzVHJhY2sgPSBkdW1teVRyYWNrKCdpZDMnLCAxKSBhcyBEZW11eGVkTWV0YWRhdGFUcmFjaztcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSAwO1xuXG4gICAgaWYgKCFpbml0U2VnbWVudD8uYnl0ZUxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbml0RGF0YSA9IHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpO1xuXG4gICAgaWYgKGluaXREYXRhLnZpZGVvKSB7XG4gICAgICBjb25zdCB7IGlkLCB0aW1lc2NhbGUsIGNvZGVjIH0gPSBpbml0RGF0YS52aWRlbztcbiAgICAgIHZpZGVvVHJhY2suaWQgPSBpZDtcbiAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gY2FwdGlvblRyYWNrLnRpbWVzY2FsZSA9IHRpbWVzY2FsZTtcbiAgICAgIHZpZGVvVHJhY2suY29kZWMgPSBjb2RlYztcbiAgICB9XG5cbiAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgIGNvbnN0IHsgaWQsIHRpbWVzY2FsZSwgY29kZWMgfSA9IGluaXREYXRhLmF1ZGlvO1xuICAgICAgYXVkaW9UcmFjay5pZCA9IGlkO1xuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSB0aW1lc2NhbGU7XG4gICAgICBhdWRpb1RyYWNrLmNvZGVjID0gY29kZWM7XG4gICAgfVxuXG4gICAgY2FwdGlvblRyYWNrLmlkID0gUmVtdXhlclRyYWNrSWRDb25maWcudGV4dDtcbiAgICB2aWRlb1RyYWNrLnNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICB2aWRlb1RyYWNrLmR1cmF0aW9uID0gYXVkaW9UcmFjay5kdXJhdGlvbiA9IHRyYWNrRHVyYXRpb247XG4gIH1cblxuICBwdWJsaWMgcmVzZXRDb250aWd1aXR5KCk6IHZvaWQge1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgcHJvYmUoZGF0YTogVWludDhBcnJheSkge1xuICAgIC8vIGVuc3VyZSB3ZSBmaW5kIGEgbW9vZiBib3ggaW4gdGhlIGZpcnN0IDE2IGtCXG4gICAgZGF0YSA9IGRhdGEubGVuZ3RoID4gMTYzODQgPyBkYXRhLnN1YmFycmF5KDAsIDE2Mzg0KSA6IGRhdGE7XG4gICAgcmV0dXJuIGZpbmRCb3goZGF0YSwgWydtb29mJ10pLmxlbmd0aCA+IDA7XG4gIH1cblxuICBwdWJsaWMgZGVtdXgoZGF0YTogVWludDhBcnJheSwgdGltZU9mZnNldDogbnVtYmVyKTogRGVtdXhlclJlc3VsdCB7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICAvLyBMb2FkIGFsbCBkYXRhIGludG8gdGhlIGF2YyB0cmFjay4gVGhlIENNQUYgcmVtdXhlciB3aWxsIGxvb2sgZm9yIHRoZSBkYXRhIGluIHRoZSBzYW1wbGVzIG9iamVjdDsgdGhlIHJlc3Qgb2YgdGhlIGZpZWxkcyBkbyBub3QgbWF0dGVyXG4gICAgbGV0IHZpZGVvU2FtcGxlcyA9IGRhdGE7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjayBhcyBQYXNzdGhyb3VnaFRyYWNrO1xuICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMudHh0VHJhY2sgYXMgRGVtdXhlZFVzZXJkYXRhVHJhY2s7XG4gICAgaWYgKHRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICAvLyBTcGxpdCB0aGUgYnl0ZXN0cmVhbSBpbnRvIHR3byByYW5nZXM6IG9uZSBlbmNvbXBhc3NpbmcgYWxsIGRhdGEgdXAgdW50aWwgdGhlIHN0YXJ0IG9mIHRoZSBsYXN0IG1vb2YsIGFuZCBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgdG8gZ3VhcmFudGVlIHRoYXQgd2UncmUgc2VuZGluZyB2YWxpZCBkYXRhIHRvIE1TRSAtIHdoZW4gZGVtdXhpbmcgcHJvZ3Jlc3NpdmVseSwgd2UgaGF2ZSBubyBndWFyYW50ZWVcbiAgICAgIC8vIHRoYXQgdGhlIGZldGNoIGxvYWRlciBnaXZlcyB1cyBmbHVzaCBtb29mK21kYXQgcGFpcnMuIElmIHdlIHB1c2ggamFnZ2VkIGRhdGEgdG8gTVNFLCBpdCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgICAgIGlmICh0aGlzLnJlbWFpbmRlckRhdGEpIHtcbiAgICAgICAgdmlkZW9TYW1wbGVzID0gYXBwZW5kVWludDhBcnJheSh0aGlzLnJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VnbWVudGVkRGF0YSA9IHNlZ21lbnRWYWxpZFJhbmdlKHZpZGVvU2FtcGxlcyk7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBzZWdtZW50ZWREYXRhLnJlbWFpbmRlcjtcbiAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHNlZ21lbnRlZERhdGEudmFsaWQgfHwgbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdmlkZW9TYW1wbGVzO1xuICAgIH1cblxuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5leHRyYWN0SUQzVHJhY2sodmlkZW9UcmFjaywgdGltZU9mZnNldCk7XG4gICAgdGV4dFRyYWNrLnNhbXBsZXMgPSBwYXJzZVNhbXBsZXModGltZU9mZnNldCwgdmlkZW9UcmFjayk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuYXVkaW9UcmFjayBhcyBEZW11eGVkQXVkaW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiB0aGlzLnR4dFRyYWNrIGFzIERlbXV4ZWRVc2VyZGF0YVRyYWNrLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZmx1c2goKSB7XG4gICAgY29uc3QgdGltZU9mZnNldCA9IHRoaXMudGltZU9mZnNldDtcbiAgICBjb25zdCB2aWRlb1RyYWNrID0gdGhpcy52aWRlb1RyYWNrIGFzIFBhc3N0aHJvdWdoVHJhY2s7XG4gICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy50eHRUcmFjayBhcyBEZW11eGVkVXNlcmRhdGFUcmFjaztcbiAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB0aGlzLnJlbWFpbmRlckRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuXG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLmV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aGlzLnRpbWVPZmZzZXQpO1xuICAgIHRleHRUcmFjay5zYW1wbGVzID0gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHZpZGVvVHJhY2spO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBhdWRpb1RyYWNrOiBkdW1teVRyYWNrKCkgYXMgRGVtdXhlZEF1ZGlvVHJhY2ssXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogZHVtbXlUcmFjaygpIGFzIERlbXV4ZWRVc2VyZGF0YVRyYWNrLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RJRDNUcmFjayhcbiAgICB2aWRlb1RyYWNrOiBQYXNzdGhyb3VnaFRyYWNrLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlclxuICApOiBEZW11eGVkTWV0YWRhdGFUcmFjayB7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrIGFzIERlbXV4ZWRNZXRhZGF0YVRyYWNrO1xuICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbXNncyA9IGZpbmRCb3godmlkZW9UcmFjay5zYW1wbGVzLCBbJ2Vtc2cnXSk7XG4gICAgICBpZiAoZW1zZ3MpIHtcbiAgICAgICAgZW1zZ3MuZm9yRWFjaCgoZGF0YTogVWludDhBcnJheSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVtc2dJbmZvID0gcGFyc2VFbXNnKGRhdGEpO1xuICAgICAgICAgIGlmIChlbXNnU2NoZW1lUGF0dGVybi50ZXN0KGVtc2dJbmZvLnNjaGVtZUlkVXJpKSkge1xuICAgICAgICAgICAgY29uc3QgcHRzID0gTnVtYmVyLmlzRmluaXRlKGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWUpXG4gICAgICAgICAgICAgID8gZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZSEgLyBlbXNnSW5mby50aW1lU2NhbGVcbiAgICAgICAgICAgICAgOiB0aW1lT2Zmc2V0ICtcbiAgICAgICAgICAgICAgICBlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lRGVsdGEhIC8gZW1zZ0luZm8udGltZVNjYWxlO1xuICAgICAgICAgICAgbGV0IGR1cmF0aW9uID1cbiAgICAgICAgICAgICAgZW1zZ0luZm8uZXZlbnREdXJhdGlvbiA9PT0gMHhmZmZmZmZmZlxuICAgICAgICAgICAgICAgID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICAgICAgICAgICAgOiBlbXNnSW5mby5ldmVudER1cmF0aW9uIC8gZW1zZ0luZm8udGltZVNjYWxlO1xuICAgICAgICAgICAgLy8gU2FmYXJpIHRha2VzIGFueXRoaW5nIDw9IDAuMDAxIHNlY29uZHMgYW5kIG1hcHMgaXQgdG8gSW5maW5pdHlcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbiA8PSAwLjAwMSkge1xuICAgICAgICAgICAgICBkdXJhdGlvbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBlbXNnSW5mby5wYXlsb2FkO1xuICAgICAgICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgZGF0YTogcGF5bG9hZCxcbiAgICAgICAgICAgICAgbGVuOiBwYXlsb2FkLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgIGR0czogcHRzLFxuICAgICAgICAgICAgICBwdHM6IHB0cyxcbiAgICAgICAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEuZW1zZyxcbiAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkM1RyYWNrO1xuICB9XG5cbiAgZGVtdXhTYW1wbGVBZXMoXG4gICAgZGF0YTogVWludDhBcnJheSxcbiAgICBrZXlEYXRhOiBLZXlEYXRhLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlclxuICApOiBQcm9taXNlPERlbXV4ZXJSZXN1bHQ+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICBuZXcgRXJyb3IoJ1RoZSBNUDQgZGVtdXhlciBkb2VzIG5vdCBzdXBwb3J0IFNBTVBMRS1BRVMgZGVjcnlwdGlvbicpXG4gICAgKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNUDREZW11eGVyO1xuIiwiLyoqXG4gKiAgTVBFRyBwYXJzZXIgaGVscGVyXG4gKi9cbmltcG9ydCB7IERlbXV4ZWRBdWRpb1RyYWNrIH0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5cbmxldCBjaHJvbWVWZXJzaW9uOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuY29uc3QgQml0cmF0ZXNNYXAgPSBbXG4gIDMyLCA2NCwgOTYsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAyODgsIDMyMCwgMzUyLCAzODQsIDQxNiwgNDQ4LCAzMiwgNDgsIDU2LFxuICA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCxcbiAgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCxcbiAgMTYwLCAxNzYsIDE5MiwgMjI0LCAyNTYsIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsXG4gIDE2MCxcbl07XG5cbmNvbnN0IFNhbXBsaW5nUmF0ZU1hcCA9IFtcbiAgNDQxMDAsIDQ4MDAwLCAzMjAwMCwgMjIwNTAsIDI0MDAwLCAxNjAwMCwgMTEwMjUsIDEyMDAwLCA4MDAwLFxuXTtcblxuY29uc3QgU2FtcGxlc0NvZWZmaWNpZW50cyA9IFtcbiAgLy8gTVBFRyAyLjVcbiAgW1xuICAgIDAsIC8vIFJlc2VydmVkXG4gICAgNzIsIC8vIExheWVyM1xuICAgIDE0NCwgLy8gTGF5ZXIyXG4gICAgMTIsIC8vIExheWVyMVxuICBdLFxuICAvLyBSZXNlcnZlZFxuICBbXG4gICAgMCwgLy8gUmVzZXJ2ZWRcbiAgICAwLCAvLyBMYXllcjNcbiAgICAwLCAvLyBMYXllcjJcbiAgICAwLCAvLyBMYXllcjFcbiAgXSxcbiAgLy8gTVBFRyAyXG4gIFtcbiAgICAwLCAvLyBSZXNlcnZlZFxuICAgIDcyLCAvLyBMYXllcjNcbiAgICAxNDQsIC8vIExheWVyMlxuICAgIDEyLCAvLyBMYXllcjFcbiAgXSxcbiAgLy8gTVBFRyAxXG4gIFtcbiAgICAwLCAvLyBSZXNlcnZlZFxuICAgIDE0NCwgLy8gTGF5ZXIzXG4gICAgMTQ0LCAvLyBMYXllcjJcbiAgICAxMiwgLy8gTGF5ZXIxXG4gIF0sXG5dO1xuXG5jb25zdCBCeXRlc0luU2xvdCA9IFtcbiAgMCwgLy8gUmVzZXJ2ZWRcbiAgMSwgLy8gTGF5ZXIzXG4gIDEsIC8vIExheWVyMlxuICA0LCAvLyBMYXllcjFcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRGcmFtZShcbiAgdHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgcHRzOiBudW1iZXIsXG4gIGZyYW1lSW5kZXg6IG51bWJlclxuKSB7XG4gIC8vIFVzaW5nIGh0dHA6Ly93d3cuZGF0YXZveWFnZS5jb20vbXBnc2NyaXB0L21wZWdoZHIuaHRtIGFzIGEgcmVmZXJlbmNlXG4gIGlmIChvZmZzZXQgKyAyNCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaGVhZGVyID0gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgaWYgKGhlYWRlciAmJiBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBmcmFtZUR1cmF0aW9uID0gKGhlYWRlci5zYW1wbGVzUGVyRnJhbWUgKiA5MDAwMCkgLyBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICBjb25zdCBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgIGNvbnN0IHNhbXBsZSA9IHtcbiAgICAgIHVuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGgpLFxuICAgICAgcHRzOiBzdGFtcCxcbiAgICAgIGR0czogc3RhbXAsXG4gICAgfTtcblxuICAgIHRyYWNrLmNvbmZpZyA9IFtdO1xuICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGhlYWRlci5jaGFubmVsQ291bnQ7XG4gICAgdHJhY2suc2FtcGxlcmF0ZSA9IGhlYWRlci5zYW1wbGVSYXRlO1xuICAgIHRyYWNrLnNhbXBsZXMucHVzaChzYW1wbGUpO1xuXG4gICAgcmV0dXJuIHsgc2FtcGxlLCBsZW5ndGg6IGhlYWRlci5mcmFtZUxlbmd0aCwgbWlzc2luZzogMCB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUhlYWRlcihkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcikge1xuICBjb25zdCBtcGVnVmVyc2lvbiA9IChkYXRhW29mZnNldCArIDFdID4+IDMpICYgMztcbiAgY29uc3QgbXBlZ0xheWVyID0gKGRhdGFbb2Zmc2V0ICsgMV0gPj4gMSkgJiAzO1xuICBjb25zdCBiaXRSYXRlSW5kZXggPSAoZGF0YVtvZmZzZXQgKyAyXSA+PiA0KSAmIDE1O1xuICBjb25zdCBzYW1wbGVSYXRlSW5kZXggPSAoZGF0YVtvZmZzZXQgKyAyXSA+PiAyKSAmIDM7XG4gIGlmIChcbiAgICBtcGVnVmVyc2lvbiAhPT0gMSAmJlxuICAgIGJpdFJhdGVJbmRleCAhPT0gMCAmJlxuICAgIGJpdFJhdGVJbmRleCAhPT0gMTUgJiZcbiAgICBzYW1wbGVSYXRlSW5kZXggIT09IDNcbiAgKSB7XG4gICAgY29uc3QgcGFkZGluZ0JpdCA9IChkYXRhW29mZnNldCArIDJdID4+IDEpICYgMTtcbiAgICBjb25zdCBjaGFubmVsTW9kZSA9IGRhdGFbb2Zmc2V0ICsgM10gPj4gNjtcbiAgICBjb25zdCBjb2x1bW5JbkJpdHJhdGVzID1cbiAgICAgIG1wZWdWZXJzaW9uID09PSAzID8gMyAtIG1wZWdMYXllciA6IG1wZWdMYXllciA9PT0gMyA/IDMgOiA0O1xuICAgIGNvbnN0IGJpdFJhdGUgPVxuICAgICAgQml0cmF0ZXNNYXBbY29sdW1uSW5CaXRyYXRlcyAqIDE0ICsgYml0UmF0ZUluZGV4IC0gMV0gKiAxMDAwO1xuICAgIGNvbnN0IGNvbHVtbkluU2FtcGxlUmF0ZXMgPVxuICAgICAgbXBlZ1ZlcnNpb24gPT09IDMgPyAwIDogbXBlZ1ZlcnNpb24gPT09IDIgPyAxIDogMjtcbiAgICBjb25zdCBzYW1wbGVSYXRlID1cbiAgICAgIFNhbXBsaW5nUmF0ZU1hcFtjb2x1bW5JblNhbXBsZVJhdGVzICogMyArIHNhbXBsZVJhdGVJbmRleF07XG4gICAgY29uc3QgY2hhbm5lbENvdW50ID0gY2hhbm5lbE1vZGUgPT09IDMgPyAxIDogMjsgLy8gSWYgYml0cyBvZiBjaGFubmVsIG1vZGUgYXJlIGAxMWAgdGhlbiBpdCBpcyBhIHNpbmdsZSBjaGFubmVsIChNb25vKVxuICAgIGNvbnN0IHNhbXBsZUNvZWZmaWNpZW50ID0gU2FtcGxlc0NvZWZmaWNpZW50c1ttcGVnVmVyc2lvbl1bbXBlZ0xheWVyXTtcbiAgICBjb25zdCBieXRlc0luU2xvdCA9IEJ5dGVzSW5TbG90W21wZWdMYXllcl07XG4gICAgY29uc3Qgc2FtcGxlc1BlckZyYW1lID0gc2FtcGxlQ29lZmZpY2llbnQgKiA4ICogYnl0ZXNJblNsb3Q7XG4gICAgY29uc3QgZnJhbWVMZW5ndGggPVxuICAgICAgTWF0aC5mbG9vcigoc2FtcGxlQ29lZmZpY2llbnQgKiBiaXRSYXRlKSAvIHNhbXBsZVJhdGUgKyBwYWRkaW5nQml0KSAqXG4gICAgICBieXRlc0luU2xvdDtcblxuICAgIGlmIChjaHJvbWVWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvaSk7XG4gICAgICBjaHJvbWVWZXJzaW9uID0gcmVzdWx0ID8gcGFyc2VJbnQocmVzdWx0WzFdKSA6IDA7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRDaHJvbWVGaXggPSAhIWNocm9tZVZlcnNpb24gJiYgY2hyb21lVmVyc2lvbiA8PSA4NztcblxuICAgIGlmIChcbiAgICAgIG5lZWRDaHJvbWVGaXggJiZcbiAgICAgIG1wZWdMYXllciA9PT0gMiAmJlxuICAgICAgYml0UmF0ZSA+PSAyMjQwMDAgJiZcbiAgICAgIGNoYW5uZWxNb2RlID09PSAwXG4gICAgKSB7XG4gICAgICAvLyBXb3JrIGFyb3VuZCBidWcgaW4gQ2hyb21pdW0gYnkgc2V0dGluZyBjaGFubmVsTW9kZSB0byBkdWFsLWNoYW5uZWwgKDAxKSBpbnN0ZWFkIG9mIHN0ZXJlbyAoMDApXG4gICAgICBkYXRhW29mZnNldCArIDNdID0gZGF0YVtvZmZzZXQgKyAzXSB8IDB4ODA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc2FtcGxlUmF0ZSwgY2hhbm5lbENvdW50LCBmcmFtZUxlbmd0aCwgc2FtcGxlc1BlckZyYW1lIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSGVhZGVyUGF0dGVybihkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJlxuICAgIChkYXRhW29mZnNldCArIDFdICYgMHhlMCkgPT09IDB4ZTAgJiZcbiAgICAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDYpICE9PSAweDAwXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hlYWRlcihkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxuICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICByZXR1cm4gb2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FuUGFyc2UoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgY29uc3QgaGVhZGVyU2l6ZSA9IDQ7XG5cbiAgcmV0dXJuIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpICYmIGhlYWRlclNpemUgPD0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9iZShkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgTVBFRyBmcmFtZSBmb2xsb3dzIGxhc3QgTVBFRyBmcmFtZVxuICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXG4gIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBNUEVHIGhlYWRlciBMZW5ndGhcbiAgICBjb25zdCBoZWFkZXJMZW5ndGggPSA0O1xuICAgIC8vIE1QRUcgZnJhbWUgTGVuZ3RoXG4gICAgY29uc3QgaGVhZGVyID0gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgICBsZXQgZnJhbWVMZW5ndGggPSBoZWFkZXJMZW5ndGg7XG4gICAgaWYgKGhlYWRlcj8uZnJhbWVMZW5ndGgpIHtcbiAgICAgIGZyYW1lTGVuZ3RoID0gaGVhZGVyLmZyYW1lTGVuZ3RoO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgIHJldHVybiBuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IGlzSGVhZGVyKGRhdGEsIG5ld09mZnNldCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiLyoqXG4gKiBQYXJzZXIgZm9yIGV4cG9uZW50aWFsIEdvbG9tYiBjb2RlcywgYSB2YXJpYWJsZS1iaXR3aWR0aCBudW1iZXIgZW5jb2Rpbmcgc2NoZW1lIHVzZWQgYnkgaDI2NC5cbiAqL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBFeHBHb2xvbWIge1xuICBwcml2YXRlIGRhdGE6IFVpbnQ4QXJyYXk7XG4gIHB1YmxpYyBieXRlc0F2YWlsYWJsZTogbnVtYmVyO1xuICBwcml2YXRlIHdvcmQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBiaXRzQXZhaWxhYmxlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoZGF0YTogVWludDhBcnJheSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXG4gICAgdGhpcy53b3JkID0gMDsgLy8gOnVpbnRcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJpdHMgbGVmdCB0byBleGFtaW5lIGluIHRoZSBjdXJyZW50IHdvcmRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSAwOyAvLyA6dWludFxuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBsb2FkV29yZCgpOiB2b2lkIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGJ5dGVzQXZhaWxhYmxlID0gdGhpcy5ieXRlc0F2YWlsYWJsZTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGRhdGEuYnl0ZUxlbmd0aCAtIGJ5dGVzQXZhaWxhYmxlO1xuICAgIGNvbnN0IHdvcmtpbmdCeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IGF2YWlsYWJsZUJ5dGVzID0gTWF0aC5taW4oNCwgYnl0ZXNBdmFpbGFibGUpO1xuICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICB3b3JraW5nQnl0ZXMuc2V0KGRhdGEuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgYXZhaWxhYmxlQnl0ZXMpKTtcbiAgICB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgIC8vIHRyYWNrIHRoZSBhbW91bnQgb2YgdGhpcy5kYXRhIHRoYXQgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gYXZhaWxhYmxlQnl0ZXM7XG4gIH1cblxuICAvLyAoY291bnQ6aW50KTp2b2lkXG4gIHNraXBCaXRzKGNvdW50OiBudW1iZXIpOiB2b2lkIHtcbiAgICBsZXQgc2tpcEJ5dGVzOyAvLyA6aW50XG4gICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgdGhpcy5ieXRlc0F2YWlsYWJsZSAqIDggKyB0aGlzLmJpdHNBdmFpbGFibGUpO1xuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiBjb3VudCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgLT0gdGhpcy5iaXRzQXZhaWxhYmxlO1xuICAgICAgc2tpcEJ5dGVzID0gY291bnQgPj4gMztcbiAgICAgIGNvdW50IC09IHNraXBCeXRlcyA8PCAzO1xuICAgICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBza2lwQnl0ZXM7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIChzaXplOmludCk6dWludFxuICByZWFkQml0cyhzaXplOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKTsgLy8gOnVpbnRcbiAgICBjb25zdCB2YWx1ID0gdGhpcy53b3JkID4+PiAoMzIgLSBiaXRzKTsgLy8gOnVpbnRcbiAgICBpZiAoc2l6ZSA+IDMyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xuICAgIH1cblxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBiaXRzO1xuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGJpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ5dGVzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJpdHMgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgYml0cyA9IHNpemUgLSBiaXRzO1xuICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiAodmFsdSA8PCBiaXRzKSB8IHRoaXMucmVhZEJpdHMoYml0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1O1xuICAgIH1cbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgc2tpcExaKCk6IG51bWJlciB7XG4gICAgbGV0IGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG4gICAgZm9yIChcbiAgICAgIGxlYWRpbmdaZXJvQ291bnQgPSAwO1xuICAgICAgbGVhZGluZ1plcm9Db3VudCA8IHRoaXMuYml0c0F2YWlsYWJsZTtcbiAgICAgICsrbGVhZGluZ1plcm9Db3VudFxuICAgICkge1xuICAgICAgaWYgKCh0aGlzLndvcmQgJiAoMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkpICE9PSAwKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgdGhpcy53b3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdlIGV4aGF1c3RlZCB3b3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcbiAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQgKyB0aGlzLnNraXBMWigpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwVUVHKCk6IHZvaWQge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwRUcoKTogdm9pZCB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHJlYWRVRUcoKTogbnVtYmVyIHtcbiAgICBjb25zdCBjbHogPSB0aGlzLnNraXBMWigpOyAvLyA6dWludFxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkRUcoKTogbnVtYmVyIHtcbiAgICBjb25zdCB2YWx1ID0gdGhpcy5yZWFkVUVHKCk7IC8vIDppbnRcbiAgICBpZiAoMHgwMSAmIHZhbHUpIHtcbiAgICAgIC8vIHRoZSBudW1iZXIgaXMgb2RkIGlmIHRoZSBsb3cgb3JkZXIgYml0IGlzIHNldFxuICAgICAgcmV0dXJuICgxICsgdmFsdSkgPj4+IDE7IC8vIGFkZCAxIHRvIG1ha2UgaXQgZXZlbiwgYW5kIGRpdmlkZSBieSAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICB9XG4gIH1cblxuICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xuICAvLyA6Qm9vbGVhblxuICByZWFkQm9vbGVhbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxKSA9PT0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVUJ5dGUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVVNob3J0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVSW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkdmFuY2UgdGhlIEV4cEdvbG9tYiBkZWNvZGVyIHBhc3QgYSBzY2FsaW5nIGxpc3QuIFRoZSBzY2FsaW5nXG4gICAqIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAqIHNldCBhbmQgaXMgbm90IHJlbGV2YW50IHRvIHRyYW5zbXV4aW5nLlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgc2NhbGluZyBsaXN0XG4gICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICovXG4gIHNraXBTY2FsaW5nTGlzdChjb3VudDogbnVtYmVyKTogdm9pZCB7XG4gICAgbGV0IGxhc3RTY2FsZSA9IDg7XG4gICAgbGV0IG5leHRTY2FsZSA9IDg7XG4gICAgbGV0IGRlbHRhU2NhbGU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XG4gICAgICAgIGRlbHRhU2NhbGUgPSB0aGlzLnJlYWRFRygpO1xuICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICB9XG4gICAgICBsYXN0U2NhbGUgPSBuZXh0U2NhbGUgPT09IDAgPyBsYXN0U2NhbGUgOiBuZXh0U2NhbGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGFuZCByZXR1cm4gc29tZSBpbnRlcmVzdGluZyB2aWRlb1xuICAgKiBwcm9wZXJ0aWVzLiBBIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgaXMgdGhlIEgyNjQgbWV0YWRhdGEgdGhhdFxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgKiBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0LCBpbmNsdWRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlXG4gICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgKi9cbiAgcmVhZFNQUygpOiB7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICBwaXhlbFJhdGlvOiBbbnVtYmVyLCBudW1iZXJdO1xuICB9IHtcbiAgICBsZXQgZnJhbWVDcm9wTGVmdE9mZnNldCA9IDA7XG4gICAgbGV0IGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gMDtcbiAgICBsZXQgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlO1xuICAgIGxldCBzY2FsaW5nTGlzdENvdW50O1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHJlYWRVQnl0ZSA9IHRoaXMucmVhZFVCeXRlLmJpbmQodGhpcyk7XG4gICAgY29uc3QgcmVhZEJpdHMgPSB0aGlzLnJlYWRCaXRzLmJpbmQodGhpcyk7XG4gICAgY29uc3QgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHJlYWRCb29sZWFuID0gdGhpcy5yZWFkQm9vbGVhbi5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBCaXRzID0gdGhpcy5za2lwQml0cy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyk7XG4gICAgY29uc3Qgc2tpcFVFRyA9IHRoaXMuc2tpcFVFRy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBTY2FsaW5nTGlzdCA9IHRoaXMuc2tpcFNjYWxpbmdMaXN0LmJpbmQodGhpcyk7XG5cbiAgICByZWFkVUJ5dGUoKTtcbiAgICBjb25zdCBwcm9maWxlSWRjID0gcmVhZFVCeXRlKCk7IC8vIHByb2ZpbGVfaWRjXG4gICAgcmVhZEJpdHMoNSk7IC8vIHByb2ZpbGVDb21wYXQgY29uc3RyYWludF9zZXRbMC00XV9mbGFnLCB1KDUpXG4gICAgc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcbiAgICByZWFkVUJ5dGUoKTsgLy8gbGV2ZWxfaWRjIHUoOClcbiAgICBza2lwVUVHKCk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG4gICAgLy8gc29tZSBwcm9maWxlcyBoYXZlIG1vcmUgb3B0aW9uYWwgZGF0YSB3ZSBkb24ndCBuZWVkXG4gICAgaWYgKFxuICAgICAgcHJvZmlsZUlkYyA9PT0gMTAwIHx8XG4gICAgICBwcm9maWxlSWRjID09PSAxMTAgfHxcbiAgICAgIHByb2ZpbGVJZGMgPT09IDEyMiB8fFxuICAgICAgcHJvZmlsZUlkYyA9PT0gMjQ0IHx8XG4gICAgICBwcm9maWxlSWRjID09PSA0NCB8fFxuICAgICAgcHJvZmlsZUlkYyA9PT0gODMgfHxcbiAgICAgIHByb2ZpbGVJZGMgPT09IDg2IHx8XG4gICAgICBwcm9maWxlSWRjID09PSAxMTggfHxcbiAgICAgIHByb2ZpbGVJZGMgPT09IDEyOFxuICAgICkge1xuICAgICAgY29uc3QgY2hyb21hRm9ybWF0SWRjID0gcmVhZFVFRygpO1xuICAgICAgaWYgKGNocm9tYUZvcm1hdElkYyA9PT0gMykge1xuICAgICAgICBza2lwQml0cygxKTtcbiAgICAgIH0gLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcblxuICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfbHVtYV9taW51czhcbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2Nocm9tYV9taW51czhcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBxcHByaW1lX3lfemVyb190cmFuc2Zvcm1fYnlwYXNzX2ZsYWdcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIHNlcV9zY2FsaW5nX21hdHJpeF9wcmVzZW50X2ZsYWdcbiAgICAgICAgc2NhbGluZ0xpc3RDb3VudCA9IGNocm9tYUZvcm1hdElkYyAhPT0gMyA/IDggOiAxMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYWxpbmdMaXN0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgICAgICAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDE2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCg2NCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgIGNvbnN0IHBpY09yZGVyQ250VHlwZSA9IHJlYWRVRUcoKTtcbiAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICByZWFkVUVHKCk7IC8vIGxvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNFxuICAgIH0gZWxzZSBpZiAocGljT3JkZXJDbnRUeXBlID09PSAxKSB7XG4gICAgICBza2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSByZWFkVUVHKCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlOyBpKyspIHtcbiAgICAgICAgc2tpcEVHKCk7XG4gICAgICB9IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cbiAgICB9XG4gICAgc2tpcFVFRygpOyAvLyBtYXhfbnVtX3JlZl9mcmFtZXNcbiAgICBza2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG4gICAgY29uc3QgcGljV2lkdGhJbk1ic01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICBjb25zdCBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxID0gcmVhZFVFRygpO1xuICAgIGNvbnN0IGZyYW1lTWJzT25seUZsYWcgPSByZWFkQml0cygxKTtcbiAgICBpZiAoZnJhbWVNYnNPbmx5RmxhZyA9PT0gMCkge1xuICAgICAgc2tpcEJpdHMoMSk7XG4gICAgfSAvLyBtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnXG5cbiAgICBza2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgfVxuICAgIGxldCBwaXhlbFJhdGlvOiBbbnVtYmVyLCBudW1iZXJdID0gWzEsIDFdO1xuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWdcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGFzcGVjdFJhdGlvSWRjKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTIsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTAsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNDAsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjQsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjAsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMzIsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbODAsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE4LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNSwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNjQsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2MCwgOTldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNCwgM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFszLCAyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIsIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNTU6IHtcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbXG4gICAgICAgICAgICAgIChyZWFkVUJ5dGUoKSA8PCA4KSB8IHJlYWRVQnl0ZSgpLFxuICAgICAgICAgICAgICAocmVhZFVCeXRlKCkgPDwgOCkgfCByZWFkVUJ5dGUoKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBNYXRoLmNlaWwoXG4gICAgICAgIChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNiAtXG4gICAgICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCAqIDIgLVxuICAgICAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ICogMlxuICAgICAgKSxcbiAgICAgIGhlaWdodDpcbiAgICAgICAgKDIgLSBmcmFtZU1ic09ubHlGbGFnKSAqIChwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxICsgMSkgKiAxNiAtXG4gICAgICAgIChmcmFtZU1ic09ubHlGbGFnID8gMiA6IDQpICpcbiAgICAgICAgICAoZnJhbWVDcm9wVG9wT2Zmc2V0ICsgZnJhbWVDcm9wQm90dG9tT2Zmc2V0KSxcbiAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW8sXG4gICAgfTtcbiAgfVxuXG4gIHJlYWRTbGljZVR5cGUoKSB7XG4gICAgLy8gc2tpcCBOQUx1IHR5cGVcbiAgICB0aGlzLnJlYWRVQnl0ZSgpO1xuICAgIC8vIGRpc2NhcmQgZmlyc3RfbWJfaW5fc2xpY2VcbiAgICB0aGlzLnJlYWRVRUcoKTtcbiAgICAvLyByZXR1cm4gc2xpY2VfdHlwZVxuICAgIHJldHVybiB0aGlzLnJlYWRVRUcoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFeHBHb2xvbWI7XG4iLCIvKipcbiAqIFNBTVBMRS1BRVMgZGVjcnlwdGVyXG4gKi9cblxuaW1wb3J0IHsgSGxzQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcbmltcG9ydCB7IEhsc0V2ZW50RW1pdHRlciB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7XG4gIEF1ZGlvU2FtcGxlLFxuICBBdmNTYW1wbGUsXG4gIEF2Y1NhbXBsZVVuaXQsXG4gIERlbXV4ZWRWaWRlb1RyYWNrLFxuICBLZXlEYXRhLFxufSBmcm9tICcuLi90eXBlcy9kZW11eGVyJztcbmltcG9ydCB7IGRpc2NhcmRFUEIgfSBmcm9tICcuLi91dGlscy9tcDQtdG9vbHMnO1xuXG5jbGFzcyBTYW1wbGVBZXNEZWNyeXB0ZXIge1xuICBwcml2YXRlIGtleURhdGE6IEtleURhdGE7XG4gIHByaXZhdGUgZGVjcnlwdGVyOiBEZWNyeXB0ZXI7XG5cbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXI6IEhsc0V2ZW50RW1pdHRlciwgY29uZmlnOiBIbHNDb25maWcsIGtleURhdGE6IEtleURhdGEpIHtcbiAgICB0aGlzLmtleURhdGEgPSBrZXlEYXRhO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcihjb25maWcsIHtcbiAgICAgIHJlbW92ZVBLQ1M3UGFkZGluZzogZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBkZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGE6IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlcik6IFByb21pc2U8QXJyYXlCdWZmZXI+IHtcbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChcbiAgICAgIGVuY3J5cHRlZERhdGEsXG4gICAgICB0aGlzLmtleURhdGEua2V5LmJ1ZmZlcixcbiAgICAgIHRoaXMua2V5RGF0YS5pdi5idWZmZXJcbiAgICApO1xuICB9XG5cbiAgLy8gQUFDIC0gZW5jcnlwdCBhbGwgZnVsbCAxNiBieXRlcyBibG9ja3Mgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMTZcbiAgcHJpdmF0ZSBkZWNyeXB0QWFjU2FtcGxlKFxuICAgIHNhbXBsZXM6IEF1ZGlvU2FtcGxlW10sXG4gICAgc2FtcGxlSW5kZXg6IG51bWJlcixcbiAgICBjYWxsYmFjazogKCkgPT4gdm9pZFxuICApIHtcbiAgICBjb25zdCBjdXJVbml0ID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdDtcbiAgICBpZiAoY3VyVW5pdC5sZW5ndGggPD0gMTYpIHtcbiAgICAgIC8vIE5vIGVuY3J5cHRlZCBwb3J0aW9uIGluIHRoaXMgc2FtcGxlIChmaXJzdCAxNiBieXRlcyBpcyBub3RcbiAgICAgIC8vIGVuY3J5cHRlZCwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvSExTX1NhbXBsZV9FbmNyeXB0aW9uL0VuY3J5cHRpb24vRW5jcnlwdGlvbi5odG1sKSxcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoXG4gICAgICAxNixcbiAgICAgIGN1clVuaXQubGVuZ3RoIC0gKGN1clVuaXQubGVuZ3RoICUgMTYpXG4gICAgKTtcbiAgICBjb25zdCBlbmNyeXB0ZWRCdWZmZXIgPSBlbmNyeXB0ZWREYXRhLmJ1ZmZlci5zbGljZShcbiAgICAgIGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCxcbiAgICAgIGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCArIGVuY3J5cHRlZERhdGEubGVuZ3RoXG4gICAgKTtcblxuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWRCdWZmZXIpLnRoZW4oKGRlY3J5cHRlZEJ1ZmZlcjogQXJyYXlCdWZmZXIpID0+IHtcbiAgICAgIGNvbnN0IGRlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWRCdWZmZXIpO1xuICAgICAgY3VyVW5pdC5zZXQoZGVjcnlwdGVkRGF0YSwgMTYpO1xuXG4gICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkZWNyeXB0QWFjU2FtcGxlcyhcbiAgICBzYW1wbGVzOiBBdWRpb1NhbXBsZVtdLFxuICAgIHNhbXBsZUluZGV4OiBudW1iZXIsXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWRcbiAgKSB7XG4gICAgZm9yICg7IDsgc2FtcGxlSW5kZXgrKykge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQubGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spO1xuXG4gICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuICBnZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhOiBVaW50OEFycmF5KSB7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YUxlbiA9XG4gICAgICBNYXRoLmZsb29yKChkZWNvZGVkRGF0YS5sZW5ndGggLSA0OCkgLyAxNjApICogMTYgKyAxNjtcbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gbmV3IEludDhBcnJheShlbmNyeXB0ZWREYXRhTGVuKTtcbiAgICBsZXQgb3V0cHV0UG9zID0gMDtcbiAgICBmb3IgKFxuICAgICAgbGV0IGlucHV0UG9zID0gMzI7XG4gICAgICBpbnB1dFBvcyA8IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2O1xuICAgICAgaW5wdXRQb3MgKz0gMTYwLCBvdXRwdXRQb3MgKz0gMTZcbiAgICApIHtcbiAgICAgIGVuY3J5cHRlZERhdGEuc2V0KFxuICAgICAgICBkZWNvZGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksXG4gICAgICAgIG91dHB1dFBvc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jcnlwdGVkRGF0YTtcbiAgfVxuXG4gIGdldEF2Y0RlY3J5cHRlZFVuaXQoXG4gICAgZGVjb2RlZERhdGE6IFVpbnQ4QXJyYXksXG4gICAgZGVjcnlwdGVkRGF0YTogQXJyYXlMaWtlPG51bWJlcj4gfCBBcnJheUJ1ZmZlciB8IFNoYXJlZEFycmF5QnVmZmVyXG4gICkge1xuICAgIGNvbnN0IHVpbnQ4RGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgIGxldCBpbnB1dFBvcyA9IDA7XG4gICAgZm9yIChcbiAgICAgIGxldCBvdXRwdXRQb3MgPSAzMjtcbiAgICAgIG91dHB1dFBvcyA8IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2O1xuICAgICAgb3V0cHV0UG9zICs9IDE2MCwgaW5wdXRQb3MgKz0gMTZcbiAgICApIHtcbiAgICAgIGRlY29kZWREYXRhLnNldChcbiAgICAgICAgdWludDhEZWNyeXB0ZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSxcbiAgICAgICAgb3V0cHV0UG9zXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNvZGVkRGF0YTtcbiAgfVxuXG4gIGRlY3J5cHRBdmNTYW1wbGUoXG4gICAgc2FtcGxlczogQXZjU2FtcGxlW10sXG4gICAgc2FtcGxlSW5kZXg6IG51bWJlcixcbiAgICB1bml0SW5kZXg6IG51bWJlcixcbiAgICBjYWxsYmFjazogKCkgPT4gdm9pZCxcbiAgICBjdXJVbml0OiBBdmNTYW1wbGVVbml0XG4gICkge1xuICAgIGNvbnN0IGRlY29kZWREYXRhID0gZGlzY2FyZEVQQihjdXJVbml0LmRhdGEpO1xuICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSB0aGlzLmdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpO1xuXG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGEuYnVmZmVyKS50aGVuKFxuICAgICAgKGRlY3J5cHRlZEJ1ZmZlcjogQXJyYXlCdWZmZXIpID0+IHtcbiAgICAgICAgY3VyVW5pdC5kYXRhID0gdGhpcy5nZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWRCdWZmZXIpO1xuXG4gICAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgICB0aGlzLmRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgZGVjcnlwdEF2Y1NhbXBsZXMoXG4gICAgc2FtcGxlczogRGVtdXhlZFZpZGVvVHJhY2tbJ3NhbXBsZXMnXSxcbiAgICBzYW1wbGVJbmRleDogbnVtYmVyLFxuICAgIHVuaXRJbmRleDogbnVtYmVyLFxuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkXG4gICkge1xuICAgIGlmIChzYW1wbGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVjcnlwdCBzYW1wbGVzIG9mIHR5cGUgVWludDhBcnJheScpO1xuICAgIH1cblxuICAgIGZvciAoOyA7IHNhbXBsZUluZGV4KyssIHVuaXRJbmRleCA9IDApIHtcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1clVuaXRzID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdHM7XG4gICAgICBmb3IgKDsgOyB1bml0SW5kZXgrKykge1xuICAgICAgICBpZiAodW5pdEluZGV4ID49IGN1clVuaXRzLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VyVW5pdCA9IGN1clVuaXRzW3VuaXRJbmRleF07XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjdXJVbml0LmRhdGEubGVuZ3RoIDw9IDQ4IHx8XG4gICAgICAgICAgKGN1clVuaXQudHlwZSAhPT0gMSAmJiBjdXJVbml0LnR5cGUgIT09IDUpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZWNyeXB0QXZjU2FtcGxlKFxuICAgICAgICAgIHNhbXBsZXMsXG4gICAgICAgICAgc2FtcGxlSW5kZXgsXG4gICAgICAgICAgdW5pdEluZGV4LFxuICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgIGN1clVuaXRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNhbXBsZUFlc0RlY3J5cHRlcjtcbiIsIi8qKlxuICogaGlnaGx5IG9wdGltaXplZCBUUyBkZW11eGVyOlxuICogcGFyc2UgUEFULCBQTVRcbiAqIGV4dHJhY3QgUEVTIHBhY2tldCBmcm9tIGF1ZGlvIGFuZCB2aWRlbyBQSURzXG4gKiBleHRyYWN0IEFWQy9IMjY0IE5BTCB1bml0cyBhbmQgQUFDL0FEVFMgc2FtcGxlcyBmcm9tIFBFUyBwYWNrZXRcbiAqIHRyaWdnZXIgdGhlIHJlbXV4ZXIgdXBvbiBwYXJzaW5nIGNvbXBsZXRpb25cbiAqIGl0IGFsc28gdHJpZXMgdG8gd29ya2Fyb3VuZCBhcyBiZXN0IGFzIGl0IGNhbiBhdWRpbyBjb2RlYyBzd2l0Y2ggKEhFLUFBQyB0byBBQUMgYW5kIHZpY2UgdmVyc2EpLCB3aXRob3V0IGhhdmluZyB0byByZXN0YXJ0IHRoZSBNZWRpYVNvdXJjZS5cbiAqIGl0IGFsc28gY29udHJvbHMgdGhlIHJlbXV4aW5nIHByb2Nlc3MgOlxuICogdXBvbiBkaXNjb250aW51aXR5IG9yIGxldmVsIHN3aXRjaCBkZXRlY3Rpb24sIGl0IHdpbGwgYWxzbyBub3RpZmllcyB0aGUgcmVtdXhlciBzbyB0aGF0IGl0IGNhbiByZXNldCBpdHMgc3RhdGUuXG4gKi9cblxuaW1wb3J0ICogYXMgQURUUyBmcm9tICcuL2FkdHMnO1xuaW1wb3J0ICogYXMgTXBlZ0F1ZGlvIGZyb20gJy4vbXBlZ2F1ZGlvJztcbmltcG9ydCBFeHBHb2xvbWIgZnJvbSAnLi9leHAtZ29sb21iJztcbmltcG9ydCBTYW1wbGVBZXNEZWNyeXB0ZXIgZnJvbSAnLi9zYW1wbGUtYWVzJztcbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQge1xuICBhcHBlbmRVaW50OEFycmF5LFxuICBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSxcbiAgUmVtdXhlclRyYWNrSWRDb25maWcsXG59IGZyb20gJy4uL3V0aWxzL21wNC10b29scyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB0eXBlIHsgSGxzQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB0eXBlIHsgSGxzRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7XG4gIERlbXV4ZWRBdmNUcmFjayxcbiAgRGVtdXhlZEF1ZGlvVHJhY2ssXG4gIERlbXV4ZWRUcmFjayxcbiAgRGVtdXhlcixcbiAgRGVtdXhlclJlc3VsdCxcbiAgQXZjU2FtcGxlLFxuICBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gIEVsZW1lbnRhcnlTdHJlYW1EYXRhLFxuICBLZXlEYXRhLFxuICBNZXRhZGF0YVNjaGVtYSxcbn0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5pbXBvcnQgeyBBdWRpb0ZyYW1lIH0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5cbnR5cGUgUGFyc2VkVGltZXN0YW1wID0ge1xuICBwdHM/OiBudW1iZXI7XG4gIGR0cz86IG51bWJlcjtcbn07XG5cbnR5cGUgUEVTID0gUGFyc2VkVGltZXN0YW1wICYge1xuICBkYXRhOiBVaW50OEFycmF5O1xuICBsZW46IG51bWJlcjtcbn07XG5cbnR5cGUgUGFyc2VkQXZjU2FtcGxlID0gUGFyc2VkVGltZXN0YW1wICYgT21pdDxBdmNTYW1wbGUsICdwdHMnIHwgJ2R0cyc+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVTdXBwb3J0ZWQge1xuICBtcGVnOiBib29sZWFuO1xuICBtcDM6IGJvb2xlYW47XG4gIG1wNDogYm9vbGVhbjtcbn1cblxuY29uc3QgUEFDS0VUX0xFTkdUSCA9IDE4ODtcblxuY2xhc3MgVFNEZW11eGVyIGltcGxlbWVudHMgRGVtdXhlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgb2JzZXJ2ZXI6IEhsc0V2ZW50RW1pdHRlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBjb25maWc6IEhsc0NvbmZpZztcbiAgcHJpdmF0ZSB0eXBlU3VwcG9ydGVkOiBUeXBlU3VwcG9ydGVkO1xuXG4gIHByaXZhdGUgc2FtcGxlQWVzOiBTYW1wbGVBZXNEZWNyeXB0ZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBwbXRQYXJzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBhdWRpb0NvZGVjPzogc3RyaW5nO1xuICBwcml2YXRlIHZpZGVvQ29kZWM/OiBzdHJpbmc7XG4gIHByaXZhdGUgX2R1cmF0aW9uOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIF9wbXRJZDogbnVtYmVyID0gLTE7XG5cbiAgcHJpdmF0ZSBfYXZjVHJhY2s/OiBEZW11eGVkQXZjVHJhY2s7XG4gIHByaXZhdGUgX2F1ZGlvVHJhY2s/OiBEZW11eGVkQXVkaW9UcmFjaztcbiAgcHJpdmF0ZSBfaWQzVHJhY2s/OiBEZW11eGVkTWV0YWRhdGFUcmFjaztcbiAgcHJpdmF0ZSBfdHh0VHJhY2s/OiBEZW11eGVkVXNlcmRhdGFUcmFjaztcbiAgcHJpdmF0ZSBhYWNPdmVyRmxvdzogQXVkaW9GcmFtZSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGF2Y1NhbXBsZTogUGFyc2VkQXZjU2FtcGxlIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcmVtYWluZGVyRGF0YTogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXIsXG4gICAgY29uZmlnOiBIbHNDb25maWcsXG4gICAgdHlwZVN1cHBvcnRlZDogVHlwZVN1cHBvcnRlZFxuICApIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgfVxuXG4gIHN0YXRpYyBwcm9iZShkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgY29uc3Qgc3luY09mZnNldCA9IFRTRGVtdXhlci5zeW5jT2Zmc2V0KGRhdGEpO1xuICAgIGlmIChzeW5jT2Zmc2V0ID4gMCkge1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgIGBNUEVHMi1UUyBkZXRlY3RlZCBidXQgZmlyc3Qgc3luYyB3b3JkIGZvdW5kIEAgb2Zmc2V0ICR7c3luY09mZnNldH1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc3luY09mZnNldCAhPT0gLTE7XG4gIH1cblxuICBzdGF0aWMgc3luY09mZnNldChkYXRhOiBVaW50OEFycmF5KTogbnVtYmVyIHtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgc2NhbndpbmRvdyA9XG4gICAgICBNYXRoLm1pbihQQUNLRVRfTEVOR1RIICogNSwgZGF0YS5sZW5ndGggLSBQQUNLRVRfTEVOR1RIKSArIDE7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc2NhbndpbmRvdykge1xuICAgICAgLy8gYSBUUyBpbml0IHNlZ21lbnQgc2hvdWxkIGNvbnRhaW4gYXQgbGVhc3QgMiBUUyBwYWNrZXRzOiBQQVQgYW5kIFBNVCwgZWFjaCBzdGFydGluZyB3aXRoIDB4NDdcbiAgICAgIGxldCBmb3VuZFBhdCA9IGZhbHNlO1xuICAgICAgbGV0IHBhY2tldFN0YXJ0ID0gLTE7XG4gICAgICBsZXQgdHNQYWNrZXRzID0gMDtcbiAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgbGVuZ3RoOyBqICs9IFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgICAgaWYgKGRhdGFbal0gPT09IDB4NDcpIHtcbiAgICAgICAgICB0c1BhY2tldHMrKztcbiAgICAgICAgICBpZiAocGFja2V0U3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgICBwYWNrZXRTdGFydCA9IGo7XG4gICAgICAgICAgICAvLyBGaXJzdCBzeW5jIHdvcmQgZm91bmQgYXQgb2Zmc2V0LCBpbmNyZWFzZSBzY2FuIGxlbmd0aCAoIzUyNTEpXG4gICAgICAgICAgICBpZiAocGFja2V0U3RhcnQgIT09IDApIHtcbiAgICAgICAgICAgICAgc2NhbndpbmRvdyA9XG4gICAgICAgICAgICAgICAgTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICBwYWNrZXRTdGFydCArIFBBQ0tFVF9MRU5HVEggKiA5OSxcbiAgICAgICAgICAgICAgICAgIGRhdGEubGVuZ3RoIC0gUEFDS0VUX0xFTkdUSFxuICAgICAgICAgICAgICAgICkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kUGF0KSB7XG4gICAgICAgICAgICBmb3VuZFBhdCA9IHBhcnNlUElEKGRhdGEsIGopID09PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTeW5jIHdvcmQgZm91bmQgYXQgMCB3aXRoIDMgcGFja2V0cywgb3IgZm91bmQgYXQgb2Zmc2V0IGxlYXN0IDIgcGFja2V0cyB1cCB0byBzY2Fud2luZG93ICgjNTUwMSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmb3VuZFBhdCAmJlxuICAgICAgICAgICAgdHNQYWNrZXRzID4gMSAmJlxuICAgICAgICAgICAgKChwYWNrZXRTdGFydCA9PT0gMCAmJiB0c1BhY2tldHMgPiAyKSB8fFxuICAgICAgICAgICAgICBqICsgUEFDS0VUX0xFTkdUSCA+IHNjYW53aW5kb3cpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFja2V0U3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRzUGFja2V0cykge1xuICAgICAgICAgIC8vIEV4aXQgaWYgc3luYyB3b3JkIGZvdW5kLCBidXQgZG9lcyBub3QgY29udGFpbiBjb250aWd1b3VzIHBhY2tldHMgKCM1NTAxKVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRyYWNrIG1vZGVsIGludGVybmFsIHRvIGRlbXV4ZXIgdXNlZCB0byBkcml2ZSByZW11eGluZyBpbnB1dFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVRyYWNrKFxuICAgIHR5cGU6ICdhdWRpbycgfCAndmlkZW8nIHwgJ2lkMycgfCAndGV4dCcsXG4gICAgZHVyYXRpb24/OiBudW1iZXJcbiAgKTogRGVtdXhlZFRyYWNrIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGFpbmVyOlxuICAgICAgICB0eXBlID09PSAndmlkZW8nIHx8IHR5cGUgPT09ICdhdWRpbycgPyAndmlkZW8vbXAydCcgOiB1bmRlZmluZWQsXG4gICAgICB0eXBlLFxuICAgICAgaWQ6IFJlbXV4ZXJUcmFja0lkQ29uZmlnW3R5cGVdLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBkcm9wcGVkOiAwLFxuICAgICAgZHVyYXRpb246IHR5cGUgPT09ICdhdWRpbycgPyBkdXJhdGlvbiA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3IGluaXQgc2VnbWVudCBvbiB0aGUgZGVtdXhlci9yZW11eGVyIGludGVyZmFjZS4gTmVlZGVkIGZvciBkaXNjb250aW51aXRpZXMvdHJhY2stc3dpdGNoZXMgKG9yIGF0IHN0cmVhbSBzdGFydClcbiAgICogUmVzZXRzIGFsbCBpbnRlcm5hbCB0cmFjayBpbnN0YW5jZXMgb2YgdGhlIGRlbXV4ZXIuXG4gICAqL1xuICBwdWJsaWMgcmVzZXRJbml0U2VnbWVudChcbiAgICBpbml0U2VnbWVudDogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgICBhdWRpb0NvZGVjOiBzdHJpbmcsXG4gICAgdmlkZW9Db2RlYzogc3RyaW5nLFxuICAgIHRyYWNrRHVyYXRpb246IG51bWJlclxuICApIHtcbiAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BtdElkID0gLTE7XG5cbiAgICB0aGlzLl9hdmNUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndmlkZW8nKSBhcyBEZW11eGVkQXZjVHJhY2s7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjayhcbiAgICAgICdhdWRpbycsXG4gICAgICB0cmFja0R1cmF0aW9uXG4gICAgKSBhcyBEZW11eGVkQXVkaW9UcmFjaztcbiAgICB0aGlzLl9pZDNUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygnaWQzJykgYXMgRGVtdXhlZE1ldGFkYXRhVHJhY2s7XG4gICAgdGhpcy5fdHh0VHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ3RleHQnKSBhcyBEZW11eGVkVXNlcmRhdGFUcmFjaztcbiAgICB0aGlzLl9hdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9ICdhYWMnO1xuXG4gICAgLy8gZmx1c2ggYW55IHBhcnRpYWwgY29udGVudFxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRyYWNrRHVyYXRpb247XG4gIH1cblxuICBwdWJsaWMgcmVzZXRUaW1lU3RhbXAoKSB7fVxuXG4gIHB1YmxpYyByZXNldENvbnRpZ3VpdHkoKTogdm9pZCB7XG4gICAgY29uc3QgeyBfYXVkaW9UcmFjaywgX2F2Y1RyYWNrLCBfaWQzVHJhY2sgfSA9IHRoaXM7XG4gICAgaWYgKF9hdWRpb1RyYWNrKSB7XG4gICAgICBfYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKF9hdmNUcmFjaykge1xuICAgICAgX2F2Y1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoX2lkM1RyYWNrKSB7XG4gICAgICBfaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICB9XG5cbiAgcHVibGljIGRlbXV4KFxuICAgIGRhdGE6IFVpbnQ4QXJyYXksXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGlzU2FtcGxlQWVzID0gZmFsc2UsXG4gICAgZmx1c2ggPSBmYWxzZVxuICApOiBEZW11eGVyUmVzdWx0IHtcbiAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHBlczogUEVTIHwgbnVsbDtcblxuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLl9hdmNUcmFjayBhcyBEZW11eGVkQXZjVHJhY2s7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMuX2F1ZGlvVHJhY2sgYXMgRGVtdXhlZEF1ZGlvVHJhY2s7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjayBhcyBEZW11eGVkTWV0YWRhdGFUcmFjaztcbiAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLl90eHRUcmFjayBhcyBEZW11eGVkVXNlcmRhdGFUcmFjaztcblxuICAgIGxldCBhdmNJZCA9IHZpZGVvVHJhY2sucGlkO1xuICAgIGxldCBhdmNEYXRhID0gdmlkZW9UcmFjay5wZXNEYXRhO1xuICAgIGxldCBhdWRpb0lkID0gYXVkaW9UcmFjay5waWQ7XG4gICAgbGV0IGlkM0lkID0gaWQzVHJhY2sucGlkO1xuICAgIGxldCBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGE7XG4gICAgbGV0IGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhO1xuICAgIGxldCB1bmtub3duUElEOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQ7XG4gICAgbGV0IHBtdElkID0gdGhpcy5fcG10SWQ7XG5cbiAgICBsZXQgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKHRoaXMucmVtYWluZGVyRGF0YSkge1xuICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobGVuIDwgUEFDS0VUX0xFTkdUSCAmJiAhZmx1c2gpIHtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IGRhdGE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdWRpb1RyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICBpZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBzeW5jT2Zmc2V0ID0gTWF0aC5tYXgoMCwgVFNEZW11eGVyLnN5bmNPZmZzZXQoZGF0YSkpO1xuICAgIGxlbiAtPSAobGVuIC0gc3luY09mZnNldCkgJSBQQUNLRVRfTEVOR1RIO1xuICAgIGlmIChsZW4gPCBkYXRhLmJ5dGVMZW5ndGggJiYgIWZsdXNoKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgZGF0YS5idWZmZXIsXG4gICAgICAgIGxlbixcbiAgICAgICAgZGF0YS5idWZmZXIuYnl0ZUxlbmd0aCAtIGxlblxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBsb29wIHRocm91Z2ggVFMgcGFja2V0c1xuICAgIGxldCB0c1BhY2tldEVycm9ycyA9IDA7XG4gICAgZm9yIChsZXQgc3RhcnQgPSBzeW5jT2Zmc2V0OyBzdGFydCA8IGxlbjsgc3RhcnQgKz0gUEFDS0VUX0xFTkdUSCkge1xuICAgICAgaWYgKGRhdGFbc3RhcnRdID09PSAweDQ3KSB7XG4gICAgICAgIGNvbnN0IHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICBjb25zdCBwaWQgPSBwYXJzZVBJRChkYXRhLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xuXG4gICAgICAgIC8vIGlmIGFuIGFkYXB0aW9uIGZpZWxkIGlzIHByZXNlbnQsIGl0cyBsZW5ndGggaXMgc3BlY2lmaWVkIGJ5IHRoZSBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLlxuICAgICAgICBsZXQgb2Zmc2V0OiBudW1iZXI7XG4gICAgICAgIGlmIChhdGYgPiAxKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdO1xuICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHRoZXJlIGlzIG9ubHkgYWRhcHRhdGlvbiBmaWVsZFxuICAgICAgICAgIGlmIChvZmZzZXQgPT09IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBpZCkge1xuICAgICAgICAgIGNhc2UgYXZjSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQVZDUEVTKHZpZGVvVHJhY2ssIHRleHRUcmFjaywgcGVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhdmNEYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF2Y0RhdGEpIHtcbiAgICAgICAgICAgICAgYXZjRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCkpO1xuICAgICAgICAgICAgICBhdmNEYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhdWRpb0lkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2FhYyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBQUNQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTVBFR1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXVkaW9EYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgICBhdWRpb0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZDNJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VJRDNQRVMoaWQzVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZDNEYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkM0RhdGEpIHtcbiAgICAgICAgICAgICAgaWQzRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCkpO1xuICAgICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCA9IHBhcnNlUEFUKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdQTVQgUElEOicgICsgdGhpcy5fcG10SWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBwbXRJZDoge1xuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcGFyc2VkUElEcyA9IHBhcnNlUE1UKFxuICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgIHRoaXMudHlwZVN1cHBvcnRlZCxcbiAgICAgICAgICAgICAgaXNTYW1wbGVBZXNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIHRyYWNrIGlkIGlmIHRyYWNrIFBJRCBmb3VuZCB3aGlsZSBwYXJzaW5nIFBNVFxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZXNldHRpbmcgdGhlIFBJRCB0byAtMSBpbiBjYXNlXG4gICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGluIGNhc2Ugb2YgdHJhbnNpZW50IG1pc3NpbmcgYXVkaW8gc2FtcGxlcyBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgLy8gTk9URSB0aGlzIGlzIG9ubHkgdGhlIFBJRCBvZiB0aGUgdHJhY2sgYXMgZm91bmQgaW4gVFMsXG4gICAgICAgICAgICAvLyBidXQgd2UgYXJlIG5vdCB1c2luZyB0aGlzIGZvciBNUDQgdHJhY2sgSURzLlxuICAgICAgICAgICAgYXZjSWQgPSBwYXJzZWRQSURzLmF2YztcbiAgICAgICAgICAgIGlmIChhdmNJZCA+IDApIHtcbiAgICAgICAgICAgICAgdmlkZW9UcmFjay5waWQgPSBhdmNJZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXVkaW9JZCA9IHBhcnNlZFBJRHMuYXVkaW87XG4gICAgICAgICAgICBpZiAoYXVkaW9JZCA+IDApIHtcbiAgICAgICAgICAgICAgYXVkaW9UcmFjay5waWQgPSBhdWRpb0lkO1xuICAgICAgICAgICAgICBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9IHBhcnNlZFBJRHMuc2VnbWVudENvZGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWQzSWQgPSBwYXJzZWRQSURzLmlkMztcbiAgICAgICAgICAgIGlmIChpZDNJZCA+IDApIHtcbiAgICAgICAgICAgICAgaWQzVHJhY2sucGlkID0gaWQzSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1bmtub3duUElEICE9PSBudWxsICYmICFwbXRQYXJzZWQpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgYE1QRUctVFMgUE1UIGZvdW5kIGF0ICR7c3RhcnR9IGFmdGVyIHVua25vd24gUElEICcke3Vua25vd25QSUR9Jy4gQmFja3RyYWNraW5nIHRvIHN5bmMgYnl0ZSBAJHtzeW5jT2Zmc2V0fSB0byBwYXJzZSBhbGwgVFMgcGFja2V0cy5gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHVua25vd25QSUQgPSBudWxsO1xuICAgICAgICAgICAgICAvLyB3ZSBzZXQgaXQgdG8gLTE4OCwgdGhlICs9IDE4OCBpbiB0aGUgZm9yIGxvb3Agd2lsbCByZXNldCBzdGFydCB0byAwXG4gICAgICAgICAgICAgIHN0YXJ0ID0gc3luY09mZnNldCAtIDE4ODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDB4MTE6XG4gICAgICAgICAgY2FzZSAweDFmZmY6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdW5rbm93blBJRCA9IHBpZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0c1BhY2tldEVycm9ycysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0c1BhY2tldEVycm9ycyA+IDApIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBgRm91bmQgJHt0c1BhY2tldEVycm9yc30gVFMgcGFja2V0L3MgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCAweDQ3YFxuICAgICAgKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yLFxuICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2aWRlb1RyYWNrLnBlc0RhdGEgPSBhdmNEYXRhO1xuICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcblxuICAgIGNvbnN0IGRlbXV4UmVzdWx0OiBEZW11eGVyUmVzdWx0ID0ge1xuICAgICAgYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjayxcbiAgICB9O1xuXG4gICAgaWYgKGZsdXNoKSB7XG4gICAgICB0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKGRlbXV4UmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVtdXhSZXN1bHQ7XG4gIH1cblxuICBwdWJsaWMgZmx1c2goKTogRGVtdXhlclJlc3VsdCB8IFByb21pc2U8RGVtdXhlclJlc3VsdD4ge1xuICAgIGNvbnN0IHsgcmVtYWluZGVyRGF0YSB9ID0gdGhpcztcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIGxldCByZXN1bHQ6IERlbXV4ZXJSZXN1bHQ7XG4gICAgaWYgKHJlbWFpbmRlckRhdGEpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuZGVtdXgocmVtYWluZGVyRGF0YSwgLTEsIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB2aWRlb1RyYWNrOiB0aGlzLl9hdmNUcmFjayBhcyBEZW11eGVkQXZjVHJhY2ssXG4gICAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2sgYXMgRGVtdXhlZEF1ZGlvVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrOiB0aGlzLl9pZDNUcmFjayBhcyBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrOiB0aGlzLl90eHRUcmFjayBhcyBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMocmVzdWx0KTtcbiAgICBpZiAodGhpcy5zYW1wbGVBZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY3J5cHQocmVzdWx0LCB0aGlzLnNhbXBsZUFlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKGRlbXV4UmVzdWx0OiBEZW11eGVyUmVzdWx0KSB7XG4gICAgY29uc3QgeyBhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrIH0gPSBkZW11eFJlc3VsdDtcbiAgICBjb25zdCBhdmNEYXRhID0gdmlkZW9UcmFjay5wZXNEYXRhO1xuICAgIGNvbnN0IGF1ZGlvRGF0YSA9IGF1ZGlvVHJhY2sucGVzRGF0YTtcbiAgICBjb25zdCBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YTtcbiAgICAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuICAgIGxldCBwZXM6IFBFUyB8IG51bGw7XG4gICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSkge1xuICAgICAgdGhpcy5wYXJzZUFWQ1BFUyhcbiAgICAgICAgdmlkZW9UcmFjayBhcyBEZW11eGVkQXZjVHJhY2ssXG4gICAgICAgIHRleHRUcmFjayBhcyBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICAgICAgcGVzLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgICAgdmlkZW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWl0aGVyIGF2Y0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgdmlkZW9UcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICB9XG5cbiAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSkge1xuICAgICAgc3dpdGNoIChhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgIHRoaXMucGFyc2VBQUNQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICB0aGlzLnBhcnNlTVBFR1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGF1ZGlvRGF0YT8uc2l6ZSkge1xuICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICdsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBlaXRoZXIgYXVkaW9EYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICB9XG5cbiAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpKSB7XG4gICAgICB0aGlzLnBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpO1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBpZDNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBpZDNEYXRhO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZW11eFNhbXBsZUFlcyhcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtleURhdGE6IEtleURhdGEsXG4gICAgdGltZU9mZnNldDogbnVtYmVyXG4gICk6IFByb21pc2U8RGVtdXhlclJlc3VsdD4ge1xuICAgIGNvbnN0IGRlbXV4UmVzdWx0ID0gdGhpcy5kZW11eChcbiAgICAgIGRhdGEsXG4gICAgICB0aW1lT2Zmc2V0LFxuICAgICAgdHJ1ZSxcbiAgICAgICF0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZVxuICAgICk7XG4gICAgY29uc3Qgc2FtcGxlQWVzID0gKHRoaXMuc2FtcGxlQWVzID0gbmV3IFNhbXBsZUFlc0RlY3J5cHRlcihcbiAgICAgIHRoaXMub2JzZXJ2ZXIsXG4gICAgICB0aGlzLmNvbmZpZyxcbiAgICAgIGtleURhdGFcbiAgICApKTtcbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0KGRlbXV4UmVzdWx0LCBzYW1wbGVBZXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBkZWNyeXB0KFxuICAgIGRlbXV4UmVzdWx0OiBEZW11eGVyUmVzdWx0LFxuICAgIHNhbXBsZUFlczogU2FtcGxlQWVzRGVjcnlwdGVyXG4gICk6IFByb21pc2U8RGVtdXhlclJlc3VsdD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgeyBhdWRpb1RyYWNrLCB2aWRlb1RyYWNrIH0gPSBkZW11eFJlc3VsdDtcbiAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QWFjU2FtcGxlcyhhdWRpb1RyYWNrLnNhbXBsZXMsIDAsICgpID0+IHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XG4gICAgICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZUFWQ1BFUyhcbiAgICB0cmFjazogRGVtdXhlZEF2Y1RyYWNrLFxuICAgIHRleHRUcmFjazogRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gICAgcGVzOiBQRVMsXG4gICAgbGFzdDogYm9vbGVhblxuICApIHtcbiAgICBjb25zdCB1bml0cyA9IHRoaXMucGFyc2VBVkNOQUx1KHRyYWNrLCBwZXMuZGF0YSk7XG4gICAgY29uc3QgZGVidWcgPSBmYWxzZTtcbiAgICBsZXQgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGU7XG4gICAgbGV0IHB1c2g6IGJvb2xlYW47XG4gICAgbGV0IHNwc2ZvdW5kID0gZmFsc2U7XG4gICAgLy8gZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XG4gICAgKHBlcyBhcyBhbnkpLmRhdGEgPSBudWxsO1xuXG4gICAgLy8gaWYgbmV3IE5BTCB1bml0cyBmb3VuZCBhbmQgbGFzdCBzYW1wbGUgc3RpbGwgdGhlcmUsIGxldCdzIHB1c2ggLi4uXG4gICAgLy8gdGhpcyBoZWxwcyBwYXJzaW5nIHN0cmVhbXMgd2l0aCBtaXNzaW5nIEFVRCAob25seSBkbyB0aGlzIGlmIEFVRCBuZXZlciBmb3VuZClcbiAgICBpZiAoYXZjU2FtcGxlICYmIHVuaXRzLmxlbmd0aCAmJiAhdHJhY2suYXVkRm91bmQpIHtcbiAgICAgIHB1c2hBY2Nlc3NVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICB9XG5cbiAgICB1bml0cy5mb3JFYWNoKCh1bml0KSA9PiB7XG4gICAgICBzd2l0Y2ggKHVuaXQudHlwZSkge1xuICAgICAgICAvLyBORFJcbiAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgaWYgKCFhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKFxuICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICBwZXMucHRzLFxuICAgICAgICAgICAgICBwZXMuZHRzLFxuICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnTkRSICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gdW5pdC5kYXRhO1xuICAgICAgICAgIC8vIG9ubHkgY2hlY2sgc2xpY2UgdHlwZSB0byBkZXRlY3QgS0YgaW4gY2FzZSBTUFMgZm91bmQgaW4gc2FtZSBwYWNrZXQgKGFueSBrZXlmcmFtZSBpcyBwcmVjZWRlZCBieSBTUFMgLi4uKVxuICAgICAgICAgIGlmIChzcHNmb3VuZCAmJiBkYXRhLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIHJldHJpZXZlIHNsaWNlIHR5cGUgYnkgcGFyc2luZyBiZWdpbm5pbmcgb2YgTkFMIHVuaXQgKGZvbGxvdyBIMjY0IHNwZWMsIHNsaWNlX2hlYWRlciBkZWZpbml0aW9uKSB0byBkZXRlY3Qga2V5ZnJhbWUgZW1iZWRkZWQgaW4gTkRSXG4gICAgICAgICAgICBjb25zdCBzbGljZVR5cGUgPSBuZXcgRXhwR29sb21iKGRhdGEpLnJlYWRTbGljZVR5cGUoKTtcbiAgICAgICAgICAgIC8vIDIgOiBJIHNsaWNlLCA0IDogU0kgc2xpY2UsIDcgOiBJIHNsaWNlLCA5OiBTSSBzbGljZVxuICAgICAgICAgICAgLy8gU0kgc2xpY2UgOiBBIHNsaWNlIHRoYXQgaXMgY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5IGFuZCB1c2luZyBxdWFudGlzYXRpb24gb2YgdGhlIHByZWRpY3Rpb24gc2FtcGxlcy5cbiAgICAgICAgICAgIC8vIEFuIFNJIHNsaWNlIGNhbiBiZSBjb2RlZCBzdWNoIHRoYXQgaXRzIGRlY29kZWQgc2FtcGxlcyBjYW4gYmUgY29uc3RydWN0ZWQgaWRlbnRpY2FsbHkgdG8gYW4gU1Agc2xpY2UuXG4gICAgICAgICAgICAvLyBJIHNsaWNlOiBBIHNsaWNlIHRoYXQgaXMgbm90IGFuIFNJIHNsaWNlIHRoYXQgaXMgZGVjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkuXG4gICAgICAgICAgICAvLyBpZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzbGljZVR5cGUgPT09IDIgfHxcbiAgICAgICAgICAgICAgc2xpY2VUeXBlID09PSA0IHx8XG4gICAgICAgICAgICAgIHNsaWNlVHlwZSA9PT0gNyB8fFxuICAgICAgICAgICAgICBzbGljZVR5cGUgPT09IDlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gSURSXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIC8vIGhhbmRsZSBQRVMgbm90IHN0YXJ0aW5nIHdpdGggQVVEXG4gICAgICAgICAgaWYgKCFhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKFxuICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICBwZXMucHRzLFxuICAgICAgICAgICAgICBwZXMuZHRzLFxuICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnSURSICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU0VJXG4gICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU0VJICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KFxuICAgICAgICAgICAgdW5pdC5kYXRhLFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIHBlcy5wdHMgYXMgbnVtYmVyLFxuICAgICAgICAgICAgdGV4dFRyYWNrLnNhbXBsZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIFNQU1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBzcHNmb3VuZCA9IHRydWU7XG4gICAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTUFMgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRyYWNrLnNwcykge1xuICAgICAgICAgICAgY29uc3Qgc3BzID0gdW5pdC5kYXRhO1xuICAgICAgICAgICAgY29uc3QgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIoc3BzKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdHJhY2suc3BzID0gW3Nwc107XG4gICAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgY29kZWNhcnJheSA9IHNwcy5zdWJhcnJheSgxLCA0KTtcbiAgICAgICAgICAgIGxldCBjb2RlY3N0cmluZyA9ICdhdmMxLic7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb2RlY3N0cmluZyArPSBoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2suY29kZWMgPSBjb2RlY3N0cmluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFBQU1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdQUFMgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRyYWNrLnBwcykge1xuICAgICAgICAgICAgdHJhY2sucHBzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFVRFxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgIHRyYWNrLmF1ZEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBwdXNoQWNjZXNzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZShcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgcGVzLnB0cyxcbiAgICAgICAgICAgIHBlcy5kdHMsXG4gICAgICAgICAgICBkZWJ1ZyA/ICdBVUQgJyA6ICcnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmlsbGVyIERhdGFcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICd1bmtub3duIE5BTCAnICsgdW5pdC50eXBlICsgJyAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGF2Y1NhbXBsZSAmJiBwdXNoKSB7XG4gICAgICAgIGNvbnN0IHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xuICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXG4gICAgaWYgKGxhc3QgJiYgYXZjU2FtcGxlKSB7XG4gICAgICBwdXNoQWNjZXNzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldExhc3ROYWxVbml0KHNhbXBsZXM6IEF2Y1NhbXBsZVtdKSB7XG4gICAgbGV0IGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlO1xuICAgIGxldCBsYXN0VW5pdDtcbiAgICAvLyB0cnkgdG8gZmFsbGJhY2sgdG8gcHJldmlvdXMgc2FtcGxlIGlmIGN1cnJlbnQgb25lIGlzIGVtcHR5XG4gICAgaWYgKCFhdmNTYW1wbGUgfHwgYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXZjU2FtcGxlID0gc2FtcGxlc1tzYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBpZiAoYXZjU2FtcGxlPy51bml0cykge1xuICAgICAgY29uc3QgdW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICBsYXN0VW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdFVuaXQ7XG4gIH1cblxuICBwcml2YXRlIHBhcnNlQVZDTkFMdShcbiAgICB0cmFjazogRGVtdXhlZEF2Y1RyYWNrLFxuICAgIGFycmF5OiBVaW50OEFycmF5XG4gICk6IEFycmF5PHtcbiAgICBkYXRhOiBVaW50OEFycmF5O1xuICAgIHR5cGU6IG51bWJlcjtcbiAgICBzdGF0ZT86IG51bWJlcjtcbiAgfT4ge1xuICAgIGNvbnN0IGxlbiA9IGFycmF5LmJ5dGVMZW5ndGg7XG4gICAgbGV0IHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDA7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gc3RhdGU7XG4gICAgY29uc3QgdW5pdHMgPSBbXSBhcyBBcnJheTx7XG4gICAgICBkYXRhOiBVaW50OEFycmF5O1xuICAgICAgdHlwZTogbnVtYmVyO1xuICAgICAgc3RhdGU/OiBudW1iZXI7XG4gICAgfT47XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCB2YWx1ZTtcbiAgICBsZXQgb3ZlcmZsb3c7XG4gICAgbGV0IHVuaXRUeXBlO1xuICAgIGxldCBsYXN0VW5pdFN0YXJ0ID0gLTE7XG4gICAgbGV0IGxhc3RVbml0VHlwZTogbnVtYmVyID0gMDtcbiAgICAvLyBsb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG5cbiAgICBpZiAoc3RhdGUgPT09IC0xKSB7XG4gICAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XG4gICAgICBsYXN0VW5pdFN0YXJ0ID0gMDtcbiAgICAgIC8vIE5BTHUgdHlwZSBpcyB2YWx1ZSByZWFkIGZyb20gb2Zmc2V0IDBcbiAgICAgIGxhc3RVbml0VHlwZSA9IGFycmF5WzBdICYgMHgxZjtcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGkgPSAxO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB2YWx1ZSA9IGFycmF5W2krK107XG4gICAgICAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxuICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDApIHtcbiAgICAgICAgICBjb25zdCB1bml0ID0ge1xuICAgICAgICAgICAgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgaSAtIHN0YXRlIC0gMSksXG4gICAgICAgICAgICB0eXBlOiBsYXN0VW5pdFR5cGUsXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGFzdFVuaXRTdGFydCBpcyB1bmRlZmluZWQgPT4gdGhpcyBpcyB0aGUgZmlyc3Qgc3RhcnQgY29kZSBmb3VuZCBpbiB0aGlzIFBFUyBwYWNrZXRcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXG4gICAgICAgICAgLy8gaWUgaXQgc3RhcnRlZCBpbiBsYXN0IHBhY2tldCAobGFzdFN0YXRlIG5vdCB6ZXJvKVxuICAgICAgICAgIC8vIGFuZCBlbmRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgUEVTIHBhY2tldCAoaSA8PSA0IC0gbGFzdFN0YXRlKVxuICAgICAgICAgIGNvbnN0IGxhc3RVbml0ID0gdGhpcy5nZXRMYXN0TmFsVW5pdCh0cmFjay5zYW1wbGVzKTtcbiAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3RhdGUgJiYgaSA8PSA0IC0gbGFzdFN0YXRlKSB7XG4gICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgIC8vIHN0cmlwIHN0YXJ0IGRlbGltaXRlciBieXRlcyBmcm9tIHRoZSBlbmQgb2YgbGFzdCBOQUwgdW5pdFxuICAgICAgICAgICAgICAvLyBjaGVjayBpZiBsYXN0VW5pdCBoYWQgYSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSB6ZXJvXG4gICAgICAgICAgICAgIGlmIChsYXN0VW5pdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxhc3QgYnl0ZXNcbiAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheShcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBOQUwgdW5pdHMgYXJlIG5vdCBzdGFydGluZyByaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGFja2V0LCBwdXNoIHByZWNlZGluZyBkYXRhIGludG8gcHJldmlvdXMgTkFMIHVuaXQuXG4gICAgICAgICAgICBvdmVyZmxvdyA9IGkgLSBzdGF0ZSAtIDE7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3cgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpcnN0IE5BTFUgZm91bmQgd2l0aCBvdmVyZmxvdzonICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgICAgICAgIHRtcC5zZXQoYXJyYXkuc3ViYXJyYXkoMCwgb3ZlcmZsb3cpLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgICAgICAgICBsYXN0VW5pdC5zdGF0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiByZWFkIHVuaXQgdHlwZVxuICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgIHVuaXRUeXBlID0gYXJyYXlbaV0gJiAweDFmO1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpbmQgTkFMVSBAIG9mZnNldDonICsgaSArICcsdHlwZTonICsgdW5pdFR5cGUpO1xuICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xuICAgICAgICAgIGxhc3RVbml0VHlwZSA9IHVuaXRUeXBlO1xuICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBub3QgZW5vdWdoIGJ5dGUgdG8gcmVhZCB1bml0IHR5cGUuIGxldCdzIHJlYWQgaXQgb24gbmV4dCBQRVMgcGFyc2luZ1xuICAgICAgICAgIHN0YXRlID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCAmJiBzdGF0ZSA+PSAwKSB7XG4gICAgICBjb25zdCB1bml0ID0ge1xuICAgICAgICBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLFxuICAgICAgICB0eXBlOiBsYXN0VW5pdFR5cGUsXG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIH07XG4gICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgLy8gbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemUvc3RhdGU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgJy8nICsgc3RhdGUpO1xuICAgIH1cbiAgICAvLyBubyBOQUx1IGZvdW5kXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gYXBwZW5kIHBlcy5kYXRhIHRvIHByZXZpb3VzIE5BTCB1bml0XG4gICAgICBjb25zdCBsYXN0VW5pdCA9IHRoaXMuZ2V0TGFzdE5hbFVuaXQodHJhY2suc2FtcGxlcyk7XG4gICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgYXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgIHRtcC5zZXQoYXJyYXksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWNrLm5hbHVTdGF0ZSA9IHN0YXRlO1xuICAgIHJldHVybiB1bml0cztcbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VBQUNQRVModHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLCBwZXM6IFBFUykge1xuICAgIGxldCBzdGFydE9mZnNldCA9IDA7XG4gICAgY29uc3QgYWFjT3ZlckZsb3cgPSB0aGlzLmFhY092ZXJGbG93O1xuICAgIGxldCBkYXRhID0gcGVzLmRhdGE7XG4gICAgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICAgIGNvbnN0IGZyYW1lTWlzc2luZ0J5dGVzID0gYWFjT3ZlckZsb3cubWlzc2luZztcbiAgICAgIGNvbnN0IHNhbXBsZUxlbmd0aCA9IGFhY092ZXJGbG93LnNhbXBsZS51bml0LmJ5dGVMZW5ndGg7XG4gICAgICAvLyBsb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke3NhbXBsZUxlbmd0aH0gYnl0ZXMgdG8gYmVnaW5uaW5nIG9mIG5ldyBQRVNgKTtcbiAgICAgIGlmIChmcmFtZU1pc3NpbmdCeXRlcyA9PT0gLTEpIHtcbiAgICAgICAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkoc2FtcGxlTGVuZ3RoICsgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdG1wLnNldChhYWNPdmVyRmxvdy5zYW1wbGUudW5pdCwgMCk7XG4gICAgICAgIHRtcC5zZXQoZGF0YSwgc2FtcGxlTGVuZ3RoKTtcbiAgICAgICAgZGF0YSA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZyYW1lT3ZlcmZsb3dCeXRlcyA9IHNhbXBsZUxlbmd0aCAtIGZyYW1lTWlzc2luZ0J5dGVzO1xuICAgICAgICBhYWNPdmVyRmxvdy5zYW1wbGUudW5pdC5zZXQoXG4gICAgICAgICAgZGF0YS5zdWJhcnJheSgwLCBmcmFtZU1pc3NpbmdCeXRlcyksXG4gICAgICAgICAgZnJhbWVPdmVyZmxvd0J5dGVzXG4gICAgICAgICk7XG4gICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNPdmVyRmxvdy5zYW1wbGUpO1xuICAgICAgICBzdGFydE9mZnNldCA9IGFhY092ZXJGbG93Lm1pc3Npbmc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgbGV0IG9mZnNldDogbnVtYmVyO1xuICAgIGxldCBsZW46IG51bWJlcjtcbiAgICBmb3IgKG9mZnNldCA9IHN0YXJ0T2Zmc2V0LCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChBRFRTLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIEFEVFMgaGVhZGVyIGRvZXMgbm90IHN0YXJ0IHN0cmFpZ2h0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBheWxvYWQsIHJhaXNlIGFuIGVycm9yXG4gICAgaWYgKG9mZnNldCAhPT0gc3RhcnRPZmZzZXQpIHtcbiAgICAgIGxldCByZWFzb246IHN0cmluZztcbiAgICAgIGNvbnN0IHJlY292ZXJhYmxlID0gb2Zmc2V0IDwgbGVuIC0gMTtcbiAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICByZWFzb24gPSBgQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OiR7b2Zmc2V0fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFzb24gPSAnTm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFUyc7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgbG9nZ2VyLndhcm4oYHBhcnNpbmcgZXJyb3I6ICR7cmVhc29ufWApO1xuICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgbGV2ZWxSZXRyeTogcmVjb3ZlcmFibGUsXG4gICAgICAgIGVycm9yLFxuICAgICAgICByZWFzb24sXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVjb3ZlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIEFEVFMuaW5pdFRyYWNrQ29uZmlnKFxuICAgICAgdHJhY2ssXG4gICAgICB0aGlzLm9ic2VydmVyLFxuICAgICAgZGF0YSxcbiAgICAgIG9mZnNldCxcbiAgICAgIHRoaXMuYXVkaW9Db2RlYyBhcyBzdHJpbmdcbiAgICApO1xuXG4gICAgbGV0IHB0czogbnVtYmVyO1xuICAgIGlmIChwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHB0cyA9IHBlcy5wdHM7XG4gICAgfSBlbHNlIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgLy8gaWYgbGFzdCBBQUMgZnJhbWUgaXMgb3ZlcmZsb3dpbmcsIHdlIHNob3VsZCBlbnN1cmUgdGltZXN0YW1wcyBhcmUgY29udGlndW91czpcbiAgICAgIC8vIGZpcnN0IHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGZyYW1lRHVyYXRpb25cbiAgICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSBBRFRTLmdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSBhcyBudW1iZXIpO1xuICAgICAgcHRzID0gYWFjT3ZlckZsb3cuc2FtcGxlLnB0cyArIGZyYW1lRHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogQUFDIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNjYW4gZm9yIGFhYyBzYW1wbGVzXG4gICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgIGxldCBmcmFtZTtcbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICBpZiAoIWZyYW1lLm1pc3NpbmcpIHtcbiAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICBpZiAoQURUUy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBmcmFtZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZU1QRUdQRVModHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLCBwZXM6IFBFUykge1xuICAgIGNvbnN0IGRhdGEgPSBwZXMuZGF0YTtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgZnJhbWVJbmRleCA9IDA7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgcHRzID0gcGVzLnB0cztcbiAgICBpZiAocHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogTVBFRyBQRVMgdW5rbm93biBQVFMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoTXBlZ0F1ZGlvLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBNcGVnQXVkaW8uYXBwZW5kRnJhbWUoXG4gICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgcHRzLFxuICAgICAgICAgIGZyYW1lSW5kZXhcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnVW5hYmxlIHRvIHBhcnNlIE1wZWcgYXVkaW8gZnJhbWUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VJRDNQRVMoaWQzVHJhY2s6IERlbXV4ZWRNZXRhZGF0YVRyYWNrLCBwZXM6IFBFUykge1xuICAgIGlmIChwZXMucHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogSUQzIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpZDNTYW1wbGUgPSBPYmplY3QuYXNzaWduKHt9LCBwZXMgYXMgUmVxdWlyZWQ8UEVTPiwge1xuICAgICAgdHlwZTogdGhpcy5fYXZjVHJhY2sgPyBNZXRhZGF0YVNjaGVtYS5lbXNnIDogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIH0pO1xuICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaChpZDNTYW1wbGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFWQ1NhbXBsZShcbiAga2V5OiBib29sZWFuLFxuICBwdHM6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgZHRzOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gIGRlYnVnOiBzdHJpbmdcbik6IFBhcnNlZEF2Y1NhbXBsZSB7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIGZyYW1lOiBmYWxzZSxcbiAgICBwdHMsXG4gICAgZHRzLFxuICAgIHVuaXRzOiBbXSxcbiAgICBkZWJ1ZyxcbiAgICBsZW5ndGg6IDAsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlUElEKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgLy8gcGlkIGlzIGEgMTMtYml0IGZpZWxkIHN0YXJ0aW5nIGF0IHRoZSBsYXN0IGJpdCBvZiBUU1sxXVxuICByZXR1cm4gKChkYXRhW29mZnNldCArIDFdICYgMHgxZikgPDwgOCkgKyBkYXRhW29mZnNldCArIDJdO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBBVChkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcbiAgcmV0dXJuICgoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDFmKSA8PCA4KSB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBNVChcbiAgZGF0YTogVWludDhBcnJheSxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHR5cGVTdXBwb3J0ZWQ6IFR5cGVTdXBwb3J0ZWQsXG4gIGlzU2FtcGxlQWVzOiBib29sZWFuXG4pIHtcbiAgY29uc3QgcmVzdWx0ID0geyBhdWRpbzogLTEsIGF2YzogLTEsIGlkMzogLTEsIHNlZ21lbnRDb2RlYzogJ2FhYycgfTtcbiAgY29uc3Qgc2VjdGlvbkxlbmd0aCA9ICgoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAyXTtcbiAgY29uc3QgdGFibGVFbmQgPSBvZmZzZXQgKyAzICsgc2VjdGlvbkxlbmd0aCAtIDQ7XG4gIC8vIHRvIGRldGVybWluZSB3aGVyZSB0aGUgdGFibGUgaXMsIHdlIGhhdmUgdG8gZmlndXJlIG91dCBob3dcbiAgLy8gbG9uZyB0aGUgcHJvZ3JhbSBpbmZvIGRlc2NyaXB0b3JzIGFyZVxuICBjb25zdCBwcm9ncmFtSW5mb0xlbmd0aCA9XG4gICAgKChkYXRhW29mZnNldCArIDEwXSAmIDB4MGYpIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gIC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcbiAgb2Zmc2V0ICs9IDEyICsgcHJvZ3JhbUluZm9MZW5ndGg7XG4gIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgIGNvbnN0IHBpZCA9IHBhcnNlUElEKGRhdGEsIG9mZnNldCk7XG4gICAgc3dpdGNoIChkYXRhW29mZnNldF0pIHtcbiAgICAgIGNhc2UgMHhjZjogLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICAgICAnQURUUyBBQUMgd2l0aCBBRVMtMTI4LUNCQyBmcmFtZSBlbmNyeXB0aW9uIGZvdW5kIGluIHVuZW5jcnlwdGVkIHN0cmVhbSdcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIDB4MGY6IC8vIElTTy9JRUMgMTM4MTgtNyBBRFRTIEFBQyAoTVBFRy0yIGxvd2VyIGJpdC1yYXRlIGF1ZGlvKVxuICAgICAgICAvLyBsb2dnZXIubG9nKCdBQUMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gUGFja2V0aXplZCBtZXRhZGF0YSAoSUQzKVxuICAgICAgY2FzZSAweDE1OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmlkMyA9IHBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4ZGI6IC8vIFNBTVBMRS1BRVMgQVZDXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgJ0guMjY0IHdpdGggQUVTLTEyOC1DQkMgc2xpY2UgZW5jcnlwdGlvbiBmb3VuZCBpbiB1bmVuY3J5cHRlZCBzdHJlYW0nXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAweDFiOiAvLyBJVFUtVCBSZWMuIEguMjY0IGFuZCBJU08vSUVDIDE0NDk2LTEwIChsb3dlciBiaXQtcmF0ZSB2aWRlbylcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnQVZDIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQuYXZjID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdmMgPSBwaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gSVNPL0lFQyAxMTE3Mi0zIChNUEVHLTEgYXVkaW8pXG4gICAgICAvLyBvciBJU08vSUVDIDEzODE4LTMgKE1QRUctMiBoYWx2ZWQgc2FtcGxlIHJhdGUgYXVkaW8pXG4gICAgICBjYXNlIDB4MDM6XG4gICAgICBjYXNlIDB4MDQ6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ01QRUcgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHR5cGVTdXBwb3J0ZWQubXBlZyAhPT0gdHJ1ZSAmJiB0eXBlU3VwcG9ydGVkLm1wMyAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ01QRUcgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmF1ZGlvID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgICByZXN1bHQuc2VnbWVudENvZGVjID0gJ21wMyc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHgyNDpcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1Vuc3VwcG9ydGVkIEhFVkMgc3RyZWFtIHR5cGUgZm91bmQnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ3Vua25vd24gc3RyZWFtIHR5cGU6JyArIGRhdGFbb2Zmc2V0XSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHRhYmxlIGVudHJ5XG4gICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuICAgIG9mZnNldCArPSAoKChkYXRhW29mZnNldCArIDNdICYgMHgwZikgPDwgOCkgfCBkYXRhW29mZnNldCArIDRdKSArIDU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQRVMoc3RyZWFtOiBFbGVtZW50YXJ5U3RyZWFtRGF0YSk6IFBFUyB8IG51bGwge1xuICBsZXQgaSA9IDA7XG4gIGxldCBmcmFnOiBVaW50OEFycmF5O1xuICBsZXQgcGVzTGVuOiBudW1iZXI7XG4gIGxldCBwZXNIZHJMZW46IG51bWJlcjtcbiAgbGV0IHBlc1B0czogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBsZXQgcGVzRHRzOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIGNvbnN0IGRhdGEgPSBzdHJlYW0uZGF0YTtcbiAgLy8gc2FmZXR5IGNoZWNrXG4gIGlmICghc3RyZWFtIHx8IHN0cmVhbS5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyB3ZSBtaWdodCBuZWVkIHVwIHRvIDE5IGJ5dGVzIHRvIHJlYWQgUEVTIGhlYWRlclxuICAvLyBpZiBmaXJzdCBjaHVuayBvZiBkYXRhIGlzIGxlc3MgdGhhbiAxOSBieXRlcywgbGV0J3MgbWVyZ2UgaXQgd2l0aCBmb2xsb3dpbmcgb25lcyB1bnRpbCB3ZSBnZXQgMTkgYnl0ZXNcbiAgLy8gdXN1YWxseSBvbmx5IG9uZSBtZXJnZSBpcyBuZWVkZWQgKGFuZCB0aGlzIGlzIHJhcmUgLi4uKVxuICB3aGlsZSAoZGF0YVswXS5sZW5ndGggPCAxOSAmJiBkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YVswXS5sZW5ndGggKyBkYXRhWzFdLmxlbmd0aCk7XG4gICAgbmV3RGF0YS5zZXQoZGF0YVswXSk7XG4gICAgbmV3RGF0YS5zZXQoZGF0YVsxXSwgZGF0YVswXS5sZW5ndGgpO1xuICAgIGRhdGFbMF0gPSBuZXdEYXRhO1xuICAgIGRhdGEuc3BsaWNlKDEsIDEpO1xuICB9XG4gIC8vIHJldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxuICBmcmFnID0gZGF0YVswXTtcbiAgY29uc3QgcGVzUHJlZml4ID0gKGZyYWdbMF0gPDwgMTYpICsgKGZyYWdbMV0gPDwgOCkgKyBmcmFnWzJdO1xuICBpZiAocGVzUHJlZml4ID09PSAxKSB7XG4gICAgcGVzTGVuID0gKGZyYWdbNF0gPDwgOCkgKyBmcmFnWzVdO1xuICAgIC8vIGlmIFBFUyBwYXJzZWQgbGVuZ3RoIGlzIG5vdCB6ZXJvIGFuZCBncmVhdGVyIHRoYW4gdG90YWwgcmVjZWl2ZWQgbGVuZ3RoLCBzdG9wIHBhcnNpbmcuIFBFUyBtaWdodCBiZSB0cnVuY2F0ZWRcbiAgICAvLyBtaW51cyA2IDogUEVTIGhlYWRlciBzaXplXG4gICAgaWYgKHBlc0xlbiAmJiBwZXNMZW4gPiBzdHJlYW0uc2l6ZSAtIDYpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHBlc0ZsYWdzID0gZnJhZ1s3XTtcbiAgICBpZiAocGVzRmxhZ3MgJiAweGMwKSB7XG4gICAgICAvKiBQRVMgaGVhZGVyIGRlc2NyaWJlZCBoZXJlIDogaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcbiAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcbiAgICAgICAgICBhcyBCaXR3aXNlIG9wZXJhdG9ycyB0cmVhdCB0aGVpciBvcGVyYW5kcyBhcyBhIHNlcXVlbmNlIG9mIDMyIGJpdHMgKi9cbiAgICAgIHBlc1B0cyA9XG4gICAgICAgIChmcmFnWzldICYgMHgwZSkgKiA1MzY4NzA5MTIgKyAvLyAxIDw8IDI5XG4gICAgICAgIChmcmFnWzEwXSAmIDB4ZmYpICogNDE5NDMwNCArIC8vIDEgPDwgMjJcbiAgICAgICAgKGZyYWdbMTFdICYgMHhmZSkgKiAxNjM4NCArIC8vIDEgPDwgMTRcbiAgICAgICAgKGZyYWdbMTJdICYgMHhmZikgKiAxMjggKyAvLyAxIDw8IDdcbiAgICAgICAgKGZyYWdbMTNdICYgMHhmZSkgLyAyO1xuXG4gICAgICBpZiAocGVzRmxhZ3MgJiAweDQwKSB7XG4gICAgICAgIHBlc0R0cyA9XG4gICAgICAgICAgKGZyYWdbMTRdICYgMHgwZSkgKiA1MzY4NzA5MTIgKyAvLyAxIDw8IDI5XG4gICAgICAgICAgKGZyYWdbMTVdICYgMHhmZikgKiA0MTk0MzA0ICsgLy8gMSA8PCAyMlxuICAgICAgICAgIChmcmFnWzE2XSAmIDB4ZmUpICogMTYzODQgKyAvLyAxIDw8IDE0XG4gICAgICAgICAgKGZyYWdbMTddICYgMHhmZikgKiAxMjggKyAvLyAxIDw8IDdcbiAgICAgICAgICAoZnJhZ1sxOF0gJiAweGZlKSAvIDI7XG5cbiAgICAgICAgaWYgKHBlc1B0cyAtIHBlc0R0cyA+IDYwICogOTAwMDApIHtcbiAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgIGAke01hdGgucm91bmQoXG4gICAgICAgICAgICAgIChwZXNQdHMgLSBwZXNEdHMpIC8gOTAwMDBcbiAgICAgICAgICAgICl9cyBkZWx0YSBiZXR3ZWVuIFBUUyBhbmQgRFRTLCBhbGlnbiB0aGVtYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcGVzUHRzID0gcGVzRHRzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXNEdHMgPSBwZXNQdHM7XG4gICAgICB9XG4gICAgfVxuICAgIHBlc0hkckxlbiA9IGZyYWdbOF07XG4gICAgLy8gOSBieXRlcyA6IDYgYnl0ZXMgZm9yIFBFUyBoZWFkZXIgKyAzIGJ5dGVzIGZvciBQRVMgZXh0ZW5zaW9uXG4gICAgbGV0IHBheWxvYWRTdGFydE9mZnNldCA9IHBlc0hkckxlbiArIDk7XG4gICAgaWYgKHN0cmVhbS5zaXplIDw9IHBheWxvYWRTdGFydE9mZnNldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0cmVhbS5zaXplIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAvLyByZWFzc2VtYmxlIFBFUyBwYWNrZXRcbiAgICBjb25zdCBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuICAgIGZvciAobGV0IGogPSAwLCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7IGogPCBkYXRhTGVuOyBqKyspIHtcbiAgICAgIGZyYWcgPSBkYXRhW2pdO1xuICAgICAgbGV0IGxlbiA9IGZyYWcuYnl0ZUxlbmd0aDtcbiAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCA+IGxlbikge1xuICAgICAgICAgIC8vIHRyaW0gZnVsbCBmcmFnIGlmIFBFUyBoZWFkZXIgYmlnZ2VyIHRoYW4gZnJhZ1xuICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCAtPSBsZW47XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdHJpbSBwYXJ0aWFsIGZyYWcgaWYgUEVTIGhlYWRlciBzbWFsbGVyIHRoYW4gZnJhZ1xuICAgICAgICAgIGZyYWcgPSBmcmFnLnN1YmFycmF5KHBheWxvYWRTdGFydE9mZnNldCk7XG4gICAgICAgICAgbGVuIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgIGkgKz0gbGVuO1xuICAgIH1cbiAgICBpZiAocGVzTGVuKSB7XG4gICAgICAvLyBwYXlsb2FkIHNpemUgOiByZW1vdmUgUEVTIGhlYWRlciArIFBFUyBleHRlbnNpb25cbiAgICAgIHBlc0xlbiAtPSBwZXNIZHJMZW4gKyAzO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhOiBwZXNEYXRhLCBwdHM6IHBlc1B0cywgZHRzOiBwZXNEdHMsIGxlbjogcGVzTGVuIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hBY2Nlc3NVbml0KGF2Y1NhbXBsZTogUGFyc2VkQXZjU2FtcGxlLCBhdmNUcmFjazogRGVtdXhlZEF2Y1RyYWNrKSB7XG4gIGlmIChhdmNTYW1wbGUudW5pdHMubGVuZ3RoICYmIGF2Y1NhbXBsZS5mcmFtZSkge1xuICAgIC8vIGlmIHNhbXBsZSBkb2VzIG5vdCBoYXZlIFBUUy9EVFMsIHBhdGNoIHdpdGggbGFzdCBzYW1wbGUgUFRTL0RUU1xuICAgIGlmIChhdmNTYW1wbGUucHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHNhbXBsZXMgPSBhdmNUcmFjay5zYW1wbGVzO1xuICAgICAgY29uc3QgbmJTYW1wbGVzID0gc2FtcGxlcy5sZW5ndGg7XG4gICAgICBpZiAobmJTYW1wbGVzKSB7XG4gICAgICAgIGNvbnN0IGxhc3RTYW1wbGUgPSBzYW1wbGVzW25iU2FtcGxlcyAtIDFdO1xuICAgICAgICBhdmNTYW1wbGUucHRzID0gbGFzdFNhbXBsZS5wdHM7XG4gICAgICAgIGF2Y1NhbXBsZS5kdHMgPSBsYXN0U2FtcGxlLmR0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRyb3BwaW5nIHNhbXBsZXMsIG5vIHRpbWVzdGFtcCBmb3VuZFxuICAgICAgICBhdmNUcmFjay5kcm9wcGVkKys7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgYXZjVHJhY2suc2FtcGxlcy5wdXNoKGF2Y1NhbXBsZSBhcyBBdmNTYW1wbGUpO1xuICB9XG4gIGlmIChhdmNTYW1wbGUuZGVidWcubGVuZ3RoKSB7XG4gICAgbG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1Zyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVFNEZW11eGVyO1xuIiwiLyoqXG4gKiBNUDMgZGVtdXhlclxuICovXG5pbXBvcnQgQmFzZUF1ZGlvRGVtdXhlciBmcm9tICcuL2Jhc2UtYXVkaW8tZGVtdXhlcic7XG5pbXBvcnQgKiBhcyBJRDMgZnJvbSAnLi4vZGVtdXgvaWQzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgKiBhcyBNcGVnQXVkaW8gZnJvbSAnLi9tcGVnYXVkaW8nO1xuXG5jbGFzcyBNUDNEZW11eGVyIGV4dGVuZHMgQmFzZUF1ZGlvRGVtdXhlciB7XG4gIHJlc2V0SW5pdFNlZ21lbnQoXG4gICAgaW5pdFNlZ21lbnQ6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQsXG4gICAgYXVkaW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHZpZGVvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB0cmFja0R1cmF0aW9uOiBudW1iZXJcbiAgKSB7XG4gICAgc3VwZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL21wZWcnLFxuICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2VnbWVudENvZGVjOiAnbXAzJyxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgZHJvcHBlZDogMCxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIHByb2JlKGRhdGEpOiBib29sZWFuIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIE1QRUcgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAgIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gICAgY29uc3QgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApIHx8IFtdO1xuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoTXBlZ0F1ZGlvLnByb2JlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnTVBFRyBBdWRpbyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIE1wZWdBdWRpby5jYW5QYXJzZShkYXRhLCBvZmZzZXQpO1xuICB9XG5cbiAgYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLmJhc2VQVFMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIE1wZWdBdWRpby5hcHBlbmRGcmFtZShcbiAgICAgIHRyYWNrLFxuICAgICAgZGF0YSxcbiAgICAgIG9mZnNldCxcbiAgICAgIHRoaXMuYmFzZVBUUyxcbiAgICAgIHRoaXMuZnJhbWVJbmRleFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTVAzRGVtdXhlcjtcbiIsIi8qKlxuICogIEFBQyBoZWxwZXJcbiAqL1xuXG5jbGFzcyBBQUMge1xuICBzdGF0aWMgZ2V0U2lsZW50RnJhbWUoXG4gICAgY29kZWM/OiBzdHJpbmcsXG4gICAgY2hhbm5lbENvdW50PzogbnVtYmVyXG4gICk6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQge1xuICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICAgIGNhc2UgJ21wNGEuNDAuMic6XG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgyMSwgMHgwMCwgMHg0OSwgMHg5MCwgMHgwMiwgMHgxOSwgMHgwMCwgMHgyMywgMHg4MCxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCxcbiAgICAgICAgICAgIDB4MDAsIDB4OGUsXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsXG4gICAgICAgICAgICAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4LFxuICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LFxuICAgICAgICAgICAgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgzOCxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCxcbiAgICAgICAgICAgIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MDAsIDB4YjIsXG4gICAgICAgICAgICAweDAwLCAweDIwLCAweDA4LCAweGUwLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBoYW5kbGUgSEUtQUFDIGJlbG93IChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg0ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCxcbiAgICAgICAgICAgIDB4MCwgMHgxYywgMHg2LCAweGYxLCAweGMxLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLFxuICAgICAgICAgICAgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSxcbiAgICAgICAgICAgIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVlLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLFxuICAgICAgICAgICAgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLFxuICAgICAgICAgICAgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSxcbiAgICAgICAgICAgIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVlLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsXG4gICAgICAgICAgICAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSxcbiAgICAgICAgICAgIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLFxuICAgICAgICAgICAgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSxcbiAgICAgICAgICAgIDB4NWEsIDB4NWUsXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQUFDO1xuIiwiLyoqXG4gKiBHZW5lcmF0ZSBNUDQgQm94XG4gKi9cblxudHlwZSBIZGxyVHlwZXMgPSB7XG4gIHZpZGVvOiBVaW50OEFycmF5O1xuICBhdWRpbzogVWludDhBcnJheTtcbn07XG5cbmNvbnN0IFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuXG5jbGFzcyBNUDQge1xuICBwdWJsaWMgc3RhdGljIHR5cGVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXJbXT47XG4gIHByaXZhdGUgc3RhdGljIEhETFJfVFlQRVM6IEhkbHJUeXBlcztcbiAgcHJpdmF0ZSBzdGF0aWMgU1RUUzogVWludDhBcnJheTtcbiAgcHJpdmF0ZSBzdGF0aWMgU1RTQzogVWludDhBcnJheTtcbiAgcHJpdmF0ZSBzdGF0aWMgU1RDTzogVWludDhBcnJheTtcbiAgcHJpdmF0ZSBzdGF0aWMgU1RTWjogVWludDhBcnJheTtcbiAgcHJpdmF0ZSBzdGF0aWMgVk1IRDogVWludDhBcnJheTtcbiAgcHJpdmF0ZSBzdGF0aWMgU01IRDogVWludDhBcnJheTtcbiAgcHJpdmF0ZSBzdGF0aWMgU1RTRDogVWludDhBcnJheTtcbiAgcHJpdmF0ZSBzdGF0aWMgRlRZUDogVWludDhBcnJheTtcbiAgcHJpdmF0ZSBzdGF0aWMgRElORjogVWludDhBcnJheTtcblxuICBzdGF0aWMgaW5pdCgpIHtcbiAgICBNUDQudHlwZXMgPSB7XG4gICAgICBhdmMxOiBbXSwgLy8gY29kaW5nbmFtZVxuICAgICAgYXZjQzogW10sXG4gICAgICBidHJ0OiBbXSxcbiAgICAgIGRpbmY6IFtdLFxuICAgICAgZHJlZjogW10sXG4gICAgICBlc2RzOiBbXSxcbiAgICAgIGZ0eXA6IFtdLFxuICAgICAgaGRscjogW10sXG4gICAgICBtZGF0OiBbXSxcbiAgICAgIG1kaGQ6IFtdLFxuICAgICAgbWRpYTogW10sXG4gICAgICBtZmhkOiBbXSxcbiAgICAgIG1pbmY6IFtdLFxuICAgICAgbW9vZjogW10sXG4gICAgICBtb292OiBbXSxcbiAgICAgIG1wNGE6IFtdLFxuICAgICAgJy5tcDMnOiBbXSxcbiAgICAgIG12ZXg6IFtdLFxuICAgICAgbXZoZDogW10sXG4gICAgICBwYXNwOiBbXSxcbiAgICAgIHNkdHA6IFtdLFxuICAgICAgc3RibDogW10sXG4gICAgICBzdGNvOiBbXSxcbiAgICAgIHN0c2M6IFtdLFxuICAgICAgc3RzZDogW10sXG4gICAgICBzdHN6OiBbXSxcbiAgICAgIHN0dHM6IFtdLFxuICAgICAgdGZkdDogW10sXG4gICAgICB0ZmhkOiBbXSxcbiAgICAgIHRyYWY6IFtdLFxuICAgICAgdHJhazogW10sXG4gICAgICB0cnVuOiBbXSxcbiAgICAgIHRyZXg6IFtdLFxuICAgICAgdGtoZDogW10sXG4gICAgICB2bWhkOiBbXSxcbiAgICAgIHNtaGQ6IFtdLFxuICAgIH07XG5cbiAgICBsZXQgaTogc3RyaW5nO1xuICAgIGZvciAoaSBpbiBNUDQudHlwZXMpIHtcbiAgICAgIGlmIChNUDQudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgTVA0LnR5cGVzW2ldID0gW1xuICAgICAgICAgIGkuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMSksXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgIGkuY2hhckNvZGVBdCgzKSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDc2LFxuICAgICAgMHg2OSxcbiAgICAgIDB4NjQsXG4gICAgICAweDY1LCAvLyBoYW5kbGVyX3R5cGU6ICd2aWRlJ1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHg1NixcbiAgICAgIDB4NjksXG4gICAgICAweDY0LFxuICAgICAgMHg2NSxcbiAgICAgIDB4NmYsXG4gICAgICAweDQ4LFxuICAgICAgMHg2MSxcbiAgICAgIDB4NmUsXG4gICAgICAweDY0LFxuICAgICAgMHg2YyxcbiAgICAgIDB4NjUsXG4gICAgICAweDcyLFxuICAgICAgMHgwMCwgLy8gbmFtZTogJ1ZpZGVvSGFuZGxlcidcbiAgICBdKTtcblxuICAgIGNvbnN0IGF1ZGlvSGRsciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4NzMsXG4gICAgICAweDZmLFxuICAgICAgMHg3NSxcbiAgICAgIDB4NmUsIC8vIGhhbmRsZXJfdHlwZTogJ3NvdW4nXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDUzLFxuICAgICAgMHg2ZixcbiAgICAgIDB4NzUsXG4gICAgICAweDZlLFxuICAgICAgMHg2NCxcbiAgICAgIDB4NDgsXG4gICAgICAweDYxLFxuICAgICAgMHg2ZSxcbiAgICAgIDB4NjQsXG4gICAgICAweDZjLFxuICAgICAgMHg2NSxcbiAgICAgIDB4NzIsXG4gICAgICAweDAwLCAvLyBuYW1lOiAnU291bmRIYW5kbGVyJ1xuICAgIF0pO1xuXG4gICAgTVA0LkhETFJfVFlQRVMgPSB7XG4gICAgICB2aWRlbzogdmlkZW9IZGxyLFxuICAgICAgYXVkaW86IGF1ZGlvSGRscixcbiAgICB9O1xuXG4gICAgY29uc3QgZHJlZiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMSwgLy8gZW50cnlfY291bnRcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MGMsIC8vIGVudHJ5X3NpemVcbiAgICAgIDB4NzUsXG4gICAgICAweDcyLFxuICAgICAgMHg2YyxcbiAgICAgIDB4MjAsIC8vICd1cmwnIHR5cGVcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAxLCAvLyBlbnRyeV9mbGFnc1xuICAgIF0pO1xuXG4gICAgY29uc3Qgc3RjbyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIGVudHJ5X2NvdW50XG4gICAgXSk7XG5cbiAgICBNUDQuU1RUUyA9IE1QNC5TVFNDID0gTVA0LlNUQ08gPSBzdGNvO1xuXG4gICAgTVA0LlNUU1ogPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gc2FtcGxlX2NvdW50XG4gICAgXSk7XG4gICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDEsIC8vIGZsYWdzXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gZ3JhcGhpY3Ntb2RlXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIG9wY29sb3JcbiAgICBdKTtcbiAgICBNUDQuU01IRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBiYWxhbmNlXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICBdKTtcblxuICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAxLFxuICAgIF0pOyAvLyBlbnRyeV9jb3VudFxuXG4gICAgY29uc3QgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsIDExNSwgMTExLCAxMDldKTsgLy8gaXNvbVxuICAgIGNvbnN0IGF2YzFCcmFuZCA9IG5ldyBVaW50OEFycmF5KFs5NywgMTE4LCA5OSwgNDldKTsgLy8gYXZjMVxuICAgIGNvbnN0IG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG5cbiAgICBNUDQuRlRZUCA9IE1QNC5ib3goXG4gICAgICBNUDQudHlwZXMuZnR5cCxcbiAgICAgIG1ham9yQnJhbmQsXG4gICAgICBtaW5vclZlcnNpb24sXG4gICAgICBtYWpvckJyYW5kLFxuICAgICAgYXZjMUJyYW5kXG4gICAgKTtcbiAgICBNUDQuRElORiA9IE1QNC5ib3goTVA0LnR5cGVzLmRpbmYsIE1QNC5ib3goTVA0LnR5cGVzLmRyZWYsIGRyZWYpKTtcbiAgfVxuXG4gIHN0YXRpYyBib3godHlwZSwgLi4ucGF5bG9hZDogVWludDhBcnJheVtdKSB7XG4gICAgbGV0IHNpemUgPSA4O1xuICAgIGxldCBpID0gcGF5bG9hZC5sZW5ndGg7XG4gICAgY29uc3QgbGVuID0gaTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIHJlc3VsdFswXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgcmVzdWx0WzFdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICByZXN1bHRbMl0gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgcmVzdWx0WzNdID0gc2l6ZSAmIDB4ZmY7XG4gICAgcmVzdWx0LnNldCh0eXBlLCA0KTtcbiAgICAvLyBjb3B5IHRoZSBwYXlsb2FkIGludG8gdGhlIHJlc3VsdFxuICAgIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIGNvcHkgcGF5bG9hZFtpXSBhcnJheSBAIG9mZnNldCBzaXplXG4gICAgICByZXN1bHQuc2V0KHBheWxvYWRbaV0sIHNpemUpO1xuICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzdGF0aWMgaGRscih0eXBlKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmhkbHIsIE1QNC5IRExSX1RZUEVTW3R5cGVdKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGF0KGRhdGEpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRhdCwgZGF0YSk7XG4gIH1cblxuICBzdGF0aWMgbWRoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLm1kaGQsXG4gICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAxNikgJiAweGZmLFxuICAgICAgICAodGltZXNjYWxlID4+IDgpICYgMHhmZixcbiAgICAgICAgdGltZXNjYWxlICYgMHhmZiwgLy8gdGltZXNjYWxlXG4gICAgICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LFxuICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhmZixcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDgpICYgMHhmZixcbiAgICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweGZmLFxuICAgICAgICBsb3dlcldvcmREdXJhdGlvbiA+PiAyNCxcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZixcbiAgICAgICAgMHg1NSxcbiAgICAgICAgMHhjNCwgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGlhKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICBNUDQudHlwZXMubWRpYSxcbiAgICAgIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSwgdHJhY2suZHVyYXRpb24pLFxuICAgICAgTVA0LmhkbHIodHJhY2sudHlwZSksXG4gICAgICBNUDQubWluZih0cmFjaylcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIG1maGQoc2VxdWVuY2VOdW1iZXIpIHtcbiAgICByZXR1cm4gTVA0LmJveChcbiAgICAgIE1QNC50eXBlcy5tZmhkLFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgICBzZXF1ZW5jZU51bWJlciA+PiAyNCxcbiAgICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChzZXF1ZW5jZU51bWJlciA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIHNlcXVlbmNlTnVtYmVyICYgMHhmZiwgLy8gc2VxdWVuY2VfbnVtYmVyXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgbWluZih0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChcbiAgICAgICAgTVA0LnR5cGVzLm1pbmYsXG4gICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnNtaGQsIE1QNC5TTUhEKSxcbiAgICAgICAgTVA0LkRJTkYsXG4gICAgICAgIE1QNC5zdGJsKHRyYWNrKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICAgIE1QNC50eXBlcy5taW5mLFxuICAgICAgICBNUDQuYm94KE1QNC50eXBlcy52bWhkLCBNUDQuVk1IRCksXG4gICAgICAgIE1QNC5ESU5GLFxuICAgICAgICBNUDQuc3RibCh0cmFjaylcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIG1vb2Yoc24sIGJhc2VNZWRpYURlY29kZVRpbWUsIHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICBNUDQudHlwZXMubW9vZixcbiAgICAgIE1QNC5tZmhkKHNuKSxcbiAgICAgIE1QNC50cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKVxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgbW9vdih0cmFja3MpIHtcbiAgICBsZXQgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgY29uc3QgYm94ZXM6IFVpbnQ4QXJyYXlbXSA9IFtdO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJhayh0cmFja3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KFxuICAgICAgbnVsbCxcbiAgICAgIFtNUDQudHlwZXMubW9vdiwgTVA0Lm12aGQodHJhY2tzWzBdLnRpbWVzY2FsZSwgdHJhY2tzWzBdLmR1cmF0aW9uKV1cbiAgICAgICAgLmNvbmNhdChib3hlcylcbiAgICAgICAgLmNvbmNhdChNUDQubXZleCh0cmFja3MpKVxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgbXZleCh0cmFja3MpIHtcbiAgICBsZXQgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgY29uc3QgYm94ZXM6IFVpbnQ4QXJyYXlbXSA9IFtdO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJleCh0cmFja3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleCwgLi4uYm94ZXNdKTtcbiAgfVxuXG4gIHN0YXRpYyBtdmhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhmZixcbiAgICAgICh0aW1lc2NhbGUgPj4gMTYpICYgMHhmZixcbiAgICAgICh0aW1lc2NhbGUgPj4gOCkgJiAweGZmLFxuICAgICAgdGltZXNjYWxlICYgMHhmZiwgLy8gdGltZXNjYWxlXG4gICAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCxcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweGZmLFxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDgpICYgMHhmZixcbiAgICAgIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZixcbiAgICAgIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4ZmYsXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweGZmLFxuICAgICAgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDEsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gMS4wIHJhdGVcbiAgICAgIDB4MDEsXG4gICAgICAweDAwLCAvLyAxLjAgdm9sdW1lXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDEsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAxLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDQwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweGZmLFxuICAgICAgMHhmZixcbiAgICAgIDB4ZmYsXG4gICAgICAweGZmLCAvLyBuZXh0X3RyYWNrX0lEXG4gICAgXSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm12aGQsIGJ5dGVzKTtcbiAgfVxuXG4gIHN0YXRpYyBzZHRwKHRyYWNrKSB7XG4gICAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW107XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGxldCBmbGFncztcbiAgICAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xuICAgIC8vIHdyaXRlIHRoZSBzYW1wbGUgdGFibGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuICAgICAgYnl0ZXNbaSArIDRdID1cbiAgICAgICAgKGZsYWdzLmRlcGVuZHNPbiA8PCA0KSB8XG4gICAgICAgIChmbGFncy5pc0RlcGVuZGVkT24gPDwgMikgfFxuICAgICAgICBmbGFncy5oYXNSZWR1bmRhbmN5O1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zZHRwLCBieXRlcyk7XG4gIH1cblxuICBzdGF0aWMgc3RibCh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLnN0YmwsXG4gICAgICBNUDQuc3RzZCh0cmFjayksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy5zdHNjLCBNUDQuU1RTQyksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuU1RTWiksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTylcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIGF2YzEodHJhY2spIHtcbiAgICBsZXQgc3BzOiBudW1iZXJbXSA9IFtdO1xuICAgIGxldCBwcHM6IG51bWJlcltdID0gW107XG4gICAgbGV0IGk7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGxlbjtcbiAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnNwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHNwcy5wdXNoKChsZW4gPj4+IDgpICYgMHhmZik7XG4gICAgICBzcHMucHVzaChsZW4gJiAweGZmKTtcblxuICAgICAgLy8gU1BTXG4gICAgICBzcHMgPSBzcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBhc3NlbWJsZSB0aGUgUFBTc1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBwcHMucHVzaCgobGVuID4+PiA4KSAmIDB4ZmYpO1xuICAgICAgcHBzLnB1c2gobGVuICYgMHhmZik7XG5cbiAgICAgIHBwcyA9IHBwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGF2Y2MgPSBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLmF2Y0MsXG4gICAgICBuZXcgVWludDhBcnJheShcbiAgICAgICAgW1xuICAgICAgICAgIDB4MDEsIC8vIHZlcnNpb25cbiAgICAgICAgICBzcHNbM10sIC8vIHByb2ZpbGVcbiAgICAgICAgICBzcHNbNF0sIC8vIHByb2ZpbGUgY29tcGF0XG4gICAgICAgICAgc3BzWzVdLCAvLyBsZXZlbFxuICAgICAgICAgIDB4ZmMgfCAzLCAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xuICAgICAgICAgIDB4ZTAgfCB0cmFjay5zcHMubGVuZ3RoLCAvLyAzYml0IHJlc2VydmVkICgxMTEpICsgbnVtT2ZTZXF1ZW5jZVBhcmFtZXRlclNldHNcbiAgICAgICAgXVxuICAgICAgICAgIC5jb25jYXQoc3BzKVxuICAgICAgICAgIC5jb25jYXQoW1xuICAgICAgICAgICAgdHJhY2sucHBzLmxlbmd0aCwgLy8gbnVtT2ZQaWN0dXJlUGFyYW1ldGVyU2V0c1xuICAgICAgICAgIF0pXG4gICAgICAgICAgLmNvbmNhdChwcHMpXG4gICAgICApXG4gICAgKTsgLy8gXCJQUFNcIlxuICAgIGNvbnN0IHdpZHRoID0gdHJhY2sud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0O1xuICAgIGNvbnN0IGhTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1swXTtcbiAgICBjb25zdCB2U3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMV07XG5cbiAgICByZXR1cm4gTVA0LmJveChcbiAgICAgIE1QNC50eXBlcy5hdmMxLFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgICAod2lkdGggPj4gOCkgJiAweGZmLFxuICAgICAgICB3aWR0aCAmIDB4ZmYsIC8vIHdpZHRoXG4gICAgICAgIChoZWlnaHQgPj4gOCkgJiAweGZmLFxuICAgICAgICBoZWlnaHQgJiAweGZmLCAvLyBoZWlnaHRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHg0OCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gaG9yaXpyZXNvbHV0aW9uXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4NDgsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDEsIC8vIGZyYW1lX2NvdW50XG4gICAgICAgIDB4MTIsXG4gICAgICAgIDB4NjQsXG4gICAgICAgIDB4NjEsXG4gICAgICAgIDB4NjksXG4gICAgICAgIDB4NmMsIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgICAgICAweDc5LFxuICAgICAgICAweDZkLFxuICAgICAgICAweDZmLFxuICAgICAgICAweDc0LFxuICAgICAgICAweDY5LFxuICAgICAgICAweDZmLFxuICAgICAgICAweDZlLFxuICAgICAgICAweDJmLFxuICAgICAgICAweDY4LFxuICAgICAgICAweDZjLFxuICAgICAgICAweDczLFxuICAgICAgICAweDJlLFxuICAgICAgICAweDZhLFxuICAgICAgICAweDczLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBjb21wcmVzc29ybmFtZVxuICAgICAgICAweDAwLFxuICAgICAgICAweDE4LCAvLyBkZXB0aCA9IDI0XG4gICAgICAgIDB4MTEsXG4gICAgICAgIDB4MTEsXG4gICAgICBdKSwgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgICAgYXZjYyxcbiAgICAgIE1QNC5ib3goXG4gICAgICAgIE1QNC50eXBlcy5idHJ0LFxuICAgICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgMHgwMCxcbiAgICAgICAgICAweDFjLFxuICAgICAgICAgIDB4OWMsXG4gICAgICAgICAgMHg4MCwgLy8gYnVmZmVyU2l6ZURCXG4gICAgICAgICAgMHgwMCxcbiAgICAgICAgICAweDJkLFxuICAgICAgICAgIDB4YzYsXG4gICAgICAgICAgMHhjMCwgLy8gbWF4Qml0cmF0ZVxuICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgMHgyZCxcbiAgICAgICAgICAweGM2LFxuICAgICAgICAgIDB4YzAsXG4gICAgICAgIF0pXG4gICAgICApLCAvLyBhdmdCaXRyYXRlXG4gICAgICBNUDQuYm94KFxuICAgICAgICBNUDQudHlwZXMucGFzcCxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgIGhTcGFjaW5nID4+IDI0LCAvLyBoU3BhY2luZ1xuICAgICAgICAgIChoU3BhY2luZyA+PiAxNikgJiAweGZmLFxuICAgICAgICAgIChoU3BhY2luZyA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgaFNwYWNpbmcgJiAweGZmLFxuICAgICAgICAgIHZTcGFjaW5nID4+IDI0LCAvLyB2U3BhY2luZ1xuICAgICAgICAgICh2U3BhY2luZyA+PiAxNikgJiAweGZmLFxuICAgICAgICAgICh2U3BhY2luZyA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdlNwYWNpbmcgJiAweGZmLFxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgZXNkcyh0cmFjaykge1xuICAgIGNvbnN0IGNvbmZpZ2xlbiA9IHRyYWNrLmNvbmZpZy5sZW5ndGg7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFxuICAgICAgW1xuICAgICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gZmxhZ3NcblxuICAgICAgICAweDAzLCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgICAgMHgxNyArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDEsIC8vIGVzX2lkXG4gICAgICAgIDB4MDAsIC8vIHN0cmVhbV9wcmlvcml0eVxuXG4gICAgICAgIDB4MDQsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgICAweDBmICsgY29uZmlnbGVuLCAvLyBsZW5ndGhcbiAgICAgICAgMHg0MCwgLy8gY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgICAgICAweDE1LCAvLyBzdHJlYW1fdHlwZVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBidWZmZXJfc2l6ZVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIGF2Z0JpdHJhdGVcblxuICAgICAgICAweDA1LCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIF1cbiAgICAgICAgLmNvbmNhdChbY29uZmlnbGVuXSlcbiAgICAgICAgLmNvbmNhdCh0cmFjay5jb25maWcpXG4gICAgICAgIC5jb25jYXQoWzB4MDYsIDB4MDEsIDB4MDJdKVxuICAgICk7IC8vIEdBU3BlY2lmaWNDb25maWcpKTsgLy8gbGVuZ3RoICsgYXVkaW8gY29uZmlnIGRlc2NyaXB0b3JcbiAgfVxuXG4gIHN0YXRpYyBtcDRhKHRyYWNrKSB7XG4gICAgY29uc3Qgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICBNUDQudHlwZXMubXA0YSxcbiAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgxMCwgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWQyXG4gICAgICAgIChzYW1wbGVyYXRlID4+IDgpICYgMHhmZixcbiAgICAgICAgc2FtcGxlcmF0ZSAmIDB4ZmYsIC8vXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICBdKSxcbiAgICAgIE1QNC5ib3goTVA0LnR5cGVzLmVzZHMsIE1QNC5lc2RzKHRyYWNrKSlcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIG1wMyh0cmFjaykge1xuICAgIGNvbnN0IHNhbXBsZXJhdGUgPSB0cmFjay5zYW1wbGVyYXRlO1xuICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzWycubXAzJ10sXG4gICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsXG4gICAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkMlxuICAgICAgICAoc2FtcGxlcmF0ZSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgXSlcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIHN0c2QodHJhY2spIHtcbiAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgaWYgKHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ21wMycgJiYgdHJhY2suY29kZWMgPT09ICdtcDMnKSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wMyh0cmFjaykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDRhKHRyYWNrKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0LmF2YzEodHJhY2spKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgdGtoZCh0cmFjaykge1xuICAgIGNvbnN0IGlkID0gdHJhY2suaWQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiAqIHRyYWNrLnRpbWVzY2FsZTtcbiAgICBjb25zdCB3aWR0aCA9IHRyYWNrLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChcbiAgICAgIE1QNC50eXBlcy50a2hkLFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwNywgLy8gZmxhZ3NcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgICAoaWQgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKGlkID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChpZCA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGlkICYgMHhmZiwgLy8gdHJhY2tfSURcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsXG4gICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweGZmLFxuICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweGZmLFxuICAgICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsXG4gICAgICAgIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LFxuICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDgpICYgMHhmZixcbiAgICAgICAgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBsYXllclxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gbm9uLWF1ZGlvIHRyYWNrIHZvbHVtZVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAxLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAxLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDQwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICAgICh3aWR0aCA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIHdpZHRoICYgMHhmZixcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gd2lkdGhcbiAgICAgICAgKGhlaWdodCA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGhlaWdodCAmIDB4ZmYsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIGhlaWdodFxuICAgICAgXSlcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIHRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICBjb25zdCBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBNUDQuc2R0cCh0cmFjayk7XG4gICAgY29uc3QgaWQgPSB0cmFjay5pZDtcbiAgICBjb25zdCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihcbiAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpXG4gICAgKTtcbiAgICBjb25zdCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihcbiAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgJSAoVUlOVDMyX01BWCArIDEpXG4gICAgKTtcbiAgICByZXR1cm4gTVA0LmJveChcbiAgICAgIE1QNC50eXBlcy50cmFmLFxuICAgICAgTVA0LmJveChcbiAgICAgICAgTVA0LnR5cGVzLnRmaGQsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgICAgICAweDAwLFxuICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgICBpZCA+PiAyNCxcbiAgICAgICAgICAoaWQgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAoaWQgPj4gOCkgJiAweGZmLFxuICAgICAgICAgIGlkICYgMHhmZiwgLy8gdHJhY2tfSURcbiAgICAgICAgXSlcbiAgICAgICksXG4gICAgICBNUDQuYm94KFxuICAgICAgICBNUDQudHlwZXMudGZkdCxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgMHgwMCxcbiAgICAgICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsXG4gICAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4ZmYsXG4gICAgICAgICAgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCxcbiAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNikgJiAweGZmLFxuICAgICAgICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDgpICYgMHhmZixcbiAgICAgICAgICBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhmZixcbiAgICAgICAgXSlcbiAgICAgICksXG4gICAgICBNUDQudHJ1bihcbiAgICAgICAgdHJhY2ssXG4gICAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZS5sZW5ndGggK1xuICAgICAgICAgIDE2ICsgLy8gdGZoZFxuICAgICAgICAgIDIwICsgLy8gdGZkdFxuICAgICAgICAgIDggKyAvLyB0cmFmIGhlYWRlclxuICAgICAgICAgIDE2ICsgLy8gbWZoZFxuICAgICAgICAgIDggKyAvLyBtb29mIGhlYWRlclxuICAgICAgICAgIDhcbiAgICAgICksIC8vIG1kYXQgaGVhZGVyXG4gICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICAgKiBAcGFyYW0gdHJhY2sgYSB0cmFjayBkZWZpbml0aW9uXG4gICAqL1xuICBzdGF0aWMgdHJhayh0cmFjaykge1xuICAgIHRyYWNrLmR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gfHwgMHhmZmZmZmZmZjtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhaywgTVA0LnRraGQodHJhY2spLCBNUDQubWRpYSh0cmFjaykpO1xuICB9XG5cbiAgc3RhdGljIHRyZXgodHJhY2spIHtcbiAgICBjb25zdCBpZCA9IHRyYWNrLmlkO1xuICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLnRyZXgsXG4gICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgICBpZCA+PiAyNCxcbiAgICAgICAgKGlkID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChpZCA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGlkICYgMHhmZiwgLy8gdHJhY2tfSURcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAxLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAxLCAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICAgICAgXSlcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIHRydW4odHJhY2ssIG9mZnNldCkge1xuICAgIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgIGNvbnN0IGxlbiA9IHNhbXBsZXMubGVuZ3RoO1xuICAgIGNvbnN0IGFycmF5bGVuID0gMTIgKyAxNiAqIGxlbjtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5bGVuKTtcbiAgICBsZXQgaTtcbiAgICBsZXQgc2FtcGxlO1xuICAgIGxldCBkdXJhdGlvbjtcbiAgICBsZXQgc2l6ZTtcbiAgICBsZXQgZmxhZ3M7XG4gICAgbGV0IGN0cztcbiAgICBvZmZzZXQgKz0gOCArIGFycmF5bGVuO1xuICAgIGFycmF5LnNldChcbiAgICAgIFtcbiAgICAgICAgdHJhY2sudHlwZSA9PT0gJ3ZpZGVvJyA/IDB4MDEgOiAweDAwLCAvLyB2ZXJzaW9uIDEgZm9yIHZpZGVvIHdpdGggc2lnbmVkLWludCBzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwZixcbiAgICAgICAgMHgwMSwgLy8gZmxhZ3NcbiAgICAgICAgKGxlbiA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgKGxlbiA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgKGxlbiA+Pj4gOCkgJiAweGZmLFxuICAgICAgICBsZW4gJiAweGZmLCAvLyBzYW1wbGVfY291bnRcbiAgICAgICAgKG9mZnNldCA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgKG9mZnNldCA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgKG9mZnNldCA+Pj4gOCkgJiAweGZmLFxuICAgICAgICBvZmZzZXQgJiAweGZmLCAvLyBkYXRhX29mZnNldFxuICAgICAgXSxcbiAgICAgIDBcbiAgICApO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2FtcGxlID0gc2FtcGxlc1tpXTtcbiAgICAgIGR1cmF0aW9uID0gc2FtcGxlLmR1cmF0aW9uO1xuICAgICAgc2l6ZSA9IHNhbXBsZS5zaXplO1xuICAgICAgZmxhZ3MgPSBzYW1wbGUuZmxhZ3M7XG4gICAgICBjdHMgPSBzYW1wbGUuY3RzO1xuICAgICAgYXJyYXkuc2V0KFxuICAgICAgICBbXG4gICAgICAgICAgKGR1cmF0aW9uID4+PiAyNCkgJiAweGZmLFxuICAgICAgICAgIChkdXJhdGlvbiA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAoZHVyYXRpb24gPj4+IDgpICYgMHhmZixcbiAgICAgICAgICBkdXJhdGlvbiAmIDB4ZmYsIC8vIHNhbXBsZV9kdXJhdGlvblxuICAgICAgICAgIChzaXplID4+PiAyNCkgJiAweGZmLFxuICAgICAgICAgIChzaXplID4+PiAxNikgJiAweGZmLFxuICAgICAgICAgIChzaXplID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgc2l6ZSAmIDB4ZmYsIC8vIHNhbXBsZV9zaXplXG4gICAgICAgICAgKGZsYWdzLmlzTGVhZGluZyA8PCAyKSB8IGZsYWdzLmRlcGVuZHNPbixcbiAgICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYpIHxcbiAgICAgICAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQpIHxcbiAgICAgICAgICAgIChmbGFncy5wYWRkaW5nVmFsdWUgPDwgMSkgfFxuICAgICAgICAgICAgZmxhZ3MuaXNOb25TeW5jLFxuICAgICAgICAgIGZsYWdzLmRlZ3JhZFByaW8gJiAoMHhmMCA8PCA4KSxcbiAgICAgICAgICBmbGFncy5kZWdyYWRQcmlvICYgMHgwZiwgLy8gc2FtcGxlX2ZsYWdzXG4gICAgICAgICAgKGN0cyA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgICAoY3RzID4+PiAxNikgJiAweGZmLFxuICAgICAgICAgIChjdHMgPj4+IDgpICYgMHhmZixcbiAgICAgICAgICBjdHMgJiAweGZmLCAvLyBzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcbiAgICAgICAgXSxcbiAgICAgICAgMTIgKyAxNiAqIGlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XG4gIH1cblxuICBzdGF0aWMgaW5pdFNlZ21lbnQodHJhY2tzKSB7XG4gICAgaWYgKCFNUDQudHlwZXMpIHtcbiAgICAgIE1QNC5pbml0KCk7XG4gICAgfVxuXG4gICAgY29uc3QgbW92aWUgPSBNUDQubW9vdih0cmFja3MpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE1QNC5GVFlQLmJ5dGVMZW5ndGggKyBtb3ZpZS5ieXRlTGVuZ3RoKTtcbiAgICByZXN1bHQuc2V0KE1QNC5GVFlQKTtcbiAgICByZXN1bHQuc2V0KG1vdmllLCBNUDQuRlRZUC5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QNDtcbiIsImNvbnN0IE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiA9IDkwMDAwO1xuXG5leHBvcnQgdHlwZSBSYXRpb25hbFRpbWVzdGFtcCA9IHtcbiAgYmFzZVRpbWU6IG51bWJlcjsgLy8gdGlja3NcbiAgdGltZXNjYWxlOiBudW1iZXI7IC8vIHRpY2tzIHBlciBzZWNvbmRcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1RpbWVzY2FsZUZyb21CYXNlKFxuICBiYXNlVGltZTogbnVtYmVyLFxuICBkZXN0U2NhbGU6IG51bWJlcixcbiAgc3JjQmFzZTogbnVtYmVyID0gMSxcbiAgcm91bmQ6IGJvb2xlYW4gPSBmYWxzZVxuKTogbnVtYmVyIHtcbiAgY29uc3QgcmVzdWx0ID0gYmFzZVRpbWUgKiBkZXN0U2NhbGUgKiBzcmNCYXNlOyAvLyBlcXVpdmFsZW50IHRvIGAodmFsdWUgKiBzY2FsZSkgLyAoMSAvIGJhc2UpYFxuICByZXR1cm4gcm91bmQgPyBNYXRoLnJvdW5kKHJlc3VsdCkgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1RpbWVzY2FsZUZyb21TY2FsZShcbiAgYmFzZVRpbWU6IG51bWJlcixcbiAgZGVzdFNjYWxlOiBudW1iZXIsXG4gIHNyY1NjYWxlOiBudW1iZXIgPSAxLFxuICByb3VuZDogYm9vbGVhbiA9IGZhbHNlXG4pOiBudW1iZXIge1xuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgZGVzdFNjYWxlLCAxIC8gc3JjU2NhbGUsIHJvdW5kKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvTXNGcm9tTXBlZ1RzQ2xvY2soXG4gIGJhc2VUaW1lOiBudW1iZXIsXG4gIHJvdW5kOiBib29sZWFuID0gZmFsc2Vcbik6IG51bWJlciB7XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCAxMDAwLCAxIC8gTVBFR19UU19DTE9DS19GUkVRX0haLCByb3VuZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZShcbiAgYmFzZVRpbWU6IG51bWJlcixcbiAgc3JjU2NhbGU6IG51bWJlciA9IDFcbik6IG51bWJlciB7XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCBNUEVHX1RTX0NMT0NLX0ZSRVFfSFosIDEgLyBzcmNTY2FsZSk7XG59XG4iLCJpbXBvcnQgQUFDIGZyb20gJy4vYWFjLWhlbHBlcic7XG5pbXBvcnQgTVA0IGZyb20gJy4vbXA0LWdlbmVyYXRvcic7XG5pbXBvcnQgdHlwZSB7IEhsc0V2ZW50RW1pdHRlciB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQge1xuICBJbml0U2VnbWVudERhdGEsXG4gIFJlbXV4ZXIsXG4gIFJlbXV4ZXJSZXN1bHQsXG4gIFJlbXV4ZWRNZXRhZGF0YSxcbiAgUmVtdXhlZFRyYWNrLFxuICBSZW11eGVkVXNlcmRhdGEsXG59IGZyb20gJy4uL3R5cGVzL3JlbXV4ZXInO1xuaW1wb3J0IHsgUGxheWxpc3RMZXZlbFR5cGUgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHtcbiAgUmF0aW9uYWxUaW1lc3RhbXAsXG4gIHRvTXNGcm9tTXBlZ1RzQ2xvY2ssXG59IGZyb20gJy4uL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uJztcbmltcG9ydCB0eXBlIHtcbiAgQXVkaW9TYW1wbGUsXG4gIEF2Y1NhbXBsZSxcbiAgRGVtdXhlZEF1ZGlvVHJhY2ssXG4gIERlbXV4ZWRBdmNUcmFjayxcbiAgRGVtdXhlZE1ldGFkYXRhVHJhY2ssXG4gIERlbXV4ZWRVc2VyZGF0YVRyYWNrLFxufSBmcm9tICcuLi90eXBlcy9kZW11eGVyJztcbmltcG9ydCB0eXBlIHsgVHJhY2tTZXQgfSBmcm9tICcuLi90eXBlcy90cmFjayc7XG5pbXBvcnQgdHlwZSB7IFNvdXJjZUJ1ZmZlck5hbWUgfSBmcm9tICcuLi90eXBlcy9idWZmZXInO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IEhsc0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5cbmNvbnN0IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gPSAxMCAqIDEwMDA7IC8vIDEwIHNlY29uZHNcbmNvbnN0IEFBQ19TQU1QTEVTX1BFUl9GUkFNRSA9IDEwMjQ7XG5jb25zdCBNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUUgPSAxMTUyO1xuXG5sZXQgY2hyb21lVmVyc2lvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5sZXQgc2FmYXJpV2Via2l0VmVyc2lvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1QNFJlbXV4ZXIgaW1wbGVtZW50cyBSZW11eGVyIHtcbiAgcHJpdmF0ZSBvYnNlcnZlcjogSGxzRXZlbnRFbWl0dGVyO1xuICBwcml2YXRlIGNvbmZpZzogSGxzQ29uZmlnO1xuICBwcml2YXRlIHR5cGVTdXBwb3J0ZWQ6IGFueTtcbiAgcHJpdmF0ZSBJU0dlbmVyYXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9pbml0UFRTOiBSYXRpb25hbFRpbWVzdGFtcCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9pbml0RFRTOiBSYXRpb25hbFRpbWVzdGFtcCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG5leHRBdmNEdHM6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG5leHRBdWRpb1B0czogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgdmlkZW9TYW1wbGVEdXJhdGlvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaXNBdWRpb0NvbnRpZ3VvdXM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBpc1ZpZGVvQ29udGlndW91czogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXIsXG4gICAgY29uZmlnOiBIbHNDb25maWcsXG4gICAgdHlwZVN1cHBvcnRlZCxcbiAgICB2ZW5kb3IgPSAnJ1xuICApIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG5cbiAgICBpZiAoY2hyb21lVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgICBpZiAoc2FmYXJpV2Via2l0VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCspL2kpO1xuICAgICAgc2FmYXJpV2Via2l0VmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7fVxuXG4gIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRUaW1lU3RhbXA6IFJhdGlvbmFsVGltZXN0YW1wIHwgbnVsbCkge1xuICAgIGxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IGluaXRQVFMgJiBpbml0RFRTIHJlc2V0Jyk7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSBkZWZhdWx0VGltZVN0YW1wO1xuICB9XG5cbiAgcmVzZXROZXh0VGltZXN0YW1wKCkge1xuICAgIGxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IHJlc2V0IG5leHQgdGltZXN0YW1wJyk7XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQoKSB7XG4gICAgbG9nZ2VyLmxvZygnW21wNC1yZW11eGVyXTogSVNHZW5lcmF0ZWQgZmxhZyByZXNldCcpO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGdldFZpZGVvU3RhcnRQdHModmlkZW9TYW1wbGVzKSB7XG4gICAgbGV0IHJvbGxvdmVyRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBzdGFydFBUUyA9IHZpZGVvU2FtcGxlcy5yZWR1Y2UoKG1pblBUUywgc2FtcGxlKSA9PiB7XG4gICAgICBjb25zdCBkZWx0YSA9IHNhbXBsZS5wdHMgLSBtaW5QVFM7XG4gICAgICBpZiAoZGVsdGEgPCAtNDI5NDk2NzI5Nikge1xuICAgICAgICAvLyAyXjMyLCBzZWUgUFRTTm9ybWFsaXplIGZvciByZWFzb25pbmcsIGJ1dCB3ZSdyZSBoaXR0aW5nIGEgcm9sbG92ZXIgaGVyZSwgYW5kIHdlIGRvbid0IHdhbnQgdGhhdCB0byBpbXBhY3QgdGhlIHRpbWVPZmZzZXQgY2FsY3VsYXRpb25cbiAgICAgICAgcm9sbG92ZXJEZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVQdHMobWluUFRTLCBzYW1wbGUucHRzKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgIHJldHVybiBtaW5QVFM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2FtcGxlLnB0cztcbiAgICAgIH1cbiAgICB9LCB2aWRlb1NhbXBsZXNbMF0ucHRzKTtcbiAgICBpZiAocm9sbG92ZXJEZXRlY3RlZCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdQVFMgcm9sbG92ZXIgZGV0ZWN0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0UFRTO1xuICB9XG5cbiAgcmVtdXgoXG4gICAgYXVkaW9UcmFjazogRGVtdXhlZEF1ZGlvVHJhY2ssXG4gICAgdmlkZW9UcmFjazogRGVtdXhlZEF2Y1RyYWNrLFxuICAgIGlkM1RyYWNrOiBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgICB0ZXh0VHJhY2s6IERlbXV4ZWRVc2VyZGF0YVRyYWNrLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGJvb2xlYW4sXG4gICAgZmx1c2g6IGJvb2xlYW4sXG4gICAgcGxheWxpc3RUeXBlOiBQbGF5bGlzdExldmVsVHlwZVxuICApOiBSZW11eGVyUmVzdWx0IHtcbiAgICBsZXQgdmlkZW86IFJlbXV4ZWRUcmFjayB8IHVuZGVmaW5lZDtcbiAgICBsZXQgYXVkaW86IFJlbXV4ZWRUcmFjayB8IHVuZGVmaW5lZDtcbiAgICBsZXQgaW5pdFNlZ21lbnQ6IEluaXRTZWdtZW50RGF0YSB8IHVuZGVmaW5lZDtcbiAgICBsZXQgdGV4dDogUmVtdXhlZFVzZXJkYXRhIHwgdW5kZWZpbmVkO1xuICAgIGxldCBpZDM6IFJlbXV4ZWRNZXRhZGF0YSB8IHVuZGVmaW5lZDtcbiAgICBsZXQgaW5kZXBlbmRlbnQ6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgbGV0IGF1ZGlvVGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgbGV0IHZpZGVvVGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG5cbiAgICAvLyBJZiB3ZSdyZSByZW11eGluZyBhdWRpbyBhbmQgdmlkZW8gcHJvZ3Jlc3NpdmVseSwgd2FpdCB1bnRpbCB3ZSd2ZSByZWNlaXZlZCBlbm91Z2ggc2FtcGxlcyBmb3IgZWFjaCB0cmFjayBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gc3luY2hyb25pemUgdGhlIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1zLiBXZSBrbm93IGlmIHRoZSBjdXJyZW50IHNlZ21lbnQgd2lsbCBoYXZlIHNhbXBsZXMgaWYgdGhlIFwicGlkXCJcbiAgICAvLyBwYXJhbWV0ZXIgaXMgZ3JlYXRlciB0aGFuIC0xLiBUaGUgcGlkIGlzIHNldCB3aGVuIHRoZSBQTVQgaXMgcGFyc2VkLCB3aGljaCBjb250YWlucyB0aGUgdHJhY2tzIGxpc3QuXG4gICAgLy8gSG93ZXZlciwgaWYgdGhlIGluaXRTZWdtZW50IGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkLCBvciB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgYSBzZWdtZW50IChmbHVzaCksXG4gICAgLy8gdGhlbiB3ZSBjYW4gcmVtdXggb25lIHRyYWNrIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIG90aGVyLlxuICAgIGNvbnN0IGhhc0F1ZGlvID0gYXVkaW9UcmFjay5waWQgPiAtMTtcbiAgICBjb25zdCBoYXNWaWRlbyA9IHZpZGVvVHJhY2sucGlkID4gLTE7XG4gICAgY29uc3QgbGVuZ3RoID0gdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgICBjb25zdCBlbm91Z2hBdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBlbm91Z2hWaWRlb1NhbXBsZXMgPSAoZmx1c2ggJiYgbGVuZ3RoID4gMCkgfHwgbGVuZ3RoID4gMTtcbiAgICBjb25zdCBjYW5SZW11eEF2YyA9XG4gICAgICAoKCFoYXNBdWRpbyB8fCBlbm91Z2hBdWRpb1NhbXBsZXMpICYmXG4gICAgICAgICghaGFzVmlkZW8gfHwgZW5vdWdoVmlkZW9TYW1wbGVzKSkgfHxcbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgfHxcbiAgICAgIGZsdXNoO1xuXG4gICAgaWYgKGNhblJlbXV4QXZjKSB7XG4gICAgICBpZiAoIXRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoXG4gICAgICAgICAgYXVkaW9UcmFjayxcbiAgICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICAgIHRpbWVPZmZzZXQsXG4gICAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzVmlkZW9Db250aWd1b3VzID0gdGhpcy5pc1ZpZGVvQ29udGlndW91cztcbiAgICAgIGxldCBmaXJzdEtleUZyYW1lSW5kZXggPSAtMTtcbiAgICAgIGxldCBmaXJzdEtleUZyYW1lUFRTO1xuXG4gICAgICBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgIGZpcnN0S2V5RnJhbWVJbmRleCA9IGZpbmRLZXlmcmFtZUluZGV4KHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgIGlmICghaXNWaWRlb0NvbnRpZ3VvdXMgJiYgdGhpcy5jb25maWcuZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eSkge1xuICAgICAgICAgIGluZGVwZW5kZW50ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZmlyc3RLZXlGcmFtZUluZGV4ID4gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgIGBbbXA0LXJlbXV4ZXJdOiBEcm9wcGVkICR7Zmlyc3RLZXlGcmFtZUluZGV4fSBvdXQgb2YgJHtsZW5ndGh9IHZpZGVvIHNhbXBsZXMgZHVlIHRvIGEgbWlzc2luZyBrZXlmcmFtZWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLnNsaWNlKGZpcnN0S2V5RnJhbWVJbmRleCk7XG4gICAgICAgICAgICB2aWRlb1RyYWNrLmRyb3BwZWQgKz0gZmlyc3RLZXlGcmFtZUluZGV4O1xuICAgICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9XG4gICAgICAgICAgICAgICh2aWRlb1RyYWNrLnNhbXBsZXNbMF0ucHRzIC0gc3RhcnRQVFMpIC9cbiAgICAgICAgICAgICAgdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgICAgIGZpcnN0S2V5RnJhbWVQVFMgPSB2aWRlb1RpbWVPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdEtleUZyYW1lSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgYFttcDQtcmVtdXhlcl06IE5vIGtleWZyYW1lIGZvdW5kIG91dCBvZiAke2xlbmd0aH0gdmlkZW8gc2FtcGxlc2BcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpbmRlcGVuZGVudCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgICBpZiAoZW5vdWdoQXVkaW9TYW1wbGVzICYmIGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgIC8vIHRpbWVPZmZzZXQgaXMgZXhwZWN0ZWQgdG8gYmUgdGhlIG9mZnNldCBvZiB0aGUgZmlyc3QgdGltZXN0YW1wIG9mIHRoaXMgZnJhZ21lbnQgKGZpcnN0IERUUylcbiAgICAgICAgICAvLyBpZiBmaXJzdCBhdWRpbyBEVFMgaXMgbm90IGFsaWduZWQgd2l0aCBmaXJzdCB2aWRlbyBEVFMgdGhlbiB3ZSBuZWVkIHRvIHRha2UgdGhhdCBpbnRvIGFjY291bnRcbiAgICAgICAgICAvLyB3aGVuIHByb3ZpZGluZyB0aW1lT2Zmc2V0IHRvIHJlbXV4QXVkaW8gLyByZW11eFZpZGVvLiBpZiB3ZSBkb24ndCBkbyB0aGF0LCB0aGVyZSBtaWdodCBiZSBhIHBlcm1hbmVudCAvIHNtYWxsXG4gICAgICAgICAgLy8gZHJpZnQgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtc1xuICAgICAgICAgIGNvbnN0IHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgY29uc3QgdHNEZWx0YSA9XG4gICAgICAgICAgICBub3JtYWxpemVQdHMoYXVkaW9UcmFjay5zYW1wbGVzWzBdLnB0cywgc3RhcnRQVFMpIC0gc3RhcnRQVFM7XG4gICAgICAgICAgY29uc3QgYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhID0gdHNEZWx0YSAvIHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgYXVkaW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIC1hdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHJlbXV4aW5nIGF1ZGlvIGJlZm9yZSB2aWRlbywgc28gdGhhdCByZW11eFZpZGVvIGNhbiB1c2UgbmV4dEF1ZGlvUHRzLCB3aGljaCBpcyBjYWxjdWxhdGVkIGluIHJlbXV4QXVkaW8uXG4gICAgICAgIGlmIChlbm91Z2hBdWRpb1NhbXBsZXMpIHtcbiAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgYXVkaW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICAgIGlmICghYXVkaW9UcmFjay5zYW1wbGVyYXRlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgJ1ttcDQtcmVtdXhlcl06IHJlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgYXVkaW8gZGV0ZWN0ZWQnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoXG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICAgICAgICAgIHZpZGVvVHJhY2ssXG4gICAgICAgICAgICAgIHRpbWVPZmZzZXQsXG4gICAgICAgICAgICAgIGFjY3VyYXRlVGltZU9mZnNldFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXVkaW8gPSB0aGlzLnJlbXV4QXVkaW8oXG4gICAgICAgICAgICBhdWRpb1RyYWNrLFxuICAgICAgICAgICAgYXVkaW9UaW1lT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyxcbiAgICAgICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgICAgICAgIGhhc1ZpZGVvIHx8XG4gICAgICAgICAgICAgIGVub3VnaFZpZGVvU2FtcGxlcyB8fFxuICAgICAgICAgICAgICBwbGF5bGlzdFR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPXG4gICAgICAgICAgICAgID8gdmlkZW9UaW1lT2Zmc2V0XG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb1RyYWNrTGVuZ3RoID0gYXVkaW8gPyBhdWRpby5lbmRQVFMgLSBhdWRpby5zdGFydFBUUyA6IDA7XG4gICAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICAgICAgaWYgKCF2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgICdbbXA0LXJlbXV4ZXJdOiByZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIHZpZGVvIGRldGVjdGVkJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLFxuICAgICAgICAgICAgICAgIHZpZGVvVHJhY2ssXG4gICAgICAgICAgICAgICAgdGltZU9mZnNldCxcbiAgICAgICAgICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZGVvID0gdGhpcy5yZW11eFZpZGVvKFxuICAgICAgICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQsXG4gICAgICAgICAgICAgIGlzVmlkZW9Db250aWd1b3VzLFxuICAgICAgICAgICAgICBhdWRpb1RyYWNrTGVuZ3RoXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICB2aWRlbyA9IHRoaXMucmVtdXhWaWRlbyhcbiAgICAgICAgICAgIHZpZGVvVHJhY2ssXG4gICAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQsXG4gICAgICAgICAgICBpc1ZpZGVvQ29udGlndW91cyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWRlbykge1xuICAgICAgICAgIHZpZGVvLmZpcnN0S2V5RnJhbWUgPSBmaXJzdEtleUZyYW1lSW5kZXg7XG4gICAgICAgICAgdmlkZW8uaW5kZXBlbmRlbnQgPSBmaXJzdEtleUZyYW1lSW5kZXggIT09IC0xO1xuICAgICAgICAgIHZpZGVvLmZpcnN0S2V5RnJhbWVQVFMgPSBmaXJzdEtleUZyYW1lUFRTO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgSUQzIGFuZCB0ZXh0IHRvIHJlbXV4LCBldmVuIGlmIG1vcmUgYXVkaW8vdmlkZW8gc2FtcGxlcyBhcmUgcmVxdWlyZWRcbiAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCAmJiB0aGlzLl9pbml0UFRTICYmIHRoaXMuX2luaXREVFMpIHtcbiAgICAgIGlmIChpZDNUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBpZDMgPSBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyhcbiAgICAgICAgICBpZDNUcmFjayxcbiAgICAgICAgICB0aW1lT2Zmc2V0LFxuICAgICAgICAgIHRoaXMuX2luaXRQVFMsXG4gICAgICAgICAgdGhpcy5faW5pdERUU1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRleHQgPSBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyhcbiAgICAgICAgICB0ZXh0VHJhY2ssXG4gICAgICAgICAgdGltZU9mZnNldCxcbiAgICAgICAgICB0aGlzLl9pbml0UFRTXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvLFxuICAgICAgdmlkZW8sXG4gICAgICBpbml0U2VnbWVudCxcbiAgICAgIGluZGVwZW5kZW50LFxuICAgICAgdGV4dCxcbiAgICAgIGlkMyxcbiAgICB9O1xuICB9XG5cbiAgZ2VuZXJhdGVJUyhcbiAgICBhdWRpb1RyYWNrOiBEZW11eGVkQXVkaW9UcmFjayxcbiAgICB2aWRlb1RyYWNrOiBEZW11eGVkQXZjVHJhY2ssXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGFjY3VyYXRlVGltZU9mZnNldDogYm9vbGVhblxuICApOiBJbml0U2VnbWVudERhdGEgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcztcbiAgICBjb25zdCB2aWRlb1NhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgY29uc3QgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZDtcbiAgICBjb25zdCB0cmFja3M6IFRyYWNrU2V0ID0ge307XG4gICAgY29uc3QgX2luaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGxldCBjb21wdXRlUFRTRFRTID0gIV9pbml0UFRTIHx8IGFjY3VyYXRlVGltZU9mZnNldDtcbiAgICBsZXQgY29udGFpbmVyID0gJ2F1ZGlvL21wNCc7XG4gICAgbGV0IGluaXRQVFM6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBsZXQgaW5pdERUUzogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGxldCB0aW1lc2NhbGU6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICBpbml0UFRTID0gaW5pdERUUyA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgYXVkaW8gc2FtcGxpbmcgcmF0ZSBhcyBNUDQgdGltZSBzY2FsZS5cbiAgICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IHRoZXJlIGlzIGEgaW50ZWdlciBuYiBvZiBhdWRpbyBmcmFtZXMgcGVyIGF1ZGlvIHNhbXBsZSAoMTAyNCBmb3IgQUFDKVxuICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxuICAgICAgLy8gdGhpcyBhdm9pZHMgcG90ZW50aWFsIHJvdW5kaW5nIGlzc3VlIGFuZCBBViBzeW5jIGlzc3VlXG4gICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suc2FtcGxlcmF0ZTtcbiAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5tcGVnKSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wZWcnO1xuICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZVN1cHBvcnRlZC5tcDMpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnbXAzJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgIGlkOiAnYXVkaW8nLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgY29kZWM6IGF1ZGlvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OlxuICAgICAgICAgIGF1ZGlvVHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0eXBlU3VwcG9ydGVkLm1wZWdcbiAgICAgICAgICAgID8gbmV3IFVpbnQ4QXJyYXkoMClcbiAgICAgICAgICAgIDogTVA0LmluaXRTZWdtZW50KFthdWRpb1RyYWNrXSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgY2hhbm5lbENvdW50OiBhdWRpb1RyYWNrLmNoYW5uZWxDb3VudCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aW1lc2NhbGUgPSBhdWRpb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICBpZiAoIV9pbml0UFRTIHx8IHRpbWVzY2FsZSAhPT0gX2luaXRQVFMudGltZXNjYWxlKSB7XG4gICAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIHRoaXMgZGVtdXhpbmcgY29udGV4dC4gZm9yIGF1ZGlvLCBQVFMgPSBEVFNcbiAgICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9XG4gICAgICAgICAgICBhdWRpb1NhbXBsZXNbMF0ucHRzIC0gTWF0aC5yb3VuZCh0aW1lc2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wdXRlUFRTRFRTID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlkZW9UcmFjay5zcHMgJiYgdmlkZW9UcmFjay5wcHMgJiYgdmlkZW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgLy8gbGV0J3MgdXNlIGlucHV0IHRpbWUgc2NhbGUgYXMgTVA0IHZpZGVvIHRpbWVzY2FsZVxuICAgICAgLy8gd2UgdXNlIGlucHV0IHRpbWUgc2NhbGUgc3RyYWlnaHQgYXdheSB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMgb24gZnJhbWUgZHVyYXRpb24gLyBjdHMgY29tcHV0YXRpb25cbiAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgaWQ6ICdtYWluJyxcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBNUDQuaW5pdFNlZ21lbnQoW3ZpZGVvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICB3aWR0aDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHZpZGVvVHJhY2suaGVpZ2h0LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRpbWVzY2FsZSA9IHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgIGlmICghX2luaXRQVFMgfHwgdGltZXNjYWxlICE9PSBfaW5pdFBUUy50aW1lc2NhbGUpIHtcbiAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1NhbXBsZXMpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gTWF0aC5yb3VuZCh0aW1lc2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICBpbml0RFRTID0gTWF0aC5taW4oXG4gICAgICAgICAgICBpbml0RFRTIGFzIG51bWJlcixcbiAgICAgICAgICAgIG5vcm1hbGl6ZVB0cyh2aWRlb1NhbXBsZXNbMF0uZHRzLCBzdGFydFBUUykgLSBzdGFydE9mZnNldFxuICAgICAgICAgICk7XG4gICAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMgYXMgbnVtYmVyLCBzdGFydFBUUyAtIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wdXRlUFRTRFRTID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IHtcbiAgICAgICAgICBiYXNlVGltZTogaW5pdFBUUyBhcyBudW1iZXIsXG4gICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUgYXMgbnVtYmVyLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbml0RFRTID0ge1xuICAgICAgICAgIGJhc2VUaW1lOiBpbml0RFRTIGFzIG51bWJlcixcbiAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZSBhcyBudW1iZXIsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0UFRTID0gdGltZXNjYWxlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFja3MsXG4gICAgICAgIGluaXRQVFMsXG4gICAgICAgIHRpbWVzY2FsZSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmVtdXhWaWRlbyhcbiAgICB0cmFjazogRGVtdXhlZEF2Y1RyYWNrLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBjb250aWd1b3VzOiBib29sZWFuLFxuICAgIGF1ZGlvVHJhY2tMZW5ndGg6IG51bWJlclxuICApOiBSZW11eGVkVHJhY2sgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHRpbWVTY2FsZTogbnVtYmVyID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgaW5wdXRTYW1wbGVzOiBBcnJheTxBdmNTYW1wbGU+ID0gdHJhY2suc2FtcGxlcztcbiAgICBjb25zdCBvdXRwdXRTYW1wbGVzOiBBcnJheTxNcDRTYW1wbGU+ID0gW107XG4gICAgY29uc3QgbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5faW5pdFBUUyBhcyBSYXRpb25hbFRpbWVzdGFtcDtcbiAgICBsZXQgbmV4dEF2Y0R0cyA9IHRoaXMubmV4dEF2Y0R0cztcbiAgICBsZXQgb2Zmc2V0ID0gODtcbiAgICBsZXQgbXA0U2FtcGxlRHVyYXRpb24gPSB0aGlzLnZpZGVvU2FtcGxlRHVyYXRpb247XG4gICAgbGV0IGZpcnN0RFRTO1xuICAgIGxldCBsYXN0RFRTO1xuICAgIGxldCBtaW5QVFM6IG51bWJlciA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4UFRTOiBudW1iZXIgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IHNvcnRTYW1wbGVzID0gZmFsc2U7XG5cbiAgICAvLyBpZiBwYXJzZWQgZnJhZ21lbnQgaXMgY29udGlndW91cyB3aXRoIGxhc3Qgb25lLCBsZXQncyB1c2UgbGFzdCBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlXG4gICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRBdmNEdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHB0cyA9IHRpbWVPZmZzZXQgKiB0aW1lU2NhbGU7XG4gICAgICBjb25zdCBjdHMgPVxuICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzIC1cbiAgICAgICAgbm9ybWFsaXplUHRzKGlucHV0U2FtcGxlc1swXS5kdHMsIGlucHV0U2FtcGxlc1swXS5wdHMpO1xuICAgICAgLy8gaWYgbm90IGNvbnRpZ3VvdXMsIGxldCdzIHVzZSB0YXJnZXQgdGltZU9mZnNldFxuICAgICAgbmV4dEF2Y0R0cyA9IHB0cyAtIGN0cztcbiAgICB9XG5cbiAgICAvLyBQVFMgaXMgY29kZWQgb24gMzNiaXRzLCBhbmQgY2FuIGxvb3AgZnJvbSAtMl4zMiB0byAyXjMyXG4gICAgLy8gUFRTTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgIGNvbnN0IGluaXRUaW1lID0gKGluaXRQVFMuYmFzZVRpbWUgKiB0aW1lU2NhbGUpIC8gaW5pdFBUUy50aW1lc2NhbGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgY29uc3Qgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFRpbWUsIG5leHRBdmNEdHMpO1xuICAgICAgc2FtcGxlLmR0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUuZHRzIC0gaW5pdFRpbWUsIG5leHRBdmNEdHMpO1xuICAgICAgaWYgKHNhbXBsZS5kdHMgPCBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpIC0gMSA6IGldLmR0cykge1xuICAgICAgICBzb3J0U2FtcGxlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc29ydCB2aWRlbyBzYW1wbGVzIGJ5IERUUyB0aGVuIFBUUyB0aGVuIGRlbXV4IGlkIG9yZGVyXG4gICAgaWYgKHNvcnRTYW1wbGVzKSB7XG4gICAgICBpbnB1dFNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBjb25zdCBkZWx0YWR0cyA9IGEuZHRzIC0gYi5kdHM7XG4gICAgICAgIGNvbnN0IGRlbHRhcHRzID0gYS5wdHMgLSBiLnB0cztcbiAgICAgICAgcmV0dXJuIGRlbHRhZHRzIHx8IGRlbHRhcHRzO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGZpcnN0L2xhc3QgRFRTXG4gICAgZmlyc3REVFMgPSBpbnB1dFNhbXBsZXNbMF0uZHRzO1xuICAgIGxhc3REVFMgPSBpbnB1dFNhbXBsZXNbaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDFdLmR0cztcblxuICAgIC8vIFNhbXBsZSBkdXJhdGlvbiAoYXMgZXhwZWN0ZWQgYnkgdHJ1biBNUDQgYm94ZXMpLCBzaG91bGQgYmUgdGhlIGRlbHRhIGJldHdlZW4gc2FtcGxlIERUU1xuICAgIC8vIHNldCB0aGlzIGNvbnN0YW50IGR1cmF0aW9uIGFzIGJlaW5nIHRoZSBhdmcgZGVsdGEgYmV0d2VlbiBjb25zZWN1dGl2ZSBEVFMuXG4gICAgY29uc3QgaW5wdXREdXJhdGlvbiA9IGxhc3REVFMgLSBmaXJzdERUUztcbiAgICBjb25zdCBhdmVyYWdlU2FtcGxlRHVyYXRpb24gPSBpbnB1dER1cmF0aW9uXG4gICAgICA/IE1hdGgucm91bmQoaW5wdXREdXJhdGlvbiAvIChuYlNhbXBsZXMgLSAxKSlcbiAgICAgIDogbXA0U2FtcGxlRHVyYXRpb24gfHwgdHJhY2suaW5wdXRUaW1lU2NhbGUgLyAzMDtcblxuICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xuICAgIGlmIChjb250aWd1b3VzKSB7XG4gICAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY3Jvc3MgY29uc2VjdXRpdmUgZnJhZ21lbnRzICh0aGlzIGlzIHRvIHJlbW92ZSBpbnRlci1mcmFnbWVudCBnYXAvaG9sZSlcbiAgICAgIGNvbnN0IGRlbHRhID0gZmlyc3REVFMgLSBuZXh0QXZjRHRzO1xuICAgICAgY29uc3QgZm91bmRIb2xlID0gZGVsdGEgPiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICBjb25zdCBmb3VuZE92ZXJsYXAgPSBkZWx0YSA8IC0xO1xuICAgICAgaWYgKGZvdW5kSG9sZSB8fCBmb3VuZE92ZXJsYXApIHtcbiAgICAgICAgaWYgKGZvdW5kSG9sZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYEFWQzogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKFxuICAgICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKX0gbXMgKCR7ZGVsdGF9ZHRzKSBob2xlIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkLCBmaWxsaW5nIGl0YFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgQVZDOiAke3RvTXNGcm9tTXBlZ1RzQ2xvY2soXG4gICAgICAgICAgICAgIC1kZWx0YSxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKX0gbXMgKCR7ZGVsdGF9ZHRzKSBvdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmRPdmVybGFwIHx8IG5leHRBdmNEdHMgPj0gaW5wdXRTYW1wbGVzWzBdLnB0cykge1xuICAgICAgICAgIGZpcnN0RFRTID0gbmV4dEF2Y0R0cztcbiAgICAgICAgICBjb25zdCBmaXJzdFBUUyA9IGlucHV0U2FtcGxlc1swXS5wdHMgLSBkZWx0YTtcbiAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFM7XG4gICAgICAgICAgaW5wdXRTYW1wbGVzWzBdLnB0cyA9IGZpcnN0UFRTO1xuICAgICAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICAgICBgVmlkZW86IEZpcnN0IFBUUy9EVFMgYWRqdXN0ZWQ6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhcbiAgICAgICAgICAgICAgZmlyc3RQVFMsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICl9LyR7dG9Nc0Zyb21NcGVnVHNDbG9jayhcbiAgICAgICAgICAgICAgZmlyc3REVFMsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICl9LCBkZWx0YTogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKGRlbHRhLCB0cnVlKX0gbXNgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZpcnN0RFRTID0gTWF0aC5tYXgoMCwgZmlyc3REVFMpO1xuXG4gICAgbGV0IG5iTmFsdSA9IDA7XG4gICAgbGV0IG5hbHVMZW4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIC8vIGNvbXB1dGUgdG90YWwvYXZjIHNhbXBsZSBsZW5ndGggYW5kIG5iIG9mIE5BTCB1bml0c1xuICAgICAgY29uc3Qgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgY29uc3QgdW5pdHMgPSBzYW1wbGUudW5pdHM7XG4gICAgICBjb25zdCBuYlVuaXRzID0gdW5pdHMubGVuZ3RoO1xuICAgICAgbGV0IHNhbXBsZUxlbiA9IDA7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5iVW5pdHM7IGorKykge1xuICAgICAgICBzYW1wbGVMZW4gKz0gdW5pdHNbal0uZGF0YS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIG5hbHVMZW4gKz0gc2FtcGxlTGVuO1xuICAgICAgbmJOYWx1ICs9IG5iVW5pdHM7XG4gICAgICBzYW1wbGUubGVuZ3RoID0gc2FtcGxlTGVuO1xuXG4gICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcbiAgICAgIHNhbXBsZS5kdHMgPSBNYXRoLm1heChzYW1wbGUuZHRzLCBmaXJzdERUUyk7XG5cbiAgICAgIG1pblBUUyA9IE1hdGgubWluKHNhbXBsZS5wdHMsIG1pblBUUyk7XG4gICAgICBtYXhQVFMgPSBNYXRoLm1heChzYW1wbGUucHRzLCBtYXhQVFMpO1xuICAgIH1cbiAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW25iU2FtcGxlcyAtIDFdLmR0cztcblxuICAgIC8qIGNvbmNhdGVuYXRlIHRoZSB2aWRlbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cbiAgICBjb25zdCBtZGF0U2l6ZSA9IG5hbHVMZW4gKyA0ICogbmJOYWx1ICsgODtcbiAgICBsZXQgbWRhdDtcbiAgICB0cnkge1xuICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1VWF9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgIGJ5dGVzOiBtZGF0U2l6ZSxcbiAgICAgICAgcmVhc29uOiBgZmFpbCBhbGxvY2F0aW5nIHZpZGVvIG1kYXQgJHttZGF0U2l6ZX1gLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcbiAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG5cbiAgICBsZXQgc3RyZXRjaGVkTGFzdEZyYW1lID0gZmFsc2U7XG4gICAgbGV0IG1pbkR0c0RlbHRhID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtaW5QdHNEZWx0YSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4RHRzRGVsdGEgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heFB0c0RlbHRhID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IGF2Y1NhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIGNvbnN0IGF2Y1NhbXBsZVVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xuICAgICAgbGV0IG1wNFNhbXBsZUxlbmd0aCA9IDA7XG4gICAgICAvLyBjb252ZXJ0IE5BTFUgYml0c3RyZWFtIHRvIE1QNCBmb3JtYXQgKHByZXBlbmQgTkFMVSB3aXRoIHNpemUgZmllbGQpXG4gICAgICBmb3IgKGxldCBqID0gMCwgbmJVbml0cyA9IGF2Y1NhbXBsZVVuaXRzLmxlbmd0aDsgaiA8IG5iVW5pdHM7IGorKykge1xuICAgICAgICBjb25zdCB1bml0ID0gYXZjU2FtcGxlVW5pdHNbal07XG4gICAgICAgIGNvbnN0IHVuaXREYXRhID0gdW5pdC5kYXRhO1xuICAgICAgICBjb25zdCB1bml0RGF0YUxlbiA9IHVuaXQuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIHVuaXREYXRhTGVuKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIG1kYXQuc2V0KHVuaXREYXRhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gdW5pdERhdGFMZW47XG4gICAgICAgIG1wNFNhbXBsZUxlbmd0aCArPSA0ICsgdW5pdERhdGFMZW47XG4gICAgICB9XG5cbiAgICAgIC8vIGV4cGVjdGVkIHNhbXBsZSBkdXJhdGlvbiBpcyB0aGUgRGVjb2RpbmcgVGltZXN0YW1wIGRpZmYgb2YgY29uc2VjdXRpdmUgc2FtcGxlc1xuICAgICAgbGV0IHB0c0RlbHRhO1xuICAgICAgaWYgKGkgPCBuYlNhbXBsZXMgLSAxKSB7XG4gICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gaW5wdXRTYW1wbGVzW2kgKyAxXS5kdHMgLSBhdmNTYW1wbGUuZHRzO1xuICAgICAgICBwdHNEZWx0YSA9IGlucHV0U2FtcGxlc1tpICsgMV0ucHRzIC0gYXZjU2FtcGxlLnB0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBsYXN0RnJhbWVEdXJhdGlvbiA9XG4gICAgICAgICAgaSA+IDBcbiAgICAgICAgICAgID8gYXZjU2FtcGxlLmR0cyAtIGlucHV0U2FtcGxlc1tpIC0gMV0uZHRzXG4gICAgICAgICAgICA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgcHRzRGVsdGEgPVxuICAgICAgICAgIGkgPiAwXG4gICAgICAgICAgICA/IGF2Y1NhbXBsZS5wdHMgLSBpbnB1dFNhbXBsZXNbaSAtIDFdLnB0c1xuICAgICAgICAgICAgOiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICAgIGlmIChjb25maWcuc3RyZXRjaFNob3J0VmlkZW9UcmFjayAmJiB0aGlzLm5leHRBdWRpb1B0cyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMsIGEgc2VnbWVudCdzIGF1ZGlvIHRyYWNrIGR1cmF0aW9uIG1heSBleGNlZWQgdGhlIHZpZGVvIHRyYWNrIGR1cmF0aW9uLlxuICAgICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGFscmVhZHkgcmVtdXhlZCBhdWRpbywgYW5kIHdlIGtub3cgaG93IGxvbmcgdGhlIGF1ZGlvIHRyYWNrIGlzLCB3ZSBsb29rIHRvXG4gICAgICAgICAgLy8gc2VlIGlmIHRoZSBkZWx0YSB0byB0aGUgbmV4dCBzZWdtZW50IGlzIGxvbmdlciB0aGFuIG1heEJ1ZmZlckhvbGUuXG4gICAgICAgICAgLy8gSWYgc28sIHBsYXliYWNrIHdvdWxkIHBvdGVudGlhbGx5IGdldCBzdHVjaywgc28gd2UgYXJ0aWZpY2lhbGx5IGluZmxhdGVcbiAgICAgICAgICAvLyB0aGUgZHVyYXRpb24gb2YgdGhlIGxhc3QgZnJhbWUgdG8gbWluaW1pemUgYW55IHBvdGVudGlhbCBnYXAgYmV0d2VlbiBzZWdtZW50cy5cbiAgICAgICAgICBjb25zdCBnYXBUb2xlcmFuY2UgPSBNYXRoLmZsb29yKGNvbmZpZy5tYXhCdWZmZXJIb2xlICogdGltZVNjYWxlKTtcbiAgICAgICAgICBjb25zdCBkZWx0YVRvRnJhbWVFbmQgPVxuICAgICAgICAgICAgKGF1ZGlvVHJhY2tMZW5ndGhcbiAgICAgICAgICAgICAgPyBtaW5QVFMgKyBhdWRpb1RyYWNrTGVuZ3RoICogdGltZVNjYWxlXG4gICAgICAgICAgICAgIDogdGhpcy5uZXh0QXVkaW9QdHMpIC0gYXZjU2FtcGxlLnB0cztcbiAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBsYXN0RnJhbWVEdXJhdGlvbiBmcm9tIGRlbHRhVG9GcmFtZUVuZCB0byB0cnkgdG8gcHJldmVudCBhbnkgdmlkZW9cbiAgICAgICAgICAgIC8vIGZyYW1lIG92ZXJsYXAuIG1heEJ1ZmZlckhvbGUgc2hvdWxkIGJlID4+IGxhc3RGcmFtZUR1cmF0aW9uIGFueXdheS5cbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICBpZiAobXA0U2FtcGxlRHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJldGNoZWRMYXN0RnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgICAgYFttcDQtcmVtdXhlcl06IEl0IGlzIGFwcHJveGltYXRlbHkgJHtcbiAgICAgICAgICAgICAgICBkZWx0YVRvRnJhbWVFbmQgLyA5MFxuICAgICAgICAgICAgICB9IG1zIHRvIHRoZSBuZXh0IHNlZ21lbnQ7IHVzaW5nIGR1cmF0aW9uICR7XG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gLyA5MFxuICAgICAgICAgICAgICB9IG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLnJvdW5kKGF2Y1NhbXBsZS5wdHMgLSBhdmNTYW1wbGUuZHRzKTtcbiAgICAgIG1pbkR0c0RlbHRhID0gTWF0aC5taW4obWluRHRzRGVsdGEsIG1wNFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgIG1heER0c0RlbHRhID0gTWF0aC5tYXgobWF4RHRzRGVsdGEsIG1wNFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgIG1pblB0c0RlbHRhID0gTWF0aC5taW4obWluUHRzRGVsdGEsIHB0c0RlbHRhKTtcbiAgICAgIG1heFB0c0RlbHRhID0gTWF0aC5tYXgobWF4UHRzRGVsdGEsIHB0c0RlbHRhKTtcblxuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKFxuICAgICAgICBuZXcgTXA0U2FtcGxlKFxuICAgICAgICAgIGF2Y1NhbXBsZS5rZXksXG4gICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24sXG4gICAgICAgICAgbXA0U2FtcGxlTGVuZ3RoLFxuICAgICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvdXRwdXRTYW1wbGVzLmxlbmd0aCkge1xuICAgICAgaWYgKGNocm9tZVZlcnNpb24pIHtcbiAgICAgICAgaWYgKGNocm9tZVZlcnNpb24gPCA3MCkge1xuICAgICAgICAgIC8vIENocm9tZSB3b3JrYXJvdW5kLCBtYXJrIGZpcnN0IHNhbXBsZSBhcyBiZWluZyBhIFJhbmRvbSBBY2Nlc3MgUG9pbnQgKGtleWZyYW1lKSB0byBhdm9pZCBzb3VyY2VidWZmZXIgYXBwZW5kIGlzc3VlXG4gICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxuICAgICAgICAgIGNvbnN0IGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcbiAgICAgICAgICBmbGFncy5kZXBlbmRzT24gPSAyO1xuICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2FmYXJpV2Via2l0VmVyc2lvbikge1xuICAgICAgICAvLyBGaXggZm9yIFwiQ05OIHNwZWNpYWwgcmVwb3J0LCB3aXRoIENDXCIgaW4gdGVzdC1zdHJlYW1zIChTYWZhcmkgYnJvd3NlciBvbmx5KVxuICAgICAgICAvLyBJZ25vcmUgRFRTIHdoZW4gZnJhbWUgZHVyYXRpb25zIGFyZSBpcnJlZ3VsYXIuIFNhZmFyaSBNU0UgZG9lcyBub3QgaGFuZGxlIHRoaXMgbGVhZGluZyB0byBnYXBzLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgbWF4UHRzRGVsdGEgLSBtaW5QdHNEZWx0YSA8IG1heER0c0RlbHRhIC0gbWluRHRzRGVsdGEgJiZcbiAgICAgICAgICBhdmVyYWdlU2FtcGxlRHVyYXRpb24gLyBtYXhEdHNEZWx0YSA8IDAuMDI1ICYmXG4gICAgICAgICAgb3V0cHV0U2FtcGxlc1swXS5jdHMgPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAnRm91bmQgaXJyZWd1bGFyIGdhcHMgaW4gc2FtcGxlIGR1cmF0aW9uLiBVc2luZyBQVFMgaW5zdGVhZCBvZiBEVFMgdG8gZGV0ZXJtaW5lIE1QNCBzYW1wbGUgZHVyYXRpb24uJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGR0cyA9IGZpcnN0RFRTO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0RHRzID0gZHRzICsgb3V0cHV0U2FtcGxlc1tpXS5kdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHB0cyA9IGR0cyArIG91dHB1dFNhbXBsZXNbaV0uY3RzO1xuICAgICAgICAgICAgaWYgKGkgPCBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRQdHMgPSBuZXh0RHRzICsgb3V0cHV0U2FtcGxlc1tpICsgMV0uY3RzO1xuICAgICAgICAgICAgICBvdXRwdXRTYW1wbGVzW2ldLmR1cmF0aW9uID0gbmV4dFB0cyAtIHB0cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbaV0uZHVyYXRpb24gPSBpXG4gICAgICAgICAgICAgICAgPyBvdXRwdXRTYW1wbGVzW2kgLSAxXS5kdXJhdGlvblxuICAgICAgICAgICAgICAgIDogYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tpXS5jdHMgPSAwO1xuICAgICAgICAgICAgZHRzID0gbmV4dER0cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbmV4dCBBVkMgc2FtcGxlIERUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgRFRTICsgbGFzdCBzYW1wbGUgZHVyYXRpb24gKGluIFBFUyB0aW1lc2NhbGUpXG4gICAgbXA0U2FtcGxlRHVyYXRpb24gPVxuICAgICAgc3RyZXRjaGVkTGFzdEZyYW1lIHx8ICFtcDRTYW1wbGVEdXJhdGlvblxuICAgICAgICA/IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvblxuICAgICAgICA6IG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIHRoaXMubmV4dEF2Y0R0cyA9IG5leHRBdmNEdHMgPSBsYXN0RFRTICsgbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IHRydWU7XG4gICAgY29uc3QgbW9vZiA9IE1QNC5tb29mKFxuICAgICAgdHJhY2suc2VxdWVuY2VOdW1iZXIrKyxcbiAgICAgIGZpcnN0RFRTLFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdHJhY2ssIHtcbiAgICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlcyxcbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCB0eXBlOiBTb3VyY2VCdWZmZXJOYW1lID0gJ3ZpZGVvJztcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBtaW5QVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmRQVFM6IChtYXhQVFMgKyBtcDRTYW1wbGVEdXJhdGlvbikgLyB0aW1lU2NhbGUsXG4gICAgICBzdGFydERUUzogZmlyc3REVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmREVFM6IChuZXh0QXZjRHRzIGFzIG51bWJlcikgLyB0aW1lU2NhbGUsXG4gICAgICB0eXBlLFxuICAgICAgaGFzQXVkaW86IGZhbHNlLFxuICAgICAgaGFzVmlkZW86IHRydWUsXG4gICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICBkcm9wcGVkOiB0cmFjay5kcm9wcGVkLFxuICAgIH07XG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIHRyYWNrLmRyb3BwZWQgPSAwO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcmVtdXhBdWRpbyhcbiAgICB0cmFjazogRGVtdXhlZEF1ZGlvVHJhY2ssXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGNvbnRpZ3VvdXM6IGJvb2xlYW4sXG4gICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiBib29sZWFuLFxuICAgIHZpZGVvVGltZU9mZnNldD86IG51bWJlclxuICApOiBSZW11eGVkVHJhY2sgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGlucHV0VGltZVNjYWxlOiBudW1iZXIgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBtcDR0aW1lU2NhbGU6IG51bWJlciA9IHRyYWNrLnNhbXBsZXJhdGVcbiAgICAgID8gdHJhY2suc2FtcGxlcmF0ZVxuICAgICAgOiBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBzY2FsZUZhY3RvcjogbnVtYmVyID0gaW5wdXRUaW1lU2NhbGUgLyBtcDR0aW1lU2NhbGU7XG4gICAgY29uc3QgbXA0U2FtcGxlRHVyYXRpb246IG51bWJlciA9XG4gICAgICB0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnXG4gICAgICAgID8gQUFDX1NBTVBMRVNfUEVSX0ZSQU1FXG4gICAgICAgIDogTVBFR19BVURJT19TQU1QTEVfUEVSX0ZSQU1FO1xuICAgIGNvbnN0IGlucHV0U2FtcGxlRHVyYXRpb246IG51bWJlciA9IG1wNFNhbXBsZUR1cmF0aW9uICogc2NhbGVGYWN0b3I7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFMgYXMgUmF0aW9uYWxUaW1lc3RhbXA7XG4gICAgY29uc3QgcmF3TVBFRzogYm9vbGVhbiA9XG4gICAgICB0cmFjay5zZWdtZW50Q29kZWMgPT09ICdtcDMnICYmIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnO1xuICAgIGNvbnN0IG91dHB1dFNhbXBsZXM6IEFycmF5PE1wNFNhbXBsZT4gPSBbXTtcbiAgICBjb25zdCBhbGlnbmVkV2l0aFZpZGVvID0gdmlkZW9UaW1lT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG5cbiAgICBsZXQgaW5wdXRTYW1wbGVzOiBBcnJheTxBdWRpb1NhbXBsZT4gPSB0cmFjay5zYW1wbGVzO1xuICAgIGxldCBvZmZzZXQ6IG51bWJlciA9IHJhd01QRUcgPyAwIDogODtcbiAgICBsZXQgbmV4dEF1ZGlvUHRzOiBudW1iZXIgPSB0aGlzLm5leHRBdWRpb1B0cyB8fCAtMTtcblxuICAgIC8vIHdpbmRvdy5hdWRpb1NhbXBsZXMgPyB3aW5kb3cuYXVkaW9TYW1wbGVzLnB1c2goaW5wdXRTYW1wbGVzLm1hcChzID0+IHMucHRzKSkgOiAod2luZG93LmF1ZGlvU2FtcGxlcyA9IFtpbnB1dFNhbXBsZXMubWFwKHMgPT4gcy5wdHMpXSk7XG5cbiAgICAvLyBmb3IgYXVkaW8gc2FtcGxlcywgYWxzbyBjb25zaWRlciBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXMgYmVpbmcgY29udGlndW91cyAoZXZlbiBpZiBhIGxldmVsIHN3aXRjaCBvY2N1cnMpLFxuICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgLy8gY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFyZSBmcmFncyB3aXRoXG4gICAgLy8gIC0gbGVzcyB0aGFuIDEwMG1zIGdhcHMgYmV0d2VlbiBuZXcgdGltZSBvZmZzZXQgKGlmIGFjY3VyYXRlKSBhbmQgbmV4dCBleHBlY3RlZCBQVFMgT1JcbiAgICAvLyAgLSBsZXNzIHRoYW4gMjAgYXVkaW8gZnJhbWVzIGRpc3RhbmNlXG4gICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAvLyB0aGlzIGhlbHBzIGVuc3VyaW5nIGF1ZGlvIGNvbnRpbnVpdHlcbiAgICAvLyBhbmQgdGhpcyBhbHNvIGF2b2lkcyBhdWRpbyBnbGl0Y2hlcy9jdXQgd2hlbiBzd2l0Y2hpbmcgcXVhbGl0eSwgb3IgcmVwb3J0aW5nIHdyb25nIGR1cmF0aW9uIG9uIGZpcnN0IGF1ZGlvIGZyYW1lXG4gICAgY29uc3QgdGltZU9mZnNldE1wZWdUUyA9IHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBpbml0VGltZSA9IChpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUpIC8gaW5pdFBUUy50aW1lc2NhbGU7XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IGNvbnRpZ3VvdXMgPVxuICAgICAgY29udGlndW91cyB8fFxuICAgICAgKChpbnB1dFNhbXBsZXMubGVuZ3RoICYmXG4gICAgICAgIG5leHRBdWRpb1B0cyA+IDAgJiZcbiAgICAgICAgKChhY2N1cmF0ZVRpbWVPZmZzZXQgJiZcbiAgICAgICAgICBNYXRoLmFicyh0aW1lT2Zmc2V0TXBlZ1RTIC0gbmV4dEF1ZGlvUHRzKSA8IDkwMDApIHx8XG4gICAgICAgICAgTWF0aC5hYnMoXG4gICAgICAgICAgICBub3JtYWxpemVQdHMoaW5wdXRTYW1wbGVzWzBdLnB0cyAtIGluaXRUaW1lLCB0aW1lT2Zmc2V0TXBlZ1RTKSAtXG4gICAgICAgICAgICAgIG5leHRBdWRpb1B0c1xuICAgICAgICAgICkgPFxuICAgICAgICAgICAgMjAgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKSkgYXMgYm9vbGVhbik7XG5cbiAgICAvLyBjb21wdXRlIG5vcm1hbGl6ZWQgUFRTXG4gICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFRpbWUsIHRpbWVPZmZzZXRNcGVnVFMpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRBdWRpb1B0cyA8IDApIHtcbiAgICAgIC8vIGZpbHRlciBvdXQgc2FtcGxlIHdpdGggbmVnYXRpdmUgUFRTIHRoYXQgYXJlIG5vdCBwbGF5YWJsZSBhbnl3YXlcbiAgICAgIC8vIGlmIHdlIGRvbid0IHJlbW92ZSB0aGVzZSBuZWdhdGl2ZSBzYW1wbGVzLCB0aGV5IHdpbGwgc2hpZnQgYWxsIGF1ZGlvIHNhbXBsZXMgZm9yd2FyZC5cbiAgICAgIC8vIGxlYWRpbmcgdG8gYXVkaW8gb3ZlcmxhcCBiZXR3ZWVuIGN1cnJlbnQgLyBuZXh0IGZyYWdtZW50XG4gICAgICBpbnB1dFNhbXBsZXMgPSBpbnB1dFNhbXBsZXMuZmlsdGVyKChzYW1wbGUpID0+IHNhbXBsZS5wdHMgPj0gMCk7XG5cbiAgICAgIC8vIGluIGNhc2UgYWxsIHNhbXBsZXMgaGF2ZSBuZWdhdGl2ZSBQVFMsIGFuZCBoYXZlIGJlZW4gZmlsdGVyZWQgb3V0LCByZXR1cm4gbm93XG4gICAgICBpZiAoIWlucHV0U2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodmlkZW9UaW1lT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIC8vIFNldCB0aGUgc3RhcnQgdG8gMCB0byBtYXRjaCB2aWRlbyBzbyB0aGF0IHN0YXJ0IGdhcHMgbGFyZ2VyIHRoYW4gaW5wdXRTYW1wbGVEdXJhdGlvbiBhcmUgZmlsbGVkIHdpdGggc2lsZW5jZVxuICAgICAgICBuZXh0QXVkaW9QdHMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgIWFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgLy8gV2hlbiBub3Qgc2Vla2luZywgbm90IGxpdmUsIGFuZCBMZXZlbERldGFpbHMuUFRTS25vd24sIHVzZSBmcmFnbWVudCBzdGFydCBhcyBwcmVkaWN0ZWQgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gTWF0aC5tYXgoMCwgdGltZU9mZnNldE1wZWdUUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBmcmFncyBhcmUgbm90IGNvbnRpZ3VvdXMgYW5kIGlmIHdlIGNhbnQgdHJ1c3QgdGltZSBvZmZzZXQsIGxldCdzIHVzZSBmaXJzdCBzYW1wbGUgUFRTIGFzIG5leHQgYXVkaW8gUFRTXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IGlucHV0U2FtcGxlc1swXS5wdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcbiAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgIC8vIEluIGFuIGVmZm9ydCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcsIHdlIGluamVjdCBmcmFtZXMgaGVyZSB3aGVyZSB0aGVyZSBhcmUgZ2Fwcy5cbiAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XG4gICAgLy8gZnJhbWUuXG5cbiAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgY29uc3QgbWF4QXVkaW9GcmFtZXNEcmlmdCA9IHRoaXMuY29uZmlnLm1heEF1ZGlvRnJhbWVzRHJpZnQ7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbmV4dFB0cyA9IG5leHRBdWRpb1B0czsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaXJzdCwgbGV0J3Mgc2VlIGhvdyBmYXIgb2ZmIHRoaXMgZnJhbWUgaXMgZnJvbSB3aGVyZSB3ZSBleHBlY3QgaXQgdG8gYmVcbiAgICAgICAgY29uc3Qgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgICBjb25zdCBwdHMgPSBzYW1wbGUucHRzO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHB0cyAtIG5leHRQdHM7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5hYnMoKDEwMDAgKiBkZWx0YSkgLyBpbnB1dFRpbWVTY2FsZSk7XG5cbiAgICAgICAgLy8gV2hlbiByZW11eGluZyB3aXRoIHZpZGVvLCBpZiB3ZSdyZSBvdmVybGFwcGluZyBieSBtb3JlIHRoYW4gYSBkdXJhdGlvbiwgZHJvcCB0aGlzIHNhbXBsZSB0byBzdGF5IGluIHN5bmNcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGRlbHRhIDw9IC1tYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbiAmJlxuICAgICAgICAgIGFsaWduZWRXaXRoVmlkZW9cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICBgQXVkaW8gZnJhbWUgQCAkeyhwdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZChcbiAgICAgICAgICAgICAgICAzXG4gICAgICAgICAgICAgICl9cyBvdmVybGFwcyBuZXh0QXVkaW9QdHMgYnkgJHtNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICgxMDAwICogZGVsdGEpIC8gaW5wdXRUaW1lU2NhbGVcbiAgICAgICAgICAgICAgKX0gbXMuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbmV4dFB0cyA9IHB0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuXG4gICAgICAgIC8vIEluc2VydCBtaXNzaW5nIGZyYW1lcyBpZjpcbiAgICAgICAgLy8gMTogV2UncmUgbW9yZSB0aGFuIG1heEF1ZGlvRnJhbWVzRHJpZnQgZnJhbWUgYXdheVxuICAgICAgICAvLyAyOiBOb3QgbW9yZSB0aGFuIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gYXdheVxuICAgICAgICAvLyAzOiBjdXJyZW50VGltZSAoYWthIG5leHRQdHNOb3JtKSBpcyBub3QgMFxuICAgICAgICAvLyA0OiByZW11eGluZyB3aXRoIHZpZGVvICh2aWRlb1RpbWVPZmZzZXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgZGVsdGEgPj0gbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiZcbiAgICAgICAgICBkdXJhdGlvbiA8IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gJiZcbiAgICAgICAgICBhbGlnbmVkV2l0aFZpZGVvXG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgIC8vIEFkanVzdCBuZXh0UHRzIHNvIHRoYXQgc2lsZW50IHNhbXBsZXMgYXJlIGFsaWduZWQgd2l0aCBtZWRpYSBwdHMuIFRoaXMgd2lsbCBwcmV2ZW50IG1lZGlhIHNhbXBsZXMgZnJvbVxuICAgICAgICAgIC8vIGxhdGVyIGJlaW5nIHNoaWZ0ZWQgaWYgbmV4dFB0cyBpcyBiYXNlZCBvbiB0aW1lT2Zmc2V0IGFuZCBkZWx0YSBpcyBub3QgYSBtdWx0aXBsZSBvZiBpbnB1dFNhbXBsZUR1cmF0aW9uLlxuICAgICAgICAgIG5leHRQdHMgPSBwdHMgLSBtaXNzaW5nICogaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICBpZiAobmV4dFB0cyA8IDApIHtcbiAgICAgICAgICAgIG1pc3NpbmctLTtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbmV4dFB0cztcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgW21wNC1yZW11eGVyXTogSW5qZWN0aW5nICR7bWlzc2luZ30gYXVkaW8gZnJhbWUgQCAkeyhcbiAgICAgICAgICAgICAgbmV4dFB0cyAvIGlucHV0VGltZVNjYWxlXG4gICAgICAgICAgICApLnRvRml4ZWQoMyl9cyBkdWUgdG8gJHtNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAoMTAwMCAqIGRlbHRhKSAvIGlucHV0VGltZVNjYWxlXG4gICAgICAgICAgICApfSBtcyBnYXAuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YW1wID0gTWF0aC5tYXgobmV4dFB0cyBhcyBudW1iZXIsIDApO1xuICAgICAgICAgICAgbGV0IGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZShcbiAgICAgICAgICAgICAgdHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYyxcbiAgICAgICAgICAgICAgdHJhY2suY2hhbm5lbENvdW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgICAgICAnW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBzYW1wbGUudW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAwLCB7XG4gICAgICAgICAgICAgIHVuaXQ6IGZpbGxGcmFtZSxcbiAgICAgICAgICAgICAgcHRzOiBuZXdTdGFtcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzYW1wbGUucHRzID0gbmV4dFB0cztcbiAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZmlyc3RQVFM6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgIGxldCBsYXN0UFRTOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgbWRhdDogYW55O1xuICAgIGxldCBtZGF0U2l6ZTogbnVtYmVyID0gMDtcbiAgICBsZXQgc2FtcGxlTGVuZ3RoOiBudW1iZXIgPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIHdoaWxlIChzYW1wbGVMZW5ndGgtLSkge1xuICAgICAgbWRhdFNpemUgKz0gaW5wdXRTYW1wbGVzW3NhbXBsZUxlbmd0aF0udW5pdC5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMCwgbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDsgaiA8IG5iU2FtcGxlczsgaisrKSB7XG4gICAgICBjb25zdCBhdWRpb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tqXTtcbiAgICAgIGNvbnN0IHVuaXQgPSBhdWRpb1NhbXBsZS51bml0O1xuICAgICAgbGV0IHB0cyA9IGF1ZGlvU2FtcGxlLnB0cztcbiAgICAgIGlmIChsYXN0UFRTICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzYW1wbGUsIHNldCB0aGUgZHVyYXRpb24gb2YgdGhlIHNhbXBsZSB0byB0aGUgXCJyZWFsXCIgZHVyYXRpb247IHRoZSBQVFMgZGlmZiB3aXRoXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyBzYW1wbGVcbiAgICAgICAgY29uc3QgcHJldlNhbXBsZSA9IG91dHB1dFNhbXBsZXNbaiAtIDFdO1xuICAgICAgICBwcmV2U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgocHRzIC0gbGFzdFBUUykgLyBzY2FsZUZhY3Rvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29udGlndW91cyAmJiB0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgICAgLy8gc2V0IFBUUy9EVFMgdG8gZXhwZWN0ZWQgUFRTL0RUU1xuICAgICAgICAgIHB0cyA9IG5leHRBdWRpb1B0cztcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2Ygb3VyIGF1ZGlvU2FtcGxlc1xuICAgICAgICBmaXJzdFBUUyA9IHB0cztcbiAgICAgICAgaWYgKG1kYXRTaXplID4gMCkge1xuICAgICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuICAgICAgICAgIG1kYXRTaXplICs9IG9mZnNldDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1VWF9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgIGJ5dGVzOiBtZGF0U2l6ZSxcbiAgICAgICAgICAgICAgcmVhc29uOiBgZmFpbCBhbGxvY2F0aW5nIGF1ZGlvIG1kYXQgJHttZGF0U2l6ZX1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmF3TVBFRykge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIGF1ZGlvIHNhbXBsZXNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1kYXQuc2V0KHVuaXQsIG9mZnNldCk7XG4gICAgICBjb25zdCB1bml0TGVuID0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgb2Zmc2V0ICs9IHVuaXRMZW47XG4gICAgICAvLyBEZWZhdWx0IHRoZSBzYW1wbGUncyBkdXJhdGlvbiB0byB0aGUgY29tcHV0ZWQgbXA0U2FtcGxlRHVyYXRpb24sIHdoaWNoIHdpbGwgZWl0aGVyIGJlIDEwMjQgZm9yIEFBQyBvciAxMTUyIGZvciBNUEVHXG4gICAgICAvLyBJbiB0aGUgY2FzZSB0aGF0IHdlIGhhdmUgMSBzYW1wbGUsIHRoaXMgd2lsbCBiZSB0aGUgZHVyYXRpb24uIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzYW1wbGUsIHRoZSBkdXJhdGlvblxuICAgICAgLy8gYmVjb21lcyB0aGUgUFRTIGRpZmYgd2l0aCB0aGUgcHJldmlvdXMgc2FtcGxlXG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobmV3IE1wNFNhbXBsZSh0cnVlLCBtcDRTYW1wbGVEdXJhdGlvbiwgdW5pdExlbiwgMCkpO1xuICAgICAgbGFzdFBUUyA9IHB0cztcbiAgICB9XG5cbiAgICAvLyBXZSBjb3VsZCBlbmQgdXAgd2l0aCBubyBhdWRpbyBzYW1wbGVzIGlmIGFsbCBpbnB1dCBzYW1wbGVzIHdlcmUgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJldmlvdXNseSByZW11eGVkIG9uZXNcbiAgICBjb25zdCBuYlNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDtcbiAgICBpZiAoIW5iU2FtcGxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZSBuZXh0IGF1ZGlvIHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGR1cmF0aW9uXG4gICAgY29uc3QgbGFzdFNhbXBsZSA9IG91dHB1dFNhbXBsZXNbb3V0cHV0U2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9XG4gICAgICBsYXN0UFRTISArIHNjYWxlRmFjdG9yICogbGFzdFNhbXBsZS5kdXJhdGlvbjtcblxuICAgIC8vIFNldCB0aGUgdHJhY2sgc2FtcGxlcyBmcm9tIGlucHV0U2FtcGxlcyB0byBvdXRwdXRTYW1wbGVzIGJlZm9yZSByZW11eGluZ1xuICAgIGNvbnN0IG1vb2YgPSByYXdNUEVHXG4gICAgICA/IG5ldyBVaW50OEFycmF5KDApXG4gICAgICA6IE1QNC5tb29mKFxuICAgICAgICAgIHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssXG4gICAgICAgICAgZmlyc3RQVFMhIC8gc2NhbGVGYWN0b3IsXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdHJhY2ssIHsgc2FtcGxlczogb3V0cHV0U2FtcGxlcyB9KVxuICAgICAgICApO1xuXG4gICAgLy8gQ2xlYXIgdGhlIHRyYWNrIHNhbXBsZXMuIFRoaXMgYWxzbyBjbGVhcnMgdGhlIHNhbXBsZXMgYXJyYXkgaW4gdGhlIGRlbXV4ZXIsIHNpbmNlIHRoZSByZWZlcmVuY2UgaXMgc2hhcmVkXG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIGNvbnN0IHN0YXJ0ID0gZmlyc3RQVFMhIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgZW5kID0gbmV4dEF1ZGlvUHRzIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgdHlwZTogU291cmNlQnVmZmVyTmFtZSA9ICdhdWRpbyc7XG4gICAgY29uc3QgYXVkaW9EYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBzdGFydCxcbiAgICAgIGVuZFBUUzogZW5kLFxuICAgICAgc3RhcnREVFM6IHN0YXJ0LFxuICAgICAgZW5kRFRTOiBlbmQsXG4gICAgICB0eXBlLFxuICAgICAgaGFzQXVkaW86IHRydWUsXG4gICAgICBoYXNWaWRlbzogZmFsc2UsXG4gICAgICBuYjogbmJTYW1wbGVzLFxuICAgIH07XG5cbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gdHJ1ZTtcbiAgICByZXR1cm4gYXVkaW9EYXRhO1xuICB9XG5cbiAgcmVtdXhFbXB0eUF1ZGlvKFxuICAgIHRyYWNrOiBEZW11eGVkQXVkaW9UcmFjayxcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gICAgY29udGlndW91czogYm9vbGVhbixcbiAgICB2aWRlb0RhdGE6IEZyYWdtZW50XG4gICk6IFJlbXV4ZWRUcmFjayB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGU6IG51bWJlciA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IG1wNHRpbWVTY2FsZTogbnVtYmVyID0gdHJhY2suc2FtcGxlcmF0ZVxuICAgICAgPyB0cmFjay5zYW1wbGVyYXRlXG4gICAgICA6IGlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yOiBudW1iZXIgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICBjb25zdCBuZXh0QXVkaW9QdHM6IG51bWJlciB8IG51bGwgPSB0aGlzLm5leHRBdWRpb1B0cztcbiAgICAvLyBzeW5jIHdpdGggdmlkZW8ncyB0aW1lc3RhbXBcbiAgICBjb25zdCBpbml0RFRTID0gdGhpcy5faW5pdERUUyBhcyBSYXRpb25hbFRpbWVzdGFtcDtcbiAgICBjb25zdCBpbml0OTBrSHogPSAoaW5pdERUUy5iYXNlVGltZSAqIDkwMDAwKSAvIGluaXREVFMudGltZXNjYWxlO1xuICAgIGNvbnN0IHN0YXJ0RFRTOiBudW1iZXIgPVxuICAgICAgKG5leHRBdWRpb1B0cyAhPT0gbnVsbFxuICAgICAgICA/IG5leHRBdWRpb1B0c1xuICAgICAgICA6IHZpZGVvRGF0YS5zdGFydERUUyAqIGlucHV0VGltZVNjYWxlKSArIGluaXQ5MGtIejtcbiAgICBjb25zdCBlbmREVFM6IG51bWJlciA9IHZpZGVvRGF0YS5lbmREVFMgKiBpbnB1dFRpbWVTY2FsZSArIGluaXQ5MGtIejtcbiAgICAvLyBvbmUgc2FtcGxlJ3MgZHVyYXRpb24gdmFsdWVcbiAgICBjb25zdCBmcmFtZUR1cmF0aW9uOiBudW1iZXIgPSBzY2FsZUZhY3RvciAqIEFBQ19TQU1QTEVTX1BFUl9GUkFNRTtcbiAgICAvLyBzYW1wbGVzIGNvdW50IG9mIHRoaXMgc2VnbWVudCdzIGR1cmF0aW9uXG4gICAgY29uc3QgbmJTYW1wbGVzOiBudW1iZXIgPSBNYXRoLmNlaWwoKGVuZERUUyAtIHN0YXJ0RFRTKSAvIGZyYW1lRHVyYXRpb24pO1xuICAgIC8vIHNpbGVudCBmcmFtZVxuICAgIGNvbnN0IHNpbGVudEZyYW1lOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkID0gQUFDLmdldFNpbGVudEZyYW1lKFxuICAgICAgdHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYyxcbiAgICAgIHRyYWNrLmNoYW5uZWxDb3VudFxuICAgICk7XG5cbiAgICBsb2dnZXIud2FybignW21wNC1yZW11eGVyXTogcmVtdXggZW1wdHkgQXVkaW8nKTtcbiAgICAvLyBDYW4ndCByZW11eCBpZiB3ZSBjYW4ndCBnZW5lcmF0ZSBhIHNpbGVudCBmcmFtZS4uLlxuICAgIGlmICghc2lsZW50RnJhbWUpIHtcbiAgICAgIGxvZ2dlci50cmFjZShcbiAgICAgICAgJ1ttcDQtcmVtdXhlcl06IFVuYWJsZSB0byByZW11eEVtcHR5QXVkaW8gc2luY2Ugd2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGEgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYydcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2FtcGxlczogQXJyYXk8YW55PiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YW1wID0gc3RhcnREVFMgKyBpICogZnJhbWVEdXJhdGlvbjtcbiAgICAgIHNhbXBsZXMucHVzaCh7IHVuaXQ6IHNpbGVudEZyYW1lLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wIH0pO1xuICAgIH1cbiAgICB0cmFjay5zYW1wbGVzID0gc2FtcGxlcztcblxuICAgIHJldHVybiB0aGlzLnJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGZhbHNlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUHRzKHZhbHVlOiBudW1iZXIsIHJlZmVyZW5jZTogbnVtYmVyIHwgbnVsbCk6IG51bWJlciB7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChyZWZlcmVuY2UgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAvLyAtIDJeMzNcbiAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcbiAgfSBlbHNlIHtcbiAgICAvLyArIDJeMzNcbiAgICBvZmZzZXQgPSA4NTg5OTM0NTkyO1xuICB9XG4gIC8qIFBUUyBpcyAzM2JpdCAoZnJvbSAwIHRvIDJeMzMgLTEpXG4gICAgaWYgZGlmZiBiZXR3ZWVuIHZhbHVlIGFuZCByZWZlcmVuY2UgaXMgYmlnZ2VyIHRoYW4gaGFsZiBvZiB0aGUgYW1wbGl0dWRlICgyXjMyKSB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cbiAgd2hpbGUgKE1hdGguYWJzKHZhbHVlIC0gcmVmZXJlbmNlKSA+IDQyOTQ5NjcyOTYpIHtcbiAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXlmcmFtZUluZGV4KHNhbXBsZXM6IEFycmF5PEF2Y1NhbXBsZT4pOiBudW1iZXIge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2FtcGxlc1tpXS5rZXkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyhcbiAgdHJhY2s6IERlbXV4ZWRNZXRhZGF0YVRyYWNrLFxuICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gIGluaXRQVFM6IFJhdGlvbmFsVGltZXN0YW1wLFxuICBpbml0RFRTOiBSYXRpb25hbFRpbWVzdGFtcFxuKTogUmVtdXhlZE1ldGFkYXRhIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAvLyBzZXR0aW5nIGlkMyBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgIHNhbXBsZS5wdHMgPVxuICAgICAgbm9ybWFsaXplUHRzKFxuICAgICAgICBzYW1wbGUucHRzIC0gKGluaXRQVFMuYmFzZVRpbWUgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbml0UFRTLnRpbWVzY2FsZSxcbiAgICAgICAgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlXG4gICAgICApIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgc2FtcGxlLmR0cyA9XG4gICAgICBub3JtYWxpemVQdHMoXG4gICAgICAgIHNhbXBsZS5kdHMgLSAoaW5pdERUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlKSAvIGluaXREVFMudGltZXNjYWxlLFxuICAgICAgICB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGVcbiAgICAgICkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgfVxuICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIHNhbXBsZXMsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyhcbiAgdHJhY2s6IERlbXV4ZWRVc2VyZGF0YVRyYWNrLFxuICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gIGluaXRQVFM6IFJhdGlvbmFsVGltZXN0YW1wXG4pOiBSZW11eGVkVXNlcmRhdGEgfCB1bmRlZmluZWQge1xuICBjb25zdCBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3Qgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgLy8gc2V0dGluZyB0ZXh0IHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgc2FtcGxlLnB0cyA9XG4gICAgICBub3JtYWxpemVQdHMoXG4gICAgICAgIHNhbXBsZS5wdHMgLSAoaW5pdFBUUy5iYXNlVGltZSAqIDkwMDAwKSAvIGluaXRQVFMudGltZXNjYWxlLFxuICAgICAgICB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGVcbiAgICAgICkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgfVxuICB0cmFjay5zYW1wbGVzLnNvcnQoKGEsIGIpID0+IGEucHRzIC0gYi5wdHMpO1xuICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIHNhbXBsZXMsXG4gIH07XG59XG5cbmNsYXNzIE1wNFNhbXBsZSB7XG4gIHB1YmxpYyBzaXplOiBudW1iZXI7XG4gIHB1YmxpYyBkdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgY3RzOiBudW1iZXI7XG4gIHB1YmxpYyBmbGFnczogTXA0U2FtcGxlRmxhZ3M7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgaXNLZXlmcmFtZTogYm9vbGVhbixcbiAgICBkdXJhdGlvbjogbnVtYmVyLFxuICAgIHNpemU6IG51bWJlcixcbiAgICBjdHM6IG51bWJlclxuICApIHtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmN0cyA9IGN0cztcbiAgICB0aGlzLmZsYWdzID0gbmV3IE1wNFNhbXBsZUZsYWdzKGlzS2V5ZnJhbWUpO1xuICB9XG59XG5cbmNsYXNzIE1wNFNhbXBsZUZsYWdzIHtcbiAgcHVibGljIGlzTGVhZGluZzogMCA9IDA7XG4gIHB1YmxpYyBpc0RlcGVuZGVkT246IDAgPSAwO1xuICBwdWJsaWMgaGFzUmVkdW5kYW5jeTogMCA9IDA7XG4gIHB1YmxpYyBkZWdyYWRQcmlvOiAwID0gMDtcbiAgcHVibGljIGRlcGVuZHNPbjogMSB8IDIgPSAxO1xuICBwdWJsaWMgaXNOb25TeW5jOiAwIHwgMSA9IDE7XG5cbiAgY29uc3RydWN0b3IoaXNLZXlmcmFtZSkge1xuICAgIHRoaXMuZGVwZW5kc09uID0gaXNLZXlmcmFtZSA/IDIgOiAxO1xuICAgIHRoaXMuaXNOb25TeW5jID0gaXNLZXlmcmFtZSA/IDAgOiAxO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyxcbiAgZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXMsXG59IGZyb20gJy4vbXA0LXJlbXV4ZXInO1xuaW1wb3J0IHtcbiAgSW5pdERhdGEsXG4gIEluaXREYXRhVHJhY2ssXG4gIHBhdGNoRW5jeXB0aW9uRGF0YSxcbn0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcbmltcG9ydCB7XG4gIGdldER1cmF0aW9uLFxuICBnZXRTdGFydERUUyxcbiAgb2Zmc2V0U3RhcnREVFMsXG4gIHBhcnNlSW5pdFNlZ21lbnQsXG59IGZyb20gJy4uL3V0aWxzL21wNC10b29scyc7XG5pbXBvcnQgeyBFbGVtZW50YXJ5U3RyZWFtVHlwZXMgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB0eXBlIHsgVHJhY2tTZXQgfSBmcm9tICcuLi90eXBlcy90cmFjayc7XG5pbXBvcnQgdHlwZSB7XG4gIEluaXRTZWdtZW50RGF0YSxcbiAgUmVtdXhlZFRyYWNrLFxuICBSZW11eGVyLFxuICBSZW11eGVyUmVzdWx0LFxufSBmcm9tICcuLi90eXBlcy9yZW11eGVyJztcbmltcG9ydCB0eXBlIHtcbiAgRGVtdXhlZEF1ZGlvVHJhY2ssXG4gIERlbXV4ZWRNZXRhZGF0YVRyYWNrLFxuICBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgUGFzc3Rocm91Z2hUcmFjayxcbn0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5pbXBvcnQgdHlwZSB7IERlY3J5cHREYXRhIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWtleSc7XG5pbXBvcnQgdHlwZSB7IFJhdGlvbmFsVGltZXN0YW1wIH0gZnJvbSAnLi4vdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24nO1xuXG5jbGFzcyBQYXNzVGhyb3VnaFJlbXV4ZXIgaW1wbGVtZW50cyBSZW11eGVyIHtcbiAgcHJpdmF0ZSBlbWl0SW5pdFNlZ21lbnQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBhdWRpb0NvZGVjPzogc3RyaW5nO1xuICBwcml2YXRlIHZpZGVvQ29kZWM/OiBzdHJpbmc7XG4gIHByaXZhdGUgaW5pdERhdGE/OiBJbml0RGF0YTtcbiAgcHJpdmF0ZSBpbml0UFRTOiBSYXRpb25hbFRpbWVzdGFtcCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGluaXRUcmFja3M/OiBUcmFja1NldDtcbiAgcHJpdmF0ZSBsYXN0RW5kVGltZTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7fVxuXG4gIHB1YmxpYyByZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFBUUzogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsKSB7XG4gICAgdGhpcy5pbml0UFRTID0gZGVmYXVsdEluaXRQVFM7XG4gICAgdGhpcy5sYXN0RW5kVGltZSA9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgcmVzZXROZXh0VGltZXN0YW1wKCkge1xuICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICB9XG5cbiAgcHVibGljIHJlc2V0SW5pdFNlZ21lbnQoXG4gICAgaW5pdFNlZ21lbnQ6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQsXG4gICAgYXVkaW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHZpZGVvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBkZWNyeXB0ZGF0YTogRGVjcnlwdERhdGEgfCBudWxsXG4gICkge1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQocGF0Y2hFbmN5cHRpb25EYXRhKGluaXRTZWdtZW50LCBkZWNyeXB0ZGF0YSkpO1xuICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVJbml0U2VnbWVudChpbml0U2VnbWVudDogVWludDhBcnJheSB8IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIGxldCB7IGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMgfSA9IHRoaXM7XG4gICAgaWYgKCFpbml0U2VnbWVudD8uYnl0ZUxlbmd0aCkge1xuICAgICAgdGhpcy5pbml0VHJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbml0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5pdERhdGEgPSAodGhpcy5pbml0RGF0YSA9IHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpKTtcblxuICAgIC8vIEdldCBjb2RlYyBmcm9tIGluaXRTZWdtZW50IG9yIGZhbGxiYWNrIHRvIGRlZmF1bHRcbiAgICBpZiAoIWF1ZGlvQ29kZWMpIHtcbiAgICAgIGF1ZGlvQ29kZWMgPSBnZXRQYXJzZWRUcmFja0NvZGVjKFxuICAgICAgICBpbml0RGF0YS5hdWRpbyxcbiAgICAgICAgRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghdmlkZW9Db2RlYykge1xuICAgICAgdmlkZW9Db2RlYyA9IGdldFBhcnNlZFRyYWNrQ29kZWMoXG4gICAgICAgIGluaXREYXRhLnZpZGVvLFxuICAgICAgICBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9cbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhY2tzOiBUcmFja1NldCA9IHt9O1xuICAgIGlmIChpbml0RGF0YS5hdWRpbyAmJiBpbml0RGF0YS52aWRlbykge1xuICAgICAgdHJhY2tzLmF1ZGlvdmlkZW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjOiBhdWRpb0NvZGVjICsgJywnICsgdmlkZW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICAgIGlkOiAnbWFpbicsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAnYXVkaW8vbXA0JyxcbiAgICAgICAgY29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ2F1ZGlvJyxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICAgIGlkOiAnbWFpbicsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybihcbiAgICAgICAgJ1twYXNzdGhyb3VnaC1yZW11eGVyLnRzXTogaW5pdFNlZ21lbnQgZG9lcyBub3QgY29udGFpbiBtb292IG9yIHRyYWsgYm94ZXMuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5pbml0VHJhY2tzID0gdHJhY2tzO1xuICB9XG5cbiAgcHVibGljIHJlbXV4KFxuICAgIGF1ZGlvVHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLFxuICAgIHZpZGVvVHJhY2s6IFBhc3N0aHJvdWdoVHJhY2ssXG4gICAgaWQzVHJhY2s6IERlbXV4ZWRNZXRhZGF0YVRyYWNrLFxuICAgIHRleHRUcmFjazogRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGFjY3VyYXRlVGltZU9mZnNldDogYm9vbGVhblxuICApOiBSZW11eGVyUmVzdWx0IHtcbiAgICBsZXQgeyBpbml0UFRTLCBsYXN0RW5kVGltZSB9ID0gdGhpcztcbiAgICBjb25zdCByZXN1bHQ6IFJlbXV4ZXJSZXN1bHQgPSB7XG4gICAgICBhdWRpbzogdW5kZWZpbmVkLFxuICAgICAgdmlkZW86IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHRleHRUcmFjayxcbiAgICAgIGlkMzogaWQzVHJhY2ssXG4gICAgICBpbml0U2VnbWVudDogdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICAvLyBJZiB3ZSBoYXZlbid0IHlldCBzZXQgYSBsYXN0RW5kRFRTLCBvciBpdCB3YXMgcmVzZXQsIHNldCBpdCB0byB0aGUgcHJvdmlkZWQgdGltZU9mZnNldC4gV2Ugd2FudCB0byB1c2UgdGhlXG4gICAgLy8gbGFzdEVuZERUUyBvdmVyIHRpbWVPZmZzZXQgd2hlbmV2ZXIgcG9zc2libGU7IGR1cmluZyBwcm9ncmVzc2l2ZSBwbGF5YmFjaywgdGhlIG1lZGlhIHNvdXJjZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAvLyB0aGUgbWVkaWEgZHVyYXRpb24gKHdoaWNoIGlzIHdoYXQgdGltZU9mZnNldCBpcyBwcm92aWRlZCBhcykgYmVmb3JlIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgbmV4dCBjaHVuay5cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShsYXN0RW5kVGltZSEpKSB7XG4gICAgICBsYXN0RW5kVGltZSA9IHRoaXMubGFzdEVuZFRpbWUgPSB0aW1lT2Zmc2V0IHx8IDA7XG4gICAgfVxuXG4gICAgLy8gVGhlIGJpbmFyeSBzZWdtZW50IGRhdGEgaXMgYWRkZWQgdG8gdGhlIHZpZGVvVHJhY2sgaW4gdGhlIG1wNGRlbXV4ZXIuIFdlIGRvbid0IGNoZWNrIHRvIHNlZSBpZiB0aGUgZGF0YSBpcyBvbmx5XG4gICAgLy8gYXVkaW8gb3IgdmlkZW8gKG9yIGJvdGgpOyBhZGRpbmcgaXQgdG8gdmlkZW8gd2FzIGFuIGFyYml0cmFyeSBjaG9pY2UuXG4gICAgY29uc3QgZGF0YSA9IHZpZGVvVHJhY2suc2FtcGxlcztcbiAgICBpZiAoIWRhdGE/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0U2VnbWVudDogSW5pdFNlZ21lbnREYXRhID0ge1xuICAgICAgaW5pdFBUUzogdW5kZWZpbmVkLFxuICAgICAgdGltZXNjYWxlOiAxLFxuICAgIH07XG4gICAgbGV0IGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICBpZiAoIWluaXREYXRhPy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJbml0U2VnbWVudChkYXRhKTtcbiAgICAgIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICB9XG4gICAgaWYgKCFpbml0RGF0YT8ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSBjYW4ndCByZW11eCBpZiB0aGUgaW5pdFNlZ21lbnQgY291bGQgbm90IGJlIGdlbmVyYXRlZFxuICAgICAgbG9nZ2VyLndhcm4oJ1twYXNzdGhyb3VnaC1yZW11eGVyLnRzXTogRmFpbGVkIHRvIGdlbmVyYXRlIGluaXRTZWdtZW50LicpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZW1pdEluaXRTZWdtZW50KSB7XG4gICAgICBpbml0U2VnbWVudC50cmFja3MgPSB0aGlzLmluaXRUcmFja3MgYXMgVHJhY2tTZXQ7XG4gICAgICB0aGlzLmVtaXRJbml0U2VnbWVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGR1cmF0aW9uID0gZ2V0RHVyYXRpb24oZGF0YSwgaW5pdERhdGEpO1xuICAgIGNvbnN0IHN0YXJ0RFRTID0gZ2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEpO1xuICAgIGNvbnN0IGRlY29kZVRpbWUgPSBzdGFydERUUyA9PT0gbnVsbCA/IHRpbWVPZmZzZXQgOiBzdGFydERUUztcbiAgICBpZiAoXG4gICAgICBpc0ludmFsaWRJbml0UHRzKGluaXRQVFMsIGRlY29kZVRpbWUsIHRpbWVPZmZzZXQsIGR1cmF0aW9uKSB8fFxuICAgICAgKGluaXRTZWdtZW50LnRpbWVzY2FsZSAhPT0gaW5pdFBUUy50aW1lc2NhbGUgJiYgYWNjdXJhdGVUaW1lT2Zmc2V0KVxuICAgICkge1xuICAgICAgaW5pdFNlZ21lbnQuaW5pdFBUUyA9IGRlY29kZVRpbWUgLSB0aW1lT2Zmc2V0O1xuICAgICAgaWYgKGluaXRQVFMgJiYgaW5pdFBUUy50aW1lc2NhbGUgPT09IDEpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYEFkanVzdGluZyBpbml0UFRTIGJ5ICR7aW5pdFNlZ21lbnQuaW5pdFBUUyAtIGluaXRQVFMuYmFzZVRpbWV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5pbml0UFRTID0gaW5pdFBUUyA9IHtcbiAgICAgICAgYmFzZVRpbWU6IGluaXRTZWdtZW50LmluaXRQVFMsXG4gICAgICAgIHRpbWVzY2FsZTogMSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gYXVkaW9UcmFja1xuICAgICAgPyBkZWNvZGVUaW1lIC0gaW5pdFBUUy5iYXNlVGltZSAvIGluaXRQVFMudGltZXNjYWxlXG4gICAgICA6IChsYXN0RW5kVGltZSBhcyBudW1iZXIpO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICBvZmZzZXRTdGFydERUUyhpbml0RGF0YSwgZGF0YSwgaW5pdFBUUy5iYXNlVGltZSAvIGluaXRQVFMudGltZXNjYWxlKTtcblxuICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgIHRoaXMubGFzdEVuZFRpbWUgPSBlbmRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybignRHVyYXRpb24gcGFyc2VkIGZyb20gbXA0IHNob3VsZCBiZSBncmVhdGVyIHRoYW4gemVybycpO1xuICAgICAgdGhpcy5yZXNldE5leHRUaW1lc3RhbXAoKTtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNBdWRpbyA9ICEhaW5pdERhdGEuYXVkaW87XG4gICAgY29uc3QgaGFzVmlkZW8gPSAhIWluaXREYXRhLnZpZGVvO1xuXG4gICAgbGV0IHR5cGU6IGFueSA9ICcnO1xuICAgIGlmIChoYXNBdWRpbykge1xuICAgICAgdHlwZSArPSAnYXVkaW8nO1xuICAgIH1cblxuICAgIGlmIChoYXNWaWRlbykge1xuICAgICAgdHlwZSArPSAndmlkZW8nO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYWNrOiBSZW11eGVkVHJhY2sgPSB7XG4gICAgICBkYXRhMTogZGF0YSxcbiAgICAgIHN0YXJ0UFRTOiBzdGFydFRpbWUsXG4gICAgICBzdGFydERUUzogc3RhcnRUaW1lLFxuICAgICAgZW5kUFRTOiBlbmRUaW1lLFxuICAgICAgZW5kRFRTOiBlbmRUaW1lLFxuICAgICAgdHlwZSxcbiAgICAgIGhhc0F1ZGlvLFxuICAgICAgaGFzVmlkZW8sXG4gICAgICBuYjogMSxcbiAgICAgIGRyb3BwZWQ6IDAsXG4gICAgfTtcblxuICAgIHJlc3VsdC5hdWRpbyA9IHRyYWNrLnR5cGUgPT09ICdhdWRpbycgPyB0cmFjayA6IHVuZGVmaW5lZDtcbiAgICByZXN1bHQudmlkZW8gPSB0cmFjay50eXBlICE9PSAnYXVkaW8nID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgcmVzdWx0LmluaXRTZWdtZW50ID0gaW5pdFNlZ21lbnQ7XG4gICAgcmVzdWx0LmlkMyA9IGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0aW1lT2Zmc2V0LFxuICAgICAgaW5pdFBUUyxcbiAgICAgIGluaXRQVFNcbiAgICApO1xuXG4gICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnRleHQgPSBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyhcbiAgICAgICAgdGV4dFRyYWNrLFxuICAgICAgICB0aW1lT2Zmc2V0LFxuICAgICAgICBpbml0UFRTXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbnZhbGlkSW5pdFB0cyhcbiAgaW5pdFBUUzogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsLFxuICBzdGFydERUUzogbnVtYmVyLFxuICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gIGR1cmF0aW9uOiBudW1iZXJcbik6IGluaXRQVFMgaXMgbnVsbCB7XG4gIGlmIChpbml0UFRTID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSW5pdFBUUyBpcyBpbnZhbGlkIHdoZW4gZGlzdGFuY2UgZnJvbSBwcm9ncmFtIHdvdWxkIGJlIG1vcmUgdGhhbiBzZWdtZW50IGR1cmF0aW9uIG9yIGEgbWluaW11bSBvZiBvbmUgc2Vjb25kXG4gIGNvbnN0IG1pbkR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIDEpO1xuICBjb25zdCBzdGFydFRpbWUgPSBzdGFydERUUyAtIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgcmV0dXJuIE1hdGguYWJzKHN0YXJ0VGltZSAtIHRpbWVPZmZzZXQpID4gbWluRHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIGdldFBhcnNlZFRyYWNrQ29kZWMoXG4gIHRyYWNrOiBJbml0RGF0YVRyYWNrIHwgdW5kZWZpbmVkLFxuICB0eXBlOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8gfCBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9cbik6IHN0cmluZyB7XG4gIGNvbnN0IHBhcnNlZENvZGVjID0gdHJhY2s/LmNvZGVjO1xuICBpZiAocGFyc2VkQ29kZWMgJiYgcGFyc2VkQ29kZWMubGVuZ3RoID4gNCkge1xuICAgIHJldHVybiBwYXJzZWRDb2RlYztcbiAgfVxuICAvLyBTaW5jZSBtcDQtdG9vbHMgY2Fubm90IHBhcnNlIGZ1bGwgY29kZWMgc3RyaW5nIChzZWUgJ1RPRE86IFBhcnNlIGNvZGVjIGRldGFpbHMnLi4uIGluIG1wNC10b29scylcbiAgLy8gUHJvdmlkZSBkZWZhdWx0cyBiYXNlZCBvbiBjb2RlYyB0eXBlXG4gIC8vIFRoaXMgYWxsb3dzIGZvciBzb21lIHBsYXliYWNrIG9mIHNvbWUgZm1wNCBwbGF5bGlzdHMgd2l0aG91dCBDT0RFQ1MgZGVmaW5lZCBpbiBtYW5pZmVzdFxuICBpZiAocGFyc2VkQ29kZWMgPT09ICdodmMxJyB8fCBwYXJzZWRDb2RlYyA9PT0gJ2hldjEnKSB7XG4gICAgcmV0dXJuICdodmMxLjEuNi5MMTIwLjkwJztcbiAgfVxuICBpZiAocGFyc2VkQ29kZWMgPT09ICdhdjAxJykge1xuICAgIHJldHVybiAnYXYwMS4wLjA0TS4wOCc7XG4gIH1cbiAgaWYgKHBhcnNlZENvZGVjID09PSAnYXZjMScgfHwgdHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgcmV0dXJuICdhdmMxLjQyZTAxZSc7XG4gIH1cbiAgcmV0dXJuICdtcDRhLjQwLjUnO1xufVxuZXhwb3J0IGRlZmF1bHQgUGFzc1Rocm91Z2hSZW11eGVyO1xuIiwiaW1wb3J0IHR5cGUgeyBIbHNFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgRGVjcnlwdGVyIGZyb20gJy4uL2NyeXB0L2RlY3J5cHRlcic7XG5pbXBvcnQgQUFDRGVtdXhlciBmcm9tICcuLi9kZW11eC9hYWNkZW11eGVyJztcbmltcG9ydCBNUDREZW11eGVyIGZyb20gJy4uL2RlbXV4L21wNGRlbXV4ZXInO1xuaW1wb3J0IFRTRGVtdXhlciwgeyBUeXBlU3VwcG9ydGVkIH0gZnJvbSAnLi4vZGVtdXgvdHNkZW11eGVyJztcbmltcG9ydCBNUDNEZW11eGVyIGZyb20gJy4uL2RlbXV4L21wM2RlbXV4ZXInO1xuaW1wb3J0IE1QNFJlbXV4ZXIgZnJvbSAnLi4vcmVtdXgvbXA0LXJlbXV4ZXInO1xuaW1wb3J0IFBhc3NUaHJvdWdoUmVtdXhlciBmcm9tICcuLi9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSB7IERlbXV4ZXIsIERlbXV4ZXJSZXN1bHQsIEtleURhdGEgfSBmcm9tICcuLi90eXBlcy9kZW11eGVyJztcbmltcG9ydCB0eXBlIHsgUmVtdXhlciB9IGZyb20gJy4uL3R5cGVzL3JlbXV4ZXInO1xuaW1wb3J0IHR5cGUgeyBUcmFuc211eGVyUmVzdWx0LCBDaHVua01ldGFkYXRhIH0gZnJvbSAnLi4vdHlwZXMvdHJhbnNtdXhlcic7XG5pbXBvcnQgdHlwZSB7IEhsc0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IERlY3J5cHREYXRhIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWtleSc7XG5pbXBvcnQgdHlwZSB7IFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB0eXBlIHsgUmF0aW9uYWxUaW1lc3RhbXAgfSBmcm9tICcuLi91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbic7XG5cbmxldCBub3c7XG4vLyBwZXJmb3JtYW5jZS5ub3coKSBub3QgYXZhaWxhYmxlIG9uIFdlYldvcmtlciwgYXQgbGVhc3Qgb24gU2FmYXJpIERlc2t0b3BcbnRyeSB7XG4gIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93LmJpbmQoc2VsZi5wZXJmb3JtYW5jZSk7XG59IGNhdGNoIChlcnIpIHtcbiAgbG9nZ2VyLmRlYnVnKCdVbmFibGUgdG8gdXNlIFBlcmZvcm1hbmNlIEFQSSBvbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gIG5vdyA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLkRhdGUubm93O1xufVxuXG50eXBlIE11eENvbmZpZyA9XG4gIHwgeyBkZW11eDogdHlwZW9mIE1QNERlbXV4ZXI7IHJlbXV4OiB0eXBlb2YgUGFzc1Rocm91Z2hSZW11eGVyIH1cbiAgfCB7IGRlbXV4OiB0eXBlb2YgVFNEZW11eGVyOyByZW11eDogdHlwZW9mIE1QNFJlbXV4ZXIgfVxuICB8IHsgZGVtdXg6IHR5cGVvZiBBQUNEZW11eGVyOyByZW11eDogdHlwZW9mIE1QNFJlbXV4ZXIgfVxuICB8IHsgZGVtdXg6IHR5cGVvZiBNUDNEZW11eGVyOyByZW11eDogdHlwZW9mIE1QNFJlbXV4ZXIgfTtcblxuY29uc3QgbXV4Q29uZmlnOiBNdXhDb25maWdbXSA9IFtcbiAgeyBkZW11eDogTVA0RGVtdXhlciwgcmVtdXg6IFBhc3NUaHJvdWdoUmVtdXhlciB9LFxuICB7IGRlbXV4OiBUU0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH0sXG4gIHsgZGVtdXg6IEFBQ0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH0sXG4gIHsgZGVtdXg6IE1QM0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH0sXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc211eGVyIHtcbiAgcHVibGljIGFzeW5jOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgb2JzZXJ2ZXI6IEhsc0V2ZW50RW1pdHRlcjtcbiAgcHJpdmF0ZSB0eXBlU3VwcG9ydGVkOiBUeXBlU3VwcG9ydGVkO1xuICBwcml2YXRlIGNvbmZpZzogSGxzQ29uZmlnO1xuICBwcml2YXRlIHZlbmRvcjogc3RyaW5nO1xuICBwcml2YXRlIGlkOiBQbGF5bGlzdExldmVsVHlwZTtcbiAgcHJpdmF0ZSBkZW11eGVyPzogRGVtdXhlcjtcbiAgcHJpdmF0ZSByZW11eGVyPzogUmVtdXhlcjtcbiAgcHJpdmF0ZSBkZWNyeXB0ZXI/OiBEZWNyeXB0ZXI7XG4gIHByaXZhdGUgcHJvYmUhOiBGdW5jdGlvbjtcbiAgcHJpdmF0ZSBkZWNyeXB0aW9uUHJvbWlzZTogUHJvbWlzZTxUcmFuc211eGVyUmVzdWx0PiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHRyYW5zbXV4Q29uZmlnITogVHJhbnNtdXhDb25maWc7XG4gIHByaXZhdGUgY3VycmVudFRyYW5zbXV4U3RhdGUhOiBUcmFuc211eFN0YXRlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXIsXG4gICAgdHlwZVN1cHBvcnRlZDogVHlwZVN1cHBvcnRlZCxcbiAgICBjb25maWc6IEhsc0NvbmZpZyxcbiAgICB2ZW5kb3I6IHN0cmluZyxcbiAgICBpZDogUGxheWxpc3RMZXZlbFR5cGVcbiAgKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy52ZW5kb3IgPSB2ZW5kb3I7XG4gICAgdGhpcy5pZCA9IGlkO1xuICB9XG5cbiAgY29uZmlndXJlKHRyYW5zbXV4Q29uZmlnOiBUcmFuc211eENvbmZpZykge1xuICAgIHRoaXMudHJhbnNtdXhDb25maWcgPSB0cmFuc211eENvbmZpZztcbiAgICBpZiAodGhpcy5kZWNyeXB0ZXIpIHtcbiAgICAgIHRoaXMuZGVjcnlwdGVyLnJlc2V0KCk7XG4gICAgfVxuICB9XG5cbiAgcHVzaChcbiAgICBkYXRhOiBBcnJheUJ1ZmZlcixcbiAgICBkZWNyeXB0ZGF0YTogRGVjcnlwdERhdGEgfCBudWxsLFxuICAgIGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YSxcbiAgICBzdGF0ZT86IFRyYW5zbXV4U3RhdGVcbiAgKTogVHJhbnNtdXhlclJlc3VsdCB8IFByb21pc2U8VHJhbnNtdXhlclJlc3VsdD4ge1xuICAgIGNvbnN0IHN0YXRzID0gY2h1bmtNZXRhLnRyYW5zbXV4aW5nO1xuICAgIHN0YXRzLmV4ZWN1dGVTdGFydCA9IG5vdygpO1xuXG4gICAgbGV0IHVpbnREYXRhOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgY29uc3QgeyBjdXJyZW50VHJhbnNtdXhTdGF0ZSwgdHJhbnNtdXhDb25maWcgfSA9IHRoaXM7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlID0gc3RhdGU7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgY29udGlndW91cyxcbiAgICAgIGRpc2NvbnRpbnVpdHksXG4gICAgICB0cmFja1N3aXRjaCxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIHRpbWVPZmZzZXQsXG4gICAgICBpbml0U2VnbWVudENoYW5nZSxcbiAgICB9ID0gc3RhdGUgfHwgY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgY29uc3Qge1xuICAgICAgYXVkaW9Db2RlYyxcbiAgICAgIHZpZGVvQ29kZWMsXG4gICAgICBkZWZhdWx0SW5pdFB0cyxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgaW5pdFNlZ21lbnREYXRhLFxuICAgIH0gPSB0cmFuc211eENvbmZpZztcblxuICAgIGNvbnN0IGtleURhdGEgPSBnZXRFbmNyeXB0aW9uVHlwZSh1aW50RGF0YSwgZGVjcnlwdGRhdGEpO1xuICAgIGlmIChrZXlEYXRhICYmIGtleURhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpIHtcbiAgICAgIGNvbnN0IGRlY3J5cHRlciA9IHRoaXMuZ2V0RGVjcnlwdGVyKCk7XG4gICAgICAvLyBTb2Z0d2FyZSBkZWNyeXB0aW9uIGlzIHN5bmNocm9ub3VzOyB3ZWJDcnlwdG8gaXMgbm90XG4gICAgICBpZiAoZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgIC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgcHJvZ3Jlc3NpdmUuIFByb2dyZXNzaXZlIGRlY3J5cHRpb24gbWF5IG5vdCByZXR1cm4gYSByZXN1bHQgb24gZWFjaCBjYWxsLiBBbnkgY2FjaGVkXG4gICAgICAgIC8vIGRhdGEgaXMgaGFuZGxlZCBpbiB0aGUgZmx1c2goKSBjYWxsXG4gICAgICAgIGxldCBkZWNyeXB0ZWREYXRhID0gZGVjcnlwdGVyLnNvZnR3YXJlRGVjcnlwdChcbiAgICAgICAgICB1aW50RGF0YSxcbiAgICAgICAgICBrZXlEYXRhLmtleS5idWZmZXIsXG4gICAgICAgICAga2V5RGF0YS5pdi5idWZmZXJcbiAgICAgICAgKTtcbiAgICAgICAgLy8gRm9yIExvdy1MYXRlbmN5IEhMUyBQYXJ0cywgZGVjcnlwdCBpbiBwbGFjZSwgc2luY2UgcGFydCBwYXJzaW5nIGlzIGV4cGVjdGVkIG9uIHB1c2ggcHJvZ3Jlc3NcbiAgICAgICAgY29uc3QgbG9hZGluZ1BhcnRzID0gY2h1bmtNZXRhLnBhcnQgPiAtMTtcbiAgICAgICAgaWYgKGxvYWRpbmdQYXJ0cykge1xuICAgICAgICAgIGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KGNodW5rTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdWludERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBkZWNyeXB0ZXJcbiAgICAgICAgICAud2ViQ3J5cHRvRGVjcnlwdCh1aW50RGF0YSwga2V5RGF0YS5rZXkuYnVmZmVyLCBrZXlEYXRhLml2LmJ1ZmZlcilcbiAgICAgICAgICAudGhlbigoZGVjcnlwdGVkRGF0YSk6IFRyYW5zbXV4ZXJSZXN1bHQgPT4ge1xuICAgICAgICAgICAgLy8gQ2FsbGluZyBwdXNoIGhlcmUgaXMgaW1wb3J0YW50OyBpZiBmbHVzaCgpIGlzIGNhbGxlZCB3aGlsZSB0aGlzIGlzIHN0aWxsIHJlc29sdmluZywgdGhpcyBlbnN1cmVzIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBkZWNyeXB0ZWQgZGF0YSBoYXMgYmVlbiB0cmFuc211eGVkXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnB1c2goXG4gICAgICAgICAgICAgIGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGNodW5rTWV0YVxuICAgICAgICAgICAgKSBhcyBUcmFuc211eGVyUmVzdWx0O1xuICAgICAgICAgICAgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzZXRNdXhlcnMgPSB0aGlzLm5lZWRzUHJvYmluZyhkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCk7XG4gICAgaWYgKHJlc2V0TXV4ZXJzKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY29uZmlndXJlVHJhbnNtdXhlcih1aW50RGF0YSk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYFt0cmFuc211eGVyXSAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaCB8fCBpbml0U2VnbWVudENoYW5nZSB8fCByZXNldE11eGVycykge1xuICAgICAgdGhpcy5yZXNldEluaXRTZWdtZW50KFxuICAgICAgICBpbml0U2VnbWVudERhdGEsXG4gICAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICAgIHZpZGVvQ29kZWMsXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBkZWNyeXB0ZGF0YVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZGlzY29udGludWl0eSB8fCBpbml0U2VnbWVudENoYW5nZSB8fCByZXNldE11eGVycykge1xuICAgICAgdGhpcy5yZXNldEluaXRpYWxUaW1lc3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIH1cblxuICAgIGlmICghY29udGlndW91cykge1xuICAgICAgdGhpcy5yZXNldENvbnRpZ3VpdHkoKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyYW5zbXV4KFxuICAgICAgdWludERhdGEsXG4gICAgICBrZXlEYXRhLFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIGNodW5rTWV0YVxuICAgICk7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZTtcblxuICAgIGN1cnJlbnRTdGF0ZS5jb250aWd1b3VzID0gdHJ1ZTtcbiAgICBjdXJyZW50U3RhdGUuZGlzY29udGludWl0eSA9IGZhbHNlO1xuICAgIGN1cnJlbnRTdGF0ZS50cmFja1N3aXRjaCA9IGZhbHNlO1xuXG4gICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBEdWUgdG8gZGF0YSBjYWNoaW5nLCBmbHVzaCBjYWxscyBjYW4gcHJvZHVjZSBtb3JlIHRoYW4gb25lIFRyYW5zbXV4ZXJSZXN1bHQgKGhlbmNlIHRoZSBBcnJheSB0eXBlKVxuICBmbHVzaChcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGFcbiAgKTogVHJhbnNtdXhlclJlc3VsdFtdIHwgUHJvbWlzZTxUcmFuc211eGVyUmVzdWx0W10+IHtcbiAgICBjb25zdCBzdGF0cyA9IGNodW5rTWV0YS50cmFuc211eGluZztcbiAgICBzdGF0cy5leGVjdXRlU3RhcnQgPSBub3coKTtcblxuICAgIGNvbnN0IHsgZGVjcnlwdGVyLCBjdXJyZW50VHJhbnNtdXhTdGF0ZSwgZGVjcnlwdGlvblByb21pc2UgfSA9IHRoaXM7XG5cbiAgICBpZiAoZGVjcnlwdGlvblByb21pc2UpIHtcbiAgICAgIC8vIFVwb24gcmVzb2x1dGlvbiwgdGhlIGRlY3J5cHRpb24gcHJvbWlzZSBjYWxscyBwdXNoKCkgYW5kIHJldHVybnMgaXRzIFRyYW5zbXV4ZXJSZXN1bHQgdXAgdGhlIHN0YWNrLiBUaGVyZWZvcmVcbiAgICAgIC8vIG9ubHkgZmx1c2hpbmcgaXMgcmVxdWlyZWQgZm9yIGFzeW5jIGRlY3J5cHRpb25cbiAgICAgIHJldHVybiBkZWNyeXB0aW9uUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmx1c2goY2h1bmtNZXRhKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zbXV4UmVzdWx0czogVHJhbnNtdXhlclJlc3VsdFtdID0gW107XG4gICAgY29uc3QgeyB0aW1lT2Zmc2V0IH0gPSBjdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBpZiAoZGVjcnlwdGVyKSB7XG4gICAgICAvLyBUaGUgZGVjcnlwdGVyIG1heSBoYXZlIGRhdGEgY2FjaGVkLCB3aGljaCBuZWVkcyB0byBiZSBkZW11eGVkLiBJbiB0aGlzIGNhc2Ugd2UnbGwgaGF2ZSB0d28gVHJhbnNtdXhSZXN1bHRzXG4gICAgICAvLyBUaGlzIGhhcHBlbnMgaW4gdGhlIGNhc2UgdGhhdCB3ZSByZWNlaXZlIG9ubHkgMSBwdXNoIGNhbGwgZm9yIGEgc2VnbWVudCAoZWl0aGVyIGZvciBub24tcHJvZ3Jlc3NpdmUgZG93bmxvYWRzLFxuICAgICAgLy8gb3IgZm9yIHByb2dyZXNzaXZlIGRvd25sb2FkcyB3aXRoIHNtYWxsIHNlZ21lbnRzKVxuICAgICAgY29uc3QgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5mbHVzaCgpO1xuICAgICAgaWYgKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgLy8gUHVzaCBhbHdheXMgcmV0dXJucyBhIFRyYW5zbXV4ZXJSZXN1bHQgaWYgZGVjcnlwdGRhdGEgaXMgbnVsbFxuICAgICAgICB0cmFuc211eFJlc3VsdHMucHVzaChcbiAgICAgICAgICB0aGlzLnB1c2goZGVjcnlwdGVkRGF0YSwgbnVsbCwgY2h1bmtNZXRhKSBhcyBUcmFuc211eGVyUmVzdWx0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBkZW11eGVyLCByZW11eGVyIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgLy8gSWYgcHJvYmluZyBmYWlsZWQsIHRoZW4gSGxzLmpzIGhhcyBiZWVuIGdpdmVuIGNvbnRlbnQgaXRzIG5vdCBhYmxlIHRvIGhhbmRsZVxuICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgcmV0dXJuIFtlbXB0eVJlc3VsdChjaHVua01ldGEpXTtcbiAgICB9XG5cbiAgICBjb25zdCBkZW11eFJlc3VsdE9yUHJvbWlzZSA9IGRlbXV4ZXIuZmx1c2godGltZU9mZnNldCk7XG4gICAgaWYgKGlzUHJvbWlzZShkZW11eFJlc3VsdE9yUHJvbWlzZSkpIHtcbiAgICAgIC8vIERlY3J5cHQgZmluYWwgU0FNUExFLUFFUyBzYW1wbGVzXG4gICAgICByZXR1cm4gZGVtdXhSZXN1bHRPclByb21pc2UudGhlbigoZGVtdXhSZXN1bHQpID0+IHtcbiAgICAgICAgdGhpcy5mbHVzaFJlbXV4KHRyYW5zbXV4UmVzdWx0cywgZGVtdXhSZXN1bHQsIGNodW5rTWV0YSk7XG4gICAgICAgIHJldHVybiB0cmFuc211eFJlc3VsdHM7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdE9yUHJvbWlzZSwgY2h1bmtNZXRhKTtcbiAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICB9XG5cbiAgcHJpdmF0ZSBmbHVzaFJlbXV4KFxuICAgIHRyYW5zbXV4UmVzdWx0czogVHJhbnNtdXhlclJlc3VsdFtdLFxuICAgIGRlbXV4UmVzdWx0OiBEZW11eGVyUmVzdWx0LFxuICAgIGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YVxuICApIHtcbiAgICBjb25zdCB7IGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2sgfSA9IGRlbXV4UmVzdWx0O1xuICAgIGNvbnN0IHsgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0aW1lT2Zmc2V0IH0gPSB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlO1xuICAgIGxvZ2dlci5sb2coXG4gICAgICBgW3RyYW5zbXV4ZXIudHNdOiBGbHVzaGVkIGZyYWdtZW50ICR7Y2h1bmtNZXRhLnNufSR7XG4gICAgICAgIGNodW5rTWV0YS5wYXJ0ID4gLTEgPyAnIHA6ICcgKyBjaHVua01ldGEucGFydCA6ICcnXG4gICAgICB9IG9mIGxldmVsICR7Y2h1bmtNZXRhLmxldmVsfWBcbiAgICApO1xuICAgIGNvbnN0IHJlbXV4UmVzdWx0ID0gdGhpcy5yZW11eGVyIS5yZW11eChcbiAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2ssXG4gICAgICB0aW1lT2Zmc2V0LFxuICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgdHJ1ZSxcbiAgICAgIHRoaXMuaWRcbiAgICApO1xuICAgIHRyYW5zbXV4UmVzdWx0cy5wdXNoKHtcbiAgICAgIHJlbXV4UmVzdWx0LFxuICAgICAgY2h1bmtNZXRhLFxuICAgIH0pO1xuXG4gICAgY2h1bmtNZXRhLnRyYW5zbXV4aW5nLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgfVxuXG4gIHJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0czogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsKSB7XG4gICAgY29uc3QgeyBkZW11eGVyLCByZW11eGVyIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZW11eGVyLnJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UHRzKTtcbiAgICByZW11eGVyLnJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UHRzKTtcbiAgfVxuXG4gIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICBjb25zdCB7IGRlbXV4ZXIsIHJlbXV4ZXIgfSA9IHRoaXM7XG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbXV4ZXIucmVzZXRDb250aWd1aXR5KCk7XG4gICAgcmVtdXhlci5yZXNldE5leHRUaW1lc3RhbXAoKTtcbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQoXG4gICAgaW5pdFNlZ21lbnREYXRhOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICAgIGF1ZGlvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2aWRlb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdHJhY2tEdXJhdGlvbjogbnVtYmVyLFxuICAgIGRlY3J5cHRkYXRhOiBEZWNyeXB0RGF0YSB8IG51bGxcbiAgKSB7XG4gICAgY29uc3QgeyBkZW11eGVyLCByZW11eGVyIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoXG4gICAgICBpbml0U2VnbWVudERhdGEsXG4gICAgICBhdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYyxcbiAgICAgIHRyYWNrRHVyYXRpb25cbiAgICApO1xuICAgIHJlbXV4ZXIucmVzZXRJbml0U2VnbWVudChcbiAgICAgIGluaXRTZWdtZW50RGF0YSxcbiAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICB2aWRlb0NvZGVjLFxuICAgICAgZGVjcnlwdGRhdGFcbiAgICApO1xuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW11eGVyKSB7XG4gICAgICB0aGlzLnJlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5yZW11eGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJhbnNtdXgoXG4gICAgZGF0YTogVWludDhBcnJheSxcbiAgICBrZXlEYXRhOiBLZXlEYXRhIHwgbnVsbCxcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiBib29sZWFuLFxuICAgIGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YVxuICApOiBUcmFuc211eGVyUmVzdWx0IHwgUHJvbWlzZTxUcmFuc211eGVyUmVzdWx0PiB7XG4gICAgbGV0IHJlc3VsdDogVHJhbnNtdXhlclJlc3VsdCB8IFByb21pc2U8VHJhbnNtdXhlclJlc3VsdD47XG4gICAgaWYgKGtleURhdGEgJiYga2V5RGF0YS5tZXRob2QgPT09ICdTQU1QTEUtQUVTJykge1xuICAgICAgcmVzdWx0ID0gdGhpcy50cmFuc211eFNhbXBsZUFlcyhcbiAgICAgICAgZGF0YSxcbiAgICAgICAga2V5RGF0YSxcbiAgICAgICAgdGltZU9mZnNldCxcbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgICBjaHVua01ldGFcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhVbmVuY3J5cHRlZChcbiAgICAgICAgZGF0YSxcbiAgICAgICAgdGltZU9mZnNldCxcbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgICBjaHVua01ldGFcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIHRyYW5zbXV4VW5lbmNyeXB0ZWQoXG4gICAgZGF0YTogVWludDhBcnJheSxcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiBib29sZWFuLFxuICAgIGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YVxuICApOiBUcmFuc211eGVyUmVzdWx0IHtcbiAgICBjb25zdCB7IGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2sgfSA9IChcbiAgICAgIHRoaXMuZGVtdXhlciBhcyBEZW11eGVyXG4gICAgKS5kZW11eChkYXRhLCB0aW1lT2Zmc2V0LCBmYWxzZSwgIXRoaXMuY29uZmlnLnByb2dyZXNzaXZlKTtcbiAgICBjb25zdCByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlciEucmVtdXgoXG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrLFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5pZFxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbXV4UmVzdWx0LFxuICAgICAgY2h1bmtNZXRhLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHRyYW5zbXV4U2FtcGxlQWVzKFxuICAgIGRhdGE6IFVpbnQ4QXJyYXksXG4gICAgZGVjcnlwdERhdGE6IEtleURhdGEsXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGFjY3VyYXRlVGltZU9mZnNldDogYm9vbGVhbixcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGFcbiAgKTogUHJvbWlzZTxUcmFuc211eGVyUmVzdWx0PiB7XG4gICAgcmV0dXJuICh0aGlzLmRlbXV4ZXIgYXMgRGVtdXhlcilcbiAgICAgIC5kZW11eFNhbXBsZUFlcyhkYXRhLCBkZWNyeXB0RGF0YSwgdGltZU9mZnNldClcbiAgICAgIC50aGVuKChkZW11eFJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlciEucmVtdXgoXG4gICAgICAgICAgZGVtdXhSZXN1bHQuYXVkaW9UcmFjayxcbiAgICAgICAgICBkZW11eFJlc3VsdC52aWRlb1RyYWNrLFxuICAgICAgICAgIGRlbXV4UmVzdWx0LmlkM1RyYWNrLFxuICAgICAgICAgIGRlbXV4UmVzdWx0LnRleHRUcmFjayxcbiAgICAgICAgICB0aW1lT2Zmc2V0LFxuICAgICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB0aGlzLmlkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoZGF0YTogVWludDhBcnJheSk6IHZvaWQgfCBFcnJvciB7XG4gICAgY29uc3QgeyBjb25maWcsIG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IgfSA9IHRoaXM7XG4gICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgIGxldCBtdXg7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG11eENvbmZpZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKG11eENvbmZpZ1tpXS5kZW11eC5wcm9iZShkYXRhKSkge1xuICAgICAgICBtdXggPSBtdXhDb25maWdbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW11eCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignRmFpbGVkIHRvIGZpbmQgZGVtdXhlciBieSBwcm9iaW5nIGZyYWdtZW50IGRhdGEnKTtcbiAgICB9XG4gICAgLy8gc28gbGV0J3MgY2hlY2sgdGhhdCBjdXJyZW50IHJlbXV4ZXIgYW5kIGRlbXV4ZXIgYXJlIHN0aWxsIHZhbGlkXG4gICAgY29uc3QgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICBjb25zdCByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuICAgIGNvbnN0IFJlbXV4ZXI6IE11eENvbmZpZ1sncmVtdXgnXSA9IG11eC5yZW11eDtcbiAgICBjb25zdCBEZW11eGVyOiBNdXhDb25maWdbJ2RlbXV4J10gPSBtdXguZGVtdXg7XG4gICAgaWYgKCFyZW11eGVyIHx8ICEocmVtdXhlciBpbnN0YW5jZW9mIFJlbXV4ZXIpKSB7XG4gICAgICB0aGlzLnJlbXV4ZXIgPSBuZXcgUmVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IpO1xuICAgIH1cbiAgICBpZiAoIWRlbXV4ZXIgfHwgIShkZW11eGVyIGluc3RhbmNlb2YgRGVtdXhlcikpIHtcbiAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpO1xuICAgICAgdGhpcy5wcm9iZSA9IERlbXV4ZXIucHJvYmU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBuZWVkc1Byb2JpbmcoZGlzY29udGludWl0eTogYm9vbGVhbiwgdHJhY2tTd2l0Y2g6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbnRpbnVpdHkgY2hhbmdlLCBvciB0cmFjayBzd2l0Y2hcbiAgICAvLyB3ZSBtaWdodCBzd2l0Y2ggZnJvbSBjb250ZW50IHR5cGUgKEFBQyBjb250YWluZXIgdG8gVFMgY29udGFpbmVyLCBvciBUUyB0byBmbXA0IGZvciBleGFtcGxlKVxuICAgIHJldHVybiAhdGhpcy5kZW11eGVyIHx8ICF0aGlzLnJlbXV4ZXIgfHwgZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVjcnlwdGVyKCk6IERlY3J5cHRlciB7XG4gICAgbGV0IGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyO1xuICAgIGlmICghZGVjcnlwdGVyKSB7XG4gICAgICBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIodGhpcy5jb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjcnlwdGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEVuY3J5cHRpb25UeXBlKFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBkZWNyeXB0RGF0YTogRGVjcnlwdERhdGEgfCBudWxsXG4pOiBLZXlEYXRhIHwgbnVsbCB7XG4gIGxldCBlbmNyeXB0aW9uVHlwZTogS2V5RGF0YSB8IG51bGwgPSBudWxsO1xuICBpZiAoXG4gICAgZGF0YS5ieXRlTGVuZ3RoID4gMCAmJlxuICAgIGRlY3J5cHREYXRhICE9IG51bGwgJiZcbiAgICBkZWNyeXB0RGF0YS5rZXkgIT0gbnVsbCAmJlxuICAgIGRlY3J5cHREYXRhLml2ICE9PSBudWxsICYmXG4gICAgZGVjcnlwdERhdGEubWV0aG9kICE9IG51bGxcbiAgKSB7XG4gICAgZW5jcnlwdGlvblR5cGUgPSBkZWNyeXB0RGF0YSBhcyBLZXlEYXRhO1xuICB9XG4gIHJldHVybiBlbmNyeXB0aW9uVHlwZTtcbn1cblxuY29uc3QgZW1wdHlSZXN1bHQgPSAoY2h1bmtNZXRhKTogVHJhbnNtdXhlclJlc3VsdCA9PiAoe1xuICByZW11eFJlc3VsdDoge30sXG4gIGNodW5rTWV0YSxcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQcm9taXNlPFQ+KHA6IFByb21pc2U8VD4gfCBhbnkpOiBwIGlzIFByb21pc2U8VD4ge1xuICByZXR1cm4gJ3RoZW4nIGluIHAgJiYgcC50aGVuIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG5cbmV4cG9ydCBjbGFzcyBUcmFuc211eENvbmZpZyB7XG4gIHB1YmxpYyBhdWRpb0NvZGVjPzogc3RyaW5nO1xuICBwdWJsaWMgdmlkZW9Db2RlYz86IHN0cmluZztcbiAgcHVibGljIGluaXRTZWdtZW50RGF0YT86IFVpbnQ4QXJyYXk7XG4gIHB1YmxpYyBkdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgZGVmYXVsdEluaXRQdHM6IFJhdGlvbmFsVGltZXN0YW1wIHwgbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBhdWRpb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdmlkZW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGluaXRTZWdtZW50RGF0YTogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgICBkdXJhdGlvbjogbnVtYmVyLFxuICAgIGRlZmF1bHRJbml0UHRzPzogUmF0aW9uYWxUaW1lc3RhbXBcbiAgKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAgIHRoaXMuaW5pdFNlZ21lbnREYXRhID0gaW5pdFNlZ21lbnREYXRhO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLmRlZmF1bHRJbml0UHRzID0gZGVmYXVsdEluaXRQdHMgfHwgbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVHJhbnNtdXhTdGF0ZSB7XG4gIHB1YmxpYyBkaXNjb250aW51aXR5OiBib29sZWFuO1xuICBwdWJsaWMgY29udGlndW91czogYm9vbGVhbjtcbiAgcHVibGljIGFjY3VyYXRlVGltZU9mZnNldDogYm9vbGVhbjtcbiAgcHVibGljIHRyYWNrU3dpdGNoOiBib29sZWFuO1xuICBwdWJsaWMgdGltZU9mZnNldDogbnVtYmVyO1xuICBwdWJsaWMgaW5pdFNlZ21lbnRDaGFuZ2U6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgZGlzY29udGludWl0eTogYm9vbGVhbixcbiAgICBjb250aWd1b3VzOiBib29sZWFuLFxuICAgIGFjY3VyYXRlVGltZU9mZnNldDogYm9vbGVhbixcbiAgICB0cmFja1N3aXRjaDogYm9vbGVhbixcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gICAgaW5pdFNlZ21lbnRDaGFuZ2U6IGJvb2xlYW5cbiAgKSB7XG4gICAgdGhpcy5kaXNjb250aW51aXR5ID0gZGlzY29udGludWl0eTtcbiAgICB0aGlzLmNvbnRpZ3VvdXMgPSBjb250aWd1b3VzO1xuICAgIHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0ID0gYWNjdXJhdGVUaW1lT2Zmc2V0O1xuICAgIHRoaXMudHJhY2tTd2l0Y2ggPSB0cmFja1N3aXRjaDtcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2UgPSBpbml0U2VnbWVudENoYW5nZTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIiwiaW1wb3J0IFRyYW5zbXV4ZXIsIHsgaXNQcm9taXNlIH0gZnJvbSAnLi4vZGVtdXgvdHJhbnNtdXhlcic7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgSUxvZ0Z1bmN0aW9uLCBlbmFibGVMb2dzLCBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMsIEVycm9yVHlwZXMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHR5cGUgeyBSZW11eGVkVHJhY2ssIFJlbXV4ZXJSZXN1bHQgfSBmcm9tICcuLi90eXBlcy9yZW11eGVyJztcbmltcG9ydCB0eXBlIHsgVHJhbnNtdXhlclJlc3VsdCwgQ2h1bmtNZXRhZGF0YSB9IGZyb20gJy4uL3R5cGVzL3RyYW5zbXV4ZXInO1xuXG5pZiAodHlwZW9mIF9fSU5fV09SS0VSX18gIT09ICd1bmRlZmluZWQnICYmIF9fSU5fV09SS0VSX18pIHtcbiAgc3RhcnRXb3JrZXIoc2VsZik7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya2VyKHNlbGYpIHtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIGNvbnN0IGZvcndhcmRNZXNzYWdlID0gKGV2LCBkYXRhKSA9PiB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7IGV2ZW50OiBldiwgZGF0YTogZGF0YSB9KTtcbiAgfTtcblxuICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICBvYnNlcnZlci5vbihFdmVudHMuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnRzLkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG5cbiAgLy8gZm9yd2FyZCBsb2dnZXIgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gIGNvbnN0IGZvcndhcmRXb3JrZXJMb2dzID0gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgbG9nRm4gaW4gbG9nZ2VyKSB7XG4gICAgICBjb25zdCBmdW5jOiBJTG9nRnVuY3Rpb24gPSAobWVzc2FnZT8pID0+IHtcbiAgICAgICAgZm9yd2FyZE1lc3NhZ2UoJ3dvcmtlckxvZycsIHtcbiAgICAgICAgICBsb2dUeXBlOiBsb2dGbixcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGxvZ2dlcltsb2dGbl0gPSBmdW5jO1xuICAgIH1cbiAgfTtcblxuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXYpID0+IHtcbiAgICBjb25zdCBkYXRhID0gZXYuZGF0YTtcbiAgICBzd2l0Y2ggKGRhdGEuY21kKSB7XG4gICAgICBjYXNlICdpbml0Jzoge1xuICAgICAgICBjb25zdCBjb25maWcgPSBKU09OLnBhcnNlKGRhdGEuY29uZmlnKTtcbiAgICAgICAgc2VsZi50cmFuc211eGVyID0gbmV3IFRyYW5zbXV4ZXIoXG4gICAgICAgICAgb2JzZXJ2ZXIsXG4gICAgICAgICAgZGF0YS50eXBlU3VwcG9ydGVkLFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBkYXRhLnZlbmRvcixcbiAgICAgICAgICBkYXRhLmlkXG4gICAgICAgICk7XG4gICAgICAgIGVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnLCBkYXRhLmlkKTtcbiAgICAgICAgZm9yd2FyZFdvcmtlckxvZ3MoKTtcbiAgICAgICAgZm9yd2FyZE1lc3NhZ2UoJ2luaXQnLCBudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdjb25maWd1cmUnOiB7XG4gICAgICAgIHNlbGYudHJhbnNtdXhlci5jb25maWd1cmUoZGF0YS5jb25maWcpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbXV4Jzoge1xuICAgICAgICBjb25zdCB0cmFuc211eFJlc3VsdDogVHJhbnNtdXhlclJlc3VsdCB8IFByb21pc2U8VHJhbnNtdXhlclJlc3VsdD4gPVxuICAgICAgICAgIHNlbGYudHJhbnNtdXhlci5wdXNoKFxuICAgICAgICAgICAgZGF0YS5kYXRhLFxuICAgICAgICAgICAgZGF0YS5kZWNyeXB0ZGF0YSxcbiAgICAgICAgICAgIGRhdGEuY2h1bmtNZXRhLFxuICAgICAgICAgICAgZGF0YS5zdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChpc1Byb21pc2UodHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgICAgc2VsZi50cmFuc211eGVyLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICB0cmFuc211eFJlc3VsdFxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgZGF0YSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBmb3J3YXJkTWVzc2FnZShFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgICAgICAgY2h1bmtNZXRhOiBkYXRhLmNodW5rTWV0YSxcbiAgICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgZXJyOiBlcnJvcixcbiAgICAgICAgICAgICAgICByZWFzb246IGB0cmFuc211eGVyLXdvcmtlciBwdXNoIGVycm9yYCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnRyYW5zbXV4ZXIuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICBlbWl0VHJhbnNtdXhDb21wbGV0ZShzZWxmLCB0cmFuc211eFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdmbHVzaCc6IHtcbiAgICAgICAgY29uc3QgaWQgPSBkYXRhLmNodW5rTWV0YTtcbiAgICAgICAgbGV0IHRyYW5zbXV4UmVzdWx0ID0gc2VsZi50cmFuc211eGVyLmZsdXNoKGlkKTtcbiAgICAgICAgY29uc3QgYXN5bmNGbHVzaCA9IGlzUHJvbWlzZSh0cmFuc211eFJlc3VsdCk7XG4gICAgICAgIGlmIChhc3luY0ZsdXNoIHx8IHNlbGYudHJhbnNtdXhlci5hc3luYykge1xuICAgICAgICAgIGlmICghaXNQcm9taXNlKHRyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICAgICAgdHJhbnNtdXhSZXN1bHQgPSBQcm9taXNlLnJlc29sdmUodHJhbnNtdXhSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFuc211eFJlc3VsdFxuICAgICAgICAgICAgLnRoZW4oKHJlc3VsdHM6IEFycmF5PFRyYW5zbXV4ZXJSZXN1bHQ+KSA9PiB7XG4gICAgICAgICAgICAgIGhhbmRsZUZsdXNoUmVzdWx0KHNlbGYsIHJlc3VsdHMgYXMgQXJyYXk8VHJhbnNtdXhlclJlc3VsdD4sIGlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIGZvcndhcmRNZXNzYWdlKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgICAgICAgICBjaHVua01ldGE6IGRhdGEuY2h1bmtNZXRhLFxuICAgICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBlcnI6IGVycm9yLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogYHRyYW5zbXV4ZXItd29ya2VyIGZsdXNoIGVycm9yYCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVGbHVzaFJlc3VsdChcbiAgICAgICAgICAgIHNlbGYsXG4gICAgICAgICAgICB0cmFuc211eFJlc3VsdCBhcyBBcnJheTxUcmFuc211eGVyUmVzdWx0PixcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVtaXRUcmFuc211eENvbXBsZXRlKFxuICBzZWxmOiBhbnksXG4gIHRyYW5zbXV4UmVzdWx0OiBUcmFuc211eGVyUmVzdWx0XG4pOiBib29sZWFuIHtcbiAgaWYgKGlzRW1wdHlSZXN1bHQodHJhbnNtdXhSZXN1bHQucmVtdXhSZXN1bHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHRyYW5zZmVyYWJsZTogQXJyYXk8QXJyYXlCdWZmZXI+ID0gW107XG4gIGNvbnN0IHsgYXVkaW8sIHZpZGVvIH0gPSB0cmFuc211eFJlc3VsdC5yZW11eFJlc3VsdDtcbiAgaWYgKGF1ZGlvKSB7XG4gICAgYWRkVG9UcmFuc2ZlcmFibGUodHJhbnNmZXJhYmxlLCBhdWRpbyk7XG4gIH1cbiAgaWYgKHZpZGVvKSB7XG4gICAgYWRkVG9UcmFuc2ZlcmFibGUodHJhbnNmZXJhYmxlLCB2aWRlbyk7XG4gIH1cbiAgc2VsZi5wb3N0TWVzc2FnZShcbiAgICB7IGV2ZW50OiAndHJhbnNtdXhDb21wbGV0ZScsIGRhdGE6IHRyYW5zbXV4UmVzdWx0IH0sXG4gICAgdHJhbnNmZXJhYmxlXG4gICk7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBDb252ZXJ0cyBkYXRhIHRvIGEgdHJhbnNmZXJhYmxlIG9iamVjdCBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDExLzEyL1RyYW5zZmVyYWJsZS1PYmplY3RzLUxpZ2h0bmluZy1GYXN0KVxuLy8gaW4gb3JkZXIgdG8gbWluaW1pemUgbWVzc2FnZSBwYXNzaW5nIG92ZXJoZWFkXG5mdW5jdGlvbiBhZGRUb1RyYW5zZmVyYWJsZShcbiAgdHJhbnNmZXJhYmxlOiBBcnJheTxBcnJheUJ1ZmZlcj4sXG4gIHRyYWNrOiBSZW11eGVkVHJhY2tcbikge1xuICBpZiAodHJhY2suZGF0YTEpIHtcbiAgICB0cmFuc2ZlcmFibGUucHVzaCh0cmFjay5kYXRhMS5idWZmZXIpO1xuICB9XG4gIGlmICh0cmFjay5kYXRhMikge1xuICAgIHRyYW5zZmVyYWJsZS5wdXNoKHRyYWNrLmRhdGEyLmJ1ZmZlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRmx1c2hSZXN1bHQoXG4gIHNlbGY6IGFueSxcbiAgcmVzdWx0czogQXJyYXk8VHJhbnNtdXhlclJlc3VsdD4sXG4gIGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YVxuKSB7XG4gIGNvbnN0IHBhcnNlZCA9IHJlc3VsdHMucmVkdWNlKFxuICAgIChwYXJzZWQsIHJlc3VsdCkgPT4gZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgcmVzdWx0KSB8fCBwYXJzZWQsXG4gICAgZmFsc2VcbiAgKTtcbiAgaWYgKCFwYXJzZWQpIHtcbiAgICAvLyBFbWl0IGF0IGxlYXN0IG9uZSBcInRyYW5zbXV4Q29tcGxldGVcIiBtZXNzYWdlIGV2ZW4gaWYgbWVkaWEgaXMgbm90IGZvdW5kIHRvIHVwZGF0ZSBzdHJlYW0tY29udHJvbGxlciBzdGF0ZSB0byBQQVJTSU5HXG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7IGV2ZW50OiAndHJhbnNtdXhDb21wbGV0ZScsIGRhdGE6IHJlc3VsdHNbMF0gfSk7XG4gIH1cbiAgc2VsZi5wb3N0TWVzc2FnZSh7IGV2ZW50OiAnZmx1c2gnLCBkYXRhOiBjaHVua01ldGEgfSk7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlSZXN1bHQocmVtdXhSZXN1bHQ6IFJlbXV4ZXJSZXN1bHQpIHtcbiAgcmV0dXJuIChcbiAgICAhcmVtdXhSZXN1bHQuYXVkaW8gJiZcbiAgICAhcmVtdXhSZXN1bHQudmlkZW8gJiZcbiAgICAhcmVtdXhSZXN1bHQudGV4dCAmJlxuICAgICFyZW11eFJlc3VsdC5pZDMgJiZcbiAgICAhcmVtdXhSZXN1bHQuaW5pdFNlZ21lbnRcbiAgKTtcbn1cbiIsIi8vIGVuc3VyZSB0aGUgd29ya2VyIGVuZHMgdXAgaW4gdGhlIGJ1bmRsZVxuLy8gSWYgdGhlIHdvcmtlciBzaG91bGQgbm90IGJlIGluY2x1ZGVkIHRoaXMgZ2V0cyBhbGlhc2VkIHRvIGVtcHR5LmpzXG5pbXBvcnQgJy4vdHJhbnNtdXhlci13b3JrZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzVU1EV29ya2VyKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZW9mIF9fSExTX1dPUktFUl9CVU5ETEVfXyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IHR5cGUgV29ya2VyQ29udGV4dCA9IHtcbiAgd29ya2VyOiBXb3JrZXI7XG4gIG9iamVjdFVSTD86IHN0cmluZztcbiAgc2NyaXB0VVJMPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGluamVjdFdvcmtlcigpOiBXb3JrZXJDb250ZXh0IHtcbiAgY29uc3QgYmxvYiA9IG5ldyBzZWxmLkJsb2IoXG4gICAgW1xuICAgICAgYHZhciBleHBvcnRzPXt9O3ZhciBtb2R1bGU9e2V4cG9ydHM6ZXhwb3J0c307ZnVuY3Rpb24gZGVmaW5lKGYpe2YoKX07ZGVmaW5lLmFtZD10cnVlOygke19fSExTX1dPUktFUl9CVU5ETEVfXy50b1N0cmluZygpfSkodHJ1ZSk7YCxcbiAgICBdLFxuICAgIHtcbiAgICAgIHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnLFxuICAgIH1cbiAgKTtcbiAgY29uc3Qgb2JqZWN0VVJMID0gc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICBjb25zdCB3b3JrZXIgPSBuZXcgc2VsZi5Xb3JrZXIob2JqZWN0VVJMKTtcblxuICByZXR1cm4ge1xuICAgIHdvcmtlcixcbiAgICBvYmplY3RVUkwsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkV29ya2VyKHBhdGg6IHN0cmluZyk6IFdvcmtlckNvbnRleHQge1xuICBjb25zdCBzY3JpcHRVUkwgPSBuZXcgc2VsZi5VUkwocGF0aCwgc2VsZi5sb2NhdGlvbi5ocmVmKS5ocmVmO1xuICBjb25zdCB3b3JrZXIgPSBuZXcgc2VsZi5Xb3JrZXIoc2NyaXB0VVJMKTtcblxuICByZXR1cm4ge1xuICAgIHdvcmtlcixcbiAgICBzY3JpcHRVUkwsXG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBXb3JrZXJDb250ZXh0LFxuICBoYXNVTURXb3JrZXIsXG4gIGluamVjdFdvcmtlcixcbiAgbG9hZFdvcmtlcixcbn0gZnJvbSAnLi9pbmplY3Qtd29ya2VyJztcbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgVHJhbnNtdXhlciwge1xuICBUcmFuc211eENvbmZpZyxcbiAgVHJhbnNtdXhTdGF0ZSxcbiAgaXNQcm9taXNlLFxufSBmcm9tICcuLi9kZW11eC90cmFuc211eGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgZ2V0TWVkaWFTb3VyY2UgfSBmcm9tICcuLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXInO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBGcmFnbWVudCwgUGFydCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IENodW5rTWV0YWRhdGEsIFRyYW5zbXV4ZXJSZXN1bHQgfSBmcm9tICcuLi90eXBlcy90cmFuc211eGVyJztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuaW1wb3J0IHR5cGUgeyBIbHNFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBQbGF5bGlzdExldmVsVHlwZSB9IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgdHlwZSB7IFR5cGVTdXBwb3J0ZWQgfSBmcm9tICcuL3RzZGVtdXhlcic7XG5pbXBvcnQgdHlwZSB7IFJhdGlvbmFsVGltZXN0YW1wIH0gZnJvbSAnLi4vdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24nO1xuXG5jb25zdCBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKCkgfHwgeyBpc1R5cGVTdXBwb3J0ZWQ6ICgpID0+IGZhbHNlIH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zbXV4ZXJJbnRlcmZhY2Uge1xuICBwdWJsaWMgZXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaGxzOiBIbHM7XG4gIHByaXZhdGUgaWQ6IFBsYXlsaXN0TGV2ZWxUeXBlO1xuICBwcml2YXRlIG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXI7XG4gIHByaXZhdGUgZnJhZzogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBwYXJ0OiBQYXJ0IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgdXNlV29ya2VyOiBib29sZWFuO1xuICBwcml2YXRlIHdvcmtlckNvbnRleHQ6IFdvcmtlckNvbnRleHQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBvbndtc2c/OiBGdW5jdGlvbjtcbiAgcHJpdmF0ZSB0cmFuc211eGVyOiBUcmFuc211eGVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgb25UcmFuc211eENvbXBsZXRlOiAodHJhbnNtdXhSZXN1bHQ6IFRyYW5zbXV4ZXJSZXN1bHQpID0+IHZvaWQ7XG4gIHByaXZhdGUgb25GbHVzaDogKGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YSkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBobHM6IEhscyxcbiAgICBpZDogUGxheWxpc3RMZXZlbFR5cGUsXG4gICAgb25UcmFuc211eENvbXBsZXRlOiAodHJhbnNtdXhSZXN1bHQ6IFRyYW5zbXV4ZXJSZXN1bHQpID0+IHZvaWQsXG4gICAgb25GbHVzaDogKGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YSkgPT4gdm9pZFxuICApIHtcbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnVzZVdvcmtlciA9ICEhY29uZmlnLmVuYWJsZVdvcmtlcjtcbiAgICB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZSA9IG9uVHJhbnNtdXhDb21wbGV0ZTtcbiAgICB0aGlzLm9uRmx1c2ggPSBvbkZsdXNoO1xuXG4gICAgY29uc3QgZm9yd2FyZE1lc3NhZ2UgPSAoZXYsIGRhdGEpID0+IHtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICBpZiAoZXYgPT09IEV2ZW50cy5FUlJPUikge1xuICAgICAgICB0aGlzLmVycm9yID0gZGF0YS5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXYsIGRhdGEpO1xuICAgIH07XG5cbiAgICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCkgYXMgSGxzRXZlbnRFbWl0dGVyO1xuICAgIHRoaXMub2JzZXJ2ZXIub24oRXZlbnRzLkZSQUdfREVDUllQVEVELCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgdGhpcy5vYnNlcnZlci5vbihFdmVudHMuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcblxuICAgIGNvbnN0IHR5cGVTdXBwb3J0ZWQ6IFR5cGVTdXBwb3J0ZWQgPSB7XG4gICAgICBtcDQ6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0JyksXG4gICAgICBtcGVnOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wZWcnKSxcbiAgICAgIG1wMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wM1wiJyksXG4gICAgfTtcbiAgICAvLyBuYXZpZ2F0b3IudmVuZG9yIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJcbiAgICAvLyByZWZlciB0byBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV29ya2VyR2xvYmFsU2NvcGUvbmF2aWdhdG9yXG4gICAgY29uc3QgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvcjtcbiAgICBpZiAodGhpcy51c2VXb3JrZXIgJiYgdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGNhbkNyZWF0ZVdvcmtlciA9IGNvbmZpZy53b3JrZXJQYXRoIHx8IGhhc1VNRFdvcmtlcigpO1xuICAgICAgaWYgKGNhbkNyZWF0ZVdvcmtlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChjb25maWcud29ya2VyUGF0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgbG9hZGluZyBXZWIgV29ya2VyICR7Y29uZmlnLndvcmtlclBhdGh9IGZvciBcIiR7aWR9XCJgKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IGxvYWRXb3JrZXIoY29uZmlnLndvcmtlclBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBpbmplY3RpbmcgV2ViIFdvcmtlciBmb3IgXCIke2lkfVwiYCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlckNvbnRleHQgPSBpbmplY3RXb3JrZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vbndtc2cgPSAoZXY6IGFueSkgPT4gdGhpcy5vbldvcmtlck1lc3NhZ2UoZXYpO1xuICAgICAgICAgIGNvbnN0IHsgd29ya2VyIH0gPSB0aGlzLndvcmtlckNvbnRleHQ7XG4gICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyBhcyBhbnkpO1xuICAgICAgICAgIHdvcmtlci5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYCR7ZXZlbnQubWVzc2FnZX0gICgke2V2ZW50LmZpbGVuYW1lfToke2V2ZW50LmxpbmVub30pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbmZpZy5lbmFibGVXb3JrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBFcnJvciBpbiBcIiR7aWR9XCIgV2ViIFdvcmtlciwgZmFsbGJhY2sgdG8gaW5saW5lYCk7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGV2ZW50OiAnZGVtdXhlcldvcmtlcicsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgY21kOiAnaW5pdCcsXG4gICAgICAgICAgICB0eXBlU3VwcG9ydGVkOiB0eXBlU3VwcG9ydGVkLFxuICAgICAgICAgICAgdmVuZG9yOiB2ZW5kb3IsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBjb25maWc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZyksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYEVycm9yIHNldHRpbmcgdXAgXCIke2lkfVwiIFdlYiBXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZWAsXG4gICAgICAgICAgICBlcnJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucmVzZXRXb3JrZXIoKTtcbiAgICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlcihcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIsXG4gICAgICAgICAgICB0eXBlU3VwcG9ydGVkLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgdmVuZG9yLFxuICAgICAgICAgICAgaWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlcihcbiAgICAgIHRoaXMub2JzZXJ2ZXIsXG4gICAgICB0eXBlU3VwcG9ydGVkLFxuICAgICAgY29uZmlnLFxuICAgICAgdmVuZG9yLFxuICAgICAgaWRcbiAgICApO1xuICB9XG5cbiAgcmVzZXRXb3JrZXIoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgY29uc3QgeyB3b3JrZXIsIG9iamVjdFVSTCB9ID0gdGhpcy53b3JrZXJDb250ZXh0O1xuICAgICAgaWYgKG9iamVjdFVSTCkge1xuICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgdHJhbnNtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVUkwpO1xuICAgICAgfVxuICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyBhcyBhbnkpO1xuICAgICAgd29ya2VyLm9uZXJyb3IgPSBudWxsO1xuICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIHRoaXMucmVzZXRXb3JrZXIoKTtcbiAgICAgIHRoaXMub253bXNnID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuICAgICAgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgICAgdHJhbnNtdXhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgIG9ic2VydmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH1cbiAgICB0aGlzLmZyYWcgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICB9XG5cbiAgcHVzaChcbiAgICBkYXRhOiBBcnJheUJ1ZmZlcixcbiAgICBpbml0U2VnbWVudERhdGE6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQsXG4gICAgYXVkaW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHZpZGVvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBwYXJ0OiBQYXJ0IHwgbnVsbCxcbiAgICBkdXJhdGlvbjogbnVtYmVyLFxuICAgIGFjY3VyYXRlVGltZU9mZnNldDogYm9vbGVhbixcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGEsXG4gICAgZGVmYXVsdEluaXRQVFM/OiBSYXRpb25hbFRpbWVzdGFtcFxuICApOiB2b2lkIHtcbiAgICBjaHVua01ldGEudHJhbnNtdXhpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHsgdHJhbnNtdXhlciB9ID0gdGhpcztcbiAgICBjb25zdCB0aW1lT2Zmc2V0ID0gcGFydCA/IHBhcnQuc3RhcnQgOiBmcmFnLnN0YXJ0O1xuICAgIC8vIFRPRE86IHB1c2ggXCJjbGVhci1sZWFkXCIgZGVjcnlwdCBkYXRhIGZvciB1bmVuY3J5cHRlZCBmcmFnbWVudHMgaW4gc3RyZWFtcyB3aXRoIGVuY3J5cHRlZCBvbmVzXG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgIGNvbnN0IGxhc3RGcmFnID0gdGhpcy5mcmFnO1xuXG4gICAgY29uc3QgZGlzY29udGludWl0eSA9ICEobGFzdEZyYWcgJiYgZnJhZy5jYyA9PT0gbGFzdEZyYWcuY2MpO1xuICAgIGNvbnN0IHRyYWNrU3dpdGNoID0gIShsYXN0RnJhZyAmJiBjaHVua01ldGEubGV2ZWwgPT09IGxhc3RGcmFnLmxldmVsKTtcbiAgICBjb25zdCBzbkRpZmYgPSBsYXN0RnJhZyA/IGNodW5rTWV0YS5zbiAtIChsYXN0RnJhZy5zbiBhcyBudW1iZXIpIDogLTE7XG4gICAgY29uc3QgcGFydERpZmYgPSB0aGlzLnBhcnQgPyBjaHVua01ldGEucGFydCAtIHRoaXMucGFydC5pbmRleCA6IC0xO1xuICAgIGNvbnN0IHByb2dyZXNzaXZlID1cbiAgICAgIHNuRGlmZiA9PT0gMCAmJlxuICAgICAgY2h1bmtNZXRhLmlkID4gMSAmJlxuICAgICAgY2h1bmtNZXRhLmlkID09PSBsYXN0RnJhZz8uc3RhdHMuY2h1bmtDb3VudDtcbiAgICBjb25zdCBjb250aWd1b3VzID1cbiAgICAgICF0cmFja1N3aXRjaCAmJlxuICAgICAgKHNuRGlmZiA9PT0gMSB8fFxuICAgICAgICAoc25EaWZmID09PSAwICYmIChwYXJ0RGlmZiA9PT0gMSB8fCAocHJvZ3Jlc3NpdmUgJiYgcGFydERpZmYgPD0gMCkpKSk7XG4gICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIGlmICh0cmFja1N3aXRjaCB8fCBzbkRpZmYgfHwgZnJhZy5zdGF0cy5wYXJzaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBmcmFnLnN0YXRzLnBhcnNpbmcuc3RhcnQgPSBub3c7XG4gICAgfVxuICAgIGlmIChwYXJ0ICYmIChwYXJ0RGlmZiB8fCAhY29udGlndW91cykpIHtcbiAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5zdGFydCA9IG5vdztcbiAgICB9XG4gICAgY29uc3QgaW5pdFNlZ21lbnRDaGFuZ2UgPSAhKFxuICAgICAgbGFzdEZyYWcgJiYgZnJhZy5pbml0U2VnbWVudD8udXJsID09PSBsYXN0RnJhZy5pbml0U2VnbWVudD8udXJsXG4gICAgKTtcbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBUcmFuc211eFN0YXRlKFxuICAgICAgZGlzY29udGludWl0eSxcbiAgICAgIGNvbnRpZ3VvdXMsXG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICB0cmFja1N3aXRjaCxcbiAgICAgIHRpbWVPZmZzZXQsXG4gICAgICBpbml0U2VnbWVudENoYW5nZVxuICAgICk7XG4gICAgaWYgKCFjb250aWd1b3VzIHx8IGRpc2NvbnRpbnVpdHkgfHwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgICAgIGxvZ2dlci5sb2coYFt0cmFuc211eGVyLWludGVyZmFjZSwgJHtmcmFnLnR5cGV9XTogU3RhcnRpbmcgbmV3IHRyYW5zbXV4IHNlc3Npb24gZm9yIHNuOiAke2NodW5rTWV0YS5zbn0gcDogJHtjaHVua01ldGEucGFydH0gbGV2ZWw6ICR7Y2h1bmtNZXRhLmxldmVsfSBpZDogJHtjaHVua01ldGEuaWR9XG4gICAgICAgIGRpc2NvbnRpbnVpdHk6ICR7ZGlzY29udGludWl0eX1cbiAgICAgICAgdHJhY2tTd2l0Y2g6ICR7dHJhY2tTd2l0Y2h9XG4gICAgICAgIGNvbnRpZ3VvdXM6ICR7Y29udGlndW91c31cbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiAke2FjY3VyYXRlVGltZU9mZnNldH1cbiAgICAgICAgdGltZU9mZnNldDogJHt0aW1lT2Zmc2V0fVxuICAgICAgICBpbml0U2VnbWVudENoYW5nZTogJHtpbml0U2VnbWVudENoYW5nZX1gKTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBUcmFuc211eENvbmZpZyhcbiAgICAgICAgYXVkaW9Db2RlYyxcbiAgICAgICAgdmlkZW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnREYXRhLFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZGVmYXVsdEluaXRQVFNcbiAgICAgICk7XG4gICAgICB0aGlzLmNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG5cbiAgICAvLyBGcmFncyB3aXRoIHNuIG9mICdpbml0U2VnbWVudCcgYXJlIG5vdCB0cmFuc211eGVkXG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgLy8gcG9zdCBmcmFnbWVudCBwYXlsb2FkIGFzIHRyYW5zZmVyYWJsZSBvYmplY3RzIGZvciBBcnJheUJ1ZmZlciAobm8gY29weSlcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2UoXG4gICAgICAgIHtcbiAgICAgICAgICBjbWQ6ICdkZW11eCcsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBkZWNyeXB0ZGF0YSxcbiAgICAgICAgICBjaHVua01ldGEsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IFtkYXRhXSA6IFtdXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgY29uc3QgdHJhbnNtdXhSZXN1bHQgPSB0cmFuc211eGVyLnB1c2goXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGRlY3J5cHRkYXRhLFxuICAgICAgICBjaHVua01ldGEsXG4gICAgICAgIHN0YXRlXG4gICAgICApO1xuICAgICAgaWYgKGlzUHJvbWlzZSh0cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgdHJhbnNtdXhlci5hc3luYyA9IHRydWU7XG4gICAgICAgIHRyYW5zbXV4UmVzdWx0XG4gICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShkYXRhKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNtdXhlckVycm9yKFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgICAgICAndHJhbnNtdXhlci1pbnRlcmZhY2UgcHVzaCBlcnJvcidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc211eGVyLmFzeW5jID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdCBhcyBUcmFuc211eGVyUmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmbHVzaChjaHVua01ldGE6IENodW5rTWV0YWRhdGEpIHtcbiAgICBjaHVua01ldGEudHJhbnNtdXhpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHsgdHJhbnNtdXhlciB9ID0gdGhpcztcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICAxO1xuICAgICAgdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ2ZsdXNoJyxcbiAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICBsZXQgdHJhbnNtdXhSZXN1bHQgPSB0cmFuc211eGVyLmZsdXNoKGNodW5rTWV0YSk7XG4gICAgICBjb25zdCBhc3luY0ZsdXNoID0gaXNQcm9taXNlKHRyYW5zbXV4UmVzdWx0KTtcbiAgICAgIGlmIChhc3luY0ZsdXNoIHx8IHRyYW5zbXV4ZXIuYXN5bmMpIHtcbiAgICAgICAgaWYgKCFpc1Byb21pc2UodHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgICAgdHJhbnNtdXhSZXN1bHQgPSBQcm9taXNlLnJlc29sdmUodHJhbnNtdXhSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zbXV4UmVzdWx0XG4gICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRmx1c2hSZXN1bHQoZGF0YSwgY2h1bmtNZXRhKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNtdXhlckVycm9yKFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgICAgICAndHJhbnNtdXhlci1pbnRlcmZhY2UgZmx1c2ggZXJyb3InXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGbHVzaFJlc3VsdChcbiAgICAgICAgICB0cmFuc211eFJlc3VsdCBhcyBBcnJheTxUcmFuc211eGVyUmVzdWx0PixcbiAgICAgICAgICBjaHVua01ldGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyYW5zbXV4ZXJFcnJvcihcbiAgICBlcnJvcjogRXJyb3IsXG4gICAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhLFxuICAgIHJlYXNvbjogc3RyaW5nXG4gICkge1xuICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgIGNodW5rTWV0YSxcbiAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgIGVycm9yLFxuICAgICAgZXJyOiBlcnJvcixcbiAgICAgIHJlYXNvbixcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRmx1c2hSZXN1bHQoXG4gICAgcmVzdWx0czogQXJyYXk8VHJhbnNtdXhlclJlc3VsdD4sXG4gICAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhXG4gICkge1xuICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUocmVzdWx0KTtcbiAgICB9KTtcbiAgICB0aGlzLm9uRmx1c2goY2h1bmtNZXRhKTtcbiAgfVxuXG4gIHByaXZhdGUgb25Xb3JrZXJNZXNzYWdlKGV2OiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBkYXRhID0gZXYuZGF0YTtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBzd2l0Y2ggKGRhdGEuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOiB7XG4gICAgICAgIGNvbnN0IG9iamVjdFVSTCA9IHRoaXMud29ya2VyQ29udGV4dD8ub2JqZWN0VVJMO1xuICAgICAgICBpZiAob2JqZWN0VVJMKSB7XG4gICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVUkwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICd0cmFuc211eENvbXBsZXRlJzoge1xuICAgICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUoZGF0YS5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ2ZsdXNoJzoge1xuICAgICAgICB0aGlzLm9uRmx1c2goZGF0YS5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhc3MgbG9ncyBmcm9tIHRoZSB3b3JrZXIgdGhyZWFkIHRvIHRoZSBtYWluIGxvZ2dlclxuICAgICAgY2FzZSAnd29ya2VyTG9nJzpcbiAgICAgICAgaWYgKGxvZ2dlcltkYXRhLmRhdGEubG9nVHlwZV0pIHtcbiAgICAgICAgICBsb2dnZXJbZGF0YS5kYXRhLmxvZ1R5cGVdKGRhdGEuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XG4gICAgICAgIGRhdGEuZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgICBkYXRhLmRhdGEuaWQgPSB0aGlzLmlkO1xuICAgICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnOiBUcmFuc211eENvbmZpZykge1xuICAgIGNvbnN0IHsgdHJhbnNtdXhlciB9ID0gdGhpcztcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICB0aGlzLndvcmtlckNvbnRleHQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnY29uZmlndXJlJyxcbiAgICAgICAgY29uZmlnLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICB0cmFuc211eGVyLmNvbmZpZ3VyZShjb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQ6IFRyYW5zbXV4ZXJSZXN1bHQpIHtcbiAgICByZXN1bHQuY2h1bmtNZXRhLnRyYW5zbXV4aW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUocmVzdWx0KTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBCdWZmZXJJbmZvIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgeyBCdWZmZXJIZWxwZXIgfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBQbGF5bGlzdExldmVsVHlwZSB9IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IEZyYWdtZW50VHJhY2tlciB9IGZyb20gJy4vZnJhZ21lbnQtdHJhY2tlcic7XG5cbmV4cG9ydCBjb25zdCBTVEFMTF9NSU5JTVVNX0RVUkFUSU9OX01TID0gMjUwO1xuZXhwb3J0IGNvbnN0IE1BWF9TVEFSVF9HQVBfSlVNUCA9IDIuMDtcbmV4cG9ydCBjb25zdCBTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EUyA9IDAuMTtcbmV4cG9ydCBjb25zdCBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCA9IDAuMDU7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhcENvbnRyb2xsZXIge1xuICBwcml2YXRlIGNvbmZpZzogSGxzQ29uZmlnO1xuICBwcml2YXRlIG1lZGlhOiBIVE1MTWVkaWFFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZnJhZ21lbnRUcmFja2VyOiBGcmFnbWVudFRyYWNrZXI7XG4gIHByaXZhdGUgaGxzOiBIbHM7XG4gIHByaXZhdGUgbnVkZ2VSZXRyeTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBzdGFsbFJlcG9ydGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgc3RhbGxlZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbW92ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBzZWVraW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnLCBtZWRpYSwgZnJhZ21lbnRUcmFja2VyLCBobHMpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gIH1cblxuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwbGF5aGVhZCBpcyBzdHVjayB3aXRoaW4gYSBnYXAsIGFuZCBpZiBzbywgYXR0ZW1wdHMgdG8gZnJlZSBpdC5cbiAgICogQSBnYXAgaXMgYW4gdW5idWZmZXJlZCByYW5nZSBiZXR3ZWVuIHR3byBidWZmZXJlZCByYW5nZXMgKG9yIHRoZSBzdGFydCBhbmQgdGhlIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlKS5cbiAgICpcbiAgICogQHBhcmFtIGxhc3RDdXJyZW50VGltZSAtIFByZXZpb3VzbHkgcmVhZCBwbGF5aGVhZCBwb3NpdGlvblxuICAgKi9cbiAgcHVibGljIHBvbGwobGFzdEN1cnJlbnRUaW1lOiBudW1iZXIsIGFjdGl2ZUZyYWc6IEZyYWdtZW50IHwgbnVsbCkge1xuICAgIGNvbnN0IHsgY29uZmlnLCBtZWRpYSwgc3RhbGxlZCB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjdXJyZW50VGltZSwgc2Vla2luZyB9ID0gbWVkaWE7XG4gICAgY29uc3Qgc2Vla2VkID0gdGhpcy5zZWVraW5nICYmICFzZWVraW5nO1xuICAgIGNvbnN0IGJlZ2luU2VlayA9ICF0aGlzLnNlZWtpbmcgJiYgc2Vla2luZztcblxuICAgIHRoaXMuc2Vla2luZyA9IHNlZWtpbmc7XG5cbiAgICAvLyBUaGUgcGxheWhlYWQgaXMgbW92aW5nLCBuby1vcFxuICAgIGlmIChjdXJyZW50VGltZSAhPT0gbGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgIGlmIChzdGFsbGVkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBwbGF5aGVhZCBpcyBub3cgbW92aW5nLCBidXQgd2FzIHByZXZpb3VzbHkgc3RhbGxlZFxuICAgICAgICBpZiAodGhpcy5zdGFsbFJlcG9ydGVkKSB7XG4gICAgICAgICAgY29uc3Qgc3RhbGxlZER1cmF0aW9uID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YWxsZWQ7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgcGxheWJhY2sgbm90IHN0dWNrIGFueW1vcmUgQCR7Y3VycmVudFRpbWV9LCBhZnRlciAke01hdGgucm91bmQoXG4gICAgICAgICAgICAgIHN0YWxsZWREdXJhdGlvblxuICAgICAgICAgICAgKX1tc2BcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgc3RhbGxlZCBzdGF0ZSB3aGVuIGJlZ2lubmluZyBvciBmaW5pc2hpbmcgc2Vla2luZyBzbyB0aGF0IHdlIGRvbid0IHJlcG9ydCBzdGFsbHMgY29taW5nIG91dCBvZiBhIHNlZWtcbiAgICBpZiAoYmVnaW5TZWVrIHx8IHNlZWtlZCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGxheWhlYWQgc2hvdWxkIG5vdCBiZSBtb3ZpbmdcbiAgICBpZiAoXG4gICAgICAobWVkaWEucGF1c2VkICYmICFzZWVraW5nKSB8fFxuICAgICAgbWVkaWEuZW5kZWQgfHxcbiAgICAgIG1lZGlhLnBsYXliYWNrUmF0ZSA9PT0gMCB8fFxuICAgICAgIUJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSkubGVuZ3RoXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgMCk7XG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IGJ1ZmZlckluZm8ubGVuID4gMDtcbiAgICBjb25zdCBuZXh0U3RhcnQgPSBidWZmZXJJbmZvLm5leHRTdGFydCB8fCAwO1xuXG4gICAgLy8gVGhlcmUgaXMgbm8gcGxheWFibGUgYnVmZmVyIChzZWVrZWQsIHdhaXRpbmcgZm9yIGJ1ZmZlcilcbiAgICBpZiAoIWlzQnVmZmVyZWQgJiYgIW5leHRTdGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZWVraW5nKSB7XG4gICAgICAvLyBXYWl0aW5nIGZvciBzZWVraW5nIGluIGEgYnVmZmVyZWQgcmFuZ2UgdG8gY29tcGxldGVcbiAgICAgIGNvbnN0IGhhc0Vub3VnaEJ1ZmZlciA9IGJ1ZmZlckluZm8ubGVuID4gTUFYX1NUQVJUX0dBUF9KVU1QO1xuICAgICAgLy8gTmV4dCBidWZmZXJlZCByYW5nZSBpcyB0b28gZmFyIGFoZWFkIHRvIGp1bXAgdG8gd2hpbGUgc3RpbGwgc2Vla2luZ1xuICAgICAgY29uc3Qgbm9CdWZmZXJHYXAgPVxuICAgICAgICAhbmV4dFN0YXJ0IHx8XG4gICAgICAgIChhY3RpdmVGcmFnICYmIGFjdGl2ZUZyYWcuc3RhcnQgPD0gY3VycmVudFRpbWUpIHx8XG4gICAgICAgIChuZXh0U3RhcnQgLSBjdXJyZW50VGltZSA+IE1BWF9TVEFSVF9HQVBfSlVNUCAmJlxuICAgICAgICAgICF0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpKTtcbiAgICAgIGlmIChoYXNFbm91Z2hCdWZmZXIgfHwgbm9CdWZmZXJHYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVzZXQgbW92ZWQgc3RhdGUgd2hlbiBzZWVraW5nIHRvIGEgcG9pbnQgaW4gb3IgYmVmb3JlIGEgZ2FwXG4gICAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBzdGFydCBnYXBzIGlmIHdlIGhhdmVuJ3QgcGxheWVkLCBidXQgdGhlIGxhc3QgcG9sbCBkZXRlY3RlZCB0aGUgc3RhcnQgb2YgYSBzdGFsbFxuICAgIC8vIFRoZSBhZGRpdGlvbiBwb2xsIGdpdmVzIHRoZSBicm93c2VyIGEgY2hhbmNlIHRvIGp1bXAgdGhlIGdhcCBmb3IgdXNcbiAgICBpZiAoIXRoaXMubW92ZWQgJiYgdGhpcy5zdGFsbGVkICE9PSBudWxsKSB7XG4gICAgICAvLyBKdW1wIHN0YXJ0IGdhcHMgd2l0aGluIGp1bXAgdGhyZXNob2xkXG4gICAgICBjb25zdCBzdGFydEp1bXAgPVxuICAgICAgICBNYXRoLm1heChuZXh0U3RhcnQsIGJ1ZmZlckluZm8uc3RhcnQgfHwgMCkgLSBjdXJyZW50VGltZTtcblxuICAgICAgLy8gV2hlbiBqb2luaW5nIGEgbGl2ZSBzdHJlYW0gd2l0aCBhdWRpbyB0cmFja3MsIGFjY291bnQgZm9yIGxpdmUgcGxheWxpc3Qgd2luZG93IHNsaWRpbmcgYnkgYWxsb3dpbmdcbiAgICAgIC8vIGEgbGFyZ2VyIGp1bXAgb3ZlciBzdGFydCBnYXBzIGNhdXNlZCBieSB0aGUgYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgYnVmZmVyaW5nIGEgc3RhcnQgZnJhZ21lbnRcbiAgICAgIC8vIHRoYXQgYmVnaW5zIG92ZXIgMSB0YXJnZXQgZHVyYXRpb24gYWZ0ZXIgdGhlIHZpZGVvIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNcbiAgICAgICAgPyB0aGlzLmhscy5sZXZlbHNbdGhpcy5obHMuY3VycmVudExldmVsXVxuICAgICAgICA6IG51bGw7XG4gICAgICBjb25zdCBpc0xpdmUgPSBsZXZlbD8uZGV0YWlscz8ubGl2ZTtcbiAgICAgIGNvbnN0IG1heFN0YXJ0R2FwSnVtcCA9IGlzTGl2ZVxuICAgICAgICA/IGxldmVsIS5kZXRhaWxzIS50YXJnZXRkdXJhdGlvbiAqIDJcbiAgICAgICAgOiBNQVhfU1RBUlRfR0FQX0pVTVA7XG4gICAgICBjb25zdCBwYXJ0aWFsT3JHYXAgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpO1xuICAgICAgaWYgKHN0YXJ0SnVtcCA+IDAgJiYgKHN0YXJ0SnVtcCA8PSBtYXhTdGFydEdhcEp1bXAgfHwgcGFydGlhbE9yR2FwKSkge1xuICAgICAgICB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShwYXJ0aWFsT3JHYXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdHJhY2tpbmcgc3RhbGwgdGltZVxuICAgIGNvbnN0IHRub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmIChzdGFsbGVkID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN0YWxsZWQgPSB0bm93O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YWxsZWREdXJhdGlvbiA9IHRub3cgLSBzdGFsbGVkO1xuICAgIGlmICghc2Vla2luZyAmJiBzdGFsbGVkRHVyYXRpb24gPj0gU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUykge1xuICAgICAgLy8gUmVwb3J0IHN0YWxsaW5nIGFmdGVyIHRyeWluZyB0byBmaXhcbiAgICAgIHRoaXMuX3JlcG9ydFN0YWxsKGJ1ZmZlckluZm8pO1xuICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXJlZFdpdGhIb2xlcyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKFxuICAgICAgbWVkaWEsXG4gICAgICBjdXJyZW50VGltZSxcbiAgICAgIGNvbmZpZy5tYXhCdWZmZXJIb2xlXG4gICAgKTtcbiAgICB0aGlzLl90cnlGaXhCdWZmZXJTdGFsbChidWZmZXJlZFdpdGhIb2xlcywgc3RhbGxlZER1cmF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3RzIGFuZCBhdHRlbXB0cyB0byBmaXgga25vd24gYnVmZmVyIHN0YWxsaW5nIGlzc3Vlcy5cbiAgICogQHBhcmFtIGJ1ZmZlckluZm8gLSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gICAqIEBwYXJhbSBzdGFsbGVkRHVyYXRpb25NcyAtIFRoZSBhbW91bnQgb2YgdGltZSBIbHMuanMgaGFzIGJlZW4gc3RhbGxpbmcgZm9yLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfdHJ5Rml4QnVmZmVyU3RhbGwoXG4gICAgYnVmZmVySW5mbzogQnVmZmVySW5mbyxcbiAgICBzdGFsbGVkRHVyYXRpb25NczogbnVtYmVyXG4gICkge1xuICAgIGNvbnN0IHsgY29uZmlnLCBmcmFnbWVudFRyYWNrZXIsIG1lZGlhIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuXG4gICAgY29uc3QgcGFydGlhbCA9IGZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpO1xuICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAvLyBUcnkgdG8gc2tpcCBvdmVyIHRoZSBidWZmZXIgaG9sZSBjYXVzZWQgYnkgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgICAvLyBUaGlzIG1ldGhvZCBpc24ndCBsaW1pdGVkIGJ5IHRoZSBzaXplIG9mIHRoZSBnYXAgYmV0d2VlbiBidWZmZXJlZCByYW5nZXNcbiAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShwYXJ0aWFsKTtcbiAgICAgIC8vIHdlIHJldHVybiBoZXJlIGluIHRoaXMgY2FzZSwgbWVhbmluZ1xuICAgICAgLy8gdGhlIGJyYW5jaCBiZWxvdyBvbmx5IGV4ZWN1dGVzIHdoZW4gd2UgaGF2ZW4ndCBzZWVrZWQgdG8gYSBuZXcgcG9zaXRpb25cbiAgICAgIGlmICh0YXJnZXRUaW1lIHx8ICF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlbid0IGhhZCB0byBza2lwIG92ZXIgYSBidWZmZXIgaG9sZSBvZiBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICAvLyB3ZSBtYXkganVzdCBoYXZlIHRvIFwibnVkZ2VcIiB0aGUgcGxheWxpc3QgYXMgdGhlIGJyb3dzZXIgZGVjb2RpbmcvcmVuZGVyaW5nIGVuZ2luZVxuICAgIC8vIG5lZWRzIHRvIGNyb3NzIHNvbWUgc29ydCBvZiB0aHJlc2hvbGQgY292ZXJpbmcgYWxsIHNvdXJjZS1idWZmZXJzIGNvbnRlbnRcbiAgICAvLyB0byBzdGFydCBwbGF5aW5nIHByb3Blcmx5LlxuICAgIGlmIChcbiAgICAgIChidWZmZXJJbmZvLmxlbiA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlIHx8XG4gICAgICAgIChidWZmZXJJbmZvLm5leHRTdGFydCAmJlxuICAgICAgICAgIGJ1ZmZlckluZm8ubmV4dFN0YXJ0IC0gY3VycmVudFRpbWUgPCBjb25maWcubWF4QnVmZmVySG9sZSkpICYmXG4gICAgICBzdGFsbGVkRHVyYXRpb25NcyA+IGNvbmZpZy5oaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2QgKiAxMDAwXG4gICAgKSB7XG4gICAgICBsb2dnZXIud2FybignVHJ5aW5nIHRvIG51ZGdlIHBsYXloZWFkIG92ZXIgYnVmZmVyLWhvbGUnKTtcbiAgICAgIC8vIFRyeSB0byBudWRnZSBjdXJyZW50VGltZSBvdmVyIGEgYnVmZmVyIGhvbGUgaWYgd2UndmUgYmVlbiBzdGFsbGluZyBmb3IgdGhlIGNvbmZpZ3VyZWQgYW1vdW50IG9mIHNlY29uZHNcbiAgICAgIC8vIFdlIG9ubHkgdHJ5IHRvIGp1bXAgdGhlIGhvbGUgaWYgaXQncyB1bmRlciB0aGUgY29uZmlndXJlZCBzaXplXG4gICAgICAvLyBSZXNldCBzdGFsbGVkIHNvIHRvIHJlYXJtIHdhdGNoZG9nIHRpbWVyXG4gICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgdGhpcy5fdHJ5TnVkZ2VCdWZmZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSBCVUZGRVJfU1RBTExFRF9FUlJPUiBldmVudCwgYnV0IG9ubHkgb25jZSBwZXIgc3RhbGwgcGVyaW9kLlxuICAgKiBAcGFyYW0gYnVmZmVyTGVuIC0gVGhlIHBsYXloZWFkIGRpc3RhbmNlIGZyb20gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXIgc2VnbWVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3JlcG9ydFN0YWxsKGJ1ZmZlckluZm86IEJ1ZmZlckluZm8pIHtcbiAgICBjb25zdCB7IGhscywgbWVkaWEsIHN0YWxsUmVwb3J0ZWQgfSA9IHRoaXM7XG4gICAgaWYgKCFzdGFsbFJlcG9ydGVkICYmIG1lZGlhKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXG4gICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBQbGF5YmFjayBzdGFsbGluZyBhdCBAJHtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZVxuICAgICAgICB9IGR1ZSB0byBsb3cgYnVmZmVyICgke0pTT04uc3RyaW5naWZ5KGJ1ZmZlckluZm8pfSlgXG4gICAgICApO1xuICAgICAgbG9nZ2VyLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBidWZmZXI6IGJ1ZmZlckluZm8ubGVuLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGp1bXBpbmcgb3ZlciBrbm93biBnYXBzIGNhdXNlZCBieSBwYXJ0aWFsIGZyYWdtZW50c1xuICAgKiBAcGFyYW0gcGFydGlhbCAtIFRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvdW5kIGF0IHRoZSBjdXJyZW50IHRpbWUgKHdoZXJlIHBsYXliYWNrIGlzIHN0YWxsaW5nKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWw6IEZyYWdtZW50IHwgbnVsbCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBjb25maWcsIGhscywgbWVkaWEgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBjdXJyZW50VGltZSBpcyBiZXR3ZWVuIHVuYnVmZmVyZWQgcmVnaW9ucyBvZiBwYXJ0aWFsIGZyYWdtZW50c1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgMCk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID1cbiAgICAgIGN1cnJlbnRUaW1lIDwgYnVmZmVySW5mby5zdGFydCA/IGJ1ZmZlckluZm8uc3RhcnQgOiBidWZmZXJJbmZvLm5leHRTdGFydDtcbiAgICBpZiAoc3RhcnRUaW1lKSB7XG4gICAgICBjb25zdCBidWZmZXJTdGFydmVkID0gYnVmZmVySW5mby5sZW4gPD0gY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgICBjb25zdCB3YWl0aW5nID1cbiAgICAgICAgYnVmZmVySW5mby5sZW4gPiAwICYmIGJ1ZmZlckluZm8ubGVuIDwgMSAmJiBtZWRpYS5yZWFkeVN0YXRlIDwgMztcbiAgICAgIGNvbnN0IGdhcExlbmd0aCA9IHN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lO1xuICAgICAgaWYgKGdhcExlbmd0aCA+IDAgJiYgKGJ1ZmZlclN0YXJ2ZWQgfHwgd2FpdGluZykpIHtcbiAgICAgICAgLy8gT25seSBhbGxvdyBsYXJnZSBnYXBzIHRvIGJlIHNraXBwZWQgaWYgaXQgaXMgYSBzdGFydCBnYXAsIG9yIGFsbCBmcmFnbWVudHMgaW4gc2tpcCByYW5nZSBhcmUgcGFydGlhbFxuICAgICAgICBpZiAoZ2FwTGVuZ3RoID4gY29uZmlnLm1heEJ1ZmZlckhvbGUpIHtcbiAgICAgICAgICBjb25zdCB7IGZyYWdtZW50VHJhY2tlciB9ID0gdGhpcztcbiAgICAgICAgICBsZXQgc3RhcnRHYXAgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0RnJhZyA9IGZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcoXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoc3RhcnRGcmFnICYmIHN0YXJ0VGltZSA8IHN0YXJ0RnJhZy5lbmQpIHtcbiAgICAgICAgICAgICAgc3RhcnRHYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXN0YXJ0R2FwKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFByb3Zpc2lvbmVkID1cbiAgICAgICAgICAgICAgcGFydGlhbCB8fFxuICAgICAgICAgICAgICBmcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgICAgIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChzdGFydFByb3Zpc2lvbmVkKSB7XG4gICAgICAgICAgICAgIGxldCBtb3JlVG9Mb2FkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGxldCBwb3MgPSBzdGFydFByb3Zpc2lvbmVkLmVuZDtcbiAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3Zpc2lvbmVkID0gZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwcm92aXNpb25lZCkge1xuICAgICAgICAgICAgICAgICAgcG9zICs9IHByb3Zpc2lvbmVkLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtb3JlVG9Mb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobW9yZVRvTG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBNYXRoLm1heChcbiAgICAgICAgICBzdGFydFRpbWUgKyBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCxcbiAgICAgICAgICBjdXJyZW50VGltZSArIFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTXG4gICAgICAgICk7XG4gICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgIGBza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3RhcmdldFRpbWV9YFxuICAgICAgICApO1xuICAgICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgICBpZiAocGFydGlhbCAmJiAhcGFydGlhbC5nYXApIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBmcmFnbWVudCBsb2FkZWQgd2l0aCBidWZmZXIgaG9sZXMsIHNlZWtpbmcgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3RhcmdldFRpbWV9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRSxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgZnJhZzogcGFydGlhbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0VGltZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkgYWR2YW5jaW5nIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUgYnkgYSBzbWFsbCBhbW91bnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF90cnlOdWRnZUJ1ZmZlcigpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgaGxzLCBtZWRpYSwgbnVkZ2VSZXRyeSB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB0aGlzLm51ZGdlUmV0cnkrKztcblxuICAgIGlmIChudWRnZVJldHJ5IDwgY29uZmlnLm51ZGdlTWF4UmV0cnkpIHtcbiAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBjdXJyZW50VGltZSArIChudWRnZVJldHJ5ICsgMSkgKiBjb25maWcubnVkZ2VPZmZzZXQ7XG4gICAgICAvLyBwbGF5YmFjayBzdGFsbGVkIGluIGJ1ZmZlcmVkIGFyZWEgLi4uIGxldCdzIG51ZGdlIGN1cnJlbnRUaW1lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgYE51ZGdpbmcgJ2N1cnJlbnRUaW1lJyBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gXG4gICAgICApO1xuICAgICAgbG9nZ2VyLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgYFBsYXloZWFkIHN0aWxsIG5vdCBtb3Zpbmcgd2hpbGUgZW5vdWdoIGRhdGEgYnVmZmVyZWQgQCR7Y3VycmVudFRpbWV9IGFmdGVyICR7Y29uZmlnLm51ZGdlTWF4UmV0cnl9IG51ZGdlc2BcbiAgICAgICk7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBCYXNlU3RyZWFtQ29udHJvbGxlciwgeyBTdGF0ZSB9IGZyb20gJy4vYmFzZS1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgeyBjaGFuZ2VUeXBlU3VwcG9ydGVkIH0gZnJvbSAnLi4vaXMtc3VwcG9ydGVkJztcbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBCdWZmZXJIZWxwZXIsIEJ1ZmZlckluZm8gfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcbmltcG9ydCB7IEZyYWdtZW50U3RhdGUgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IHsgUGxheWxpc3RDb250ZXh0VHlwZSwgUGxheWxpc3RMZXZlbFR5cGUgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHsgRWxlbWVudGFyeVN0cmVhbVR5cGVzLCBGcmFnbWVudCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgVHJhbnNtdXhlckludGVyZmFjZSBmcm9tICcuLi9kZW11eC90cmFuc211eGVyLWludGVyZmFjZSc7XG5pbXBvcnQgeyBDaHVua01ldGFkYXRhIH0gZnJvbSAnLi4vdHlwZXMvdHJhbnNtdXhlcic7XG5pbXBvcnQgR2FwQ29udHJvbGxlciBmcm9tICcuL2dhcC1jb250cm9sbGVyJztcbmltcG9ydCB7IEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgdHlwZSB7IE5ldHdvcmtDb21wb25lbnRBUEkgfSBmcm9tICcuLi90eXBlcy9jb21wb25lbnQtYXBpJztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuaW1wb3J0IHR5cGUgeyBMZXZlbCB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB0eXBlIHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWRldGFpbHMnO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudFRyYWNrZXIgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IHR5cGUgS2V5TG9hZGVyIGZyb20gJy4uL2xvYWRlci9rZXktbG9hZGVyJztcbmltcG9ydCB0eXBlIHsgVHJhbnNtdXhlclJlc3VsdCB9IGZyb20gJy4uL3R5cGVzL3RyYW5zbXV4ZXInO1xuaW1wb3J0IHR5cGUgeyBUcmFja1NldCB9IGZyb20gJy4uL3R5cGVzL3RyYWNrJztcbmltcG9ydCB0eXBlIHsgU291cmNlQnVmZmVyTmFtZSB9IGZyb20gJy4uL3R5cGVzL2J1ZmZlcic7XG5pbXBvcnQgdHlwZSB7XG4gIEF1ZGlvVHJhY2tTd2l0Y2hlZERhdGEsXG4gIEF1ZGlvVHJhY2tTd2l0Y2hpbmdEYXRhLFxuICBCdWZmZXJDcmVhdGVkRGF0YSxcbiAgQnVmZmVyRU9TRGF0YSxcbiAgQnVmZmVyRmx1c2hlZERhdGEsXG4gIEVycm9yRGF0YSxcbiAgRnJhZ0J1ZmZlcmVkRGF0YSxcbiAgRnJhZ0xvYWRlZERhdGEsXG4gIEZyYWdQYXJzaW5nTWV0YWRhdGFEYXRhLFxuICBGcmFnUGFyc2luZ1VzZXJkYXRhRGF0YSxcbiAgTGV2ZWxMb2FkZWREYXRhLFxuICBMZXZlbExvYWRpbmdEYXRhLFxuICBMZXZlbHNVcGRhdGVkRGF0YSxcbiAgTWFuaWZlc3RQYXJzZWREYXRhLFxuICBNZWRpYUF0dGFjaGVkRGF0YSxcbn0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcblxuY29uc3QgVElDS19JTlRFUlZBTCA9IDEwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyZWFtQ29udHJvbGxlclxuICBleHRlbmRzIEJhc2VTdHJlYW1Db250cm9sbGVyXG4gIGltcGxlbWVudHMgTmV0d29ya0NvbXBvbmVudEFQSVxue1xuICBwcml2YXRlIGF1ZGlvQ29kZWNTd2FwOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgZ2FwQ29udHJvbGxlcjogR2FwQ29udHJvbGxlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGxldmVsOiBudW1iZXIgPSAtMTtcbiAgcHJpdmF0ZSBfZm9yY2VTdGFydExvYWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBhbHRBdWRpbzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGF1ZGlvT25seTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGZyYWdQbGF5aW5nOiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG9udnBsYXlpbmc6IEV2ZW50TGlzdGVuZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBvbnZzZWVrZWQ6IEV2ZW50TGlzdGVuZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBmcmFnTGFzdEticHM6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgY291bGRCYWNrdHJhY2s6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBiYWNrdHJhY2tGcmFnbWVudDogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBhdWRpb0NvZGVjU3dpdGNoOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgdmlkZW9CdWZmZXI6IGFueSB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGhsczogSGxzLFxuICAgIGZyYWdtZW50VHJhY2tlcjogRnJhZ21lbnRUcmFja2VyLFxuICAgIGtleUxvYWRlcjogS2V5TG9hZGVyXG4gICkge1xuICAgIHN1cGVyKFxuICAgICAgaGxzLFxuICAgICAgZnJhZ21lbnRUcmFja2VyLFxuICAgICAga2V5TG9hZGVyLFxuICAgICAgJ1tzdHJlYW0tY29udHJvbGxlcl0nLFxuICAgICAgUGxheWxpc3RMZXZlbFR5cGUuTUFJTlxuICAgICk7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKFxuICAgICAgRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCxcbiAgICAgIHRoaXMub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoXG4gICAgICBFdmVudHMuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELFxuICAgICAgdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGFydExvYWQoc3RhcnRQb3NpdGlvbjogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubGV2ZWxzKSB7XG4gICAgICBjb25zdCB7IGxhc3RDdXJyZW50VGltZSwgaGxzIH0gPSB0aGlzO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGxvYWQgbGV2ZWxcbiAgICAgICAgbGV0IHN0YXJ0TGV2ZWwgPSBobHMuc3RhcnRMZXZlbDtcbiAgICAgICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgaWYgKGhscy5jb25maWcudGVzdEJhbmR3aWR0aCAmJiB0aGlzLmxldmVscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSAwO1xuICAgICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSBobHMubmV4dEF1dG9MZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IG5ldyBsZXZlbCB0byBwbGF5bGlzdCBsb2FkZXIgOiB0aGlzIHdpbGwgdHJpZ2dlciBzdGFydCBsZXZlbCBsb2FkXG4gICAgICAgIC8vIGhscy5uZXh0TG9hZExldmVsIHJlbWFpbnMgdW50aWwgaXQgaXMgc2V0IHRvIGEgbmV3IHZhbHVlIG9yIHVudGlsIGEgbmV3IGZyYWcgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZFxuICAgICAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBzdGFydExldmVsO1xuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBpZiBzdGFydFBvc2l0aW9uIHVuZGVmaW5lZCBidXQgbGFzdEN1cnJlbnRUaW1lIHNldCwgc2V0IHN0YXJ0UG9zaXRpb24gdG8gbGFzdCBjdXJyZW50VGltZVxuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgYE92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQCR7bGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoXG4gICAgICAgICAgICAzXG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID1cbiAgICAgICAgICBzdGFydFBvc2l0aW9uO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZvcmNlU3RhcnRMb2FkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuICAgIHN1cGVyLnN0b3BMb2FkKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZG9UaWNrKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0xFVkVMOiB7XG4gICAgICAgIGNvbnN0IHsgbGV2ZWxzLCBsZXZlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IGxldmVscz8uW2xldmVsXT8uZGV0YWlscztcbiAgICAgICAgaWYgKGRldGFpbHMgJiYgKCFkZXRhaWxzLmxpdmUgfHwgdGhpcy5sZXZlbExhc3RMb2FkZWQgPT09IHRoaXMubGV2ZWwpKSB7XG4gICAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgY29uc3QgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgICBpZiAoIXJldHJ5RGF0ZSB8fCBub3cgPj0gcmV0cnlEYXRlIHx8IHRoaXMubWVkaWE/LnNlZWtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQodGhpcy5sZXZlbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgIHRoaXMuZG9UaWNrSWRsZSgpO1xuICAgIH1cbiAgICB0aGlzLm9uVGlja0VuZCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uVGlja0VuZCgpIHtcbiAgICBzdXBlci5vblRpY2tFbmQoKTtcbiAgICB0aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgdGhpcy5jaGVja0ZyYWdtZW50Q2hhbmdlZCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBkb1RpY2tJZGxlKCkge1xuICAgIGNvbnN0IHsgaGxzLCBsZXZlbExhc3RMb2FkZWQsIGxldmVscywgbWVkaWEgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjb25maWcsIG5leHRMb2FkTGV2ZWw6IGxldmVsIH0gPSBobHM7XG5cbiAgICAvLyBpZiBzdGFydCBsZXZlbCBub3QgcGFyc2VkIHlldCBPUlxuICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkQgc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBub3QgZW5hYmxlZFxuICAgIC8vIGV4aXQgbG9vcCwgYXMgd2UgZWl0aGVyIG5lZWQgbW9yZSBpbmZvIChsZXZlbCBub3QgcGFyc2VkKSBvciB3ZSBuZWVkIG1lZGlhIHRvIGJlIGF0dGFjaGVkIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgaWYgKFxuICAgICAgbGV2ZWxMYXN0TG9hZGVkID09PSBudWxsIHx8XG4gICAgICAoIW1lZGlhICYmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSlcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgXCJtYWluXCIgbGV2ZWwgaXMgYXVkaW8tb25seSBidXQgd2UgYXJlIGxvYWRpbmcgYW4gYWx0ZXJuYXRlIHRyYWNrIGluIHRoZSBzYW1lIGdyb3VwLCBkbyBub3QgbG9hZCBhbnl0aGluZ1xuICAgIGlmICh0aGlzLmFsdEF1ZGlvICYmIHRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFsZXZlbHM/LltsZXZlbF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsZXZlbEluZm8gPSBsZXZlbHNbbGV2ZWxdO1xuXG4gICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XG5cbiAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFzdERldGFpbHMgPSB0aGlzLmdldExldmVsRGV0YWlscygpO1xuICAgIGlmIChsYXN0RGV0YWlscyAmJiB0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsYXN0RGV0YWlscykpIHtcbiAgICAgIGNvbnN0IGRhdGE6IEJ1ZmZlckVPU0RhdGEgPSB7fTtcbiAgICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgIGRhdGEudHlwZSA9ICd2aWRlbyc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9FT1MsIGRhdGEpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXG4gICAgaWYgKGhscy5sb2FkTGV2ZWwgIT09IGxldmVsICYmIGhscy5tYW51YWxMZXZlbCA9PT0gLTEpIHtcbiAgICAgIHRoaXMubG9nKGBBZGFwdGluZyB0byBsZXZlbCAke2xldmVsfSBmcm9tIGxldmVsICR7dGhpcy5sZXZlbH1gKTtcbiAgICB9XG4gICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG5cbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICAvLyBpZiBsZXZlbCBpbmZvIG5vdCByZXRyaWV2ZWQgeWV0LCBzd2l0Y2ggc3RhdGUgYW5kIHdhaXQgZm9yIGxldmVsIHJldHJpZXZhbFxuICAgIC8vIGlmIGxpdmUgcGxheWxpc3QsIGVuc3VyZSB0aGF0IG5ldyBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgdG8gYXZvaWQgbG9hZGluZy90cnkgdG8gbG9hZFxuICAgIC8vIGEgdXNlbGVzcyBhbmQgb3V0ZGF0ZWQgZnJhZ21lbnQgKHRoYXQgbWlnaHQgZXZlbiBpbnRyb2R1Y2UgbG9hZCBlcnJvciBpZiBpdCBpcyBhbHJlYWR5IG91dCBvZiB0aGUgbGl2ZSBwbGF5bGlzdClcbiAgICBpZiAoXG4gICAgICAhbGV2ZWxEZXRhaWxzIHx8XG4gICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0xFVkVMIHx8XG4gICAgICAobGV2ZWxEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsKVxuICAgICkge1xuICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfTEVWRUw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG5cbiAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXG4gICAgY29uc3QgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobGV2ZWxJbmZvLm1heEJpdHJhdGUpO1xuXG4gICAgLy8gU3RheSBpZGxlIGlmIHdlIGFyZSBzdGlsbCB3aXRoIGJ1ZmZlciBtYXJnaW5zXG4gICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ICYmXG4gICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50LnN0YXJ0ID4gYnVmZmVySW5mby5lbmRcbiAgICApIHtcbiAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRCdWZmZXJUaW1lID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudFxuICAgICAgPyB0aGlzLmJhY2t0cmFja0ZyYWdtZW50LnN0YXJ0XG4gICAgICA6IGJ1ZmZlckluZm8uZW5kO1xuICAgIGxldCBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGFyZ2V0QnVmZmVyVGltZSwgbGV2ZWxEZXRhaWxzKTtcbiAgICAvLyBBdm9pZCBiYWNrdHJhY2tpbmcgYnkgbG9hZGluZyBhbiBlYXJsaWVyIHNlZ21lbnQgaW4gc3RyZWFtcyB3aXRoIHNlZ21lbnRzIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggYSBrZXkgZnJhbWUgKGZsYWdnZWQgYnkgYGNvdWxkQmFja3RyYWNrYClcbiAgICBpZiAoXG4gICAgICB0aGlzLmNvdWxkQmFja3RyYWNrICYmXG4gICAgICAhdGhpcy5mcmFnUHJldmlvdXMgJiZcbiAgICAgIGZyYWcgJiZcbiAgICAgIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcgJiZcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpICE9PSBGcmFnbWVudFN0YXRlLk9LXG4gICAgKSB7XG4gICAgICBjb25zdCBiYWNrdHJhY2tTbiA9ICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID8/IGZyYWcpLnNuIGFzIG51bWJlcjtcbiAgICAgIGNvbnN0IGZyYWdJZHggPSBiYWNrdHJhY2tTbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xuICAgICAgY29uc3QgYmFja3RyYWNrRnJhZyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbZnJhZ0lkeCAtIDFdO1xuICAgICAgaWYgKGJhY2t0cmFja0ZyYWcgJiYgZnJhZy5jYyA9PT0gYmFja3RyYWNrRnJhZy5jYykge1xuICAgICAgICBmcmFnID0gYmFja3RyYWNrRnJhZztcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoYmFja3RyYWNrRnJhZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50ICYmIGJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gQXZvaWQgbG9vcCBsb2FkaW5nIGJ5IHVzaW5nIG5leHRMb2FkUG9zaXRpb24gc2V0IGZvciBiYWNrdHJhY2tpbmcgYW5kIHNraXBwaW5nIGNvbnNlY3V0aXZlIEdBUCB0YWdzXG4gICAgaWYgKGZyYWcgJiYgdGhpcy5pc0xvb3BMb2FkaW5nKGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpKSB7XG4gICAgICBjb25zdCBnYXBTdGFydCA9IGZyYWcuZ2FwO1xuICAgICAgaWYgKCFnYXBTdGFydCkge1xuICAgICAgICAvLyBDbGVhbnVwIHRoZSBmcmFnbWVudCB0cmFja2VyIGJlZm9yZSB0cnlpbmcgdG8gZmluZCB0aGUgbmV4dCB1bmJ1ZmZlcmVkIGZyYWdtZW50XG4gICAgICAgIGNvbnN0IHR5cGUgPVxuICAgICAgICAgIHRoaXMuYXVkaW9Pbmx5ICYmICF0aGlzLmFsdEF1ZGlvXG4gICAgICAgICAgICA/IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1xuICAgICAgICAgICAgOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU87XG4gICAgICAgIGNvbnN0IG1lZGlhQnVmZmVyID1cbiAgICAgICAgICAodHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXG4gICAgICAgICAgICA/IHRoaXMudmlkZW9CdWZmZXJcbiAgICAgICAgICAgIDogdGhpcy5tZWRpYUJ1ZmZlcikgfHwgdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhQnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWFCdWZmZXIsIHR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnRMb29wTG9hZGluZyhcbiAgICAgICAgZnJhZyxcbiAgICAgICAgbGV2ZWxEZXRhaWxzLFxuICAgICAgICBidWZmZXJJbmZvLFxuICAgICAgICBQbGF5bGlzdExldmVsVHlwZS5NQUlOLFxuICAgICAgICBtYXhCdWZMZW5cbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZnJhZy5pbml0U2VnbWVudCAmJiAhZnJhZy5pbml0U2VnbWVudC5kYXRhICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICBmcmFnID0gZnJhZy5pbml0U2VnbWVudDtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbEluZm8sIHRhcmdldEJ1ZmZlclRpbWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGxvYWRGcmFnbWVudChcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBsZXZlbDogTGV2ZWwsXG4gICAgdGFyZ2V0QnVmZmVyVGltZTogbnVtYmVyXG4gICkge1xuICAgIC8vIENoZWNrIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWRcbiAgICBjb25zdCBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICBpZiAoXG4gICAgICBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCB8fFxuICAgICAgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUxcbiAgICApIHtcbiAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCBsZXZlbCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgYEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSBpcyBiZWluZyBkb3dubG9hZGVkIHRvIHRlc3QgYml0cmF0ZSBhbmQgd2lsbCBub3QgYmUgYnVmZmVyZWRgXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2xvYWRCaXRyYXRlVGVzdEZyYWcoZnJhZywgbGV2ZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICBzdXBlci5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgUGxheWxpc3RMZXZlbFR5cGUuTUFJTlxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhmcmFnOiBGcmFnbWVudCB8IG51bGwpIHtcbiAgICBpZiAoZnJhZykge1xuICAgICAgLy8gdHJ5IHRvIGdldCByYW5nZSBvZiBuZXh0IGZyYWdtZW50ICg1MDBtcyBhZnRlciB0aGlzIHJhbmdlKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGZyYWcuZW5kICsgMC41KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKlxuICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggOlxuICAgICAtIHBhdXNlIHBsYXliYWNrIGlmIHBsYXlpbmdcbiAgICAgLSBjYW5jZWwgYW55IHBlbmRpbmcgbG9hZCByZXF1ZXN0XG4gICAgIC0gYW5kIHRyaWdnZXIgYSBidWZmZXIgZmx1c2hcbiAgKi9cbiAgcHVibGljIGltbWVkaWF0ZUxldmVsU3dpdGNoKCkge1xuICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpO1xuICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gIH1cblxuICAvKipcbiAgICogdHJ5IHRvIHN3aXRjaCBBU0FQIHdpdGhvdXQgYnJlYWtpbmcgdmlkZW8gcGxheWJhY2s6XG4gICAqIGluIG9yZGVyIHRvIGVuc3VyZSBzbW9vdGggYnV0IHF1aWNrIGxldmVsIHN3aXRjaGluZyxcbiAgICogd2UgbmVlZCB0byBmaW5kIHRoZSBuZXh0IGZsdXNoYWJsZSBidWZmZXIgcmFuZ2VcbiAgICogd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcbiAgICovXG4gIHB1YmxpYyBuZXh0TGV2ZWxTd2l0Y2goKSB7XG4gICAgY29uc3QgeyBsZXZlbHMsIG1lZGlhIH0gPSB0aGlzO1xuICAgIC8vIGVuc3VyZSB0aGF0IG1lZGlhIGlzIGRlZmluZWQgYW5kIHRoYXQgbWV0YWRhdGEgYXJlIGF2YWlsYWJsZSAodG8gcmV0cmlldmUgY3VycmVudFRpbWUpXG4gICAgaWYgKG1lZGlhPy5yZWFkeVN0YXRlKSB7XG4gICAgICBsZXQgZmV0Y2hkZWxheTtcbiAgICAgIGNvbnN0IGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQgJiYgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0ID4gMSkge1xuICAgICAgICAvLyBmbHVzaCBidWZmZXIgcHJlY2VkaW5nIGN1cnJlbnQgZnJhZ21lbnQgKGZsdXNoIHVudGlsIGN1cnJlbnQgZnJhZ21lbnQgc3RhcnQgb2Zmc2V0KVxuICAgICAgICAvLyBtaW51cyAxcyB0byBhdm9pZCB2aWRlbyBmcmVlemluZywgdGhhdCBjb3VsZCBoYXBwZW4gaWYgd2UgZmx1c2gga2V5ZnJhbWUgb2YgY3VycmVudCB2aWRlbyAuLi5cbiAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0IC0gMSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmdldExldmVsRGV0YWlscygpO1xuICAgICAgaWYgKGxldmVsRGV0YWlscz8ubGl2ZSkge1xuICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICAvLyBEbyBub3QgZmx1c2ggaW4gbGl2ZSBzdHJlYW0gd2l0aCBsb3cgYnVmZmVyXG4gICAgICAgIGlmICghYnVmZmVySW5mbyB8fCBidWZmZXJJbmZvLmxlbiA8IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbWVkaWEucGF1c2VkICYmIGxldmVscykge1xuICAgICAgICAvLyBhZGQgYSBzYWZldHkgZGVsYXkgb2YgMXNcbiAgICAgICAgY29uc3QgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsO1xuICAgICAgICBjb25zdCBuZXh0TGV2ZWwgPSBsZXZlbHNbbmV4dExldmVsSWRdO1xuICAgICAgICBjb25zdCBmcmFnTGFzdEticHMgPSB0aGlzLmZyYWdMYXN0S2JwcztcbiAgICAgICAgaWYgKGZyYWdMYXN0S2JwcyAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9XG4gICAgICAgICAgICAodGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5tYXhCaXRyYXRlKSAvXG4gICAgICAgICAgICAgICgxMDAwICogZnJhZ0xhc3RLYnBzKSArXG4gICAgICAgICAgICAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMubG9nKCdmZXRjaGRlbGF5OicrZmV0Y2hkZWxheSk7XG4gICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkRnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XG4gICAgICBpZiAoYnVmZmVyZWRGcmFnKSB7XG4gICAgICAgIC8vIHdlIGNhbiBmbHVzaCBidWZmZXIgcmFuZ2UgZm9sbG93aW5nIHRoaXMgb25lIHdpdGhvdXQgc3RhbGxpbmcgcGxheWJhY2tcbiAgICAgICAgY29uc3QgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGJ1ZmZlcmVkRnJhZyk7XG4gICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xuICAgICAgICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpO1xuICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoIHBvc2l0aW9uIGlzIGluIG5leHQgYnVmZmVyZWQgZnJhZy4gTGVhdmUgc29tZSBwYWRkaW5nIGZvciBub24taW5kZXBlbmRlbnQgc2VnbWVudHMgYW5kIHNtb290aGVyIHBsYXliYWNrLlxuICAgICAgICAgIGNvbnN0IG1heFN0YXJ0ID0gbmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUU1xuICAgICAgICAgICAgPyBuZXh0QnVmZmVyZWRGcmFnLm1heFN0YXJ0UFRTXG4gICAgICAgICAgICA6IG5leHRCdWZmZXJlZEZyYWcuc3RhcnQ7XG4gICAgICAgICAgY29uc3QgZnJhZ0R1cmF0aW9uID0gbmV4dEJ1ZmZlcmVkRnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBzdGFydFB0cyA9IE1hdGgubWF4KFxuICAgICAgICAgICAgYnVmZmVyZWRGcmFnLmVuZCxcbiAgICAgICAgICAgIG1heFN0YXJ0ICtcbiAgICAgICAgICAgICAgTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICBmcmFnRHVyYXRpb24gLSB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLFxuICAgICAgICAgICAgICAgICAgZnJhZ0R1cmF0aW9uICogMC41XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmcmFnRHVyYXRpb24gKiAwLjc1XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKHN0YXJ0UHRzLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhYm9ydEN1cnJlbnRGcmFnKCkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWdDdXJyZW50KTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFN0YXRlLktFWV9MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQ6IG51bWJlciwgZW5kT2Zmc2V0OiBudW1iZXIpIHtcbiAgICBzdXBlci5mbHVzaE1haW5CdWZmZXIoXG4gICAgICBzdGFydE9mZnNldCxcbiAgICAgIGVuZE9mZnNldCxcbiAgICAgIHRoaXMuYWx0QXVkaW8gPyAndmlkZW8nIDogbnVsbFxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NZWRpYUF0dGFjaGVkKFxuICAgIGV2ZW50OiBFdmVudHMuTUVESUFfQVRUQUNIRUQsXG4gICAgZGF0YTogTWVkaWFBdHRhY2hlZERhdGFcbiAgKSB7XG4gICAgc3VwZXIub25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKTtcbiAgICBjb25zdCBtZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5vbnZwbGF5aW5nID0gdGhpcy5vbk1lZGlhUGxheWluZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252c2Vla2VkID0gdGhpcy5vbk1lZGlhU2Vla2VkLmJpbmQodGhpcyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub252cGxheWluZyBhcyBFdmVudExpc3RlbmVyKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCBhcyBFdmVudExpc3RlbmVyKTtcbiAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBuZXcgR2FwQ29udHJvbGxlcihcbiAgICAgIHRoaXMuY29uZmlnLFxuICAgICAgbWVkaWEsXG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlcixcbiAgICAgIHRoaXMuaGxzXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGNvbnN0IHsgbWVkaWEgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhICYmIHRoaXMub252cGxheWluZyAmJiB0aGlzLm9udnNlZWtlZCkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub252cGxheWluZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgICB0aGlzLm9udnBsYXlpbmcgPSB0aGlzLm9udnNlZWtlZCA9IG51bGw7XG4gICAgICB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5mcmFnUGxheWluZyA9IG51bGw7XG4gICAgaWYgKHRoaXMuZ2FwQ29udHJvbGxlcikge1xuICAgICAgdGhpcy5nYXBDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgfVxuXG4gIHByaXZhdGUgb25NZWRpYVBsYXlpbmcoKSB7XG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHX0NIQU5HRUQgdHJpZ2dlcmluZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1lZGlhU2Vla2VkKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiBudWxsO1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY3VycmVudFRpbWUpKSB7XG4gICAgICB0aGlzLmxvZyhgTWVkaWEgc2Vla2VkIHRvICR7KGN1cnJlbnRUaW1lIGFzIG51bWJlcikudG9GaXhlZCgzKX1gKTtcbiAgICB9XG5cbiAgICAvLyBJZiBzZWVrZWQgd2FzIGlzc3VlZCBiZWZvcmUgYnVmZmVyIHdhcyBhcHBlbmRlZCBkbyBub3QgdGljayBpbW1lZGlhdGVseVxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwgfHwgYnVmZmVySW5mby5sZW4gPT09IDApIHtcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYE1haW4gZm9yd2FyZCBidWZmZXIgbGVuZ3RoIG9uIFwic2Vla2VkXCIgZXZlbnQgJHtcbiAgICAgICAgICBidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAnZW1wdHknXG4gICAgICAgIH0pYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdfQ0hBTkdFRCB0cmlnZ2VyaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBwcml2YXRlIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXG4gICAgdGhpcy5sb2coJ1RyaWdnZXIgQlVGRkVSX1JFU0VUJyk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX1JFU0VULCB1bmRlZmluZWQpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5sZXZlbHMgPSB0aGlzLmZyYWdQbGF5aW5nID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgdGhpcy5hbHRBdWRpbyA9IHRoaXMuYXVkaW9Pbmx5ID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIG9uTWFuaWZlc3RQYXJzZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsXG4gICAgZGF0YTogTWFuaWZlc3RQYXJzZWREYXRhXG4gICkge1xuICAgIGxldCBhYWMgPSBmYWxzZTtcbiAgICBsZXQgaGVhYWMgPSBmYWxzZTtcbiAgICBsZXQgY29kZWM7XG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaCgobGV2ZWwpID0+IHtcbiAgICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgICBjb2RlYyA9IGxldmVsLmF1ZGlvQ29kZWM7XG4gICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSkge1xuICAgICAgICAgIGFhYyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgaGVhYWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gYWFjICYmIGhlYWFjICYmICFjaGFuZ2VUeXBlU3VwcG9ydGVkKCk7XG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgICdCb3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIG9uTGV2ZWxMb2FkaW5nKGV2ZW50OiBFdmVudHMuTEVWRUxfTE9BRElORywgZGF0YTogTGV2ZWxMb2FkaW5nRGF0YSkge1xuICAgIGNvbnN0IHsgbGV2ZWxzIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzIHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLklETEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbZGF0YS5sZXZlbF07XG4gICAgaWYgKFxuICAgICAgIWxldmVsLmRldGFpbHMgfHxcbiAgICAgIChsZXZlbC5kZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGRhdGEubGV2ZWwpIHx8XG4gICAgICB0aGlzLndhaXRGb3JDZG5UdW5lSW4obGV2ZWwuZGV0YWlscylcbiAgICApIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25MZXZlbExvYWRlZChldmVudDogRXZlbnRzLkxFVkVMX0xPQURFRCwgZGF0YTogTGV2ZWxMb2FkZWREYXRhKSB7XG4gICAgY29uc3QgeyBsZXZlbHMgfSA9IHRoaXM7XG4gICAgY29uc3QgbmV3TGV2ZWxJZCA9IGRhdGEubGV2ZWw7XG4gICAgY29uc3QgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICBjb25zdCBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbjtcblxuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oYExldmVscyB3ZXJlIHJlc2V0IHdoaWxlIGxvYWRpbmcgbGV2ZWwgJHtuZXdMZXZlbElkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZyhcbiAgICAgIGBMZXZlbCAke25ld0xldmVsSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dJHtcbiAgICAgICAgbmV3RGV0YWlscy5sYXN0UGFydFNuXG4gICAgICAgICAgPyBgW3BhcnQtJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U259LSR7bmV3RGV0YWlscy5sYXN0UGFydEluZGV4fV1gXG4gICAgICAgICAgOiAnJ1xuICAgICAgfSwgY2MgWyR7bmV3RGV0YWlscy5zdGFydENDfSwgJHtuZXdEZXRhaWxzLmVuZENDfV0gZHVyYXRpb246JHtkdXJhdGlvbn1gXG4gICAgKTtcblxuICAgIGNvbnN0IGN1ckxldmVsID0gbGV2ZWxzW25ld0xldmVsSWRdO1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoXG4gICAgICBmcmFnQ3VycmVudCAmJlxuICAgICAgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyB8fFxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSlcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgKGZyYWdDdXJyZW50LmxldmVsICE9PSBkYXRhLmxldmVsIHx8XG4gICAgICAgICAgZnJhZ0N1cnJlbnQudXJsSWQgIT09IGN1ckxldmVsLnVybElkKSAmJlxuICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXJcbiAgICAgICkge1xuICAgICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc2xpZGluZyA9IDA7XG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSB8fCBjdXJMZXZlbC5kZXRhaWxzPy5saXZlKSB7XG4gICAgICBpZiAoIW5ld0RldGFpbHMuZnJhZ21lbnRzWzBdKSB7XG4gICAgICAgIG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2xpZGluZyA9IHRoaXMuYWxpZ25QbGF5bGlzdHMobmV3RGV0YWlscywgY3VyTGV2ZWwuZGV0YWlscyk7XG4gICAgfVxuICAgIC8vIG92ZXJyaWRlIGxldmVsIGluZm9cbiAgICBjdXJMZXZlbC5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IG5ld0xldmVsSWQ7XG5cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTF9VUERBVEVELCB7XG4gICAgICBkZXRhaWxzOiBuZXdEZXRhaWxzLFxuICAgICAgbGV2ZWw6IG5ld0xldmVsSWQsXG4gICAgfSk7XG5cbiAgICAvLyBvbmx5IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciBsZXZlbCB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0xFVkVMKSB7XG4gICAgICBpZiAodGhpcy53YWl0Rm9yQ2RuVHVuZUluKG5ld0RldGFpbHMpKSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIExvdy1MYXRlbmN5IENETiBUdW5lLWluXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbihuZXdEZXRhaWxzLCBzbGlkaW5nKTtcbiAgICB9IGVsc2UgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgdGhpcy5zeW5jaHJvbml6ZVRvTGl2ZUVkZ2UobmV3RGV0YWlscyk7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhOiBGcmFnTG9hZGVkRGF0YSkge1xuICAgIGNvbnN0IHsgZnJhZywgcGFydCwgcGF5bG9hZCB9ID0gZGF0YTtcbiAgICBjb25zdCB7IGxldmVscyB9ID0gdGhpcztcbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKFxuICAgICAgICBgTGV2ZWxzIHdlcmUgcmVzZXQgd2hpbGUgZnJhZ21lbnQgbG9hZCB3YXMgaW4gcHJvZ3Jlc3MuIEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSB3aWxsIG5vdCBiZSBidWZmZXJlZGBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGxldmVsc1tmcmFnLmxldmVsXTtcbiAgICBjb25zdCBkZXRhaWxzID0gY3VycmVudExldmVsLmRldGFpbHMgYXMgTGV2ZWxEZXRhaWxzO1xuICAgIGlmICghZGV0YWlscykge1xuICAgICAgdGhpcy53YXJuKFxuICAgICAgICBgRHJvcHBpbmcgZnJhZ21lbnQgJHtmcmFnLnNufSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IGFmdGVyIGxldmVsIGRldGFpbHMgd2VyZSByZXNldGBcbiAgICAgICk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuXG4gICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgY29uc3QgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgIGNvbnN0IGluaXRTZWdtZW50RGF0YSA9IGZyYWcuaW5pdFNlZ21lbnQ/LmRhdGE7XG4gICAgY29uc3QgYXVkaW9Db2RlYyA9IHRoaXMuX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKTtcblxuICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAvLyB0aGlzLmxvZyhgVHJhbnNtdXhpbmcgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2ZyYWcubGV2ZWx9LCBjYyAke2ZyYWcuY2N9YCk7XG4gICAgY29uc3QgdHJhbnNtdXhlciA9ICh0aGlzLnRyYW5zbXV4ZXIgPVxuICAgICAgdGhpcy50cmFuc211eGVyIHx8XG4gICAgICBuZXcgVHJhbnNtdXhlckludGVyZmFjZShcbiAgICAgICAgdGhpcy5obHMsXG4gICAgICAgIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sXG4gICAgICAgIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSxcbiAgICAgICAgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcylcbiAgICAgICkpO1xuICAgIGNvbnN0IHBhcnRJbmRleCA9IHBhcnQgPyBwYXJ0LmluZGV4IDogLTE7XG4gICAgY29uc3QgcGFydGlhbCA9IHBhcnRJbmRleCAhPT0gLTE7XG4gICAgY29uc3QgY2h1bmtNZXRhID0gbmV3IENodW5rTWV0YWRhdGEoXG4gICAgICBmcmFnLmxldmVsLFxuICAgICAgZnJhZy5zbiBhcyBudW1iZXIsXG4gICAgICBmcmFnLnN0YXRzLmNodW5rQ291bnQsXG4gICAgICBwYXlsb2FkLmJ5dGVMZW5ndGgsXG4gICAgICBwYXJ0SW5kZXgsXG4gICAgICBwYXJ0aWFsXG4gICAgKTtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuXG4gICAgdHJhbnNtdXhlci5wdXNoKFxuICAgICAgcGF5bG9hZCxcbiAgICAgIGluaXRTZWdtZW50RGF0YSxcbiAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICB2aWRlb0NvZGVjLFxuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBkZXRhaWxzLnRvdGFsZHVyYXRpb24sXG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICBjaHVua01ldGEsXG4gICAgICBpbml0UFRTXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgb25BdWRpb1RyYWNrU3dpdGNoaW5nKFxuICAgIGV2ZW50OiBFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLFxuICAgIGRhdGE6IEF1ZGlvVHJhY2tTd2l0Y2hpbmdEYXRhXG4gICkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBjb25zdCBmcm9tQWx0QXVkaW8gPSB0aGlzLmFsdEF1ZGlvO1xuICAgIGNvbnN0IGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICAvLyBpZiB3ZSBzd2l0Y2ggb24gbWFpbiBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIG1lZGlhLmJ1ZmZlcmVkXG4gICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgd2Ugc3dpdGNoIHRvIGFsdCBhdWRpbzogYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIgaXMgaGFuZGxpbmcgaXQuXG4gICAgLy8gd2Ugd2lsbCBqdXN0IGhhdmUgdG8gY2hhbmdlIGJ1ZmZlciBzY2hlZHVsaW5nIG9uIGF1ZGlvVHJhY2tTd2l0Y2hlZFxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhQnVmZmVyICE9PSB0aGlzLm1lZGlhKSB7XG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICdTd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZydcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXG4gICAgICAgIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbyB0cmFjaywgY2FuY2VsIG1haW4gZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnQ3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVzdHJveSB0cmFuc211eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxuICAgICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICAgIC8vIFJlc2V0IGF1ZGlvIHRyYW5zbXV4ZXIgc28gd2hlbiBzd2l0Y2hpbmcgYmFjayB0byBtYWluIGF1ZGlvIHdlJ3JlIG5vdCBzdGlsbCBhcHBlbmRpbmcgd2hlcmUgd2UgbGVmdCBvZmZcbiAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgLy8gSWYgc3dpdGNoaW5nIGZyb20gYWx0IHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxuICAgICAgaWYgKGZyb21BbHRBdWRpbykge1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB7XG4gICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgICAgfVxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCBkYXRhKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uQXVkaW9UcmFja1N3aXRjaGVkKFxuICAgIGV2ZW50OiBFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsXG4gICAgZGF0YTogQXVkaW9UcmFja1N3aXRjaGVkRGF0YVxuICApIHtcbiAgICBjb25zdCB0cmFja0lkID0gZGF0YS5pZDtcbiAgICBjb25zdCBhbHRBdWRpbyA9ICEhdGhpcy5obHMuYXVkaW9UcmFja3NbdHJhY2tJZF0udXJsO1xuICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgY29uc3QgdmlkZW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyO1xuICAgICAgLy8gaWYgd2Ugc3dpdGNoZWQgb24gYWx0ZXJuYXRlIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggdmlkZW8gc291cmNlYnVmZmVyIGJ1ZmZlcmVkXG4gICAgICBpZiAodmlkZW9CdWZmZXIgJiYgdGhpcy5tZWRpYUJ1ZmZlciAhPT0gdmlkZW9CdWZmZXIpIHtcbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgJ1N3aXRjaGluZyBvbiBhbHRlcm5hdGUgYXVkaW8sIHVzZSB2aWRlby5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB2aWRlb0J1ZmZlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hbHRBdWRpbyA9IGFsdEF1ZGlvO1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkJ1ZmZlckNyZWF0ZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCxcbiAgICBkYXRhOiBCdWZmZXJDcmVhdGVkRGF0YVxuICApIHtcbiAgICBjb25zdCB0cmFja3MgPSBkYXRhLnRyYWNrcztcbiAgICBsZXQgbWVkaWFUcmFjaztcbiAgICBsZXQgbmFtZTtcbiAgICBsZXQgYWx0ZXJuYXRlID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB0eXBlIGluIHRyYWNrcykge1xuICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHlwZV07XG4gICAgICBpZiAodHJhY2suaWQgPT09ICdtYWluJykge1xuICAgICAgICBuYW1lID0gdHlwZTtcbiAgICAgICAgbWVkaWFUcmFjayA9IHRyYWNrO1xuICAgICAgICAvLyBrZWVwIHZpZGVvIHNvdXJjZSBidWZmZXIgcmVmZXJlbmNlXG4gICAgICAgIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHRyYWNrc1t0eXBlXTtcbiAgICAgICAgICBpZiAodmlkZW9UcmFjaykge1xuICAgICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHZpZGVvVHJhY2suYnVmZmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsdGVybmF0ZSAmJiBtZWRpYVRyYWNrKSB7XG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgYEFsdGVybmF0ZSB0cmFjayBmb3VuZCwgdXNlICR7bmFtZX0uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYFxuICAgICAgKTtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkZyYWdCdWZmZXJlZChldmVudDogRXZlbnRzLkZSQUdfQlVGRkVSRUQsIGRhdGE6IEZyYWdCdWZmZXJlZERhdGEpIHtcbiAgICBjb25zdCB7IGZyYWcsIHBhcnQgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgLy8gSWYgYSBsZXZlbCBzd2l0Y2ggd2FzIHJlcXVlc3RlZCB3aGlsZSBhIGZyYWdtZW50IHdhcyBidWZmZXJpbmcsIGl0IHdpbGwgZW1pdCB0aGUgRlJBR19CVUZGRVJFRCBldmVudCB1cG9uIGNvbXBsZXRpb25cbiAgICAgIC8vIEF2b2lkIHNldHRpbmcgc3RhdGUgYmFjayB0byBJRExFLCBzaW5jZSB0aGF0IHdpbGwgaW50ZXJmZXJlIHdpdGggYSBsZXZlbCBzd2l0Y2hcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYEZyYWdtZW50ICR7ZnJhZy5zbn0ke3BhcnQgPyAnIHA6ICcgKyBwYXJ0LmluZGV4IDogJyd9IG9mIGxldmVsICR7XG4gICAgICAgICAgZnJhZy5sZXZlbFxuICAgICAgICB9IGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogJHt0aGlzLnN0YXRlfWBcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICB0aGlzLmZyYWdMYXN0S2JwcyA9IE1hdGgucm91bmQoXG4gICAgICAoOCAqIHN0YXRzLnRvdGFsKSAvIChzdGF0cy5idWZmZXJpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5maXJzdClcbiAgICApO1xuICAgIGlmIChmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgfVxuICAgIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCk7XG4gIH1cblxuICBwcml2YXRlIG9uRXJyb3IoZXZlbnQ6IEV2ZW50cy5FUlJPUiwgZGF0YTogRXJyb3JEYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfR0FQOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIHRoaXMub25GcmFnbWVudE9yS2V5TG9hZEVycm9yKFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SOlxuICAgICAgICAvLyBpbiBjYXNlIG9mIG5vbiBmYXRhbCBlcnJvciB3aGlsZSBsb2FkaW5nIGxldmVsLCBpZiBsZXZlbCBjb250cm9sbGVyIGlzIG5vdCByZXRyeWluZyB0byBsb2FkIGxldmVsLCBzd2l0Y2ggYmFjayB0byBJRExFXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhZGF0YS5sZXZlbFJldHJ5ICYmXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCAmJlxuICAgICAgICAgIGRhdGEuY29udGV4dD8udHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICBpZiAoIWRhdGEucGFyZW50IHx8IGRhdGEucGFyZW50ICE9PSAnbWFpbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OOlxuICAgICAgICB0aGlzLnJlY292ZXJXb3JrZXJFcnJvcihkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBDaGVja3MgdGhlIGhlYWx0aCBvZiB0aGUgYnVmZmVyIGFuZCBhdHRlbXB0cyB0byByZXNvbHZlIHBsYXliYWNrIHN0YWxscy5cbiAgcHJpdmF0ZSBjaGVja0J1ZmZlcigpIHtcbiAgICBjb25zdCB7IG1lZGlhLCBnYXBDb250cm9sbGVyIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgIWdhcENvbnRyb2xsZXIgfHwgIW1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBtZWRpYSBvciBpZiB0aGUgbWVkaWEgaGFzbid0IGJ1ZmZlcmVkIGFueXRoaW5nIHlldCAocmVhZHlTdGF0ZSAwKVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhIHx8ICFCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpLmxlbmd0aCkge1xuICAgICAgLy8gUmVzb2x2ZSBnYXBzIHVzaW5nIHRoZSBtYWluIGJ1ZmZlciwgd2hvc2UgcmFuZ2VzIGFyZSB0aGUgaW50ZXJzZWN0aW9ucyBvZiB0aGUgQS9WIHNvdXJjZWJ1ZmZlcnNcbiAgICAgIGNvbnN0IGFjdGl2ZUZyYWcgPSB0aGlzLnN0YXRlICE9PSBTdGF0ZS5JRExFID8gdGhpcy5mcmFnQ3VycmVudCA6IG51bGw7XG4gICAgICBnYXBDb250cm9sbGVyLnBvbGwodGhpcy5sYXN0Q3VycmVudFRpbWUsIGFjdGl2ZUZyYWcpO1xuICAgIH1cblxuICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gIH1cblxuICBwcml2YXRlIG9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkKCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbiBmaXJzdCBmcmFnXG4gICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gIH1cblxuICBwcml2YXRlIG9uQnVmZmVyRmx1c2hlZChcbiAgICBldmVudDogRXZlbnRzLkJVRkZFUl9GTFVTSEVELFxuICAgIHsgdHlwZSB9OiBCdWZmZXJGbHVzaGVkRGF0YVxuICApIHtcbiAgICBpZiAoXG4gICAgICB0eXBlICE9PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8gfHxcbiAgICAgICh0aGlzLmF1ZGlvT25seSAmJiAhdGhpcy5hbHRBdWRpbylcbiAgICApIHtcbiAgICAgIGNvbnN0IG1lZGlhQnVmZmVyID1cbiAgICAgICAgKHR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT1xuICAgICAgICAgID8gdGhpcy52aWRlb0J1ZmZlclxuICAgICAgICAgIDogdGhpcy5tZWRpYUJ1ZmZlcikgfHwgdGhpcy5tZWRpYTtcbiAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhQnVmZmVyLCB0eXBlLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uTGV2ZWxzVXBkYXRlZChcbiAgICBldmVudDogRXZlbnRzLkxFVkVMU19VUERBVEVELFxuICAgIGRhdGE6IExldmVsc1VwZGF0ZWREYXRhXG4gICkge1xuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gIH1cblxuICBwdWJsaWMgc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9ICF0aGlzLmF1ZGlvQ29kZWNTd2FwO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZWtzIHRvIHRoZSBzZXQgc3RhcnRQb3NpdGlvbiBpZiBub3QgZXF1YWwgdG8gdGhlIG1lZGlhRWxlbWVudCdzIGN1cnJlbnQgdGltZS5cbiAgICovXG4gIHByb3RlY3RlZCBzZWVrVG9TdGFydFBvcygpIHtcbiAgICBjb25zdCB7IG1lZGlhIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAvLyBvbmx5IGFkanVzdCBjdXJyZW50VGltZSBpZiBkaWZmZXJlbnQgZnJvbSBzdGFydFBvc2l0aW9uIG9yIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXG4gICAgLy8gYXQgdGhhdCBzdGFnZSwgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJ1ZmZlcmVkIHJhbmdlLCBhcyB3ZSByZWFjaCB0aGF0IGNvZGUgYWZ0ZXIgZmlyc3QgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWRcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA+PSAwICYmIGN1cnJlbnRUaW1lIDwgc3RhcnRQb3NpdGlvbikge1xuICAgICAgaWYgKG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgYGNvdWxkIG5vdCBzZWVrIHRvICR7c3RhcnRQb3NpdGlvbn0sIGFscmVhZHkgc2Vla2luZyBhdCAke2N1cnJlbnRUaW1lfWBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgY29uc3QgYnVmZmVyU3RhcnQgPSBidWZmZXJlZC5sZW5ndGggPyBidWZmZXJlZC5zdGFydCgwKSA6IDA7XG4gICAgICBjb25zdCBkZWx0YSA9IGJ1ZmZlclN0YXJ0IC0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIGlmIChcbiAgICAgICAgZGVsdGEgPiAwICYmXG4gICAgICAgIChkZWx0YSA8IHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgfHxcbiAgICAgICAgICBkZWx0YSA8IHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5sb2coYGFkanVzdGluZyBzdGFydCBwb3NpdGlvbiBieSAke2RlbHRhfSB0byBtYXRjaCBidWZmZXIgc3RhcnRgKTtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiArPSBkZWx0YTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgc2VlayB0byB0YXJnZXQgc3RhcnQgcG9zaXRpb24gJHtzdGFydFBvc2l0aW9ufSBmcm9tIGN1cnJlbnQgdGltZSAke2N1cnJlbnRUaW1lfWBcbiAgICAgICk7XG4gICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0QXVkaW9Db2RlYyhjdXJyZW50TGV2ZWwpIHtcbiAgICBsZXQgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2FwICYmIGF1ZGlvQ29kZWMpIHtcbiAgICAgIHRoaXMubG9nKCdTd2FwcGluZyBhdWRpbyBjb2RlYycpO1xuICAgICAgaWYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXVkaW9Db2RlYztcbiAgfVxuXG4gIHByaXZhdGUgX2xvYWRCaXRyYXRlVGVzdEZyYWcoZnJhZzogRnJhZ21lbnQsIGxldmVsOiBMZXZlbCkge1xuICAgIGZyYWcuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgICAgaWYgKCFkYXRhIHx8IHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgY29uc3Qgc3RhdHMgPSBmcmFnLnN0YXRzO1xuICAgICAgLy8gQml0cmF0ZSB0ZXN0cyBmcmFnbWVudHMgYXJlIG5laXRoZXIgcGFyc2VkIG5vciBidWZmZXJlZFxuICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9XG4gICAgICAgIHN0YXRzLnBhcnNpbmcuZW5kID1cbiAgICAgICAgc3RhdHMuYnVmZmVyaW5nLnN0YXJ0ID1cbiAgICAgICAgc3RhdHMuYnVmZmVyaW5nLmVuZCA9XG4gICAgICAgICAgc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSBhcyBGcmFnTG9hZGVkRGF0YSk7XG4gICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF9oYW5kbGVUcmFuc211eENvbXBsZXRlKHRyYW5zbXV4UmVzdWx0OiBUcmFuc211eGVyUmVzdWx0KSB7XG4gICAgY29uc3QgaWQgPSAnbWFpbic7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyByZW11eFJlc3VsdCwgY2h1bmtNZXRhIH0gPSB0cmFuc211eFJlc3VsdDtcblxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZnJhZywgcGFydCwgbGV2ZWwgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgeyB2aWRlbywgdGV4dCwgaWQzLCBpbml0U2VnbWVudCB9ID0gcmVtdXhSZXN1bHQ7XG4gICAgY29uc3QgeyBkZXRhaWxzIH0gPSBsZXZlbDtcbiAgICAvLyBUaGUgYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgaGFuZGxlcyBhdWRpbyBidWZmZXJpbmcgaWYgSGxzLmpzIGlzIHBsYXlpbmcgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgY29uc3QgYXVkaW8gPSB0aGlzLmFsdEF1ZGlvID8gdW5kZWZpbmVkIDogcmVtdXhSZXN1bHQuYXVkaW87XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCBmcmFnbWVudCBoYXMgYmVlbiBhYm9ydGVkLiBXZSBjaGVjayB0aGlzIGJ5IGZpcnN0IHNlZWluZyBpZiB3ZSdyZSBzdGlsbCBwbGF5aW5nIHRoZSBjdXJyZW50IGxldmVsLlxuICAgIC8vIElmIHdlIGFyZSwgc3Vic2VxdWVudGx5IGNoZWNrIGlmIHRoZSBjdXJyZW50bHkgbG9hZGluZyBmcmFnbWVudCAoZnJhZ0N1cnJlbnQpIGhhcyBjaGFuZ2VkLlxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG5cbiAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgIGlmIChpbml0U2VnbWVudD8udHJhY2tzKSB7XG4gICAgICAgIGNvbnN0IG1hcEZyYWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCB8fCBmcmFnO1xuICAgICAgICB0aGlzLl9idWZmZXJJbml0U2VnbWVudChcbiAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICBpbml0U2VnbWVudC50cmFja3MsXG4gICAgICAgICAgbWFwRnJhZ21lbnQsXG4gICAgICAgICAgY2h1bmtNZXRhXG4gICAgICAgICk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7XG4gICAgICAgICAgZnJhZzogbWFwRnJhZ21lbnQsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdHJhY2tzOiBpbml0U2VnbWVudC50cmFja3MsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIHdvdWxkIGJlIG5pY2UgaWYgTnVtYmVyLmlzRmluaXRlIGFjdGVkIGFzIGEgdHlwZWd1YXJkLCBidXQgaXQgZG9lc24ndC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEwMDM4XG4gICAgICBjb25zdCBpbml0UFRTID0gaW5pdFNlZ21lbnQuaW5pdFBUUyBhcyBudW1iZXI7XG4gICAgICBjb25zdCB0aW1lc2NhbGUgPSBpbml0U2VnbWVudC50aW1lc2NhbGUgYXMgbnVtYmVyO1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShpbml0UFRTKSkge1xuICAgICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSB7IGJhc2VUaW1lOiBpbml0UFRTLCB0aW1lc2NhbGUgfTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB7IGZyYWcsIGlkLCBpbml0UFRTLCB0aW1lc2NhbGUgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgYnVmZmVyaW5nIGlmIGJhY2t0cmFja2luZyB0aGlzIGZyYWdtZW50XG4gICAgaWYgKHZpZGVvICYmIHJlbXV4UmVzdWx0LmluZGVwZW5kZW50ICE9PSBmYWxzZSkge1xuICAgICAgaWYgKGRldGFpbHMpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTIH0gPSB2aWRlbztcbiAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zW3ZpZGVvLnR5cGVdID0ge1xuICAgICAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgICBzdGFydERUUyxcbiAgICAgICAgICAgIGVuZERUUyxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2aWRlby5maXJzdEtleUZyYW1lICYmIHZpZGVvLmluZGVwZW5kZW50ICYmIGNodW5rTWV0YS5pZCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2aWRlby5kcm9wcGVkICYmIHZpZGVvLmluZGVwZW5kZW50KSB7XG4gICAgICAgICAgICAvLyBCYWNrdHJhY2sgaWYgZHJvcHBlZCBmcmFtZXMgY3JlYXRlIGEgZ2FwIGFmdGVyIGN1cnJlbnRUaW1lXG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRCdWZmZXJUaW1lID1cbiAgICAgICAgICAgICAgKGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmVuZCA6IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCkpICtcbiAgICAgICAgICAgICAgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHZpZGVvLmZpcnN0S2V5RnJhbWVQVFNcbiAgICAgICAgICAgICAgPyB2aWRlby5maXJzdEtleUZyYW1lUFRTXG4gICAgICAgICAgICAgIDogc3RhcnRQVFM7XG4gICAgICAgICAgICBpZiAodGFyZ2V0QnVmZmVyVGltZSA8IHN0YXJ0VGltZSAtIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB2aWRlbyBzdHJlYW0gc3RhcnQgdG8gZnJhZ21lbnQgc3RhcnQgc28gdGhhdCB0cnVuY2F0ZWQgc2FtcGxlcyBkbyBub3QgZGlzdG9ydCB0aGUgdGltZWxpbmUsIGFuZCBtYXJrIGl0IHBhcnRpYWxcbiAgICAgICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8oXG4gICAgICAgICAgICAgIHZpZGVvLnR5cGUgYXMgRWxlbWVudGFyeVN0cmVhbVR5cGVzLFxuICAgICAgICAgICAgICBmcmFnLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgICAgIGZyYWcuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZERUUyxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhcbiAgICAgICAgICB2aWRlby50eXBlIGFzIEVsZW1lbnRhcnlTdHJlYW1UeXBlcyxcbiAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50KSB7XG4gICAgICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IGZyYWc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJGcmFnbWVudERhdGEodmlkZW8sIGZyYWcsIHBhcnQsIGNodW5rTWV0YSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZW11eFJlc3VsdC5pbmRlcGVuZGVudCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYmFja3RyYWNrKGZyYWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhdWRpbykge1xuICAgICAgY29uc3QgeyBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTIH0gPSBhdWRpbztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IHtcbiAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhcbiAgICAgICAgRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLFxuICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgZW5kUFRTLFxuICAgICAgICBzdGFydERUUyxcbiAgICAgICAgZW5kRFRTXG4gICAgICApO1xuICAgICAgdGhpcy5idWZmZXJGcmFnbWVudERhdGEoYXVkaW8sIGZyYWcsIHBhcnQsIGNodW5rTWV0YSk7XG4gICAgfVxuXG4gICAgaWYgKGRldGFpbHMgJiYgaWQzPy5zYW1wbGVzPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVtaXR0ZWRJRDM6IEZyYWdQYXJzaW5nTWV0YWRhdGFEYXRhID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgZGV0YWlscyxcbiAgICAgICAgc2FtcGxlczogaWQzLnNhbXBsZXMsXG4gICAgICB9O1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZW1pdHRlZElEMyk7XG4gICAgfVxuICAgIGlmIChkZXRhaWxzICYmIHRleHQpIHtcbiAgICAgIGNvbnN0IGVtaXR0ZWRUZXh0OiBGcmFnUGFyc2luZ1VzZXJkYXRhRGF0YSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIHNhbXBsZXM6IHRleHQuc2FtcGxlcyxcbiAgICAgIH07XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCBlbWl0dGVkVGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfYnVmZmVySW5pdFNlZ21lbnQoXG4gICAgY3VycmVudExldmVsOiBMZXZlbCxcbiAgICB0cmFja3M6IFRyYWNrU2V0LFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YVxuICApIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Pbmx5ID0gISF0cmFja3MuYXVkaW8gJiYgIXRyYWNrcy52aWRlbztcblxuICAgIC8vIGlmIGF1ZGlvIHRyYWNrIGlzIGV4cGVjdGVkIHRvIGNvbWUgZnJvbSBhdWRpbyBzdHJlYW0gY29udHJvbGxlciwgZGlzY2FyZCBhbnkgY29taW5nIGZyb20gbWFpblxuICAgIGlmICh0aGlzLmFsdEF1ZGlvICYmICF0aGlzLmF1ZGlvT25seSkge1xuICAgICAgZGVsZXRlIHRyYWNrcy5hdWRpbztcbiAgICB9XG4gICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICBjb25zdCB7IGF1ZGlvLCB2aWRlbywgYXVkaW92aWRlbyB9ID0gdHJhY2tzO1xuICAgIGlmIChhdWRpbykge1xuICAgICAgbGV0IGF1ZGlvQ29kZWMgPSBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgICBpZiAoYXVkaW9Db2RlYykge1xuICAgICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIHRoYXQgQUFDIGFuZCBIRS1BQUMgYXVkaW8gY29kZWNzIGFyZSBzaWduYWxsZWQgaW4gbWFuaWZlc3QsXG4gICAgICAgIC8vIGZvcmNlIEhFLUFBQywgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgaXQuXG4gICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBtb25vIHN0cmVhbSwgb3IgaW4gRmlyZWZveFxuICAgICAgICBpZiAoYXVkaW8ubWV0YWRhdGEuY2hhbm5lbENvdW50ICE9PSAxICYmIHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSA9PT0gLTEpIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEhFLUFBQyBpcyBicm9rZW4gb24gQW5kcm9pZCwgYWx3YXlzIHNpZ25hbCBhdWRpbyBjb2RlYyBhcyBBQUMgZXZlbiBpZiB2YXJpYW50IG1hbmlmZXN0IHN0YXRlcyBvdGhlcndpc2VcbiAgICAgIGlmICh1YS5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xICYmIGF1ZGlvLmNvbnRhaW5lciAhPT0gJ2F1ZGlvL21wZWcnKSB7XG4gICAgICAgIC8vIEV4Y2x1ZGUgbXBlZyBhdWRpb1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgIHRoaXMubG9nKGBBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byAke2F1ZGlvQ29kZWN9YCk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvQ29kZWMgJiYgY3VycmVudExldmVsLmF1ZGlvQ29kZWMgIT09IGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgYFN3YXBwaW5nIG1hbmlmZXN0IGF1ZGlvIGNvZGVjIFwiJHtjdXJyZW50TGV2ZWwuYXVkaW9Db2RlY31cIiBmb3IgXCIke2F1ZGlvQ29kZWN9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBhdWRpby5sZXZlbENvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgIGF1ZGlvLmlkID0gJ21haW4nO1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgIGBJbml0IGF1ZGlvIGJ1ZmZlciwgY29udGFpbmVyOiR7XG4gICAgICAgICAgYXVkaW8uY29udGFpbmVyXG4gICAgICAgIH0sIGNvZGVjc1tzZWxlY3RlZC9sZXZlbC9wYXJzZWRdPVske2F1ZGlvQ29kZWMgfHwgJyd9LyR7XG4gICAgICAgICAgY3VycmVudExldmVsLmF1ZGlvQ29kZWMgfHwgJydcbiAgICAgICAgfS8ke2F1ZGlvLmNvZGVjfV1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIHZpZGVvLmxldmVsQ29kZWMgPSBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYztcbiAgICAgIHZpZGVvLmlkID0gJ21haW4nO1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgIGBJbml0IHZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOiR7XG4gICAgICAgICAgdmlkZW8uY29udGFpbmVyXG4gICAgICAgIH0sIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske2N1cnJlbnRMZXZlbC52aWRlb0NvZGVjIHx8ICcnfS8ke1xuICAgICAgICAgIHZpZGVvLmNvZGVjXG4gICAgICAgIH1dYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGF1ZGlvdmlkZW8pIHtcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgSW5pdCBhdWRpb3ZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOiR7XG4gICAgICAgICAgYXVkaW92aWRlby5jb250YWluZXJcbiAgICAgICAgfSwgY29kZWNzW2xldmVsL3BhcnNlZF09WyR7Y3VycmVudExldmVsLmF0dHJzLkNPREVDUyB8fCAnJ30vJHtcbiAgICAgICAgICBhdWRpb3ZpZGVvLmNvZGVjXG4gICAgICAgIH1dYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICAvLyBsb29wIHRocm91Z2ggdHJhY2tzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHByb3ZpZGVkIHRvIGJ1ZmZlckNvbnRyb2xsZXJcbiAgICBPYmplY3Qua2V5cyh0cmFja3MpLmZvckVhY2goKHRyYWNrTmFtZSkgPT4ge1xuICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgIGNvbnN0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICBpZiAoaW5pdFNlZ21lbnQ/LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVORElORywge1xuICAgICAgICAgIHR5cGU6IHRyYWNrTmFtZSBhcyBTb3VyY2VCdWZmZXJOYW1lLFxuICAgICAgICAgIGRhdGE6IGluaXRTZWdtZW50LFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICBjaHVua01ldGEsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRNYWluRndkQnVmZmVySW5mbygpOiBCdWZmZXJJbmZvIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mbyhcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYSxcbiAgICAgIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU5cbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBiYWNrdHJhY2soZnJhZzogRnJhZ21lbnQpIHtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gdHJ1ZTtcbiAgICAvLyBDYXVzZXMgZmluZEZyYWdtZW50cyB0byBiYWNrdHJhY2sgdGhyb3VnaCBmcmFnbWVudHMgdG8gZmluZCB0aGUga2V5ZnJhbWVcbiAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gZnJhZztcbiAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgIHRoaXMuZmx1c2hCdWZmZXJHYXAoZnJhZyk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQ7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrRnJhZ21lbnRDaGFuZ2VkKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICBsZXQgZnJhZ1BsYXlpbmdDdXJyZW50OiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICAgIGlmICh2aWRlbyAmJiB2aWRlby5yZWFkeVN0YXRlID4gMSAmJiB2aWRlby5zZWVraW5nID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcbiAgICAgIC8qIGlmIHZpZGVvIGVsZW1lbnQgaXMgaW4gc2Vla2VkIHN0YXRlLCBjdXJyZW50VGltZSBjYW4gb25seSBpbmNyZWFzZS5cbiAgICAgICAgKGFzc3VtaW5nIHRoYXQgcGxheWJhY2sgcmF0ZSBpcyBwb3NpdGl2ZSAuLi4pXG4gICAgICAgIEFzIHNvbWV0aW1lcyBjdXJyZW50VGltZSBqdW1wcyBiYWNrIHRvIHplcm8gYWZ0ZXIgYVxuICAgICAgICBtZWRpYSBkZWNvZGUgZXJyb3IsIGNoZWNrIHRoaXMsIHRvIGF2b2lkIHNlZWtpbmcgYmFjayB0b1xuICAgICAgICB3cm9uZyBwb3NpdGlvbiBhZnRlciBhIG1lZGlhIGRlY29kZSBlcnJvclxuICAgICAgKi9cblxuICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcoY3VycmVudFRpbWUpO1xuICAgICAgfSBlbHNlIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUgKyAwLjEpKSB7XG4gICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxuICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcbiAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcoY3VycmVudFRpbWUgKyAwLjEpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCkge1xuICAgICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgY29uc3QgZnJhZ1BsYXlpbmcgPSB0aGlzLmZyYWdQbGF5aW5nO1xuICAgICAgICBjb25zdCBmcmFnQ3VycmVudExldmVsID0gZnJhZ1BsYXlpbmdDdXJyZW50LmxldmVsO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWZyYWdQbGF5aW5nIHx8XG4gICAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50LnNuICE9PSBmcmFnUGxheWluZy5zbiB8fFxuICAgICAgICAgIGZyYWdQbGF5aW5nLmxldmVsICE9PSBmcmFnQ3VycmVudExldmVsIHx8XG4gICAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50LnVybElkICE9PSBmcmFnUGxheWluZy51cmxJZFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmdDdXJyZW50O1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQ0hBTkdFRCwgeyBmcmFnOiBmcmFnUGxheWluZ0N1cnJlbnQgfSk7XG4gICAgICAgICAgaWYgKCFmcmFnUGxheWluZyB8fCBmcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnRMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENIRUQsIHtcbiAgICAgICAgICAgICAgbGV2ZWw6IGZyYWdDdXJyZW50TGV2ZWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgbmV4dExldmVsKCk6IG51bWJlciB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMubmV4dEJ1ZmZlcmVkRnJhZztcbiAgICBpZiAoZnJhZykge1xuICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGdldCBjdXJyZW50RnJhZygpOiBGcmFnbWVudCB8IG51bGwge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdQbGF5aW5nIHx8IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgY3VycmVudFByb2dyYW1EYXRlVGltZSgpOiBEYXRlIHwgbnVsbCB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIGNvbnN0IGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgICAgaWYgKFxuICAgICAgICBmcmFnICYmXG4gICAgICAgIE51bWJlci5pc0Zpbml0ZShjdXJyZW50VGltZSkgJiZcbiAgICAgICAgTnVtYmVyLmlzRmluaXRlKGZyYWcucHJvZ3JhbURhdGVUaW1lKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGVwb2NNcyA9XG4gICAgICAgICAgKGZyYWcucHJvZ3JhbURhdGVUaW1lIGFzIG51bWJlcikgKyAoY3VycmVudFRpbWUgLSBmcmFnLnN0YXJ0KSAqIDEwMDA7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShlcG9jTXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBjdXJyZW50TGV2ZWwoKTogbnVtYmVyIHtcbiAgICBjb25zdCBmcmFnID0gdGhpcy5jdXJyZW50RnJhZztcbiAgICBpZiAoZnJhZykge1xuICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGdldCBuZXh0QnVmZmVyZWRGcmFnKCkge1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgIGlmIChmcmFnKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcoZnJhZyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IGZvcmNlU3RhcnRMb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVN0YXJ0TG9hZDtcbiAgfVxufVxuIiwiLypcbiAqIGNvbXB1dGUgYW4gRXhwb25lbnRpYWwgV2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VcbiAqIC0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW92aW5nX2F2ZXJhZ2UjRXhwb25lbnRpYWxfbW92aW5nX2F2ZXJhZ2VcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqL1xuXG5jbGFzcyBFV01BIHtcbiAgcHVibGljIHJlYWRvbmx5IGhhbGZMaWZlOiBudW1iZXI7XG4gIHByaXZhdGUgYWxwaGFfOiBudW1iZXI7XG4gIHByaXZhdGUgZXN0aW1hdGVfOiBudW1iZXI7XG4gIHByaXZhdGUgdG90YWxXZWlnaHRfOiBudW1iZXI7XG5cbiAgLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cbiAgY29uc3RydWN0b3IoaGFsZkxpZmU6IG51bWJlciwgZXN0aW1hdGU6IG51bWJlciA9IDAsIHdlaWdodDogbnVtYmVyID0gMCkge1xuICAgIHRoaXMuaGFsZkxpZmUgPSBoYWxmTGlmZTtcbiAgICAvLyBMYXJnZXIgdmFsdWVzIG9mIGFscGhhIGV4cGlyZSBoaXN0b3JpY2FsIGRhdGEgbW9yZSBzbG93bHkuXG4gICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gZXN0aW1hdGU7XG4gICAgdGhpcy50b3RhbFdlaWdodF8gPSB3ZWlnaHQ7XG4gIH1cblxuICBzYW1wbGUod2VpZ2h0OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcbiAgICBjb25zdCBhZGpBbHBoYSA9IE1hdGgucG93KHRoaXMuYWxwaGFfLCB3ZWlnaHQpO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gdmFsdWUgKiAoMSAtIGFkakFscGhhKSArIGFkakFscGhhICogdGhpcy5lc3RpbWF0ZV87XG4gICAgdGhpcy50b3RhbFdlaWdodF8gKz0gd2VpZ2h0O1xuICB9XG5cbiAgZ2V0VG90YWxXZWlnaHQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH1cblxuICBnZXRFc3RpbWF0ZSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmFscGhhXykge1xuICAgICAgY29uc3QgemVyb0ZhY3RvciA9IDEgLSBNYXRoLnBvdyh0aGlzLmFscGhhXywgdGhpcy50b3RhbFdlaWdodF8pO1xuICAgICAgaWYgKHplcm9GYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfIC8gemVyb0ZhY3RvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVXTUE7XG4iLCIvKlxuICogRVdNQSBCYW5kd2lkdGggRXN0aW1hdG9yXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXG4gKiBUcmFja3MgYmFuZHdpZHRoIHNhbXBsZXMgYW5kIGVzdGltYXRlcyBhdmFpbGFibGUgYmFuZHdpZHRoLlxuICogQmFzZWQgb24gdGhlIG1pbmltdW0gb2YgdHdvIGV4cG9uZW50aWFsbHktd2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VzIHdpdGhcbiAqIGRpZmZlcmVudCBoYWxmLWxpdmVzLlxuICovXG5cbmltcG9ydCBFV01BIGZyb20gJy4uL3V0aWxzL2V3bWEnO1xuXG5jbGFzcyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIHtcbiAgcHJpdmF0ZSBkZWZhdWx0RXN0aW1hdGVfOiBudW1iZXI7XG4gIHByaXZhdGUgbWluV2VpZ2h0XzogbnVtYmVyO1xuICBwcml2YXRlIG1pbkRlbGF5TXNfOiBudW1iZXI7XG4gIHByaXZhdGUgc2xvd186IEVXTUE7XG4gIHByaXZhdGUgZmFzdF86IEVXTUE7XG4gIHByaXZhdGUgZGVmYXVsdFRURkJfOiBudW1iZXI7XG4gIHByaXZhdGUgdHRmYl86IEVXTUE7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc2xvdzogbnVtYmVyLFxuICAgIGZhc3Q6IG51bWJlcixcbiAgICBkZWZhdWx0RXN0aW1hdGU6IG51bWJlcixcbiAgICBkZWZhdWx0VFRGQjogbnVtYmVyID0gMTAwXG4gICkge1xuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IGRlZmF1bHRFc3RpbWF0ZTtcbiAgICB0aGlzLm1pbldlaWdodF8gPSAwLjAwMTtcbiAgICB0aGlzLm1pbkRlbGF5TXNfID0gNTA7XG4gICAgdGhpcy5zbG93XyA9IG5ldyBFV01BKHNsb3cpO1xuICAgIHRoaXMuZmFzdF8gPSBuZXcgRVdNQShmYXN0KTtcbiAgICB0aGlzLmRlZmF1bHRUVEZCXyA9IGRlZmF1bHRUVEZCO1xuICAgIHRoaXMudHRmYl8gPSBuZXcgRVdNQShzbG93KTtcbiAgfVxuXG4gIHVwZGF0ZShzbG93OiBudW1iZXIsIGZhc3Q6IG51bWJlcikge1xuICAgIGNvbnN0IHsgc2xvd18sIGZhc3RfLCB0dGZiXyB9ID0gdGhpcztcbiAgICBpZiAoc2xvd18uaGFsZkxpZmUgIT09IHNsb3cpIHtcbiAgICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93LCBzbG93Xy5nZXRFc3RpbWF0ZSgpLCBzbG93Xy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG4gICAgaWYgKGZhc3RfLmhhbGZMaWZlICE9PSBmYXN0KSB7XG4gICAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCwgZmFzdF8uZ2V0RXN0aW1hdGUoKSwgZmFzdF8uZ2V0VG90YWxXZWlnaHQoKSk7XG4gICAgfVxuICAgIGlmICh0dGZiXy5oYWxmTGlmZSAhPT0gc2xvdykge1xuICAgICAgdGhpcy50dGZiXyA9IG5ldyBFV01BKHNsb3csIHR0ZmJfLmdldEVzdGltYXRlKCksIHR0ZmJfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgIH1cbiAgfVxuXG4gIHNhbXBsZShkdXJhdGlvbk1zOiBudW1iZXIsIG51bUJ5dGVzOiBudW1iZXIpIHtcbiAgICBkdXJhdGlvbk1zID0gTWF0aC5tYXgoZHVyYXRpb25NcywgdGhpcy5taW5EZWxheU1zXyk7XG4gICAgY29uc3QgbnVtQml0cyA9IDggKiBudW1CeXRlcztcbiAgICAvLyB3ZWlnaHQgaXMgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgIGNvbnN0IGR1cmF0aW9uUyA9IGR1cmF0aW9uTXMgLyAxMDAwO1xuICAgIC8vIHZhbHVlIGlzIGJhbmR3aWR0aCBpbiBiaXRzL3NcbiAgICBjb25zdCBiYW5kd2lkdGhJbkJwcyA9IG51bUJpdHMgLyBkdXJhdGlvblM7XG4gICAgdGhpcy5mYXN0Xy5zYW1wbGUoZHVyYXRpb25TLCBiYW5kd2lkdGhJbkJwcyk7XG4gICAgdGhpcy5zbG93Xy5zYW1wbGUoZHVyYXRpb25TLCBiYW5kd2lkdGhJbkJwcyk7XG4gIH1cblxuICBzYW1wbGVUVEZCKHR0ZmI6IG51bWJlcikge1xuICAgIC8vIHdlaWdodCBpcyBmcmVxdWVuY3kgY3VydmUgYXBwbGllZCB0byBUVEZCIGluIHNlY29uZHNcbiAgICAvLyAobG9uZ2VyIHRpbWVzIGhhdmUgbGVzcyB3ZWlnaHQgd2l0aCBleHBlY3RlZCBpbnB1dCB1bmRlciAxIHNlY29uZClcbiAgICBjb25zdCBzZWNvbmRzID0gdHRmYiAvIDEwMDA7XG4gICAgY29uc3Qgd2VpZ2h0ID0gTWF0aC5zcXJ0KDIpICogTWF0aC5leHAoLU1hdGgucG93KHNlY29uZHMsIDIpIC8gMik7XG4gICAgdGhpcy50dGZiXy5zYW1wbGUod2VpZ2h0LCBNYXRoLm1heCh0dGZiLCA1KSk7XG4gIH1cblxuICBjYW5Fc3RpbWF0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5mYXN0Xy5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0XztcbiAgfVxuXG4gIGdldEVzdGltYXRlKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuY2FuRXN0aW1hdGUoKSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ3Nsb3cgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdmYXN0IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgICAvLyBUYWtlIHRoZSBtaW5pbXVtIG9mIHRoZXNlIHR3byBlc3RpbWF0ZXMuICBUaGlzIHNob3VsZCBoYXZlIHRoZSBlZmZlY3Qgb2ZcbiAgICAgIC8vIGFkYXB0aW5nIGRvd24gcXVpY2tseSwgYnV0IHVwIG1vcmUgc2xvd2x5LlxuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSwgdGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEVzdGltYXRlXztcbiAgICB9XG4gIH1cblxuICBnZXRFc3RpbWF0ZVRURkIoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy50dGZiXy5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0Xykge1xuICAgICAgcmV0dXJuIHRoaXMudHRmYl8uZ2V0RXN0aW1hdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFRURkJfO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7fVxufVxuZXhwb3J0IGRlZmF1bHQgRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcbiIsImltcG9ydCBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIGZyb20gJy4uL3V0aWxzL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvcic7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgUGxheWxpc3RMZXZlbFR5cGUgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB0eXBlIHsgRnJhZ21lbnQgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBQYXJ0IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB0eXBlIHsgTG9hZGVyU3RhdHMgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5pbXBvcnQgdHlwZSB7XG4gIEZyYWdMb2FkaW5nRGF0YSxcbiAgRnJhZ0xvYWRlZERhdGEsXG4gIEZyYWdCdWZmZXJlZERhdGEsXG4gIExldmVsTG9hZGVkRGF0YSxcbiAgTGV2ZWxTd2l0Y2hpbmdEYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBBYnJDb21wb25lbnRBUEkgfSBmcm9tICcuLi90eXBlcy9jb21wb25lbnQtYXBpJztcblxuY2xhc3MgQWJyQ29udHJvbGxlciBpbXBsZW1lbnRzIEFickNvbXBvbmVudEFQSSB7XG4gIHByb3RlY3RlZCBobHM6IEhscztcbiAgcHJpdmF0ZSBsYXN0TGV2ZWxMb2FkU2VjOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIGxhc3RMb2FkZWRGcmFnTGV2ZWw6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgX25leHRBdXRvTGV2ZWw6IG51bWJlciA9IC0xO1xuICBwcml2YXRlIHRpbWVyOiBudW1iZXIgPSAtMTtcbiAgcHJpdmF0ZSBvbkNoZWNrOiBGdW5jdGlvbiA9IHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrLmJpbmQodGhpcyk7XG4gIHByaXZhdGUgZnJhZ0N1cnJlbnQ6IEZyYWdtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcGFydEN1cnJlbnQ6IFBhcnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBiaXRyYXRlVGVzdERlbGF5OiBudW1iZXIgPSAwO1xuXG4gIHB1YmxpYyByZWFkb25seSBid0VzdGltYXRvcjogRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcblxuICBjb25zdHJ1Y3RvcihobHM6IEhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuXG4gICAgY29uc3QgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmJ3RXN0aW1hdG9yID0gbmV3IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IoXG4gICAgICBjb25maWcuYWJyRXdtYVNsb3dWb0QsXG4gICAgICBjb25maWcuYWJyRXdtYUZhc3RWb0QsXG4gICAgICBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZVxuICAgICk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5vbkNoZWNrID0gbnVsbDtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25GcmFnTG9hZGluZyhldmVudDogRXZlbnRzLkZSQUdfTE9BRElORywgZGF0YTogRnJhZ0xvYWRpbmdEYXRhKSB7XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICB0aGlzLnBhcnRDdXJyZW50ID0gZGF0YS5wYXJ0ID8/IG51bGw7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5vbkNoZWNrLCAxMDApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTGV2ZWxTd2l0Y2hpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsXG4gICAgZGF0YTogTGV2ZWxTd2l0Y2hpbmdEYXRhXG4gICk6IHZvaWQge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRUaW1lVG9Mb2FkRnJhZyhcbiAgICB0aW1lVG9GaXJzdEJ5dGVTZWM6IG51bWJlcixcbiAgICBiYW5kd2lkdGg6IG51bWJlcixcbiAgICBmcmFnU2l6ZUJpdHM6IG51bWJlcixcbiAgICBpc1N3aXRjaDogYm9vbGVhblxuICApIHtcbiAgICBjb25zdCBmcmFnTG9hZFNlYyA9IHRpbWVUb0ZpcnN0Qnl0ZVNlYyArIGZyYWdTaXplQml0cyAvIGJhbmR3aWR0aDtcbiAgICBjb25zdCBwbGF5bGlzdExvYWRTZWMgPSBpc1N3aXRjaCA/IHRoaXMubGFzdExldmVsTG9hZFNlYyA6IDA7XG4gICAgcmV0dXJuIGZyYWdMb2FkU2VjICsgcGxheWxpc3RMb2FkU2VjO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTGV2ZWxMb2FkZWQoZXZlbnQ6IEV2ZW50cy5MRVZFTF9MT0FERUQsIGRhdGE6IExldmVsTG9hZGVkRGF0YSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCB7IHRvdGFsLCBid0VzdGltYXRlIH0gPSBkYXRhLnN0YXRzO1xuICAgIC8vIFRvdGFsIGlzIHRoZSBieXRlbGVuZ3RoIGFuZCBid0VzdGltYXRlIGluIGJpdHMvc2VjXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZSh0b3RhbCkgJiYgTnVtYmVyLmlzRmluaXRlKGJ3RXN0aW1hdGUpKSB7XG4gICAgICB0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSAoOCAqIHRvdGFsKSAvIGJ3RXN0aW1hdGU7XG4gICAgfVxuICAgIGlmIChkYXRhLmRldGFpbHMubGl2ZSkge1xuICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93TGl2ZSwgY29uZmlnLmFickV3bWFGYXN0TGl2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3IudXBkYXRlKGNvbmZpZy5hYnJFd21hU2xvd1ZvRCwgY29uZmlnLmFickV3bWFGYXN0Vm9EKTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgICAgVGhpcyBtZXRob2QgbW9uaXRvcnMgdGhlIGRvd25sb2FkIHJhdGUgb2YgdGhlIGN1cnJlbnQgZnJhZ21lbnQsIGFuZCB3aWxsIGRvd25zd2l0Y2ggaWYgdGhhdCBmcmFnbWVudCB3aWxsIG5vdCBsb2FkXG4gICAgICBxdWlja2x5IGVub3VnaCB0byBwcmV2ZW50IHVuZGVyYnVmZmVyaW5nXG4gICAgKi9cbiAgcHJpdmF0ZSBfYWJhbmRvblJ1bGVzQ2hlY2soKSB7XG4gICAgY29uc3QgeyBmcmFnQ3VycmVudDogZnJhZywgcGFydEN1cnJlbnQ6IHBhcnQsIGhscyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGF1dG9MZXZlbEVuYWJsZWQsIG1lZGlhIH0gPSBobHM7XG4gICAgaWYgKCFmcmFnIHx8ICFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHN0YXRzOiBMb2FkZXJTdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnQgPyBwYXJ0LmR1cmF0aW9uIDogZnJhZy5kdXJhdGlvbjtcbiAgICBjb25zdCB0aW1lTG9hZGluZyA9IG5vdyAtIHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgLy8gSWYgZnJhZyBsb2FkaW5nIGlzIGFib3J0ZWQsIGNvbXBsZXRlLCBvciBmcm9tIGxvd2VzdCBsZXZlbCwgc3RvcCB0aW1lciBhbmQgcmV0dXJuXG4gICAgaWYgKFxuICAgICAgc3RhdHMuYWJvcnRlZCB8fFxuICAgICAgKHN0YXRzLmxvYWRlZCAmJiBzdGF0cy5sb2FkZWQgPT09IHN0YXRzLnRvdGFsKSB8fFxuICAgICAgZnJhZy5sZXZlbCA9PT0gMFxuICAgICkge1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgY2hlY2sgb25seSBydW5zIGlmIHdlJ3JlIGluIEFCUiBtb2RlIGFuZCBhY3R1YWxseSBwbGF5aW5nXG4gICAgaWYgKFxuICAgICAgIWF1dG9MZXZlbEVuYWJsZWQgfHxcbiAgICAgIG1lZGlhLnBhdXNlZCB8fFxuICAgICAgIW1lZGlhLnBsYXliYWNrUmF0ZSB8fFxuICAgICAgIW1lZGlhLnJlYWR5U3RhdGVcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXJJbmZvID0gaGxzLm1haW5Gb3J3YXJkQnVmZmVySW5mbztcbiAgICBpZiAoYnVmZmVySW5mbyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHR0ZmJFc3RpbWF0ZSA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gICAgY29uc3QgcGxheWJhY2tSYXRlID0gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKTtcbiAgICAvLyBUbyBtYWludGFpbiBzdGFibGUgYWRhcHRpdmUgcGxheWJhY2ssIG9ubHkgYmVnaW4gbW9uaXRvcmluZyBmcmFnIGxvYWRpbmcgYWZ0ZXIgaGFsZiBvciBtb3JlIG9mIGl0cyBwbGF5YmFjayBkdXJhdGlvbiBoYXMgcGFzc2VkXG4gICAgaWYgKFxuICAgICAgdGltZUxvYWRpbmcgPD1cbiAgICAgIE1hdGgubWF4KHR0ZmJFc3RpbWF0ZSwgMTAwMCAqIChkdXJhdGlvbiAvIChwbGF5YmFja1JhdGUgKiAyKSkpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGV4aGF1c3QgdGhlIGJ1ZmZlclxuICAgIGNvbnN0IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IGJ1ZmZlckluZm8ubGVuIC8gcGxheWJhY2tSYXRlO1xuICAgIC8vIE9ubHkgZG93bnN3aXRjaCBpZiBsZXNzIHRoYW4gMiBmcmFnbWVudCBsZW5ndGhzIGFyZSBidWZmZXJlZFxuICAgIGlmIChidWZmZXJTdGFydmF0aW9uRGVsYXkgPj0gKDIgKiBkdXJhdGlvbikgLyBwbGF5YmFja1JhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0dGZiID0gc3RhdHMubG9hZGluZy5maXJzdFxuICAgICAgPyBzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydFxuICAgICAgOiAtMTtcbiAgICBjb25zdCBsb2FkZWRGaXJzdEJ5dGUgPSBzdGF0cy5sb2FkZWQgJiYgdHRmYiA+IC0xO1xuICAgIGNvbnN0IGJ3RXN0aW1hdGU6IG51bWJlciA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcbiAgICBjb25zdCB7IGxldmVscywgbWluQXV0b0xldmVsIH0gPSBobHM7XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgY29uc3QgZXhwZWN0ZWRMZW4gPVxuICAgICAgc3RhdHMudG90YWwgfHxcbiAgICAgIE1hdGgubWF4KHN0YXRzLmxvYWRlZCwgTWF0aC5yb3VuZCgoZHVyYXRpb24gKiBsZXZlbC5tYXhCaXRyYXRlKSAvIDgpKTtcbiAgICBsZXQgdGltZVN0cmVhbWluZyA9IHRpbWVMb2FkaW5nIC0gdHRmYjtcbiAgICBpZiAodGltZVN0cmVhbWluZyA8IDEgJiYgbG9hZGVkRmlyc3RCeXRlKSB7XG4gICAgICB0aW1lU3RyZWFtaW5nID0gTWF0aC5taW4odGltZUxvYWRpbmcsIChzdGF0cy5sb2FkZWQgKiA4KSAvIGJ3RXN0aW1hdGUpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkUmF0ZSA9IGxvYWRlZEZpcnN0Qnl0ZVxuICAgICAgPyAoc3RhdHMubG9hZGVkICogMTAwMCkgLyB0aW1lU3RyZWFtaW5nXG4gICAgICA6IDA7XG4gICAgLy8gZnJhZ0xvYWREZWxheSBpcyBhbiBlc3RpbWF0ZSBvZiB0aGUgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGJ1ZmZlciB0aGUgcmVtYWluZGVyIG9mIHRoZSBmcmFnbWVudFxuICAgIGNvbnN0IGZyYWdMb2FkZWREZWxheSA9IGxvYWRSYXRlXG4gICAgICA/IChleHBlY3RlZExlbiAtIHN0YXRzLmxvYWRlZCkgLyBsb2FkUmF0ZVxuICAgICAgOiAoZXhwZWN0ZWRMZW4gKiA4KSAvIGJ3RXN0aW1hdGUgKyB0dGZiRXN0aW1hdGUgLyAxMDAwO1xuICAgIC8vIE9ubHkgZG93bnN3aXRjaCBpZiB0aGUgdGltZSB0byBmaW5pc2ggbG9hZGluZyB0aGUgY3VycmVudCBmcmFnbWVudCBpcyBncmVhdGVyIHRoYW4gdGhlIGFtb3VudCBvZiBidWZmZXIgbGVmdFxuICAgIGlmIChmcmFnTG9hZGVkRGVsYXkgPD0gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYndlID0gbG9hZFJhdGUgPyBsb2FkUmF0ZSAqIDggOiBid0VzdGltYXRlO1xuICAgIGxldCBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXk6IG51bWJlciA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbmV4dExvYWRMZXZlbDogbnVtYmVyO1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBsb3dlciBsZXZlbCBhbmQgdHJ5IHRvIGZpbmQgdGhlIGxhcmdlc3Qgb25lIHRoYXQgYXZvaWRzIHJlYnVmZmVyaW5nXG4gICAgZm9yIChcbiAgICAgIG5leHRMb2FkTGV2ZWwgPSBmcmFnLmxldmVsIC0gMTtcbiAgICAgIG5leHRMb2FkTGV2ZWwgPiBtaW5BdXRvTGV2ZWw7XG4gICAgICBuZXh0TG9hZExldmVsLS1cbiAgICApIHtcbiAgICAgIC8vIGNvbXB1dGUgdGltZSB0byBsb2FkIG5leHQgZnJhZ21lbnQgYXQgbG93ZXIgbGV2ZWxcbiAgICAgIC8vIDggPSBiaXRzIHBlciBieXRlIChicHMvQnBzKVxuICAgICAgY29uc3QgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5tYXhCaXRyYXRlO1xuICAgICAgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gdGhpcy5nZXRUaW1lVG9Mb2FkRnJhZyhcbiAgICAgICAgdHRmYkVzdGltYXRlIC8gMTAwMCxcbiAgICAgICAgYndlLFxuICAgICAgICBkdXJhdGlvbiAqIGxldmVsTmV4dEJpdHJhdGUsXG4gICAgICAgICFsZXZlbHNbbmV4dExvYWRMZXZlbF0uZGV0YWlsc1xuICAgICAgKTtcbiAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE9ubHkgZW1lcmdlbmN5IHN3aXRjaCBkb3duIGlmIGl0IHRha2VzIGxlc3MgdGltZSB0byBsb2FkIGEgbmV3IGZyYWdtZW50IGF0IGxvd2VzdCBsZXZlbCBpbnN0ZWFkIG9mIGNvbnRpbnVpbmdcbiAgICAvLyB0byBsb2FkIHRoZSBjdXJyZW50IG9uZVxuICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPj0gZnJhZ0xvYWRlZERlbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgZXN0aW1hdGVkIGxvYWQgdGltZSBvZiBuZXcgc2VnbWVudCBpcyBjb21wbGV0ZWx5IHVucmVhc29uYWJsZSwgaWdub3JlIGFuZCBkbyBub3QgZW1lcmdlbmN5IHN3aXRjaCBkb3duXG4gICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA+IGR1cmF0aW9uICogMTApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBuZXh0TG9hZExldmVsO1xuICAgIGlmIChsb2FkZWRGaXJzdEJ5dGUpIHtcbiAgICAgIC8vIElmIHRoZXJlIGhhcyBiZWVuIGxvYWRpbmcgcHJvZ3Jlc3MsIHNhbXBsZSBiYW5kd2lkdGggdXNpbmcgbG9hZGluZyB0aW1lIG9mZnNldCBieSBtaW5pbXVtIFRURkIgdGltZVxuICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUoXG4gICAgICAgIHRpbWVMb2FkaW5nIC0gTWF0aC5taW4odHRmYkVzdGltYXRlLCB0dGZiKSxcbiAgICAgICAgc3RhdHMubG9hZGVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSBoYXMgYmVlbiBubyBsb2FkaW5nIHByb2dyZXNzLCBzYW1wbGUgVFRGQlxuICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGVUVEZCKHRpbWVMb2FkaW5nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICBsb2dnZXIud2FybihgW2Ficl0gRnJhZ21lbnQgJHtmcmFnLnNufSR7XG4gICAgICBwYXJ0ID8gJyBwYXJ0ICcgKyBwYXJ0LmluZGV4IDogJydcbiAgICB9IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gaXMgbG9hZGluZyB0b28gc2xvd2x5O1xuICAgICAgVGltZSB0byB1bmRlcmJ1ZmZlcjogJHtidWZmZXJTdGFydmF0aW9uRGVsYXkudG9GaXhlZCgzKX0gc1xuICAgICAgRXN0aW1hdGVkIGxvYWQgdGltZSBmb3IgY3VycmVudCBmcmFnbWVudDogJHtmcmFnTG9hZGVkRGVsYXkudG9GaXhlZCgzKX0gc1xuICAgICAgRXN0aW1hdGVkIGxvYWQgdGltZSBmb3IgZG93biBzd2l0Y2ggZnJhZ21lbnQ6ICR7ZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LnRvRml4ZWQoXG4gICAgICAgIDNcbiAgICAgICl9IHNcbiAgICAgIFRURkIgZXN0aW1hdGU6ICR7dHRmYn1cbiAgICAgIEN1cnJlbnQgQlcgZXN0aW1hdGU6ICR7XG4gICAgICAgIE51bWJlci5pc0Zpbml0ZShid0VzdGltYXRlKSA/IChid0VzdGltYXRlIC8gMTAyNCkudG9GaXhlZCgzKSA6ICdVbmtub3duJ1xuICAgICAgfSBLYi9zXG4gICAgICBOZXcgQlcgZXN0aW1hdGU6ICR7KHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKSAvIDEwMjQpLnRvRml4ZWQoXG4gICAgICAgIDNcbiAgICAgICl9IEtiL3NcbiAgICAgIEFib3J0aW5nIGFuZCBzd2l0Y2hpbmcgdG8gbGV2ZWwgJHtuZXh0TG9hZExldmVsfWApO1xuICAgIGlmIChmcmFnLmxvYWRlcikge1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICAgICAgZnJhZy5hYm9ydFJlcXVlc3RzKCk7XG4gICAgfVxuICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHsgZnJhZywgcGFydCwgc3RhdHMgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25GcmFnTG9hZGVkKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19MT0FERUQsXG4gICAgeyBmcmFnLCBwYXJ0IH06IEZyYWdMb2FkZWREYXRhXG4gICkge1xuICAgIGNvbnN0IHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIGlmIChmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQihzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlnbm9yZUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkXG4gICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcblxuICAgIC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5hYnJNYXhXaXRoUmVhbEJpdHJhdGUpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcGFydCA/IHBhcnQuZHVyYXRpb24gOiBmcmFnLmR1cmF0aW9uO1xuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICBjb25zdCBsb2FkZWRCeXRlcyA9XG4gICAgICAgIChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuYnl0ZXMgOiAwKSArIHN0YXRzLmxvYWRlZDtcbiAgICAgIGNvbnN0IGxvYWRlZER1cmF0aW9uID1cbiAgICAgICAgKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZHVyYXRpb247XG4gICAgICBsZXZlbC5sb2FkZWQgPSB7IGJ5dGVzOiBsb2FkZWRCeXRlcywgZHVyYXRpb246IGxvYWRlZER1cmF0aW9uIH07XG4gICAgICBsZXZlbC5yZWFsQml0cmF0ZSA9IE1hdGgucm91bmQoKDggKiBsb2FkZWRCeXRlcykgLyBsb2FkZWREdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICBjb25zdCBmcmFnQnVmZmVyZWREYXRhOiBGcmFnQnVmZmVyZWREYXRhID0ge1xuICAgICAgICBzdGF0cyxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgaWQ6IGZyYWcudHlwZSxcbiAgICAgIH07XG4gICAgICB0aGlzLm9uRnJhZ0J1ZmZlcmVkKEV2ZW50cy5GUkFHX0JVRkZFUkVELCBmcmFnQnVmZmVyZWREYXRhKTtcbiAgICAgIGZyYWcuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25GcmFnQnVmZmVyZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX0JVRkZFUkVELFxuICAgIGRhdGE6IEZyYWdCdWZmZXJlZERhdGFcbiAgKSB7XG4gICAgY29uc3QgeyBmcmFnLCBwYXJ0IH0gPSBkYXRhO1xuICAgIGNvbnN0IHN0YXRzID0gcGFydD8uc3RhdHMubG9hZGVkID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG5cbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBVc2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBwYXJzaW5nIGFuZCByZXF1ZXN0IGluc3RlYWQgb2YgYnVmZmVyaW5nIGFuZCByZXF1ZXN0IHRvIGNvbXB1dGUgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nO1xuICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGJ1ZmZlciBhcHBlbmRpbmcgb25seSBoYXBwZW5zIG9uY2UgbWVkaWEgaXMgYXR0YWNoZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaFxuICAgIC8vIGlzIHVzZWQuIElmIHdlIHVzZWQgYnVmZmVyaW5nIGluIHRoYXQgY2FzZSwgb3VyIEJXIGVzdGltYXRlIHNhbXBsZSB3aWxsIGJlIHZlcnkgbGFyZ2UuXG4gICAgY29uc3QgcHJvY2Vzc2luZ01zID1cbiAgICAgIHN0YXRzLnBhcnNpbmcuZW5kIC1cbiAgICAgIHN0YXRzLmxvYWRpbmcuc3RhcnQgLVxuICAgICAgTWF0aC5taW4oXG4gICAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0LFxuICAgICAgICB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpXG4gICAgICApO1xuICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHByb2Nlc3NpbmdNcywgc3RhdHMubG9hZGVkKTtcbiAgICBzdGF0cy5id0VzdGltYXRlID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpO1xuICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSBwcm9jZXNzaW5nTXMgLyAxMDAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaWdub3JlRnJhZ21lbnQoZnJhZzogRnJhZ21lbnQpOiBib29sZWFuIHtcbiAgICAvLyBPbmx5IGNvdW50IG5vbi1hbHQtYXVkaW8gZnJhZ3Mgd2hpY2ggd2VyZSBhY3R1YWxseSBidWZmZXJlZCBpbiBvdXIgQlcgY2FsY3VsYXRpb25zXG4gICAgcmV0dXJuIGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiB8fCBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnO1xuICB9XG5cbiAgcHVibGljIGNsZWFyVGltZXIoKSB7XG4gICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICB9XG5cbiAgLy8gcmV0dXJuIG5leHQgYXV0byBsZXZlbFxuICBnZXQgbmV4dEF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCBmb3JjZWRBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QXV0b0xldmVsO1xuICAgIGNvbnN0IGJ3RXN0aW1hdG9yID0gdGhpcy5id0VzdGltYXRvcjtcbiAgICAvLyBpbiBjYXNlIG5leHQgYXV0byBsZXZlbCBoYXMgYmVlbiBmb3JjZWQsIGFuZCBidyBub3QgYXZhaWxhYmxlIG9yIG5vdCByZWxpYWJsZSwgcmV0dXJuIGZvcmNlZCB2YWx1ZVxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmICFid0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICByZXR1cm4gZm9yY2VkQXV0b0xldmVsO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcbiAgICBsZXQgbmV4dEFCUkF1dG9MZXZlbCA9IHRoaXMuZ2V0TmV4dEFCUkF1dG9MZXZlbCgpO1xuICAgIC8vIHVzZSBmb3JjZWQgYXV0byBsZXZlbCB3aGVuIEFCUiBzZWxlY3RlZCBsZXZlbCBoYXMgZXJyb3JlZFxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICBpZiAoXG4gICAgICAgIGxldmVscy5sZW5ndGggPiBNYXRoLm1heChmb3JjZWRBdXRvTGV2ZWwsIG5leHRBQlJBdXRvTGV2ZWwpICYmXG4gICAgICAgIGxldmVsc1tmb3JjZWRBdXRvTGV2ZWxdLmxvYWRFcnJvciA8PSBsZXZlbHNbbmV4dEFCUkF1dG9MZXZlbF0ubG9hZEVycm9yXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgZm9yY2VkIGF1dG8gbGV2ZWwgaGFzIGJlZW4gZGVmaW5lZCwgdXNlIGl0IHRvIGNhcCBBQlIgY29tcHV0ZWQgcXVhbGl0eSBsZXZlbFxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICBuZXh0QUJSQXV0b0xldmVsID0gTWF0aC5taW4oZm9yY2VkQXV0b0xldmVsLCBuZXh0QUJSQXV0b0xldmVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dEFCUkF1dG9MZXZlbDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TmV4dEFCUkF1dG9MZXZlbCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgZnJhZ0N1cnJlbnQsIHBhcnRDdXJyZW50LCBobHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBtYXhBdXRvTGV2ZWwsIGNvbmZpZywgbWluQXV0b0xldmVsLCBtZWRpYSB9ID0gaGxzO1xuICAgIGNvbnN0IGN1cnJlbnRGcmFnRHVyYXRpb24gPSBwYXJ0Q3VycmVudFxuICAgICAgPyBwYXJ0Q3VycmVudC5kdXJhdGlvblxuICAgICAgOiBmcmFnQ3VycmVudFxuICAgICAgPyBmcmFnQ3VycmVudC5kdXJhdGlvblxuICAgICAgOiAwO1xuXG4gICAgLy8gcGxheWJhY2tSYXRlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgcGxheWJhY2sgcmF0ZTsgaWYgbWVkaWEucGxheWJhY2tSYXRlIGlzIDAsIHdlIHVzZSAxIHRvIGxvYWQgYXNcbiAgICAvLyBpZiB3ZSdyZSBwbGF5aW5nIGJhY2sgYXQgdGhlIG5vcm1hbCByYXRlLlxuICAgIGNvbnN0IHBsYXliYWNrUmF0ZSA9XG4gICAgICBtZWRpYSAmJiBtZWRpYS5wbGF5YmFja1JhdGUgIT09IDAgPyBNYXRoLmFicyhtZWRpYS5wbGF5YmFja1JhdGUpIDogMS4wO1xuICAgIGNvbnN0IGF2Z2J3ID0gdGhpcy5id0VzdGltYXRvclxuICAgICAgPyB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKClcbiAgICAgIDogY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGU7XG4gICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIHRoZSB3YWxsLWNsb2NrIHRpbWUgbGVmdCB1bnRpbCB0aGUgcGxheWJhY2sgYnVmZmVyIGlzIGV4aGF1c3RlZC5cbiAgICBjb25zdCBidWZmZXJJbmZvID0gaGxzLm1haW5Gb3J3YXJkQnVmZmVySW5mbztcbiAgICBjb25zdCBidWZmZXJTdGFydmF0aW9uRGVsYXkgPVxuICAgICAgKGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmxlbiA6IDApIC8gcGxheWJhY2tSYXRlO1xuXG4gICAgLy8gRmlyc3QsIGxvb2sgdG8gc2VlIGlmIHdlIGNhbiBmaW5kIGEgbGV2ZWwgbWF0Y2hpbmcgd2l0aCBvdXIgYXZnIGJhbmR3aWR0aCBBTkQgdGhhdCBjb3VsZCBhbHNvIGd1YXJhbnRlZSBubyByZWJ1ZmZlcmluZyBhdCBhbGxcbiAgICBsZXQgYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKFxuICAgICAgYXZnYncsXG4gICAgICBtaW5BdXRvTGV2ZWwsXG4gICAgICBtYXhBdXRvTGV2ZWwsXG4gICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXksXG4gICAgICBjb25maWcuYWJyQmFuZFdpZHRoRmFjdG9yLFxuICAgICAgY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yXG4gICAgKTtcbiAgICBpZiAoYmVzdExldmVsID49IDApIHtcbiAgICAgIHJldHVybiBiZXN0TGV2ZWw7XG4gICAgfVxuICAgIGxvZ2dlci50cmFjZShcbiAgICAgIGBbYWJyXSAke1xuICAgICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPyAncmVidWZmZXJpbmcgZXhwZWN0ZWQnIDogJ2J1ZmZlciBpcyBlbXB0eSdcbiAgICAgIH0sIGZpbmRpbmcgb3B0aW1hbCBxdWFsaXR5IGxldmVsYFxuICAgICk7XG4gICAgLy8gbm90IHBvc3NpYmxlIHRvIGdldCByaWQgb2YgcmVidWZmZXJpbmcgLi4uIGxldCdzIHRyeSB0byBmaW5kIGxldmVsIHRoYXQgd2lsbCBndWFyYW50ZWUgbGVzcyB0aGFuIG1heFN0YXJ2YXRpb25EZWxheSBvZiByZWJ1ZmZlcmluZ1xuICAgIC8vIGlmIG5vIG1hdGNoaW5nIGxldmVsIGZvdW5kLCBsb2dpYyB3aWxsIHJldHVybiAwXG4gICAgbGV0IG1heFN0YXJ2YXRpb25EZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb25cbiAgICAgID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSlcbiAgICAgIDogY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheTtcbiAgICBsZXQgYndGYWN0b3IgPSBjb25maWcuYWJyQmFuZFdpZHRoRmFjdG9yO1xuICAgIGxldCBid1VwRmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yO1xuXG4gICAgaWYgKCFidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgIC8vIGluIGNhc2UgYnVmZmVyIGlzIGVtcHR5LCBsZXQncyBjaGVjayBpZiBwcmV2aW91cyBmcmFnbWVudCB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3RcbiAgICAgIGNvbnN0IGJpdHJhdGVUZXN0RGVsYXkgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICBpZiAoYml0cmF0ZVRlc3REZWxheSkge1xuICAgICAgICAvLyBpZiBpdCBpcyB0aGUgY2FzZSwgdGhlbiB3ZSBuZWVkIHRvIGFkanVzdCBvdXIgbWF4IHN0YXJ2YXRpb24gZGVsYXkgdXNpbmcgbWF4TG9hZGluZ0RlbGF5IGNvbmZpZyB2YWx1ZVxuICAgICAgICAvLyBtYXggdmlkZW8gbG9hZGluZyBkZWxheSB1c2VkIGluICBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uIDpcbiAgICAgICAgLy8gaW4gdGhhdCBtb2RlIEFCUiBjb250cm9sbGVyIHdpbGwgZW5zdXJlIHRoYXQgdmlkZW8gbG9hZGluZyB0aW1lIChpZSB0aGUgdGltZSB0byBmZXRjaCB0aGUgZmlyc3QgZnJhZ21lbnQgYXQgbG93ZXN0IHF1YWxpdHkgbGV2ZWwgK1xuICAgICAgICAvLyB0aGUgdGltZSB0byBmZXRjaCB0aGUgZnJhZ21lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHF1YWxpdHkgbGV2ZWwgaXMgbGVzcyB0aGFuIGBgYG1heExvYWRpbmdEZWxheWBgYCApXG4gICAgICAgIC8vIGNhcCBtYXhMb2FkaW5nRGVsYXkgYW5kIGVuc3VyZSBpdCBpcyBub3QgYmlnZ2VyICd0aGFuIGJpdHJhdGUgdGVzdCcgZnJhZyBkdXJhdGlvblxuICAgICAgICBjb25zdCBtYXhMb2FkaW5nRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uXG4gICAgICAgICAgPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4TG9hZGluZ0RlbGF5KVxuICAgICAgICAgIDogY29uZmlnLm1heExvYWRpbmdEZWxheTtcbiAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID0gbWF4TG9hZGluZ0RlbGF5IC0gYml0cmF0ZVRlc3REZWxheTtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKFxuICAgICAgICAgIGBbYWJyXSBiaXRyYXRlIHRlc3QgdG9vayAke01hdGgucm91bmQoXG4gICAgICAgICAgICAxMDAwICogYml0cmF0ZVRlc3REZWxheVxuICAgICAgICAgICl9bXMsIHNldCBmaXJzdCBmcmFnbWVudCBtYXggZmV0Y2hEdXJhdGlvbiB0byAke01hdGgucm91bmQoXG4gICAgICAgICAgICAxMDAwICogbWF4U3RhcnZhdGlvbkRlbGF5XG4gICAgICAgICAgKX0gbXNgXG4gICAgICAgICk7XG4gICAgICAgIC8vIGRvbid0IHVzZSBjb25zZXJ2YXRpdmUgZmFjdG9yIG9uIGJpdHJhdGUgdGVzdFxuICAgICAgICBid0ZhY3RvciA9IGJ3VXBGYWN0b3IgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBiZXN0TGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwoXG4gICAgICBhdmdidyxcbiAgICAgIG1pbkF1dG9MZXZlbCxcbiAgICAgIG1heEF1dG9MZXZlbCxcbiAgICAgIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSArIG1heFN0YXJ2YXRpb25EZWxheSxcbiAgICAgIGJ3RmFjdG9yLFxuICAgICAgYndVcEZhY3RvclxuICAgICk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJlc3RMZXZlbCwgMCk7XG4gIH1cblxuICBwcml2YXRlIGZpbmRCZXN0TGV2ZWwoXG4gICAgY3VycmVudEJ3OiBudW1iZXIsXG4gICAgbWluQXV0b0xldmVsOiBudW1iZXIsXG4gICAgbWF4QXV0b0xldmVsOiBudW1iZXIsXG4gICAgbWF4RmV0Y2hEdXJhdGlvbjogbnVtYmVyLFxuICAgIGJ3RmFjdG9yOiBudW1iZXIsXG4gICAgYndVcEZhY3RvcjogbnVtYmVyXG4gICk6IG51bWJlciB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0N1cnJlbnQsXG4gICAgICBwYXJ0Q3VycmVudCxcbiAgICAgIGxhc3RMb2FkZWRGcmFnTGV2ZWw6IGN1cnJlbnRMZXZlbCxcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxldmVscyB9ID0gdGhpcy5obHM7XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbY3VycmVudExldmVsXTtcbiAgICBjb25zdCBsaXZlID0gISFsZXZlbD8uZGV0YWlscz8ubGl2ZTtcbiAgICBjb25zdCBjdXJyZW50Q29kZWNTZXQgPSBsZXZlbD8uY29kZWNTZXQ7XG5cbiAgICBjb25zdCBjdXJyZW50RnJhZ0R1cmF0aW9uID0gcGFydEN1cnJlbnRcbiAgICAgID8gcGFydEN1cnJlbnQuZHVyYXRpb25cbiAgICAgIDogZnJhZ0N1cnJlbnRcbiAgICAgID8gZnJhZ0N1cnJlbnQuZHVyYXRpb25cbiAgICAgIDogMDtcblxuICAgIGNvbnN0IHR0ZmJFc3RpbWF0ZVNlYyA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCkgLyAxMDAwO1xuICAgIGxldCBsZXZlbFNraXBwZWRNaW4gPSBtaW5BdXRvTGV2ZWw7XG4gICAgbGV0IGxldmVsU2tpcHBlZE1heCA9IC0xO1xuICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgIGNvbnN0IGxldmVsSW5mbyA9IGxldmVsc1tpXTtcblxuICAgICAgaWYgKFxuICAgICAgICAhbGV2ZWxJbmZvIHx8XG4gICAgICAgIChjdXJyZW50Q29kZWNTZXQgJiYgbGV2ZWxJbmZvLmNvZGVjU2V0ICE9PSBjdXJyZW50Q29kZWNTZXQpXG4gICAgICApIHtcbiAgICAgICAgaWYgKGxldmVsSW5mbykge1xuICAgICAgICAgIGxldmVsU2tpcHBlZE1pbiA9IE1hdGgubWluKGksIGxldmVsU2tpcHBlZE1pbik7XG4gICAgICAgICAgbGV2ZWxTa2lwcGVkTWF4ID0gTWF0aC5tYXgoaSwgbGV2ZWxTa2lwcGVkTWF4KTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbFNraXBwZWRNYXggIT09IC0xKSB7XG4gICAgICAgIGxvZ2dlci50cmFjZShcbiAgICAgICAgICBgW2Ficl0gU2tpcHBlZCBsZXZlbChzKSAke2xldmVsU2tpcHBlZE1pbn0tJHtsZXZlbFNraXBwZWRNYXh9IHdpdGggQ09ERUNTOlwiJHtsZXZlbHNbbGV2ZWxTa2lwcGVkTWF4XS5hdHRycy5DT0RFQ1N9XCI7IG5vdCBjb21wYXRpYmxlIHdpdGggXCIke2xldmVsLmF0dHJzLkNPREVDU31cImBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgICBjb25zdCBhdmdEdXJhdGlvbiA9XG4gICAgICAgIChwYXJ0Q3VycmVudFxuICAgICAgICAgID8gbGV2ZWxEZXRhaWxzPy5wYXJ0VGFyZ2V0XG4gICAgICAgICAgOiBsZXZlbERldGFpbHM/LmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbikgfHwgY3VycmVudEZyYWdEdXJhdGlvbjtcblxuICAgICAgbGV0IGFkanVzdGVkYnc6IG51bWJlcjtcbiAgICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXG4gICAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxuICAgICAgLy8gc3dpdGNoaW5nIGJhY2suXG4gICAgICBpZiAoaSA8PSBjdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3RmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3VXBGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJpdHJhdGU6IG51bWJlciA9IGxldmVsc1tpXS5tYXhCaXRyYXRlO1xuICAgICAgY29uc3QgZmV0Y2hEdXJhdGlvbjogbnVtYmVyID0gdGhpcy5nZXRUaW1lVG9Mb2FkRnJhZyhcbiAgICAgICAgdHRmYkVzdGltYXRlU2VjLFxuICAgICAgICBhZGp1c3RlZGJ3LFxuICAgICAgICBiaXRyYXRlICogYXZnRHVyYXRpb24sXG4gICAgICAgIGxldmVsRGV0YWlscyA9PT0gdW5kZWZpbmVkXG4gICAgICApO1xuXG4gICAgICBsb2dnZXIudHJhY2UoXG4gICAgICAgIGBbYWJyXSBsZXZlbDoke2l9IGFkanVzdGVkYnctYml0cmF0ZToke01hdGgucm91bmQoXG4gICAgICAgICAgYWRqdXN0ZWRidyAtIGJpdHJhdGVcbiAgICAgICAgKX0gYXZnRHVyYXRpb246JHthdmdEdXJhdGlvbi50b0ZpeGVkKFxuICAgICAgICAgIDFcbiAgICAgICAgKX0gbWF4RmV0Y2hEdXJhdGlvbjoke21heEZldGNoRHVyYXRpb24udG9GaXhlZChcbiAgICAgICAgICAxXG4gICAgICAgICl9IGZldGNoRHVyYXRpb246JHtmZXRjaER1cmF0aW9uLnRvRml4ZWQoMSl9YFxuICAgICAgKTtcbiAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgaWYgKFxuICAgICAgICBhZGp1c3RlZGJ3ID4gYml0cmF0ZSAmJlxuICAgICAgICAvLyBmcmFnbWVudCBmZXRjaER1cmF0aW9uIHVua25vd24gT1IgbGl2ZSBzdHJlYW0gT1IgZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiBsZXNzIHRoYW4gbWF4IGFsbG93ZWQgZmV0Y2ggZHVyYXRpb24sIHRoZW4gdGhpcyBsZXZlbCBtYXRjaGVzXG4gICAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBzdGFydExldmVsID0gLTEgKGJpdHJhdGVUZXN0KSBvbiBsaXZlIHN0cmVhbXMgOiBpbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIG5vdCBleGl0IGxvb3Agc28gdGhhdCBmaW5kQmVzdExldmVsIHdpbGwgcmV0dXJuIC0xXG4gICAgICAgIChmZXRjaER1cmF0aW9uID09PSAwIHx8XG4gICAgICAgICAgIU51bWJlci5pc0Zpbml0ZShmZXRjaER1cmF0aW9uKSB8fFxuICAgICAgICAgIChsaXZlICYmICF0aGlzLmJpdHJhdGVUZXN0RGVsYXkpIHx8XG4gICAgICAgICAgZmV0Y2hEdXJhdGlvbiA8IG1heEZldGNoRHVyYXRpb24pXG4gICAgICApIHtcbiAgICAgICAgLy8gYXMgd2UgYXJlIGxvb3BpbmcgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCwgdGhpcyB3aWxsIHJldHVybiB0aGUgYmVzdCBhY2hpZXZhYmxlIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vdCBlbm91Z2ggdGltZSBidWRnZXQgZXZlbiB3aXRoIHF1YWxpdHkgbGV2ZWwgMCAuLi4gcmVidWZmZXJpbmcgbWlnaHQgaGFwcGVuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgc2V0IG5leHRBdXRvTGV2ZWwobmV4dExldmVsKSB7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBYnJDb250cm9sbGVyO1xuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB0eXBlIHtcbiAgQnVmZmVyT3BlcmF0aW9uLFxuICBCdWZmZXJPcGVyYXRpb25RdWV1ZXMsXG4gIFNvdXJjZUJ1ZmZlcnMsXG4gIFNvdXJjZUJ1ZmZlck5hbWUsXG59IGZyb20gJy4uL3R5cGVzL2J1ZmZlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1ZmZlck9wZXJhdGlvblF1ZXVlIHtcbiAgcHJpdmF0ZSBidWZmZXJzOiBTb3VyY2VCdWZmZXJzO1xuICBwcml2YXRlIHF1ZXVlczogQnVmZmVyT3BlcmF0aW9uUXVldWVzID0ge1xuICAgIHZpZGVvOiBbXSxcbiAgICBhdWRpbzogW10sXG4gICAgYXVkaW92aWRlbzogW10sXG4gIH07XG5cbiAgY29uc3RydWN0b3Ioc291cmNlQnVmZmVyUmVmZXJlbmNlOiBTb3VyY2VCdWZmZXJzKSB7XG4gICAgdGhpcy5idWZmZXJzID0gc291cmNlQnVmZmVyUmVmZXJlbmNlO1xuICB9XG5cbiAgcHVibGljIGFwcGVuZChvcGVyYXRpb246IEJ1ZmZlck9wZXJhdGlvbiwgdHlwZTogU291cmNlQnVmZmVyTmFtZSkge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZXNbdHlwZV07XG4gICAgcXVldWUucHVzaChvcGVyYXRpb24pO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgdGhpcy5idWZmZXJzW3R5cGVdKSB7XG4gICAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBpbnNlcnRBYm9ydChvcGVyYXRpb246IEJ1ZmZlck9wZXJhdGlvbiwgdHlwZTogU291cmNlQnVmZmVyTmFtZSkge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZXNbdHlwZV07XG4gICAgcXVldWUudW5zaGlmdChvcGVyYXRpb24pO1xuICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gIH1cblxuICBwdWJsaWMgYXBwZW5kQmxvY2tlcih0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKTogUHJvbWlzZTx7fT4ge1xuICAgIGxldCBleGVjdXRlO1xuICAgIGNvbnN0IHByb21pc2U6IFByb21pc2U8e30+ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGV4ZWN1dGUgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IG9wZXJhdGlvbjogQnVmZmVyT3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZSxcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHt9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge30sXG4gICAgICBvbkVycm9yOiAoKSA9PiB7fSxcbiAgICB9O1xuXG4gICAgdGhpcy5hcHBlbmQob3BlcmF0aW9uLCB0eXBlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHB1YmxpYyBleGVjdXRlTmV4dCh0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSB7XG4gICAgY29uc3QgeyBidWZmZXJzLCBxdWV1ZXMgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2IgPSBidWZmZXJzW3R5cGVdO1xuICAgIGNvbnN0IHF1ZXVlID0gcXVldWVzW3R5cGVdO1xuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbjogQnVmZmVyT3BlcmF0aW9uID0gcXVldWVbMF07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBPcGVyYXRpb25zIGFyZSBleHBlY3RlZCB0byByZXN1bHQgaW4gYW4gJ3VwZGF0ZWVuZCcgZXZlbnQgYmVpbmcgZmlyZWQuIElmIG5vdCwgdGhlIHF1ZXVlIHdpbGwgbG9jay4gT3BlcmF0aW9uc1xuICAgICAgICAvLyB3aGljaCBkbyBub3QgZW5kIHdpdGggdGhpcyBldmVudCBtdXN0IGNhbGwgX29uU0JVcGRhdGVFbmQgbWFudWFsbHlcbiAgICAgICAgb3BlcmF0aW9uLmV4ZWN1dGUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgJ1tidWZmZXItb3BlcmF0aW9uLXF1ZXVlXTogVW5oYW5kbGVkIGV4Y2VwdGlvbiBleGVjdXRpbmcgdGhlIGN1cnJlbnQgb3BlcmF0aW9uJ1xuICAgICAgICApO1xuICAgICAgICBvcGVyYXRpb24ub25FcnJvcihlKTtcblxuICAgICAgICAvLyBPbmx5IHNoaWZ0IHRoZSBjdXJyZW50IG9wZXJhdGlvbiBvZmYsIG90aGVyd2lzZSB0aGUgdXBkYXRlZW5kIGhhbmRsZXIgd2lsbCBkbyB0aGlzIGZvciB1c1xuICAgICAgICBpZiAoIXNiPy51cGRhdGluZykge1xuICAgICAgICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUpIHtcbiAgICB0aGlzLnF1ZXVlc1t0eXBlXS5zaGlmdCgpO1xuICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gIH1cblxuICBwdWJsaWMgY3VycmVudCh0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWVzW3R5cGVdWzBdO1xuICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yRGV0YWlscywgRXJyb3JUeXBlcyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBCdWZmZXJIZWxwZXIgfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcbmltcG9ydCB7IGdldE1lZGlhU291cmNlIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyJztcbmltcG9ydCB7IEVsZW1lbnRhcnlTdHJlYW1UeXBlcyB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrU2V0IH0gZnJvbSAnLi4vdHlwZXMvdHJhY2snO1xuaW1wb3J0IEJ1ZmZlck9wZXJhdGlvblF1ZXVlIGZyb20gJy4vYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZSc7XG5pbXBvcnQge1xuICBCdWZmZXJPcGVyYXRpb24sXG4gIFNvdXJjZUJ1ZmZlcnMsXG4gIFNvdXJjZUJ1ZmZlck5hbWUsXG4gIFNvdXJjZUJ1ZmZlckxpc3RlbmVycyxcbn0gZnJvbSAnLi4vdHlwZXMvYnVmZmVyJztcbmltcG9ydCB0eXBlIHtcbiAgTGV2ZWxVcGRhdGVkRGF0YSxcbiAgQnVmZmVyQXBwZW5kaW5nRGF0YSxcbiAgTWVkaWFBdHRhY2hpbmdEYXRhLFxuICBNYW5pZmVzdFBhcnNlZERhdGEsXG4gIEJ1ZmZlckNvZGVjc0RhdGEsXG4gIEJ1ZmZlckVPU0RhdGEsXG4gIEJ1ZmZlckZsdXNoaW5nRGF0YSxcbiAgRnJhZ1BhcnNlZERhdGEsXG4gIEZyYWdDaGFuZ2VkRGF0YSxcbn0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSB7IENodW5rTWV0YWRhdGEgfSBmcm9tICcuLi90eXBlcy90cmFuc211eGVyJztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuaW1wb3J0IHR5cGUgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwtZGV0YWlscyc7XG5cbmNvbnN0IE1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcbmNvbnN0IFZJREVPX0NPREVDX1BST0ZJTEVfUkVQQUNFID0gLyhbaGFddmMuKSg/OlxcLlteLixdKykrLztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVmZmVyQ29udHJvbGxlciBpbXBsZW1lbnRzIENvbXBvbmVudEFQSSB7XG4gIC8vIFRoZSBsZXZlbCBkZXRhaWxzIHVzZWQgdG8gZGV0ZXJtaW5lIGR1cmF0aW9uLCB0YXJnZXQtZHVyYXRpb24gYW5kIGxpdmVcbiAgcHJpdmF0ZSBkZXRhaWxzOiBMZXZlbERldGFpbHMgfCBudWxsID0gbnVsbDtcbiAgLy8gY2FjaGUgdGhlIHNlbGYgZ2VuZXJhdGVkIG9iamVjdCB1cmwgdG8gZGV0ZWN0IGhpamFjayBvZiB2aWRlbyB0YWdcbiAgcHJpdmF0ZSBfb2JqZWN0VXJsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgLy8gQSBxdWV1ZSBvZiBidWZmZXIgb3BlcmF0aW9ucyB3aGljaCByZXF1aXJlIHRoZSBTb3VyY2VCdWZmZXIgdG8gbm90IGJlIHVwZGF0aW5nIHVwb24gZXhlY3V0aW9uXG4gIHByaXZhdGUgb3BlcmF0aW9uUXVldWUhOiBCdWZmZXJPcGVyYXRpb25RdWV1ZTtcbiAgLy8gUmVmZXJlbmNlcyB0byBldmVudCBsaXN0ZW5lcnMgZm9yIGVhY2ggU291cmNlQnVmZmVyLCBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlZmVyZW5jZWQgZm9yIGV2ZW50IHJlbW92YWxcbiAgcHJpdmF0ZSBsaXN0ZW5lcnMhOiBTb3VyY2VCdWZmZXJMaXN0ZW5lcnM7XG5cbiAgcHJpdmF0ZSBobHM6IEhscztcblxuICAvLyBUaGUgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWQgYmVmb3JlIGFueSBzb3VyY2VCdWZmZXJzIGFyZSBjcmVhdGVkXG4gIHB1YmxpYyBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkOiBudW1iZXIgPSAwO1xuXG4gIC8vIFRoZSB0b3RhbCBudW1iZXIgb2YgQlVGRkVSX0NPREVDIGV2ZW50cyByZWNlaXZlZFxuICBwcml2YXRlIF9idWZmZXJDb2RlY0V2ZW50c1RvdGFsOiBudW1iZXIgPSAwO1xuXG4gIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBhdHRhY2hlZCBtZWRpYSBlbGVtZW50XG4gIHB1YmxpYyBtZWRpYTogSFRNTE1lZGlhRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBhY3RpdmUgbWVkaWEgc291cmNlXG4gIHB1YmxpYyBtZWRpYVNvdXJjZTogTWVkaWFTb3VyY2UgfCBudWxsID0gbnVsbDtcblxuICAvLyBMYXN0IE1QMyBhdWRpbyBjaHVuayBhcHBlbmRlZFxuICBwcml2YXRlIGxhc3RNcGVnQXVkaW9DaHVuazogQ2h1bmtNZXRhZGF0YSB8IG51bGwgPSBudWxsO1xuXG4gIC8vIGNvdW50ZXJzXG4gIHB1YmxpYyBhcHBlbmRFcnJvcjogbnVtYmVyID0gMDtcblxuICBwdWJsaWMgdHJhY2tzOiBUcmFja1NldCA9IHt9O1xuICBwdWJsaWMgcGVuZGluZ1RyYWNrczogVHJhY2tTZXQgPSB7fTtcbiAgcHVibGljIHNvdXJjZUJ1ZmZlciE6IFNvdXJjZUJ1ZmZlcnM7XG5cbiAgY29uc3RydWN0b3IoaGxzOiBIbHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLl9pbml0U291cmNlQnVmZmVyKCk7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgcHVibGljIGhhc1NvdXJjZVR5cGVzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkubGVuZ3RoID4gMCB8fFxuICAgICAgT2JqZWN0LmtleXModGhpcy5wZW5kaW5nVHJhY2tzKS5sZW5ndGggPiAwXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgPSBudWxsO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCB0aGlzLm9uQnVmZmVyQXBwZW5kaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0VPUywgdGhpcy5vbkJ1ZmZlckVvcywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfUEFSU0VELCB0aGlzLm9uRnJhZ1BhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0NIQU5HRUQsIHRoaXMub25GcmFnQ2hhbmdlZCwgdGhpcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0VPUywgdGhpcy5vbkJ1ZmZlckVvcywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfUEFSU0VELCB0aGlzLm9uRnJhZ1BhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaW5pdFNvdXJjZUJ1ZmZlcigpIHtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgIHRoaXMub3BlcmF0aW9uUXVldWUgPSBuZXcgQnVmZmVyT3BlcmF0aW9uUXVldWUodGhpcy5zb3VyY2VCdWZmZXIpO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge1xuICAgICAgYXVkaW86IFtdLFxuICAgICAgdmlkZW86IFtdLFxuICAgICAgYXVkaW92aWRlbzogW10sXG4gICAgfTtcbiAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IG51bGw7XG4gIH1cblxuICBwcml2YXRlIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSAwO1xuICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NYW5pZmVzdFBhcnNlZChcbiAgICBldmVudDogRXZlbnRzLk1BTklGRVNUX1BBUlNFRCxcbiAgICBkYXRhOiBNYW5pZmVzdFBhcnNlZERhdGFcbiAgKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBhbHQgYXVkaW8gMiBCVUZGRVJfQ09ERUNTIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCwgb25lIHBlciBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIHNvdXJjZWJ1ZmZlcnMgd2lsbCBiZSBjcmVhdGVkIGFsbCBhdCBvbmNlIHdoZW4gdGhlIGV4cGVjdGVkIG5iIG9mIHRyYWNrcyB3aWxsIGJlIHJlYWNoZWRcbiAgICAvLyBpbiBjYXNlIGFsdCBhdWRpbyBpcyBub3QgdXNlZCwgb25seSBvbmUgQlVGRkVSX0NPREVDIGV2ZW50IHdpbGwgYmUgZmlyZWQgZnJvbSBtYWluIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gaXQgd2lsbCBjb250YWluIHRoZSBleHBlY3RlZCBuYiBvZiBzb3VyY2UgYnVmZmVycywgbm8gbmVlZCB0byBjb21wdXRlIGl0XG4gICAgbGV0IGNvZGVjRXZlbnRzOiBudW1iZXIgPSAyO1xuICAgIGlmICgoZGF0YS5hdWRpbyAmJiAhZGF0YS52aWRlbykgfHwgIWRhdGEuYWx0QXVkaW8gfHwgIV9fVVNFX0FMVF9BVURJT19fKSB7XG4gICAgICBjb2RlY0V2ZW50cyA9IDE7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSBjb2RlY0V2ZW50cztcbiAgICBsb2dnZXIubG9nKFxuICAgICAgYCR7dGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkfSBidWZmZXJDb2RlYyBldmVudChzKSBleHBlY3RlZGBcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFBdHRhY2hpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsXG4gICAgZGF0YTogTWVkaWFBdHRhY2hpbmdEYXRhXG4gICkge1xuICAgIGNvbnN0IG1lZGlhID0gKHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhKTtcbiAgICBpZiAobWVkaWEgJiYgTWVkaWFTb3VyY2UpIHtcbiAgICAgIGNvbnN0IG1zID0gKHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKSk7XG4gICAgICAvLyBNZWRpYVNvdXJjZSBsaXN0ZW5lcnMgYXJlIGFycm93IGZ1bmN0aW9ucyB3aXRoIGEgbGV4aWNhbCBzY29wZSwgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIGJvdW5kXG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UpO1xuICAgICAgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXG4gICAgICBtZWRpYS5zcmMgPSBzZWxmLlVSTC5jcmVhdGVPYmplY3RVUkwobXMpO1xuICAgICAgLy8gY2FjaGUgdGhlIGxvY2FsbHkgZ2VuZXJhdGVkIG9iamVjdCB1cmxcbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG1lZGlhLnNyYztcbiAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCB0aGlzLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgY29uc3QgeyBtZWRpYSwgbWVkaWFTb3VyY2UsIF9vYmplY3RVcmwgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICBsb2dnZXIubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBtZWRpYSBzb3VyY2UgZGV0YWNoaW5nJyk7XG4gICAgICBpZiAobWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gZW5kT2ZTdHJlYW0gY291bGQgdHJpZ2dlciBleGNlcHRpb24gaWYgYW55IHNvdXJjZWJ1ZmZlciBpcyBpbiB1cGRhdGluZyBzdGF0ZVxuICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IGNoZWNraW5nIHNvdXJjZWJ1ZmZlciBzdGF0ZSBoZXJlLFxuICAgICAgICAgIC8vIGFzIHdlIGFyZSBhbnl3YXkgZGV0YWNoaW5nIHRoZSBNZWRpYVNvdXJjZVxuICAgICAgICAgIC8vIGxldCdzIGp1c3QgYXZvaWQgdGhpcyBleGNlcHRpb24gdG8gcHJvcGFnYXRlXG4gICAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogb25NZWRpYURldGFjaGluZzogJHtlcnIubWVzc2FnZX0gd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDbGVhbiB1cCB0aGUgU291cmNlQnVmZmVycyBieSBpbnZva2luZyBvbkJ1ZmZlclJlc2V0XG4gICAgICB0aGlzLm9uQnVmZmVyUmVzZXQoKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSk7XG5cbiAgICAgIC8vIERldGFjaCBwcm9wZXJseSB0aGUgTWVkaWFTb3VyY2UgZnJvbSB0aGUgSFRNTE1lZGlhRWxlbWVudCBhc1xuICAgICAgLy8gc3VnZ2VzdGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvbWVkaWEtc291cmNlL2lzc3Vlcy81My5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbXB0aWVkJywgdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgICAgICBpZiAoX29iamVjdFVybCkge1xuICAgICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTChfb2JqZWN0VXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFuIHVwIHZpZGVvIHRhZyBzcmMgb25seSBpZiBpdCdzIG91ciBvd24gdXJsLiBzb21lIGV4dGVybmFsIGxpYnJhcmllcyBtaWdodFxuICAgICAgICAvLyBoaWphY2sgdGhlIHZpZGVvIHRhZyBhbmQgY2hhbmdlIGl0cyAnc3JjJyB3aXRob3V0IGRlc3Ryb3lpbmcgdGhlIEhscyBpbnN0YW5jZSBmaXJzdFxuICAgICAgICBpZiAobWVkaWEuc3JjID09PSBfb2JqZWN0VXJsKSB7XG4gICAgICAgICAgbWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICBtZWRpYS5sb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAnW2J1ZmZlci1jb250cm9sbGVyXTogbWVkaWEuc3JjIHdhcyBjaGFuZ2VkIGJ5IGEgdGhpcmQgcGFydHkgLSBza2lwIGNsZWFudXAnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWw7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgIHRoaXMudHJhY2tzID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUVESUFfREVUQUNIRUQsIHVuZGVmaW5lZCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25CdWZmZXJSZXNldCgpIHtcbiAgICB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzYikge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQnVmZmVyTGlzdGVuZXJzKHR5cGUpO1xuICAgICAgICAgIGlmICh0aGlzLm1lZGlhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFN5bmNocm9ub3VzbHkgcmVtb3ZlIHRoZSBTQiBmcm9tIHRoZSBtYXAgYmVmb3JlIHRoZSBuZXh0IGNhbGwgaW4gb3JkZXIgdG8gcHJldmVudCBhbiBhc3luYyBmdW5jdGlvbiBmcm9tXG4gICAgICAgICAgLy8gYWNjZXNzaW5nIGl0XG4gICAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIHRvIHJlc2V0IHRoZSAke3R5cGV9IGJ1ZmZlcmAsXG4gICAgICAgICAgZXJyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQnVmZmVyQ29kZWNzKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0NPREVDUyxcbiAgICBkYXRhOiBCdWZmZXJDb2RlY3NEYXRhXG4gICkge1xuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlckNvdW50ID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aDtcblxuICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goKHRyYWNrTmFtZSkgPT4ge1xuICAgICAgaWYgKHNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIFNvdXJjZUJ1ZmZlciBjb2RlYyBuZWVkcyB0byBjaGFuZ2VcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICBpZiAodHJhY2sgJiYgdHlwZW9mIHRyYWNrLmJ1ZmZlci5jaGFuZ2VUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc3QgeyBpZCwgY29kZWMsIGxldmVsQ29kZWMsIGNvbnRhaW5lciwgbWV0YWRhdGEgfSA9XG4gICAgICAgICAgICBkYXRhW3RyYWNrTmFtZV07XG4gICAgICAgICAgY29uc3QgY3VycmVudENvZGVjID0gKHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWMpLnJlcGxhY2UoXG4gICAgICAgICAgICBWSURFT19DT0RFQ19QUk9GSUxFX1JFUEFDRSxcbiAgICAgICAgICAgICckMSdcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IG5leHRDb2RlYyA9IChsZXZlbENvZGVjIHx8IGNvZGVjKS5yZXBsYWNlKFxuICAgICAgICAgICAgVklERU9fQ09ERUNfUFJPRklMRV9SRVBBQ0UsXG4gICAgICAgICAgICAnJDEnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoY3VycmVudENvZGVjICE9PSBuZXh0Q29kZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbWVUeXBlID0gYCR7Y29udGFpbmVyfTtjb2RlY3M9JHtsZXZlbENvZGVjIHx8IGNvZGVjfWA7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoYW5nZVR5cGUodHJhY2tOYW1lLCBtaW1lVHlwZSk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogc3dpdGNoaW5nIGNvZGVjICR7Y3VycmVudENvZGVjfSB0byAke25leHRDb2RlY31gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy50cmFja3NbdHJhY2tOYW1lXSA9IHtcbiAgICAgICAgICAgICAgYnVmZmVyOiB0cmFjay5idWZmZXIsXG4gICAgICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICAgIGxldmVsQ29kZWMsXG4gICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBzb3VyY2UgYnVmZmVyKHMpIG5vdCBjcmVhdGVkIHlldCwgYXBwZW5kZWQgYnVmZmVyIHRyYWNrcyBpbiB0aGlzLnBlbmRpbmdUcmFja3NcbiAgICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzW3RyYWNrTmFtZV0gPSBkYXRhW3RyYWNrTmFtZV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiBzb3VyY2VidWZmZXJzIGFscmVhZHkgY3JlYXRlZCwgZG8gbm90aGluZyAuLi5cbiAgICBpZiAoc291cmNlQnVmZmVyQ291bnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSBNYXRoLm1heChcbiAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCAtIDEsXG4gICAgICAwXG4gICAgKTtcbiAgICBpZiAodGhpcy5tZWRpYVNvdXJjZSAmJiB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgYXBwZW5kQ2hhbmdlVHlwZSh0eXBlLCBtaW1lVHlwZSkge1xuICAgIGNvbnN0IHsgb3BlcmF0aW9uUXVldWUgfSA9IHRoaXM7XG4gICAgY29uc3Qgb3BlcmF0aW9uOiBCdWZmZXJPcGVyYXRpb24gPSB7XG4gICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgIGlmIChzYikge1xuICAgICAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogY2hhbmdpbmcgJHt0eXBlfSBzb3VyY2VCdWZmZXIgdHlwZSB0byAke21pbWVUeXBlfWBcbiAgICAgICAgICApO1xuICAgICAgICAgIHNiLmNoYW5nZVR5cGUobWltZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogKCkgPT4ge30sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7fSxcbiAgICAgIG9uRXJyb3I6IChlKSA9PiB7XG4gICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgIGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBGYWlsZWQgdG8gY2hhbmdlICR7dHlwZX0gU291cmNlQnVmZmVyIHR5cGVgLFxuICAgICAgICAgIGVcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChvcGVyYXRpb24sIHR5cGUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQnVmZmVyQXBwZW5kaW5nKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0FQUEVORElORyxcbiAgICBldmVudERhdGE6IEJ1ZmZlckFwcGVuZGluZ0RhdGFcbiAgKSB7XG4gICAgY29uc3QgeyBobHMsIG9wZXJhdGlvblF1ZXVlLCB0cmFja3MgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBkYXRhLCB0eXBlLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEgfSA9IGV2ZW50RGF0YTtcbiAgICBjb25zdCBjaHVua1N0YXRzID0gY2h1bmtNZXRhLmJ1ZmZlcmluZ1t0eXBlXTtcblxuICAgIGNvbnN0IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjaHVua1N0YXRzLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgY29uc3QgZnJhZ0J1ZmZlcmluZyA9IGZyYWcuc3RhdHMuYnVmZmVyaW5nO1xuICAgIGNvbnN0IHBhcnRCdWZmZXJpbmcgPSBwYXJ0ID8gcGFydC5zdGF0cy5idWZmZXJpbmcgOiBudWxsO1xuICAgIGlmIChmcmFnQnVmZmVyaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBmcmFnQnVmZmVyaW5nLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgfVxuICAgIGlmIChwYXJ0QnVmZmVyaW5nICYmIHBhcnRCdWZmZXJpbmcuc3RhcnQgPT09IDApIHtcbiAgICAgIHBhcnRCdWZmZXJpbmcuc3RhcnQgPSBidWZmZXJBcHBlbmRpbmdTdGFydDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBPbmx5IHVwZGF0ZSB0aW1lc3RhbXBPZmZzZXQgd2hlbiBhdWRpby9tcGVnIGZyYWdtZW50IG9yIHBhcnQgaXMgbm90IGNvbnRpZ3VvdXMgd2l0aCBwcmV2aW91c2x5IGFwcGVuZGVkXG4gICAgLy8gQWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCAoZGVzaXJlZCBwb2ludCBpbiB0aGUgdGltZWxpbmUgd2hlcmUgdGhlIG5leHQgZnJhbWVzIHNob3VsZCBiZSBhcHBlbmRlZClcbiAgICAvLyBpbiBDaHJvbWUgYnJvd3NlciB3aGVuIHdlIGRldGVjdCBNUEVHIGF1ZGlvIGNvbnRhaW5lciBhbmQgdGltZSBkZWx0YSBiZXR3ZWVuIGxldmVsIFBUUyBhbmQgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgXG4gICAgLy8gaXMgZ3JlYXRlciB0aGFuIDEwMG1zICh0aGlzIGlzIGVub3VnaCB0byBoYW5kbGUgc2VlayBmb3IgVk9EIG9yIGxldmVsIGNoYW5nZSBmb3IgTElWRSB2aWRlb3MpLlxuICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzMyI2lzc3VlY29tbWVudC0yNTc5ODY0ODZcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgIGxldCBjaGVja1RpbWVzdGFtcE9mZnNldCA9IGZhbHNlO1xuICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIGF1ZGlvVHJhY2s/LmNvbnRhaW5lciA9PT0gJ2F1ZGlvL21wZWcnKSB7XG4gICAgICBjaGVja1RpbWVzdGFtcE9mZnNldCA9XG4gICAgICAgICF0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayB8fFxuICAgICAgICBjaHVua01ldGEuaWQgPT09IDEgfHxcbiAgICAgICAgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsuc24gIT09IGNodW5rTWV0YS5zbjtcbiAgICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gY2h1bmtNZXRhO1xuICAgIH1cblxuICAgIGNvbnN0IGZyYWdTdGFydCA9IGZyYWcuc3RhcnQ7XG4gICAgY29uc3Qgb3BlcmF0aW9uOiBCdWZmZXJPcGVyYXRpb24gPSB7XG4gICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgIGNodW5rU3RhdHMuZXhlY3V0ZVN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaWYgKGNoZWNrVGltZXN0YW1wT2Zmc2V0KSB7XG4gICAgICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZnJhZ1N0YXJ0IC0gc2IudGltZXN0YW1wT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAwLjEpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogVXBkYXRpbmcgYXVkaW8gU291cmNlQnVmZmVyIHRpbWVzdGFtcE9mZnNldCB0byAke2ZyYWdTdGFydH0gKGRlbHRhOiAke2RlbHRhfSkgc246ICR7ZnJhZy5zbn0pYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzYi50aW1lc3RhbXBPZmZzZXQgPSBmcmFnU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwZW5kRXhlY3V0b3IoZGF0YSwgdHlwZSk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gU291cmNlQnVmZmVyIHVwZGF0ZXN0YXJ0YCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gU291cmNlQnVmZmVyIHVwZGF0ZWVuZGApO1xuICAgICAgICBjb25zdCBlbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjaHVua1N0YXRzLmV4ZWN1dGVFbmQgPSBjaHVua1N0YXRzLmVuZCA9IGVuZDtcbiAgICAgICAgaWYgKGZyYWdCdWZmZXJpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICBmcmFnQnVmZmVyaW5nLmZpcnN0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0QnVmZmVyaW5nICYmIHBhcnRCdWZmZXJpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICBwYXJ0QnVmZmVyaW5nLmZpcnN0ID0gZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzb3VyY2VCdWZmZXIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRpbWVSYW5nZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgIHRpbWVSYW5nZXNbdHlwZV0gPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc291cmNlQnVmZmVyW3R5cGVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICAgIHRpbWVSYW5nZXMsXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IChlcnIpID0+IHtcbiAgICAgICAgLy8gaW4gY2FzZSBhbnkgZXJyb3Igb2NjdXJlZCB3aGlsZSBhcHBlbmRpbmcsIHB1dCBiYWNrIHNlZ21lbnQgaW4gc2VnbWVudHMgdGFibGVcbiAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgIGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG8gYXBwZW5kIHRvIHRoZSAke3R5cGV9IFNvdXJjZUJ1ZmZlcmAsXG4gICAgICAgICAgZXJyXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBwYXJ0LFxuICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBET01FeGNlcHRpb24uUVVPVEFfRVhDRUVERURfRVJSKSB7XG4gICAgICAgICAgLy8gUXVvdGFFeGNlZWRlZEVycm9yOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3F1b3RhZXhjZWVkZWRlcnJvclxuICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcisrO1xuICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjtcbiAgICAgICAgICAvKiB3aXRoIFVIRCBjb250ZW50LCB3ZSBjb3VsZCBnZXQgbG9vcCBvZiBxdW90YSBleGNlZWRlZCBlcnJvciB1bnRpbFxuICAgICAgICAgICAgYnJvd3NlciBpcyBhYmxlIHRvIGV2aWN0IHNvbWUgZGF0YSBmcm9tIHNvdXJjZWJ1ZmZlci4gUmV0cnlpbmcgY2FuIGhlbHAgcmVjb3Zlci5cbiAgICAgICAgICAqL1xuICAgICAgICAgIGlmICh0aGlzLmFwcGVuZEVycm9yID4gaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgIGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBGYWlsZWQgJHtobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnl9IHRpbWVzIHRvIGFwcGVuZCBzZWdtZW50IGluIHNvdXJjZUJ1ZmZlcmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBldmVudC5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICB9O1xuICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChvcGVyYXRpb24sIHR5cGUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQnVmZmVyRmx1c2hpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsXG4gICAgZGF0YTogQnVmZmVyRmx1c2hpbmdEYXRhXG4gICkge1xuICAgIGNvbnN0IHsgb3BlcmF0aW9uUXVldWUgfSA9IHRoaXM7XG4gICAgY29uc3QgZmx1c2hPcGVyYXRpb24gPSAodHlwZTogU291cmNlQnVmZmVyTmFtZSk6IEJ1ZmZlck9wZXJhdGlvbiA9PiAoe1xuICAgICAgZXhlY3V0ZTogdGhpcy5yZW1vdmVFeGVjdXRvci5iaW5kKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0eXBlLFxuICAgICAgICBkYXRhLnN0YXJ0T2Zmc2V0LFxuICAgICAgICBkYXRhLmVuZE9mZnNldFxuICAgICAgKSxcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBTdGFydGVkIGZsdXNoaW5nICR7ZGF0YS5zdGFydE9mZnNldH0gLT4gJHtkYXRhLmVuZE9mZnNldH0gZm9yICR7dHlwZX0gU291cmNlIEJ1ZmZlcmApO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBGaW5pc2hlZCBmbHVzaGluZyAke2RhdGEuc3RhcnRPZmZzZXR9IC0+ICR7ZGF0YS5lbmRPZmZzZXR9IGZvciAke3R5cGV9IFNvdXJjZSBCdWZmZXJgKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHsgdHlwZSB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAoZSkgPT4ge1xuICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIHRvIHJlbW92ZSBmcm9tICR7dHlwZX0gU291cmNlQnVmZmVyYCxcbiAgICAgICAgICBlXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKGRhdGEudHlwZSkge1xuICAgICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKGZsdXNoT3BlcmF0aW9uKGRhdGEudHlwZSksIGRhdGEudHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKCh0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSA9PiB7XG4gICAgICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChmbHVzaE9wZXJhdGlvbih0eXBlKSwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25GcmFnUGFyc2VkKGV2ZW50OiBFdmVudHMuRlJBR19QQVJTRUQsIGRhdGE6IEZyYWdQYXJzZWREYXRhKSB7XG4gICAgY29uc3QgeyBmcmFnLCBwYXJ0IH0gPSBkYXRhO1xuICAgIGNvbnN0IGJ1ZmZlcnNBcHBlbmRlZFRvOiBBcnJheTxTb3VyY2VCdWZmZXJOYW1lPiA9IFtdO1xuICAgIGNvbnN0IGVsZW1lbnRhcnlTdHJlYW1zID0gcGFydFxuICAgICAgPyBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zXG4gICAgICA6IGZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXSkge1xuICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgnYXVkaW92aWRlbycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSkge1xuICAgICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCdhdWRpbycpO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10pIHtcbiAgICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgndmlkZW8nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvblVuYmxvY2tlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBmcmFnLnN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBub3c7XG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBwYXJ0LnN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBub3c7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIGlkOiBmcmFnLnR5cGUsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKGJ1ZmZlcnNBcHBlbmRlZFRvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgIGBGcmFnbWVudHMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBFbGVtZW50YXJ5U3RyZWFtVHlwZSBzZXQuIHR5cGU6ICR7ZnJhZy50eXBlfSBsZXZlbDogJHtmcmFnLmxldmVsfSBzbjogJHtmcmFnLnNufWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5ibG9ja0J1ZmZlcnMob25VbmJsb2NrZWQsIGJ1ZmZlcnNBcHBlbmRlZFRvKTtcbiAgfVxuXG4gIHByaXZhdGUgb25GcmFnQ2hhbmdlZChldmVudDogRXZlbnRzLkZSQUdfQ0hBTkdFRCwgZGF0YTogRnJhZ0NoYW5nZWREYXRhKSB7XG4gICAgdGhpcy5mbHVzaEJhY2tCdWZmZXIoKTtcbiAgfVxuXG4gIC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgZW5kZWQgYW5kIHRyaWdnZXIgY2hlY2tFb3MoKVxuICAvLyBhbiB1bmRlZmluZWQgZGF0YS50eXBlIHdpbGwgbWFyayBhbGwgYnVmZmVycyBhcyBFT1MuXG4gIHByb3RlY3RlZCBvbkJ1ZmZlckVvcyhldmVudDogRXZlbnRzLkJVRkZFUl9FT1MsIGRhdGE6IEJ1ZmZlckVPU0RhdGEpIHtcbiAgICBjb25zdCBlbmRlZCA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5yZWR1Y2UoKGFjYywgdHlwZSkgPT4ge1xuICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgIGlmIChzYiAmJiAoIWRhdGEudHlwZSB8fCBkYXRhLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgICAgIHNiLmVuZGluZyA9IHRydWU7XG4gICAgICAgIGlmICghc2IuZW5kZWQpIHtcbiAgICAgICAgICBzYi5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgW2J1ZmZlci1jb250cm9sbGVyXTogJHt0eXBlfSBzb3VyY2VCdWZmZXIgbm93IEVPU2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICYmICEhKCFzYiB8fCBzYi5lbmRlZCk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBpZiAoZW5kZWQpIHtcbiAgICAgIGxvZ2dlci5sb2coYFtidWZmZXItY29udHJvbGxlcl06IFF1ZXVlaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKClgKTtcbiAgICAgIHRoaXMuYmxvY2tCdWZmZXJzKCgpID0+IHtcbiAgICAgICAgdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICBjb25zdCBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgc2IuZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBtZWRpYVNvdXJjZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFtZWRpYVNvdXJjZSB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgICAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogQ291bGQgbm90IGNhbGwgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKS4gbWVkaWFTb3VyY2UucmVhZHlTdGF0ZTogJHttZWRpYVNvdXJjZS5yZWFkeVN0YXRlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIubG9nKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBDYWxsaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKClgKTtcbiAgICAgICAgLy8gQWxsb3cgdGhpcyB0byB0aHJvdyBhbmQgYmUgY2F1Z2h0IGJ5IHRoZSBlbnF1ZXVlaW5nIGZ1bmN0aW9uXG4gICAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25MZXZlbFVwZGF0ZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTF9VUERBVEVELFxuICAgIHsgZGV0YWlscyB9OiBMZXZlbFVwZGF0ZWREYXRhXG4gICkge1xuICAgIGlmICghZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG5cbiAgICBpZiAodGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aCkge1xuICAgICAgdGhpcy5ibG9ja0J1ZmZlcnModGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoQmFja0J1ZmZlcigpIHtcbiAgICBjb25zdCB7IGhscywgZGV0YWlscywgbWVkaWEsIHNvdXJjZUJ1ZmZlciB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhIHx8IGRldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VCdWZmZXJUeXBlcyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtcbiAgICBpZiAoIXNvdXJjZUJ1ZmZlclR5cGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgZm9yIGRlcHJlY2F0ZWQgbGl2ZUJhY2tCdWZmZXJMZW5ndGhcbiAgICBjb25zdCBiYWNrQnVmZmVyTGVuZ3RoID1cbiAgICAgIGRldGFpbHMubGl2ZSAmJiBobHMuY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoICE9PSBudWxsXG4gICAgICAgID8gaGxzLmNvbmZpZy5saXZlQmFja0J1ZmZlckxlbmd0aFxuICAgICAgICA6IGhscy5jb25maWcuYmFja0J1ZmZlckxlbmd0aDtcblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGJhY2tCdWZmZXJMZW5ndGgpIHx8IGJhY2tCdWZmZXJMZW5ndGggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCB0YXJnZXREdXJhdGlvbiA9IGRldGFpbHMubGV2ZWxUYXJnZXREdXJhdGlvbjtcbiAgICBjb25zdCBtYXhCYWNrQnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoYmFja0J1ZmZlckxlbmd0aCwgdGFyZ2V0RHVyYXRpb24pO1xuICAgIGNvbnN0IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA9XG4gICAgICBNYXRoLmZsb29yKGN1cnJlbnRUaW1lIC8gdGFyZ2V0RHVyYXRpb24pICogdGFyZ2V0RHVyYXRpb24gLVxuICAgICAgbWF4QmFja0J1ZmZlckxlbmd0aDtcbiAgICBzb3VyY2VCdWZmZXJUeXBlcy5mb3JFYWNoKCh0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSA9PiB7XG4gICAgICBjb25zdCBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgIGlmIChzYikge1xuICAgICAgICBjb25zdCBidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChzYik7XG4gICAgICAgIC8vIHdoZW4gdGFyZ2V0IGJ1ZmZlciBzdGFydCBleGNlZWRzIGFjdHVhbCBidWZmZXIgc3RhcnRcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGJ1ZmZlcmVkLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPiBidWZmZXJlZC5zdGFydCgwKVxuICAgICAgICApIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQkFDS19CVUZGRVJfUkVBQ0hFRCwge1xuICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0IGZvciBkZXByZWNhdGVkIGV2ZW50OlxuICAgICAgICAgIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5MSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgc2IuZW5kZWQgJiZcbiAgICAgICAgICAgIGJ1ZmZlcmVkLmVuZChidWZmZXJlZC5sZW5ndGggLSAxKSAtIGN1cnJlbnRUaW1lIDwgdGFyZ2V0RHVyYXRpb24gKiAyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgYFtidWZmZXItY29udHJvbGxlcl06IENhbm5vdCBmbHVzaCAke3R5cGV9IGJhY2sgYnVmZmVyIHdoaWxlIFNvdXJjZUJ1ZmZlciBpcyBpbiBlbmRlZCBzdGF0ZWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbixcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvIGN1cnJlbnQgbGV2ZWwgZHVyYXRpb24gb3Igb3ZlcnJpZGUgdG8gSW5maW5pdHkgaWYgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJcbiAgICogJ2xpdmVEdXJhdGlvbkluZmluaXR5YCBpcyBzZXQgdG8gYHRydWVgXG4gICAqIE1vcmUgZGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzM1NVxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpIHtcbiAgICBpZiAoXG4gICAgICAhdGhpcy5kZXRhaWxzIHx8XG4gICAgICAhdGhpcy5tZWRpYSB8fFxuICAgICAgIXRoaXMubWVkaWFTb3VyY2UgfHxcbiAgICAgIHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGV0YWlscywgaGxzLCBtZWRpYSwgbWVkaWFTb3VyY2UgfSA9IHRoaXM7XG4gICAgY29uc3QgbGV2ZWxEdXJhdGlvbiA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0ICsgZGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgIGNvbnN0IG1lZGlhRHVyYXRpb24gPSBtZWRpYS5kdXJhdGlvbjtcbiAgICBjb25zdCBtc0R1cmF0aW9uID0gTnVtYmVyLmlzRmluaXRlKG1lZGlhU291cmNlLmR1cmF0aW9uKVxuICAgICAgPyBtZWRpYVNvdXJjZS5kdXJhdGlvblxuICAgICAgOiAwO1xuXG4gICAgaWYgKGRldGFpbHMubGl2ZSAmJiBobHMuY29uZmlnLmxpdmVEdXJhdGlvbkluZmluaXR5KSB7XG4gICAgICAvLyBPdmVycmlkZSBkdXJhdGlvbiB0byBJbmZpbml0eVxuICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgJ1tidWZmZXItY29udHJvbGxlcl06IE1lZGlhIFNvdXJjZSBkdXJhdGlvbiBpcyBzZXQgdG8gSW5maW5pdHknXG4gICAgICApO1xuICAgICAgbWVkaWFTb3VyY2UuZHVyYXRpb24gPSBJbmZpbml0eTtcbiAgICAgIHRoaXMudXBkYXRlU2Vla2FibGVSYW5nZShkZXRhaWxzKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgKGxldmVsRHVyYXRpb24gPiBtc0R1cmF0aW9uICYmIGxldmVsRHVyYXRpb24gPiBtZWRpYUR1cmF0aW9uKSB8fFxuICAgICAgIU51bWJlci5pc0Zpbml0ZShtZWRpYUR1cmF0aW9uKVxuICAgICkge1xuICAgICAgLy8gbGV2ZWxEdXJhdGlvbiB3YXMgdGhlIGxhc3QgdmFsdWUgd2Ugc2V0LlxuICAgICAgLy8gbm90IHVzaW5nIG1lZGlhU291cmNlLmR1cmF0aW9uIGFzIHRoZSBicm93c2VyIG1heSB0d2VhayB0aGlzIHZhbHVlXG4gICAgICAvLyBvbmx5IHVwZGF0ZSBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaWYgaXRzIHZhbHVlIGluY3JlYXNlLCB0aGlzIGlzIHRvIGF2b2lkXG4gICAgICAvLyBmbHVzaGluZyBhbHJlYWR5IGJ1ZmZlcmVkIHBvcnRpb24gd2hlbiBzd2l0Y2hpbmcgYmV0d2VlbiBxdWFsaXR5IGxldmVsXG4gICAgICBsb2dnZXIubG9nKFxuICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogVXBkYXRpbmcgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvICR7bGV2ZWxEdXJhdGlvbi50b0ZpeGVkKFxuICAgICAgICAgIDNcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgICAgbWVkaWFTb3VyY2UuZHVyYXRpb24gPSBsZXZlbER1cmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVNlZWthYmxlUmFuZ2UobGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3QgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3QgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBpZiAobGVuICYmIGxldmVsRGV0YWlscy5saXZlICYmIG1lZGlhU291cmNlPy5zZXRMaXZlU2Vla2FibGVSYW5nZSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBmcmFnbWVudHNbMF0uc3RhcnQpO1xuICAgICAgY29uc3QgZW5kID0gTWF0aC5tYXgoc3RhcnQsIHN0YXJ0ICsgbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgICAgbWVkaWFTb3VyY2Uuc2V0TGl2ZVNlZWthYmxlUmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrUGVuZGluZ1RyYWNrcygpIHtcbiAgICBjb25zdCB7IGJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQsIG9wZXJhdGlvblF1ZXVlLCBwZW5kaW5nVHJhY2tzIH0gPSB0aGlzO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UndmUgcmVjZWl2ZWQgYWxsIG9mIHRoZSBleHBlY3RlZCBidWZmZXJDb2RlYyBldmVudHMuIFdoZW4gbm9uZSByZW1haW4sIGNyZWF0ZSBhbGwgdGhlIHNvdXJjZUJ1ZmZlcnMgYXQgb25jZS5cbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBNU0Ugc3BlYyBhbGxvd3MgaW1wbGVtZW50YXRpb25zIHRvIHRocm93IFF1b3RhRXhjZWVkZWRFcnJvcnMgaWYgY3JlYXRpbmcgbmV3IHNvdXJjZUJ1ZmZlcnMgYWZ0ZXJcbiAgICAvLyBkYXRhIGhhcyBiZWVuIGFwcGVuZGVkIHRvIGV4aXN0aW5nIG9uZXMuXG4gICAgLy8gMiB0cmFja3MgaXMgdGhlIG1heCAob25lIGZvciBhdWRpbywgb25lIGZvciB2aWRlbykuIElmIHdlJ3ZlIHJlYWNoIHRoaXMgbWF4IGdvIGFoZWFkIGFuZCBjcmVhdGUgdGhlIGJ1ZmZlcnMuXG4gICAgY29uc3QgcGVuZGluZ1RyYWNrc0NvdW50ID0gT2JqZWN0LmtleXMocGVuZGluZ1RyYWNrcykubGVuZ3RoO1xuICAgIGlmIChcbiAgICAgIChwZW5kaW5nVHJhY2tzQ291bnQgJiYgIWJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQpIHx8XG4gICAgICBwZW5kaW5nVHJhY2tzQ291bnQgPT09IDJcbiAgICApIHtcbiAgICAgIC8vIG9rLCBsZXQncyBjcmVhdGUgdGhlbSBub3cgIVxuICAgICAgdGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJzKHBlbmRpbmdUcmFja3MpO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICAvLyBhcHBlbmQgYW55IHBlbmRpbmcgc2VnbWVudHMgbm93ICFcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCk7XG4gICAgICBpZiAoYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHsgdHJhY2tzOiB0aGlzLnRyYWNrcyB9KTtcbiAgICAgICAgYnVmZmVycy5mb3JFYWNoKCh0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSA9PiB7XG4gICAgICAgICAgb3BlcmF0aW9uUXVldWUuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2NvdWxkIG5vdCBjcmVhdGUgc291cmNlIGJ1ZmZlciBmb3IgbWVkaWEgY29kZWMocyknXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgY3JlYXRlU291cmNlQnVmZmVycyh0cmFja3M6IFRyYWNrU2V0KSB7XG4gICAgY29uc3QgeyBzb3VyY2VCdWZmZXIsIG1lZGlhU291cmNlIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWFTb3VyY2UpIHtcbiAgICAgIHRocm93IEVycm9yKCdjcmVhdGVTb3VyY2VCdWZmZXJzIGNhbGxlZCB3aGVuIG1lZGlhU291cmNlIHdhcyBudWxsJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgaWYgKCFzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSkge1xuICAgICAgICBjb25zdCB0cmFjayA9IHRyYWNrc1t0cmFja05hbWUgYXMga2V5b2YgVHJhY2tTZXRdO1xuICAgICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBgc291cmNlIGJ1ZmZlciBleGlzdHMgZm9yIHRyYWNrICR7dHJhY2tOYW1lfSwgaG93ZXZlciB0cmFjayBkb2VzIG5vdGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgIGNvbnN0IGNvZGVjID0gdHJhY2subGV2ZWxDb2RlYyB8fCB0cmFjay5jb2RlYztcbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBgJHt0cmFjay5jb250YWluZXJ9O2NvZGVjcz0ke2NvZGVjfWA7XG4gICAgICAgIGxvZ2dlci5sb2coYFtidWZmZXItY29udHJvbGxlcl06IGNyZWF0aW5nIHNvdXJjZUJ1ZmZlcigke21pbWVUeXBlfSlgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzYiA9IChzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSA9XG4gICAgICAgICAgICBtZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIobWltZVR5cGUpKTtcbiAgICAgICAgICBjb25zdCBzYk5hbWUgPSB0cmFja05hbWUgYXMgU291cmNlQnVmZmVyTmFtZTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ3VwZGF0ZXN0YXJ0JywgdGhpcy5fb25TQlVwZGF0ZVN0YXJ0KTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ3VwZGF0ZWVuZCcsIHRoaXMuX29uU0JVcGRhdGVFbmQpO1xuICAgICAgICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoc2JOYW1lLCAnZXJyb3InLCB0aGlzLl9vblNCVXBkYXRlRXJyb3IpO1xuICAgICAgICAgIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gPSB7XG4gICAgICAgICAgICBidWZmZXI6IHNiLFxuICAgICAgICAgICAgY29kZWM6IGNvZGVjLFxuICAgICAgICAgICAgY29udGFpbmVyOiB0cmFjay5jb250YWluZXIsXG4gICAgICAgICAgICBsZXZlbENvZGVjOiB0cmFjay5sZXZlbENvZGVjLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRyYWNrLm1ldGFkYXRhLFxuICAgICAgICAgICAgaWQ6IHRyYWNrLmlkLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgIGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBlcnJvciB3aGlsZSB0cnlpbmcgdG8gYWRkIHNvdXJjZUJ1ZmZlcjogJHtlcnIubWVzc2FnZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEtlZXAgYXMgYXJyb3cgZnVuY3Rpb25zIHNvIHRoYXQgd2UgY2FuIGRpcmVjdGx5IHJlZmVyZW5jZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgYXMgZXZlbnQgbGlzdGVuZXJzXG4gIHByaXZhdGUgX29uTWVkaWFTb3VyY2VPcGVuID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgbWVkaWEsIG1lZGlhU291cmNlIH0gPSB0aGlzO1xuICAgIGxvZ2dlci5sb2coJ1tidWZmZXItY29udHJvbGxlcl06IE1lZGlhIHNvdXJjZSBvcGVuZWQnKTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCB0aGlzLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgeyBtZWRpYSB9KTtcbiAgICB9XG5cbiAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBfb25NZWRpYVNvdXJjZUNsb3NlID0gKCkgPT4ge1xuICAgIGxvZ2dlci5sb2coJ1tidWZmZXItY29udHJvbGxlcl06IE1lZGlhIHNvdXJjZSBjbG9zZWQnKTtcbiAgfTtcblxuICBwcml2YXRlIF9vbk1lZGlhU291cmNlRW5kZWQgPSAoKSA9PiB7XG4gICAgbG9nZ2VyLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgc291cmNlIGVuZGVkJyk7XG4gIH07XG5cbiAgcHJpdmF0ZSBfb25NZWRpYUVtcHRpZWQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBtZWRpYSwgX29iamVjdFVybCB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuc3JjICE9PSBfb2JqZWN0VXJsKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgIGBNZWRpYSBlbGVtZW50IHNyYyB3YXMgc2V0IHdoaWxlIGF0dGFjaGluZyBNZWRpYVNvdXJjZSAoJHtfb2JqZWN0VXJsfSA+ICR7bWVkaWEuc3JjfSlgXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIF9vblNCVXBkYXRlU3RhcnQodHlwZTogU291cmNlQnVmZmVyTmFtZSkge1xuICAgIGNvbnN0IHsgb3BlcmF0aW9uUXVldWUgfSA9IHRoaXM7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gb3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcbiAgICBvcGVyYXRpb24ub25TdGFydCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfb25TQlVwZGF0ZUVuZCh0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSB7XG4gICAgY29uc3QgeyBvcGVyYXRpb25RdWV1ZSB9ID0gdGhpcztcbiAgICBjb25zdCBvcGVyYXRpb24gPSBvcGVyYXRpb25RdWV1ZS5jdXJyZW50KHR5cGUpO1xuICAgIG9wZXJhdGlvbi5vbkNvbXBsZXRlKCk7XG4gICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgfVxuXG4gIHByaXZhdGUgX29uU0JVcGRhdGVFcnJvcih0eXBlOiBTb3VyY2VCdWZmZXJOYW1lLCBldmVudDogRXZlbnQpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgJHt0eXBlfSBTb3VyY2VCdWZmZXIgZXJyb3JgKTtcbiAgICBsb2dnZXIuZXJyb3IoYFtidWZmZXItY29udHJvbGxlcl06ICR7ZXJyb3J9YCwgZXZlbnQpO1xuICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAvLyBTb3VyY2VCdWZmZXIgZXJyb3JzIGFyZSBub3QgbmVjZXNzYXJpbHkgZmF0YWw7IGlmIHNvLCB0aGUgSFRNTE1lZGlhRWxlbWVudCB3aWxsIGZpcmUgYW4gZXJyb3IgZXZlbnRcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLFxuICAgICAgZXJyb3IsXG4gICAgICBmYXRhbDogZmFsc2UsXG4gICAgfSk7XG4gICAgLy8gdXBkYXRlZW5kIGlzIGFsd2F5cyBmaXJlZCBhZnRlciBlcnJvciwgc28gd2UnbGwgYWxsb3cgdGhhdCB0byBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmIG9mIHRoZSBxdWV1ZVxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMub3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcbiAgICBpZiAob3BlcmF0aW9uKSB7XG4gICAgICBvcGVyYXRpb24ub25FcnJvcihldmVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBtZXRob2QgbXVzdCByZXN1bHQgaW4gYW4gdXBkYXRlZW5kIGV2ZW50OyBpZiByZW1vdmUgaXMgbm90IGNhbGxlZCwgX29uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgcHJpdmF0ZSByZW1vdmVFeGVjdXRvcihcbiAgICB0eXBlOiBTb3VyY2VCdWZmZXJOYW1lLFxuICAgIHN0YXJ0T2Zmc2V0OiBudW1iZXIsXG4gICAgZW5kT2Zmc2V0OiBudW1iZXJcbiAgKSB7XG4gICAgY29uc3QgeyBtZWRpYSwgbWVkaWFTb3VyY2UsIG9wZXJhdGlvblF1ZXVlLCBzb3VyY2VCdWZmZXIgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFtZWRpYSB8fCAhbWVkaWFTb3VyY2UgfHwgIXNiKSB7XG4gICAgICBsb2dnZXIud2FybihcbiAgICAgICAgYFtidWZmZXItY29udHJvbGxlcl06IEF0dGVtcHRpbmcgdG8gcmVtb3ZlIGZyb20gdGhlICR7dHlwZX0gU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RgXG4gICAgICApO1xuICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVkaWFEdXJhdGlvbiA9IE51bWJlci5pc0Zpbml0ZShtZWRpYS5kdXJhdGlvbilcbiAgICAgID8gbWVkaWEuZHVyYXRpb25cbiAgICAgIDogSW5maW5pdHk7XG4gICAgY29uc3QgbXNEdXJhdGlvbiA9IE51bWJlci5pc0Zpbml0ZShtZWRpYVNvdXJjZS5kdXJhdGlvbilcbiAgICAgID8gbWVkaWFTb3VyY2UuZHVyYXRpb25cbiAgICAgIDogSW5maW5pdHk7XG4gICAgY29uc3QgcmVtb3ZlU3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydE9mZnNldCk7XG4gICAgY29uc3QgcmVtb3ZlRW5kID0gTWF0aC5taW4oZW5kT2Zmc2V0LCBtZWRpYUR1cmF0aW9uLCBtc0R1cmF0aW9uKTtcbiAgICBpZiAocmVtb3ZlRW5kID4gcmVtb3ZlU3RhcnQgJiYgIXNiLmVuZGluZykge1xuICAgICAgc2IuZW5kZWQgPSBmYWxzZTtcbiAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgIGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBSZW1vdmluZyBbJHtyZW1vdmVTdGFydH0sJHtyZW1vdmVFbmR9XSBmcm9tIHRoZSAke3R5cGV9IFNvdXJjZUJ1ZmZlcmBcbiAgICAgICk7XG4gICAgICBzYi5yZW1vdmUocmVtb3ZlU3RhcnQsIHJlbW92ZUVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN5Y2xlIHRoZSBxdWV1ZVxuICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIG1ldGhvZCBtdXN0IHJlc3VsdCBpbiBhbiB1cGRhdGVlbmQgZXZlbnQ7IGlmIGFwcGVuZCBpcyBub3QgY2FsbGVkLCBfb25TQlVwZGF0ZUVuZCBtdXN0IGJlIGNhbGxlZCBtYW51YWxseVxuICBwcml2YXRlIGFwcGVuZEV4ZWN1dG9yKGRhdGE6IFVpbnQ4QXJyYXksIHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUpIHtcbiAgICBjb25zdCB7IG9wZXJhdGlvblF1ZXVlLCBzb3VyY2VCdWZmZXIgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFzYikge1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgIGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBBdHRlbXB0aW5nIHRvIGFwcGVuZCB0byB0aGUgJHt0eXBlfSBTb3VyY2VCdWZmZXIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdGBcbiAgICAgICk7XG4gICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgc2IuYXBwZW5kQnVmZmVyKGRhdGEpO1xuICB9XG5cbiAgLy8gRW5xdWV1ZXMgYW4gb3BlcmF0aW9uIHRvIGVhY2ggU291cmNlQnVmZmVyIHF1ZXVlIHdoaWNoLCB1cG9uIGV4ZWN1dGlvbiwgcmVzb2x2ZXMgYSBwcm9taXNlLiBXaGVuIGFsbCBwcm9taXNlc1xuICAvLyByZXNvbHZlLCB0aGUgb25VbmJsb2NrZWQgZnVuY3Rpb24gaXMgZXhlY3V0ZWQuIEZ1bmN0aW9ucyBjYWxsaW5nIHRoaXMgbWV0aG9kIGRvIG5vdCBuZWVkIHRvIHVuYmxvY2sgdGhlIHF1ZXVlXG4gIC8vIHVwb24gY29tcGxldGlvbiwgc2luY2Ugd2UgYWxyZWFkeSBkbyBpdCBoZXJlXG4gIHByaXZhdGUgYmxvY2tCdWZmZXJzKFxuICAgIG9uVW5ibG9ja2VkOiAoKSA9PiB2b2lkLFxuICAgIGJ1ZmZlcnM6IEFycmF5PFNvdXJjZUJ1ZmZlck5hbWU+ID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpXG4gICkge1xuICAgIGlmICghYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICdbYnVmZmVyLWNvbnRyb2xsZXJdOiBCbG9ja2luZyBvcGVyYXRpb24gcmVxdWVzdGVkLCBidXQgbm8gU291cmNlQnVmZmVycyBleGlzdCdcbiAgICAgICk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKG9uVW5ibG9ja2VkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBvcGVyYXRpb25RdWV1ZSB9ID0gdGhpcztcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQmxvY2tpbmcgJHtidWZmZXJzfSBTb3VyY2VCdWZmZXJgKTtcbiAgICBjb25zdCBibG9ja2luZ09wZXJhdGlvbnMgPSBidWZmZXJzLm1hcCgodHlwZSkgPT5cbiAgICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZEJsb2NrZXIodHlwZSBhcyBTb3VyY2VCdWZmZXJOYW1lKVxuICAgICk7XG4gICAgUHJvbWlzZS5hbGwoYmxvY2tpbmdPcGVyYXRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQmxvY2tpbmcgb3BlcmF0aW9uIHJlc29sdmVkOyB1bmJsb2NraW5nICR7YnVmZmVyc30gU291cmNlQnVmZmVyYCk7XG4gICAgICBvblVuYmxvY2tlZCgpO1xuICAgICAgYnVmZmVycy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgIC8vIE9ubHkgY3ljbGUgdGhlIHF1ZXVlIGlmIHRoZSBTQiBpcyBub3QgdXBkYXRpbmcuIFRoZXJlJ3MgYSBidWcgaW4gQ2hyb21lIHdoaWNoIHNldHMgdGhlIFNCIHVwZGF0aW5nIGZsYWcgdG9cbiAgICAgICAgLy8gdHJ1ZSB3aGVuIGNoYW5naW5nIHRoZSBNZWRpYVNvdXJjZSBkdXJhdGlvbiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTU5MzU5JmNhbj0yJnE9bWVkaWFzb3VyY2UlMjBkdXJhdGlvbilcbiAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBhIHdvcmthcm91bmQsIGl0J3MgcHJvYmFibHkgdXNlZnVsIHRvIGhhdmUgYXJvdW5kXG4gICAgICAgIGlmICghc2I/LnVwZGF0aW5nKSB7XG4gICAgICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdldFNvdXJjZUJ1ZmZlclR5cGVzKCk6IEFycmF5PFNvdXJjZUJ1ZmZlck5hbWU+IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXIpIGFzIEFycmF5PFNvdXJjZUJ1ZmZlck5hbWU+O1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRCdWZmZXJMaXN0ZW5lcihcbiAgICB0eXBlOiBTb3VyY2VCdWZmZXJOYW1lLFxuICAgIGV2ZW50OiBzdHJpbmcsXG4gICAgZm46IEZ1bmN0aW9uXG4gICkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVyID0gZm4uYmluZCh0aGlzLCB0eXBlKTtcbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKHsgZXZlbnQsIGxpc3RlbmVyIH0pO1xuICAgIGJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0uZm9yRWFjaCgobCkgPT4ge1xuICAgICAgYnVmZmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobC5ldmVudCwgbC5saXN0ZW5lcik7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBjYXAgc3RyZWFtIGxldmVsIHRvIG1lZGlhIHNpemUgZGltZW5zaW9uIGNvbnRyb2xsZXJcbiAqL1xuXG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBMZXZlbCB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB0eXBlIHtcbiAgTWFuaWZlc3RQYXJzZWREYXRhLFxuICBCdWZmZXJDb2RlY3NEYXRhLFxuICBNZWRpYUF0dGFjaGluZ0RhdGEsXG4gIEZQU0Ryb3BMZXZlbENhcHBpbmdEYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IFN0cmVhbUNvbnRyb2xsZXIgZnJvbSAnLi9zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5cbnR5cGUgUmVzdHJpY3RlZExldmVsID0geyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlcjsgYml0cmF0ZTogbnVtYmVyIH07XG5jbGFzcyBDYXBMZXZlbENvbnRyb2xsZXIgaW1wbGVtZW50cyBDb21wb25lbnRBUEkge1xuICBwcml2YXRlIGhsczogSGxzO1xuICBwcml2YXRlIGF1dG9MZXZlbENhcHBpbmc6IG51bWJlcjtcbiAgcHJpdmF0ZSBmaXJzdExldmVsOiBudW1iZXI7XG4gIHByaXZhdGUgbWVkaWE6IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsO1xuICBwcml2YXRlIHJlc3RyaWN0ZWRMZXZlbHM6IFJlc3RyaWN0ZWRMZXZlbFtdO1xuICBwcml2YXRlIHRpbWVyOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgY2xpZW50UmVjdDogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9IHwgbnVsbDtcbiAgcHJpdmF0ZSBzdHJlYW1Db250cm9sbGVyPzogU3RyZWFtQ29udHJvbGxlcjtcblxuICBjb25zdHJ1Y3RvcihobHM6IEhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSAtMTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG5cbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBwdWJsaWMgc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyOiBTdHJlYW1Db250cm9sbGVyKSB7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gc3RyZWFtQ29udHJvbGxlcjtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVyKCk7XG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgdGhpcy5zdG9wQ2FwcGluZygpO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB1bnJlZ2lzdGVyTGlzdGVuZXIoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuRlBTX0RST1BfTEVWRUxfQ0FQUElORywgdGhpcy5vbkZwc0Ryb3BMZXZlbENhcHBpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRnBzRHJvcExldmVsQ2FwcGluZyhcbiAgICBldmVudDogRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsXG4gICAgZGF0YTogRlBTRHJvcExldmVsQ2FwcGluZ0RhdGFcbiAgKSB7XG4gICAgLy8gRG9uJ3QgYWRkIGEgcmVzdHJpY3RlZCBsZXZlbCBtb3JlIHRoYW4gb25jZVxuICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2RhdGEuZHJvcHBlZExldmVsXTtcbiAgICBpZiAodGhpcy5pc0xldmVsQWxsb3dlZChsZXZlbCkpIHtcbiAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscy5wdXNoKHtcbiAgICAgICAgYml0cmF0ZTogbGV2ZWwuYml0cmF0ZSxcbiAgICAgICAgaGVpZ2h0OiBsZXZlbC5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBsZXZlbC53aWR0aCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhQXR0YWNoaW5nKFxuICAgIGV2ZW50OiBFdmVudHMuTUVESUFfQVRUQUNISU5HLFxuICAgIGRhdGE6IE1lZGlhQXR0YWNoaW5nRGF0YVxuICApIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWFuaWZlc3RQYXJzZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsXG4gICAgZGF0YTogTWFuaWZlc3RQYXJzZWREYXRhXG4gICkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IGRhdGEuZmlyc3RMZXZlbDtcbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAvLyBTdGFydCBjYXBwaW5nIGltbWVkaWF0ZWx5IGlmIHRoZSBtYW5pZmVzdCBoYXMgc2lnbmFsZWQgdmlkZW8gY29kZWNzXG4gICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE9ubHkgYWN0aXZhdGUgY2FwcGluZyB3aGVuIHBsYXlpbmcgYSB2aWRlbyBzdHJlYW07IG90aGVyd2lzZSwgbXVsdGktYml0cmF0ZSBhdWRpby1vbmx5IHN0cmVhbXMgd2lsbCBiZSByZXN0cmljdGVkXG4gIC8vIHRvIHRoZSBmaXJzdCBsZXZlbFxuICBwcm90ZWN0ZWQgb25CdWZmZXJDb2RlY3MoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfQ09ERUNTLFxuICAgIGRhdGE6IEJ1ZmZlckNvZGVjc0RhdGFcbiAgKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gSWYgdGhlIG1hbmlmZXN0IGRpZCBub3Qgc2lnbmFsIGEgdmlkZW8gY29kZWMgY2FwcGluZyBoYXMgYmVlbiBkZWZlcnJlZCB1bnRpbCB3ZSdyZSBjZXJ0YWluIHZpZGVvIGlzIHByZXNlbnRcbiAgICAgIHRoaXMuc3RhcnRDYXBwaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdGhpcy5zdG9wQ2FwcGluZygpO1xuICB9XG5cbiAgZGV0ZWN0UGxheWVyU2l6ZSgpIHtcbiAgICBpZiAodGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhSGVpZ2h0ID4gMCAmJiB0aGlzLm1lZGlhV2lkdGggPiAwKSB7XG4gICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSB0aGlzLmdldE1heExldmVsKGxldmVscy5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID4gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nICYmXG4gICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGlmIGF1dG8gbGV2ZWwgY2FwcGluZyBoYXMgYSBoaWdoZXIgdmFsdWUgZm9yIHRoZSBwcmV2aW91cyBvbmUsIGZsdXNoIHRoZSBidWZmZXIgdXNpbmcgbmV4dExldmVsU3dpdGNoXG4gICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBobHMuYXV0b0xldmVsQ2FwcGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiByZXR1cm5zIGxldmVsIHNob3VsZCBiZSB0aGUgb25lIHdpdGggdGhlIGRpbWVuc2lvbnMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBtZWRpYSAocGxheWVyKSBkaW1lbnNpb25zIChzbyB0aGUgdmlkZW8gd2lsbCBiZSBkb3duc2NhbGVkKVxuICAgKi9cbiAgZ2V0TWF4TGV2ZWwoY2FwTGV2ZWxJbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWRMZXZlbHMgPSBsZXZlbHMuZmlsdGVyKFxuICAgICAgKGxldmVsLCBpbmRleCkgPT4gdGhpcy5pc0xldmVsQWxsb3dlZChsZXZlbCkgJiYgaW5kZXggPD0gY2FwTGV2ZWxJbmRleFxuICAgICk7XG5cbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXIuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZShcbiAgICAgIHZhbGlkTGV2ZWxzLFxuICAgICAgdGhpcy5tZWRpYVdpZHRoLFxuICAgICAgdGhpcy5tZWRpYUhlaWdodFxuICAgICk7XG4gIH1cblxuICBzdGFydENhcHBpbmcoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIC8vIERvbid0IHJlc2V0IGNhcHBpbmcgaWYgc3RhcnRlZCB0d2ljZTsgdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBtYW5pZmVzdCBzaWduYWxzIGEgdmlkZW8gY29kZWNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMuaGxzLmZpcnN0TGV2ZWwgPSB0aGlzLmdldE1heExldmVsKHRoaXMuZmlyc3RMZXZlbCk7XG4gICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMuZGV0ZWN0UGxheWVyU2l6ZS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgfVxuXG4gIHN0b3BDYXBwaW5nKCkge1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IC0xO1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBnZXREaW1lbnNpb25zKCk6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSB7XG4gICAgaWYgKHRoaXMuY2xpZW50UmVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50UmVjdDtcbiAgICB9XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGNvbnN0IGJvdW5kc1JlY3QgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICB9O1xuXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBjb25zdCBjbGllbnRSZWN0ID0gbWVkaWEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBib3VuZHNSZWN0LndpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgICAgIGJvdW5kc1JlY3QuaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gICAgICBpZiAoIWJvdW5kc1JlY3Qud2lkdGggJiYgIWJvdW5kc1JlY3QuaGVpZ2h0KSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIG1lZGlhIGVsZW1lbnQgaGFzIG5vIHdpZHRoIG9yIGhlaWdodCAoZXF1aXZhbGVudCB0byBub3QgYmVpbmcgaW4gdGhlIERPTSksXG4gICAgICAgIC8vIHRoZW4gdXNlIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZXMgKG1lZGlhLndpZHRoLCBtZWRpYS5oZWlnaHQpXG4gICAgICAgIGJvdW5kc1JlY3Qud2lkdGggPVxuICAgICAgICAgIGNsaWVudFJlY3QucmlnaHQgLSBjbGllbnRSZWN0LmxlZnQgfHwgbWVkaWEud2lkdGggfHwgMDtcbiAgICAgICAgYm91bmRzUmVjdC5oZWlnaHQgPVxuICAgICAgICAgIGNsaWVudFJlY3QuYm90dG9tIC0gY2xpZW50UmVjdC50b3AgfHwgbWVkaWEuaGVpZ2h0IHx8IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xpZW50UmVjdCA9IGJvdW5kc1JlY3Q7XG4gICAgcmV0dXJuIGJvdW5kc1JlY3Q7XG4gIH1cblxuICBnZXQgbWVkaWFXaWR0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbnMoKS53aWR0aCAqIHRoaXMuY29udGVudFNjYWxlRmFjdG9yO1xuICB9XG5cbiAgZ2V0IG1lZGlhSGVpZ2h0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9ucygpLmhlaWdodCAqIHRoaXMuY29udGVudFNjYWxlRmFjdG9yO1xuICB9XG5cbiAgZ2V0IGNvbnRlbnRTY2FsZUZhY3RvcigpOiBudW1iZXIge1xuICAgIGxldCBwaXhlbFJhdGlvID0gMTtcbiAgICBpZiAoIXRoaXMuaGxzLmNvbmZpZy5pZ25vcmVEZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwaXhlbFJhdGlvID0gc2VsZi5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBuby1vcCAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwaXhlbFJhdGlvO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0xldmVsQWxsb3dlZChsZXZlbDogTGV2ZWwpOiBib29sZWFuIHtcbiAgICBjb25zdCByZXN0cmljdGVkTGV2ZWxzID0gdGhpcy5yZXN0cmljdGVkTGV2ZWxzO1xuICAgIHJldHVybiAhcmVzdHJpY3RlZExldmVscy5zb21lKChyZXN0cmljdGVkTGV2ZWwpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGxldmVsLmJpdHJhdGUgPT09IHJlc3RyaWN0ZWRMZXZlbC5iaXRyYXRlICYmXG4gICAgICAgIGxldmVsLndpZHRoID09PSByZXN0cmljdGVkTGV2ZWwud2lkdGggJiZcbiAgICAgICAgbGV2ZWwuaGVpZ2h0ID09PSByZXN0cmljdGVkTGV2ZWwuaGVpZ2h0XG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldE1heExldmVsQnlNZWRpYVNpemUoXG4gICAgbGV2ZWxzOiBBcnJheTxMZXZlbD4sXG4gICAgd2lkdGg6IG51bWJlcixcbiAgICBoZWlnaHQ6IG51bWJlclxuICApOiBudW1iZXIge1xuICAgIGlmICghbGV2ZWxzPy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBMZXZlbHMgY2FuIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBidXQgZGlmZmVyaW5nIGJhbmR3aWR0aHMgLSBzaW5jZSBsZXZlbHMgYXJlIG9yZGVyZWQsIHdlIGNhbiBsb29rIHRvIHRoZSBuZXh0XG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UndmUgY2hvc2VuIHRoZSBncmVhdGVzdCBiYW5kd2lkdGggZm9yIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnNcbiAgICBjb25zdCBhdEdyZWF0ZXN0QmFuZHdpZHRoID0gKGN1ckxldmVsLCBuZXh0TGV2ZWwpID0+IHtcbiAgICAgIGlmICghbmV4dExldmVsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBjdXJMZXZlbC53aWR0aCAhPT0gbmV4dExldmVsLndpZHRoIHx8XG4gICAgICAgIGN1ckxldmVsLmhlaWdodCAhPT0gbmV4dExldmVsLmhlaWdodFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gSWYgd2UgcnVuIHRocm91Z2ggdGhlIGxvb3Agd2l0aG91dCBicmVha2luZywgdGhlIG1lZGlhJ3MgZGltZW5zaW9ucyBhcmUgZ3JlYXRlciB0aGFuIGV2ZXJ5IGxldmVsLCBzbyBkZWZhdWx0IHRvXG4gICAgLy8gdGhlIG1heCBsZXZlbFxuICAgIGxldCBtYXhMZXZlbEluZGV4ID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICBpZiAoXG4gICAgICAgIChsZXZlbC53aWR0aCA+PSB3aWR0aCB8fCBsZXZlbC5oZWlnaHQgPj0gaGVpZ2h0KSAmJlxuICAgICAgICBhdEdyZWF0ZXN0QmFuZHdpZHRoKGxldmVsLCBsZXZlbHNbaSArIDFdKVxuICAgICAgKSB7XG4gICAgICAgIG1heExldmVsSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4TGV2ZWxJbmRleDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXBMZXZlbENvbnRyb2xsZXI7XG4iLCJpbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgTWVkaWFBdHRhY2hpbmdEYXRhIH0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcbmltcG9ydCBTdHJlYW1Db250cm9sbGVyIGZyb20gJy4vc3RyZWFtLWNvbnRyb2xsZXInO1xuXG5jbGFzcyBGUFNDb250cm9sbGVyIGltcGxlbWVudHMgQ29tcG9uZW50QVBJIHtcbiAgcHJpdmF0ZSBobHM6IEhscztcbiAgcHJpdmF0ZSBpc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgdGltZXI/OiBudW1iZXI7XG4gIHByaXZhdGUgbWVkaWE6IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBsYXN0VGltZTogYW55O1xuICBwcml2YXRlIGxhc3REcm9wcGVkRnJhbWVzOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIGxhc3REZWNvZGVkRnJhbWVzOiBudW1iZXIgPSAwO1xuICAvLyBzdHJlYW0gY29udHJvbGxlciBtdXN0IGJlIHByb3ZpZGVkIGFzIGEgZGVwZW5kZW5jeSFcbiAgcHJpdmF0ZSBzdHJlYW1Db250cm9sbGVyITogU3RyZWFtQ29udHJvbGxlcjtcblxuICBjb25zdHJ1Y3RvcihobHM6IEhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuXG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgcHVibGljIHNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcjogU3RyZWFtQ29udHJvbGxlcikge1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHN0cmVhbUNvbnRyb2xsZXI7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB9XG5cbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhQXR0YWNoaW5nKFxuICAgIGV2ZW50OiBFdmVudHMuTUVESUFfQVRUQUNISU5HLFxuICAgIGRhdGE6IE1lZGlhQXR0YWNoaW5nRGF0YVxuICApIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgaWYgKGNvbmZpZy5jYXBMZXZlbE9uRlBTRHJvcCkge1xuICAgICAgY29uc3QgbWVkaWEgPVxuICAgICAgICBkYXRhLm1lZGlhIGluc3RhbmNlb2Ygc2VsZi5IVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgICBpZiAobWVkaWEgJiYgdHlwZW9mIG1lZGlhLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKFxuICAgICAgICB0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSxcbiAgICAgICAgY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRlBTKFxuICAgIHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50LFxuICAgIGRlY29kZWRGcmFtZXM6IG51bWJlcixcbiAgICBkcm9wcGVkRnJhbWVzOiBudW1iZXJcbiAgKSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoZGVjb2RlZEZyYW1lcykge1xuICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZTtcbiAgICAgICAgY29uc3QgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcztcbiAgICAgICAgY29uc3QgY3VycmVudERlY29kZWQgPSBkZWNvZGVkRnJhbWVzIC0gdGhpcy5sYXN0RGVjb2RlZEZyYW1lcztcbiAgICAgICAgY29uc3QgZHJvcHBlZEZQUyA9ICgxMDAwICogY3VycmVudERyb3BwZWQpIC8gY3VycmVudFBlcmlvZDtcbiAgICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUFNfRFJPUCwge1xuICAgICAgICAgIGN1cnJlbnREcm9wcGVkOiBjdXJyZW50RHJvcHBlZCxcbiAgICAgICAgICBjdXJyZW50RGVjb2RlZDogY3VycmVudERlY29kZWQsXG4gICAgICAgICAgdG90YWxEcm9wcGVkRnJhbWVzOiBkcm9wcGVkRnJhbWVzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnY2hlY2tGUFMgOiBkcm9wcGVkRlBTL2RlY29kZWRGUFM6JyArIGRyb3BwZWRGUFMvKDEwMDAgKiBjdXJyZW50RGVjb2RlZCAvIGN1cnJlbnRQZXJpb2QpKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjdXJyZW50RHJvcHBlZCA+XG4gICAgICAgICAgICBobHMuY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkICogY3VycmVudERlY29kZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSBobHMuY3VycmVudExldmVsO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICdkcm9wIEZQUyByYXRpbyBncmVhdGVyIHRoYW4gbWF4IGFsbG93ZWQgdmFsdWUgZm9yIGN1cnJlbnRMZXZlbDogJyArXG4gICAgICAgICAgICAgICAgY3VycmVudExldmVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPiAwICYmXG4gICAgICAgICAgICAgIChobHMuYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgfHxcbiAgICAgICAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA+PSBjdXJyZW50TGV2ZWwpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsIC0gMTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHtcbiAgICAgICAgICAgICAgICBsZXZlbDogY3VycmVudExldmVsLFxuICAgICAgICAgICAgICAgIGRyb3BwZWRMZXZlbDogaGxzLmN1cnJlbnRMZXZlbCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gY3VycmVudExldmVsO1xuICAgICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gZHJvcHBlZEZyYW1lcztcbiAgICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSBkZWNvZGVkRnJhbWVzO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRlBTSW50ZXJ2YWwoKSB7XG4gICAgY29uc3QgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgIGlmICh2aWRlbykge1xuICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSkge1xuICAgICAgICBjb25zdCB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgICAgIHRoaXMuY2hlY2tGUFMoXG4gICAgICAgICAgdmlkZW8sXG4gICAgICAgICAgdmlkZW9QbGF5YmFja1F1YWxpdHkudG90YWxWaWRlb0ZyYW1lcyxcbiAgICAgICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXNcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhUTUxWaWRlb0VsZW1lbnQgZG9lc24ndCBpbmNsdWRlIHRoZSB3ZWJraXQgdHlwZXNcbiAgICAgICAgdGhpcy5jaGVja0ZQUyhcbiAgICAgICAgICB2aWRlbyxcbiAgICAgICAgICAodmlkZW8gYXMgYW55KS53ZWJraXREZWNvZGVkRnJhbWVDb3VudCBhcyBudW1iZXIsXG4gICAgICAgICAgKHZpZGVvIGFzIGFueSkud2Via2l0RHJvcHBlZEZyYW1lQ291bnQgYXMgbnVtYmVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZQU0NvbnRyb2xsZXI7XG4iLCJpbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHR5cGUge1xuICBMb2FkZXJDYWxsYmFja3MsXG4gIExvYWRlckNvbnRleHQsXG4gIExvYWRlclN0YXRzLFxuICBMb2FkZXIsXG4gIExvYWRlckNvbmZpZ3VyYXRpb24sXG4gIExvYWRlclJlc3BvbnNlLFxufSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHsgTG9hZFN0YXRzIH0gZnJvbSAnLi4vbG9hZGVyL2xvYWQtc3RhdHMnO1xuaW1wb3J0IHsgdHlwZSBIbHNDb25maWcsIFJldHJ5Q29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB7IGdldFJldHJ5RGVsYXksIHNob3VsZFJldHJ5IH0gZnJvbSAnLi9lcnJvci1oZWxwZXInO1xuXG5jb25zdCBBR0VfSEVBREVSX0xJTkVfUkVHRVggPSAvXmFnZTpcXHMqW1xcZC5dK1xccyokL2ltO1xuXG5jbGFzcyBYaHJMb2FkZXIgaW1wbGVtZW50cyBMb2FkZXI8TG9hZGVyQ29udGV4dD4ge1xuICBwcml2YXRlIHhoclNldHVwOlxuICAgIHwgKCh4aHI6IFhNTEh0dHBSZXF1ZXN0LCB1cmw6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQpXG4gICAgfCBudWxsO1xuICBwcml2YXRlIHJlcXVlc3RUaW1lb3V0PzogbnVtYmVyO1xuICBwcml2YXRlIHJldHJ5VGltZW91dD86IG51bWJlcjtcbiAgcHJpdmF0ZSByZXRyeURlbGF5OiBudW1iZXI7XG4gIHByaXZhdGUgY29uZmlnOiBMb2FkZXJDb25maWd1cmF0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY2FsbGJhY2tzOiBMb2FkZXJDYWxsYmFja3M8TG9hZGVyQ29udGV4dD4gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNvbnRleHQhOiBMb2FkZXJDb250ZXh0O1xuXG4gIHByaXZhdGUgbG9hZGVyOiBYTUxIdHRwUmVxdWVzdCB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgc3RhdHM6IExvYWRlclN0YXRzO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogSGxzQ29uZmlnKSB7XG4gICAgdGhpcy54aHJTZXR1cCA9IGNvbmZpZyA/IGNvbmZpZy54aHJTZXR1cCB8fCBudWxsIDogbnVsbDtcbiAgICB0aGlzLnN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICAgIHRoaXMucmV0cnlEZWxheSA9IDA7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICB9XG5cbiAgYWJvcnRJbnRlcm5hbCgpIHtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlcjtcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICBsb2FkZXIub25wcm9ncmVzcyA9IG51bGw7XG4gICAgICBpZiAobG9hZGVyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgaWYgKHRoaXMuY2FsbGJhY2tzPy5vbkFib3J0KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkFib3J0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5sb2FkZXIpO1xuICAgIH1cbiAgfVxuXG4gIGxvYWQoXG4gICAgY29udGV4dDogTG9hZGVyQ29udGV4dCxcbiAgICBjb25maWc6IExvYWRlckNvbmZpZ3VyYXRpb24sXG4gICAgY2FsbGJhY2tzOiBMb2FkZXJDYWxsYmFja3M8TG9hZGVyQ29udGV4dD5cbiAgKSB7XG4gICAgaWYgKHRoaXMuc3RhdHMubG9hZGluZy5zdGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkZXIgY2FuIG9ubHkgYmUgdXNlZCBvbmNlLicpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5sb2FkSW50ZXJuYWwoKTtcbiAgfVxuXG4gIGxvYWRJbnRlcm5hbCgpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgY29udGV4dCB9ID0gdGhpcztcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHIgPSAodGhpcy5sb2FkZXIgPSBuZXcgc2VsZi5YTUxIdHRwUmVxdWVzdCgpKTtcblxuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gMDtcbiAgICBzdGF0cy5sb2FkZWQgPSAwO1xuICAgIGNvbnN0IHhoclNldHVwID0gdGhpcy54aHJTZXR1cDtcblxuICAgIGlmICh4aHJTZXR1cCkge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRzLmFib3J0ZWQpIHJldHVybjtcbiAgICAgICAgICByZXR1cm4geGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4geGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0cy5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgICAgdGhpcy5vcGVuQW5kU2VuZFhocih4aHIsIGNvbnRleHQsIGNvbmZpZyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgICAgLy8gSUUxMSB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIHhoci5vcGVuIGlmIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGFuIEhUVFAgcmVzb3VyY2Ugb3ZlciBIVFRQU1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzIS5vbkVycm9yKFxuICAgICAgICAgICAgeyBjb2RlOiB4aHIuc3RhdHVzLCB0ZXh0OiBlcnJvci5tZXNzYWdlIH0sXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgeGhyLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIG9wZW5BbmRTZW5kWGhyKFxuICAgIHhocjogWE1MSHR0cFJlcXVlc3QsXG4gICAgY29udGV4dDogTG9hZGVyQ29udGV4dCxcbiAgICBjb25maWc6IExvYWRlckNvbmZpZ3VyYXRpb25cbiAgKSB7XG4gICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5jb250ZXh0LmhlYWRlcnM7XG4gICAgY29uc3QgeyBtYXhUaW1lVG9GaXJzdEJ5dGVNcywgbWF4TG9hZFRpbWVNcyB9ID0gY29uZmlnLmxvYWRQb2xpY3k7XG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCBoZWFkZXJzW2hlYWRlcl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcbiAgICAgICAgJ1JhbmdlJyxcbiAgICAgICAgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyAoY29udGV4dC5yYW5nZUVuZCAtIDEpXG4gICAgICApO1xuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLnJlYWR5c3RhdGVjaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlIGFzIFhNTEh0dHBSZXF1ZXN0UmVzcG9uc2VUeXBlO1xuICAgIC8vIHNldHVwIHRpbWVvdXQgYmVmb3JlIHdlIHBlcmZvcm0gcmVxdWVzdFxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIGNvbmZpZy50aW1lb3V0ID1cbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zICYmIE51bWJlci5pc0Zpbml0ZShtYXhUaW1lVG9GaXJzdEJ5dGVNcylcbiAgICAgICAgPyBtYXhUaW1lVG9GaXJzdEJ5dGVNc1xuICAgICAgICA6IG1heExvYWRUaW1lTXM7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dChcbiAgICAgIHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSxcbiAgICAgIGNvbmZpZy50aW1lb3V0XG4gICAgKTtcbiAgICB4aHIuc2VuZCgpO1xuICB9XG5cbiAgcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQsIGxvYWRlcjogeGhyLCBzdGF0cyB9ID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHQgfHwgIXhocikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgYXMgTG9hZGVyQ29uZmlndXJhdGlvbjtcblxuICAgIC8vIGRvbid0IHByb2NlZWQgaWYgeGhyIGhhcyBiZWVuIGFib3J0ZWRcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vID49IEhFQURFUlNfUkVDRUlWRURcbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICBpZiAoc3RhdHMubG9hZGluZy5maXJzdCA9PT0gMCkge1xuICAgICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gTWF0aC5tYXgoXG4gICAgICAgICAgc2VsZi5wZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICBzdGF0cy5sb2FkaW5nLnN0YXJ0XG4gICAgICAgICk7XG4gICAgICAgIC8vIHJlYWR5U3RhdGUgPj0gMiBBTkQgcmVhZHlTdGF0ZSAhPT00IChyZWFkeVN0YXRlID0gSEVBREVSU19SRUNFSVZFRCB8fCBMT0FESU5HKSByZWFybSB0aW1lb3V0IGFzIHhociBub3QgZmluaXNoZWQgeWV0XG4gICAgICAgIGlmIChjb25maWcudGltZW91dCAhPT0gY29uZmlnLmxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcykge1xuICAgICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICAgIGNvbmZpZy50aW1lb3V0ID0gY29uZmlnLmxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcztcbiAgICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY29uZmlnLmxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyAtXG4gICAgICAgICAgICAgIChzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICAvLyBodHRwIHN0YXR1cyBiZXR3ZWVuIDIwMCB0byAyOTkgYXJlIGFsbCBzdWNjZXNzZnVsXG4gICAgICAgIGNvbnN0IHVzZVJlc3BvbnNlID0geGhyLnJlc3BvbnNlVHlwZSAhPT0gJ3RleHQnO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RhdHVzID49IDIwMCAmJlxuICAgICAgICAgIHN0YXR1cyA8IDMwMCAmJlxuICAgICAgICAgICgodXNlUmVzcG9uc2UgJiYgeGhyLnJlc3BvbnNlKSB8fCB4aHIucmVzcG9uc2VUZXh0ICE9PSBudWxsKVxuICAgICAgICApIHtcbiAgICAgICAgICBzdGF0cy5sb2FkaW5nLmVuZCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgc2VsZi5wZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3RcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB1c2VSZXNwb25zZSA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgY29uc3QgbGVuID1cbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IGxlbjtcbiAgICAgICAgICBzdGF0cy5id0VzdGltYXRlID1cbiAgICAgICAgICAgIChzdGF0cy50b3RhbCAqIDgwMDApIC8gKHN0YXRzLmxvYWRpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5maXJzdCk7XG4gICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvblByb2dyZXNzID0gdGhpcy5jYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgZGF0YSwgeGhyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXNwb25zZTogTG9hZGVyUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICB1cmw6IHhoci5yZXNwb25zZVVSTCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBjb2RlOiBzdGF0dXMsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIHhocik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmV0cnlDb25maWcgPSBjb25maWcubG9hZFBvbGljeS5lcnJvclJldHJ5O1xuICAgICAgICAgIGNvbnN0IHJldHJ5Q291bnQgPSBzdGF0cy5yZXRyeTtcbiAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgIGlmIChzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgZmFsc2UsIHN0YXR1cykpIHtcbiAgICAgICAgICAgIHRoaXMucmV0cnkocmV0cnlDb25maWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYCR7c3RhdHVzfSB3aGlsZSBsb2FkaW5nICR7Y29udGV4dC51cmx9YCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcyEub25FcnJvcihcbiAgICAgICAgICAgICAgeyBjb2RlOiBzdGF0dXMsIHRleHQ6IHhoci5zdGF0dXNUZXh0IH0sXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIHhocixcbiAgICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9hZHRpbWVvdXQoKSB7XG4gICAgY29uc3QgcmV0cnlDb25maWcgPSB0aGlzLmNvbmZpZz8ubG9hZFBvbGljeS50aW1lb3V0UmV0cnk7XG4gICAgY29uc3QgcmV0cnlDb3VudCA9IHRoaXMuc3RhdHMucmV0cnk7XG4gICAgaWYgKHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCB0cnVlKSkge1xuICAgICAgdGhpcy5yZXRyeShyZXRyeUNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci53YXJuKGB0aW1lb3V0IHdoaWxlIGxvYWRpbmcgJHt0aGlzLmNvbnRleHQudXJsfWApO1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3M7XG4gICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5sb2FkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHJ5KHJldHJ5Q29uZmlnOiBSZXRyeUNvbmZpZykge1xuICAgIGNvbnN0IHsgY29udGV4dCwgc3RhdHMgfSA9IHRoaXM7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgc3RhdHMucmV0cnkpO1xuICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgbG9nZ2VyLndhcm4oXG4gICAgICBgJHtzdGF0dXMgPyAnSFRUUCBTdGF0dXMgJyArIHN0YXR1cyA6ICdUaW1lb3V0J30gd2hpbGUgbG9hZGluZyAke1xuICAgICAgICBjb250ZXh0LnVybFxuICAgICAgfSwgcmV0cnlpbmcgJHtzdGF0cy5yZXRyeX0vJHtyZXRyeUNvbmZpZy5tYXhOdW1SZXRyeX0gaW4gJHtcbiAgICAgICAgdGhpcy5yZXRyeURlbGF5XG4gICAgICB9bXNgXG4gICAgKTtcbiAgICAvLyBhYm9ydCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGVcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgLy8gc2NoZWR1bGUgcmV0cnlcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoXG4gICAgICB0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLFxuICAgICAgdGhpcy5yZXRyeURlbGF5XG4gICAgKTtcbiAgfVxuXG4gIGxvYWRwcm9ncmVzcyhldmVudDogUHJvZ3Jlc3NFdmVudCkge1xuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0cztcblxuICAgIHN0YXRzLmxvYWRlZCA9IGV2ZW50LmxvYWRlZDtcbiAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgc3RhdHMudG90YWwgPSBldmVudC50b3RhbDtcbiAgICB9XG4gIH1cblxuICBnZXRDYWNoZUFnZSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICBsZXQgcmVzdWx0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICBpZiAoXG4gICAgICB0aGlzLmxvYWRlciAmJlxuICAgICAgQUdFX0hFQURFUl9MSU5FX1JFR0VYLnRlc3QodGhpcy5sb2FkZXIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgKSB7XG4gICAgICBjb25zdCBhZ2VIZWFkZXIgPSB0aGlzLmxvYWRlci5nZXRSZXNwb25zZUhlYWRlcignYWdlJyk7XG4gICAgICByZXN1bHQgPSBhZ2VIZWFkZXIgPyBwYXJzZUZsb2F0KGFnZUhlYWRlcikgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0UmVzcG9uc2VIZWFkZXIobmFtZTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5sb2FkZXIgJiZcbiAgICAgIG5ldyBSZWdFeHAoYF4ke25hbWV9OlxcXFxzKltcXFxcZC5dK1xcXFxzKiRgLCAnaW0nKS50ZXN0KFxuICAgICAgICB0aGlzLmxvYWRlci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBYaHJMb2FkZXI7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBDaHVua0NhY2hlIHtcbiAgcHJpdmF0ZSBjaHVua3M6IEFycmF5PFVpbnQ4QXJyYXk+ID0gW107XG4gIHB1YmxpYyBkYXRhTGVuZ3RoOiBudW1iZXIgPSAwO1xuXG4gIHB1c2goY2h1bms6IFVpbnQ4QXJyYXkpIHtcbiAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLmRhdGFMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICB9XG5cbiAgZmx1c2goKTogVWludDhBcnJheSB7XG4gICAgY29uc3QgeyBjaHVua3MsIGRhdGFMZW5ndGggfSA9IHRoaXM7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoIWNodW5rcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9IGVsc2UgaWYgKGNodW5rcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJlc3VsdCA9IGNodW5rc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY29uY2F0VWludDhBcnJheXMoY2h1bmtzLCBkYXRhTGVuZ3RoKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLmNodW5rcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGF0YUxlbmd0aCA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uY2F0VWludDhBcnJheXMoXG4gIGNodW5rczogQXJyYXk8VWludDhBcnJheT4sXG4gIGRhdGFMZW5ndGg6IG51bWJlclxuKTogVWludDhBcnJheSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGRhdGFMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpXTtcbiAgICByZXN1bHQuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7XG4gIExvYWRlckNhbGxiYWNrcyxcbiAgTG9hZGVyQ29udGV4dCxcbiAgTG9hZGVyLFxuICBMb2FkZXJTdGF0cyxcbiAgTG9hZGVyQ29uZmlndXJhdGlvbixcbiAgTG9hZGVyT25Qcm9ncmVzcyxcbiAgTG9hZGVyUmVzcG9uc2UsXG59IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgeyBMb2FkU3RhdHMgfSBmcm9tICcuLi9sb2FkZXIvbG9hZC1zdGF0cyc7XG5pbXBvcnQgQ2h1bmtDYWNoZSBmcm9tICcuLi9kZW11eC9jaHVuay1jYWNoZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaFN1cHBvcnRlZCgpIHtcbiAgaWYgKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzZWxmLmZldGNoICYmXG4gICAgc2VsZi5BYm9ydENvbnRyb2xsZXIgJiZcbiAgICBzZWxmLlJlYWRhYmxlU3RyZWFtICYmXG4gICAgc2VsZi5SZXF1ZXN0XG4gICkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgc2VsZi5SZWFkYWJsZVN0cmVhbSh7fSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBub29wICovXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgQllURVJBTkdFID0gLyhcXGQrKS0oXFxkKylcXC8oXFxkKykvO1xuXG5jbGFzcyBGZXRjaExvYWRlciBpbXBsZW1lbnRzIExvYWRlcjxMb2FkZXJDb250ZXh0PiB7XG4gIHByaXZhdGUgZmV0Y2hTZXR1cDogRnVuY3Rpb247XG4gIHByaXZhdGUgcmVxdWVzdFRpbWVvdXQ/OiBudW1iZXI7XG4gIHByaXZhdGUgcmVxdWVzdCE6IFJlcXVlc3Q7XG4gIHByaXZhdGUgcmVzcG9uc2UhOiBSZXNwb25zZTtcbiAgcHJpdmF0ZSBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXI7XG4gIHB1YmxpYyBjb250ZXh0ITogTG9hZGVyQ29udGV4dDtcbiAgcHJpdmF0ZSBjb25maWc6IExvYWRlckNvbmZpZ3VyYXRpb24gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjYWxsYmFja3M6IExvYWRlckNhbGxiYWNrczxMb2FkZXJDb250ZXh0PiB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgc3RhdHM6IExvYWRlclN0YXRzO1xuICBwcml2YXRlIGxvYWRlcjogUmVzcG9uc2UgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWcgLyogSGxzQ29uZmlnICovKSB7XG4gICAgdGhpcy5mZXRjaFNldHVwID0gY29uZmlnLmZldGNoU2V0dXAgfHwgZ2V0UmVxdWVzdDtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgc2VsZi5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLnN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmxvYWRlciA9IHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgfVxuXG4gIGFib3J0SW50ZXJuYWwoKTogdm9pZCB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlO1xuICAgIGlmICghcmVzcG9uc2U/Lm9rKSB7XG4gICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuICB9XG5cbiAgYWJvcnQoKTogdm9pZCB7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgaWYgKHRoaXMuY2FsbGJhY2tzPy5vbkFib3J0KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkFib3J0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgfVxuICB9XG5cbiAgbG9hZChcbiAgICBjb250ZXh0OiBMb2FkZXJDb250ZXh0LFxuICAgIGNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbixcbiAgICBjYWxsYmFja3M6IExvYWRlckNhbGxiYWNrczxMb2FkZXJDb250ZXh0PlxuICApOiB2b2lkIHtcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgaWYgKHN0YXRzLmxvYWRpbmcuc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4nKTtcbiAgICB9XG4gICAgc3RhdHMubG9hZGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBjb25zdCBpbml0UGFyYW1zID0gZ2V0UmVxdWVzdFBhcmFtZXRlcnMoY29udGV4dCwgdGhpcy5jb250cm9sbGVyLnNpZ25hbCk7XG4gICAgY29uc3Qgb25Qcm9ncmVzczogTG9hZGVyT25Qcm9ncmVzczxMb2FkZXJDb250ZXh0PiB8IHVuZGVmaW5lZCA9XG4gICAgICBjYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICBjb25zdCBpc0FycmF5QnVmZmVyID0gY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcic7XG4gICAgY29uc3QgTEVOR1RIID0gaXNBcnJheUJ1ZmZlciA/ICdieXRlTGVuZ3RoJyA6ICdsZW5ndGgnO1xuICAgIGNvbnN0IHsgbWF4VGltZVRvRmlyc3RCeXRlTXMsIG1heExvYWRUaW1lTXMgfSA9IGNvbmZpZy5sb2FkUG9saWN5O1xuXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB0aGlzLnJlcXVlc3QgPSB0aGlzLmZldGNoU2V0dXAoY29udGV4dCwgaW5pdFBhcmFtcyk7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgY29uZmlnLnRpbWVvdXQgPVxuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXMgJiYgTnVtYmVyLmlzRmluaXRlKG1heFRpbWVUb0ZpcnN0Qnl0ZU1zKVxuICAgICAgICA/IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zXG4gICAgICAgIDogbWF4TG9hZFRpbWVNcztcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgY2FsbGJhY2tzLm9uVGltZW91dChzdGF0cywgY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuXG4gICAgc2VsZlxuICAgICAgLmZldGNoKHRoaXMucmVxdWVzdClcbiAgICAgIC50aGVuKChyZXNwb25zZTogUmVzcG9uc2UpOiBQcm9taXNlPHN0cmluZyB8IEFycmF5QnVmZmVyPiA9PiB7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLmxvYWRlciA9IHJlc3BvbnNlO1xuXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5zdGFydCk7XG5cbiAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIGNvbmZpZy50aW1lb3V0ID0gbWF4TG9hZFRpbWVNcztcbiAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICAgICAgY2FsbGJhY2tzLm9uVGltZW91dChzdGF0cywgY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgICAgIH0sIG1heExvYWRUaW1lTXMgLSAoZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IHsgc3RhdHVzLCBzdGF0dXNUZXh0IH0gPSByZXNwb25zZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRmV0Y2hFcnJvcihcbiAgICAgICAgICAgIHN0YXR1c1RleHQgfHwgJ2ZldGNoLCBiYWQgbmV0d29yayByZXNwb25zZScsXG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHMubG9hZGluZy5maXJzdCA9IGZpcnN0O1xuXG4gICAgICAgIHN0YXRzLnRvdGFsID0gZ2V0Q29udGVudExlbmd0aChyZXNwb25zZS5oZWFkZXJzKSB8fCBzdGF0cy50b3RhbDtcblxuICAgICAgICBpZiAob25Qcm9ncmVzcyAmJiBOdW1iZXIuaXNGaW5pdGUoY29uZmlnLmhpZ2hXYXRlck1hcmspKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZFByb2dyZXNzaXZlbHkoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGNvbmZpZy5oaWdoV2F0ZXJNYXJrLFxuICAgICAgICAgICAgb25Qcm9ncmVzc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKChyZXNwb25zZURhdGE6IHN0cmluZyB8IEFycmF5QnVmZmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVzcG9uc2UgfSA9IHRoaXM7XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICBzdGF0cy5sb2FkaW5nLmVuZCA9IE1hdGgubWF4KFxuICAgICAgICAgIHNlbGYucGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgc3RhdHMubG9hZGluZy5maXJzdFxuICAgICAgICApO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHJlc3BvbnNlRGF0YVtMRU5HVEhdO1xuICAgICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9hZGVyUmVzcG9uc2U6IExvYWRlclJlc3BvbnNlID0ge1xuICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgICBjb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgIU51bWJlci5pc0Zpbml0ZShjb25maWcuaGlnaFdhdGVyTWFyaykpIHtcbiAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCByZXNwb25zZURhdGEsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrcy5vblN1Y2Nlc3MobG9hZGVyUmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCByZXNwb25zZSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ09SUyBlcnJvcnMgcmVzdWx0IGluIGFuIHVuZGVmaW5lZCBjb2RlLiBTZXQgaXQgdG8gMCBoZXJlIHRvIGFsaWduIHdpdGggWEhSJ3MgYmVoYXZpb3JcbiAgICAgICAgLy8gd2hlbiBkZXN0cm95aW5nLCAnZXJyb3InIGl0c2VsZiBjYW4gYmUgdW5kZWZpbmVkXG4gICAgICAgIGNvbnN0IGNvZGU6IG51bWJlciA9ICFlcnJvciA/IDAgOiBlcnJvci5jb2RlIHx8IDA7XG4gICAgICAgIGNvbnN0IHRleHQ6IHN0cmluZyA9ICFlcnJvciA/IG51bGwgOiBlcnJvci5tZXNzYWdlO1xuICAgICAgICBjYWxsYmFja3Mub25FcnJvcihcbiAgICAgICAgICB7IGNvZGUsIHRleHQgfSxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGVycm9yID8gZXJyb3IuZGV0YWlscyA6IG51bGwsXG4gICAgICAgICAgc3RhdHNcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgZ2V0Q2FjaGVBZ2UoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgbGV0IHJlc3VsdDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IGFnZUhlYWRlciA9IHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQoJ2FnZScpO1xuICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldFJlc3BvbnNlSGVhZGVyKG5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlID8gdGhpcy5yZXNwb25zZS5oZWFkZXJzLmdldChuYW1lKSA6IG51bGw7XG4gIH1cblxuICBwcml2YXRlIGxvYWRQcm9ncmVzc2l2ZWx5KFxuICAgIHJlc3BvbnNlOiBSZXNwb25zZSxcbiAgICBzdGF0czogTG9hZGVyU3RhdHMsXG4gICAgY29udGV4dDogTG9hZGVyQ29udGV4dCxcbiAgICBoaWdoV2F0ZXJNYXJrOiBudW1iZXIgPSAwLFxuICAgIG9uUHJvZ3Jlc3M6IExvYWRlck9uUHJvZ3Jlc3M8TG9hZGVyQ29udGV4dD5cbiAgKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4ge1xuICAgIGNvbnN0IGNodW5rQ2FjaGUgPSBuZXcgQ2h1bmtDYWNoZSgpO1xuICAgIGNvbnN0IHJlYWRlciA9IChyZXNwb25zZS5ib2R5IGFzIFJlYWRhYmxlU3RyZWFtKS5nZXRSZWFkZXIoKTtcblxuICAgIGNvbnN0IHB1bXAgPSAoKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4gPT4ge1xuICAgICAgcmV0dXJuIHJlYWRlclxuICAgICAgICAucmVhZCgpXG4gICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGRhdGEuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGNodW5rQ2FjaGUuZGF0YUxlbmd0aCkge1xuICAgICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVua0NhY2hlLmZsdXNoKCksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjaHVuazogVWludDhBcnJheSA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgY29uc3QgbGVuID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIHN0YXRzLmxvYWRlZCArPSBsZW47XG4gICAgICAgICAgaWYgKGxlbiA8IGhpZ2hXYXRlck1hcmsgfHwgY2h1bmtDYWNoZS5kYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUaGUgY3VycmVudCBjaHVuayBpcyB0b28gc21hbGwgdG8gdG8gYmUgZW1pdHRlZCBvciB0aGUgY2FjaGUgYWxyZWFkeSBoYXMgZGF0YVxuICAgICAgICAgICAgLy8gUHVzaCBpdCB0byB0aGUgY2FjaGVcbiAgICAgICAgICAgIGNodW5rQ2FjaGUucHVzaChjaHVuayk7XG4gICAgICAgICAgICBpZiAoY2h1bmtDYWNoZS5kYXRhTGVuZ3RoID49IGhpZ2hXYXRlck1hcmspIHtcbiAgICAgICAgICAgICAgLy8gZmx1c2ggaW4gb3JkZXIgdG8gam9pbiB0aGUgdHlwZWQgYXJyYXlzXG4gICAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rQ2FjaGUuZmx1c2goKSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vdGhpbmcgY2FjaGVkIGFscmVhZHksIGFuZCB0aGUgY2hhY2hlIGlzIGxhcmdlIGVub3VnaFxuICAgICAgICAgICAgLy8ganVzdCBlbWl0IHRoZSBwcm9ncmVzcyBldmVudFxuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmssIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAvKiBhYm9ydGVkICovXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gcHVtcCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQ6IExvYWRlckNvbnRleHQsIHNpZ25hbCk6IGFueSB7XG4gIGNvbnN0IGluaXRQYXJhbXM6IGFueSA9IHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIG1vZGU6ICdjb3JzJyxcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICBzaWduYWwsXG4gICAgaGVhZGVyczogbmV3IHNlbGYuSGVhZGVycyhPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LmhlYWRlcnMpKSxcbiAgfTtcblxuICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgIGluaXRQYXJhbXMuaGVhZGVycy5zZXQoXG4gICAgICAnUmFuZ2UnLFxuICAgICAgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyBTdHJpbmcoY29udGV4dC5yYW5nZUVuZCAtIDEpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBpbml0UGFyYW1zO1xufVxuXG5mdW5jdGlvbiBnZXRCeXRlUmFuZ2VMZW5ndGgoYnl0ZVJhbmdlSGVhZGVyOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCByZXN1bHQgPSBCWVRFUkFOR0UuZXhlYyhieXRlUmFuZ2VIZWFkZXIpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdFsyXSkgLSBwYXJzZUludChyZXN1bHRbMV0pICsgMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb250ZW50TGVuZ3RoKGhlYWRlcnM6IEhlYWRlcnMpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCBjb250ZW50UmFuZ2UgPSBoZWFkZXJzLmdldCgnQ29udGVudC1SYW5nZScpO1xuICBpZiAoY29udGVudFJhbmdlKSB7XG4gICAgY29uc3QgYnl0ZVJhbmdlTGVuZ3RoID0gZ2V0Qnl0ZVJhbmdlTGVuZ3RoKGNvbnRlbnRSYW5nZSk7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShieXRlUmFuZ2VMZW5ndGgpKSB7XG4gICAgICByZXR1cm4gYnl0ZVJhbmdlTGVuZ3RoO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gIGlmIChjb250ZW50TGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlcXVlc3QoY29udGV4dDogTG9hZGVyQ29udGV4dCwgaW5pdFBhcmFtczogYW55KTogUmVxdWVzdCB7XG4gIHJldHVybiBuZXcgc2VsZi5SZXF1ZXN0KGNvbnRleHQudXJsLCBpbml0UGFyYW1zKTtcbn1cblxuY2xhc3MgRmV0Y2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIGNvZGU6IG51bWJlcjtcbiAgcHVibGljIGRldGFpbHM6IGFueTtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBjb2RlOiBudW1iZXIsIGRldGFpbHM6IGFueSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGZXRjaExvYWRlcjtcbiIsImltcG9ydCBBYnJDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hYnItY29udHJvbGxlcic7XG5pbXBvcnQgQXVkaW9TdHJlYW1Db250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgQXVkaW9UcmFja0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIH0gZnJvbSAnLi9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQgQnVmZmVyQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgVGltZWxpbmVDb250cm9sbGVyIH0gZnJvbSAnLi9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXInO1xuaW1wb3J0IENhcExldmVsQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXInO1xuaW1wb3J0IEZQU0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyJztcbmltcG9ydCBFTUVDb250cm9sbGVyLCB7XG4gIE1lZGlhS2V5U2Vzc2lvbkNvbnRleHQsXG59IGZyb20gJy4vY29udHJvbGxlci9lbWUtY29udHJvbGxlcic7XG5pbXBvcnQgQ01DRENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2NtY2QtY29udHJvbGxlcic7XG5pbXBvcnQgQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvY29udGVudC1zdGVlcmluZy1jb250cm9sbGVyJztcbmltcG9ydCBFcnJvckNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Vycm9yLWNvbnRyb2xsZXInO1xuaW1wb3J0IFhockxvYWRlciBmcm9tICcuL3V0aWxzL3hoci1sb2FkZXInO1xuaW1wb3J0IEZldGNoTG9hZGVyLCB7IGZldGNoU3VwcG9ydGVkIH0gZnJvbSAnLi91dGlscy9mZXRjaC1sb2FkZXInO1xuaW1wb3J0IEN1ZXMgZnJvbSAnLi91dGlscy9jdWVzJztcbmltcG9ydCB7IHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyB9IGZyb20gJy4vdXRpbHMvbWVkaWFrZXlzLWhlbHBlcic7XG5pbXBvcnQgeyBJTG9nZ2VyLCBsb2dnZXIgfSBmcm9tICcuL3V0aWxzL2xvZ2dlcic7XG5cbmltcG9ydCB0eXBlIEhscyBmcm9tICcuL2hscyc7XG5pbXBvcnQgdHlwZSB7IEN1ZXNJbnRlcmZhY2UgfSBmcm9tICcuL3V0aWxzL2N1ZXMnO1xuaW1wb3J0IHR5cGUgeyBNZWRpYUtleUZ1bmMsIEtleVN5c3RlbXMgfSBmcm9tICcuL3V0aWxzL21lZGlha2V5cy1oZWxwZXInO1xuaW1wb3J0IHR5cGUge1xuICBGcmFnbWVudExvYWRlckNvbnRleHQsXG4gIExvYWRlcixcbiAgTG9hZGVyQ29udGV4dCxcbiAgUGxheWxpc3RMb2FkZXJDb250ZXh0LFxufSBmcm9tICcuL3R5cGVzL2xvYWRlcic7XG5cbmV4cG9ydCB0eXBlIEFCUkNvbnRyb2xsZXJDb25maWcgPSB7XG4gIGFickV3bWFGYXN0TGl2ZTogbnVtYmVyO1xuICBhYnJFd21hU2xvd0xpdmU6IG51bWJlcjtcbiAgYWJyRXdtYUZhc3RWb0Q6IG51bWJlcjtcbiAgYWJyRXdtYVNsb3dWb0Q6IG51bWJlcjtcbiAgLyoqXG4gICAqIERlZmF1bHQgYmFuZHdpZHRoIGVzdGltYXRlIGluIGJpdHMvcyBwcmlvciB0byBjb2xsZWN0aW5nIGZyYWdtZW50IGJhbmR3aWR0aCBzYW1wbGVzXG4gICAqL1xuICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiBudW1iZXI7XG4gIGFickJhbmRXaWR0aEZhY3RvcjogbnVtYmVyO1xuICBhYnJCYW5kV2lkdGhVcEZhY3RvcjogbnVtYmVyO1xuICBhYnJNYXhXaXRoUmVhbEJpdHJhdGU6IGJvb2xlYW47XG4gIG1heFN0YXJ2YXRpb25EZWxheTogbnVtYmVyO1xuICBtYXhMb2FkaW5nRGVsYXk6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIEJ1ZmZlckNvbnRyb2xsZXJDb25maWcgPSB7XG4gIGFwcGVuZEVycm9yTWF4UmV0cnk6IG51bWJlcjtcbiAgYmFja0J1ZmZlckxlbmd0aDogbnVtYmVyO1xuICBsaXZlRHVyYXRpb25JbmZpbml0eTogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBiYWNrQnVmZmVyTGVuZ3RoXG4gICAqL1xuICBsaXZlQmFja0J1ZmZlckxlbmd0aDogbnVtYmVyIHwgbnVsbDtcbn07XG5cbmV4cG9ydCB0eXBlIENhcExldmVsQ29udHJvbGxlckNvbmZpZyA9IHtcbiAgY2FwTGV2ZWxUb1BsYXllclNpemU6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBDTUNEQ29udHJvbGxlckNvbmZpZyA9IHtcbiAgc2Vzc2lvbklkPzogc3RyaW5nO1xuICBjb250ZW50SWQ/OiBzdHJpbmc7XG4gIHVzZUhlYWRlcnM/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgRFJNU3lzdGVtT3B0aW9ucyA9IHtcbiAgYXVkaW9Sb2J1c3RuZXNzPzogc3RyaW5nO1xuICB2aWRlb1JvYnVzdG5lc3M/OiBzdHJpbmc7XG4gIGF1ZGlvRW5jcnlwdGlvblNjaGVtZT86IHN0cmluZyB8IG51bGw7XG4gIHZpZGVvRW5jcnlwdGlvblNjaGVtZT86IHN0cmluZyB8IG51bGw7XG4gIHBlcnNpc3RlbnRTdGF0ZT86IE1lZGlhS2V5c1JlcXVpcmVtZW50O1xuICBkaXN0aW5jdGl2ZUlkZW50aWZpZXI/OiBNZWRpYUtleXNSZXF1aXJlbWVudDtcbiAgc2Vzc2lvblR5cGVzPzogc3RyaW5nW107XG4gIHNlc3Npb25UeXBlPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgRFJNU3lzdGVtQ29uZmlndXJhdGlvbiA9IHtcbiAgbGljZW5zZVVybDogc3RyaW5nO1xuICBzZXJ2ZXJDZXJ0aWZpY2F0ZVVybD86IHN0cmluZztcbiAgZ2VuZXJhdGVSZXF1ZXN0PzogKFxuICAgIHRoaXM6IEhscyxcbiAgICBpbml0RGF0YVR5cGU6IHN0cmluZyxcbiAgICBpbml0RGF0YTogQXJyYXlCdWZmZXIgfCBudWxsLFxuICAgIGtleUNvbnRleHQ6IE1lZGlhS2V5U2Vzc2lvbkNvbnRleHRcbiAgKSA9PlxuICAgIHwgeyBpbml0RGF0YVR5cGU6IHN0cmluZzsgaW5pdERhdGE6IEFycmF5QnVmZmVyIHwgbnVsbCB9XG4gICAgfCB1bmRlZmluZWRcbiAgICB8IG5ldmVyO1xufTtcblxuZXhwb3J0IHR5cGUgRFJNU3lzdGVtc0NvbmZpZ3VyYXRpb24gPSBQYXJ0aWFsPFxuICBSZWNvcmQ8S2V5U3lzdGVtcywgRFJNU3lzdGVtQ29uZmlndXJhdGlvbj5cbj47XG5cbmV4cG9ydCB0eXBlIEVNRUNvbnRyb2xsZXJDb25maWcgPSB7XG4gIGxpY2Vuc2VYaHJTZXR1cD86IChcbiAgICB0aGlzOiBIbHMsXG4gICAgeGhyOiBYTUxIdHRwUmVxdWVzdCxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBrZXlDb250ZXh0OiBNZWRpYUtleVNlc3Npb25Db250ZXh0LFxuICAgIGxpY2Vuc2VDaGFsbGVuZ2U6IFVpbnQ4QXJyYXlcbiAgKSA9PiB2b2lkIHwgVWludDhBcnJheSB8IFByb21pc2U8VWludDhBcnJheSB8IHZvaWQ+O1xuICBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjaz86IChcbiAgICB0aGlzOiBIbHMsXG4gICAgeGhyOiBYTUxIdHRwUmVxdWVzdCxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBrZXlDb250ZXh0OiBNZWRpYUtleVNlc3Npb25Db250ZXh0XG4gICkgPT4gQXJyYXlCdWZmZXI7XG4gIGVtZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHdpZGV2aW5lTGljZW5zZVVybD86IHN0cmluZztcbiAgZHJtU3lzdGVtczogRFJNU3lzdGVtc0NvbmZpZ3VyYXRpb247XG4gIGRybVN5c3RlbU9wdGlvbnM6IERSTVN5c3RlbU9wdGlvbnM7XG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6IE1lZGlhS2V5RnVuYyB8IG51bGw7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEZyYWdtZW50TG9hZGVyQ29uc3RydWN0b3Ige1xuICBuZXcgKGNvbmZnOiBIbHNDb25maWcpOiBMb2FkZXI8RnJhZ21lbnRMb2FkZXJDb250ZXh0Pjtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdFxuICovXG5leHBvcnQgdHlwZSBGcmFnbWVudExvYWRlckNvbmZpZyA9IHtcbiAgZnJhZ0xvYWRpbmdUaW1lT3V0OiBudW1iZXI7XG4gIGZyYWdMb2FkaW5nTWF4UmV0cnk6IG51bWJlcjtcbiAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiBudW1iZXI7XG4gIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBGUFNDb250cm9sbGVyQ29uZmlnID0ge1xuICBjYXBMZXZlbE9uRlBTRHJvcDogYm9vbGVhbjtcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IG51bWJlcjtcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIExldmVsQ29udHJvbGxlckNvbmZpZyA9IHtcbiAgc3RhcnRMZXZlbD86IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIE1QNFJlbXV4ZXJDb25maWcgPSB7XG4gIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGJvb2xlYW47XG4gIG1heEF1ZGlvRnJhbWVzRHJpZnQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxheWxpc3RMb2FkZXJDb25zdHJ1Y3RvciB7XG4gIG5ldyAoY29uZmc6IEhsc0NvbmZpZyk6IExvYWRlcjxQbGF5bGlzdExvYWRlckNvbnRleHQ+O1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBtYW5pZmVzdExvYWRQb2xpY3kuZGVmYXVsdCBhbmQgcGxheWxpc3RMb2FkUG9saWN5LmRlZmF1bHRcbiAqL1xuZXhwb3J0IHR5cGUgUGxheWxpc3RMb2FkZXJDb25maWcgPSB7XG4gIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IG51bWJlcjtcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6IG51bWJlcjtcbiAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogbnVtYmVyO1xuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IG51bWJlcjtcblxuICBsZXZlbExvYWRpbmdUaW1lT3V0OiBudW1iZXI7XG4gIGxldmVsTG9hZGluZ01heFJldHJ5OiBudW1iZXI7XG4gIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IG51bWJlcjtcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBIbHNMb2FkUG9saWNpZXMgPSB7XG4gIGZyYWdMb2FkUG9saWN5OiBMb2FkUG9saWN5O1xuICBrZXlMb2FkUG9saWN5OiBMb2FkUG9saWN5O1xuICBjZXJ0TG9hZFBvbGljeTogTG9hZFBvbGljeTtcbiAgcGxheWxpc3RMb2FkUG9saWN5OiBMb2FkUG9saWN5O1xuICBtYW5pZmVzdExvYWRQb2xpY3k6IExvYWRQb2xpY3k7XG4gIHN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5OiBMb2FkUG9saWN5O1xufTtcblxuZXhwb3J0IHR5cGUgTG9hZFBvbGljeSA9IHtcbiAgZGVmYXVsdDogTG9hZGVyQ29uZmlnO1xufTtcblxuZXhwb3J0IHR5cGUgTG9hZGVyQ29uZmlnID0ge1xuICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogbnVtYmVyOyAvLyBNYXggdGltZSB0byBmaXJzdCBieXRlXG4gIG1heExvYWRUaW1lTXM6IG51bWJlcjsgLy8gTWF4IHRpbWUgZm9yIGxvYWQgY29tcGxldGlvblxuICB0aW1lb3V0UmV0cnk6IFJldHJ5Q29uZmlnIHwgbnVsbDtcbiAgZXJyb3JSZXRyeTogUmV0cnlDb25maWcgfCBudWxsO1xufTtcblxuZXhwb3J0IHR5cGUgUmV0cnlDb25maWcgPSB7XG4gIG1heE51bVJldHJ5OiBudW1iZXI7IC8vIE1heGltdW0gbnVtYmVyIG9mIHJldHJpZXNcbiAgcmV0cnlEZWxheU1zOiBudW1iZXI7IC8vIFJldHJ5IGRlbGF5ID0gMl5yZXRyeUNvdW50ICogcmV0cnlEZWxheU1zIChleHBvbmVudGlhbCkgb3IgcmV0cnlDb3VudCAqIHJldHJ5RGVsYXlNcyAobGluZWFyKVxuICBtYXhSZXRyeURlbGF5TXM6IG51bWJlcjsgLy8gTWF4aW11bSBkZWxheSBiZXR3ZWVuIHJldHJpZXNcbiAgYmFja29mZj86ICdleHBvbmVudGlhbCcgfCAnbGluZWFyJzsgLy8gdXNlZCB0byBkZXRlcm1pbmUgcmV0cnkgYmFja29mZiBkdXJhdGlvbiAoc2VlIHJldHJ5RGVsYXlNcylcbn07XG5cbmV4cG9ydCB0eXBlIFN0cmVhbUNvbnRyb2xsZXJDb25maWcgPSB7XG4gIGF1dG9TdGFydExvYWQ6IGJvb2xlYW47XG4gIHN0YXJ0UG9zaXRpb246IG51bWJlcjtcbiAgZGVmYXVsdEF1ZGlvQ29kZWM/OiBzdHJpbmc7XG4gIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOiBudW1iZXI7XG4gIG1heEJ1ZmZlckxlbmd0aDogbnVtYmVyO1xuICBtYXhCdWZmZXJTaXplOiBudW1iZXI7XG4gIG1heEJ1ZmZlckhvbGU6IG51bWJlcjtcbiAgaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kOiBudW1iZXI7XG4gIG51ZGdlT2Zmc2V0OiBudW1iZXI7XG4gIG51ZGdlTWF4UmV0cnk6IG51bWJlcjtcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogbnVtYmVyO1xuICBtYXhNYXhCdWZmZXJMZW5ndGg6IG51bWJlcjtcbiAgc3RhcnRGcmFnUHJlZmV0Y2g6IGJvb2xlYW47XG4gIHRlc3RCYW5kd2lkdGg6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBMYXRlbmN5Q29udHJvbGxlckNvbmZpZyA9IHtcbiAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50OiBudW1iZXI7XG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudDogbnVtYmVyO1xuICBsaXZlU3luY0R1cmF0aW9uPzogbnVtYmVyO1xuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uPzogbnVtYmVyO1xuICBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZTogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgTWV0YWRhdGFDb250cm9sbGVyQ29uZmlnID0ge1xuICBlbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXM6IGJvb2xlYW47XG4gIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM6IGJvb2xlYW47XG4gIGVuYWJsZUlEM01ldGFkYXRhQ3VlczogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIFRpbWVsaW5lQ29udHJvbGxlckNvbmZpZyA9IHtcbiAgY3VlSGFuZGxlcjogQ3Vlc0ludGVyZmFjZTtcbiAgZW5hYmxlV2ViVlRUOiBib29sZWFuO1xuICBlbmFibGVJTVNDMTogYm9vbGVhbjtcbiAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IGJvb2xlYW47XG4gIGNhcHRpb25zVGV4dFRyYWNrMUxhYmVsOiBzdHJpbmc7XG4gIGNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZTogc3RyaW5nO1xuICBjYXB0aW9uc1RleHRUcmFjazJMYWJlbDogc3RyaW5nO1xuICBjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGU6IHN0cmluZztcbiAgY2FwdGlvbnNUZXh0VHJhY2szTGFiZWw6IHN0cmluZztcbiAgY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlOiBzdHJpbmc7XG4gIGNhcHRpb25zVGV4dFRyYWNrNExhYmVsOiBzdHJpbmc7XG4gIGNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZTogc3RyaW5nO1xuICByZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHk6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBUU0RlbXV4ZXJDb25maWcgPSB7XG4gIGZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHk6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBIbHNDb25maWcgPSB7XG4gIGRlYnVnOiBib29sZWFuIHwgSUxvZ2dlcjtcbiAgZW5hYmxlV29ya2VyOiBib29sZWFuO1xuICB3b3JrZXJQYXRoOiBudWxsIHwgc3RyaW5nO1xuICBlbmFibGVTb2Z0d2FyZUFFUzogYm9vbGVhbjtcbiAgbWluQXV0b0JpdHJhdGU6IG51bWJlcjtcbiAgaWdub3JlRGV2aWNlUGl4ZWxSYXRpbzogYm9vbGVhbjtcbiAgbG9hZGVyOiB7IG5ldyAoY29uZmc6IEhsc0NvbmZpZyk6IExvYWRlcjxMb2FkZXJDb250ZXh0PiB9O1xuICBmTG9hZGVyPzogRnJhZ21lbnRMb2FkZXJDb25zdHJ1Y3RvcjtcbiAgcExvYWRlcj86IFBsYXlsaXN0TG9hZGVyQ29uc3RydWN0b3I7XG4gIGZldGNoU2V0dXA/OiAoY29udGV4dDogTG9hZGVyQ29udGV4dCwgaW5pdFBhcmFtczogYW55KSA9PiBSZXF1ZXN0O1xuICB4aHJTZXR1cD86ICh4aHI6IFhNTEh0dHBSZXF1ZXN0LCB1cmw6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG5cbiAgLy8gQWx0IEF1ZGlvXG4gIGF1ZGlvU3RyZWFtQ29udHJvbGxlcj86IHR5cGVvZiBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG4gIGF1ZGlvVHJhY2tDb250cm9sbGVyPzogdHlwZW9mIEF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAvLyBTdWJ0aXRsZVxuICBzdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI/OiB0eXBlb2YgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcj86IHR5cGVvZiBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgdGltZWxpbmVDb250cm9sbGVyPzogdHlwZW9mIFRpbWVsaW5lQ29udHJvbGxlcjtcbiAgLy8gRU1FXG4gIGVtZUNvbnRyb2xsZXI/OiB0eXBlb2YgRU1FQ29udHJvbGxlcjtcbiAgLy8gQ01DRFxuICBjbWNkPzogQ01DRENvbnRyb2xsZXJDb25maWc7XG4gIGNtY2RDb250cm9sbGVyPzogdHlwZW9mIENNQ0RDb250cm9sbGVyO1xuICAvLyBDb250ZW50IFN0ZWVyaW5nXG4gIGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI/OiB0eXBlb2YgQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcblxuICBhYnJDb250cm9sbGVyOiB0eXBlb2YgQWJyQ29udHJvbGxlcjtcbiAgYnVmZmVyQ29udHJvbGxlcjogdHlwZW9mIEJ1ZmZlckNvbnRyb2xsZXI7XG4gIGNhcExldmVsQ29udHJvbGxlcjogdHlwZW9mIENhcExldmVsQ29udHJvbGxlcjtcbiAgZXJyb3JDb250cm9sbGVyOiB0eXBlb2YgRXJyb3JDb250cm9sbGVyO1xuICBmcHNDb250cm9sbGVyOiB0eXBlb2YgRlBTQ29udHJvbGxlcjtcbiAgcHJvZ3Jlc3NpdmU6IGJvb2xlYW47XG4gIGxvd0xhdGVuY3lNb2RlOiBib29sZWFuO1xufSAmIEFCUkNvbnRyb2xsZXJDb25maWcgJlxuICBCdWZmZXJDb250cm9sbGVyQ29uZmlnICZcbiAgQ2FwTGV2ZWxDb250cm9sbGVyQ29uZmlnICZcbiAgRU1FQ29udHJvbGxlckNvbmZpZyAmXG4gIEZQU0NvbnRyb2xsZXJDb25maWcgJlxuICBMZXZlbENvbnRyb2xsZXJDb25maWcgJlxuICBNUDRSZW11eGVyQ29uZmlnICZcbiAgU3RyZWFtQ29udHJvbGxlckNvbmZpZyAmXG4gIExhdGVuY3lDb250cm9sbGVyQ29uZmlnICZcbiAgTWV0YWRhdGFDb250cm9sbGVyQ29uZmlnICZcbiAgVGltZWxpbmVDb250cm9sbGVyQ29uZmlnICZcbiAgVFNEZW11eGVyQ29uZmlnICZcbiAgSGxzTG9hZFBvbGljaWVzICZcbiAgRnJhZ21lbnRMb2FkZXJDb25maWcgJlxuICBQbGF5bGlzdExvYWRlckNvbmZpZztcblxuY29uc3QgZGVmYXVsdExvYWRQb2xpY3k6IExvYWRlckNvbmZpZyA9IHtcbiAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDgwMDAsXG4gIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICB0aW1lb3V0UmV0cnk6IG51bGwsXG4gIGVycm9yUmV0cnk6IG51bGwsXG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqIElmIHBvc3NpYmxlLCBrZWVwIGhsc0RlZmF1bHRDb25maWcgc2hhbGxvd1xuICogSXQgaXMgY2xvbmVkIHdoZW5ldmVyIGEgbmV3IEhscyBpbnN0YW5jZSBpcyBjcmVhdGVkLCBieSBrZWVwaW5nIHRoZSBjb25maWdcbiAqIHNoYWxsb3cgdGhlIHByb3BlcnRpZXMgYXJlIGNsb25lZCwgYW5kIHdlIGRvbid0IGVuZCB1cCBtYW5pcHVsYXRpbmcgdGhlIGRlZmF1bHRcbiAqL1xuZXhwb3J0IGNvbnN0IGhsc0RlZmF1bHRDb25maWc6IEhsc0NvbmZpZyA9IHtcbiAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBzdGFydFBvc2l0aW9uOiAtMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWZhdWx0QXVkaW9Db2RlYzogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGRlYnVnOiBmYWxzZSwgLy8gdXNlZCBieSBsb2dnZXJcbiAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLCAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSwgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICBpZ25vcmVEZXZpY2VQaXhlbFJhdGlvOiBmYWxzZSwgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJMZW5ndGg6IDMwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGJhY2tCdWZmZXJMZW5ndGg6IEluZmluaXR5LCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVySG9sZTogMC4xLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMiwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBudWRnZU9mZnNldDogMC4xLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG51ZGdlTWF4UmV0cnk6IDMsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogMC4yNSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6IDMsIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudDogSW5maW5pdHksIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbjogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZTogMSwgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYmFja0J1ZmZlckxlbmd0aFxuICAgKi9cbiAgbGl2ZUJhY2tCdWZmZXJMZW5ndGg6IG51bGwsIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZW5hYmxlV29ya2VyOiB0cnVlLCAvLyB1c2VkIGJ5IHRyYW5zbXV4ZXJcbiAgd29ya2VyUGF0aDogbnVsbCwgLy8gdXNlZCBieSB0cmFuc211eGVyXG4gIGVuYWJsZVNvZnR3YXJlQUVTOiB0cnVlLCAvLyB1c2VkIGJ5IGRlY3J5cHRlclxuICBzdGFydExldmVsOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgbGV2ZWwtY29udHJvbGxlclxuICBzdGFydEZyYWdQcmVmZXRjaDogZmFsc2UsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IDUwMDAsIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMiwgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBhcHBlbmRFcnJvck1heFJldHJ5OiAzLCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGxvYWRlcjogWGhyTG9hZGVyLFxuICAvLyBsb2FkZXI6IEZldGNoTG9hZGVyLFxuICBmTG9hZGVyOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIHBMb2FkZXI6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgeGhyU2V0dXA6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSB4aHItbG9hZGVyXG4gIGxpY2Vuc2VYaHJTZXR1cDogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgYWJyQ29udHJvbGxlcjogQWJyQ29udHJvbGxlcixcbiAgYnVmZmVyQ29udHJvbGxlcjogQnVmZmVyQ29udHJvbGxlcixcbiAgY2FwTGV2ZWxDb250cm9sbGVyOiBDYXBMZXZlbENvbnRyb2xsZXIsXG4gIGVycm9yQ29udHJvbGxlcjogRXJyb3JDb250cm9sbGVyLFxuICBmcHNDb250cm9sbGVyOiBGUFNDb250cm9sbGVyLFxuICBzdHJldGNoU2hvcnRWaWRlb1RyYWNrOiBmYWxzZSwgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxuICBtYXhBdWRpb0ZyYW1lc0RyaWZ0OiAxLCAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIGZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHk6IHRydWUsIC8vIHVzZWQgYnkgdHMtZGVtdXhlclxuICBhYnJFd21hRmFzdExpdmU6IDMsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dMaXZlOiA5LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFGYXN0Vm9EOiAzLCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFTbG93Vm9EOiA5LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IDVlNSwgLy8gNTAwIGticHMgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyQmFuZFdpZHRoRmFjdG9yOiAwLjk1LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickJhbmRXaWR0aFVwRmFjdG9yOiAwLjcsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyTWF4V2l0aFJlYWxCaXRyYXRlOiBmYWxzZSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhTdGFydmF0aW9uRGVsYXk6IDQsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWF4TG9hZGluZ0RlbGF5OiA0LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1pbkF1dG9CaXRyYXRlOiAwLCAvLyB1c2VkIGJ5IGhsc1xuICBlbWVFbmFibGVkOiBmYWxzZSwgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICB3aWRldmluZUxpY2Vuc2VVcmw6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBkcm1TeXN0ZW1zOiB7fSwgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBkcm1TeXN0ZW1PcHRpb25zOiB7fSwgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jOiBfX1VTRV9FTUVfRFJNX19cbiAgICA/IHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xuICAgIDogbnVsbCwgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICB0ZXN0QmFuZHdpZHRoOiB0cnVlLFxuICBwcm9ncmVzc2l2ZTogZmFsc2UsXG4gIGxvd0xhdGVuY3lNb2RlOiB0cnVlLFxuICBjbWNkOiB1bmRlZmluZWQsXG4gIGVuYWJsZURhdGVSYW5nZU1ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgZW5hYmxlSUQzTWV0YWRhdGFDdWVzOiB0cnVlLFxuXG4gIGNlcnRMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDogZGVmYXVsdExvYWRQb2xpY3ksXG4gIH0sXG4gIGtleUxvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogODAwMCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMjAwMDAsXG4gICAgICAgIGJhY2tvZmY6ICdsaW5lYXInLFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDgsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAyMDAwMCxcbiAgICAgICAgYmFja29mZjogJ2xpbmVhcicsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG4gIG1hbmlmZXN0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiBJbmZpbml0eSxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMCxcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbiAgcGxheWxpc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwLFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwLFxuICAgICAgfSxcbiAgICB9LFxuICB9LFxuICBmcmFnTG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiAxMDAwMCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDEyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogNCxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDAsXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogNixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDAsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG4gIHN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDogX19VU0VfQ09OVEVOVF9TVEVFUklOR19fXG4gICAgICA/IHtcbiAgICAgICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgICAgICBtYXhOdW1SZXRyeTogMixcbiAgICAgICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgICAgIG1heFJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgIDogZGVmYXVsdExvYWRQb2xpY3ksXG4gIH0sXG5cbiAgLy8gVGhlc2UgZGVmYXVsdCBzZXR0aW5ncyBhcmUgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB0aGUgYWJvdmUgcG9saWNpZXNcbiAgLy8gYW5kIGFyZSBtYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICBtYW5pZmVzdExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6IDEsXG4gIG1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gIGxldmVsTG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICBsZXZlbExvYWRpbmdNYXhSZXRyeTogNCxcbiAgbGV2ZWxMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgZnJhZ0xvYWRpbmdUaW1lT3V0OiAyMDAwMCxcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeTogNixcbiAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICBmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG5cbiAgLy8gRHluYW1pYyBNb2R1bGVzXG4gIC4uLnRpbWVsaW5lQ29uZmlnKCksXG4gIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjogX19VU0VfU1VCVElUTEVTX19cbiAgICA/IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlclxuICAgIDogdW5kZWZpbmVkLFxuICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjogX19VU0VfU1VCVElUTEVTX19cbiAgICA/IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyXG4gICAgOiB1bmRlZmluZWQsXG4gIHRpbWVsaW5lQ29udHJvbGxlcjogX19VU0VfU1VCVElUTEVTX18gPyBUaW1lbGluZUNvbnRyb2xsZXIgOiB1bmRlZmluZWQsXG4gIGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogX19VU0VfQUxUX0FVRElPX18gPyBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgOiB1bmRlZmluZWQsXG4gIGF1ZGlvVHJhY2tDb250cm9sbGVyOiBfX1VTRV9BTFRfQVVESU9fXyA/IEF1ZGlvVHJhY2tDb250cm9sbGVyIDogdW5kZWZpbmVkLFxuICBlbWVDb250cm9sbGVyOiBfX1VTRV9FTUVfRFJNX18gPyBFTUVDb250cm9sbGVyIDogdW5kZWZpbmVkLFxuICBjbWNkQ29udHJvbGxlcjogX19VU0VfQ01DRF9fID8gQ01DRENvbnRyb2xsZXIgOiB1bmRlZmluZWQsXG4gIGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI6IF9fVVNFX0NPTlRFTlRfU1RFRVJJTkdfX1xuICAgID8gQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlclxuICAgIDogdW5kZWZpbmVkLFxufTtcblxuZnVuY3Rpb24gdGltZWxpbmVDb25maWcoKTogVGltZWxpbmVDb250cm9sbGVyQ29uZmlnIHtcbiAgcmV0dXJuIHtcbiAgICBjdWVIYW5kbGVyOiBDdWVzLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVXZWJWVFQ6IF9fVVNFX1NVQlRJVExFU19fLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVJTVNDMTogX19VU0VfU1VCVElUTEVTX18sIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZUNFQTcwOENhcHRpb25zOiBfX1VTRV9TVUJUSVRMRVNfXywgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWw6ICdFbmdsaXNoJywgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOiAnZW4nLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazJMYWJlbDogJ1NwYW5pc2gnLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGU6ICdlcycsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhYmVsOiAnVW5rbm93biBDQycsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZTogJycsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrNExhYmVsOiAnVW5rbm93biBDQycsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZTogJycsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIHJlbmRlclRleHRUcmFja3NOYXRpdmVseTogdHJ1ZSxcbiAgfTtcbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNvbmZpZyhcbiAgZGVmYXVsdENvbmZpZzogSGxzQ29uZmlnLFxuICB1c2VyQ29uZmlnOiBQYXJ0aWFsPEhsc0NvbmZpZz5cbik6IEhsc0NvbmZpZyB7XG4gIGlmIChcbiAgICAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHxcbiAgICAgIHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSAmJlxuICAgICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIklsbGVnYWwgaGxzLmpzIGNvbmZpZzogZG9uJ3QgbWl4IHVwIGxpdmVTeW5jRHVyYXRpb25Db3VudC9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgYW5kIGxpdmVTeW5jRHVyYXRpb24vbGl2ZU1heExhdGVuY3lEdXJhdGlvblwiXG4gICAgKTtcbiAgfVxuXG4gIGlmIChcbiAgICB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IDw9XG4gICAgICAgIHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50KVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudFwiIG11c3QgYmUgZ3JlYXRlciB0aGFuIFwibGl2ZVN5bmNEdXJhdGlvbkNvdW50XCInXG4gICAgKTtcbiAgfVxuXG4gIGlmIChcbiAgICB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDw9IHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbilcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uXCInXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRzQ29weSA9IGRlZXBDcHkoZGVmYXVsdENvbmZpZyk7XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBkZXByZWNhdGVkIGNvbmZpZyB2YWx1ZXNcbiAgY29uc3QgZGVwcmVjYXRlZFNldHRpbmdUeXBlcyA9IFsnbWFuaWZlc3QnLCAnbGV2ZWwnLCAnZnJhZyddO1xuICBjb25zdCBkZXByZWNhdGVkU2V0dGluZ3MgPSBbXG4gICAgJ1RpbWVPdXQnLFxuICAgICdNYXhSZXRyeScsXG4gICAgJ1JldHJ5RGVsYXknLFxuICAgICdNYXhSZXRyeVRpbWVvdXQnLFxuICBdO1xuICBkZXByZWNhdGVkU2V0dGluZ1R5cGVzLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICBjb25zdCBwb2xpY3lOYW1lID0gYCR7dHlwZSA9PT0gJ2xldmVsJyA/ICdwbGF5bGlzdCcgOiB0eXBlfUxvYWRQb2xpY3lgO1xuICAgIGNvbnN0IHBvbGljeU5vdFNldCA9IHVzZXJDb25maWdbcG9saWN5TmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXBvcnQ6IHN0cmluZ1tdID0gW107XG4gICAgZGVwcmVjYXRlZFNldHRpbmdzLmZvckVhY2goKHNldHRpbmcpID0+IHtcbiAgICAgIGNvbnN0IGRlcHJlY2F0ZWRTZXR0aW5nID0gYCR7dHlwZX1Mb2FkaW5nJHtzZXR0aW5nfWA7XG4gICAgICBjb25zdCB2YWx1ZSA9IHVzZXJDb25maWdbZGVwcmVjYXRlZFNldHRpbmddO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgcG9saWN5Tm90U2V0KSB7XG4gICAgICAgIHJlcG9ydC5wdXNoKGRlcHJlY2F0ZWRTZXR0aW5nKTtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3M6IExvYWRlckNvbmZpZyA9IGRlZmF1bHRzQ29weVtwb2xpY3lOYW1lXS5kZWZhdWx0O1xuICAgICAgICB1c2VyQ29uZmlnW3BvbGljeU5hbWVdID0geyBkZWZhdWx0OiBzZXR0aW5ncyB9O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmcpIHtcbiAgICAgICAgICBjYXNlICdUaW1lT3V0JzpcbiAgICAgICAgICAgIHNldHRpbmdzLm1heExvYWRUaW1lTXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldHRpbmdzLm1heFRpbWVUb0ZpcnN0Qnl0ZU1zID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNYXhSZXRyeSc6XG4gICAgICAgICAgICBzZXR0aW5ncy5lcnJvclJldHJ5IS5tYXhOdW1SZXRyeSA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0dGluZ3MudGltZW91dFJldHJ5IS5tYXhOdW1SZXRyeSA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUmV0cnlEZWxheSc6XG4gICAgICAgICAgICBzZXR0aW5ncy5lcnJvclJldHJ5IS5yZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldHRpbmdzLnRpbWVvdXRSZXRyeSEucmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNYXhSZXRyeVRpbWVvdXQnOlxuICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeSEubWF4UmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy50aW1lb3V0UmV0cnkhLm1heFJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVwb3J0Lmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgIGBobHMuanMgY29uZmlnOiBcIiR7cmVwb3J0LmpvaW4oXG4gICAgICAgICAgJ1wiLCBcIidcbiAgICAgICAgKX1cIiBzZXR0aW5nKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgXCIke3BvbGljeU5hbWV9XCI6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgdXNlckNvbmZpZ1twb2xpY3lOYW1lXVxuICAgICAgICApfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIC4uLmRlZmF1bHRzQ29weSxcbiAgICAuLi51c2VyQ29uZmlnLFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWVwQ3B5KG9iajogYW55KTogYW55IHtcbiAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmoubWFwKGRlZXBDcHkpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG4gICAgICByZXN1bHRba2V5XSA9IGRlZXBDcHkob2JqW2tleV0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVTdHJlYW1pbmdNb2RlKGNvbmZpZykge1xuICBjb25zdCBjdXJyZW50TG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgaWYgKGN1cnJlbnRMb2FkZXIgIT09IEZldGNoTG9hZGVyICYmIGN1cnJlbnRMb2FkZXIgIT09IFhockxvYWRlcikge1xuICAgIC8vIElmIGEgZGV2ZWxvcGVyIGhhcyBjb25maWd1cmVkIHRoZWlyIG93biBsb2FkZXIsIHJlc3BlY3QgdGhhdCBjaG9pY2VcbiAgICBsb2dnZXIubG9nKFxuICAgICAgJ1tjb25maWddOiBDdXN0b20gbG9hZGVyIGRldGVjdGVkLCBjYW5ub3QgZW5hYmxlIHByb2dyZXNzaXZlIHN0cmVhbWluZydcbiAgICApO1xuICAgIGNvbmZpZy5wcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNhblN0cmVhbVByb2dyZXNzaXZlbHkgPSBmZXRjaFN1cHBvcnRlZCgpO1xuICAgIGlmIChjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5KSB7XG4gICAgICBjb25maWcubG9hZGVyID0gRmV0Y2hMb2FkZXI7XG4gICAgICBjb25maWcucHJvZ3Jlc3NpdmUgPSB0cnVlO1xuICAgICAgY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTID0gdHJ1ZTtcbiAgICAgIGxvZ2dlci5sb2coJ1tjb25maWddOiBQcm9ncmVzc2l2ZSBzdHJlYW1pbmcgZW5hYmxlZCwgdXNpbmcgRmV0Y2hMb2FkZXInKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGJ1aWxkQWJzb2x1dGVVUkwgfSBmcm9tICd1cmwtdG9vbGtpdCc7XG5pbXBvcnQgUGxheWxpc3RMb2FkZXIgZnJvbSAnLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyJztcbmltcG9ydCBJRDNUcmFja0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2lkMy10cmFjay1jb250cm9sbGVyJztcbmltcG9ydCBMYXRlbmN5Q29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvbGF0ZW5jeS1jb250cm9sbGVyJztcbmltcG9ydCBMZXZlbENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgRnJhZ21lbnRUcmFja2VyIH0gZnJvbSAnLi9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IEtleUxvYWRlciBmcm9tICcuL2xvYWRlci9rZXktbG9hZGVyJztcbmltcG9ydCBTdHJlYW1Db250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgeyBpc1N1cHBvcnRlZCB9IGZyb20gJy4vaXMtc3VwcG9ydGVkJztcbmltcG9ydCB7IGxvZ2dlciwgZW5hYmxlTG9ncyB9IGZyb20gJy4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IGVuYWJsZVN0cmVhbWluZ01vZGUsIGhsc0RlZmF1bHRDb25maWcsIG1lcmdlQ29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBIZGNwTGV2ZWxzIH0gZnJvbSAnLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgdHlwZSB7IEhsc0V2ZW50RW1pdHRlciwgSGxzTGlzdGVuZXJzIH0gZnJvbSAnLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUgQXVkaW9UcmFja0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgQWJyQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgQnVmZmVyQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgQ2FwTGV2ZWxDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSBDTUNEQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvY21jZC1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIEVNRUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50QVBJLCBOZXR3b3JrQ29tcG9uZW50QVBJIH0gZnJvbSAnLi90eXBlcy9jb21wb25lbnQtYXBpJztcbmltcG9ydCB0eXBlIHsgTWVkaWFQbGF5bGlzdCB9IGZyb20gJy4vdHlwZXMvbWVkaWEtcGxheWxpc3QnO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IEhkY3BMZXZlbCwgTGV2ZWwgfSBmcm9tICcuL3R5cGVzL2xldmVsJztcbmltcG9ydCB0eXBlIHsgQnVmZmVySW5mbyB9IGZyb20gJy4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgdHlwZSBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSBCYXNlU3RyZWFtQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYmFzZS1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9jb250ZW50LXN0ZWVyaW5nLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgRXJyb3JDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9lcnJvci1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIEZQU0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyJztcblxuLyoqXG4gKiBUaGUgYEhsc2AgY2xhc3MgaXMgdGhlIGNvcmUgb2YgdGhlIEhMUy5qcyBsaWJyYXJ5IHVzZWQgdG8gaW5zdGFudGlhdGUgcGxheWVyIGluc3RhbmNlcy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGxzIGltcGxlbWVudHMgSGxzRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgZGVmYXVsdENvbmZpZzogSGxzQ29uZmlnIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgcnVudGltZSBjb25maWd1cmF0aW9uIHVzZWQgYnkgdGhlIHBsYXllci4gQXQgaW5zdGFudGlhdGlvbiB0aGlzIGlzIGNvbWJpbmF0aW9uIG9mIGBobHMudXNlckNvbmZpZ2AgbWVyZ2VkIG92ZXIgYEhscy5EZWZhdWx0Q29uZmlnYC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBjb25maWc6IEhsc0NvbmZpZztcblxuICAvKipcbiAgICogVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHByb3ZpZGVkIG9uIHBsYXllciBpbnN0YW50aWF0aW9uLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHVzZXJDb25maWc6IFBhcnRpYWw8SGxzQ29uZmlnPjtcblxuICBwcml2YXRlIGNvcmVDb21wb25lbnRzOiBDb21wb25lbnRBUElbXTtcbiAgcHJpdmF0ZSBuZXR3b3JrQ29udHJvbGxlcnM6IE5ldHdvcmtDb21wb25lbnRBUElbXTtcbiAgcHJpdmF0ZSBfZW1pdHRlcjogSGxzRXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBwcml2YXRlIF9hdXRvTGV2ZWxDYXBwaW5nOiBudW1iZXI7XG4gIHByaXZhdGUgX21heEhkY3BMZXZlbDogSGRjcExldmVsID0gbnVsbDtcbiAgcHJpdmF0ZSBhYnJDb250cm9sbGVyOiBBYnJDb250cm9sbGVyO1xuICBwcml2YXRlIGJ1ZmZlckNvbnRyb2xsZXI6IEJ1ZmZlckNvbnRyb2xsZXI7XG4gIHByaXZhdGUgY2FwTGV2ZWxDb250cm9sbGVyOiBDYXBMZXZlbENvbnRyb2xsZXI7XG4gIHByaXZhdGUgbGF0ZW5jeUNvbnRyb2xsZXI6IExhdGVuY3lDb250cm9sbGVyO1xuICBwcml2YXRlIGxldmVsQ29udHJvbGxlcjogTGV2ZWxDb250cm9sbGVyO1xuICBwcml2YXRlIHN0cmVhbUNvbnRyb2xsZXI6IFN0cmVhbUNvbnRyb2xsZXI7XG4gIHByaXZhdGUgYXVkaW9UcmFja0NvbnRyb2xsZXI6IEF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICBwcml2YXRlIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyOiBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgcHJpdmF0ZSBlbWVDb250cm9sbGVyOiBFTUVDb250cm9sbGVyO1xuICBwcml2YXRlIGNtY2RDb250cm9sbGVyOiBDTUNEQ29udHJvbGxlcjtcbiAgcHJpdmF0ZSBfbWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB1cmw6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZGVvLWRldi9obHMuanMgcGFja2FnZSB2ZXJzaW9uLlxuICAgKi9cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIF9fVkVSU0lPTl9fO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSByZXF1aXJlZCBNZWRpYVNvdXJjZSBFeHRlbnNpb25zIGFyZSBhdmFpbGFibGUuXG4gICAqL1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEV2ZW50cygpOiB0eXBlb2YgRXZlbnRzIHtcbiAgICByZXR1cm4gRXZlbnRzO1xuICB9XG5cbiAgc3RhdGljIGdldCBFcnJvclR5cGVzKCk6IHR5cGVvZiBFcnJvclR5cGVzIHtcbiAgICByZXR1cm4gRXJyb3JUeXBlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXJyb3JEZXRhaWxzKCk6IHR5cGVvZiBFcnJvckRldGFpbHMge1xuICAgIHJldHVybiBFcnJvckRldGFpbHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYXBwbGllZCB0byBuZXcgaW5zdGFuY2VzLlxuICAgKi9cbiAgc3RhdGljIGdldCBEZWZhdWx0Q29uZmlnKCk6IEhsc0NvbmZpZyB7XG4gICAgaWYgKCFIbHMuZGVmYXVsdENvbmZpZykge1xuICAgICAgcmV0dXJuIGhsc0RlZmF1bHRDb25maWc7XG4gICAgfVxuXG4gICAgcmV0dXJuIEhscy5kZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBhcHBsaWVkIHRvIG5ldyBpbnN0YW5jZXMuXG4gICAqL1xuICBzdGF0aWMgc2V0IERlZmF1bHRDb25maWcoZGVmYXVsdENvbmZpZzogSGxzQ29uZmlnKSB7XG4gICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gSExTIGNsaWVudCB0aGF0IGNhbiBhdHRhY2ggdG8gZXhhY3RseSBvbmUgYEhUTUxNZWRpYUVsZW1lbnRgLlxuICAgKiBAcGFyYW0gdXNlckNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcHBsaWVkIG92ZXIgYEhscy5EZWZhdWx0Q29uZmlnYFxuICAgKi9cbiAgY29uc3RydWN0b3IodXNlckNvbmZpZzogUGFydGlhbDxIbHNDb25maWc+ID0ge30pIHtcbiAgICBlbmFibGVMb2dzKHVzZXJDb25maWcuZGVidWcgfHwgZmFsc2UsICdIbHMgaW5zdGFuY2UnKTtcbiAgICBjb25zdCBjb25maWcgPSAodGhpcy5jb25maWcgPSBtZXJnZUNvbmZpZyhIbHMuRGVmYXVsdENvbmZpZywgdXNlckNvbmZpZykpO1xuICAgIHRoaXMudXNlckNvbmZpZyA9IHVzZXJDb25maWc7XG5cbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG5cbiAgICBpZiAoY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICBlbmFibGVTdHJlYW1pbmdNb2RlKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gY29yZSBjb250cm9sbGVycyBhbmQgbmV0d29yayBsb2FkZXJzXG4gICAgY29uc3Qge1xuICAgICAgYWJyQ29udHJvbGxlcjogQ29uZmlnQWJyQ29udHJvbGxlcixcbiAgICAgIGJ1ZmZlckNvbnRyb2xsZXI6IENvbmZpZ0J1ZmZlckNvbnRyb2xsZXIsXG4gICAgICBjYXBMZXZlbENvbnRyb2xsZXI6IENvbmZpZ0NhcExldmVsQ29udHJvbGxlcixcbiAgICAgIGVycm9yQ29udHJvbGxlcjogQ29uZmlnRXJyb3JDb250cm9sbGVyLFxuICAgICAgZnBzQ29udHJvbGxlcjogQ29uZmlnRnBzQ29udHJvbGxlcixcbiAgICB9ID0gY29uZmlnO1xuICAgIGNvbnN0IGVycm9yQ29udHJvbGxlciA9IG5ldyBDb25maWdFcnJvckNvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgYWJyQ29udHJvbGxlciA9ICh0aGlzLmFickNvbnRyb2xsZXIgPSBuZXcgQ29uZmlnQWJyQ29udHJvbGxlcih0aGlzKSk7XG4gICAgY29uc3QgYnVmZmVyQ29udHJvbGxlciA9ICh0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPVxuICAgICAgbmV3IENvbmZpZ0J1ZmZlckNvbnRyb2xsZXIodGhpcykpO1xuICAgIGNvbnN0IGNhcExldmVsQ29udHJvbGxlciA9ICh0aGlzLmNhcExldmVsQ29udHJvbGxlciA9XG4gICAgICBuZXcgQ29uZmlnQ2FwTGV2ZWxDb250cm9sbGVyKHRoaXMpKTtcblxuICAgIGNvbnN0IGZwc0NvbnRyb2xsZXIgPSBuZXcgQ29uZmlnRnBzQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBwbGF5TGlzdExvYWRlciA9IG5ldyBQbGF5bGlzdExvYWRlcih0aGlzKTtcbiAgICBjb25zdCBpZDNUcmFja0NvbnRyb2xsZXIgPSBuZXcgSUQzVHJhY2tDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgY29uc3QgQ29uZmlnQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciA9IGNvbmZpZy5jb250ZW50U3RlZXJpbmdDb250cm9sbGVyO1xuICAgIC8vIENvbmVudFN0ZWVyaW5nQ29udHJvbGxlciBpcyBkZWZpbmVkIGJlZm9yZSBMZXZlbENvbnRyb2xsZXIgdG8gcmVjZWl2ZSBNdWx0aXZhcmlhbnQgUGxheWxpc3QgZXZlbnRzIGZpcnN0XG4gICAgY29uc3QgY29udGVudFN0ZWVyaW5nID0gQ29uZmlnQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlclxuICAgICAgPyBuZXcgQ29uZmlnQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlcih0aGlzKVxuICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGxldmVsQ29udHJvbGxlciA9ICh0aGlzLmxldmVsQ29udHJvbGxlciA9IG5ldyBMZXZlbENvbnRyb2xsZXIoXG4gICAgICB0aGlzLFxuICAgICAgY29udGVudFN0ZWVyaW5nXG4gICAgKSk7XG4gICAgLy8gRnJhZ21lbnRUcmFja2VyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcbiAgICBjb25zdCBmcmFnbWVudFRyYWNrZXIgPSBuZXcgRnJhZ21lbnRUcmFja2VyKHRoaXMpO1xuICAgIGNvbnN0IGtleUxvYWRlciA9IG5ldyBLZXlMb2FkZXIodGhpcy5jb25maWcpO1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSAodGhpcy5zdHJlYW1Db250cm9sbGVyID0gbmV3IFN0cmVhbUNvbnRyb2xsZXIoXG4gICAgICB0aGlzLFxuICAgICAgZnJhZ21lbnRUcmFja2VyLFxuICAgICAga2V5TG9hZGVyXG4gICAgKSk7XG5cbiAgICAvLyBDYXAgbGV2ZWwgY29udHJvbGxlciB1c2VzIHN0cmVhbUNvbnRyb2xsZXIgdG8gZmx1c2ggdGhlIGJ1ZmZlclxuICAgIGNhcExldmVsQ29udHJvbGxlci5zZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIC8vIGZwc0NvbnRyb2xsZXIgdXNlcyBzdHJlYW1Db250cm9sbGVyIHRvIHN3aXRjaCB3aGVuIGZyYW1lcyBhcmUgYmVpbmcgZHJvcHBlZFxuICAgIGZwc0NvbnRyb2xsZXIuc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKTtcblxuICAgIGNvbnN0IG5ldHdvcmtDb250cm9sbGVyczogTmV0d29ya0NvbXBvbmVudEFQSVtdID0gW1xuICAgICAgcGxheUxpc3RMb2FkZXIsXG4gICAgICBsZXZlbENvbnRyb2xsZXIsXG4gICAgICBzdHJlYW1Db250cm9sbGVyLFxuICAgIF07XG4gICAgaWYgKGNvbnRlbnRTdGVlcmluZykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnNwbGljZSgxLCAwLCBjb250ZW50U3RlZXJpbmcpO1xuICAgIH1cblxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gbmV0d29ya0NvbnRyb2xsZXJzO1xuICAgIGNvbnN0IGNvcmVDb21wb25lbnRzOiBDb21wb25lbnRBUElbXSA9IFtcbiAgICAgIGFickNvbnRyb2xsZXIsXG4gICAgICBidWZmZXJDb250cm9sbGVyLFxuICAgICAgY2FwTGV2ZWxDb250cm9sbGVyLFxuICAgICAgZnBzQ29udHJvbGxlcixcbiAgICAgIGlkM1RyYWNrQ29udHJvbGxlcixcbiAgICAgIGZyYWdtZW50VHJhY2tlcixcbiAgICBdO1xuXG4gICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihcbiAgICAgIGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlcixcbiAgICAgIG5ldHdvcmtDb250cm9sbGVyc1xuICAgICk7XG4gICAgY29uc3QgQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3MgPSBjb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2goXG4gICAgICAgIG5ldyBBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcyh0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcilcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyIGJlY2F1c2UgdGhlIG9yZGVyIG9mIGV2ZW50IGhhbmRsaW5nIGlzIGltcG9ydGFudFxuICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoXG4gICAgICBjb25maWcuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIsXG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnNcbiAgICApO1xuICAgIGNvbnN0IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlckNsYXNzID0gY29uZmlnLnN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICBpZiAoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3MpIHtcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKFxuICAgICAgICBuZXcgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3ModGhpcywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLnRpbWVsaW5lQ29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgIGtleUxvYWRlci5lbWVDb250cm9sbGVyID0gdGhpcy5lbWVDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKFxuICAgICAgY29uZmlnLmVtZUNvbnRyb2xsZXIsXG4gICAgICBjb3JlQ29tcG9uZW50c1xuICAgICk7XG4gICAgdGhpcy5jbWNkQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihcbiAgICAgIGNvbmZpZy5jbWNkQ29udHJvbGxlcixcbiAgICAgIGNvcmVDb21wb25lbnRzXG4gICAgKTtcbiAgICB0aGlzLmxhdGVuY3lDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKFxuICAgICAgTGF0ZW5jeUNvbnRyb2xsZXIsXG4gICAgICBjb3JlQ29tcG9uZW50c1xuICAgICk7XG5cbiAgICB0aGlzLmNvcmVDb21wb25lbnRzID0gY29yZUNvbXBvbmVudHM7XG5cbiAgICAvLyBFcnJvciBjb250cm9sbGVyIGhhbmRsZXMgZXJyb3JzIGJlZm9yZSBhbmQgYWZ0ZXIgYWxsIG90aGVyIGNvbnRyb2xsZXJzXG4gICAgLy8gVGhpcyBsaXN0ZW5lciB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgYWxsIG90aGVyIGNvbnRyb2xsZXJzIGVycm9yIGxpc3RlbmVyc1xuICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKGVycm9yQ29udHJvbGxlcik7XG4gICAgY29uc3Qgb25FcnJvck91dCA9IGVycm9yQ29udHJvbGxlci5vbkVycm9yT3V0O1xuICAgIGlmICh0eXBlb2Ygb25FcnJvck91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5vbihFdmVudHMuRVJST1IsIG9uRXJyb3JPdXQsIGVycm9yQ29udHJvbGxlcik7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlQ29udHJvbGxlcihDb250cm9sbGVyQ2xhc3MsIGNvbXBvbmVudHMpIHtcbiAgICBpZiAoQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICBjb25zdCBjb250cm9sbGVySW5zdGFuY2UgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMpO1xuICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbnRyb2xsZXJJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udHJvbGxlckluc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIERlbGVnYXRlIHRoZSBFdmVudEVtaXR0ZXIgdGhyb3VnaCB0aGUgcHVibGljIEFQSSBvZiBIbHMuanNcbiAgb248RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycywgQ29udGV4dCA9IHVuZGVmaW5lZD4oXG4gICAgZXZlbnQ6IEUsXG4gICAgbGlzdGVuZXI6IEhsc0xpc3RlbmVyc1tFXSxcbiAgICBjb250ZXh0OiBDb250ZXh0ID0gdGhpcyBhcyBhbnlcbiAgKSB7XG4gICAgdGhpcy5fZW1pdHRlci5vbihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpO1xuICB9XG5cbiAgb25jZTxFIGV4dGVuZHMga2V5b2YgSGxzTGlzdGVuZXJzLCBDb250ZXh0ID0gdW5kZWZpbmVkPihcbiAgICBldmVudDogRSxcbiAgICBsaXN0ZW5lcjogSGxzTGlzdGVuZXJzW0VdLFxuICAgIGNvbnRleHQ6IENvbnRleHQgPSB0aGlzIGFzIGFueVxuICApIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9uY2UoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJlbW92ZUFsbExpc3RlbmVyczxFIGV4dGVuZHMga2V5b2YgSGxzTGlzdGVuZXJzPihldmVudD86IEUgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudCk7XG4gIH1cblxuICBvZmY8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycywgQ29udGV4dCA9IHVuZGVmaW5lZD4oXG4gICAgZXZlbnQ6IEUsXG4gICAgbGlzdGVuZXI/OiBIbHNMaXN0ZW5lcnNbRV0gfCB1bmRlZmluZWQsXG4gICAgY29udGV4dDogQ29udGV4dCA9IHRoaXMgYXMgYW55LFxuICAgIG9uY2U/OiBib29sZWFuIHwgdW5kZWZpbmVkXG4gICkge1xuICAgIHRoaXMuX2VtaXR0ZXIub2ZmKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCwgb25jZSk7XG4gIH1cblxuICBsaXN0ZW5lcnM8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oZXZlbnQ6IEUpOiBIbHNMaXN0ZW5lcnNbRV1bXSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJzKGV2ZW50KTtcbiAgfVxuXG4gIGVtaXQ8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oXG4gICAgZXZlbnQ6IEUsXG4gICAgbmFtZTogRSxcbiAgICBldmVudE9iamVjdDogUGFyYW1ldGVyczxIbHNMaXN0ZW5lcnNbRV0+WzFdXG4gICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmVtaXQoZXZlbnQsIG5hbWUsIGV2ZW50T2JqZWN0KTtcbiAgfVxuXG4gIHRyaWdnZXI8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oXG4gICAgZXZlbnQ6IEUsXG4gICAgZXZlbnRPYmplY3Q6IFBhcmFtZXRlcnM8SGxzTGlzdGVuZXJzW0VdPlsxXVxuICApOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5jb25maWcuZGVidWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAnQW4gaW50ZXJuYWwgZXJyb3IgaGFwcGVuZWQgd2hpbGUgaGFuZGxpbmcgZXZlbnQgJyArXG4gICAgICAgICAgICBldmVudCArXG4gICAgICAgICAgICAnLiBFcnJvciBtZXNzYWdlOiBcIicgK1xuICAgICAgICAgICAgZS5tZXNzYWdlICtcbiAgICAgICAgICAgICdcIi4gSGVyZSBpcyBhIHN0YWNrdHJhY2U6JyxcbiAgICAgICAgICBlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxpc3RlbmVyQ291bnQ8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oZXZlbnQ6IEUpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmxpc3RlbmVyQ291bnQoZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugb2YgdGhlIGluc3RhbmNlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGxvZ2dlci5sb2coJ2Rlc3Ryb3knKTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkRFU1RST1lJTkcsIHVuZGVmaW5lZCk7XG4gICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgIHRoaXMudXJsID0gbnVsbDtcblxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LmRlc3Ryb3koKSk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuY29yZUNvbXBvbmVudHMuZm9yRWFjaCgoY29tcG9uZW50KSA9PiBjb21wb25lbnQuZGVzdHJveSgpKTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgLy8gUmVtb3ZlIGFueSByZWZlcmVuY2VzIHRoYXQgY291bGQgYmUgaGVsZCBpbiBjb25maWcgb3B0aW9ucyBvciBjYWxsYmFja3NcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25maWcueGhyU2V0dXAgPSBjb25maWcuZmV0Y2hTZXR1cCA9IHVuZGVmaW5lZDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy51c2VyQ29uZmlnID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2hlcyBIbHMuanMgdG8gYSBtZWRpYSBlbGVtZW50XG4gICAqL1xuICBhdHRhY2hNZWRpYShtZWRpYTogSFRNTE1lZGlhRWxlbWVudCkge1xuICAgIGxvZ2dlci5sb2coJ2F0dGFjaE1lZGlhJyk7XG4gICAgdGhpcy5fbWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0FUVEFDSElORywgeyBtZWRpYTogbWVkaWEgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoIEhscy5qcyBmcm9tIHRoZSBtZWRpYVxuICAgKi9cbiAgZGV0YWNoTWVkaWEoKSB7XG4gICAgbG9nZ2VyLmxvZygnZGV0YWNoTWVkaWEnKTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdW5kZWZpbmVkKTtcbiAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgVVJMLiBDYW4gYmUgcmVsYXRpdmUgb3IgYWJzb2x1dGUuXG4gICAqL1xuICBsb2FkU291cmNlKHVybDogc3RyaW5nKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBsb2FkZWRTb3VyY2UgPSB0aGlzLnVybDtcbiAgICBjb25zdCBsb2FkaW5nU291cmNlID0gKHRoaXMudXJsID0gYnVpbGRBYnNvbHV0ZVVSTChcbiAgICAgIHNlbGYubG9jYXRpb24uaHJlZixcbiAgICAgIHVybCxcbiAgICAgIHtcbiAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlLFxuICAgICAgfVxuICAgICkpO1xuICAgIGxvZ2dlci5sb2coYGxvYWRTb3VyY2U6JHtsb2FkaW5nU291cmNlfWApO1xuICAgIGlmIChcbiAgICAgIG1lZGlhICYmXG4gICAgICBsb2FkZWRTb3VyY2UgJiZcbiAgICAgIChsb2FkZWRTb3VyY2UgIT09IGxvYWRpbmdTb3VyY2UgfHwgdGhpcy5idWZmZXJDb250cm9sbGVyLmhhc1NvdXJjZVR5cGVzKCkpXG4gICAgKSB7XG4gICAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgICB9XG4gICAgLy8gd2hlbiBhdHRhY2hpbmcgdG8gYSBzb3VyY2UgVVJMLCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZFxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgeyB1cmw6IHVybCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBsb2FkaW5nIGRhdGEgZnJvbSB0aGUgc3RyZWFtIHNvdXJjZS5cbiAgICogRGVwZW5kaW5nIG9uIGRlZmF1bHQgY29uZmlnLCBjbGllbnQgc3RhcnRzIGxvYWRpbmcgYXV0b21hdGljYWxseSB3aGVuIGEgc291cmNlIGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0UG9zaXRpb24gLSBTZXQgdGhlIHN0YXJ0IHBvc2l0aW9uIHRvIHN0cmVhbSBmcm9tLlxuICAgKiBEZWZhdWx0cyB0byAtMSAoTm9uZTogc3RhcnRzIGZyb20gZWFybGllc3QgcG9pbnQpXG4gICAqL1xuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbjogbnVtYmVyID0gLTEpIHtcbiAgICBsb2dnZXIubG9nKGBzdGFydExvYWQoJHtzdGFydFBvc2l0aW9ufSlgKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgICBjb250cm9sbGVyLnN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxvYWRpbmcgb2YgYW55IHN0cmVhbSBkYXRhLlxuICAgKi9cbiAgc3RvcExvYWQoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3RvcExvYWQnKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgICBjb250cm9sbGVyLnN0b3BMb2FkKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3dhcCB0aHJvdWdoIHBvc3NpYmxlIGF1ZGlvIGNvZGVjcyBpbiB0aGUgc3RyZWFtIChmb3IgZXhhbXBsZSB0byBzd2l0Y2ggZnJvbSBzdGVyZW8gdG8gNS4xKVxuICAgKi9cbiAgc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3dhcEF1ZGlvQ29kZWMnKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3dhcEF1ZGlvQ29kZWMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBtZWRpYS1lbGVtZW50IGZhaWxzLCB0aGlzIGFsbG93cyB0byBkZXRhY2ggYW5kIHRoZW4gcmUtYXR0YWNoIGl0XG4gICAqIGFzIG9uZSBjYWxsIChjb252ZW5pZW5jZSBtZXRob2QpLlxuICAgKlxuICAgKiBBdXRvbWF0aWMgcmVjb3Zlcnkgb2YgbWVkaWEtZXJyb3JzIGJ5IHRoaXMgcHJvY2VzcyBpcyBjb25maWd1cmFibGUuXG4gICAqL1xuICByZWNvdmVyTWVkaWFFcnJvcigpIHtcbiAgICBsb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5fbWVkaWE7XG4gICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCwgdXJsSWQgPSAwKSB7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIucmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCwgdXJsSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIGxldmVscyAodmFyaWFudHMpIHNvcnRlZCBieSBIRENQLUxFVkVMLCBCQU5EV0lEVEgsIFNDT1JFLCBhbmQgUkVTT0xVVElPTiAoaGVpZ2h0KVxuICAgKi9cbiAgZ2V0IGxldmVscygpOiBMZXZlbFtdIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbHM7XG4gICAgcmV0dXJuIGxldmVscyA/IGxldmVscyA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHF1YWxpdHkgbGV2ZWwgKHZhcmlhbnQpIGN1cnJlbnRseSBwbGF5ZWRcbiAgICovXG4gIGdldCBjdXJyZW50TGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBpbW1lZGlhdGVseS4gVGhpcyB3aWxsIGZsdXNoIHRoZSBjdXJyZW50IGJ1ZmZlciB0byByZXBsYWNlIHRoZSBxdWFsaXR5IGFzYXAuIFRoYXQgbWVhbnMgcGxheWJhY2sgd2lsbCBpbnRlcnJ1cHQgYXQgbGVhc3Qgc2hvcnRseSB0byByZS1idWZmZXIgYW5kIHJlLXN5bmMgZXZlbnR1YWxseS4gU2V0IHRvIC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uLlxuICAgKi9cbiAgc2V0IGN1cnJlbnRMZXZlbChuZXdMZXZlbDogbnVtYmVyKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGN1cnJlbnRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubG9hZExldmVsID0gbmV3TGV2ZWw7XG4gICAgdGhpcy5hYnJDb250cm9sbGVyLmNsZWFyVGltZXIoKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkIGFzIHNjaGVkdWxlZCBieSBzdHJlYW0gY29udHJvbGxlci5cbiAgICovXG4gIGdldCBuZXh0TGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YS5cbiAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgdmlkZW8gcXVhbGl0eSBhc2FwLCB3aXRob3V0IGludGVycnVwdGluZyBwbGF5YmFjay5cbiAgICogTWF5IGFib3J0IGN1cnJlbnQgbG9hZGluZyBvZiBkYXRhLCBhbmQgZmx1c2ggcGFydHMgb2YgYnVmZmVyIChvdXRzaWRlIGN1cnJlbnRseSBwbGF5ZWQgZnJhZ21lbnQgcmVnaW9uKS5cbiAgICogQHBhcmFtIG5ld0xldmVsIC0gUGFzcyAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IG5leHRMZXZlbChuZXdMZXZlbDogbnVtYmVyKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IG5leHRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcXVhbGl0eSBsZXZlbCBvZiB0aGUgY3VycmVudGx5IG9yIGxhc3QgKG9mIG5vbmUgaXMgbG9hZGVkIGN1cnJlbnRseSkgc2VnbWVudFxuICAgKi9cbiAgZ2V0IGxvYWRMZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YSBpbiBhIGNvbnNlcnZhdGl2ZSB3YXkuXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHF1YWxpdHkgd2l0aG91dCBmbHVzaGluZywgYnV0IGludGVycnVwdCBjdXJyZW50IGxvYWRpbmcuXG4gICAqIFRodXMgdGhlIG1vbWVudCB3aGVuIHRoZSBxdWFsaXR5IHN3aXRjaCB3aWxsIGFwcGVhciBpbiBlZmZlY3Qgd2lsbCBvbmx5IGJlIGFmdGVyIHRoZSBhbHJlYWR5IGV4aXN0aW5nIGJ1ZmZlci5cbiAgICogQHBhcmFtIG5ld0xldmVsIC0gUGFzcyAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IGxvYWRMZXZlbChuZXdMZXZlbDogbnVtYmVyKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGxvYWRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWRcbiAgICovXG4gIGdldCBuZXh0TG9hZExldmVsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBsb2FkZWQgc2VnbWVudCBpbiBhIGZ1bGx5IFwibm9uLWRlc3RydWN0aXZlXCIgd2F5LlxuICAgKiBTYW1lIGFzIGBsb2FkTGV2ZWxgIGJ1dCB3aWxsIHdhaXQgZm9yIG5leHQgc3dpdGNoICh1bnRpbCBjdXJyZW50IGxvYWRpbmcgaXMgZG9uZSkuXG4gICAqL1xuICBzZXQgbmV4dExvYWRMZXZlbChsZXZlbDogbnVtYmVyKSB7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBcImZpcnN0IGxldmVsXCI6IGxpa2UgYSBkZWZhdWx0IGxldmVsLCBpZiBub3Qgc2V0LFxuICAgKiBmYWxscyBiYWNrIHRvIGluZGV4IG9mIGZpcnN0IGxldmVsIHJlZmVyZW5jZWQgaW4gbWFuaWZlc3RcbiAgICovXG4gIGdldCBmaXJzdExldmVsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIFwiZmlyc3QtbGV2ZWxcIiwgc2VlIGdldHRlci5cbiAgICovXG4gIHNldCBmaXJzdExldmVsKG5ld0xldmVsOiBudW1iZXIpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgZmlyc3RMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAqL1xuICBnZXQgc3RhcnRMZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCAgc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAqL1xuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbDogbnVtYmVyKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IHN0YXJ0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICAvLyBpZiBub3QgaW4gYXV0b21hdGljIHN0YXJ0IGxldmVsIGRldGVjdGlvbiwgZW5zdXJlIHN0YXJ0TGV2ZWwgaXMgZ3JlYXRlciB0aGFuIG1pbkF1dG9MZXZlbFxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgIG5ld0xldmVsID0gTWF0aC5tYXgobmV3TGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKTtcbiAgICB9XG5cbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBsZXZlbCBjYXBwaW5nIGlzIGVuYWJsZWQuXG4gICAqIERlZmF1bHQgdmFsdWUgaXMgc2V0IHZpYSBgY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplYC5cbiAgICovXG4gIGdldCBjYXBMZXZlbFRvUGxheWVyU2l6ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemU7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBsZXZlbCBjYXBwaW5nLiBJZiBkaXNhYmxlZCBhZnRlciBwcmV2aW91c2x5IGVuYWJsZWQsIGBuZXh0TGV2ZWxTd2l0Y2hgIHdpbGwgYmUgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICAgKi9cbiAgc2V0IGNhcExldmVsVG9QbGF5ZXJTaXplKHNob3VsZFN0YXJ0Q2FwcGluZzogYm9vbGVhbikge1xuICAgIGNvbnN0IG5ld0NhcExldmVsVG9QbGF5ZXJTaXplID0gISFzaG91bGRTdGFydENhcHBpbmc7XG5cbiAgICBpZiAobmV3Q2FwTGV2ZWxUb1BsYXllclNpemUgIT09IHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICBpZiAobmV3Q2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIuc3RhcnRDYXBwaW5nKCk7IC8vIElmIGNhcHBpbmcgb2NjdXJzLCBuZXh0TGV2ZWxTd2l0Y2ggd2lsbCBoYXBwZW4gYmFzZWQgb24gc2l6ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyLnN0b3BDYXBwaW5nKCk7XG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7IC8vIE5vdyB3ZSdyZSB1bmNhcHBlZCwgZ2V0IHRoZSBuZXh0IGxldmVsIGFzYXAuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplID0gbmV3Q2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICovXG4gIGdldCBhdXRvTGV2ZWxDYXBwaW5nKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBiYW5kd2lkdGggZXN0aW1hdGUgaW4gYml0cyBwZXIgc2Vjb25kLCB3aGVuIGF2YWlsYWJsZS4gT3RoZXJ3aXNlLCBgTmFOYCBpcyByZXR1cm5lZC5cbiAgICovXG4gIGdldCBiYW5kd2lkdGhFc3RpbWF0ZSgpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgYndFc3RpbWF0b3IgfSA9IHRoaXMuYWJyQ29udHJvbGxlcjtcbiAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGltZSB0byBmaXJzdCBieXRlIGVzdGltYXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgdHRmYkVzdGltYXRlKCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBid0VzdGltYXRvciB9ID0gdGhpcy5hYnJDb250cm9sbGVyO1xuICAgIGlmICghYndFc3RpbWF0b3IpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiBid0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAqL1xuICBzZXQgYXV0b0xldmVsQ2FwcGluZyhuZXdMZXZlbDogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgIT09IG5ld0xldmVsKSB7XG4gICAgICBsb2dnZXIubG9nKGBzZXQgYXV0b0xldmVsQ2FwcGluZzoke25ld0xldmVsfWApO1xuICAgICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IG5ld0xldmVsO1xuICAgIH1cbiAgfVxuXG4gIGdldCBtYXhIZGNwTGV2ZWwoKTogSGRjcExldmVsIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4SGRjcExldmVsO1xuICB9XG5cbiAgc2V0IG1heEhkY3BMZXZlbCh2YWx1ZTogSGRjcExldmVsKSB7XG4gICAgaWYgKEhkY3BMZXZlbHMuaW5kZXhPZih2YWx1ZSkgPiAtMSkge1xuICAgICAgdGhpcy5fbWF4SGRjcExldmVsID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGVuYWJsZWRcbiAgICovXG4gIGdldCBhdXRvTGV2ZWxFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9PT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogTGV2ZWwgc2V0IG1hbnVhbGx5IChpZiBhbnkpXG4gICAqL1xuICBnZXQgbWFudWFsTGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogbWluIGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBjb25maWcubWluQXV0b0JpdHJhdGVcbiAgICovXG4gIGdldCBtaW5BdXRvTGV2ZWwoKTogbnVtYmVyIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBjb25maWc6IHsgbWluQXV0b0JpdHJhdGUgfSxcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWxldmVscykgcmV0dXJuIDA7XG5cbiAgICBjb25zdCBsZW4gPSBsZXZlbHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbHNbaV0ubWF4Qml0cmF0ZSA+PSBtaW5BdXRvQml0cmF0ZSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYXggbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGF1dG9MZXZlbENhcHBpbmdcbiAgICovXG4gIGdldCBtYXhBdXRvTGV2ZWwoKTogbnVtYmVyIHtcbiAgICBjb25zdCB7IGxldmVscywgYXV0b0xldmVsQ2FwcGluZywgbWF4SGRjcExldmVsIH0gPSB0aGlzO1xuXG4gICAgbGV0IG1heEF1dG9MZXZlbDtcbiAgICBpZiAoYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgJiYgbGV2ZWxzICYmIGxldmVscy5sZW5ndGgpIHtcbiAgICAgIG1heEF1dG9MZXZlbCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhBdXRvTGV2ZWwgPSBhdXRvTGV2ZWxDYXBwaW5nO1xuICAgIH1cblxuICAgIGlmIChtYXhIZGNwTGV2ZWwpIHtcbiAgICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGktLTsgKSB7XG4gICAgICAgIGNvbnN0IGhkY3BMZXZlbCA9IGxldmVsc1tpXS5hdHRyc1snSERDUC1MRVZFTCddO1xuICAgICAgICBpZiAoaGRjcExldmVsICYmIGhkY3BMZXZlbCA8PSBtYXhIZGNwTGV2ZWwpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogbmV4dCBhdXRvbWF0aWNhbGx5IHNlbGVjdGVkIHF1YWxpdHkgbGV2ZWxcbiAgICovXG4gIGdldCBuZXh0QXV0b0xldmVsKCk6IG51bWJlciB7XG4gICAgLy8gZW5zdXJlIG5leHQgYXV0byBsZXZlbCBpcyBiZXR3ZWVuICBtaW4gYW5kIG1heCBhdXRvIGxldmVsXG4gICAgcmV0dXJuIE1hdGgubWluKFxuICAgICAgTWF0aC5tYXgodGhpcy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKSxcbiAgICAgIHRoaXMubWF4QXV0b0xldmVsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbC5cbiAgICogdGhpcyBpcyB1c2VmdWwgdG8gZm9yY2UgYSBzd2l0Y2ggZG93biBpbiBhdXRvIG1vZGU6XG4gICAqIGluIGNhc2Ugb2YgbG9hZCBlcnJvciBvbiBsZXZlbCBOLCBobHMuanMgY2FuIHNldCBuZXh0QXV0b0xldmVsIHRvIE4tMSBmb3IgZXhhbXBsZSlcbiAgICogZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2Vzc2Z1bCBmcmFnIGxvYWRpbmcgYXQgZm9yY2VkIGxldmVsLFxuICAgKiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVzZXR0ZWQgdG8gLTEgYnkgQUJSIGNvbnRyb2xsZXIuXG4gICAqL1xuICBzZXQgbmV4dEF1dG9MZXZlbChuZXh0TGV2ZWw6IG51bWJlcikge1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsID0gTWF0aC5tYXgodGhpcy5taW5BdXRvTGV2ZWwsIG5leHRMZXZlbCk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBkYXRldGltZSB2YWx1ZSByZWxhdGl2ZSB0byBtZWRpYS5jdXJyZW50VGltZSBmb3IgdGhlIGFjdGl2ZSBsZXZlbCBQcm9ncmFtIERhdGUgVGltZSBpZiBwcmVzZW50XG4gICAqL1xuICBwdWJsaWMgZ2V0IHBsYXlpbmdEYXRlKCk6IERhdGUgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRQcm9ncmFtRGF0ZVRpbWU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG1haW5Gb3J3YXJkQnVmZmVySW5mbygpOiBCdWZmZXJJbmZvIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiBzZWxlY3RhYmxlIGF1ZGlvIHRyYWNrc1xuICAgKi9cbiAgZ2V0IGF1ZGlvVHJhY2tzKCk6IEFycmF5PE1lZGlhUGxheWxpc3Q+IHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKVxuICAgKi9cbiAgZ2V0IGF1ZGlvVHJhY2soKTogbnVtYmVyIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA6IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIHNlbGVjdHMgYW4gYXVkaW8gdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0c1xuICAgKi9cbiAgc2V0IGF1ZGlvVHJhY2soYXVkaW9UcmFja0lkOiBudW1iZXIpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKGF1ZGlvVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrID0gYXVkaW9UcmFja0lkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3RcbiAgICovXG4gIGdldCBzdWJ0aXRsZVRyYWNrcygpOiBBcnJheTxNZWRpYVBsYXlsaXN0PiB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlclxuICAgICAgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrc1xuICAgICAgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKVxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2soKTogbnVtYmVyIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA6IC0xO1xuICB9XG5cbiAgZ2V0IG1lZGlhKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0c1xuICAgKi9cbiAgc2V0IHN1YnRpdGxlVHJhY2soc3VidGl0bGVUcmFja0lkOiBudW1iZXIpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrID0gc3VidGl0bGVUcmFja0lkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHN1YnRpdGxlIGRpc3BsYXkgaXMgZW5hYmxlZCBvciBub3RcbiAgICovXG4gIGdldCBzdWJ0aXRsZURpc3BsYXkoKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlclxuICAgICAgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXlcbiAgICAgIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlL2Rpc2FibGUgc3VidGl0bGUgZGlzcGxheSByZW5kZXJpbmdcbiAgICovXG4gIHNldCBzdWJ0aXRsZURpc3BsYXkodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXkgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IG1vZGUgZm9yIExvdy1MYXRlbmN5IEhMUyBsb2FkaW5nXG4gICAqL1xuICBnZXQgbG93TGF0ZW5jeU1vZGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZS9kaXNhYmxlIExvdy1MYXRlbmN5IEhMUyBwYXJ0IHBsYXlsaXN0IGFuZCBzZWdtZW50IGxvYWRpbmcsIGFuZCBzdGFydCBsaXZlIHN0cmVhbXMgYXQgcGxheWxpc3QgUEFSVC1IT0xELUJBQ0sgcmF0aGVyIHRoYW4gSE9MRC1CQUNLLlxuICAgKi9cbiAgc2V0IGxvd0xhdGVuY3lNb2RlKG1vZGU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSA9IG1vZGU7XG4gIH1cblxuICAvKipcbiAgICogUG9zaXRpb24gKGluIHNlY29uZHMpIG9mIGxpdmUgc3luYyBwb2ludCAoaWUgZWRnZSBvZiBsaXZlIHBvc2l0aW9uIG1pbnVzIHNhZmV0eSBkZWxheSBkZWZpbmVkIGJ5IGBgYGhscy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbmBgYClcbiAgICogQHJldHVybnMgbnVsbCBwcmlvciB0byBsb2FkaW5nIGxpdmUgUGxheWxpc3RcbiAgICovXG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uKCk6IG51bWJlciB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmxpdmVTeW5jUG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogRXN0aW1hdGVkIHBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiBsaXZlIGVkZ2UgKGllIGVkZ2Ugb2YgbGl2ZSBwbGF5bGlzdCBwbHVzIHRpbWUgc3luYyBwbGF5bGlzdCBhZHZhbmNlZClcbiAgICogQHJldHVybnMgMCBiZWZvcmUgZmlyc3QgcGxheWxpc3QgaXMgbG9hZGVkXG4gICAqL1xuICBnZXQgbGF0ZW5jeSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmxhdGVuY3k7XG4gIH1cblxuICAvKipcbiAgICogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHRoZSBlZGdlIGJlZm9yZSB0aGUgcGxheWVyIHNlZWtzIGZvcndhcmQgdG8gYGBgaGxzLmxpdmVTeW5jUG9zaXRpb25gYGBcbiAgICogY29uZmlndXJlZCB1c2luZyBgYGBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRgYGAgKG11bHRpcGxlIG9mIHRhcmdldCBkdXJhdGlvbikgb3IgYGBgbGl2ZU1heExhdGVuY3lEdXJhdGlvbmBgYFxuICAgKiBAcmV0dXJucyAwIGJlZm9yZSBmaXJzdCBwbGF5bGlzdCBpcyBsb2FkZWRcbiAgICovXG4gIGdldCBtYXhMYXRlbmN5KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubWF4TGF0ZW5jeTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0YXJnZXQgZGlzdGFuY2UgZnJvbSB0aGUgZWRnZSBhcyBjYWxjdWxhdGVkIGJ5IHRoZSBsYXRlbmN5IGNvbnRyb2xsZXJcbiAgICovXG4gIGdldCB0YXJnZXRMYXRlbmN5KCk6IG51bWJlciB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLnRhcmdldExhdGVuY3k7XG4gIH1cblxuICAvKipcbiAgICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIGVkZ2Ugb2YgdGhlIGN1cnJlbnQgbGl2ZSBwbGF5bGlzdCBpcyBhZHZhbmNpbmcgb3IgMSBpZiB0aGVyZSBpcyBub25lXG4gICAqL1xuICBnZXQgZHJpZnQoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIuZHJpZnQ7XG4gIH1cblxuICAvKipcbiAgICogc2V0IHRvIHRydWUgd2hlbiBzdGFydExvYWQgaXMgY2FsbGVkIGJlZm9yZSBNQU5JRkVTVF9QQVJTRUQgZXZlbnRcbiAgICovXG4gIGdldCBmb3JjZVN0YXJ0TG9hZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmZvcmNlU3RhcnRMb2FkO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIHtcbiAgTWVkaWFQbGF5bGlzdCxcbiAgRXJyb3JEZXRhaWxzLFxuICBFcnJvclR5cGVzLFxuICBFdmVudHMsXG4gIExldmVsLFxuICBIbHNMaXN0ZW5lcnMsXG4gIEhsc0V2ZW50RW1pdHRlcixcbiAgSGxzQ29uZmlnLFxuICBCdWZmZXJJbmZvLFxuICBIZGNwTGV2ZWxzLFxuICBIZGNwTGV2ZWwsXG4gIEFickNvbnRyb2xsZXIsXG4gIEF1ZGlvU3RyZWFtQ29udHJvbGxlcixcbiAgQXVkaW9UcmFja0NvbnRyb2xsZXIsXG4gIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIsXG4gIEJhc2VTdHJlYW1Db250cm9sbGVyLFxuICBCdWZmZXJDb250cm9sbGVyLFxuICBDYXBMZXZlbENvbnRyb2xsZXIsXG4gIENNQ0RDb250cm9sbGVyLFxuICBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyLFxuICBFTUVDb250cm9sbGVyLFxuICBFcnJvckNvbnRyb2xsZXIsXG4gIEZQU0NvbnRyb2xsZXIsXG4gIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLFxufTtcbmV4cG9ydCB0eXBlIHtcbiAgQ29tcG9uZW50QVBJLFxuICBBYnJDb21wb25lbnRBUEksXG4gIE5ldHdvcmtDb21wb25lbnRBUEksXG59IGZyb20gJy4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5leHBvcnQgdHlwZSB7XG4gIEFCUkNvbnRyb2xsZXJDb25maWcsXG4gIEJ1ZmZlckNvbnRyb2xsZXJDb25maWcsXG4gIENhcExldmVsQ29udHJvbGxlckNvbmZpZyxcbiAgQ01DRENvbnRyb2xsZXJDb25maWcsXG4gIEVNRUNvbnRyb2xsZXJDb25maWcsXG4gIERSTVN5c3RlbXNDb25maWd1cmF0aW9uLFxuICBEUk1TeXN0ZW1PcHRpb25zLFxuICBGUFNDb250cm9sbGVyQ29uZmlnLFxuICBGcmFnbWVudExvYWRlckNvbmZpZyxcbiAgRnJhZ21lbnRMb2FkZXJDb25zdHJ1Y3RvcixcbiAgSGxzTG9hZFBvbGljaWVzLFxuICBMZXZlbENvbnRyb2xsZXJDb25maWcsXG4gIExvYWRlckNvbmZpZyxcbiAgTG9hZFBvbGljeSxcbiAgTVA0UmVtdXhlckNvbmZpZyxcbiAgUGxheWxpc3RMb2FkZXJDb25maWcsXG4gIFBsYXlsaXN0TG9hZGVyQ29uc3RydWN0b3IsXG4gIFJldHJ5Q29uZmlnLFxuICBTdHJlYW1Db250cm9sbGVyQ29uZmlnLFxuICBMYXRlbmN5Q29udHJvbGxlckNvbmZpZyxcbiAgTWV0YWRhdGFDb250cm9sbGVyQ29uZmlnLFxuICBUaW1lbGluZUNvbnRyb2xsZXJDb25maWcsXG4gIFRTRGVtdXhlckNvbmZpZyxcbn0gZnJvbSAnLi9jb25maWcnO1xuZXhwb3J0IHR5cGUgeyBNZWRpYUtleVNlc3Npb25Db250ZXh0IH0gZnJvbSAnLi9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyJztcbmV4cG9ydCB0eXBlIHsgSUxvZ2dlciB9IGZyb20gJy4vdXRpbHMvbG9nZ2VyJztcbmV4cG9ydCB0eXBlIHsgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIH0gZnJvbSAnLi9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyJztcbmV4cG9ydCB0eXBlIHsgVGltZWxpbmVDb250cm9sbGVyIH0gZnJvbSAnLi9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXInO1xuZXhwb3J0IHR5cGUgeyBDdWVzSW50ZXJmYWNlIH0gZnJvbSAnLi91dGlscy9jdWVzJztcbmV4cG9ydCB0eXBlIHtcbiAgTWVkaWFLZXlGdW5jLFxuICBLZXlTeXN0ZW1zLFxuICBLZXlTeXN0ZW1Gb3JtYXRzLFxufSBmcm9tICcuL3V0aWxzL21lZGlha2V5cy1oZWxwZXInO1xuZXhwb3J0IHR5cGUgeyBEYXRlUmFuZ2UgfSBmcm9tICcuL2xvYWRlci9kYXRlLXJhbmdlJztcbmV4cG9ydCB0eXBlIHsgTG9hZFN0YXRzIH0gZnJvbSAnLi9sb2FkZXIvbG9hZC1zdGF0cyc7XG5leHBvcnQgdHlwZSB7IExldmVsS2V5IH0gZnJvbSAnLi9sb2FkZXIvbGV2ZWwta2V5JztcbmV4cG9ydCB0eXBlIHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi9sb2FkZXIvbGV2ZWwtZGV0YWlscyc7XG5leHBvcnQgdHlwZSB7IFNvdXJjZUJ1ZmZlck5hbWUgfSBmcm9tICcuL3R5cGVzL2J1ZmZlcic7XG5leHBvcnQgdHlwZSB7XG4gIE1ldGFkYXRhU2FtcGxlLFxuICBNZXRhZGF0YVNjaGVtYSxcbiAgVXNlcmRhdGFTYW1wbGUsXG59IGZyb20gJy4vdHlwZXMvZGVtdXhlcic7XG5leHBvcnQgdHlwZSB7XG4gIEhsc1NraXAsXG4gIEhsc1VybFBhcmFtZXRlcnMsXG4gIExldmVsQXR0cmlidXRlcyxcbiAgTGV2ZWxQYXJzZWQsXG4gIFZhcmlhYmxlTWFwLFxufSBmcm9tICcuL3R5cGVzL2xldmVsJztcbmV4cG9ydCB0eXBlIHtcbiAgUGxheWxpc3RMZXZlbFR5cGUsXG4gIEhsc0NodW5rUGVyZm9ybWFuY2VUaW1pbmcsXG4gIEhsc1BlcmZvcm1hbmNlVGltaW5nLFxuICBIbHNQcm9ncmVzc2l2ZVBlcmZvcm1hbmNlVGltaW5nLFxuICBQbGF5bGlzdENvbnRleHRUeXBlLFxuICBQbGF5bGlzdExvYWRlckNvbnRleHQsXG4gIEZyYWdtZW50TG9hZGVyQ29udGV4dCxcbiAgTG9hZGVyLFxuICBMb2FkZXJTdGF0cyxcbiAgTG9hZGVyQ29udGV4dCxcbiAgTG9hZGVyUmVzcG9uc2UsXG4gIExvYWRlckNvbmZpZ3VyYXRpb24sXG4gIExvYWRlckNhbGxiYWNrcyxcbiAgTG9hZGVyT25Qcm9ncmVzcyxcbiAgTG9hZGVyT25BYm9ydCxcbiAgTG9hZGVyT25FcnJvcixcbiAgTG9hZGVyT25TdWNjZXNzLFxuICBMb2FkZXJPblRpbWVvdXQsXG59IGZyb20gJy4vdHlwZXMvbG9hZGVyJztcbmV4cG9ydCB0eXBlIHtcbiAgTWVkaWFBdHRyaWJ1dGVzLFxuICBNZWRpYVBsYXlsaXN0VHlwZSxcbiAgTWFpblBsYXlsaXN0VHlwZSxcbiAgQXVkaW9QbGF5bGlzdFR5cGUsXG4gIFN1YnRpdGxlUGxheWxpc3RUeXBlLFxufSBmcm9tICcuL3R5cGVzL21lZGlhLXBsYXlsaXN0JztcbmV4cG9ydCB0eXBlIHsgVHJhY2ssIFRyYWNrU2V0IH0gZnJvbSAnLi90eXBlcy90cmFjayc7XG5leHBvcnQgdHlwZSB7IENodW5rTWV0YWRhdGEgfSBmcm9tICcuL3R5cGVzL3RyYW5zbXV4ZXInO1xuZXhwb3J0IHR5cGUge1xuICBCYXNlU2VnbWVudCxcbiAgRnJhZ21lbnQsXG4gIFBhcnQsXG4gIEVsZW1lbnRhcnlTdHJlYW1zLFxuICBFbGVtZW50YXJ5U3RyZWFtVHlwZXMsXG4gIEVsZW1lbnRhcnlTdHJlYW1JbmZvLFxufSBmcm9tICcuL2xvYWRlci9mcmFnbWVudCc7XG5leHBvcnQgdHlwZSB7XG4gIFRyYWNrTG9hZGluZ0RhdGEsXG4gIFRyYWNrTG9hZGVkRGF0YSxcbiAgQXVkaW9UcmFja0xvYWRlZERhdGEsXG4gIEF1ZGlvVHJhY2tzVXBkYXRlZERhdGEsXG4gIEF1ZGlvVHJhY2tTd2l0Y2hlZERhdGEsXG4gIEF1ZGlvVHJhY2tTd2l0Y2hpbmdEYXRhLFxuICBCYWNrQnVmZmVyRGF0YSxcbiAgQnVmZmVyQXBwZW5kZWREYXRhLFxuICBCdWZmZXJBcHBlbmRpbmdEYXRhLFxuICBCdWZmZXJDb2RlY3NEYXRhLFxuICBCdWZmZXJDcmVhdGVkRGF0YSxcbiAgQnVmZmVyRU9TRGF0YSxcbiAgQnVmZmVyRmx1c2hlZERhdGEsXG4gIEJ1ZmZlckZsdXNoaW5nRGF0YSxcbiAgQ3Vlc1BhcnNlZERhdGEsXG4gIEVycm9yRGF0YSxcbiAgRlBTRHJvcERhdGEsXG4gIEZQU0Ryb3BMZXZlbENhcHBpbmdEYXRhLFxuICBGcmFnQnVmZmVyZWREYXRhLFxuICBGcmFnQ2hhbmdlZERhdGEsXG4gIEZyYWdEZWNyeXB0ZWREYXRhLFxuICBGcmFnTG9hZGVkRGF0YSxcbiAgRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkRGF0YSxcbiAgRnJhZ0xvYWRpbmdEYXRhLFxuICBGcmFnUGFyc2VkRGF0YSxcbiAgRnJhZ1BhcnNpbmdJbml0U2VnbWVudERhdGEsXG4gIEZyYWdQYXJzaW5nTWV0YWRhdGFEYXRhLFxuICBGcmFnUGFyc2luZ1VzZXJkYXRhRGF0YSxcbiAgSW5pdFBUU0ZvdW5kRGF0YSxcbiAgS2V5TG9hZGVkRGF0YSxcbiAgS2V5TG9hZGluZ0RhdGEsXG4gIExldmVsTG9hZGVkRGF0YSxcbiAgTGV2ZWxMb2FkaW5nRGF0YSxcbiAgTGV2ZWxQVFNVcGRhdGVkRGF0YSxcbiAgTGV2ZWxzVXBkYXRlZERhdGEsXG4gIExldmVsU3dpdGNoZWREYXRhLFxuICBMZXZlbFN3aXRjaGluZ0RhdGEsXG4gIExldmVsVXBkYXRlZERhdGEsXG4gIExpdmVCYWNrQnVmZmVyRGF0YSxcbiAgQ29udGVudFN0ZWVyaW5nT3B0aW9ucyxcbiAgTWFuaWZlc3RMb2FkZWREYXRhLFxuICBNYW5pZmVzdExvYWRpbmdEYXRhLFxuICBNYW5pZmVzdFBhcnNlZERhdGEsXG4gIE1lZGlhQXR0YWNoZWREYXRhLFxuICBNZWRpYUF0dGFjaGluZ0RhdGEsXG4gIE5vbk5hdGl2ZVRleHRUcmFjayxcbiAgTm9uTmF0aXZlVGV4dFRyYWNrc0RhdGEsXG4gIFN1YnRpdGxlRnJhZ1Byb2Nlc3NlZERhdGEsXG4gIFN1YnRpdGxlVHJhY2tMb2FkZWREYXRhLFxuICBTdWJ0aXRsZVRyYWNrc1VwZGF0ZWREYXRhLFxuICBTdWJ0aXRsZVRyYWNrU3dpdGNoRGF0YSxcbn0gZnJvbSAnLi90eXBlcy9ldmVudHMnO1xuZXhwb3J0IHR5cGUge1xuICBOZXR3b3JrRXJyb3JBY3Rpb24sXG4gIEVycm9yQWN0aW9uRmxhZ3MsXG4gIElFcnJvckFjdGlvbixcbn0gZnJvbSAnLi9jb250cm9sbGVyL2Vycm9yLWNvbnRyb2xsZXInO1xuZXhwb3J0IHR5cGUgeyBBdHRyTGlzdCB9IGZyb20gJy4vdXRpbHMvYXR0ci1saXN0JztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/hls.js/dist/hls.light.js\n");

/***/ })

}]);