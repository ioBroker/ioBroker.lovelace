"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_superstruct_lib_index_es_js"],{

/***/ "./node_modules/superstruct/lib/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/superstruct/lib/index.es.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Struct\": function() { return /* binding */ Struct; },\n/* harmony export */   \"StructError\": function() { return /* binding */ StructError; },\n/* harmony export */   \"any\": function() { return /* binding */ any; },\n/* harmony export */   \"array\": function() { return /* binding */ array; },\n/* harmony export */   \"assert\": function() { return /* binding */ _assert; },\n/* harmony export */   \"assign\": function() { return /* binding */ assign; },\n/* harmony export */   \"boolean\": function() { return /* binding */ _boolean; },\n/* harmony export */   \"coerce\": function() { return /* binding */ coerce; },\n/* harmony export */   \"create\": function() { return /* binding */ _create; },\n/* harmony export */   \"date\": function() { return /* binding */ date; },\n/* harmony export */   \"defaulted\": function() { return /* binding */ defaulted; },\n/* harmony export */   \"define\": function() { return /* binding */ define; },\n/* harmony export */   \"deprecated\": function() { return /* binding */ deprecated; },\n/* harmony export */   \"dynamic\": function() { return /* binding */ dynamic; },\n/* harmony export */   \"empty\": function() { return /* binding */ empty; },\n/* harmony export */   \"enums\": function() { return /* binding */ enums; },\n/* harmony export */   \"func\": function() { return /* binding */ func; },\n/* harmony export */   \"instance\": function() { return /* binding */ instance; },\n/* harmony export */   \"integer\": function() { return /* binding */ integer; },\n/* harmony export */   \"intersection\": function() { return /* binding */ intersection; },\n/* harmony export */   \"is\": function() { return /* binding */ _is; },\n/* harmony export */   \"lazy\": function() { return /* binding */ lazy; },\n/* harmony export */   \"literal\": function() { return /* binding */ literal; },\n/* harmony export */   \"map\": function() { return /* binding */ map; },\n/* harmony export */   \"mask\": function() { return /* binding */ _mask; },\n/* harmony export */   \"max\": function() { return /* binding */ max; },\n/* harmony export */   \"min\": function() { return /* binding */ min; },\n/* harmony export */   \"never\": function() { return /* binding */ never; },\n/* harmony export */   \"nullable\": function() { return /* binding */ nullable; },\n/* harmony export */   \"number\": function() { return /* binding */ number; },\n/* harmony export */   \"object\": function() { return /* binding */ object; },\n/* harmony export */   \"omit\": function() { return /* binding */ omit; },\n/* harmony export */   \"optional\": function() { return /* binding */ optional; },\n/* harmony export */   \"partial\": function() { return /* binding */ partial; },\n/* harmony export */   \"pattern\": function() { return /* binding */ pattern; },\n/* harmony export */   \"pick\": function() { return /* binding */ pick; },\n/* harmony export */   \"record\": function() { return /* binding */ record; },\n/* harmony export */   \"refine\": function() { return /* binding */ refine; },\n/* harmony export */   \"regexp\": function() { return /* binding */ regexp; },\n/* harmony export */   \"set\": function() { return /* binding */ set; },\n/* harmony export */   \"size\": function() { return /* binding */ size; },\n/* harmony export */   \"string\": function() { return /* binding */ string; },\n/* harmony export */   \"struct\": function() { return /* binding */ struct; },\n/* harmony export */   \"trimmed\": function() { return /* binding */ trimmed; },\n/* harmony export */   \"tuple\": function() { return /* binding */ tuple; },\n/* harmony export */   \"type\": function() { return /* binding */ type; },\n/* harmony export */   \"union\": function() { return /* binding */ union; },\n/* harmony export */   \"unknown\": function() { return /* binding */ unknown; },\n/* harmony export */   \"validate\": function() { return /* binding */ _validate; }\n/* harmony export */ });\nvar _excluded = [\"message\"];\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar _marked = /*#__PURE__*/regeneratorRuntime.mark(toFailures),\n    _marked2 = /*#__PURE__*/regeneratorRuntime.mark(run);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nvar StructError = /*#__PURE__*/function (_TypeError) {\n  _inherits(StructError, _TypeError);\n\n  var _super = _createSuper(StructError);\n\n  function StructError(failure, failures) {\n    var _this;\n\n    _classCallCheck(this, StructError);\n\n    var cached;\n\n    var message = failure.message,\n        rest = _objectWithoutProperties(failure, _excluded);\n\n    var path = failure.path;\n    var msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    _this = _super.call(this, msg);\n    Object.assign(_assertThisInitialized(_this), rest);\n    _this.name = _this.constructor.name;\n\n    _this.failures = function () {\n      var _cached;\n\n      return (_cached = cached) != null ? _cached : cached = [failure].concat(_toConsumableArray(failures()));\n    };\n\n    return _this;\n  }\n\n  return StructError;\n}( /*#__PURE__*/_wrapNativeSuper(TypeError));\n/**\n * Check if a value is an iterator.\n */\n\n\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isObject(x) {\n  return _typeof(x) === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\n\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\n\nfunction shiftIterator(input) {\n  var _input$next = input.next(),\n      done = _input$next.done,\n      value = _input$next.value;\n\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\n\n\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n\n  var path = context.path,\n      branch = context.branch;\n  var type = struct.type;\n  var _result = result,\n      refinement = _result.refinement,\n      _result$message = _result.message,\n      message = _result$message === void 0 ? \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + \", but received: `\" + print(value) + \"`\" : _result$message;\n  return Object.assign({\n    value: value,\n    type: type,\n    refinement: refinement,\n    key: path[path.length - 1],\n    path: path,\n    branch: branch\n  }, result, {\n    message: message\n  });\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\n\nfunction toFailures(result, context, struct, value) {\n  var _iterator, _step, r, failure;\n\n  return regeneratorRuntime.wrap(function toFailures$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!isIterable(result)) {\n            result = [result];\n          }\n\n          _iterator = _createForOfIteratorHelper(result);\n          _context.prev = 2;\n\n          _iterator.s();\n\n        case 4:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 12;\n            break;\n          }\n\n          r = _step.value;\n          failure = toFailure(r, context, struct, value);\n\n          if (!failure) {\n            _context.next = 10;\n            break;\n          }\n\n          _context.next = 10;\n          return failure;\n\n        case 10:\n          _context.next = 4;\n          break;\n\n        case 12:\n          _context.next = 17;\n          break;\n\n        case 14:\n          _context.prev = 14;\n          _context.t0 = _context[\"catch\"](2);\n\n          _iterator.e(_context.t0);\n\n        case 17:\n          _context.prev = 17;\n\n          _iterator.f();\n\n          return _context.finish(17);\n\n        case 20:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[2, 14, 17, 20]]);\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\n\nfunction run(value, struct) {\n  var options,\n      _options$path,\n      path,\n      _options$branch,\n      branch,\n      _options$coerce,\n      coerce,\n      _options$mask,\n      mask,\n      ctx,\n      key,\n      valid,\n      _iterator2,\n      _step2,\n      _failure,\n      _iterator3,\n      _step3,\n      _step3$value,\n      k,\n      v,\n      s,\n      ts,\n      _iterator5,\n      _step5,\n      t,\n      _iterator4,\n      _step4,\n      failure,\n      _args2 = arguments;\n\n  return regeneratorRuntime.wrap(function run$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n          _options$path = options.path, path = _options$path === void 0 ? [] : _options$path, _options$branch = options.branch, branch = _options$branch === void 0 ? [value] : _options$branch, _options$coerce = options.coerce, coerce = _options$coerce === void 0 ? false : _options$coerce, _options$mask = options.mask, mask = _options$mask === void 0 ? false : _options$mask;\n          ctx = {\n            path: path,\n            branch: branch\n          };\n\n          if (coerce) {\n            value = struct.coercer(value, ctx);\n\n            if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n              for (key in value) {\n                if (struct.schema[key] === undefined) {\n                  delete value[key];\n                }\n              }\n            }\n          }\n\n          valid = true;\n          _iterator2 = _createForOfIteratorHelper(struct.validator(value, ctx));\n          _context2.prev = 6;\n\n          _iterator2.s();\n\n        case 8:\n          if ((_step2 = _iterator2.n()).done) {\n            _context2.next = 15;\n            break;\n          }\n\n          _failure = _step2.value;\n          valid = false;\n          _context2.next = 13;\n          return [_failure, undefined];\n\n        case 13:\n          _context2.next = 8;\n          break;\n\n        case 15:\n          _context2.next = 20;\n          break;\n\n        case 17:\n          _context2.prev = 17;\n          _context2.t0 = _context2[\"catch\"](6);\n\n          _iterator2.e(_context2.t0);\n\n        case 20:\n          _context2.prev = 20;\n\n          _iterator2.f();\n\n          return _context2.finish(20);\n\n        case 23:\n          _iterator3 = _createForOfIteratorHelper(struct.entries(value, ctx));\n          _context2.prev = 24;\n\n          _iterator3.s();\n\n        case 26:\n          if ((_step3 = _iterator3.n()).done) {\n            _context2.next = 53;\n            break;\n          }\n\n          _step3$value = _slicedToArray(_step3.value, 3), k = _step3$value[0], v = _step3$value[1], s = _step3$value[2];\n          ts = run(v, s, {\n            path: k === undefined ? path : [].concat(_toConsumableArray(path), [k]),\n            branch: k === undefined ? branch : [].concat(_toConsumableArray(branch), [v]),\n            coerce: coerce,\n            mask: mask\n          });\n          _iterator5 = _createForOfIteratorHelper(ts);\n          _context2.prev = 30;\n\n          _iterator5.s();\n\n        case 32:\n          if ((_step5 = _iterator5.n()).done) {\n            _context2.next = 43;\n            break;\n          }\n\n          t = _step5.value;\n\n          if (!t[0]) {\n            _context2.next = 40;\n            break;\n          }\n\n          valid = false;\n          _context2.next = 38;\n          return [t[0], undefined];\n\n        case 38:\n          _context2.next = 41;\n          break;\n\n        case 40:\n          if (coerce) {\n            v = t[1];\n\n            if (k === undefined) {\n              value = v;\n            } else if (value instanceof Map) {\n              value.set(k, v);\n            } else if (value instanceof Set) {\n              value.add(v);\n            } else if (isObject(value)) {\n              value[k] = v;\n            }\n          }\n\n        case 41:\n          _context2.next = 32;\n          break;\n\n        case 43:\n          _context2.next = 48;\n          break;\n\n        case 45:\n          _context2.prev = 45;\n          _context2.t1 = _context2[\"catch\"](30);\n\n          _iterator5.e(_context2.t1);\n\n        case 48:\n          _context2.prev = 48;\n\n          _iterator5.f();\n\n          return _context2.finish(48);\n\n        case 51:\n          _context2.next = 26;\n          break;\n\n        case 53:\n          _context2.next = 58;\n          break;\n\n        case 55:\n          _context2.prev = 55;\n          _context2.t2 = _context2[\"catch\"](24);\n\n          _iterator3.e(_context2.t2);\n\n        case 58:\n          _context2.prev = 58;\n\n          _iterator3.f();\n\n          return _context2.finish(58);\n\n        case 61:\n          if (!valid) {\n            _context2.next = 80;\n            break;\n          }\n\n          _iterator4 = _createForOfIteratorHelper(struct.refiner(value, ctx));\n          _context2.prev = 63;\n\n          _iterator4.s();\n\n        case 65:\n          if ((_step4 = _iterator4.n()).done) {\n            _context2.next = 72;\n            break;\n          }\n\n          failure = _step4.value;\n          valid = false;\n          _context2.next = 70;\n          return [failure, undefined];\n\n        case 70:\n          _context2.next = 65;\n          break;\n\n        case 72:\n          _context2.next = 77;\n          break;\n\n        case 74:\n          _context2.prev = 74;\n          _context2.t3 = _context2[\"catch\"](63);\n\n          _iterator4.e(_context2.t3);\n\n        case 77:\n          _context2.prev = 77;\n\n          _iterator4.f();\n\n          return _context2.finish(77);\n\n        case 80:\n          if (!valid) {\n            _context2.next = 83;\n            break;\n          }\n\n          _context2.next = 83;\n          return [undefined, value];\n\n        case 83:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[6, 17, 20, 23], [24, 55, 58, 61], [30, 45, 48, 51], [63, 74, 77, 80]]);\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\n\nvar Struct = /*#__PURE__*/function () {\n  function Struct(props) {\n    var _this2 = this;\n\n    _classCallCheck(this, Struct);\n\n    var type = props.type,\n        schema = props.schema,\n        validator = props.validator,\n        refiner = props.refiner,\n        _props$coercer = props.coercer,\n        coercer = _props$coercer === void 0 ? function (value) {\n      return value;\n    } : _props$coercer,\n        _props$entries = props.entries,\n        entries = _props$entries === void 0 ? /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      return regeneratorRuntime.wrap(function _callee$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee);\n    }) : _props$entries;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n\n    if (validator) {\n      this.validator = function (value, context) {\n        var result = validator(value, context);\n        return toFailures(result, context, _this2, value);\n      };\n    } else {\n      this.validator = function () {\n        return [];\n      };\n    }\n\n    if (refiner) {\n      this.refiner = function (value, context) {\n        var result = refiner(value, context);\n        return toFailures(result, context, _this2, value);\n      };\n    } else {\n      this.refiner = function () {\n        return [];\n      };\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n\n  _createClass(Struct, [{\n    key: \"assert\",\n    value: function assert(value) {\n      return _assert(value, this);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(value) {\n      return _create(value, this);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(value) {\n      return _is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n\n  }, {\n    key: \"mask\",\n    value: function mask(value) {\n      return _mask(value, this);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _validate(value, this, options);\n    }\n  }]);\n\n  return Struct;\n}();\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\n\nfunction _assert(value, struct) {\n  var result = _validate(value, struct);\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\n\nfunction _create(value, struct) {\n  var result = _validate(value, struct, {\n    coerce: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\n\nfunction _mask(value, struct) {\n  var result = _validate(value, struct, {\n    coerce: true,\n    mask: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\n\n\nfunction _is(value, struct) {\n  var result = _validate(value, struct);\n\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\n\nfunction _validate(value, struct) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var tuples = run(value, struct, options);\n  var tuple = shiftIterator(tuples);\n\n  if (tuple[0]) {\n    var error = new StructError(tuple[0], /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n      var _iterator6, _step6, t;\n\n      return regeneratorRuntime.wrap(function _callee2$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _iterator6 = _createForOfIteratorHelper(tuples);\n              _context4.prev = 1;\n\n              _iterator6.s();\n\n            case 3:\n              if ((_step6 = _iterator6.n()).done) {\n                _context4.next = 10;\n                break;\n              }\n\n              t = _step6.value;\n\n              if (!t[0]) {\n                _context4.next = 8;\n                break;\n              }\n\n              _context4.next = 8;\n              return t[0];\n\n            case 8:\n              _context4.next = 3;\n              break;\n\n            case 10:\n              _context4.next = 15;\n              break;\n\n            case 12:\n              _context4.prev = 12;\n              _context4.t0 = _context4[\"catch\"](1);\n\n              _iterator6.e(_context4.t0);\n\n            case 15:\n              _context4.prev = 15;\n\n              _iterator6.f();\n\n              return _context4.finish(15);\n\n            case 18:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee2, null, [[1, 12, 15, 18]]);\n    }));\n    return [error, undefined];\n  } else {\n    var v = tuple[1];\n    return [undefined, v];\n  }\n}\n\nfunction assign() {\n  for (var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++) {\n    Structs[_key] = arguments[_key];\n  }\n\n  var isType = Structs[0].type === 'type';\n  var schemas = Structs.map(function (s) {\n    return s.schema;\n  });\n  var schema = Object.assign.apply(Object, [{}].concat(_toConsumableArray(schemas)));\n  return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator: validator\n  });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\n\nfunction deprecated(struct, log) {\n  return new Struct(Object.assign({}, struct, {\n    refiner: function refiner(value, ctx) {\n      return value === undefined || struct.refiner(value, ctx);\n    },\n    validator: function validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      } else {\n        log(value, ctx);\n        return struct.validator(value, ctx);\n      }\n    }\n  }));\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\n\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    entries: /*#__PURE__*/regeneratorRuntime.mark(function entries(value, ctx) {\n      var struct;\n      return regeneratorRuntime.wrap(function entries$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              struct = fn(value, ctx);\n              return _context5.delegateYield(struct.entries(value, ctx), \"t0\", 2);\n\n            case 2:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, entries);\n    }),\n    validator: function validator(value, ctx) {\n      var struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n    coercer: function coercer(value, ctx) {\n      var struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\n\nfunction lazy(fn) {\n  var struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    entries: /*#__PURE__*/regeneratorRuntime.mark(function entries(value, ctx) {\n      var _struct;\n\n      return regeneratorRuntime.wrap(function entries$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              (_struct = struct) != null ? _struct : struct = fn();\n              return _context6.delegateYield(struct.entries(value, ctx), \"t0\", 2);\n\n            case 2:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, entries);\n    }),\n    validator: function validator(value, ctx) {\n      var _struct2;\n\n      (_struct2 = struct) != null ? _struct2 : struct = fn();\n      return struct.validator(value, ctx);\n    },\n    coercer: function coercer(value, ctx) {\n      var _struct3;\n\n      (_struct3 = struct) != null ? _struct3 : struct = fn();\n      return struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\n\nfunction omit(struct, keys) {\n  var schema = struct.schema;\n  var subschema = Object.assign({}, schema);\n\n  var _iterator7 = _createForOfIteratorHelper(keys),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var key = _step7.value;\n      delete subschema[key];\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  return object(subschema);\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\n\nfunction partial(struct) {\n  var schema = struct instanceof Struct ? Object.assign({}, struct.schema) : Object.assign({}, struct);\n\n  for (var key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\n\nfunction pick(struct, keys) {\n  var schema = struct.schema;\n  var subschema = {};\n\n  var _iterator8 = _createForOfIteratorHelper(keys),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var key = _step8.value;\n      subschema[key] = schema[key];\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\n\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */\n\n\nfunction any() {\n  return define('any', function () {\n    return true;\n  });\n}\n\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    entries: /*#__PURE__*/regeneratorRuntime.mark(function entries(value) {\n      var _iterator9, _step9, _step9$value, i, v;\n\n      return regeneratorRuntime.wrap(function entries$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!(Element && Array.isArray(value))) {\n                _context7.next = 18;\n                break;\n              }\n\n              _iterator9 = _createForOfIteratorHelper(value.entries());\n              _context7.prev = 2;\n\n              _iterator9.s();\n\n            case 4:\n              if ((_step9 = _iterator9.n()).done) {\n                _context7.next = 10;\n                break;\n              }\n\n              _step9$value = _slicedToArray(_step9.value, 2), i = _step9$value[0], v = _step9$value[1];\n              _context7.next = 8;\n              return [i, v, Element];\n\n            case 8:\n              _context7.next = 4;\n              break;\n\n            case 10:\n              _context7.next = 15;\n              break;\n\n            case 12:\n              _context7.prev = 12;\n              _context7.t0 = _context7[\"catch\"](2);\n\n              _iterator9.e(_context7.t0);\n\n            case 15:\n              _context7.prev = 15;\n\n              _iterator9.f();\n\n              return _context7.finish(15);\n\n            case 18:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, entries, null, [[2, 12, 15, 18]]);\n    }),\n    coercer: function coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator: function validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\n\nfunction _boolean() {\n  return define('boolean', function (value) {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\n\nfunction date() {\n  return define('date', function (value) {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n  });\n}\n\nfunction enums(values) {\n  var schema = {};\n  var description = values.map(function (v) {\n    return print(v);\n  }).join();\n\n  var _iterator10 = _createForOfIteratorHelper(values),\n      _step10;\n\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var key = _step10.value;\n      schema[key] = key;\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema: schema,\n    validator: function validator(value) {\n      return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a function.\n */\n\n\nfunction func() {\n  return define('func', function (value) {\n    return typeof value === 'function' || \"Expected a function, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\n\nfunction instance(Class) {\n  return define('instance', function (value) {\n    return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\n\n\nfunction integer() {\n  return define('integer', function (value) {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n  });\n}\n\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    entries: /*#__PURE__*/regeneratorRuntime.mark(function entries(value, ctx) {\n      var _iterator11, _step11, S;\n\n      return regeneratorRuntime.wrap(function entries$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              _iterator11 = _createForOfIteratorHelper(Structs);\n              _context8.prev = 1;\n\n              _iterator11.s();\n\n            case 3:\n              if ((_step11 = _iterator11.n()).done) {\n                _context8.next = 8;\n                break;\n              }\n\n              S = _step11.value;\n              return _context8.delegateYield(S.entries(value, ctx), \"t0\", 6);\n\n            case 6:\n              _context8.next = 3;\n              break;\n\n            case 8:\n              _context8.next = 13;\n              break;\n\n            case 10:\n              _context8.prev = 10;\n              _context8.t1 = _context8[\"catch\"](1);\n\n              _iterator11.e(_context8.t1);\n\n            case 13:\n              _context8.prev = 13;\n\n              _iterator11.f();\n\n              return _context8.finish(13);\n\n            case 16:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, entries, null, [[1, 10, 13, 16]]);\n    }),\n    validator: /*#__PURE__*/regeneratorRuntime.mark(function validator(value, ctx) {\n      var _iterator12, _step12, S;\n\n      return regeneratorRuntime.wrap(function validator$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              _iterator12 = _createForOfIteratorHelper(Structs);\n              _context9.prev = 1;\n\n              _iterator12.s();\n\n            case 3:\n              if ((_step12 = _iterator12.n()).done) {\n                _context9.next = 8;\n                break;\n              }\n\n              S = _step12.value;\n              return _context9.delegateYield(S.validator(value, ctx), \"t0\", 6);\n\n            case 6:\n              _context9.next = 3;\n              break;\n\n            case 8:\n              _context9.next = 13;\n              break;\n\n            case 10:\n              _context9.prev = 10;\n              _context9.t1 = _context9[\"catch\"](1);\n\n              _iterator12.e(_context9.t1);\n\n            case 13:\n              _context9.prev = 13;\n\n              _iterator12.f();\n\n              return _context9.finish(13);\n\n            case 16:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, validator, null, [[1, 10, 13, 16]]);\n    }),\n    refiner: /*#__PURE__*/regeneratorRuntime.mark(function refiner(value, ctx) {\n      var _iterator13, _step13, S;\n\n      return regeneratorRuntime.wrap(function refiner$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              _iterator13 = _createForOfIteratorHelper(Structs);\n              _context10.prev = 1;\n\n              _iterator13.s();\n\n            case 3:\n              if ((_step13 = _iterator13.n()).done) {\n                _context10.next = 8;\n                break;\n              }\n\n              S = _step13.value;\n              return _context10.delegateYield(S.refiner(value, ctx), \"t0\", 6);\n\n            case 6:\n              _context10.next = 3;\n              break;\n\n            case 8:\n              _context10.next = 13;\n              break;\n\n            case 10:\n              _context10.prev = 10;\n              _context10.t1 = _context10[\"catch\"](1);\n\n              _iterator13.e(_context10.t1);\n\n            case 13:\n              _context10.prev = 13;\n\n              _iterator13.f();\n\n              return _context10.finish(13);\n\n            case 16:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, refiner, null, [[1, 10, 13, 16]]);\n    })\n  });\n}\n\nfunction literal(constant) {\n  var description = print(constant);\n\n  var t = _typeof(constant);\n\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator: function validator(value) {\n      return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n    }\n  });\n}\n\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    entries: /*#__PURE__*/regeneratorRuntime.mark(function entries(value) {\n      var _iterator14, _step14, _step14$value, k, v;\n\n      return regeneratorRuntime.wrap(function entries$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              if (!(Key && Value && value instanceof Map)) {\n                _context11.next = 20;\n                break;\n              }\n\n              _iterator14 = _createForOfIteratorHelper(value.entries());\n              _context11.prev = 2;\n\n              _iterator14.s();\n\n            case 4:\n              if ((_step14 = _iterator14.n()).done) {\n                _context11.next = 12;\n                break;\n              }\n\n              _step14$value = _slicedToArray(_step14.value, 2), k = _step14$value[0], v = _step14$value[1];\n              _context11.next = 8;\n              return [k, k, Key];\n\n            case 8:\n              _context11.next = 10;\n              return [k, v, Value];\n\n            case 10:\n              _context11.next = 4;\n              break;\n\n            case 12:\n              _context11.next = 17;\n              break;\n\n            case 14:\n              _context11.prev = 14;\n              _context11.t0 = _context11[\"catch\"](2);\n\n              _iterator14.e(_context11.t0);\n\n            case 17:\n              _context11.prev = 17;\n\n              _iterator14.f();\n\n              return _context11.finish(17);\n\n            case 20:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, entries, null, [[2, 14, 17, 20]]);\n    }),\n    coercer: function coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n    validator: function validator(value) {\n      return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\n\n\nfunction never() {\n  return define('never', function () {\n    return false;\n  });\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\n\nfunction nullable(struct) {\n  return new Struct(Object.assign({}, struct, {\n    validator: function validator(value, ctx) {\n      return value === null || struct.validator(value, ctx);\n    },\n    refiner: function refiner(value, ctx) {\n      return value === null || struct.refiner(value, ctx);\n    }\n  }));\n}\n/**\n * Ensure that a value is a number.\n */\n\n\nfunction number() {\n  return define('number', function (value) {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\n\nfunction object(schema) {\n  var knowns = schema ? Object.keys(schema) : [];\n  var Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    entries: /*#__PURE__*/regeneratorRuntime.mark(function entries(value) {\n      var unknowns, _iterator15, _step15, key, _iterator16, _step16, _key2;\n\n      return regeneratorRuntime.wrap(function entries$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              if (!(schema && isObject(value))) {\n                _context12.next = 37;\n                break;\n              }\n\n              unknowns = new Set(Object.keys(value));\n              _iterator15 = _createForOfIteratorHelper(knowns);\n              _context12.prev = 3;\n\n              _iterator15.s();\n\n            case 5:\n              if ((_step15 = _iterator15.n()).done) {\n                _context12.next = 12;\n                break;\n              }\n\n              key = _step15.value;\n              unknowns[\"delete\"](key);\n              _context12.next = 10;\n              return [key, value[key], schema[key]];\n\n            case 10:\n              _context12.next = 5;\n              break;\n\n            case 12:\n              _context12.next = 17;\n              break;\n\n            case 14:\n              _context12.prev = 14;\n              _context12.t0 = _context12[\"catch\"](3);\n\n              _iterator15.e(_context12.t0);\n\n            case 17:\n              _context12.prev = 17;\n\n              _iterator15.f();\n\n              return _context12.finish(17);\n\n            case 20:\n              _iterator16 = _createForOfIteratorHelper(unknowns);\n              _context12.prev = 21;\n\n              _iterator16.s();\n\n            case 23:\n              if ((_step16 = _iterator16.n()).done) {\n                _context12.next = 29;\n                break;\n              }\n\n              _key2 = _step16.value;\n              _context12.next = 27;\n              return [_key2, value[_key2], Never];\n\n            case 27:\n              _context12.next = 23;\n              break;\n\n            case 29:\n              _context12.next = 34;\n              break;\n\n            case 31:\n              _context12.prev = 31;\n              _context12.t1 = _context12[\"catch\"](21);\n\n              _iterator16.e(_context12.t1);\n\n            case 34:\n              _context12.prev = 34;\n\n              _iterator16.f();\n\n              return _context12.finish(34);\n\n            case 37:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, entries, null, [[3, 14, 17, 20], [21, 31, 34, 37]]);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    },\n    coercer: function coercer(value) {\n      return isObject(value) ? Object.assign({}, value) : value;\n    }\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\n\nfunction optional(struct) {\n  return new Struct(Object.assign({}, struct, {\n    validator: function validator(value, ctx) {\n      return value === undefined || struct.validator(value, ctx);\n    },\n    refiner: function refiner(value, ctx) {\n      return value === undefined || struct.refiner(value, ctx);\n    }\n  }));\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\n\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    entries: /*#__PURE__*/regeneratorRuntime.mark(function entries(value) {\n      var k, v;\n      return regeneratorRuntime.wrap(function entries$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              if (!isObject(value)) {\n                _context13.next = 11;\n                break;\n              }\n\n              _context13.t0 = regeneratorRuntime.keys(value);\n\n            case 2:\n              if ((_context13.t1 = _context13.t0()).done) {\n                _context13.next = 11;\n                break;\n              }\n\n              k = _context13.t1.value;\n              v = value[k];\n              _context13.next = 7;\n              return [k, k, Key];\n\n            case 7:\n              _context13.next = 9;\n              return [k, v, Value];\n\n            case 9:\n              _context13.next = 2;\n              break;\n\n            case 11:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, entries);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\n\nfunction regexp() {\n  return define('regexp', function (value) {\n    return value instanceof RegExp;\n  });\n}\n\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    entries: /*#__PURE__*/regeneratorRuntime.mark(function entries(value) {\n      var _iterator17, _step17, v;\n\n      return regeneratorRuntime.wrap(function entries$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              if (!(Element && value instanceof Set)) {\n                _context14.next = 18;\n                break;\n              }\n\n              _iterator17 = _createForOfIteratorHelper(value);\n              _context14.prev = 2;\n\n              _iterator17.s();\n\n            case 4:\n              if ((_step17 = _iterator17.n()).done) {\n                _context14.next = 10;\n                break;\n              }\n\n              v = _step17.value;\n              _context14.next = 8;\n              return [v, v, Element];\n\n            case 8:\n              _context14.next = 4;\n              break;\n\n            case 10:\n              _context14.next = 15;\n              break;\n\n            case 12:\n              _context14.prev = 12;\n              _context14.t0 = _context14[\"catch\"](2);\n\n              _iterator17.e(_context14.t0);\n\n            case 15:\n              _context14.prev = 15;\n\n              _iterator17.f();\n\n              return _context14.finish(15);\n\n            case 18:\n            case \"end\":\n              return _context14.stop();\n          }\n        }\n      }, entries, null, [[2, 12, 15, 18]]);\n    }),\n    coercer: function coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n    validator: function validator(value) {\n      return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a string.\n */\n\n\nfunction string() {\n  return define('string', function (value) {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\n\nfunction tuple(Elements) {\n  var Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    entries: /*#__PURE__*/regeneratorRuntime.mark(function entries(value) {\n      var length, i;\n      return regeneratorRuntime.wrap(function entries$(_context15) {\n        while (1) {\n          switch (_context15.prev = _context15.next) {\n            case 0:\n              if (!Array.isArray(value)) {\n                _context15.next = 9;\n                break;\n              }\n\n              length = Math.max(Elements.length, value.length);\n              i = 0;\n\n            case 3:\n              if (!(i < length)) {\n                _context15.next = 9;\n                break;\n              }\n\n              _context15.next = 6;\n              return [i, value[i], Elements[i] || Never];\n\n            case 6:\n              i++;\n              _context15.next = 3;\n              break;\n\n            case 9:\n            case \"end\":\n              return _context15.stop();\n          }\n        }\n      }, entries);\n    }),\n    validator: function validator(value) {\n      return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\n\nfunction type(schema) {\n  var keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema: schema,\n    entries: /*#__PURE__*/regeneratorRuntime.mark(function entries(value) {\n      var _iterator18, _step18, k;\n\n      return regeneratorRuntime.wrap(function entries$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              if (!isObject(value)) {\n                _context16.next = 18;\n                break;\n              }\n\n              _iterator18 = _createForOfIteratorHelper(keys);\n              _context16.prev = 2;\n\n              _iterator18.s();\n\n            case 4:\n              if ((_step18 = _iterator18.n()).done) {\n                _context16.next = 10;\n                break;\n              }\n\n              k = _step18.value;\n              _context16.next = 8;\n              return [k, value[k], schema[k]];\n\n            case 8:\n              _context16.next = 4;\n              break;\n\n            case 10:\n              _context16.next = 15;\n              break;\n\n            case 12:\n              _context16.prev = 12;\n              _context16.t0 = _context16[\"catch\"](2);\n\n              _iterator18.e(_context16.t0);\n\n            case 15:\n              _context16.prev = 15;\n\n              _iterator18.f();\n\n              return _context16.finish(15);\n\n            case 18:\n            case \"end\":\n              return _context16.stop();\n          }\n        }\n      }, entries, null, [[2, 12, 15, 18]]);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n  });\n}\n\nfunction union(Structs) {\n  var description = Structs.map(function (s) {\n    return s.type;\n  }).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n    coercer: function coercer(value, ctx) {\n      var firstMatch = Structs.find(function (s) {\n        var _s$validate = s.validate(value, {\n          coerce: true\n        }),\n            _s$validate2 = _slicedToArray(_s$validate, 1),\n            e = _s$validate2[0];\n\n        return !e;\n      }) || unknown();\n      return firstMatch.coercer(value, ctx);\n    },\n    validator: function validator(value, ctx) {\n      var failures = [];\n\n      var _iterator19 = _createForOfIteratorHelper(Structs),\n          _step19;\n\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var S = _step19.value;\n\n          var _run = run(value, S, ctx),\n              _run2 = _toArray(_run),\n              tuples = _run2.slice(0);\n\n          var _tuples = _slicedToArray(tuples, 1),\n              first = _tuples[0];\n\n          if (!first[0]) {\n            return [];\n          } else {\n            var _iterator20 = _createForOfIteratorHelper(tuples),\n                _step20;\n\n            try {\n              for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                var _step20$value = _slicedToArray(_step20.value, 1),\n                    failure = _step20$value[0];\n\n                if (failure) {\n                  failures.push(failure);\n                }\n              }\n            } catch (err) {\n              _iterator20.e(err);\n            } finally {\n              _iterator20.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n\n      return [\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value)].concat(failures);\n    }\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\n\nfunction unknown() {\n  return define('unknown', function () {\n    return true;\n  });\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationfor example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\n\nfunction coerce(struct, condition, _coercer) {\n  return new Struct(Object.assign({}, struct, {\n    coercer: function coercer(value, ctx) {\n      return _is(value, condition) ? struct.coercer(_coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  }));\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\n\nfunction defaulted(struct, fallback) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return coerce(struct, unknown(), function (x) {\n    var f = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (x === undefined) {\n      return f;\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      var ret = Object.assign({}, x);\n      var changed = false;\n\n      for (var key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return x;\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\n\nfunction trimmed(struct) {\n  return coerce(struct, string(), function (x) {\n    return x.trim();\n  });\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\n\nfunction empty(struct) {\n  var expected = \"Expected an empty \" + struct.type;\n  return refine(struct, 'empty', function (value) {\n    if (value instanceof Map || value instanceof Set) {\n      var _size = value.size;\n      return _size === 0 || expected + \" but received one with a size of `\" + _size + \"`\";\n    } else {\n      var length = value.length;\n      return length === 0 || expected + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\n\n\nfunction max(struct, threshold) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var exclusive = options.exclusive;\n  return refine(struct, 'max', function (value) {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" less than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\n\n\nfunction min(struct, threshold) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var exclusive = options.exclusive;\n  return refine(struct, 'min', function (value) {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\n\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', function (value) {\n    return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + \"/` but received \\\"\" + value + \"\\\"\";\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\n\nfunction size(struct, min) {\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min;\n  var expected = \"Expected a \" + struct.type;\n  var of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n  return refine(struct, 'size', function (value) {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n    } else if (value instanceof Map || value instanceof Set) {\n      var _size2 = value.size;\n      return min <= _size2 && _size2 <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + _size2 + \"`\";\n    } else {\n      var length = value.length;\n      return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\n\nfunction refine(struct, name, refiner) {\n  return new Struct(Object.assign({}, struct, {\n    refiner: function (_refiner) {\n      var _marked3 = /*#__PURE__*/regeneratorRuntime.mark(refiner);\n\n      function refiner(_x, _x2) {\n        var _args17 = arguments;\n        return regeneratorRuntime.wrap(function refiner$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                return _context17.delegateYield(_refiner.apply(this, _args17), \"t0\", 1);\n\n              case 1:\n                return _context17.abrupt(\"return\", _context17.t0);\n\n              case 2:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _marked3, this);\n      }\n\n      refiner.toString = function () {\n        return _refiner.toString();\n      };\n\n      return refiner;\n    }( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(value, ctx) {\n      var result, failures, _iterator21, _step21, failure;\n\n      return regeneratorRuntime.wrap(function _callee3$(_context18) {\n        while (1) {\n          switch (_context18.prev = _context18.next) {\n            case 0:\n              return _context18.delegateYield(struct.refiner(value, ctx), \"t0\", 1);\n\n            case 1:\n              result = refiner(value, ctx);\n              failures = toFailures(result, ctx, struct, value);\n              _iterator21 = _createForOfIteratorHelper(failures);\n              _context18.prev = 4;\n\n              _iterator21.s();\n\n            case 6:\n              if ((_step21 = _iterator21.n()).done) {\n                _context18.next = 12;\n                break;\n              }\n\n              failure = _step21.value;\n              _context18.next = 10;\n              return Object.assign({}, failure, {\n                refinement: name\n              });\n\n            case 10:\n              _context18.next = 6;\n              break;\n\n            case 12:\n              _context18.next = 17;\n              break;\n\n            case 14:\n              _context18.prev = 14;\n              _context18.t1 = _context18[\"catch\"](4);\n\n              _iterator21.e(_context18.t1);\n\n            case 17:\n              _context18.prev = 17;\n\n              _iterator21.f();\n\n              return _context18.finish(17);\n\n            case 20:\n            case \"end\":\n              return _context18.stop();\n          }\n        }\n      }, _callee3, null, [[4, 14, 17, 20]]);\n    }))\n  }));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvbGliL2luZGV4LmVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNkZBO0FBd0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBRHJIQTs7OztBQWNBOzs7Ozs7OztBQVNBOzs7OztBQVVBO0FBQUE7O0FBQUE7O0FBQ0E7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBOzs7QUFDQTtBQURBOztBQVRBO0FBWUE7OztBQXRCQTtBQ3BCQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBOzs7OztBQUlBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBUkE7QUFVQTtBQUVBOzs7OztBQUlBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7Ozs7OztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQTs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7QUFPQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7Ozs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQTs7Ozs7QUFDQTs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQTs7Ozs7O0FBQ0E7Ozs7Ozs7OztBQzVMQTs7Ozs7OztBQU1BO0FBWUE7QUFBQTs7QUFBQTs7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUFBO0FBTEE7QUFBQTtBQU1BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQUE7QUFNQTtBQUNBOzs7OztBQUdBOzs7OztBQUlBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQU1BO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7O0FBREE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFHQTs7QUFIQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBSUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUVBOzs7Ozs7Ozs7QUFRQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7O0FBTEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFFQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFMQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BOzs7QUFDQTtBQUNBO0FBVEE7QUFXQTs7O0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUlBO0FBQ0E7O0FBSEE7QUFBQTs7QUFBQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFTQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7Ozs7OztBQU9BO0FBSUE7QUFDQTs7QUFIQTtBQUFBOztBQUFBO0FBS0E7QUFBQTtBQUNBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVNBO0FBQ0E7QUFFQTs7Ozs7OztBQU1BO0FBQ0E7QUFJQTtBQUNBO0FDck5BOzs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFNQTs7QUFOQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVUE7QUFDQTtBQVhBO0FBYUE7QUFDQTtBQUlBO0FBbEJBO0FBb0JBO0FBRUE7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUVBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQURBO0FBTUE7O0FBZUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFGQTtBQUFBOztBQUFBO0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQVJBO0FBVUE7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQU1BO0FBRUE7Ozs7O0FBSUE7QUFHQTtBQUNBO0FBREE7QUFNQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQURBO0FBTUE7O0FBMERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFJQTtBQUNBOztBQUxBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRQTtBQVJBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVNBO0FBQ0E7O0FBVkE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWFBO0FBYkE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBY0E7QUFDQTs7QUFmQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFtQkE7O0FBVUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFUQTtBQVdBOztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBTUE7O0FBTkE7QUFBQTtBQU9BOztBQVBBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBSUE7QUFuQkE7QUFxQkE7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7Ozs7O0FBSUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBS0E7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQU1BOztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFLQTtBQUxBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFPQTtBQUNBO0FBUkE7QUFTQTs7QUFUQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVlBO0FBWkE7QUFhQTs7QUFiQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBaUJBO0FBQ0E7QUFsQkE7QUFzQkE7QUFDQTtBQUNBO0FBeEJBO0FBMEJBO0FBRUE7Ozs7O0FBSUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUpBO0FBTUE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBS0E7QUFDQTtBQU5BO0FBT0E7O0FBUEE7QUFBQTtBQVFBOztBQVJBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVlBO0FBQ0E7QUFHQTtBQWhCQTtBQWtCQTtBQUVBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUtBO0FBTEE7QUFNQTs7QUFOQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVUE7QUFDQTtBQVhBO0FBYUE7QUFDQTtBQUlBO0FBbEJBO0FBb0JBO0FBRUE7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBREE7QUFNQTs7QUFzREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUtBO0FBRUE7O0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQVFBOztBQVJBO0FBT0E7QUFQQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBWUE7QUFDQTtBQUlBO0FBakJBO0FBbUJBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBS0E7QUFMQTtBQU1BOztBQU5BO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVQTtBQUNBO0FBR0E7QUFkQTtBQWdCQTs7QUF3REE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUZBO0FBSUE7QUFUQTtBQVdBO0FBQ0E7O0FBREE7QUFBQTs7QUFBQTtBQUdBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQURBO0FBRUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBaEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBa0JBO0FBTUE7QUFuQ0E7QUFxQ0E7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FDenBCQTs7Ozs7Ozs7Ozs7O0FBV0E7QUFLQTtBQUVBO0FBQ0E7QUFHQTtBQU5BO0FBUUE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUtBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQXZCQTtBQXlCQTtBQUVBOzs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUM3RUE7Ozs7O0FBSUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFNQTtBQUNBO0FBSUE7QUFaQTtBQWNBO0FBRUE7Ozs7O0FBSUE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBUUE7QUFFQTs7Ozs7QUFJQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFRQTtBQUNBOzs7OztBQUlBO0FBSUE7QUFDQTtBQURBO0FBTUE7QUFFQTs7Ozs7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBTUE7QUFDQTtBQUZBO0FBT0E7QUFDQTtBQUlBO0FBbEJBO0FBb0JBO0FBRUE7Ozs7Ozs7OztBQVFBO0FBS0E7QUFFQTtBQUZBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBOztBQUhBO0FBSUE7QUFDQTtBQUxBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFPQTtBQVBBO0FBUUE7QUFBQTtBQUFBOztBQVJBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVlBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2Vycm9yLnRzPzkyMGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzLnRzPzdmMzMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3N0cnVjdC50cz8yYzQ4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9zdHJ1Y3RzL3V0aWxpdGllcy50cz83NjYwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9zdHJ1Y3RzL3R5cGVzLnRzP2UwNjkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3N0cnVjdHMvY29lcmNpb25zLnRzPzE0ZmIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3N0cnVjdHMvcmVmaW5lbWVudHMudHM/YzEzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgYFN0cnVjdEZhaWx1cmVgIHJlcHJlc2VudHMgYSBzaW5nbGUgc3BlY2lmaWMgZmFpbHVyZSBpbiB2YWxpZGF0aW9uLlxuICovXG5cbmV4cG9ydCB0eXBlIEZhaWx1cmUgPSB7XG4gIHZhbHVlOiBhbnlcbiAga2V5OiBhbnlcbiAgdHlwZTogc3RyaW5nXG4gIHJlZmluZW1lbnQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBtZXNzYWdlOiBzdHJpbmdcbiAgYnJhbmNoOiBBcnJheTxhbnk+XG4gIHBhdGg6IEFycmF5PGFueT5cbn1cblxuLyoqXG4gKiBgU3RydWN0RXJyb3JgIG9iamVjdHMgYXJlIHRocm93biAob3IgcmV0dXJuZWQpIHdoZW4gdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBWYWxpZGF0aW9uIGxvZ2ljIGlzIGRlc2lnbiB0byBleGl0IGVhcmx5IGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlLiBUaGUgZXJyb3JcbiAqIHJlcHJlc2VudHMgdGhlIGZpcnN0IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyB2YWxpZGF0aW9uLiBGb3IgbW9yZSBkZXRhaWwsXG4gKiB0aGUgYGVycm9yLmZhaWx1cmVzYCBwcm9wZXJ0eSBpcyBhIGdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSBydW4gdG9cbiAqIGNvbnRpbnVlIHZhbGlkYXRpb24gYW5kIHJlY2VpdmUgYWxsIHRoZSBmYWlsdXJlcyBpbiB0aGUgZGF0YS5cbiAqL1xuXG5leHBvcnQgY2xhc3MgU3RydWN0RXJyb3IgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICB2YWx1ZTogYW55XG4gIGtleSE6IGFueVxuICB0eXBlITogc3RyaW5nXG4gIHJlZmluZW1lbnQhOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgcGF0aCE6IEFycmF5PGFueT5cbiAgYnJhbmNoITogQXJyYXk8YW55PlxuICBmYWlsdXJlczogKCkgPT4gQXJyYXk8RmFpbHVyZT47XG4gIFt4OiBzdHJpbmddOiBhbnlcblxuICBjb25zdHJ1Y3RvcihmYWlsdXJlOiBGYWlsdXJlLCBmYWlsdXJlczogKCkgPT4gR2VuZXJhdG9yPEZhaWx1cmU+KSB7XG4gICAgbGV0IGNhY2hlZDogQXJyYXk8RmFpbHVyZT4gfCB1bmRlZmluZWRcbiAgICBjb25zdCB7IG1lc3NhZ2UsIC4uLnJlc3QgfSA9IGZhaWx1cmVcbiAgICBjb25zdCB7IHBhdGggfSA9IGZhaWx1cmVcbiAgICBjb25zdCBtc2cgPVxuICAgICAgcGF0aC5sZW5ndGggPT09IDAgPyBtZXNzYWdlIDogYEF0IHBhdGg6ICR7cGF0aC5qb2luKCcuJyl9IC0tICR7bWVzc2FnZX1gXG4gICAgc3VwZXIobXNnKVxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdClcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWVcbiAgICB0aGlzLmZhaWx1cmVzID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIChjYWNoZWQgPz89IFtmYWlsdXJlLCAuLi5mYWlsdXJlcygpXSlcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IFN0cnVjdCwgSW5mZXIsIFJlc3VsdCwgQ29udGV4dCwgRGVzY3JpYmUgfSBmcm9tICcuL3N0cnVjdCdcbmltcG9ydCB7IEZhaWx1cmUgfSBmcm9tICcuL2Vycm9yJ1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaXRlcmF0b3IuXG4gKi9cblxuZnVuY3Rpb24gaXNJdGVyYWJsZTxUPih4OiB1bmtub3duKTogeCBpcyBJdGVyYWJsZTxUPiB7XG4gIHJldHVybiBpc09iamVjdCh4KSAmJiB0eXBlb2YgeFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QoeDogdW5rbm93bik6IHggaXMgb2JqZWN0IHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9IG51bGxcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHg6IHVua25vd24pOiB4IGlzIHsgW2tleTogc3RyaW5nXTogYW55IH0ge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpXG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlXG59XG5cbi8qKlxuICogUmV0dXJuIGEgdmFsdWUgYXMgYSBwcmludGFibGUgc3RyaW5nLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludCh2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBgJHt2YWx1ZX1gXG59XG5cbi8qKlxuICogU2hpZnRzIChyZW1vdmVzIGFuZCByZXR1cm5zKSB0aGUgZmlyc3QgdmFsdWUgZnJvbSB0aGUgYGlucHV0YCBpdGVyYXRvci5cbiAqIExpa2UgYEFycmF5LnByb3RvdHlwZS5zaGlmdCgpYCBidXQgZm9yIGFuIGBJdGVyYXRvcmAuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaWZ0SXRlcmF0b3I8VD4oaW5wdXQ6IEl0ZXJhdG9yPFQ+KTogVCB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGlucHV0Lm5leHQoKVxuICByZXR1cm4gZG9uZSA/IHVuZGVmaW5lZCA6IHZhbHVlXG59XG5cbi8qKlxuICogQ29udmVydCBhIHNpbmdsZSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhIGZhaWx1cmUuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRmFpbHVyZTxULCBTPihcbiAgcmVzdWx0OiBzdHJpbmcgfCBib29sZWFuIHwgUGFydGlhbDxGYWlsdXJlPixcbiAgY29udGV4dDogQ29udGV4dCxcbiAgc3RydWN0OiBTdHJ1Y3Q8VCwgUz4sXG4gIHZhbHVlOiBhbnlcbik6IEZhaWx1cmUgfCB1bmRlZmluZWQge1xuICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgIHJlc3VsdCA9IHt9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSB7IG1lc3NhZ2U6IHJlc3VsdCB9XG4gIH1cblxuICBjb25zdCB7IHBhdGgsIGJyYW5jaCB9ID0gY29udGV4dFxuICBjb25zdCB7IHR5cGUgfSA9IHN0cnVjdFxuICBjb25zdCB7XG4gICAgcmVmaW5lbWVudCxcbiAgICBtZXNzYWdlID0gYEV4cGVjdGVkIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgJHtcbiAgICAgIHJlZmluZW1lbnQgPyBgIHdpdGggcmVmaW5lbWVudCBcXGAke3JlZmluZW1lbnR9XFxgYCA6ICcnXG4gICAgfSwgYnV0IHJlY2VpdmVkOiBcXGAke3ByaW50KHZhbHVlKX1cXGBgLFxuICB9ID0gcmVzdWx0XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZSxcbiAgICB0eXBlLFxuICAgIHJlZmluZW1lbnQsXG4gICAga2V5OiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0sXG4gICAgcGF0aCxcbiAgICBicmFuY2gsXG4gICAgLi4ucmVzdWx0LFxuICAgIG1lc3NhZ2UsXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsaWRhdGlvbiByZXN1bHQgdG8gYW4gaXRlcmFibGUgb2YgZmFpbHVyZXMuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uKiB0b0ZhaWx1cmVzPFQsIFM+KFxuICByZXN1bHQ6IFJlc3VsdCxcbiAgY29udGV4dDogQ29udGV4dCxcbiAgc3RydWN0OiBTdHJ1Y3Q8VCwgUz4sXG4gIHZhbHVlOiBhbnlcbik6IEl0ZXJhYmxlSXRlcmF0b3I8RmFpbHVyZT4ge1xuICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IFtyZXN1bHRdXG4gIH1cblxuICBmb3IgKGNvbnN0IHIgb2YgcmVzdWx0KSB7XG4gICAgY29uc3QgZmFpbHVyZSA9IHRvRmFpbHVyZShyLCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKVxuXG4gICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgIHlpZWxkIGZhaWx1cmVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHRyYXZlcnNpbmcgZGVlcGx5IGludG8gbmVzdGVkIHZhbHVlcywgYW5kXG4gKiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb2YgZmFpbHVyZXMgb3Igc3VjY2Vzcy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24qIHJ1bjxULCBTPihcbiAgdmFsdWU6IHVua25vd24sXG4gIHN0cnVjdDogU3RydWN0PFQsIFM+LFxuICBvcHRpb25zOiB7XG4gICAgcGF0aD86IGFueVtdXG4gICAgYnJhbmNoPzogYW55W11cbiAgICBjb2VyY2U/OiBib29sZWFuXG4gICAgbWFzaz86IGJvb2xlYW5cbiAgfSA9IHt9XG4pOiBJdGVyYWJsZUl0ZXJhdG9yPFtGYWlsdXJlLCB1bmRlZmluZWRdIHwgW3VuZGVmaW5lZCwgVF0+IHtcbiAgY29uc3QgeyBwYXRoID0gW10sIGJyYW5jaCA9IFt2YWx1ZV0sIGNvZXJjZSA9IGZhbHNlLCBtYXNrID0gZmFsc2UgfSA9IG9wdGlvbnNcbiAgY29uc3QgY3R4OiBDb250ZXh0ID0geyBwYXRoLCBicmFuY2ggfVxuXG4gIGlmIChjb2VyY2UpIHtcbiAgICB2YWx1ZSA9IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpXG5cbiAgICBpZiAoXG4gICAgICBtYXNrICYmXG4gICAgICBzdHJ1Y3QudHlwZSAhPT0gJ3R5cGUnICYmXG4gICAgICBpc09iamVjdChzdHJ1Y3Quc2NoZW1hKSAmJlxuICAgICAgaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICApIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChzdHJ1Y3Quc2NoZW1hW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgdmFsaWQgPSB0cnVlXG5cbiAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCkpIHtcbiAgICB2YWxpZCA9IGZhbHNlXG4gICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF1cbiAgfVxuXG4gIGZvciAobGV0IFtrLCB2LCBzXSBvZiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KSkge1xuICAgIGNvbnN0IHRzID0gcnVuKHYsIHMgYXMgU3RydWN0LCB7XG4gICAgICBwYXRoOiBrID09PSB1bmRlZmluZWQgPyBwYXRoIDogWy4uLnBhdGgsIGtdLFxuICAgICAgYnJhbmNoOiBrID09PSB1bmRlZmluZWQgPyBicmFuY2ggOiBbLi4uYnJhbmNoLCB2XSxcbiAgICAgIGNvZXJjZSxcbiAgICAgIG1hc2ssXG4gICAgfSlcblxuICAgIGZvciAoY29uc3QgdCBvZiB0cykge1xuICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgdmFsaWQgPSBmYWxzZVxuICAgICAgICB5aWVsZCBbdFswXSwgdW5kZWZpbmVkXVxuICAgICAgfSBlbHNlIGlmIChjb2VyY2UpIHtcbiAgICAgICAgdiA9IHRbMV1cblxuICAgICAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFsdWUgPSB2XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICB2YWx1ZS5zZXQoaywgdilcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgIHZhbHVlLmFkZCh2KVxuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlW2tdID0gdlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbGlkKSB7XG4gICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC5yZWZpbmVyKHZhbHVlIGFzIFQsIGN0eCkpIHtcbiAgICAgIHZhbGlkID0gZmFsc2VcbiAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdXG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbGlkKSB7XG4gICAgeWllbGQgW3VuZGVmaW5lZCwgdmFsdWUgYXMgVF1cbiAgfVxufVxuXG4vKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gb25lIHR5cGUgdG8gYW5vdGhlciwgb3ZlcndyaXRpbmcgZXhpc3RpbmcuXG4gKi9cblxuZXhwb3J0IHR5cGUgQXNzaWduPFQsIFU+ID0gU2ltcGxpZnk8VSAmIE9taXQ8VCwga2V5b2YgVT4+XG5cbi8qKlxuICogQSBzY2hlbWEgZm9yIGVudW0gc3RydWN0cy5cbiAqL1xuXG5leHBvcnQgdHlwZSBFbnVtU2NoZW1hPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCB1bmRlZmluZWQ+ID0ge1xuICBbSyBpbiBOb25OdWxsYWJsZTxUPl06IEtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHR5cGUgaXMgYW4gZXhhY3QgbWF0Y2guXG4gKi9cblxuZXhwb3J0IHR5cGUgSXNNYXRjaDxULCBHPiA9IFQgZXh0ZW5kcyBHID8gKEcgZXh0ZW5kcyBUID8gVCA6IG5ldmVyKSA6IG5ldmVyXG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgcmVjb3JkIHR5cGUuXG4gKi9cblxuZXhwb3J0IHR5cGUgSXNSZWNvcmQ8VD4gPSBUIGV4dGVuZHMgb2JqZWN0XG4gID8gc3RyaW5nIGV4dGVuZHMga2V5b2YgVFxuICAgID8gVFxuICAgIDogbmV2ZXJcbiAgOiBuZXZlclxuLyoqXG4gKiBDaGVjayBpZiBhIHR5cGUgaXMgYSB0dXBsZS5cbiAqL1xuXG5leHBvcnQgdHlwZSBJc1R1cGxlPFQ+ID0gVCBleHRlbmRzIFthbnldXG4gID8gVFxuICA6IFQgZXh0ZW5kcyBbYW55LCBhbnldXG4gID8gVFxuICA6IFQgZXh0ZW5kcyBbYW55LCBhbnksIGFueV1cbiAgPyBUXG4gIDogVCBleHRlbmRzIFthbnksIGFueSwgYW55LCBhbnldXG4gID8gVFxuICA6IFQgZXh0ZW5kcyBbYW55LCBhbnksIGFueSwgYW55LCBhbnldXG4gID8gVFxuICA6IG5ldmVyXG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgdW5pb24uXG4gKi9cblxuZXhwb3J0IHR5cGUgSXNVbmlvbjxULCBVIGV4dGVuZHMgVCA9IFQ+ID0gKFxuICBUIGV4dGVuZHMgYW55ID8gKFUgZXh0ZW5kcyBUID8gZmFsc2UgOiB0cnVlKSA6IGZhbHNlXG4pIGV4dGVuZHMgZmFsc2VcbiAgPyBuZXZlclxuICA6IFRcblxuLyoqXG4gKiBBIHNjaGVtYSBmb3Igb2JqZWN0IHN0cnVjdHMuXG4gKi9cblxuZXhwb3J0IHR5cGUgT2JqZWN0U2NoZW1hID0gUmVjb3JkPHN0cmluZywgU3RydWN0PGFueSwgYW55Pj5cblxuLyoqXG4gKiBJbmZlciBhIHR5cGUgZnJvbSBhbiBvYmplY3Qgc3RydWN0IHNjaGVtYS5cbiAqL1xuXG5leHBvcnQgdHlwZSBPYmplY3RUeXBlPFMgZXh0ZW5kcyBPYmplY3RTY2hlbWE+ID0gU2ltcGxpZnk8XG4gIE9wdGlvbmFsaXplPHsgW0sgaW4ga2V5b2YgU106IEluZmVyPFNbS10+IH0+XG4+XG5cbi8qKlxuICogT21pdCBwcm9wZXJ0aWVzIGZyb20gYSB0eXBlIHRoYXQgZXh0ZW5kIGZyb20gYSBzcGVjaWZpYyB0eXBlLlxuICovXG5cbmV4cG9ydCB0eXBlIE9taXRCeTxULCBWPiA9IE9taXQ8XG4gIFQsXG4gIHsgW0sgaW4ga2V5b2YgVF06IFYgZXh0ZW5kcyBFeHRyYWN0PFRbS10sIFY+ID8gSyA6IG5ldmVyIH1ba2V5b2YgVF1cbj5cblxuLyoqXG4gKiBOb3JtYWxpemUgcHJvcGVydGllcyBvZiBhIHR5cGUgdGhhdCBhbGxvdyBgdW5kZWZpbmVkYCB0byBtYWtlIHRoZW0gb3B0aW9uYWwuXG4gKi9cblxuZXhwb3J0IHR5cGUgT3B0aW9uYWxpemU8UyBleHRlbmRzIG9iamVjdD4gPSBPbWl0Qnk8UywgdW5kZWZpbmVkPiAmXG4gIFBhcnRpYWw8UGlja0J5PFMsIHVuZGVmaW5lZD4+XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIG9iamVjdCBzY2hlbWEgdHlwZSB0byByZXByZXNlbnQgYSBwYXJ0aWFsLlxuICovXG5cbmV4cG9ydCB0eXBlIFBhcnRpYWxPYmplY3RTY2hlbWE8UyBleHRlbmRzIE9iamVjdFNjaGVtYT4gPSB7XG4gIFtLIGluIGtleW9mIFNdOiBTdHJ1Y3Q8SW5mZXI8U1tLXT4gfCB1bmRlZmluZWQ+XG59XG5cbi8qKlxuICogUGljayBwcm9wZXJ0aWVzIGZyb20gYSB0eXBlIHRoYXQgZXh0ZW5kIGZyb20gYSBzcGVjaWZpYyB0eXBlLlxuICovXG5cbmV4cG9ydCB0eXBlIFBpY2tCeTxULCBWPiA9IFBpY2s8XG4gIFQsXG4gIHsgW0sgaW4ga2V5b2YgVF06IFYgZXh0ZW5kcyBFeHRyYWN0PFRbS10sIFY+ID8gSyA6IG5ldmVyIH1ba2V5b2YgVF1cbj5cblxuLyoqXG4gKiBTaW1wbGlmaWVzIGEgdHlwZSBkZWZpbml0aW9uIHRvIGl0cyBtb3N0IGJhc2ljIHJlcHJlc2VudGF0aW9uLlxuICovXG5cbmV4cG9ydCB0eXBlIFNpbXBsaWZ5PFQ+ID0gVCBleHRlbmRzIGFueVtdIHwgRGF0ZVxuICA/IFRcbiAgOiB7IFtLIGluIGtleW9mIFRdOiBUW0tdIH0gJiB7fVxuXG5leHBvcnQgdHlwZSBJZjxCIGV4dGVuZHMgQm9vbGVhbiwgVGhlbiwgRWxzZT4gPSBCIGV4dGVuZHMgdHJ1ZSA/IFRoZW4gOiBFbHNlXG5cbi8qKlxuICogQSBzY2hlbWEgZm9yIGFueSB0eXBlIG9mIHN0cnVjdC5cbiAqL1xuXG5leHBvcnQgdHlwZSBTdHJ1Y3RTY2hlbWE8VD4gPSBbVF0gZXh0ZW5kcyBbc3RyaW5nIHwgdW5kZWZpbmVkXVxuICA/IFtUXSBleHRlbmRzIFtJc01hdGNoPFQsIHN0cmluZyB8IHVuZGVmaW5lZD5dXG4gICAgPyBudWxsXG4gICAgOiBbVF0gZXh0ZW5kcyBbSXNVbmlvbjxUPl1cbiAgICA/IEVudW1TY2hlbWE8VD5cbiAgICA6IFRcbiAgOiBbVF0gZXh0ZW5kcyBbbnVtYmVyIHwgdW5kZWZpbmVkXVxuICA/IFtUXSBleHRlbmRzIFtJc01hdGNoPFQsIG51bWJlciB8IHVuZGVmaW5lZD5dXG4gICAgPyBudWxsXG4gICAgOiBbVF0gZXh0ZW5kcyBbSXNVbmlvbjxUPl1cbiAgICA/IEVudW1TY2hlbWE8VD5cbiAgICA6IFRcbiAgOiBbVF0gZXh0ZW5kcyBbYm9vbGVhbl1cbiAgPyBbVF0gZXh0ZW5kcyBbSXNNYXRjaDxULCBib29sZWFuPl1cbiAgICA/IG51bGxcbiAgICA6IFRcbiAgOiBUIGV4dGVuZHNcbiAgICAgIHwgYmlnaW50XG4gICAgICB8IHN5bWJvbFxuICAgICAgfCB1bmRlZmluZWRcbiAgICAgIHwgbnVsbFxuICAgICAgfCBGdW5jdGlvblxuICAgICAgfCBEYXRlXG4gICAgICB8IEVycm9yXG4gICAgICB8IFJlZ0V4cFxuICAgICAgfCBNYXA8YW55LCBhbnk+XG4gICAgICB8IFdlYWtNYXA8YW55LCBhbnk+XG4gICAgICB8IFNldDxhbnk+XG4gICAgICB8IFdlYWtTZXQ8YW55PlxuICAgICAgfCBQcm9taXNlPGFueT5cbiAgPyBudWxsXG4gIDogVCBleHRlbmRzIEFycmF5PGluZmVyIEU+XG4gID8gVCBleHRlbmRzIElzVHVwbGU8VD5cbiAgICA/IG51bGxcbiAgICA6IFN0cnVjdDxFPlxuICA6IFQgZXh0ZW5kcyBvYmplY3RcbiAgPyBUIGV4dGVuZHMgSXNSZWNvcmQ8VD5cbiAgICA/IG51bGxcbiAgICA6IHsgW0sgaW4ga2V5b2YgVF06IERlc2NyaWJlPFRbS10+IH1cbiAgOiBudWxsXG5cbi8qKlxuICogQSBzY2hlbWEgZm9yIHR1cGxlIHN0cnVjdHMuXG4gKi9cblxuZXhwb3J0IHR5cGUgVHVwbGVTY2hlbWE8VD4gPSB7IFtLIGluIGtleW9mIFRdOiBTdHJ1Y3Q8VFtLXT4gfVxuIiwiaW1wb3J0IHsgdG9GYWlsdXJlcywgc2hpZnRJdGVyYXRvciwgU3RydWN0U2NoZW1hLCBydW4gfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHsgU3RydWN0RXJyb3IsIEZhaWx1cmUgfSBmcm9tICcuL2Vycm9yJ1xuXG4vKipcbiAqIGBTdHJ1Y3RgIG9iamVjdHMgZW5jYXBzdWxhdGUgdGhlIHZhbGlkYXRpb24gbG9naWMgZm9yIGEgc3BlY2lmaWMgdHlwZSBvZlxuICogdmFsdWVzLiBPbmNlIGNvbnN0cnVjdGVkLCB5b3UgdXNlIHRoZSBgYXNzZXJ0YCwgYGlzYCBvciBgdmFsaWRhdGVgIGhlbHBlcnMgdG9cbiAqIHZhbGlkYXRlIHVua25vd24gaW5wdXQgZGF0YSBhZ2FpbnN0IHRoZSBzdHJ1Y3QuXG4gKi9cblxuZXhwb3J0IGNsYXNzIFN0cnVjdDxUID0gdW5rbm93biwgUyA9IHVua25vd24+IHtcbiAgcmVhZG9ubHkgVFlQRSE6IFRcbiAgdHlwZTogc3RyaW5nXG4gIHNjaGVtYTogU1xuICBjb2VyY2VyOiAodmFsdWU6IHVua25vd24sIGNvbnRleHQ6IENvbnRleHQpID0+IHVua25vd25cbiAgdmFsaWRhdG9yOiAodmFsdWU6IHVua25vd24sIGNvbnRleHQ6IENvbnRleHQpID0+IEl0ZXJhYmxlPEZhaWx1cmU+XG4gIHJlZmluZXI6ICh2YWx1ZTogVCwgY29udGV4dDogQ29udGV4dCkgPT4gSXRlcmFibGU8RmFpbHVyZT5cbiAgZW50cmllczogKFxuICAgIHZhbHVlOiB1bmtub3duLFxuICAgIGNvbnRleHQ6IENvbnRleHRcbiAgKSA9PiBJdGVyYWJsZTxbc3RyaW5nIHwgbnVtYmVyLCB1bmtub3duLCBTdHJ1Y3Q8YW55PiB8IFN0cnVjdDxuZXZlcj5dPlxuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiB7XG4gICAgdHlwZTogc3RyaW5nXG4gICAgc2NoZW1hOiBTXG4gICAgY29lcmNlcj86IENvZXJjZXJcbiAgICB2YWxpZGF0b3I/OiBWYWxpZGF0b3JcbiAgICByZWZpbmVyPzogUmVmaW5lcjxUPlxuICAgIGVudHJpZXM/OiBTdHJ1Y3Q8VCwgUz5bJ2VudHJpZXMnXVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHNjaGVtYSxcbiAgICAgIHZhbGlkYXRvcixcbiAgICAgIHJlZmluZXIsXG4gICAgICBjb2VyY2VyID0gKHZhbHVlOiB1bmtub3duKSA9PiB2YWx1ZSxcbiAgICAgIGVudHJpZXMgPSBmdW5jdGlvbiogKCkge30sXG4gICAgfSA9IHByb3BzXG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlXG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWFcbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzXG4gICAgdGhpcy5jb2VyY2VyID0gY29lcmNlclxuXG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdGhpcy52YWxpZGF0b3IgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KVxuICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdXG4gICAgfVxuXG4gICAgaWYgKHJlZmluZXIpIHtcbiAgICAgIHRoaXMucmVmaW5lciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjb250ZXh0KVxuICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZmluZXIgPSAoKSA9PiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICovXG5cbiAgYXNzZXJ0KHZhbHVlOiB1bmtub3duKTogYXNzZXJ0cyB2YWx1ZSBpcyBUIHtcbiAgICByZXR1cm4gYXNzZXJ0KHZhbHVlLCB0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIGNvZXJjaW9uIGxvZ2ljLCB0aGVuIHZhbGlkYXRlIGl0LlxuICAgKi9cblxuICBjcmVhdGUodmFsdWU6IHVua25vd24pOiBUIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCB0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLlxuICAgKi9cblxuICBpcyh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFQge1xuICAgIHJldHVybiBpcyh2YWx1ZSwgdGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXNrIGEgdmFsdWUsIGNvZXJjaW5nIGFuZCB2YWxpZGF0aW5nIGl0LCBidXQgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZlxuICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS5cbiAgICovXG5cbiAgbWFzayh2YWx1ZTogdW5rbm93bik6IFQge1xuICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiBsb2dpYywgcmV0dXJuaW5nIGEgdHVwbGVcbiAgICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIFlvdSBtYXkgb3B0aW9uYWxseSBwYXNzIGB0cnVlYCBmb3IgdGhlIGB3aXRoQ29lcmNpb25gIGFyZ3VtZW50IHRvIGNvZXJjZVxuICAgKiB0aGUgdmFsdWUgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdmFsaWRhdGUgaXQuIElmIHlvdSBkbywgdGhlIHJlc3VsdCB3aWxsXG4gICAqIGNvbnRhaW4gdGhlIGNvZXJjZWQgcmVzdWx0IHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICovXG5cbiAgdmFsaWRhdGUoXG4gICAgdmFsdWU6IHVua25vd24sXG4gICAgb3B0aW9uczoge1xuICAgICAgY29lcmNlPzogYm9vbGVhblxuICAgIH0gPSB7fVxuICApOiBbU3RydWN0RXJyb3IsIHVuZGVmaW5lZF0gfCBbdW5kZWZpbmVkLCBUXSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKHZhbHVlLCB0aGlzLCBvcHRpb25zKVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QsIHRocm93aW5nIGlmIGl0IGRvZXNuJ3QuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydDxULCBTPihcbiAgdmFsdWU6IHVua25vd24sXG4gIHN0cnVjdDogU3RydWN0PFQsIFM+XG4pOiBhc3NlcnRzIHZhbHVlIGlzIFQge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0KVxuXG4gIGlmIChyZXN1bHRbMF0pIHtcbiAgICB0aHJvdyByZXN1bHRbMF1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIGNvZXJjaW9uIGxvZ2ljIG9mIHN0cnVjdCBhbmQgdmFsaWRhdGUgaXQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZTxULCBTPih2YWx1ZTogdW5rbm93biwgc3RydWN0OiBTdHJ1Y3Q8VCwgUz4pOiBUIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgeyBjb2VyY2U6IHRydWUgfSlcblxuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdFsxXVxuICB9XG59XG5cbi8qKlxuICogTWFzayBhIHZhbHVlLCByZXR1cm5pbmcgb25seSB0aGUgc3Vic2V0IG9mIHByb3BlcnRpZXMgZGVmaW5lZCBieSBhIHN0cnVjdC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWFzazxULCBTPih2YWx1ZTogdW5rbm93biwgc3RydWN0OiBTdHJ1Y3Q8VCwgUz4pOiBUIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgeyBjb2VyY2U6IHRydWUsIG1hc2s6IHRydWUgfSlcblxuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdFsxXVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzPFQsIFM+KHZhbHVlOiB1bmtub3duLCBzdHJ1Y3Q6IFN0cnVjdDxULCBTPik6IHZhbHVlIGlzIFQge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0KVxuICByZXR1cm4gIXJlc3VsdFswXVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgcmV0dXJuaW5nIGFuIGVycm9yIGlmIGludmFsaWQsIG9yIHRoZVxuICogdmFsdWUgKHdpdGggcG90ZW50aWFsIGNvZXJjaW9uKSBpZiB2YWxpZC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGU8VCwgUz4oXG4gIHZhbHVlOiB1bmtub3duLFxuICBzdHJ1Y3Q6IFN0cnVjdDxULCBTPixcbiAgb3B0aW9uczoge1xuICAgIGNvZXJjZT86IGJvb2xlYW5cbiAgICBtYXNrPzogYm9vbGVhblxuICB9ID0ge31cbik6IFtTdHJ1Y3RFcnJvciwgdW5kZWZpbmVkXSB8IFt1bmRlZmluZWQsIFRdIHtcbiAgY29uc3QgdHVwbGVzID0gcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpXG4gIGNvbnN0IHR1cGxlID0gc2hpZnRJdGVyYXRvcih0dXBsZXMpIVxuXG4gIGlmICh0dXBsZVswXSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFN0cnVjdEVycm9yKHR1cGxlWzBdLCBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIChjb25zdCB0IG9mIHR1cGxlcykge1xuICAgICAgICBpZiAodFswXSkge1xuICAgICAgICAgIHlpZWxkIHRbMF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gW2Vycm9yLCB1bmRlZmluZWRdXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdiA9IHR1cGxlWzFdXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHZdXG4gIH1cbn1cblxuLyoqXG4gKiBBIGBDb250ZXh0YCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBsb2NhdGlvbiBvZiB0aGVcbiAqIHZhbGlkYXRpb24gaW5zaWRlIHRoZSBpbml0aWFsIGlucHV0IHZhbHVlLlxuICovXG5cbmV4cG9ydCB0eXBlIENvbnRleHQgPSB7XG4gIGJyYW5jaDogQXJyYXk8YW55PlxuICBwYXRoOiBBcnJheTxhbnk+XG59XG5cbi8qKlxuICogQSB0eXBlIHV0aWxpdHkgdG8gZXh0cmFjdCB0aGUgdHlwZSBmcm9tIGEgYFN0cnVjdGAgY2xhc3MuXG4gKi9cblxuZXhwb3J0IHR5cGUgSW5mZXI8VCBleHRlbmRzIFN0cnVjdDxhbnksIGFueT4+ID0gVFsnVFlQRSddXG5cbi8qKlxuICogQSB0eXBlIHV0aWxpdHkgdG8gZGVzY3JpYmUgdGhhdCBhIHN0cnVjdCByZXByZXNlbnRzIGEgVHlwZVNjcmlwdCB0eXBlLlxuICovXG5cbmV4cG9ydCB0eXBlIERlc2NyaWJlPFQ+ID0gU3RydWN0PFQsIFN0cnVjdFNjaGVtYTxUPj5cblxuLyoqXG4gKiBBIGBSZXN1bHRgIGlzIHJldHVybmVkIGZyb20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuXG4gKi9cblxuZXhwb3J0IHR5cGUgUmVzdWx0ID1cbiAgfCBib29sZWFuXG4gIHwgc3RyaW5nXG4gIHwgUGFydGlhbDxGYWlsdXJlPlxuICB8IEl0ZXJhYmxlPGJvb2xlYW4gfCBzdHJpbmcgfCBQYXJ0aWFsPEZhaWx1cmU+PlxuXG4vKipcbiAqIEEgYENvZXJjZXJgIHRha2VzIGFuIHVua25vd24gdmFsdWUgYW5kIG9wdGlvbmFsbHkgY29lcmNlcyBpdC5cbiAqL1xuXG5leHBvcnQgdHlwZSBDb2VyY2VyPFQgPSB1bmtub3duPiA9ICh2YWx1ZTogVCwgY29udGV4dDogQ29udGV4dCkgPT4gdW5rbm93blxuXG4vKipcbiAqIEEgYFZhbGlkYXRvcmAgdGFrZXMgYW4gdW5rbm93biB2YWx1ZSBhbmQgdmFsaWRhdGVzIGl0LlxuICovXG5cbmV4cG9ydCB0eXBlIFZhbGlkYXRvciA9ICh2YWx1ZTogdW5rbm93biwgY29udGV4dDogQ29udGV4dCkgPT4gUmVzdWx0XG5cbi8qKlxuICogQSBgUmVmaW5lcmAgdGFrZXMgYSB2YWx1ZSBvZiBhIGtub3duIHR5cGUgYW5kIHZhbGlkYXRlcyBpdCBhZ2FpbnN0IGEgZnVydGhlclxuICogY29uc3RyYWludC5cbiAqL1xuXG5leHBvcnQgdHlwZSBSZWZpbmVyPFQ+ID0gKHZhbHVlOiBULCBjb250ZXh0OiBDb250ZXh0KSA9PiBSZXN1bHRcbiIsImltcG9ydCB7IFN0cnVjdCwgQ29udGV4dCwgVmFsaWRhdG9yIH0gZnJvbSAnLi4vc3RydWN0J1xuaW1wb3J0IHsgb2JqZWN0LCBvcHRpb25hbCwgdHlwZSB9IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgeyBPYmplY3RTY2hlbWEsIEFzc2lnbiwgT2JqZWN0VHlwZSwgUGFydGlhbE9iamVjdFNjaGVtYSB9IGZyb20gJy4uL3V0aWxzJ1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgdGhhdCBjb21iaW5lcyB0aGUgcHJvcGVydGllcyBwcm9wZXJ0aWVzIGZyb20gbXVsdGlwbGVcbiAqIG9iamVjdCBvciB0eXBlIHN0cnVjdHMuIEl0cyByZXR1cm4gdHlwZSB3aWxsIG1hdGNoIHRoZSBmaXJzdCBwYXJhbWV0ZXIncyB0eXBlLlxuICpcbiAqIExpa2UgSmF2YVNjcmlwdCdzIGBPYmplY3QuYXNzaWduYCB1dGlsaXR5LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248QSBleHRlbmRzIE9iamVjdFNjaGVtYSwgQiBleHRlbmRzIE9iamVjdFNjaGVtYT4oXG4gIEE6IFN0cnVjdDxPYmplY3RUeXBlPEE+LCBBPixcbiAgQjogU3RydWN0PE9iamVjdFR5cGU8Qj4sIEI+XG4pOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxBc3NpZ248QSwgQj4+LCBBc3NpZ248QSwgQj4+XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFxuICBBIGV4dGVuZHMgT2JqZWN0U2NoZW1hLFxuICBCIGV4dGVuZHMgT2JqZWN0U2NoZW1hLFxuICBDIGV4dGVuZHMgT2JqZWN0U2NoZW1hXG4+KFxuICBBOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxBPiwgQT4sXG4gIEI6IFN0cnVjdDxPYmplY3RUeXBlPEI+LCBCPixcbiAgQzogU3RydWN0PE9iamVjdFR5cGU8Qz4sIEM+XG4pOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxBc3NpZ248QXNzaWduPEEsIEI+LCBDPj4sIEFzc2lnbjxBc3NpZ248QSwgQj4sIEM+PlxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxcbiAgQSBleHRlbmRzIE9iamVjdFNjaGVtYSxcbiAgQiBleHRlbmRzIE9iamVjdFNjaGVtYSxcbiAgQyBleHRlbmRzIE9iamVjdFNjaGVtYSxcbiAgRCBleHRlbmRzIE9iamVjdFNjaGVtYVxuPihcbiAgQTogU3RydWN0PE9iamVjdFR5cGU8QT4sIEE+LFxuICBCOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxCPiwgQj4sXG4gIEM6IFN0cnVjdDxPYmplY3RUeXBlPEM+LCBDPixcbiAgRDogU3RydWN0PE9iamVjdFR5cGU8RD4sIEQ+XG4pOiBTdHJ1Y3Q8XG4gIE9iamVjdFR5cGU8QXNzaWduPEFzc2lnbjxBc3NpZ248QSwgQj4sIEM+LCBEPj4sXG4gIEFzc2lnbjxBc3NpZ248QXNzaWduPEEsIEI+LCBDPiwgRD5cbj5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248XG4gIEEgZXh0ZW5kcyBPYmplY3RTY2hlbWEsXG4gIEIgZXh0ZW5kcyBPYmplY3RTY2hlbWEsXG4gIEMgZXh0ZW5kcyBPYmplY3RTY2hlbWEsXG4gIEQgZXh0ZW5kcyBPYmplY3RTY2hlbWEsXG4gIEUgZXh0ZW5kcyBPYmplY3RTY2hlbWFcbj4oXG4gIEE6IFN0cnVjdDxPYmplY3RUeXBlPEE+LCBBPixcbiAgQjogU3RydWN0PE9iamVjdFR5cGU8Qj4sIEI+LFxuICBDOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxDPiwgQz4sXG4gIEQ6IFN0cnVjdDxPYmplY3RUeXBlPEQ+LCBEPixcbiAgRTogU3RydWN0PE9iamVjdFR5cGU8RT4sIEU+XG4pOiBTdHJ1Y3Q8XG4gIE9iamVjdFR5cGU8QXNzaWduPEFzc2lnbjxBc3NpZ248QXNzaWduPEEsIEI+LCBDPiwgRD4sIEU+PixcbiAgQXNzaWduPEFzc2lnbjxBc3NpZ248QXNzaWduPEEsIEI+LCBDPiwgRD4sIEU+XG4+XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKC4uLlN0cnVjdHM6IFN0cnVjdDxhbnk+W10pOiBhbnkge1xuICBjb25zdCBpc1R5cGUgPSBTdHJ1Y3RzWzBdLnR5cGUgPT09ICd0eXBlJ1xuICBjb25zdCBzY2hlbWFzID0gU3RydWN0cy5tYXAoKHMpID0+IHMuc2NoZW1hKVxuICBjb25zdCBzY2hlbWEgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5zY2hlbWFzKVxuICByZXR1cm4gaXNUeXBlID8gdHlwZShzY2hlbWEpIDogb2JqZWN0KHNjaGVtYSlcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmU8VD4obmFtZTogc3RyaW5nLCB2YWxpZGF0b3I6IFZhbGlkYXRvcik6IFN0cnVjdDxULCBudWxsPiB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgdHlwZTogbmFtZSwgc2NoZW1hOiBudWxsLCB2YWxpZGF0b3IgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIHN0cnVjdCwgYnV0IHRoZSB2YWx1ZSBpcyBhbGxvd2VkIHRvXG4gKiBiZSBgdW5kZWZpbmVkYC4gYGxvZ2Agd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHZhbHVlIGlzIG5vdCBgdW5kZWZpbmVkYC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlZDxUPihcbiAgc3RydWN0OiBTdHJ1Y3Q8VD4sXG4gIGxvZzogKHZhbHVlOiB1bmtub3duLCBjdHg6IENvbnRleHQpID0+IHZvaWRcbik6IFN0cnVjdDxUPiB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAuLi5zdHJ1Y3QsXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2codmFsdWUsIGN0eClcbiAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eClcbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGR5bmFtaWMgdmFsaWRhdGlvbiBsb2dpYy5cbiAqXG4gKiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHRoZSB2YWx1ZSBjdXJyZW50bHkgYmVpbmcgdmFsaWRhdGVkLCBhbmQgbXVzdFxuICogcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB2YWxpZGF0ZSBpdCB3aXRoLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gbW9kZWxcbiAqIHZhbGlkYXRpb24gbG9naWMgdGhhdCBjaGFuZ2VzIGJhc2VkIG9uIGl0cyBpbnB1dC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZHluYW1pYzxUPihcbiAgZm46ICh2YWx1ZTogdW5rbm93biwgY3R4OiBDb250ZXh0KSA9PiBTdHJ1Y3Q8VCwgYW55PlxuKTogU3RydWN0PFQsIG51bGw+IHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdkeW5hbWljJyxcbiAgICBzY2hlbWE6IG51bGwsXG4gICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eClcbiAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KVxuICAgIH0sXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpXG4gICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KVxuICAgIH0sXG4gICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KVxuICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpXG4gICAgfSxcbiAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBsYXppbHkgZXZhbHVhdGVkIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdmFsaWRhdGlvbiBpcyBydW4gd2l0aCB0aGUgc3RydWN0LCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAqIGFuZCBtdXN0IHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdXNlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXMgd2hlcmUgeW91XG4gKiB3YW50IHRvIGhhdmUgc2VsZi1yZWZlcmVudGlhbCBzdHJ1Y3RzIGZvciBuZXN0ZWQgZGF0YSBzdHJ1Y3R1cmVzIHRvIGF2b2lkIGFcbiAqIGNpcmN1bGFyIGRlZmluaXRpb24gcHJvYmxlbS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGF6eTxUPihmbjogKCkgPT4gU3RydWN0PFQsIGFueT4pOiBTdHJ1Y3Q8VCwgbnVsbD4ge1xuICBsZXQgc3RydWN0OiBTdHJ1Y3Q8VCwgYW55PiB8IHVuZGVmaW5lZFxuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2xhenknLFxuICAgIHNjaGVtYTogbnVsbCxcbiAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICBzdHJ1Y3QgPz89IGZuKClcbiAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KVxuICAgIH0sXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIHN0cnVjdCA/Pz0gZm4oKVxuICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eClcbiAgICB9LFxuICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgc3RydWN0ID8/PSBmbigpXG4gICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eClcbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IGV4Y2x1ZGluZ1xuICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgT21pdGAgdXRpbGl0eS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gb21pdDxTIGV4dGVuZHMgT2JqZWN0U2NoZW1hLCBLIGV4dGVuZHMga2V5b2YgUz4oXG4gIHN0cnVjdDogU3RydWN0PE9iamVjdFR5cGU8Uz4sIFM+LFxuICBrZXlzOiBLW11cbik6IFN0cnVjdDxPYmplY3RUeXBlPE9taXQ8UywgSz4+LCBPbWl0PFMsIEs+PiB7XG4gIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3RcbiAgY29uc3Qgc3Vic2NoZW1hOiBhbnkgPSB7IC4uLnNjaGVtYSB9XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEgYXMgT21pdDxTLCBLPilcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCB3aXRoIGFsbCBvZiBpdHNcbiAqIHByb3BlcnRpZXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYC5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGFydGlhbGAgdXRpbGl0eS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGFydGlhbDxTIGV4dGVuZHMgT2JqZWN0U2NoZW1hPihcbiAgc3RydWN0OiBTdHJ1Y3Q8T2JqZWN0VHlwZTxTPiwgUz4gfCBTXG4pOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxQYXJ0aWFsT2JqZWN0U2NoZW1hPFM+PiwgUGFydGlhbE9iamVjdFNjaGVtYTxTPj4ge1xuICBjb25zdCBzY2hlbWE6IGFueSA9XG4gICAgc3RydWN0IGluc3RhbmNlb2YgU3RydWN0ID8geyAuLi5zdHJ1Y3Quc2NoZW1hIH0gOiB7IC4uLnN0cnVjdCB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgc2NoZW1hW2tleV0gPSBvcHRpb25hbChzY2hlbWFba2V5XSlcbiAgfVxuXG4gIHJldHVybiBvYmplY3Qoc2NoZW1hKSBhcyBhbnlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCBvbmx5IGluY2x1ZGluZ1xuICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGlja2AgdXRpbGl0eS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGljazxTIGV4dGVuZHMgT2JqZWN0U2NoZW1hLCBLIGV4dGVuZHMga2V5b2YgUz4oXG4gIHN0cnVjdDogU3RydWN0PE9iamVjdFR5cGU8Uz4sIFM+LFxuICBrZXlzOiBLW11cbik6IFN0cnVjdDxPYmplY3RUeXBlPFBpY2s8UywgSz4+LCBQaWNrPFMsIEs+PiB7XG4gIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3RcbiAgY29uc3Qgc3Vic2NoZW1hOiBhbnkgPSB7fVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBzdWJzY2hlbWFba2V5XSA9IHNjaGVtYVtrZXldXG4gIH1cblxuICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSBhcyBQaWNrPFMsIEs+KVxufVxuXG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJ1Y3Q8VD4obmFtZTogc3RyaW5nLCB2YWxpZGF0b3I6IFZhbGlkYXRvcik6IFN0cnVjdDxULCBudWxsPiB7XG4gIGNvbnNvbGUud2FybihcbiAgICAnc3VwZXJzdHJ1Y3RAMC4xMSAtIFRoZSBgc3RydWN0YCBoZWxwZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBgZGVmaW5lYC4nXG4gIClcblxuICByZXR1cm4gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcilcbn1cbiIsImltcG9ydCB7IEluZmVyLCBTdHJ1Y3QgfSBmcm9tICcuLi9zdHJ1Y3QnXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tICcuL3V0aWxpdGllcydcbmltcG9ydCB7XG4gIFR1cGxlU2NoZW1hLFxuICBPYmplY3RTY2hlbWEsXG4gIE9iamVjdFR5cGUsXG4gIHByaW50LFxuICBydW4sXG4gIGlzT2JqZWN0LFxufSBmcm9tICcuLi91dGlscydcblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFueSgpOiBTdHJ1Y3Q8YW55LCBudWxsPiB7XG4gIHJldHVybiBkZWZpbmUoJ2FueScsICgpID0+IHRydWUpXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBhcnJheSBhbmQgdGhhdCBpdHMgZWxlbWVudHMgYXJlIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAqXG4gKiBOb3RlOiBJZiB5b3Ugb21pdCB0aGUgZWxlbWVudCBzdHJ1Y3QsIHRoZSBhcnJheXMgZWxlbWVudHMgd2lsbCBub3QgYmVcbiAqIGl0ZXJhdGVkIGF0IGFsbC4gVGhpcyBjYW4gYmUgaGVscGZ1bCBmb3IgY2FzZXMgd2hlcmUgcGVyZm9ybWFuY2UgaXMgY3JpdGljYWwsXG4gKiBhbmQgaXQgaXMgcHJlZmVycmVkIHRvIHVzaW5nIGBhcnJheShhbnkoKSlgLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheTxUIGV4dGVuZHMgU3RydWN0PGFueT4+KEVsZW1lbnQ6IFQpOiBTdHJ1Y3Q8SW5mZXI8VD5bXSwgVD5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheSgpOiBTdHJ1Y3Q8dW5rbm93bltdLCB1bmRlZmluZWQ+XG5leHBvcnQgZnVuY3Rpb24gYXJyYXk8VCBleHRlbmRzIFN0cnVjdDxhbnk+PihFbGVtZW50PzogVCk6IGFueSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnYXJyYXknLFxuICAgIHNjaGVtYTogRWxlbWVudCxcbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEVsZW1lbnQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaSwgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgeWllbGQgW2ksIHYsIEVsZW1lbnRdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiB2YWx1ZVxuICAgIH0sXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXkgdmFsdWUsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YFxuICAgICAgKVxuICAgIH0sXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGJvb2xlYW4oKTogU3RydWN0PGJvb2xlYW4sIG51bGw+IHtcbiAgcmV0dXJuIGRlZmluZSgnYm9vbGVhbicsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBgRGF0ZWAuXG4gKlxuICogTm90ZTogdGhpcyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgdmFsdWUgaXMgKm5vdCogYW4gaW52YWxpZCBgRGF0ZWAgb2JqZWN0LFxuICogd2hpY2ggY2FuIG9jY3VyIHdoZW4gcGFyc2luZyBhIGRhdGUgZmFpbHMgYnV0IHN0aWxsIHJldHVybnMgYSBgRGF0ZWAuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRhdGUoKTogU3RydWN0PERhdGUsIG51bGw+IHtcbiAgcmV0dXJuIGRlZmluZSgnZGF0ZScsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAodmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB8fFxuICAgICAgYEV4cGVjdGVkIGEgdmFsaWQgXFxgRGF0ZVxcYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YFxuICAgIClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIG9uZSBvZiBhIHNldCBvZiBwb3RlbnRpYWwgdmFsdWVzLlxuICpcbiAqIE5vdGU6IGFmdGVyIGNyZWF0aW5nIHRoZSBzdHJ1Y3QsIHlvdSBjYW4gYWNjZXNzIHRoZSBkZWZpbml0aW9uIG9mIHRoZVxuICogcG90ZW50aWFsIHZhbHVlcyBhcyBgc3RydWN0LnNjaGVtYWAuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVudW1zPFQgZXh0ZW5kcyBudW1iZXI+KFxuICB2YWx1ZXM6IHJlYWRvbmx5IFRbXVxuKTogU3RydWN0PFQsIHsgW0sgaW4gVFtdW251bWJlcl1dOiBLIH0+XG5leHBvcnQgZnVuY3Rpb24gZW51bXM8VCBleHRlbmRzIHN0cmluZz4oXG4gIHZhbHVlczogcmVhZG9ubHkgVFtdXG4pOiBTdHJ1Y3Q8VCwgeyBbSyBpbiBUW11bbnVtYmVyXV06IEsgfT5cbmV4cG9ydCBmdW5jdGlvbiBlbnVtczxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nPih2YWx1ZXM6IHJlYWRvbmx5IFRbXSk6IGFueSB7XG4gIGNvbnN0IHNjaGVtYTogYW55ID0ge31cbiAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZXMubWFwKCh2KSA9PiBwcmludCh2KSkuam9pbigpXG5cbiAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgc2NoZW1hW2tleV0gPSBrZXlcbiAgfVxuXG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnZW51bXMnLFxuICAgIHNjaGVtYSxcbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZhbHVlcy5pbmNsdWRlcyh2YWx1ZSBhcyBhbnkpIHx8XG4gICAgICAgIGBFeHBlY3RlZCBvbmUgb2YgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YFxuICAgICAgKVxuICAgIH0sXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jKCk6IFN0cnVjdDxGdW5jdGlvbiwgbnVsbD4ge1xuICByZXR1cm4gZGVmaW5lKCdmdW5jJywgKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgYEV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YFxuICAgIClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGEgc3BlY2lmaWMgY2xhc3MuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbmNlPFQgZXh0ZW5kcyB7IG5ldyAoLi4uYXJnczogYW55KTogYW55IH0+KFxuICBDbGFzczogVFxuKTogU3RydWN0PEluc3RhbmNlVHlwZTxUPiwgbnVsbD4ge1xuICByZXR1cm4gZGVmaW5lKCdpbnN0YW5jZScsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICB2YWx1ZSBpbnN0YW5jZW9mIENsYXNzIHx8XG4gICAgICBgRXhwZWN0ZWQgYSBcXGAke0NsYXNzLm5hbWV9XFxgIGluc3RhbmNlLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICApXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyKCk6IFN0cnVjdDxudW1iZXIsIG51bGw+IHtcbiAgcmV0dXJuIGRlZmluZSgnaW50ZWdlcicsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB8fFxuICAgICAgYEV4cGVjdGVkIGFuIGludGVnZXIsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YFxuICAgIClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgYWxsIG9mIGEgc2V0IG9mIHR5cGVzLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Rpb248QT4oU3RydWN0czogVHVwbGVTY2hlbWE8W0FdPik6IFN0cnVjdDxBLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbjxBLCBCPihcbiAgU3RydWN0czogVHVwbGVTY2hlbWE8W0EsIEJdPlxuKTogU3RydWN0PEEgJiBCLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbjxBLCBCLCBDPihcbiAgU3RydWN0czogVHVwbGVTY2hlbWE8W0EsIEIsIENdPlxuKTogU3RydWN0PEEgJiBCICYgQywgbnVsbD5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Rpb248QSwgQiwgQywgRD4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBEXT5cbik6IFN0cnVjdDxBICYgQiAmIEMgJiBELCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbjxBLCBCLCBDLCBELCBFPihcbiAgU3RydWN0czogVHVwbGVTY2hlbWE8W0EsIEIsIEMsIEQsIEVdPlxuKTogU3RydWN0PEEgJiBCICYgQyAmIEQgJiBFLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbjxBLCBCLCBDLCBELCBFLCBGPihcbiAgU3RydWN0czogVHVwbGVTY2hlbWE8W0EsIEIsIEMsIEQsIEUsIEZdPlxuKTogU3RydWN0PEEgJiBCICYgQyAmIEQgJiBFICYgRiwgbnVsbD5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Rpb248QSwgQiwgQywgRCwgRSwgRiwgRz4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBELCBFLCBGLCBHXT5cbik6IFN0cnVjdDxBICYgQiAmIEMgJiBEICYgRSAmIEYgJiBHLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbjxBLCBCLCBDLCBELCBFLCBGLCBHLCBIPihcbiAgU3RydWN0czogVHVwbGVTY2hlbWE8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdPlxuKTogU3RydWN0PEEgJiBCICYgQyAmIEQgJiBFICYgRiAmIEcgJiBILCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbjxBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJPihcbiAgU3RydWN0czogVHVwbGVTY2hlbWE8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEldPlxuKTogU3RydWN0PEEgJiBCICYgQyAmIEQgJiBFICYgRiAmIEcgJiBIICYgSSwgbnVsbD5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Rpb248QSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSj4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKXT5cbik6IFN0cnVjdDxBICYgQiAmIEMgJiBEICYgRSAmIEYgJiBHICYgSCAmIEkgJiBKLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbjxBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKLCBLPihcbiAgU3RydWN0czogVHVwbGVTY2hlbWE8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEtdPlxuKTogU3RydWN0PEEgJiBCICYgQyAmIEQgJiBFICYgRiAmIEcgJiBIICYgSSAmIEogJiBLLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbjxBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKLCBLLCBMPihcbiAgU3RydWN0czogVHVwbGVTY2hlbWE8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIExdPlxuKTogU3RydWN0PEEgJiBCICYgQyAmIEQgJiBFICYgRiAmIEcgJiBIICYgSSAmIEogJiBLICYgTCwgbnVsbD5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Rpb248QSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTCwgTT4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKLCBLLCBMLCBNXT5cbik6IFN0cnVjdDxBICYgQiAmIEMgJiBEICYgRSAmIEYgJiBHICYgSCAmIEkgJiBKICYgSyAmIEwgJiBNLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbjxBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKLCBLLCBMLCBNLCBOPihcbiAgU3RydWN0czogVHVwbGVTY2hlbWE8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE5dPlxuKTogU3RydWN0PEEgJiBCICYgQyAmIEQgJiBFICYgRiAmIEcgJiBIICYgSSAmIEogJiBLICYgTCAmIE0gJiBOLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbjxBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKLCBLLCBMLCBNLCBOLCBPPihcbiAgU3RydWN0czogVHVwbGVTY2hlbWE8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE4sIE9dPlxuKTogU3RydWN0PEEgJiBCICYgQyAmIEQgJiBFICYgRiAmIEcgJiBIICYgSSAmIEogJiBLICYgTCAmIE0gJiBOICYgTywgbnVsbD5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Rpb248QSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTCwgTSwgTiwgTywgUD4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKLCBLLCBMLCBNLCBOLCBPLCBQXT5cbik6IFN0cnVjdDxBICYgQiAmIEMgJiBEICYgRSAmIEYgJiBHICYgSCAmIEkgJiBKICYgSyAmIEwgJiBNICYgTiAmIE8gJiBQLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbjxBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKLCBLLCBMLCBNLCBOLCBPLCBQLCBRPihcbiAgU3RydWN0czogVHVwbGVTY2hlbWE8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE4sIE8sIFAsIFFdPlxuKTogU3RydWN0PFxuICBBICYgQiAmIEMgJiBEICYgRSAmIEYgJiBHICYgSCAmIEkgJiBKICYgSyAmIEwgJiBNICYgTiAmIE8gJiBQICYgUSxcbiAgbnVsbFxuPlxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbihTdHJ1Y3RzOiBBcnJheTxTdHJ1Y3Q8YW55LCBhbnk+Pik6IGFueSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnaW50ZXJzZWN0aW9uJyxcbiAgICBzY2hlbWE6IG51bGwsXG4gICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgeWllbGQqIFMuZW50cmllcyh2YWx1ZSwgY3R4KVxuICAgICAgfVxuICAgIH0sXG4gICAgKnZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICB5aWVsZCogUy52YWxpZGF0b3IodmFsdWUsIGN0eClcbiAgICAgIH1cbiAgICB9LFxuICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIHlpZWxkKiBTLnJlZmluZXIodmFsdWUsIGN0eClcbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gZXhhY3QgdmFsdWUsIHVzaW5nIGA9PT1gIGZvciBjb21wYXJpc29uLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsaXRlcmFsPFQgZXh0ZW5kcyBib29sZWFuPihjb25zdGFudDogVCk6IFN0cnVjdDxULCBUPlxuZXhwb3J0IGZ1bmN0aW9uIGxpdGVyYWw8VCBleHRlbmRzIG51bWJlcj4oY29uc3RhbnQ6IFQpOiBTdHJ1Y3Q8VCwgVD5cbmV4cG9ydCBmdW5jdGlvbiBsaXRlcmFsPFQgZXh0ZW5kcyBzdHJpbmc+KGNvbnN0YW50OiBUKTogU3RydWN0PFQsIFQ+XG5leHBvcnQgZnVuY3Rpb24gbGl0ZXJhbDxUPihjb25zdGFudDogVCk6IFN0cnVjdDxULCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGxpdGVyYWw8VD4oY29uc3RhbnQ6IFQpOiBhbnkge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IHByaW50KGNvbnN0YW50KVxuICBjb25zdCB0ID0gdHlwZW9mIGNvbnN0YW50XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgc2NoZW1hOlxuICAgICAgdCA9PT0gJ3N0cmluZycgfHwgdCA9PT0gJ251bWJlcicgfHwgdCA9PT0gJ2Jvb2xlYW4nID8gY29uc3RhbnQgOiBudWxsLFxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdmFsdWUgPT09IGNvbnN0YW50IHx8XG4gICAgICAgIGBFeHBlY3RlZCB0aGUgbGl0ZXJhbCBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gXG4gICAgICApXG4gICAgfSxcbiAgfSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYE1hcGAgb2JqZWN0LCBhbmQgdGhhdCBpdHMga2V5cyBhbmQgdmFsdWVzIGFyZSBvZlxuICogc3BlY2lmaWMgdHlwZXMuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcCgpOiBTdHJ1Y3Q8TWFwPHVua25vd24sIHVua25vd24+LCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIG1hcDxLLCBWPihcbiAgS2V5OiBTdHJ1Y3Q8Sz4sXG4gIFZhbHVlOiBTdHJ1Y3Q8Vj5cbik6IFN0cnVjdDxNYXA8SywgVj4sIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gbWFwPEssIFY+KEtleT86IFN0cnVjdDxLPiwgVmFsdWU/OiBTdHJ1Y3Q8Vj4pOiBhbnkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ21hcCcsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoS2V5ICYmIFZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIHlpZWxkIFtrIGFzIHN0cmluZywgaywgS2V5XVxuICAgICAgICAgIHlpZWxkIFtrIGFzIHN0cmluZywgdiwgVmFsdWVdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCA/IG5ldyBNYXAodmFsdWUpIDogdmFsdWVcbiAgICB9LFxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgYEV4cGVjdGVkIGEgXFxgTWFwXFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gXG4gICAgICApXG4gICAgfSxcbiAgfSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBubyB2YWx1ZSBldmVyIHBhc3NlcyB2YWxpZGF0aW9uLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBuZXZlcigpOiBTdHJ1Y3Q8bmV2ZXIsIG51bGw+IHtcbiAgcmV0dXJuIGRlZmluZSgnbmV2ZXInLCAoKSA9PiBmYWxzZSlcbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIGV4aXN0aW5nIHN0cnVjdCB0byBhbGxvdyBgbnVsbGAgdmFsdWVzLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBudWxsYWJsZTxULCBTPihzdHJ1Y3Q6IFN0cnVjdDxULCBTPik6IFN0cnVjdDxUIHwgbnVsbCwgUz4ge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgLi4uc3RydWN0LFxuICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlcigpOiBTdHJ1Y3Q8bnVtYmVyLCBudWxsPiB7XG4gIHJldHVybiBkZWZpbmUoJ251bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpKSB8fFxuICAgICAgYEV4cGVjdGVkIGEgbnVtYmVyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICApXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3QsIHRoYXQgaXMgaGFzIGEga25vd24gc2V0IG9mIHByb3BlcnRpZXMsXG4gKiBhbmQgdGhhdCBpdHMgcHJvcGVydGllcyBhcmUgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgd2lsbCBmYWlsIHZhbGlkYXRpb24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdCgpOiBTdHJ1Y3Q8UmVjb3JkPHN0cmluZywgdW5rbm93bj4sIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0PFMgZXh0ZW5kcyBPYmplY3RTY2hlbWE+KFxuICBzY2hlbWE6IFNcbik6IFN0cnVjdDxPYmplY3RUeXBlPFM+LCBTPlxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdDxTIGV4dGVuZHMgT2JqZWN0U2NoZW1hPihzY2hlbWE/OiBTKTogYW55IHtcbiAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdXG4gIGNvbnN0IE5ldmVyID0gbmV2ZXIoKVxuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgc2NoZW1hOiBzY2hlbWEgPyBzY2hlbWEgOiBudWxsLFxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoc2NoZW1hICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCB1bmtub3ducyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtub3ducykge1xuICAgICAgICAgIHVua25vd25zLmRlbGV0ZShrZXkpXG4gICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgc2NoZW1hW2tleV1dXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIE5ldmVyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICAgIClcbiAgICB9LFxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZVxuICAgIH0sXG4gIH0pXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byBhbGxvdyBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsPFQsIFM+KHN0cnVjdDogU3RydWN0PFQsIFM+KTogU3RydWN0PFQgfCB1bmRlZmluZWQsIFM+IHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIC4uLnN0cnVjdCxcbiAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PlxuICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGgga2V5cyBhbmQgdmFsdWVzIG9mIHNwZWNpZmljIHR5cGVzLCBidXRcbiAqIHdpdGhvdXQgZW5zdXJpbmcgYW55IHNwZWNpZmljIHNoYXBlIG9mIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFJlY29yZGAgdXRpbGl0eS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcsIFY+KFxuICBLZXk6IFN0cnVjdDxLPixcbiAgVmFsdWU6IFN0cnVjdDxWPlxuKTogU3RydWN0PFJlY29yZDxLLCBWPiwgbnVsbD4ge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3JlY29yZCcsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZVtrXVxuICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldXG4gICAgICAgICAgeWllbGQgW2ssIHYsIFZhbHVlXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICAgIClcbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBgUmVnRXhwYC5cbiAqXG4gKiBOb3RlOiB0aGlzIGRvZXMgbm90IHRlc3QgdGhlIHZhbHVlIGFnYWluc3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiEgRm9yIHRoYXRcbiAqIHlvdSBuZWVkIHRvIHVzZSB0aGUgYHBhdHRlcm4oKWAgcmVmaW5lbWVudC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnZXhwKCk6IFN0cnVjdDxSZWdFeHAsIG51bGw+IHtcbiAgcmV0dXJuIGRlZmluZSgncmVnZXhwJywgKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGBTZXRgIG9iamVjdCwgYW5kIHRoYXQgaXRzIGVsZW1lbnRzIGFyZSBvZiBhXG4gKiBzcGVjaWZpYyB0eXBlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQoKTogU3RydWN0PFNldDx1bmtub3duPiwgbnVsbD5cbmV4cG9ydCBmdW5jdGlvbiBzZXQ8VD4oRWxlbWVudDogU3RydWN0PFQ+KTogU3RydWN0PFNldDxUPiwgbnVsbD5cbmV4cG9ydCBmdW5jdGlvbiBzZXQ8VD4oRWxlbWVudD86IFN0cnVjdDxUPik6IGFueSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnc2V0JyxcbiAgICBzY2hlbWE6IG51bGwsXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChFbGVtZW50ICYmIHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgIHlpZWxkIFt2IGFzIHN0cmluZywgdiwgRWxlbWVudF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0ID8gbmV3IFNldCh2YWx1ZSkgOiB2YWx1ZVxuICAgIH0sXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFNldCB8fFxuICAgICAgICBgRXhwZWN0ZWQgYSBcXGBTZXRcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICAgIClcbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZygpOiBTdHJ1Y3Q8c3RyaW5nLCBudWxsPiB7XG4gIHJldHVybiBkZWZpbmUoJ3N0cmluZycsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICBgRXhwZWN0ZWQgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YFxuICAgIClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdHVwbGUgb2YgYSBzcGVjaWZpYyBsZW5ndGgsIGFuZCB0aGF0IGVhY2ggb2YgaXRzXG4gKiBlbGVtZW50cyBpcyBvZiBhIHNwZWNpZmljIHR5cGUuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEE+KFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBXT4pOiBTdHJ1Y3Q8W0FdLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEI+KFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCXT4pOiBTdHJ1Y3Q8W0EsIEJdLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEM+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQ10+XG4pOiBTdHJ1Y3Q8W0EsIEIsIENdLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQ+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRF0+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIERdLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEU+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRV0+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEVdLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEUsIEY+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRl0+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEUsIEZdLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEUsIEYsIEc+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgR10+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEUsIEYsIEddLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEg+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSF0+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEk+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSV0+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEldLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEo+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSl0+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEpdLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEs+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgS10+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEtdLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEw+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTF0+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIExdLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTCwgTV0+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE1dLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE4+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTCwgTSwgTl0+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE5dLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE4sIE8+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTCwgTSwgTiwgT10+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE4sIE9dLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE4sIE8sIFA+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTCwgTSwgTiwgTywgUF0+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE4sIE8sIFBdLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE4sIE8sIFAsIFE+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTCwgTSwgTiwgTywgUCwgUV0+XG4pOiBTdHJ1Y3Q8W0EsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE4sIE8sIFAsIFFdLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlKEVsZW1lbnRzOiBTdHJ1Y3Q8YW55PltdKTogYW55IHtcbiAgY29uc3QgTmV2ZXIgPSBuZXZlcigpXG5cbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICd0dXBsZScsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoRWxlbWVudHMubGVuZ3RoLCB2YWx1ZS5sZW5ndGgpXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHlpZWxkIFtpLCB2YWx1ZVtpXSwgRWxlbWVudHNbaV0gfHwgTmV2ZXJdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgYEV4cGVjdGVkIGFuIGFycmF5LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICAgIClcbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaGFzIGEgc2V0IG9mIGtub3duIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQgYW5kIHVudG91Y2hlZC4gVGhpcyBpcyBzaW1pbGFyIHRvXG4gKiBob3cgVHlwZVNjcmlwdCdzIHN0cnVjdHVyYWwgdHlwaW5nIHdvcmtzLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlPFMgZXh0ZW5kcyBPYmplY3RTY2hlbWE+KFxuICBzY2hlbWE6IFNcbik6IFN0cnVjdDxPYmplY3RUeXBlPFM+LCBTPiB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpXG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAndHlwZScsXG4gICAgc2NoZW1hLFxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgICAgeWllbGQgW2ssIHZhbHVlW2tdLCBzY2hlbWFba11dXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaXNPYmplY3QodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YFxuICAgICAgKVxuICAgIH0sXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIG9uZSBvZiBhIHNldCBvZiB0eXBlcy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdW5pb248QT4oU3RydWN0czogVHVwbGVTY2hlbWE8W0FdPik6IFN0cnVjdDxBLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uPEEsIEI+KFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCXT4pOiBTdHJ1Y3Q8QSB8IEIsIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gdW5pb248QSwgQiwgQz4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDXT5cbik6IFN0cnVjdDxBIHwgQiB8IEMsIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gdW5pb248QSwgQiwgQywgRD4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBEXT5cbik6IFN0cnVjdDxBIHwgQiB8IEMgfCBELCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uPEEsIEIsIEMsIEQsIEU+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRV0+XG4pOiBTdHJ1Y3Q8QSB8IEIgfCBDIHwgRCB8IEUsIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gdW5pb248QSwgQiwgQywgRCwgRSwgRj4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBELCBFLCBGXT5cbik6IFN0cnVjdDxBIHwgQiB8IEMgfCBEIHwgRSB8IEYsIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gdW5pb248QSwgQiwgQywgRCwgRSwgRiwgRz4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBELCBFLCBGLCBHXT5cbik6IFN0cnVjdDxBIHwgQiB8IEMgfCBEIHwgRSB8IEYgfCBHLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEg+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSF0+XG4pOiBTdHJ1Y3Q8QSB8IEIgfCBDIHwgRCB8IEUgfCBGIHwgRyB8IEgsIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gdW5pb248QSwgQiwgQywgRCwgRSwgRiwgRywgSCwgST4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJXT5cbik6IFN0cnVjdDxBIHwgQiB8IEMgfCBEIHwgRSB8IEYgfCBHIHwgSCB8IEksIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gdW5pb248QSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSj4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKXT5cbik6IFN0cnVjdDxBIHwgQiB8IEMgfCBEIHwgRSB8IEYgfCBHIHwgSCB8IEkgfCBKLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEs+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgS10+XG4pOiBTdHJ1Y3Q8QSB8IEIgfCBDIHwgRCB8IEUgfCBGIHwgRyB8IEggfCBJIHwgSiB8IEssIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gdW5pb248QSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTD4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKLCBLLCBMXT5cbik6IFN0cnVjdDxBIHwgQiB8IEMgfCBEIHwgRSB8IEYgfCBHIHwgSCB8IEkgfCBKIHwgSyB8IEwsIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gdW5pb248QSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTCwgTT4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKLCBLLCBMLCBNXT5cbik6IFN0cnVjdDxBIHwgQiB8IEMgfCBEIHwgRSB8IEYgfCBHIHwgSCB8IEkgfCBKIHwgSyB8IEwgfCBNLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE4+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTCwgTSwgTl0+XG4pOiBTdHJ1Y3Q8QSB8IEIgfCBDIHwgRCB8IEUgfCBGIHwgRyB8IEggfCBJIHwgSiB8IEsgfCBMIHwgTSB8IE4sIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gdW5pb248QSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTCwgTSwgTiwgTz4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKLCBLLCBMLCBNLCBOLCBPXT5cbik6IFN0cnVjdDxBIHwgQiB8IEMgfCBEIHwgRSB8IEYgfCBHIHwgSCB8IEkgfCBKIHwgSyB8IEwgfCBNIHwgTiB8IE8sIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gdW5pb248QSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTCwgTSwgTiwgTywgUD4oXG4gIFN0cnVjdHM6IFR1cGxlU2NoZW1hPFtBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKLCBLLCBMLCBNLCBOLCBPLCBQXT5cbik6IFN0cnVjdDxBIHwgQiB8IEMgfCBEIHwgRSB8IEYgfCBHIHwgSCB8IEkgfCBKIHwgSyB8IEwgfCBNIHwgTiB8IE8gfCBQLCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIEosIEssIEwsIE0sIE4sIE8sIFAsIFE+KFxuICBTdHJ1Y3RzOiBUdXBsZVNjaGVtYTxbQSwgQiwgQywgRCwgRSwgRiwgRywgSCwgSSwgSiwgSywgTCwgTSwgTiwgTywgUCwgUV0+XG4pOiBTdHJ1Y3Q8XG4gIEEgfCBCIHwgQyB8IEQgfCBFIHwgRiB8IEcgfCBIIHwgSSB8IEogfCBLIHwgTCB8IE0gfCBOIHwgTyB8IFAgfCBRLFxuICBudWxsXG4+XG5leHBvcnQgZnVuY3Rpb24gdW5pb24oU3RydWN0czogU3RydWN0PGFueT5bXSk6IGFueSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gU3RydWN0cy5tYXAoKHMpID0+IHMudHlwZSkuam9pbignIHwgJylcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICd1bmlvbicsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3QgZmlyc3RNYXRjaCA9XG4gICAgICAgIFN0cnVjdHMuZmluZCgocykgPT4ge1xuICAgICAgICAgIGNvbnN0IFtlXSA9IHMudmFsaWRhdGUodmFsdWUsIHsgY29lcmNlOiB0cnVlIH0pXG4gICAgICAgICAgcmV0dXJuICFlXG4gICAgICAgIH0pIHx8IHVua25vd24oKVxuICAgICAgcmV0dXJuIGZpcnN0TWF0Y2guY29lcmNlcih2YWx1ZSwgY3R4KVxuICAgIH0sXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IGZhaWx1cmVzID0gW11cblxuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgY29uc3QgWy4uLnR1cGxlc10gPSBydW4odmFsdWUsIFMsIGN0eClcbiAgICAgICAgY29uc3QgW2ZpcnN0XSA9IHR1cGxlc1xuXG4gICAgICAgIGlmICghZmlyc3RbMF0pIHtcbiAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtmYWlsdXJlXSBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmVzLnB1c2goZmFpbHVyZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYEV4cGVjdGVkIHRoZSB2YWx1ZSB0byBzYXRpc2Z5IGEgdW5pb24gb2YgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludChcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICApfWAsXG4gICAgICAgIC4uLmZhaWx1cmVzLFxuICAgICAgXVxuICAgIH0sXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLCB3aXRob3V0IHdpZGVuaW5nIGl0cyB0eXBlIHRvIGBhbnlgLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB1bmtub3duKCk6IFN0cnVjdDx1bmtub3duLCBudWxsPiB7XG4gIHJldHVybiBkZWZpbmUoJ3Vua25vd24nLCAoKSA9PiB0cnVlKVxufVxuIiwiaW1wb3J0IHsgU3RydWN0LCBpcywgQ29lcmNlciB9IGZyb20gJy4uL3N0cnVjdCdcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IHN0cmluZywgdW5rbm93biB9IGZyb20gJy4vdHlwZXMnXG5cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGNvZXJjaW9uIHN0ZXAgdG8gaXRzIGlucHV0LlxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gaW5wdXQgZGF0YSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgdG8gaW5jcmVhc2UgdGhlXG4gKiBsaWtlbGlob29kIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb27igJRmb3IgZXhhbXBsZSBmb3IgZGVmYXVsdCB2YWx1ZXMsIHBhcnNpbmdcbiAqIGRpZmZlcmVudCBmb3JtYXRzLCBldGMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZTxULCBTLCBDPihcbiAgc3RydWN0OiBTdHJ1Y3Q8VCwgUz4sXG4gIGNvbmRpdGlvbjogU3RydWN0PEMsIGFueT4sXG4gIGNvZXJjZXI6IENvZXJjZXI8Qz5cbik6IFN0cnVjdDxULCBTPiB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAuLi5zdHJ1Y3QsXG4gICAgY29lcmNlcjogKHZhbHVlLCBjdHgpID0+IHtcbiAgICAgIHJldHVybiBpcyh2YWx1ZSwgY29uZGl0aW9uKVxuICAgICAgICA/IHN0cnVjdC5jb2VyY2VyKGNvZXJjZXIodmFsdWUsIGN0eCksIGN0eClcbiAgICAgICAgOiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KVxuICAgIH0sXG4gIH0pXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byByZXBsYWNlIGB1bmRlZmluZWRgIHZhbHVlcyB3aXRoIGEgZGVmYXVsdC5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdGVkPFQsIFM+KFxuICBzdHJ1Y3Q6IFN0cnVjdDxULCBTPixcbiAgZmFsbGJhY2s6IGFueSxcbiAgb3B0aW9uczoge1xuICAgIHN0cmljdD86IGJvb2xlYW5cbiAgfSA9IHt9XG4pOiBTdHJ1Y3Q8VCwgUz4ge1xuICByZXR1cm4gY29lcmNlKHN0cnVjdCwgdW5rbm93bigpLCAoeCkgPT4ge1xuICAgIGNvbnN0IGYgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFjaygpIDogZmFsbGJhY2tcblxuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmXG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiBpc1BsYWluT2JqZWN0KHgpICYmIGlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgIGNvbnN0IHJldCA9IHsgLi4ueCB9XG4gICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlXG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGYpIHtcbiAgICAgICAgaWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXRba2V5XSA9IGZba2V5XVxuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB4XG4gIH0pXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyaW1tZWQ8VCwgUz4oc3RydWN0OiBTdHJ1Y3Q8VCwgUz4pOiBTdHJ1Y3Q8VCwgUz4ge1xuICByZXR1cm4gY29lcmNlKHN0cnVjdCwgc3RyaW5nKCksICh4KSA9PiB4LnRyaW0oKSlcbn1cbiIsImltcG9ydCB7IFN0cnVjdCwgUmVmaW5lciB9IGZyb20gJy4uL3N0cnVjdCdcbmltcG9ydCB7IHRvRmFpbHVyZXMgfSBmcm9tICcuLi91dGlscydcblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCwgb3Igc2V0IGlzIGVtcHR5LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eTxcbiAgVCBleHRlbmRzIHN0cmluZyB8IGFueVtdIHwgTWFwPGFueSwgYW55PiB8IFNldDxhbnk+LFxuICBTIGV4dGVuZHMgYW55XG4+KHN0cnVjdDogU3RydWN0PFQsIFM+KTogU3RydWN0PFQsIFM+IHtcbiAgY29uc3QgZXhwZWN0ZWQgPSBgRXhwZWN0ZWQgYW4gZW1wdHkgJHtzdHJ1Y3QudHlwZX1gXG5cbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdlbXB0eScsICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgY29uc3QgeyBzaXplIH0gPSB2YWx1ZVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgc2l6ZSA9PT0gMCB8fCBgJHtleHBlY3RlZH0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBcXGAke3NpemV9XFxgYFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gdmFsdWUgYXMgc3RyaW5nIHwgYW55W11cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGxlbmd0aCA9PT0gMCB8fFxuICAgICAgICBgJHtleHBlY3RlZH0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgbGVuZ3RoIG9mIFxcYCR7bGVuZ3RofVxcYGBcbiAgICAgIClcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4PFQgZXh0ZW5kcyBudW1iZXIgfCBEYXRlLCBTIGV4dGVuZHMgYW55PihcbiAgc3RydWN0OiBTdHJ1Y3Q8VCwgUz4sXG4gIHRocmVzaG9sZDogVCxcbiAgb3B0aW9uczoge1xuICAgIGV4Y2x1c2l2ZT86IGJvb2xlYW5cbiAgfSA9IHt9XG4pOiBTdHJ1Y3Q8VCwgUz4ge1xuICBjb25zdCB7IGV4Y2x1c2l2ZSB9ID0gb3B0aW9uc1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21heCcsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBleGNsdXNpdmVcbiAgICAgID8gdmFsdWUgPCB0aHJlc2hvbGRcbiAgICAgIDogdmFsdWUgPD0gdGhyZXNob2xkIHx8XG4gICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbGVzcyB0aGFuICR7XG4gICAgICAgICAgICBleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnXG4gICAgICAgICAgfSR7dGhyZXNob2xkfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBhYm92ZSBhIHRocmVzaG9sZC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWluPFQgZXh0ZW5kcyBudW1iZXIgfCBEYXRlLCBTIGV4dGVuZHMgYW55PihcbiAgc3RydWN0OiBTdHJ1Y3Q8VCwgUz4sXG4gIHRocmVzaG9sZDogVCxcbiAgb3B0aW9uczoge1xuICAgIGV4Y2x1c2l2ZT86IGJvb2xlYW5cbiAgfSA9IHt9XG4pOiBTdHJ1Y3Q8VCwgUz4ge1xuICBjb25zdCB7IGV4Y2x1c2l2ZSB9ID0gb3B0aW9uc1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21pbicsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBleGNsdXNpdmVcbiAgICAgID8gdmFsdWUgPiB0aHJlc2hvbGRcbiAgICAgIDogdmFsdWUgPj0gdGhyZXNob2xkIHx8XG4gICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gZ3JlYXRlciB0aGFuICR7XG4gICAgICAgICAgICBleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnXG4gICAgICAgICAgfSR7dGhyZXNob2xkfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgXG4gIH0pXG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nIG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdHRlcm48VCBleHRlbmRzIHN0cmluZywgUyBleHRlbmRzIGFueT4oXG4gIHN0cnVjdDogU3RydWN0PFQsIFM+LFxuICByZWdleHA6IFJlZ0V4cFxuKTogU3RydWN0PFQsIFM+IHtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdwYXR0ZXJuJywgKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHJlZ2V4cC50ZXN0KHZhbHVlKSB8fFxuICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbWF0Y2hpbmcgXFxgLyR7cmVnZXhwLnNvdXJjZX0vXFxgIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCJgXG4gICAgKVxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbnVtYmVyLCBkYXRlLCBtYXAsIG9yIHNldCBoYXMgYSBzaXplIChvciBsZW5ndGgsIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzaXplPFxuICBUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgRGF0ZSB8IGFueVtdIHwgTWFwPGFueSwgYW55PiB8IFNldDxhbnk+LFxuICBTIGV4dGVuZHMgYW55XG4+KHN0cnVjdDogU3RydWN0PFQsIFM+LCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIgPSBtaW4pOiBTdHJ1Y3Q8VCwgUz4ge1xuICBjb25zdCBleHBlY3RlZCA9IGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9YFxuICBjb25zdCBvZiA9IG1pbiA9PT0gbWF4ID8gYG9mIFxcYCR7bWlufVxcYGAgOiBgYmV0d2VlbiBcXGAke21pbn1cXGAgYW5kIFxcYCR7bWF4fVxcYGBcblxuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3NpemUnLCAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4KSB8fFxuICAgICAgICBgJHtleHBlY3RlZH0gJHtvZn0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIGNvbnN0IHsgc2l6ZSB9ID0gdmFsdWVcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChtaW4gPD0gc2l6ZSAmJiBzaXplIDw9IG1heCkgfHxcbiAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBzaXplICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHZhbHVlIGFzIHN0cmluZyB8IGFueVtdXG4gICAgICByZXR1cm4gKFxuICAgICAgICAobWluIDw9IGxlbmd0aCAmJiBsZW5ndGggPD0gbWF4KSB8fFxuICAgICAgICBgJHtleHBlY3RlZH0gd2l0aCBhIGxlbmd0aCAke29mfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBsZW5ndGggb2YgXFxgJHtsZW5ndGh9XFxgYFxuICAgICAgKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgcmVmaW5lbWVudCB0byB0aGUgdmFsaWRhdGlvbi5cbiAqXG4gKiBUaGUgcmVmaW5lciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJlY2VpdmUgYSB2YWx1ZSBvZiB0aGUgc3RydWN0J3MgdHlwZSxcbiAqIGJlY2F1c2UgdGhlIHN0cnVjdCdzIGV4aXN0aW5nIHZhbGlkYXRpb24gd2lsbCBhbHJlYWR5IGhhdmUgcGFzc2VkLiBUaGlzXG4gKiBhbGxvd3MgeW91IHRvIGxheWVyIGFkZGl0aW9uYWwgdmFsaWRhdGlvbiBvbiB0b3Agb2YgZXhpc3Rpbmcgc3RydWN0cy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVmaW5lPFQsIFM+KFxuICBzdHJ1Y3Q6IFN0cnVjdDxULCBTPixcbiAgbmFtZTogc3RyaW5nLFxuICByZWZpbmVyOiBSZWZpbmVyPFQ+XG4pOiBTdHJ1Y3Q8VCwgUz4ge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgLi4uc3RydWN0LFxuICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHlpZWxkKiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KVxuICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY3R4KVxuICAgICAgY29uc3QgZmFpbHVyZXMgPSB0b0ZhaWx1cmVzKHJlc3VsdCwgY3R4LCBzdHJ1Y3QsIHZhbHVlKVxuXG4gICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgeWllbGQgeyAuLi5mYWlsdXJlLCByZWZpbmVtZW50OiBuYW1lIH1cbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/superstruct/lib/index.es.js\n");

/***/ })

}]);