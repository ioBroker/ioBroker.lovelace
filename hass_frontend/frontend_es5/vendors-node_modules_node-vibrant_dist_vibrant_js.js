/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_node-vibrant_dist_vibrant_js"],{

/***/ "./node_modules/node-vibrant/dist/vibrant.js":
/*!***************************************************!*\
  !*** ./node_modules/node-vibrant/dist/vibrant.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = (__webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (( false ? 0 : _typeof(exports)) === 'object' && ( false ? 0 : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(window, function () {\n  return (/******/function (modules) {\n      // webpackBootstrap\n      /******/ // The module cache\n      /******/\n      var installedModules = {};\n      /******/\n      /******/ // The require function\n      /******/\n      function __nested_webpack_require_792__(moduleId) {\n        /******/\n        /******/ // Check if module is in cache\n        /******/if (installedModules[moduleId]) {\n          /******/return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = installedModules[moduleId] = {\n          /******/i: moduleId,\n          /******/l: false,\n          /******/exports: {}\n          /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_792__);\n        /******/\n        /******/ // Flag the module as loaded\n        /******/\n        module.l = true;\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n      }\n      /******/\n      /******/\n      /******/ // expose the modules object (__webpack_modules__)\n      /******/\n      __nested_webpack_require_792__.m = modules;\n      /******/\n      /******/ // expose the module cache\n      /******/\n      __nested_webpack_require_792__.c = installedModules;\n      /******/\n      /******/ // define getter function for harmony exports\n      /******/\n      __nested_webpack_require_792__.d = function (exports, name, getter) {\n        /******/if (!__nested_webpack_require_792__.o(exports, name)) {\n          /******/Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n      };\n      /******/\n      /******/ // define __esModule on exports\n      /******/\n      __nested_webpack_require_792__.r = function (exports) {\n        /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n      /******/ // create a fake namespace object\n      /******/ // mode & 1: value is a module id, require it\n      /******/ // mode & 2: merge all properties of value into the ns\n      /******/ // mode & 4: return value when already ns object\n      /******/ // mode & 8|1: behave like require\n      /******/\n      __nested_webpack_require_792__.t = function (value, mode) {\n        /******/if (mode & 1) value = __nested_webpack_require_792__(value);\n        /******/\n        if (mode & 8) return value;\n        /******/\n        if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;\n        /******/\n        var ns = Object.create(null);\n        /******/\n        __nested_webpack_require_792__.r(ns);\n        /******/\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n        if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_792__.d(ns, key, function (key) {\n          return value[key];\n        }.bind(null, key));\n        /******/\n        return ns;\n        /******/\n      };\n      /******/\n      /******/ // getDefaultExport function for compatibility with non-harmony modules\n      /******/\n      __nested_webpack_require_792__.n = function (module) {\n        /******/var getter = module && module.__esModule ? /******/function getDefault() {\n          return module['default'];\n        } : /******/function getModuleExports() {\n          return module;\n        };\n        /******/\n        __nested_webpack_require_792__.d(getter, 'a', getter);\n        /******/\n        return getter;\n        /******/\n      };\n      /******/\n      /******/ // Object.prototype.hasOwnProperty.call\n      /******/\n      __nested_webpack_require_792__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n      /******/ // __webpack_public_path__\n      /******/\n      __nested_webpack_require_792__.p = \"\";\n      /******/\n      /******/\n      /******/ // Load entry module and return exports\n      /******/\n      return __nested_webpack_require_792__(__nested_webpack_require_792__.s = 10);\n      /******/\n    }\n    /************************************************************************/\n    /******/([/* 0 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.assignDeep = exports.mapValues = void 0;\n      function mapValues(o, mapper) {\n        var result = {};\n        for (var key in o) {\n          if (o.hasOwnProperty(key)) {\n            var v = o[key];\n            result[key] = mapper(v);\n          }\n        }\n        return result;\n      }\n      exports.mapValues = mapValues;\n      /**\n       * Overwrite values or properties on objects and lists recursively.\n       * A shallow copy will be created for each array value.\n       */\n      function assignDeep(target) {\n        var sources = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n          sources[_i - 1] = arguments[_i];\n        }\n        sources.forEach(function (s) {\n          if (!s) return;\n          for (var key in s) {\n            if (s.hasOwnProperty(key)) {\n              var v = s[key];\n              if (Array.isArray(v)) {\n                // Shallow copy\n                target[key] = v.slice(0);\n              } else if (_typeof(v) === 'object') {\n                if (!target[key]) target[key] = {};\n                assignDeep(target[key], v);\n              } else {\n                target[key] = v;\n              }\n            }\n          }\n        });\n        return target;\n      }\n      exports.assignDeep = assignDeep;\n\n      /***/\n    }, /* 1 */\n    /***/function (module, exports, __nested_webpack_require_6595__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var options_1 = __nested_webpack_require_6595__(7);\n      var builder_1 = __importDefault(__nested_webpack_require_6595__(8));\n      var utils_1 = __nested_webpack_require_6595__(0);\n      var Vibrant = /** @class */function () {\n        function Vibrant(_src, opts) {\n          this._src = _src;\n          this.opts = utils_1.assignDeep({}, Vibrant.DefaultOpts, opts);\n        }\n        Vibrant.use = function (pipeline) {\n          this._pipeline = pipeline;\n        };\n        Vibrant.from = function (src) {\n          return new builder_1.default(src);\n        };\n        Object.defineProperty(Vibrant.prototype, \"result\", {\n          get: function get() {\n            return this._result;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Vibrant.prototype._process = function (image, opts) {\n          var quantizer = this.opts.quantizer;\n          image.scaleDown(this.opts);\n          var processOpts = options_1.buildProcessOptions(this.opts, opts);\n          return Vibrant._pipeline.process(image.getImageData(), processOpts);\n        };\n        Vibrant.prototype.palette = function () {\n          return this.swatches();\n        };\n        Vibrant.prototype.swatches = function () {\n          throw new Error('Method deprecated. Use `Vibrant.result.palettes[name]` instead');\n        };\n        Vibrant.prototype.getPalette = function () {\n          var _this = this;\n          var arg0 = arguments[0];\n          var arg1 = arguments[1];\n          var name = typeof arg0 === 'string' ? arg0 : 'default';\n          var cb = typeof arg0 === 'string' ? arg1 : arg0;\n          var image = new this.opts.ImageClass();\n          return image.load(this._src).then(function (image) {\n            return _this._process(image, {\n              generators: [name]\n            });\n          }).then(function (result) {\n            _this._result = result;\n            return result.palettes[name];\n          }).then(function (res) {\n            image.remove();\n            if (cb) {\n              cb(undefined, res);\n            }\n            return res;\n          }).catch(function (err) {\n            image.remove();\n            if (cb) {\n              cb(err);\n            }\n            return Promise.reject(err);\n          });\n        };\n        Vibrant.prototype.getPalettes = function () {\n          var _this = this;\n          var arg0 = arguments[0];\n          var arg1 = arguments[1];\n          var names = Array.isArray(arg0) ? arg0 : ['*'];\n          var cb = Array.isArray(arg0) ? arg1 : arg0;\n          var image = new this.opts.ImageClass();\n          return image.load(this._src).then(function (image) {\n            return _this._process(image, {\n              generators: names\n            });\n          }).then(function (result) {\n            _this._result = result;\n            return result.palettes;\n          }).then(function (res) {\n            image.remove();\n            if (cb) {\n              cb(undefined, res);\n            }\n            return res;\n          }).catch(function (err) {\n            image.remove();\n            if (cb) {\n              cb(err);\n            }\n            return Promise.reject(err);\n          });\n        };\n        Vibrant.DefaultOpts = {\n          colorCount: 64,\n          quality: 5,\n          filters: []\n        };\n        return Vibrant;\n      }();\n      exports.default = Vibrant;\n\n      /***/\n    }, /* 2 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.applyFilters = exports.ImageBase = void 0;\n      var ImageBase = /** @class */function () {\n        function ImageBase() {}\n        ImageBase.prototype.scaleDown = function (opts) {\n          var width = this.getWidth();\n          var height = this.getHeight();\n          var ratio = 1;\n          if (opts.maxDimension > 0) {\n            var maxSide = Math.max(width, height);\n            if (maxSide > opts.maxDimension) ratio = opts.maxDimension / maxSide;\n          } else {\n            ratio = 1 / opts.quality;\n          }\n          if (ratio < 1) this.resize(width * ratio, height * ratio, ratio);\n        };\n        return ImageBase;\n      }();\n      exports.ImageBase = ImageBase;\n      function applyFilters(imageData, filters) {\n        if (filters.length > 0) {\n          var pixels = imageData.data;\n          var n = pixels.length / 4;\n          var offset = void 0;\n          var r = void 0;\n          var g = void 0;\n          var b = void 0;\n          var a = void 0;\n          for (var i = 0; i < n; i++) {\n            offset = i * 4;\n            r = pixels[offset + 0];\n            g = pixels[offset + 1];\n            b = pixels[offset + 2];\n            a = pixels[offset + 3];\n            // Mark ignored color\n            for (var j = 0; j < filters.length; j++) {\n              if (!filters[j](r, g, b, a)) {\n                pixels[offset + 3] = 0;\n                break;\n              }\n            }\n          }\n        }\n        return imageData;\n      }\n      exports.applyFilters = applyFilters;\n\n      /***/\n    }, /* 3 */\n    /***/function (module, exports, __nested_webpack_require_12038__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.Swatch = void 0;\n      var converter_1 = __nested_webpack_require_12038__(4);\n      var Swatch = /** @class */function () {\n        function Swatch(rgb, population) {\n          this._rgb = rgb;\n          this._population = population;\n        }\n        Swatch.applyFilters = function (colors, filters) {\n          return filters.length > 0 ? colors.filter(function (_a) {\n            var r = _a.r,\n              g = _a.g,\n              b = _a.b;\n            for (var j = 0; j < filters.length; j++) {\n              if (!filters[j](r, g, b, 255)) return false;\n            }\n            return true;\n          }) : colors;\n        };\n        /**\n         * Make a value copy of a swatch based on a previous one. Returns a new Swatch instance\n         * @param {Swatch} swatch\n         */\n        Swatch.clone = function (swatch) {\n          return new Swatch(swatch._rgb, swatch._population);\n        };\n        Object.defineProperty(Swatch.prototype, \"r\", {\n          /**\n           * The red value in the RGB value\n           */\n          get: function get() {\n            return this._rgb[0];\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"g\", {\n          /**\n           * The green value in the RGB value\n           */\n          get: function get() {\n            return this._rgb[1];\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"b\", {\n          /**\n           * The blue value in the RGB value\n           */\n          get: function get() {\n            return this._rgb[2];\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"rgb\", {\n          /**\n           * The color value as a rgb value\n           */\n          get: function get() {\n            return this._rgb;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"hsl\", {\n          /**\n           * The color value as a hsl value\n           */\n          get: function get() {\n            if (!this._hsl) {\n              var _a = this._rgb,\n                r = _a[0],\n                g = _a[1],\n                b = _a[2];\n              this._hsl = converter_1.rgbToHsl(r, g, b);\n            }\n            return this._hsl;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"hex\", {\n          /**\n           * The color value as a hex string\n           */\n          get: function get() {\n            if (!this._hex) {\n              var _a = this._rgb,\n                r = _a[0],\n                g = _a[1],\n                b = _a[2];\n              this._hex = converter_1.rgbToHex(r, g, b);\n            }\n            return this._hex;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"population\", {\n          get: function get() {\n            return this._population;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        /**\n         * Get the JSON object for the swatch\n         */\n        Swatch.prototype.toJSON = function () {\n          return {\n            rgb: this.rgb,\n            population: this.population\n          };\n        };\n        /**\n         * Get the color value as a rgb value\n         * @deprecated Use property instead\n         */\n        // TODO: deprecate internally, use property instead\n        Swatch.prototype.getRgb = function () {\n          return this._rgb;\n        };\n        /**\n         * Get the color value as a hsl value\n         * @deprecated Use property instead\n         */\n        // TODO: deprecate internally, use property instead\n        Swatch.prototype.getHsl = function () {\n          return this.hsl;\n        };\n        /**\n         * @deprecated Use property instead\n         */\n        // TODO: deprecate internally, use property instead\n        Swatch.prototype.getPopulation = function () {\n          return this._population;\n        };\n        /**\n         * Get the color value as a hex string\n         * @deprecated Use property instead\n         */\n        // TODO: deprecate internally, use property instead\n        Swatch.prototype.getHex = function () {\n          return this.hex;\n        };\n        Swatch.prototype.getYiq = function () {\n          if (!this._yiq) {\n            var rgb = this._rgb;\n            this._yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n          }\n          return this._yiq;\n        };\n        Object.defineProperty(Swatch.prototype, \"titleTextColor\", {\n          get: function get() {\n            if (this._titleTextColor) {\n              this._titleTextColor = this.getYiq() < 200 ? '#fff' : '#000';\n            }\n            return this._titleTextColor;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"bodyTextColor\", {\n          get: function get() {\n            if (this._bodyTextColor) {\n              this._bodyTextColor = this.getYiq() < 150 ? '#fff' : '#000';\n            }\n            return this._bodyTextColor;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Swatch.prototype.getTitleTextColor = function () {\n          return this.titleTextColor;\n        };\n        Swatch.prototype.getBodyTextColor = function () {\n          return this.bodyTextColor;\n        };\n        return Swatch;\n      }();\n      exports.Swatch = Swatch;\n\n      /***/\n    }, /* 4 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.getColorDiffStatus = exports.hexDiff = exports.rgbDiff = exports.deltaE94 = exports.rgbToCIELab = exports.xyzToCIELab = exports.rgbToXyz = exports.hslToRgb = exports.rgbToHsl = exports.rgbToHex = exports.hexToRgb = exports.DELTAE94_DIFF_STATUS = void 0;\n      exports.DELTAE94_DIFF_STATUS = {\n        NA: 0,\n        PERFECT: 1,\n        CLOSE: 2,\n        GOOD: 10,\n        SIMILAR: 50\n      };\n      /**\n       * Converts hex string to RGB\n       * @param hex - The hex value you with to get the RGB value of\n       * @returns an array in the order of `red, green, blue` numerical values\n       */\n      function hexToRgb(hex) {\n        var m = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        if (!m) throw new RangeError(\"'\" + hex + \"' is not a valid hex color\");\n        return [m[1], m[2], m[3]].map(function (s) {\n          return parseInt(s, 16);\n        });\n      }\n      exports.hexToRgb = hexToRgb;\n      /**\n       * Given values for an RGB color convert to and return a valid HEX string\n       * @param r - Red value in RGB\n       * @param g - Green value in RGB\n       * @param b - Blue value in RGB\n       * @returns a valid hex string with pre-pending pound sign\n       */\n      function rgbToHex(r, g, b) {\n        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);\n      }\n      exports.rgbToHex = rgbToHex;\n      /**\n       * Given values for an RGB color convert to and return a valid HSL value\n       * @param r - Red value in RGB\n       * @param g - Green value in RGB\n       * @param b - Blue value in RGB\n       * @returns an array in the order of `hue, saturation, light` numerical values\n       */\n      function rgbToHsl(r, g, b) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var h = 0;\n        var s = 0;\n        var l = (max + min) / 2;\n        if (max !== min) {\n          var d = max - min;\n          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n          switch (max) {\n            case r:\n              h = (g - b) / d + (g < b ? 6 : 0);\n              break;\n            case g:\n              h = (b - r) / d + 2;\n              break;\n            case b:\n              h = (r - g) / d + 4;\n              break;\n          }\n          h /= 6;\n        }\n        return [h, s, l];\n      }\n      exports.rgbToHsl = rgbToHsl;\n      function hslToRgb(h, s, l) {\n        var r;\n        var g;\n        var b;\n        function hue2rgb(p, q, t) {\n          if (t < 0) t += 1;\n          if (t > 1) t -= 1;\n          if (t < 1 / 6) return p + (q - p) * 6 * t;\n          if (t < 1 / 2) return q;\n          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n          return p;\n        }\n        if (s === 0) {\n          r = g = b = l;\n        } else {\n          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n          var p = 2 * l - q;\n          r = hue2rgb(p, q, h + 1 / 3);\n          g = hue2rgb(p, q, h);\n          b = hue2rgb(p, q, h - 1 / 3);\n        }\n        return [r * 255, g * 255, b * 255];\n      }\n      exports.hslToRgb = hslToRgb;\n      function rgbToXyz(r, g, b) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        r = r > 0.04045 ? Math.pow((r + 0.005) / 1.055, 2.4) : r / 12.92;\n        g = g > 0.04045 ? Math.pow((g + 0.005) / 1.055, 2.4) : g / 12.92;\n        b = b > 0.04045 ? Math.pow((b + 0.005) / 1.055, 2.4) : b / 12.92;\n        r *= 100;\n        g *= 100;\n        b *= 100;\n        var x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n        var y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n        var z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n        return [x, y, z];\n      }\n      exports.rgbToXyz = rgbToXyz;\n      function xyzToCIELab(x, y, z) {\n        var REF_X = 95.047;\n        var REF_Y = 100;\n        var REF_Z = 108.883;\n        x /= REF_X;\n        y /= REF_Y;\n        z /= REF_Z;\n        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n        var L = 116 * y - 16;\n        var a = 500 * (x - y);\n        var b = 200 * (y - z);\n        return [L, a, b];\n      }\n      exports.xyzToCIELab = xyzToCIELab;\n      function rgbToCIELab(r, g, b) {\n        var _a = rgbToXyz(r, g, b),\n          x = _a[0],\n          y = _a[1],\n          z = _a[2];\n        return xyzToCIELab(x, y, z);\n      }\n      exports.rgbToCIELab = rgbToCIELab;\n      function deltaE94(lab1, lab2) {\n        var WEIGHT_L = 1;\n        var WEIGHT_C = 1;\n        var WEIGHT_H = 1;\n        var L1 = lab1[0],\n          a1 = lab1[1],\n          b1 = lab1[2];\n        var L2 = lab2[0],\n          a2 = lab2[1],\n          b2 = lab2[2];\n        var dL = L1 - L2;\n        var da = a1 - a2;\n        var db = b1 - b2;\n        var xC1 = Math.sqrt(a1 * a1 + b1 * b1);\n        var xC2 = Math.sqrt(a2 * a2 + b2 * b2);\n        var xDL = L2 - L1;\n        var xDC = xC2 - xC1;\n        var xDE = Math.sqrt(dL * dL + da * da + db * db);\n        var xDH = Math.sqrt(xDE) > Math.sqrt(Math.abs(xDL)) + Math.sqrt(Math.abs(xDC)) ? Math.sqrt(xDE * xDE - xDL * xDL - xDC * xDC) : 0;\n        var xSC = 1 + 0.045 * xC1;\n        var xSH = 1 + 0.015 * xC1;\n        xDL /= WEIGHT_L;\n        xDC /= WEIGHT_C * xSC;\n        xDH /= WEIGHT_H * xSH;\n        return Math.sqrt(xDL * xDL + xDC * xDC + xDH * xDH);\n      }\n      exports.deltaE94 = deltaE94;\n      function rgbDiff(rgb1, rgb2) {\n        var lab1 = rgbToCIELab.apply(undefined, rgb1);\n        var lab2 = rgbToCIELab.apply(undefined, rgb2);\n        return deltaE94(lab1, lab2);\n      }\n      exports.rgbDiff = rgbDiff;\n      function hexDiff(hex1, hex2) {\n        var rgb1 = hexToRgb(hex1);\n        var rgb2 = hexToRgb(hex2);\n        return rgbDiff(rgb1, rgb2);\n      }\n      exports.hexDiff = hexDiff;\n      function getColorDiffStatus(d) {\n        if (d < exports.DELTAE94_DIFF_STATUS.NA) {\n          return 'N/A';\n        }\n        // Not perceptible by human eyes\n        if (d <= exports.DELTAE94_DIFF_STATUS.PERFECT) {\n          return 'Perfect';\n        }\n        // Perceptible through close observation\n        if (d <= exports.DELTAE94_DIFF_STATUS.CLOSE) {\n          return 'Close';\n        }\n        // Perceptible at a glance\n        if (d <= exports.DELTAE94_DIFF_STATUS.GOOD) {\n          return 'Good';\n        }\n        // Colors are more similar than opposite\n        if (d < exports.DELTAE94_DIFF_STATUS.SIMILAR) {\n          return 'Similar';\n        }\n        return 'Wrong';\n      }\n      exports.getColorDiffStatus = getColorDiffStatus;\n\n      /***/\n    }, /* 5 */\n    /***/function (module, exports, __nested_webpack_require_24693__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      var config_1 = __importDefault(__nested_webpack_require_24693__(6));\n      var image_browser_1 = __importDefault(__nested_webpack_require_24693__(9));\n      config_1.default.DefaultOpts.ImageClass = image_browser_1.default;\n      module.exports = config_1.default;\n\n      /***/\n    }, /* 6 */\n    /***/function (module, exports, __nested_webpack_require_25215__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var core_1 = __importDefault(__nested_webpack_require_25215__(1));\n      core_1.default.DefaultOpts.quantizer = 'mmcq';\n      core_1.default.DefaultOpts.generators = ['default'];\n      core_1.default.DefaultOpts.filters = ['default'];\n      exports.default = core_1.default;\n\n      /***/\n    }, /* 7 */\n    /***/function (module, exports, __nested_webpack_require_25843__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.buildProcessOptions = void 0;\n      var utils_1 = __nested_webpack_require_25843__(0);\n      function buildProcessOptions(opts, override) {\n        var colorCount = opts.colorCount,\n          quantizer = opts.quantizer,\n          generators = opts.generators,\n          filters = opts.filters;\n        // Merge with common quantizer options\n        var commonQuantizerOpts = {\n          colorCount: colorCount\n        };\n        var q = typeof quantizer === 'string' ? {\n          name: quantizer,\n          options: {}\n        } : quantizer;\n        q.options = utils_1.assignDeep({}, commonQuantizerOpts, q.options);\n        return utils_1.assignDeep({}, {\n          quantizer: q,\n          generators: generators,\n          filters: filters\n        }, override);\n      }\n      exports.buildProcessOptions = buildProcessOptions;\n\n      /***/\n    }, /* 8 */\n    /***/function (module, exports, __nested_webpack_require_26866__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var _1 = __importDefault(__nested_webpack_require_26866__(1));\n      var utils_1 = __nested_webpack_require_26866__(0);\n      var Builder = /** @class */function () {\n        function Builder(src, opts) {\n          if (opts === void 0) {\n            opts = {};\n          }\n          this._src = src;\n          this._opts = utils_1.assignDeep({}, _1.default.DefaultOpts, opts);\n        }\n        Builder.prototype.maxColorCount = function (n) {\n          this._opts.colorCount = n;\n          return this;\n        };\n        Builder.prototype.maxDimension = function (d) {\n          this._opts.maxDimension = d;\n          return this;\n        };\n        Builder.prototype.addFilter = function (name) {\n          if (!this._opts.filters) {\n            this._opts.filters = [name];\n          } else {\n            this._opts.filters.push(name);\n          }\n          return this;\n        };\n        Builder.prototype.removeFilter = function (name) {\n          if (this._opts.filters) {\n            var i = this._opts.filters.indexOf(name);\n            if (i > 0) this._opts.filters.splice(i);\n          }\n          return this;\n        };\n        Builder.prototype.clearFilters = function () {\n          this._opts.filters = [];\n          return this;\n        };\n        Builder.prototype.quality = function (q) {\n          this._opts.quality = q;\n          return this;\n        };\n        Builder.prototype.useImageClass = function (imageClass) {\n          this._opts.ImageClass = imageClass;\n          return this;\n        };\n        Builder.prototype.useGenerator = function (generator, options) {\n          if (!this._opts.generators) this._opts.generators = [];\n          this._opts.generators.push(options ? {\n            name: generator,\n            options: options\n          } : generator);\n          return this;\n        };\n        Builder.prototype.useQuantizer = function (quantizer, options) {\n          this._opts.quantizer = options ? {\n            name: quantizer,\n            options: options\n          } : quantizer;\n          return this;\n        };\n        Builder.prototype.build = function () {\n          return new _1.default(this._src, this._opts);\n        };\n        Builder.prototype.getPalette = function (cb) {\n          return this.build().getPalette(cb);\n        };\n        Builder.prototype.getSwatches = function (cb) {\n          return this.build().getPalette(cb);\n        };\n        return Builder;\n      }();\n      exports.default = Builder;\n\n      /***/\n    }, /* 9 */\n    /***/function (module, exports, __nested_webpack_require_29678__) {\n      \"use strict\";\n\n      var __extends = this && this.__extends || function () {\n        var _extendStatics = function extendStatics(d, b) {\n          _extendStatics = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (d, b) {\n            d.__proto__ = b;\n          } || function (d, b) {\n            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n          };\n          return _extendStatics(d, b);\n        };\n        return function (d, b) {\n          _extendStatics(d, b);\n          function __() {\n            this.constructor = d;\n          }\n          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n      }();\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var image_1 = __nested_webpack_require_29678__(2);\n      function isRelativeUrl(url) {\n        var u = new URL(url, location.href);\n        return u.protocol === location.protocol && u.host === location.host && u.port === location.port;\n      }\n      function isSameOrigin(a, b) {\n        var ua = new URL(a);\n        var ub = new URL(b);\n        // https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\n        return ua.protocol === ub.protocol && ua.hostname === ub.hostname && ua.port === ub.port;\n      }\n      var BrowserImage = /** @class */function (_super) {\n        __extends(BrowserImage, _super);\n        function BrowserImage() {\n          return _super !== null && _super.apply(this, arguments) || this;\n        }\n        BrowserImage.prototype._initCanvas = function () {\n          var img = this.image;\n          var canvas = this._canvas = document.createElement('canvas');\n          var context = canvas.getContext('2d');\n          if (!context) throw new ReferenceError('Failed to create canvas context');\n          this._context = context;\n          canvas.className = '@vibrant/canvas';\n          canvas.style.display = 'none';\n          this._width = canvas.width = img.width;\n          this._height = canvas.height = img.height;\n          context.drawImage(img, 0, 0);\n          document.body.appendChild(canvas);\n        };\n        BrowserImage.prototype.load = function (image) {\n          var _this = this;\n          var img;\n          var src;\n          if (typeof image === 'string') {\n            img = document.createElement('img');\n            src = image;\n            if (!isRelativeUrl(src) && !isSameOrigin(window.location.href, src)) {\n              img.crossOrigin = 'anonymous';\n            }\n            img.src = src;\n          } else if (image instanceof HTMLImageElement) {\n            img = image;\n            src = image.src;\n          } else {\n            return Promise.reject(new Error(\"Cannot load buffer as an image in browser\"));\n          }\n          this.image = img;\n          return new Promise(function (resolve, reject) {\n            var onImageLoad = function onImageLoad() {\n              _this._initCanvas();\n              resolve(_this);\n            };\n            if (img.complete) {\n              // Already loaded\n              onImageLoad();\n            } else {\n              img.onload = onImageLoad;\n              img.onerror = function (e) {\n                return reject(new Error(\"Fail to load image: \" + src));\n              };\n            }\n          });\n        };\n        BrowserImage.prototype.clear = function () {\n          this._context.clearRect(0, 0, this._width, this._height);\n        };\n        BrowserImage.prototype.update = function (imageData) {\n          this._context.putImageData(imageData, 0, 0);\n        };\n        BrowserImage.prototype.getWidth = function () {\n          return this._width;\n        };\n        BrowserImage.prototype.getHeight = function () {\n          return this._height;\n        };\n        BrowserImage.prototype.resize = function (targetWidth, targetHeight, ratio) {\n          var _a = this,\n            canvas = _a._canvas,\n            context = _a._context,\n            img = _a.image;\n          this._width = canvas.width = targetWidth;\n          this._height = canvas.height = targetHeight;\n          context.scale(ratio, ratio);\n          context.drawImage(img, 0, 0);\n        };\n        BrowserImage.prototype.getPixelCount = function () {\n          return this._width * this._height;\n        };\n        BrowserImage.prototype.getImageData = function () {\n          return this._context.getImageData(0, 0, this._width, this._height);\n        };\n        BrowserImage.prototype.remove = function () {\n          if (this._canvas && this._canvas.parentNode) {\n            this._canvas.parentNode.removeChild(this._canvas);\n          }\n        };\n        return BrowserImage;\n      }(image_1.ImageBase);\n      exports.default = BrowserImage;\n\n      /***/\n    }, /* 10 */\n    /***/function (module, exports, __nested_webpack_require_34537__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      var Vibrant = __nested_webpack_require_34537__(5);\n      var pipeline_1 = __importDefault(__nested_webpack_require_34537__(11));\n      Vibrant.use(pipeline_1.default);\n      module.exports = Vibrant;\n\n      /***/\n    }, /* 11 */\n    /***/function (module, exports, __nested_webpack_require_34995__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var quantizer_mmcq_1 = __importDefault(__nested_webpack_require_34995__(12));\n      var generator_default_1 = __importDefault(__nested_webpack_require_34995__(16));\n      var pipeline_1 = __nested_webpack_require_34995__(17);\n      var pipeline = new pipeline_1.BasicPipeline().filter.register('default', function (r, g, b, a) {\n        return a >= 125 && !(r > 250 && g > 250 && b > 250);\n      }).quantizer.register('mmcq', quantizer_mmcq_1.default).generator.register('default', generator_default_1.default);\n      exports.default = pipeline;\n\n      /***/\n    }, /* 12 */\n    /***/function (module, exports, __nested_webpack_require_35869__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var color_1 = __nested_webpack_require_35869__(3);\n      var vbox_1 = __importDefault(__nested_webpack_require_35869__(13));\n      var pqueue_1 = __importDefault(__nested_webpack_require_35869__(15));\n      var fractByPopulations = 0.75;\n      function _splitBoxes(pq, target) {\n        var lastSize = pq.size();\n        while (pq.size() < target) {\n          var vbox = pq.pop();\n          if (vbox && vbox.count() > 0) {\n            var _a = vbox.split(),\n              vbox1 = _a[0],\n              vbox2 = _a[1];\n            pq.push(vbox1);\n            if (vbox2 && vbox2.count() > 0) pq.push(vbox2);\n            // No more new boxes, converged\n            if (pq.size() === lastSize) {\n              break;\n            } else {\n              lastSize = pq.size();\n            }\n          } else {\n            break;\n          }\n        }\n      }\n      var MMCQ = function MMCQ(pixels, opts) {\n        if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n          throw new Error('Wrong MMCQ parameters');\n        }\n        var vbox = vbox_1.default.build(pixels);\n        var colorCount = vbox.histogram.colorCount;\n        var pq = new pqueue_1.default(function (a, b) {\n          return a.count() - b.count();\n        });\n        pq.push(vbox);\n        // first set of colors, sorted by population\n        _splitBoxes(pq, fractByPopulations * opts.colorCount);\n        // Re-order\n        var pq2 = new pqueue_1.default(function (a, b) {\n          return a.count() * a.volume() - b.count() * b.volume();\n        });\n        pq2.contents = pq.contents;\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        _splitBoxes(pq2, opts.colorCount - pq2.size());\n        // calculate the actual colors\n        return generateSwatches(pq2);\n      };\n      function generateSwatches(pq) {\n        var swatches = [];\n        while (pq.size()) {\n          var v = pq.pop();\n          var color = v.avg();\n          var r = color[0],\n            g = color[1],\n            b = color[2];\n          swatches.push(new color_1.Swatch(color, v.count()));\n        }\n        return swatches;\n      }\n      exports.default = MMCQ;\n\n      /***/\n    }, /* 13 */\n    /***/function (module, exports, __nested_webpack_require_38367__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var histogram_1 = __importDefault(__nested_webpack_require_38367__(14));\n      var SIGBITS = 5;\n      var RSHIFT = 8 - SIGBITS;\n      var VBox = /** @class */function () {\n        function VBox(r1, r2, g1, g2, b1, b2, histogram) {\n          this.histogram = histogram;\n          this._volume = -1;\n          this._count = -1;\n          // NOTE: dimension will be mutated by split operation.\n          //       It must be specified explicitly, not from histogram\n          this.dimension = {\n            r1: r1,\n            r2: r2,\n            g1: g1,\n            g2: g2,\n            b1: b1,\n            b2: b2\n          };\n        }\n        VBox.build = function (pixels) {\n          var h = new histogram_1.default(pixels, {\n            sigBits: SIGBITS\n          });\n          var rmin = h.rmin,\n            rmax = h.rmax,\n            gmin = h.gmin,\n            gmax = h.gmax,\n            bmin = h.bmin,\n            bmax = h.bmax;\n          return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, h);\n        };\n        VBox.prototype.invalidate = function () {\n          this._volume = this._count = -1;\n          this._avg = null;\n        };\n        VBox.prototype.volume = function () {\n          if (this._volume < 0) {\n            var _a = this.dimension,\n              r1 = _a.r1,\n              r2 = _a.r2,\n              g1 = _a.g1,\n              g2 = _a.g2,\n              b1 = _a.b1,\n              b2 = _a.b2;\n            this._volume = (r2 - r1 + 1) * (g2 - g1 + 1) * (b2 - b1 + 1);\n          }\n          return this._volume;\n        };\n        VBox.prototype.count = function () {\n          if (this._count < 0) {\n            var _a = this.histogram,\n              hist = _a.hist,\n              getColorIndex = _a.getColorIndex;\n            var _b = this.dimension,\n              r1 = _b.r1,\n              r2 = _b.r2,\n              g1 = _b.g1,\n              g2 = _b.g2,\n              b1 = _b.b1,\n              b2 = _b.b2;\n            var c = 0;\n            for (var r = r1; r <= r2; r++) {\n              for (var g = g1; g <= g2; g++) {\n                for (var b = b1; b <= b2; b++) {\n                  var index = getColorIndex(r, g, b);\n                  c += hist[index];\n                }\n              }\n            }\n            this._count = c;\n          }\n          return this._count;\n        };\n        VBox.prototype.clone = function () {\n          var histogram = this.histogram;\n          var _a = this.dimension,\n            r1 = _a.r1,\n            r2 = _a.r2,\n            g1 = _a.g1,\n            g2 = _a.g2,\n            b1 = _a.b1,\n            b2 = _a.b2;\n          return new VBox(r1, r2, g1, g2, b1, b2, histogram);\n        };\n        VBox.prototype.avg = function () {\n          if (!this._avg) {\n            var _a = this.histogram,\n              hist = _a.hist,\n              getColorIndex = _a.getColorIndex;\n            var _b = this.dimension,\n              r1 = _b.r1,\n              r2 = _b.r2,\n              g1 = _b.g1,\n              g2 = _b.g2,\n              b1 = _b.b1,\n              b2 = _b.b2;\n            var ntot = 0;\n            var mult = 1 << 8 - SIGBITS;\n            var rsum = void 0;\n            var gsum = void 0;\n            var bsum = void 0;\n            rsum = gsum = bsum = 0;\n            for (var r = r1; r <= r2; r++) {\n              for (var g = g1; g <= g2; g++) {\n                for (var b = b1; b <= b2; b++) {\n                  var index = getColorIndex(r, g, b);\n                  var h = hist[index];\n                  ntot += h;\n                  rsum += h * (r + 0.5) * mult;\n                  gsum += h * (g + 0.5) * mult;\n                  bsum += h * (b + 0.5) * mult;\n                }\n              }\n            }\n            if (ntot) {\n              this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n            } else {\n              this._avg = [~~(mult * (r1 + r2 + 1) / 2), ~~(mult * (g1 + g2 + 1) / 2), ~~(mult * (b1 + b2 + 1) / 2)];\n            }\n          }\n          return this._avg;\n        };\n        VBox.prototype.contains = function (rgb) {\n          var r = rgb[0],\n            g = rgb[1],\n            b = rgb[2];\n          var _a = this.dimension,\n            r1 = _a.r1,\n            r2 = _a.r2,\n            g1 = _a.g1,\n            g2 = _a.g2,\n            b1 = _a.b1,\n            b2 = _a.b2;\n          r >>= RSHIFT;\n          g >>= RSHIFT;\n          b >>= RSHIFT;\n          return r >= r1 && r <= r2 && g >= g1 && g <= g2 && b >= b1 && b <= b2;\n        };\n        VBox.prototype.split = function () {\n          var _a = this.histogram,\n            hist = _a.hist,\n            getColorIndex = _a.getColorIndex;\n          var _b = this.dimension,\n            r1 = _b.r1,\n            r2 = _b.r2,\n            g1 = _b.g1,\n            g2 = _b.g2,\n            b1 = _b.b1,\n            b2 = _b.b2;\n          var count = this.count();\n          if (!count) return [];\n          if (count === 1) return [this.clone()];\n          var rw = r2 - r1 + 1;\n          var gw = g2 - g1 + 1;\n          var bw = b2 - b1 + 1;\n          var maxw = Math.max(rw, gw, bw);\n          var accSum = null;\n          var sum;\n          var total;\n          sum = total = 0;\n          var maxd = null;\n          if (maxw === rw) {\n            maxd = 'r';\n            accSum = new Uint32Array(r2 + 1);\n            for (var r = r1; r <= r2; r++) {\n              sum = 0;\n              for (var g = g1; g <= g2; g++) {\n                for (var b = b1; b <= b2; b++) {\n                  var index = getColorIndex(r, g, b);\n                  sum += hist[index];\n                }\n              }\n              total += sum;\n              accSum[r] = total;\n            }\n          } else if (maxw === gw) {\n            maxd = 'g';\n            accSum = new Uint32Array(g2 + 1);\n            for (var g = g1; g <= g2; g++) {\n              sum = 0;\n              for (var r = r1; r <= r2; r++) {\n                for (var b = b1; b <= b2; b++) {\n                  var index = getColorIndex(r, g, b);\n                  sum += hist[index];\n                }\n              }\n              total += sum;\n              accSum[g] = total;\n            }\n          } else {\n            maxd = 'b';\n            accSum = new Uint32Array(b2 + 1);\n            for (var b = b1; b <= b2; b++) {\n              sum = 0;\n              for (var r = r1; r <= r2; r++) {\n                for (var g = g1; g <= g2; g++) {\n                  var index = getColorIndex(r, g, b);\n                  sum += hist[index];\n                }\n              }\n              total += sum;\n              accSum[b] = total;\n            }\n          }\n          var splitPoint = -1;\n          var reverseSum = new Uint32Array(accSum.length);\n          for (var i = 0; i < accSum.length; i++) {\n            var d = accSum[i];\n            if (splitPoint < 0 && d > total / 2) splitPoint = i;\n            reverseSum[i] = total - d;\n          }\n          var vbox = this;\n          function doCut(d) {\n            var dim1 = d + '1';\n            var dim2 = d + '2';\n            var d1 = vbox.dimension[dim1];\n            var d2 = vbox.dimension[dim2];\n            var vbox1 = vbox.clone();\n            var vbox2 = vbox.clone();\n            var left = splitPoint - d1;\n            var right = d2 - splitPoint;\n            if (left <= right) {\n              d2 = Math.min(d2 - 1, ~~(splitPoint + right / 2));\n              d2 = Math.max(0, d2);\n            } else {\n              d2 = Math.max(d1, ~~(splitPoint - 1 - left / 2));\n              d2 = Math.min(vbox.dimension[dim2], d2);\n            }\n            while (!accSum[d2]) d2++;\n            var c2 = reverseSum[d2];\n            while (!c2 && accSum[d2 - 1]) c2 = reverseSum[--d2];\n            vbox1.dimension[dim2] = d2;\n            vbox2.dimension[dim1] = d2 + 1;\n            return [vbox1, vbox2];\n          }\n          return doCut(maxd);\n        };\n        return VBox;\n      }();\n      exports.default = VBox;\n\n      /***/\n    }, /* 14 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var Histogram = /** @class */function () {\n        function Histogram(pixels, opts) {\n          this.pixels = pixels;\n          this.opts = opts;\n          var sigBits = opts.sigBits;\n          var getColorIndex = function getColorIndex(r, g, b) {\n            return (r << 2 * sigBits) + (g << sigBits) + b;\n          };\n          this.getColorIndex = getColorIndex;\n          var rshift = 8 - sigBits;\n          var hn = 1 << 3 * sigBits;\n          var hist = new Uint32Array(hn);\n          var rmax;\n          var rmin;\n          var gmax;\n          var gmin;\n          var bmax;\n          var bmin;\n          var r;\n          var g;\n          var b;\n          var a;\n          rmax = gmax = bmax = 0;\n          rmin = gmin = bmin = Number.MAX_VALUE;\n          var n = pixels.length / 4;\n          var i = 0;\n          while (i < n) {\n            var offset = i * 4;\n            i++;\n            r = pixels[offset + 0];\n            g = pixels[offset + 1];\n            b = pixels[offset + 2];\n            a = pixels[offset + 3];\n            // Ignored pixels' alpha is marked as 0 in filtering stage\n            if (a === 0) continue;\n            r = r >> rshift;\n            g = g >> rshift;\n            b = b >> rshift;\n            var index = getColorIndex(r, g, b);\n            hist[index] += 1;\n            if (r > rmax) rmax = r;\n            if (r < rmin) rmin = r;\n            if (g > gmax) gmax = g;\n            if (g < gmin) gmin = g;\n            if (b > bmax) bmax = b;\n            if (b < bmin) bmin = b;\n          }\n          this._colorCount = hist.reduce(function (total, c) {\n            return c > 0 ? total + 1 : total;\n          }, 0);\n          this.hist = hist;\n          this.rmax = rmax;\n          this.rmin = rmin;\n          this.gmax = gmax;\n          this.gmin = gmin;\n          this.bmax = bmax;\n          this.bmin = bmin;\n        }\n        Object.defineProperty(Histogram.prototype, \"colorCount\", {\n          get: function get() {\n            return this._colorCount;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        return Histogram;\n      }();\n      exports.default = Histogram;\n\n      /***/\n    }, /* 15 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var PQueue = /** @class */function () {\n        function PQueue(comparator) {\n          this._comparator = comparator;\n          this.contents = [];\n          this._sorted = false;\n        }\n        PQueue.prototype._sort = function () {\n          if (!this._sorted) {\n            this.contents.sort(this._comparator);\n            this._sorted = true;\n          }\n        };\n        PQueue.prototype.push = function (item) {\n          this.contents.push(item);\n          this._sorted = false;\n        };\n        PQueue.prototype.peek = function (index) {\n          this._sort();\n          index = typeof index === 'number' ? index : this.contents.length - 1;\n          return this.contents[index];\n        };\n        PQueue.prototype.pop = function () {\n          this._sort();\n          return this.contents.pop();\n        };\n        PQueue.prototype.size = function () {\n          return this.contents.length;\n        };\n        PQueue.prototype.map = function (mapper) {\n          this._sort();\n          return this.contents.map(mapper);\n        };\n        return PQueue;\n      }();\n      exports.default = PQueue;\n\n      /***/\n    }, /* 16 */\n    /***/function (module, exports, __nested_webpack_require_50275__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var color_1 = __nested_webpack_require_50275__(3);\n      var converter_1 = __nested_webpack_require_50275__(4);\n      var DefaultOpts = {\n        targetDarkLuma: 0.26,\n        maxDarkLuma: 0.45,\n        minLightLuma: 0.55,\n        targetLightLuma: 0.74,\n        minNormalLuma: 0.3,\n        targetNormalLuma: 0.5,\n        maxNormalLuma: 0.7,\n        targetMutesSaturation: 0.3,\n        maxMutesSaturation: 0.4,\n        targetVibrantSaturation: 1.0,\n        minVibrantSaturation: 0.35,\n        weightSaturation: 3,\n        weightLuma: 6.5,\n        weightPopulation: 0.5\n      };\n      function _findMaxPopulation(swatches) {\n        var p = 0;\n        swatches.forEach(function (s) {\n          p = Math.max(p, s.population);\n        });\n        return p;\n      }\n      function _isAlreadySelected(palette, s) {\n        return palette.Vibrant === s || palette.DarkVibrant === s || palette.LightVibrant === s || palette.Muted === s || palette.DarkMuted === s || palette.LightMuted === s;\n      }\n      function _createComparisonValue(saturation, targetSaturation, luma, targetLuma, population, maxPopulation, opts) {\n        function weightedMean() {\n          var values = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n            values[_i] = arguments[_i];\n          }\n          var sum = 0;\n          var weightSum = 0;\n          for (var i = 0; i < values.length; i += 2) {\n            var value = values[i];\n            var weight = values[i + 1];\n            sum += value * weight;\n            weightSum += weight;\n          }\n          return sum / weightSum;\n        }\n        function invertDiff(value, targetValue) {\n          return 1 - Math.abs(value - targetValue);\n        }\n        return weightedMean(invertDiff(saturation, targetSaturation), opts.weightSaturation, invertDiff(luma, targetLuma), opts.weightLuma, population / maxPopulation, opts.weightPopulation);\n      }\n      function _findColorVariation(palette, swatches, maxPopulation, targetLuma, minLuma, maxLuma, targetSaturation, minSaturation, maxSaturation, opts) {\n        var max = null;\n        var maxValue = 0;\n        swatches.forEach(function (swatch) {\n          var _a = swatch.hsl,\n            s = _a[1],\n            l = _a[2];\n          if (s >= minSaturation && s <= maxSaturation && l >= minLuma && l <= maxLuma && !_isAlreadySelected(palette, swatch)) {\n            var value = _createComparisonValue(s, targetSaturation, l, targetLuma, swatch.population, maxPopulation, opts);\n            if (max === null || value > maxValue) {\n              max = swatch;\n              maxValue = value;\n            }\n          }\n        });\n        return max;\n      }\n      function _generateVariationColors(swatches, maxPopulation, opts) {\n        var palette = {\n          Vibrant: null,\n          DarkVibrant: null,\n          LightVibrant: null,\n          Muted: null,\n          DarkMuted: null,\n          LightMuted: null\n        };\n        // mVibrantSwatch = findColor(TARGET_NORMAL_LUMA, MIN_NORMAL_LUMA, MAX_NORMAL_LUMA,\n        //     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n        palette.Vibrant = _findColorVariation(palette, swatches, maxPopulation, opts.targetNormalLuma, opts.minNormalLuma, opts.maxNormalLuma, opts.targetVibrantSaturation, opts.minVibrantSaturation, 1, opts);\n        // mLightVibrantSwatch = findColor(TARGET_LIGHT_LUMA, MIN_LIGHT_LUMA, 1f,\n        //     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n        palette.LightVibrant = _findColorVariation(palette, swatches, maxPopulation, opts.targetLightLuma, opts.minLightLuma, 1, opts.targetVibrantSaturation, opts.minVibrantSaturation, 1, opts);\n        // mDarkVibrantSwatch = findColor(TARGET_DARK_LUMA, 0f, MAX_DARK_LUMA,\n        //     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n        palette.DarkVibrant = _findColorVariation(palette, swatches, maxPopulation, opts.targetDarkLuma, 0, opts.maxDarkLuma, opts.targetVibrantSaturation, opts.minVibrantSaturation, 1, opts);\n        // mMutedSwatch = findColor(TARGET_NORMAL_LUMA, MIN_NORMAL_LUMA, MAX_NORMAL_LUMA,\n        //     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n        palette.Muted = _findColorVariation(palette, swatches, maxPopulation, opts.targetNormalLuma, opts.minNormalLuma, opts.maxNormalLuma, opts.targetMutesSaturation, 0, opts.maxMutesSaturation, opts);\n        // mLightMutedColor = findColor(TARGET_LIGHT_LUMA, MIN_LIGHT_LUMA, 1f,\n        //     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n        palette.LightMuted = _findColorVariation(palette, swatches, maxPopulation, opts.targetLightLuma, opts.minLightLuma, 1, opts.targetMutesSaturation, 0, opts.maxMutesSaturation, opts);\n        // mDarkMutedSwatch = findColor(TARGET_DARK_LUMA, 0f, MAX_DARK_LUMA,\n        //     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n        palette.DarkMuted = _findColorVariation(palette, swatches, maxPopulation, opts.targetDarkLuma, 0, opts.maxDarkLuma, opts.targetMutesSaturation, 0, opts.maxMutesSaturation, opts);\n        return palette;\n      }\n      function _generateEmptySwatches(palette, maxPopulation, opts) {\n        if (!palette.Vibrant && !palette.DarkVibrant && !palette.LightVibrant) {\n          if (!palette.DarkVibrant && palette.DarkMuted) {\n            var _a = palette.DarkMuted.hsl,\n              h = _a[0],\n              s = _a[1],\n              l = _a[2];\n            l = opts.targetDarkLuma;\n            palette.DarkVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n          }\n          if (!palette.LightVibrant && palette.LightMuted) {\n            var _b = palette.LightMuted.hsl,\n              h = _b[0],\n              s = _b[1],\n              l = _b[2];\n            l = opts.targetDarkLuma;\n            palette.DarkVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n          }\n        }\n        if (!palette.Vibrant && palette.DarkVibrant) {\n          var _c = palette.DarkVibrant.hsl,\n            h = _c[0],\n            s = _c[1],\n            l = _c[2];\n          l = opts.targetNormalLuma;\n          palette.Vibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        } else if (!palette.Vibrant && palette.LightVibrant) {\n          var _d = palette.LightVibrant.hsl,\n            h = _d[0],\n            s = _d[1],\n            l = _d[2];\n          l = opts.targetNormalLuma;\n          palette.Vibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n        if (!palette.DarkVibrant && palette.Vibrant) {\n          var _e = palette.Vibrant.hsl,\n            h = _e[0],\n            s = _e[1],\n            l = _e[2];\n          l = opts.targetDarkLuma;\n          palette.DarkVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n        if (!palette.LightVibrant && palette.Vibrant) {\n          var _f = palette.Vibrant.hsl,\n            h = _f[0],\n            s = _f[1],\n            l = _f[2];\n          l = opts.targetLightLuma;\n          palette.LightVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n        if (!palette.Muted && palette.Vibrant) {\n          var _g = palette.Vibrant.hsl,\n            h = _g[0],\n            s = _g[1],\n            l = _g[2];\n          l = opts.targetMutesSaturation;\n          palette.Muted = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n        if (!palette.DarkMuted && palette.DarkVibrant) {\n          var _h = palette.DarkVibrant.hsl,\n            h = _h[0],\n            s = _h[1],\n            l = _h[2];\n          l = opts.targetMutesSaturation;\n          palette.DarkMuted = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n        if (!palette.LightMuted && palette.LightVibrant) {\n          var _j = palette.LightVibrant.hsl,\n            h = _j[0],\n            s = _j[1],\n            l = _j[2];\n          l = opts.targetMutesSaturation;\n          palette.LightMuted = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n      }\n      var DefaultGenerator = function DefaultGenerator(swatches, opts) {\n        opts = Object.assign({}, DefaultOpts, opts);\n        var maxPopulation = _findMaxPopulation(swatches);\n        var palette = _generateVariationColors(swatches, maxPopulation, opts);\n        _generateEmptySwatches(palette, maxPopulation, opts);\n        return palette;\n      };\n      exports.default = DefaultGenerator;\n\n      /***/\n    }, /* 17 */\n    /***/function (module, exports, __nested_webpack_require_58790__) {\n      \"use strict\";\n\n      var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function (resolve) {\n            resolve(value);\n          });\n        }\n        return new (P || (P = Promise))(function (resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n      var __generator = this && this.__generator || function (thisArg, body) {\n        var _ = {\n            label: 0,\n            sent: function sent() {\n              if (t[0] & 1) throw t[1];\n              return t[1];\n            },\n            trys: [],\n            ops: []\n          },\n          f,\n          y,\n          t,\n          g;\n        return g = {\n          next: verb(0),\n          \"throw\": verb(1),\n          \"return\": verb(2)\n        }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n          return this;\n        }), g;\n        function verb(n) {\n          return function (v) {\n            return step([n, v]);\n          };\n        }\n        function step(op) {\n          if (f) throw new TypeError(\"Generator is already executing.\");\n          while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return {\n                  value: op[1],\n                  done: false\n                };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2]) _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n          if (op[0] & 5) throw op[1];\n          return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n          };\n        }\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.BasicPipeline = exports.Stage = void 0;\n      var image_1 = __nested_webpack_require_58790__(2);\n      var Stage = /** @class */function () {\n        function Stage(pipeline) {\n          this.pipeline = pipeline;\n          this._map = {};\n        }\n        Stage.prototype.names = function () {\n          return Object.keys(this._map);\n        };\n        Stage.prototype.has = function (name) {\n          return !!this._map[name];\n        };\n        Stage.prototype.get = function (name) {\n          return this._map[name];\n        };\n        Stage.prototype.register = function (name, stageFn) {\n          this._map[name] = stageFn;\n          return this.pipeline;\n        };\n        return Stage;\n      }();\n      exports.Stage = Stage;\n      var BasicPipeline = /** @class */function () {\n        function BasicPipeline() {\n          this.filter = new Stage(this);\n          this.quantizer = new Stage(this);\n          this.generator = new Stage(this);\n        }\n        BasicPipeline.prototype._buildProcessTasks = function (_a) {\n          var _this = this;\n          var filters = _a.filters,\n            quantizer = _a.quantizer,\n            generators = _a.generators;\n          // Support wildcard for generators\n          if (generators.length === 1 && generators[0] === '*') {\n            generators = this.generator.names();\n          }\n          return {\n            filters: filters.map(function (f) {\n              return createTask(_this.filter, f);\n            }),\n            quantizer: createTask(this.quantizer, quantizer),\n            generators: generators.map(function (g) {\n              return createTask(_this.generator, g);\n            })\n          };\n          function createTask(stage, o) {\n            var name;\n            var options;\n            if (typeof o === 'string') {\n              name = o;\n            } else {\n              name = o.name;\n              options = o.options;\n            }\n            return {\n              name: name,\n              fn: stage.get(name),\n              options: options\n            };\n          }\n        };\n        BasicPipeline.prototype.process = function (imageData, opts) {\n          return __awaiter(this, void 0, void 0, function () {\n            var _a, filters, quantizer, generators, imageFilterData, colors, palettes;\n            return __generator(this, function (_b) {\n              switch (_b.label) {\n                case 0:\n                  _a = this._buildProcessTasks(opts), filters = _a.filters, quantizer = _a.quantizer, generators = _a.generators;\n                  return [4 /*yield*/, this._filterColors(filters, imageData)];\n                case 1:\n                  imageFilterData = _b.sent();\n                  return [4 /*yield*/, this._generateColors(quantizer, imageFilterData)];\n                case 2:\n                  colors = _b.sent();\n                  return [4 /*yield*/, this._generatePalettes(generators, colors)];\n                case 3:\n                  palettes = _b.sent();\n                  return [2 /*return*/, {\n                    colors: colors,\n                    palettes: palettes\n                  }];\n              }\n            });\n          });\n        };\n        BasicPipeline.prototype._filterColors = function (filters, imageData) {\n          return Promise.resolve(image_1.applyFilters(imageData, filters.map(function (_a) {\n            var fn = _a.fn;\n            return fn;\n          })));\n        };\n        BasicPipeline.prototype._generateColors = function (quantizer, imageData) {\n          return Promise.resolve(quantizer.fn(imageData.data, quantizer.options));\n        };\n        BasicPipeline.prototype._generatePalettes = function (generators, colors) {\n          return __awaiter(this, void 0, void 0, function () {\n            var promiseArr;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4 /*yield*/, Promise.all(generators.map(function (_a) {\n                    var fn = _a.fn,\n                      options = _a.options;\n                    return Promise.resolve(fn(colors, options));\n                  }))\n                  // Map the values to the expected name\n                  ];\n\n                case 1:\n                  promiseArr = _a.sent();\n                  // Map the values to the expected name\n                  return [2 /*return*/, Promise.resolve(promiseArr.reduce(function (promises, promiseVal, i) {\n                    promises[generators[i].name] = promiseVal;\n                    return promises;\n                  }, {}))];\n              }\n            });\n          });\n        };\n        return BasicPipeline;\n      }();\n      exports.BasicPipeline = BasicPipeline;\n\n      /***/\n    }\n    /******/])\n  );\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm9kZS12aWJyYW50L2Rpc3QvdmlicmFudC5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFRQTtBQUNBOztBQ1ZBOztBQUNBOztBQUVBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUVBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOzs7QUFHQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7QUFBQTtBQUFBOztBQUVBOztBQUNBOzs7QUFHQTs7QUFDQTs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQVhBO0FBYUE7Ozs7QUFJQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQW5CQTs7Ozs7Ozs7Ozs7Ozs7O0FDakJBO0FBTUE7QUFFQTtBQU1BO0FBcUJBO0FBQUE7QUFDQTtBQUNBO0FBcEJBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBOzs7O0FBTUE7QUFJQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBTUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFzR0E7QUFBQTtBQWhIQTs7Ozs7Ozs7Ozs7QUNzQkE7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQTFCQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQU1BO0FBQ0E7QUExQkE7Ozs7Ozs7Ozs7O0FDaEVBO0FBeUJBO0FBbUpBO0FBQ0E7QUFDQTtBQUNBO0FBckpBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBVUE7QUFIQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFIQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFIQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFIQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFIQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUtBO0FBSEE7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7OztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBS0E7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFNQTtBQUFBO0FBdkpBOzs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBTkE7QUFRQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTs7QUFFQTtBQUNBO0FBM0JBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFLQTtBQTVCQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFqQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBOUJBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQXRCQTs7Ozs7Ozs7Ozs7O0FDN0xBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQ0RBO0FBVUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBOzs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBRUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekZBO0FBUUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFFQTtBQUFBO0FBQUE7O0FBOEZBO0FBeEZBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUN6SEE7QUFDQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFBQTtBQU1BOzs7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUNuRUE7QUFXQTtBQUNBO0FBRUE7QUFhQTtBQUlBO0FBUkE7QUFFQTtBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFyQkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUtBO0FBQ0E7OztBQVFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7Ozs7Ozs7Ozs7O0FDcE9BO0FBV0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE3REE7QUFBQTtBQUFBO0FBQUE7Ozs7QUE4REE7QUFBQTs7Ozs7Ozs7Ozs7QUN6RUE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7Ozs7QUM3Q0E7QUFFQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBRUE7QUFLQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUVBO0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTs7O0FBSUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hRQTtBQUtBO0FBRUE7QUFBQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFoQkE7QUFvREE7QUFBQTtBQW1DQTtBQUNBO0FBQ0E7QUE0Q0E7QUFoRkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7Ozs7OztBQUlBO0FBQ0E7O0FBQUE7QUFDQTs7QUFBQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTs7O0FBSEE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUFBO0FBakZBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24/OTEwMCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3dlYnBhY2svYm9vdHN0cmFwPzdmOTgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWNvcmUvc3JjL3V0aWxzLnRzP2YwOGIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWNvcmUvc3JjL2luZGV4LnRzPzZmMDkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWltYWdlL3NyYy9pbmRleC50cz9hOTNhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1jb2xvci9zcmMvaW5kZXgudHM/ZGMyZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtY29sb3Ivc3JjL2NvbnZlcnRlci50cz82NmRlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvc3JjL2Jyb3dzZXIudHM/ZjI1MSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3NyYy9jb25maWcudHM/YzY1YSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtY29yZS9zcmMvb3B0aW9ucy50cz9lNGZlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1jb3JlL3NyYy9idWlsZGVyLnRzP2Y2MjAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWltYWdlLWJyb3dzZXIvc3JjL2luZGV4LnRzPzdiNDUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC9zcmMvYnVuZGxlLnRzP2QxOGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC9zcmMvcGlwZWxpbmUvaW5kZXgudHM/OTI2MCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtcXVhbnRpemVyLW1tY3Evc3JjL2luZGV4LnRzP2UzMmEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LXF1YW50aXplci1tbWNxL3NyYy92Ym94LnRzP2NmZGEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWltYWdlL3NyYy9oaXN0b2dyYW0udHM/MDhhNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtcXVhbnRpemVyLW1tY3Evc3JjL3BxdWV1ZS50cz9kNTk5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1nZW5lcmF0b3ItZGVmYXVsdC9zcmMvaW5kZXgudHM/NDM0MCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtY29yZS9zcmMvcGlwZWxpbmUvaW5kZXgudHM/ZmEyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJWaWJyYW50XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlZpYnJhbnRcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMCk7XG4iLCJleHBvcnQgZnVuY3Rpb24gbWFwVmFsdWVzPFQsIFI+IChvOiB7IFtrZXk6IHN0cmluZ106IFQgfSwgbWFwcGVyOiAodjogVCkgPT4gUik6IHsgW2tleTogc3RyaW5nXTogUiB9IHtcbiAgbGV0IHJlc3VsdDogeyBba2V5OiBzdHJpbmddOiBSIH0gPSB7fVxuXG4gIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb25zdCB2ID0gb1trZXldXG4gICAgICByZXN1bHRba2V5XSA9IG1hcHBlcih2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBPdmVyd3JpdGUgdmFsdWVzIG9yIHByb3BlcnRpZXMgb24gb2JqZWN0cyBhbmQgbGlzdHMgcmVjdXJzaXZlbHkuXG4gKiBBIHNoYWxsb3cgY29weSB3aWxsIGJlIGNyZWF0ZWQgZm9yIGVhY2ggYXJyYXkgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25EZWVwPFQ+ICh0YXJnZXQ6IFBhcnRpYWw8VD4sIC4uLnNvdXJjZXM6IChQYXJ0aWFsPFQ+IHwgdW5kZWZpbmVkKVtdKTogVCB7XG4gIHNvdXJjZXMuZm9yRWFjaChzID0+IHtcbiAgICBpZiAoIXMpIHJldHVyblxuICAgIGZvciAoY29uc3Qga2V5IGluIHMpIHtcbiAgICAgIGlmIChzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY29uc3QgdiA9IHNba2V5XSBhcyBhbnlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAvLyBTaGFsbG93IGNvcHlcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHYuc2xpY2UoMCkgYXMgYW55XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKCF0YXJnZXRba2V5XSkgdGFyZ2V0W2tleV0gPSB7fSBhcyBhbnlcbiAgICAgICAgICBhc3NpZ25EZWVwPGFueT4odGFyZ2V0W2tleV0gYXMgYW55LCB2KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gdGFyZ2V0IGFzIFRcbn1cbiIsImltcG9ydCB7IE9wdGlvbnMsIGJ1aWxkUHJvY2Vzc09wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMnXG5pbXBvcnQgeyBDYWxsYmFjayB9IGZyb20gJ0B2aWJyYW50L3R5cGVzJ1xuaW1wb3J0IHsgSW1hZ2UsIEltYWdlU291cmNlIH0gZnJvbSAnQHZpYnJhbnQvaW1hZ2UnXG5cbmltcG9ydCB7IEZpbHRlciwgUGFsZXR0ZSwgU3dhdGNoIH0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5cbmltcG9ydCBCdWlsZGVyIGZyb20gJy4vYnVpbGRlcidcbmltcG9ydCB7IFBpcGVsaW5lLCBQcm9jZXNzT3B0aW9ucywgUHJvY2Vzc1Jlc3VsdCB9IGZyb20gJy4vcGlwZWxpbmUnXG5pbXBvcnQgeyBhc3NpZ25EZWVwIH0gZnJvbSAnLi91dGlscydcblxuZXhwb3J0IGludGVyZmFjZSBWaWJyYW50U3RhdGljIHtcbiAgZnJvbSAoc3JjOiBJbWFnZVNvdXJjZSk6IEJ1aWxkZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlicmFudCB7XG4gIHByaXZhdGUgX3Jlc3VsdDogUHJvY2Vzc1Jlc3VsdFxuICBwcml2YXRlIHN0YXRpYyBfcGlwZWxpbmU6IFBpcGVsaW5lXG4gIHN0YXRpYyB1c2UgKHBpcGVsaW5lOiBQaXBlbGluZSkge1xuICAgIHRoaXMuX3BpcGVsaW5lID0gcGlwZWxpbmVcbiAgfVxuICBzdGF0aWMgRGVmYXVsdE9wdHM6IFBhcnRpYWw8T3B0aW9ucz4gPSB7XG4gICAgY29sb3JDb3VudDogNjQsXG4gICAgcXVhbGl0eTogNSxcbiAgICBmaWx0ZXJzOiBbXVxuICB9XG5cbiAgc3RhdGljIGZyb20gKHNyYzogSW1hZ2VTb3VyY2UpOiBCdWlsZGVyIHtcbiAgICByZXR1cm4gbmV3IEJ1aWxkZXIoc3JjKVxuICB9XG5cbiAgZ2V0IHJlc3VsdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3VsdFxuICB9XG5cbiAgb3B0czogT3B0aW9uc1xuICBjb25zdHJ1Y3RvciAocHJpdmF0ZSBfc3JjOiBJbWFnZVNvdXJjZSwgb3B0cz86IFBhcnRpYWw8T3B0aW9ucz4pIHtcbiAgICB0aGlzLm9wdHMgPSBhc3NpZ25EZWVwKHt9LCBWaWJyYW50LkRlZmF1bHRPcHRzLCBvcHRzKVxuICB9XG4gIHByaXZhdGUgX3Byb2Nlc3MgKFxuICAgIGltYWdlOiBJbWFnZSxcbiAgICBvcHRzPzogUGFydGlhbDxQcm9jZXNzT3B0aW9ucz5cbiAgKTogUHJvbWlzZTxQcm9jZXNzUmVzdWx0PiB7XG4gICAgbGV0IHsgcXVhbnRpemVyIH0gPSB0aGlzLm9wdHNcblxuICAgIGltYWdlLnNjYWxlRG93bih0aGlzLm9wdHMpXG5cbiAgICBsZXQgcHJvY2Vzc09wdHMgPSBidWlsZFByb2Nlc3NPcHRpb25zKHRoaXMub3B0cywgb3B0cylcblxuICAgIHJldHVybiBWaWJyYW50Ll9waXBlbGluZS5wcm9jZXNzKGltYWdlLmdldEltYWdlRGF0YSgpLCBwcm9jZXNzT3B0cylcbiAgfVxuICBwYWxldHRlICgpOiBQYWxldHRlIHtcbiAgICByZXR1cm4gdGhpcy5zd2F0Y2hlcygpXG4gIH1cbiAgc3dhdGNoZXMgKCk6IFBhbGV0dGUge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdNZXRob2QgZGVwcmVjYXRlZC4gVXNlIGBWaWJyYW50LnJlc3VsdC5wYWxldHRlc1tuYW1lXWAgaW5zdGVhZCdcbiAgICApXG4gIH1cblxuICBnZXRQYWxldHRlIChuYW1lOiBzdHJpbmcsIGNiPzogQ2FsbGJhY2s8UGFsZXR0ZT4pOiBQcm9taXNlPFBhbGV0dGU+XG4gIGdldFBhbGV0dGUgKGNiPzogQ2FsbGJhY2s8UGFsZXR0ZT4pOiBQcm9taXNlPFBhbGV0dGU+XG4gIGdldFBhbGV0dGUgKCk6IFByb21pc2U8UGFsZXR0ZT4ge1xuICAgIGNvbnN0IGFyZzAgPSBhcmd1bWVudHNbMF1cbiAgICBjb25zdCBhcmcxID0gYXJndW1lbnRzWzFdXG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJyA/IGFyZzAgOiAnZGVmYXVsdCdcbiAgICBjb25zdCBjYiA9IHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJyA/IGFyZzEgOiBhcmcwXG4gICAgbGV0IGltYWdlID0gbmV3IHRoaXMub3B0cy5JbWFnZUNsYXNzKClcbiAgICByZXR1cm4gaW1hZ2VcbiAgICAgIC5sb2FkKHRoaXMuX3NyYylcbiAgICAgIC50aGVuKGltYWdlID0+IHRoaXMuX3Byb2Nlc3MoaW1hZ2UsIHsgZ2VuZXJhdG9yczogW25hbWVdIH0pKVxuICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gcmVzdWx0XG4gICAgICAgIHJldHVybiByZXN1bHQucGFsZXR0ZXNbbmFtZV1cbiAgICAgIH0pXG4gICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICBpbWFnZS5yZW1vdmUoKVxuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYih1bmRlZmluZWQsIHJlcylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGltYWdlLnJlbW92ZSgpXG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKGVycilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgICAgfSlcbiAgfVxuICBnZXRQYWxldHRlcyAoXG4gICAgbmFtZXM6IHN0cmluZ1tdLFxuICAgIGNiPzogQ2FsbGJhY2s8UGFsZXR0ZT5cbiAgKTogUHJvbWlzZTx7IFtuYW1lOiBzdHJpbmddOiBQYWxldHRlIH0+XG4gIGdldFBhbGV0dGVzIChjYj86IENhbGxiYWNrPFBhbGV0dGU+KTogUHJvbWlzZTx7IFtuYW1lOiBzdHJpbmddOiBQYWxldHRlIH0+XG4gIGdldFBhbGV0dGVzICgpOiBQcm9taXNlPHsgW25hbWU6IHN0cmluZ106IFBhbGV0dGUgfT4ge1xuICAgIGNvbnN0IGFyZzAgPSBhcmd1bWVudHNbMF1cbiAgICBjb25zdCBhcmcxID0gYXJndW1lbnRzWzFdXG4gICAgY29uc3QgbmFtZXMgPSBBcnJheS5pc0FycmF5KGFyZzApID8gYXJnMCA6IFsnKiddXG4gICAgY29uc3QgY2IgPSBBcnJheS5pc0FycmF5KGFyZzApID8gYXJnMSA6IGFyZzBcbiAgICBsZXQgaW1hZ2UgPSBuZXcgdGhpcy5vcHRzLkltYWdlQ2xhc3MoKVxuICAgIHJldHVybiBpbWFnZVxuICAgICAgLmxvYWQodGhpcy5fc3JjKVxuICAgICAgLnRoZW4oaW1hZ2UgPT5cbiAgICAgICAgdGhpcy5fcHJvY2VzcyhpbWFnZSwge1xuICAgICAgICAgIGdlbmVyYXRvcnM6IG5hbWVzXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICB0aGlzLl9yZXN1bHQgPSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5wYWxldHRlc1xuICAgICAgfSlcbiAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIGltYWdlLnJlbW92ZSgpXG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKHVuZGVmaW5lZCwgcmVzKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaW1hZ2UucmVtb3ZlKClcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gICAgICB9KVxuICB9XG59XG4iLCJpbXBvcnQgeyBDYWxsYmFjayB9IGZyb20gJ0B2aWJyYW50L3R5cGVzJ1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5cbmV4cG9ydCB0eXBlIEltYWdlQ2FsbGJhY2sgPSBDYWxsYmFjazxJbWFnZT5cblxuZXhwb3J0IHR5cGUgSW1hZ2VTb3VyY2UgPSBzdHJpbmcgfCBIVE1MSW1hZ2VFbGVtZW50IHwgQnVmZmVyXG5cbmV4cG9ydCB0eXBlIFBpeGVscyA9IFVpbnQ4Q2xhbXBlZEFycmF5IHwgQnVmZmVyXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlRGF0YSB7XG4gIGRhdGE6IFBpeGVscyxcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZU9wdGlvbnMge1xuICBxdWFsaXR5OiBudW1iZXJcbiAgbWF4RGltZW5zaW9uOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZSB7XG4gIGxvYWQgKGltYWdlOiBJbWFnZVNvdXJjZSk6IFByb21pc2U8SW1hZ2U+XG4gIGNsZWFyICgpOiB2b2lkXG4gIHVwZGF0ZSAoaW1hZ2VEYXRhOiBJbWFnZURhdGEpOiB2b2lkXG4gIGdldFdpZHRoICgpOiBudW1iZXJcbiAgZ2V0SGVpZ2h0ICgpOiBudW1iZXJcbiAgcmVzaXplICh0YXJnZXRXaWR0aDogbnVtYmVyLCB0YXJnZXRIZWlnaHQ6IG51bWJlciwgcmF0aW86IG51bWJlcik6IHZvaWRcbiAgZ2V0UGl4ZWxDb3VudCAoKTogbnVtYmVyXG4gIGdldEltYWdlRGF0YSAoKTogSW1hZ2VEYXRhXG4gIHJlbW92ZSAoKTogdm9pZFxuICBzY2FsZURvd24gKG9wdHM6IEltYWdlT3B0aW9ucyk6IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUNsYXNzIHtcbiAgbmV3KCk6IEltYWdlXG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbWFnZUJhc2UgaW1wbGVtZW50cyBJbWFnZSB7XG4gIGFic3RyYWN0IGxvYWQgKGltYWdlOiBJbWFnZVNvdXJjZSk6IFByb21pc2U8SW1hZ2VCYXNlPlxuICBhYnN0cmFjdCBjbGVhciAoKTogdm9pZFxuICBhYnN0cmFjdCB1cGRhdGUgKGltYWdlRGF0YTogSW1hZ2VEYXRhKTogdm9pZFxuICBhYnN0cmFjdCBnZXRXaWR0aCAoKTogbnVtYmVyXG4gIGFic3RyYWN0IGdldEhlaWdodCAoKTogbnVtYmVyXG4gIGFic3RyYWN0IHJlc2l6ZSAodGFyZ2V0V2lkdGg6IG51bWJlciwgdGFyZ2V0SGVpZ2h0OiBudW1iZXIsIHJhdGlvOiBudW1iZXIpOiB2b2lkXG4gIGFic3RyYWN0IGdldFBpeGVsQ291bnQgKCk6IG51bWJlclxuICBhYnN0cmFjdCBnZXRJbWFnZURhdGEgKCk6IEltYWdlRGF0YVxuICBhYnN0cmFjdCByZW1vdmUgKCk6IHZvaWRcblxuICBzY2FsZURvd24gKG9wdHM6IEltYWdlT3B0aW9ucyk6IHZvaWQge1xuICAgIGxldCB3aWR0aDogbnVtYmVyID0gdGhpcy5nZXRXaWR0aCgpXG4gICAgbGV0IGhlaWdodDogbnVtYmVyID0gdGhpcy5nZXRIZWlnaHQoKVxuXG4gICAgbGV0IHJhdGlvOiBudW1iZXIgPSAxXG5cbiAgICBpZiAob3B0cy5tYXhEaW1lbnNpb24gPiAwKSB7XG4gICAgICBsZXQgbWF4U2lkZTogbnVtYmVyID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodClcbiAgICAgIGlmIChtYXhTaWRlID4gb3B0cy5tYXhEaW1lbnNpb24pIHJhdGlvID0gb3B0cy5tYXhEaW1lbnNpb24gLyBtYXhTaWRlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhdGlvID0gMSAvIG9wdHMucXVhbGl0eVxuICAgIH1cblxuICAgIGlmIChyYXRpbyA8IDEpIHRoaXMucmVzaXplKHdpZHRoICogcmF0aW8sIGhlaWdodCAqIHJhdGlvLCByYXRpbylcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlGaWx0ZXJzIChpbWFnZURhdGE6IEltYWdlRGF0YSwgZmlsdGVyczogRmlsdGVyW10pIHtcbiAgaWYgKGZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgIGxldCBwaXhlbHMgPSBpbWFnZURhdGEuZGF0YVxuICAgIGxldCBuID0gcGl4ZWxzLmxlbmd0aCAvIDRcbiAgICBsZXQgb2Zmc2V0XG4gICAgbGV0IHJcbiAgICBsZXQgZ1xuICAgIGxldCBiXG4gICAgbGV0IGFcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgb2Zmc2V0ID0gaSAqIDRcbiAgICAgIHIgPSBwaXhlbHNbb2Zmc2V0ICsgMF1cbiAgICAgIGcgPSBwaXhlbHNbb2Zmc2V0ICsgMV1cbiAgICAgIGIgPSBwaXhlbHNbb2Zmc2V0ICsgMl1cbiAgICAgIGEgPSBwaXhlbHNbb2Zmc2V0ICsgM11cbiAgICAgIC8vIE1hcmsgaWdub3JlZCBjb2xvclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaWx0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghZmlsdGVyc1tqXShyLCBnLCBiLCBhKSkge1xuICAgICAgICAgIHBpeGVsc1tvZmZzZXQgKyAzXSA9IDBcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGltYWdlRGF0YVxufVxuIiwiaW1wb3J0IHsgcmdiVG9Ic2wsIHJnYlRvSGV4IH0gZnJvbSAnLi9jb252ZXJ0ZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsdGVyIHtcbiAgKHJlZDogbnVtYmVyLCBncmVlbjogbnVtYmVyLCBibHVlOiBudW1iZXIsIGFscGhhOiBudW1iZXIpOiBib29sZWFuXG59XG5cbi8qKlxuICogM2QgZmxvYXRpbmcgcG9pbnRlciB2ZWN0b3JcbiAqL1xuZXhwb3J0IHR5cGUgVmVjMyA9IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuXG4vKipcbiAqIFRoZSBsYXlvdXQgZm9yIGEgbm9kZS12aWJyYW50IFBhbGV0dGUuIEFsbG93cyB5b3UgdG8ga2VlcCB0cmFjayBvZlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhbGV0dGUge1xuICBWaWJyYW50OiBTd2F0Y2ggfCBudWxsXG4gIE11dGVkOiBTd2F0Y2ggfCBudWxsXG4gIERhcmtWaWJyYW50OiBTd2F0Y2ggfCBudWxsXG4gIERhcmtNdXRlZDogU3dhdGNoIHwgbnVsbFxuICBMaWdodFZpYnJhbnQ6IFN3YXRjaCB8IG51bGxcbiAgTGlnaHRNdXRlZDogU3dhdGNoIHwgbnVsbFxuICAvLyA/XG4gIFtuYW1lOiBzdHJpbmddOiBTd2F0Y2ggfCBudWxsXG59XG5cbmV4cG9ydCBjbGFzcyBTd2F0Y2gge1xuICBzdGF0aWMgYXBwbHlGaWx0ZXJzIChjb2xvcnM6IFN3YXRjaFtdLCBmaWx0ZXJzOiBGaWx0ZXJbXSk6IFN3YXRjaFtdIHtcbiAgICByZXR1cm4gZmlsdGVycy5sZW5ndGggPiAwXG4gICAgICA/IGNvbG9ycy5maWx0ZXIoKHsgciwgZywgYiB9KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmlsdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICghZmlsdGVyc1tqXShyLCBnLCBiLCAyNTUpKSByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICAgIDogY29sb3JzXG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIHZhbHVlIGNvcHkgb2YgYSBzd2F0Y2ggYmFzZWQgb24gYSBwcmV2aW91cyBvbmUuIFJldHVybnMgYSBuZXcgU3dhdGNoIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dhdGNofSBzd2F0Y2hcbiAgICovXG4gIHN0YXRpYyBjbG9uZSAoc3dhdGNoOiBTd2F0Y2gpIHtcbiAgICByZXR1cm4gbmV3IFN3YXRjaChzd2F0Y2guX3JnYiwgc3dhdGNoLl9wb3B1bGF0aW9uKVxuICB9XG4gIHByaXZhdGUgX2hzbDogVmVjM1xuICBwcml2YXRlIF9yZ2I6IFZlYzNcbiAgcHJpdmF0ZSBfeWlxOiBudW1iZXJcbiAgcHJpdmF0ZSBfcG9wdWxhdGlvbjogbnVtYmVyXG4gIHByaXZhdGUgX2hleDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSByZWQgdmFsdWUgaW4gdGhlIFJHQiB2YWx1ZVxuICAgKi9cbiAgZ2V0IHIgKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3JnYlswXVxuICB9XG4gIC8qKlxuICAgKiBUaGUgZ3JlZW4gdmFsdWUgaW4gdGhlIFJHQiB2YWx1ZVxuICAgKi9cbiAgZ2V0IGcgKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3JnYlsxXVxuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ZSB2YWx1ZSBpbiB0aGUgUkdCIHZhbHVlXG4gICAqL1xuICBnZXQgYiAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcmdiWzJdXG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjb2xvciB2YWx1ZSBhcyBhIHJnYiB2YWx1ZVxuICAgKi9cbiAgZ2V0IHJnYiAoKTogVmVjMyB7XG4gICAgcmV0dXJuIHRoaXMuX3JnYlxuICB9XG4gIC8qKlxuICAgKiBUaGUgY29sb3IgdmFsdWUgYXMgYSBoc2wgdmFsdWVcbiAgICovXG4gIGdldCBoc2wgKCk6IFZlYzMge1xuICAgIGlmICghdGhpcy5faHNsKSB7XG4gICAgICBsZXQgW3IsIGcsIGJdID0gdGhpcy5fcmdiXG4gICAgICB0aGlzLl9oc2wgPSByZ2JUb0hzbChyLCBnLCBiKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faHNsXG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbG9yIHZhbHVlIGFzIGEgaGV4IHN0cmluZ1xuICAgKi9cbiAgZ2V0IGhleCAoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuX2hleCkge1xuICAgICAgbGV0IFtyLCBnLCBiXSA9IHRoaXMuX3JnYlxuICAgICAgdGhpcy5faGV4ID0gcmdiVG9IZXgociwgZywgYilcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2hleFxuICB9XG4gIGdldCBwb3B1bGF0aW9uICgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9wb3B1bGF0aW9uXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBKU09OIG9iamVjdCBmb3IgdGhlIHN3YXRjaFxuICAgKi9cbiAgdG9KU09OICgpOiB7cmdiOiBWZWMzLCBwb3B1bGF0aW9uOiBudW1iZXJ9IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmdiOiB0aGlzLnJnYixcbiAgICAgIHBvcHVsYXRpb246IHRoaXMucG9wdWxhdGlvblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbG9yIHZhbHVlIGFzIGEgcmdiIHZhbHVlXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcm9wZXJ0eSBpbnN0ZWFkXG4gICAqL1xuICAvLyBUT0RPOiBkZXByZWNhdGUgaW50ZXJuYWxseSwgdXNlIHByb3BlcnR5IGluc3RlYWRcbiAgZ2V0UmdiICgpOiBWZWMzIHtcbiAgICByZXR1cm4gdGhpcy5fcmdiXG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY29sb3IgdmFsdWUgYXMgYSBoc2wgdmFsdWVcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByb3BlcnR5IGluc3RlYWRcbiAgICovXG4gIC8vIFRPRE86IGRlcHJlY2F0ZSBpbnRlcm5hbGx5LCB1c2UgcHJvcGVydHkgaW5zdGVhZFxuICBnZXRIc2wgKCk6IFZlYzMge1xuICAgIHJldHVybiB0aGlzLmhzbFxuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJvcGVydHkgaW5zdGVhZFxuICAgKi9cbiAgLy8gVE9ETzogZGVwcmVjYXRlIGludGVybmFsbHksIHVzZSBwcm9wZXJ0eSBpbnN0ZWFkXG4gIGdldFBvcHVsYXRpb24gKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcHVsYXRpb25cbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjb2xvciB2YWx1ZSBhcyBhIGhleCBzdHJpbmdcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByb3BlcnR5IGluc3RlYWRcbiAgICovXG4gIC8vIFRPRE86IGRlcHJlY2F0ZSBpbnRlcm5hbGx5LCB1c2UgcHJvcGVydHkgaW5zdGVhZFxuICBnZXRIZXggKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaGV4XG4gIH1cblxuICBwcml2YXRlIGdldFlpcSAoKTogbnVtYmVyIHtcbiAgICBpZiAoIXRoaXMuX3lpcSkge1xuICAgICAgbGV0IHJnYiA9IHRoaXMuX3JnYlxuICAgICAgdGhpcy5feWlxID0gKHJnYlswXSAqIDI5OSArIHJnYlsxXSAqIDU4NyArIHJnYlsyXSAqIDExNCkgLyAxMDAwXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl95aXFcbiAgfVxuXG4gIHByaXZhdGUgX3RpdGxlVGV4dENvbG9yOiBzdHJpbmdcbiAgcHJpdmF0ZSBfYm9keVRleHRDb2xvcjogc3RyaW5nXG5cbiAgZ2V0IHRpdGxlVGV4dENvbG9yICgpIHtcbiAgICBpZiAodGhpcy5fdGl0bGVUZXh0Q29sb3IpIHtcbiAgICAgIHRoaXMuX3RpdGxlVGV4dENvbG9yID0gdGhpcy5nZXRZaXEoKSA8IDIwMCA/ICcjZmZmJyA6ICcjMDAwJ1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGl0bGVUZXh0Q29sb3JcbiAgfVxuICBnZXQgYm9keVRleHRDb2xvciAoKSB7XG4gICAgaWYgKHRoaXMuX2JvZHlUZXh0Q29sb3IpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0Q29sb3IgPSB0aGlzLmdldFlpcSgpIDwgMTUwID8gJyNmZmYnIDogJyMwMDAnXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ib2R5VGV4dENvbG9yXG4gIH1cbiAgZ2V0VGl0bGVUZXh0Q29sb3IgKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGVUZXh0Q29sb3JcbiAgfVxuXG4gIGdldEJvZHlUZXh0Q29sb3IgKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYm9keVRleHRDb2xvclxuICB9XG5cbiAgY29uc3RydWN0b3IgKHJnYjogVmVjMywgcG9wdWxhdGlvbjogbnVtYmVyKSB7XG4gICAgdGhpcy5fcmdiID0gcmdiXG4gICAgdGhpcy5fcG9wdWxhdGlvbiA9IHBvcHVsYXRpb25cbiAgfVxufVxuIiwiaW1wb3J0IHsgVmVjMyB9IGZyb20gJy4vJ1xuXG5leHBvcnQgY29uc3QgREVMVEFFOTRfRElGRl9TVEFUVVMgPSB7XG4gIE5BOiAwLFxuICBQRVJGRUNUOiAxLFxuICBDTE9TRTogMixcbiAgR09PRDogMTAsXG4gIFNJTUlMQVI6IDUwXG59XG5cbi8qKlxuICogQ29udmVydHMgaGV4IHN0cmluZyB0byBSR0JcbiAqIEBwYXJhbSBoZXggLSBUaGUgaGV4IHZhbHVlIHlvdSB3aXRoIHRvIGdldCB0aGUgUkdCIHZhbHVlIG9mXG4gKiBAcmV0dXJucyBhbiBhcnJheSBpbiB0aGUgb3JkZXIgb2YgYHJlZCwgZ3JlZW4sIGJsdWVgIG51bWVyaWNhbCB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvUmdiIChoZXg6IHN0cmluZyk6IFZlYzMge1xuICBsZXQgbSA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpXG5cbiAgaWYgKCFtKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJyR7aGV4fScgaXMgbm90IGEgdmFsaWQgaGV4IGNvbG9yYClcblxuICByZXR1cm4gW21bMV0sIG1bMl0sIG1bM11dLm1hcCgocykgPT4gcGFyc2VJbnQocywgMTYpKSBhcyBWZWMzXG59XG5cbi8qKlxuICogR2l2ZW4gdmFsdWVzIGZvciBhbiBSR0IgY29sb3IgY29udmVydCB0byBhbmQgcmV0dXJuIGEgdmFsaWQgSEVYIHN0cmluZ1xuICogQHBhcmFtIHIgLSBSZWQgdmFsdWUgaW4gUkdCXG4gKiBAcGFyYW0gZyAtIEdyZWVuIHZhbHVlIGluIFJHQlxuICogQHBhcmFtIGIgLSBCbHVlIHZhbHVlIGluIFJHQlxuICogQHJldHVybnMgYSB2YWxpZCBoZXggc3RyaW5nIHdpdGggcHJlLXBlbmRpbmcgcG91bmQgc2lnblxuICovXG5leHBvcnQgZnVuY3Rpb24gcmdiVG9IZXggKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gJyMnICsgKCgxIDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYikudG9TdHJpbmcoMTYpLnNsaWNlKDEsIDcpXG59XG5cbi8qKlxuICogR2l2ZW4gdmFsdWVzIGZvciBhbiBSR0IgY29sb3IgY29udmVydCB0byBhbmQgcmV0dXJuIGEgdmFsaWQgSFNMIHZhbHVlXG4gKiBAcGFyYW0gciAtIFJlZCB2YWx1ZSBpbiBSR0JcbiAqIEBwYXJhbSBnIC0gR3JlZW4gdmFsdWUgaW4gUkdCXG4gKiBAcGFyYW0gYiAtIEJsdWUgdmFsdWUgaW4gUkdCXG4gKiBAcmV0dXJucyBhbiBhcnJheSBpbiB0aGUgb3JkZXIgb2YgYGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRgIG51bWVyaWNhbCB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJnYlRvSHNsIChyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyKTogVmVjMyB7XG4gIHIgLz0gMjU1XG4gIGcgLz0gMjU1XG4gIGIgLz0gMjU1XG4gIGxldCBtYXggPSBNYXRoLm1heChyLCBnLCBiKVxuICBsZXQgbWluID0gTWF0aC5taW4ociwgZywgYilcbiAgbGV0IGg6IG51bWJlciA9IDBcbiAgbGV0IHM6IG51bWJlciA9IDBcbiAgbGV0IGwgPSAobWF4ICsgbWluKSAvIDJcbiAgaWYgKG1heCAhPT0gbWluKSB7XG4gICAgbGV0IGQgPSBtYXggLSBtaW5cbiAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbilcbiAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgY2FzZSByOlxuICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgZzpcbiAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMlxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBiOlxuICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgaCAvPSA2XG4gIH1cbiAgcmV0dXJuIFtoLCBzLCBsXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsVG9SZ2IgKGg6IG51bWJlciwgczogbnVtYmVyLCBsOiBudW1iZXIpOiBWZWMzIHtcbiAgbGV0IHI6IG51bWJlclxuICBsZXQgZzogbnVtYmVyXG4gIGxldCBiOiBudW1iZXJcblxuICBmdW5jdGlvbiBodWUycmdiIChwOiBudW1iZXIsIHE6IG51bWJlciwgdDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAodCA8IDApIHQgKz0gMVxuICAgIGlmICh0ID4gMSkgdCAtPSAxXG4gICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHRcbiAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcVxuICAgIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNlxuICAgIHJldHVybiBwXG4gIH1cblxuICBpZiAocyA9PT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGxcbiAgfSBlbHNlIHtcbiAgICBsZXQgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gKGwgKiBzKVxuICAgIGxldCBwID0gMiAqIGwgLSBxXG4gICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKVxuICAgIGcgPSBodWUycmdiKHAsIHEsIGgpXG4gICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtICgxIC8gMykpXG4gIH1cbiAgcmV0dXJuIFtcbiAgICByICogMjU1LFxuICAgIGcgKiAyNTUsXG4gICAgYiAqIDI1NVxuICBdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JUb1h5eiAocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcik6IFZlYzMge1xuICByIC89IDI1NVxuICBnIC89IDI1NVxuICBiIC89IDI1NVxuICByID0gciA+IDAuMDQwNDUgPyBNYXRoLnBvdygociArIDAuMDA1KSAvIDEuMDU1LCAyLjQpIDogciAvIDEyLjkyXG4gIGcgPSBnID4gMC4wNDA0NSA/IE1hdGgucG93KChnICsgMC4wMDUpIC8gMS4wNTUsIDIuNCkgOiBnIC8gMTIuOTJcbiAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKGIgKyAwLjAwNSkgLyAxLjA1NSwgMi40KSA6IGIgLyAxMi45MlxuXG4gIHIgKj0gMTAwXG4gIGcgKj0gMTAwXG4gIGIgKj0gMTAwXG5cbiAgbGV0IHggPSByICogMC40MTI0ICsgZyAqIDAuMzU3NiArIGIgKiAwLjE4MDVcbiAgbGV0IHkgPSByICogMC4yMTI2ICsgZyAqIDAuNzE1MiArIGIgKiAwLjA3MjJcbiAgbGV0IHogPSByICogMC4wMTkzICsgZyAqIDAuMTE5MiArIGIgKiAwLjk1MDVcblxuICByZXR1cm4gW3gsIHksIHpdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB4eXpUb0NJRUxhYiAoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IFZlYzMge1xuICBsZXQgUkVGX1ggPSA5NS4wNDdcbiAgbGV0IFJFRl9ZID0gMTAwXG4gIGxldCBSRUZfWiA9IDEwOC44ODNcblxuICB4IC89IFJFRl9YXG4gIHkgLz0gUkVGX1lcbiAgeiAvPSBSRUZfWlxuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiA3Ljc4NyAqIHggKyAxNiAvIDExNlxuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMSAvIDMpIDogNy43ODcgKiB5ICsgMTYgLyAxMTZcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEgLyAzKSA6IDcuNzg3ICogeiArIDE2IC8gMTE2XG5cbiAgbGV0IEwgPSAxMTYgKiB5IC0gMTZcbiAgbGV0IGEgPSA1MDAgKiAoeCAtIHkpXG4gIGxldCBiID0gMjAwICogKHkgLSB6KVxuXG4gIHJldHVybiBbTCwgYSwgYl1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYlRvQ0lFTGFiIChyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyKTogVmVjMyB7XG4gIGxldCBbeCwgeSwgel0gPSByZ2JUb1h5eihyLCBnLCBiKVxuICByZXR1cm4geHl6VG9DSUVMYWIoeCwgeSwgeilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbHRhRTk0IChsYWIxOiBWZWMzLCBsYWIyOiBWZWMzKTogbnVtYmVyIHtcbiAgbGV0IFdFSUdIVF9MID0gMVxuICBsZXQgV0VJR0hUX0MgPSAxXG4gIGxldCBXRUlHSFRfSCA9IDFcblxuICBsZXQgW0wxLCBhMSwgYjFdID0gbGFiMVxuICBsZXQgW0wyLCBhMiwgYjJdID0gbGFiMlxuICBsZXQgZEwgPSBMMSAtIEwyXG4gIGxldCBkYSA9IGExIC0gYTJcbiAgbGV0IGRiID0gYjEgLSBiMlxuXG4gIGxldCB4QzEgPSBNYXRoLnNxcnQoYTEgKiBhMSArIGIxICogYjEpXG4gIGxldCB4QzIgPSBNYXRoLnNxcnQoYTIgKiBhMiArIGIyICogYjIpXG5cbiAgbGV0IHhETCA9IEwyIC0gTDFcbiAgbGV0IHhEQyA9IHhDMiAtIHhDMVxuICBsZXQgeERFID0gTWF0aC5zcXJ0KGRMICogZEwgKyBkYSAqIGRhICsgZGIgKiBkYilcblxuICBsZXQgeERIID0gKE1hdGguc3FydCh4REUpID4gTWF0aC5zcXJ0KE1hdGguYWJzKHhETCkpICsgTWF0aC5zcXJ0KE1hdGguYWJzKHhEQykpKVxuICAgID8gTWF0aC5zcXJ0KHhERSAqIHhERSAtIHhETCAqIHhETCAtIHhEQyAqIHhEQylcbiAgICA6IDBcblxuICBsZXQgeFNDID0gMSArIDAuMDQ1ICogeEMxXG4gIGxldCB4U0ggPSAxICsgMC4wMTUgKiB4QzFcblxuICB4REwgLz0gV0VJR0hUX0xcbiAgeERDIC89IFdFSUdIVF9DICogeFNDXG4gIHhESCAvPSBXRUlHSFRfSCAqIHhTSFxuXG4gIHJldHVybiBNYXRoLnNxcnQoeERMICogeERMICsgeERDICogeERDICsgeERIICogeERIKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiRGlmZiAocmdiMTogVmVjMywgcmdiMjogVmVjMyk6IG51bWJlciB7XG4gIGxldCBsYWIxID0gcmdiVG9DSUVMYWIuYXBwbHkodW5kZWZpbmVkLCByZ2IxKVxuICBsZXQgbGFiMiA9IHJnYlRvQ0lFTGFiLmFwcGx5KHVuZGVmaW5lZCwgcmdiMilcbiAgcmV0dXJuIGRlbHRhRTk0KGxhYjEsIGxhYjIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXhEaWZmIChoZXgxOiBzdHJpbmcsIGhleDI6IHN0cmluZyk6IG51bWJlciB7XG4gIGxldCByZ2IxID0gaGV4VG9SZ2IoaGV4MSlcbiAgbGV0IHJnYjIgPSBoZXhUb1JnYihoZXgyKVxuXG4gIHJldHVybiByZ2JEaWZmKHJnYjEsIHJnYjIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xvckRpZmZTdGF0dXMgKGQ6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChkIDwgREVMVEFFOTRfRElGRl9TVEFUVVMuTkEpIHtcbiAgICByZXR1cm4gJ04vQSdcbiAgfVxuICAvLyBOb3QgcGVyY2VwdGlibGUgYnkgaHVtYW4gZXllc1xuICBpZiAoZCA8PSBERUxUQUU5NF9ESUZGX1NUQVRVUy5QRVJGRUNUKSB7XG4gICAgcmV0dXJuICdQZXJmZWN0J1xuICB9XG4gIC8vIFBlcmNlcHRpYmxlIHRocm91Z2ggY2xvc2Ugb2JzZXJ2YXRpb25cbiAgaWYgKGQgPD0gREVMVEFFOTRfRElGRl9TVEFUVVMuQ0xPU0UpIHtcbiAgICByZXR1cm4gJ0Nsb3NlJ1xuICB9XG4gIC8vIFBlcmNlcHRpYmxlIGF0IGEgZ2xhbmNlXG4gIGlmIChkIDw9IERFTFRBRTk0X0RJRkZfU1RBVFVTLkdPT0QpIHtcbiAgICByZXR1cm4gJ0dvb2QnXG4gIH1cbiAgLy8gQ29sb3JzIGFyZSBtb3JlIHNpbWlsYXIgdGhhbiBvcHBvc2l0ZVxuICBpZiAoZCA8IERFTFRBRTk0X0RJRkZfU1RBVFVTLlNJTUlMQVIpIHtcbiAgICByZXR1cm4gJ1NpbWlsYXInXG4gIH1cbiAgcmV0dXJuICdXcm9uZydcblxufVxuIiwiaW1wb3J0IFZpYnJhbnQgZnJvbSAnLi9jb25maWcnXG5pbXBvcnQgQnJvd3NlckltYWdlIGZyb20gJ0B2aWJyYW50L2ltYWdlLWJyb3dzZXInXG5cblZpYnJhbnQuRGVmYXVsdE9wdHMuSW1hZ2VDbGFzcyA9IEJyb3dzZXJJbWFnZVxuXG5leHBvcnQgPSBWaWJyYW50XG4iLCJpbXBvcnQgVmlicmFudCBmcm9tICdAdmlicmFudC9jb3JlJ1xuXG5WaWJyYW50LkRlZmF1bHRPcHRzLnF1YW50aXplciA9ICdtbWNxJ1xuVmlicmFudC5EZWZhdWx0T3B0cy5nZW5lcmF0b3JzID0gWydkZWZhdWx0J11cblZpYnJhbnQuRGVmYXVsdE9wdHMuZmlsdGVycyA9IFsnZGVmYXVsdCddXG5cbmV4cG9ydCBkZWZhdWx0IFZpYnJhbnRcbiIsImltcG9ydCB7IFBhbGV0dGUsIFN3YXRjaCwgRmlsdGVyIH0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5pbXBvcnQgeyBJbWFnZSwgSW1hZ2VDbGFzcywgSW1hZ2VTb3VyY2UsIEltYWdlT3B0aW9ucyB9IGZyb20gJ0B2aWJyYW50L2ltYWdlJ1xuaW1wb3J0IHsgUXVhbnRpemVyLCBRdWFudGl6ZXJPcHRpb25zIH0gZnJvbSAnQHZpYnJhbnQvcXVhbnRpemVyJ1xuaW1wb3J0IHsgR2VuZXJhdG9yIH0gZnJvbSAnQHZpYnJhbnQvZ2VuZXJhdG9yJ1xuaW1wb3J0IHsgU3RhZ2VPcHRpb25zLCBQcm9jZXNzT3B0aW9ucyB9IGZyb20gJy4vcGlwZWxpbmUnXG5pbXBvcnQgeyBhc3NpZ25EZWVwIH0gZnJvbSAnLi91dGlscydcblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zIGV4dGVuZHMgSW1hZ2VPcHRpb25zLCBRdWFudGl6ZXJPcHRpb25zIHtcbiAgdXNlV29ya2VyOiBib29sZWFuXG4gIEltYWdlQ2xhc3M6IEltYWdlQ2xhc3NcbiAgcXVhbnRpemVyOiBzdHJpbmcgfCBTdGFnZU9wdGlvbnNcbiAgZ2VuZXJhdG9yczogKHN0cmluZyB8IFN0YWdlT3B0aW9ucylbXVxuICBmaWx0ZXJzOiBzdHJpbmdbXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRQcm9jZXNzT3B0aW9ucyAob3B0czogT3B0aW9ucywgb3ZlcnJpZGU/OiBQYXJ0aWFsPFByb2Nlc3NPcHRpb25zPik6IFByb2Nlc3NPcHRpb25zIHtcbiAgbGV0IHsgY29sb3JDb3VudCwgcXVhbnRpemVyLCBnZW5lcmF0b3JzLCBmaWx0ZXJzIH0gPSBvcHRzXG4gIC8vIE1lcmdlIHdpdGggY29tbW9uIHF1YW50aXplciBvcHRpb25zXG4gIGxldCBjb21tb25RdWFudGl6ZXJPcHRzID0geyBjb2xvckNvdW50IH1cbiAgbGV0IHEgPSB0eXBlb2YgcXVhbnRpemVyID09PSAnc3RyaW5nJ1xuICAgID8geyBuYW1lOiBxdWFudGl6ZXIsIG9wdGlvbnM6IHt9IH1cbiAgICA6IHF1YW50aXplclxuICBxLm9wdGlvbnMgPSBhc3NpZ25EZWVwKHt9LCBjb21tb25RdWFudGl6ZXJPcHRzLCBxLm9wdGlvbnMpXG5cbiAgcmV0dXJuIGFzc2lnbkRlZXAoe30sIHtcbiAgICBxdWFudGl6ZXI6IHEsXG4gICAgZ2VuZXJhdG9ycyxcbiAgICBmaWx0ZXJzXG4gIH0sIG92ZXJyaWRlKVxufVxuIiwiaW1wb3J0IHtcbiAgT3B0aW9uc1xufSBmcm9tICcuL29wdGlvbnMnXG5pbXBvcnQge1xuICBDYWxsYmFja1xufSBmcm9tICdAdmlicmFudC90eXBlcydcbmltcG9ydCB7XG4gIEltYWdlQ2xhc3MsXG4gIEltYWdlU291cmNlXG59IGZyb20gJ0B2aWJyYW50L2ltYWdlJ1xuXG5pbXBvcnQge1xuICBGaWx0ZXIsXG4gIFBhbGV0dGVcbn0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5pbXBvcnQgVmlicmFudCBmcm9tICcuLydcbmltcG9ydCB7IGFzc2lnbkRlZXAgfSBmcm9tICcuL3V0aWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWlsZGVyIHtcbiAgcHJpdmF0ZSBfc3JjOiBJbWFnZVNvdXJjZVxuICBwcml2YXRlIF9vcHRzOiBQYXJ0aWFsPE9wdGlvbnM+XG4gIGNvbnN0cnVjdG9yIChzcmM6IEltYWdlU291cmNlLCBvcHRzOiBQYXJ0aWFsPE9wdGlvbnM+ID0ge30pIHtcbiAgICB0aGlzLl9zcmMgPSBzcmNcbiAgICB0aGlzLl9vcHRzID0gYXNzaWduRGVlcCh7fSwgVmlicmFudC5EZWZhdWx0T3B0cywgb3B0cylcbiAgfVxuXG4gIG1heENvbG9yQ291bnQgKG46IG51bWJlcik6IEJ1aWxkZXIge1xuICAgIHRoaXMuX29wdHMuY29sb3JDb3VudCA9IG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbWF4RGltZW5zaW9uIChkOiBudW1iZXIpOiBCdWlsZGVyIHtcbiAgICB0aGlzLl9vcHRzLm1heERpbWVuc2lvbiA9IGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYWRkRmlsdGVyIChuYW1lOiBzdHJpbmcpOiBCdWlsZGVyIHtcbiAgICBpZiAoIXRoaXMuX29wdHMuZmlsdGVycykge1xuICAgICAgdGhpcy5fb3B0cy5maWx0ZXJzID0gW25hbWVdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wdHMuZmlsdGVycy5wdXNoKG5hbWUpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZW1vdmVGaWx0ZXIgKG5hbWU6IHN0cmluZyk6IEJ1aWxkZXIge1xuICAgIGlmICh0aGlzLl9vcHRzLmZpbHRlcnMpIHtcbiAgICAgIGxldCBpID0gdGhpcy5fb3B0cy5maWx0ZXJzLmluZGV4T2YobmFtZSlcbiAgICAgIGlmIChpID4gMCkgdGhpcy5fb3B0cy5maWx0ZXJzLnNwbGljZShpKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY2xlYXJGaWx0ZXJzICgpOiBCdWlsZGVyIHtcbiAgICB0aGlzLl9vcHRzLmZpbHRlcnMgPSBbXVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBxdWFsaXR5IChxOiBudW1iZXIpOiBCdWlsZGVyIHtcbiAgICB0aGlzLl9vcHRzLnF1YWxpdHkgPSBxXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHVzZUltYWdlQ2xhc3MgKGltYWdlQ2xhc3M6IEltYWdlQ2xhc3MpOiBCdWlsZGVyIHtcbiAgICB0aGlzLl9vcHRzLkltYWdlQ2xhc3MgPSBpbWFnZUNsYXNzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHVzZUdlbmVyYXRvciAoZ2VuZXJhdG9yOiBzdHJpbmcsIG9wdGlvbnM/OiBhbnkpOiBCdWlsZGVyIHtcbiAgICBpZiAoIXRoaXMuX29wdHMuZ2VuZXJhdG9ycykgdGhpcy5fb3B0cy5nZW5lcmF0b3JzID0gW11cbiAgICB0aGlzLl9vcHRzLmdlbmVyYXRvcnMucHVzaChvcHRpb25zID8geyBuYW1lOiBnZW5lcmF0b3IsIG9wdGlvbnMgfSA6IGdlbmVyYXRvcilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdXNlUXVhbnRpemVyIChxdWFudGl6ZXI6IHN0cmluZywgb3B0aW9ucz86IGFueSk6IEJ1aWxkZXIge1xuICAgIHRoaXMuX29wdHMucXVhbnRpemVyID0gb3B0aW9ucyA/IHsgbmFtZTogcXVhbnRpemVyLCBvcHRpb25zIH0gOiBxdWFudGl6ZXJcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYnVpbGQgKCk6IFZpYnJhbnQge1xuICAgIHJldHVybiBuZXcgVmlicmFudCh0aGlzLl9zcmMsIHRoaXMuX29wdHMpXG4gIH1cblxuICBnZXRQYWxldHRlIChjYj86IENhbGxiYWNrPFBhbGV0dGU+KTogUHJvbWlzZTxQYWxldHRlPiB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGQoKS5nZXRQYWxldHRlKGNiKVxuICB9XG4gIGdldFN3YXRjaGVzIChjYj86IENhbGxiYWNrPFBhbGV0dGU+KTogUHJvbWlzZTxQYWxldHRlPiB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGQoKS5nZXRQYWxldHRlKGNiKVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBJbWFnZU9wdGlvbnMsXG4gIEltYWdlRGF0YSBhcyBWaWJyYW50SW1hZ2VEYXRhLFxuICBJbWFnZVNvdXJjZSxcbiAgSW1hZ2VDYWxsYmFjayxcbiAgSW1hZ2VCYXNlXG59IGZyb20gJ0B2aWJyYW50L2ltYWdlJ1xuXG5mdW5jdGlvbiBpc1JlbGF0aXZlVXJsICh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBsZXQgdSA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKVxuICByZXR1cm4gdS5wcm90b2NvbCA9PT0gbG9jYXRpb24ucHJvdG9jb2wgJiZcbiAgICB1Lmhvc3QgPT09IGxvY2F0aW9uLmhvc3QgJiZcbiAgICB1LnBvcnQgPT09IGxvY2F0aW9uLnBvcnRcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JpZ2luIChhOiBzdHJpbmcsIGI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBsZXQgdWEgPSBuZXcgVVJMKGEpXG4gIGxldCB1YiA9IG5ldyBVUkwoYilcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TZWN1cml0eS9TYW1lLW9yaWdpbl9wb2xpY3lcbiAgcmV0dXJuIChcbiAgICB1YS5wcm90b2NvbCA9PT0gdWIucHJvdG9jb2wgJiZcbiAgICB1YS5ob3N0bmFtZSA9PT0gdWIuaG9zdG5hbWUgJiZcbiAgICB1YS5wb3J0ID09PSB1Yi5wb3J0XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJvd3NlckltYWdlIGV4dGVuZHMgSW1hZ2VCYXNlIHtcbiAgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnRcbiAgcHJpdmF0ZSBfY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxuICBwcml2YXRlIF9jb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgcHJpdmF0ZSBfd2lkdGg6IG51bWJlclxuICBwcml2YXRlIF9oZWlnaHQ6IG51bWJlclxuICBwcml2YXRlIF9pbml0Q2FudmFzICgpOiB2b2lkIHtcbiAgICBjb25zdCBpbWcgPSB0aGlzLmltYWdlXG4gICAgY29uc3QgY2FudmFzID0gKHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKVxuICAgIGNvbnN0IGNvbnRleHQgPSAoY2FudmFzLmdldENvbnRleHQoJzJkJykpXG5cbiAgICBpZiAoIWNvbnRleHQpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBjYW52YXMgY29udGV4dCcpXG5cbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dFxuXG4gICAgY2FudmFzLmNsYXNzTmFtZSA9ICdAdmlicmFudC9jYW52YXMnXG4gICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcblxuICAgIHRoaXMuX3dpZHRoID0gY2FudmFzLndpZHRoID0gaW1nLndpZHRoXG4gICAgdGhpcy5faGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHRcblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMClcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKVxuICB9XG4gIGxvYWQgKGltYWdlOiBJbWFnZVNvdXJjZSk6IFByb21pc2U8SW1hZ2VCYXNlPiB7XG4gICAgbGV0IGltZzogSFRNTEltYWdlRWxlbWVudFxuICAgIGxldCBzcmM6IHN0cmluZ1xuICAgIGlmICh0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICAgICAgc3JjID0gaW1hZ2VcblxuICAgICAgaWYgKCFpc1JlbGF0aXZlVXJsKHNyYykgJiYgIWlzU2FtZU9yaWdpbih3aW5kb3cubG9jYXRpb24uaHJlZiwgc3JjKSkge1xuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJ1xuICAgICAgfVxuXG4gICAgICBpbWcuc3JjID0gc3JjXG4gICAgfSBlbHNlIGlmIChpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgIGltZyA9IGltYWdlXG4gICAgICBzcmMgPSBpbWFnZS5zcmNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgRXJyb3IoYENhbm5vdCBsb2FkIGJ1ZmZlciBhcyBhbiBpbWFnZSBpbiBicm93c2VyYClcbiAgICAgIClcbiAgICB9XG4gICAgdGhpcy5pbWFnZSA9IGltZ1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPEltYWdlQmFzZT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IG9uSW1hZ2VMb2FkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9pbml0Q2FudmFzKClcbiAgICAgICAgcmVzb2x2ZSh0aGlzKVxuICAgICAgfVxuXG4gICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgIC8vIEFscmVhZHkgbG9hZGVkXG4gICAgICAgIG9uSW1hZ2VMb2FkKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltZy5vbmxvYWQgPSBvbkltYWdlTG9hZFxuICAgICAgICBpbWcub25lcnJvciA9IGUgPT4gcmVqZWN0KG5ldyBFcnJvcihgRmFpbCB0byBsb2FkIGltYWdlOiAke3NyY31gKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGNsZWFyICgpOiB2b2lkIHtcbiAgICB0aGlzLl9jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KVxuICB9XG4gIHVwZGF0ZSAoaW1hZ2VEYXRhOiBWaWJyYW50SW1hZ2VEYXRhKTogdm9pZCB7XG4gICAgdGhpcy5fY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhIGFzIEltYWdlRGF0YSwgMCwgMClcbiAgfVxuICBnZXRXaWR0aCAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGhcbiAgfVxuICBnZXRIZWlnaHQgKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodFxuICB9XG4gIHJlc2l6ZSAodGFyZ2V0V2lkdGg6IG51bWJlciwgdGFyZ2V0SGVpZ2h0OiBudW1iZXIsIHJhdGlvOiBudW1iZXIpOiB2b2lkIHtcbiAgICBsZXQgeyBfY2FudmFzOiBjYW52YXMsIF9jb250ZXh0OiBjb250ZXh0LCBpbWFnZTogaW1nIH0gPSB0aGlzXG5cbiAgICB0aGlzLl93aWR0aCA9IGNhbnZhcy53aWR0aCA9IHRhcmdldFdpZHRoXG4gICAgdGhpcy5faGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IHRhcmdldEhlaWdodFxuXG4gICAgY29udGV4dC5zY2FsZShyYXRpbywgcmF0aW8pXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKVxuICB9XG4gIGdldFBpeGVsQ291bnQgKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoICogdGhpcy5faGVpZ2h0XG4gIH1cbiAgZ2V0SW1hZ2VEYXRhICgpOiBJbWFnZURhdGEge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KVxuICB9XG4gIHJlbW92ZSAoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2NhbnZhcyAmJiB0aGlzLl9jYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5fY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY2FudmFzKVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IFZpYnJhbnQgPSByZXF1aXJlKCcuL2Jyb3dzZXInKVxuaW1wb3J0IHBpcGVsaW5lIGZyb20gJy4vcGlwZWxpbmUnXG5cblZpYnJhbnQudXNlKHBpcGVsaW5lKVxuXG5leHBvcnQgPSBWaWJyYW50XG4iLCJpbXBvcnQgTU1DUSBmcm9tICdAdmlicmFudC9xdWFudGl6ZXItbW1jcSdcbmltcG9ydCBEZWZhdWx0R2VuZXJhdG9yIGZyb20gJ0B2aWJyYW50L2dlbmVyYXRvci1kZWZhdWx0J1xuXG5pbXBvcnQgeyBCYXNpY1BpcGVsaW5lIH0gZnJvbSAnQHZpYnJhbnQvY29yZS9saWIvcGlwZWxpbmUnXG5cbmNvbnN0IHBpcGVsaW5lID0gbmV3IEJhc2ljUGlwZWxpbmUoKVxuICAuZmlsdGVyLnJlZ2lzdGVyKCdkZWZhdWx0JywgKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIsIGE6IG51bWJlcikgPT5cbiAgICBhID49IDEyNVxuICAgICYmICEociA+IDI1MCAmJiBnID4gMjUwICYmIGIgPiAyNTApXG4gIClcbiAgLnF1YW50aXplci5yZWdpc3RlcignbW1jcScsIE1NQ1EpXG4gIC5nZW5lcmF0b3IucmVnaXN0ZXIoJ2RlZmF1bHQnLCBEZWZhdWx0R2VuZXJhdG9yKVxuXG5leHBvcnQgZGVmYXVsdCBwaXBlbGluZVxuIiwiaW1wb3J0IHsgUXVhbnRpemVyLCBRdWFudGl6ZXJPcHRpb25zIH0gZnJvbSAnQHZpYnJhbnQvcXVhbnRpemVyJ1xuaW1wb3J0IHtcbiAgUGl4ZWxzXG59IGZyb20gJ0B2aWJyYW50L2ltYWdlJ1xuaW1wb3J0IHsgRmlsdGVyLCBTd2F0Y2ggfSBmcm9tICdAdmlicmFudC9jb2xvcidcbmltcG9ydCBWQm94IGZyb20gJy4vdmJveCdcbmltcG9ydCBQUXVldWUgZnJvbSAnLi9wcXVldWUnXG5cbmNvbnN0IGZyYWN0QnlQb3B1bGF0aW9ucyA9IDAuNzVcblxuZnVuY3Rpb24gX3NwbGl0Qm94ZXMgKHBxOiBQUXVldWU8VkJveD4sIHRhcmdldDogbnVtYmVyKTogdm9pZCB7XG4gIGxldCBsYXN0U2l6ZSA9IHBxLnNpemUoKVxuICB3aGlsZSAocHEuc2l6ZSgpIDwgdGFyZ2V0KSB7XG4gICAgbGV0IHZib3ggPSBwcS5wb3AoKVxuXG4gICAgaWYgKHZib3ggJiYgdmJveC5jb3VudCgpID4gMCkge1xuICAgICAgbGV0IFt2Ym94MSwgdmJveDJdID0gdmJveC5zcGxpdCgpXG5cbiAgICAgIHBxLnB1c2godmJveDEpXG4gICAgICBpZiAodmJveDIgJiYgdmJveDIuY291bnQoKSA+IDApIHBxLnB1c2godmJveDIpXG5cbiAgICAgIC8vIE5vIG1vcmUgbmV3IGJveGVzLCBjb252ZXJnZWRcbiAgICAgIGlmIChwcS5zaXplKCkgPT09IGxhc3RTaXplKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0U2l6ZSA9IHBxLnNpemUoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBNTUNRID0gKHBpeGVsczogUGl4ZWxzLCBvcHRzOiBRdWFudGl6ZXJPcHRpb25zKTogQXJyYXk8U3dhdGNoPiA9PiB7XG4gIGlmIChwaXhlbHMubGVuZ3RoID09PSAwIHx8IG9wdHMuY29sb3JDb3VudCA8IDIgfHwgb3B0cy5jb2xvckNvdW50ID4gMjU2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBNTUNRIHBhcmFtZXRlcnMnKVxuICB9XG5cbiAgbGV0IHZib3ggPSBWQm94LmJ1aWxkKHBpeGVscylcbiAgbGV0IGNvbG9yQ291bnQgPSB2Ym94Lmhpc3RvZ3JhbS5jb2xvckNvdW50XG4gIGxldCBwcSA9IG5ldyBQUXVldWU8VkJveD4oKGEsIGIpID0+IGEuY291bnQoKSAtIGIuY291bnQoKSlcblxuICBwcS5wdXNoKHZib3gpXG5cbiAgLy8gZmlyc3Qgc2V0IG9mIGNvbG9ycywgc29ydGVkIGJ5IHBvcHVsYXRpb25cbiAgX3NwbGl0Qm94ZXMocHEsIGZyYWN0QnlQb3B1bGF0aW9ucyAqIG9wdHMuY29sb3JDb3VudClcblxuICAvLyBSZS1vcmRlclxuICBsZXQgcHEyID0gbmV3IFBRdWV1ZTxWQm94PigoYSwgYikgPT4gYS5jb3VudCgpICogYS52b2x1bWUoKSAtIGIuY291bnQoKSAqIGIudm9sdW1lKCkpXG4gIHBxMi5jb250ZW50cyA9IHBxLmNvbnRlbnRzXG5cbiAgLy8gbmV4dCBzZXQgLSBnZW5lcmF0ZSB0aGUgbWVkaWFuIGN1dHMgdXNpbmcgdGhlIChucGl4ICogdm9sKSBzb3J0aW5nLlxuICBfc3BsaXRCb3hlcyhwcTIsIG9wdHMuY29sb3JDb3VudCAtIHBxMi5zaXplKCkpXG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBhY3R1YWwgY29sb3JzXG4gIHJldHVybiBnZW5lcmF0ZVN3YXRjaGVzKHBxMilcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVTd2F0Y2hlcyAocHE6IFBRdWV1ZTxWQm94Pikge1xuICBsZXQgc3dhdGNoZXM6IFN3YXRjaFtdID0gW11cbiAgd2hpbGUgKHBxLnNpemUoKSkge1xuICAgIGxldCB2ID0gcHEucG9wKCkhXG4gICAgbGV0IGNvbG9yID0gdi5hdmcoKVxuICAgIGxldCBbciwgZywgYl0gPSBjb2xvclxuICAgIHN3YXRjaGVzLnB1c2gobmV3IFN3YXRjaChjb2xvciwgdi5jb3VudCgpKSlcbiAgfVxuICByZXR1cm4gc3dhdGNoZXNcbn1cblxuZXhwb3J0IGRlZmF1bHQgTU1DUVxuIiwiaW1wb3J0IHsgVmVjMywgRmlsdGVyIH0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5pbXBvcnQgeyBQaXhlbHMgfSBmcm9tICdAdmlicmFudC9pbWFnZSdcbmltcG9ydCBIaXN0b2dyYW0gZnJvbSAnQHZpYnJhbnQvaW1hZ2UvbGliL2hpc3RvZ3JhbSdcbmV4cG9ydCBpbnRlcmZhY2UgRGltZW5zaW9uIHtcbiAgcjE6IG51bWJlclxuICByMjogbnVtYmVyXG4gIGcxOiBudW1iZXJcbiAgZzI6IG51bWJlclxuICBiMTogbnVtYmVyXG4gIGIyOiBudW1iZXJcbiAgW2Q6IHN0cmluZ106IG51bWJlclxufVxuXG5jb25zdCBTSUdCSVRTID0gNVxuY29uc3QgUlNISUZUID0gOCAtIFNJR0JJVFNcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVkJveCB7XG4gIHN0YXRpYyBidWlsZCAocGl4ZWxzOiBQaXhlbHMpOiBWQm94IHtcbiAgICBsZXQgaCA9IG5ldyBIaXN0b2dyYW0ocGl4ZWxzLCB7IHNpZ0JpdHM6IFNJR0JJVFMgfSlcbiAgICBsZXQgeyBybWluLCBybWF4LCBnbWluLCBnbWF4LCBibWluLCBibWF4IH0gPSBoXG4gICAgcmV0dXJuIG5ldyBWQm94KHJtaW4sIHJtYXgsIGdtaW4sIGdtYXgsIGJtaW4sIGJtYXgsIGgpXG4gIH1cblxuICBkaW1lbnNpb246IERpbWVuc2lvblxuXG4gIHByaXZhdGUgX3ZvbHVtZSA9IC0xXG4gIHByaXZhdGUgX2F2ZzogVmVjMyB8IG51bGxcbiAgcHJpdmF0ZSBfY291bnQgPSAtMVxuXG4gIGNvbnN0cnVjdG9yIChcbiAgICByMTogbnVtYmVyLCByMjogbnVtYmVyLFxuICAgIGcxOiBudW1iZXIsIGcyOiBudW1iZXIsXG4gICAgYjE6IG51bWJlciwgYjI6IG51bWJlcixcbiAgICBwdWJsaWMgaGlzdG9ncmFtOiBIaXN0b2dyYW1cbiAgKSB7XG4gICAgLy8gTk9URTogZGltZW5zaW9uIHdpbGwgYmUgbXV0YXRlZCBieSBzcGxpdCBvcGVyYXRpb24uXG4gICAgLy8gICAgICAgSXQgbXVzdCBiZSBzcGVjaWZpZWQgZXhwbGljaXRseSwgbm90IGZyb20gaGlzdG9ncmFtXG4gICAgdGhpcy5kaW1lbnNpb24gPSB7IHIxLCByMiwgZzEsIGcyLCBiMSwgYjIgfVxuICB9XG5cbiAgaW52YWxpZGF0ZSAoKTogdm9pZCB7XG4gICAgdGhpcy5fdm9sdW1lID0gdGhpcy5fY291bnQgPSAtMVxuICAgIHRoaXMuX2F2ZyA9IG51bGxcbiAgfVxuXG4gIHZvbHVtZSAoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5fdm9sdW1lIDwgMCkge1xuICAgICAgbGV0IHsgcjEsIHIyLCBnMSwgZzIsIGIxLCBiMiB9ID0gdGhpcy5kaW1lbnNpb25cbiAgICAgIHRoaXMuX3ZvbHVtZSA9IChyMiAtIHIxICsgMSkgKiAoZzIgLSBnMSArIDEpICogKGIyIC0gYjEgKyAxKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdm9sdW1lXG4gIH1cblxuICBjb3VudCAoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5fY291bnQgPCAwKSB7XG4gICAgICBsZXQgeyBoaXN0LCBnZXRDb2xvckluZGV4IH0gPSB0aGlzLmhpc3RvZ3JhbVxuICAgICAgbGV0IHsgcjEsIHIyLCBnMSwgZzIsIGIxLCBiMiB9ID0gdGhpcy5kaW1lbnNpb25cbiAgICAgIGxldCBjID0gMFxuXG4gICAgICBmb3IgKGxldCByID0gcjE7IHIgPD0gcjI7IHIrKykge1xuICAgICAgICBmb3IgKGxldCBnID0gZzE7IGcgPD0gZzI7IGcrKykge1xuICAgICAgICAgIGZvciAobGV0IGIgPSBiMTsgYiA8PSBiMjsgYisrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBnZXRDb2xvckluZGV4KHIsIGcsIGIpXG4gICAgICAgICAgICBjICs9IGhpc3RbaW5kZXhdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jb3VudCA9IGNcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NvdW50XG4gIH1cblxuICBjbG9uZSAoKTogVkJveCB7XG4gICAgbGV0IHsgaGlzdG9ncmFtIH0gPSB0aGlzXG4gICAgbGV0IHsgcjEsIHIyLCBnMSwgZzIsIGIxLCBiMiB9ID0gdGhpcy5kaW1lbnNpb25cbiAgICByZXR1cm4gbmV3IFZCb3gocjEsIHIyLCBnMSwgZzIsIGIxLCBiMiwgaGlzdG9ncmFtKVxuICB9XG5cbiAgYXZnICgpOiBWZWMzIHtcbiAgICBpZiAoIXRoaXMuX2F2Zykge1xuICAgICAgbGV0IHsgaGlzdCwgZ2V0Q29sb3JJbmRleCB9ID0gdGhpcy5oaXN0b2dyYW1cbiAgICAgIGxldCB7IHIxLCByMiwgZzEsIGcyLCBiMSwgYjIgfSA9IHRoaXMuZGltZW5zaW9uXG4gICAgICBsZXQgbnRvdCA9IDBcbiAgICAgIGxldCBtdWx0ID0gMSA8PCAoOCAtIFNJR0JJVFMpXG4gICAgICBsZXQgcnN1bTogbnVtYmVyXG4gICAgICBsZXQgZ3N1bTogbnVtYmVyXG4gICAgICBsZXQgYnN1bTogbnVtYmVyXG4gICAgICByc3VtID0gZ3N1bSA9IGJzdW0gPSAwXG5cbiAgICAgIGZvciAobGV0IHIgPSByMTsgciA8PSByMjsgcisrKSB7XG4gICAgICAgIGZvciAobGV0IGcgPSBnMTsgZyA8PSBnMjsgZysrKSB7XG4gICAgICAgICAgZm9yIChsZXQgYiA9IGIxOyBiIDw9IGIyOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGdldENvbG9ySW5kZXgociwgZywgYilcbiAgICAgICAgICAgIGxldCBoID0gaGlzdFtpbmRleF1cbiAgICAgICAgICAgIG50b3QgKz0gaFxuICAgICAgICAgICAgcnN1bSArPSAoaCAqIChyICsgMC41KSAqIG11bHQpXG4gICAgICAgICAgICBnc3VtICs9IChoICogKGcgKyAwLjUpICogbXVsdClcbiAgICAgICAgICAgIGJzdW0gKz0gKGggKiAoYiArIDAuNSkgKiBtdWx0KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG50b3QpIHtcbiAgICAgICAgdGhpcy5fYXZnID0gW1xuICAgICAgICAgIH5+KHJzdW0gLyBudG90KSxcbiAgICAgICAgICB+fihnc3VtIC8gbnRvdCksXG4gICAgICAgICAgfn4oYnN1bSAvIG50b3QpXG4gICAgICAgIF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2F2ZyA9IFtcbiAgICAgICAgICB+fihtdWx0ICogKHIxICsgcjIgKyAxKSAvIDIpLFxuICAgICAgICAgIH5+KG11bHQgKiAoZzEgKyBnMiArIDEpIC8gMiksXG4gICAgICAgICAgfn4obXVsdCAqIChiMSArIGIyICsgMSkgLyAyKVxuICAgICAgICBdXG4gICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2F2Z1xuICB9XG5cbiAgY29udGFpbnMgKHJnYjogVmVjMyk6IGJvb2xlYW4ge1xuICAgIGxldCBbciwgZywgYl0gPSByZ2JcbiAgICBsZXQgeyByMSwgcjIsIGcxLCBnMiwgYjEsIGIyIH0gPSB0aGlzLmRpbWVuc2lvblxuICAgIHIgPj49IFJTSElGVFxuICAgIGcgPj49IFJTSElGVFxuICAgIGIgPj49IFJTSElGVFxuXG4gICAgcmV0dXJuIHIgPj0gcjEgJiYgciA8PSByMlxuICAgICAgJiYgZyA+PSBnMSAmJiBnIDw9IGcyXG4gICAgICAmJiBiID49IGIxICYmIGIgPD0gYjJcbiAgfVxuXG4gIHNwbGl0ICgpOiBWQm94W10ge1xuICAgIGxldCB7IGhpc3QsIGdldENvbG9ySW5kZXggfSA9IHRoaXMuaGlzdG9ncmFtXG4gICAgbGV0IHsgcjEsIHIyLCBnMSwgZzIsIGIxLCBiMiB9ID0gdGhpcy5kaW1lbnNpb25cbiAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50KClcbiAgICBpZiAoIWNvdW50KSByZXR1cm4gW11cbiAgICBpZiAoY291bnQgPT09IDEpIHJldHVybiBbdGhpcy5jbG9uZSgpXVxuICAgIGxldCBydyA9IHIyIC0gcjEgKyAxXG4gICAgbGV0IGd3ID0gZzIgLSBnMSArIDFcbiAgICBsZXQgYncgPSBiMiAtIGIxICsgMVxuXG4gICAgbGV0IG1heHcgPSBNYXRoLm1heChydywgZ3csIGJ3KVxuICAgIGxldCBhY2NTdW06IFVpbnQzMkFycmF5IHwgbnVsbCA9IG51bGxcbiAgICBsZXQgc3VtOiBudW1iZXJcbiAgICBsZXQgdG90YWw6IG51bWJlclxuICAgIHN1bSA9IHRvdGFsID0gMFxuXG4gICAgbGV0IG1heGQ6ICdyJyB8ICdnJyB8ICdiJyB8IG51bGwgPSBudWxsXG5cbiAgICBpZiAobWF4dyA9PT0gcncpIHtcbiAgICAgIG1heGQgPSAncidcbiAgICAgIGFjY1N1bSA9IG5ldyBVaW50MzJBcnJheShyMiArIDEpXG4gICAgICBmb3IgKGxldCByID0gcjE7IHIgPD0gcjI7IHIrKykge1xuICAgICAgICBzdW0gPSAwXG4gICAgICAgIGZvciAobGV0IGcgPSBnMTsgZyA8PSBnMjsgZysrKSB7XG4gICAgICAgICAgZm9yIChsZXQgYiA9IGIxOyBiIDw9IGIyOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGdldENvbG9ySW5kZXgociwgZywgYilcbiAgICAgICAgICAgIHN1bSArPSBoaXN0W2luZGV4XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b3RhbCArPSBzdW1cbiAgICAgICAgYWNjU3VtW3JdID0gdG90YWxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1heHcgPT09IGd3KSB7XG4gICAgICBtYXhkID0gJ2cnXG4gICAgICBhY2NTdW0gPSBuZXcgVWludDMyQXJyYXkoZzIgKyAxKVxuICAgICAgZm9yIChsZXQgZyA9IGcxOyBnIDw9IGcyOyBnKyspIHtcbiAgICAgICAgc3VtID0gMFxuICAgICAgICBmb3IgKGxldCByID0gcjE7IHIgPD0gcjI7IHIrKykge1xuICAgICAgICAgIGZvciAobGV0IGIgPSBiMTsgYiA8PSBiMjsgYisrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBnZXRDb2xvckluZGV4KHIsIGcsIGIpXG4gICAgICAgICAgICBzdW0gKz0gaGlzdFtpbmRleF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG90YWwgKz0gc3VtXG4gICAgICAgIGFjY1N1bVtnXSA9IHRvdGFsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heGQgPSAnYidcbiAgICAgIGFjY1N1bSA9IG5ldyBVaW50MzJBcnJheShiMiArIDEpXG4gICAgICBmb3IgKGxldCBiID0gYjE7IGIgPD0gYjI7IGIrKykge1xuICAgICAgICBzdW0gPSAwXG4gICAgICAgIGZvciAobGV0IHIgPSByMTsgciA8PSByMjsgcisrKSB7XG4gICAgICAgICAgZm9yIChsZXQgZyA9IGcxOyBnIDw9IGcyOyBnKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGdldENvbG9ySW5kZXgociwgZywgYilcbiAgICAgICAgICAgIHN1bSArPSBoaXN0W2luZGV4XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b3RhbCArPSBzdW1cbiAgICAgICAgYWNjU3VtW2JdID0gdG90YWxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc3BsaXRQb2ludCA9IC0xXG4gICAgbGV0IHJldmVyc2VTdW0gPSBuZXcgVWludDMyQXJyYXkoYWNjU3VtLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjY1N1bS5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGQgPSBhY2NTdW1baV1cbiAgICAgIGlmIChzcGxpdFBvaW50IDwgMCAmJiBkID4gdG90YWwgLyAyKSBzcGxpdFBvaW50ID0gaVxuICAgICAgcmV2ZXJzZVN1bVtpXSA9IHRvdGFsIC0gZFxuICAgIH1cblxuICAgIGxldCB2Ym94ID0gdGhpc1xuXG4gICAgZnVuY3Rpb24gZG9DdXQgKGQ6IHN0cmluZyk6IFZCb3hbXSB7XG4gICAgICBsZXQgZGltMSA9IGQgKyAnMSdcbiAgICAgIGxldCBkaW0yID0gZCArICcyJ1xuICAgICAgbGV0IGQxID0gdmJveC5kaW1lbnNpb25bZGltMV1cbiAgICAgIGxldCBkMiA9IHZib3guZGltZW5zaW9uW2RpbTJdXG4gICAgICBsZXQgdmJveDEgPSB2Ym94LmNsb25lKClcbiAgICAgIGxldCB2Ym94MiA9IHZib3guY2xvbmUoKVxuICAgICAgbGV0IGxlZnQgPSBzcGxpdFBvaW50IC0gZDFcbiAgICAgIGxldCByaWdodCA9IGQyIC0gc3BsaXRQb2ludFxuICAgICAgaWYgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICAgICAgZDIgPSBNYXRoLm1pbihkMiAtIDEsIH5+KHNwbGl0UG9pbnQgKyByaWdodCAvIDIpKVxuICAgICAgICBkMiA9IE1hdGgubWF4KDAsIGQyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZDIgPSBNYXRoLm1heChkMSwgfn4oc3BsaXRQb2ludCAtIDEgLSBsZWZ0IC8gMikpXG4gICAgICAgIGQyID0gTWF0aC5taW4odmJveC5kaW1lbnNpb25bZGltMl0sIGQyKVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoIWFjY1N1bSFbZDJdKSBkMisrXG5cbiAgICAgIGxldCBjMiA9IHJldmVyc2VTdW1bZDJdXG4gICAgICB3aGlsZSAoIWMyICYmIGFjY1N1bSFbZDIgLSAxXSkgYzIgPSByZXZlcnNlU3VtWy0tZDJdXG5cbiAgICAgIHZib3gxLmRpbWVuc2lvbltkaW0yXSA9IGQyXG4gICAgICB2Ym94Mi5kaW1lbnNpb25bZGltMV0gPSBkMiArIDFcblxuICAgICAgcmV0dXJuIFt2Ym94MSwgdmJveDJdXG4gICAgfVxuXG4gICAgcmV0dXJuIGRvQ3V0KG1heGQpXG4gIH1cblxufVxuIiwiaW1wb3J0IHsgUGl4ZWxzIH0gZnJvbSAnLi9pbmRleCdcblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b2dyYW1PcHRpb25zIHtcbiAgc2lnQml0czogbnVtYmVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpc3RvZ3JhbSB7XG4gIGJtaW46IG51bWJlclxuICBibWF4OiBudW1iZXJcbiAgZ21pbjogbnVtYmVyXG4gIGdtYXg6IG51bWJlclxuICBybWluOiBudW1iZXJcbiAgcm1heDogbnVtYmVyXG4gIGhpc3Q6IFVpbnQzMkFycmF5XG4gIHByaXZhdGUgX2NvbG9yQ291bnQ6IG51bWJlclxuICBnZXQgY29sb3JDb3VudCAoKSB7IHJldHVybiB0aGlzLl9jb2xvckNvdW50IH1cbiAgZ2V0Q29sb3JJbmRleDogKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpID0+IG51bWJlclxuICBjb25zdHJ1Y3RvciAocHVibGljIHBpeGVsczogUGl4ZWxzLCBwdWJsaWMgb3B0czogSGlzdG9ncmFtT3B0aW9ucykge1xuICAgIGNvbnN0IHsgc2lnQml0cyB9ID0gb3B0c1xuICAgIGNvbnN0IGdldENvbG9ySW5kZXggPSAocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcikgPT5cbiAgICAgIChyIDw8ICgyICogc2lnQml0cykpICsgKGcgPDwgc2lnQml0cykgKyBiXG5cbiAgICB0aGlzLmdldENvbG9ySW5kZXggPSBnZXRDb2xvckluZGV4XG5cbiAgICBjb25zdCByc2hpZnQgPSA4IC0gc2lnQml0c1xuICAgIGNvbnN0IGhuID0gMSA8PCAoMyAqIHNpZ0JpdHMpXG4gICAgbGV0IGhpc3QgPSBuZXcgVWludDMyQXJyYXkoaG4pXG4gICAgbGV0IHJtYXg6IG51bWJlclxuICAgIGxldCBybWluOiBudW1iZXJcbiAgICBsZXQgZ21heDogbnVtYmVyXG4gICAgbGV0IGdtaW46IG51bWJlclxuICAgIGxldCBibWF4OiBudW1iZXJcbiAgICBsZXQgYm1pbjogbnVtYmVyXG4gICAgbGV0IHI6IG51bWJlclxuICAgIGxldCBnOiBudW1iZXJcbiAgICBsZXQgYjogbnVtYmVyXG4gICAgbGV0IGE6IG51bWJlclxuICAgIHJtYXggPSBnbWF4ID0gYm1heCA9IDBcbiAgICBybWluID0gZ21pbiA9IGJtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgbGV0IG4gPSBwaXhlbHMubGVuZ3RoIC8gNFxuICAgIGxldCBpID0gMFxuXG4gICAgd2hpbGUgKGkgPCBuKSB7XG5cbiAgICAgIGxldCBvZmZzZXQgPSBpICogNFxuICAgICAgaSsrXG4gICAgICByID0gcGl4ZWxzW29mZnNldCArIDBdXG4gICAgICBnID0gcGl4ZWxzW29mZnNldCArIDFdXG4gICAgICBiID0gcGl4ZWxzW29mZnNldCArIDJdXG4gICAgICBhID0gcGl4ZWxzW29mZnNldCArIDNdXG5cbiAgICAgIC8vIElnbm9yZWQgcGl4ZWxzJyBhbHBoYSBpcyBtYXJrZWQgYXMgMCBpbiBmaWx0ZXJpbmcgc3RhZ2VcbiAgICAgIGlmIChhID09PSAwKSBjb250aW51ZVxuXG4gICAgICByID0gciA+PiByc2hpZnRcbiAgICAgIGcgPSBnID4+IHJzaGlmdFxuICAgICAgYiA9IGIgPj4gcnNoaWZ0XG5cbiAgICAgIGxldCBpbmRleCA9IGdldENvbG9ySW5kZXgociwgZywgYilcbiAgICAgIGhpc3RbaW5kZXhdICs9IDFcblxuICAgICAgaWYgKHIgPiBybWF4KSBybWF4ID0gclxuICAgICAgaWYgKHIgPCBybWluKSBybWluID0gclxuICAgICAgaWYgKGcgPiBnbWF4KSBnbWF4ID0gZ1xuICAgICAgaWYgKGcgPCBnbWluKSBnbWluID0gZ1xuICAgICAgaWYgKGIgPiBibWF4KSBibWF4ID0gYlxuICAgICAgaWYgKGIgPCBibWluKSBibWluID0gYlxuICAgIH1cbiAgICB0aGlzLl9jb2xvckNvdW50ID0gaGlzdC5yZWR1Y2UoKHRvdGFsLCBjKSA9PiBjID4gMCA/IHRvdGFsICsgMSA6IHRvdGFsLCAwKVxuICAgIHRoaXMuaGlzdCA9IGhpc3RcbiAgICB0aGlzLnJtYXggPSBybWF4XG4gICAgdGhpcy5ybWluID0gcm1pblxuICAgIHRoaXMuZ21heCA9IGdtYXhcbiAgICB0aGlzLmdtaW4gPSBnbWluXG4gICAgdGhpcy5ibWF4ID0gYm1heFxuICAgIHRoaXMuYm1pbiA9IGJtaW5cbiAgfVxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBQUXVldWVDb21wYXJhdG9yPFQ+IHtcbiAgKGE6IFQsIGI6IFQpOiBudW1iZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUFF1ZXVlPFQ+IHtcbiAgY29udGVudHM6IFRbXVxuICBwcml2YXRlIF9zb3J0ZWQ6IGJvb2xlYW5cbiAgcHJpdmF0ZSBfY29tcGFyYXRvcjogUFF1ZXVlQ29tcGFyYXRvcjxUPlxuICBwcml2YXRlIF9zb3J0ICgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgICAgdGhpcy5jb250ZW50cy5zb3J0KHRoaXMuX2NvbXBhcmF0b3IpXG4gICAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IgKGNvbXBhcmF0b3I6IFBRdWV1ZUNvbXBhcmF0b3I8VD4pIHtcbiAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvclxuICAgIHRoaXMuY29udGVudHMgPSBbXVxuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlXG4gIH1cblxuICBwdXNoIChpdGVtOiBUKTogdm9pZCB7XG4gICAgdGhpcy5jb250ZW50cy5wdXNoKGl0ZW0pXG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2VcbiAgfVxuXG4gIHBlZWsgKGluZGV4PzogbnVtYmVyKTogVCB7XG4gICAgdGhpcy5fc29ydCgpXG4gICAgaW5kZXggPSB0eXBlb2YgaW5kZXggPT09ICdudW1iZXInID8gaW5kZXggOiB0aGlzLmNvbnRlbnRzLmxlbmd0aCAtIDFcbiAgICByZXR1cm4gdGhpcy5jb250ZW50c1tpbmRleF1cbiAgfVxuXG4gIHBvcCAoKSB7XG4gICAgdGhpcy5fc29ydCgpXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHMucG9wKClcbiAgfVxuXG4gIHNpemUgKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHMubGVuZ3RoXG4gIH1cblxuICBtYXA8VT4gKG1hcHBlcjogKGl0ZW06IFQsIGluZGV4OiBudW1iZXIpID0+IGFueSk6IFVbXSB7XG4gICAgdGhpcy5fc29ydCgpXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHMubWFwKG1hcHBlcilcbiAgfVxufVxuIiwiaW1wb3J0IHsgU3dhdGNoLCBQYWxldHRlIH0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5pbXBvcnQgeyBHZW5lcmF0b3IgfSBmcm9tICdAdmlicmFudC9nZW5lcmF0b3InXG5pbXBvcnQgeyBoc2xUb1JnYiB9IGZyb20gJ0B2aWJyYW50L2NvbG9yL2xpYi9jb252ZXJ0ZXInXG5cbmludGVyZmFjZSBEZWZhdWx0R2VuZXJhdG9yT3B0aW9ucyB7XG4gIHRhcmdldERhcmtMdW1hOiBudW1iZXIsXG4gIG1heERhcmtMdW1hOiBudW1iZXIsXG4gIG1pbkxpZ2h0THVtYTogbnVtYmVyLFxuICB0YXJnZXRMaWdodEx1bWE6IG51bWJlcixcbiAgbWluTm9ybWFsTHVtYTogbnVtYmVyLFxuICB0YXJnZXROb3JtYWxMdW1hOiBudW1iZXIsXG4gIG1heE5vcm1hbEx1bWE6IG51bWJlcixcbiAgdGFyZ2V0TXV0ZXNTYXR1cmF0aW9uOiBudW1iZXIsXG4gIG1heE11dGVzU2F0dXJhdGlvbjogbnVtYmVyLFxuICB0YXJnZXRWaWJyYW50U2F0dXJhdGlvbjogbnVtYmVyLFxuICBtaW5WaWJyYW50U2F0dXJhdGlvbjogbnVtYmVyLFxuICB3ZWlnaHRTYXR1cmF0aW9uOiBudW1iZXIsXG4gIHdlaWdodEx1bWE6IG51bWJlcixcbiAgd2VpZ2h0UG9wdWxhdGlvbjogbnVtYmVyXG59XG5cbmNvbnN0IERlZmF1bHRPcHRzOiBEZWZhdWx0R2VuZXJhdG9yT3B0aW9ucyA9IHtcbiAgdGFyZ2V0RGFya0x1bWE6IDAuMjYsXG4gIG1heERhcmtMdW1hOiAwLjQ1LFxuICBtaW5MaWdodEx1bWE6IDAuNTUsXG4gIHRhcmdldExpZ2h0THVtYTogMC43NCxcbiAgbWluTm9ybWFsTHVtYTogMC4zLFxuICB0YXJnZXROb3JtYWxMdW1hOiAwLjUsXG4gIG1heE5vcm1hbEx1bWE6IDAuNyxcbiAgdGFyZ2V0TXV0ZXNTYXR1cmF0aW9uOiAwLjMsXG4gIG1heE11dGVzU2F0dXJhdGlvbjogMC40LFxuICB0YXJnZXRWaWJyYW50U2F0dXJhdGlvbjogMS4wLFxuICBtaW5WaWJyYW50U2F0dXJhdGlvbjogMC4zNSxcbiAgd2VpZ2h0U2F0dXJhdGlvbjogMyxcbiAgd2VpZ2h0THVtYTogNi41LFxuICB3ZWlnaHRQb3B1bGF0aW9uOiAwLjVcbn1cblxuZnVuY3Rpb24gX2ZpbmRNYXhQb3B1bGF0aW9uIChzd2F0Y2hlczogQXJyYXk8U3dhdGNoPik6IG51bWJlciB7XG4gIGxldCBwID0gMFxuXG4gIHN3YXRjaGVzLmZvckVhY2goKHMpID0+IHtcbiAgICBwID0gTWF0aC5tYXgocCwgcy5wb3B1bGF0aW9uKVxuICB9KVxuXG4gIHJldHVybiBwXG59XG5cbmZ1bmN0aW9uIF9pc0FscmVhZHlTZWxlY3RlZCAocGFsZXR0ZTogUGFsZXR0ZSwgczogU3dhdGNoKTogYm9vbGVhbiB7XG4gIHJldHVybiBwYWxldHRlLlZpYnJhbnQgPT09IHNcbiAgICB8fCBwYWxldHRlLkRhcmtWaWJyYW50ID09PSBzXG4gICAgfHwgcGFsZXR0ZS5MaWdodFZpYnJhbnQgPT09IHNcbiAgICB8fCBwYWxldHRlLk11dGVkID09PSBzXG4gICAgfHwgcGFsZXR0ZS5EYXJrTXV0ZWQgPT09IHNcbiAgICB8fCBwYWxldHRlLkxpZ2h0TXV0ZWQgPT09IHNcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNvbXBhcmlzb25WYWx1ZSAoXG4gIHNhdHVyYXRpb246IG51bWJlciwgdGFyZ2V0U2F0dXJhdGlvbjogbnVtYmVyLFxuICBsdW1hOiBudW1iZXIsIHRhcmdldEx1bWE6IG51bWJlcixcbiAgcG9wdWxhdGlvbjogbnVtYmVyLCBtYXhQb3B1bGF0aW9uOiBudW1iZXIsIG9wdHM6IERlZmF1bHRHZW5lcmF0b3JPcHRpb25zKTogbnVtYmVyIHtcblxuICBmdW5jdGlvbiB3ZWlnaHRlZE1lYW4gKC4uLnZhbHVlczogbnVtYmVyW10pIHtcbiAgICBsZXQgc3VtID0gMFxuICAgIGxldCB3ZWlnaHRTdW0gPSAwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1tpXVxuICAgICAgbGV0IHdlaWdodCA9IHZhbHVlc1tpICsgMV1cbiAgICAgIHN1bSArPSB2YWx1ZSAqIHdlaWdodFxuICAgICAgd2VpZ2h0U3VtICs9IHdlaWdodFxuICAgIH1cblxuICAgIHJldHVybiBzdW0gLyB3ZWlnaHRTdW1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludmVydERpZmYgKHZhbHVlOiBudW1iZXIsIHRhcmdldFZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiAxIC0gTWF0aC5hYnModmFsdWUgLSB0YXJnZXRWYWx1ZSlcbiAgfVxuXG4gIHJldHVybiB3ZWlnaHRlZE1lYW4oXG4gICAgaW52ZXJ0RGlmZihzYXR1cmF0aW9uLCB0YXJnZXRTYXR1cmF0aW9uKSwgb3B0cy53ZWlnaHRTYXR1cmF0aW9uLFxuICAgIGludmVydERpZmYobHVtYSwgdGFyZ2V0THVtYSksIG9wdHMud2VpZ2h0THVtYSxcbiAgICBwb3B1bGF0aW9uIC8gbWF4UG9wdWxhdGlvbiwgb3B0cy53ZWlnaHRQb3B1bGF0aW9uXG4gIClcblxufVxuXG5mdW5jdGlvbiBfZmluZENvbG9yVmFyaWF0aW9uIChwYWxldHRlOiBQYWxldHRlLCBzd2F0Y2hlczogQXJyYXk8U3dhdGNoPiwgbWF4UG9wdWxhdGlvbjogbnVtYmVyLFxuICB0YXJnZXRMdW1hOiBudW1iZXIsXG4gIG1pbkx1bWE6IG51bWJlcixcbiAgbWF4THVtYTogbnVtYmVyLFxuICB0YXJnZXRTYXR1cmF0aW9uOiBudW1iZXIsXG4gIG1pblNhdHVyYXRpb246IG51bWJlcixcbiAgbWF4U2F0dXJhdGlvbjogbnVtYmVyLFxuICBvcHRzOiBEZWZhdWx0R2VuZXJhdG9yT3B0aW9ucyk6IFN3YXRjaCB8IG51bGwge1xuXG4gIGxldCBtYXg6IFN3YXRjaCB8IG51bGwgPSBudWxsXG4gIGxldCBtYXhWYWx1ZSA9IDBcblxuICBzd2F0Y2hlcy5mb3JFYWNoKChzd2F0Y2gpID0+IHtcbiAgICBsZXQgWywgcywgbF0gPSBzd2F0Y2guaHNsXG5cbiAgICBpZiAocyA+PSBtaW5TYXR1cmF0aW9uICYmIHMgPD0gbWF4U2F0dXJhdGlvblxuICAgICAgJiYgbCA+PSBtaW5MdW1hICYmIGwgPD0gbWF4THVtYVxuICAgICAgJiYgIV9pc0FscmVhZHlTZWxlY3RlZChwYWxldHRlLCBzd2F0Y2gpXG4gICAgKSB7XG4gICAgICBsZXQgdmFsdWUgPSBfY3JlYXRlQ29tcGFyaXNvblZhbHVlKHMsIHRhcmdldFNhdHVyYXRpb24sIGwsIHRhcmdldEx1bWEsIHN3YXRjaC5wb3B1bGF0aW9uLCBtYXhQb3B1bGF0aW9uLCBvcHRzKVxuXG4gICAgICBpZiAobWF4ID09PSBudWxsIHx8IHZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgbWF4ID0gc3dhdGNoXG4gICAgICAgIG1heFZhbHVlID0gdmFsdWVcbiAgICAgIH1cblxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gbWF4XG59XG5cbmZ1bmN0aW9uIF9nZW5lcmF0ZVZhcmlhdGlvbkNvbG9ycyAoc3dhdGNoZXM6IEFycmF5PFN3YXRjaD4sIG1heFBvcHVsYXRpb246IG51bWJlciwgb3B0czogRGVmYXVsdEdlbmVyYXRvck9wdGlvbnMpOiBQYWxldHRlIHtcbiAgbGV0IHBhbGV0dGU6IFBhbGV0dGUgPSB7XG4gICAgVmlicmFudDogbnVsbCxcbiAgICBEYXJrVmlicmFudDogbnVsbCxcbiAgICBMaWdodFZpYnJhbnQ6IG51bGwsXG4gICAgTXV0ZWQ6IG51bGwsXG4gICAgRGFya011dGVkOiBudWxsLFxuICAgIExpZ2h0TXV0ZWQ6IG51bGxcbiAgfVxuICAvLyBtVmlicmFudFN3YXRjaCA9IGZpbmRDb2xvcihUQVJHRVRfTk9STUFMX0xVTUEsIE1JTl9OT1JNQUxfTFVNQSwgTUFYX05PUk1BTF9MVU1BLFxuICAvLyAgICAgVEFSR0VUX1ZJQlJBTlRfU0FUVVJBVElPTiwgTUlOX1ZJQlJBTlRfU0FUVVJBVElPTiwgMWYpXG4gIHBhbGV0dGUuVmlicmFudCA9IF9maW5kQ29sb3JWYXJpYXRpb24ocGFsZXR0ZSwgc3dhdGNoZXMsIG1heFBvcHVsYXRpb24sXG4gICAgb3B0cy50YXJnZXROb3JtYWxMdW1hLFxuICAgIG9wdHMubWluTm9ybWFsTHVtYSxcbiAgICBvcHRzLm1heE5vcm1hbEx1bWEsXG4gICAgb3B0cy50YXJnZXRWaWJyYW50U2F0dXJhdGlvbixcbiAgICBvcHRzLm1pblZpYnJhbnRTYXR1cmF0aW9uLFxuICAgIDEsXG4gICAgb3B0c1xuICApXG4gIC8vIG1MaWdodFZpYnJhbnRTd2F0Y2ggPSBmaW5kQ29sb3IoVEFSR0VUX0xJR0hUX0xVTUEsIE1JTl9MSUdIVF9MVU1BLCAxZixcbiAgLy8gICAgIFRBUkdFVF9WSUJSQU5UX1NBVFVSQVRJT04sIE1JTl9WSUJSQU5UX1NBVFVSQVRJT04sIDFmKVxuICBwYWxldHRlLkxpZ2h0VmlicmFudCA9IF9maW5kQ29sb3JWYXJpYXRpb24ocGFsZXR0ZSwgc3dhdGNoZXMsIG1heFBvcHVsYXRpb24sXG4gICAgb3B0cy50YXJnZXRMaWdodEx1bWEsXG4gICAgb3B0cy5taW5MaWdodEx1bWEsXG4gICAgMSxcbiAgICBvcHRzLnRhcmdldFZpYnJhbnRTYXR1cmF0aW9uLFxuICAgIG9wdHMubWluVmlicmFudFNhdHVyYXRpb24sXG4gICAgMSxcbiAgICBvcHRzXG4gIClcbiAgLy8gbURhcmtWaWJyYW50U3dhdGNoID0gZmluZENvbG9yKFRBUkdFVF9EQVJLX0xVTUEsIDBmLCBNQVhfREFSS19MVU1BLFxuICAvLyAgICAgVEFSR0VUX1ZJQlJBTlRfU0FUVVJBVElPTiwgTUlOX1ZJQlJBTlRfU0FUVVJBVElPTiwgMWYpXG4gIHBhbGV0dGUuRGFya1ZpYnJhbnQgPSBfZmluZENvbG9yVmFyaWF0aW9uKHBhbGV0dGUsIHN3YXRjaGVzLCBtYXhQb3B1bGF0aW9uLFxuICAgIG9wdHMudGFyZ2V0RGFya0x1bWEsXG4gICAgMCxcbiAgICBvcHRzLm1heERhcmtMdW1hLFxuICAgIG9wdHMudGFyZ2V0VmlicmFudFNhdHVyYXRpb24sXG4gICAgb3B0cy5taW5WaWJyYW50U2F0dXJhdGlvbixcbiAgICAxLFxuICAgIG9wdHNcbiAgKVxuICAvLyBtTXV0ZWRTd2F0Y2ggPSBmaW5kQ29sb3IoVEFSR0VUX05PUk1BTF9MVU1BLCBNSU5fTk9STUFMX0xVTUEsIE1BWF9OT1JNQUxfTFVNQSxcbiAgLy8gICAgIFRBUkdFVF9NVVRFRF9TQVRVUkFUSU9OLCAwZiwgTUFYX01VVEVEX1NBVFVSQVRJT04pXG4gIHBhbGV0dGUuTXV0ZWQgPSBfZmluZENvbG9yVmFyaWF0aW9uKHBhbGV0dGUsIHN3YXRjaGVzLCBtYXhQb3B1bGF0aW9uLFxuICAgIG9wdHMudGFyZ2V0Tm9ybWFsTHVtYSxcbiAgICBvcHRzLm1pbk5vcm1hbEx1bWEsXG4gICAgb3B0cy5tYXhOb3JtYWxMdW1hLFxuICAgIG9wdHMudGFyZ2V0TXV0ZXNTYXR1cmF0aW9uLFxuICAgIDAsXG4gICAgb3B0cy5tYXhNdXRlc1NhdHVyYXRpb24sXG4gICAgb3B0c1xuICApXG4gIC8vIG1MaWdodE11dGVkQ29sb3IgPSBmaW5kQ29sb3IoVEFSR0VUX0xJR0hUX0xVTUEsIE1JTl9MSUdIVF9MVU1BLCAxZixcbiAgLy8gICAgIFRBUkdFVF9NVVRFRF9TQVRVUkFUSU9OLCAwZiwgTUFYX01VVEVEX1NBVFVSQVRJT04pXG4gIHBhbGV0dGUuTGlnaHRNdXRlZCA9IF9maW5kQ29sb3JWYXJpYXRpb24ocGFsZXR0ZSwgc3dhdGNoZXMsIG1heFBvcHVsYXRpb24sXG4gICAgb3B0cy50YXJnZXRMaWdodEx1bWEsXG4gICAgb3B0cy5taW5MaWdodEx1bWEsXG4gICAgMSxcbiAgICBvcHRzLnRhcmdldE11dGVzU2F0dXJhdGlvbixcbiAgICAwLFxuICAgIG9wdHMubWF4TXV0ZXNTYXR1cmF0aW9uLFxuICAgIG9wdHNcbiAgKVxuICAvLyBtRGFya011dGVkU3dhdGNoID0gZmluZENvbG9yKFRBUkdFVF9EQVJLX0xVTUEsIDBmLCBNQVhfREFSS19MVU1BLFxuICAvLyAgICAgVEFSR0VUX01VVEVEX1NBVFVSQVRJT04sIDBmLCBNQVhfTVVURURfU0FUVVJBVElPTilcbiAgcGFsZXR0ZS5EYXJrTXV0ZWQgPSBfZmluZENvbG9yVmFyaWF0aW9uKHBhbGV0dGUsIHN3YXRjaGVzLCBtYXhQb3B1bGF0aW9uLFxuICAgIG9wdHMudGFyZ2V0RGFya0x1bWEsXG4gICAgMCxcbiAgICBvcHRzLm1heERhcmtMdW1hLFxuICAgIG9wdHMudGFyZ2V0TXV0ZXNTYXR1cmF0aW9uLFxuICAgIDAsXG4gICAgb3B0cy5tYXhNdXRlc1NhdHVyYXRpb24sXG4gICAgb3B0c1xuICApXG4gIHJldHVybiBwYWxldHRlXG59XG5cbmZ1bmN0aW9uIF9nZW5lcmF0ZUVtcHR5U3dhdGNoZXMgKHBhbGV0dGU6IFBhbGV0dGUsIG1heFBvcHVsYXRpb246IG51bWJlciwgb3B0czogRGVmYXVsdEdlbmVyYXRvck9wdGlvbnMpOiB2b2lkIHtcbiAgaWYgKCFwYWxldHRlLlZpYnJhbnQgJiYgIXBhbGV0dGUuRGFya1ZpYnJhbnQgJiYgIXBhbGV0dGUuTGlnaHRWaWJyYW50KSB7XG4gICAgaWYgKCFwYWxldHRlLkRhcmtWaWJyYW50ICYmIHBhbGV0dGUuRGFya011dGVkKSB7XG4gICAgICBsZXQgW2gsIHMsIGxdID0gcGFsZXR0ZS5EYXJrTXV0ZWQuaHNsXG4gICAgICBsID0gb3B0cy50YXJnZXREYXJrTHVtYVxuICAgICAgcGFsZXR0ZS5EYXJrVmlicmFudCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gICAgfVxuICAgIGlmICghcGFsZXR0ZS5MaWdodFZpYnJhbnQgJiYgcGFsZXR0ZS5MaWdodE11dGVkKSB7XG4gICAgICBsZXQgW2gsIHMsIGxdID0gcGFsZXR0ZS5MaWdodE11dGVkLmhzbFxuICAgICAgbCA9IG9wdHMudGFyZ2V0RGFya0x1bWFcbiAgICAgIHBhbGV0dGUuRGFya1ZpYnJhbnQgPSBuZXcgU3dhdGNoKGhzbFRvUmdiKGgsIHMsIGwpLCAwKVxuICAgIH1cbiAgfVxuICBpZiAoIXBhbGV0dGUuVmlicmFudCAmJiBwYWxldHRlLkRhcmtWaWJyYW50KSB7XG4gICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuRGFya1ZpYnJhbnQuaHNsXG4gICAgbCA9IG9wdHMudGFyZ2V0Tm9ybWFsTHVtYVxuICAgIHBhbGV0dGUuVmlicmFudCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gIH0gZWxzZSBpZiAoIXBhbGV0dGUuVmlicmFudCAmJiBwYWxldHRlLkxpZ2h0VmlicmFudCkge1xuICAgIGxldCBbaCwgcywgbF0gPSBwYWxldHRlLkxpZ2h0VmlicmFudC5oc2xcbiAgICBsID0gb3B0cy50YXJnZXROb3JtYWxMdW1hXG4gICAgcGFsZXR0ZS5WaWJyYW50ID0gbmV3IFN3YXRjaChoc2xUb1JnYihoLCBzLCBsKSwgMClcbiAgfVxuICBpZiAoIXBhbGV0dGUuRGFya1ZpYnJhbnQgJiYgcGFsZXR0ZS5WaWJyYW50KSB7XG4gICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuVmlicmFudC5oc2xcbiAgICBsID0gb3B0cy50YXJnZXREYXJrTHVtYVxuICAgIHBhbGV0dGUuRGFya1ZpYnJhbnQgPSBuZXcgU3dhdGNoKGhzbFRvUmdiKGgsIHMsIGwpLCAwKVxuICB9XG4gIGlmICghcGFsZXR0ZS5MaWdodFZpYnJhbnQgJiYgcGFsZXR0ZS5WaWJyYW50KSB7XG4gICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuVmlicmFudC5oc2xcbiAgICBsID0gb3B0cy50YXJnZXRMaWdodEx1bWFcbiAgICBwYWxldHRlLkxpZ2h0VmlicmFudCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gIH1cbiAgaWYgKCFwYWxldHRlLk11dGVkICYmIHBhbGV0dGUuVmlicmFudCkge1xuICAgIGxldCBbaCwgcywgbF0gPSBwYWxldHRlLlZpYnJhbnQuaHNsXG4gICAgbCA9IG9wdHMudGFyZ2V0TXV0ZXNTYXR1cmF0aW9uXG4gICAgcGFsZXR0ZS5NdXRlZCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gIH1cbiAgaWYgKCFwYWxldHRlLkRhcmtNdXRlZCAmJiBwYWxldHRlLkRhcmtWaWJyYW50KSB7XG4gICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuRGFya1ZpYnJhbnQuaHNsXG4gICAgbCA9IG9wdHMudGFyZ2V0TXV0ZXNTYXR1cmF0aW9uXG4gICAgcGFsZXR0ZS5EYXJrTXV0ZWQgPSBuZXcgU3dhdGNoKGhzbFRvUmdiKGgsIHMsIGwpLCAwKVxuICB9XG4gIGlmICghcGFsZXR0ZS5MaWdodE11dGVkICYmIHBhbGV0dGUuTGlnaHRWaWJyYW50KSB7XG4gICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuTGlnaHRWaWJyYW50LmhzbFxuICAgIGwgPSBvcHRzLnRhcmdldE11dGVzU2F0dXJhdGlvblxuICAgIHBhbGV0dGUuTGlnaHRNdXRlZCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gIH1cbn1cblxuY29uc3QgRGVmYXVsdEdlbmVyYXRvcjogR2VuZXJhdG9yID0gKHN3YXRjaGVzOiBBcnJheTxTd2F0Y2g+LCBvcHRzPzogRGVmYXVsdEdlbmVyYXRvck9wdGlvbnMpOiBQYWxldHRlID0+IHtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIERlZmF1bHRPcHRzLCBvcHRzKVxuICBsZXQgbWF4UG9wdWxhdGlvbiA9IF9maW5kTWF4UG9wdWxhdGlvbihzd2F0Y2hlcylcblxuICBsZXQgcGFsZXR0ZSA9IF9nZW5lcmF0ZVZhcmlhdGlvbkNvbG9ycyhzd2F0Y2hlcywgbWF4UG9wdWxhdGlvbiwgb3B0cylcbiAgX2dlbmVyYXRlRW1wdHlTd2F0Y2hlcyhwYWxldHRlLCBtYXhQb3B1bGF0aW9uLCBvcHRzKVxuXG4gIHJldHVybiBwYWxldHRlXG59XG5cbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRHZW5lcmF0b3JcbiIsImltcG9ydCB7IEltYWdlRGF0YSwgYXBwbHlGaWx0ZXJzIH0gZnJvbSAnQHZpYnJhbnQvaW1hZ2UnXG5pbXBvcnQgeyBRdWFudGl6ZXIgfSBmcm9tICdAdmlicmFudC9xdWFudGl6ZXInXG5pbXBvcnQgeyBHZW5lcmF0b3IgfSBmcm9tICdAdmlicmFudC9nZW5lcmF0b3InXG5pbXBvcnQgeyBQYWxldHRlLCBTd2F0Y2gsIEZpbHRlciB9IGZyb20gJ0B2aWJyYW50L2NvbG9yJ1xuXG5leHBvcnQgY2xhc3MgU3RhZ2U8VD4ge1xuICBwcml2YXRlIF9tYXA6IHsgW25hbWU6IHN0cmluZ106IFQgfSA9IHt9XG4gIGNvbnN0cnVjdG9yIChwcm90ZWN0ZWQgcGlwZWxpbmU6IEJhc2ljUGlwZWxpbmUpIHsgfVxuICBuYW1lcyAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX21hcClcbiAgfVxuICBoYXMgKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiAhIXRoaXMuX21hcFtuYW1lXVxuICB9XG4gIGdldCAobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcFtuYW1lXVxuICB9XG4gIHJlZ2lzdGVyIChuYW1lOiBzdHJpbmcsIHN0YWdlRm46IFQpIHtcbiAgICB0aGlzLl9tYXBbbmFtZV0gPSBzdGFnZUZuXG4gICAgcmV0dXJuIHRoaXMucGlwZWxpbmVcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NSZXN1bHQge1xuICBjb2xvcnM6IFN3YXRjaFtdXG4gIHBhbGV0dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBQYWxldHRlIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGFnZU9wdGlvbnMge1xuICBuYW1lOiBzdHJpbmdcbiAgb3B0aW9ucz86IGFueVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NPcHRpb25zIHtcbiAgZmlsdGVyczogc3RyaW5nW11cbiAgcXVhbnRpemVyOiBzdHJpbmcgfCBTdGFnZU9wdGlvbnNcbiAgZ2VuZXJhdG9yczogKHN0cmluZyB8IFN0YWdlT3B0aW9ucylbXVxufVxuXG5pbnRlcmZhY2UgU3RhZ2VUYXNrPFE+IHtcbiAgbmFtZTogc3RyaW5nXG4gIGZuOiBRXG4gIG9wdGlvbnM/OiBhbnlcbn1cblxuaW50ZXJmYWNlIFByb2Nlc3NUYXNrcyB7XG4gIGZpbHRlcnM6IFN0YWdlVGFzazxGaWx0ZXI+W11cbiAgcXVhbnRpemVyOiBTdGFnZVRhc2s8UXVhbnRpemVyPlxuICBnZW5lcmF0b3JzOiBTdGFnZVRhc2s8R2VuZXJhdG9yPltdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGlwZWxpbmUge1xuICAvLyBxdWFudGl6ZXI6IFN0YWdlPFF1YW50aXplcj5cbiAgLy8gZ2VuZXJhdG9yOiBTdGFnZTxHZW5lcmF0b3I+XG4gIHByb2Nlc3MgKGltYWdlRGF0YTogSW1hZ2VEYXRhLCBvcHRzOiBQcm9jZXNzT3B0aW9ucyk6IFByb21pc2U8UHJvY2Vzc1Jlc3VsdD5cbn1cblxuZXhwb3J0IGNsYXNzIEJhc2ljUGlwZWxpbmUgaW1wbGVtZW50cyBQaXBlbGluZSB7XG4gIHByaXZhdGUgX2J1aWxkUHJvY2Vzc1Rhc2tzICh7XG4gICAgZmlsdGVycyxcbiAgICBxdWFudGl6ZXIsXG4gICAgZ2VuZXJhdG9yc1xuICB9OiBQcm9jZXNzT3B0aW9ucyk6IFByb2Nlc3NUYXNrcyB7XG4gICAgLy8gU3VwcG9ydCB3aWxkY2FyZCBmb3IgZ2VuZXJhdG9yc1xuICAgIGlmIChnZW5lcmF0b3JzLmxlbmd0aCA9PT0gMSAmJiBnZW5lcmF0b3JzWzBdID09PSAnKicpIHtcbiAgICAgIGdlbmVyYXRvcnMgPSB0aGlzLmdlbmVyYXRvci5uYW1lcygpXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmaWx0ZXJzOiBmaWx0ZXJzLm1hcChmID0+IGNyZWF0ZVRhc2sodGhpcy5maWx0ZXIsIGYpKSxcbiAgICAgIHF1YW50aXplcjogY3JlYXRlVGFzayh0aGlzLnF1YW50aXplciwgcXVhbnRpemVyKSxcbiAgICAgIGdlbmVyYXRvcnM6IGdlbmVyYXRvcnMubWFwKGcgPT4gY3JlYXRlVGFzayh0aGlzLmdlbmVyYXRvciwgZykpXG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRhc2s8UT4gKFxuICAgICAgc3RhZ2U6IFN0YWdlPFE+LFxuICAgICAgbzogc3RyaW5nIHwgU3RhZ2VPcHRpb25zXG4gICAgKTogU3RhZ2VUYXNrPFE+IHtcbiAgICAgIGxldCBuYW1lOiBzdHJpbmdcbiAgICAgIGxldCBvcHRpb25zOiBhbnlcbiAgICAgIGlmICh0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IG9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBvLm5hbWVcbiAgICAgICAgb3B0aW9ucyA9IG8ub3B0aW9uc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBmbjogc3RhZ2UuZ2V0KG5hbWUpLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbHRlcjogU3RhZ2U8RmlsdGVyPiA9IG5ldyBTdGFnZSh0aGlzKVxuICBxdWFudGl6ZXI6IFN0YWdlPFF1YW50aXplcj4gPSBuZXcgU3RhZ2UodGhpcylcbiAgZ2VuZXJhdG9yOiBTdGFnZTxHZW5lcmF0b3I+ID0gbmV3IFN0YWdlKHRoaXMpXG4gIGFzeW5jIHByb2Nlc3MgKFxuICAgIGltYWdlRGF0YTogSW1hZ2VEYXRhLFxuICAgIG9wdHM6IFByb2Nlc3NPcHRpb25zXG4gICk6IFByb21pc2U8UHJvY2Vzc1Jlc3VsdD4ge1xuICAgIGxldCB7IGZpbHRlcnMsIHF1YW50aXplciwgZ2VuZXJhdG9ycyB9ID0gdGhpcy5fYnVpbGRQcm9jZXNzVGFza3Mob3B0cylcbiAgICBjb25zdCBpbWFnZUZpbHRlckRhdGEgPSBhd2FpdCB0aGlzLl9maWx0ZXJDb2xvcnMoZmlsdGVycywgaW1hZ2VEYXRhKVxuICAgIGNvbnN0IGNvbG9ycyA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlQ29sb3JzKHF1YW50aXplciwgaW1hZ2VGaWx0ZXJEYXRhKVxuICAgIGNvbnN0IHBhbGV0dGVzID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGVQYWxldHRlcyhnZW5lcmF0b3JzLCBjb2xvcnMpXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHBhbGV0dGVzXG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2ZpbHRlckNvbG9ycyAoZmlsdGVyczogU3RhZ2VUYXNrPEZpbHRlcj5bXSwgaW1hZ2VEYXRhOiBJbWFnZURhdGEpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgYXBwbHlGaWx0ZXJzKGltYWdlRGF0YSwgZmlsdGVycy5tYXAoKHsgZm4gfSkgPT4gZm4pKVxuICAgIClcbiAgfVxuICBwcml2YXRlIF9nZW5lcmF0ZUNvbG9ycyAoXG4gICAgcXVhbnRpemVyOiBTdGFnZVRhc2s8UXVhbnRpemVyPixcbiAgICBpbWFnZURhdGE6IEltYWdlRGF0YVxuICApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHF1YW50aXplci5mbihpbWFnZURhdGEuZGF0YSwgcXVhbnRpemVyLm9wdGlvbnMpKVxuICB9XG4gIHByaXZhdGUgYXN5bmMgX2dlbmVyYXRlUGFsZXR0ZXMgKFxuICAgIGdlbmVyYXRvcnM6IFN0YWdlVGFzazxHZW5lcmF0b3I+W10sXG4gICAgY29sb3JzOiBTd2F0Y2hbXVxuICApIHtcbiAgICAvLyBNYWtlIGEgcHJvbWlzZSBtYXAgdGhhdCB3aWxsIHJ1biB0aGVtIFwiY29uY3VycmVudGx5XCIgKGJ1dCByZXR1cm4gaW4gZXhwZWN0ZWQgcmVzdWx0KVxuICAgIGNvbnN0IHByb21pc2VBcnIgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGdlbmVyYXRvcnMubWFwKCh7IGZuLCBvcHRpb25zIH0pID0+IFByb21pc2UucmVzb2x2ZShmbihjb2xvcnMsIG9wdGlvbnMpKSlcbiAgICApXG4gICAgLy8gTWFwIHRoZSB2YWx1ZXMgdG8gdGhlIGV4cGVjdGVkIG5hbWVcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgcHJvbWlzZUFyci5yZWR1Y2UoXG4gICAgICAgIChwcm9taXNlcywgcHJvbWlzZVZhbCwgaSkgPT4ge1xuICAgICAgICAgIHByb21pc2VzW2dlbmVyYXRvcnNbaV0ubmFtZV0gPSBwcm9taXNlVmFsXG4gICAgICAgICAgcmV0dXJuIHByb21pc2VzXG4gICAgICAgIH0sXG4gICAgICAgIHt9IGFzIHsgW25hbWU6IHN0cmluZ106IFBhbGV0dGUgfVxuICAgICAgKVxuICAgIClcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/node-vibrant/dist/vibrant.js\n");

/***/ })

}]);