{"version":3,"file":"060a5708.js","mappings":";;AA0EA;;AAIA;;;AAKA;AACA;AACA;;;;;AAhBA;;;;;;;;;;;;;AAhCA","sources":["webpack://home-assistant-frontend/./src/panels/lovelace/cards/energy/hui-energy-devices-graph-card.ts"],"sourcesContent":["import {\n  ChartData,\n  ChartDataset,\n  ChartOptions,\n  ParsedDataType,\n  ScatterDataPoint,\n} from \"chart.js\";\nimport { getRelativePosition } from \"chart.js/helpers\";\nimport { addHours, differenceInDays } from \"date-fns/esm\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport { getColorByIndex } from \"../../../../common/color/colors\";\nimport { fireEvent } from \"../../../../common/dom/fire_event\";\nimport { computeStateName } from \"../../../../common/entity/compute_state_name\";\nimport {\n  formatNumber,\n  numberFormatToLocale,\n} from \"../../../../common/number/format_number\";\nimport \"../../../../components/chart/ha-chart-base\";\nimport type HaChartBase from \"../../../../components/chart/ha-chart-base\";\nimport \"../../../../components/ha-card\";\nimport { EnergyData, getEnergyDataCollection } from \"../../../../data/energy\";\nimport {\n  calculateStatisticSumGrowth,\n  fetchStatistics,\n  Statistics,\n} from \"../../../../data/history\";\nimport { FrontendLocaleData } from \"../../../../data/translation\";\nimport { SubscribeMixin } from \"../../../../mixins/subscribe-mixin\";\nimport { HomeAssistant } from \"../../../../types\";\nimport { LovelaceCard } from \"../../types\";\nimport { EnergyDevicesGraphCardConfig } from \"../types\";\n\n@customElement(\"hui-energy-devices-graph-card\")\nexport class HuiEnergyDevicesGraphCard\n  extends SubscribeMixin(LitElement)\n  implements LovelaceCard\n{\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @state() private _config?: EnergyDevicesGraphCardConfig;\n\n  @state() private _chartData: ChartData = { datasets: [] };\n\n  @query(\"ha-chart-base\") private _chart?: HaChartBase;\n\n  protected hassSubscribeRequiredHostProps = [\"_config\"];\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      getEnergyDataCollection(this.hass, {\n        key: this._config?.collection_key,\n      }).subscribe((data) => this._getStatistics(data)),\n    ];\n  }\n\n  public getCardSize(): Promise<number> | number {\n    return 3;\n  }\n\n  public setConfig(config: EnergyDevicesGraphCardConfig): void {\n    this._config = config;\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass || !this._config) {\n      return html``;\n    }\n\n    return html`\n      <ha-card>\n        ${this._config.title\n          ? html`<h1 class=\"card-header\">${this._config.title}</h1>`\n          : \"\"}\n        <div\n          class=\"content ${classMap({\n            \"has-header\": !!this._config.title,\n          })}\"\n        >\n          <ha-chart-base\n            .data=${this._chartData}\n            .options=${this._createOptions(this.hass.locale)}\n            .height=${(this._chartData?.datasets[0]?.data.length || 0) * 28 +\n            50}\n            chart-type=\"bar\"\n          ></ha-chart-base>\n        </div>\n      </ha-card>\n    `;\n  }\n\n  private _createOptions = memoizeOne(\n    (locale: FrontendLocaleData): ChartOptions => ({\n      parsing: false,\n      animation: false,\n      responsive: true,\n      maintainAspectRatio: false,\n      indexAxis: \"y\",\n      scales: {\n        y: {\n          type: \"category\",\n          ticks: {\n            autoSkip: false,\n            callback: (index) => {\n              const entityId = (\n                this._chartData.datasets[0].data[index] as ScatterDataPoint\n              ).y;\n              const entity = this.hass.states[entityId];\n              return entity ? computeStateName(entity) : entityId;\n            },\n          },\n        },\n        x: {\n          title: {\n            display: true,\n            text: \"kWh\",\n          },\n        },\n      },\n      elements: { bar: { borderWidth: 1.5, borderRadius: 4 } },\n      plugins: {\n        tooltip: {\n          mode: \"nearest\",\n          callbacks: {\n            title: (item) => {\n              const entity = this.hass.states[item[0].label];\n              return entity ? computeStateName(entity) : item[0].label;\n            },\n            label: (context) =>\n              `${context.dataset.label}: ${formatNumber(\n                context.parsed.x,\n                locale\n              )} kWh`,\n          },\n        },\n      },\n      // @ts-expect-error\n      locale: numberFormatToLocale(this.hass.locale),\n      onClick: (e: any) => {\n        const chart = e.chart;\n        const canvasPosition = getRelativePosition(e, chart);\n\n        const index = Math.abs(\n          chart.scales.y.getValueForPixel(canvasPosition.y)\n        );\n        fireEvent(this, \"hass-more-info\", {\n          // @ts-ignore\n          entityId: this._chartData?.datasets[0]?.data[index]?.y,\n        });\n      },\n    })\n  );\n\n  private async _getStatistics(energyData: EnergyData): Promise<void> {\n    const dayDifference = differenceInDays(\n      energyData.end || new Date(),\n      energyData.start\n    );\n\n    const devices = energyData.prefs.device_consumption.map(\n      (device) => device.stat_consumption\n    );\n\n    const period =\n      dayDifference > 35 ? \"month\" : dayDifference > 2 ? \"day\" : \"hour\";\n\n    const startMinHour = addHours(energyData.start, -1);\n\n    const data = await fetchStatistics(\n      this.hass,\n      startMinHour,\n      energyData.end,\n      devices,\n      period\n    );\n\n    Object.values(data).forEach((stat) => {\n      // if the start of the first value is after the requested period, we have the first data point, and should add a zero point\n      if (stat.length && new Date(stat[0].start) > startMinHour) {\n        stat.unshift({\n          ...stat[0],\n          start: startMinHour.toISOString(),\n          end: startMinHour.toISOString(),\n          sum: 0,\n          state: 0,\n        });\n      }\n    });\n\n    let compareData: Statistics | undefined;\n\n    if (energyData.startCompare && energyData.endCompare) {\n      const startCompareMinHour = addHours(energyData.startCompare, -1);\n      compareData = await fetchStatistics(\n        this.hass,\n        startCompareMinHour,\n        energyData.endCompare,\n        devices,\n        period\n      );\n\n      Object.values(compareData).forEach((stat) => {\n        // if the start of the first value is after the requested period, we have the first data point, and should add a zero point\n        if (stat.length && new Date(stat[0].start) > startMinHour) {\n          stat.unshift({\n            ...stat[0],\n            start: startCompareMinHour.toISOString(),\n            end: startCompareMinHour.toISOString(),\n            sum: 0,\n            state: 0,\n          });\n        }\n      });\n    }\n\n    const chartData: Array<ChartDataset<\"bar\", ParsedDataType<\"bar\">>[\"data\"]> =\n      [];\n    const chartDataCompare: Array<\n      ChartDataset<\"bar\", ParsedDataType<\"bar\">>[\"data\"]\n    > = [];\n    const borderColor: string[] = [];\n    const borderColorCompare: string[] = [];\n    const backgroundColor: string[] = [];\n    const backgroundColorCompare: string[] = [];\n\n    const datasets: ChartDataset<\"bar\", ParsedDataType<\"bar\">[]>[] = [\n      {\n        label: this.hass.localize(\n          \"ui.panel.lovelace.cards.energy.energy_devices_graph.energy_usage\"\n        ),\n        borderColor,\n        backgroundColor,\n        data: chartData,\n        barThickness: compareData ? 10 : 20,\n      },\n    ];\n\n    if (compareData) {\n      datasets.push({\n        label: this.hass.localize(\n          \"ui.panel.lovelace.cards.energy.energy_devices_graph.previous_energy_usage\"\n        ),\n        borderColor: borderColorCompare,\n        backgroundColor: backgroundColorCompare,\n        data: chartDataCompare,\n        barThickness: 10,\n      });\n    }\n\n    energyData.prefs.device_consumption.forEach((device, idx) => {\n      const value =\n        device.stat_consumption in data\n          ? calculateStatisticSumGrowth(data[device.stat_consumption]) || 0\n          : 0;\n\n      chartData.push({\n        // @ts-expect-error\n        y: device.stat_consumption,\n        x: value,\n        idx,\n      });\n\n      if (compareData) {\n        const compareValue =\n          device.stat_consumption in compareData\n            ? calculateStatisticSumGrowth(\n                compareData[device.stat_consumption]\n              ) || 0\n            : 0;\n\n        chartDataCompare.push({\n          // @ts-expect-error\n          y: device.stat_consumption,\n          x: compareValue,\n          idx,\n        });\n      }\n    });\n\n    chartData.sort((a, b) => b.x - a.x);\n\n    chartData.forEach((d: any) => {\n      const color = getColorByIndex(d.idx);\n\n      borderColor.push(color);\n      backgroundColor.push(color + \"7F\");\n    });\n\n    chartDataCompare.forEach((d: any) => {\n      const color = getColorByIndex(d.idx);\n\n      borderColorCompare.push(color + \"7F\");\n      backgroundColorCompare.push(color + \"32\");\n    });\n\n    this._chartData = {\n      datasets,\n    };\n    await this.updateComplete;\n    this._chart?.updateChart(\"none\");\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      .card-header {\n        padding-bottom: 0;\n      }\n      .content {\n        padding: 16px;\n      }\n      .has-header {\n        padding-top: 0;\n      }\n      ha-chart-base {\n        --chart-max-height: none;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-energy-devices-graph-card\": HuiEnergyDevicesGraphCard;\n  }\n}\n"],"names":[],"sourceRoot":""}