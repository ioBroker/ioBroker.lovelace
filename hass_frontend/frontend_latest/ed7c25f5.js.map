{"version":3,"file":"ed7c25f5.js","mappings":";;;AA+DA;AACA;;;;AAeA;;AAcA;AAKA;AACA;AAKA;;AAEA;AAEA;AACA;AACA;AAEA;AAEA;;;AAvFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;ACFA;;AAGA;;AAKA;;AAEA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;AA5BA;;;;;;;;;;;AAAA","sources":["webpack://home-assistant-frontend/./src/components/entity/ha-state-label-badge.ts","webpack://home-assistant-frontend/./src/components/ha-label-badge.ts","webpack://home-assistant-frontend/./src/panels/lovelace/badges/hui-state-label-badge.ts"],"sourcesContent":["import { mdiAlert } from \"@mdi/js\";\nimport { HassEntity } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport secondsToDuration from \"../../common/datetime/seconds_to_duration\";\nimport { computeStateDisplay } from \"../../common/entity/compute_state_display\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport {\n  formatNumber,\n  isNumericState,\n} from \"../../common/number/format_number\";\nimport { UNAVAILABLE, UNKNOWN } from \"../../data/entity\";\nimport { timerTimeRemaining } from \"../../data/timer\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-label-badge\";\nimport \"../ha-state-icon\";\n\n@customElement(\"ha-state-label-badge\")\nexport class HaStateLabelBadge extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ attribute: false }) public state?: HassEntity;\n\n  @property() public name?: string;\n\n  @property() public icon?: string;\n\n  @property() public image?: string;\n\n  @state() private _timerTimeRemaining?: number;\n\n  private _connected?: boolean;\n\n  private _updateRemaining?: number;\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    this._connected = true;\n    this.startInterval(this.state);\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    this._connected = false;\n    this.clearInterval();\n  }\n\n  protected render(): TemplateResult {\n    const entityState = this.state;\n\n    if (!entityState) {\n      return html`\n        <ha-label-badge\n          class=\"warning\"\n          label=${this.hass!.localize(\"state_badge.default.error\")}\n          description=${this.hass!.localize(\n            \"state_badge.default.entity_not_found\"\n          )}\n        >\n          <ha-svg-icon .path=${mdiAlert}></ha-svg-icon>\n        </ha-label-badge>\n      `;\n    }\n\n    // Rendering priority inside badge:\n    // 1. Icon directly defined in badge config\n    // 2. Image directly defined in badge config\n    // 3. Image taken from entity picture\n    // 4. Icon determined via entity state\n    // 5. Value string as fallback\n    const domain = computeStateDomain(entityState);\n\n    const showIcon = this.icon || this._computeShowIcon(domain, entityState);\n    const image = this.icon\n      ? \"\"\n      : this.image\n      ? this.image\n      : entityState.attributes.entity_picture_local ||\n        entityState.attributes.entity_picture;\n    const value =\n      !image && !showIcon ? this._computeValue(domain, entityState) : undefined;\n\n    return html`\n      <ha-label-badge\n        class=${classMap({\n          [domain]: true,\n          \"has-unit_of_measurement\":\n            \"unit_of_measurement\" in entityState.attributes,\n        })}\n        .image=${image}\n        .label=${this._computeLabel(\n          domain,\n          entityState,\n          this._timerTimeRemaining\n        )}\n        .description=${this.name ?? computeStateName(entityState)}\n      >\n        ${!image && showIcon\n          ? html`<ha-state-icon\n              .icon=${this.icon}\n              .state=${entityState}\n            ></ha-state-icon>`\n          : \"\"}\n        ${value && !image && !showIcon\n          ? html`<span class=${value && value.length > 4 ? \"big\" : \"\"}\n              >${value}</span\n            >`\n          : \"\"}\n      </ha-label-badge>\n    `;\n  }\n\n  protected updated(changedProperties: PropertyValues): void {\n    super.updated(changedProperties);\n\n    if (this._connected && changedProperties.has(\"state\")) {\n      this.startInterval(this.state);\n    }\n  }\n\n  private _computeValue(domain: string, entityState: HassEntity) {\n    switch (domain) {\n      case \"alarm_control_panel\":\n      case \"binary_sensor\":\n      case \"device_tracker\":\n      case \"person\":\n      case \"scene\":\n      case \"sun\":\n      case \"timer\":\n      case \"updater\":\n        return null;\n      // @ts-expect-error we don't break and go to default\n      case \"sensor\":\n        if (entityState.attributes.device_class === \"moon__phase\") {\n          return null;\n        }\n      // eslint-disable-next-line: disable=no-fallthrough\n      default:\n        return entityState.state === UNKNOWN ||\n          entityState.state === UNAVAILABLE\n          ? \"-\"\n          : isNumericState(entityState)\n          ? formatNumber(entityState.state, this.hass!.locale)\n          : computeStateDisplay(\n              this.hass!.localize,\n              entityState,\n              this.hass!.locale\n            );\n    }\n  }\n\n  private _computeShowIcon(domain: string, entityState: HassEntity): boolean {\n    if (entityState.state === UNAVAILABLE) {\n      return false;\n    }\n    switch (domain) {\n      case \"alarm_control_panel\":\n      case \"binary_sensor\":\n      case \"device_tracker\":\n      case \"updater\":\n      case \"person\":\n      case \"scene\":\n      case \"sun\":\n        return true;\n      case \"timer\":\n        return true;\n      case \"sensor\":\n        return entityState.attributes.device_class === \"moon__phase\";\n      default:\n        return false;\n    }\n  }\n\n  private _computeLabel(domain, entityState, _timerTimeRemaining) {\n    if (\n      entityState.state === UNAVAILABLE ||\n      [\"device_tracker\", \"alarm_control_panel\", \"person\"].includes(domain)\n    ) {\n      // Localize the state with a special state_badge namespace, which has variations of\n      // the state translations that are truncated to fit within the badge label. Translations\n      // are only added for device_tracker, alarm_control_panel and person.\n      return (\n        this.hass!.localize(`state_badge.${domain}.${entityState.state}`) ||\n        this.hass!.localize(`state_badge.default.${entityState.state}`) ||\n        entityState.state\n      );\n    }\n    if (domain === \"timer\") {\n      return secondsToDuration(_timerTimeRemaining);\n    }\n    return entityState.attributes.unit_of_measurement || null;\n  }\n\n  private clearInterval() {\n    if (this._updateRemaining) {\n      clearInterval(this._updateRemaining);\n      this._updateRemaining = undefined;\n    }\n  }\n\n  private startInterval(stateObj) {\n    this.clearInterval();\n    if (stateObj && computeStateDomain(stateObj) === \"timer\") {\n      this.calculateTimerRemaining(stateObj);\n\n      if (stateObj.state === \"active\") {\n        this._updateRemaining = window.setInterval(\n          () => this.calculateTimerRemaining(this.state),\n          1000\n        );\n      }\n    }\n  }\n\n  private calculateTimerRemaining(stateObj) {\n    this._timerTimeRemaining = timerTimeRemaining(stateObj);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        cursor: pointer;\n      }\n      .big {\n        font-size: 70%;\n      }\n      ha-label-badge {\n        --ha-label-badge-color: var(--label-badge-red, #df4c1e);\n      }\n      ha-label-badge.has-unit_of_measurement {\n        --ha-label-badge-label-text-transform: none;\n      }\n\n      ha-label-badge.binary_sensor,\n      ha-label-badge.updater {\n        --ha-label-badge-color: var(--label-badge-blue, #039be5);\n      }\n\n      .red {\n        --ha-label-badge-color: var(--label-badge-red, #df4c1e);\n      }\n\n      .blue {\n        --ha-label-badge-color: var(--label-badge-blue, #039be5);\n      }\n\n      .green {\n        --ha-label-badge-color: var(--label-badge-green, #0da035);\n      }\n\n      .yellow {\n        --ha-label-badge-color: var(--label-badge-yellow, #f4b400);\n      }\n\n      .grey {\n        --ha-label-badge-color: var(--label-badge-grey, var(--paper-grey-500));\n      }\n\n      .warning {\n        --ha-label-badge-color: var(--label-badge-yellow, #f4b400);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-state-label-badge\": HaStateLabelBadge;\n  }\n}\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { property } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\n\nclass HaLabelBadge extends LitElement {\n  @property() public label?: string;\n\n  @property() public description?: string;\n\n  @property() public image?: string;\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"badge-container\">\n        <div class=\"label-badge\" id=\"badge\">\n          <div class=\"value\">\n            <slot></slot>\n          </div>\n          ${this.label\n            ? html`\n                <div\n                  class=${classMap({\n                    label: true,\n                    big: this.label.length > 5,\n                  })}\n                >\n                  <span>${this.label}</span>\n                </div>\n              `\n            : \"\"}\n        </div>\n        ${this.description\n          ? html`<div class=\"title\">${this.description}</div>`\n          : \"\"}\n      </div>\n    `;\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      css`\n        .badge-container {\n          display: inline-block;\n          text-align: center;\n          vertical-align: top;\n          padding: var(--ha-label-badge-padding, 0 0 0 0);\n        }\n        .label-badge {\n          position: relative;\n          display: block;\n          margin: 0 auto;\n          width: var(--ha-label-badge-size, 2.5em);\n          text-align: center;\n          height: var(--ha-label-badge-size, 2.5em);\n          line-height: var(--ha-label-badge-size, 2.5em);\n          font-size: var(--ha-label-badge-font-size, 1.5em);\n          border-radius: 50%;\n          border: 0.1em solid var(--ha-label-badge-color, var(--primary-color));\n          color: var(--label-badge-text-color, rgb(76, 76, 76));\n\n          white-space: nowrap;\n          background-color: var(--label-badge-background-color, white);\n          background-size: cover;\n          transition: border 0.3s ease-in-out;\n        }\n        .label-badge .label.big span {\n          font-size: 90%;\n          padding: 10% 12% 7% 12%; /* push smaller text a bit down to center vertically */\n        }\n        .label-badge .value {\n          font-size: 90%;\n          overflow: hidden;\n          text-overflow: ellipsis;\n        }\n        .label-badge .label {\n          position: absolute;\n          bottom: -1em;\n          /* Make the label as wide as container+border. (parent_borderwidth / font-size) */\n          left: -0.2em;\n          right: -0.2em;\n          line-height: 1em;\n          font-size: 0.5em;\n        }\n        .label-badge .label span {\n          box-sizing: border-box;\n          max-width: 100%;\n          display: inline-block;\n          background-color: var(--ha-label-badge-color, var(--primary-color));\n          color: var(--ha-label-badge-label-color, white);\n          border-radius: 1em;\n          padding: 9% 16% 8% 16%; /* mostly apitalized text, not much descenders => bit more top margin */\n          font-weight: 500;\n          overflow: hidden;\n          text-transform: uppercase;\n          text-overflow: ellipsis;\n          transition: background-color 0.3s ease-in-out;\n          text-transform: var(--ha-label-badge-label-text-transform, uppercase);\n        }\n        .badge-container .title {\n          margin-top: 1em;\n          font-size: var(--ha-label-badge-title-font-size, 0.9em);\n          width: var(--ha-label-badge-title-width, 5em);\n          font-weight: var(--ha-label-badge-title-font-weight, 400);\n          overflow: hidden;\n          text-overflow: ellipsis;\n          line-height: normal;\n        }\n      `,\n    ];\n  }\n\n  protected updated(changedProperties: PropertyValues): void {\n    super.updated(changedProperties);\n    if (changedProperties.has(\"image\")) {\n      this.shadowRoot!.getElementById(\"badge\")!.style.backgroundImage = this\n        .image\n        ? `url(${this.image})`\n        : \"\";\n    }\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-label-badge\": HaLabelBadge;\n  }\n}\n\ncustomElements.define(\"ha-label-badge\", HaLabelBadge);\n","import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { ifDefined } from \"lit/directives/if-defined\";\nimport \"../../../components/entity/ha-state-label-badge\";\nimport { ActionHandlerEvent } from \"../../../data/lovelace\";\nimport { HomeAssistant } from \"../../../types\";\nimport { actionHandler } from \"../common/directives/action-handler-directive\";\nimport { handleAction } from \"../common/handle-action\";\nimport { hasAction } from \"../common/has-action\";\nimport { LovelaceBadge } from \"../types\";\nimport { StateLabelBadgeConfig } from \"./types\";\n\n@customElement(\"hui-state-label-badge\")\nexport class HuiStateLabelBadge extends LitElement implements LovelaceBadge {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property() protected _config?: StateLabelBadgeConfig;\n\n  public setConfig(config: StateLabelBadgeConfig): void {\n    this._config = config;\n  }\n\n  protected render(): TemplateResult {\n    if (!this._config || !this.hass) {\n      return html``;\n    }\n\n    const stateObj = this.hass.states[this._config.entity!];\n\n    return html`\n      <ha-state-label-badge\n        .hass=${this.hass}\n        .state=${stateObj}\n        .name=${this._config.name}\n        .icon=${this._config.icon}\n        .image=${this._config.image}\n        @action=${this._handleAction}\n        .actionHandler=${actionHandler({\n          hasHold: hasAction(this._config!.hold_action),\n          hasDoubleClick: hasAction(this._config!.double_tap_action),\n        })}\n        tabindex=${ifDefined(\n          hasAction(this._config.tap_action) || this._config.entity\n            ? \"0\"\n            : undefined\n        )}\n      ></ha-state-label-badge>\n    `;\n  }\n\n  private _handleAction(ev: ActionHandlerEvent) {\n    handleAction(this, this.hass!, this._config!, ev.detail.action!);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-state-label-badge:focus {\n        outline: none;\n        background: var(--divider-color);\n        border-radius: 4px;\n      }\n      ha-state-label-badge {\n        display: inline-block;\n        padding: 4px 2px 4px 2px;\n        margin: -4px -2px -4px -2px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-state-label-badge\": HuiStateLabelBadge;\n  }\n}\n"],"names":[],"sourceRoot":""}