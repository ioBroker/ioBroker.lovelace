{"version":3,"file":"5334403c.js","mappings":";AAwCA;;AAEA;AACA;;;AAkOA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAhBA;;;;ACnQA;;AC8HA;AACA;AACA;AACA;AACA;AACA;;AAIA;;;AAIA;;AAEA;AACA;AACA;;;;AAMA;;AAGA;AAEA;AACA;AACA;AACA;;;AAMA;AACA;AACA;AAGA;AACA;;;;AAIA;;;AAKA;AACA;;;;;AAKA;;AAIA;AACA;;;;AAIA;AACA;;;;;;AA3KA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA","sources":["webpack://home-assistant-frontend/./src/components/device/ha-device-picker.ts","webpack://home-assistant-frontend/./src/components/ha-checkbox.ts","webpack://home-assistant-frontend/./src/panels/config/integrations/integration-panels/zha/zha-network-visualization-page.ts"],"sourcesContent":["import \"@material/mwc-list/mwc-list-item\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { ComboBoxLitRenderer } from \"lit-vaadin-helpers\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { stringCompare } from \"../../common/string/compare\";\nimport {\n  AreaRegistryEntry,\n  subscribeAreaRegistry,\n} from \"../../data/area_registry\";\nimport {\n  computeDeviceName,\n  DeviceEntityLookup,\n  DeviceRegistryEntry,\n  subscribeDeviceRegistry,\n} from \"../../data/device_registry\";\nimport {\n  EntityRegistryEntry,\n  subscribeEntityRegistry,\n} from \"../../data/entity_registry\";\nimport { SubscribeMixin } from \"../../mixins/subscribe-mixin\";\nimport { PolymerChangedEvent } from \"../../polymer-types\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-combo-box\";\nimport type { HaComboBox } from \"../ha-combo-box\";\n\ninterface Device {\n  name: string;\n  area: string;\n  id: string;\n}\n\nexport type HaDevicePickerDeviceFilterFunc = (\n  device: DeviceRegistryEntry\n) => boolean;\n\nconst rowRenderer: ComboBoxLitRenderer<Device> = (item) => html`<mwc-list-item\n  .twoline=${!!item.area}\n>\n  <span>${item.name}</span>\n  <span slot=\"secondary\">${item.area}</span>\n</mwc-list-item>`;\n\n@customElement(\"ha-device-picker\")\nexport class HaDevicePicker extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  @property() public devices?: DeviceRegistryEntry[];\n\n  @property() public areas?: AreaRegistryEntry[];\n\n  @property() public entities?: EntityRegistryEntry[];\n\n  /**\n   * Show only devices with entities from specific domains.\n   * @type {Array}\n   * @attr include-domains\n   */\n  @property({ type: Array, attribute: \"include-domains\" })\n  public includeDomains?: string[];\n\n  /**\n   * Show no devices with entities of these domains.\n   * @type {Array}\n   * @attr exclude-domains\n   */\n  @property({ type: Array, attribute: \"exclude-domains\" })\n  public excludeDomains?: string[];\n\n  /**\n   * Show only devices with entities of these device classes.\n   * @type {Array}\n   * @attr include-device-classes\n   */\n  @property({ type: Array, attribute: \"include-device-classes\" })\n  public includeDeviceClasses?: string[];\n\n  @property() public deviceFilter?: HaDevicePickerDeviceFilterFunc;\n\n  @property({ type: Boolean }) public disabled?: boolean;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @state() private _opened?: boolean;\n\n  @query(\"ha-combo-box\", true) public comboBox!: HaComboBox;\n\n  private _init = false;\n\n  private _getDevices = memoizeOne(\n    (\n      devices: DeviceRegistryEntry[],\n      areas: AreaRegistryEntry[],\n      entities: EntityRegistryEntry[],\n      includeDomains: this[\"includeDomains\"],\n      excludeDomains: this[\"excludeDomains\"],\n      includeDeviceClasses: this[\"includeDeviceClasses\"],\n      deviceFilter: this[\"deviceFilter\"]\n    ): Device[] => {\n      if (!devices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_devices\"),\n          },\n        ];\n      }\n\n      const deviceEntityLookup: DeviceEntityLookup = {};\n\n      if (includeDomains || excludeDomains || includeDeviceClasses) {\n        for (const entity of entities) {\n          if (!entity.device_id) {\n            continue;\n          }\n          if (!(entity.device_id in deviceEntityLookup)) {\n            deviceEntityLookup[entity.device_id] = [];\n          }\n          deviceEntityLookup[entity.device_id].push(entity);\n        }\n      }\n\n      const areaLookup: { [areaId: string]: AreaRegistryEntry } = {};\n      for (const area of areas) {\n        areaLookup[area.area_id] = area;\n      }\n\n      let inputDevices = devices.filter(\n        (device) => device.id === this.value || !device.disabled_by\n      );\n\n      if (includeDomains) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) =>\n            includeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n      }\n\n      if (excludeDomains) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return true;\n          }\n          return entities.every(\n            (entity) =>\n              !excludeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n      }\n\n      if (includeDeviceClasses) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) => {\n            const stateObj = this.hass.states[entity.entity_id];\n            if (!stateObj) {\n              return false;\n            }\n            return (\n              stateObj.attributes.device_class &&\n              includeDeviceClasses.includes(stateObj.attributes.device_class)\n            );\n          });\n        });\n      }\n\n      if (deviceFilter) {\n        inputDevices = inputDevices.filter(\n          (device) =>\n            // We always want to include the device of the current value\n            device.id === this.value || deviceFilter!(device)\n        );\n      }\n\n      const outputDevices = inputDevices.map((device) => ({\n        id: device.id,\n        name: computeDeviceName(\n          device,\n          this.hass,\n          deviceEntityLookup[device.id]\n        ),\n        area:\n          device.area_id && areaLookup[device.area_id]\n            ? areaLookup[device.area_id].name\n            : this.hass.localize(\"ui.components.device-picker.no_area\"),\n      }));\n      if (!outputDevices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_match\"),\n          },\n        ];\n      }\n      if (outputDevices.length === 1) {\n        return outputDevices;\n      }\n      return outputDevices.sort((a, b) =>\n        stringCompare(a.name || \"\", b.name || \"\")\n      );\n    }\n  );\n\n  public open() {\n    this.comboBox?.open();\n  }\n\n  public focus() {\n    this.comboBox?.focus();\n  }\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      subscribeDeviceRegistry(this.hass.connection!, (devices) => {\n        this.devices = devices;\n      }),\n      subscribeAreaRegistry(this.hass.connection!, (areas) => {\n        this.areas = areas;\n      }),\n      subscribeEntityRegistry(this.hass.connection!, (entities) => {\n        this.entities = entities;\n      }),\n    ];\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    if (\n      (!this._init && this.devices && this.areas && this.entities) ||\n      (changedProps.has(\"_opened\") && this._opened)\n    ) {\n      this._init = true;\n      (this.comboBox as any).items = this._getDevices(\n        this.devices!,\n        this.areas!,\n        this.entities!,\n        this.includeDomains,\n        this.excludeDomains,\n        this.includeDeviceClasses,\n        this.deviceFilter\n      );\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.devices || !this.areas || !this.entities) {\n      return html``;\n    }\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        .label=${this.label === undefined && this.hass\n          ? this.hass.localize(\"ui.components.device-picker.device\")\n          : this.label}\n        .value=${this._value}\n        .helper=${this.helper}\n        .renderer=${rowRenderer}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        item-value-path=\"id\"\n        item-label-path=\"name\"\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._deviceChanged}\n      ></ha-combo-box>\n    `;\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  private _deviceChanged(ev: PolymerChangedEvent<string>) {\n    ev.stopPropagation();\n    let newValue = ev.detail.value;\n\n    if (newValue === \"no_devices\") {\n      newValue = \"\";\n    }\n\n    if (newValue !== this._value) {\n      this._setValue(newValue);\n    }\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n  }\n\n  private _setValue(value: string) {\n    this.value = value;\n    setTimeout(() => {\n      fireEvent(this, \"value-changed\", { value });\n      fireEvent(this, \"change\");\n    }, 0);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-device-picker\": HaDevicePicker;\n  }\n}\n","import { CheckboxBase } from \"@material/mwc-checkbox/mwc-checkbox-base\";\nimport { styles } from \"@material/mwc-checkbox/mwc-checkbox.css\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\n\n@customElement(\"ha-checkbox\")\nexport class HaCheckbox extends CheckboxBase {\n  static override styles = [\n    styles,\n    css`\n      :host {\n        --mdc-theme-secondary: var(--primary-color);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-checkbox\": HaCheckbox;\n  }\n}\n","import \"@material/mwc-button\";\nimport { css, CSSResultGroup, html, LitElement, PropertyValues } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport {\n  Edge,\n  EdgeOptions,\n  Network,\n  Node,\n} from \"vis-network/peer/esm/vis-network\";\nimport { navigate } from \"../../../../../common/navigate\";\nimport \"../../../../../components/search-input\";\nimport \"../../../../../components/device/ha-device-picker\";\nimport \"../../../../../components/ha-button-menu\";\nimport \"../../../../../components/ha-checkbox\";\nimport type { HaCheckbox } from \"../../../../../components/ha-checkbox\";\nimport \"../../../../../components/ha-formfield\";\nimport { DeviceRegistryEntry } from \"../../../../../data/device_registry\";\nimport {\n  fetchDevices,\n  refreshTopology,\n  ZHADevice,\n} from \"../../../../../data/zha\";\nimport \"../../../../../layouts/hass-tabs-subpage\";\nimport { PolymerChangedEvent } from \"../../../../../polymer-types\";\nimport type { HomeAssistant, Route } from \"../../../../../types\";\nimport { formatAsPaddedHex } from \"./functions\";\nimport { zhaTabs } from \"./zha-config-dashboard\";\n\n@customElement(\"zha-network-visualization-page\")\nexport class ZHANetworkVisualizationPage extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public route!: Route;\n\n  @property({ type: Boolean, reflect: true }) public narrow!: boolean;\n\n  @property({ type: Boolean }) public isWide!: boolean;\n\n  @property()\n  public zoomedDeviceId?: string;\n\n  @query(\"#visualization\", true)\n  private _visualization?: HTMLElement;\n\n  @state()\n  private _devices: Map<string, ZHADevice> = new Map();\n\n  @state()\n  private _devicesByDeviceId: Map<string, ZHADevice> = new Map();\n\n  @state()\n  private _nodes: Node[] = [];\n\n  @state()\n  private _network?: Network;\n\n  @state()\n  private _filter?: string;\n\n  private _autoZoom = true;\n\n  private _enablePhysics = true;\n\n  protected firstUpdated(changedProperties: PropertyValues): void {\n    super.firstUpdated(changedProperties);\n\n    if (this.hass) {\n      this._fetchData();\n    }\n\n    this._network = new Network(\n      this._visualization!,\n      {},\n      {\n        autoResize: true,\n        layout: {\n          improvedLayout: true,\n        },\n        physics: {\n          barnesHut: {\n            springConstant: 0,\n            avoidOverlap: 10,\n            damping: 0.09,\n          },\n        },\n        nodes: {\n          font: {\n            multi: \"html\",\n          },\n        },\n        edges: {\n          smooth: {\n            enabled: true,\n            type: \"continuous\",\n            forceDirection: \"none\",\n            roundness: 0.6,\n          },\n        },\n      }\n    );\n\n    this._network.on(\"doubleClick\", (properties) => {\n      const ieee = properties.nodes[0];\n      if (ieee) {\n        const device = this._devices.get(ieee);\n        if (device) {\n          navigate(`/config/devices/device/${device.device_reg_id}`);\n        }\n      }\n    });\n\n    this._network.on(\"click\", (properties) => {\n      const ieee = properties.nodes[0];\n      if (ieee) {\n        const device = this._devices.get(ieee);\n        if (device && this._autoZoom) {\n          this.zoomedDeviceId = device.device_reg_id;\n          this._zoomToDevice();\n        }\n      }\n    });\n\n    this._network.on(\"stabilized\", () => {\n      if (this.zoomedDeviceId) {\n        this._zoomToDevice();\n      }\n    });\n  }\n\n  protected render() {\n    return html`\n      <hass-tabs-subpage\n        .tabs=${zhaTabs}\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n        .isWide=${this.isWide}\n        .route=${this.route}\n        .header=${this.hass.localize(\n          \"ui.panel.config.zha.visualization.header\"\n        )}\n      >\n        ${this.narrow\n          ? html`\n              <div slot=\"header\">\n                <search-input\n                  .hass=${this.hass}\n                  class=\"header\"\n                  @value-changed=${this._handleSearchChange}\n                  .filter=${this._filter}\n                  .label=${this.hass.localize(\n                    \"ui.panel.config.zha.visualization.highlight_label\"\n                  )}\n                >\n                </search-input>\n              </div>\n            `\n          : \"\"}\n        <div class=\"header\">\n          ${!this.narrow\n            ? html`<search-input\n                .hass=${this.hass}\n                @value-changed=${this._handleSearchChange}\n                .filter=${this._filter}\n                .label=${this.hass.localize(\n                  \"ui.panel.config.zha.visualization.highlight_label\"\n                )}\n              ></search-input>`\n            : \"\"}\n          <ha-device-picker\n            .hass=${this.hass}\n            .value=${this.zoomedDeviceId}\n            .label=${this.hass.localize(\n              \"ui.panel.config.zha.visualization.zoom_label\"\n            )}\n            .deviceFilter=${this._filterDevices}\n            @value-changed=${this._onZoomToDevice}\n          ></ha-device-picker>\n          <div class=\"controls\">\n            <ha-formfield\n              .label=${this.hass!.localize(\n                \"ui.panel.config.zha.visualization.auto_zoom\"\n              )}\n            >\n              <ha-checkbox\n                @change=${this._handleAutoZoomCheckboxChange}\n                .checked=${this._autoZoom}\n              >\n              </ha-checkbox>\n            </ha-formfield>\n            <ha-formfield\n              .label=${this.hass!.localize(\n                \"ui.panel.config.zha.visualization.enable_physics\"\n              )}\n              ><ha-checkbox\n                @change=${this._handlePhysicsCheckboxChange}\n                .checked=${this._enablePhysics}\n              >\n              </ha-checkbox\n            ></ha-formfield>\n            <mwc-button @click=${this._refreshTopology}>\n              ${this.hass!.localize(\n                \"ui.panel.config.zha.visualization.refresh_topology\"\n              )}\n            </mwc-button>\n          </div>\n        </div>\n        <div id=\"visualization\"></div>\n      </hass-tabs-subpage>\n    `;\n  }\n\n  private async _fetchData() {\n    const devices = await fetchDevices(this.hass!);\n    this._devices = new Map(\n      devices.map((device: ZHADevice) => [device.ieee, device])\n    );\n    this._devicesByDeviceId = new Map(\n      devices.map((device: ZHADevice) => [device.device_reg_id, device])\n    );\n    this._updateDevices(devices);\n  }\n\n  private _updateDevices(devices: ZHADevice[]) {\n    this._nodes = [];\n    const edges: Edge[] = [];\n\n    devices.forEach((device) => {\n      this._nodes.push({\n        id: device.ieee,\n        label: this._buildLabel(device),\n        shape: this._getShape(device),\n        mass: this._getMass(device),\n      });\n      if (device.neighbors && device.neighbors.length > 0) {\n        device.neighbors.forEach((neighbor) => {\n          const idx = edges.findIndex(\n            (e) => device.ieee === e.to && neighbor.ieee === e.from\n          );\n          if (idx === -1) {\n            edges.push({\n              from: device.ieee,\n              to: neighbor.ieee,\n              label: neighbor.lqi + \"\",\n              color: this._getLQI(parseInt(neighbor.lqi)),\n            });\n          } else {\n            edges[idx].color = this._getLQI(\n              (parseInt(edges[idx].label!) + parseInt(neighbor.lqi)) / 2\n            );\n            edges[idx].label += \"/\" + neighbor.lqi;\n          }\n        });\n      }\n    });\n\n    this._network?.setData({ nodes: this._nodes, edges: edges });\n  }\n\n  private _getLQI(lqi: number): EdgeOptions[\"color\"] {\n    if (lqi > 192) {\n      return { color: \"#17ab00\", highlight: \"#17ab00\" };\n    }\n    if (lqi > 128) {\n      return { color: \"#e6b402\", highlight: \"#e6b402\" };\n    }\n    if (lqi > 80) {\n      return { color: \"#fc4c4c\", highlight: \"#fc4c4c\" };\n    }\n    return { color: \"#bfbfbf\", highlight: \"#bfbfbf\" };\n  }\n\n  private _getMass(device: ZHADevice): number {\n    if (device.device_type === \"Coordinator\") {\n      return 2;\n    }\n    if (device.device_type === \"Router\") {\n      return 4;\n    }\n    return 5;\n  }\n\n  private _getShape(device: ZHADevice): string {\n    if (device.device_type === \"Coordinator\") {\n      return \"box\";\n    }\n    if (device.device_type === \"Router\") {\n      return \"ellipse\";\n    }\n    return \"circle\";\n  }\n\n  private _buildLabel(device: ZHADevice): string {\n    let label =\n      device.user_given_name !== null\n        ? `<b>${device.user_given_name}</b>\\n`\n        : \"\";\n    label += `<b>IEEE: </b>${device.ieee}`;\n    label += `\\n<b>Device Type: </b>${device.device_type.replace(\"_\", \" \")}`;\n    if (device.nwk != null) {\n      label += `\\n<b>NWK: </b>${formatAsPaddedHex(device.nwk)}`;\n    }\n    if (device.manufacturer != null && device.model != null) {\n      label += `\\n<b>Device: </b>${device.manufacturer} ${device.model}`;\n    } else {\n      label += \"\\n<b>Device is not in <i>'zigbee.db'</i></b>\";\n    }\n    if (!device.available) {\n      label += \"\\n<b>Device is <i>Offline</i></b>\";\n    }\n    return label;\n  }\n\n  private _handleSearchChange(ev: CustomEvent) {\n    this._filter = ev.detail.value;\n    const filterText = this._filter!.toLowerCase();\n    if (!this._network) {\n      return;\n    }\n    if (this._filter) {\n      const filteredNodeIds: (string | number)[] = [];\n      this._nodes.forEach((node) => {\n        if (node.label && node.label.toLowerCase().includes(filterText)) {\n          filteredNodeIds.push(node.id!);\n        }\n      });\n      this.zoomedDeviceId = \"\";\n      this._zoomOut();\n      this._network.selectNodes(filteredNodeIds, true);\n    } else {\n      this._network.unselectAll();\n    }\n  }\n\n  private _onZoomToDevice(event: PolymerChangedEvent<string>) {\n    event.stopPropagation();\n    this.zoomedDeviceId = event.detail.value;\n    if (!this._network) {\n      return;\n    }\n    this._zoomToDevice();\n  }\n\n  private _zoomToDevice() {\n    this._filter = \"\";\n    if (!this.zoomedDeviceId) {\n      this._zoomOut();\n    } else {\n      const device: ZHADevice | undefined = this._devicesByDeviceId.get(\n        this.zoomedDeviceId\n      );\n      if (device) {\n        this._network!.fit({\n          nodes: [device.ieee],\n          animation: { duration: 500, easingFunction: \"easeInQuad\" },\n        });\n      }\n    }\n  }\n\n  private _zoomOut() {\n    this._network!.fit({\n      nodes: [],\n      animation: { duration: 500, easingFunction: \"easeOutQuad\" },\n    });\n  }\n\n  private async _refreshTopology(): Promise<void> {\n    await refreshTopology(this.hass);\n  }\n\n  private _filterDevices = (device: DeviceRegistryEntry): boolean => {\n    if (!this.hass) {\n      return false;\n    }\n    for (const parts of device.identifiers) {\n      for (const part of parts) {\n        if (part === \"zha\") {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  private _handleAutoZoomCheckboxChange(ev: Event) {\n    this._autoZoom = (ev.target as HaCheckbox).checked;\n  }\n\n  private _handlePhysicsCheckboxChange(ev: Event) {\n    this._enablePhysics = (ev.target as HaCheckbox).checked;\n\n    this._network!.setOptions(\n      this._enablePhysics\n        ? {\n            physics: {\n              barnesHut: {\n                springConstant: 0,\n                avoidOverlap: 10,\n                damping: 0.09,\n              },\n            },\n          }\n        : { physics: false }\n    );\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      css`\n        .header {\n          border-bottom: 1px solid var(--divider-color);\n          padding: 0 8px;\n          display: flex;\n          align-items: center;\n          justify-content: space-between;\n          height: var(--header-height);\n          box-sizing: border-box;\n        }\n\n        .header > * {\n          padding: 0 8px;\n        }\n\n        :host([narrow]) .header {\n          flex-direction: column;\n          align-items: stretch;\n          height: var(--header-height) * 2;\n        }\n\n        .search-toolbar {\n          display: flex;\n          align-items: center;\n          color: var(--secondary-text-color);\n          padding: 0 16px;\n        }\n\n        search-input {\n          flex: 1;\n          display: block;\n        }\n\n        search-input.header {\n          color: var(--secondary-text-color);\n        }\n\n        ha-device-picker {\n          flex: 1;\n        }\n\n        .controls {\n          display: flex;\n          align-items: center;\n          justify-content: space-between;\n        }\n\n        #visualization {\n          height: calc(100% - var(--header-height));\n          width: 100%;\n        }\n        :host([narrow]) #visualization {\n          height: calc(100% - (var(--header-height) * 2));\n        }\n      `,\n    ];\n  }\n}\n"],"names":[],"sourceRoot":""}