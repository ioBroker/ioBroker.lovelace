"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_fullcalendar_core_locales-all_js-node_modules_fullcalendar_core_main_js--5760cd"],{

/***/ "./node_modules/@fullcalendar/common/main.js":
/*!***************************************************!*\
  !*** ./node_modules/@fullcalendar/common/main.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Component\": () => (/* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.Component),\n/* harmony export */   \"Fragment\": () => (/* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment),\n/* harmony export */   \"createContext\": () => (/* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createContext),\n/* harmony export */   \"createElement\": () => (/* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement),\n/* harmony export */   \"createPortal\": () => (/* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createPortal),\n/* harmony export */   \"createRef\": () => (/* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef),\n/* harmony export */   \"flushToDom\": () => (/* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.flushToDom),\n/* harmony export */   \"render\": () => (/* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.render),\n/* harmony export */   \"unmountComponentAtNode\": () => (/* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.unmountComponentAtNode),\n/* harmony export */   \"BASE_OPTION_DEFAULTS\": () => (/* binding */ BASE_OPTION_DEFAULTS),\n/* harmony export */   \"BASE_OPTION_REFINERS\": () => (/* binding */ BASE_OPTION_REFINERS),\n/* harmony export */   \"BaseComponent\": () => (/* binding */ BaseComponent),\n/* harmony export */   \"BgEvent\": () => (/* binding */ BgEvent),\n/* harmony export */   \"CalendarApi\": () => (/* binding */ CalendarApi),\n/* harmony export */   \"CalendarContent\": () => (/* binding */ CalendarContent),\n/* harmony export */   \"CalendarDataManager\": () => (/* binding */ CalendarDataManager),\n/* harmony export */   \"CalendarDataProvider\": () => (/* binding */ CalendarDataProvider),\n/* harmony export */   \"CalendarRoot\": () => (/* binding */ CalendarRoot),\n/* harmony export */   \"ContentHook\": () => (/* binding */ ContentHook),\n/* harmony export */   \"CustomContentRenderContext\": () => (/* binding */ CustomContentRenderContext),\n/* harmony export */   \"DateComponent\": () => (/* binding */ DateComponent),\n/* harmony export */   \"DateEnv\": () => (/* binding */ DateEnv),\n/* harmony export */   \"DateProfileGenerator\": () => (/* binding */ DateProfileGenerator),\n/* harmony export */   \"DayCellContent\": () => (/* binding */ DayCellContent),\n/* harmony export */   \"DayCellRoot\": () => (/* binding */ DayCellRoot),\n/* harmony export */   \"DayHeader\": () => (/* binding */ DayHeader),\n/* harmony export */   \"DaySeriesModel\": () => (/* binding */ DaySeriesModel),\n/* harmony export */   \"DayTableModel\": () => (/* binding */ DayTableModel),\n/* harmony export */   \"DelayedRunner\": () => (/* binding */ DelayedRunner),\n/* harmony export */   \"ElementDragging\": () => (/* binding */ ElementDragging),\n/* harmony export */   \"ElementScrollController\": () => (/* binding */ ElementScrollController),\n/* harmony export */   \"Emitter\": () => (/* binding */ Emitter),\n/* harmony export */   \"EventApi\": () => (/* binding */ EventApi),\n/* harmony export */   \"EventRoot\": () => (/* binding */ EventRoot),\n/* harmony export */   \"EventSourceApi\": () => (/* binding */ EventSourceApi),\n/* harmony export */   \"Interaction\": () => (/* binding */ Interaction),\n/* harmony export */   \"MoreLinkRoot\": () => (/* binding */ MoreLinkRoot),\n/* harmony export */   \"MountHook\": () => (/* binding */ MountHook),\n/* harmony export */   \"NamedTimeZoneImpl\": () => (/* binding */ NamedTimeZoneImpl),\n/* harmony export */   \"NowIndicatorRoot\": () => (/* binding */ NowIndicatorRoot),\n/* harmony export */   \"NowTimer\": () => (/* binding */ NowTimer),\n/* harmony export */   \"PositionCache\": () => (/* binding */ PositionCache),\n/* harmony export */   \"RefMap\": () => (/* binding */ RefMap),\n/* harmony export */   \"RenderHook\": () => (/* binding */ RenderHook),\n/* harmony export */   \"ScrollController\": () => (/* binding */ ScrollController),\n/* harmony export */   \"ScrollResponder\": () => (/* binding */ ScrollResponder),\n/* harmony export */   \"Scroller\": () => (/* binding */ Scroller),\n/* harmony export */   \"SegHierarchy\": () => (/* binding */ SegHierarchy),\n/* harmony export */   \"SimpleScrollGrid\": () => (/* binding */ SimpleScrollGrid),\n/* harmony export */   \"Slicer\": () => (/* binding */ Slicer),\n/* harmony export */   \"Splitter\": () => (/* binding */ Splitter),\n/* harmony export */   \"StandardEvent\": () => (/* binding */ StandardEvent),\n/* harmony export */   \"TableDateCell\": () => (/* binding */ TableDateCell),\n/* harmony export */   \"TableDowCell\": () => (/* binding */ TableDowCell),\n/* harmony export */   \"Theme\": () => (/* binding */ Theme),\n/* harmony export */   \"ViewApi\": () => (/* binding */ ViewApi),\n/* harmony export */   \"ViewContextType\": () => (/* binding */ ViewContextType),\n/* harmony export */   \"ViewRoot\": () => (/* binding */ ViewRoot),\n/* harmony export */   \"WeekNumberRoot\": () => (/* binding */ WeekNumberRoot),\n/* harmony export */   \"WindowScrollController\": () => (/* binding */ WindowScrollController),\n/* harmony export */   \"addDays\": () => (/* binding */ addDays),\n/* harmony export */   \"addDurations\": () => (/* binding */ addDurations),\n/* harmony export */   \"addMs\": () => (/* binding */ addMs),\n/* harmony export */   \"addWeeks\": () => (/* binding */ addWeeks),\n/* harmony export */   \"allowContextMenu\": () => (/* binding */ allowContextMenu),\n/* harmony export */   \"allowSelection\": () => (/* binding */ allowSelection),\n/* harmony export */   \"applyMutationToEventStore\": () => (/* binding */ applyMutationToEventStore),\n/* harmony export */   \"applyStyle\": () => (/* binding */ applyStyle),\n/* harmony export */   \"applyStyleProp\": () => (/* binding */ applyStyleProp),\n/* harmony export */   \"asCleanDays\": () => (/* binding */ asCleanDays),\n/* harmony export */   \"asRoughMinutes\": () => (/* binding */ asRoughMinutes),\n/* harmony export */   \"asRoughMs\": () => (/* binding */ asRoughMs),\n/* harmony export */   \"asRoughSeconds\": () => (/* binding */ asRoughSeconds),\n/* harmony export */   \"binarySearch\": () => (/* binding */ binarySearch),\n/* harmony export */   \"buildClassNameNormalizer\": () => (/* binding */ buildClassNameNormalizer),\n/* harmony export */   \"buildEntryKey\": () => (/* binding */ buildEntryKey),\n/* harmony export */   \"buildEventApis\": () => (/* binding */ buildEventApis),\n/* harmony export */   \"buildEventRangeKey\": () => (/* binding */ buildEventRangeKey),\n/* harmony export */   \"buildHashFromArray\": () => (/* binding */ buildHashFromArray),\n/* harmony export */   \"buildIsoString\": () => (/* binding */ buildIsoString),\n/* harmony export */   \"buildNavLinkData\": () => (/* binding */ buildNavLinkData),\n/* harmony export */   \"buildSegCompareObj\": () => (/* binding */ buildSegCompareObj),\n/* harmony export */   \"buildSegTimeText\": () => (/* binding */ buildSegTimeText),\n/* harmony export */   \"collectFromHash\": () => (/* binding */ collectFromHash),\n/* harmony export */   \"combineEventUis\": () => (/* binding */ combineEventUis),\n/* harmony export */   \"compareByFieldSpec\": () => (/* binding */ compareByFieldSpec),\n/* harmony export */   \"compareByFieldSpecs\": () => (/* binding */ compareByFieldSpecs),\n/* harmony export */   \"compareNumbers\": () => (/* binding */ compareNumbers),\n/* harmony export */   \"compareObjs\": () => (/* binding */ compareObjs),\n/* harmony export */   \"computeEarliestSegStart\": () => (/* binding */ computeEarliestSegStart),\n/* harmony export */   \"computeEdges\": () => (/* binding */ computeEdges),\n/* harmony export */   \"computeFallbackHeaderFormat\": () => (/* binding */ computeFallbackHeaderFormat),\n/* harmony export */   \"computeHeightAndMargins\": () => (/* binding */ computeHeightAndMargins),\n/* harmony export */   \"computeInnerRect\": () => (/* binding */ computeInnerRect),\n/* harmony export */   \"computeRect\": () => (/* binding */ computeRect),\n/* harmony export */   \"computeSegDraggable\": () => (/* binding */ computeSegDraggable),\n/* harmony export */   \"computeSegEndResizable\": () => (/* binding */ computeSegEndResizable),\n/* harmony export */   \"computeSegStartResizable\": () => (/* binding */ computeSegStartResizable),\n/* harmony export */   \"computeShrinkWidth\": () => (/* binding */ computeShrinkWidth),\n/* harmony export */   \"computeSmallestCellWidth\": () => (/* binding */ computeSmallestCellWidth),\n/* harmony export */   \"computeVisibleDayRange\": () => (/* binding */ computeVisibleDayRange),\n/* harmony export */   \"config\": () => (/* binding */ config),\n/* harmony export */   \"constrainPoint\": () => (/* binding */ constrainPoint),\n/* harmony export */   \"createDuration\": () => (/* binding */ createDuration),\n/* harmony export */   \"createEmptyEventStore\": () => (/* binding */ createEmptyEventStore),\n/* harmony export */   \"createEventInstance\": () => (/* binding */ createEventInstance),\n/* harmony export */   \"createEventUi\": () => (/* binding */ createEventUi),\n/* harmony export */   \"createFormatter\": () => (/* binding */ createFormatter),\n/* harmony export */   \"createPlugin\": () => (/* binding */ createPlugin),\n/* harmony export */   \"diffDates\": () => (/* binding */ diffDates),\n/* harmony export */   \"diffDayAndTime\": () => (/* binding */ diffDayAndTime),\n/* harmony export */   \"diffDays\": () => (/* binding */ diffDays),\n/* harmony export */   \"diffPoints\": () => (/* binding */ diffPoints),\n/* harmony export */   \"diffWeeks\": () => (/* binding */ diffWeeks),\n/* harmony export */   \"diffWholeDays\": () => (/* binding */ diffWholeDays),\n/* harmony export */   \"diffWholeWeeks\": () => (/* binding */ diffWholeWeeks),\n/* harmony export */   \"disableCursor\": () => (/* binding */ disableCursor),\n/* harmony export */   \"elementClosest\": () => (/* binding */ elementClosest),\n/* harmony export */   \"elementMatches\": () => (/* binding */ elementMatches),\n/* harmony export */   \"enableCursor\": () => (/* binding */ enableCursor),\n/* harmony export */   \"eventTupleToStore\": () => (/* binding */ eventTupleToStore),\n/* harmony export */   \"filterEventStoreDefs\": () => (/* binding */ filterEventStoreDefs),\n/* harmony export */   \"filterHash\": () => (/* binding */ filterHash),\n/* harmony export */   \"findDirectChildren\": () => (/* binding */ findDirectChildren),\n/* harmony export */   \"findElements\": () => (/* binding */ findElements),\n/* harmony export */   \"flexibleCompare\": () => (/* binding */ flexibleCompare),\n/* harmony export */   \"formatDate\": () => (/* binding */ formatDate),\n/* harmony export */   \"formatDayString\": () => (/* binding */ formatDayString),\n/* harmony export */   \"formatIsoTimeString\": () => (/* binding */ formatIsoTimeString),\n/* harmony export */   \"formatRange\": () => (/* binding */ formatRange),\n/* harmony export */   \"getAllowYScrolling\": () => (/* binding */ getAllowYScrolling),\n/* harmony export */   \"getCanVGrowWithinCell\": () => (/* binding */ getCanVGrowWithinCell),\n/* harmony export */   \"getClippingParents\": () => (/* binding */ getClippingParents),\n/* harmony export */   \"getDateMeta\": () => (/* binding */ getDateMeta),\n/* harmony export */   \"getDayClassNames\": () => (/* binding */ getDayClassNames),\n/* harmony export */   \"getDefaultEventEnd\": () => (/* binding */ getDefaultEventEnd),\n/* harmony export */   \"getElRoot\": () => (/* binding */ getElRoot),\n/* harmony export */   \"getElSeg\": () => (/* binding */ getElSeg),\n/* harmony export */   \"getEntrySpanEnd\": () => (/* binding */ getEntrySpanEnd),\n/* harmony export */   \"getEventClassNames\": () => (/* binding */ getEventClassNames),\n/* harmony export */   \"getEventTargetViaRoot\": () => (/* binding */ getEventTargetViaRoot),\n/* harmony export */   \"getIsRtlScrollbarOnLeft\": () => (/* binding */ getIsRtlScrollbarOnLeft),\n/* harmony export */   \"getRectCenter\": () => (/* binding */ getRectCenter),\n/* harmony export */   \"getRelevantEvents\": () => (/* binding */ getRelevantEvents),\n/* harmony export */   \"getScrollGridClassNames\": () => (/* binding */ getScrollGridClassNames),\n/* harmony export */   \"getScrollbarWidths\": () => (/* binding */ getScrollbarWidths),\n/* harmony export */   \"getSectionClassNames\": () => (/* binding */ getSectionClassNames),\n/* harmony export */   \"getSectionHasLiquidHeight\": () => (/* binding */ getSectionHasLiquidHeight),\n/* harmony export */   \"getSegMeta\": () => (/* binding */ getSegMeta),\n/* harmony export */   \"getSlotClassNames\": () => (/* binding */ getSlotClassNames),\n/* harmony export */   \"getStickyFooterScrollbar\": () => (/* binding */ getStickyFooterScrollbar),\n/* harmony export */   \"getStickyHeaderDates\": () => (/* binding */ getStickyHeaderDates),\n/* harmony export */   \"getUnequalProps\": () => (/* binding */ getUnequalProps),\n/* harmony export */   \"globalLocales\": () => (/* binding */ globalLocales),\n/* harmony export */   \"globalPlugins\": () => (/* binding */ globalPlugins),\n/* harmony export */   \"greatestDurationDenominator\": () => (/* binding */ greatestDurationDenominator),\n/* harmony export */   \"groupIntersectingEntries\": () => (/* binding */ groupIntersectingEntries),\n/* harmony export */   \"guid\": () => (/* binding */ guid),\n/* harmony export */   \"hasBgRendering\": () => (/* binding */ hasBgRendering),\n/* harmony export */   \"hasShrinkWidth\": () => (/* binding */ hasShrinkWidth),\n/* harmony export */   \"identity\": () => (/* binding */ identity),\n/* harmony export */   \"interactionSettingsStore\": () => (/* binding */ interactionSettingsStore),\n/* harmony export */   \"interactionSettingsToStore\": () => (/* binding */ interactionSettingsToStore),\n/* harmony export */   \"intersectRanges\": () => (/* binding */ intersectRanges),\n/* harmony export */   \"intersectRects\": () => (/* binding */ intersectRects),\n/* harmony export */   \"intersectSpans\": () => (/* binding */ intersectSpans),\n/* harmony export */   \"isArraysEqual\": () => (/* binding */ isArraysEqual),\n/* harmony export */   \"isColPropsEqual\": () => (/* binding */ isColPropsEqual),\n/* harmony export */   \"isDateSelectionValid\": () => (/* binding */ isDateSelectionValid),\n/* harmony export */   \"isDateSpansEqual\": () => (/* binding */ isDateSpansEqual),\n/* harmony export */   \"isInt\": () => (/* binding */ isInt),\n/* harmony export */   \"isInteractionValid\": () => (/* binding */ isInteractionValid),\n/* harmony export */   \"isMultiDayRange\": () => (/* binding */ isMultiDayRange),\n/* harmony export */   \"isPropsEqual\": () => (/* binding */ isPropsEqual),\n/* harmony export */   \"isPropsValid\": () => (/* binding */ isPropsValid),\n/* harmony export */   \"isValidDate\": () => (/* binding */ isValidDate),\n/* harmony export */   \"joinSpans\": () => (/* binding */ joinSpans),\n/* harmony export */   \"listenBySelector\": () => (/* binding */ listenBySelector),\n/* harmony export */   \"mapHash\": () => (/* binding */ mapHash),\n/* harmony export */   \"memoize\": () => (/* binding */ memoize),\n/* harmony export */   \"memoizeArraylike\": () => (/* binding */ memoizeArraylike),\n/* harmony export */   \"memoizeHashlike\": () => (/* binding */ memoizeHashlike),\n/* harmony export */   \"memoizeObjArg\": () => (/* binding */ memoizeObjArg),\n/* harmony export */   \"mergeEventStores\": () => (/* binding */ mergeEventStores),\n/* harmony export */   \"multiplyDuration\": () => (/* binding */ multiplyDuration),\n/* harmony export */   \"padStart\": () => (/* binding */ padStart),\n/* harmony export */   \"parseBusinessHours\": () => (/* binding */ parseBusinessHours),\n/* harmony export */   \"parseClassNames\": () => (/* binding */ parseClassNames),\n/* harmony export */   \"parseDragMeta\": () => (/* binding */ parseDragMeta),\n/* harmony export */   \"parseEventDef\": () => (/* binding */ parseEventDef),\n/* harmony export */   \"parseFieldSpecs\": () => (/* binding */ parseFieldSpecs),\n/* harmony export */   \"parseMarker\": () => (/* binding */ parse),\n/* harmony export */   \"pointInsideRect\": () => (/* binding */ pointInsideRect),\n/* harmony export */   \"preventContextMenu\": () => (/* binding */ preventContextMenu),\n/* harmony export */   \"preventDefault\": () => (/* binding */ preventDefault),\n/* harmony export */   \"preventSelection\": () => (/* binding */ preventSelection),\n/* harmony export */   \"rangeContainsMarker\": () => (/* binding */ rangeContainsMarker),\n/* harmony export */   \"rangeContainsRange\": () => (/* binding */ rangeContainsRange),\n/* harmony export */   \"rangesEqual\": () => (/* binding */ rangesEqual),\n/* harmony export */   \"rangesIntersect\": () => (/* binding */ rangesIntersect),\n/* harmony export */   \"refineEventDef\": () => (/* binding */ refineEventDef),\n/* harmony export */   \"refineProps\": () => (/* binding */ refineProps),\n/* harmony export */   \"removeElement\": () => (/* binding */ removeElement),\n/* harmony export */   \"removeExact\": () => (/* binding */ removeExact),\n/* harmony export */   \"renderChunkContent\": () => (/* binding */ renderChunkContent),\n/* harmony export */   \"renderFill\": () => (/* binding */ renderFill),\n/* harmony export */   \"renderMicroColGroup\": () => (/* binding */ renderMicroColGroup),\n/* harmony export */   \"renderScrollShim\": () => (/* binding */ renderScrollShim),\n/* harmony export */   \"requestJson\": () => (/* binding */ requestJson),\n/* harmony export */   \"sanitizeShrinkWidth\": () => (/* binding */ sanitizeShrinkWidth),\n/* harmony export */   \"setElSeg\": () => (/* binding */ setElSeg),\n/* harmony export */   \"setRef\": () => (/* binding */ setRef),\n/* harmony export */   \"sliceEventStore\": () => (/* binding */ sliceEventStore),\n/* harmony export */   \"sliceEvents\": () => (/* binding */ sliceEvents),\n/* harmony export */   \"sortEventSegs\": () => (/* binding */ sortEventSegs),\n/* harmony export */   \"startOfDay\": () => (/* binding */ startOfDay),\n/* harmony export */   \"translateRect\": () => (/* binding */ translateRect),\n/* harmony export */   \"triggerDateSelect\": () => (/* binding */ triggerDateSelect),\n/* harmony export */   \"unpromisify\": () => (/* binding */ unpromisify),\n/* harmony export */   \"version\": () => (/* binding */ version),\n/* harmony export */   \"whenTransitionDone\": () => (/* binding */ whenTransitionDone),\n/* harmony export */   \"wholeDivideDurations\": () => (/* binding */ wholeDivideDurations)\n/* harmony export */ });\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ \"./node_modules/@fullcalendar/common/main.css\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _vdom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vdom.js */ \"./node_modules/@fullcalendar/common/vdom.js\");\n/*!\nFullCalendar v5.9.0\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n\n // no public types yet. when there are, export from:\n// import {} from './api-type-deps'\n\nvar EventSourceApi = function () {\n  function EventSourceApi(context, internalEventSource) {\n    this.context = context;\n    this.internalEventSource = internalEventSource;\n  }\n\n  EventSourceApi.prototype.remove = function () {\n    this.context.dispatch({\n      type: 'REMOVE_EVENT_SOURCE',\n      sourceId: this.internalEventSource.sourceId\n    });\n  };\n\n  EventSourceApi.prototype.refetch = function () {\n    this.context.dispatch({\n      type: 'FETCH_EVENT_SOURCES',\n      sourceIds: [this.internalEventSource.sourceId],\n      isRefetch: true\n    });\n  };\n\n  Object.defineProperty(EventSourceApi.prototype, \"id\", {\n    get: function () {\n      return this.internalEventSource.publicId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventSourceApi.prototype, \"url\", {\n    get: function () {\n      return this.internalEventSource.meta.url;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventSourceApi.prototype, \"format\", {\n    get: function () {\n      return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return EventSourceApi;\n}();\n\nfunction removeElement(el) {\n  if (el.parentNode) {\n    el.parentNode.removeChild(el);\n  }\n} // Querying\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction elementClosest(el, selector) {\n  if (el.closest) {\n    return el.closest(selector); // really bad fallback for IE\n    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n  }\n\n  if (!document.documentElement.contains(el)) {\n    return null;\n  }\n\n  do {\n    if (elementMatches(el, selector)) {\n      return el;\n    }\n\n    el = el.parentElement || el.parentNode;\n  } while (el !== null && el.nodeType === 1);\n\n  return null;\n}\n\nfunction elementMatches(el, selector) {\n  var method = el.matches || el.matchesSelector || el.msMatchesSelector;\n  return method.call(el, selector);\n} // accepts multiple subject els\n// returns a real array. good for methods like forEach\n// TODO: accept the document\n\n\nfunction findElements(container, selector) {\n  var containers = container instanceof HTMLElement ? [container] : container;\n  var allMatches = [];\n\n  for (var i = 0; i < containers.length; i += 1) {\n    var matches = containers[i].querySelectorAll(selector);\n\n    for (var j = 0; j < matches.length; j += 1) {\n      allMatches.push(matches[j]);\n    }\n  }\n\n  return allMatches;\n} // accepts multiple subject els\n// only queries direct child elements // TODO: rename to findDirectChildren!\n\n\nfunction findDirectChildren(parent, selector) {\n  var parents = parent instanceof HTMLElement ? [parent] : parent;\n  var allMatches = [];\n\n  for (var i = 0; i < parents.length; i += 1) {\n    var childNodes = parents[i].children; // only ever elements\n\n    for (var j = 0; j < childNodes.length; j += 1) {\n      var childNode = childNodes[j];\n\n      if (!selector || elementMatches(childNode, selector)) {\n        allMatches.push(childNode);\n      }\n    }\n  }\n\n  return allMatches;\n} // Style\n// ----------------------------------------------------------------------------------------------------------------\n\n\nvar PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\n\nfunction applyStyle(el, props) {\n  for (var propName in props) {\n    applyStyleProp(el, propName, props[propName]);\n  }\n}\n\nfunction applyStyleProp(el, name, val) {\n  if (val == null) {\n    el.style[name] = '';\n  } else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {\n    el.style[name] = val + \"px\";\n  } else {\n    el.style[name] = val;\n  }\n} // Event Handling\n// ----------------------------------------------------------------------------------------------------------------\n// if intercepting bubbled events at the document/window/body level,\n// and want to see originating element (the 'target'), use this util instead\n// of `ev.target` because it goes within web-component boundaries.\n\n\nfunction getEventTargetViaRoot(ev) {\n  var _a, _b;\n\n  return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n} // Shadow DOM consuderations\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction getElRoot(el) {\n  return el.getRootNode ? el.getRootNode() : document;\n} // Stops a mouse/touch event from doing it's native browser action\n\n\nfunction preventDefault(ev) {\n  ev.preventDefault();\n} // Event Delegation\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction buildDelegationHandler(selector, handler) {\n  return function (ev) {\n    var matchedChild = elementClosest(ev.target, selector);\n\n    if (matchedChild) {\n      handler.call(matchedChild, ev, matchedChild);\n    }\n  };\n}\n\nfunction listenBySelector(container, eventType, selector, handler) {\n  var attachedHandler = buildDelegationHandler(selector, handler);\n  container.addEventListener(eventType, attachedHandler);\n  return function () {\n    container.removeEventListener(eventType, attachedHandler);\n  };\n}\n\nfunction listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n  var currentMatchedChild;\n  return listenBySelector(container, 'mouseover', selector, function (mouseOverEv, matchedChild) {\n    if (matchedChild !== currentMatchedChild) {\n      currentMatchedChild = matchedChild;\n      onMouseEnter(mouseOverEv, matchedChild);\n\n      var realOnMouseLeave_1 = function (mouseLeaveEv) {\n        currentMatchedChild = null;\n        onMouseLeave(mouseLeaveEv, matchedChild);\n        matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);\n      }; // listen to the next mouseleave, and then unattach\n\n\n      matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);\n    }\n  });\n} // Animation\n// ----------------------------------------------------------------------------------------------------------------\n\n\nvar transitionEventNames = ['webkitTransitionEnd', 'otransitionend', 'oTransitionEnd', 'msTransitionEnd', 'transitionend']; // triggered only when the next single subsequent transition finishes\n\nfunction whenTransitionDone(el, callback) {\n  var realCallback = function (ev) {\n    callback(ev);\n    transitionEventNames.forEach(function (eventName) {\n      el.removeEventListener(eventName, realCallback);\n    });\n  };\n\n  transitionEventNames.forEach(function (eventName) {\n    el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n  });\n}\n\nvar guidNumber = 0;\n\nfunction guid() {\n  guidNumber += 1;\n  return String(guidNumber);\n}\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n// Make the mouse cursor express that an event is not allowed in the current area\n\n\nfunction disableCursor() {\n  document.body.classList.add('fc-not-allowed');\n} // Returns the mouse cursor to its original look\n\n\nfunction enableCursor() {\n  document.body.classList.remove('fc-not-allowed');\n}\n/* Selection\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction preventSelection(el) {\n  el.classList.add('fc-unselectable');\n  el.addEventListener('selectstart', preventDefault);\n}\n\nfunction allowSelection(el) {\n  el.classList.remove('fc-unselectable');\n  el.removeEventListener('selectstart', preventDefault);\n}\n/* Context Menu\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction preventContextMenu(el) {\n  el.addEventListener('contextmenu', preventDefault);\n}\n\nfunction allowContextMenu(el) {\n  el.removeEventListener('contextmenu', preventDefault);\n}\n\nfunction parseFieldSpecs(input) {\n  var specs = [];\n  var tokens = [];\n  var i;\n  var token;\n\n  if (typeof input === 'string') {\n    tokens = input.split(/\\s*,\\s*/);\n  } else if (typeof input === 'function') {\n    tokens = [input];\n  } else if (Array.isArray(input)) {\n    tokens = input;\n  }\n\n  for (i = 0; i < tokens.length; i += 1) {\n    token = tokens[i];\n\n    if (typeof token === 'string') {\n      specs.push(token.charAt(0) === '-' ? {\n        field: token.substring(1),\n        order: -1\n      } : {\n        field: token,\n        order: 1\n      });\n    } else if (typeof token === 'function') {\n      specs.push({\n        func: token\n      });\n    }\n  }\n\n  return specs;\n}\n\nfunction compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n  var i;\n  var cmp;\n\n  for (i = 0; i < fieldSpecs.length; i += 1) {\n    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n\n    if (cmp) {\n      return cmp;\n    }\n  }\n\n  return 0;\n}\n\nfunction compareByFieldSpec(obj0, obj1, fieldSpec) {\n  if (fieldSpec.func) {\n    return fieldSpec.func(obj0, obj1);\n  }\n\n  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n}\n\nfunction flexibleCompare(a, b) {\n  if (!a && !b) {\n    return 0;\n  }\n\n  if (b == null) {\n    return -1;\n  }\n\n  if (a == null) {\n    return 1;\n  }\n\n  if (typeof a === 'string' || typeof b === 'string') {\n    return String(a).localeCompare(String(b));\n  }\n\n  return a - b;\n}\n/* String Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction padStart(val, len) {\n  var s = String(val);\n  return '000'.substr(0, len - s.length) + s;\n}\n/* Number Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nfunction isInt(n) {\n  return n % 1 === 0;\n}\n/* FC-specific DOM dimension stuff\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction computeSmallestCellWidth(cellEl) {\n  var allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');\n  var contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');\n\n  if (!allWidthEl) {\n    throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const\n  }\n\n  if (!contentWidthEl) {\n    throw new Error('needs fc-scrollgrid-shrink-cushion className');\n  }\n\n  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n  contentWidthEl.getBoundingClientRect().width;\n}\n\nvar DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; // Adding\n\nfunction addWeeks(m, n) {\n  var a = dateToUtcArray(m);\n  a[2] += n * 7;\n  return arrayToUtcDate(a);\n}\n\nfunction addDays(m, n) {\n  var a = dateToUtcArray(m);\n  a[2] += n;\n  return arrayToUtcDate(a);\n}\n\nfunction addMs(m, n) {\n  var a = dateToUtcArray(m);\n  a[6] += n;\n  return arrayToUtcDate(a);\n} // Diffing (all return floats)\n// TODO: why not use ranges?\n\n\nfunction diffWeeks(m0, m1) {\n  return diffDays(m0, m1) / 7;\n}\n\nfunction diffDays(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n}\n\nfunction diffHours(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n}\n\nfunction diffMinutes(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n}\n\nfunction diffSeconds(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / 1000;\n}\n\nfunction diffDayAndTime(m0, m1) {\n  var m0day = startOfDay(m0);\n  var m1day = startOfDay(m1);\n  return {\n    years: 0,\n    months: 0,\n    days: Math.round(diffDays(m0day, m1day)),\n    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n  };\n} // Diffing Whole Units\n\n\nfunction diffWholeWeeks(m0, m1) {\n  var d = diffWholeDays(m0, m1);\n\n  if (d !== null && d % 7 === 0) {\n    return d / 7;\n  }\n\n  return null;\n}\n\nfunction diffWholeDays(m0, m1) {\n  if (timeAsMs(m0) === timeAsMs(m1)) {\n    return Math.round(diffDays(m0, m1));\n  }\n\n  return null;\n} // Start-Of\n\n\nfunction startOfDay(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate()]);\n}\n\nfunction startOfHour(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours()]);\n}\n\nfunction startOfMinute(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes()]);\n}\n\nfunction startOfSecond(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes(), m.getUTCSeconds()]);\n} // Week Computation\n\n\nfunction weekOfYear(marker, dow, doy) {\n  var y = marker.getUTCFullYear();\n  var w = weekOfGivenYear(marker, y, dow, doy);\n\n  if (w < 1) {\n    return weekOfGivenYear(marker, y - 1, dow, doy);\n  }\n\n  var nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n\n  if (nextW >= 1) {\n    return Math.min(w, nextW);\n  }\n\n  return w;\n}\n\nfunction weekOfGivenYear(marker, year, dow, doy) {\n  var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);\n  var dayStart = startOfDay(marker);\n  var days = Math.round(diffDays(firstWeekStart, dayStart));\n  return Math.floor(days / 7) + 1; // zero-indexed\n} // start-of-first-week - start-of-year\n\n\nfunction firstWeekOffset(year, dow, doy) {\n  // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n  var fwd = 7 + dow - doy; // first-week day local weekday -- which local weekday is fwd\n\n  var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;\n  return -fwdlw + fwd - 1;\n} // Array Conversion\n\n\nfunction dateToLocalArray(date) {\n  return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];\n}\n\nfunction arrayToLocalDate(a) {\n  return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month\n  a[3] || 0, a[4] || 0, a[5] || 0);\n}\n\nfunction dateToUtcArray(date) {\n  return [date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()];\n}\n\nfunction arrayToUtcDate(a) {\n  // according to web standards (and Safari), a month index is required.\n  // massage if only given a year.\n  if (a.length === 1) {\n    a = a.concat([0]);\n  }\n\n  return new Date(Date.UTC.apply(Date, a));\n} // Other Utils\n\n\nfunction isValidDate(m) {\n  return !isNaN(m.valueOf());\n}\n\nfunction timeAsMs(m) {\n  return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n}\n\nfunction createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n  return {\n    instanceId: guid(),\n    defId: defId,\n    range: range,\n    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n  };\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty; // Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\n\nfunction mergeProps(propObjs, complexPropsMap) {\n  var dest = {};\n\n  if (complexPropsMap) {\n    for (var name_1 in complexPropsMap) {\n      var complexObjs = []; // collect the trailing object values, stopping when a non-object is discovered\n\n      for (var i = propObjs.length - 1; i >= 0; i -= 1) {\n        var val = propObjs[i][name_1];\n\n        if (typeof val === 'object' && val) {\n          // non-null object\n          complexObjs.unshift(val);\n        } else if (val !== undefined) {\n          dest[name_1] = val; // if there were no objects, this value will be used\n\n          break;\n        }\n      } // if the trailing values were objects, use the merged value\n\n\n      if (complexObjs.length) {\n        dest[name_1] = mergeProps(complexObjs);\n      }\n    }\n  } // copy values into the destination, going from last to first\n\n\n  for (var i = propObjs.length - 1; i >= 0; i -= 1) {\n    var props = propObjs[i];\n\n    for (var name_2 in props) {\n      if (!(name_2 in dest)) {\n        // if already assigned by previous props or complex props, don't reassign\n        dest[name_2] = props[name_2];\n      }\n    }\n  }\n\n  return dest;\n}\n\nfunction filterHash(hash, func) {\n  var filtered = {};\n\n  for (var key in hash) {\n    if (func(hash[key], key)) {\n      filtered[key] = hash[key];\n    }\n  }\n\n  return filtered;\n}\n\nfunction mapHash(hash, func) {\n  var newHash = {};\n\n  for (var key in hash) {\n    newHash[key] = func(hash[key], key);\n  }\n\n  return newHash;\n}\n\nfunction arrayToHash(a) {\n  var hash = {};\n\n  for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n    var item = a_1[_i];\n    hash[item] = true;\n  }\n\n  return hash;\n}\n\nfunction buildHashFromArray(a, func) {\n  var hash = {};\n\n  for (var i = 0; i < a.length; i += 1) {\n    var tuple = func(a[i], i);\n    hash[tuple[0]] = tuple[1];\n  }\n\n  return hash;\n}\n\nfunction hashValuesToArray(obj) {\n  var a = [];\n\n  for (var key in obj) {\n    a.push(obj[key]);\n  }\n\n  return a;\n}\n\nfunction isPropsEqual(obj0, obj1) {\n  if (obj0 === obj1) {\n    return true;\n  }\n\n  for (var key in obj0) {\n    if (hasOwnProperty.call(obj0, key)) {\n      if (!(key in obj1)) {\n        return false;\n      }\n    }\n  }\n\n  for (var key in obj1) {\n    if (hasOwnProperty.call(obj1, key)) {\n      if (obj0[key] !== obj1[key]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction getUnequalProps(obj0, obj1) {\n  var keys = [];\n\n  for (var key in obj0) {\n    if (hasOwnProperty.call(obj0, key)) {\n      if (!(key in obj1)) {\n        keys.push(key);\n      }\n    }\n  }\n\n  for (var key in obj1) {\n    if (hasOwnProperty.call(obj1, key)) {\n      if (obj0[key] !== obj1[key]) {\n        keys.push(key);\n      }\n    }\n  }\n\n  return keys;\n}\n\nfunction compareObjs(oldProps, newProps, equalityFuncs) {\n  if (equalityFuncs === void 0) {\n    equalityFuncs = {};\n  }\n\n  if (oldProps === newProps) {\n    return true;\n  }\n\n  for (var key in newProps) {\n    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;else {\n      return false;\n    }\n  } // check for props that were omitted in the new\n\n\n  for (var key in oldProps) {\n    if (!(key in newProps)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*\nassumed \"true\" equality for handler names like \"onReceiveSomething\"\n*/\n\n\nfunction isObjValsEqual(val0, val1, comparator) {\n  if (val0 === val1 || comparator === true) {\n    return true;\n  }\n\n  if (comparator) {\n    return comparator(val0, val1);\n  }\n\n  return false;\n}\n\nfunction collectFromHash(hash, startIndex, endIndex, step) {\n  if (startIndex === void 0) {\n    startIndex = 0;\n  }\n\n  if (step === void 0) {\n    step = 1;\n  }\n\n  var res = [];\n\n  if (endIndex == null) {\n    endIndex = Object.keys(hash).length;\n  }\n\n  for (var i = startIndex; i < endIndex; i += step) {\n    var val = hash[i];\n\n    if (val !== undefined) {\n      // will disregard undefined for sparse arrays\n      res.push(val);\n    }\n  }\n\n  return res;\n}\n\nfunction parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n  for (var i = 0; i < recurringTypes.length; i += 1) {\n    var parsed = recurringTypes[i].parse(refined, dateEnv);\n\n    if (parsed) {\n      var allDay = refined.allDay;\n\n      if (allDay == null) {\n        allDay = defaultAllDay;\n\n        if (allDay == null) {\n          allDay = parsed.allDayGuess;\n\n          if (allDay == null) {\n            allDay = false;\n          }\n        }\n      }\n\n      return {\n        allDay: allDay,\n        duration: parsed.duration,\n        typeData: parsed.typeData,\n        typeId: i\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction expandRecurring(eventStore, framingRange, context) {\n  var dateEnv = context.dateEnv,\n      pluginHooks = context.pluginHooks,\n      options = context.options;\n  var defs = eventStore.defs,\n      instances = eventStore.instances; // remove existing recurring instances\n  // TODO: bad. always expand events as a second step\n\n  instances = filterHash(instances, function (instance) {\n    return !defs[instance.defId].recurringDef;\n  });\n\n  for (var defId in defs) {\n    var def = defs[defId];\n\n    if (def.recurringDef) {\n      var duration = def.recurringDef.duration;\n\n      if (!duration) {\n        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n      }\n\n      var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n\n      for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {\n        var start = starts_1[_i];\n        var instance = createEventInstance(defId, {\n          start: start,\n          end: dateEnv.add(start, duration)\n        });\n        instances[instance.instanceId] = instance;\n      }\n    }\n  }\n\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n/*\nEvent MUST have a recurringDef\n*/\n\n\nfunction expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n  var typeDef = recurringTypes[eventDef.recurringDef.typeId];\n  var markers = typeDef.expand(eventDef.recurringDef.typeData, {\n    start: dateEnv.subtract(framingRange.start, duration),\n    end: framingRange.end\n  }, dateEnv); // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n\n  if (eventDef.allDay) {\n    markers = markers.map(startOfDay);\n  }\n\n  return markers;\n}\n\nvar INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];\nvar PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/; // Parsing and Creation\n\nfunction createDuration(input, unit) {\n  var _a;\n\n  if (typeof input === 'string') {\n    return parseString(input);\n  }\n\n  if (typeof input === 'object' && input) {\n    // non-null object\n    return parseObject(input);\n  }\n\n  if (typeof input === 'number') {\n    return parseObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));\n  }\n\n  return null;\n}\n\nfunction parseString(s) {\n  var m = PARSE_RE.exec(s);\n\n  if (m) {\n    var sign = m[1] ? -1 : 1;\n    return {\n      years: 0,\n      months: 0,\n      days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n      milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n      (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n      (m[5] ? parseInt(m[5], 10) : 0) * 1000 + (m[6] ? parseInt(m[6], 10) : 0) // ms\n      )\n    };\n  }\n\n  return null;\n}\n\nfunction parseObject(obj) {\n  var duration = {\n    years: obj.years || obj.year || 0,\n    months: obj.months || obj.month || 0,\n    days: obj.days || obj.day || 0,\n    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n    (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n    (obj.seconds || obj.second || 0) * 1000 + (obj.milliseconds || obj.millisecond || obj.ms || 0) // ms\n\n  };\n  var weeks = obj.weeks || obj.week;\n\n  if (weeks) {\n    duration.days += weeks * 7;\n    duration.specifiedWeeks = true;\n  }\n\n  return duration;\n} // Equality\n\n\nfunction durationsEqual(d0, d1) {\n  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n}\n\nfunction asCleanDays(dur) {\n  if (!dur.years && !dur.months && !dur.milliseconds) {\n    return dur.days;\n  }\n\n  return 0;\n} // Simple Math\n\n\nfunction addDurations(d0, d1) {\n  return {\n    years: d0.years + d1.years,\n    months: d0.months + d1.months,\n    days: d0.days + d1.days,\n    milliseconds: d0.milliseconds + d1.milliseconds\n  };\n}\n\nfunction subtractDurations(d1, d0) {\n  return {\n    years: d1.years - d0.years,\n    months: d1.months - d0.months,\n    days: d1.days - d0.days,\n    milliseconds: d1.milliseconds - d0.milliseconds\n  };\n}\n\nfunction multiplyDuration(d, n) {\n  return {\n    years: d.years * n,\n    months: d.months * n,\n    days: d.days * n,\n    milliseconds: d.milliseconds * n\n  };\n} // Conversions\n// \"Rough\" because they are based on average-case Gregorian months/years\n\n\nfunction asRoughYears(dur) {\n  return asRoughDays(dur) / 365;\n}\n\nfunction asRoughMonths(dur) {\n  return asRoughDays(dur) / 30;\n}\n\nfunction asRoughDays(dur) {\n  return asRoughMs(dur) / 864e5;\n}\n\nfunction asRoughMinutes(dur) {\n  return asRoughMs(dur) / (1000 * 60);\n}\n\nfunction asRoughSeconds(dur) {\n  return asRoughMs(dur) / 1000;\n}\n\nfunction asRoughMs(dur) {\n  return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n} // Advanced Math\n\n\nfunction wholeDivideDurations(numerator, denominator) {\n  var res = null;\n\n  for (var i = 0; i < INTERNAL_UNITS.length; i += 1) {\n    var unit = INTERNAL_UNITS[i];\n\n    if (denominator[unit]) {\n      var localRes = numerator[unit] / denominator[unit];\n\n      if (!isInt(localRes) || res !== null && res !== localRes) {\n        return null;\n      }\n\n      res = localRes;\n    } else if (numerator[unit]) {\n      // needs to divide by something but can't!\n      return null;\n    }\n  }\n\n  return res;\n}\n\nfunction greatestDurationDenominator(dur) {\n  var ms = dur.milliseconds;\n\n  if (ms) {\n    if (ms % 1000 !== 0) {\n      return {\n        unit: 'millisecond',\n        value: ms\n      };\n    }\n\n    if (ms % (1000 * 60) !== 0) {\n      return {\n        unit: 'second',\n        value: ms / 1000\n      };\n    }\n\n    if (ms % (1000 * 60 * 60) !== 0) {\n      return {\n        unit: 'minute',\n        value: ms / (1000 * 60)\n      };\n    }\n\n    if (ms) {\n      return {\n        unit: 'hour',\n        value: ms / (1000 * 60 * 60)\n      };\n    }\n  }\n\n  if (dur.days) {\n    if (dur.specifiedWeeks && dur.days % 7 === 0) {\n      return {\n        unit: 'week',\n        value: dur.days / 7\n      };\n    }\n\n    return {\n      unit: 'day',\n      value: dur.days\n    };\n  }\n\n  if (dur.months) {\n    return {\n      unit: 'month',\n      value: dur.months\n    };\n  }\n\n  if (dur.years) {\n    return {\n      unit: 'year',\n      value: dur.years\n    };\n  }\n\n  return {\n    unit: 'millisecond',\n    value: 0\n  };\n} // timeZoneOffset is in minutes\n\n\nfunction buildIsoString(marker, timeZoneOffset, stripZeroTime) {\n  if (stripZeroTime === void 0) {\n    stripZeroTime = false;\n  }\n\n  var s = marker.toISOString();\n  s = s.replace('.000', '');\n\n  if (stripZeroTime) {\n    s = s.replace('T00:00:00Z', '');\n  }\n\n  if (s.length > 10) {\n    // time part wasn't stripped, can add timezone info\n    if (timeZoneOffset == null) {\n      s = s.replace('Z', '');\n    } else if (timeZoneOffset !== 0) {\n      s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));\n    } // otherwise, its UTC-0 and we want to keep the Z\n\n  }\n\n  return s;\n} // formats the date, but with no time part\n// TODO: somehow merge with buildIsoString and stripZeroTime\n// TODO: rename. omit \"string\"\n\n\nfunction formatDayString(marker) {\n  return marker.toISOString().replace(/T.*$/, '');\n} // TODO: use Date::toISOString and use everything after the T?\n\n\nfunction formatIsoTimeString(marker) {\n  return padStart(marker.getUTCHours(), 2) + ':' + padStart(marker.getUTCMinutes(), 2) + ':' + padStart(marker.getUTCSeconds(), 2);\n}\n\nfunction formatTimeZoneOffset(minutes, doIso) {\n  if (doIso === void 0) {\n    doIso = false;\n  }\n\n  var sign = minutes < 0 ? '-' : '+';\n  var abs = Math.abs(minutes);\n  var hours = Math.floor(abs / 60);\n  var mins = Math.round(abs % 60);\n\n  if (doIso) {\n    return sign + padStart(hours, 2) + \":\" + padStart(mins, 2);\n  }\n\n  return \"GMT\" + sign + hours + (mins ? \":\" + padStart(mins, 2) : '');\n} // TODO: new util arrayify?\n\n\nfunction removeExact(array, exactVal) {\n  var removeCnt = 0;\n  var i = 0;\n\n  while (i < array.length) {\n    if (array[i] === exactVal) {\n      array.splice(i, 1);\n      removeCnt += 1;\n    } else {\n      i += 1;\n    }\n  }\n\n  return removeCnt;\n}\n\nfunction isArraysEqual(a0, a1, equalityFunc) {\n  if (a0 === a1) {\n    return true;\n  }\n\n  var len = a0.length;\n  var i;\n\n  if (len !== a1.length) {\n    // not array? or not same length?\n    return false;\n  }\n\n  for (i = 0; i < len; i += 1) {\n    if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction memoize(workerFunc, resEquality, teardownFunc) {\n  var currentArgs;\n  var currentRes;\n  return function () {\n    var newArgs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      newArgs[_i] = arguments[_i];\n    }\n\n    if (!currentArgs) {\n      currentRes = workerFunc.apply(this, newArgs);\n    } else if (!isArraysEqual(currentArgs, newArgs)) {\n      if (teardownFunc) {\n        teardownFunc(currentRes);\n      }\n\n      var res = workerFunc.apply(this, newArgs);\n\n      if (!resEquality || !resEquality(res, currentRes)) {\n        currentRes = res;\n      }\n    }\n\n    currentArgs = newArgs;\n    return currentRes;\n  };\n}\n\nfunction memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n  var _this = this;\n\n  var currentArg;\n  var currentRes;\n  return function (newArg) {\n    if (!currentArg) {\n      currentRes = workerFunc.call(_this, newArg);\n    } else if (!isPropsEqual(currentArg, newArg)) {\n      if (teardownFunc) {\n        teardownFunc(currentRes);\n      }\n\n      var res = workerFunc.call(_this, newArg);\n\n      if (!resEquality || !resEquality(res, currentRes)) {\n        currentRes = res;\n      }\n    }\n\n    currentArg = newArg;\n    return currentRes;\n  };\n}\n\nfunction memoizeArraylike( // used at all?\nworkerFunc, resEquality, teardownFunc) {\n  var _this = this;\n\n  var currentArgSets = [];\n  var currentResults = [];\n  return function (newArgSets) {\n    var currentLen = currentArgSets.length;\n    var newLen = newArgSets.length;\n    var i = 0;\n\n    for (; i < currentLen; i += 1) {\n      if (!newArgSets[i]) {\n        // one of the old sets no longer exists\n        if (teardownFunc) {\n          teardownFunc(currentResults[i]);\n        }\n      } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n        if (teardownFunc) {\n          teardownFunc(currentResults[i]);\n        }\n\n        var res = workerFunc.apply(_this, newArgSets[i]);\n\n        if (!resEquality || !resEquality(res, currentResults[i])) {\n          currentResults[i] = res;\n        }\n      }\n    }\n\n    for (; i < newLen; i += 1) {\n      currentResults[i] = workerFunc.apply(_this, newArgSets[i]);\n    }\n\n    currentArgSets = newArgSets;\n    currentResults.splice(newLen); // remove excess\n\n    return currentResults;\n  };\n}\n\nfunction memoizeHashlike( // used?\nworkerFunc, resEquality, teardownFunc) {\n  var _this = this;\n\n  var currentArgHash = {};\n  var currentResHash = {};\n  return function (newArgHash) {\n    var newResHash = {};\n\n    for (var key in newArgHash) {\n      if (!currentResHash[key]) {\n        newResHash[key] = workerFunc.apply(_this, newArgHash[key]);\n      } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n        if (teardownFunc) {\n          teardownFunc(currentResHash[key]);\n        }\n\n        var res = workerFunc.apply(_this, newArgHash[key]);\n        newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n      } else {\n        newResHash[key] = currentResHash[key];\n      }\n    }\n\n    currentArgHash = newArgHash;\n    currentResHash = newResHash;\n    return newResHash;\n  };\n}\n\nvar EXTENDED_SETTINGS_AND_SEVERITIES = {\n  week: 3,\n  separator: 0,\n  omitZeroMinute: 0,\n  meridiem: 0,\n  omitCommas: 0\n};\nvar STANDARD_DATE_PROP_SEVERITIES = {\n  timeZoneName: 7,\n  era: 6,\n  year: 5,\n  month: 4,\n  day: 2,\n  weekday: 2,\n  hour: 1,\n  minute: 1,\n  second: 1\n};\nvar MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\n\nvar COMMA_RE = /,/g; // we need re for globalness\n\nvar MULTI_SPACE_RE = /\\s+/g;\nvar LTR_RE = /\\u200e/g; // control character\n\nvar UTC_RE = /UTC|GMT/;\n\nvar NativeFormatter = function () {\n  function NativeFormatter(formatSettings) {\n    var standardDateProps = {};\n    var extendedSettings = {};\n    var severity = 0;\n\n    for (var name_1 in formatSettings) {\n      if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {\n        extendedSettings[name_1] = formatSettings[name_1];\n        severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);\n      } else {\n        standardDateProps[name_1] = formatSettings[name_1];\n\n        if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {\n          // TODO: what about hour12? no severity\n          severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);\n        }\n      }\n    }\n\n    this.standardDateProps = standardDateProps;\n    this.extendedSettings = extendedSettings;\n    this.severity = severity;\n    this.buildFormattingFunc = memoize(buildFormattingFunc);\n  }\n\n  NativeFormatter.prototype.format = function (date, context) {\n    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n  };\n\n  NativeFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n    var _a = this,\n        standardDateProps = _a.standardDateProps,\n        extendedSettings = _a.extendedSettings;\n\n    var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n\n    if (!diffSeverity) {\n      return this.format(start, context);\n    }\n\n    var biggestUnitForPartial = diffSeverity;\n\n    if (biggestUnitForPartial > 1 && (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') && (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') && (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {\n      biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n    }\n\n    var full0 = this.format(start, context);\n    var full1 = this.format(end, context);\n\n    if (full0 === full1) {\n      return full0;\n    }\n\n    var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n    var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n    var partial0 = partialFormattingFunc(start);\n    var partial1 = partialFormattingFunc(end);\n    var insertion = findCommonInsertion(full0, partial0, full1, partial1);\n    var separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';\n\n    if (insertion) {\n      return insertion.before + partial0 + separator + partial1 + insertion.after;\n    }\n\n    return full0 + separator + full1;\n  };\n\n  NativeFormatter.prototype.getLargestUnit = function () {\n    switch (this.severity) {\n      case 7:\n      case 6:\n      case 5:\n        return 'year';\n\n      case 4:\n        return 'month';\n\n      case 3:\n        return 'week';\n\n      case 2:\n        return 'day';\n\n      default:\n        return 'time';\n      // really?\n    }\n  };\n\n  return NativeFormatter;\n}();\n\nfunction buildFormattingFunc(standardDateProps, extendedSettings, context) {\n  var standardDatePropCnt = Object.keys(standardDateProps).length;\n\n  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {\n    return function (date) {\n      return formatTimeZoneOffset(date.timeZoneOffset);\n    };\n  }\n\n  if (standardDatePropCnt === 0 && extendedSettings.week) {\n    return function (date) {\n      return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.locale, extendedSettings.week);\n    };\n  }\n\n  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n}\n\nfunction buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n  standardDateProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, standardDateProps); // copy\n\n  extendedSettings = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, extendedSettings); // copy\n\n  sanitizeSettings(standardDateProps, extendedSettings);\n  standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers\n\n  var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n  var zeroFormat; // needed?\n\n  if (extendedSettings.omitZeroMinute) {\n    var zeroProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, standardDateProps);\n\n    delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n\n    zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n  }\n\n  return function (date) {\n    var marker = date.marker;\n    var format;\n\n    if (zeroFormat && !marker.getUTCMinutes()) {\n      format = zeroFormat;\n    } else {\n      format = normalFormat;\n    }\n\n    var s = format.format(marker);\n    return postProcess(s, date, standardDateProps, extendedSettings, context);\n  };\n}\n\nfunction sanitizeSettings(standardDateProps, extendedSettings) {\n  // deal with a browser inconsistency where formatting the timezone\n  // requires that the hour/minute be present.\n  if (standardDateProps.timeZoneName) {\n    if (!standardDateProps.hour) {\n      standardDateProps.hour = '2-digit';\n    }\n\n    if (!standardDateProps.minute) {\n      standardDateProps.minute = '2-digit';\n    }\n  } // only support short timezone names\n\n\n  if (standardDateProps.timeZoneName === 'long') {\n    standardDateProps.timeZoneName = 'short';\n  } // if requesting to display seconds, MUST display minutes\n\n\n  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n    delete extendedSettings.omitZeroMinute;\n  }\n}\n\nfunction postProcess(s, date, standardDateProps, extendedSettings, context) {\n  s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes\n\n  if (standardDateProps.timeZoneName === 'short') {\n    s = injectTzoStr(s, context.timeZone === 'UTC' || date.timeZoneOffset == null ? 'UTC' : // important to normalize for IE, which does \"GMT\"\n    formatTimeZoneOffset(date.timeZoneOffset));\n  }\n\n  if (extendedSettings.omitCommas) {\n    s = s.replace(COMMA_RE, '').trim();\n  }\n\n  if (extendedSettings.omitZeroMinute) {\n    s = s.replace(':00', ''); // zeroFormat doesn't always achieve this\n  } // ^ do anything that might create adjacent spaces before this point,\n  // because MERIDIEM_RE likes to eat up loading spaces\n\n\n  if (extendedSettings.meridiem === false) {\n    s = s.replace(MERIDIEM_RE, '').trim();\n  } else if (extendedSettings.meridiem === 'narrow') {\n    // a/p\n    s = s.replace(MERIDIEM_RE, function (m0, m1) {\n      return m1.toLocaleLowerCase();\n    });\n  } else if (extendedSettings.meridiem === 'short') {\n    // am/pm\n    s = s.replace(MERIDIEM_RE, function (m0, m1) {\n      return m1.toLocaleLowerCase() + \"m\";\n    });\n  } else if (extendedSettings.meridiem === 'lowercase') {\n    // other meridiem transformers already converted to lowercase\n    s = s.replace(MERIDIEM_RE, function (m0) {\n      return m0.toLocaleLowerCase();\n    });\n  }\n\n  s = s.replace(MULTI_SPACE_RE, ' ');\n  s = s.trim();\n  return s;\n}\n\nfunction injectTzoStr(s, tzoStr) {\n  var replaced = false;\n  s = s.replace(UTC_RE, function () {\n    replaced = true;\n    return tzoStr;\n  }); // IE11 doesn't include UTC/GMT in the original string, so append to end\n\n  if (!replaced) {\n    s += \" \" + tzoStr;\n  }\n\n  return s;\n}\n\nfunction formatWeekNumber(num, weekText, locale, display) {\n  var parts = [];\n\n  if (display === 'narrow') {\n    parts.push(weekText);\n  } else if (display === 'short') {\n    parts.push(weekText, ' ');\n  } // otherwise, considered 'numeric'\n\n\n  parts.push(locale.simpleNumberFormat.format(num));\n\n  if (locale.options.direction === 'rtl') {\n    // TODO: use control characters instead?\n    parts.reverse();\n  }\n\n  return parts.join('');\n} // Range Formatting Utils\n// 0 = exactly the same\n// 1 = different by time\n// and bigger\n\n\nfunction computeMarkerDiffSeverity(d0, d1, ca) {\n  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n    return 5;\n  }\n\n  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n    return 4;\n  }\n\n  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n    return 2;\n  }\n\n  if (timeAsMs(d0) !== timeAsMs(d1)) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction computePartialFormattingOptions(options, biggestUnit) {\n  var partialOptions = {};\n\n  for (var name_2 in options) {\n    if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n    STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {\n      partialOptions[name_2] = options[name_2];\n    }\n  }\n\n  return partialOptions;\n}\n\nfunction findCommonInsertion(full0, partial0, full1, partial1) {\n  var i0 = 0;\n\n  while (i0 < full0.length) {\n    var found0 = full0.indexOf(partial0, i0);\n\n    if (found0 === -1) {\n      break;\n    }\n\n    var before0 = full0.substr(0, found0);\n    i0 = found0 + partial0.length;\n    var after0 = full0.substr(i0);\n    var i1 = 0;\n\n    while (i1 < full1.length) {\n      var found1 = full1.indexOf(partial1, i1);\n\n      if (found1 === -1) {\n        break;\n      }\n\n      var before1 = full1.substr(0, found1);\n      i1 = found1 + partial1.length;\n      var after1 = full1.substr(i1);\n\n      if (before0 === before1 && after0 === after1) {\n        return {\n          before: before0,\n          after: after0\n        };\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction expandZonedMarker(dateInfo, calendarSystem) {\n  var a = calendarSystem.markerToArray(dateInfo.marker);\n  return {\n    marker: dateInfo.marker,\n    timeZoneOffset: dateInfo.timeZoneOffset,\n    array: a,\n    year: a[0],\n    month: a[1],\n    day: a[2],\n    hour: a[3],\n    minute: a[4],\n    second: a[5],\n    millisecond: a[6]\n  };\n}\n\nfunction createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n  var startInfo = expandZonedMarker(start, context.calendarSystem);\n  var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n  return {\n    date: startInfo,\n    start: startInfo,\n    end: endInfo,\n    timeZone: context.timeZone,\n    localeCodes: context.locale.codes,\n    defaultSeparator: betterDefaultSeparator || context.defaultSeparator\n  };\n}\n/*\nTODO: fix the terminology of \"formatter\" vs \"formatting func\"\n*/\n\n/*\nAt the time of instantiation, this object does not know which cmd-formatting system it will use.\nIt receives this at the time of formatting, as a setting.\n*/\n\n\nvar CmdFormatter = function () {\n  function CmdFormatter(cmdStr) {\n    this.cmdStr = cmdStr;\n  }\n\n  CmdFormatter.prototype.format = function (date, context, betterDefaultSeparator) {\n    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n  };\n\n  CmdFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n  };\n\n  return CmdFormatter;\n}();\n\nvar FuncFormatter = function () {\n  function FuncFormatter(func) {\n    this.func = func;\n  }\n\n  FuncFormatter.prototype.format = function (date, context, betterDefaultSeparator) {\n    return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n  };\n\n  FuncFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n    return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n  };\n\n  return FuncFormatter;\n}();\n\nfunction createFormatter(input) {\n  if (typeof input === 'object' && input) {\n    // non-null object\n    return new NativeFormatter(input);\n  }\n\n  if (typeof input === 'string') {\n    return new CmdFormatter(input);\n  }\n\n  if (typeof input === 'function') {\n    return new FuncFormatter(input);\n  }\n\n  return null;\n} // base options\n// ------------\n\n\nvar BASE_OPTION_REFINERS = {\n  navLinkDayClick: identity,\n  navLinkWeekClick: identity,\n  duration: createDuration,\n  bootstrapFontAwesome: identity,\n  buttonIcons: identity,\n  customButtons: identity,\n  defaultAllDayEventDuration: createDuration,\n  defaultTimedEventDuration: createDuration,\n  nextDayThreshold: createDuration,\n  scrollTime: createDuration,\n  scrollTimeReset: Boolean,\n  slotMinTime: createDuration,\n  slotMaxTime: createDuration,\n  dayPopoverFormat: createFormatter,\n  slotDuration: createDuration,\n  snapDuration: createDuration,\n  headerToolbar: identity,\n  footerToolbar: identity,\n  defaultRangeSeparator: String,\n  titleRangeSeparator: String,\n  forceEventDuration: Boolean,\n  dayHeaders: Boolean,\n  dayHeaderFormat: createFormatter,\n  dayHeaderClassNames: identity,\n  dayHeaderContent: identity,\n  dayHeaderDidMount: identity,\n  dayHeaderWillUnmount: identity,\n  dayCellClassNames: identity,\n  dayCellContent: identity,\n  dayCellDidMount: identity,\n  dayCellWillUnmount: identity,\n  initialView: String,\n  aspectRatio: Number,\n  weekends: Boolean,\n  weekNumberCalculation: identity,\n  weekNumbers: Boolean,\n  weekNumberClassNames: identity,\n  weekNumberContent: identity,\n  weekNumberDidMount: identity,\n  weekNumberWillUnmount: identity,\n  editable: Boolean,\n  viewClassNames: identity,\n  viewDidMount: identity,\n  viewWillUnmount: identity,\n  nowIndicator: Boolean,\n  nowIndicatorClassNames: identity,\n  nowIndicatorContent: identity,\n  nowIndicatorDidMount: identity,\n  nowIndicatorWillUnmount: identity,\n  showNonCurrentDates: Boolean,\n  lazyFetching: Boolean,\n  startParam: String,\n  endParam: String,\n  timeZoneParam: String,\n  timeZone: String,\n  locales: identity,\n  locale: identity,\n  themeSystem: String,\n  dragRevertDuration: Number,\n  dragScroll: Boolean,\n  allDayMaintainDuration: Boolean,\n  unselectAuto: Boolean,\n  dropAccept: identity,\n  eventOrder: parseFieldSpecs,\n  eventOrderStrict: Boolean,\n  handleWindowResize: Boolean,\n  windowResizeDelay: Number,\n  longPressDelay: Number,\n  eventDragMinDistance: Number,\n  expandRows: Boolean,\n  height: identity,\n  contentHeight: identity,\n  direction: String,\n  weekNumberFormat: createFormatter,\n  eventResizableFromStart: Boolean,\n  displayEventTime: Boolean,\n  displayEventEnd: Boolean,\n  weekText: String,\n  progressiveEventRendering: Boolean,\n  businessHours: identity,\n  initialDate: identity,\n  now: identity,\n  eventDataTransform: identity,\n  stickyHeaderDates: identity,\n  stickyFooterScrollbar: identity,\n  viewHeight: identity,\n  defaultAllDay: Boolean,\n  eventSourceFailure: identity,\n  eventSourceSuccess: identity,\n  eventDisplay: String,\n  eventStartEditable: Boolean,\n  eventDurationEditable: Boolean,\n  eventOverlap: identity,\n  eventConstraint: identity,\n  eventAllow: identity,\n  eventBackgroundColor: String,\n  eventBorderColor: String,\n  eventTextColor: String,\n  eventColor: String,\n  eventClassNames: identity,\n  eventContent: identity,\n  eventDidMount: identity,\n  eventWillUnmount: identity,\n  selectConstraint: identity,\n  selectOverlap: identity,\n  selectAllow: identity,\n  droppable: Boolean,\n  unselectCancel: String,\n  slotLabelFormat: identity,\n  slotLaneClassNames: identity,\n  slotLaneContent: identity,\n  slotLaneDidMount: identity,\n  slotLaneWillUnmount: identity,\n  slotLabelClassNames: identity,\n  slotLabelContent: identity,\n  slotLabelDidMount: identity,\n  slotLabelWillUnmount: identity,\n  dayMaxEvents: identity,\n  dayMaxEventRows: identity,\n  dayMinWidth: Number,\n  slotLabelInterval: createDuration,\n  allDayText: String,\n  allDayClassNames: identity,\n  allDayContent: identity,\n  allDayDidMount: identity,\n  allDayWillUnmount: identity,\n  slotMinWidth: Number,\n  navLinks: Boolean,\n  eventTimeFormat: createFormatter,\n  rerenderDelay: Number,\n  moreLinkText: identity,\n  selectMinDistance: Number,\n  selectable: Boolean,\n  selectLongPressDelay: Number,\n  eventLongPressDelay: Number,\n  selectMirror: Boolean,\n  eventMaxStack: Number,\n  eventMinHeight: Number,\n  eventMinWidth: Number,\n  eventShortHeight: Number,\n  slotEventOverlap: Boolean,\n  plugins: identity,\n  firstDay: Number,\n  dayCount: Number,\n  dateAlignment: String,\n  dateIncrement: createDuration,\n  hiddenDays: identity,\n  monthMode: Boolean,\n  fixedWeekCount: Boolean,\n  validRange: identity,\n  visibleRange: identity,\n  titleFormat: identity,\n  // only used by list-view, but languages define the value, so we need it in base options\n  noEventsText: String,\n  moreLinkClick: identity,\n  moreLinkClassNames: identity,\n  moreLinkContent: identity,\n  moreLinkDidMount: identity,\n  moreLinkWillUnmount: identity\n}; // do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n// raw values.\n\nvar BASE_OPTION_DEFAULTS = {\n  eventDisplay: 'auto',\n  defaultRangeSeparator: ' - ',\n  titleRangeSeparator: ' \\u2013 ',\n  defaultTimedEventDuration: '01:00:00',\n  defaultAllDayEventDuration: {\n    day: 1\n  },\n  forceEventDuration: false,\n  nextDayThreshold: '00:00:00',\n  dayHeaders: true,\n  initialView: '',\n  aspectRatio: 1.35,\n  headerToolbar: {\n    start: 'title',\n    center: '',\n    end: 'today prev,next'\n  },\n  weekends: true,\n  weekNumbers: false,\n  weekNumberCalculation: 'local',\n  editable: false,\n  nowIndicator: false,\n  scrollTime: '06:00:00',\n  scrollTimeReset: true,\n  slotMinTime: '00:00:00',\n  slotMaxTime: '24:00:00',\n  showNonCurrentDates: true,\n  lazyFetching: true,\n  startParam: 'start',\n  endParam: 'end',\n  timeZoneParam: 'timeZone',\n  timeZone: 'local',\n  locales: [],\n  locale: '',\n  themeSystem: 'standard',\n  dragRevertDuration: 500,\n  dragScroll: true,\n  allDayMaintainDuration: false,\n  unselectAuto: true,\n  dropAccept: '*',\n  eventOrder: 'start,-duration,allDay,title',\n  dayPopoverFormat: {\n    month: 'long',\n    day: 'numeric',\n    year: 'numeric'\n  },\n  handleWindowResize: true,\n  windowResizeDelay: 100,\n  longPressDelay: 1000,\n  eventDragMinDistance: 5,\n  expandRows: false,\n  navLinks: false,\n  selectable: false,\n  eventMinHeight: 15,\n  eventMinWidth: 30,\n  eventShortHeight: 30\n}; // calendar listeners\n// ------------------\n\nvar CALENDAR_LISTENER_REFINERS = {\n  datesSet: identity,\n  eventsSet: identity,\n  eventAdd: identity,\n  eventChange: identity,\n  eventRemove: identity,\n  windowResize: identity,\n  eventClick: identity,\n  eventMouseEnter: identity,\n  eventMouseLeave: identity,\n  select: identity,\n  unselect: identity,\n  loading: identity,\n  // internal\n  _unmount: identity,\n  _beforeprint: identity,\n  _afterprint: identity,\n  _noEventDrop: identity,\n  _noEventResize: identity,\n  _resize: identity,\n  _scrollRequest: identity\n}; // calendar-specific options\n// -------------------------\n\nvar CALENDAR_OPTION_REFINERS = {\n  buttonText: identity,\n  views: identity,\n  plugins: identity,\n  initialEvents: identity,\n  events: identity,\n  eventSources: identity\n};\nvar COMPLEX_OPTION_COMPARATORS = {\n  headerToolbar: isBoolComplexEqual,\n  footerToolbar: isBoolComplexEqual,\n  buttonText: isBoolComplexEqual,\n  buttonIcons: isBoolComplexEqual\n};\n\nfunction isBoolComplexEqual(a, b) {\n  if (typeof a === 'object' && typeof b === 'object' && a && b) {\n    // both non-null objects\n    return isPropsEqual(a, b);\n  }\n\n  return a === b;\n} // view-specific options\n// ---------------------\n\n\nvar VIEW_OPTION_REFINERS = {\n  type: String,\n  component: identity,\n  buttonText: String,\n  buttonTextKey: String,\n  dateProfileGeneratorClass: identity,\n  usesMinMaxTime: Boolean,\n  classNames: identity,\n  content: identity,\n  didMount: identity,\n  willUnmount: identity\n}; // util funcs\n// ----------------------------------------------------------------------------------------------------\n\nfunction mergeRawOptions(optionSets) {\n  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n}\n\nfunction refineProps(input, refiners) {\n  var refined = {};\n  var extra = {};\n\n  for (var propName in refiners) {\n    if (propName in input) {\n      refined[propName] = refiners[propName](input[propName]);\n    }\n  }\n\n  for (var propName in input) {\n    if (!(propName in refiners)) {\n      extra[propName] = input[propName];\n    }\n  }\n\n  return {\n    refined: refined,\n    extra: extra\n  };\n}\n\nfunction identity(raw) {\n  return raw;\n}\n\nfunction parseEvents(rawEvents, eventSource, context, allowOpenRange) {\n  var eventStore = createEmptyEventStore();\n  var eventRefiners = buildEventRefiners(context);\n\n  for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n    var rawEvent = rawEvents_1[_i];\n    var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);\n\n    if (tuple) {\n      eventTupleToStore(tuple, eventStore);\n    }\n  }\n\n  return eventStore;\n}\n\nfunction eventTupleToStore(tuple, eventStore) {\n  if (eventStore === void 0) {\n    eventStore = createEmptyEventStore();\n  }\n\n  eventStore.defs[tuple.def.defId] = tuple.def;\n\n  if (tuple.instance) {\n    eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n  }\n\n  return eventStore;\n} // retrieves events that have the same groupId as the instance specified by `instanceId`\n// or they are the same as the instance.\n// why might instanceId not be in the store? an event from another calendar?\n\n\nfunction getRelevantEvents(eventStore, instanceId) {\n  var instance = eventStore.instances[instanceId];\n\n  if (instance) {\n    var def_1 = eventStore.defs[instance.defId]; // get events/instances with same group\n\n    var newStore = filterEventStoreDefs(eventStore, function (lookDef) {\n      return isEventDefsGrouped(def_1, lookDef);\n    }); // add the original\n    // TODO: wish we could use eventTupleToStore or something like it\n\n    newStore.defs[def_1.defId] = def_1;\n    newStore.instances[instance.instanceId] = instance;\n    return newStore;\n  }\n\n  return createEmptyEventStore();\n}\n\nfunction isEventDefsGrouped(def0, def1) {\n  return Boolean(def0.groupId && def0.groupId === def1.groupId);\n}\n\nfunction createEmptyEventStore() {\n  return {\n    defs: {},\n    instances: {}\n  };\n}\n\nfunction mergeEventStores(store0, store1) {\n  return {\n    defs: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, store0.defs), store1.defs),\n    instances: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, store0.instances), store1.instances)\n  };\n}\n\nfunction filterEventStoreDefs(eventStore, filterFunc) {\n  var defs = filterHash(eventStore.defs, filterFunc);\n  var instances = filterHash(eventStore.instances, function (instance) {\n    return defs[instance.defId] // still exists?\n    ;\n  });\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n\nfunction excludeSubEventStore(master, sub) {\n  var defs = master.defs,\n      instances = master.instances;\n  var filteredDefs = {};\n  var filteredInstances = {};\n\n  for (var defId in defs) {\n    if (!sub.defs[defId]) {\n      // not explicitly excluded\n      filteredDefs[defId] = defs[defId];\n    }\n  }\n\n  for (var instanceId in instances) {\n    if (!sub.instances[instanceId] && // not explicitly excluded\n    filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n    ) {\n      filteredInstances[instanceId] = instances[instanceId];\n    }\n  }\n\n  return {\n    defs: filteredDefs,\n    instances: filteredInstances\n  };\n}\n\nfunction normalizeConstraint(input, context) {\n  if (Array.isArray(input)) {\n    return parseEvents(input, null, context, true); // allowOpenRange=true\n  }\n\n  if (typeof input === 'object' && input) {\n    // non-null object\n    return parseEvents([input], null, context, true); // allowOpenRange=true\n  }\n\n  if (input != null) {\n    return String(input);\n  }\n\n  return null;\n}\n\nfunction parseClassNames(raw) {\n  if (Array.isArray(raw)) {\n    return raw;\n  }\n\n  if (typeof raw === 'string') {\n    return raw.split(/\\s+/);\n  }\n\n  return [];\n} // TODO: better called \"EventSettings\" or \"EventConfig\"\n// TODO: move this file into structs\n// TODO: separate constraint/overlap/allow, because selection uses only that, not other props\n\n\nvar EVENT_UI_REFINERS = {\n  display: String,\n  editable: Boolean,\n  startEditable: Boolean,\n  durationEditable: Boolean,\n  constraint: identity,\n  overlap: identity,\n  allow: identity,\n  className: parseClassNames,\n  classNames: parseClassNames,\n  color: String,\n  backgroundColor: String,\n  borderColor: String,\n  textColor: String\n};\nvar EMPTY_EVENT_UI = {\n  display: null,\n  startEditable: null,\n  durationEditable: null,\n  constraints: [],\n  overlap: null,\n  allows: [],\n  backgroundColor: '',\n  borderColor: '',\n  textColor: '',\n  classNames: []\n};\n\nfunction createEventUi(refined, context) {\n  var constraint = normalizeConstraint(refined.constraint, context);\n  return {\n    display: refined.display || null,\n    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n    constraints: constraint != null ? [constraint] : [],\n    overlap: refined.overlap != null ? refined.overlap : null,\n    allows: refined.allow != null ? [refined.allow] : [],\n    backgroundColor: refined.backgroundColor || refined.color || '',\n    borderColor: refined.borderColor || refined.color || '',\n    textColor: refined.textColor || '',\n    classNames: (refined.className || []).concat(refined.classNames || []) // join singular and plural\n\n  };\n} // TODO: prevent against problems with <2 args!\n\n\nfunction combineEventUis(uis) {\n  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n}\n\nfunction combineTwoEventUis(item0, item1) {\n  return {\n    display: item1.display != null ? item1.display : item0.display,\n    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n    constraints: item0.constraints.concat(item1.constraints),\n    overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,\n    allows: item0.allows.concat(item1.allows),\n    backgroundColor: item1.backgroundColor || item0.backgroundColor,\n    borderColor: item1.borderColor || item0.borderColor,\n    textColor: item1.textColor || item0.textColor,\n    classNames: item0.classNames.concat(item1.classNames)\n  };\n}\n\nvar EVENT_NON_DATE_REFINERS = {\n  id: String,\n  groupId: String,\n  title: String,\n  url: String\n};\nvar EVENT_DATE_REFINERS = {\n  start: identity,\n  end: identity,\n  date: identity,\n  allDay: Boolean\n};\n\nvar EVENT_REFINERS = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n  extendedProps: identity\n});\n\nfunction parseEvent(raw, eventSource, context, allowOpenRange, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventRefiners(context);\n  }\n\n  var _a = refineEventDef(raw, context, refiners),\n      refined = _a.refined,\n      extra = _a.extra;\n\n  var defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n  var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n\n  if (recurringRes) {\n    var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context);\n    def.recurringDef = {\n      typeId: recurringRes.typeId,\n      typeData: recurringRes.typeData,\n      duration: recurringRes.duration\n    };\n    return {\n      def: def,\n      instance: null\n    };\n  }\n\n  var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n\n  if (singleRes) {\n    var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context);\n    var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n    return {\n      def: def,\n      instance: instance\n    };\n  }\n\n  return null;\n}\n\nfunction refineEventDef(raw, context, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventRefiners(context);\n  }\n\n  return refineProps(raw, refiners);\n}\n\nfunction buildEventRefiners(context) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n}\n/*\nWill NOT populate extendedProps with the leftover properties.\nWill NOT populate date-related props.\n*/\n\n\nfunction parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {\n  var def = {\n    title: refined.title || '',\n    groupId: refined.groupId || '',\n    publicId: refined.id || '',\n    url: refined.url || '',\n    recurringDef: null,\n    defId: guid(),\n    sourceId: sourceId,\n    allDay: allDay,\n    hasEnd: hasEnd,\n    ui: createEventUi(refined, context),\n    extendedProps: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, refined.extendedProps || {}), extra)\n  };\n\n  for (var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++) {\n    var memberAdder = _a[_i];\n\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(def, memberAdder(refined));\n  } // help out EventApi from having user modify props\n\n\n  Object.freeze(def.ui.classNames);\n  Object.freeze(def.extendedProps);\n  return def;\n}\n\nfunction parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n  var allDay = refined.allDay;\n  var startMeta;\n  var startMarker = null;\n  var hasEnd = false;\n  var endMeta;\n  var endMarker = null;\n  var startInput = refined.start != null ? refined.start : refined.date;\n  startMeta = context.dateEnv.createMarkerMeta(startInput);\n\n  if (startMeta) {\n    startMarker = startMeta.marker;\n  } else if (!allowOpenRange) {\n    return null;\n  }\n\n  if (refined.end != null) {\n    endMeta = context.dateEnv.createMarkerMeta(refined.end);\n  }\n\n  if (allDay == null) {\n    if (defaultAllDay != null) {\n      allDay = defaultAllDay;\n    } else {\n      // fall back to the date props LAST\n      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n    }\n  }\n\n  if (allDay && startMarker) {\n    startMarker = startOfDay(startMarker);\n  }\n\n  if (endMeta) {\n    endMarker = endMeta.marker;\n\n    if (allDay) {\n      endMarker = startOfDay(endMarker);\n    }\n\n    if (startMarker && endMarker <= startMarker) {\n      endMarker = null;\n    }\n  }\n\n  if (endMarker) {\n    hasEnd = true;\n  } else if (!allowOpenRange) {\n    hasEnd = context.options.forceEventDuration || false;\n    endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n  }\n\n  return {\n    allDay: allDay,\n    hasEnd: hasEnd,\n    range: {\n      start: startMarker,\n      end: endMarker\n    },\n    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n    forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n  };\n}\n\nfunction computeIsDefaultAllDay(eventSource, context) {\n  var res = null;\n\n  if (eventSource) {\n    res = eventSource.defaultAllDay;\n  }\n\n  if (res == null) {\n    res = context.options.defaultAllDay;\n  }\n\n  return res;\n}\n/* Date stuff that doesn't belong in datelib core\n----------------------------------------------------------------------------------------------------------------------*/\n// given a timed range, computes an all-day range that has the same exact duration,\n// but whose start time is aligned with the start of the day.\n\n\nfunction computeAlignedDayRange(timedRange) {\n  var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n  var start = startOfDay(timedRange.start);\n  var end = addDays(start, dayCnt);\n  return {\n    start: start,\n    end: end\n  };\n} // given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n// TODO: give nextDayThreshold a default arg\n\n\nfunction computeVisibleDayRange(timedRange, nextDayThreshold) {\n  if (nextDayThreshold === void 0) {\n    nextDayThreshold = createDuration(0);\n  }\n\n  var startDay = null;\n  var endDay = null;\n\n  if (timedRange.end) {\n    endDay = startOfDay(timedRange.end);\n    var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n    // If the end time is actually inclusively part of the next day and is equal to or\n    // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n    // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n\n    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n      endDay = addDays(endDay, 1);\n    }\n  }\n\n  if (timedRange.start) {\n    startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n    // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n\n    if (endDay && endDay <= startDay) {\n      endDay = addDays(startDay, 1);\n    }\n  }\n\n  return {\n    start: startDay,\n    end: endDay\n  };\n} // spans from one day into another?\n\n\nfunction isMultiDayRange(range) {\n  var visibleRange = computeVisibleDayRange(range);\n  return diffDays(visibleRange.start, visibleRange.end) > 1;\n}\n\nfunction diffDates(date0, date1, dateEnv, largeUnit) {\n  if (largeUnit === 'year') {\n    return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');\n  }\n\n  if (largeUnit === 'month') {\n    return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');\n  }\n\n  return diffDayAndTime(date0, date1); // returns a duration\n}\n\nfunction parseRange(input, dateEnv) {\n  var start = null;\n  var end = null;\n\n  if (input.start) {\n    start = dateEnv.createMarker(input.start);\n  }\n\n  if (input.end) {\n    end = dateEnv.createMarker(input.end);\n  }\n\n  if (!start && !end) {\n    return null;\n  }\n\n  if (start && end && end < start) {\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n} // SIDE-EFFECT: will mutate ranges.\n// Will return a new array result.\n\n\nfunction invertRanges(ranges, constraintRange) {\n  var invertedRanges = [];\n  var start = constraintRange.start; // the end of the previous range. the start of the new range\n\n  var i;\n  var dateRange; // ranges need to be in order. required for our date-walking algorithm\n\n  ranges.sort(compareRanges);\n\n  for (i = 0; i < ranges.length; i += 1) {\n    dateRange = ranges[i]; // add the span of time before the event (if there is any)\n\n    if (dateRange.start > start) {\n      // compare millisecond time (skip any ambig logic)\n      invertedRanges.push({\n        start: start,\n        end: dateRange.start\n      });\n    }\n\n    if (dateRange.end > start) {\n      start = dateRange.end;\n    }\n  } // add the span of time after the last event (if there is any)\n\n\n  if (start < constraintRange.end) {\n    // compare millisecond time (skip any ambig logic)\n    invertedRanges.push({\n      start: start,\n      end: constraintRange.end\n    });\n  }\n\n  return invertedRanges;\n}\n\nfunction compareRanges(range0, range1) {\n  return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n}\n\nfunction intersectRanges(range0, range1) {\n  var start = range0.start,\n      end = range0.end;\n  var newRange = null;\n\n  if (range1.start !== null) {\n    if (start === null) {\n      start = range1.start;\n    } else {\n      start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n    }\n  }\n\n  if (range1.end != null) {\n    if (end === null) {\n      end = range1.end;\n    } else {\n      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n    }\n  }\n\n  if (start === null || end === null || start < end) {\n    newRange = {\n      start: start,\n      end: end\n    };\n  }\n\n  return newRange;\n}\n\nfunction rangesEqual(range0, range1) {\n  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n}\n\nfunction rangesIntersect(range0, range1) {\n  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n}\n\nfunction rangeContainsRange(outerRange, innerRange) {\n  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n}\n\nfunction rangeContainsMarker(range, date) {\n  return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n} // If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\n\n\nfunction constrainMarkerToRange(date, range) {\n  if (range.start != null && date < range.start) {\n    return range.start;\n  }\n\n  if (range.end != null && date >= range.end) {\n    return new Date(range.end.valueOf() - 1);\n  }\n\n  return date;\n}\n/*\nSpecifying nextDayThreshold signals that all-day ranges should be sliced.\n*/\n\n\nfunction sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n  var inverseBgByGroupId = {};\n  var inverseBgByDefId = {};\n  var defByGroupId = {};\n  var bgRanges = [];\n  var fgRanges = [];\n  var eventUis = compileEventUis(eventStore.defs, eventUiBases);\n\n  for (var defId in eventStore.defs) {\n    var def = eventStore.defs[defId];\n    var ui = eventUis[def.defId];\n\n    if (ui.display === 'inverse-background') {\n      if (def.groupId) {\n        inverseBgByGroupId[def.groupId] = [];\n\n        if (!defByGroupId[def.groupId]) {\n          defByGroupId[def.groupId] = def;\n        }\n      } else {\n        inverseBgByDefId[defId] = [];\n      }\n    }\n  }\n\n  for (var instanceId in eventStore.instances) {\n    var instance = eventStore.instances[instanceId];\n    var def = eventStore.defs[instance.defId];\n    var ui = eventUis[def.defId];\n    var origRange = instance.range;\n    var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n    var slicedRange = intersectRanges(normalRange, framingRange);\n\n    if (slicedRange) {\n      if (ui.display === 'inverse-background') {\n        if (def.groupId) {\n          inverseBgByGroupId[def.groupId].push(slicedRange);\n        } else {\n          inverseBgByDefId[instance.defId].push(slicedRange);\n        }\n      } else if (ui.display !== 'none') {\n        (ui.display === 'background' ? bgRanges : fgRanges).push({\n          def: def,\n          ui: ui,\n          instance: instance,\n          range: slicedRange,\n          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n        });\n      }\n    }\n  }\n\n  for (var groupId in inverseBgByGroupId) {\n    // BY GROUP\n    var ranges = inverseBgByGroupId[groupId];\n    var invertedRanges = invertRanges(ranges, framingRange);\n\n    for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {\n      var invertedRange = invertedRanges_1[_i];\n      var def = defByGroupId[groupId];\n      var ui = eventUis[def.defId];\n      bgRanges.push({\n        def: def,\n        ui: ui,\n        instance: null,\n        range: invertedRange,\n        isStart: false,\n        isEnd: false\n      });\n    }\n  }\n\n  for (var defId in inverseBgByDefId) {\n    var ranges = inverseBgByDefId[defId];\n    var invertedRanges = invertRanges(ranges, framingRange);\n\n    for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {\n      var invertedRange = invertedRanges_2[_a];\n      bgRanges.push({\n        def: eventStore.defs[defId],\n        ui: eventUis[defId],\n        instance: null,\n        range: invertedRange,\n        isStart: false,\n        isEnd: false\n      });\n    }\n  }\n\n  return {\n    bg: bgRanges,\n    fg: fgRanges\n  };\n}\n\nfunction hasBgRendering(def) {\n  return def.ui.display === 'background' || def.ui.display === 'inverse-background';\n}\n\nfunction setElSeg(el, seg) {\n  el.fcSeg = seg;\n}\n\nfunction getElSeg(el) {\n  return el.fcSeg || el.parentNode.fcSeg || // for the harness\n  null;\n} // event ui computation\n\n\nfunction compileEventUis(eventDefs, eventUiBases) {\n  return mapHash(eventDefs, function (eventDef) {\n    return compileEventUi(eventDef, eventUiBases);\n  });\n}\n\nfunction compileEventUi(eventDef, eventUiBases) {\n  var uis = [];\n\n  if (eventUiBases['']) {\n    uis.push(eventUiBases['']);\n  }\n\n  if (eventUiBases[eventDef.defId]) {\n    uis.push(eventUiBases[eventDef.defId]);\n  }\n\n  uis.push(eventDef.ui);\n  return combineEventUis(uis);\n}\n\nfunction sortEventSegs(segs, eventOrderSpecs) {\n  var objs = segs.map(buildSegCompareObj);\n  objs.sort(function (obj0, obj1) {\n    return compareByFieldSpecs(obj0, obj1, eventOrderSpecs);\n  });\n  return objs.map(function (c) {\n    return c._seg;\n  });\n} // returns a object with all primitive props that can be compared\n\n\nfunction buildSegCompareObj(seg) {\n  var eventRange = seg.eventRange;\n  var eventDef = eventRange.def;\n  var range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n  var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n\n  var end = range.end ? range.end.valueOf() : 0; // \"\n\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventDef.extendedProps), eventDef), {\n    id: eventDef.publicId,\n    start: start,\n    end: end,\n    duration: end - start,\n    allDay: Number(eventDef.allDay),\n    _seg: seg\n  });\n}\n\nfunction computeSegDraggable(seg, context) {\n  var pluginHooks = context.pluginHooks;\n  var transformers = pluginHooks.isDraggableTransformers;\n  var _a = seg.eventRange,\n      def = _a.def,\n      ui = _a.ui;\n  var val = ui.startEditable;\n\n  for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n    var transformer = transformers_1[_i];\n    val = transformer(val, def, ui, context);\n  }\n\n  return val;\n}\n\nfunction computeSegStartResizable(seg, context) {\n  return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n}\n\nfunction computeSegEndResizable(seg, context) {\n  return seg.isEnd && seg.eventRange.ui.durationEditable;\n}\n\nfunction buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, // defaults to true\ndefaultDisplayEventEnd, // defaults to true\nstartOverride, endOverride) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var displayEventTime = options.displayEventTime,\n      displayEventEnd = options.displayEventEnd;\n  var eventDef = seg.eventRange.def;\n  var eventInstance = seg.eventRange.instance;\n\n  if (displayEventTime == null) {\n    displayEventTime = defaultDisplayEventTime !== false;\n  }\n\n  if (displayEventEnd == null) {\n    displayEventEnd = defaultDisplayEventEnd !== false;\n  }\n\n  var wholeEventStart = eventInstance.range.start;\n  var wholeEventEnd = eventInstance.range.end;\n  var segStart = startOverride || seg.start || seg.eventRange.range.start;\n  var segEnd = endOverride || seg.end || seg.eventRange.range.end;\n  var isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n  var isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n\n  if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n    segStart = isStartDay ? wholeEventStart : segStart;\n    segEnd = isEndDay ? wholeEventEnd : segEnd;\n\n    if (displayEventEnd && eventDef.hasEnd) {\n      return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n      });\n    }\n\n    return dateEnv.format(segStart, timeFormat, {\n      forcedTzo: startOverride ? null : eventInstance.forcedStartTzo // nooooo, same\n\n    });\n  }\n\n  return '';\n}\n\nfunction getSegMeta(seg, todayRange, nowDate) {\n  var segRange = seg.eventRange.range;\n  return {\n    isPast: segRange.end < (nowDate || todayRange.start),\n    isFuture: segRange.start >= (nowDate || todayRange.end),\n    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n  };\n}\n\nfunction getEventClassNames(props) {\n  var classNames = ['fc-event'];\n\n  if (props.isMirror) {\n    classNames.push('fc-event-mirror');\n  }\n\n  if (props.isDraggable) {\n    classNames.push('fc-event-draggable');\n  }\n\n  if (props.isStartResizable || props.isEndResizable) {\n    classNames.push('fc-event-resizable');\n  }\n\n  if (props.isDragging) {\n    classNames.push('fc-event-dragging');\n  }\n\n  if (props.isResizing) {\n    classNames.push('fc-event-resizing');\n  }\n\n  if (props.isSelected) {\n    classNames.push('fc-event-selected');\n  }\n\n  if (props.isStart) {\n    classNames.push('fc-event-start');\n  }\n\n  if (props.isEnd) {\n    classNames.push('fc-event-end');\n  }\n\n  if (props.isPast) {\n    classNames.push('fc-event-past');\n  }\n\n  if (props.isToday) {\n    classNames.push('fc-event-today');\n  }\n\n  if (props.isFuture) {\n    classNames.push('fc-event-future');\n  }\n\n  return classNames;\n}\n\nfunction buildEventRangeKey(eventRange) {\n  return eventRange.instance ? eventRange.instance.instanceId : eventRange.def.defId + \":\" + eventRange.range.start.toISOString(); // inverse-background events don't have specific instances. TODO: better solution\n}\n\nvar STANDARD_PROPS = {\n  start: identity,\n  end: identity,\n  allDay: Boolean\n};\n\nfunction parseDateSpan(raw, dateEnv, defaultDuration) {\n  var span = parseOpenDateSpan(raw, dateEnv);\n  var range = span.range;\n\n  if (!range.start) {\n    return null;\n  }\n\n  if (!range.end) {\n    if (defaultDuration == null) {\n      return null;\n    }\n\n    range.end = dateEnv.add(range.start, defaultDuration);\n  }\n\n  return span;\n}\n/*\nTODO: somehow combine with parseRange?\nWill return null if the start/end props were present but parsed invalidly.\n*/\n\n\nfunction parseOpenDateSpan(raw, dateEnv) {\n  var _a = refineProps(raw, STANDARD_PROPS),\n      standardProps = _a.refined,\n      extra = _a.extra;\n\n  var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n  var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n  var allDay = standardProps.allDay;\n\n  if (allDay == null) {\n    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n  }\n\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n    range: {\n      start: startMeta ? startMeta.marker : null,\n      end: endMeta ? endMeta.marker : null\n    },\n    allDay: allDay\n  }, extra);\n}\n\nfunction isDateSpansEqual(span0, span1) {\n  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n} // the NON-DATE-RELATED props\n\n\nfunction isSpanPropsEqual(span0, span1) {\n  for (var propName in span1) {\n    if (propName !== 'range' && propName !== 'allDay') {\n      if (span0[propName] !== span1[propName]) {\n        return false;\n      }\n    }\n  } // are there any props that span0 has that span1 DOESN'T have?\n  // both have range/allDay, so no need to special-case.\n\n\n  for (var propName in span0) {\n    if (!(propName in span1)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction buildDateSpanApi(span, dateEnv) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n    allDay: span.allDay\n  });\n}\n\nfunction buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, buildRangeApi(range, dateEnv, omitTime)), {\n    timeZone: dateEnv.timeZone\n  });\n}\n\nfunction buildRangeApi(range, dateEnv, omitTime) {\n  return {\n    start: dateEnv.toDate(range.start),\n    end: dateEnv.toDate(range.end),\n    startStr: dateEnv.formatIso(range.start, {\n      omitTime: omitTime\n    }),\n    endStr: dateEnv.formatIso(range.end, {\n      omitTime: omitTime\n    })\n  };\n}\n\nfunction fabricateEventRange(dateSpan, eventUiBases, context) {\n  var res = refineEventDef({\n    editable: false\n  }, context);\n  var def = parseEventDef(res.refined, res.extra, '', // sourceId\n  dateSpan.allDay, true, // hasEnd\n  context);\n  return {\n    def: def,\n    ui: compileEventUi(def, eventUiBases),\n    instance: createEventInstance(def.defId, dateSpan.range),\n    range: dateSpan.range,\n    isStart: true,\n    isEnd: true\n  };\n}\n\nfunction triggerDateSelect(selection, pev, context) {\n  context.emitter.trigger('select', (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, buildDateSpanApiWithContext(selection, context)), {\n    jsEvent: pev ? pev.origEvent : null,\n    view: context.viewApi || context.calendarApi.view\n  }));\n}\n\nfunction triggerDateUnselect(pev, context) {\n  context.emitter.trigger('unselect', {\n    jsEvent: pev ? pev.origEvent : null,\n    view: context.viewApi || context.calendarApi.view\n  });\n}\n\nfunction buildDateSpanApiWithContext(dateSpan, context) {\n  var props = {};\n\n  for (var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++) {\n    var transform = _a[_i];\n\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(props, transform(dateSpan, context));\n  }\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(props, buildDateSpanApi(dateSpan, context.dateEnv));\n\n  return props;\n} // Given an event's allDay status and start date, return what its fallback end date should be.\n// TODO: rename to computeDefaultEventEnd\n\n\nfunction getDefaultEventEnd(allDay, marker, context) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var end = marker;\n\n  if (allDay) {\n    end = startOfDay(end);\n    end = dateEnv.add(end, options.defaultAllDayEventDuration);\n  } else {\n    end = dateEnv.add(end, options.defaultTimedEventDuration);\n  }\n\n  return end;\n} // applies the mutation to ALL defs/instances within the event store\n\n\nfunction applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n  var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n  var dest = createEmptyEventStore();\n\n  for (var defId in eventStore.defs) {\n    var def = eventStore.defs[defId];\n    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n  }\n\n  for (var instanceId in eventStore.instances) {\n    var instance = eventStore.instances[instanceId];\n    var def = dest.defs[instance.defId]; // important to grab the newly modified def\n\n    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n  }\n\n  return dest;\n}\n\nfunction applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n  var standardProps = mutation.standardProps || {}; // if hasEnd has not been specified, guess a good value based on deltas.\n  // if duration will change, there's no way the default duration will persist,\n  // and thus, we need to mark the event as having a real end\n\n  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n    standardProps.hasEnd = true; // TODO: is this mutation okay?\n  }\n\n  var copy = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventDef), standardProps), {\n    ui: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventDef.ui), standardProps.ui)\n  });\n\n  if (mutation.extendedProps) {\n    copy.extendedProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, copy.extendedProps), mutation.extendedProps);\n  }\n\n  for (var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++) {\n    var applier = _a[_i];\n    applier(copy, mutation, context);\n  }\n\n  if (!copy.hasEnd && context.options.forceEventDuration) {\n    copy.hasEnd = true;\n  }\n\n  return copy;\n}\n\nfunction applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef\neventConfig, mutation, context) {\n  var dateEnv = context.dateEnv;\n  var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n  var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n\n  var copy = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventInstance);\n\n  if (forceAllDay) {\n    copy.range = computeAlignedDayRange(copy.range);\n  }\n\n  if (mutation.datesDelta && eventConfig.startEditable) {\n    copy.range = {\n      start: dateEnv.add(copy.range.start, mutation.datesDelta),\n      end: dateEnv.add(copy.range.end, mutation.datesDelta)\n    };\n  }\n\n  if (mutation.startDelta && eventConfig.durationEditable) {\n    copy.range = {\n      start: dateEnv.add(copy.range.start, mutation.startDelta),\n      end: copy.range.end\n    };\n  }\n\n  if (mutation.endDelta && eventConfig.durationEditable) {\n    copy.range = {\n      start: copy.range.start,\n      end: dateEnv.add(copy.range.end, mutation.endDelta)\n    };\n  }\n\n  if (clearEnd) {\n    copy.range = {\n      start: copy.range.start,\n      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n    };\n  } // in case event was all-day but the supplied deltas were not\n  // better util for this?\n\n\n  if (eventDef.allDay) {\n    copy.range = {\n      start: startOfDay(copy.range.start),\n      end: startOfDay(copy.range.end)\n    };\n  } // handle invalid durations\n\n\n  if (copy.range.end < copy.range.start) {\n    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n  }\n\n  return copy;\n} // no public types yet. when there are, export from:\n// import {} from './api-type-deps'\n\n\nvar ViewApi = function () {\n  function ViewApi(type, getCurrentData, dateEnv) {\n    this.type = type;\n    this.getCurrentData = getCurrentData;\n    this.dateEnv = dateEnv;\n  }\n\n  Object.defineProperty(ViewApi.prototype, \"calendar\", {\n    get: function () {\n      return this.getCurrentData().calendarApi;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"title\", {\n    get: function () {\n      return this.getCurrentData().viewTitle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"activeStart\", {\n    get: function () {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"activeEnd\", {\n    get: function () {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"currentStart\", {\n    get: function () {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"currentEnd\", {\n    get: function () {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ViewApi.prototype.getOption = function (name) {\n    return this.getCurrentData().options[name]; // are the view-specific options\n  };\n\n  return ViewApi;\n}();\n\nvar EVENT_SOURCE_REFINERS = {\n  id: String,\n  defaultAllDay: Boolean,\n  url: String,\n  format: String,\n  events: identity,\n  eventDataTransform: identity,\n  // for any network-related sources\n  success: identity,\n  failure: identity\n};\n\nfunction parseEventSource(raw, context, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventSourceRefiners(context);\n  }\n\n  var rawObj;\n\n  if (typeof raw === 'string') {\n    rawObj = {\n      url: raw\n    };\n  } else if (typeof raw === 'function' || Array.isArray(raw)) {\n    rawObj = {\n      events: raw\n    };\n  } else if (typeof raw === 'object' && raw) {\n    // not null\n    rawObj = raw;\n  }\n\n  if (rawObj) {\n    var _a = refineProps(rawObj, refiners),\n        refined = _a.refined,\n        extra = _a.extra;\n\n    var metaRes = buildEventSourceMeta(refined, context);\n\n    if (metaRes) {\n      return {\n        _raw: raw,\n        isFetching: false,\n        latestFetchId: '',\n        fetchRange: null,\n        defaultAllDay: refined.defaultAllDay,\n        eventDataTransform: refined.eventDataTransform,\n        success: refined.success,\n        failure: refined.failure,\n        publicId: refined.id || '',\n        sourceId: guid(),\n        sourceDefId: metaRes.sourceDefId,\n        meta: metaRes.meta,\n        ui: createEventUi(refined, context),\n        extendedProps: extra\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction buildEventSourceRefiners(context) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n}\n\nfunction buildEventSourceMeta(raw, context) {\n  var defs = context.pluginHooks.eventSourceDefs;\n\n  for (var i = defs.length - 1; i >= 0; i -= 1) {\n    // later-added plugins take precedence\n    var def = defs[i];\n    var meta = def.parseMeta(raw);\n\n    if (meta) {\n      return {\n        sourceDefId: i,\n        meta: meta\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction reduceCurrentDate(currentDate, action) {\n  switch (action.type) {\n    case 'CHANGE_DATE':\n      return action.dateMarker;\n\n    default:\n      return currentDate;\n  }\n}\n\nfunction getInitialDate(options, dateEnv) {\n  var initialDateInput = options.initialDate; // compute the initial ambig-timezone date\n\n  if (initialDateInput != null) {\n    return dateEnv.createMarker(initialDateInput);\n  }\n\n  return getNow(options.now, dateEnv); // getNow already returns unzoned\n}\n\nfunction getNow(nowInput, dateEnv) {\n  if (typeof nowInput === 'function') {\n    nowInput = nowInput();\n  }\n\n  if (nowInput == null) {\n    return dateEnv.createNowMarker();\n  }\n\n  return dateEnv.createMarker(nowInput);\n}\n\nvar CalendarApi = function () {\n  function CalendarApi() {}\n\n  CalendarApi.prototype.getCurrentData = function () {\n    return this.currentDataManager.getCurrentData();\n  };\n\n  CalendarApi.prototype.dispatch = function (action) {\n    return this.currentDataManager.dispatch(action);\n  };\n\n  Object.defineProperty(CalendarApi.prototype, \"view\", {\n    get: function () {\n      return this.getCurrentData().viewApi;\n    } // for public API\n    ,\n    enumerable: false,\n    configurable: true\n  });\n\n  CalendarApi.prototype.batchRendering = function (callback) {\n    callback();\n  };\n\n  CalendarApi.prototype.updateSize = function () {\n    this.trigger('_resize', true);\n  }; // Options\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.setOption = function (name, val) {\n    this.dispatch({\n      type: 'SET_OPTION',\n      optionName: name,\n      rawOptionValue: val\n    });\n  };\n\n  CalendarApi.prototype.getOption = function (name) {\n    return this.currentDataManager.currentCalendarOptionsInput[name];\n  };\n\n  CalendarApi.prototype.getAvailableLocaleCodes = function () {\n    return Object.keys(this.getCurrentData().availableRawLocales);\n  }; // Trigger\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.on = function (handlerName, handler) {\n    var currentDataManager = this.currentDataManager;\n\n    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n      currentDataManager.emitter.on(handlerName, handler);\n    } else {\n      console.warn(\"Unknown listener name '\" + handlerName + \"'\");\n    }\n  };\n\n  CalendarApi.prototype.off = function (handlerName, handler) {\n    this.currentDataManager.emitter.off(handlerName, handler);\n  }; // not meant for public use\n\n\n  CalendarApi.prototype.trigger = function (handlerName) {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    (_a = this.currentDataManager.emitter).trigger.apply(_a, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([handlerName], args));\n  }; // View\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.changeView = function (viewType, dateOrRange) {\n    var _this = this;\n\n    this.batchRendering(function () {\n      _this.unselect();\n\n      if (dateOrRange) {\n        if (dateOrRange.start && dateOrRange.end) {\n          // a range\n          _this.dispatch({\n            type: 'CHANGE_VIEW_TYPE',\n            viewType: viewType\n          });\n\n          _this.dispatch({\n            type: 'SET_OPTION',\n            optionName: 'visibleRange',\n            rawOptionValue: dateOrRange\n          });\n        } else {\n          var dateEnv = _this.getCurrentData().dateEnv;\n\n          _this.dispatch({\n            type: 'CHANGE_VIEW_TYPE',\n            viewType: viewType,\n            dateMarker: dateEnv.createMarker(dateOrRange)\n          });\n        }\n      } else {\n        _this.dispatch({\n          type: 'CHANGE_VIEW_TYPE',\n          viewType: viewType\n        });\n      }\n    });\n  }; // Forces navigation to a view for the given date.\n  // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n  // needs to change\n\n\n  CalendarApi.prototype.zoomTo = function (dateMarker, viewType) {\n    var state = this.getCurrentData();\n    var spec;\n    viewType = viewType || 'day'; // day is default zoom\n\n    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n    this.unselect();\n\n    if (spec) {\n      this.dispatch({\n        type: 'CHANGE_VIEW_TYPE',\n        viewType: spec.type,\n        dateMarker: dateMarker\n      });\n    } else {\n      this.dispatch({\n        type: 'CHANGE_DATE',\n        dateMarker: dateMarker\n      });\n    }\n  }; // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n  // Preference is given to views that have corresponding buttons.\n\n\n  CalendarApi.prototype.getUnitViewSpec = function (unit) {\n    var _a = this.getCurrentData(),\n        viewSpecs = _a.viewSpecs,\n        toolbarConfig = _a.toolbarConfig;\n\n    var viewTypes = [].concat(toolbarConfig.viewsWithButtons);\n    var i;\n    var spec;\n\n    for (var viewType in viewSpecs) {\n      viewTypes.push(viewType);\n    }\n\n    for (i = 0; i < viewTypes.length; i += 1) {\n      spec = viewSpecs[viewTypes[i]];\n\n      if (spec) {\n        if (spec.singleUnit === unit) {\n          return spec;\n        }\n      }\n    }\n\n    return null;\n  }; // Current Date\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.prev = function () {\n    this.unselect();\n    this.dispatch({\n      type: 'PREV'\n    });\n  };\n\n  CalendarApi.prototype.next = function () {\n    this.unselect();\n    this.dispatch({\n      type: 'NEXT'\n    });\n  };\n\n  CalendarApi.prototype.prevYear = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n    });\n  };\n\n  CalendarApi.prototype.nextYear = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n    });\n  };\n\n  CalendarApi.prototype.today = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: getNow(state.calendarOptions.now, state.dateEnv)\n    });\n  };\n\n  CalendarApi.prototype.gotoDate = function (zonedDateInput) {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.createMarker(zonedDateInput)\n    });\n  };\n\n  CalendarApi.prototype.incrementDate = function (deltaInput) {\n    var state = this.getCurrentData();\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // else, warn about invalid input?\n      this.unselect();\n      this.dispatch({\n        type: 'CHANGE_DATE',\n        dateMarker: state.dateEnv.add(state.currentDate, delta)\n      });\n    }\n  }; // for external API\n\n\n  CalendarApi.prototype.getDate = function () {\n    var state = this.getCurrentData();\n    return state.dateEnv.toDate(state.currentDate);\n  }; // Date Formatting Utils\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.formatDate = function (d, formatter) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n  }; // `settings` is for formatter AND isEndExclusive\n\n\n  CalendarApi.prototype.formatRange = function (d0, d1, settings) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n  };\n\n  CalendarApi.prototype.formatIso = function (d, omitTime) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.formatIso(dateEnv.createMarker(d), {\n      omitTime: omitTime\n    });\n  }; // Date Selection / Event Selection / DayClick\n  // -----------------------------------------------------------------------------------------------------------------\n  // this public method receives start/end dates in any format, with any timezone\n  // NOTE: args were changed from v3\n\n\n  CalendarApi.prototype.select = function (dateOrObj, endDate) {\n    var selectionInput;\n\n    if (endDate == null) {\n      if (dateOrObj.start != null) {\n        selectionInput = dateOrObj;\n      } else {\n        selectionInput = {\n          start: dateOrObj,\n          end: null\n        };\n      }\n    } else {\n      selectionInput = {\n        start: dateOrObj,\n        end: endDate\n      };\n    }\n\n    var state = this.getCurrentData();\n    var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n      days: 1\n    }));\n\n    if (selection) {\n      // throw parse error otherwise?\n      this.dispatch({\n        type: 'SELECT_DATES',\n        selection: selection\n      });\n      triggerDateSelect(selection, null, state);\n    }\n  }; // public method\n\n\n  CalendarApi.prototype.unselect = function (pev) {\n    var state = this.getCurrentData();\n\n    if (state.dateSelection) {\n      this.dispatch({\n        type: 'UNSELECT_DATES'\n      });\n      triggerDateUnselect(pev, state);\n    }\n  }; // Public Events API\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.addEvent = function (eventInput, sourceInput) {\n    if (eventInput instanceof EventApi) {\n      var def = eventInput._def;\n      var instance = eventInput._instance;\n      var currentData = this.getCurrentData(); // not already present? don't want to add an old snapshot\n\n      if (!currentData.eventStore.defs[def.defId]) {\n        this.dispatch({\n          type: 'ADD_EVENTS',\n          eventStore: eventTupleToStore({\n            def: def,\n            instance: instance\n          }) // TODO: better util for two args?\n\n        });\n        this.triggerEventAdd(eventInput);\n      }\n\n      return eventInput;\n    }\n\n    var state = this.getCurrentData();\n    var eventSource;\n\n    if (sourceInput instanceof EventSourceApi) {\n      eventSource = sourceInput.internalEventSource;\n    } else if (typeof sourceInput === 'boolean') {\n      if (sourceInput) {\n        // true. part of the first event source\n        eventSource = hashValuesToArray(state.eventSources)[0];\n      }\n    } else if (sourceInput != null) {\n      // an ID. accepts a number too\n      var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n\n      if (!sourceApi) {\n        console.warn(\"Could not find an event source with ID \\\"\" + sourceInput + \"\\\"\"); // TODO: test\n\n        return null;\n      }\n\n      eventSource = sourceApi.internalEventSource;\n    }\n\n    var tuple = parseEvent(eventInput, eventSource, state, false);\n\n    if (tuple) {\n      var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n      this.dispatch({\n        type: 'ADD_EVENTS',\n        eventStore: eventTupleToStore(tuple)\n      });\n      this.triggerEventAdd(newEventApi);\n      return newEventApi;\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.triggerEventAdd = function (eventApi) {\n    var _this = this;\n\n    var emitter = this.getCurrentData().emitter;\n    emitter.trigger('eventAdd', {\n      event: eventApi,\n      relatedEvents: [],\n      revert: function () {\n        _this.dispatch({\n          type: 'REMOVE_EVENTS',\n          eventStore: eventApiToStore(eventApi)\n        });\n      }\n    });\n  }; // TODO: optimize\n\n\n  CalendarApi.prototype.getEventById = function (id) {\n    var state = this.getCurrentData();\n    var _a = state.eventStore,\n        defs = _a.defs,\n        instances = _a.instances;\n    id = String(id);\n\n    for (var defId in defs) {\n      var def = defs[defId];\n\n      if (def.publicId === id) {\n        if (def.recurringDef) {\n          return new EventApi(state, def, null);\n        }\n\n        for (var instanceId in instances) {\n          var instance = instances[instanceId];\n\n          if (instance.defId === def.defId) {\n            return new EventApi(state, def, instance);\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.getEvents = function () {\n    var currentData = this.getCurrentData();\n    return buildEventApis(currentData.eventStore, currentData);\n  };\n\n  CalendarApi.prototype.removeAllEvents = function () {\n    this.dispatch({\n      type: 'REMOVE_ALL_EVENTS'\n    });\n  }; // Public Event Sources API\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.getEventSources = function () {\n    var state = this.getCurrentData();\n    var sourceHash = state.eventSources;\n    var sourceApis = [];\n\n    for (var internalId in sourceHash) {\n      sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));\n    }\n\n    return sourceApis;\n  };\n\n  CalendarApi.prototype.getEventSourceById = function (id) {\n    var state = this.getCurrentData();\n    var sourceHash = state.eventSources;\n    id = String(id);\n\n    for (var sourceId in sourceHash) {\n      if (sourceHash[sourceId].publicId === id) {\n        return new EventSourceApi(state, sourceHash[sourceId]);\n      }\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.addEventSource = function (sourceInput) {\n    var state = this.getCurrentData();\n\n    if (sourceInput instanceof EventSourceApi) {\n      // not already present? don't want to add an old snapshot\n      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n        this.dispatch({\n          type: 'ADD_EVENT_SOURCES',\n          sources: [sourceInput.internalEventSource]\n        });\n      }\n\n      return sourceInput;\n    }\n\n    var eventSource = parseEventSource(sourceInput, state);\n\n    if (eventSource) {\n      // TODO: error otherwise?\n      this.dispatch({\n        type: 'ADD_EVENT_SOURCES',\n        sources: [eventSource]\n      });\n      return new EventSourceApi(state, eventSource);\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.removeAllEventSources = function () {\n    this.dispatch({\n      type: 'REMOVE_ALL_EVENT_SOURCES'\n    });\n  };\n\n  CalendarApi.prototype.refetchEvents = function () {\n    this.dispatch({\n      type: 'FETCH_EVENT_SOURCES',\n      isRefetch: true\n    });\n  }; // Scroll\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.scrollToTime = function (timeInput) {\n    var time = createDuration(timeInput);\n\n    if (time) {\n      this.trigger('_scrollRequest', {\n        time: time\n      });\n    }\n  };\n\n  return CalendarApi;\n}();\n\nvar EventApi = function () {\n  // instance will be null if expressing a recurring event that has no current instances,\n  // OR if trying to validate an incoming external event that has no dates assigned\n  function EventApi(context, def, instance) {\n    this._context = context;\n    this._def = def;\n    this._instance = instance || null;\n  }\n  /*\n  TODO: make event struct more responsible for this\n  */\n\n\n  EventApi.prototype.setProp = function (name, val) {\n    var _a, _b;\n\n    if (name in EVENT_DATE_REFINERS) {\n      console.warn('Could not set date-related prop \\'name\\'. Use one of the date-related methods instead.'); // TODO: make proper aliasing system?\n    } else if (name === 'id') {\n      val = EVENT_NON_DATE_REFINERS[name](val);\n      this.mutate({\n        standardProps: {\n          publicId: val\n        } // hardcoded internal name\n\n      });\n    } else if (name in EVENT_NON_DATE_REFINERS) {\n      val = EVENT_NON_DATE_REFINERS[name](val);\n      this.mutate({\n        standardProps: (_a = {}, _a[name] = val, _a)\n      });\n    } else if (name in EVENT_UI_REFINERS) {\n      var ui = EVENT_UI_REFINERS[name](val);\n\n      if (name === 'color') {\n        ui = {\n          backgroundColor: val,\n          borderColor: val\n        };\n      } else if (name === 'editable') {\n        ui = {\n          startEditable: val,\n          durationEditable: val\n        };\n      } else {\n        ui = (_b = {}, _b[name] = val, _b);\n      }\n\n      this.mutate({\n        standardProps: {\n          ui: ui\n        }\n      });\n    } else {\n      console.warn(\"Could not set prop '\" + name + \"'. Use setExtendedProp instead.\");\n    }\n  };\n\n  EventApi.prototype.setExtendedProp = function (name, val) {\n    var _a;\n\n    this.mutate({\n      extendedProps: (_a = {}, _a[name] = val, _a)\n    });\n  };\n\n  EventApi.prototype.setStart = function (startInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var start = dateEnv.createMarker(startInput);\n\n    if (start && this._instance) {\n      // TODO: warning if parsed bad\n      var instanceRange = this._instance.range;\n      var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n\n      if (options.maintainDuration) {\n        this.mutate({\n          datesDelta: startDelta\n        });\n      } else {\n        this.mutate({\n          startDelta: startDelta\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.setEnd = function (endInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var end;\n\n    if (endInput != null) {\n      end = dateEnv.createMarker(endInput);\n\n      if (!end) {\n        return; // TODO: warning if parsed bad\n      }\n    }\n\n    if (this._instance) {\n      if (end) {\n        var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n        this.mutate({\n          endDelta: endDelta\n        });\n      } else {\n        this.mutate({\n          standardProps: {\n            hasEnd: false\n          }\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.setDates = function (startInput, endInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var standardProps = {\n      allDay: options.allDay\n    };\n    var start = dateEnv.createMarker(startInput);\n    var end;\n\n    if (!start) {\n      return; // TODO: warning if parsed bad\n    }\n\n    if (endInput != null) {\n      end = dateEnv.createMarker(endInput);\n\n      if (!end) {\n        // TODO: warning if parsed bad\n        return;\n      }\n    }\n\n    if (this._instance) {\n      var instanceRange = this._instance.range; // when computing the diff for an event being converted to all-day,\n      // compute diff off of the all-day values the way event-mutation does.\n\n      if (options.allDay === true) {\n        instanceRange = computeAlignedDayRange(instanceRange);\n      }\n\n      var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n\n      if (end) {\n        var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n\n        if (durationsEqual(startDelta, endDelta)) {\n          this.mutate({\n            datesDelta: startDelta,\n            standardProps: standardProps\n          });\n        } else {\n          this.mutate({\n            startDelta: startDelta,\n            endDelta: endDelta,\n            standardProps: standardProps\n          });\n        }\n      } else {\n        // means \"clear the end\"\n        standardProps.hasEnd = false;\n        this.mutate({\n          datesDelta: startDelta,\n          standardProps: standardProps\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.moveStart = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        startDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.moveEnd = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        endDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.moveDates = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        datesDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.setAllDay = function (allDay, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var standardProps = {\n      allDay: allDay\n    };\n    var maintainDuration = options.maintainDuration;\n\n    if (maintainDuration == null) {\n      maintainDuration = this._context.options.allDayMaintainDuration;\n    }\n\n    if (this._def.allDay !== allDay) {\n      standardProps.hasEnd = maintainDuration;\n    }\n\n    this.mutate({\n      standardProps: standardProps\n    });\n  };\n\n  EventApi.prototype.formatRange = function (formatInput) {\n    var dateEnv = this._context.dateEnv;\n    var instance = this._instance;\n    var formatter = createFormatter(formatInput);\n\n    if (this._def.hasEnd) {\n      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n        forcedStartTzo: instance.forcedStartTzo,\n        forcedEndTzo: instance.forcedEndTzo\n      });\n    }\n\n    return dateEnv.format(instance.range.start, formatter, {\n      forcedTzo: instance.forcedStartTzo\n    });\n  };\n\n  EventApi.prototype.mutate = function (mutation) {\n    var instance = this._instance;\n\n    if (instance) {\n      var def = this._def;\n      var context_1 = this._context;\n      var eventStore_1 = context_1.getCurrentData().eventStore;\n      var relevantEvents = getRelevantEvents(eventStore_1, instance.instanceId);\n      var eventConfigBase = {\n        '': {\n          display: '',\n          startEditable: true,\n          durationEditable: true,\n          constraints: [],\n          overlap: null,\n          allows: [],\n          backgroundColor: '',\n          borderColor: '',\n          textColor: '',\n          classNames: []\n        }\n      };\n      relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context_1);\n      var oldEvent = new EventApi(context_1, def, instance); // snapshot\n\n      this._def = relevantEvents.defs[def.defId];\n      this._instance = relevantEvents.instances[instance.instanceId];\n      context_1.dispatch({\n        type: 'MERGE_EVENTS',\n        eventStore: relevantEvents\n      });\n      context_1.emitter.trigger('eventChange', {\n        oldEvent: oldEvent,\n        event: this,\n        relatedEvents: buildEventApis(relevantEvents, context_1, instance),\n        revert: function () {\n          context_1.dispatch({\n            type: 'RESET_EVENTS',\n            eventStore: eventStore_1\n          });\n        }\n      });\n    }\n  };\n\n  EventApi.prototype.remove = function () {\n    var context = this._context;\n    var asStore = eventApiToStore(this);\n    context.dispatch({\n      type: 'REMOVE_EVENTS',\n      eventStore: asStore\n    });\n    context.emitter.trigger('eventRemove', {\n      event: this,\n      relatedEvents: [],\n      revert: function () {\n        context.dispatch({\n          type: 'MERGE_EVENTS',\n          eventStore: asStore\n        });\n      }\n    });\n  };\n\n  Object.defineProperty(EventApi.prototype, \"source\", {\n    get: function () {\n      var sourceId = this._def.sourceId;\n\n      if (sourceId) {\n        return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"start\", {\n    get: function () {\n      return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"end\", {\n    get: function () {\n      return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"startStr\", {\n    get: function () {\n      var instance = this._instance;\n\n      if (instance) {\n        return this._context.dateEnv.formatIso(instance.range.start, {\n          omitTime: this._def.allDay,\n          forcedTzo: instance.forcedStartTzo\n        });\n      }\n\n      return '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"endStr\", {\n    get: function () {\n      var instance = this._instance;\n\n      if (instance && this._def.hasEnd) {\n        return this._context.dateEnv.formatIso(instance.range.end, {\n          omitTime: this._def.allDay,\n          forcedTzo: instance.forcedEndTzo\n        });\n      }\n\n      return '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"id\", {\n    // computable props that all access the def\n    // TODO: find a TypeScript-compatible way to do this at scale\n    get: function () {\n      return this._def.publicId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"groupId\", {\n    get: function () {\n      return this._def.groupId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"allDay\", {\n    get: function () {\n      return this._def.allDay;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"title\", {\n    get: function () {\n      return this._def.title;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"url\", {\n    get: function () {\n      return this._def.url;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"display\", {\n    get: function () {\n      return this._def.ui.display || 'auto';\n    } // bad. just normalize the type earlier\n    ,\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"startEditable\", {\n    get: function () {\n      return this._def.ui.startEditable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"durationEditable\", {\n    get: function () {\n      return this._def.ui.durationEditable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"constraint\", {\n    get: function () {\n      return this._def.ui.constraints[0] || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"overlap\", {\n    get: function () {\n      return this._def.ui.overlap;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"allow\", {\n    get: function () {\n      return this._def.ui.allows[0] || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"backgroundColor\", {\n    get: function () {\n      return this._def.ui.backgroundColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"borderColor\", {\n    get: function () {\n      return this._def.ui.borderColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"textColor\", {\n    get: function () {\n      return this._def.ui.textColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"classNames\", {\n    // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n    get: function () {\n      return this._def.ui.classNames;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"extendedProps\", {\n    get: function () {\n      return this._def.extendedProps;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  EventApi.prototype.toPlainObject = function (settings) {\n    if (settings === void 0) {\n      settings = {};\n    }\n\n    var def = this._def;\n    var ui = def.ui;\n\n    var _a = this,\n        startStr = _a.startStr,\n        endStr = _a.endStr;\n\n    var res = {};\n\n    if (def.title) {\n      res.title = def.title;\n    }\n\n    if (startStr) {\n      res.start = startStr;\n    }\n\n    if (endStr) {\n      res.end = endStr;\n    }\n\n    if (def.publicId) {\n      res.id = def.publicId;\n    }\n\n    if (def.groupId) {\n      res.groupId = def.groupId;\n    }\n\n    if (def.url) {\n      res.url = def.url;\n    }\n\n    if (ui.display && ui.display !== 'auto') {\n      res.display = ui.display;\n    } // TODO: what about recurring-event properties???\n    // TODO: include startEditable/durationEditable/constraint/overlap/allow\n\n\n    if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n      res.color = ui.backgroundColor;\n    } else {\n      if (ui.backgroundColor) {\n        res.backgroundColor = ui.backgroundColor;\n      }\n\n      if (ui.borderColor) {\n        res.borderColor = ui.borderColor;\n      }\n    }\n\n    if (ui.textColor) {\n      res.textColor = ui.textColor;\n    }\n\n    if (ui.classNames.length) {\n      res.classNames = ui.classNames;\n    }\n\n    if (Object.keys(def.extendedProps).length) {\n      if (settings.collapseExtendedProps) {\n        (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(res, def.extendedProps);\n      } else {\n        res.extendedProps = def.extendedProps;\n      }\n    }\n\n    return res;\n  };\n\n  EventApi.prototype.toJSON = function () {\n    return this.toPlainObject();\n  };\n\n  return EventApi;\n}();\n\nfunction eventApiToStore(eventApi) {\n  var _a, _b;\n\n  var def = eventApi._def;\n  var instance = eventApi._instance;\n  return {\n    defs: (_a = {}, _a[def.defId] = def, _a),\n    instances: instance ? (_b = {}, _b[instance.instanceId] = instance, _b) : {}\n  };\n}\n\nfunction buildEventApis(eventStore, context, excludeInstance) {\n  var defs = eventStore.defs,\n      instances = eventStore.instances;\n  var eventApis = [];\n  var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';\n\n  for (var id in instances) {\n    var instance = instances[id];\n    var def = defs[instance.defId];\n\n    if (instance.instanceId !== excludeInstanceId) {\n      eventApis.push(new EventApi(context, def, instance));\n    }\n  }\n\n  return eventApis;\n}\n\nvar calendarSystemClassMap = {};\n\nfunction registerCalendarSystem(name, theClass) {\n  calendarSystemClassMap[name] = theClass;\n}\n\nfunction createCalendarSystem(name) {\n  return new calendarSystemClassMap[name]();\n}\n\nvar GregorianCalendarSystem = function () {\n  function GregorianCalendarSystem() {}\n\n  GregorianCalendarSystem.prototype.getMarkerYear = function (d) {\n    return d.getUTCFullYear();\n  };\n\n  GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {\n    return d.getUTCMonth();\n  };\n\n  GregorianCalendarSystem.prototype.getMarkerDay = function (d) {\n    return d.getUTCDate();\n  };\n\n  GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {\n    return arrayToUtcDate(arr);\n  };\n\n  GregorianCalendarSystem.prototype.markerToArray = function (marker) {\n    return dateToUtcArray(marker);\n  };\n\n  return GregorianCalendarSystem;\n}();\n\nregisterCalendarSystem('gregory', GregorianCalendarSystem);\nvar ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\n\nfunction parse(str) {\n  var m = ISO_RE.exec(str);\n\n  if (m) {\n    var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(\"0.\" + m[12]) * 1000 : 0));\n\n    if (isValidDate(marker)) {\n      var timeZoneOffset = null;\n\n      if (m[13]) {\n        timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n      }\n\n      return {\n        marker: marker,\n        isTimeUnspecified: !m[6],\n        timeZoneOffset: timeZoneOffset\n      };\n    }\n  }\n\n  return null;\n}\n\nvar DateEnv = function () {\n  function DateEnv(settings) {\n    var timeZone = this.timeZone = settings.timeZone;\n    var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';\n\n    if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n    }\n\n    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n    this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n    this.locale = settings.locale;\n    this.weekDow = settings.locale.week.dow;\n    this.weekDoy = settings.locale.week.doy;\n\n    if (settings.weekNumberCalculation === 'ISO') {\n      this.weekDow = 1;\n      this.weekDoy = 4;\n    }\n\n    if (typeof settings.firstDay === 'number') {\n      this.weekDow = settings.firstDay;\n    }\n\n    if (typeof settings.weekNumberCalculation === 'function') {\n      this.weekNumberFunc = settings.weekNumberCalculation;\n    }\n\n    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n    this.cmdFormatter = settings.cmdFormatter;\n    this.defaultSeparator = settings.defaultSeparator;\n  } // Creating / Parsing\n\n\n  DateEnv.prototype.createMarker = function (input) {\n    var meta = this.createMarkerMeta(input);\n\n    if (meta === null) {\n      return null;\n    }\n\n    return meta.marker;\n  };\n\n  DateEnv.prototype.createNowMarker = function () {\n    if (this.canComputeOffset) {\n      return this.timestampToMarker(new Date().valueOf());\n    } // if we can't compute the current date val for a timezone,\n    // better to give the current local date vals than UTC\n\n\n    return arrayToUtcDate(dateToLocalArray(new Date()));\n  };\n\n  DateEnv.prototype.createMarkerMeta = function (input) {\n    if (typeof input === 'string') {\n      return this.parse(input);\n    }\n\n    var marker = null;\n\n    if (typeof input === 'number') {\n      marker = this.timestampToMarker(input);\n    } else if (input instanceof Date) {\n      input = input.valueOf();\n\n      if (!isNaN(input)) {\n        marker = this.timestampToMarker(input);\n      }\n    } else if (Array.isArray(input)) {\n      marker = arrayToUtcDate(input);\n    }\n\n    if (marker === null || !isValidDate(marker)) {\n      return null;\n    }\n\n    return {\n      marker: marker,\n      isTimeUnspecified: false,\n      forcedTzo: null\n    };\n  };\n\n  DateEnv.prototype.parse = function (s) {\n    var parts = parse(s);\n\n    if (parts === null) {\n      return null;\n    }\n\n    var marker = parts.marker;\n    var forcedTzo = null;\n\n    if (parts.timeZoneOffset !== null) {\n      if (this.canComputeOffset) {\n        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n      } else {\n        forcedTzo = parts.timeZoneOffset;\n      }\n    }\n\n    return {\n      marker: marker,\n      isTimeUnspecified: parts.isTimeUnspecified,\n      forcedTzo: forcedTzo\n    };\n  }; // Accessors\n\n\n  DateEnv.prototype.getYear = function (marker) {\n    return this.calendarSystem.getMarkerYear(marker);\n  };\n\n  DateEnv.prototype.getMonth = function (marker) {\n    return this.calendarSystem.getMarkerMonth(marker);\n  }; // Adding / Subtracting\n\n\n  DateEnv.prototype.add = function (marker, dur) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] += dur.years;\n    a[1] += dur.months;\n    a[2] += dur.days;\n    a[6] += dur.milliseconds;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.subtract = function (marker, dur) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] -= dur.years;\n    a[1] -= dur.months;\n    a[2] -= dur.days;\n    a[6] -= dur.milliseconds;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.addYears = function (marker, n) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] += n;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.addMonths = function (marker, n) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[1] += n;\n    return this.calendarSystem.arrayToMarker(a);\n  }; // Diffing Whole Units\n\n\n  DateEnv.prototype.diffWholeYears = function (m0, m1) {\n    var calendarSystem = this.calendarSystem;\n\n    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n    }\n\n    return null;\n  };\n\n  DateEnv.prototype.diffWholeMonths = function (m0, m1) {\n    var calendarSystem = this.calendarSystem;\n\n    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n    }\n\n    return null;\n  }; // Range / Duration\n\n\n  DateEnv.prototype.greatestWholeUnit = function (m0, m1) {\n    var n = this.diffWholeYears(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'year',\n        value: n\n      };\n    }\n\n    n = this.diffWholeMonths(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'month',\n        value: n\n      };\n    }\n\n    n = diffWholeWeeks(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'week',\n        value: n\n      };\n    }\n\n    n = diffWholeDays(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'day',\n        value: n\n      };\n    }\n\n    n = diffHours(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'hour',\n        value: n\n      };\n    }\n\n    n = diffMinutes(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'minute',\n        value: n\n      };\n    }\n\n    n = diffSeconds(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'second',\n        value: n\n      };\n    }\n\n    return {\n      unit: 'millisecond',\n      value: m1.valueOf() - m0.valueOf()\n    };\n  };\n\n  DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {\n    // TODO: can use greatestWholeUnit\n    var diff;\n\n    if (d.years) {\n      diff = this.diffWholeYears(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughYears(d);\n      }\n    }\n\n    if (d.months) {\n      diff = this.diffWholeMonths(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughMonths(d);\n      }\n    }\n\n    if (d.days) {\n      diff = diffWholeDays(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughDays(d);\n      }\n    }\n\n    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n  }; // Start-Of\n  // these DON'T return zoned-dates. only UTC start-of dates\n\n\n  DateEnv.prototype.startOf = function (m, unit) {\n    if (unit === 'year') {\n      return this.startOfYear(m);\n    }\n\n    if (unit === 'month') {\n      return this.startOfMonth(m);\n    }\n\n    if (unit === 'week') {\n      return this.startOfWeek(m);\n    }\n\n    if (unit === 'day') {\n      return startOfDay(m);\n    }\n\n    if (unit === 'hour') {\n      return startOfHour(m);\n    }\n\n    if (unit === 'minute') {\n      return startOfMinute(m);\n    }\n\n    if (unit === 'second') {\n      return startOfSecond(m);\n    }\n\n    return null;\n  };\n\n  DateEnv.prototype.startOfYear = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m)]);\n  };\n\n  DateEnv.prototype.startOfMonth = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m)]);\n  };\n\n  DateEnv.prototype.startOfWeek = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m), m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7]);\n  }; // Week Number\n\n\n  DateEnv.prototype.computeWeekNumber = function (marker) {\n    if (this.weekNumberFunc) {\n      return this.weekNumberFunc(this.toDate(marker));\n    }\n\n    return weekOfYear(marker, this.weekDow, this.weekDoy);\n  }; // TODO: choke on timeZoneName: long\n\n\n  DateEnv.prototype.format = function (marker, formatter, dateOptions) {\n    if (dateOptions === void 0) {\n      dateOptions = {};\n    }\n\n    return formatter.format({\n      marker: marker,\n      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n    }, this);\n  };\n\n  DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {\n    if (dateOptions === void 0) {\n      dateOptions = {};\n    }\n\n    if (dateOptions.isEndExclusive) {\n      end = addMs(end, -1);\n    }\n\n    return formatter.formatRange({\n      marker: start,\n      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n    }, {\n      marker: end,\n      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n    }, this, dateOptions.defaultSeparator);\n  };\n  /*\n  DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n  might as well use buildIsoString or some other util directly\n  */\n\n\n  DateEnv.prototype.formatIso = function (marker, extraOptions) {\n    if (extraOptions === void 0) {\n      extraOptions = {};\n    }\n\n    var timeZoneOffset = null;\n\n    if (!extraOptions.omitTimeZoneOffset) {\n      if (extraOptions.forcedTzo != null) {\n        timeZoneOffset = extraOptions.forcedTzo;\n      } else {\n        timeZoneOffset = this.offsetForMarker(marker);\n      }\n    }\n\n    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n  }; // TimeZone\n\n\n  DateEnv.prototype.timestampToMarker = function (ms) {\n    if (this.timeZone === 'local') {\n      return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n    }\n\n    if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {\n      return new Date(ms);\n    }\n\n    return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n  };\n\n  DateEnv.prototype.offsetForMarker = function (m) {\n    if (this.timeZone === 'local') {\n      return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n    }\n\n    if (this.timeZone === 'UTC') {\n      return 0;\n    }\n\n    if (this.namedTimeZoneImpl) {\n      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n    }\n\n    return null;\n  }; // Conversion\n\n\n  DateEnv.prototype.toDate = function (m, forcedTzo) {\n    if (this.timeZone === 'local') {\n      return arrayToLocalDate(dateToUtcArray(m));\n    }\n\n    if (this.timeZone === 'UTC') {\n      return new Date(m.valueOf()); // make sure it's a copy\n    }\n\n    if (!this.namedTimeZoneImpl) {\n      return new Date(m.valueOf() - (forcedTzo || 0));\n    }\n\n    return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n  };\n\n  return DateEnv;\n}();\n\nvar globalLocales = [];\nvar RAW_EN_LOCALE = {\n  code: 'en',\n  week: {\n    dow: 0,\n    doy: 4 // 4 days need to be within the year to be considered the first week\n\n  },\n  direction: 'ltr',\n  buttonText: {\n    prev: 'prev',\n    next: 'next',\n    prevYear: 'prev year',\n    nextYear: 'next year',\n    year: 'year',\n    today: 'today',\n    month: 'month',\n    week: 'week',\n    day: 'day',\n    list: 'list'\n  },\n  weekText: 'W',\n  allDayText: 'all-day',\n  moreLinkText: 'more',\n  noEventsText: 'No events to display'\n};\n\nfunction organizeRawLocales(explicitRawLocales) {\n  var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';\n  var allRawLocales = globalLocales.concat(explicitRawLocales);\n  var rawLocaleMap = {\n    en: RAW_EN_LOCALE // necessary?\n\n  };\n\n  for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {\n    var rawLocale = allRawLocales_1[_i];\n    rawLocaleMap[rawLocale.code] = rawLocale;\n  }\n\n  return {\n    map: rawLocaleMap,\n    defaultCode: defaultCode\n  };\n}\n\nfunction buildLocale(inputSingular, available) {\n  if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {\n    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);\n  }\n\n  return queryLocale(inputSingular, available);\n}\n\nfunction queryLocale(codeArg, available) {\n  var codes = [].concat(codeArg || []); // will convert to array\n\n  var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n  return parseLocale(codeArg, codes, raw);\n}\n\nfunction queryRawLocale(codes, available) {\n  for (var i = 0; i < codes.length; i += 1) {\n    var parts = codes[i].toLocaleLowerCase().split('-');\n\n    for (var j = parts.length; j > 0; j -= 1) {\n      var simpleId = parts.slice(0, j).join('-');\n\n      if (available[simpleId]) {\n        return available[simpleId];\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction parseLocale(codeArg, codes, raw) {\n  var merged = mergeProps([RAW_EN_LOCALE, raw], ['buttonText']);\n  delete merged.code; // don't want this part of the options\n\n  var week = merged.week;\n  delete merged.week;\n  return {\n    codeArg: codeArg,\n    codes: codes,\n    week: week,\n    simpleNumberFormat: new Intl.NumberFormat(codeArg),\n    options: merged\n  };\n}\n\nfunction formatDate(dateInput, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var dateEnv = buildDateEnv$1(options);\n  var formatter = createFormatter(options);\n  var dateMeta = dateEnv.createMarkerMeta(dateInput);\n\n  if (!dateMeta) {\n    // TODO: warning?\n    return '';\n  }\n\n  return dateEnv.format(dateMeta.marker, formatter, {\n    forcedTzo: dateMeta.forcedTzo\n  });\n}\n\nfunction formatRange(startInput, endInput, options) {\n  var dateEnv = buildDateEnv$1(typeof options === 'object' && options ? options : {}); // pass in if non-null object\n\n  var formatter = createFormatter(options);\n  var startMeta = dateEnv.createMarkerMeta(startInput);\n  var endMeta = dateEnv.createMarkerMeta(endInput);\n\n  if (!startMeta || !endMeta) {\n    // TODO: warning?\n    return '';\n  }\n\n  return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n    forcedStartTzo: startMeta.forcedTzo,\n    forcedEndTzo: endMeta.forcedTzo,\n    isEndExclusive: options.isEndExclusive,\n    defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator\n  });\n} // TODO: more DRY and optimized\n\n\nfunction buildDateEnv$1(settings) {\n  var locale = buildLocale(settings.locale || 'en', organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n\n  return new DateEnv((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n    timeZone: BASE_OPTION_DEFAULTS.timeZone,\n    calendarSystem: 'gregory'\n  }, settings), {\n    locale: locale\n  }));\n}\n\nvar DEF_DEFAULTS = {\n  startTime: '09:00',\n  endTime: '17:00',\n  daysOfWeek: [1, 2, 3, 4, 5],\n  display: 'inverse-background',\n  classNames: 'fc-non-business',\n  groupId: '_businessHours' // so multiple defs get grouped\n\n};\n/*\nTODO: pass around as EventDefHash!!!\n*/\n\nfunction parseBusinessHours(input, context) {\n  return parseEvents(refineInputs(input), null, context);\n}\n\nfunction refineInputs(input) {\n  var rawDefs;\n\n  if (input === true) {\n    rawDefs = [{}]; // will get DEF_DEFAULTS verbatim\n  } else if (Array.isArray(input)) {\n    // if specifying an array, every sub-definition NEEDS a day-of-week\n    rawDefs = input.filter(function (rawDef) {\n      return rawDef.daysOfWeek;\n    });\n  } else if (typeof input === 'object' && input) {\n    // non-null object\n    rawDefs = [input];\n  } else {\n    // is probably false\n    rawDefs = [];\n  }\n\n  rawDefs = rawDefs.map(function (rawDef) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, DEF_DEFAULTS), rawDef);\n  });\n  return rawDefs;\n}\n\nfunction pointInsideRect(point, rect) {\n  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n} // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\n\n\nfunction intersectRects(rect1, rect2) {\n  var res = {\n    left: Math.max(rect1.left, rect2.left),\n    right: Math.min(rect1.right, rect2.right),\n    top: Math.max(rect1.top, rect2.top),\n    bottom: Math.min(rect1.bottom, rect2.bottom)\n  };\n\n  if (res.left < res.right && res.top < res.bottom) {\n    return res;\n  }\n\n  return false;\n}\n\nfunction translateRect(rect, deltaX, deltaY) {\n  return {\n    left: rect.left + deltaX,\n    right: rect.right + deltaX,\n    top: rect.top + deltaY,\n    bottom: rect.bottom + deltaY\n  };\n} // Returns a new point that will have been moved to reside within the given rectangle\n\n\nfunction constrainPoint(point, rect) {\n  return {\n    left: Math.min(Math.max(point.left, rect.left), rect.right),\n    top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n  };\n} // Returns a point that is the center of the given rectangle\n\n\nfunction getRectCenter(rect) {\n  return {\n    left: (rect.left + rect.right) / 2,\n    top: (rect.top + rect.bottom) / 2\n  };\n} // Subtracts point2's coordinates from point1's coordinates, returning a delta\n\n\nfunction diffPoints(point1, point2) {\n  return {\n    left: point1.left - point2.left,\n    top: point1.top - point2.top\n  };\n}\n\nvar canVGrowWithinCell;\n\nfunction getCanVGrowWithinCell() {\n  if (canVGrowWithinCell == null) {\n    canVGrowWithinCell = computeCanVGrowWithinCell();\n  }\n\n  return canVGrowWithinCell;\n}\n\nfunction computeCanVGrowWithinCell() {\n  // for SSR, because this function is call immediately at top-level\n  // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n  if (typeof document === 'undefined') {\n    return true;\n  }\n\n  var el = document.createElement('div');\n  el.style.position = 'absolute';\n  el.style.top = '0px';\n  el.style.left = '0px';\n  el.innerHTML = '<table><tr><td><div></div></td></tr></table>';\n  el.querySelector('table').style.height = '100px';\n  el.querySelector('div').style.height = '100%';\n  document.body.appendChild(el);\n  var div = el.querySelector('div');\n  var possible = div.offsetHeight > 0;\n  document.body.removeChild(el);\n  return possible;\n}\n\nvar EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\n\nvar Splitter = function () {\n  function Splitter() {\n    this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n    this.splitDateSelection = memoize(this._splitDateSpan);\n    this.splitEventStore = memoize(this._splitEventStore);\n    this.splitIndividualUi = memoize(this._splitIndividualUi);\n    this.splitEventDrag = memoize(this._splitInteraction);\n    this.splitEventResize = memoize(this._splitInteraction);\n    this.eventUiBuilders = {}; // TODO: typescript protection\n  }\n\n  Splitter.prototype.splitProps = function (props) {\n    var _this = this;\n\n    var keyInfos = this.getKeyInfo(props);\n    var defKeys = this.getKeysForEventDefs(props.eventStore);\n    var dateSelections = this.splitDateSelection(props.dateSelection);\n    var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n\n    var eventStores = this.splitEventStore(props.eventStore, defKeys);\n    var eventDrags = this.splitEventDrag(props.eventDrag);\n    var eventResizes = this.splitEventResize(props.eventResize);\n    var splitProps = {};\n    this.eventUiBuilders = mapHash(keyInfos, function (info, key) {\n      return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);\n    });\n\n    for (var key in keyInfos) {\n      var keyInfo = keyInfos[key];\n      var eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n      var buildEventUi = this.eventUiBuilders[key];\n      splitProps[key] = {\n        businessHours: keyInfo.businessHours || props.businessHours,\n        dateSelection: dateSelections[key] || null,\n        eventStore: eventStore,\n        eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),\n        eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',\n        eventDrag: eventDrags[key] || null,\n        eventResize: eventResizes[key] || null\n      };\n    }\n\n    return splitProps;\n  };\n\n  Splitter.prototype._splitDateSpan = function (dateSpan) {\n    var dateSpans = {};\n\n    if (dateSpan) {\n      var keys = this.getKeysForDateSpan(dateSpan);\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n        dateSpans[key] = dateSpan;\n      }\n    }\n\n    return dateSpans;\n  };\n\n  Splitter.prototype._getKeysForEventDefs = function (eventStore) {\n    var _this = this;\n\n    return mapHash(eventStore.defs, function (eventDef) {\n      return _this.getKeysForEventDef(eventDef);\n    });\n  };\n\n  Splitter.prototype._splitEventStore = function (eventStore, defKeys) {\n    var defs = eventStore.defs,\n        instances = eventStore.instances;\n    var splitStores = {};\n\n    for (var defId in defs) {\n      for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n        var key = _a[_i];\n\n        if (!splitStores[key]) {\n          splitStores[key] = createEmptyEventStore();\n        }\n\n        splitStores[key].defs[defId] = defs[defId];\n      }\n    }\n\n    for (var instanceId in instances) {\n      var instance = instances[instanceId];\n\n      for (var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++) {\n        var key = _c[_b];\n\n        if (splitStores[key]) {\n          // must have already been created\n          splitStores[key].instances[instanceId] = instance;\n        }\n      }\n    }\n\n    return splitStores;\n  };\n\n  Splitter.prototype._splitIndividualUi = function (eventUiBases, defKeys) {\n    var splitHashes = {};\n\n    for (var defId in eventUiBases) {\n      if (defId) {\n        // not the '' key\n        for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n          var key = _a[_i];\n\n          if (!splitHashes[key]) {\n            splitHashes[key] = {};\n          }\n\n          splitHashes[key][defId] = eventUiBases[defId];\n        }\n      }\n    }\n\n    return splitHashes;\n  };\n\n  Splitter.prototype._splitInteraction = function (interaction) {\n    var splitStates = {};\n\n    if (interaction) {\n      var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents)); // can't rely on defKeys because event data is mutated\n\n\n      var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n\n      var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n\n      var populate = function (key) {\n        if (!splitStates[key]) {\n          splitStates[key] = {\n            affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,\n            mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,\n            isEvent: interaction.isEvent\n          };\n        }\n      };\n\n      for (var key in affectedStores_1) {\n        populate(key);\n      }\n\n      for (var key in mutatedStores_1) {\n        populate(key);\n      }\n    }\n\n    return splitStates;\n  };\n\n  return Splitter;\n}();\n\nfunction buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n  var baseParts = [];\n\n  if (allUi) {\n    baseParts.push(allUi);\n  }\n\n  if (eventUiForKey) {\n    baseParts.push(eventUiForKey);\n  }\n\n  var stuff = {\n    '': combineEventUis(baseParts)\n  };\n\n  if (individualUi) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(stuff, individualUi);\n  }\n\n  return stuff;\n}\n\nfunction getDateMeta(date, todayRange, nowDate, dateProfile) {\n  return {\n    dow: date.getUTCDay(),\n    isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n  };\n}\n\nfunction getDayClassNames(meta, theme) {\n  var classNames = ['fc-day', \"fc-day-\" + DAY_IDS[meta.dow]];\n\n  if (meta.isDisabled) {\n    classNames.push('fc-day-disabled');\n  } else {\n    if (meta.isToday) {\n      classNames.push('fc-day-today');\n      classNames.push(theme.getClass('today'));\n    }\n\n    if (meta.isPast) {\n      classNames.push('fc-day-past');\n    }\n\n    if (meta.isFuture) {\n      classNames.push('fc-day-future');\n    }\n\n    if (meta.isOther) {\n      classNames.push('fc-day-other');\n    }\n  }\n\n  return classNames;\n}\n\nfunction getSlotClassNames(meta, theme) {\n  var classNames = ['fc-slot', \"fc-slot-\" + DAY_IDS[meta.dow]];\n\n  if (meta.isDisabled) {\n    classNames.push('fc-slot-disabled');\n  } else {\n    if (meta.isToday) {\n      classNames.push('fc-slot-today');\n      classNames.push(theme.getClass('today'));\n    }\n\n    if (meta.isPast) {\n      classNames.push('fc-slot-past');\n    }\n\n    if (meta.isFuture) {\n      classNames.push('fc-slot-future');\n    }\n  }\n\n  return classNames;\n}\n\nfunction buildNavLinkData(date, type) {\n  if (type === void 0) {\n    type = 'day';\n  }\n\n  return JSON.stringify({\n    date: formatDayString(date),\n    type: type\n  });\n}\n\nvar _isRtlScrollbarOnLeft = null;\n\nfunction getIsRtlScrollbarOnLeft() {\n  if (_isRtlScrollbarOnLeft === null) {\n    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n  }\n\n  return _isRtlScrollbarOnLeft;\n}\n\nfunction computeIsRtlScrollbarOnLeft() {\n  var outerEl = document.createElement('div');\n  applyStyle(outerEl, {\n    position: 'absolute',\n    top: -1000,\n    left: 0,\n    border: 0,\n    padding: 0,\n    overflow: 'scroll',\n    direction: 'rtl'\n  });\n  outerEl.innerHTML = '<div></div>';\n  document.body.appendChild(outerEl);\n  var innerEl = outerEl.firstChild;\n  var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n  removeElement(outerEl);\n  return res;\n}\n\nvar _scrollbarWidths;\n\nfunction getScrollbarWidths() {\n  if (!_scrollbarWidths) {\n    _scrollbarWidths = computeScrollbarWidths();\n  }\n\n  return _scrollbarWidths;\n}\n\nfunction computeScrollbarWidths() {\n  var el = document.createElement('div');\n  el.style.overflow = 'scroll';\n  el.style.position = 'absolute';\n  el.style.top = '-9999px';\n  el.style.left = '-9999px';\n  document.body.appendChild(el);\n  var res = computeScrollbarWidthsForEl(el);\n  document.body.removeChild(el);\n  return res;\n} // WARNING: will include border\n\n\nfunction computeScrollbarWidthsForEl(el) {\n  return {\n    x: el.offsetHeight - el.clientHeight,\n    y: el.offsetWidth - el.clientWidth\n  };\n}\n\nfunction computeEdges(el, getPadding) {\n  if (getPadding === void 0) {\n    getPadding = false;\n  }\n\n  var computedStyle = window.getComputedStyle(el);\n  var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n  var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n  var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n  var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n  var badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n\n  var scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n  var scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n  var res = {\n    borderLeft: borderLeft,\n    borderRight: borderRight,\n    borderTop: borderTop,\n    borderBottom: borderBottom,\n    scrollbarBottom: scrollbarBottom,\n    scrollbarLeft: 0,\n    scrollbarRight: 0\n  };\n\n  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') {\n    // is the scrollbar on the left side?\n    res.scrollbarLeft = scrollbarLeftRight;\n  } else {\n    res.scrollbarRight = scrollbarLeftRight;\n  }\n\n  if (getPadding) {\n    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n  }\n\n  return res;\n}\n\nfunction computeInnerRect(el, goWithinPadding, doFromWindowViewport) {\n  if (goWithinPadding === void 0) {\n    goWithinPadding = false;\n  }\n\n  var outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n  var edges = computeEdges(el, goWithinPadding);\n  var res = {\n    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n    right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n    top: outerRect.top + edges.borderTop,\n    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n  };\n\n  if (goWithinPadding) {\n    res.left += edges.paddingLeft;\n    res.right -= edges.paddingRight;\n    res.top += edges.paddingTop;\n    res.bottom -= edges.paddingBottom;\n  }\n\n  return res;\n}\n\nfunction computeRect(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + window.pageXOffset,\n    top: rect.top + window.pageYOffset,\n    right: rect.right + window.pageXOffset,\n    bottom: rect.bottom + window.pageYOffset\n  };\n}\n\nfunction computeClippedClientRect(el) {\n  var clippingParents = getClippingParents(el);\n  var rect = el.getBoundingClientRect();\n\n  for (var _i = 0, clippingParents_1 = clippingParents; _i < clippingParents_1.length; _i++) {\n    var clippingParent = clippingParents_1[_i];\n    var intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n\n    if (intersection) {\n      rect = intersection;\n    } else {\n      return null;\n    }\n  }\n\n  return rect;\n}\n\nfunction computeHeightAndMargins(el) {\n  return el.getBoundingClientRect().height + computeVMargins(el);\n}\n\nfunction computeVMargins(el) {\n  var computed = window.getComputedStyle(el);\n  return parseInt(computed.marginTop, 10) + parseInt(computed.marginBottom, 10);\n} // does not return window\n\n\nfunction getClippingParents(el) {\n  var parents = [];\n\n  while (el instanceof HTMLElement) {\n    // will stop when gets to document or null\n    var computedStyle = window.getComputedStyle(el);\n\n    if (computedStyle.position === 'fixed') {\n      break;\n    }\n\n    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n      parents.push(el);\n    }\n\n    el = el.parentNode;\n  }\n\n  return parents;\n} // given a function that resolves a result asynchronously.\n// the function can either call passed-in success and failure callbacks,\n// or it can return a promise.\n// if you need to pass additional params to func, bind them first.\n\n\nfunction unpromisify(func, success, failure) {\n  // guard against success/failure callbacks being called more than once\n  // and guard against a promise AND callback being used together.\n  var isResolved = false;\n\n  var wrappedSuccess = function () {\n    if (!isResolved) {\n      isResolved = true;\n      success.apply(this, arguments); // eslint-disable-line prefer-rest-params\n    }\n  };\n\n  var wrappedFailure = function () {\n    if (!isResolved) {\n      isResolved = true;\n\n      if (failure) {\n        failure.apply(this, arguments); // eslint-disable-line prefer-rest-params\n      }\n    }\n  };\n\n  var res = func(wrappedSuccess, wrappedFailure);\n\n  if (res && typeof res.then === 'function') {\n    res.then(wrappedSuccess, wrappedFailure);\n  }\n}\n\nvar Emitter = function () {\n  function Emitter() {\n    this.handlers = {};\n    this.thisContext = null;\n  }\n\n  Emitter.prototype.setThisContext = function (thisContext) {\n    this.thisContext = thisContext;\n  };\n\n  Emitter.prototype.setOptions = function (options) {\n    this.options = options;\n  };\n\n  Emitter.prototype.on = function (type, handler) {\n    addToHash(this.handlers, type, handler);\n  };\n\n  Emitter.prototype.off = function (type, handler) {\n    removeFromHash(this.handlers, type, handler);\n  };\n\n  Emitter.prototype.trigger = function (type) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var attachedHandlers = this.handlers[type] || [];\n    var optionHandler = this.options && this.options[type];\n    var handlers = [].concat(optionHandler || [], attachedHandlers);\n\n    for (var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++) {\n      var handler = handlers_1[_a];\n      handler.apply(this.thisContext, args);\n    }\n  };\n\n  Emitter.prototype.hasHandlers = function (type) {\n    return this.handlers[type] && this.handlers[type].length || this.options && this.options[type];\n  };\n\n  return Emitter;\n}();\n\nfunction addToHash(hash, type, handler) {\n  (hash[type] || (hash[type] = [])).push(handler);\n}\n\nfunction removeFromHash(hash, type, handler) {\n  if (handler) {\n    if (hash[type]) {\n      hash[type] = hash[type].filter(function (func) {\n        return func !== handler;\n      });\n    }\n  } else {\n    delete hash[type]; // remove all handler funcs for this type\n  }\n}\n/*\nRecords offset information for a set of elements, relative to an origin element.\nCan record the left/right OR the top/bottom OR both.\nProvides methods for querying the cache by position.\n*/\n\n\nvar PositionCache = function () {\n  function PositionCache(originEl, els, isHorizontal, isVertical) {\n    this.els = els;\n    var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n\n    if (isHorizontal) {\n      this.buildElHorizontals(originClientRect.left);\n    }\n\n    if (isVertical) {\n      this.buildElVerticals(originClientRect.top);\n    }\n  } // Populates the left/right internal coordinate arrays\n\n\n  PositionCache.prototype.buildElHorizontals = function (originClientLeft) {\n    var lefts = [];\n    var rights = [];\n\n    for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n      var el = _a[_i];\n      var rect = el.getBoundingClientRect();\n      lefts.push(rect.left - originClientLeft);\n      rights.push(rect.right - originClientLeft);\n    }\n\n    this.lefts = lefts;\n    this.rights = rights;\n  }; // Populates the top/bottom internal coordinate arrays\n\n\n  PositionCache.prototype.buildElVerticals = function (originClientTop) {\n    var tops = [];\n    var bottoms = [];\n\n    for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n      var el = _a[_i];\n      var rect = el.getBoundingClientRect();\n      tops.push(rect.top - originClientTop);\n      bottoms.push(rect.bottom - originClientTop);\n    }\n\n    this.tops = tops;\n    this.bottoms = bottoms;\n  }; // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n  // If no intersection is made, returns undefined.\n\n\n  PositionCache.prototype.leftToIndex = function (leftPosition) {\n    var _a = this,\n        lefts = _a.lefts,\n        rights = _a.rights;\n\n    var len = lefts.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n        return i;\n      }\n    }\n\n    return undefined; // TODO: better\n  }; // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n  // If no intersection is made, returns undefined.\n\n\n  PositionCache.prototype.topToIndex = function (topPosition) {\n    var _a = this,\n        tops = _a.tops,\n        bottoms = _a.bottoms;\n\n    var len = tops.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n        return i;\n      }\n    }\n\n    return undefined; // TODO: better\n  }; // Gets the width of the element at the given index\n\n\n  PositionCache.prototype.getWidth = function (leftIndex) {\n    return this.rights[leftIndex] - this.lefts[leftIndex];\n  }; // Gets the height of the element at the given index\n\n\n  PositionCache.prototype.getHeight = function (topIndex) {\n    return this.bottoms[topIndex] - this.tops[topIndex];\n  };\n\n  return PositionCache;\n}();\n/* eslint max-classes-per-file: \"off\" */\n\n/*\nAn object for getting/setting scroll-related information for an element.\nInternally, this is done very differently for window versus DOM element,\nso this object serves as a common interface.\n*/\n\n\nvar ScrollController = function () {\n  function ScrollController() {}\n\n  ScrollController.prototype.getMaxScrollTop = function () {\n    return this.getScrollHeight() - this.getClientHeight();\n  };\n\n  ScrollController.prototype.getMaxScrollLeft = function () {\n    return this.getScrollWidth() - this.getClientWidth();\n  };\n\n  ScrollController.prototype.canScrollVertically = function () {\n    return this.getMaxScrollTop() > 0;\n  };\n\n  ScrollController.prototype.canScrollHorizontally = function () {\n    return this.getMaxScrollLeft() > 0;\n  };\n\n  ScrollController.prototype.canScrollUp = function () {\n    return this.getScrollTop() > 0;\n  };\n\n  ScrollController.prototype.canScrollDown = function () {\n    return this.getScrollTop() < this.getMaxScrollTop();\n  };\n\n  ScrollController.prototype.canScrollLeft = function () {\n    return this.getScrollLeft() > 0;\n  };\n\n  ScrollController.prototype.canScrollRight = function () {\n    return this.getScrollLeft() < this.getMaxScrollLeft();\n  };\n\n  return ScrollController;\n}();\n\nvar ElementScrollController = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ElementScrollController, _super);\n\n  function ElementScrollController(el) {\n    var _this = _super.call(this) || this;\n\n    _this.el = el;\n    return _this;\n  }\n\n  ElementScrollController.prototype.getScrollTop = function () {\n    return this.el.scrollTop;\n  };\n\n  ElementScrollController.prototype.getScrollLeft = function () {\n    return this.el.scrollLeft;\n  };\n\n  ElementScrollController.prototype.setScrollTop = function (top) {\n    this.el.scrollTop = top;\n  };\n\n  ElementScrollController.prototype.setScrollLeft = function (left) {\n    this.el.scrollLeft = left;\n  };\n\n  ElementScrollController.prototype.getScrollWidth = function () {\n    return this.el.scrollWidth;\n  };\n\n  ElementScrollController.prototype.getScrollHeight = function () {\n    return this.el.scrollHeight;\n  };\n\n  ElementScrollController.prototype.getClientHeight = function () {\n    return this.el.clientHeight;\n  };\n\n  ElementScrollController.prototype.getClientWidth = function () {\n    return this.el.clientWidth;\n  };\n\n  return ElementScrollController;\n}(ScrollController);\n\nvar WindowScrollController = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(WindowScrollController, _super);\n\n  function WindowScrollController() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  WindowScrollController.prototype.getScrollTop = function () {\n    return window.pageYOffset;\n  };\n\n  WindowScrollController.prototype.getScrollLeft = function () {\n    return window.pageXOffset;\n  };\n\n  WindowScrollController.prototype.setScrollTop = function (n) {\n    window.scroll(window.pageXOffset, n);\n  };\n\n  WindowScrollController.prototype.setScrollLeft = function (n) {\n    window.scroll(n, window.pageYOffset);\n  };\n\n  WindowScrollController.prototype.getScrollWidth = function () {\n    return document.documentElement.scrollWidth;\n  };\n\n  WindowScrollController.prototype.getScrollHeight = function () {\n    return document.documentElement.scrollHeight;\n  };\n\n  WindowScrollController.prototype.getClientHeight = function () {\n    return document.documentElement.clientHeight;\n  };\n\n  WindowScrollController.prototype.getClientWidth = function () {\n    return document.documentElement.clientWidth;\n  };\n\n  return WindowScrollController;\n}(ScrollController);\n\nvar Theme = function () {\n  function Theme(calendarOptions) {\n    if (this.iconOverrideOption) {\n      this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n    }\n  }\n\n  Theme.prototype.setIconOverride = function (iconOverrideHash) {\n    var iconClassesCopy;\n    var buttonName;\n\n    if (typeof iconOverrideHash === 'object' && iconOverrideHash) {\n      // non-null object\n      iconClassesCopy = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.iconClasses);\n\n      for (buttonName in iconOverrideHash) {\n        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n      }\n\n      this.iconClasses = iconClassesCopy;\n    } else if (iconOverrideHash === false) {\n      this.iconClasses = {};\n    }\n  };\n\n  Theme.prototype.applyIconOverridePrefix = function (className) {\n    var prefix = this.iconOverridePrefix;\n\n    if (prefix && className.indexOf(prefix) !== 0) {\n      // if not already present\n      className = prefix + className;\n    }\n\n    return className;\n  };\n\n  Theme.prototype.getClass = function (key) {\n    return this.classes[key] || '';\n  };\n\n  Theme.prototype.getIconClass = function (buttonName, isRtl) {\n    var className;\n\n    if (isRtl && this.rtlIconClasses) {\n      className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n    } else {\n      className = this.iconClasses[buttonName];\n    }\n\n    if (className) {\n      return this.baseIconClass + \" \" + className;\n    }\n\n    return '';\n  };\n\n  Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {\n    var className;\n\n    if (this.iconOverrideCustomButtonOption) {\n      className = customButtonProps[this.iconOverrideCustomButtonOption];\n\n      if (className) {\n        return this.baseIconClass + \" \" + this.applyIconOverridePrefix(className);\n      }\n    }\n\n    return '';\n  };\n\n  return Theme;\n}();\n\nTheme.prototype.classes = {};\nTheme.prototype.iconClasses = {};\nTheme.prototype.baseIconClass = '';\nTheme.prototype.iconOverridePrefix = '';\n\nvar ScrollResponder = function () {\n  function ScrollResponder(execFunc, emitter, scrollTime, scrollTimeReset) {\n    var _this = this;\n\n    this.execFunc = execFunc;\n    this.emitter = emitter;\n    this.scrollTime = scrollTime;\n    this.scrollTimeReset = scrollTimeReset;\n\n    this.handleScrollRequest = function (request) {\n      _this.queuedRequest = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, _this.queuedRequest || {}, request);\n\n      _this.drain();\n    };\n\n    emitter.on('_scrollRequest', this.handleScrollRequest);\n    this.fireInitialScroll();\n  }\n\n  ScrollResponder.prototype.detach = function () {\n    this.emitter.off('_scrollRequest', this.handleScrollRequest);\n  };\n\n  ScrollResponder.prototype.update = function (isDatesNew) {\n    if (isDatesNew && this.scrollTimeReset) {\n      this.fireInitialScroll(); // will drain\n    } else {\n      this.drain();\n    }\n  };\n\n  ScrollResponder.prototype.fireInitialScroll = function () {\n    this.handleScrollRequest({\n      time: this.scrollTime\n    });\n  };\n\n  ScrollResponder.prototype.drain = function () {\n    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n      this.queuedRequest = null;\n    }\n  };\n\n  return ScrollResponder;\n}();\n\nvar ViewContextType = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createContext)({}); // for Components\n\nfunction buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n  return {\n    dateEnv: dateEnv,\n    options: viewOptions,\n    pluginHooks: pluginHooks,\n    emitter: emitter,\n    dispatch: dispatch,\n    getCurrentData: getCurrentData,\n    calendarApi: calendarApi,\n    viewSpec: viewSpec,\n    viewApi: viewApi,\n    dateProfileGenerator: dateProfileGenerator,\n    theme: theme,\n    isRtl: viewOptions.direction === 'rtl',\n    addResizeHandler: function (handler) {\n      emitter.on('_resize', handler);\n    },\n    removeResizeHandler: function (handler) {\n      emitter.off('_resize', handler);\n    },\n    createScrollResponder: function (execFunc) {\n      return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n    },\n    registerInteractiveComponent: registerInteractiveComponent,\n    unregisterInteractiveComponent: unregisterInteractiveComponent\n  };\n}\n/* eslint max-classes-per-file: off */\n\n\nvar PureComponent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(PureComponent, _super);\n\n  function PureComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PureComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    if (this.debug) {\n      // eslint-disable-next-line no-console\n      console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n    }\n\n    return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n  };\n\n  PureComponent.addPropsEquality = addPropsEquality;\n  PureComponent.addStateEquality = addStateEquality;\n  PureComponent.contextType = ViewContextType;\n  return PureComponent;\n}(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Component);\n\nPureComponent.prototype.propEquality = {};\nPureComponent.prototype.stateEquality = {};\n\nvar BaseComponent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(BaseComponent, _super);\n\n  function BaseComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  BaseComponent.contextType = ViewContextType;\n  return BaseComponent;\n}(PureComponent);\n\nfunction addPropsEquality(propEquality) {\n  var hash = Object.create(this.prototype.propEquality);\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(hash, propEquality);\n\n  this.prototype.propEquality = hash;\n}\n\nfunction addStateEquality(stateEquality) {\n  var hash = Object.create(this.prototype.stateEquality);\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(hash, stateEquality);\n\n  this.prototype.stateEquality = hash;\n} // use other one\n\n\nfunction setRef(ref, current) {\n  if (typeof ref === 'function') {\n    ref(current);\n  } else if (ref) {\n    // see https://github.com/facebook/react/issues/13029\n    ref.current = current;\n  }\n}\n/*\nan INTERACTABLE date component\n\nPURPOSES:\n- hook up to fg, fill, and mirror renderers\n- interface for dragging and hits\n*/\n\n\nvar DateComponent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DateComponent, _super);\n\n  function DateComponent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.uid = guid();\n    return _this;\n  } // Hit System\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  DateComponent.prototype.prepareHits = function () {};\n\n  DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    return null; // this should be abstract\n  }; // Pointer Interaction Utils\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  DateComponent.prototype.isValidSegDownEl = function (el) {\n    return !this.props.eventDrag && // HACK\n    !this.props.eventResize && // HACK\n    !elementClosest(el, '.fc-event-mirror');\n  };\n\n  DateComponent.prototype.isValidDateDownEl = function (el) {\n    return !elementClosest(el, '.fc-event:not(.fc-bg-event)') && !elementClosest(el, '.fc-more-link') && // a \"more..\" link\n    !elementClosest(el, 'a[data-navlink]') && // a clickable nav link\n    !elementClosest(el, '.fc-popover'); // hack\n  };\n\n  return DateComponent;\n}(BaseComponent); // TODO: easier way to add new hooks? need to update a million things\n\n\nfunction createPlugin(input) {\n  return {\n    id: guid(),\n    deps: input.deps || [],\n    reducers: input.reducers || [],\n    isLoadingFuncs: input.isLoadingFuncs || [],\n    contextInit: [].concat(input.contextInit || []),\n    eventRefiners: input.eventRefiners || {},\n    eventDefMemberAdders: input.eventDefMemberAdders || [],\n    eventSourceRefiners: input.eventSourceRefiners || {},\n    isDraggableTransformers: input.isDraggableTransformers || [],\n    eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n    eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n    dateSelectionTransformers: input.dateSelectionTransformers || [],\n    datePointTransforms: input.datePointTransforms || [],\n    dateSpanTransforms: input.dateSpanTransforms || [],\n    views: input.views || {},\n    viewPropsTransformers: input.viewPropsTransformers || [],\n    isPropsValid: input.isPropsValid || null,\n    externalDefTransforms: input.externalDefTransforms || [],\n    viewContainerAppends: input.viewContainerAppends || [],\n    eventDropTransformers: input.eventDropTransformers || [],\n    componentInteractions: input.componentInteractions || [],\n    calendarInteractions: input.calendarInteractions || [],\n    themeClasses: input.themeClasses || {},\n    eventSourceDefs: input.eventSourceDefs || [],\n    cmdFormatter: input.cmdFormatter,\n    recurringTypes: input.recurringTypes || [],\n    namedTimeZonedImpl: input.namedTimeZonedImpl,\n    initialView: input.initialView || '',\n    elementDraggingImpl: input.elementDraggingImpl,\n    optionChangeHandlers: input.optionChangeHandlers || {},\n    scrollGridImpl: input.scrollGridImpl || null,\n    contentTypeHandlers: input.contentTypeHandlers || {},\n    listenerRefiners: input.listenerRefiners || {},\n    optionRefiners: input.optionRefiners || {},\n    propSetHandlers: input.propSetHandlers || {}\n  };\n}\n\nfunction buildPluginHooks(pluginDefs, globalDefs) {\n  var isAdded = {};\n  var hooks = {\n    reducers: [],\n    isLoadingFuncs: [],\n    contextInit: [],\n    eventRefiners: {},\n    eventDefMemberAdders: [],\n    eventSourceRefiners: {},\n    isDraggableTransformers: [],\n    eventDragMutationMassagers: [],\n    eventDefMutationAppliers: [],\n    dateSelectionTransformers: [],\n    datePointTransforms: [],\n    dateSpanTransforms: [],\n    views: {},\n    viewPropsTransformers: [],\n    isPropsValid: null,\n    externalDefTransforms: [],\n    viewContainerAppends: [],\n    eventDropTransformers: [],\n    componentInteractions: [],\n    calendarInteractions: [],\n    themeClasses: {},\n    eventSourceDefs: [],\n    cmdFormatter: null,\n    recurringTypes: [],\n    namedTimeZonedImpl: null,\n    initialView: '',\n    elementDraggingImpl: null,\n    optionChangeHandlers: {},\n    scrollGridImpl: null,\n    contentTypeHandlers: {},\n    listenerRefiners: {},\n    optionRefiners: {},\n    propSetHandlers: {}\n  };\n\n  function addDefs(defs) {\n    for (var _i = 0, defs_1 = defs; _i < defs_1.length; _i++) {\n      var def = defs_1[_i];\n\n      if (!isAdded[def.id]) {\n        isAdded[def.id] = true;\n        addDefs(def.deps);\n        hooks = combineHooks(hooks, def);\n      }\n    }\n  }\n\n  if (pluginDefs) {\n    addDefs(pluginDefs);\n  }\n\n  addDefs(globalDefs);\n  return hooks;\n}\n\nfunction buildBuildPluginHooks() {\n  var currentOverrideDefs = [];\n  var currentGlobalDefs = [];\n  var currentHooks;\n  return function (overrideDefs, globalDefs) {\n    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {\n      currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n    }\n\n    currentOverrideDefs = overrideDefs;\n    currentGlobalDefs = globalDefs;\n    return currentHooks;\n  };\n}\n\nfunction combineHooks(hooks0, hooks1) {\n  return {\n    reducers: hooks0.reducers.concat(hooks1.reducers),\n    isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n    contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n    eventRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.eventRefiners), hooks1.eventRefiners),\n    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n    eventSourceRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n    views: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.views), hooks1.views),\n    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n    themeClasses: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.themeClasses), hooks1.themeClasses),\n    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n    initialView: hooks0.initialView || hooks1.initialView,\n    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n    optionChangeHandlers: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n    contentTypeHandlers: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),\n    listenerRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n    optionRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.optionRefiners), hooks1.optionRefiners),\n    propSetHandlers: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n  };\n}\n\nvar StandardTheme = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(StandardTheme, _super);\n\n  function StandardTheme() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return StandardTheme;\n}(Theme);\n\nStandardTheme.prototype.classes = {\n  root: 'fc-theme-standard',\n  tableCellShaded: 'fc-cell-shaded',\n  buttonGroup: 'fc-button-group',\n  button: 'fc-button fc-button-primary',\n  buttonActive: 'fc-button-active'\n};\nStandardTheme.prototype.baseIconClass = 'fc-icon';\nStandardTheme.prototype.iconClasses = {\n  close: 'fc-icon-x',\n  prev: 'fc-icon-chevron-left',\n  next: 'fc-icon-chevron-right',\n  prevYear: 'fc-icon-chevrons-left',\n  nextYear: 'fc-icon-chevrons-right'\n};\nStandardTheme.prototype.rtlIconClasses = {\n  prev: 'fc-icon-chevron-right',\n  next: 'fc-icon-chevron-left',\n  prevYear: 'fc-icon-chevrons-right',\n  nextYear: 'fc-icon-chevrons-left'\n};\nStandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly\n\nStandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\nStandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\n\nfunction compileViewDefs(defaultConfigs, overrideConfigs) {\n  var hash = {};\n  var viewType;\n\n  for (viewType in defaultConfigs) {\n    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  for (viewType in overrideConfigs) {\n    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  return hash;\n}\n\nfunction ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n  if (hash[viewType]) {\n    return hash[viewType];\n  }\n\n  var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n\n  if (viewDef) {\n    hash[viewType] = viewDef;\n  }\n\n  return viewDef;\n}\n\nfunction buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n  var defaultConfig = defaultConfigs[viewType];\n  var overrideConfig = overrideConfigs[viewType];\n\n  var queryProp = function (name) {\n    return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n  };\n\n  var theComponent = queryProp('component');\n  var superType = queryProp('superType');\n  var superDef = null;\n\n  if (superType) {\n    if (superType === viewType) {\n      throw new Error('Can\\'t have a custom view type that references itself');\n    }\n\n    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  if (!theComponent && superDef) {\n    theComponent = superDef.component;\n  }\n\n  if (!theComponent) {\n    return null; // don't throw a warning, might be settings for a single-unit view\n  }\n\n  return {\n    type: viewType,\n    component: theComponent,\n    defaults: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n    overrides: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n  };\n}\n/* eslint max-classes-per-file: off */\n// NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???\n\n\nvar RenderHook = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(RenderHook, _super);\n\n  function RenderHook() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n\n    _this.handleRootEl = function (el) {\n      setRef(_this.rootElRef, el);\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, el);\n      }\n    };\n\n    return _this;\n  }\n\n  RenderHook.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var hookProps = props.hookProps;\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(MountHook, {\n      hookProps: hookProps,\n      didMount: props.didMount,\n      willUnmount: props.willUnmount,\n      elRef: this.handleRootEl\n    }, function (rootElRef) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ContentHook, {\n        hookProps: hookProps,\n        content: props.content,\n        defaultContent: props.defaultContent,\n        backupElRef: _this.rootElRef\n      }, function (innerElRef, innerContent) {\n        return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent);\n      });\n    });\n  };\n\n  return RenderHook;\n}(BaseComponent); // TODO: rename to be about function, not default. use in above type\n// for forcing rerender of components that use the ContentHook\n\n\nvar CustomContentRenderContext = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createContext)(0);\n\nfunction ContentHook(props) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(CustomContentRenderContext.Consumer, null, function (renderId) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ContentHookInner, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      renderId: renderId\n    }, props));\n  });\n}\n\nvar ContentHookInner = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ContentHookInner, _super);\n\n  function ContentHookInner() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.innerElRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    return _this;\n  }\n\n  ContentHookInner.prototype.render = function () {\n    return this.props.children(this.innerElRef, this.renderInnerContent());\n  };\n\n  ContentHookInner.prototype.componentDidMount = function () {\n    this.updateCustomContent();\n  };\n\n  ContentHookInner.prototype.componentDidUpdate = function () {\n    this.updateCustomContent();\n  };\n\n  ContentHookInner.prototype.componentWillUnmount = function () {\n    if (this.customContentInfo && this.customContentInfo.destroy) {\n      this.customContentInfo.destroy();\n    }\n  };\n\n  ContentHookInner.prototype.renderInnerContent = function () {\n    var customContentInfo = this.customContentInfo; // only populated if using non-[p]react node(s)\n\n    var innerContent = this.getInnerContent();\n    var meta = this.getContentMeta(innerContent); // initial run, or content-type changing? (from vue -> react for example)\n\n    if (!customContentInfo || customContentInfo.contentKey !== meta.contentKey) {\n      // clearing old value\n      if (customContentInfo) {\n        if (customContentInfo.destroy) {\n          customContentInfo.destroy();\n        }\n\n        customContentInfo = this.customContentInfo = null;\n      } // assigning new value\n\n\n      if (meta.contentKey) {\n        customContentInfo = this.customContentInfo = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          contentKey: meta.contentKey,\n          contentVal: innerContent[meta.contentKey]\n        }, meta.buildLifecycleFuncs());\n      } // updating\n\n    } else if (customContentInfo) {\n      customContentInfo.contentVal = innerContent[meta.contentKey];\n    }\n\n    return customContentInfo ? [] // signal that something was specified\n    : innerContent; // assume a [p]react vdom node. use it\n  };\n\n  ContentHookInner.prototype.getInnerContent = function () {\n    var props = this.props;\n    var innerContent = normalizeContent(props.content, props.hookProps);\n\n    if (innerContent === undefined) {\n      // use the default\n      innerContent = normalizeContent(props.defaultContent, props.hookProps);\n    }\n\n    return innerContent == null ? null : innerContent; // convert undefined to null (better for React)\n  };\n\n  ContentHookInner.prototype.getContentMeta = function (innerContent) {\n    var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;\n    var contentKey = '';\n    var buildLifecycleFuncs = null;\n\n    if (innerContent) {\n      // allowed to be null, for convenience to caller\n      for (var searchKey in contentTypeHandlers) {\n        if (innerContent[searchKey] !== undefined) {\n          contentKey = searchKey;\n          buildLifecycleFuncs = contentTypeHandlers[searchKey];\n          break;\n        }\n      }\n    }\n\n    return {\n      contentKey: contentKey,\n      buildLifecycleFuncs: buildLifecycleFuncs\n    };\n  };\n\n  ContentHookInner.prototype.updateCustomContent = function () {\n    if (this.customContentInfo) {\n      // for non-[p]react\n      this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, // the element to render into\n      this.customContentInfo.contentVal);\n    }\n  };\n\n  return ContentHookInner;\n}(BaseComponent);\n\nvar MountHook = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(MountHook, _super);\n\n  function MountHook() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, rootEl);\n      }\n    };\n\n    return _this;\n  }\n\n  MountHook.prototype.render = function () {\n    return this.props.children(this.handleRootEl);\n  };\n\n  MountHook.prototype.componentDidMount = function () {\n    var callback = this.props.didMount;\n\n    if (callback) {\n      callback((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.props.hookProps), {\n        el: this.rootEl\n      }));\n    }\n  };\n\n  MountHook.prototype.componentWillUnmount = function () {\n    var callback = this.props.willUnmount;\n\n    if (callback) {\n      callback((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.props.hookProps), {\n        el: this.rootEl\n      }));\n    }\n  };\n\n  return MountHook;\n}(BaseComponent);\n\nfunction buildClassNameNormalizer() {\n  var currentGenerator;\n  var currentHookProps;\n  var currentClassNames = [];\n  return function (generator, hookProps) {\n    if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {\n      currentGenerator = generator;\n      currentHookProps = hookProps;\n      currentClassNames = normalizeClassNames(generator, hookProps);\n    }\n\n    return currentClassNames;\n  };\n}\n\nfunction normalizeClassNames(classNames, hookProps) {\n  if (typeof classNames === 'function') {\n    classNames = classNames(hookProps);\n  }\n\n  return parseClassNames(classNames);\n}\n\nfunction normalizeContent(input, hookProps) {\n  if (typeof input === 'function') {\n    return input(hookProps, _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement); // give the function the vdom-creation func\n  }\n\n  return input;\n}\n\nvar ViewRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ViewRoot, _super);\n\n  function ViewRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.normalizeClassNames = buildClassNameNormalizer();\n    return _this;\n  }\n\n  ViewRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = {\n      view: context.viewApi\n    };\n    var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(MountHook, {\n      hookProps: hookProps,\n      didMount: options.viewDidMount,\n      willUnmount: options.viewWillUnmount,\n      elRef: props.elRef\n    }, function (rootElRef) {\n      return props.children(rootElRef, [\"fc-\" + props.viewSpec.type + \"-view\", 'fc-view'].concat(customClassNames));\n    });\n  };\n\n  return ViewRoot;\n}(BaseComponent);\n\nfunction parseViewConfigs(inputs) {\n  return mapHash(inputs, parseViewConfig);\n}\n\nfunction parseViewConfig(input) {\n  var rawOptions = typeof input === 'function' ? {\n    component: input\n  } : input;\n  var component = rawOptions.component;\n\n  if (rawOptions.content) {\n    component = createViewHookComponent(rawOptions); // TODO: remove content/classNames/didMount/etc from options?\n  }\n\n  return {\n    superType: rawOptions.type,\n    component: component,\n    rawOptions: rawOptions\n  };\n}\n\nfunction createViewHookComponent(options) {\n  return function (viewProps) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Consumer, null, function (context) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewRoot, {\n        viewSpec: context.viewSpec\n      }, function (viewElRef, viewClassNames) {\n        var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, viewProps), {\n          nextDayThreshold: context.options.nextDayThreshold\n        });\n\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n          hookProps: hookProps,\n          classNames: options.classNames,\n          content: options.content,\n          didMount: options.didMount,\n          willUnmount: options.willUnmount,\n          elRef: viewElRef\n        }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n          return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: viewClassNames.concat(customClassNames).join(' '),\n            ref: rootElRef\n          }, innerContent);\n        });\n      });\n    });\n  };\n}\n\nfunction buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n  var defaultConfigs = parseViewConfigs(defaultInputs);\n  var overrideConfigs = parseViewConfigs(optionOverrides.views);\n  var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n  return mapHash(viewDefs, function (viewDef) {\n    return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults);\n  });\n}\n\nfunction buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n  var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n  var duration = null;\n  var durationUnit = '';\n  var singleUnit = '';\n  var singleUnitOverrides = {};\n\n  if (durationInput) {\n    duration = createDurationCached(durationInput);\n\n    if (duration) {\n      // valid?\n      var denom = greatestDurationDenominator(duration);\n      durationUnit = denom.unit;\n\n      if (denom.value === 1) {\n        singleUnit = durationUnit;\n        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n      }\n    }\n  }\n\n  var queryButtonText = function (optionsSubset) {\n    var buttonTextMap = optionsSubset.buttonText || {};\n    var buttonTextKey = viewDef.defaults.buttonTextKey;\n\n    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n      return buttonTextMap[buttonTextKey];\n    }\n\n    if (buttonTextMap[viewDef.type] != null) {\n      return buttonTextMap[viewDef.type];\n    }\n\n    if (buttonTextMap[singleUnit] != null) {\n      return buttonTextMap[singleUnit];\n    }\n\n    return null;\n  };\n\n  return {\n    type: viewDef.type,\n    component: viewDef.component,\n    duration: duration,\n    durationUnit: durationUnit,\n    singleUnit: singleUnit,\n    optionDefaults: viewDef.defaults,\n    optionOverrides: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, singleUnitOverrides), viewDef.overrides),\n    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n    viewDef.overrides.buttonText,\n    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type // fall back to given view name\n\n  };\n} // hack to get memoization working\n\n\nvar durationInputMap = {};\n\nfunction createDurationCached(durationInput) {\n  var json = JSON.stringify(durationInput);\n  var res = durationInputMap[json];\n\n  if (res === undefined) {\n    res = createDuration(durationInput);\n    durationInputMap[json] = res;\n  }\n\n  return res;\n}\n\nvar DateProfileGenerator = function () {\n  function DateProfileGenerator(props) {\n    this.props = props;\n    this.nowDate = getNow(props.nowInput, props.dateEnv);\n    this.initHiddenDays();\n  }\n  /* Date Range Computation\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n\n\n  DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate, forceToValid) {\n    var dateEnv = this.props.dateEnv;\n    var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n    currentDateProfile.dateIncrement);\n    return this.build(prevDate, -1, forceToValid);\n  }; // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n\n\n  DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate, forceToValid) {\n    var dateEnv = this.props.dateEnv;\n    var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n    currentDateProfile.dateIncrement);\n    return this.build(nextDate, 1, forceToValid);\n  }; // Builds a structure holding dates/ranges for rendering around the given date.\n  // Optional direction param indicates whether the date is being incremented/decremented\n  // from its previous value. decremented = -1, incremented = 1 (default).\n\n\n  DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {\n    if (forceToValid === void 0) {\n      forceToValid = true;\n    }\n\n    var props = this.props;\n    var validRange;\n    var currentInfo;\n    var isRangeAllDay;\n    var renderRange;\n    var activeRange;\n    var isValid;\n    validRange = this.buildValidRange();\n    validRange = this.trimHiddenDays(validRange);\n\n    if (forceToValid) {\n      currentDate = constrainMarkerToRange(currentDate, validRange);\n    }\n\n    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n    renderRange = this.trimHiddenDays(renderRange);\n    activeRange = renderRange;\n\n    if (!props.showNonCurrentDates) {\n      activeRange = intersectRanges(activeRange, currentInfo.range);\n    }\n\n    activeRange = this.adjustActiveRange(activeRange);\n    activeRange = intersectRanges(activeRange, validRange); // might return null\n    // it's invalid if the originally requested date is not contained,\n    // or if the range is completely outside of the valid range.\n\n    isValid = rangesIntersect(currentInfo.range, validRange);\n    return {\n      // constraint for where prev/next operations can go and where events can be dragged/resized to.\n      // an object with optional start and end properties.\n      validRange: validRange,\n      // range the view is formally responsible for.\n      // for example, a month view might have 1st-31st, excluding padded dates\n      currentRange: currentInfo.range,\n      // name of largest unit being displayed, like \"month\" or \"week\"\n      currentRangeUnit: currentInfo.unit,\n      isRangeAllDay: isRangeAllDay,\n      // dates that display events and accept drag-n-drop\n      // will be `null` if no dates accept events\n      activeRange: activeRange,\n      // date range with a rendered skeleton\n      // includes not-active days that need some sort of DOM\n      renderRange: renderRange,\n      // Duration object that denotes the first visible time of any given day\n      slotMinTime: props.slotMinTime,\n      // Duration object that denotes the exclusive visible end time of any given day\n      slotMaxTime: props.slotMaxTime,\n      isValid: isValid,\n      // how far the current date will move for a prev/next operation\n      dateIncrement: this.buildDateIncrement(currentInfo.duration) // pass a fallback (might be null) ^\n\n    };\n  }; // Builds an object with optional start/end properties.\n  // Indicates the minimum/maximum dates to display.\n  // not responsible for trimming hidden days.\n\n\n  DateProfileGenerator.prototype.buildValidRange = function () {\n    var input = this.props.validRangeInput;\n    var simpleInput = typeof input === 'function' ? input.call(this.props.calendarApi, this.nowDate) : input;\n    return this.refineRange(simpleInput) || {\n      start: null,\n      end: null\n    }; // completely open-ended\n  }; // Builds a structure with info about the \"current\" range, the range that is\n  // highlighted as being the current month for example.\n  // See build() for a description of `direction`.\n  // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n\n\n  DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {\n    var props = this.props;\n    var duration = null;\n    var unit = null;\n    var range = null;\n    var dayCount;\n\n    if (props.duration) {\n      duration = props.duration;\n      unit = props.durationUnit;\n      range = this.buildRangeFromDuration(date, direction, duration, unit);\n    } else if (dayCount = this.props.dayCount) {\n      unit = 'day';\n      range = this.buildRangeFromDayCount(date, direction, dayCount);\n    } else if (range = this.buildCustomVisibleRange(date)) {\n      unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n    } else {\n      duration = this.getFallbackDuration();\n      unit = greatestDurationDenominator(duration).unit;\n      range = this.buildRangeFromDuration(date, direction, duration, unit);\n    }\n\n    return {\n      duration: duration,\n      unit: unit,\n      range: range\n    };\n  };\n\n  DateProfileGenerator.prototype.getFallbackDuration = function () {\n    return createDuration({\n      day: 1\n    });\n  }; // Returns a new activeRange to have time values (un-ambiguate)\n  // slotMinTime or slotMaxTime causes the range to expand.\n\n\n  DateProfileGenerator.prototype.adjustActiveRange = function (range) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        usesMinMaxTime = _a.usesMinMaxTime,\n        slotMinTime = _a.slotMinTime,\n        slotMaxTime = _a.slotMaxTime;\n    var start = range.start,\n        end = range.end;\n\n    if (usesMinMaxTime) {\n      // expand active range if slotMinTime is negative (why not when positive?)\n      if (asRoughDays(slotMinTime) < 0) {\n        start = startOfDay(start); // necessary?\n\n        start = dateEnv.add(start, slotMinTime);\n      } // expand active range if slotMaxTime is beyond one day (why not when negative?)\n\n\n      if (asRoughDays(slotMaxTime) > 1) {\n        end = startOfDay(end); // necessary?\n\n        end = addDays(end, -1);\n        end = dateEnv.add(end, slotMaxTime);\n      }\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  }; // Builds the \"current\" range when it is specified as an explicit duration.\n  // `unit` is the already-computed greatestDurationDenominator unit of duration.\n\n\n  DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        dateAlignment = _a.dateAlignment;\n    var start;\n    var end;\n    var res; // compute what the alignment should be\n\n    if (!dateAlignment) {\n      var dateIncrement = this.props.dateIncrement;\n\n      if (dateIncrement) {\n        // use the smaller of the two units\n        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n          dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n        } else {\n          dateAlignment = unit;\n        }\n      } else {\n        dateAlignment = unit;\n      }\n    } // if the view displays a single day or smaller\n\n\n    if (asRoughDays(duration) <= 1) {\n      if (this.isHiddenDay(start)) {\n        start = this.skipHiddenDays(start, direction);\n        start = startOfDay(start);\n      }\n    }\n\n    function computeRes() {\n      start = dateEnv.startOf(date, dateAlignment);\n      end = dateEnv.add(start, duration);\n      res = {\n        start: start,\n        end: end\n      };\n    }\n\n    computeRes(); // if range is completely enveloped by hidden days, go past the hidden days\n\n    if (!this.trimHiddenDays(res)) {\n      date = this.skipHiddenDays(date, direction);\n      computeRes();\n    }\n\n    return res;\n  }; // Builds the \"current\" range when a dayCount is specified.\n\n\n  DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        dateAlignment = _a.dateAlignment;\n    var runningCount = 0;\n    var start = date;\n    var end;\n\n    if (dateAlignment) {\n      start = dateEnv.startOf(start, dateAlignment);\n    }\n\n    start = startOfDay(start);\n    start = this.skipHiddenDays(start, direction);\n    end = start;\n\n    do {\n      end = addDays(end, 1);\n\n      if (!this.isHiddenDay(end)) {\n        runningCount += 1;\n      }\n    } while (runningCount < dayCount);\n\n    return {\n      start: start,\n      end: end\n    };\n  }; // Builds a normalized range object for the \"visible\" range,\n  // which is a way to define the currentRange and activeRange at the same time.\n\n\n  DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {\n    var props = this.props;\n    var input = props.visibleRangeInput;\n    var simpleInput = typeof input === 'function' ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n    var range = this.refineRange(simpleInput);\n\n    if (range && (range.start == null || range.end == null)) {\n      return null;\n    }\n\n    return range;\n  }; // Computes the range that will represent the element/cells for *rendering*,\n  // but which may have voided days/times.\n  // not responsible for trimming hidden days.\n\n\n  DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    return currentRange;\n  }; // Compute the duration value that should be added/substracted to the current date\n  // when a prev/next operation happens.\n\n\n  DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {\n    var dateIncrement = this.props.dateIncrement;\n    var customAlignment;\n\n    if (dateIncrement) {\n      return dateIncrement;\n    }\n\n    if (customAlignment = this.props.dateAlignment) {\n      return createDuration(1, customAlignment);\n    }\n\n    if (fallback) {\n      return fallback;\n    }\n\n    return createDuration({\n      days: 1\n    });\n  };\n\n  DateProfileGenerator.prototype.refineRange = function (rangeInput) {\n    if (rangeInput) {\n      var range = parseRange(rangeInput, this.props.dateEnv);\n\n      if (range) {\n        range = computeVisibleDayRange(range);\n      }\n\n      return range;\n    }\n\n    return null;\n  };\n  /* Hidden Days\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Initializes internal variables related to calculating hidden days-of-week\n\n\n  DateProfileGenerator.prototype.initHiddenDays = function () {\n    var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n\n    var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n\n    var dayCnt = 0;\n    var i;\n\n    if (this.props.weekends === false) {\n      hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n    }\n\n    for (i = 0; i < 7; i += 1) {\n      if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n        dayCnt += 1;\n      }\n    }\n\n    if (!dayCnt) {\n      throw new Error('invalid hiddenDays'); // all days were hidden? bad.\n    }\n\n    this.isHiddenDayHash = isHiddenDayHash;\n  }; // Remove days from the beginning and end of the range that are computed as hidden.\n  // If the whole range is trimmed off, returns null\n\n\n  DateProfileGenerator.prototype.trimHiddenDays = function (range) {\n    var start = range.start,\n        end = range.end;\n\n    if (start) {\n      start = this.skipHiddenDays(start);\n    }\n\n    if (end) {\n      end = this.skipHiddenDays(end, -1, true);\n    }\n\n    if (start == null || end == null || start < end) {\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    return null;\n  }; // Is the current day hidden?\n  // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n\n\n  DateProfileGenerator.prototype.isHiddenDay = function (day) {\n    if (day instanceof Date) {\n      day = day.getUTCDay();\n    }\n\n    return this.isHiddenDayHash[day];\n  }; // Incrementing the current day until it is no longer a hidden day, returning a copy.\n  // DOES NOT CONSIDER validRange!\n  // If the initial value of `date` is not a hidden day, don't do anything.\n  // Pass `isExclusive` as `true` if you are dealing with an end date.\n  // `inc` defaults to `1` (increment one day forward each time)\n\n\n  DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {\n    if (inc === void 0) {\n      inc = 1;\n    }\n\n    if (isExclusive === void 0) {\n      isExclusive = false;\n    }\n\n    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {\n      date = addDays(date, inc);\n    }\n\n    return date;\n  };\n\n  return DateProfileGenerator;\n}();\n\nfunction reduceViewType(viewType, action) {\n  switch (action.type) {\n    case 'CHANGE_VIEW_TYPE':\n      viewType = action.viewType;\n  }\n\n  return viewType;\n}\n\nfunction reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n  var _a;\n\n  switch (action.type) {\n    case 'SET_OPTION':\n      return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));\n\n    default:\n      return dynamicOptionOverrides;\n  }\n}\n\nfunction reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n  var dp;\n\n  switch (action.type) {\n    case 'CHANGE_VIEW_TYPE':\n      return dateProfileGenerator.build(action.dateMarker || currentDate);\n\n    case 'CHANGE_DATE':\n      return dateProfileGenerator.build(action.dateMarker);\n\n    case 'PREV':\n      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n\n      if (dp.isValid) {\n        return dp;\n      }\n\n      break;\n\n    case 'NEXT':\n      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n\n      if (dp.isValid) {\n        return dp;\n      }\n\n      break;\n  }\n\n  return currentDateProfile;\n}\n\nfunction initEventSources(calendarOptions, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null;\n  return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n}\n\nfunction reduceEventSources(eventSources, action, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n\n  switch (action.type) {\n    case 'ADD_EVENT_SOURCES':\n      // already parsed\n      return addSources(eventSources, action.sources, activeRange, context);\n\n    case 'REMOVE_EVENT_SOURCE':\n      return removeSource(eventSources, action.sourceId);\n\n    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n\n    case 'NEXT':\n    case 'CHANGE_DATE':\n    case 'CHANGE_VIEW_TYPE':\n      if (dateProfile) {\n        return fetchDirtySources(eventSources, activeRange, context);\n      }\n\n      return eventSources;\n\n    case 'FETCH_EVENT_SOURCES':\n      return fetchSourcesByIds(eventSources, action.sourceIds ? // why no type?\n      arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n\n    case 'RECEIVE_EVENTS':\n    case 'RECEIVE_EVENT_ERROR':\n      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n\n    case 'REMOVE_ALL_EVENT_SOURCES':\n      return {};\n\n    default:\n      return eventSources;\n  }\n}\n\nfunction reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n\n  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n}\n\nfunction computeEventSourcesLoading(eventSources) {\n  for (var sourceId in eventSources) {\n    if (eventSources[sourceId].isFetching) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction addSources(eventSourceHash, sources, fetchRange, context) {\n  var hash = {};\n\n  for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {\n    var source = sources_1[_i];\n    hash[source.sourceId] = source;\n  }\n\n  if (fetchRange) {\n    hash = fetchDirtySources(hash, fetchRange, context);\n  }\n\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventSourceHash), hash);\n}\n\nfunction removeSource(eventSourceHash, sourceId) {\n  return filterHash(eventSourceHash, function (eventSource) {\n    return eventSource.sourceId !== sourceId;\n  });\n}\n\nfunction fetchDirtySources(sourceHash, fetchRange, context) {\n  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) {\n    return isSourceDirty(eventSource, fetchRange, context);\n  }), fetchRange, false, context);\n}\n\nfunction isSourceDirty(eventSource, fetchRange, context) {\n  if (!doesSourceNeedRange(eventSource, context)) {\n    return !eventSource.latestFetchId;\n  }\n\n  return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n  fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n}\n\nfunction fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n  var nextSources = {};\n\n  for (var sourceId in prevSources) {\n    var source = prevSources[sourceId];\n\n    if (sourceIdHash[sourceId]) {\n      nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n    } else {\n      nextSources[sourceId] = source;\n    }\n  }\n\n  return nextSources;\n}\n\nfunction fetchSource(eventSource, fetchRange, isRefetch, context) {\n  var options = context.options,\n      calendarApi = context.calendarApi;\n  var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n  var fetchId = guid();\n  sourceDef.fetch({\n    eventSource: eventSource,\n    range: fetchRange,\n    isRefetch: isRefetch,\n    context: context\n  }, function (res) {\n    var rawEvents = res.rawEvents;\n\n    if (options.eventSourceSuccess) {\n      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n    }\n\n    if (eventSource.success) {\n      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n    }\n\n    context.dispatch({\n      type: 'RECEIVE_EVENTS',\n      sourceId: eventSource.sourceId,\n      fetchId: fetchId,\n      fetchRange: fetchRange,\n      rawEvents: rawEvents\n    });\n  }, function (error) {\n    console.warn(error.message, error);\n\n    if (options.eventSourceFailure) {\n      options.eventSourceFailure.call(calendarApi, error);\n    }\n\n    if (eventSource.failure) {\n      eventSource.failure(error);\n    }\n\n    context.dispatch({\n      type: 'RECEIVE_EVENT_ERROR',\n      sourceId: eventSource.sourceId,\n      fetchId: fetchId,\n      fetchRange: fetchRange,\n      error: error\n    });\n  });\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventSource), {\n    isFetching: true,\n    latestFetchId: fetchId\n  });\n}\n\nfunction receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n  var _a;\n\n  var eventSource = sourceHash[sourceId];\n\n  if (eventSource && // not already removed\n  fetchId === eventSource.latestFetchId) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, sourceHash), (_a = {}, _a[sourceId] = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventSource), {\n      isFetching: false,\n      fetchRange: fetchRange\n    }), _a));\n  }\n\n  return sourceHash;\n}\n\nfunction excludeStaticSources(eventSources, context) {\n  return filterHash(eventSources, function (eventSource) {\n    return doesSourceNeedRange(eventSource, context);\n  });\n}\n\nfunction parseInitialSources(rawOptions, context) {\n  var refiners = buildEventSourceRefiners(context);\n  var rawSources = [].concat(rawOptions.eventSources || []);\n  var sources = []; // parsed\n\n  if (rawOptions.initialEvents) {\n    rawSources.unshift(rawOptions.initialEvents);\n  }\n\n  if (rawOptions.events) {\n    rawSources.unshift(rawOptions.events);\n  }\n\n  for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {\n    var rawSource = rawSources_1[_i];\n    var source = parseEventSource(rawSource, context, refiners);\n\n    if (source) {\n      sources.push(source);\n    }\n  }\n\n  return sources;\n}\n\nfunction doesSourceNeedRange(eventSource, context) {\n  var defs = context.pluginHooks.eventSourceDefs;\n  return !defs[eventSource.sourceDefId].ignoreRange;\n}\n\nfunction reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n  switch (action.type) {\n    case 'RECEIVE_EVENTS':\n      // raw\n      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n\n    case 'ADD_EVENTS':\n      // already parsed, but not expanded\n      return addEvent(eventStore, action.eventStore, // new ones\n      dateProfile ? dateProfile.activeRange : null, context);\n\n    case 'RESET_EVENTS':\n      return action.eventStore;\n\n    case 'MERGE_EVENTS':\n      // already parsed and expanded\n      return mergeEventStores(eventStore, action.eventStore);\n\n    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n\n    case 'NEXT':\n    case 'CHANGE_DATE':\n    case 'CHANGE_VIEW_TYPE':\n      if (dateProfile) {\n        return expandRecurring(eventStore, dateProfile.activeRange, context);\n      }\n\n      return eventStore;\n\n    case 'REMOVE_EVENTS':\n      return excludeSubEventStore(eventStore, action.eventStore);\n\n    case 'REMOVE_EVENT_SOURCE':\n      return excludeEventsBySourceId(eventStore, action.sourceId);\n\n    case 'REMOVE_ALL_EVENT_SOURCES':\n      return filterEventStoreDefs(eventStore, function (eventDef) {\n        return !eventDef.sourceId // only keep events with no source id\n        ;\n      });\n\n    case 'REMOVE_ALL_EVENTS':\n      return createEmptyEventStore();\n\n    default:\n      return eventStore;\n  }\n}\n\nfunction receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n  if (eventSource && // not already removed\n  fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n  ) {\n    var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n\n    if (fetchRange) {\n      subset = expandRecurring(subset, fetchRange, context);\n    }\n\n    return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n  }\n\n  return eventStore;\n}\n\nfunction transformRawEvents(rawEvents, eventSource, context) {\n  var calEachTransform = context.options.eventDataTransform;\n  var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n\n  if (sourceEachTransform) {\n    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n  }\n\n  if (calEachTransform) {\n    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n  }\n\n  return rawEvents;\n}\n\nfunction transformEachRawEvent(rawEvents, func) {\n  var refinedEvents;\n\n  if (!func) {\n    refinedEvents = rawEvents;\n  } else {\n    refinedEvents = [];\n\n    for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n      var rawEvent = rawEvents_1[_i];\n      var refinedEvent = func(rawEvent);\n\n      if (refinedEvent) {\n        refinedEvents.push(refinedEvent);\n      } else if (refinedEvent == null) {\n        refinedEvents.push(rawEvent);\n      } // if a different falsy value, do nothing\n\n    }\n  }\n\n  return refinedEvents;\n}\n\nfunction addEvent(eventStore, subset, expandRange, context) {\n  if (expandRange) {\n    subset = expandRecurring(subset, expandRange, context);\n  }\n\n  return mergeEventStores(eventStore, subset);\n}\n\nfunction rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n  var defs = eventStore.defs;\n  var instances = mapHash(eventStore.instances, function (instance) {\n    var def = defs[instance.defId];\n\n    if (def.allDay || def.recurringDef) {\n      return instance; // isn't dependent on timezone\n    }\n\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, instance), {\n      range: {\n        start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n        end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n      },\n      forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n      forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n    });\n  });\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n\nfunction excludeEventsBySourceId(eventStore, sourceId) {\n  return filterEventStoreDefs(eventStore, function (eventDef) {\n    return eventDef.sourceId !== sourceId;\n  });\n} // QUESTION: why not just return instances? do a general object-property-exclusion util\n\n\nfunction excludeInstances(eventStore, removals) {\n  return {\n    defs: eventStore.defs,\n    instances: filterHash(eventStore.instances, function (instance) {\n      return !removals[instance.instanceId];\n    })\n  };\n}\n\nfunction reduceDateSelection(currentSelection, action) {\n  switch (action.type) {\n    case 'UNSELECT_DATES':\n      return null;\n\n    case 'SELECT_DATES':\n      return action.selection;\n\n    default:\n      return currentSelection;\n  }\n}\n\nfunction reduceSelectedEvent(currentInstanceId, action) {\n  switch (action.type) {\n    case 'UNSELECT_EVENT':\n      return '';\n\n    case 'SELECT_EVENT':\n      return action.eventInstanceId;\n\n    default:\n      return currentInstanceId;\n  }\n}\n\nfunction reduceEventDrag(currentDrag, action) {\n  var newDrag;\n\n  switch (action.type) {\n    case 'UNSET_EVENT_DRAG':\n      return null;\n\n    case 'SET_EVENT_DRAG':\n      newDrag = action.state;\n      return {\n        affectedEvents: newDrag.affectedEvents,\n        mutatedEvents: newDrag.mutatedEvents,\n        isEvent: newDrag.isEvent\n      };\n\n    default:\n      return currentDrag;\n  }\n}\n\nfunction reduceEventResize(currentResize, action) {\n  var newResize;\n\n  switch (action.type) {\n    case 'UNSET_EVENT_RESIZE':\n      return null;\n\n    case 'SET_EVENT_RESIZE':\n      newResize = action.state;\n      return {\n        affectedEvents: newResize.affectedEvents,\n        mutatedEvents: newResize.mutatedEvents,\n        isEvent: newResize.isEvent\n      };\n\n    default:\n      return currentResize;\n  }\n}\n\nfunction parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n  var viewsWithButtons = [];\n  var headerToolbar = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) : null;\n  var footerToolbar = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) : null;\n  return {\n    headerToolbar: headerToolbar,\n    footerToolbar: footerToolbar,\n    viewsWithButtons: viewsWithButtons\n  };\n}\n\nfunction parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) {\n  return mapHash(sectionStrHash, function (sectionStr) {\n    return parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons);\n  });\n}\n/*\nBAD: querying icons and text here. should be done at render time\n*/\n\n\nfunction parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) {\n  var isRtl = calendarOptions.direction === 'rtl';\n  var calendarCustomButtons = calendarOptions.customButtons || {};\n  var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n  var calendarButtonText = calendarOptions.buttonText || {};\n  var sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];\n  return sectionSubstrs.map(function (buttonGroupStr) {\n    return buttonGroupStr.split(',').map(function (buttonName) {\n      if (buttonName === 'title') {\n        return {\n          buttonName: buttonName\n        };\n      }\n\n      var customButtonProps;\n      var viewSpec;\n      var buttonClick;\n      var buttonIcon; // only one of these will be set\n\n      var buttonText; // \"\n\n      if (customButtonProps = calendarCustomButtons[buttonName]) {\n        buttonClick = function (ev) {\n          if (customButtonProps.click) {\n            customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n          }\n        };\n\n        (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);\n      } else if (viewSpec = viewSpecs[buttonName]) {\n        viewsWithButtons.push(buttonName);\n\n        buttonClick = function () {\n          calendarApi.changeView(buttonName);\n        };\n\n        (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n      } else if (calendarApi[buttonName]) {\n        // a calendarApi method\n        buttonClick = function () {\n          calendarApi[buttonName]();\n        };\n\n        (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); //            ^ everything else is considered default\n      }\n\n      return {\n        buttonName: buttonName,\n        buttonClick: buttonClick,\n        buttonIcon: buttonIcon,\n        buttonText: buttonText\n      };\n    });\n  });\n}\n\nvar eventSourceDef$2 = {\n  ignoreRange: true,\n  parseMeta: function (refined) {\n    if (Array.isArray(refined.events)) {\n      return refined.events;\n    }\n\n    return null;\n  },\n  fetch: function (arg, success) {\n    success({\n      rawEvents: arg.eventSource.meta\n    });\n  }\n};\nvar arrayEventSourcePlugin = createPlugin({\n  eventSourceDefs: [eventSourceDef$2]\n});\nvar eventSourceDef$1 = {\n  parseMeta: function (refined) {\n    if (typeof refined.events === 'function') {\n      return refined.events;\n    }\n\n    return null;\n  },\n  fetch: function (arg, success, failure) {\n    var dateEnv = arg.context.dateEnv;\n    var func = arg.eventSource.meta;\n    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function (rawEvents) {\n      success({\n        rawEvents: rawEvents\n      }); // needs an object response\n    }, failure);\n  }\n};\nvar funcEventSourcePlugin = createPlugin({\n  eventSourceDefs: [eventSourceDef$1]\n});\n\nfunction requestJson(method, url, params, successCallback, failureCallback) {\n  method = method.toUpperCase();\n  var body = null;\n\n  if (method === 'GET') {\n    url = injectQueryStringParams(url, params);\n  } else {\n    body = encodeParams(params);\n  }\n\n  var xhr = new XMLHttpRequest();\n  xhr.open(method, url, true);\n\n  if (method !== 'GET') {\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  }\n\n  xhr.onload = function () {\n    if (xhr.status >= 200 && xhr.status < 400) {\n      var parsed = false;\n      var res = void 0;\n\n      try {\n        res = JSON.parse(xhr.responseText);\n        parsed = true;\n      } catch (err) {// will handle parsed=false\n      }\n\n      if (parsed) {\n        successCallback(res, xhr);\n      } else {\n        failureCallback('Failure parsing JSON', xhr);\n      }\n    } else {\n      failureCallback('Request failed', xhr);\n    }\n  };\n\n  xhr.onerror = function () {\n    failureCallback('Request failed', xhr);\n  };\n\n  xhr.send(body);\n}\n\nfunction injectQueryStringParams(url, params) {\n  return url + (url.indexOf('?') === -1 ? '?' : '&') + encodeParams(params);\n}\n\nfunction encodeParams(params) {\n  var parts = [];\n\n  for (var key in params) {\n    parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n  }\n\n  return parts.join('&');\n}\n\nvar JSON_FEED_EVENT_SOURCE_REFINERS = {\n  method: String,\n  extraParams: identity,\n  startParam: String,\n  endParam: String,\n  timeZoneParam: String\n};\nvar eventSourceDef = {\n  parseMeta: function (refined) {\n    if (refined.url && (refined.format === 'json' || !refined.format)) {\n      return {\n        url: refined.url,\n        format: 'json',\n        method: (refined.method || 'GET').toUpperCase(),\n        extraParams: refined.extraParams,\n        startParam: refined.startParam,\n        endParam: refined.endParam,\n        timeZoneParam: refined.timeZoneParam\n      };\n    }\n\n    return null;\n  },\n  fetch: function (arg, success, failure) {\n    var meta = arg.eventSource.meta;\n    var requestParams = buildRequestParams(meta, arg.range, arg.context);\n    requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {\n      success({\n        rawEvents: rawEvents,\n        xhr: xhr\n      });\n    }, function (errorMessage, xhr) {\n      failure({\n        message: errorMessage,\n        xhr: xhr\n      });\n    });\n  }\n};\nvar jsonFeedEventSourcePlugin = createPlugin({\n  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n  eventSourceDefs: [eventSourceDef]\n});\n\nfunction buildRequestParams(meta, range, context) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var startParam;\n  var endParam;\n  var timeZoneParam;\n  var customRequestParams;\n  var params = {};\n  startParam = meta.startParam;\n\n  if (startParam == null) {\n    startParam = options.startParam;\n  }\n\n  endParam = meta.endParam;\n\n  if (endParam == null) {\n    endParam = options.endParam;\n  }\n\n  timeZoneParam = meta.timeZoneParam;\n\n  if (timeZoneParam == null) {\n    timeZoneParam = options.timeZoneParam;\n  } // retrieve any outbound GET/POST data from the options\n\n\n  if (typeof meta.extraParams === 'function') {\n    // supplied as a function that returns a key/value object\n    customRequestParams = meta.extraParams();\n  } else {\n    // probably supplied as a straight key/value object\n    customRequestParams = meta.extraParams || {};\n  }\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(params, customRequestParams);\n\n  params[startParam] = dateEnv.formatIso(range.start);\n  params[endParam] = dateEnv.formatIso(range.end);\n\n  if (dateEnv.timeZone !== 'local') {\n    params[timeZoneParam] = dateEnv.timeZone;\n  }\n\n  return params;\n}\n\nvar SIMPLE_RECURRING_REFINERS = {\n  daysOfWeek: identity,\n  startTime: createDuration,\n  endTime: createDuration,\n  duration: createDuration,\n  startRecur: identity,\n  endRecur: identity\n};\nvar recurring = {\n  parse: function (refined, dateEnv) {\n    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n      var recurringData = {\n        daysOfWeek: refined.daysOfWeek || null,\n        startTime: refined.startTime || null,\n        endTime: refined.endTime || null,\n        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null\n      };\n      var duration = void 0;\n\n      if (refined.duration) {\n        duration = refined.duration;\n      }\n\n      if (!duration && refined.startTime && refined.endTime) {\n        duration = subtractDurations(refined.endTime, refined.startTime);\n      }\n\n      return {\n        allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n        duration: duration,\n        typeData: recurringData // doesn't need endTime anymore but oh well\n\n      };\n    }\n\n    return null;\n  },\n  expand: function (typeData, framingRange, dateEnv) {\n    var clippedFramingRange = intersectRanges(framingRange, {\n      start: typeData.startRecur,\n      end: typeData.endRecur\n    });\n\n    if (clippedFramingRange) {\n      return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n    }\n\n    return [];\n  }\n};\nvar simpleRecurringEventsPlugin = createPlugin({\n  recurringTypes: [recurring],\n  eventRefiners: SIMPLE_RECURRING_REFINERS\n});\n\nfunction expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n  var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;\n  var dayMarker = startOfDay(framingRange.start);\n  var endMarker = framingRange.end;\n  var instanceStarts = [];\n\n  while (dayMarker < endMarker) {\n    var instanceStart // if everyday, or this particular day-of-week\n    = void 0; // if everyday, or this particular day-of-week\n\n    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n      if (startTime) {\n        instanceStart = dateEnv.add(dayMarker, startTime);\n      } else {\n        instanceStart = dayMarker;\n      }\n\n      instanceStarts.push(instanceStart);\n    }\n\n    dayMarker = addDays(dayMarker, 1);\n  }\n\n  return instanceStarts;\n}\n\nvar changeHandlerPlugin = createPlugin({\n  optionChangeHandlers: {\n    events: function (events, context) {\n      handleEventSources([events], context);\n    },\n    eventSources: handleEventSources\n  }\n});\n/*\nBUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n*/\n\nfunction handleEventSources(inputs, context) {\n  var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);\n  var newInputs = [];\n\n  for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n    var input = inputs_1[_i];\n    var inputFound = false;\n\n    for (var i = 0; i < unfoundSources.length; i += 1) {\n      if (unfoundSources[i]._raw === input) {\n        unfoundSources.splice(i, 1); // delete\n\n        inputFound = true;\n        break;\n      }\n    }\n\n    if (!inputFound) {\n      newInputs.push(input);\n    }\n  }\n\n  for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {\n    var unfoundSource = unfoundSources_1[_a];\n    context.dispatch({\n      type: 'REMOVE_EVENT_SOURCE',\n      sourceId: unfoundSource.sourceId\n    });\n  }\n\n  for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {\n    var newInput = newInputs_1[_b];\n    context.calendarApi.addEventSource(newInput);\n  }\n}\n\nfunction handleDateProfile(dateProfile, context) {\n  context.emitter.trigger('datesSet', (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {\n    view: context.viewApi\n  }));\n}\n\nfunction handleEventStore(eventStore, context) {\n  var emitter = context.emitter;\n\n  if (emitter.hasHandlers('eventsSet')) {\n    emitter.trigger('eventsSet', buildEventApis(eventStore, context));\n  }\n}\n/*\nthis array is exposed on the root namespace so that UMD plugins can add to it.\nsee the rollup-bundles script.\n*/\n\n\nvar globalPlugins = [arrayEventSourcePlugin, funcEventSourcePlugin, jsonFeedEventSourcePlugin, simpleRecurringEventsPlugin, changeHandlerPlugin, createPlugin({\n  isLoadingFuncs: [function (state) {\n    return computeEventSourcesLoading(state.eventSources);\n  }],\n  contentTypeHandlers: {\n    html: function () {\n      return {\n        render: injectHtml\n      };\n    },\n    domNodes: function () {\n      return {\n        render: injectDomNodes\n      };\n    }\n  },\n  propSetHandlers: {\n    dateProfile: handleDateProfile,\n    eventStore: handleEventStore\n  }\n})];\n\nfunction injectHtml(el, html) {\n  el.innerHTML = html;\n}\n\nfunction injectDomNodes(el, domNodes) {\n  var oldNodes = Array.prototype.slice.call(el.childNodes); // TODO: use array util\n\n  var newNodes = Array.prototype.slice.call(domNodes); // TODO: use array util\n\n  if (!isArraysEqual(oldNodes, newNodes)) {\n    for (var _i = 0, newNodes_1 = newNodes; _i < newNodes_1.length; _i++) {\n      var newNode = newNodes_1[_i];\n      el.appendChild(newNode);\n    }\n\n    oldNodes.forEach(removeElement);\n  }\n}\n\nvar DelayedRunner = function () {\n  function DelayedRunner(drainedOption) {\n    this.drainedOption = drainedOption;\n    this.isRunning = false;\n    this.isDirty = false;\n    this.pauseDepths = {};\n    this.timeoutId = 0;\n  }\n\n  DelayedRunner.prototype.request = function (delay) {\n    this.isDirty = true;\n\n    if (!this.isPaused()) {\n      this.clearTimeout();\n\n      if (delay == null) {\n        this.tryDrain();\n      } else {\n        this.timeoutId = setTimeout( // NOT OPTIMAL! TODO: look at debounce\n        this.tryDrain.bind(this), delay);\n      }\n    }\n  };\n\n  DelayedRunner.prototype.pause = function (scope) {\n    if (scope === void 0) {\n      scope = '';\n    }\n\n    var pauseDepths = this.pauseDepths;\n    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n    this.clearTimeout();\n  };\n\n  DelayedRunner.prototype.resume = function (scope, force) {\n    if (scope === void 0) {\n      scope = '';\n    }\n\n    var pauseDepths = this.pauseDepths;\n\n    if (scope in pauseDepths) {\n      if (force) {\n        delete pauseDepths[scope];\n      } else {\n        pauseDepths[scope] -= 1;\n        var depth = pauseDepths[scope];\n\n        if (depth <= 0) {\n          delete pauseDepths[scope];\n        }\n      }\n\n      this.tryDrain();\n    }\n  };\n\n  DelayedRunner.prototype.isPaused = function () {\n    return Object.keys(this.pauseDepths).length;\n  };\n\n  DelayedRunner.prototype.tryDrain = function () {\n    if (!this.isRunning && !this.isPaused()) {\n      this.isRunning = true;\n\n      while (this.isDirty) {\n        this.isDirty = false;\n        this.drained(); // might set isDirty to true again\n      }\n\n      this.isRunning = false;\n    }\n  };\n\n  DelayedRunner.prototype.clear = function () {\n    this.clearTimeout();\n    this.isDirty = false;\n    this.pauseDepths = {};\n  };\n\n  DelayedRunner.prototype.clearTimeout = function () {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = 0;\n    }\n  };\n\n  DelayedRunner.prototype.drained = function () {\n    if (this.drainedOption) {\n      this.drainedOption();\n    }\n  };\n\n  return DelayedRunner;\n}();\n\nvar TaskRunner = function () {\n  function TaskRunner(runTaskOption, drainedOption) {\n    this.runTaskOption = runTaskOption;\n    this.drainedOption = drainedOption;\n    this.queue = [];\n    this.delayedRunner = new DelayedRunner(this.drain.bind(this));\n  }\n\n  TaskRunner.prototype.request = function (task, delay) {\n    this.queue.push(task);\n    this.delayedRunner.request(delay);\n  };\n\n  TaskRunner.prototype.pause = function (scope) {\n    this.delayedRunner.pause(scope);\n  };\n\n  TaskRunner.prototype.resume = function (scope, force) {\n    this.delayedRunner.resume(scope, force);\n  };\n\n  TaskRunner.prototype.drain = function () {\n    var queue = this.queue;\n\n    while (queue.length) {\n      var completedTasks = [];\n      var task = void 0;\n\n      while (task = queue.shift()) {\n        this.runTask(task);\n        completedTasks.push(task);\n      }\n\n      this.drained(completedTasks);\n    } // keep going, in case new tasks were added in the drained handler\n\n  };\n\n  TaskRunner.prototype.runTask = function (task) {\n    if (this.runTaskOption) {\n      this.runTaskOption(task);\n    }\n  };\n\n  TaskRunner.prototype.drained = function (completedTasks) {\n    if (this.drainedOption) {\n      this.drainedOption(completedTasks);\n    }\n  };\n\n  return TaskRunner;\n}(); // Computes what the title at the top of the calendarApi should be for this view\n\n\nfunction buildTitle(dateProfile, viewOptions, dateEnv) {\n  var range; // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n\n  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n    range = dateProfile.currentRange;\n  } else {\n    // for day units or smaller, use the actual day range\n    range = dateProfile.activeRange;\n  }\n\n  return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n    isEndExclusive: dateProfile.isRangeAllDay,\n    defaultSeparator: viewOptions.titleRangeSeparator\n  });\n} // Generates the format string that should be used to generate the title for the current date range.\n// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n\n\nfunction buildTitleFormat(dateProfile) {\n  var currentRangeUnit = dateProfile.currentRangeUnit;\n\n  if (currentRangeUnit === 'year') {\n    return {\n      year: 'numeric'\n    };\n  }\n\n  if (currentRangeUnit === 'month') {\n    return {\n      year: 'numeric',\n      month: 'long'\n    }; // like \"September 2014\"\n  }\n\n  var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);\n\n  if (days !== null && days > 1) {\n    // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n    return {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric'\n    };\n  } // one day. longer, like \"September 9 2014\"\n\n\n  return {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric'\n  };\n} // in future refactor, do the redux-style function(state=initial) for initial-state\n// also, whatever is happening in constructor, have it happen in action queue too\n\n\nvar CalendarDataManager = function () {\n  function CalendarDataManager(props) {\n    var _this = this;\n\n    this.computeOptionsData = memoize(this._computeOptionsData);\n    this.computeCurrentViewData = memoize(this._computeCurrentViewData);\n    this.organizeRawLocales = memoize(organizeRawLocales);\n    this.buildLocale = memoize(buildLocale);\n    this.buildPluginHooks = buildBuildPluginHooks();\n    this.buildDateEnv = memoize(buildDateEnv);\n    this.buildTheme = memoize(buildTheme);\n    this.parseToolbars = memoize(parseToolbars);\n    this.buildViewSpecs = memoize(buildViewSpecs);\n    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);\n    this.buildViewApi = memoize(buildViewApi);\n    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);\n    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);\n    this.buildEventUiBases = memoize(buildEventUiBases);\n    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);\n    this.buildTitle = memoize(buildTitle);\n    this.emitter = new Emitter();\n    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n    this.currentCalendarOptionsInput = {};\n    this.currentCalendarOptionsRefined = {};\n    this.currentViewOptionsInput = {};\n    this.currentViewOptionsRefined = {};\n    this.currentCalendarOptionsRefiners = {};\n\n    this.getCurrentData = function () {\n      return _this.data;\n    };\n\n    this.dispatch = function (action) {\n      _this.actionRunner.request(action); // protects against recursive calls to _handleAction\n\n    };\n\n    this.props = props;\n    this.actionRunner.pause();\n    var dynamicOptionOverrides = {};\n    var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n    var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n    var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up\n    // TODO: not DRY\n\n    props.calendarApi.currentDataManager = this;\n    this.emitter.setThisContext(props.calendarApi);\n    this.emitter.setOptions(currentViewData.options);\n    var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);\n    var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n\n    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {\n      currentDate = dateProfile.currentRange.start;\n    }\n\n    var calendarContext = {\n      dateEnv: optionsData.dateEnv,\n      options: optionsData.calendarOptions,\n      pluginHooks: optionsData.pluginHooks,\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: this.emitter,\n      getCurrentData: this.getCurrentData\n    }; // needs to be after setThisContext\n\n    for (var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++) {\n      var callback = _a[_i];\n      callback(calendarContext);\n    } // NOT DRY\n\n\n    var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n    var initialState = {\n      dynamicOptionOverrides: dynamicOptionOverrides,\n      currentViewType: currentViewType,\n      currentDate: currentDate,\n      dateProfile: dateProfile,\n      businessHours: this.parseContextBusinessHours(calendarContext),\n      eventSources: eventSources,\n      eventUiBases: {},\n      eventStore: createEmptyEventStore(),\n      renderableEventStore: createEmptyEventStore(),\n      dateSelection: null,\n      eventSelection: '',\n      eventDrag: null,\n      eventResize: null,\n      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n    };\n\n    var contextAndState = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, calendarContext), initialState);\n\n    for (var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++) {\n      var reducer = _c[_b];\n\n      (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(initialState, reducer(null, null, contextAndState));\n    }\n\n    if (computeIsLoading(initialState, calendarContext)) {\n      this.emitter.trigger('loading', true); // NOT DRY\n    }\n\n    this.state = initialState;\n    this.updateData();\n    this.actionRunner.resume();\n  }\n\n  CalendarDataManager.prototype.resetOptions = function (optionOverrides, append) {\n    var props = this.props;\n    props.optionOverrides = append ? (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, props.optionOverrides), optionOverrides) : optionOverrides;\n    this.actionRunner.request({\n      type: 'NOTHING'\n    });\n  };\n\n  CalendarDataManager.prototype._handleAction = function (action) {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        emitter = _a.emitter;\n\n    var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n    var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n    var currentViewType = reduceViewType(state.currentViewType, action);\n    var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up\n    // TODO: not DRY\n\n    props.calendarApi.currentDataManager = this;\n    emitter.setThisContext(props.calendarApi);\n    emitter.setOptions(currentViewData.options);\n    var calendarContext = {\n      dateEnv: optionsData.dateEnv,\n      options: optionsData.calendarOptions,\n      pluginHooks: optionsData.pluginHooks,\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: emitter,\n      getCurrentData: this.getCurrentData\n    };\n    var currentDate = state.currentDate,\n        dateProfile = state.dateProfile;\n\n    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n      // hack\n      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n    }\n\n    currentDate = reduceCurrentDate(currentDate, action);\n    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n\n    if (action.type === 'PREV' || // TODO: move this logic into DateProfileGenerator\n    action.type === 'NEXT' || // \"\n    !rangeContainsMarker(dateProfile.currentRange, currentDate)) {\n      currentDate = dateProfile.currentRange.start;\n    }\n\n    var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n    var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);\n    var isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n\n    var renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : // try from previous state\n    eventStore;\n\n    var _b = this.buildViewUiProps(calendarContext),\n        eventUiSingleBase = _b.eventUiSingleBase,\n        selectionConfig = _b.selectionConfig; // will memoize obj\n\n\n    var eventUiBySource = this.buildEventUiBySource(eventSources);\n    var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n    var newState = {\n      dynamicOptionOverrides: dynamicOptionOverrides,\n      currentViewType: currentViewType,\n      currentDate: currentDate,\n      dateProfile: dateProfile,\n      eventSources: eventSources,\n      eventStore: eventStore,\n      renderableEventStore: renderableEventStore,\n      selectionConfig: selectionConfig,\n      eventUiBases: eventUiBases,\n      businessHours: this.parseContextBusinessHours(calendarContext),\n      dateSelection: reduceDateSelection(state.dateSelection, action),\n      eventSelection: reduceSelectedEvent(state.eventSelection, action),\n      eventDrag: reduceEventDrag(state.eventDrag, action),\n      eventResize: reduceEventResize(state.eventResize, action)\n    };\n\n    var contextAndState = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, calendarContext), newState);\n\n    for (var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++) {\n      var reducer = _c[_i];\n\n      (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n\n    }\n\n    var wasLoading = computeIsLoading(state, calendarContext);\n    var isLoading = computeIsLoading(newState, calendarContext); // TODO: use propSetHandlers in plugin system\n\n    if (!wasLoading && isLoading) {\n      emitter.trigger('loading', true);\n    } else if (wasLoading && !isLoading) {\n      emitter.trigger('loading', false);\n    }\n\n    this.state = newState;\n\n    if (props.onAction) {\n      props.onAction(action);\n    }\n  };\n\n  CalendarDataManager.prototype.updateData = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    var oldData = this.data;\n    var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n    var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n\n    var data = this.data = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: this.emitter,\n      getCurrentData: this.getCurrentData\n    }, optionsData), currentViewData), state);\n\n    var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n    var oldCalendarOptions = oldData && oldData.calendarOptions;\n    var newCalendarOptions = optionsData.calendarOptions;\n\n    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n        // hack\n        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);\n      }\n\n      for (var optionName in changeHandlers) {\n        if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n          changeHandlers[optionName](newCalendarOptions[optionName], data);\n        }\n      }\n    }\n\n    if (props.onData) {\n      props.onData(data);\n    }\n  };\n\n  CalendarDataManager.prototype._computeOptionsData = function (optionOverrides, dynamicOptionOverrides, calendarApi) {\n    // TODO: blacklist options that are handled by optionChangeHandlers\n    var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides),\n        refinedOptions = _a.refinedOptions,\n        pluginHooks = _a.pluginHooks,\n        localeDefaults = _a.localeDefaults,\n        availableLocaleData = _a.availableLocaleData,\n        extra = _a.extra;\n\n    warnUnknownOptions(extra);\n    var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n    var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);\n    var theme = this.buildTheme(refinedOptions, pluginHooks);\n    var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);\n    return {\n      calendarOptions: refinedOptions,\n      pluginHooks: pluginHooks,\n      dateEnv: dateEnv,\n      viewSpecs: viewSpecs,\n      theme: theme,\n      toolbarConfig: toolbarConfig,\n      localeDefaults: localeDefaults,\n      availableRawLocales: availableLocaleData.map\n    };\n  }; // always called from behind a memoizer\n\n\n  CalendarDataManager.prototype.processRawCalendarOptions = function (optionOverrides, dynamicOptionOverrides) {\n    var _a = mergeRawOptions([BASE_OPTION_DEFAULTS, optionOverrides, dynamicOptionOverrides]),\n        locales = _a.locales,\n        locale = _a.locale;\n\n    var availableLocaleData = this.organizeRawLocales(locales);\n    var availableRawLocales = availableLocaleData.map;\n    var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n    var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n\n    var refiners = this.currentCalendarOptionsRefiners = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n\n    var extra = {};\n    var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, localeDefaults, optionOverrides, dynamicOptionOverrides]);\n    var refined = {};\n    var currentRaw = this.currentCalendarOptionsInput;\n    var currentRefined = this.currentCalendarOptionsRefined;\n    var anyChanges = false;\n\n    for (var optionName in raw) {\n      if (optionName !== 'plugins') {\n        // because plugins is special-cased\n        if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName])) {\n          refined[optionName] = currentRefined[optionName];\n        } else if (refiners[optionName]) {\n          refined[optionName] = refiners[optionName](raw[optionName]);\n          anyChanges = true;\n        } else {\n          extra[optionName] = currentRaw[optionName];\n        }\n      }\n    }\n\n    if (anyChanges) {\n      this.currentCalendarOptionsInput = raw;\n      this.currentCalendarOptionsRefined = refined;\n    }\n\n    return {\n      rawOptions: this.currentCalendarOptionsInput,\n      refinedOptions: this.currentCalendarOptionsRefined,\n      pluginHooks: pluginHooks,\n      availableLocaleData: availableLocaleData,\n      localeDefaults: localeDefaults,\n      extra: extra\n    };\n  };\n\n  CalendarDataManager.prototype._computeCurrentViewData = function (viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n    var viewSpec = optionsData.viewSpecs[viewType];\n\n    if (!viewSpec) {\n      throw new Error(\"viewType \\\"\" + viewType + \"\\\" is not available. Please make sure you've loaded all neccessary plugins\");\n    }\n\n    var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides),\n        refinedOptions = _a.refinedOptions,\n        extra = _a.extra;\n\n    warnUnknownOptions(extra);\n    var dateProfileGenerator = this.buildDateProfileGenerator({\n      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n      duration: viewSpec.duration,\n      durationUnit: viewSpec.durationUnit,\n      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n      dateEnv: optionsData.dateEnv,\n      calendarApi: this.props.calendarApi,\n      slotMinTime: refinedOptions.slotMinTime,\n      slotMaxTime: refinedOptions.slotMaxTime,\n      showNonCurrentDates: refinedOptions.showNonCurrentDates,\n      dayCount: refinedOptions.dayCount,\n      dateAlignment: refinedOptions.dateAlignment,\n      dateIncrement: refinedOptions.dateIncrement,\n      hiddenDays: refinedOptions.hiddenDays,\n      weekends: refinedOptions.weekends,\n      nowInput: refinedOptions.now,\n      validRangeInput: refinedOptions.validRange,\n      visibleRangeInput: refinedOptions.visibleRange,\n      monthMode: refinedOptions.monthMode,\n      fixedWeekCount: refinedOptions.fixedWeekCount\n    });\n    var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n    return {\n      viewSpec: viewSpec,\n      options: refinedOptions,\n      dateProfileGenerator: dateProfileGenerator,\n      viewApi: viewApi\n    };\n  };\n\n  CalendarDataManager.prototype.processRawViewOptions = function (viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n    var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, viewSpec.optionDefaults, localeDefaults, optionOverrides, viewSpec.optionOverrides, dynamicOptionOverrides]);\n\n    var refiners = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n\n    var refined = {};\n    var currentRaw = this.currentViewOptionsInput;\n    var currentRefined = this.currentViewOptionsRefined;\n    var anyChanges = false;\n    var extra = {};\n\n    for (var optionName in raw) {\n      if (raw[optionName] === currentRaw[optionName]) {\n        refined[optionName] = currentRefined[optionName];\n      } else {\n        if (raw[optionName] === this.currentCalendarOptionsInput[optionName]) {\n          if (optionName in this.currentCalendarOptionsRefined) {\n            // might be an \"extra\" prop\n            refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n          }\n        } else if (refiners[optionName]) {\n          refined[optionName] = refiners[optionName](raw[optionName]);\n        } else {\n          extra[optionName] = raw[optionName];\n        }\n\n        anyChanges = true;\n      }\n    }\n\n    if (anyChanges) {\n      this.currentViewOptionsInput = raw;\n      this.currentViewOptionsRefined = refined;\n    }\n\n    return {\n      rawOptions: this.currentViewOptionsInput,\n      refinedOptions: this.currentViewOptionsRefined,\n      extra: extra\n    };\n  };\n\n  return CalendarDataManager;\n}();\n\nfunction buildDateEnv(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n  var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n  return new DateEnv({\n    calendarSystem: 'gregory',\n    timeZone: timeZone,\n    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n    locale: locale,\n    weekNumberCalculation: weekNumberCalculation,\n    firstDay: firstDay,\n    weekText: weekText,\n    cmdFormatter: pluginHooks.cmdFormatter,\n    defaultSeparator: defaultSeparator\n  });\n}\n\nfunction buildTheme(options, pluginHooks) {\n  var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n  return new ThemeClass(options);\n}\n\nfunction buildDateProfileGenerator(props) {\n  var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;\n  return new DateProfileGeneratorClass(props);\n}\n\nfunction buildViewApi(type, getCurrentData, dateEnv) {\n  return new ViewApi(type, getCurrentData, dateEnv);\n}\n\nfunction buildEventUiBySource(eventSources) {\n  return mapHash(eventSources, function (eventSource) {\n    return eventSource.ui;\n  });\n}\n\nfunction buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n  var eventUiBases = {\n    '': eventUiSingleBase\n  };\n\n  for (var defId in eventDefs) {\n    var def = eventDefs[defId];\n\n    if (def.sourceId && eventUiBySource[def.sourceId]) {\n      eventUiBases[defId] = eventUiBySource[def.sourceId];\n    }\n  }\n\n  return eventUiBases;\n}\n\nfunction buildViewUiProps(calendarContext) {\n  var options = calendarContext.options;\n  return {\n    eventUiSingleBase: createEventUi({\n      display: options.eventDisplay,\n      editable: options.editable,\n      startEditable: options.eventStartEditable,\n      durationEditable: options.eventDurationEditable,\n      constraint: options.eventConstraint,\n      overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,\n      allow: options.eventAllow,\n      backgroundColor: options.eventBackgroundColor,\n      borderColor: options.eventBorderColor,\n      textColor: options.eventTextColor,\n      color: options.eventColor // classNames: options.eventClassNames // render hook will handle this\n\n    }, calendarContext),\n    selectionConfig: createEventUi({\n      constraint: options.selectConstraint,\n      overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,\n      allow: options.selectAllow\n    }, calendarContext)\n  };\n}\n\nfunction computeIsLoading(state, context) {\n  for (var _i = 0, _a = context.pluginHooks.isLoadingFuncs; _i < _a.length; _i++) {\n    var isLoadingFunc = _a[_i];\n\n    if (isLoadingFunc(state)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction parseContextBusinessHours(calendarContext) {\n  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);\n}\n\nfunction warnUnknownOptions(options, viewName) {\n  for (var optionName in options) {\n    console.warn(\"Unknown option '\" + optionName + \"'\" + (viewName ? \" for view '\" + viewName + \"'\" : ''));\n  }\n} // TODO: move this to react plugin?\n\n\nvar CalendarDataProvider = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(CalendarDataProvider, _super);\n\n  function CalendarDataProvider(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.handleData = function (data) {\n      if (!_this.dataManager) {\n        // still within initial run, before assignment in constructor\n        // eslint-disable-next-line react/no-direct-mutation-state\n        _this.state = data; // can't use setState yet\n      } else {\n        _this.setState(data);\n      }\n    };\n\n    _this.dataManager = new CalendarDataManager({\n      optionOverrides: props.optionOverrides,\n      calendarApi: props.calendarApi,\n      onData: _this.handleData\n    });\n    return _this;\n  }\n\n  CalendarDataProvider.prototype.render = function () {\n    return this.props.children(this.state);\n  };\n\n  CalendarDataProvider.prototype.componentDidUpdate = function (prevProps) {\n    var newOptionOverrides = this.props.optionOverrides;\n\n    if (newOptionOverrides !== prevProps.optionOverrides) {\n      // prevent recursive handleData\n      this.dataManager.resetOptions(newOptionOverrides);\n    }\n  };\n\n  return CalendarDataProvider;\n}(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Component); // HELPERS\n\n/*\nif nextDayThreshold is specified, slicing is done in an all-day fashion.\nyou can get nextDayThreshold from context.nextDayThreshold\n*/\n\n\nfunction sliceEvents(props, allDay) {\n  return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n}\n\nvar NamedTimeZoneImpl = function () {\n  function NamedTimeZoneImpl(timeZoneName) {\n    this.timeZoneName = timeZoneName;\n  }\n\n  return NamedTimeZoneImpl;\n}();\n\nvar SegHierarchy = function () {\n  function SegHierarchy() {\n    // settings\n    this.strictOrder = false;\n    this.allowReslicing = false;\n    this.maxCoord = -1; // -1 means no max\n\n    this.maxStackCnt = -1; // -1 means no max\n\n    this.levelCoords = []; // ordered\n\n    this.entriesByLevel = []; // parallel with levelCoords\n\n    this.stackCnts = {}; // TODO: use better technique!?\n  }\n\n  SegHierarchy.prototype.addSegs = function (inputs) {\n    var hiddenEntries = [];\n\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n      var input = inputs_1[_i];\n      this.insertEntry(input, hiddenEntries);\n    }\n\n    return hiddenEntries;\n  };\n\n  SegHierarchy.prototype.insertEntry = function (entry, hiddenEntries) {\n    var insertion = this.findInsertion(entry);\n\n    if (this.isInsertionValid(insertion, entry)) {\n      this.insertEntryAt(entry, insertion);\n      return 1;\n    }\n\n    return this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n  };\n\n  SegHierarchy.prototype.isInsertionValid = function (insertion, entry) {\n    return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n  }; // returns number of new entries inserted\n\n\n  SegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {\n    if (this.allowReslicing && insertion.touchingEntry) {\n      return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n    }\n\n    hiddenEntries.push(entry);\n    return 0;\n  };\n\n  SegHierarchy.prototype.splitEntry = function (entry, barrier, hiddenEntries) {\n    var partCnt = 0;\n    var splitHiddenEntries = [];\n    var entrySpan = entry.span;\n    var barrierSpan = barrier.span;\n\n    if (entrySpan.start < barrierSpan.start) {\n      partCnt += this.insertEntry({\n        index: entry.index,\n        thickness: entry.thickness,\n        span: {\n          start: entrySpan.start,\n          end: barrierSpan.start\n        }\n      }, splitHiddenEntries);\n    }\n\n    if (entrySpan.end > barrierSpan.end) {\n      partCnt += this.insertEntry({\n        index: entry.index,\n        thickness: entry.thickness,\n        span: {\n          start: barrierSpan.end,\n          end: entrySpan.end\n        }\n      }, splitHiddenEntries);\n    }\n\n    if (partCnt) {\n      hiddenEntries.push.apply(hiddenEntries, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([{\n        index: entry.index,\n        thickness: entry.thickness,\n        span: intersectSpans(barrierSpan, entrySpan) // guaranteed to intersect\n\n      }], splitHiddenEntries));\n      return partCnt;\n    }\n\n    hiddenEntries.push(entry);\n    return 0;\n  };\n\n  SegHierarchy.prototype.insertEntryAt = function (entry, insertion) {\n    var _a = this,\n        entriesByLevel = _a.entriesByLevel,\n        levelCoords = _a.levelCoords;\n\n    if (insertion.lateral === -1) {\n      // create a new level\n      insertAt(levelCoords, insertion.level, insertion.levelCoord);\n      insertAt(entriesByLevel, insertion.level, [entry]);\n    } else {\n      // insert into existing level\n      insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n    }\n\n    this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n  };\n\n  SegHierarchy.prototype.findInsertion = function (newEntry) {\n    var _a = this,\n        levelCoords = _a.levelCoords,\n        entriesByLevel = _a.entriesByLevel,\n        strictOrder = _a.strictOrder,\n        stackCnts = _a.stackCnts;\n\n    var levelCnt = levelCoords.length;\n    var candidateCoord = 0;\n    var touchingLevel = -1;\n    var touchingLateral = -1;\n    var touchingEntry = null;\n    var stackCnt = 0;\n\n    for (var trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {\n      var trackingCoord = levelCoords[trackingLevel]; // if the current level is past the placed entry, we have found a good empty space and can stop.\n      // if strictOrder, keep finding more lateral intersections.\n\n      if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) {\n        break;\n      }\n\n      var trackingEntries = entriesByLevel[trackingLevel];\n      var trackingEntry = void 0;\n      var searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n\n      var lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n\n      while ( // loop through entries that horizontally intersect\n      (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n      trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n      ) {\n        var trackingEntryBottom = trackingCoord + trackingEntry.thickness; // intersects into the top of the candidate?\n\n        if (trackingEntryBottom > candidateCoord) {\n          candidateCoord = trackingEntryBottom;\n          touchingEntry = trackingEntry;\n          touchingLevel = trackingLevel;\n          touchingLateral = lateralIndex;\n        } // butts up against top of candidate? (will happen if just intersected as well)\n\n\n        if (trackingEntryBottom === candidateCoord) {\n          // accumulate the highest possible stackCnt of the trackingEntries that butt up\n          stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n        }\n\n        lateralIndex += 1;\n      }\n    } // the destination level will be after touchingEntry's level. find it\n\n\n    var destLevel = 0;\n\n    if (touchingEntry) {\n      destLevel = touchingLevel + 1;\n\n      while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {\n        destLevel += 1;\n      }\n    } // if adding to an existing level, find where to insert\n\n\n    var destLateral = -1;\n\n    if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n      destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n    }\n\n    return {\n      touchingLevel: touchingLevel,\n      touchingLateral: touchingLateral,\n      touchingEntry: touchingEntry,\n      stackCnt: stackCnt,\n      levelCoord: candidateCoord,\n      level: destLevel,\n      lateral: destLateral\n    };\n  }; // sorted by levelCoord (lowest to highest)\n\n\n  SegHierarchy.prototype.toRects = function () {\n    var _a = this,\n        entriesByLevel = _a.entriesByLevel,\n        levelCoords = _a.levelCoords;\n\n    var levelCnt = entriesByLevel.length;\n    var rects = [];\n\n    for (var level = 0; level < levelCnt; level += 1) {\n      var entries = entriesByLevel[level];\n      var levelCoord = levelCoords[level];\n\n      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n        var entry = entries_1[_i];\n        rects.push((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, entry), {\n          levelCoord: levelCoord\n        }));\n      }\n    }\n\n    return rects;\n  };\n\n  return SegHierarchy;\n}();\n\nfunction getEntrySpanEnd(entry) {\n  return entry.span.end;\n}\n\nfunction buildEntryKey(entry) {\n  return entry.index + ':' + entry.span.start;\n} // returns groups with entries sorted by input order\n\n\nfunction groupIntersectingEntries(entries) {\n  var merges = [];\n\n  for (var _i = 0, entries_2 = entries; _i < entries_2.length; _i++) {\n    var entry = entries_2[_i];\n    var filteredMerges = [];\n    var hungryMerge = {\n      span: entry.span,\n      entries: [entry]\n    };\n\n    for (var _a = 0, merges_1 = merges; _a < merges_1.length; _a++) {\n      var merge = merges_1[_a];\n\n      if (intersectSpans(merge.span, hungryMerge.span)) {\n        hungryMerge = {\n          entries: merge.entries.concat(hungryMerge.entries),\n          span: joinSpans(merge.span, hungryMerge.span)\n        };\n      } else {\n        filteredMerges.push(merge);\n      }\n    }\n\n    filteredMerges.push(hungryMerge);\n    merges = filteredMerges;\n  }\n\n  return merges;\n}\n\nfunction joinSpans(span0, span1) {\n  return {\n    start: Math.min(span0.start, span1.start),\n    end: Math.max(span0.end, span1.end)\n  };\n}\n\nfunction intersectSpans(span0, span1) {\n  var start = Math.max(span0.start, span1.start);\n  var end = Math.min(span0.end, span1.end);\n\n  if (start < end) {\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  return null;\n} // general util\n// ---------------------------------------------------------------------------------------------------------------------\n\n\nfunction insertAt(arr, index, item) {\n  arr.splice(index, 0, item);\n}\n\nfunction binarySearch(a, searchVal, getItemVal) {\n  var startIndex = 0;\n  var endIndex = a.length; // exclusive\n\n  if (!endIndex || searchVal < getItemVal(a[startIndex])) {\n    // no items OR before first item\n    return [0, 0];\n  }\n\n  if (searchVal > getItemVal(a[endIndex - 1])) {\n    // after last item\n    return [endIndex, 0];\n  }\n\n  while (startIndex < endIndex) {\n    var middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n    var middleVal = getItemVal(a[middleIndex]);\n\n    if (searchVal < middleVal) {\n      endIndex = middleIndex;\n    } else if (searchVal > middleVal) {\n      startIndex = middleIndex + 1;\n    } else {\n      // equal!\n      return [middleIndex, 1];\n    }\n  }\n\n  return [startIndex, 0];\n}\n\nvar Interaction = function () {\n  function Interaction(settings) {\n    this.component = settings.component;\n    this.isHitComboAllowed = settings.isHitComboAllowed || null;\n  }\n\n  Interaction.prototype.destroy = function () {};\n\n  return Interaction;\n}();\n\nfunction parseInteractionSettings(component, input) {\n  return {\n    component: component,\n    el: input.el,\n    useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n    isHitComboAllowed: input.isHitComboAllowed || null\n  };\n}\n\nfunction interactionSettingsToStore(settings) {\n  var _a;\n\n  return _a = {}, _a[settings.component.uid] = settings, _a;\n} // global state\n\n\nvar interactionSettingsStore = {};\n/*\nAn abstraction for a dragging interaction originating on an event.\nDoes higher-level things than PointerDragger, such as possibly:\n- a \"mirror\" that moves with the pointer\n- a minimum number of pixels or other criteria for a true drag to begin\n\nsubclasses must emit:\n- pointerdown\n- dragstart\n- dragmove\n- pointerup\n- dragend\n*/\n\nvar ElementDragging = function () {\n  function ElementDragging(el, selector) {\n    this.emitter = new Emitter();\n  }\n\n  ElementDragging.prototype.destroy = function () {};\n\n  ElementDragging.prototype.setMirrorIsVisible = function (bool) {// optional if subclass doesn't want to support a mirror\n  };\n\n  ElementDragging.prototype.setMirrorNeedsRevert = function (bool) {// optional if subclass doesn't want to support a mirror\n  };\n\n  ElementDragging.prototype.setAutoScrollEnabled = function (bool) {// optional\n  };\n\n  return ElementDragging;\n}(); // TODO: get rid of this in favor of options system,\n// tho it's really easy to access this globally rather than pass thru options.\n\n\nvar config = {};\n/*\nInformation about what will happen when an external element is dragged-and-dropped\nonto a calendar. Contains information for creating an event.\n*/\n\nvar DRAG_META_REFINERS = {\n  startTime: createDuration,\n  duration: createDuration,\n  create: Boolean,\n  sourceId: String\n};\n\nfunction parseDragMeta(raw) {\n  var _a = refineProps(raw, DRAG_META_REFINERS),\n      refined = _a.refined,\n      extra = _a.extra;\n\n  return {\n    startTime: refined.startTime || null,\n    duration: refined.duration || null,\n    create: refined.create != null ? refined.create : true,\n    sourceId: refined.sourceId,\n    leftoverProps: extra\n  };\n}\n\nvar ToolbarSection = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ToolbarSection, _super);\n\n  function ToolbarSection() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ToolbarSection.prototype.render = function () {\n    var _this = this;\n\n    var children = this.props.widgetGroups.map(function (widgetGroup) {\n      return _this.renderWidgetGroup(widgetGroup);\n    });\n    return _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['div', {\n      className: 'fc-toolbar-chunk'\n    }], children));\n  };\n\n  ToolbarSection.prototype.renderWidgetGroup = function (widgetGroup) {\n    var props = this.props;\n    var theme = this.context.theme;\n    var children = [];\n    var isOnlyButtons = true;\n\n    for (var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++) {\n      var widget = widgetGroup_1[_i];\n      var buttonName = widget.buttonName,\n          buttonClick = widget.buttonClick,\n          buttonText = widget.buttonText,\n          buttonIcon = widget.buttonIcon;\n\n      if (buttonName === 'title') {\n        isOnlyButtons = false;\n        children.push((0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"h2\", {\n          className: \"fc-toolbar-title\"\n        }, props.title));\n      } else {\n        var ariaAttrs = buttonIcon ? {\n          'aria-label': buttonName\n        } : {};\n        var buttonClasses = [\"fc-\" + buttonName + \"-button\", theme.getClass('button')];\n\n        if (buttonName === props.activeButton) {\n          buttonClasses.push(theme.getClass('buttonActive'));\n        }\n\n        var isDisabled = !props.isTodayEnabled && buttonName === 'today' || !props.isPrevEnabled && buttonName === 'prev' || !props.isNextEnabled && buttonName === 'next';\n        children.push((0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"button\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          disabled: isDisabled,\n          className: buttonClasses.join(' '),\n          onClick: buttonClick,\n          type: \"button\"\n        }, ariaAttrs), buttonText || (buttonIcon ? (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n          className: buttonIcon\n        }) : '')));\n      }\n    }\n\n    if (children.length > 1) {\n      var groupClassName = isOnlyButtons && theme.getClass('buttonGroup') || '';\n      return _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['div', {\n        className: groupClassName\n      }], children));\n    }\n\n    return children[0];\n  };\n\n  return ToolbarSection;\n}(BaseComponent);\n\nvar Toolbar = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Toolbar, _super);\n\n  function Toolbar() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Toolbar.prototype.render = function () {\n    var _a = this.props,\n        model = _a.model,\n        extraClassName = _a.extraClassName;\n    var forceLtr = false;\n    var startContent;\n    var endContent;\n    var centerContent = model.center;\n\n    if (model.left) {\n      forceLtr = true;\n      startContent = model.left;\n    } else {\n      startContent = model.start;\n    }\n\n    if (model.right) {\n      forceLtr = true;\n      endContent = model.right;\n    } else {\n      endContent = model.end;\n    }\n\n    var classNames = [extraClassName || '', 'fc-toolbar', forceLtr ? 'fc-toolbar-ltr' : ''];\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      className: classNames.join(' ')\n    }, this.renderSection('start', startContent || []), this.renderSection('center', centerContent || []), this.renderSection('end', endContent || []));\n  };\n\n  Toolbar.prototype.renderSection = function (key, widgetGroups) {\n    var props = this.props;\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ToolbarSection, {\n      key: key,\n      widgetGroups: widgetGroups,\n      title: props.title,\n      activeButton: props.activeButton,\n      isTodayEnabled: props.isTodayEnabled,\n      isPrevEnabled: props.isPrevEnabled,\n      isNextEnabled: props.isNextEnabled\n    });\n  };\n\n  return Toolbar;\n}(BaseComponent); // TODO: do function component?\n\n\nvar ViewContainer = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ViewContainer, _super);\n\n  function ViewContainer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      availableWidth: null\n    };\n\n    _this.handleEl = function (el) {\n      _this.el = el;\n      setRef(_this.props.elRef, el);\n\n      _this.updateAvailableWidth();\n    };\n\n    _this.handleResize = function () {\n      _this.updateAvailableWidth();\n    };\n\n    return _this;\n  }\n\n  ViewContainer.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    var aspectRatio = props.aspectRatio;\n    var classNames = ['fc-view-harness', aspectRatio || props.liquid || props.height ? 'fc-view-harness-active' // harness controls the height\n    : 'fc-view-harness-passive' // let the view do the height\n    ];\n    var height = '';\n    var paddingBottom = '';\n\n    if (aspectRatio) {\n      if (state.availableWidth !== null) {\n        height = state.availableWidth / aspectRatio;\n      } else {\n        // while waiting to know availableWidth, we can't set height to *zero*\n        // because will cause lots of unnecessary scrollbars within scrollgrid.\n        // BETTER: don't start rendering ANYTHING yet until we know container width\n        // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n        paddingBottom = 1 / aspectRatio * 100 + \"%\";\n      }\n    } else {\n      height = props.height || '';\n    }\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      ref: this.handleEl,\n      onClick: props.onClick,\n      className: classNames.join(' '),\n      style: {\n        height: height,\n        paddingBottom: paddingBottom\n      }\n    }, props.children);\n  };\n\n  ViewContainer.prototype.componentDidMount = function () {\n    this.context.addResizeHandler(this.handleResize);\n  };\n\n  ViewContainer.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleResize);\n  };\n\n  ViewContainer.prototype.updateAvailableWidth = function () {\n    if (this.el && // needed. but why?\n    this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n    ) {\n      this.setState({\n        availableWidth: this.el.offsetWidth\n      });\n    }\n  };\n\n  return ViewContainer;\n}(BaseComponent);\n/*\nDetects when the user clicks on an event within a DateComponent\n*/\n\n\nvar EventClicking = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(EventClicking, _super);\n\n  function EventClicking(settings) {\n    var _this = _super.call(this, settings) || this;\n\n    _this.handleSegClick = function (ev, segEl) {\n      var component = _this.component;\n      var context = component.context;\n      var seg = getElSeg(segEl);\n\n      if (seg && // might be the <div> surrounding the more link\n      component.isValidSegDownEl(ev.target)) {\n        // our way to simulate a link click for elements that can't be <a> tags\n        // grab before trigger fired in case trigger trashes DOM thru rerendering\n        var hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');\n        var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';\n        context.emitter.trigger('eventClick', {\n          el: segEl,\n          event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),\n          jsEvent: ev,\n          view: context.viewApi\n        });\n\n        if (url && !ev.defaultPrevented) {\n          window.location.href = url;\n        }\n      }\n    };\n\n    _this.destroy = listenBySelector(settings.el, 'click', '.fc-event', // on both fg and bg events\n    _this.handleSegClick);\n    return _this;\n  }\n\n  return EventClicking;\n}(Interaction);\n/*\nTriggers events and adds/removes core classNames when the user's pointer\nenters/leaves event-elements of a component.\n*/\n\n\nvar EventHovering = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(EventHovering, _super);\n\n  function EventHovering(settings) {\n    var _this = _super.call(this, settings) || this; // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n\n\n    _this.handleEventElRemove = function (el) {\n      if (el === _this.currentSegEl) {\n        _this.handleSegLeave(null, _this.currentSegEl);\n      }\n    };\n\n    _this.handleSegEnter = function (ev, segEl) {\n      if (getElSeg(segEl)) {\n        // TODO: better way to make sure not hovering over more+ link or its wrapper\n        _this.currentSegEl = segEl;\n\n        _this.triggerEvent('eventMouseEnter', ev, segEl);\n      }\n    };\n\n    _this.handleSegLeave = function (ev, segEl) {\n      if (_this.currentSegEl) {\n        _this.currentSegEl = null;\n\n        _this.triggerEvent('eventMouseLeave', ev, segEl);\n      }\n    };\n\n    _this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', // on both fg and bg events\n    _this.handleSegEnter, _this.handleSegLeave);\n    return _this;\n  }\n\n  EventHovering.prototype.destroy = function () {\n    this.removeHoverListeners();\n  };\n\n  EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {\n    var component = this.component;\n    var context = component.context;\n    var seg = getElSeg(segEl);\n\n    if (!ev || component.isValidSegDownEl(ev.target)) {\n      context.emitter.trigger(publicEvName, {\n        el: segEl,\n        event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),\n        jsEvent: ev,\n        view: context.viewApi\n      });\n    }\n  };\n\n  return EventHovering;\n}(Interaction);\n\nvar CalendarContent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(CalendarContent, _super);\n\n  function CalendarContent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildViewContext = memoize(buildViewContext);\n    _this.buildViewPropTransformers = memoize(buildViewPropTransformers);\n    _this.buildToolbarProps = memoize(buildToolbarProps);\n    _this.handleNavLinkClick = buildDelegationHandler('a[data-navlink]', _this._handleNavLinkClick.bind(_this));\n    _this.headerRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    _this.footerRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    _this.interactionsStore = {}; // Component Registration\n    // -----------------------------------------------------------------------------------------------------------------\n\n    _this.registerInteractiveComponent = function (component, settingsInput) {\n      var settings = parseInteractionSettings(component, settingsInput);\n      var DEFAULT_INTERACTIONS = [EventClicking, EventHovering];\n      var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);\n      var interactions = interactionClasses.map(function (TheInteractionClass) {\n        return new TheInteractionClass(settings);\n      });\n      _this.interactionsStore[component.uid] = interactions;\n      interactionSettingsStore[component.uid] = settings;\n    };\n\n    _this.unregisterInteractiveComponent = function (component) {\n      for (var _i = 0, _a = _this.interactionsStore[component.uid]; _i < _a.length; _i++) {\n        var listener = _a[_i];\n        listener.destroy();\n      }\n\n      delete _this.interactionsStore[component.uid];\n      delete interactionSettingsStore[component.uid];\n    }; // Resizing\n    // -----------------------------------------------------------------------------------------------------------------\n\n\n    _this.resizeRunner = new DelayedRunner(function () {\n      _this.props.emitter.trigger('_resize', true); // should window resizes be considered \"forced\" ?\n\n\n      _this.props.emitter.trigger('windowResize', {\n        view: _this.props.viewApi\n      });\n    });\n\n    _this.handleWindowResize = function (ev) {\n      var options = _this.props.options;\n\n      if (options.handleWindowResize && ev.target === window // avoid jqui events\n      ) {\n        _this.resizeRunner.request(options.windowResizeDelay);\n      }\n    };\n\n    return _this;\n  }\n  /*\n  renders INSIDE of an outer div\n  */\n\n\n  CalendarContent.prototype.render = function () {\n    var props = this.props;\n    var toolbarConfig = props.toolbarConfig,\n        options = props.options;\n    var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), // TODO: use NowTimer????\n    props.viewTitle);\n    var viewVGrow = false;\n    var viewHeight = '';\n    var viewAspectRatio;\n\n    if (props.isHeightAuto || props.forPrint) {\n      viewHeight = '';\n    } else if (options.height != null) {\n      viewVGrow = true;\n    } else if (options.contentHeight != null) {\n      viewHeight = options.contentHeight;\n    } else {\n      viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n    }\n\n    var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Provider, {\n      value: viewContext\n    }, toolbarConfig.headerToolbar && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      ref: this.headerRef,\n      extraClassName: \"fc-header-toolbar\",\n      model: toolbarConfig.headerToolbar\n    }, toolbarProps)), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContainer, {\n      liquid: viewVGrow,\n      height: viewHeight,\n      aspectRatio: viewAspectRatio,\n      onClick: this.handleNavLinkClick\n    }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footerToolbar && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      ref: this.footerRef,\n      extraClassName: \"fc-footer-toolbar\",\n      model: toolbarConfig.footerToolbar\n    }, toolbarProps)));\n  };\n\n  CalendarContent.prototype.componentDidMount = function () {\n    var props = this.props;\n    this.calendarInteractions = props.pluginHooks.calendarInteractions.map(function (CalendarInteractionClass) {\n      return new CalendarInteractionClass(props);\n    });\n    window.addEventListener('resize', this.handleWindowResize);\n    var propSetHandlers = props.pluginHooks.propSetHandlers;\n\n    for (var propName in propSetHandlers) {\n      propSetHandlers[propName](props[propName], props);\n    }\n  };\n\n  CalendarContent.prototype.componentDidUpdate = function (prevProps) {\n    var props = this.props;\n    var propSetHandlers = props.pluginHooks.propSetHandlers;\n\n    for (var propName in propSetHandlers) {\n      if (props[propName] !== prevProps[propName]) {\n        propSetHandlers[propName](props[propName], props);\n      }\n    }\n  };\n\n  CalendarContent.prototype.componentWillUnmount = function () {\n    window.removeEventListener('resize', this.handleWindowResize);\n    this.resizeRunner.clear();\n\n    for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {\n      var interaction = _a[_i];\n      interaction.destroy();\n    }\n\n    this.props.emitter.trigger('_unmount');\n  };\n\n  CalendarContent.prototype._handleNavLinkClick = function (ev, anchorEl) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        options = _a.options,\n        calendarApi = _a.calendarApi;\n    var navLinkOptions = anchorEl.getAttribute('data-navlink');\n    navLinkOptions = navLinkOptions ? JSON.parse(navLinkOptions) : {};\n    var dateMarker = dateEnv.createMarker(navLinkOptions.date);\n    var viewType = navLinkOptions.type;\n    var customAction = viewType === 'day' ? options.navLinkDayClick : viewType === 'week' ? options.navLinkWeekClick : null;\n\n    if (typeof customAction === 'function') {\n      customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n    } else {\n      if (typeof customAction === 'string') {\n        viewType = customAction;\n      }\n\n      calendarApi.zoomTo(dateMarker, viewType);\n    }\n  };\n\n  CalendarContent.prototype.buildAppendContent = function () {\n    var props = this.props;\n    var children = props.pluginHooks.viewContainerAppends.map(function (buildAppendContent) {\n      return buildAppendContent(props);\n    });\n    return _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, {}], children));\n  };\n\n  CalendarContent.prototype.renderView = function (props) {\n    var pluginHooks = props.pluginHooks;\n    var viewSpec = props.viewSpec;\n    var viewProps = {\n      dateProfile: props.dateProfile,\n      businessHours: props.businessHours,\n      eventStore: props.renderableEventStore,\n      eventUiBases: props.eventUiBases,\n      dateSelection: props.dateSelection,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      isHeightAuto: props.isHeightAuto,\n      forPrint: props.forPrint\n    };\n    var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n\n    for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n      var transformer = transformers_1[_i];\n\n      (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(viewProps, transformer.transform(viewProps, props));\n    }\n\n    var ViewComponent = viewSpec.component;\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewComponent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, viewProps));\n  };\n\n  return CalendarContent;\n}(PureComponent);\n\nfunction buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n  // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n  var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n\n  var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n  var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n  return {\n    title: title,\n    activeButton: viewSpec.type,\n    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),\n    isPrevEnabled: prevInfo.isValid,\n    isNextEnabled: nextInfo.isValid\n  };\n} // Plugin\n// -----------------------------------------------------------------------------------------------------------------\n\n\nfunction buildViewPropTransformers(theClasses) {\n  return theClasses.map(function (TheClass) {\n    return new TheClass();\n  });\n}\n\nvar CalendarRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(CalendarRoot, _super);\n\n  function CalendarRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      forPrint: false\n    };\n\n    _this.handleBeforePrint = function () {\n      _this.setState({\n        forPrint: true\n      });\n    };\n\n    _this.handleAfterPrint = function () {\n      _this.setState({\n        forPrint: false\n      });\n    };\n\n    return _this;\n  }\n\n  CalendarRoot.prototype.render = function () {\n    var props = this.props;\n    var options = props.options;\n    var forPrint = this.state.forPrint;\n    var isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';\n    var height = !isHeightAuto && options.height != null ? options.height : '';\n    var classNames = ['fc', forPrint ? 'fc-media-print' : 'fc-media-screen', \"fc-direction-\" + options.direction, props.theme.getClass('root')];\n\n    if (!getCanVGrowWithinCell()) {\n      classNames.push('fc-liquid-hack');\n    }\n\n    return props.children(classNames, height, isHeightAuto, forPrint);\n  };\n\n  CalendarRoot.prototype.componentDidMount = function () {\n    var emitter = this.props.emitter;\n    emitter.on('_beforeprint', this.handleBeforePrint);\n    emitter.on('_afterprint', this.handleAfterPrint);\n  };\n\n  CalendarRoot.prototype.componentWillUnmount = function () {\n    var emitter = this.props.emitter;\n    emitter.off('_beforeprint', this.handleBeforePrint);\n    emitter.off('_afterprint', this.handleAfterPrint);\n  };\n\n  return CalendarRoot;\n}(BaseComponent); // Computes a default column header formatting string if `colFormat` is not explicitly defined\n\n\nfunction computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n  // if more than one week row, or if there are a lot of columns with not much space,\n  // put just the day numbers will be in each cell\n  if (!datesRepDistinctDays || dayCnt > 10) {\n    return createFormatter({\n      weekday: 'short'\n    }); // \"Sat\"\n  }\n\n  if (dayCnt > 1) {\n    return createFormatter({\n      weekday: 'short',\n      month: 'numeric',\n      day: 'numeric',\n      omitCommas: true\n    }); // \"Sat 11/12\"\n  }\n\n  return createFormatter({\n    weekday: 'long'\n  }); // \"Saturday\"\n}\n\nvar CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no\n\nfunction renderInner$1(hookProps) {\n  return hookProps.text;\n}\n\nvar TableDateCell = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableDateCell, _super);\n\n  function TableDateCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableDateCell.prototype.render = function () {\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        options = _a.options,\n        theme = _a.theme,\n        viewApi = _a.viewApi;\n    var props = this.props;\n    var date = props.date,\n        dateProfile = props.dateProfile;\n    var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n    var classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));\n    var text = dateEnv.format(date, props.dayHeaderFormat); // if colCnt is 1, we are already in a day-view and don't need a navlink\n\n    var navLinkAttrs = options.navLinks && !dayMeta.isDisabled && props.colCnt > 1 ? {\n      'data-navlink': buildNavLinkData(date),\n      tabIndex: 0\n    } : {};\n\n    var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      date: dateEnv.toDate(date),\n      view: viewApi\n    }, props.extraHookProps), {\n      text: text\n    }), dayMeta);\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.dayHeaderClassNames,\n      content: options.dayHeaderContent,\n      defaultContent: renderInner$1,\n      didMount: options.dayHeaderDidMount,\n      willUnmount: options.dayHeaderWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"th\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-date\": !dayMeta.isDisabled ? formatDayString(date) : undefined,\n        colSpan: props.colSpan\n      }, props.extraDataAttrs), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-scrollgrid-sync-inner\"\n      }, !dayMeta.isDisabled && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        ref: innerElRef,\n        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' ')\n      }, navLinkAttrs), innerContent)));\n    });\n  };\n\n  return TableDateCell;\n}(BaseComponent);\n\nvar TableDowCell = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableDowCell, _super);\n\n  function TableDowCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableDowCell.prototype.render = function () {\n    var props = this.props;\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        theme = _a.theme,\n        viewApi = _a.viewApi,\n        options = _a.options;\n    var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n\n    var dateMeta = {\n      dow: props.dow,\n      isDisabled: false,\n      isFuture: false,\n      isPast: false,\n      isToday: false,\n      isOther: false\n    };\n    var classNames = [CLASS_NAME].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);\n    var text = dateEnv.format(date, props.dayHeaderFormat);\n\n    var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      // TODO: make this public?\n      date: date\n    }, dateMeta), {\n      view: viewApi\n    }), props.extraHookProps), {\n      text: text\n    });\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.dayHeaderClassNames,\n      content: options.dayHeaderContent,\n      defaultContent: renderInner$1,\n      didMount: options.dayHeaderDidMount,\n      willUnmount: options.dayHeaderWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"th\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        colSpan: props.colSpan\n      }, props.extraDataAttrs), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-scrollgrid-sync-inner\"\n      }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", {\n        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' '),\n        ref: innerElRef\n      }, innerContent)));\n    });\n  };\n\n  return TableDowCell;\n}(BaseComponent);\n\nvar NowTimer = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(NowTimer, _super);\n\n  function NowTimer(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.initialNowDate = getNow(context.options.now, context.dateEnv);\n    _this.initialNowQueriedMs = new Date().valueOf();\n    _this.state = _this.computeTiming().currentState;\n    return _this;\n  }\n\n  NowTimer.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    return props.children(state.nowDate, state.todayRange);\n  };\n\n  NowTimer.prototype.componentDidMount = function () {\n    this.setTimeout();\n  };\n\n  NowTimer.prototype.componentDidUpdate = function (prevProps) {\n    if (prevProps.unit !== this.props.unit) {\n      this.clearTimeout();\n      this.setTimeout();\n    }\n  };\n\n  NowTimer.prototype.componentWillUnmount = function () {\n    this.clearTimeout();\n  };\n\n  NowTimer.prototype.computeTiming = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n    var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n    var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n    var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf(); // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n    // ensure no longer than a day\n\n    waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n    return {\n      currentState: {\n        nowDate: currentUnitStart,\n        todayRange: buildDayRange(currentUnitStart)\n      },\n      nextState: {\n        nowDate: nextUnitStart,\n        todayRange: buildDayRange(nextUnitStart)\n      },\n      waitMs: waitMs\n    };\n  };\n\n  NowTimer.prototype.setTimeout = function () {\n    var _this = this;\n\n    var _a = this.computeTiming(),\n        nextState = _a.nextState,\n        waitMs = _a.waitMs;\n\n    this.timeoutId = setTimeout(function () {\n      _this.setState(nextState, function () {\n        _this.setTimeout();\n      });\n    }, waitMs);\n  };\n\n  NowTimer.prototype.clearTimeout = function () {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n    }\n  };\n\n  NowTimer.contextType = ViewContextType;\n  return NowTimer;\n}(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Component);\n\nfunction buildDayRange(date) {\n  var start = startOfDay(date);\n  var end = addDays(start, 1);\n  return {\n    start: start,\n    end: end\n  };\n}\n\nvar DayHeader = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayHeader, _super);\n\n  function DayHeader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n    return _this;\n  }\n\n  DayHeader.prototype.render = function () {\n    var context = this.context;\n    var _a = this.props,\n        dates = _a.dates,\n        dateProfile = _a.dateProfile,\n        datesRepDistinctDays = _a.datesRepDistinctDays,\n        renderIntro = _a.renderIntro;\n    var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(NowTimer, {\n      unit: \"day\"\n    }, function (nowDate, todayRange) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", null, renderIntro && renderIntro('day'), dates.map(function (date) {\n        return datesRepDistinctDays ? (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableDateCell, {\n          key: date.toISOString(),\n          date: date,\n          dateProfile: dateProfile,\n          todayRange: todayRange,\n          colCnt: dates.length,\n          dayHeaderFormat: dayHeaderFormat\n        }) : (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableDowCell, {\n          key: date.getUTCDay(),\n          dow: date.getUTCDay(),\n          dayHeaderFormat: dayHeaderFormat\n        });\n      }));\n    });\n  };\n\n  return DayHeader;\n}(BaseComponent);\n\nfunction createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n}\n\nvar DaySeriesModel = function () {\n  function DaySeriesModel(range, dateProfileGenerator) {\n    var date = range.start;\n    var end = range.end;\n    var indices = [];\n    var dates = [];\n    var dayIndex = -1;\n\n    while (date < end) {\n      // loop each day from start to end\n      if (dateProfileGenerator.isHiddenDay(date)) {\n        indices.push(dayIndex + 0.5); // mark that it's between indices\n      } else {\n        dayIndex += 1;\n        indices.push(dayIndex);\n        dates.push(date);\n      }\n\n      date = addDays(date, 1);\n    }\n\n    this.dates = dates;\n    this.indices = indices;\n    this.cnt = dates.length;\n  }\n\n  DaySeriesModel.prototype.sliceRange = function (range) {\n    var firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n\n    var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n\n    var clippedFirstIndex = Math.max(0, firstIndex);\n    var clippedLastIndex = Math.min(this.cnt - 1, lastIndex); // deal with in-between indices\n\n    clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n\n    clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n\n    if (clippedFirstIndex <= clippedLastIndex) {\n      return {\n        firstIndex: clippedFirstIndex,\n        lastIndex: clippedLastIndex,\n        isStart: firstIndex === clippedFirstIndex,\n        isEnd: lastIndex === clippedLastIndex\n      };\n    }\n\n    return null;\n  }; // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n  // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n  // If before the first offset, returns a negative number.\n  // If after the last offset, returns an offset past the last cell offset.\n  // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n\n\n  DaySeriesModel.prototype.getDateDayIndex = function (date) {\n    var indices = this.indices;\n    var dayOffset = Math.floor(diffDays(this.dates[0], date));\n\n    if (dayOffset < 0) {\n      return indices[0] - 1;\n    }\n\n    if (dayOffset >= indices.length) {\n      return indices[indices.length - 1] + 1;\n    }\n\n    return indices[dayOffset];\n  };\n\n  return DaySeriesModel;\n}();\n\nvar DayTableModel = function () {\n  function DayTableModel(daySeries, breakOnWeeks) {\n    var dates = daySeries.dates;\n    var daysPerRow;\n    var firstDay;\n    var rowCnt;\n\n    if (breakOnWeeks) {\n      // count columns until the day-of-week repeats\n      firstDay = dates[0].getUTCDay();\n\n      for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {\n        if (dates[daysPerRow].getUTCDay() === firstDay) {\n          break;\n        }\n      }\n\n      rowCnt = Math.ceil(dates.length / daysPerRow);\n    } else {\n      rowCnt = 1;\n      daysPerRow = dates.length;\n    }\n\n    this.rowCnt = rowCnt;\n    this.colCnt = daysPerRow;\n    this.daySeries = daySeries;\n    this.cells = this.buildCells();\n    this.headerDates = this.buildHeaderDates();\n  }\n\n  DayTableModel.prototype.buildCells = function () {\n    var rows = [];\n\n    for (var row = 0; row < this.rowCnt; row += 1) {\n      var cells = [];\n\n      for (var col = 0; col < this.colCnt; col += 1) {\n        cells.push(this.buildCell(row, col));\n      }\n\n      rows.push(cells);\n    }\n\n    return rows;\n  };\n\n  DayTableModel.prototype.buildCell = function (row, col) {\n    var date = this.daySeries.dates[row * this.colCnt + col];\n    return {\n      key: date.toISOString(),\n      date: date\n    };\n  };\n\n  DayTableModel.prototype.buildHeaderDates = function () {\n    var dates = [];\n\n    for (var col = 0; col < this.colCnt; col += 1) {\n      dates.push(this.cells[0][col].date);\n    }\n\n    return dates;\n  };\n\n  DayTableModel.prototype.sliceRange = function (range) {\n    var colCnt = this.colCnt;\n    var seriesSeg = this.daySeries.sliceRange(range);\n    var segs = [];\n\n    if (seriesSeg) {\n      var firstIndex = seriesSeg.firstIndex,\n          lastIndex = seriesSeg.lastIndex;\n      var index = firstIndex;\n\n      while (index <= lastIndex) {\n        var row = Math.floor(index / colCnt);\n        var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n        segs.push({\n          row: row,\n          firstCol: index % colCnt,\n          lastCol: (nextIndex - 1) % colCnt,\n          isStart: seriesSeg.isStart && index === firstIndex,\n          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n        });\n        index = nextIndex;\n      }\n    }\n\n    return segs;\n  };\n\n  return DayTableModel;\n}();\n\nvar Slicer = function () {\n  function Slicer() {\n    this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n    this.sliceDateSelection = memoize(this._sliceDateSpan);\n    this.sliceEventStore = memoize(this._sliceEventStore);\n    this.sliceEventDrag = memoize(this._sliceInteraction);\n    this.sliceEventResize = memoize(this._sliceInteraction);\n    this.forceDayIfListItem = false; // hack\n  }\n\n  Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, context) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    var eventUiBases = props.eventUiBases;\n    var eventSegs = this.sliceEventStore.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([props.eventStore, eventUiBases, dateProfile, nextDayThreshold], extraArgs));\n    return {\n      dateSelectionSegs: this.sliceDateSelection.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([props.dateSelection, eventUiBases, context], extraArgs)),\n      businessHourSegs: this.sliceBusinessHours.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([props.businessHours, dateProfile, nextDayThreshold, context], extraArgs)),\n      fgEventSegs: eventSegs.fg,\n      bgEventSegs: eventSegs.bg,\n      eventDrag: this.sliceEventDrag.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([props.eventDrag, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),\n      eventResize: this.sliceEventResize.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([props.eventResize, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),\n      eventSelection: props.eventSelection\n    }; // TODO: give interactionSegs?\n  };\n\n  Slicer.prototype.sliceNowDate = function ( // does not memoize\n  date, context) {\n    var extraArgs = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      extraArgs[_i - 2] = arguments[_i];\n    }\n\n    return this._sliceDateSpan.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([{\n      range: {\n        start: date,\n        end: addMs(date, 1)\n      },\n      allDay: false\n    }, {}, context], extraArgs));\n  };\n\n  Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, context) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (!businessHours) {\n      return [];\n    }\n\n    return this._sliceEventStore.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold], extraArgs)).bg;\n  };\n\n  Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (eventStore) {\n      var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n      return {\n        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n      };\n    }\n\n    return {\n      bg: [],\n      fg: []\n    };\n  };\n\n  Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (!interaction) {\n      return null;\n    }\n\n    var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n    return {\n      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n      affectedInstances: interaction.affectedEvents.instances,\n      isEvent: interaction.isEvent\n    };\n  };\n\n  Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, context) {\n    var extraArgs = [];\n\n    for (var _i = 3; _i < arguments.length; _i++) {\n      extraArgs[_i - 3] = arguments[_i];\n    }\n\n    if (!dateSpan) {\n      return [];\n    }\n\n    var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n    var segs = this.sliceRange.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([dateSpan.range], extraArgs));\n\n    for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {\n      var seg = segs_1[_a];\n      seg.eventRange = eventRange;\n    }\n\n    return segs;\n  };\n  /*\n  \"complete\" seg means it has component and eventRange\n  */\n\n\n  Slicer.prototype.sliceEventRanges = function (eventRanges, extraArgs) {\n    var segs = [];\n\n    for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {\n      var eventRange = eventRanges_1[_i];\n      segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));\n    }\n\n    return segs;\n  };\n  /*\n  \"complete\" seg means it has component and eventRange\n  */\n\n\n  Slicer.prototype.sliceEventRange = function (eventRange, extraArgs) {\n    var dateRange = eventRange.range; // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n\n    if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {\n      dateRange = {\n        start: dateRange.start,\n        end: addDays(dateRange.start, 1)\n      };\n    }\n\n    var segs = this.sliceRange.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([dateRange], extraArgs));\n\n    for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n      var seg = segs_2[_i];\n      seg.eventRange = eventRange;\n      seg.isStart = eventRange.isStart && seg.isStart;\n      seg.isEnd = eventRange.isEnd && seg.isEnd;\n    }\n\n    return segs;\n  };\n\n  return Slicer;\n}();\n/*\nfor incorporating slotMinTime/slotMaxTime if appropriate\nTODO: should be part of DateProfile!\nTimelineDateProfile already does this btw\n*/\n\n\nfunction computeActiveRange(dateProfile, isComponentAllDay) {\n  var range = dateProfile.activeRange;\n\n  if (isComponentAllDay) {\n    return range;\n  }\n\n  return {\n    start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n    end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5) // 864e5 = ms in a day\n\n  };\n} // high-level segmenting-aware tester functions\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isInteractionValid(interaction, dateProfile, context) {\n  var instances = interaction.mutatedEvents.instances;\n\n  for (var instanceId in instances) {\n    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n      return false;\n    }\n  }\n\n  return isNewPropsValid({\n    eventDrag: interaction\n  }, context); // HACK: the eventDrag props is used for ALL interactions\n}\n\nfunction isDateSelectionValid(dateSelection, dateProfile, context) {\n  if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n    return false;\n  }\n\n  return isNewPropsValid({\n    dateSelection: dateSelection\n  }, context);\n}\n\nfunction isNewPropsValid(newProps, context) {\n  var calendarState = context.getCurrentData();\n\n  var props = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n    businessHours: calendarState.businessHours,\n    dateSelection: '',\n    eventStore: calendarState.eventStore,\n    eventUiBases: calendarState.eventUiBases,\n    eventSelection: '',\n    eventDrag: null,\n    eventResize: null\n  }, newProps);\n\n  return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n}\n\nfunction isPropsValid(state, context, dateSpanMeta, filterConfig) {\n  if (dateSpanMeta === void 0) {\n    dateSpanMeta = {};\n  }\n\n  if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n    return false;\n  }\n\n  if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n    return false;\n  }\n\n  return true;\n} // Moving Event Validation\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n  var currentState = context.getCurrentData();\n  var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n\n  var subjectEventStore = interaction.mutatedEvents;\n  var subjectDefs = subjectEventStore.defs;\n  var subjectInstances = subjectEventStore.instances;\n  var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n    '': currentState.selectionConfig\n  });\n\n  if (filterConfig) {\n    subjectConfigs = mapHash(subjectConfigs, filterConfig);\n  } // exclude the subject events. TODO: exclude defs too?\n\n\n  var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n  var otherDefs = otherEventStore.defs;\n  var otherInstances = otherEventStore.instances;\n  var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n\n  for (var subjectInstanceId in subjectInstances) {\n    var subjectInstance = subjectInstances[subjectInstanceId];\n    var subjectRange = subjectInstance.range;\n    var subjectConfig = subjectConfigs[subjectInstance.defId];\n    var subjectDef = subjectDefs[subjectInstance.defId]; // constraint\n\n    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n      return false;\n    } // overlap\n\n\n    var eventOverlap = context.options.eventOverlap;\n    var eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;\n\n    for (var otherInstanceId in otherInstances) {\n      var otherInstance = otherInstances[otherInstanceId]; // intersect! evaluate\n\n      if (rangesIntersect(subjectRange, otherInstance.range)) {\n        var otherOverlap = otherConfigs[otherInstance.defId].overlap; // consider the other event's overlap. only do this if the subject event is a \"real\" event\n\n        if (otherOverlap === false && interaction.isEvent) {\n          return false;\n        }\n\n        if (subjectConfig.overlap === false) {\n          return false;\n        }\n\n        if (eventOverlapFunc && !eventOverlapFunc(new EventApi(context, otherDefs[otherInstance.defId], otherInstance), // still event\n        new EventApi(context, subjectDef, subjectInstance))) {\n          return false;\n        }\n      }\n    } // allow (a function)\n\n\n    var calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n\n    for (var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++) {\n      var subjectAllow = _a[_i];\n\n      var subjectDateSpan = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, dateSpanMeta), {\n        range: subjectInstance.range,\n        allDay: subjectDef.allDay\n      });\n\n      var origDef = calendarEventStore.defs[subjectDef.defId];\n      var origInstance = calendarEventStore.instances[subjectInstanceId];\n      var eventApi = void 0;\n\n      if (origDef) {\n        // was previously in the calendar\n        eventApi = new EventApi(context, origDef, origInstance);\n      } else {\n        // was an external event\n        eventApi = new EventApi(context, subjectDef); // no instance, because had no dates\n      }\n\n      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n} // Date Selection Validation\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n  var relevantEventStore = state.eventStore;\n  var relevantDefs = relevantEventStore.defs;\n  var relevantInstances = relevantEventStore.instances;\n  var selection = state.dateSelection;\n  var selectionRange = selection.range;\n  var selectionConfig = context.getCurrentData().selectionConfig;\n\n  if (filterConfig) {\n    selectionConfig = filterConfig(selectionConfig);\n  } // constraint\n\n\n  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n    return false;\n  } // overlap\n\n\n  var selectOverlap = context.options.selectOverlap;\n  var selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;\n\n  for (var relevantInstanceId in relevantInstances) {\n    var relevantInstance = relevantInstances[relevantInstanceId]; // intersect! evaluate\n\n    if (rangesIntersect(selectionRange, relevantInstance.range)) {\n      if (selectionConfig.overlap === false) {\n        return false;\n      }\n\n      if (selectOverlapFunc && !selectOverlapFunc(new EventApi(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n        return false;\n      }\n    }\n  } // allow (a function)\n\n\n  for (var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++) {\n    var selectionAllow = _a[_i];\n\n    var fullDateSpan = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, dateSpanMeta), selection);\n\n    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n      return false;\n    }\n  }\n\n  return true;\n} // Constraint Utils\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n  for (var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++) {\n    var constraint = constraints_1[_i];\n\n    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours\notherEventStore, // for if constraint is an even group ID\nbusinessHoursUnexpanded, // for if constraint is 'businessHours'\ncontext) {\n  if (constraint === 'businessHours') {\n    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n  }\n\n  if (typeof constraint === 'string') {\n    // an group ID\n    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function (eventDef) {\n      return eventDef.groupId === constraint;\n    }));\n  }\n\n  if (typeof constraint === 'object' && constraint) {\n    // non-null object\n    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n  }\n\n  return []; // if it's false\n} // TODO: move to event-store file?\n\n\nfunction eventStoreToRanges(eventStore) {\n  var instances = eventStore.instances;\n  var ranges = [];\n\n  for (var instanceId in instances) {\n    ranges.push(instances[instanceId].range);\n  }\n\n  return ranges;\n} // TODO: move to geom file?\n\n\nfunction anyRangesContainRange(outerRanges, innerRange) {\n  for (var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++) {\n    var outerRange = outerRanges_1[_i];\n\n    if (rangeContainsRange(outerRange, innerRange)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\n\nvar Scroller = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Scroller, _super);\n\n  function Scroller() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleEl = function (el) {\n      _this.el = el;\n      setRef(_this.props.elRef, el);\n    };\n\n    return _this;\n  }\n\n  Scroller.prototype.render = function () {\n    var props = this.props;\n    var liquid = props.liquid,\n        liquidIsAbsolute = props.liquidIsAbsolute;\n    var isAbsolute = liquid && liquidIsAbsolute;\n    var className = ['fc-scroller'];\n\n    if (liquid) {\n      if (liquidIsAbsolute) {\n        className.push('fc-scroller-liquid-absolute');\n      } else {\n        className.push('fc-scroller-liquid');\n      }\n    }\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      ref: this.handleEl,\n      className: className.join(' '),\n      style: {\n        overflowX: props.overflowX,\n        overflowY: props.overflowY,\n        left: isAbsolute && -(props.overcomeLeft || 0) || '',\n        right: isAbsolute && -(props.overcomeRight || 0) || '',\n        bottom: isAbsolute && -(props.overcomeBottom || 0) || '',\n        marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || '',\n        marginRight: !isAbsolute && -(props.overcomeRight || 0) || '',\n        marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || '',\n        maxHeight: props.maxHeight || ''\n      }\n    }, props.children);\n  };\n\n  Scroller.prototype.needsXScrolling = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n      return false;\n    } // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n    // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n    // inner-child margins and absolute positioning\n\n\n    var el = this.el;\n    var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n    var children = el.children;\n\n    for (var i = 0; i < children.length; i += 1) {\n      var childEl = children[i];\n\n      if (childEl.getBoundingClientRect().width > realClientWidth) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Scroller.prototype.needsYScrolling = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n      return false;\n    } // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n    // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n    // inner-child margins and absolute positioning\n\n\n    var el = this.el;\n    var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n    var children = el.children;\n\n    for (var i = 0; i < children.length; i += 1) {\n      var childEl = children[i];\n\n      if (childEl.getBoundingClientRect().height > realClientHeight) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Scroller.prototype.getXScrollbarWidth = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n      return 0;\n    }\n\n    return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n  };\n\n  Scroller.prototype.getYScrollbarWidth = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n      return 0;\n    }\n\n    return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n  };\n\n  return Scroller;\n}(BaseComponent);\n/*\nTODO: somehow infer OtherArgs from masterCallback?\nTODO: infer RefType from masterCallback if provided\n*/\n\n\nvar RefMap = function () {\n  function RefMap(masterCallback) {\n    var _this = this;\n\n    this.masterCallback = masterCallback;\n    this.currentMap = {};\n    this.depths = {};\n    this.callbackMap = {};\n\n    this.handleValue = function (val, key) {\n      var _a = _this,\n          depths = _a.depths,\n          currentMap = _a.currentMap;\n      var removed = false;\n      var added = false;\n\n      if (val !== null) {\n        // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n        removed = key in currentMap;\n        currentMap[key] = val;\n        depths[key] = (depths[key] || 0) + 1;\n        added = true;\n      } else {\n        depths[key] -= 1;\n\n        if (!depths[key]) {\n          delete currentMap[key];\n          delete _this.callbackMap[key];\n          removed = true;\n        }\n      }\n\n      if (_this.masterCallback) {\n        if (removed) {\n          _this.masterCallback(null, String(key));\n        }\n\n        if (added) {\n          _this.masterCallback(val, String(key));\n        }\n      }\n    };\n  }\n\n  RefMap.prototype.createRef = function (key) {\n    var _this = this;\n\n    var refCallback = this.callbackMap[key];\n\n    if (!refCallback) {\n      refCallback = this.callbackMap[key] = function (val) {\n        _this.handleValue(val, String(key));\n      };\n    }\n\n    return refCallback;\n  }; // TODO: check callers that don't care about order. should use getAll instead\n  // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n  // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n\n\n  RefMap.prototype.collect = function (startIndex, endIndex, step) {\n    return collectFromHash(this.currentMap, startIndex, endIndex, step);\n  };\n\n  RefMap.prototype.getAll = function () {\n    return hashValuesToArray(this.currentMap);\n  };\n\n  return RefMap;\n}();\n\nfunction computeShrinkWidth(chunkEls) {\n  var shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');\n  var largestWidth = 0;\n\n  for (var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++) {\n    var shrinkCell = shrinkCells_1[_i];\n    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n  }\n\n  return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n}\n\nfunction getSectionHasLiquidHeight(props, sectionConfig) {\n  return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n}\n\nfunction getAllowYScrolling(props, sectionConfig) {\n  return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n  getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n} // TODO: ONLY use `arg`. force out internal function to use same API\n\n\nfunction renderChunkContent(sectionConfig, chunkConfig, arg) {\n  var expandRows = arg.expandRows;\n  var content = typeof chunkConfig.content === 'function' ? chunkConfig.content(arg) : (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)('table', {\n    className: [chunkConfig.tableClassName, sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : ''].join(' '),\n    style: {\n      minWidth: arg.tableMinWidth,\n      width: arg.clientWidth,\n      height: expandRows ? arg.clientHeight : '' // css `height` on a <table> serves as a min-height\n\n    }\n  }, arg.tableColGroupNode, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)('tbody', {}, typeof chunkConfig.rowContent === 'function' ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n  return content;\n}\n\nfunction isColPropsEqual(cols0, cols1) {\n  return isArraysEqual(cols0, cols1, isPropsEqual);\n}\n\nfunction renderMicroColGroup(cols, shrinkWidth) {\n  var colNodes = [];\n  /*\n  for ColProps with spans, it would have been great to make a single <col span=\"\">\n  HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n  SOLUTION: making individual <col> elements makes Chrome behave.\n  */\n\n  for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {\n    var colProps = cols_1[_i];\n    var span = colProps.span || 1;\n\n    for (var i = 0; i < span; i += 1) {\n      colNodes.push((0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"col\", {\n        style: {\n          width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || '',\n          minWidth: colProps.minWidth || ''\n        }\n      }));\n    }\n  }\n\n  return _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['colgroup', {}], colNodes));\n}\n\nfunction sanitizeShrinkWidth(shrinkWidth) {\n  /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n  4 accounts for 2 2-pixel borders. TODO: better solution? */\n  return shrinkWidth == null ? 4 : shrinkWidth;\n}\n\nfunction hasShrinkWidth(cols) {\n  for (var _i = 0, cols_2 = cols; _i < cols_2.length; _i++) {\n    var col = cols_2[_i];\n\n    if (col.width === 'shrink') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getScrollGridClassNames(liquid, context) {\n  var classNames = ['fc-scrollgrid', context.theme.getClass('table')];\n\n  if (liquid) {\n    classNames.push('fc-scrollgrid-liquid');\n  }\n\n  return classNames;\n}\n\nfunction getSectionClassNames(sectionConfig, wholeTableVGrow) {\n  var classNames = ['fc-scrollgrid-section', \"fc-scrollgrid-section-\" + sectionConfig.type, sectionConfig.className // used?\n  ];\n\n  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n    classNames.push('fc-scrollgrid-section-liquid');\n  }\n\n  if (sectionConfig.isSticky) {\n    classNames.push('fc-scrollgrid-section-sticky');\n  }\n\n  return classNames;\n}\n\nfunction renderScrollShim(arg) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-scrollgrid-sticky-shim\",\n    style: {\n      width: arg.clientWidth,\n      minWidth: arg.tableMinWidth\n    }\n  });\n}\n\nfunction getStickyHeaderDates(options) {\n  var stickyHeaderDates = options.stickyHeaderDates;\n\n  if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {\n    stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';\n  }\n\n  return stickyHeaderDates;\n}\n\nfunction getStickyFooterScrollbar(options) {\n  var stickyFooterScrollbar = options.stickyFooterScrollbar;\n\n  if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {\n    stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';\n  }\n\n  return stickyFooterScrollbar;\n}\n\nvar SimpleScrollGrid = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(SimpleScrollGrid, _super);\n\n  function SimpleScrollGrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.processCols = memoize(function (a) {\n      return a;\n    }, isColPropsEqual); // so we get same `cols` props every time\n    // yucky to memoize VNodes, but much more efficient for consumers\n\n    _this.renderMicroColGroup = memoize(renderMicroColGroup);\n    _this.scrollerRefs = new RefMap();\n    _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));\n    _this.state = {\n      shrinkWidth: null,\n      forceYScrollbars: false,\n      scrollerClientWidths: {},\n      scrollerClientHeights: {}\n    }; // TODO: can do a really simple print-view. dont need to join rows\n\n    _this.handleSizing = function () {\n      _this.setState((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        shrinkWidth: _this.computeShrinkWidth()\n      }, _this.computeScrollerDims()));\n    };\n\n    return _this;\n  }\n\n  SimpleScrollGrid.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var sectionConfigs = props.sections || [];\n    var cols = this.processCols(props.cols);\n    var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n    var classNames = getScrollGridClassNames(props.liquid, context);\n\n    if (props.collapsibleWidth) {\n      classNames.push('fc-scrollgrid-collapsible');\n    } // TODO: make DRY\n\n\n    var configCnt = sectionConfigs.length;\n    var configI = 0;\n    var currentConfig;\n    var headSectionNodes = [];\n    var bodySectionNodes = [];\n    var footSectionNodes = [];\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n      headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode));\n      configI += 1;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n      bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode));\n      configI += 1;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n      footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode));\n      configI += 1;\n    } // firefox bug: when setting height on table and there is a thead or tfoot,\n    // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n    // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n    // if so, use a simpler dom structure, jam everything into a lone tbody.\n\n\n    var isBuggy = !getCanVGrowWithinCell();\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)('table', {\n      className: classNames.join(' '),\n      style: {\n        height: props.height\n      }\n    }, Boolean(!isBuggy && headSectionNodes.length) && _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['thead', {}], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['tbody', {}], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['tfoot', {}], footSectionNodes)), isBuggy && _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['tbody', {}], headSectionNodes), bodySectionNodes), footSectionNodes)));\n  };\n\n  SimpleScrollGrid.prototype.renderSection = function (sectionConfig, microColGroupNode) {\n    if ('outerContent' in sectionConfig) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n        key: sectionConfig.key\n      }, sectionConfig.outerContent);\n    }\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n      key: sectionConfig.key,\n      className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')\n    }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk));\n  };\n\n  SimpleScrollGrid.prototype.renderChunkTd = function (sectionConfig, microColGroupNode, chunkConfig) {\n    if ('outerContent' in chunkConfig) {\n      return chunkConfig.outerContent;\n    }\n\n    var props = this.props;\n    var _a = this.state,\n        forceYScrollbars = _a.forceYScrollbars,\n        scrollerClientWidths = _a.scrollerClientWidths,\n        scrollerClientHeights = _a.scrollerClientHeights;\n    var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n\n    var isLiquid = getSectionHasLiquidHeight(props, sectionConfig); // for `!props.liquid` - is WHOLE scrollgrid natural height?\n    // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n\n    var overflowY = !props.liquid ? 'visible' : forceYScrollbars ? 'scroll' : !needsYScrolling ? 'hidden' : 'auto';\n    var sectionKey = sectionConfig.key;\n    var content = renderChunkContent(sectionConfig, chunkConfig, {\n      tableColGroupNode: microColGroupNode,\n      tableMinWidth: '',\n      clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,\n      clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n      expandRows: sectionConfig.expandRows,\n      syncRowHeights: false,\n      rowSyncHeights: [],\n      reportRowHeightChange: function () {}\n    });\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n      ref: chunkConfig.elRef\n    }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      className: \"fc-scroller-harness\" + (isLiquid ? ' fc-scroller-harness-liquid' : '')\n    }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Scroller, {\n      ref: this.scrollerRefs.createRef(sectionKey),\n      elRef: this.scrollerElRefs.createRef(sectionKey),\n      overflowY: overflowY,\n      overflowX: !props.liquid ? 'visible' : 'hidden'\n      /* natural height? */\n      ,\n      maxHeight: sectionConfig.maxHeight,\n      liquid: isLiquid,\n      liquidIsAbsolute // because its within a harness\n      : true\n    }, content)));\n  };\n\n  SimpleScrollGrid.prototype._handleScrollerEl = function (scrollerEl, key) {\n    var section = getSectionByKey(this.props.sections, key);\n\n    if (section) {\n      setRef(section.chunk.scrollerElRef, scrollerEl);\n    }\n  };\n\n  SimpleScrollGrid.prototype.componentDidMount = function () {\n    this.handleSizing();\n    this.context.addResizeHandler(this.handleSizing);\n  };\n\n  SimpleScrollGrid.prototype.componentDidUpdate = function () {\n    // TODO: need better solution when state contains non-sizing things\n    this.handleSizing();\n  };\n\n  SimpleScrollGrid.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleSizing);\n  };\n\n  SimpleScrollGrid.prototype.computeShrinkWidth = function () {\n    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n  };\n\n  SimpleScrollGrid.prototype.computeScrollerDims = function () {\n    var scrollbarWidth = getScrollbarWidths();\n\n    var _a = this,\n        scrollerRefs = _a.scrollerRefs,\n        scrollerElRefs = _a.scrollerElRefs;\n\n    var forceYScrollbars = false;\n    var scrollerClientWidths = {};\n    var scrollerClientHeights = {};\n\n    for (var sectionKey in scrollerRefs.currentMap) {\n      var scroller = scrollerRefs.currentMap[sectionKey];\n\n      if (scroller && scroller.needsYScrolling()) {\n        forceYScrollbars = true;\n        break;\n      }\n    }\n\n    for (var _i = 0, _b = this.props.sections; _i < _b.length; _i++) {\n      var section = _b[_i];\n      var sectionKey = section.key;\n      var scrollerEl = scrollerElRefs.currentMap[sectionKey];\n\n      if (scrollerEl) {\n        var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n\n        scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n        : 0));\n        scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n      }\n    }\n\n    return {\n      forceYScrollbars: forceYScrollbars,\n      scrollerClientWidths: scrollerClientWidths,\n      scrollerClientHeights: scrollerClientHeights\n    };\n  };\n\n  return SimpleScrollGrid;\n}(BaseComponent);\n\nSimpleScrollGrid.addStateEquality({\n  scrollerClientWidths: isPropsEqual,\n  scrollerClientHeights: isPropsEqual\n});\n\nfunction getSectionByKey(sections, key) {\n  for (var _i = 0, sections_1 = sections; _i < sections_1.length; _i++) {\n    var section = sections_1[_i];\n\n    if (section.key === key) {\n      return section;\n    }\n  }\n\n  return null;\n}\n\nvar EventRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(EventRoot, _super);\n\n  function EventRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.elRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    return _this;\n  }\n\n  EventRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var seg = props.seg;\n    var eventRange = seg.eventRange;\n    var ui = eventRange.ui;\n    var hookProps = {\n      event: new EventApi(context, eventRange.def, eventRange.instance),\n      view: context.viewApi,\n      timeText: props.timeText,\n      textColor: ui.textColor,\n      backgroundColor: ui.backgroundColor,\n      borderColor: ui.borderColor,\n      isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n      isStart: Boolean(seg.isStart),\n      isEnd: Boolean(seg.isEnd),\n      isPast: Boolean(props.isPast),\n      isFuture: Boolean(props.isFuture),\n      isToday: Boolean(props.isToday),\n      isSelected: Boolean(props.isSelected),\n      isDragging: Boolean(props.isDragging),\n      isResizing: Boolean(props.isResizing)\n    };\n    var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.eventClassNames,\n      content: options.eventContent,\n      defaultContent: props.defaultContent,\n      didMount: options.eventDidMount,\n      willUnmount: options.eventWillUnmount,\n      elRef: this.elRef\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps);\n    });\n  };\n\n  EventRoot.prototype.componentDidMount = function () {\n    setElSeg(this.elRef.current, this.props.seg);\n  };\n  /*\n  need to re-assign seg to the element if seg changes, even if the element is the same\n  */\n\n\n  EventRoot.prototype.componentDidUpdate = function (prevProps) {\n    var seg = this.props.seg;\n\n    if (seg !== prevProps.seg) {\n      setElSeg(this.elRef.current, seg);\n    }\n  };\n\n  return EventRoot;\n}(BaseComponent); // should not be a purecomponent\n\n\nvar StandardEvent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(StandardEvent, _super);\n\n  function StandardEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  StandardEvent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var seg = props.seg;\n    var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;\n    var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(EventRoot, {\n      seg: seg,\n      timeText: timeText,\n      disableDragging: props.disableDragging,\n      disableResizing: props.disableResizing,\n      defaultContent: props.defaultContent || renderInnerContent$1,\n      isDragging: props.isDragging,\n      isResizing: props.isResizing,\n      isDateSelecting: props.isDateSelecting,\n      isSelected: props.isSelected,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday\n    }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        className: props.extraClassNames.concat(classNames).join(' '),\n        style: {\n          borderColor: hookProps.borderColor,\n          backgroundColor: hookProps.backgroundColor\n        },\n        ref: rootElRef\n      }, getSegAnchorAttrs(seg)), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-main\",\n        ref: innerElRef,\n        style: {\n          color: hookProps.textColor\n        }\n      }, innerContent), hookProps.isStartResizable && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-resizer fc-event-resizer-start\"\n      }), hookProps.isEndResizable && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-resizer fc-event-resizer-end\"\n      }));\n    });\n  };\n\n  return StandardEvent;\n}(BaseComponent);\n\nfunction renderInnerContent$1(innerProps) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-main-frame\"\n  }, innerProps.timeText && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-time\"\n  }, innerProps.timeText), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-title-container\"\n  }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-title fc-sticky\"\n  }, innerProps.event.title || (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\u00A0\"))));\n}\n\nfunction getSegAnchorAttrs(seg) {\n  var url = seg.eventRange.def.url;\n  return url ? {\n    href: url\n  } : {};\n}\n\nvar NowIndicatorRoot = function (props) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Consumer, null, function (context) {\n    var options = context.options;\n    var hookProps = {\n      isAxis: props.isAxis,\n      date: context.dateEnv.toDate(props.date),\n      view: context.viewApi\n    };\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.nowIndicatorClassNames,\n      content: options.nowIndicatorContent,\n      didMount: options.nowIndicatorDidMount,\n      willUnmount: options.nowIndicatorWillUnmount\n    }, props.children);\n  });\n};\n\nvar DAY_NUM_FORMAT = createFormatter({\n  day: 'numeric'\n});\n\nvar DayCellContent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayCellContent, _super);\n\n  function DayCellContent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DayCellContent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = refineDayCellHookProps({\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraProps: props.extraHookProps,\n      viewApi: context.viewApi,\n      dateEnv: context.dateEnv\n    });\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ContentHook, {\n      hookProps: hookProps,\n      content: options.dayCellContent,\n      defaultContent: props.defaultContent\n    }, props.children);\n  };\n\n  return DayCellContent;\n}(BaseComponent);\n\nfunction refineDayCellHookProps(raw) {\n  var date = raw.date,\n      dateEnv = raw.dateEnv;\n  var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n    date: dateEnv.toDate(date),\n    view: raw.viewApi\n  }, dayMeta), {\n    dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : ''\n  }), raw.extraProps);\n}\n\nvar DayCellRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayCellRoot, _super);\n\n  function DayCellRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.refineHookProps = memoizeObjArg(refineDayCellHookProps);\n    _this.normalizeClassNames = buildClassNameNormalizer();\n    return _this;\n  }\n\n  DayCellRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = this.refineHookProps({\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraProps: props.extraHookProps,\n      viewApi: context.viewApi,\n      dateEnv: context.dateEnv\n    });\n    var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled ? [] // don't use custom classNames if disabled\n    : this.normalizeClassNames(options.dayCellClassNames, hookProps));\n    var dataAttrs = hookProps.isDisabled ? {} : {\n      'data-date': formatDayString(props.date)\n    };\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(MountHook, {\n      hookProps: hookProps,\n      didMount: options.dayCellDidMount,\n      willUnmount: options.dayCellWillUnmount,\n      elRef: props.elRef\n    }, function (rootElRef) {\n      return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled);\n    });\n  };\n\n  return DayCellRoot;\n}(BaseComponent);\n\nfunction renderFill(fillType) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-\" + fillType\n  });\n}\n\nvar BgEvent = function (props) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(EventRoot, {\n    defaultContent: renderInnerContent,\n    seg: props.seg\n    /* uselesss i think */\n    ,\n    timeText: \"\",\n    disableDragging: true,\n    disableResizing: true,\n    isDragging: false,\n    isResizing: false,\n    isDateSelecting: false,\n    isSelected: false,\n    isPast: props.isPast,\n    isFuture: props.isFuture,\n    isToday: props.isToday\n  }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      ref: rootElRef,\n      className: ['fc-bg-event'].concat(classNames).join(' '),\n      style: {\n        backgroundColor: hookProps.backgroundColor\n      }\n    }, innerContent);\n  });\n};\n\nfunction renderInnerContent(props) {\n  var title = props.event.title;\n  return title && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-title\"\n  }, props.event.title);\n}\n\nvar WeekNumberRoot = function (props) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Consumer, null, function (context) {\n    var dateEnv = context.dateEnv,\n        options = context.options;\n    var date = props.date;\n    var format = options.weekNumberFormat || props.defaultFormat;\n    var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n\n    var text = dateEnv.format(date, format);\n    var hookProps = {\n      num: num,\n      text: text,\n      date: date\n    };\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.weekNumberClassNames,\n      content: options.weekNumberContent,\n      defaultContent: renderInner,\n      didMount: options.weekNumberDidMount,\n      willUnmount: options.weekNumberWillUnmount\n    }, props.children);\n  });\n};\n\nfunction renderInner(innerProps) {\n  return innerProps.text;\n}\n\nvar PADDING_FROM_VIEWPORT = 10;\n\nvar Popover = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Popover, _super);\n\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (el) {\n      _this.rootEl = el;\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, el);\n      }\n    }; // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n\n\n    _this.handleDocumentMousedown = function (ev) {\n      // only hide the popover if the click happened outside the popover\n      var target = getEventTargetViaRoot(ev);\n\n      if (!_this.rootEl.contains(target)) {\n        _this.handleCloseClick();\n      }\n    };\n\n    _this.handleCloseClick = function () {\n      var onClose = _this.props.onClose;\n\n      if (onClose) {\n        onClose();\n      }\n    };\n\n    return _this;\n  }\n\n  Popover.prototype.render = function () {\n    var theme = this.context.theme;\n    var props = this.props;\n    var classNames = ['fc-popover', theme.getClass('popover')].concat(props.extraClassNames || []);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createPortal)((0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      className: classNames.join(' ')\n    }, props.extraAttrs, {\n      ref: this.handleRootEl\n    }), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      className: 'fc-popover-header ' + theme.getClass('popoverHeader')\n    }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n      className: \"fc-popover-title\"\n    }, props.title), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n      className: 'fc-popover-close ' + theme.getIconClass('close'),\n      onClick: this.handleCloseClick\n    })), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      className: 'fc-popover-body ' + theme.getClass('popoverContent')\n    }, props.children)), props.parentEl);\n  };\n\n  Popover.prototype.componentDidMount = function () {\n    document.addEventListener('mousedown', this.handleDocumentMousedown);\n    this.updateSize();\n  };\n\n  Popover.prototype.componentWillUnmount = function () {\n    document.removeEventListener('mousedown', this.handleDocumentMousedown);\n  };\n\n  Popover.prototype.updateSize = function () {\n    var isRtl = this.context.isRtl;\n    var _a = this.props,\n        alignmentEl = _a.alignmentEl,\n        alignGridTop = _a.alignGridTop;\n    var rootEl = this.rootEl;\n    var alignmentRect = computeClippedClientRect(alignmentEl);\n\n    if (alignmentRect) {\n      var popoverDims = rootEl.getBoundingClientRect(); // position relative to viewport\n\n      var popoverTop = alignGridTop ? elementClosest(alignmentEl, '.fc-scrollgrid').getBoundingClientRect().top : alignmentRect.top;\n      var popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left; // constrain\n\n      popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n      popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n      popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n      var origin_1 = rootEl.offsetParent.getBoundingClientRect();\n      applyStyle(rootEl, {\n        top: popoverTop - origin_1.top,\n        left: popoverLeft - origin_1.left\n      });\n    }\n  };\n\n  return Popover;\n}(BaseComponent);\n\nvar MorePopover = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(MorePopover, _super);\n\n  function MorePopover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl,\n          useEventCenter: false\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  MorePopover.prototype.render = function () {\n    var _a = this.context,\n        options = _a.options,\n        dateEnv = _a.dateEnv;\n    var props = this.props;\n    var startDate = props.startDate,\n        todayRange = props.todayRange,\n        dateProfile = props.dateProfile;\n    var title = dateEnv.format(startDate, options.dayPopoverFormat);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayCellRoot, {\n      date: startDate,\n      dateProfile: dateProfile,\n      todayRange: todayRange,\n      elRef: this.handleRootEl\n    }, function (rootElRef, dayClassNames, dataAttrs) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Popover, {\n        elRef: rootElRef,\n        title: title,\n        extraClassNames: ['fc-more-popover'].concat(dayClassNames),\n        extraAttrs: dataAttrs\n        /* TODO: make these time-based when not whole-day? */\n        ,\n        parentEl: props.parentEl,\n        alignmentEl: props.alignmentEl,\n        alignGridTop: props.alignGridTop,\n        onClose: props.onClose\n      }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayCellContent, {\n        date: startDate,\n        dateProfile: dateProfile,\n        todayRange: todayRange\n      }, function (innerElRef, innerContent) {\n        return innerContent && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n          className: \"fc-more-popover-misc\",\n          ref: innerElRef\n        }, innerContent);\n      }), props.children);\n    });\n  };\n\n  MorePopover.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    var _a = this,\n        rootEl = _a.rootEl,\n        props = _a.props;\n\n    if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {\n      return {\n        dateProfile: props.dateProfile,\n        dateSpan: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          allDay: true,\n          range: {\n            start: props.startDate,\n            end: props.endDate\n          }\n        }, props.extraDateSpan),\n        dayEl: rootEl,\n        rect: {\n          left: 0,\n          top: 0,\n          right: elWidth,\n          bottom: elHeight\n        },\n        layer: 1 // important when comparing with hits from other components\n\n      };\n    }\n\n    return null;\n  };\n\n  return MorePopover;\n}(DateComponent);\n\nvar MoreLinkRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(MoreLinkRoot, _super);\n\n  function MoreLinkRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.linkElRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    _this.state = {\n      isPopoverOpen: false\n    };\n\n    _this.handleClick = function (ev) {\n      var _a = _this,\n          props = _a.props,\n          context = _a.context;\n      var moreLinkClick = context.options.moreLinkClick;\n      var date = computeRange(props).start;\n\n      function buildPublicSeg(seg) {\n        var _a = seg.eventRange,\n            def = _a.def,\n            instance = _a.instance,\n            range = _a.range;\n        return {\n          event: new EventApi(context, def, instance),\n          start: context.dateEnv.toDate(range.start),\n          end: context.dateEnv.toDate(range.end),\n          isStart: seg.isStart,\n          isEnd: seg.isEnd\n        };\n      }\n\n      if (typeof moreLinkClick === 'function') {\n        moreLinkClick = moreLinkClick({\n          date: date,\n          allDay: Boolean(props.allDayDate),\n          allSegs: props.allSegs.map(buildPublicSeg),\n          hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n          jsEvent: ev,\n          view: context.viewApi\n        });\n      }\n\n      if (!moreLinkClick || moreLinkClick === 'popover') {\n        _this.setState({\n          isPopoverOpen: true\n        });\n      } else if (typeof moreLinkClick === 'string') {\n        // a view name\n        context.calendarApi.zoomTo(date, moreLinkClick);\n      }\n    };\n\n    _this.handlePopoverClose = function () {\n      _this.setState({\n        isPopoverOpen: false\n      });\n    };\n\n    return _this;\n  }\n\n  MoreLinkRoot.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Consumer, null, function (context) {\n      var viewApi = context.viewApi,\n          options = context.options,\n          calendarApi = context.calendarApi;\n      var moreLinkText = options.moreLinkText;\n      var moreCnt = props.moreCnt;\n      var range = computeRange(props);\n      var hookProps = {\n        num: moreCnt,\n        shortText: \"+\" + moreCnt,\n        text: typeof moreLinkText === 'function' ? moreLinkText.call(calendarApi, moreCnt) : \"+\" + moreCnt + \" \" + moreLinkText,\n        view: viewApi\n      };\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, Boolean(props.moreCnt) && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n        elRef: _this.linkElRef,\n        hookProps: hookProps,\n        classNames: options.moreLinkClassNames,\n        content: options.moreLinkContent,\n        defaultContent: props.defaultContent || renderMoreLinkInner,\n        didMount: options.moreLinkDidMount,\n        willUnmount: options.moreLinkWillUnmount\n      }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n        return props.children(rootElRef, ['fc-more-link'].concat(customClassNames), innerElRef, innerContent, _this.handleClick);\n      }), _this.state.isPopoverOpen && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(MorePopover, {\n        startDate: range.start,\n        endDate: range.end,\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        extraDateSpan: props.extraDateSpan,\n        parentEl: _this.parentEl,\n        alignmentEl: props.alignmentElRef.current,\n        alignGridTop: props.alignGridTop,\n        onClose: _this.handlePopoverClose\n      }, props.popoverContent()));\n    });\n  };\n\n  MoreLinkRoot.prototype.componentDidMount = function () {\n    this.updateParentEl();\n  };\n\n  MoreLinkRoot.prototype.componentDidUpdate = function () {\n    this.updateParentEl();\n  };\n\n  MoreLinkRoot.prototype.updateParentEl = function () {\n    if (this.linkElRef.current) {\n      this.parentEl = elementClosest(this.linkElRef.current, '.fc-view-harness');\n    }\n  };\n\n  return MoreLinkRoot;\n}(BaseComponent);\n\nfunction renderMoreLinkInner(props) {\n  return props.text;\n}\n\nfunction computeRange(props) {\n  if (props.allDayDate) {\n    return {\n      start: props.allDayDate,\n      end: addDays(props.allDayDate, 1)\n    };\n  }\n\n  var hiddenSegs = props.hiddenSegs;\n  return {\n    start: computeEarliestSegStart(hiddenSegs),\n    end: computeLatestSegEnd(hiddenSegs)\n  };\n}\n\nfunction computeEarliestSegStart(segs) {\n  return segs.reduce(pickEarliestStart).eventRange.range.start;\n}\n\nfunction pickEarliestStart(seg0, seg1) {\n  return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n}\n\nfunction computeLatestSegEnd(segs) {\n  return segs.reduce(pickLatestEnd).eventRange.range.end;\n}\n\nfunction pickLatestEnd(seg0, seg1) {\n  return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n} // exports\n// --------------------------------------------------------------------------------------------------\n\n\nvar version = '5.9.0'; // important to type it, so .d.ts has generic string\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUZBOztBQUFBO0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBRkE7O0FBQUE7QUFHQTtBQUFBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTs7O0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQzNHQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFNQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUVBOztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUdBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFjQTs7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUM3S0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBS0E7O0FBRUE7QUFDQTtBQU1BOztBQUVBO0FBQ0E7QUFPQTs7QUFFQTtBQUNBO0FBUUE7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFHQTtBQUVBO0FBQ0E7OztBQUlBO0FBQ0E7QUFTQTs7QUFFQTtBQUNBO0FBSUE7QUFJQTs7QUFFQTtBQUNBO0FBU0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBOztBQzFNQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7O0FDMUJBO0FBR0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQVNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQ3pMQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBOzs7QUFJQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTs7QUFFQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQUZBOztBQVFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQ3hGQTtBQUNBOztBQUlBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFIQTtBQUpBO0FBV0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQVBBO0FBV0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBSUE7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBOzs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7OztBQzdOQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBR0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQ2xEQTtBQUtBO0FBQ0E7QUFFQTtBQUFBOztBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7O0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTs7QUFLQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBWUE7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFVQTtBQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBTUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQVpBO0FBY0E7O0FBQ0E7QUFBQTs7QUFFQTtBQUtBOztBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBT0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBS0E7O0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBSUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDMVZBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTs7QUNwQkE7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FDNUJBOzs7O0FBSUE7Ozs7OztBQUlBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUNwQkE7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBOztBQ1pBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FDeUJBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcExBO0FBa01BOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxEQTtBQTJEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQWtDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBeUJBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBOEJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBaUNBO0FBQ0E7QUFDQTs7QUM5Y0E7QUFNQTtBQUNBOztBQUVBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQUE7QUFBQTs7O0FBSUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQ05BO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7O0FBcUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVZBO0FBWUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBT0E7QUFHQTtBQURBOztBQTJCQTtBQUtBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTs7QUFPQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7O0FBaUJBO0FBQUE7O0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUNsT0E7O0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBR0E7O0FBRUE7QUFDQTs7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBO0FBR0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FDaEhBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOzs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTs7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBS0E7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUNBO0FBQ0E7O0FBREE7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBOztBQ3ZSQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBTEE7QUFRQTs7QUFFQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBREE7QUFHQTs7QUFFQTtBQUNBO0FBRUE7QUFEQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSkE7QUFNQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTs7QUNsSkE7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUlBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBR0E7OztBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUN0REE7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBSUE7QUFDQTs7OztBQUtBO0FBS0E7QUFDQTs7QUFFQTtBQUdBO0FBREE7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUM3SUE7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRkE7O0FBQUE7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUZBOztBQUFBO0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBRkE7O0FBQUE7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUZBOztBQUFBO0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7QUFBQTs7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQVZBOztBQWtDQTtBQUdBO0FBQUE7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDRkE7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFBQTs7QUFBQTtBQUFBOzs7QUFDQTtBQUNBOzs7O0FBS0E7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFFQTtBQUlBOzs7QUFHQTtBQUNBO0FBRUE7QUFNQTs7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFHQTtBQUFBOztBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRkE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBUkE7QUFVQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7Ozs7QUNyZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBREE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBREE7QUFlQTtBQUVBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBVEE7QUFXQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBUkE7QUFVQTs7QUFFQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBOztBQUNBO0FBQ0E7QUFWQTs7QUFBQTtBQVlBO0FBQUE7QUFDQTtBQUdBO0FBSkE7O0FBQUE7QUFNQTtBQUFBO0FBQ0E7QUFHQTtBQUpBOztBQUFBO0FBTUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFDQTtBQUNBO0FBVEE7O0FBQUE7QUFXQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUNBO0FBQ0E7QUFUQTs7QUFBQTtBQWFBOzs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUdBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBOztBQUVBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFNQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQ3hiQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBOztBQUVBO0FDeENBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFVQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTs7QUFFQTtBQUNBOzs7QUNjQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7O0FBRUE7QUFLQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUlBO0FBRUE7O0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFLQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFRQTs7QUFFQTtBQUlBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBRkE7QUFPQTtBQUNBO0FBRkE7QUFTQTs7Ozs7OztBQU1BO0FBQUE7QUFBQTtBQUFBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBOztBQUNBO0FBQUE7O0FDcmNBO0FDd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBdEJBOztBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQURBOztBQUlBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBS0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BOztBQ2pHQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQURBO0FBR0E7O0FBRUE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQURBO0FBR0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU5BO0FBU0E7Ozs7QUFHQTtBQUNBO0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTs7QUNwQ0E7QUFDQTtBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQ2xFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFzSUE7O0FBaElBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBTUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7O0FBRUE7QUFDQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUM1RUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUNOQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FDZkE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7O0FBVUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQ2xJQTtBQUNBO0FBQ0E7OztBQUNBOzs7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZCQTtBQUNBO0FBSUE7QUFnQ0E7O0FBOUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeERBOzs7Ozs7OztBQWdCQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FDckdBOztBQUVBOzs7Ozs7OztBQUtBOztBQVVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7O0FBRUE7O0FBR0E7QUFBQTs7QUFFQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBdkNBOzs7QUF5Q0E7O0FBQUE7O0FBZ0NBOztBQS9CQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBaENBOzs7QUMvRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQ3hFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXdCQTtBQUNBOztBQUNBO0FBQ0E7O0FBekJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7O0FDbkNBOztBQXFCQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQTVCQTtBQThCQTtBQ3BGQTs7O0FBUUE7QUFBQTs7QUFBQTs7QUFvQkE7O0FBVEE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBRUE7O0FBbEJBO0FBQ0E7QUFDQTtBQWlCQTtBQUFBOztBQUVBO0FBQ0E7OztBQUVBOztBQUFBOztBQUlBOztBQUhBO0FBR0E7QUFBQTs7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUMvQkE7Ozs7Ozs7Ozs7QUFPQTs7QUFBQTtBQUFBOztBQUNBOztBQTJCQTs7OztBQXRCQTs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUE1QkE7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5DQTtBQXFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQ0E7O0FBb0NBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakNBO0FBbUNBOztBQ3hKQTtBQUFBOztBQUFBOztBQUNBOztBQUFBO0FBREE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7O0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBTUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBTUE7QUFDQTs7QUFFQTtBQUFBO0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBUEE7QUFZQTtBQ2hHQTtBQW9DQTs7OztBQUNBOztBQUFBO0FBQUE7O0FBQ0E7O0FBc0JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOztBQTNCQTtBQUFBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBRUE7QUFHQTs7QUFTQTtBQTlCQTtBQTRDQTs7O0FBQ0E7O0FBaUJBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUdBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTs7QUFDQTs7QUFnR0E7O0FBdkZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7QUFqR0E7OztBQTJHQTs7QUFBQTtBQUFBOztBQXVCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7QUEzQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQVNBO0FBOUJBOztBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUNyUUE7O0FBQUE7QUFBQTs7QUFDQTs7QUFzQkE7O0FBcEJBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUdBO0FBR0E7O0FBQ0E7QUF2QkE7O0FDV0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFRQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBREE7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFHQTtBQUVBO0FBRUE7QUFDQTs7QUM1REE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQU9BO0FBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFFQTs7QUFkQTtBQW9CQTs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQ2pFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFDQTs7Ozs7QUFLQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUVBOzs7QUFHQTs7O0FBSUE7O0FBR0E7QUFFQTs7O0FBSUE7OztBQUlBOztBQUdBOztBQUdBO0FBRUE7O0FBR0E7O0FBL0JBO0FBa0NBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7QUFFQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFHQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUM1YkE7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBOztBQ1BBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FDTEE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQW5CQTs7QUFzQkE7QUFDQTs7QUN6QkE7QUFDQTtBQUVBO0FBTUE7O0FBRUE7QUFNQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBR0E7O0FBT0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQW5DQTtBQXFDQTs7QUFFQTtBQUNBOztBQUVBO0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFNQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUVBOztBQUVBO0FBT0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBR0E7QUFFQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTs7O0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBSUE7QUFDQTtBQUZBO0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FDdFBBO0FBT0E7QUFDQTtBQUFBO0FBQ0E7O0FBU0E7QUFBQTtBQUNBO0FBR0E7O0FBSUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQWpEQTtBQW1EQTs7QUFFQTtBQVFBO0FBRUE7QUFGQTtBQUlBOztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUlBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQU5BO0FBUUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBSUE7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQVJBO0FBVUE7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBUkE7QUFVQTs7QUNWQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBO0FBZEE7QUFnQkE7O0FDbkJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFkQTtBQWdCQTs7QUNmQTtBQU9BO0FBQ0E7QUFTQTtBQVVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQVNBO0FBRUE7QUFBQTtBQUVBO0FBRUE7Ozs7O0FBR0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBSUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOztBQy9HQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFkQTtBQWlCQTtBQUNBO0FBREE7QUNGQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFwQkE7QUF3QkE7QUFDQTtBQURBOztBQ3pDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUNnQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQTlCQTtBQWtDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FDbUJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFIQTtBQUtBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7QUFNQTs7QUFDQTtBQUNBO0FBOUNBO0FBa0RBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFEQTtBQVNBOzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUVBO0FBREE7QUFHQTs7QUNxQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQ3pCQTs7Ozs7O0FBSUE7QUFPQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQVJBOztBQWVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUMvQ0E7QUFDQTtBQU5BO0FBQ0E7QUFDQTtBQUNBO0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7O0FDeEZBO0FBS0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7O0FDOUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFHQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFLQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7OztBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQ0tBOzs7O0FBZ0NBO0FBQUE7O0FBN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbUZBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUNBOztBQXBGQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7OztBQVNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTs7QUFXQTtBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTs7QUFnQkE7O0FBRUE7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFRQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBREE7QUFHQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFNQTtBQUNBOzs7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFVQTtBQUFBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTs7QUFFQTtBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTs7QUFnQkE7O0FBRUE7QUFBQTs7QUFDQTs7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFFQTtBQU1BOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQVdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUlBO0FBRUE7QUFXQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFPQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBOztBQUVBO0FBTUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQU9BOztBQVFBOztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUNBO0FBQUE7O0FBRUE7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVhBO0FBZ0JBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFuQkE7QUEyQkE7O0FBRUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7Ozs7QUNucEJBOztBQUdBO0FBQUE7O0FBVUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZEE7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFLQTs7QUFXQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBakNBOztBQ1dBOzs7Ozs7QUFJQTtBQUlBO0FBTUE7OztBQ2xDQTtBQUNBO0FBQ0E7O0FBS0E7QUFBQTs7O0FDcUJBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTtBQStLQTs7QUE3S0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFIQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFIQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSEE7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTs7O0FBR0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFLQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQUE7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBRUE7OztBQUNBO0FBR0E7OztBQUdBO0FDL0NBOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBOztBQUVBOztBQU1BO0FBRUE7O0FBRUE7QUFFQTs7QUFFQTtBQUVBOztBQUNBO0FBQUE7QUN0Q0E7OztBQUNBO0FDQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQW1CQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BOztBQ3JCQTtBQUFBOztBQUFBOztBQXVEQTs7QUF0REE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUFBO0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQXZEQTs7QUNOQTtBQUFBOztBQUFBOztBQW9EQTs7QUFuREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBTUE7QUFDQTtBQUFBO0FBTUE7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVVBOztBQUNBO0FBcERBOzs7QUNRQTtBQUFBOztBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQURBOztBQW1EQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQVVBOztBQWpFQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUVBO0FBRUE7QUFGQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSkE7QUFTQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQVlBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQXhFQTtBQ0pBOzs7OztBQUdBO0FBQUE7O0FBQ0E7QUFBQTs7QUFXQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOzs7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQVJBOztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBckNBO0FBSUE7O0FBRUE7O0FBZ0NBO0FBMUNBO0FDSkE7Ozs7OztBQUlBO0FBQUE7O0FBS0E7QUFBQTs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBL0JBO0FBR0E7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQXVCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7O0FBQ0E7QUEzREE7OztBQ2lCQTs7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUEwTEE7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7OztBQUNBOzs7Ozs7QUE5TkE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQU1BO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQWdCQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFIQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFXQTtBQUNBO0FBQ0E7QUFIQTtBQVNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFhQTs7QUFFQTtBQUFBOztBQUNBO0FBSUE7O0FBRUE7QUFFQTtBQUdBOztBQStDQTtBQTNPQTs7QUE2T0E7O0FBU0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFHQTs7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FDdlJBOztBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQURBOztBQXNDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUNBOztBQXpDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBU0E7QUE5Q0E7OztBQ2hCQTs7O0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUNBOztBQ2JBOztBQUVBO0FBQ0E7QUFDQTs7O0FDb0JBOztBQUFBOztBQTZEQTs7QUE1REE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUdBOztBQUdBO0FBQ0E7QUFBQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFEQTs7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUpBO0FBT0E7QUFBQTtBQUdBO0FBQ0E7QUFGQTtBQWFBO0FBR0E7O0FBQ0E7QUE3REE7OztBQ05BOztBQUFBOztBQTBEQTs7QUF6REE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFJQTs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBOztBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFBQTtBQUVBO0FBSUE7QUFMQTtBQVdBO0FBR0E7O0FBQ0E7QUExREE7OztBQ0hBOztBQU9BO0FBQUE7O0FBR0E7QUFDQTtBQUVBOztBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQUtBOztBQUVBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5FQTtBQW9FQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7OztBQzFFQTs7QUFBQTtBQUFBOztBQUNBOztBQXdDQTs7QUF0Q0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVVBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFFQTtBQUdBOztBQUNBO0FBekNBOztBQTJDQTtBQUNBO0FBQ0E7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFFQTtBQUNBOztBQUdBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFBQTs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFBQTs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBMktBOztBQXpLQTtBQUtBOztBQUFBO0FBQUE7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTs7QUFFQTtBQUNBO0FBRUE7O0FBQUE7QUFBQTs7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTs7QUFFQTtBQUtBOztBQUFBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQVdBOztBQUVBO0FBS0E7O0FBQUE7QUFBQTs7O0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUtBOztBQUFBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFFQTtBQUlBOztBQUFBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7OztBQUtBO0FBSUE7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7O0FBS0E7QUFJQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUZBO0FBSUE7QUN2TkE7OztBQUVBO0FBS0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUtBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTs7QUFXQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTs7QUFFQTtBQUFBOztBQUNBO0FBRUE7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUFBOztBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTs7O0FBRUE7QUFPQTtBQUFBOztBQUNBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBOztBQUVBO0FBQUE7QUFDQTtBQUdBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDN1JBOzs7QUFFQTs7QUFBQTtBQUFBOztBQXNDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBK0RBOztBQXJHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUhBO0FBa0JBOztBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7OztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUF4R0E7QUNuQkE7Ozs7Ozs7QUFTQTtBQUFBOztBQUFBO0FBSkE7QUFDQTtBQUNBOztBQWlCQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUNBOztBQUVBO0FBQUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQXFDQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQUE7O0FDdEJBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBOztBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUVBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFIQTtBQUxBO0FBY0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQU9BO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTs7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFGQTtBQVFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDL0tBOztBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBOzs7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBd0lBO0FBQ0E7QUFDQTtBQURBO0FBSUE7OztBQThEQTs7QUFwTUE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFTQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7O0FBQ0E7OztBQUlBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSkE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQVBBO0FBY0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFNQTtBQUdBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBcE5BOztBQXNOQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDOU5BOztBQUFBO0FBQUE7O0FBQ0E7O0FBK0RBOztBQTdEQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBcUJBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFFQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQWhFQTs7OztBQ3JCQTs7QUFBQTs7QUFrREE7O0FBakRBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQU5BO0FBU0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUdBOztBQUNBO0FBbERBOztBQW9EQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUNwRUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBVUE7QUFDQTs7QUM5QkE7QUFBQTtBQUFBOzs7QUFnQ0E7O0FBQUE7O0FBd0JBOztBQXZCQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVVBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFRQTs7QUFDQTtBQXhCQTs7QUEwQkE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBREE7QUFJQTs7O0FDN0NBOztBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFvQ0E7O0FBbENBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUtBO0FBQ0E7QUFEQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQUE7QUFHQTs7QUFDQTtBQXRDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQUE7QUFFQTs7QUFTQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBRkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSEE7QUFTQTtBQUNBOztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTs7QUNsQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVdBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQzdCQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7O0FBc0NBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQTZCQTs7QUF0RkE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQTBCQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUdBO0FBR0E7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7O0FBQ0E7QUF6RkE7O0FDSUE7QUFBQTs7QUFBQTtBQUFBOztBQWtDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0FBZ0NBOztBQXpFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFKQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUdBOztBQWNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFqQkE7QUFtQkE7O0FBRUE7QUFDQTs7QUFDQTtBQTVFQTs7O0FDMkJBOztBQUFBO0FBQUE7O0FBQ0E7QUFHQTtBQUNBO0FBREE7O0FBNEVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7O0FBN0dBO0FBQUE7O0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFOQTtBQVNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQWdCQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF1Q0E7QUFySEE7O0FBdUhBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FDeE1BOzs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9hcGkvRXZlbnRTb3VyY2VBcGkudHM/NTBhNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9kb20tbWFuaXAudHM/MzkxNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9kb20tZXZlbnQudHM/OTE2OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9taXNjLnRzPzNiNGIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RhdGVsaWIvbWFya2VyLnRzPzkxZjEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3N0cnVjdHMvZXZlbnQtaW5zdGFuY2UudHM/MzE3ZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9vYmplY3QudHM/NmRhZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvc3RydWN0cy9yZWN1cnJpbmctZXZlbnQudHM/ODBkMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGF0ZWxpYi9kdXJhdGlvbi50cz84ZjRmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL2Zvcm1hdHRpbmctdXRpbHMudHM/NjM5MSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9hcnJheS50cz85ZWFjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL21lbW9pemUudHM/N2VmMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGF0ZWxpYi9mb3JtYXR0aW5nLW5hdGl2ZS50cz8zZTdjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL3pvbmVkLW1hcmtlci50cz80MGI1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL0RhdGVGb3JtYXR0ZXIudHM/OGIwOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGF0ZWxpYi9mb3JtYXR0aW5nLWNtZC50cz83Y2RlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL2Zvcm1hdHRpbmctZnVuYy50cz84YzcyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL2Zvcm1hdHRpbmcudHM/NzkxYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvb3B0aW9ucy50cz85MTgxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9zdHJ1Y3RzL2V2ZW50LXN0b3JlLnRzPzdlZDIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3N0cnVjdHMvY29uc3RyYWludC50cz9mMWNiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL2h0bWwudHM/MjNhOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tcG9uZW50L2V2ZW50LXVpLnRzPzMyM2EiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3N0cnVjdHMvZXZlbnQtcGFyc2UudHM/YTBkMCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9kYXRlLnRzPzQ3MGMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RhdGVsaWIvZGF0ZS1yYW5nZS50cz9jOWY5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21wb25lbnQvZXZlbnQtcmVuZGVyaW5nLnRzP2Q3NTMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3N0cnVjdHMvZGF0ZS1zcGFuLnRzPzBjMDIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NhbGVuZGFyLXV0aWxzLnRzPzNjMGMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3N0cnVjdHMvZXZlbnQtbXV0YXRpb24udHM/YWE5OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvVmlld0FwaS50cz84ZjI1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9zdHJ1Y3RzL2V2ZW50LXNvdXJjZS1wYXJzZS50cz8xY2FjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZWR1Y2Vycy9jdXJyZW50LWRhdGUudHM/YzQ2OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvQ2FsZW5kYXJBcGkudHN4Pzc1ZmUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2FwaS9FdmVudEFwaS50cz9iODc2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL2NhbGVuZGFyLXN5c3RlbS50cz9lNDQzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL3BhcnNpbmcudHM/YTExZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGF0ZWxpYi9lbnYudHM/ZDQzYiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZ2xvYmFsLWxvY2FsZXMudHM/MTgyNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGF0ZWxpYi9sb2NhbGUudHM/MjI2NyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZm9ybWF0dGluZy1hcGkudHM/NTNmMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvc3RydWN0cy9idXNpbmVzcy1ob3Vycy50cz82OGYwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL2dlb20udHM/Y2ZjMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC90YWJsZS1zdHlsaW5nLnRzeD9iYmFkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21wb25lbnQvZXZlbnQtc3BsaXR0aW5nLnRzPzM1MWEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbXBvbmVudC9kYXRlLXJlbmRlcmluZy50c3g/ZWE1MCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL25hdi1saW5rLnRzP2VjNGQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWwvc2Nyb2xsYmFyLXNpZGUudHM/ODhjMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9zY3JvbGxiYXItd2lkdGgudHM/NDBhZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9kb20tZ2VvbS50cz9kODA1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL3Byb21pc2UudHM/ZDk3MyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL0VtaXR0ZXIudHM/NmQ2OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL1Bvc2l0aW9uQ2FjaGUudHM/MWM5YyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL3Njcm9sbC1jb250cm9sbGVyLnRzPzYyZTEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3RoZW1lL1RoZW1lLnRzP2YzZjEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1Njcm9sbFJlc3BvbmRlci50cz8yZjYyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9WaWV3Q29udGV4dC50cz8xMjc3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy92ZG9tLXV0aWwudHN4Pzc4MTciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbXBvbmVudC9EYXRlQ29tcG9uZW50LnRzPzRlMzYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3BsdWdpbi1zeXN0ZW0udHM/OWEyYiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdGhlbWUvU3RhbmRhcmRUaGVtZS50cz9jYTY1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9zdHJ1Y3RzL3ZpZXctZGVmLnRzPzM4MzIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi9yZW5kZXItaG9vay50c3g/Mzc0YyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL1ZpZXdSb290LnRzeD8wZGM1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9zdHJ1Y3RzL3ZpZXctY29uZmlnLnRzeD83NWQxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9zdHJ1Y3RzL3ZpZXctc3BlYy50cz9lZGY5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9EYXRlUHJvZmlsZUdlbmVyYXRvci50cz82Mjg0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZWR1Y2Vycy92aWV3LXR5cGUudHM/Mjk3YSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcmVkdWNlcnMvb3B0aW9ucy50cz85YmI3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZWR1Y2Vycy9kYXRlLXByb2ZpbGUudHM/MDY5NyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcmVkdWNlcnMvZXZlbnRTb3VyY2VzLnRzPzExYmIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3JlZHVjZXJzL2V2ZW50U3RvcmUudHM/MTNlYiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcmVkdWNlcnMvZGF0ZS1zZWxlY3Rpb24udHM/NmVkOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcmVkdWNlcnMvc2VsZWN0ZWQtZXZlbnQudHM/YTNjNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcmVkdWNlcnMvZXZlbnQtZHJhZy50cz9jYmNkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZWR1Y2Vycy9ldmVudC1yZXNpemUudHM/ZmVhMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdG9vbGJhci1wYXJzZS50cz8zODZjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9ldmVudC1zb3VyY2VzL2FycmF5LWV2ZW50LXNvdXJjZS50cz9lNzZhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9ldmVudC1zb3VyY2VzL2Z1bmMtZXZlbnQtc291cmNlLnRzPzQ3YjEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWwvcmVxdWVzdEpzb24udHM/MmFiOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZXZlbnQtc291cmNlcy9qc29uLWZlZWQtZXZlbnQtc291cmNlLXJlZmluZXJzLnRzPzlkNTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2V2ZW50LXNvdXJjZXMvanNvbi1mZWVkLWV2ZW50LXNvdXJjZS50cz9kYWY5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9zdHJ1Y3RzL3JlY3VycmluZy1ldmVudC1zaW1wbGUtcmVmaW5lcnMudHM/Y2VhYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvc3RydWN0cy9yZWN1cnJpbmctZXZlbnQtc2ltcGxlLnRzPzM0ZjYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL29wdGlvbi1jaGFuZ2UtaGFuZGxlcnMudHM/Yzc2OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGF0ZXMtc2V0LnRzPzAxNzMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2V2ZW50LWNydWQudHM/NmVlNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZ2xvYmFsLXBsdWdpbnMudHM/ZTZjNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9EZWxheWVkUnVubmVyLnRzP2Y3OWEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWwvVGFza1J1bm5lci50cz81OTM2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZWR1Y2Vycy90aXRsZS1mb3JtYXR0aW5nLnRzPzA5NmUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3JlZHVjZXJzL0NhbGVuZGFyRGF0YU1hbmFnZXIudHM/MzNmZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tcG9uZW50L0NhbGVuZGFyRGF0YVByb3ZpZGVyLnRzPzhiMzkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1ZpZXcudHM/YzMxNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGF0ZWxpYi90aW1lem9uZS50cz9hODJiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9zZWctaGllcmFyY2h5LnRzP2ZlOGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvbi50cz84ZjBkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9pbnRlcmFjdGlvbnMvRWxlbWVudERyYWdnaW5nLnRzP2EwYmYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2dsb2JhbC1jb25maWcudHM/ZmZlMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvc3RydWN0cy9kcmFnLW1ldGEudHM/ODhjOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvVG9vbGJhclNlY3Rpb24udHN4PzkwYWIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1Rvb2xiYXIudHN4PzQxZjUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1ZpZXdDb250YWluZXIudHN4P2IwY2EiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy9FdmVudENsaWNraW5nLnRzPzNjOTYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy9FdmVudEhvdmVyaW5nLnRzPzE5YzQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL0NhbGVuZGFyQ29udGVudC50c3g/MjRkNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvQ2FsZW5kYXJSb290LnRzeD82OGIyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vdGFibGUtdXRpbHMudHM/OGYyNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL3RhYmxlLWNlbGwtdXRpbC50c3g/NjBlOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL1RhYmxlRGF0ZUNlbGwudHN4P2E5YWEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi9UYWJsZURvd0NlbGwudHN4P2M3OTciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL05vd1RpbWVyLnRzP2ZiZmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi9EYXlIZWFkZXIudHN4PzUyZjYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi9EYXlTZXJpZXNNb2RlbC50cz9iNWFhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vRGF5VGFibGVNb2RlbC50cz82MjcxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vc2xpY2luZy11dGlscy50cz85MmQyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy92YWxpZGF0aW9uLnRzP2VmYmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3Njcm9sbGdyaWQvU2Nyb2xsZXIudHN4PzY3MDUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWwvUmVmTWFwLnRzPzIxODIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3Njcm9sbGdyaWQvdXRpbC50c3g/NzBkNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvc2Nyb2xsZ3JpZC9TaW1wbGVTY3JvbGxHcmlkLnRzeD80MjAxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vRXZlbnRSb290LnRzeD9kNzkyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vU3RhbmRhcmRFdmVudC50c3g/M2UwNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL05vd0luZGljYXRvclJvb3QudHN4PzllMDMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi9EYXlDZWxsQ29udGVudC50c3g/MzFkNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL0RheUNlbGxSb290LnRzeD8xOTdkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vYmctZmlsbC50c3g/ZTYxNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL1dlZWtOdW1iZXJSb290LnRzeD9hOTkzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vUG9wb3Zlci50c3g/MTA5OCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL01vcmVQb3BvdmVyLnRzeD83YjE2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vTW9yZUxpbmtSb290LnRzeD83ZDQ3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9tYWluLnRzP2I5OWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRTb3VyY2UgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZSdcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcblxuLy8gbm8gcHVibGljIHR5cGVzIHlldC4gd2hlbiB0aGVyZSBhcmUsIGV4cG9ydCBmcm9tOlxuLy8gaW1wb3J0IHt9IGZyb20gJy4vYXBpLXR5cGUtZGVwcydcblxuZXhwb3J0IGNsYXNzIEV2ZW50U291cmNlQXBpIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4gICAgcHVibGljIGludGVybmFsRXZlbnRTb3VyY2U6IEV2ZW50U291cmNlPGFueT4sIC8vIHJlbmFtZT9cbiAgKSB7XG4gIH1cblxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcbiAgICAgIHNvdXJjZUlkOiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgfSlcbiAgfVxuXG4gIHJlZmV0Y2goKSB7XG4gICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgIHNvdXJjZUlkczogW3RoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0sXG4gICAgICBpc1JlZmV0Y2g6IHRydWUsXG4gICAgfSlcbiAgfVxuXG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UucHVibGljSWRcbiAgfVxuXG4gIGdldCB1cmwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEudXJsXG4gIH1cblxuICBnZXQgZm9ybWF0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5tZXRhLmZvcm1hdCAvLyBUT0RPOiBiYWQuIG5vdCBndWFyYW50ZWVkXG4gIH1cbn1cbiIsImltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbDogSFRNTEVsZW1lbnQpIHsgLy8gcmVtb3ZlcyBub2RlcyBpbiBhZGRpdGlvbiB0byBlbGVtZW50cy4gYmFkIG5hbWVcbiAgaWYgKGVsLnBhcmVudE5vZGUpIHtcbiAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKVxuICB9XG59XG5cbi8vIFF1ZXJ5aW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50Q2xvc2VzdChlbDogSFRNTEVsZW1lbnQsIHNlbGVjdG9yOiBzdHJpbmcpOiBIVE1MRWxlbWVudCB7XG4gIGlmIChlbC5jbG9zZXN0KSB7XG4gICAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpXG5cbiAgLy8gcmVhbGx5IGJhZCBmYWxsYmFjayBmb3IgSUVcbiAgLy8gZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0XG4gIH1cbiAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBkbyB7XG4gICAgaWYgKGVsZW1lbnRNYXRjaGVzKGVsLCBzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiBlbFxuICAgIH1cbiAgICBlbCA9IChlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGUpIGFzIEhUTUxFbGVtZW50XG4gIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxKVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudE1hdGNoZXMoZWw6IEhUTUxFbGVtZW50LCBzZWxlY3Rvcjogc3RyaW5nKTogSFRNTEVsZW1lbnQge1xuICBsZXQgbWV0aG9kID0gZWwubWF0Y2hlcyB8fCAoZWwgYXMgYW55KS5tYXRjaGVzU2VsZWN0b3IgfHwgKGVsIGFzIGFueSkubXNNYXRjaGVzU2VsZWN0b3JcblxuICByZXR1cm4gbWV0aG9kLmNhbGwoZWwsIHNlbGVjdG9yKVxufVxuXG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyByZXR1cm5zIGEgcmVhbCBhcnJheS4gZ29vZCBmb3IgbWV0aG9kcyBsaWtlIGZvckVhY2hcbi8vIFRPRE86IGFjY2VwdCB0aGUgZG9jdW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRWxlbWVudHMoY29udGFpbmVyOiBIVE1MRWxlbWVudFtdIHwgSFRNTEVsZW1lbnQgfCBOb2RlTGlzdE9mPEhUTUxFbGVtZW50Piwgc2VsZWN0b3I6IHN0cmluZyk6IEhUTUxFbGVtZW50W10ge1xuICBsZXQgY29udGFpbmVycyA9IGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gW2NvbnRhaW5lcl0gOiBjb250YWluZXJcbiAgbGV0IGFsbE1hdGNoZXM6IEhUTUxFbGVtZW50W10gPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGFpbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGxldCBtYXRjaGVzID0gY29udGFpbmVyc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKVxuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICBhbGxNYXRjaGVzLnB1c2gobWF0Y2hlc1tqXSBhcyBIVE1MRWxlbWVudClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYWxsTWF0Y2hlc1xufVxuXG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyBvbmx5IHF1ZXJpZXMgZGlyZWN0IGNoaWxkIGVsZW1lbnRzIC8vIFRPRE86IHJlbmFtZSB0byBmaW5kRGlyZWN0Q2hpbGRyZW4hXG5leHBvcnQgZnVuY3Rpb24gZmluZERpcmVjdENoaWxkcmVuKHBhcmVudDogSFRNTEVsZW1lbnRbXSB8IEhUTUxFbGVtZW50LCBzZWxlY3Rvcj86IHN0cmluZyk6IEhUTUxFbGVtZW50W10ge1xuICBsZXQgcGFyZW50cyA9IHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gW3BhcmVudF0gOiBwYXJlbnRcbiAgbGV0IGFsbE1hdGNoZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGxldCBjaGlsZE5vZGVzID0gcGFyZW50c1tpXS5jaGlsZHJlbiAvLyBvbmx5IGV2ZXIgZWxlbWVudHNcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgbGV0IGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbal1cblxuICAgICAgaWYgKCFzZWxlY3RvciB8fCBlbGVtZW50TWF0Y2hlcyhjaGlsZE5vZGUgYXMgSFRNTEVsZW1lbnQsIHNlbGVjdG9yKSkge1xuICAgICAgICBhbGxNYXRjaGVzLnB1c2goY2hpbGROb2RlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbGxNYXRjaGVzXG59XG5cbi8vIFN0eWxlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IFBJWEVMX1BST1BfUkUgPSAvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbXx3aWR0aHxoZWlnaHQpJC9pXG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVN0eWxlKGVsOiBIVE1MRWxlbWVudCwgcHJvcHM6IERpY3Rpb25hcnkpIHtcbiAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICBhcHBseVN0eWxlUHJvcChlbCwgcHJvcE5hbWUsIHByb3BzW3Byb3BOYW1lXSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTdHlsZVByb3AoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBzdHJpbmcsIHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICBlbC5zdHlsZVtuYW1lXSA9ICcnXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgUElYRUxfUFJPUF9SRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGVbbmFtZV0gPSBgJHt2YWx9cHhgXG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGVbbmFtZV0gPSB2YWxcbiAgfVxufVxuXG4vLyBFdmVudCBIYW5kbGluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBpZiBpbnRlcmNlcHRpbmcgYnViYmxlZCBldmVudHMgYXQgdGhlIGRvY3VtZW50L3dpbmRvdy9ib2R5IGxldmVsLFxuLy8gYW5kIHdhbnQgdG8gc2VlIG9yaWdpbmF0aW5nIGVsZW1lbnQgKHRoZSAndGFyZ2V0JyksIHVzZSB0aGlzIHV0aWwgaW5zdGVhZFxuLy8gb2YgYGV2LnRhcmdldGAgYmVjYXVzZSBpdCBnb2VzIHdpdGhpbiB3ZWItY29tcG9uZW50IGJvdW5kYXJpZXMuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXRWaWFSb290KGV2OiBFdmVudCkge1xuICByZXR1cm4gZXYuY29tcG9zZWRQYXRoPy4oKVswXSA/PyBldi50YXJnZXRcbn1cblxuLy8gU2hhZG93IERPTSBjb25zdWRlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RWxSb290KGVsOiBIVE1MRWxlbWVudCk6IFNoYWRvd1Jvb3QgfCBEb2N1bWVudCB7XG4gIHJldHVybiBlbC5nZXRSb290Tm9kZSA/IGVsLmdldFJvb3ROb2RlKCkgYXMgU2hhZG93Um9vdCA6IGRvY3VtZW50XG59XG4iLCJpbXBvcnQgeyBlbGVtZW50Q2xvc2VzdCB9IGZyb20gJy4vZG9tLW1hbmlwJ1xuaW1wb3J0IHsgVlVJRXZlbnQgfSBmcm9tICcuLi92ZG9tJ1xuXG4vLyBTdG9wcyBhIG1vdXNlL3RvdWNoIGV2ZW50IGZyb20gZG9pbmcgaXQncyBuYXRpdmUgYnJvd3NlciBhY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xuICBldi5wcmV2ZW50RGVmYXVsdCgpXG59XG5cbi8vIEV2ZW50IERlbGVnYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXI8RXZlbnRUeXBlIGV4dGVuZHMgKEV2ZW50IHwgVlVJRXZlbnQpPihcbiAgc2VsZWN0b3I6IHN0cmluZyxcbiAgaGFuZGxlcjogKGV2OiBFdmVudFR5cGUsIG1hdGNoZWRUYXJnZXQ6IEhUTUxFbGVtZW50KSA9PiB2b2lkLFxuKSB7XG4gIHJldHVybiAoZXY6IEV2ZW50VHlwZSkgPT4ge1xuICAgIGxldCBtYXRjaGVkQ2hpbGQgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIHNlbGVjdG9yKVxuXG4gICAgaWYgKG1hdGNoZWRDaGlsZCkge1xuICAgICAgaGFuZGxlci5jYWxsKG1hdGNoZWRDaGlsZCwgZXYsIG1hdGNoZWRDaGlsZClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkJ5U2VsZWN0b3IoXG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gIGV2ZW50VHlwZTogc3RyaW5nLFxuICBzZWxlY3Rvcjogc3RyaW5nLFxuICBoYW5kbGVyOiAoZXY6IEV2ZW50LCBtYXRjaGVkVGFyZ2V0OiBIVE1MRWxlbWVudCkgPT4gdm9pZCxcbikge1xuICBsZXQgYXR0YWNoZWRIYW5kbGVyID0gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcihzZWxlY3RvciwgaGFuZGxlcilcblxuICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGF0dGFjaGVkSGFuZGxlcilcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvcihcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgc2VsZWN0b3I6IHN0cmluZyxcbiAgb25Nb3VzZUVudGVyOiAoZXY6IEV2ZW50LCBtYXRjaGVkVGFyZ2V0OiBIVE1MRWxlbWVudCkgPT4gdm9pZCxcbiAgb25Nb3VzZUxlYXZlOiAoZXY6IEV2ZW50LCBtYXRjaGVkVGFyZ2V0OiBIVE1MRWxlbWVudCkgPT4gdm9pZCxcbikge1xuICBsZXQgY3VycmVudE1hdGNoZWRDaGlsZFxuXG4gIHJldHVybiBsaXN0ZW5CeVNlbGVjdG9yKGNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIHNlbGVjdG9yLCAobW91c2VPdmVyRXYsIG1hdGNoZWRDaGlsZCkgPT4ge1xuICAgIGlmIChtYXRjaGVkQ2hpbGQgIT09IGN1cnJlbnRNYXRjaGVkQ2hpbGQpIHtcbiAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBtYXRjaGVkQ2hpbGRcbiAgICAgIG9uTW91c2VFbnRlcihtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKVxuXG4gICAgICBsZXQgcmVhbE9uTW91c2VMZWF2ZSA9IChtb3VzZUxlYXZlRXYpID0+IHtcbiAgICAgICAgY3VycmVudE1hdGNoZWRDaGlsZCA9IG51bGxcbiAgICAgICAgb25Nb3VzZUxlYXZlKG1vdXNlTGVhdmVFdiwgbWF0Y2hlZENoaWxkKVxuICAgICAgICBtYXRjaGVkQ2hpbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHJlYWxPbk1vdXNlTGVhdmUpXG4gICAgICB9XG5cbiAgICAgIC8vIGxpc3RlbiB0byB0aGUgbmV4dCBtb3VzZWxlYXZlLCBhbmQgdGhlbiB1bmF0dGFjaFxuICAgICAgbWF0Y2hlZENoaWxkLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCByZWFsT25Nb3VzZUxlYXZlKVxuICAgIH1cbiAgfSlcbn1cblxuLy8gQW5pbWF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IHRyYW5zaXRpb25FdmVudE5hbWVzID0gW1xuICAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICdvdHJhbnNpdGlvbmVuZCcsXG4gICdvVHJhbnNpdGlvbkVuZCcsXG4gICdtc1RyYW5zaXRpb25FbmQnLFxuICAndHJhbnNpdGlvbmVuZCcsXG5dXG5cbi8vIHRyaWdnZXJlZCBvbmx5IHdoZW4gdGhlIG5leHQgc2luZ2xlIHN1YnNlcXVlbnQgdHJhbnNpdGlvbiBmaW5pc2hlc1xuZXhwb3J0IGZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRG9uZShlbDogSFRNTEVsZW1lbnQsIGNhbGxiYWNrOiAoZXY6IEV2ZW50KSA9PiB2b2lkKSB7XG4gIGxldCByZWFsQ2FsbGJhY2sgPSAoZXYpID0+IHtcbiAgICBjYWxsYmFjayhldilcbiAgICB0cmFuc2l0aW9uRXZlbnROYW1lcy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spXG4gICAgfSlcbiAgfVxuXG4gIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spIC8vIGNyb3NzLWJyb3dzZXIgd2F5IHRvIGRldGVybWluZSB3aGVuIHRoZSB0cmFuc2l0aW9uIGZpbmlzaGVzXG4gIH0pXG59XG4iLCJpbXBvcnQgeyBwcmV2ZW50RGVmYXVsdCB9IGZyb20gJy4vZG9tLWV2ZW50J1xuXG5leHBvcnQgdHlwZSBHZW5lcmljSGFzaCA9IHsgW2tleTogc3RyaW5nXTogYW55IH0gLy8gYWxyZWFkeSBkaWQgdGhpcyBzb21ld2hlcmVcblxubGV0IGd1aWROdW1iZXIgPSAwXG5cbmV4cG9ydCBmdW5jdGlvbiBndWlkKCkge1xuICBndWlkTnVtYmVyICs9IDFcbiAgcmV0dXJuIFN0cmluZyhndWlkTnVtYmVyKVxufVxuXG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgRE9NIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vIE1ha2UgdGhlIG1vdXNlIGN1cnNvciBleHByZXNzIHRoYXQgYW4gZXZlbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgYXJlYVxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVDdXJzb3IoKSB7XG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnZmMtbm90LWFsbG93ZWQnKVxufVxuXG4vLyBSZXR1cm5zIHRoZSBtb3VzZSBjdXJzb3IgdG8gaXRzIG9yaWdpbmFsIGxvb2tcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVDdXJzb3IoKSB7XG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnZmMtbm90LWFsbG93ZWQnKVxufVxuXG4vKiBTZWxlY3Rpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudFNlbGVjdGlvbihlbDogSFRNTEVsZW1lbnQpIHtcbiAgZWwuY2xhc3NMaXN0LmFkZCgnZmMtdW5zZWxlY3RhYmxlJylcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFsbG93U2VsZWN0aW9uKGVsOiBIVE1MRWxlbWVudCkge1xuICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmYy11bnNlbGVjdGFibGUnKVxuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KVxufVxuXG4vKiBDb250ZXh0IE1lbnVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudENvbnRleHRNZW51KGVsOiBIVE1MRWxlbWVudCkge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxsb3dDb250ZXh0TWVudShlbDogSFRNTEVsZW1lbnQpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdClcbn1cblxuLyogT2JqZWN0IE9yZGVyaW5nIGJ5IEZpZWxkXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZXhwb3J0IGludGVyZmFjZSBPcmRlclNwZWM8U3ViamVjdD4ge1xuICBmaWVsZD86IHN0cmluZ1xuICBvcmRlcj86IG51bWJlclxuICBmdW5jPzogRmllbGRTcGVjSW5wdXRGdW5jPFN1YmplY3Q+XG59XG5cbmV4cG9ydCB0eXBlIEZpZWxkU3BlY0lucHV0PFN1YmplY3Q+ID0gc3RyaW5nIHwgc3RyaW5nW10gfCBGaWVsZFNwZWNJbnB1dEZ1bmM8U3ViamVjdD4gfCBGaWVsZFNwZWNJbnB1dEZ1bmM8U3ViamVjdD5bXVxuZXhwb3J0IHR5cGUgRmllbGRTcGVjSW5wdXRGdW5jPFN1YmplY3Q+ID0gKGE6IFN1YmplY3QsIGI6IFN1YmplY3QpID0+IG51bWJlclxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGaWVsZFNwZWNzPFN1YmplY3Q+KGlucHV0OiBGaWVsZFNwZWNJbnB1dDxTdWJqZWN0Pik6IE9yZGVyU3BlYzxTdWJqZWN0PltdIHtcbiAgbGV0IHNwZWNzOiBPcmRlclNwZWM8U3ViamVjdD5bXSA9IFtdXG4gIGxldCB0b2tlbnMgPSBbXVxuICBsZXQgaVxuICBsZXQgdG9rZW5cblxuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIHRva2VucyA9IGlucHV0LnNwbGl0KC9cXHMqLFxccyovKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRva2VucyA9IFtpbnB1dF1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIHRva2VucyA9IGlucHV0XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICBzcGVjcy5wdXNoKFxuICAgICAgICB0b2tlbi5jaGFyQXQoMCkgPT09ICctJyA/XG4gICAgICAgICAgeyBmaWVsZDogdG9rZW4uc3Vic3RyaW5nKDEpLCBvcmRlcjogLTEgfSA6XG4gICAgICAgICAgeyBmaWVsZDogdG9rZW4sIG9yZGVyOiAxIH0sXG4gICAgICApXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNwZWNzLnB1c2goeyBmdW5jOiB0b2tlbiB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzcGVjc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjczxTdWJqZWN0PihvYmowOiBTdWJqZWN0LCBvYmoxOiBTdWJqZWN0LCBmaWVsZFNwZWNzOiBPcmRlclNwZWM8U3ViamVjdD5bXSk6IG51bWJlciB7XG4gIGxldCBpXG4gIGxldCBjbXBcblxuICBmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNtcCA9IGNvbXBhcmVCeUZpZWxkU3BlYyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzW2ldKVxuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjPFN1YmplY3Q+KG9iajA6IFN1YmplY3QsIG9iajE6IFN1YmplY3QsIGZpZWxkU3BlYzogT3JkZXJTcGVjPFN1YmplY3Q+KTogbnVtYmVyIHtcbiAgaWYgKGZpZWxkU3BlYy5mdW5jKSB7XG4gICAgcmV0dXJuIGZpZWxkU3BlYy5mdW5jKG9iajAsIG9iajEpXG4gIH1cblxuICByZXR1cm4gZmxleGlibGVDb21wYXJlKG9iajBbZmllbGRTcGVjLmZpZWxkXSwgb2JqMVtmaWVsZFNwZWMuZmllbGRdKVxuICAgICogKGZpZWxkU3BlYy5vcmRlciB8fCAxKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcbiAgaWYgKCFhICYmICFiKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAoYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKGEgPT0gbnVsbCkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKVxuICB9XG4gIHJldHVybiBhIC0gYlxufVxuXG4vKiBTdHJpbmcgVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZFN0YXJ0KHZhbCwgbGVuKSB7IC8vIGRvZXNuJ3Qgd29yayB3aXRoIHRvdGFsIGxlbmd0aCBtb3JlIHRoYW4gM1xuICBsZXQgcyA9IFN0cmluZyh2YWwpXG4gIHJldHVybiAnMDAwJy5zdWJzdHIoMCwgbGVuIC0gcy5sZW5ndGgpICsgc1xufVxuXG4vKiBOdW1iZXIgVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHsgLy8gZm9yIC5zb3J0KClcbiAgcmV0dXJuIGEgLSBiXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ludChuKSB7XG4gIHJldHVybiBuICUgMSA9PT0gMFxufVxuXG4vKiBXZWlyZCBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnQgZnVuY3Rpb24gZmlyc3REZWZpbmVkKC4uLmFyZ3MpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGFyZ3NbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGFyZ3NbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG4vKiBGQy1zcGVjaWZpYyBET00gZGltZW5zaW9uIHN0dWZmXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChjZWxsRWw6IEhUTUxFbGVtZW50KSB7XG4gIGxldCBhbGxXaWR0aEVsID0gY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zY3JvbGxncmlkLXNocmluay1mcmFtZScpXG4gIGxldCBjb250ZW50V2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicpXG5cbiAgaWYgKCFhbGxXaWR0aEVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZSBjbGFzc05hbWUnKSAvLyBUT0RPOiB1c2UgY29uc3RcbiAgfVxuICBpZiAoIWNvbnRlbnRXaWR0aEVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uIGNsYXNzTmFtZScpXG4gIH1cblxuICByZXR1cm4gY2VsbEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gYWxsV2lkdGhFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIC8vIHRoZSBjZWxsIHBhZGRpbmcrYm9yZGVyXG4gICAgY29udGVudFdpZHRoRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbn1cbiIsImltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi9kdXJhdGlvbidcblxuZXhwb3J0IHR5cGUgRGF0ZU1hcmtlciA9IERhdGVcblxuZXhwb3J0IGNvbnN0IERBWV9JRFMgPSBbJ3N1bicsICdtb24nLCAndHVlJywgJ3dlZCcsICd0aHUnLCAnZnJpJywgJ3NhdCddXG5cbi8vIEFkZGluZ1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkV2Vla3MobTogRGF0ZU1hcmtlciwgbjogbnVtYmVyKSB7XG4gIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSlcbiAgYVsyXSArPSBuICogN1xuICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZERheXMobTogRGF0ZU1hcmtlciwgbjogbnVtYmVyKSB7XG4gIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSlcbiAgYVsyXSArPSBuXG4gIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTXMobTogRGF0ZU1hcmtlciwgbjogbnVtYmVyKSB7XG4gIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSlcbiAgYVs2XSArPSBuXG4gIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKVxufVxuXG4vLyBEaWZmaW5nIChhbGwgcmV0dXJuIGZsb2F0cylcbi8vIFRPRE86IHdoeSBub3QgdXNlIHJhbmdlcz9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZXZWVrcyhtMCwgbTEpIHtcbiAgcmV0dXJuIGRpZmZEYXlzKG0wLCBtMSkgLyA3XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmRGF5cyhtMCwgbTEpIHtcbiAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmSG91cnMobTAsIG0xKSB7XG4gIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZNaW51dGVzKG0wLCBtMSkge1xuICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZlNlY29uZHMobTAsIG0xKSB7XG4gIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIDEwMDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZEYXlBbmRUaW1lKG0wOiBEYXRlTWFya2VyLCBtMTogRGF0ZU1hcmtlcik6IER1cmF0aW9uIHtcbiAgbGV0IG0wZGF5ID0gc3RhcnRPZkRheShtMClcbiAgbGV0IG0xZGF5ID0gc3RhcnRPZkRheShtMSlcblxuICByZXR1cm4ge1xuICAgIHllYXJzOiAwLFxuICAgIG1vbnRoczogMCxcbiAgICBkYXlzOiBNYXRoLnJvdW5kKGRpZmZEYXlzKG0wZGF5LCBtMWRheSkpLFxuICAgIG1pbGxpc2Vjb25kczogKG0xLnZhbHVlT2YoKSAtIG0xZGF5LnZhbHVlT2YoKSkgLSAobTAudmFsdWVPZigpIC0gbTBkYXkudmFsdWVPZigpKSxcbiAgfVxufVxuXG4vLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmV2hvbGVXZWVrcyhtMDogRGF0ZU1hcmtlciwgbTE6IERhdGVNYXJrZXIpOiBudW1iZXIge1xuICBsZXQgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKVxuXG4gIGlmIChkICE9PSBudWxsICYmIGQgJSA3ID09PSAwKSB7XG4gICAgcmV0dXJuIGQgLyA3XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMDogRGF0ZU1hcmtlciwgbTE6IERhdGVNYXJrZXIpOiBudW1iZXIge1xuICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChkaWZmRGF5cyhtMCwgbTEpKVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8vIFN0YXJ0LU9mXG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydE9mRGF5KG06IERhdGVNYXJrZXIpOiBEYXRlTWFya2VyIHtcbiAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgbS5nZXRVVENNb250aCgpLFxuICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICBdKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRPZkhvdXIobTogRGF0ZU1hcmtlcikge1xuICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgbS5nZXRVVENEYXRlKCksXG4gICAgbS5nZXRVVENIb3VycygpLFxuICBdKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRPZk1pbnV0ZShtOiBEYXRlTWFya2VyKSB7XG4gIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICBtLmdldFVUQ0hvdXJzKCksXG4gICAgbS5nZXRVVENNaW51dGVzKCksXG4gIF0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydE9mU2Vjb25kKG06IERhdGVNYXJrZXIpIHtcbiAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgbS5nZXRVVENNb250aCgpLFxuICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgIG0uZ2V0VVRDSG91cnMoKSxcbiAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBtLmdldFVUQ1NlY29uZHMoKSxcbiAgXSlcbn1cblxuLy8gV2VlayBDb21wdXRhdGlvblxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla09mWWVhcihtYXJrZXIsIGRvdywgZG95KSB7XG4gIGxldCB5ID0gbWFya2VyLmdldFVUQ0Z1bGxZZWFyKClcbiAgbGV0IHcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5LCBkb3csIGRveSlcblxuICBpZiAodyA8IDEpIHtcbiAgICByZXR1cm4gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSAtIDEsIGRvdywgZG95KVxuICB9XG5cbiAgbGV0IG5leHRXID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSArIDEsIGRvdywgZG95KVxuICBpZiAobmV4dFcgPj0gMSkge1xuICAgIHJldHVybiBNYXRoLm1pbih3LCBuZXh0VylcbiAgfVxuXG4gIHJldHVybiB3XG59XG5cbmZ1bmN0aW9uIHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHllYXIsIGRvdywgZG95KSB7XG4gIGxldCBmaXJzdFdlZWtTdGFydCA9IGFycmF5VG9VdGNEYXRlKFt5ZWFyLCAwLCAxICsgZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KV0pXG4gIGxldCBkYXlTdGFydCA9IHN0YXJ0T2ZEYXkobWFya2VyKVxuICBsZXQgZGF5cyA9IE1hdGgucm91bmQoZGlmZkRheXMoZmlyc3RXZWVrU3RhcnQsIGRheVN0YXJ0KSlcblxuICByZXR1cm4gTWF0aC5mbG9vcihkYXlzIC8gNykgKyAxIC8vIHplcm8taW5kZXhlZFxufVxuXG4vLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICBsZXQgZndkID0gNyArIGRvdyAtIGRveVxuXG4gIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgbGV0IGZ3ZGx3ID0gKDcgKyBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgZndkXSkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgN1xuXG4gIHJldHVybiAtZndkbHcgKyBmd2QgLSAxXG59XG5cbi8vIEFycmF5IENvbnZlcnNpb25cblxuZXhwb3J0IGZ1bmN0aW9uIGRhdGVUb0xvY2FsQXJyYXkoZGF0ZSkge1xuICByZXR1cm4gW1xuICAgIGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICBkYXRlLmdldE1vbnRoKCksXG4gICAgZGF0ZS5nZXREYXRlKCksXG4gICAgZGF0ZS5nZXRIb3VycygpLFxuICAgIGRhdGUuZ2V0TWludXRlcygpLFxuICAgIGRhdGUuZ2V0U2Vjb25kcygpLFxuICAgIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gIF1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5VG9Mb2NhbERhdGUoYSkge1xuICByZXR1cm4gbmV3IERhdGUoXG4gICAgYVswXSxcbiAgICBhWzFdIHx8IDAsXG4gICAgYVsyXSA9PSBudWxsID8gMSA6IGFbMl0sIC8vIGRheSBvZiBtb250aFxuICAgIGFbM10gfHwgMCxcbiAgICBhWzRdIHx8IDAsXG4gICAgYVs1XSB8fCAwLFxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXRlVG9VdGNBcnJheShkYXRlKSB7XG4gIHJldHVybiBbXG4gICAgZGF0ZS5nZXRVVENGdWxsWWVhcigpLFxuICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICBkYXRlLmdldFVUQ0RhdGUoKSxcbiAgICBkYXRlLmdldFVUQ0hvdXJzKCksXG4gICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgZGF0ZS5nZXRVVENTZWNvbmRzKCksXG4gICAgZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKSxcbiAgXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlUb1V0Y0RhdGUoYSkge1xuICAvLyBhY2NvcmRpbmcgdG8gd2ViIHN0YW5kYXJkcyAoYW5kIFNhZmFyaSksIGEgbW9udGggaW5kZXggaXMgcmVxdWlyZWQuXG4gIC8vIG1hc3NhZ2UgaWYgb25seSBnaXZlbiBhIHllYXIuXG4gIGlmIChhLmxlbmd0aCA9PT0gMSkge1xuICAgIGEgPSBhLmNvbmNhdChbMF0pXG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoLi4uKGEgYXMgW2FueSwgYW55XSkpKVxufVxuXG4vLyBPdGhlciBVdGlsc1xuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZERhdGUobTogRGF0ZU1hcmtlcikge1xuICByZXR1cm4gIWlzTmFOKG0udmFsdWVPZigpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZUFzTXMobTogRGF0ZU1hcmtlcikge1xuICByZXR1cm4gbS5nZXRVVENIb3VycygpICogMTAwMCAqIDYwICogNjAgK1xuICAgIG0uZ2V0VVRDTWludXRlcygpICogMTAwMCAqIDYwICtcbiAgICBtLmdldFVUQ1NlY29uZHMoKSAqIDEwMDAgK1xuICAgIG0uZ2V0VVRDTWlsbGlzZWNvbmRzKClcbn1cbiIsImltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IGd1aWQgfSBmcm9tICcuLi91dGlsL21pc2MnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRJbnN0YW5jZSB7XG4gIGluc3RhbmNlSWQ6IHN0cmluZ1xuICBkZWZJZDogc3RyaW5nXG4gIHJhbmdlOiBEYXRlUmFuZ2VcbiAgZm9yY2VkU3RhcnRUem86IG51bWJlciB8IG51bGxcbiAgZm9yY2VkRW5kVHpvOiBudW1iZXIgfCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIEV2ZW50SW5zdGFuY2VIYXNoID0geyBbaW5zdGFuY2VJZDogc3RyaW5nXTogRXZlbnRJbnN0YW5jZSB9XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudEluc3RhbmNlKFxuICBkZWZJZDogc3RyaW5nLFxuICByYW5nZTogRGF0ZVJhbmdlLFxuICBmb3JjZWRTdGFydFR6bz86IG51bWJlcixcbiAgZm9yY2VkRW5kVHpvPzogbnVtYmVyLFxuKTogRXZlbnRJbnN0YW5jZSB7XG4gIHJldHVybiB7XG4gICAgaW5zdGFuY2VJZDogZ3VpZCgpLFxuICAgIGRlZklkLFxuICAgIHJhbmdlLFxuICAgIGZvcmNlZFN0YXJ0VHpvOiBmb3JjZWRTdGFydFR6byA9PSBudWxsID8gbnVsbCA6IGZvcmNlZFN0YXJ0VHpvLFxuICAgIGZvcmNlZEVuZFR6bzogZm9yY2VkRW5kVHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkRW5kVHpvLFxuICB9XG59XG4iLCJjb25zdCB7IGhhc093blByb3BlcnR5IH0gPSBPYmplY3QucHJvdG90eXBlXG5cbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VQcm9wcyhwcm9wT2JqcywgY29tcGxleFByb3BzTWFwPyk6IGFueSB7XG4gIGxldCBkZXN0ID0ge31cblxuICBpZiAoY29tcGxleFByb3BzTWFwKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgIGxldCBjb21wbGV4T2JqcyA9IFtdXG5cbiAgICAgIC8vIGNvbGxlY3QgdGhlIHRyYWlsaW5nIG9iamVjdCB2YWx1ZXMsIHN0b3BwaW5nIHdoZW4gYSBub24tb2JqZWN0IGlzIGRpc2NvdmVyZWRcbiAgICAgIGZvciAobGV0IGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBsZXQgdmFsID0gcHJvcE9ianNbaV1bbmFtZV1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgIGNvbXBsZXhPYmpzLnVuc2hpZnQodmFsKVxuICAgICAgICB9IGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVzdFtuYW1lXSA9IHZhbCAvLyBpZiB0aGVyZSB3ZXJlIG5vIG9iamVjdHMsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcbiAgICAgIGlmIChjb21wbGV4T2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgZGVzdFtuYW1lXSA9IG1lcmdlUHJvcHMoY29tcGxleE9ianMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuICBmb3IgKGxldCBpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICBsZXQgcHJvcHMgPSBwcm9wT2Jqc1tpXVxuXG4gICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcykge1xuICAgICAgaWYgKCEobmFtZSBpbiBkZXN0KSkgeyAvLyBpZiBhbHJlYWR5IGFzc2lnbmVkIGJ5IHByZXZpb3VzIHByb3BzIG9yIGNvbXBsZXggcHJvcHMsIGRvbid0IHJlYXNzaWduXG4gICAgICAgIGRlc3RbbmFtZV0gPSBwcm9wc1tuYW1lXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXN0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJIYXNoKGhhc2gsIGZ1bmMpIHtcbiAgbGV0IGZpbHRlcmVkID0ge31cblxuICBmb3IgKGxldCBrZXkgaW4gaGFzaCkge1xuICAgIGlmIChmdW5jKGhhc2hba2V5XSwga2V5KSkge1xuICAgICAgZmlsdGVyZWRba2V5XSA9IGhhc2hba2V5XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaDxJbnB1dEl0ZW0sIE91dHB1dEl0ZW0+KFxuICBoYXNoOiB7IFtrZXk6IHN0cmluZ106IElucHV0SXRlbSB9LFxuICBmdW5jOiAoaW5wdXQ6IElucHV0SXRlbSwga2V5OiBzdHJpbmcpID0+IE91dHB1dEl0ZW0sXG4pOiB7IFtrZXk6IHN0cmluZ106IE91dHB1dEl0ZW0gfSB7XG4gIGxldCBuZXdIYXNoID0ge31cblxuICBmb3IgKGxldCBrZXkgaW4gaGFzaCkge1xuICAgIG5ld0hhc2hba2V5XSA9IGZ1bmMoaGFzaFtrZXldLCBrZXkpXG4gIH1cblxuICByZXR1cm4gbmV3SGFzaFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlUb0hhc2goYSk6IHsgW2tleTogc3RyaW5nXTogdHJ1ZSB9IHsgLy8gVE9ETzogcmVuYW1lIHRvIHN0cmluQXJyYXlUb0hhc2ggb3Igc29tZXRoaW5nXG4gIGxldCBoYXNoID0ge31cblxuICBmb3IgKGxldCBpdGVtIG9mIGEpIHtcbiAgICBoYXNoW2l0ZW1dID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGhhc2hcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkSGFzaEZyb21BcnJheTxJdGVtLCBJdGVtUmVzPihhOiBJdGVtW10sIGZ1bmM6IChpdGVtOiBJdGVtLCBpbmRleDogbnVtYmVyKSA9PiBbIHN0cmluZywgSXRlbVJlcyBdKSB7XG4gIGxldCBoYXNoOiB7IFtrZXk6IHN0cmluZ106IEl0ZW1SZXMgfSA9IHt9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgbGV0IHR1cGxlID0gZnVuYyhhW2ldLCBpKVxuXG4gICAgaGFzaFt0dXBsZVswXV0gPSB0dXBsZVsxXVxuICB9XG5cbiAgcmV0dXJuIGhhc2hcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hWYWx1ZXNUb0FycmF5KG9iaikgeyAvLyBjYW4ndCB1c2UgT2JqZWN0LnZhbHVlcyB5ZXQgYmVjYXVzZSBvZiBubyBJRSBzdXBwb3J0XG4gIGxldCBhID0gW11cblxuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgYS5wdXNoKG9ialtrZXldKVxuICB9XG5cbiAgcmV0dXJuIGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvcHNFcXVhbChvYmowLCBvYmoxKSB7IC8vIFRPRE86IG1lcmdlIHdpdGggY29tcGFyZU9ianNcbiAgaWYgKG9iajAgPT09IG9iajEpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZm9yIChsZXQga2V5IGluIG9iajApIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmowLCBrZXkpKSB7XG4gICAgICBpZiAoIShrZXkgaW4gb2JqMSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQga2V5IGluIG9iajEpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmoxLCBrZXkpKSB7XG4gICAgICBpZiAob2JqMFtrZXldICE9PSBvYmoxW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuZXF1YWxQcm9wcyhvYmowLCBvYmoxKSB7XG4gIGxldCBrZXlzOiBzdHJpbmdbXSA9IFtdXG5cbiAgZm9yIChsZXQga2V5IGluIG9iajApIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmowLCBrZXkpKSB7XG4gICAgICBpZiAoIShrZXkgaW4gb2JqMSkpIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBrZXkgaW4gb2JqMSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlzXG59XG5cbmV4cG9ydCB0eXBlIEVxdWFsaXR5RnVuYzxUPiA9IChhOiBULCBiOiBUKSA9PiBib29sZWFuXG5leHBvcnQgdHlwZSBFcXVhbGl0eVRoaW5nPFQ+ID0gRXF1YWxpdHlGdW5jPFQ+IHwgdHJ1ZVxuXG5leHBvcnQgdHlwZSBFcXVhbGl0eUZ1bmNzPE9ialR5cGU+ID0geyAvLyBub3QgcmVhbGx5IGp1c3QgYSBcImZ1bmNcIiBhbnltb3JlXG4gIFtLIGluIGtleW9mIE9ialR5cGVdPzogRXF1YWxpdHlUaGluZzxPYmpUeXBlW0tdPlxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZU9ianMob2xkUHJvcHMsIG5ld1Byb3BzLCBlcXVhbGl0eUZ1bmNzOiBFcXVhbGl0eUZ1bmNzPGFueT4gPSB7fSkge1xuICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAobGV0IGtleSBpbiBuZXdQcm9wcykge1xuICAgIGlmIChrZXkgaW4gb2xkUHJvcHMgJiYgaXNPYmpWYWxzRXF1YWwob2xkUHJvcHNba2V5XSwgbmV3UHJvcHNba2V5XSwgZXF1YWxpdHlGdW5jc1trZXldKSkge1xuICAgICAgLy8gZXF1YWxcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgZm9yIHByb3BzIHRoYXQgd2VyZSBvbWl0dGVkIGluIHRoZSBuZXdcbiAgZm9yIChsZXQga2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIG5ld1Byb3BzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLypcbmFzc3VtZWQgXCJ0cnVlXCIgZXF1YWxpdHkgZm9yIGhhbmRsZXIgbmFtZXMgbGlrZSBcIm9uUmVjZWl2ZVNvbWV0aGluZ1wiXG4qL1xuZnVuY3Rpb24gaXNPYmpWYWxzRXF1YWw8VD4odmFsMDogVCwgdmFsMTogVCwgY29tcGFyYXRvcjogRXF1YWxpdHlUaGluZzxUPikge1xuICBpZiAodmFsMCA9PT0gdmFsMSB8fCBjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIHJldHVybiBjb21wYXJhdG9yKHZhbDAsIHZhbDEpXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0RnJvbUhhc2g8SXRlbT4oXG4gIGhhc2g6IHsgW2tleTogc3RyaW5nXTogSXRlbSB9LFxuICBzdGFydEluZGV4ID0gMCxcbiAgZW5kSW5kZXg/OiBudW1iZXIsXG4gIHN0ZXAgPSAxLFxuKSB7XG4gIGxldCByZXM6IEl0ZW1bXSA9IFtdXG5cbiAgaWYgKGVuZEluZGV4ID09IG51bGwpIHtcbiAgICBlbmRJbmRleCA9IE9iamVjdC5rZXlzKGhhc2gpLmxlbmd0aFxuICB9XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSArPSBzdGVwKSB7XG4gICAgbGV0IHZhbCA9IGhhc2hbaV1cblxuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkgeyAvLyB3aWxsIGRpc3JlZ2FyZCB1bmRlZmluZWQgZm9yIHNwYXJzZSBhcnJheXNcbiAgICAgIHJlcy5wdXNoKHZhbClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzXG59XG4iLCJpbXBvcnQgeyBFdmVudERlZiB9IGZyb20gJy4vZXZlbnQtZGVmJ1xuaW1wb3J0IHsgRXZlbnRJbnN0YW5jZSwgY3JlYXRlRXZlbnRJbnN0YW5jZSB9IGZyb20gJy4vZXZlbnQtaW5zdGFuY2UnXG5pbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBEYXRlRW52IH0gZnJvbSAnLi4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBEdXJhdGlvbiB9IGZyb20gJy4uL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyBEYXRlTWFya2VyLCBzdGFydE9mRGF5IH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBFdmVudFN0b3JlIH0gZnJvbSAnLi9ldmVudC1zdG9yZSdcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IGZpbHRlckhhc2ggfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IEV2ZW50UmVmaW5lZCB9IGZyb20gJy4vZXZlbnQtcGFyc2UnXG5cbi8qXG5UaGUgcGx1Z2luIHN5c3RlbSBmb3IgZGVmaW5pbmcgaG93IGEgcmVjdXJyaW5nIGV2ZW50IGlzIGV4cGFuZGVkIGludG8gaW5kaXZpZHVhbCBpbnN0YW5jZXMuXG4qL1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlZFJlY3VycmluZzxSZWN1cnJpbmdEYXRhPiB7XG4gIHR5cGVEYXRhOiBSZWN1cnJpbmdEYXRhXG4gIGFsbERheUd1ZXNzOiBib29sZWFuIHwgbnVsbFxuICBkdXJhdGlvbjogRHVyYXRpb24gfCBudWxsIC8vIHNpZ25hbHMgaGFzRW5kXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjdXJyaW5nVHlwZTxSZWN1cnJpbmdEYXRhPiB7XG4gIHBhcnNlOiAocmVmaW5lZDogRXZlbnRSZWZpbmVkLCBkYXRlRW52OiBEYXRlRW52KSA9PiBQYXJzZWRSZWN1cnJpbmc8UmVjdXJyaW5nRGF0YT4gfCBudWxsIC8vIFRPRE86IHJlbmFtZSB0byBwb3N0LXByb2Nlc3Mgb3Igc29tZXRoaW5nXG4gIGV4cGFuZDogKHR5cGVEYXRhOiBhbnksIGZyYW1pbmdSYW5nZTogRGF0ZVJhbmdlLCBkYXRlRW52OiBEYXRlRW52KSA9PiBEYXRlTWFya2VyW11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVjdXJyaW5nKFxuICByZWZpbmVkOiBFdmVudFJlZmluZWQsXG4gIGRlZmF1bHRBbGxEYXk6IGJvb2xlYW4gfCBudWxsLFxuICBkYXRlRW52OiBEYXRlRW52LFxuICByZWN1cnJpbmdUeXBlczogUmVjdXJyaW5nVHlwZTxhbnk+W10sXG4pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN1cnJpbmdUeXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGxldCBwYXJzZWQgPSByZWN1cnJpbmdUeXBlc1tpXS5wYXJzZShyZWZpbmVkLCBkYXRlRW52KVxuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbGV0IHsgYWxsRGF5IH0gPSByZWZpbmVkXG4gICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheVxuICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICBhbGxEYXkgPSBwYXJzZWQuYWxsRGF5R3Vlc3NcbiAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFsbERheSA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFsbERheSxcbiAgICAgICAgZHVyYXRpb246IHBhcnNlZC5kdXJhdGlvbixcbiAgICAgICAgdHlwZURhdGE6IHBhcnNlZC50eXBlRGF0YSxcbiAgICAgICAgdHlwZUlkOiBpLFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSwgZnJhbWluZ1JhbmdlOiBEYXRlUmFuZ2UsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IEV2ZW50U3RvcmUge1xuICBsZXQgeyBkYXRlRW52LCBwbHVnaW5Ib29rcywgb3B0aW9ucyB9ID0gY29udGV4dFxuICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmVcblxuICAvLyByZW1vdmUgZXhpc3RpbmcgcmVjdXJyaW5nIGluc3RhbmNlc1xuICAvLyBUT0RPOiBiYWQuIGFsd2F5cyBleHBhbmQgZXZlbnRzIGFzIGEgc2Vjb25kIHN0ZXBcbiAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIChpbnN0YW5jZTogRXZlbnRJbnN0YW5jZSkgPT4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZilcblxuICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgbGV0IGRlZiA9IGRlZnNbZGVmSWRdXG5cbiAgICBpZiAoZGVmLnJlY3VycmluZ0RlZikge1xuICAgICAgbGV0IHsgZHVyYXRpb24gfSA9IGRlZi5yZWN1cnJpbmdEZWZcblxuICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICBkdXJhdGlvbiA9IGRlZi5hbGxEYXkgP1xuICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvblxuICAgICAgfVxuXG4gICAgICBsZXQgc3RhcnRzID0gZXhwYW5kUmVjdXJyaW5nUmFuZ2VzKGRlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcGx1Z2luSG9va3MucmVjdXJyaW5nVHlwZXMpXG5cbiAgICAgIGZvciAobGV0IHN0YXJ0IG9mIHN0YXJ0cykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZklkLCB7XG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChzdGFydCwgZHVyYXRpb24pLFxuICAgICAgICB9KVxuICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGRlZnMsIGluc3RhbmNlcyB9XG59XG5cbi8qXG5FdmVudCBNVVNUIGhhdmUgYSByZWN1cnJpbmdEZWZcbiovXG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmdSYW5nZXMoXG4gIGV2ZW50RGVmOiBFdmVudERlZixcbiAgZHVyYXRpb246IER1cmF0aW9uLFxuICBmcmFtaW5nUmFuZ2U6IERhdGVSYW5nZSxcbiAgZGF0ZUVudjogRGF0ZUVudixcbiAgcmVjdXJyaW5nVHlwZXM6IFJlY3VycmluZ1R5cGU8YW55PltdLFxuKTogRGF0ZU1hcmtlcltdIHtcbiAgbGV0IHR5cGVEZWYgPSByZWN1cnJpbmdUeXBlc1tldmVudERlZi5yZWN1cnJpbmdEZWYudHlwZUlkXVxuICBsZXQgbWFya2VycyA9IHR5cGVEZWYuZXhwYW5kKFxuICAgIGV2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlRGF0YSxcbiAgICB7XG4gICAgICBzdGFydDogZGF0ZUVudi5zdWJ0cmFjdChmcmFtaW5nUmFuZ2Uuc3RhcnQsIGR1cmF0aW9uKSwgLy8gZm9yIHdoZW4gZXZlbnQgc3RhcnRzIGJlZm9yZSBmcmFtaW5nIHJhbmdlIGFuZCBnb2VzIGludG9cbiAgICAgIGVuZDogZnJhbWluZ1JhbmdlLmVuZCxcbiAgICB9LFxuICAgIGRhdGVFbnYsXG4gIClcblxuICAvLyB0aGUgcmVjdXJyZW5jZSBwbHVnaW5zIGRvbid0IGd1YXJhbnRlZSB0aGF0IGFsbC1kYXkgZXZlbnRzIGFyZSBzdGFydC1vZi1kYXksIHNvIHdlIGhhdmUgdG9cbiAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgIG1hcmtlcnMgPSBtYXJrZXJzLm1hcChzdGFydE9mRGF5KVxuICB9XG5cbiAgcmV0dXJuIG1hcmtlcnNcbn1cbiIsImltcG9ydCB7IGlzSW50IH0gZnJvbSAnLi4vdXRpbC9taXNjJ1xuXG5leHBvcnQgdHlwZSBEdXJhdGlvbklucHV0ID0gRHVyYXRpb25PYmplY3RJbnB1dCB8IHN0cmluZyB8IG51bWJlclxuXG5leHBvcnQgaW50ZXJmYWNlIER1cmF0aW9uT2JqZWN0SW5wdXQge1xuICB5ZWFycz86IG51bWJlclxuICB5ZWFyPzogbnVtYmVyXG4gIG1vbnRocz86IG51bWJlclxuICBtb250aD86IG51bWJlclxuICB3ZWVrcz86IG51bWJlclxuICB3ZWVrPzogbnVtYmVyXG4gIGRheXM/OiBudW1iZXJcbiAgZGF5PzogbnVtYmVyXG4gIGhvdXJzPzogbnVtYmVyXG4gIGhvdXI/OiBudW1iZXJcbiAgbWludXRlcz86IG51bWJlclxuICBtaW51dGU/OiBudW1iZXJcbiAgc2Vjb25kcz86IG51bWJlclxuICBzZWNvbmQ/OiBudW1iZXJcbiAgbWlsbGlzZWNvbmRzPzogbnVtYmVyXG4gIG1pbGxpc2Vjb25kPzogbnVtYmVyXG4gIG1zPzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHVyYXRpb24ge1xuICB5ZWFyczogbnVtYmVyXG4gIG1vbnRoczogbnVtYmVyXG4gIGRheXM6IG51bWJlclxuICBtaWxsaXNlY29uZHM6IG51bWJlclxuICBzcGVjaWZpZWRXZWVrcz86IGJvb2xlYW5cbn1cblxuY29uc3QgSU5URVJOQUxfVU5JVFMgPSBbJ3llYXJzJywgJ21vbnRocycsICdkYXlzJywgJ21pbGxpc2Vjb25kcyddXG5jb25zdCBQQVJTRV9SRSA9IC9eKC0/KSg/OihcXGQrKVxcLik/KFxcZCspOihcXGRcXGQpKD86OihcXGRcXGQpKD86XFwuKFxcZFxcZFxcZCkpPyk/L1xuXG4vLyBQYXJzaW5nIGFuZCBDcmVhdGlvblxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24oaW5wdXQ6IER1cmF0aW9uSW5wdXQsIHVuaXQ/OiBzdHJpbmcpOiBEdXJhdGlvbiB8IG51bGwge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0cmluZyhpbnB1dClcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgIHJldHVybiBwYXJzZU9iamVjdChpbnB1dClcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KHsgW3VuaXQgfHwgJ21pbGxpc2Vjb25kcyddOiBpbnB1dCB9KVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHM6IHN0cmluZyk6IER1cmF0aW9uIHtcbiAgbGV0IG0gPSBQQVJTRV9SRS5leGVjKHMpXG4gIGlmIChtKSB7XG4gICAgbGV0IHNpZ24gPSBtWzFdID8gLTEgOiAxXG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXJzOiAwLFxuICAgICAgbW9udGhzOiAwLFxuICAgICAgZGF5czogc2lnbiAqIChtWzJdID8gcGFyc2VJbnQobVsyXSwgMTApIDogMCksXG4gICAgICBtaWxsaXNlY29uZHM6IHNpZ24gKiAoXG4gICAgICAgIChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgIChtWzRdID8gcGFyc2VJbnQobVs0XSwgMTApIDogMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAgIChtWzVdID8gcGFyc2VJbnQobVs1XSwgMTApIDogMCkgKiAxMDAwICsgLy8gc2Vjb25kc1xuICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXG4gICAgICApLFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBwYXJzZU9iamVjdChvYmo6IER1cmF0aW9uT2JqZWN0SW5wdXQpOiBEdXJhdGlvbiB7XG4gIGxldCBkdXJhdGlvbjogRHVyYXRpb24gPSB7XG4gICAgeWVhcnM6IG9iai55ZWFycyB8fCBvYmoueWVhciB8fCAwLFxuICAgIG1vbnRoczogb2JqLm1vbnRocyB8fCBvYmoubW9udGggfHwgMCxcbiAgICBkYXlzOiBvYmouZGF5cyB8fCBvYmouZGF5IHx8IDAsXG4gICAgbWlsbGlzZWNvbmRzOlxuICAgICAgKG9iai5ob3VycyB8fCBvYmouaG91ciB8fCAwKSAqIDYwICogNjAgKiAxMDAwICsgLy8gaG91cnNcbiAgICAgIChvYmoubWludXRlcyB8fCBvYmoubWludXRlIHx8IDApICogNjAgKiAxMDAwICsgLy8gbWludXRlc1xuICAgICAgKG9iai5zZWNvbmRzIHx8IG9iai5zZWNvbmQgfHwgMCkgKiAxMDAwICsgLy8gc2Vjb25kc1xuICAgICAgKG9iai5taWxsaXNlY29uZHMgfHwgb2JqLm1pbGxpc2Vjb25kIHx8IG9iai5tcyB8fCAwKSwgLy8gbXNcbiAgfVxuXG4gIGxldCB3ZWVrcyA9IG9iai53ZWVrcyB8fCBvYmoud2Vla1xuICBpZiAod2Vla3MpIHtcbiAgICBkdXJhdGlvbi5kYXlzICs9IHdlZWtzICogN1xuICAgIGR1cmF0aW9uLnNwZWNpZmllZFdlZWtzID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGR1cmF0aW9uXG59XG5cbi8vIEVxdWFsaXR5XG5cbmV4cG9ydCBmdW5jdGlvbiBkdXJhdGlvbnNFcXVhbChkMDogRHVyYXRpb24sIGQxOiBEdXJhdGlvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gZDAueWVhcnMgPT09IGQxLnllYXJzICYmXG4gICAgZDAubW9udGhzID09PSBkMS5tb250aHMgJiZcbiAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXG4gICAgZDAubWlsbGlzZWNvbmRzID09PSBkMS5taWxsaXNlY29uZHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzQ2xlYW5EYXlzKGR1cjogRHVyYXRpb24pIHtcbiAgaWYgKCFkdXIueWVhcnMgJiYgIWR1ci5tb250aHMgJiYgIWR1ci5taWxsaXNlY29uZHMpIHtcbiAgICByZXR1cm4gZHVyLmRheXNcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vLyBTaW1wbGUgTWF0aFxuXG5leHBvcnQgZnVuY3Rpb24gYWRkRHVyYXRpb25zKGQwOiBEdXJhdGlvbiwgZDE6IER1cmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXG4gICAgbW9udGhzOiBkMC5tb250aHMgKyBkMS5tb250aHMsXG4gICAgZGF5czogZDAuZGF5cyArIGQxLmRheXMsXG4gICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHMsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0RHVyYXRpb25zKGQxOiBEdXJhdGlvbiwgZDA6IER1cmF0aW9uKTogRHVyYXRpb24ge1xuICByZXR1cm4ge1xuICAgIHllYXJzOiBkMS55ZWFycyAtIGQwLnllYXJzLFxuICAgIG1vbnRoczogZDEubW9udGhzIC0gZDAubW9udGhzLFxuICAgIGRheXM6IGQxLmRheXMgLSBkMC5kYXlzLFxuICAgIG1pbGxpc2Vjb25kczogZDEubWlsbGlzZWNvbmRzIC0gZDAubWlsbGlzZWNvbmRzLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQ6IER1cmF0aW9uLCBuOiBudW1iZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB5ZWFyczogZC55ZWFycyAqIG4sXG4gICAgbW9udGhzOiBkLm1vbnRocyAqIG4sXG4gICAgZGF5czogZC5kYXlzICogbixcbiAgICBtaWxsaXNlY29uZHM6IGQubWlsbGlzZWNvbmRzICogbixcbiAgfVxufVxuXG4vLyBDb252ZXJzaW9uc1xuLy8gXCJSb3VnaFwiIGJlY2F1c2UgdGhleSBhcmUgYmFzZWQgb24gYXZlcmFnZS1jYXNlIEdyZWdvcmlhbiBtb250aHMveWVhcnNcblxuZXhwb3J0IGZ1bmN0aW9uIGFzUm91Z2hZZWFycyhkdXI6IER1cmF0aW9uKSB7XG4gIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzY1XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cjogRHVyYXRpb24pIHtcbiAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzMFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNSb3VnaERheXMoZHVyOiBEdXJhdGlvbikge1xuICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNSb3VnaEhvdXJzKGR1cjogRHVyYXRpb24pIHtcbiAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gKDEwMDAgKiA2MCAqIDYwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNSb3VnaE1pbnV0ZXMoZHVyOiBEdXJhdGlvbikge1xuICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyAoMTAwMCAqIDYwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyOiBEdXJhdGlvbikge1xuICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyAxMDAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1JvdWdoTXMoZHVyOiBEdXJhdGlvbikge1xuICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXG4gICAgZHVyLm1vbnRocyAqICgzMCAqIDg2NGU1KSArXG4gICAgZHVyLmRheXMgKiA4NjRlNSArXG4gICAgZHVyLm1pbGxpc2Vjb25kc1xufVxuXG4vLyBBZHZhbmNlZCBNYXRoXG5cbmV4cG9ydCBmdW5jdGlvbiB3aG9sZURpdmlkZUR1cmF0aW9ucyhudW1lcmF0b3I6IER1cmF0aW9uLCBkZW5vbWluYXRvcjogRHVyYXRpb24pOiBudW1iZXIge1xuICBsZXQgcmVzID0gbnVsbFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5URVJOQUxfVU5JVFMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBsZXQgdW5pdCA9IElOVEVSTkFMX1VOSVRTW2ldXG5cbiAgICBpZiAoZGVub21pbmF0b3JbdW5pdF0pIHtcbiAgICAgIGxldCBsb2NhbFJlcyA9IG51bWVyYXRvclt1bml0XSAvIGRlbm9taW5hdG9yW3VuaXRdXG5cbiAgICAgIGlmICghaXNJbnQobG9jYWxSZXMpIHx8IChyZXMgIT09IG51bGwgJiYgcmVzICE9PSBsb2NhbFJlcykpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgcmVzID0gbG9jYWxSZXNcbiAgICB9IGVsc2UgaWYgKG51bWVyYXRvclt1bml0XSkge1xuICAgICAgLy8gbmVlZHMgdG8gZGl2aWRlIGJ5IHNvbWV0aGluZyBidXQgY2FuJ3QhXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXI6IER1cmF0aW9uKSB7XG4gIGxldCBtcyA9IGR1ci5taWxsaXNlY29uZHNcbiAgaWYgKG1zKSB7XG4gICAgaWYgKG1zICUgMTAwMCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IG1zIH1cbiAgICB9XG4gICAgaWYgKG1zICUgKDEwMDAgKiA2MCkgIT09IDApIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICdzZWNvbmQnLCB2YWx1ZTogbXMgLyAxMDAwIH1cbiAgICB9XG4gICAgaWYgKG1zICUgKDEwMDAgKiA2MCAqIDYwKSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbnV0ZScsIHZhbHVlOiBtcyAvICgxMDAwICogNjApIH1cbiAgICB9XG4gICAgaWYgKG1zKSB7XG4gICAgICByZXR1cm4geyB1bml0OiAnaG91cicsIHZhbHVlOiBtcyAvICgxMDAwICogNjAgKiA2MCkgfVxuICAgIH1cbiAgfVxuICBpZiAoZHVyLmRheXMpIHtcbiAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9XG4gIH1cbiAgaWYgKGR1ci5tb250aHMpIHtcbiAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9XG4gIH1cbiAgaWYgKGR1ci55ZWFycykge1xuICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9XG4gIH1cbiAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IDAgfVxufVxuIiwiaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4vbWFya2VyJ1xuaW1wb3J0IHsgcGFkU3RhcnQgfSBmcm9tICcuLi91dGlsL21pc2MnXG5cbi8vIHRpbWVab25lT2Zmc2V0IGlzIGluIG1pbnV0ZXNcbmV4cG9ydCBmdW5jdGlvbiBidWlsZElzb1N0cmluZyhtYXJrZXI6IERhdGVNYXJrZXIsIHRpbWVab25lT2Zmc2V0PzogbnVtYmVyLCBzdHJpcFplcm9UaW1lOiBib29sZWFuID0gZmFsc2UpIHtcbiAgbGV0IHMgPSBtYXJrZXIudG9JU09TdHJpbmcoKVxuXG4gIHMgPSBzLnJlcGxhY2UoJy4wMDAnLCAnJylcblxuICBpZiAoc3RyaXBaZXJvVGltZSkge1xuICAgIHMgPSBzLnJlcGxhY2UoJ1QwMDowMDowMFonLCAnJylcbiAgfVxuXG4gIGlmIChzLmxlbmd0aCA+IDEwKSB7IC8vIHRpbWUgcGFydCB3YXNuJ3Qgc3RyaXBwZWQsIGNhbiBhZGQgdGltZXpvbmUgaW5mb1xuICAgIGlmICh0aW1lWm9uZU9mZnNldCA9PSBudWxsKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKCdaJywgJycpXG4gICAgfSBlbHNlIGlmICh0aW1lWm9uZU9mZnNldCAhPT0gMCkge1xuICAgICAgcyA9IHMucmVwbGFjZSgnWicsIGZvcm1hdFRpbWVab25lT2Zmc2V0KHRpbWVab25lT2Zmc2V0LCB0cnVlKSlcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlLCBpdHMgVVRDLTAgYW5kIHdlIHdhbnQgdG8ga2VlcCB0aGUgWlxuICB9XG5cbiAgcmV0dXJuIHNcbn1cblxuLy8gZm9ybWF0cyB0aGUgZGF0ZSwgYnV0IHdpdGggbm8gdGltZSBwYXJ0XG4vLyBUT0RPOiBzb21laG93IG1lcmdlIHdpdGggYnVpbGRJc29TdHJpbmcgYW5kIHN0cmlwWmVyb1RpbWVcbi8vIFRPRE86IHJlbmFtZS4gb21pdCBcInN0cmluZ1wiXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF5U3RyaW5nKG1hcmtlcjogRGF0ZU1hcmtlcikge1xuICByZXR1cm4gbWFya2VyLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvVC4qJC8sICcnKVxufVxuXG4vLyBUT0RPOiB1c2UgRGF0ZTo6dG9JU09TdHJpbmcgYW5kIHVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBUP1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdElzb1RpbWVTdHJpbmcobWFya2VyOiBEYXRlTWFya2VyKSB7XG4gIHJldHVybiBwYWRTdGFydChtYXJrZXIuZ2V0VVRDSG91cnMoKSwgMikgKyAnOicgK1xuICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENNaW51dGVzKCksIDIpICsgJzonICtcbiAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDU2Vjb25kcygpLCAyKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VGltZVpvbmVPZmZzZXQobWludXRlczogbnVtYmVyLCBkb0lzbyA9IGZhbHNlKSB7XG4gIGxldCBzaWduID0gbWludXRlcyA8IDAgPyAnLScgOiAnKydcbiAgbGV0IGFicyA9IE1hdGguYWJzKG1pbnV0ZXMpXG4gIGxldCBob3VycyA9IE1hdGguZmxvb3IoYWJzIC8gNjApXG4gIGxldCBtaW5zID0gTWF0aC5yb3VuZChhYnMgJSA2MClcblxuICBpZiAoZG9Jc28pIHtcbiAgICByZXR1cm4gYCR7c2lnbiArIHBhZFN0YXJ0KGhvdXJzLCAyKX06JHtwYWRTdGFydChtaW5zLCAyKX1gXG4gIH1cbiAgcmV0dXJuIGBHTVQke3NpZ259JHtob3Vyc30ke21pbnMgPyBgOiR7cGFkU3RhcnQobWlucywgMil9YCA6ICcnfWBcbn1cbiIsIi8vIFRPRE86IG5ldyB1dGlsIGFycmF5aWZ5P1xuLy8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoXG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVNYXRjaGluZyhhcnJheSwgdGVzdEZ1bmMpIHtcbiAgbGV0IHJlbW92ZUNudCA9IDBcbiAgbGV0IGkgPSAwXG5cbiAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGgpIHtcbiAgICBpZiAodGVzdEZ1bmMoYXJyYXlbaV0pKSB7IC8vIHRydXRoeSB2YWx1ZSBtZWFucyAqcmVtb3ZlKlxuICAgICAgYXJyYXkuc3BsaWNlKGksIDEpXG4gICAgICByZW1vdmVDbnQgKz0gMVxuICAgIH0gZWxzZSB7XG4gICAgICBpICs9IDFcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlQ250XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVFeGFjdChhcnJheSwgZXhhY3RWYWwpIHtcbiAgbGV0IHJlbW92ZUNudCA9IDBcbiAgbGV0IGkgPSAwXG5cbiAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IGV4YWN0VmFsKSB7XG4gICAgICBhcnJheS5zcGxpY2UoaSwgMSlcbiAgICAgIHJlbW92ZUNudCArPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGkgKz0gMVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZW1vdmVDbnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlzRXF1YWwoYTAsIGExLCBlcXVhbGl0eUZ1bmM/OiAodjAsIHYxKSA9PiBib29sZWFuKSB7IC8vIFRPRE86IGJldHRlciB0eXBpbmdcbiAgaWYgKGEwID09PSBhMSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBsZXQgbGVuID0gYTAubGVuZ3RoXG4gIGxldCBpXG5cbiAgaWYgKGxlbiAhPT0gYTEubGVuZ3RoKSB7IC8vIG5vdCBhcnJheT8gb3Igbm90IHNhbWUgbGVuZ3RoP1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgaWYgKCEoZXF1YWxpdHlGdW5jID8gZXF1YWxpdHlGdW5jKGEwW2ldLCBhMVtpXSkgOiBhMFtpXSA9PT0gYTFbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwiaW1wb3J0IHsgaXNBcnJheXNFcXVhbCB9IGZyb20gJy4vYXJyYXknXG5pbXBvcnQgeyBpc1Byb3BzRXF1YWwgfSBmcm9tICcuL29iamVjdCdcbmltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZTxBcmdzIGV4dGVuZHMgYW55W10sIFJlcz4oXG4gIHdvcmtlckZ1bmM6ICguLi5hcmdzOiBBcmdzKSA9PiBSZXMsXG4gIHJlc0VxdWFsaXR5PzogKHJlczA6IFJlcywgcmVzMTogUmVzKSA9PiBib29sZWFuLFxuICB0ZWFyZG93bkZ1bmM/OiAocmVzOiBSZXMpID0+IHZvaWQsXG4pOiAoLi4uYXJnczogQXJncykgPT4gUmVzIHtcbiAgbGV0IGN1cnJlbnRBcmdzOiBBcmdzIHwgdW5kZWZpbmVkXG4gIGxldCBjdXJyZW50UmVzOiBSZXMgfCB1bmRlZmluZWRcblxuICByZXR1cm4gZnVuY3Rpb24gKC4uLm5ld0FyZ3M6IEFyZ3MpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWVzXG4gICAgaWYgKCFjdXJyZW50QXJncykge1xuICAgICAgY3VycmVudFJlcyA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJncylcbiAgICB9IGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdzLCBuZXdBcmdzKSkge1xuICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlcylcbiAgICAgIH1cblxuICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJncylcblxuICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICBjdXJyZW50UmVzID0gcmVzXG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudEFyZ3MgPSBuZXdBcmdzXG5cbiAgICByZXR1cm4gY3VycmVudFJlc1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplT2JqQXJnPEFyZyBleHRlbmRzIERpY3Rpb25hcnksIFJlcz4oXG4gIHdvcmtlckZ1bmM6IChhcmc6IEFyZykgPT4gUmVzLFxuICByZXNFcXVhbGl0eT86IChyZXMwOiBSZXMsIHJlczE6IFJlcykgPT4gYm9vbGVhbixcbiAgdGVhcmRvd25GdW5jPzogKHJlczogUmVzKSA9PiB2b2lkLFxuKTogKGFyZzogQXJnKSA9PiBSZXMge1xuICBsZXQgY3VycmVudEFyZzogQXJnIHwgdW5kZWZpbmVkXG4gIGxldCBjdXJyZW50UmVzOiBSZXMgfCB1bmRlZmluZWRcblxuICByZXR1cm4gKG5ld0FyZzogQXJnKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50QXJnKSB7XG4gICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZylcbiAgICB9IGVsc2UgaWYgKCFpc1Byb3BzRXF1YWwoY3VycmVudEFyZywgbmV3QXJnKSkge1xuICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlcylcbiAgICAgIH1cblxuICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuY2FsbCh0aGlzLCBuZXdBcmcpXG5cbiAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlcykpIHtcbiAgICAgICAgY3VycmVudFJlcyA9IHJlc1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRBcmcgPSBuZXdBcmdcblxuICAgIHJldHVybiBjdXJyZW50UmVzXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemVBcnJheWxpa2U8QXJncyBleHRlbmRzIGFueVtdLCBSZXM+KCAvLyB1c2VkIGF0IGFsbD9cbiAgd29ya2VyRnVuYzogKC4uLmFyZ3M6IEFyZ3MpID0+IFJlcyxcbiAgcmVzRXF1YWxpdHk/OiAocmVzMDogUmVzLCByZXMxOiBSZXMpID0+IGJvb2xlYW4sXG4gIHRlYXJkb3duRnVuYz86IChyZXM6IFJlcykgPT4gdm9pZCxcbik6IChhcmdTZXRzOiBBcmdzW10pID0+IFJlc1tdIHtcbiAgbGV0IGN1cnJlbnRBcmdTZXRzOiBBcmdzW10gPSBbXVxuICBsZXQgY3VycmVudFJlc3VsdHM6IFJlc1tdID0gW11cblxuICByZXR1cm4gKG5ld0FyZ1NldHM6IEFyZ3NbXSkgPT4ge1xuICAgIGxldCBjdXJyZW50TGVuID0gY3VycmVudEFyZ1NldHMubGVuZ3RoXG4gICAgbGV0IG5ld0xlbiA9IG5ld0FyZ1NldHMubGVuZ3RoXG4gICAgbGV0IGkgPSAwXG5cbiAgICBmb3IgKDsgaSA8IGN1cnJlbnRMZW47IGkgKz0gMSkge1xuICAgICAgaWYgKCFuZXdBcmdTZXRzW2ldKSB7IC8vIG9uZSBvZiB0aGUgb2xkIHNldHMgbm8gbG9uZ2VyIGV4aXN0c1xuICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXN1bHRzW2ldKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdTZXRzW2ldLCBuZXdBcmdTZXRzW2ldKSkge1xuICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXN1bHRzW2ldKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJnU2V0c1tpXSlcblxuICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXN1bHRzW2ldKSkge1xuICAgICAgICAgIGN1cnJlbnRSZXN1bHRzW2ldID0gcmVzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IG5ld0xlbjsgaSArPSAxKSB7XG4gICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJnU2V0c1tpXSlcbiAgICB9XG5cbiAgICBjdXJyZW50QXJnU2V0cyA9IG5ld0FyZ1NldHNcbiAgICBjdXJyZW50UmVzdWx0cy5zcGxpY2UobmV3TGVuKSAvLyByZW1vdmUgZXhjZXNzXG5cbiAgICByZXR1cm4gY3VycmVudFJlc3VsdHNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZUhhc2hsaWtlPEFyZ3MgZXh0ZW5kcyBhbnlbXSwgUmVzPiggLy8gdXNlZD9cbiAgd29ya2VyRnVuYzogKC4uLmFyZ3M6IEFyZ3MpID0+IFJlcyxcbiAgcmVzRXF1YWxpdHk/OiAocmVzMDogUmVzLCByZXMxOiBSZXMpID0+IGJvb2xlYW4sXG4gIHRlYXJkb3duRnVuYz86IChyZXM6IFJlcykgPT4gdm9pZCwgLy8gVE9ETzogY2hhbmdlIGFyZyBvcmRlclxuKTogKGFyZ0hhc2g6IHsgW2tleTogc3RyaW5nXTogQXJncyB9KSA9PiB7IFtrZXk6IHN0cmluZ106IFJlcyB9IHtcbiAgbGV0IGN1cnJlbnRBcmdIYXNoOiB7IFtrZXk6IHN0cmluZ106IEFyZ3MgfSA9IHt9XG4gIGxldCBjdXJyZW50UmVzSGFzaDogeyBba2V5OiBzdHJpbmddOiBSZXMgfSA9IHt9XG5cbiAgcmV0dXJuIChuZXdBcmdIYXNoOiB7IFtrZXk6IHN0cmluZ106IEFyZ3MgfSkgPT4ge1xuICAgIGxldCBuZXdSZXNIYXNoOiB7IFtrZXk6IHN0cmluZ106IFJlcyB9ID0ge31cblxuICAgIGZvciAobGV0IGtleSBpbiBuZXdBcmdIYXNoKSB7XG4gICAgICBpZiAoIWN1cnJlbnRSZXNIYXNoW2tleV0pIHtcbiAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdIYXNoW2tleV0sIG5ld0FyZ0hhc2hba2V5XSkpIHtcbiAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzSGFzaFtrZXldKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJnSGFzaFtrZXldKVxuXG4gICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IChyZXNFcXVhbGl0eSAmJiByZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXNIYXNoW2tleV0pKVxuICAgICAgICAgID8gY3VycmVudFJlc0hhc2hba2V5XVxuICAgICAgICAgIDogcmVzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSBjdXJyZW50UmVzSGFzaFtrZXldXG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudEFyZ0hhc2ggPSBuZXdBcmdIYXNoXG4gICAgY3VycmVudFJlc0hhc2ggPSBuZXdSZXNIYXNoXG5cbiAgICByZXR1cm4gbmV3UmVzSGFzaFxuICB9XG59XG4iLCJpbXBvcnQgeyBEYXRlTWFya2VyLCB0aW1lQXNNcyB9IGZyb20gJy4vbWFya2VyJ1xuaW1wb3J0IHsgQ2FsZW5kYXJTeXN0ZW0gfSBmcm9tICcuL2NhbGVuZGFyLXN5c3RlbSdcbmltcG9ydCB7IExvY2FsZSB9IGZyb20gJy4vbG9jYWxlJ1xuaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciwgRGF0ZUZvcm1hdHRpbmdDb250ZXh0IH0gZnJvbSAnLi9EYXRlRm9ybWF0dGVyJ1xuaW1wb3J0IHsgWm9uZWRNYXJrZXIgfSBmcm9tICcuL3pvbmVkLW1hcmtlcidcbmltcG9ydCB7IGZvcm1hdFRpbWVab25lT2Zmc2V0IH0gZnJvbSAnLi9mb3JtYXR0aW5nLXV0aWxzJ1xuaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJy4uL3V0aWwvbWVtb2l6ZSdcblxuY29uc3QgRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVMgPSB7XG4gIHdlZWs6IDMsXG4gIHNlcGFyYXRvcjogMCwgLy8gMCA9IG5vdCBhcHBsaWNhYmxlXG4gIG9taXRaZXJvTWludXRlOiAwLFxuICBtZXJpZGllbTogMCwgLy8gbGlrZSBhbS9wbVxuICBvbWl0Q29tbWFzOiAwLFxufVxuXG5jb25zdCBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUyA9IHtcbiAgdGltZVpvbmVOYW1lOiA3LFxuICBlcmE6IDYsXG4gIHllYXI6IDUsXG4gIG1vbnRoOiA0LFxuICBkYXk6IDIsXG4gIHdlZWtkYXk6IDIsXG4gIGhvdXI6IDEsXG4gIG1pbnV0ZTogMSxcbiAgc2Vjb25kOiAxLFxufVxuXG5jb25zdCBNRVJJRElFTV9SRSA9IC9cXHMqKFthcF0pXFwuP21cXC4/L2kgLy8gZWF0cyB1cCBsZWFkaW5nIHNwYWNlcyB0b29cbmNvbnN0IENPTU1BX1JFID0gLywvZyAvLyB3ZSBuZWVkIHJlIGZvciBnbG9iYWxuZXNzXG5jb25zdCBNVUxUSV9TUEFDRV9SRSA9IC9cXHMrL2dcbmNvbnN0IExUUl9SRSA9IC9cXHUyMDBlL2cgLy8gY29udHJvbCBjaGFyYWN0ZXJcbmNvbnN0IFVUQ19SRSA9IC9VVEN8R01UL1xuXG5leHBvcnQgaW50ZXJmYWNlIE5hdGl2ZUZvcm1hdHRlck9wdGlvbnMgZXh0ZW5kcyBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9ucyB7XG4gIHdlZWs/OiAnc2hvcnQnIHwgJ25hcnJvdycgfCAnbnVtZXJpYydcbiAgbWVyaWRpZW0/OiAnbG93ZXJjYXNlJyB8ICdzaG9ydCcgfCAnbmFycm93JyB8IGJvb2xlYW5cbiAgb21pdFplcm9NaW51dGU/OiBib29sZWFuXG4gIG9taXRDb21tYXM/OiBib29sZWFuXG4gIHNlcGFyYXRvcj86IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgTmF0aXZlRm9ybWF0dGVyIGltcGxlbWVudHMgRGF0ZUZvcm1hdHRlciB7XG4gIHN0YW5kYXJkRGF0ZVByb3BzOiBhbnlcbiAgZXh0ZW5kZWRTZXR0aW5nczogYW55XG4gIHNldmVyaXR5OiBudW1iZXJcbiAgcHJpdmF0ZSBidWlsZEZvcm1hdHRpbmdGdW5jOiB0eXBlb2YgYnVpbGRGb3JtYXR0aW5nRnVuYyAvLyBjYWNoaW5nIGZvciBlZmZpY2llbmN5IHdpdGggc2FtZSBkYXRlIGVudlxuXG4gIGNvbnN0cnVjdG9yKGZvcm1hdFNldHRpbmdzOiBOYXRpdmVGb3JtYXR0ZXJPcHRpb25zKSB7XG4gICAgbGV0IHN0YW5kYXJkRGF0ZVByb3BzOiBhbnkgPSB7fVxuICAgIGxldCBleHRlbmRlZFNldHRpbmdzOiBhbnkgPSB7fVxuICAgIGxldCBzZXZlcml0eSA9IDBcblxuICAgIGZvciAobGV0IG5hbWUgaW4gZm9ybWF0U2V0dGluZ3MpIHtcbiAgICAgIGlmIChuYW1lIGluIEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTKSB7XG4gICAgICAgIGV4dGVuZGVkU2V0dGluZ3NbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXVxuICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTW25hbWVdLCBzZXZlcml0eSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzW25hbWVdID0gZm9ybWF0U2V0dGluZ3NbbmFtZV1cblxuICAgICAgICBpZiAobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgeyAvLyBUT0RPOiB3aGF0IGFib3V0IGhvdXIxMj8gbm8gc2V2ZXJpdHlcbiAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVdLCBzZXZlcml0eSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhbmRhcmREYXRlUHJvcHMgPSBzdGFuZGFyZERhdGVQcm9wc1xuICAgIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncyA9IGV4dGVuZGVkU2V0dGluZ3NcbiAgICB0aGlzLnNldmVyaXR5ID0gc2V2ZXJpdHlcblxuICAgIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyA9IG1lbW9pemUoYnVpbGRGb3JtYXR0aW5nRnVuYylcbiAgfVxuXG4gIGZvcm1hdChkYXRlOiBab25lZE1hcmtlciwgY29udGV4dDogRGF0ZUZvcm1hdHRpbmdDb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyh0aGlzLnN0YW5kYXJkRGF0ZVByb3BzLCB0aGlzLmV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpKGRhdGUpXG4gIH1cblxuICBmb3JtYXRSYW5nZShzdGFydDogWm9uZWRNYXJrZXIsIGVuZDogWm9uZWRNYXJrZXIsIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcj86IHN0cmluZykge1xuICAgIGxldCB7IHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzIH0gPSB0aGlzXG5cbiAgICBsZXQgZGlmZlNldmVyaXR5ID0gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShzdGFydC5tYXJrZXIsIGVuZC5tYXJrZXIsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pXG4gICAgaWYgKCFkaWZmU2V2ZXJpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdChzdGFydCwgY29udGV4dClcbiAgICB9XG5cbiAgICBsZXQgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gZGlmZlNldmVyaXR5XG4gICAgaWYgKFxuICAgICAgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID4gMSAmJiAvLyB0aGUgdHdvIGRhdGVzIGFyZSBkaWZmZXJlbnQgaW4gYSB3YXkgdGhhdCdzIGxhcmdlciBzY2FsZSB0aGFuIHRpbWVcbiAgICAgIChzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMueWVhciA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLm1vbnRoID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICcyLWRpZ2l0JykgJiZcbiAgICAgIChzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICcyLWRpZ2l0JylcbiAgICApIHtcbiAgICAgIGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA9IDEgLy8gbWFrZSBpdCBsb29rIGxpa2UgdGhlIGRhdGVzIGFyZSBvbmx5IGRpZmZlcmVudCBpbiB0ZXJtcyBvZiB0aW1lXG4gICAgfVxuXG4gICAgbGV0IGZ1bGwwID0gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpXG4gICAgbGV0IGZ1bGwxID0gdGhpcy5mb3JtYXQoZW5kLCBjb250ZXh0KVxuXG4gICAgaWYgKGZ1bGwwID09PSBmdWxsMSkge1xuICAgICAgcmV0dXJuIGZ1bGwwXG4gICAgfVxuXG4gICAgbGV0IHBhcnRpYWxEYXRlUHJvcHMgPSBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKHN0YW5kYXJkRGF0ZVByb3BzLCBiaWdnZXN0VW5pdEZvclBhcnRpYWwpXG4gICAgbGV0IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyA9IGJ1aWxkRm9ybWF0dGluZ0Z1bmMocGFydGlhbERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dClcbiAgICBsZXQgcGFydGlhbDAgPSBwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMoc3RhcnQpXG4gICAgbGV0IHBhcnRpYWwxID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKGVuZClcblxuICAgIGxldCBpbnNlcnRpb24gPSBmaW5kQ29tbW9uSW5zZXJ0aW9uKGZ1bGwwLCBwYXJ0aWFsMCwgZnVsbDEsIHBhcnRpYWwxKVxuICAgIGxldCBzZXBhcmF0b3IgPSBleHRlbmRlZFNldHRpbmdzLnNlcGFyYXRvciB8fCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIHx8IGNvbnRleHQuZGVmYXVsdFNlcGFyYXRvciB8fCAnJ1xuXG4gICAgaWYgKGluc2VydGlvbikge1xuICAgICAgcmV0dXJuIGluc2VydGlvbi5iZWZvcmUgKyBwYXJ0aWFsMCArIHNlcGFyYXRvciArIHBhcnRpYWwxICsgaW5zZXJ0aW9uLmFmdGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwwICsgc2VwYXJhdG9yICsgZnVsbDFcbiAgfVxuXG4gIGdldExhcmdlc3RVbml0KCkge1xuICAgIHN3aXRjaCAodGhpcy5zZXZlcml0eSkge1xuICAgICAgY2FzZSA3OlxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gJ3llYXInXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiAnbW9udGgnXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiAnd2VlaydcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuICdkYXknXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ3RpbWUnIC8vIHJlYWxseT9cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRGb3JtYXR0aW5nRnVuYyhcbiAgc3RhbmRhcmREYXRlUHJvcHMsXG4gIGV4dGVuZGVkU2V0dGluZ3MsXG4gIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCxcbik6IChkYXRlOiBab25lZE1hcmtlcikgPT4gc3RyaW5nIHtcbiAgbGV0IHN0YW5kYXJkRGF0ZVByb3BDbnQgPSBPYmplY3Qua2V5cyhzdGFuZGFyZERhdGVQcm9wcykubGVuZ3RoXG5cbiAgaWYgKHN0YW5kYXJkRGF0ZVByb3BDbnQgPT09IDEgJiYgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnc2hvcnQnKSB7XG4gICAgcmV0dXJuIChkYXRlOiBab25lZE1hcmtlcikgPT4gKFxuICAgICAgZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMCAmJiBleHRlbmRlZFNldHRpbmdzLndlZWspIHtcbiAgICByZXR1cm4gKGRhdGU6IFpvbmVkTWFya2VyKSA9PiAoXG4gICAgICBmb3JtYXRXZWVrTnVtYmVyKFxuICAgICAgICBjb250ZXh0LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUubWFya2VyKSxcbiAgICAgICAgY29udGV4dC53ZWVrVGV4dCxcbiAgICAgICAgY29udGV4dC5sb2NhbGUsXG4gICAgICAgIGV4dGVuZGVkU2V0dGluZ3Mud2VlayxcbiAgICAgIClcbiAgICApXG4gIH1cblxuICByZXR1cm4gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dClcbn1cblxuZnVuY3Rpb24gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhcbiAgc3RhbmRhcmREYXRlUHJvcHMsXG4gIGV4dGVuZGVkU2V0dGluZ3MsXG4gIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCxcbik6IChkYXRlOiBab25lZE1hcmtlcikgPT4gc3RyaW5nIHtcbiAgc3RhbmRhcmREYXRlUHJvcHMgPSB7IC4uLnN0YW5kYXJkRGF0ZVByb3BzIH0gLy8gY29weVxuICBleHRlbmRlZFNldHRpbmdzID0geyAuLi5leHRlbmRlZFNldHRpbmdzIH0gLy8gY29weVxuXG4gIHNhbml0aXplU2V0dGluZ3Moc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MpXG5cbiAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmUgPSAnVVRDJyAvLyB3ZSBsZXZlcmFnZSB0aGUgb25seSBndWFyYW50ZWVkIHRpbWVab25lIGZvciBvdXIgVVRDIG1hcmtlcnNcblxuICBsZXQgbm9ybWFsRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHN0YW5kYXJkRGF0ZVByb3BzKVxuICBsZXQgemVyb0Zvcm1hdCAvLyBuZWVkZWQ/XG5cbiAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGUpIHtcbiAgICBsZXQgemVyb1Byb3BzID0geyAuLi5zdGFuZGFyZERhdGVQcm9wcyB9XG4gICAgZGVsZXRlIHplcm9Qcm9wcy5taW51dGUgLy8gc2Vjb25kcyBhbmQgbXMgd2VyZSBhbHJlYWR5IGNvbnNpZGVyZWQgaW4gc2FuaXRpemVTZXR0aW5nc1xuICAgIHplcm9Gb3JtYXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChjb250ZXh0LmxvY2FsZS5jb2RlcywgemVyb1Byb3BzKVxuICB9XG5cbiAgcmV0dXJuIChkYXRlOiBab25lZE1hcmtlcikgPT4ge1xuICAgIGxldCB7IG1hcmtlciB9ID0gZGF0ZVxuICAgIGxldCBmb3JtYXRcblxuICAgIGlmICh6ZXJvRm9ybWF0ICYmICFtYXJrZXIuZ2V0VVRDTWludXRlcygpKSB7XG4gICAgICBmb3JtYXQgPSB6ZXJvRm9ybWF0XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1hdCA9IG5vcm1hbEZvcm1hdFxuICAgIH1cblxuICAgIGxldCBzID0gZm9ybWF0LmZvcm1hdChtYXJrZXIpXG5cbiAgICByZXR1cm4gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpXG4gIH1cbn1cblxuZnVuY3Rpb24gc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncykge1xuICAvLyBkZWFsIHdpdGggYSBicm93c2VyIGluY29uc2lzdGVuY3kgd2hlcmUgZm9ybWF0dGluZyB0aGUgdGltZXpvbmVcbiAgLy8gcmVxdWlyZXMgdGhhdCB0aGUgaG91ci9taW51dGUgYmUgcHJlc2VudC5cbiAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSkge1xuICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMuaG91cikge1xuICAgICAgc3RhbmRhcmREYXRlUHJvcHMuaG91ciA9ICcyLWRpZ2l0J1xuICAgIH1cbiAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLm1pbnV0ZSkge1xuICAgICAgc3RhbmRhcmREYXRlUHJvcHMubWludXRlID0gJzItZGlnaXQnXG4gICAgfVxuICB9XG5cbiAgLy8gb25seSBzdXBwb3J0IHNob3J0IHRpbWV6b25lIG5hbWVzXG4gIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdsb25nJykge1xuICAgIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9ICdzaG9ydCdcbiAgfVxuXG4gIC8vIGlmIHJlcXVlc3RpbmcgdG8gZGlzcGxheSBzZWNvbmRzLCBNVVNUIGRpc3BsYXkgbWludXRlc1xuICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSAmJiAoc3RhbmRhcmREYXRlUHJvcHMuc2Vjb25kIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1pbGxpc2Vjb25kKSkge1xuICAgIGRlbGV0ZSBleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlXG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdFByb2Nlc3Moczogc3RyaW5nLCBkYXRlOiBab25lZE1hcmtlciwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCk6IHN0cmluZyB7XG4gIHMgPSBzLnJlcGxhY2UoTFRSX1JFLCAnJykgLy8gcmVtb3ZlIGxlZnQtdG8tcmlnaHQgY29udHJvbCBjaGFycy4gZG8gZmlyc3QuIGdvb2QgZm9yIG90aGVyIHJlZ2V4ZXNcblxuICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnc2hvcnQnKSB7XG4gICAgcyA9IGluamVjdFR6b1N0cihcbiAgICAgIHMsXG4gICAgICAoY29udGV4dC50aW1lWm9uZSA9PT0gJ1VUQycgfHwgZGF0ZS50aW1lWm9uZU9mZnNldCA9PSBudWxsKSA/XG4gICAgICAgICdVVEMnIDogLy8gaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSBmb3IgSUUsIHdoaWNoIGRvZXMgXCJHTVRcIlxuICAgICAgICBmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KSxcbiAgICApXG4gIH1cblxuICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0Q29tbWFzKSB7XG4gICAgcyA9IHMucmVwbGFjZShDT01NQV9SRSwgJycpLnRyaW0oKVxuICB9XG5cbiAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGUpIHtcbiAgICBzID0gcy5yZXBsYWNlKCc6MDAnLCAnJykgLy8gemVyb0Zvcm1hdCBkb2Vzbid0IGFsd2F5cyBhY2hpZXZlIHRoaXNcbiAgfVxuXG4gIC8vIF4gZG8gYW55dGhpbmcgdGhhdCBtaWdodCBjcmVhdGUgYWRqYWNlbnQgc3BhY2VzIGJlZm9yZSB0aGlzIHBvaW50LFxuICAvLyBiZWNhdXNlIE1FUklESUVNX1JFIGxpa2VzIHRvIGVhdCB1cCBsb2FkaW5nIHNwYWNlc1xuXG4gIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSBmYWxzZSkge1xuICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsICcnKS50cmltKClcbiAgfSBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbmFycm93JykgeyAvLyBhL3BcbiAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCAobTAsIG0xKSA9PiBtMS50b0xvY2FsZUxvd2VyQ2FzZSgpKVxuICB9IGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdzaG9ydCcpIHsgLy8gYW0vcG1cbiAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCAobTAsIG0xKSA9PiBgJHttMS50b0xvY2FsZUxvd2VyQ2FzZSgpfW1gKVxuICB9IGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdsb3dlcmNhc2UnKSB7IC8vIG90aGVyIG1lcmlkaWVtIHRyYW5zZm9ybWVycyBhbHJlYWR5IGNvbnZlcnRlZCB0byBsb3dlcmNhc2VcbiAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCAobTApID0+IG0wLnRvTG9jYWxlTG93ZXJDYXNlKCkpXG4gIH1cblxuICBzID0gcy5yZXBsYWNlKE1VTFRJX1NQQUNFX1JFLCAnICcpXG4gIHMgPSBzLnRyaW0oKVxuXG4gIHJldHVybiBzXG59XG5cbmZ1bmN0aW9uIGluamVjdFR6b1N0cihzOiBzdHJpbmcsIHR6b1N0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHJlcGxhY2VkID0gZmFsc2VcblxuICBzID0gcy5yZXBsYWNlKFVUQ19SRSwgKCkgPT4ge1xuICAgIHJlcGxhY2VkID0gdHJ1ZVxuICAgIHJldHVybiB0em9TdHJcbiAgfSlcblxuICAvLyBJRTExIGRvZXNuJ3QgaW5jbHVkZSBVVEMvR01UIGluIHRoZSBvcmlnaW5hbCBzdHJpbmcsIHNvIGFwcGVuZCB0byBlbmRcbiAgaWYgKCFyZXBsYWNlZCkge1xuICAgIHMgKz0gYCAke3R6b1N0cn1gXG4gIH1cblxuICByZXR1cm4gc1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyKG51bTogbnVtYmVyLCB3ZWVrVGV4dDogc3RyaW5nLCBsb2NhbGU6IExvY2FsZSwgZGlzcGxheT86ICdudW1lcmljJyB8ICduYXJyb3cnIHwgJ3Nob3J0Jyk6IHN0cmluZyB7XG4gIGxldCBwYXJ0cyA9IFtdXG5cbiAgaWYgKGRpc3BsYXkgPT09ICduYXJyb3cnKSB7XG4gICAgcGFydHMucHVzaCh3ZWVrVGV4dClcbiAgfSBlbHNlIGlmIChkaXNwbGF5ID09PSAnc2hvcnQnKSB7XG4gICAgcGFydHMucHVzaCh3ZWVrVGV4dCwgJyAnKVxuICB9XG4gIC8vIG90aGVyd2lzZSwgY29uc2lkZXJlZCAnbnVtZXJpYydcblxuICBwYXJ0cy5wdXNoKGxvY2FsZS5zaW1wbGVOdW1iZXJGb3JtYXQuZm9ybWF0KG51bSkpXG5cbiAgaWYgKGxvY2FsZS5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHsgLy8gVE9ETzogdXNlIGNvbnRyb2wgY2hhcmFjdGVycyBpbnN0ZWFkP1xuICAgIHBhcnRzLnJldmVyc2UoKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cbi8vIFJhbmdlIEZvcm1hdHRpbmcgVXRpbHNcblxuLy8gMCA9IGV4YWN0bHkgdGhlIHNhbWVcbi8vIDEgPSBkaWZmZXJlbnQgYnkgdGltZVxuLy8gYW5kIGJpZ2dlclxuZnVuY3Rpb24gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShkMDogRGF0ZU1hcmtlciwgZDE6IERhdGVNYXJrZXIsIGNhOiBDYWxlbmRhclN5c3RlbSkge1xuICBpZiAoY2EuZ2V0TWFya2VyWWVhcihkMCkgIT09IGNhLmdldE1hcmtlclllYXIoZDEpKSB7XG4gICAgcmV0dXJuIDVcbiAgfVxuICBpZiAoY2EuZ2V0TWFya2VyTW9udGgoZDApICE9PSBjYS5nZXRNYXJrZXJNb250aChkMSkpIHtcbiAgICByZXR1cm4gNFxuICB9XG4gIGlmIChjYS5nZXRNYXJrZXJEYXkoZDApICE9PSBjYS5nZXRNYXJrZXJEYXkoZDEpKSB7XG4gICAgcmV0dXJuIDJcbiAgfVxuICBpZiAodGltZUFzTXMoZDApICE9PSB0aW1lQXNNcyhkMSkpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMob3B0aW9ucywgYmlnZ2VzdFVuaXQpIHtcbiAgbGV0IHBhcnRpYWxPcHRpb25zID0ge31cblxuICBmb3IgKGxldCBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoXG4gICAgICAhKG5hbWUgaW4gU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMpIHx8IC8vIG5vdCBhIGRhdGUgcGFydCBwcm9wIChsaWtlIHRpbWVab25lKVxuICAgICAgU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVNbbmFtZV0gPD0gYmlnZ2VzdFVuaXRcbiAgICApIHtcbiAgICAgIHBhcnRpYWxPcHRpb25zW25hbWVdID0gb3B0aW9uc1tuYW1lXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0aWFsT3B0aW9uc1xufVxuXG5mdW5jdGlvbiBmaW5kQ29tbW9uSW5zZXJ0aW9uKGZ1bGwwLCBwYXJ0aWFsMCwgZnVsbDEsIHBhcnRpYWwxKSB7XG4gIGxldCBpMCA9IDBcbiAgd2hpbGUgKGkwIDwgZnVsbDAubGVuZ3RoKSB7XG4gICAgbGV0IGZvdW5kMCA9IGZ1bGwwLmluZGV4T2YocGFydGlhbDAsIGkwKVxuICAgIGlmIChmb3VuZDAgPT09IC0xKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGxldCBiZWZvcmUwID0gZnVsbDAuc3Vic3RyKDAsIGZvdW5kMClcbiAgICBpMCA9IGZvdW5kMCArIHBhcnRpYWwwLmxlbmd0aFxuICAgIGxldCBhZnRlcjAgPSBmdWxsMC5zdWJzdHIoaTApXG5cbiAgICBsZXQgaTEgPSAwXG4gICAgd2hpbGUgKGkxIDwgZnVsbDEubGVuZ3RoKSB7XG4gICAgICBsZXQgZm91bmQxID0gZnVsbDEuaW5kZXhPZihwYXJ0aWFsMSwgaTEpXG4gICAgICBpZiAoZm91bmQxID09PSAtMSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBsZXQgYmVmb3JlMSA9IGZ1bGwxLnN1YnN0cigwLCBmb3VuZDEpXG4gICAgICBpMSA9IGZvdW5kMSArIHBhcnRpYWwxLmxlbmd0aFxuICAgICAgbGV0IGFmdGVyMSA9IGZ1bGwxLnN1YnN0cihpMSlcblxuICAgICAgaWYgKGJlZm9yZTAgPT09IGJlZm9yZTEgJiYgYWZ0ZXIwID09PSBhZnRlcjEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBiZWZvcmU6IGJlZm9yZTAsXG4gICAgICAgICAgYWZ0ZXI6IGFmdGVyMCxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCJpbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi9tYXJrZXInXG5pbXBvcnQgeyBDYWxlbmRhclN5c3RlbSB9IGZyb20gJy4vY2FsZW5kYXItc3lzdGVtJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFpvbmVkTWFya2VyIHtcbiAgbWFya2VyOiBEYXRlTWFya2VyLFxuICB0aW1lWm9uZU9mZnNldDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwYW5kZWRab25lZE1hcmtlciBleHRlbmRzIFpvbmVkTWFya2VyIHtcbiAgYXJyYXk6IG51bWJlcltdLFxuICB5ZWFyOiBudW1iZXIsXG4gIG1vbnRoOiBudW1iZXIsXG4gIGRheTogbnVtYmVyLFxuICBob3VyOiBudW1iZXIsXG4gIG1pbnV0ZTogbnVtYmVyLFxuICBzZWNvbmQ6IG51bWJlcixcbiAgbWlsbGlzZWNvbmQ6IG51bWJlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kWm9uZWRNYXJrZXIoZGF0ZUluZm86IFpvbmVkTWFya2VyLCBjYWxlbmRhclN5c3RlbTogQ2FsZW5kYXJTeXN0ZW0pOiBFeHBhbmRlZFpvbmVkTWFya2VyIHtcbiAgbGV0IGEgPSBjYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KGRhdGVJbmZvLm1hcmtlcilcblxuICByZXR1cm4ge1xuICAgIG1hcmtlcjogZGF0ZUluZm8ubWFya2VyLFxuICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlSW5mby50aW1lWm9uZU9mZnNldCxcbiAgICBhcnJheTogYSxcbiAgICB5ZWFyOiBhWzBdLFxuICAgIG1vbnRoOiBhWzFdLFxuICAgIGRheTogYVsyXSxcbiAgICBob3VyOiBhWzNdLFxuICAgIG1pbnV0ZTogYVs0XSxcbiAgICBzZWNvbmQ6IGFbNV0sXG4gICAgbWlsbGlzZWNvbmQ6IGFbNl0sXG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuL21hcmtlcidcbmltcG9ydCB7IENhbGVuZGFyU3lzdGVtIH0gZnJvbSAnLi9jYWxlbmRhci1zeXN0ZW0nXG5pbXBvcnQgeyBMb2NhbGUgfSBmcm9tICcuL2xvY2FsZSdcbmltcG9ydCB7IFpvbmVkTWFya2VyLCBFeHBhbmRlZFpvbmVkTWFya2VyLCBleHBhbmRab25lZE1hcmtlciB9IGZyb20gJy4vem9uZWQtbWFya2VyJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmJvc2VGb3JtYXR0aW5nQXJnIHsgLy8gVE9ETzoga2lsbCB0aGlzXG4gIGRhdGU6IEV4cGFuZGVkWm9uZWRNYXJrZXJcbiAgc3RhcnQ6IEV4cGFuZGVkWm9uZWRNYXJrZXJcbiAgZW5kPzogRXhwYW5kZWRab25lZE1hcmtlclxuICB0aW1lWm9uZTogc3RyaW5nXG4gIGxvY2FsZUNvZGVzOiBzdHJpbmdbXSxcbiAgZGVmYXVsdFNlcGFyYXRvcjogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhcbiAgc3RhcnQ6IFpvbmVkTWFya2VyLFxuICBlbmQ6IFpvbmVkTWFya2VyLFxuICBjb250ZXh0OiBEYXRlRm9ybWF0dGluZ0NvbnRleHQsXG4gIGJldHRlckRlZmF1bHRTZXBhcmF0b3I/OiBzdHJpbmcsXG4pOiBWZXJib3NlRm9ybWF0dGluZ0FyZyB7XG4gIGxldCBzdGFydEluZm8gPSBleHBhbmRab25lZE1hcmtlcihzdGFydCwgY29udGV4dC5jYWxlbmRhclN5c3RlbSlcbiAgbGV0IGVuZEluZm8gPSBlbmQgPyBleHBhbmRab25lZE1hcmtlcihlbmQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pIDogbnVsbFxuXG4gIHJldHVybiB7XG4gICAgZGF0ZTogc3RhcnRJbmZvLFxuICAgIHN0YXJ0OiBzdGFydEluZm8sXG4gICAgZW5kOiBlbmRJbmZvLFxuICAgIHRpbWVab25lOiBjb250ZXh0LnRpbWVab25lLFxuICAgIGxvY2FsZUNvZGVzOiBjb250ZXh0LmxvY2FsZS5jb2RlcyxcbiAgICBkZWZhdWx0U2VwYXJhdG9yOiBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIHx8IGNvbnRleHQuZGVmYXVsdFNlcGFyYXRvcixcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBDbWRGb3JtYXR0ZXJGdW5jID0gKGNtZDogc3RyaW5nLCBhcmc6IFZlcmJvc2VGb3JtYXR0aW5nQXJnKSA9PiBzdHJpbmdcblxuZXhwb3J0IGludGVyZmFjZSBEYXRlRm9ybWF0dGluZ0NvbnRleHQge1xuICB0aW1lWm9uZTogc3RyaW5nLFxuICBsb2NhbGU6IExvY2FsZSxcbiAgY2FsZW5kYXJTeXN0ZW06IENhbGVuZGFyU3lzdGVtXG4gIGNvbXB1dGVXZWVrTnVtYmVyOiAoZDogRGF0ZU1hcmtlcikgPT4gbnVtYmVyXG4gIHdlZWtUZXh0OiBzdHJpbmdcbiAgY21kRm9ybWF0dGVyPzogQ21kRm9ybWF0dGVyRnVuY1xuICBkZWZhdWx0U2VwYXJhdG9yOiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRlRm9ybWF0dGVyIHtcbiAgZm9ybWF0KGRhdGU6IFpvbmVkTWFya2VyLCBjb250ZXh0OiBEYXRlRm9ybWF0dGluZ0NvbnRleHQpOiBzdHJpbmdcbiAgZm9ybWF0UmFuZ2Uoc3RhcnQ6IFpvbmVkTWFya2VyLCBlbmQ6IFpvbmVkTWFya2VyLCBjb250ZXh0OiBEYXRlRm9ybWF0dGluZ0NvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3I/OiBzdHJpbmcpOiBzdHJpbmdcbn1cbiIsImltcG9ydCB7IERhdGVGb3JtYXR0ZXIsIERhdGVGb3JtYXR0aW5nQ29udGV4dCwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcgfSBmcm9tICcuL0RhdGVGb3JtYXR0ZXInXG5pbXBvcnQgeyBab25lZE1hcmtlciB9IGZyb20gJy4vem9uZWQtbWFya2VyJ1xuXG4vKlxuVE9ETzogZml4IHRoZSB0ZXJtaW5vbG9neSBvZiBcImZvcm1hdHRlclwiIHZzIFwiZm9ybWF0dGluZyBmdW5jXCJcbiovXG5cbi8qXG5BdCB0aGUgdGltZSBvZiBpbnN0YW50aWF0aW9uLCB0aGlzIG9iamVjdCBkb2VzIG5vdCBrbm93IHdoaWNoIGNtZC1mb3JtYXR0aW5nIHN5c3RlbSBpdCB3aWxsIHVzZS5cbkl0IHJlY2VpdmVzIHRoaXMgYXQgdGhlIHRpbWUgb2YgZm9ybWF0dGluZywgYXMgYSBzZXR0aW5nLlxuKi9cbmV4cG9ydCBjbGFzcyBDbWRGb3JtYXR0ZXIgaW1wbGVtZW50cyBEYXRlRm9ybWF0dGVyIHtcbiAgY21kU3RyOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihjbWRTdHI6IHN0cmluZykge1xuICAgIHRoaXMuY21kU3RyID0gY21kU3RyXG4gIH1cblxuICBmb3JtYXQoZGF0ZTogWm9uZWRNYXJrZXIsIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcj86IHN0cmluZykge1xuICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpXG4gIH1cblxuICBmb3JtYXRSYW5nZShzdGFydDogWm9uZWRNYXJrZXIsIGVuZDogWm9uZWRNYXJrZXIsIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcj86IHN0cmluZykge1xuICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpXG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVGb3JtYXR0ZXIsIERhdGVGb3JtYXR0aW5nQ29udGV4dCwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcsIFZlcmJvc2VGb3JtYXR0aW5nQXJnIH0gZnJvbSAnLi9EYXRlRm9ybWF0dGVyJ1xuaW1wb3J0IHsgWm9uZWRNYXJrZXIgfSBmcm9tICcuL3pvbmVkLW1hcmtlcidcblxuZXhwb3J0IHR5cGUgRnVuY0Zvcm1hdHRlckZ1bmMgPSAoYXJnOiBWZXJib3NlRm9ybWF0dGluZ0FyZykgPT4gc3RyaW5nXG5cbmV4cG9ydCBjbGFzcyBGdW5jRm9ybWF0dGVyIGltcGxlbWVudHMgRGF0ZUZvcm1hdHRlciB7XG4gIGZ1bmM6IEZ1bmNGb3JtYXR0ZXJGdW5jXG5cbiAgY29uc3RydWN0b3IoZnVuYzogRnVuY0Zvcm1hdHRlckZ1bmMpIHtcbiAgICB0aGlzLmZ1bmMgPSBmdW5jXG4gIH1cblxuICBmb3JtYXQoZGF0ZTogWm9uZWRNYXJrZXIsIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcj86IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmZ1bmMoY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpXG4gIH1cblxuICBmb3JtYXRSYW5nZShzdGFydDogWm9uZWRNYXJrZXIsIGVuZDogWm9uZWRNYXJrZXIsIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcj86IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmZ1bmMoY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpXG4gIH1cbn1cbiIsImltcG9ydCB7IE5hdGl2ZUZvcm1hdHRlciwgTmF0aXZlRm9ybWF0dGVyT3B0aW9ucyB9IGZyb20gJy4vZm9ybWF0dGluZy1uYXRpdmUnXG5pbXBvcnQgeyBDbWRGb3JtYXR0ZXIgfSBmcm9tICcuL2Zvcm1hdHRpbmctY21kJ1xuaW1wb3J0IHsgRnVuY0Zvcm1hdHRlciwgRnVuY0Zvcm1hdHRlckZ1bmMgfSBmcm9tICcuL2Zvcm1hdHRpbmctZnVuYydcbmltcG9ydCB7IERhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL0RhdGVGb3JtYXR0ZXInXG5cbmV4cG9ydCB0eXBlIEZvcm1hdHRlcklucHV0ID0gTmF0aXZlRm9ybWF0dGVyT3B0aW9ucyB8IHN0cmluZyB8IEZ1bmNGb3JtYXR0ZXJGdW5jXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQ6IEZvcm1hdHRlcklucHV0KTogRGF0ZUZvcm1hdHRlciB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgIHJldHVybiBuZXcgTmF0aXZlRm9ybWF0dGVyKGlucHV0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IENtZEZvcm1hdHRlcihpbnB1dClcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmNGb3JtYXR0ZXIoaW5wdXQgYXMgRnVuY0Zvcm1hdHRlckZ1bmMpXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRHVyYXRpb24gfSBmcm9tICcuL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyBtZXJnZVByb3BzLCBpc1Byb3BzRXF1YWwgfSBmcm9tICcuL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgY3JlYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi9kYXRlbGliL2Zvcm1hdHRpbmcnXG5pbXBvcnQgeyBwYXJzZUZpZWxkU3BlY3MgfSBmcm9tICcuL3V0aWwvbWlzYydcbmltcG9ydCB7IERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgfSBmcm9tICcuL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuXG4vLyBwdWJsaWNcbmltcG9ydCB7XG4gIENzc0RpbVZhbHVlLFxuICBEYXRlSW5wdXQsXG4gIERhdGVSYW5nZUlucHV0LFxuICBCdXNpbmVzc0hvdXJzSW5wdXQsXG4gIEV2ZW50U291cmNlSW5wdXQsXG4gIFZpZXdBcGksXG4gIExvY2FsZVNpbmd1bGFyQXJnLCBMb2NhbGVJbnB1dCxcbiAgRXZlbnRJbnB1dCwgRXZlbnRJbnB1dFRyYW5zZm9ybWVyLFxuICBPdmVybGFwRnVuYywgQ29uc3RyYWludElucHV0LCBBbGxvd0Z1bmMsXG4gIFBsdWdpbkRlZixcbiAgVmlld0NvbXBvbmVudFR5cGUsXG4gIFNwZWNpZmljVmlld0NvbnRlbnRBcmcsIFNwZWNpZmljVmlld01vdW50QXJnLFxuICBDbGFzc05hbWVzR2VuZXJhdG9yLCBDdXN0b21Db250ZW50R2VuZXJhdG9yLCBEaWRNb3VudEhhbmRsZXIsIFdpbGxVbm1vdW50SGFuZGxlcixcbiAgTm93SW5kaWNhdG9yQ29udGVudEFyZywgTm93SW5kaWNhdG9yTW91bnRBcmcsXG4gIFdlZWtOdW1iZXJDb250ZW50QXJnLCBXZWVrTnVtYmVyTW91bnRBcmcsXG4gIFNsb3RMYW5lQ29udGVudEFyZywgU2xvdExhbmVNb3VudEFyZyxcbiAgU2xvdExhYmVsQ29udGVudEFyZywgU2xvdExhYmVsTW91bnRBcmcsXG4gIEFsbERheUNvbnRlbnRBcmcsIEFsbERheU1vdW50QXJnLFxuICBEYXlIZWFkZXJDb250ZW50QXJnLCBEYXlIZWFkZXJNb3VudEFyZyxcbiAgRGF5Q2VsbENvbnRlbnRBcmcsIERheUNlbGxNb3VudEFyZyxcbiAgVmlld0NvbnRlbnRBcmcsIFZpZXdNb3VudEFyZyxcbiAgRXZlbnRDbGlja0FyZyxcbiAgRXZlbnRIb3ZlcmluZ0FyZyxcbiAgRGF0ZVNlbGVjdEFyZywgRGF0ZVVuc2VsZWN0QXJnLFxuICBDYWxlbmRhckFwaSxcbiAgVlVJRXZlbnQsXG4gIFdlZWtOdW1iZXJDYWxjdWxhdGlvbixcbiAgRm9ybWF0dGVySW5wdXQsXG4gIFRvb2xiYXJJbnB1dCwgQ3VzdG9tQnV0dG9uSW5wdXQsIEJ1dHRvbkljb25zSW5wdXQsIEJ1dHRvblRleHRDb21wb3VuZElucHV0LFxuICBFdmVudENvbnRlbnRBcmcsIEV2ZW50TW91bnRBcmcsXG4gIERhdGVzU2V0QXJnLFxuICBFdmVudEFwaSwgRXZlbnRBZGRBcmcsIEV2ZW50Q2hhbmdlQXJnLCBFdmVudFJlbW92ZUFyZyxcbiAgTW9yZUxpbmtDb250ZW50QXJnLFxuICBNb3JlTGlua01vdW50QXJnLFxuICBNb3JlTGlua0FjdGlvbixcbn0gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xuXG4vLyBiYXNlIG9wdGlvbnNcbi8vIC0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgQkFTRV9PUFRJT05fUkVGSU5FUlMgPSB7XG4gIG5hdkxpbmtEYXlDbGljazogaWRlbnRpdHkgYXMgSWRlbnRpdHk8c3RyaW5nIHwgKCh0aGlzOiBDYWxlbmRhckFwaSwgZGF0ZTogRGF0ZSwganNFdmVudDogVlVJRXZlbnQpID0+IHZvaWQpPixcbiAgbmF2TGlua1dlZWtDbGljazogaWRlbnRpdHkgYXMgSWRlbnRpdHk8c3RyaW5nIHwgKCh0aGlzOiBDYWxlbmRhckFwaSwgd2Vla1N0YXJ0OiBEYXRlLCBqc0V2ZW50OiBWVUlFdmVudCkgPT4gdm9pZCk+LFxuICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gIGJvb3RzdHJhcEZvbnRBd2Vzb21lOiBpZGVudGl0eSBhcyBJZGVudGl0eTxCdXR0b25JY29uc0lucHV0IHwgZmFsc2U+LCAvLyBUT0RPOiBtb3ZlIHRvIGJvb3RzdHJhcCBwbHVnaW5cbiAgYnV0dG9uSWNvbnM6IGlkZW50aXR5IGFzIElkZW50aXR5PEJ1dHRvbkljb25zSW5wdXQgfCBmYWxzZT4sXG4gIGN1c3RvbUJ1dHRvbnM6IGlkZW50aXR5IGFzIElkZW50aXR5PHsgW25hbWU6IHN0cmluZ106IEN1c3RvbUJ1dHRvbklucHV0IH0+LFxuICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICBuZXh0RGF5VGhyZXNob2xkOiBjcmVhdGVEdXJhdGlvbixcbiAgc2Nyb2xsVGltZTogY3JlYXRlRHVyYXRpb24sXG4gIHNjcm9sbFRpbWVSZXNldDogQm9vbGVhbixcbiAgc2xvdE1pblRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICBzbG90TWF4VGltZTogY3JlYXRlRHVyYXRpb24sXG4gIGRheVBvcG92ZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgc2xvdER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgc25hcER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgaGVhZGVyVG9vbGJhcjogaWRlbnRpdHkgYXMgSWRlbnRpdHk8VG9vbGJhcklucHV0IHwgZmFsc2U+LFxuICBmb290ZXJUb29sYmFyOiBpZGVudGl0eSBhcyBJZGVudGl0eTxUb29sYmFySW5wdXQgfCBmYWxzZT4sXG4gIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICB0aXRsZVJhbmdlU2VwYXJhdG9yOiBTdHJpbmcsXG4gIGZvcmNlRXZlbnREdXJhdGlvbjogQm9vbGVhbixcblxuICBkYXlIZWFkZXJzOiBCb29sZWFuLFxuICBkYXlIZWFkZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgZGF5SGVhZGVyQ2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxEYXlIZWFkZXJDb250ZW50QXJnPj4sXG4gIGRheUhlYWRlckNvbnRlbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PEN1c3RvbUNvbnRlbnRHZW5lcmF0b3I8RGF5SGVhZGVyQ29udGVudEFyZz4+LFxuICBkYXlIZWFkZXJEaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPERheUhlYWRlck1vdW50QXJnPj4sXG4gIGRheUhlYWRlcldpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8RGF5SGVhZGVyTW91bnRBcmc+PixcblxuICBkYXlDZWxsQ2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxEYXlDZWxsQ29udGVudEFyZz4+LFxuICBkYXlDZWxsQ29udGVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3VzdG9tQ29udGVudEdlbmVyYXRvcjxEYXlDZWxsQ29udGVudEFyZz4+LFxuICBkYXlDZWxsRGlkTW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERpZE1vdW50SGFuZGxlcjxEYXlDZWxsTW91bnRBcmc+PixcbiAgZGF5Q2VsbFdpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8RGF5Q2VsbE1vdW50QXJnPj4sXG5cbiAgaW5pdGlhbFZpZXc6IFN0cmluZyxcbiAgYXNwZWN0UmF0aW86IE51bWJlcixcbiAgd2Vla2VuZHM6IEJvb2xlYW4sXG5cbiAgd2Vla051bWJlckNhbGN1bGF0aW9uOiBpZGVudGl0eSBhcyBJZGVudGl0eTxXZWVrTnVtYmVyQ2FsY3VsYXRpb24+LFxuICB3ZWVrTnVtYmVyczogQm9vbGVhbixcbiAgd2Vla051bWJlckNsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8V2Vla051bWJlckNvbnRlbnRBcmc+PixcbiAgd2Vla051bWJlckNvbnRlbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PEN1c3RvbUNvbnRlbnRHZW5lcmF0b3I8V2Vla051bWJlckNvbnRlbnRBcmc+PixcbiAgd2Vla051bWJlckRpZE1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWRNb3VudEhhbmRsZXI8V2Vla051bWJlck1vdW50QXJnPj4sXG4gIHdlZWtOdW1iZXJXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPFdlZWtOdW1iZXJNb3VudEFyZz4+LFxuXG4gIGVkaXRhYmxlOiBCb29sZWFuLFxuXG4gIHZpZXdDbGFzc05hbWVzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxDbGFzc05hbWVzR2VuZXJhdG9yPFZpZXdDb250ZW50QXJnPj4sXG4gIHZpZXdEaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPFZpZXdNb3VudEFyZz4+LFxuICB2aWV3V2lsbFVubW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PFdpbGxVbm1vdW50SGFuZGxlcjxWaWV3TW91bnRBcmc+PixcblxuICBub3dJbmRpY2F0b3I6IEJvb2xlYW4sXG4gIG5vd0luZGljYXRvckNsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8Tm93SW5kaWNhdG9yQ29udGVudEFyZz4+LFxuICBub3dJbmRpY2F0b3JDb250ZW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDdXN0b21Db250ZW50R2VuZXJhdG9yPE5vd0luZGljYXRvckNvbnRlbnRBcmc+PixcbiAgbm93SW5kaWNhdG9yRGlkTW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERpZE1vdW50SGFuZGxlcjxOb3dJbmRpY2F0b3JNb3VudEFyZz4+LFxuICBub3dJbmRpY2F0b3JXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPE5vd0luZGljYXRvck1vdW50QXJnPj4sXG5cbiAgc2hvd05vbkN1cnJlbnREYXRlczogQm9vbGVhbixcbiAgbGF6eUZldGNoaW5nOiBCb29sZWFuLFxuICBzdGFydFBhcmFtOiBTdHJpbmcsXG4gIGVuZFBhcmFtOiBTdHJpbmcsXG4gIHRpbWVab25lUGFyYW06IFN0cmluZyxcbiAgdGltZVpvbmU6IFN0cmluZyxcbiAgbG9jYWxlczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8TG9jYWxlSW5wdXRbXT4sXG4gIGxvY2FsZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8TG9jYWxlU2luZ3VsYXJBcmc+LFxuICB0aGVtZVN5c3RlbTogU3RyaW5nIGFzIElkZW50aXR5PCdzdGFuZGFyZCcgfCBzdHJpbmc+LFxuICBkcmFnUmV2ZXJ0RHVyYXRpb246IE51bWJlcixcbiAgZHJhZ1Njcm9sbDogQm9vbGVhbixcbiAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogQm9vbGVhbixcbiAgdW5zZWxlY3RBdXRvOiBCb29sZWFuLFxuICBkcm9wQWNjZXB0OiBpZGVudGl0eSBhcyBJZGVudGl0eTxzdHJpbmcgfCAoKHRoaXM6IENhbGVuZGFyQXBpLCBkcmFnZ2FibGU6IGFueSkgPT4gYm9vbGVhbik+LCAvLyBUT0RPOiB0eXBlIGRyYWdnYWJsZVxuICBldmVudE9yZGVyOiBwYXJzZUZpZWxkU3BlY3MsXG4gIGV2ZW50T3JkZXJTdHJpY3Q6IEJvb2xlYW4sXG5cbiAgaGFuZGxlV2luZG93UmVzaXplOiBCb29sZWFuLFxuICB3aW5kb3dSZXNpemVEZWxheTogTnVtYmVyLFxuICBsb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICBldmVudERyYWdNaW5EaXN0YW5jZTogTnVtYmVyLFxuICBleHBhbmRSb3dzOiBCb29sZWFuLFxuICBoZWlnaHQ6IGlkZW50aXR5IGFzIElkZW50aXR5PENzc0RpbVZhbHVlPixcbiAgY29udGVudEhlaWdodDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3NzRGltVmFsdWU+LFxuICBkaXJlY3Rpb246IFN0cmluZyBhcyBJZGVudGl0eTwnbHRyJyB8ICdydGwnPixcbiAgd2Vla051bWJlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICBldmVudFJlc2l6YWJsZUZyb21TdGFydDogQm9vbGVhbixcbiAgZGlzcGxheUV2ZW50VGltZTogQm9vbGVhbixcbiAgZGlzcGxheUV2ZW50RW5kOiBCb29sZWFuLFxuICB3ZWVrVGV4dDogU3RyaW5nLFxuICBwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nOiBCb29sZWFuLFxuICBidXNpbmVzc0hvdXJzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxCdXNpbmVzc0hvdXJzSW5wdXQ+LFxuICBpbml0aWFsRGF0ZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZUlucHV0PixcbiAgbm93OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlSW5wdXQgfCAoKHRoaXM6IENhbGVuZGFyQXBpKSA9PiBEYXRlSW5wdXQpPixcbiAgZXZlbnREYXRhVHJhbnNmb3JtOiBpZGVudGl0eSBhcyBJZGVudGl0eTxFdmVudElucHV0VHJhbnNmb3JtZXI+LFxuICBzdGlja3lIZWFkZXJEYXRlczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbiB8ICdhdXRvJz4sXG4gIHN0aWNreUZvb3RlclNjcm9sbGJhcjogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbiB8ICdhdXRvJz4sXG4gIHZpZXdIZWlnaHQ6IGlkZW50aXR5IGFzIElkZW50aXR5PENzc0RpbVZhbHVlPixcbiAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgZXZlbnRTb3VyY2VGYWlsdXJlOiBpZGVudGl0eSBhcyBJZGVudGl0eTwodGhpczogQ2FsZW5kYXJBcGksIGVycm9yOiBhbnkpID0+IHZvaWQ+LFxuICBldmVudFNvdXJjZVN1Y2Nlc3M6IGlkZW50aXR5IGFzIElkZW50aXR5PCh0aGlzOiBDYWxlbmRhckFwaSwgZXZlbnRzSW5wdXQ6IEV2ZW50SW5wdXRbXSwgeGhyPzogWE1MSHR0cFJlcXVlc3QpID0+IEV2ZW50SW5wdXRbXSB8IHZvaWQ+LFxuXG4gIGV2ZW50RGlzcGxheTogU3RyaW5nLCAvLyBUT0RPOiBnaXZlIG1vcmUgc3BlY2lmaWNcbiAgZXZlbnRTdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICBldmVudER1cmF0aW9uRWRpdGFibGU6IEJvb2xlYW4sXG4gIGV2ZW50T3ZlcmxhcDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbiB8IE92ZXJsYXBGdW5jPixcbiAgZXZlbnRDb25zdHJhaW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDb25zdHJhaW50SW5wdXQ+LFxuICBldmVudEFsbG93OiBpZGVudGl0eSBhcyBJZGVudGl0eTxBbGxvd0Z1bmM+LFxuICBldmVudEJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICBldmVudEJvcmRlckNvbG9yOiBTdHJpbmcsXG4gIGV2ZW50VGV4dENvbG9yOiBTdHJpbmcsXG4gIGV2ZW50Q29sb3I6IFN0cmluZyxcbiAgZXZlbnRDbGFzc05hbWVzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxDbGFzc05hbWVzR2VuZXJhdG9yPEV2ZW50Q29udGVudEFyZz4+LFxuICBldmVudENvbnRlbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PEN1c3RvbUNvbnRlbnRHZW5lcmF0b3I8RXZlbnRDb250ZW50QXJnPj4sXG4gIGV2ZW50RGlkTW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERpZE1vdW50SGFuZGxlcjxFdmVudE1vdW50QXJnPj4sXG4gIGV2ZW50V2lsbFVubW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PFdpbGxVbm1vdW50SGFuZGxlcjxFdmVudE1vdW50QXJnPj4sXG5cbiAgc2VsZWN0Q29uc3RyYWludDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q29uc3RyYWludElucHV0PixcbiAgc2VsZWN0T3ZlcmxhcDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbiB8IE92ZXJsYXBGdW5jPixcbiAgc2VsZWN0QWxsb3c6IGlkZW50aXR5IGFzIElkZW50aXR5PEFsbG93RnVuYz4sXG5cbiAgZHJvcHBhYmxlOiBCb29sZWFuLFxuICB1bnNlbGVjdENhbmNlbDogU3RyaW5nLFxuXG4gIHNsb3RMYWJlbEZvcm1hdDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Rm9ybWF0dGVySW5wdXQgfCBGb3JtYXR0ZXJJbnB1dFtdPixcblxuICBzbG90TGFuZUNsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8U2xvdExhbmVDb250ZW50QXJnPj4sXG4gIHNsb3RMYW5lQ29udGVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3VzdG9tQ29udGVudEdlbmVyYXRvcjxTbG90TGFuZUNvbnRlbnRBcmc+PixcbiAgc2xvdExhbmVEaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPFNsb3RMYW5lTW91bnRBcmc+PixcbiAgc2xvdExhbmVXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPFNsb3RMYW5lTW91bnRBcmc+PixcblxuICBzbG90TGFiZWxDbGFzc05hbWVzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxDbGFzc05hbWVzR2VuZXJhdG9yPFNsb3RMYWJlbENvbnRlbnRBcmc+PixcbiAgc2xvdExhYmVsQ29udGVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3VzdG9tQ29udGVudEdlbmVyYXRvcjxTbG90TGFiZWxDb250ZW50QXJnPj4sXG4gIHNsb3RMYWJlbERpZE1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWRNb3VudEhhbmRsZXI8U2xvdExhYmVsTW91bnRBcmc+PixcbiAgc2xvdExhYmVsV2lsbFVubW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PFdpbGxVbm1vdW50SGFuZGxlcjxTbG90TGFiZWxNb3VudEFyZz4+LFxuXG4gIGRheU1heEV2ZW50czogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbiB8IG51bWJlcj4sXG4gIGRheU1heEV2ZW50Um93czogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbiB8IG51bWJlcj4sXG4gIGRheU1pbldpZHRoOiBOdW1iZXIsXG4gIHNsb3RMYWJlbEludGVydmFsOiBjcmVhdGVEdXJhdGlvbixcblxuICBhbGxEYXlUZXh0OiBTdHJpbmcsXG4gIGFsbERheUNsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8QWxsRGF5Q29udGVudEFyZz4+LFxuICBhbGxEYXlDb250ZW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDdXN0b21Db250ZW50R2VuZXJhdG9yPEFsbERheUNvbnRlbnRBcmc+PixcbiAgYWxsRGF5RGlkTW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERpZE1vdW50SGFuZGxlcjxBbGxEYXlNb3VudEFyZz4+LFxuICBhbGxEYXlXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPEFsbERheU1vdW50QXJnPj4sXG5cbiAgc2xvdE1pbldpZHRoOiBOdW1iZXIsIC8vIG1vdmUgdG8gdGltZWxpbmU/XG4gIG5hdkxpbmtzOiBCb29sZWFuLFxuICBldmVudFRpbWVGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgcmVyZW5kZXJEZWxheTogTnVtYmVyLCAvLyBUT0RPOiBtb3ZlIHRvIEBmdWxsY2FsZW5kYXIvY29yZSByaWdodD8gbmFoIGtlZXAgaGVyZVxuICBtb3JlTGlua1RleHQ6IGlkZW50aXR5IGFzIElkZW50aXR5PHN0cmluZyB8ICgodGhpczogQ2FsZW5kYXJBcGksIG51bTogbnVtYmVyKSA9PiBzdHJpbmcpPiwgLy8gdGhpcyBub3QgZW5mb3JjZWQgOiggY2hlY2sgb3RoZXJzIHRvb1xuICBzZWxlY3RNaW5EaXN0YW5jZTogTnVtYmVyLFxuICBzZWxlY3RhYmxlOiBCb29sZWFuLFxuICBzZWxlY3RMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICBldmVudExvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXG5cbiAgc2VsZWN0TWlycm9yOiBCb29sZWFuLFxuICBldmVudE1heFN0YWNrOiBOdW1iZXIsXG4gIGV2ZW50TWluSGVpZ2h0OiBOdW1iZXIsXG4gIGV2ZW50TWluV2lkdGg6IE51bWJlcixcbiAgZXZlbnRTaG9ydEhlaWdodDogTnVtYmVyLFxuICBzbG90RXZlbnRPdmVybGFwOiBCb29sZWFuLFxuICBwbHVnaW5zOiBpZGVudGl0eSBhcyBJZGVudGl0eTxQbHVnaW5EZWZbXT4sXG4gIGZpcnN0RGF5OiBOdW1iZXIsXG4gIGRheUNvdW50OiBOdW1iZXIsXG4gIGRhdGVBbGlnbm1lbnQ6IFN0cmluZyxcbiAgZGF0ZUluY3JlbWVudDogY3JlYXRlRHVyYXRpb24sXG4gIGhpZGRlbkRheXM6IGlkZW50aXR5IGFzIElkZW50aXR5PG51bWJlcltdPixcbiAgbW9udGhNb2RlOiBCb29sZWFuLFxuICBmaXhlZFdlZWtDb3VudDogQm9vbGVhbixcbiAgdmFsaWRSYW5nZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZVJhbmdlSW5wdXQgfCAoKHRoaXM6IENhbGVuZGFyQXBpLCBub3dEYXRlOiBEYXRlKSA9PiBEYXRlUmFuZ2VJbnB1dCk+LCAvLyBgdGhpc2Agd29ya3M/XG4gIHZpc2libGVSYW5nZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZVJhbmdlSW5wdXQgfCAoKHRoaXM6IENhbGVuZGFyQXBpLCBjdXJyZW50RGF0ZTogRGF0ZSkgPT4gRGF0ZVJhbmdlSW5wdXQpPiwgLy8gYHRoaXNgIHdvcmtzP1xuICB0aXRsZUZvcm1hdDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Rm9ybWF0dGVySW5wdXQ+LCAvLyBET05UIHBhcnNlIGp1c3QgeWV0LiB3ZSBuZWVkIHRvIGluamVjdCB0aXRsZVNlcGFyYXRvclxuXG4gIC8vIG9ubHkgdXNlZCBieSBsaXN0LXZpZXcsIGJ1dCBsYW5ndWFnZXMgZGVmaW5lIHRoZSB2YWx1ZSwgc28gd2UgbmVlZCBpdCBpbiBiYXNlIG9wdGlvbnNcbiAgbm9FdmVudHNUZXh0OiBTdHJpbmcsXG5cbiAgbW9yZUxpbmtDbGljazogaWRlbnRpdHkgYXMgSWRlbnRpdHk8TW9yZUxpbmtBY3Rpb24+LFxuICBtb3JlTGlua0NsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8TW9yZUxpbmtDb250ZW50QXJnPj4sXG4gIG1vcmVMaW5rQ29udGVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3VzdG9tQ29udGVudEdlbmVyYXRvcjxNb3JlTGlua0NvbnRlbnRBcmc+PixcbiAgbW9yZUxpbmtEaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPE1vcmVMaW5rTW91bnRBcmc+PixcbiAgbW9yZUxpbmtXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPE1vcmVMaW5rTW91bnRBcmc+Pixcbn1cblxudHlwZSBCdWlsdEluQmFzZU9wdGlvblJlZmluZXJzID0gdHlwZW9mIEJBU0VfT1BUSU9OX1JFRklORVJTXG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZU9wdGlvblJlZmluZXJzIGV4dGVuZHMgQnVpbHRJbkJhc2VPcHRpb25SZWZpbmVycyB7XG4gIC8vIGZvciBhbWJpZW50LWV4dGVuZGluZ1xufVxuXG5leHBvcnQgdHlwZSBCYXNlT3B0aW9ucyA9IFJhd09wdGlvbnNGcm9tUmVmaW5lcnM8IC8vIGFzIFJhd09wdGlvbnNcbiAgUmVxdWlyZWQ8QmFzZU9wdGlvblJlZmluZXJzPiAvLyBSZXF1aXJlZCBpcyBhIGhhY2sgZm9yIFwiSW5kZXggc2lnbmF0dXJlIGlzIG1pc3NpbmdcIlxuPlxuXG4vLyBkbyBOT1QgZ2l2ZSBhIHR5cGUgaGVyZS4gbmVlZCBgdHlwZW9mIEJBU0VfT1BUSU9OX0RFRkFVTFRTYCB0byBnaXZlIHJlYWwgcmVzdWx0cy5cbi8vIHJhdyB2YWx1ZXMuXG5leHBvcnQgY29uc3QgQkFTRV9PUFRJT05fREVGQVVMVFMgPSB7XG4gIGV2ZW50RGlzcGxheTogJ2F1dG8nLFxuICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxuICB0aXRsZVJhbmdlU2VwYXJhdG9yOiAnIFxcdTIwMTMgJywgLy8gZW4gZGFzaFxuICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiAnMDE6MDA6MDAnLFxuICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogeyBkYXk6IDEgfSxcbiAgZm9yY2VFdmVudER1cmF0aW9uOiBmYWxzZSxcbiAgbmV4dERheVRocmVzaG9sZDogJzAwOjAwOjAwJyxcbiAgZGF5SGVhZGVyczogdHJ1ZSxcbiAgaW5pdGlhbFZpZXc6ICcnLFxuICBhc3BlY3RSYXRpbzogMS4zNSxcbiAgaGVhZGVyVG9vbGJhcjoge1xuICAgIHN0YXJ0OiAndGl0bGUnLFxuICAgIGNlbnRlcjogJycsXG4gICAgZW5kOiAndG9kYXkgcHJldixuZXh0JyxcbiAgfSxcbiAgd2Vla2VuZHM6IHRydWUsXG4gIHdlZWtOdW1iZXJzOiBmYWxzZSxcbiAgd2Vla051bWJlckNhbGN1bGF0aW9uOiAnbG9jYWwnIGFzIFdlZWtOdW1iZXJDYWxjdWxhdGlvbixcbiAgZWRpdGFibGU6IGZhbHNlLFxuICBub3dJbmRpY2F0b3I6IGZhbHNlLFxuICBzY3JvbGxUaW1lOiAnMDY6MDA6MDAnLFxuICBzY3JvbGxUaW1lUmVzZXQ6IHRydWUsXG4gIHNsb3RNaW5UaW1lOiAnMDA6MDA6MDAnLFxuICBzbG90TWF4VGltZTogJzI0OjAwOjAwJyxcbiAgc2hvd05vbkN1cnJlbnREYXRlczogdHJ1ZSxcbiAgbGF6eUZldGNoaW5nOiB0cnVlLFxuICBzdGFydFBhcmFtOiAnc3RhcnQnLFxuICBlbmRQYXJhbTogJ2VuZCcsXG4gIHRpbWVab25lUGFyYW06ICd0aW1lWm9uZScsXG4gIHRpbWVab25lOiAnbG9jYWwnLCAvLyBUT0RPOiB0aHJvdyBlcnJvciBpZiBnaXZlbiBmYWxzeSB2YWx1ZT9cbiAgbG9jYWxlczogW10sXG4gIGxvY2FsZTogJycsIC8vIGJsYW5rIHZhbHVlcyBtZWFucyBpdCB3aWxsIGNvbXB1dGUgYmFzZWQgb2ZmIGxvY2FsZXNbXVxuICB0aGVtZVN5c3RlbTogJ3N0YW5kYXJkJyxcbiAgZHJhZ1JldmVydER1cmF0aW9uOiA1MDAsXG4gIGRyYWdTY3JvbGw6IHRydWUsXG4gIGFsbERheU1haW50YWluRHVyYXRpb246IGZhbHNlLFxuICB1bnNlbGVjdEF1dG86IHRydWUsXG4gIGRyb3BBY2NlcHQ6ICcqJyxcbiAgZXZlbnRPcmRlcjogJ3N0YXJ0LC1kdXJhdGlvbixhbGxEYXksdGl0bGUnLFxuICBkYXlQb3BvdmVyRm9ybWF0OiB7IG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnLCB5ZWFyOiAnbnVtZXJpYycgfSxcbiAgaGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxuICB3aW5kb3dSZXNpemVEZWxheTogMTAwLCAvLyBtaWxsaXNlY29uZHMgYmVmb3JlIGFuIHVwZGF0ZVNpemUgaGFwcGVuc1xuICBsb25nUHJlc3NEZWxheTogMTAwMCxcbiAgZXZlbnREcmFnTWluRGlzdGFuY2U6IDUsIC8vIG9ubHkgYXBwbGllcyB0byBtb3VzZVxuICBleHBhbmRSb3dzOiBmYWxzZSxcbiAgbmF2TGlua3M6IGZhbHNlLFxuICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgZXZlbnRNaW5IZWlnaHQ6IDE1LFxuICBldmVudE1pbldpZHRoOiAzMCxcbiAgZXZlbnRTaG9ydEhlaWdodDogMzAsXG59XG5cbmV4cG9ydCB0eXBlIEJhc2VPcHRpb25zUmVmaW5lZCA9IERlZmF1bHRlZFJlZmluZWRPcHRpb25zPFxuICBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVyczxSZXF1aXJlZDxCYXNlT3B0aW9uUmVmaW5lcnM+PiwgLy8gUmVxdWlyZWQgaXMgYSBoYWNrIGZvciBcIkluZGV4IHNpZ25hdHVyZSBpcyBtaXNzaW5nXCJcbiAga2V5b2YgdHlwZW9mIEJBU0VfT1BUSU9OX0RFRkFVTFRTXG4+XG5cbi8vIGNhbGVuZGFyIGxpc3RlbmVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgZGF0ZXNTZXQ6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IERhdGVzU2V0QXJnKSA9PiB2b2lkPixcbiAgZXZlbnRzU2V0OiBpZGVudGl0eSBhcyBJZGVudGl0eTwoZXZlbnRzOiBFdmVudEFwaVtdKSA9PiB2b2lkPixcbiAgZXZlbnRBZGQ6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50QWRkQXJnKSA9PiB2b2lkPixcbiAgZXZlbnRDaGFuZ2U6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50Q2hhbmdlQXJnKSA9PiB2b2lkPixcbiAgZXZlbnRSZW1vdmU6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50UmVtb3ZlQXJnKSA9PiB2b2lkPixcbiAgd2luZG93UmVzaXplOiBpZGVudGl0eSBhcyBJZGVudGl0eTwoYXJnOiB7IHZpZXc6IFZpZXdBcGkgfSkgPT4gdm9pZD4sXG4gIGV2ZW50Q2xpY2s6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50Q2xpY2tBcmcpID0+IHZvaWQ+LCAvLyBUT0RPOiByZXNvdXJjZSBmb3Igc2NoZWR1bGVyPz8/P1xuICBldmVudE1vdXNlRW50ZXI6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50SG92ZXJpbmdBcmcpID0+IHZvaWQ+LFxuICBldmVudE1vdXNlTGVhdmU6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50SG92ZXJpbmdBcmcpID0+IHZvaWQ+LFxuICBzZWxlY3Q6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IERhdGVTZWxlY3RBcmcpID0+IHZvaWQ+LCAvLyByZXNvdXJjZSBmb3Igc2NoZWR1bGVyPz8/P1xuICB1bnNlbGVjdDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRGF0ZVVuc2VsZWN0QXJnKSA9PiB2b2lkPixcbiAgbG9hZGluZzogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGlzTG9hZGluZzogYm9vbGVhbikgPT4gdm9pZD4sXG5cbiAgLy8gaW50ZXJuYWxcbiAgX3VubW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PCgpID0+IHZvaWQ+LFxuICBfYmVmb3JlcHJpbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PCgpID0+IHZvaWQ+LFxuICBfYWZ0ZXJwcmludDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KCkgPT4gdm9pZD4sXG4gIF9ub0V2ZW50RHJvcDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KCkgPT4gdm9pZD4sXG4gIF9ub0V2ZW50UmVzaXplOiBpZGVudGl0eSBhcyBJZGVudGl0eTwoKSA9PiB2b2lkPixcbiAgX3Jlc2l6ZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGZvcmNlZDogYm9vbGVhbikgPT4gdm9pZD4sXG4gIF9zY3JvbGxSZXF1ZXN0OiBpZGVudGl0eSBhcyBJZGVudGl0eTwoYXJnOiBhbnkpID0+IHZvaWQ+LFxufVxuXG50eXBlIEJ1aWx0SW5DYWxlbmRhckxpc3RlbmVyUmVmaW5lcnMgPSB0eXBlb2YgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlNcblxuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhckxpc3RlbmVyUmVmaW5lcnMgZXh0ZW5kcyBCdWlsdEluQ2FsZW5kYXJMaXN0ZW5lclJlZmluZXJzIHtcbiAgLy8gZm9yIGFtYmllbnQgZXh0ZW5kaW5nXG59XG5cbnR5cGUgQ2FsZW5kYXJMaXN0ZW5lcnNMb29zZSA9IFJlZmluZWRPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPENhbGVuZGFyTGlzdGVuZXJSZWZpbmVycz4+IC8vIFJlcXVpcmVkIGhhY2tcbmV4cG9ydCB0eXBlIENhbGVuZGFyTGlzdGVuZXJzID0gUmVxdWlyZWQ8Q2FsZW5kYXJMaXN0ZW5lcnNMb29zZT4gLy8gbXVjaCBtb3JlIGNvbnZlbmllbnQgZm9yIEVtaXR0ZXJzIGFuZCB3aGF0bm90XG5cbi8vIGNhbGVuZGFyLXNwZWNpZmljIG9wdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IENBTEVOREFSX09QVElPTl9SRUZJTkVSUyA9IHsgLy8gZG9lcyBub3QgaW5jbHVkZSBiYXNlIG5vciBjYWxlbmRhciBsaXN0ZW5lcnNcbiAgYnV0dG9uVGV4dDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8QnV0dG9uVGV4dENvbXBvdW5kSW5wdXQ+LFxuICB2aWV3czogaWRlbnRpdHkgYXMgSWRlbnRpdHk8eyBbdmlld0lkOiBzdHJpbmddOiBWaWV3T3B0aW9ucyB9PixcbiAgcGx1Z2luczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8UGx1Z2luRGVmW10+LFxuICBpbml0aWFsRXZlbnRzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxFdmVudFNvdXJjZUlucHV0PixcbiAgZXZlbnRzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxFdmVudFNvdXJjZUlucHV0PixcbiAgZXZlbnRTb3VyY2VzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxFdmVudFNvdXJjZUlucHV0W10+LFxufVxuXG50eXBlIEJ1aWx0SW5DYWxlbmRhck9wdGlvblJlZmluZXJzID0gdHlwZW9mIENBTEVOREFSX09QVElPTl9SRUZJTkVSU1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbGVuZGFyT3B0aW9uUmVmaW5lcnMgZXh0ZW5kcyBCdWlsdEluQ2FsZW5kYXJPcHRpb25SZWZpbmVycyB7XG4gIC8vIGZvciBhbWJpZW50LWV4dGVuZGluZ1xufVxuXG5leHBvcnQgdHlwZSBDYWxlbmRhck9wdGlvbnMgPVxuICBCYXNlT3B0aW9ucyAmXG4gIENhbGVuZGFyTGlzdGVuZXJzTG9vc2UgJlxuICBSYXdPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPENhbGVuZGFyT3B0aW9uUmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTUzMDBcblxuZXhwb3J0IHR5cGUgQ2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9XG4gIEJhc2VPcHRpb25zUmVmaW5lZCAmXG4gIENhbGVuZGFyTGlzdGVuZXJzTG9vc2UgJlxuICBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVyczxSZXF1aXJlZDxDYWxlbmRhck9wdGlvblJlZmluZXJzPj4gLy8gUmVxdWlyZWQgaGFja1xuXG5leHBvcnQgY29uc3QgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlM6IHtcbiAgW29wdGlvbk5hbWUgaW4ga2V5b2YgQ2FsZW5kYXJPcHRpb25zXTogKGE6IENhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSwgYjogQ2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdKSA9PiBib29sZWFuXG59ID0ge1xuICBoZWFkZXJUb29sYmFyOiBpc0Jvb2xDb21wbGV4RXF1YWwsXG4gIGZvb3RlclRvb2xiYXI6IGlzQm9vbENvbXBsZXhFcXVhbCxcbiAgYnV0dG9uVGV4dDogaXNCb29sQ29tcGxleEVxdWFsLFxuICBidXR0b25JY29uczogaXNCb29sQ29tcGxleEVxdWFsLFxufVxuXG5mdW5jdGlvbiBpc0Jvb2xDb21wbGV4RXF1YWwoYSwgYikge1xuICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiBhICYmIGIpIHsgLy8gYm90aCBub24tbnVsbCBvYmplY3RzXG4gICAgcmV0dXJuIGlzUHJvcHNFcXVhbChhLCBiKVxuICB9XG4gIHJldHVybiBhID09PSBiXG59XG5cbi8vIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBWSUVXX09QVElPTl9SRUZJTkVSUzoge1xuICBbbmFtZTogc3RyaW5nXTogYW55XG59ID0ge1xuICB0eXBlOiBTdHJpbmcsXG4gIGNvbXBvbmVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Vmlld0NvbXBvbmVudFR5cGU+LFxuICBidXR0b25UZXh0OiBTdHJpbmcsXG4gIGJ1dHRvblRleHRLZXk6IFN0cmluZywgLy8gaW50ZXJuYWwgb25seVxuICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzPixcbiAgdXNlc01pbk1heFRpbWU6IEJvb2xlYW4sIC8vIGludGVybmFsIG9ubHlcbiAgY2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxTcGVjaWZpY1ZpZXdDb250ZW50QXJnPj4sXG4gIGNvbnRlbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PEN1c3RvbUNvbnRlbnRHZW5lcmF0b3I8U3BlY2lmaWNWaWV3Q29udGVudEFyZz4+LFxuICBkaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPFNwZWNpZmljVmlld01vdW50QXJnPj4sXG4gIHdpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8U3BlY2lmaWNWaWV3TW91bnRBcmc+Pixcbn1cblxudHlwZSBCdWlsdEluVmlld09wdGlvblJlZmluZXJzID0gdHlwZW9mIFZJRVdfT1BUSU9OX1JFRklORVJTXG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlld09wdGlvblJlZmluZXJzIGV4dGVuZHMgQnVpbHRJblZpZXdPcHRpb25SZWZpbmVycyB7XG4gIC8vIGZvciBhbWJpZW50LWV4dGVuZGluZ1xufVxuXG5leHBvcnQgdHlwZSBWaWV3T3B0aW9ucyA9XG4gIEJhc2VPcHRpb25zICZcbiAgQ2FsZW5kYXJMaXN0ZW5lcnNMb29zZSAmXG4gIFJhd09wdGlvbnNGcm9tUmVmaW5lcnM8UmVxdWlyZWQ8Vmlld09wdGlvblJlZmluZXJzPj4gLy8gUmVxdWlyZWQgaGFja1xuXG5leHBvcnQgdHlwZSBWaWV3T3B0aW9uc1JlZmluZWQgPVxuICBCYXNlT3B0aW9uc1JlZmluZWQgJlxuICBDYWxlbmRhckxpc3RlbmVyc0xvb3NlICZcbiAgUmVmaW5lZE9wdGlvbnNGcm9tUmVmaW5lcnM8UmVxdWlyZWQ8Vmlld09wdGlvblJlZmluZXJzPj4gLy8gUmVxdWlyZWQgaGFja1xuXG4vLyB1dGlsIGZ1bmNzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVJhd09wdGlvbnMob3B0aW9uU2V0czogRGljdGlvbmFyeVtdKSB7XG4gIHJldHVybiBtZXJnZVByb3BzKG9wdGlvblNldHMsIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVmaW5lUHJvcHM8UmVmaW5lcnMgZXh0ZW5kcyBHZW5lcmljUmVmaW5lcnMsIFJhdyBleHRlbmRzIFJhd09wdGlvbnNGcm9tUmVmaW5lcnM8UmVmaW5lcnM+PihcbiAgaW5wdXQ6IFJhdyxcbiAgcmVmaW5lcnM6IFJlZmluZXJzLFxuKToge1xuICByZWZpbmVkOiBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVyczxSZWZpbmVycz4sXG4gIGV4dHJhOiBEaWN0aW9uYXJ5LFxufSB7XG4gIGxldCByZWZpbmVkID0ge30gYXMgYW55XG4gIGxldCBleHRyYSA9IHt9IGFzIGFueVxuXG4gIGZvciAobGV0IHByb3BOYW1lIGluIHJlZmluZXJzKSB7XG4gICAgaWYgKHByb3BOYW1lIGluIGlucHV0KSB7XG4gICAgICByZWZpbmVkW3Byb3BOYW1lXSA9IHJlZmluZXJzW3Byb3BOYW1lXShpbnB1dFtwcm9wTmFtZV0pXG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgcHJvcE5hbWUgaW4gaW5wdXQpIHtcbiAgICBpZiAoIShwcm9wTmFtZSBpbiByZWZpbmVycykpIHtcbiAgICAgIGV4dHJhW3Byb3BOYW1lXSA9IGlucHV0W3Byb3BOYW1lXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHJlZmluZWQsIGV4dHJhIH1cbn1cblxuLy8gZGVmaW5pdGlvbiB1dGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgdHlwZSBHZW5lcmljUmVmaW5lcnMgPSB7XG4gIFtwcm9wTmFtZTogc3RyaW5nXTogKGlucHV0OiBhbnkpID0+IGFueVxufVxuXG5leHBvcnQgdHlwZSBHZW5lcmljTGlzdGVuZXJSZWZpbmVycyA9IHtcbiAgW2xpc3RlbmVyTmFtZTogc3RyaW5nXTogSWRlbnRpdHk8KHRoaXM6IENhbGVuZGFyQXBpLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD5cbn1cblxuZXhwb3J0IHR5cGUgUmF3T3B0aW9uc0Zyb21SZWZpbmVyczxSZWZpbmVycyBleHRlbmRzIEdlbmVyaWNSZWZpbmVycz4gPSB7XG4gIFtQcm9wIGluIGtleW9mIFJlZmluZXJzXT86IC8vIGFsbCBvcHRpb25hbFxuICAgIFJlZmluZXJzW1Byb3BdIGV4dGVuZHMgKChpbnB1dDogaW5mZXIgUmF3VHlwZSkgPT4gaW5mZXIgUmVmaW5lZFR5cGUpXG4gICAgICA/IChhbnkgZXh0ZW5kcyBSYXdUeXBlID8gUmVmaW5lZFR5cGUgOiBSYXdUeXBlKSAvLyBpZiBpbnB1dCB0eXBlIGBhbnlgLCB1c2Ugb3V0cHV0IChmb3IgQm9vbGVhbi9OdW1iZXIvU3RyaW5nKVxuICAgICAgOiBuZXZlclxufVxuXG5leHBvcnQgdHlwZSBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVyczxSZWZpbmVycyBleHRlbmRzIEdlbmVyaWNSZWZpbmVycz4gPSB7XG4gIFtQcm9wIGluIGtleW9mIFJlZmluZXJzXT86IC8vIGFsbCBvcHRpb25hbFxuICAgIFJlZmluZXJzW1Byb3BdIGV4dGVuZHMgKChpbnB1dDogYW55KSA9PiBpbmZlciBSZWZpbmVkVHlwZSkgPyBSZWZpbmVkVHlwZSA6IG5ldmVyXG59XG5cbmV4cG9ydCB0eXBlIERlZmF1bHRlZFJlZmluZWRPcHRpb25zPFJlZmluZWRPcHRpb25zIGV4dGVuZHMgRGljdGlvbmFyeSwgRGVmYXVsdEtleSBleHRlbmRzIGtleW9mIFJlZmluZWRPcHRpb25zPiA9XG4gIFJlcXVpcmVkPFBpY2s8UmVmaW5lZE9wdGlvbnMsIERlZmF1bHRLZXk+PiAmXG4gIFBhcnRpYWw8T21pdDxSZWZpbmVkT3B0aW9ucywgRGVmYXVsdEtleT4+XG5cbmV4cG9ydCB0eXBlIERpY3Rpb25hcnkgPSBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5cbmV4cG9ydCB0eXBlIElkZW50aXR5PFQgPSBhbnk+ID0gKHJhdzogVCkgPT4gVFxuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHk8VD4ocmF3OiBUKTogVCB7XG4gIHJldHVybiByYXdcbn1cbiIsImltcG9ydCB7IEV2ZW50RGVmLCBFdmVudERlZkhhc2ggfSBmcm9tICcuL2V2ZW50LWRlZidcbmltcG9ydCB7IEV2ZW50SW5zdGFuY2UsIEV2ZW50SW5zdGFuY2VIYXNoIH0gZnJvbSAnLi9ldmVudC1pbnN0YW5jZSdcbmltcG9ydCB7IEV2ZW50SW5wdXQsIHBhcnNlRXZlbnQsIEV2ZW50VHVwbGUsIGJ1aWxkRXZlbnRSZWZpbmVycyB9IGZyb20gJy4vZXZlbnQtcGFyc2UnXG5pbXBvcnQgeyBmaWx0ZXJIYXNoIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBFdmVudFNvdXJjZSB9IGZyb20gJy4vZXZlbnQtc291cmNlJ1xuXG4vKlxuQSBkYXRhIHN0cnVjdHVyZSB0aGF0IGVuY2Fwc3VsYXRlcyBFdmVudERlZnMgYW5kIEV2ZW50SW5zdGFuY2VzLlxuVXRpbHMgZm9yIHBhcnNpbmcgdGhpcyBkYXRhIGZyb20gcmF3IEV2ZW50SW5wdXRzLlxuVXRpbHMgZm9yIG1hbmlwdWxhdGluZyBhbiBFdmVudFN0b3JlLlxuKi9cblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFN0b3JlIHtcbiAgZGVmczogRXZlbnREZWZIYXNoXG4gIGluc3RhbmNlczogRXZlbnRJbnN0YW5jZUhhc2hcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRXZlbnRzKFxuICByYXdFdmVudHM6IEV2ZW50SW5wdXRbXSxcbiAgZXZlbnRTb3VyY2U6IEV2ZW50U291cmNlPGFueT4gfCBudWxsLFxuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4gIGFsbG93T3BlblJhbmdlPzogYm9vbGVhbixcbik6IEV2ZW50U3RvcmUge1xuICBsZXQgZXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpXG4gIGxldCBldmVudFJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpXG5cbiAgZm9yIChsZXQgcmF3RXZlbnQgb2YgcmF3RXZlbnRzKSB7XG4gICAgbGV0IHR1cGxlID0gcGFyc2VFdmVudChyYXdFdmVudCwgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCBldmVudFJlZmluZXJzKVxuXG4gICAgaWYgKHR1cGxlKSB7XG4gICAgICBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnRTdG9yZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZlbnRUdXBsZVRvU3RvcmUodHVwbGU6IEV2ZW50VHVwbGUsIGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSkge1xuICBldmVudFN0b3JlLmRlZnNbdHVwbGUuZGVmLmRlZklkXSA9IHR1cGxlLmRlZlxuXG4gIGlmICh0dXBsZS5pbnN0YW5jZSkge1xuICAgIGV2ZW50U3RvcmUuaW5zdGFuY2VzW3R1cGxlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gdHVwbGUuaW5zdGFuY2VcbiAgfVxuXG4gIHJldHVybiBldmVudFN0b3JlXG59XG5cbi8vIHJldHJpZXZlcyBldmVudHMgdGhhdCBoYXZlIHRoZSBzYW1lIGdyb3VwSWQgYXMgdGhlIGluc3RhbmNlIHNwZWNpZmllZCBieSBgaW5zdGFuY2VJZGBcbi8vIG9yIHRoZXkgYXJlIHRoZSBzYW1lIGFzIHRoZSBpbnN0YW5jZS5cbi8vIHdoeSBtaWdodCBpbnN0YW5jZUlkIG5vdCBiZSBpbiB0aGUgc3RvcmU/IGFuIGV2ZW50IGZyb20gYW5vdGhlciBjYWxlbmRhcj9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlOiBFdmVudFN0b3JlLCBpbnN0YW5jZUlkOiBzdHJpbmcpOiBFdmVudFN0b3JlIHtcbiAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF1cblxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2luc3RhbmNlLmRlZklkXVxuXG4gICAgLy8gZ2V0IGV2ZW50cy9pbnN0YW5jZXMgd2l0aCBzYW1lIGdyb3VwXG4gICAgbGV0IG5ld1N0b3JlID0gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgKGxvb2tEZWYpID0+IGlzRXZlbnREZWZzR3JvdXBlZChkZWYsIGxvb2tEZWYpKVxuXG4gICAgLy8gYWRkIHRoZSBvcmlnaW5hbFxuICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgdXNlIGV2ZW50VHVwbGVUb1N0b3JlIG9yIHNvbWV0aGluZyBsaWtlIGl0XG4gICAgbmV3U3RvcmUuZGVmc1tkZWYuZGVmSWRdID0gZGVmXG4gICAgbmV3U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2VcblxuICAgIHJldHVybiBuZXdTdG9yZVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpXG59XG5cbmZ1bmN0aW9uIGlzRXZlbnREZWZzR3JvdXBlZChkZWYwOiBFdmVudERlZiwgZGVmMTogRXZlbnREZWYpOiBib29sZWFuIHtcbiAgcmV0dXJuIEJvb2xlYW4oZGVmMC5ncm91cElkICYmIGRlZjAuZ3JvdXBJZCA9PT0gZGVmMS5ncm91cElkKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk6IEV2ZW50U3RvcmUge1xuICByZXR1cm4geyBkZWZzOiB7fSwgaW5zdGFuY2VzOiB7fSB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUV2ZW50U3RvcmVzKHN0b3JlMDogRXZlbnRTdG9yZSwgc3RvcmUxOiBFdmVudFN0b3JlKTogRXZlbnRTdG9yZSB7XG4gIHJldHVybiB7XG4gICAgZGVmczogeyAuLi5zdG9yZTAuZGVmcywgLi4uc3RvcmUxLmRlZnMgfSxcbiAgICBpbnN0YW5jZXM6IHsgLi4uc3RvcmUwLmluc3RhbmNlcywgLi4uc3RvcmUxLmluc3RhbmNlcyB9LFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlOiBFdmVudFN0b3JlLCBmaWx0ZXJGdW5jOiAoZXZlbnREZWY6IEV2ZW50RGVmKSA9PiBib29sZWFuKTogRXZlbnRTdG9yZSB7XG4gIGxldCBkZWZzID0gZmlsdGVySGFzaChldmVudFN0b3JlLmRlZnMsIGZpbHRlckZ1bmMpXG4gIGxldCBpbnN0YW5jZXMgPSBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCAoaW5zdGFuY2U6IEV2ZW50SW5zdGFuY2UpID0+IChcbiAgICBkZWZzW2luc3RhbmNlLmRlZklkXSAvLyBzdGlsbCBleGlzdHM/XG4gICkpXG4gIHJldHVybiB7IGRlZnMsIGluc3RhbmNlcyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleGNsdWRlU3ViRXZlbnRTdG9yZShtYXN0ZXI6IEV2ZW50U3RvcmUsIHN1YjogRXZlbnRTdG9yZSk6IEV2ZW50U3RvcmUge1xuICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IG1hc3RlclxuICBsZXQgZmlsdGVyZWREZWZzOiB7IFtkZWZJZDogc3RyaW5nXTogRXZlbnREZWYgfSA9IHt9XG4gIGxldCBmaWx0ZXJlZEluc3RhbmNlczogeyBbaW5zdGFuY2VJZDogc3RyaW5nXTogRXZlbnRJbnN0YW5jZSB9ID0ge31cblxuICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgaWYgKCFzdWIuZGVmc1tkZWZJZF0pIHsgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcbiAgICAgIGZpbHRlcmVkRGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgaWYgKFxuICAgICAgIXN1Yi5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gJiYgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcbiAgICAgIGZpbHRlcmVkRGVmc1tpbnN0YW5jZXNbaW5zdGFuY2VJZF0uZGVmSWRdIC8vIGRlZiB3YXNuJ3QgZmlsdGVyZWQgYXdheVxuICAgICkge1xuICAgICAgZmlsdGVyZWRJbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRlZnM6IGZpbHRlcmVkRGVmcyxcbiAgICBpbnN0YW5jZXM6IGZpbHRlcmVkSW5zdGFuY2VzLFxuICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudFN0b3JlLCBwYXJzZUV2ZW50cyB9IGZyb20gJy4vZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBFdmVudElucHV0IH0gZnJvbSAnLi9ldmVudC1wYXJzZSdcbmltcG9ydCB7IERhdGVTcGFuQXBpIH0gZnJvbSAnLi9kYXRlLXNwYW4nXG5pbXBvcnQgeyBFdmVudEFwaSB9IGZyb20gJy4uL2FwaS9FdmVudEFwaSdcbmltcG9ydCB7IFNwbGl0dGFibGVQcm9wcyB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC1zcGxpdHRpbmcnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5cbi8vIFRPRE86IHJlbmFtZSB0byBcImNyaXRlcmlhXCIgP1xuZXhwb3J0IHR5cGUgQ29uc3RyYWludElucHV0ID0gJ2J1c2luZXNzSG91cnMnIHwgc3RyaW5nIHwgRXZlbnRJbnB1dCB8IEV2ZW50SW5wdXRbXVxuZXhwb3J0IHR5cGUgQ29uc3RyYWludCA9ICdidXNpbmVzc0hvdXJzJyB8IHN0cmluZyB8IEV2ZW50U3RvcmUgfCBmYWxzZSAvLyBmYWxzZSBtZWFucyB3b24ndCBwYXNzIGF0IGFsbFxuZXhwb3J0IHR5cGUgT3ZlcmxhcEZ1bmMgPSAoKHN0aWxsRXZlbnQ6IEV2ZW50QXBpLCBtb3ZpbmdFdmVudDogRXZlbnRBcGkgfCBudWxsKSA9PiBib29sZWFuKVxuZXhwb3J0IHR5cGUgQWxsb3dGdW5jID0gKHNwYW46IERhdGVTcGFuQXBpLCBtb3ZpbmdFdmVudDogRXZlbnRBcGkgfCBudWxsKSA9PiBib29sZWFuXG5leHBvcnQgdHlwZSBpc1Byb3BzVmFsaWRUZXN0ZXIgPSAocHJvcHM6IFNwbGl0dGFibGVQcm9wcywgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSA9PiBib29sZWFuXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVDb25zdHJhaW50KGlucHV0OiBDb25zdHJhaW50SW5wdXQsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IENvbnN0cmFpbnQgfCBudWxsIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKGlucHV0LCBudWxsLCBjb250ZXh0LCB0cnVlKSAvLyBhbGxvd09wZW5SYW5nZT10cnVlXG4gIH0gaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKFtpbnB1dF0sIG51bGwsIGNvbnRleHQsIHRydWUpIC8vIGFsbG93T3BlblJhbmdlPXRydWVcbiAgfSBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgIHJldHVybiBTdHJpbmcoaW5wdXQpXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cbiIsImV4cG9ydCB0eXBlIENsYXNzTmFtZXNJbnB1dCA9IHN0cmluZyB8IHN0cmluZ1tdXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNsYXNzTmFtZXMocmF3OiBDbGFzc05hbWVzSW5wdXQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgIHJldHVybiByYXdcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiByYXcuc3BsaXQoL1xccysvKVxuICB9XG5cbiAgcmV0dXJuIFtdXG59XG4iLCJpbXBvcnQgeyBDb25zdHJhaW50LCBBbGxvd0Z1bmMsIG5vcm1hbGl6ZUNvbnN0cmFpbnQgfSBmcm9tICcuLi9zdHJ1Y3RzL2NvbnN0cmFpbnQnXG5pbXBvcnQgeyBwYXJzZUNsYXNzTmFtZXMgfSBmcm9tICcuLi91dGlsL2h0bWwnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBSYXdPcHRpb25zRnJvbVJlZmluZXJzLCBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVycywgaWRlbnRpdHksIElkZW50aXR5IH0gZnJvbSAnLi4vb3B0aW9ucydcblxuLy8gVE9ETzogYmV0dGVyIGNhbGxlZCBcIkV2ZW50U2V0dGluZ3NcIiBvciBcIkV2ZW50Q29uZmlnXCJcbi8vIFRPRE86IG1vdmUgdGhpcyBmaWxlIGludG8gc3RydWN0c1xuLy8gVE9ETzogc2VwYXJhdGUgY29uc3RyYWludC9vdmVybGFwL2FsbG93LCBiZWNhdXNlIHNlbGVjdGlvbiB1c2VzIG9ubHkgdGhhdCwgbm90IG90aGVyIHByb3BzXG5cbmV4cG9ydCBjb25zdCBFVkVOVF9VSV9SRUZJTkVSUyA9IHtcbiAgZGlzcGxheTogU3RyaW5nLFxuICBlZGl0YWJsZTogQm9vbGVhbixcbiAgc3RhcnRFZGl0YWJsZTogQm9vbGVhbixcbiAgZHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgY29uc3RyYWludDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8YW55PiwgLy8gSWRlbnRpdHk8Q29uc3RyYWludElucHV0PiwgLy8gY2lyY3VsYXIgcmVmZXJlbmNlLiB0cyBkaWVzLiBldmVudC0+Y29uc3RyYWludC0+ZXZlbnRcbiAgb3ZlcmxhcDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbj4sXG4gIGFsbG93OiBpZGVudGl0eSBhcyBJZGVudGl0eTxBbGxvd0Z1bmM+LFxuICBjbGFzc05hbWU6IHBhcnNlQ2xhc3NOYW1lcywgLy8gd2lsbCBib3RoIGVuZCB1cCBhcyBhcnJheSBvZiBzdHJpbmdzXG4gIGNsYXNzTmFtZXM6IHBhcnNlQ2xhc3NOYW1lcywgLy8gXCJcbiAgY29sb3I6IFN0cmluZyxcbiAgYmFja2dyb3VuZENvbG9yOiBTdHJpbmcsXG4gIGJvcmRlckNvbG9yOiBTdHJpbmcsXG4gIHRleHRDb2xvcjogU3RyaW5nLFxufVxuXG5jb25zdCBFTVBUWV9FVkVOVF9VSTogRXZlbnRVaSA9IHtcbiAgZGlzcGxheTogbnVsbCxcbiAgc3RhcnRFZGl0YWJsZTogbnVsbCxcbiAgZHVyYXRpb25FZGl0YWJsZTogbnVsbCxcbiAgY29uc3RyYWludHM6IFtdLFxuICBvdmVybGFwOiBudWxsLFxuICBhbGxvd3M6IFtdLFxuICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICBib3JkZXJDb2xvcjogJycsXG4gIHRleHRDb2xvcjogJycsXG4gIGNsYXNzTmFtZXM6IFtdLFxufVxuXG50eXBlIEJ1aWx0SW5FdmVudFVpUmVmaW5lcnMgPSB0eXBlb2YgRVZFTlRfVUlfUkVGSU5FUlNcblxuaW50ZXJmYWNlIEV2ZW50VWlSZWZpbmVycyBleHRlbmRzIEJ1aWx0SW5FdmVudFVpUmVmaW5lcnMge1xuICAvLyB0byBwcmV2ZW50IGNpcmN1bGFyIHJlZmVyZW5jZSAoYW5kIGdpdmUgaXMgdGhlIG9wdGlvbiBmb3IgYW1iaWVudCBtb2RpZmljYXRpb24gZm9yIGxhdGVyKVxufVxuXG5leHBvcnQgdHlwZSBFdmVudFVpSW5wdXQgPSBSYXdPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPEV2ZW50VWlSZWZpbmVycz4+IC8vIFJlcXVpcmVkIGhhY2tcbmV4cG9ydCB0eXBlIEV2ZW50VWlSZWZpbmVkID0gUmVmaW5lZE9wdGlvbnNGcm9tUmVmaW5lcnM8UmVxdWlyZWQ8RXZlbnRVaVJlZmluZXJzPj4gLy8gUmVxdWlyZWQgaGFja1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50VWkge1xuICBkaXNwbGF5OiBzdHJpbmcgfCBudWxsXG4gIHN0YXJ0RWRpdGFibGU6IGJvb2xlYW4gfCBudWxsXG4gIGR1cmF0aW9uRWRpdGFibGU6IGJvb2xlYW4gfCBudWxsXG4gIGNvbnN0cmFpbnRzOiBDb25zdHJhaW50W11cbiAgb3ZlcmxhcDogYm9vbGVhbiB8IG51bGxcbiAgYWxsb3dzOiBBbGxvd0Z1bmNbXSAvLyBjcmFwcHkgbmFtZSB0byBpbmRpY2F0ZSBwbHVyYWxcbiAgYmFja2dyb3VuZENvbG9yOiBzdHJpbmdcbiAgYm9yZGVyQ29sb3I6IHN0cmluZ1xuICB0ZXh0Q29sb3I6IHN0cmluZyxcbiAgY2xhc3NOYW1lczogc3RyaW5nW11cbn1cblxuZXhwb3J0IHR5cGUgRXZlbnRVaUhhc2ggPSB7IFtkZWZJZDogc3RyaW5nXTogRXZlbnRVaSB9XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudFVpKHJlZmluZWQ6IEV2ZW50VWlSZWZpbmVkLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudFVpIHtcbiAgbGV0IGNvbnN0cmFpbnQgPSBub3JtYWxpemVDb25zdHJhaW50KHJlZmluZWQuY29uc3RyYWludCwgY29udGV4dClcblxuICByZXR1cm4ge1xuICAgIGRpc3BsYXk6IHJlZmluZWQuZGlzcGxheSB8fCBudWxsLFxuICAgIHN0YXJ0RWRpdGFibGU6IHJlZmluZWQuc3RhcnRFZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5zdGFydEVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICBkdXJhdGlvbkVkaXRhYmxlOiByZWZpbmVkLmR1cmF0aW9uRWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnQgIT0gbnVsbCA/IFtjb25zdHJhaW50XSA6IFtdLFxuICAgIG92ZXJsYXA6IHJlZmluZWQub3ZlcmxhcCAhPSBudWxsID8gcmVmaW5lZC5vdmVybGFwIDogbnVsbCxcbiAgICBhbGxvd3M6IHJlZmluZWQuYWxsb3cgIT0gbnVsbCA/IFtyZWZpbmVkLmFsbG93XSA6IFtdLFxuICAgIGJhY2tncm91bmRDb2xvcjogcmVmaW5lZC5iYWNrZ3JvdW5kQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICBib3JkZXJDb2xvcjogcmVmaW5lZC5ib3JkZXJDb2xvciB8fCByZWZpbmVkLmNvbG9yIHx8ICcnLFxuICAgIHRleHRDb2xvcjogcmVmaW5lZC50ZXh0Q29sb3IgfHwgJycsXG4gICAgY2xhc3NOYW1lczogKHJlZmluZWQuY2xhc3NOYW1lIHx8IFtdKS5jb25jYXQocmVmaW5lZC5jbGFzc05hbWVzIHx8IFtdKSwgLy8gam9pbiBzaW5ndWxhciBhbmQgcGx1cmFsXG4gIH1cbn1cblxuLy8gVE9ETzogcHJldmVudCBhZ2FpbnN0IHByb2JsZW1zIHdpdGggPDIgYXJncyFcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lRXZlbnRVaXModWlzOiBFdmVudFVpW10pOiBFdmVudFVpIHtcbiAgcmV0dXJuIHVpcy5yZWR1Y2UoY29tYmluZVR3b0V2ZW50VWlzLCBFTVBUWV9FVkVOVF9VSSlcbn1cblxuZnVuY3Rpb24gY29tYmluZVR3b0V2ZW50VWlzKGl0ZW0wOiBFdmVudFVpLCBpdGVtMTogRXZlbnRVaSk6IEV2ZW50VWkgeyAvLyBoYXNoMSBoYXMgaGlnaGVyIHByZWNlZGVuY2VcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGF5OiBpdGVtMS5kaXNwbGF5ICE9IG51bGwgPyBpdGVtMS5kaXNwbGF5IDogaXRlbTAuZGlzcGxheSxcbiAgICBzdGFydEVkaXRhYmxlOiBpdGVtMS5zdGFydEVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5zdGFydEVkaXRhYmxlIDogaXRlbTAuc3RhcnRFZGl0YWJsZSxcbiAgICBkdXJhdGlvbkVkaXRhYmxlOiBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlIDogaXRlbTAuZHVyYXRpb25FZGl0YWJsZSxcbiAgICBjb25zdHJhaW50czogaXRlbTAuY29uc3RyYWludHMuY29uY2F0KGl0ZW0xLmNvbnN0cmFpbnRzKSxcbiAgICBvdmVybGFwOiB0eXBlb2YgaXRlbTEub3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gaXRlbTEub3ZlcmxhcCA6IGl0ZW0wLm92ZXJsYXAsXG4gICAgYWxsb3dzOiBpdGVtMC5hbGxvd3MuY29uY2F0KGl0ZW0xLmFsbG93cyksXG4gICAgYmFja2dyb3VuZENvbG9yOiBpdGVtMS5iYWNrZ3JvdW5kQ29sb3IgfHwgaXRlbTAuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNvbG9yOiBpdGVtMS5ib3JkZXJDb2xvciB8fCBpdGVtMC5ib3JkZXJDb2xvcixcbiAgICB0ZXh0Q29sb3I6IGl0ZW0xLnRleHRDb2xvciB8fCBpdGVtMC50ZXh0Q29sb3IsXG4gICAgY2xhc3NOYW1lczogaXRlbTAuY2xhc3NOYW1lcy5jb25jYXQoaXRlbTEuY2xhc3NOYW1lcyksXG4gIH1cbn1cbiIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInXG5pbXBvcnQgeyBndWlkIH0gZnJvbSAnLi4vdXRpbC9taXNjJ1xuaW1wb3J0IHsgRGF0ZUlucHV0IH0gZnJvbSAnLi4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBzdGFydE9mRGF5IH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBwYXJzZVJlY3VycmluZyB9IGZyb20gJy4vcmVjdXJyaW5nLWV2ZW50J1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgRXZlbnREZWYgfSBmcm9tICcuL2V2ZW50LWRlZidcbmltcG9ydCB7IGNyZWF0ZUV2ZW50SW5zdGFuY2UsIEV2ZW50SW5zdGFuY2UgfSBmcm9tICcuL2V2ZW50LWluc3RhbmNlJ1xuaW1wb3J0IHsgRXZlbnRTb3VyY2UgfSBmcm9tICcuL2V2ZW50LXNvdXJjZSdcbmltcG9ydCB7IFJlZmluZWRPcHRpb25zRnJvbVJlZmluZXJzLCBSYXdPcHRpb25zRnJvbVJlZmluZXJzLCBpZGVudGl0eSwgSWRlbnRpdHksIERpY3Rpb25hcnksIHJlZmluZVByb3BzIH0gZnJvbSAnLi4vb3B0aW9ucydcbmltcG9ydCB7IEVWRU5UX1VJX1JFRklORVJTLCBjcmVhdGVFdmVudFVpLCBFdmVudFVpSW5wdXQsIEV2ZW50VWlSZWZpbmVkIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXVpJ1xuXG5leHBvcnQgY29uc3QgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMgPSB7XG4gIGlkOiBTdHJpbmcsXG4gIGdyb3VwSWQ6IFN0cmluZyxcbiAgdGl0bGU6IFN0cmluZyxcbiAgdXJsOiBTdHJpbmcsXG59XG5cbmV4cG9ydCBjb25zdCBFVkVOVF9EQVRFX1JFRklORVJTID0ge1xuICBzdGFydDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZUlucHV0PixcbiAgZW5kOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlSW5wdXQ+LFxuICBkYXRlOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlSW5wdXQ+LFxuICBhbGxEYXk6IEJvb2xlYW4sXG59XG5cbmNvbnN0IEVWRU5UX1JFRklORVJTID0geyAvLyBkb2VzIE5PVCBpbmNsdWRlIEVWRU5UX1VJX1JFRklORVJTXG4gIC4uLkVWRU5UX05PTl9EQVRFX1JFRklORVJTLFxuICAuLi5FVkVOVF9EQVRFX1JFRklORVJTLFxuICBleHRlbmRlZFByb3BzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWN0aW9uYXJ5Pixcbn1cblxudHlwZSBCdWlsdEluRXZlbnRSZWZpbmVycyA9IHR5cGVvZiBFVkVOVF9SRUZJTkVSU1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50UmVmaW5lcnMgZXh0ZW5kcyBCdWlsdEluRXZlbnRSZWZpbmVycyB7XG4gIC8vIGZvciBhbWJpZW50XG59XG5cbmV4cG9ydCB0eXBlIEV2ZW50SW5wdXQgPVxuICBFdmVudFVpSW5wdXQgJlxuICBSYXdPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPEV2ZW50UmVmaW5lcnM+PiAmIC8vIFJlcXVpcmVkIGhhY2tcbiAgeyBbZXh0ZW5kZWRQcm9wOiBzdHJpbmddOiBhbnkgfVxuXG5leHBvcnQgdHlwZSBFdmVudFJlZmluZWQgPVxuICBFdmVudFVpUmVmaW5lZCAmXG4gIFJlZmluZWRPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPEV2ZW50UmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRUdXBsZSB7XG4gIGRlZjogRXZlbnREZWZcbiAgaW5zdGFuY2U6IEV2ZW50SW5zdGFuY2UgfCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIEV2ZW50SW5wdXRUcmFuc2Zvcm1lciA9IChpbnB1dDogRXZlbnRJbnB1dCkgPT4gRXZlbnRJbnB1dFxuZXhwb3J0IHR5cGUgRXZlbnREZWZNZW1iZXJBZGRlciA9IChyZWZpbmVkOiBFdmVudFJlZmluZWQpID0+IFBhcnRpYWw8RXZlbnREZWY+XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV2ZW50KFxuICByYXc6IEV2ZW50SW5wdXQsXG4gIGV2ZW50U291cmNlOiBFdmVudFNvdXJjZTxhbnk+IHwgbnVsbCxcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuICBhbGxvd09wZW5SYW5nZTogYm9vbGVhbixcbiAgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCksXG4pOiBFdmVudFR1cGxlIHwgbnVsbCB7XG4gIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzKVxuXG4gIGxldCBkZWZhdWx0QWxsRGF5ID0gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dClcbiAgbGV0IHJlY3VycmluZ1JlcyA9IHBhcnNlUmVjdXJyaW5nKFxuICAgIHJlZmluZWQsXG4gICAgZGVmYXVsdEFsbERheSxcbiAgICBjb250ZXh0LmRhdGVFbnYsXG4gICAgY29udGV4dC5wbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlcyxcbiAgKVxuXG4gIGlmIChyZWN1cnJpbmdSZXMpIHtcbiAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihcbiAgICAgIHJlZmluZWQsXG4gICAgICBleHRyYSxcbiAgICAgIGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2Uuc291cmNlSWQgOiAnJyxcbiAgICAgIHJlY3VycmluZ1Jlcy5hbGxEYXksXG4gICAgICBCb29sZWFuKHJlY3VycmluZ1Jlcy5kdXJhdGlvbiksXG4gICAgICBjb250ZXh0LFxuICAgIClcblxuICAgIGRlZi5yZWN1cnJpbmdEZWYgPSB7IC8vIGRvbid0IHdhbnQgYWxsIHRoZSBwcm9wcyBmcm9tIHJlY3VycmluZ1Jlcy4gVE9ETzogbW9yZSBlZmZpY2llbnQgd2F5IHRvIGRvIHRoaXNcbiAgICAgIHR5cGVJZDogcmVjdXJyaW5nUmVzLnR5cGVJZCxcbiAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdSZXMudHlwZURhdGEsXG4gICAgICBkdXJhdGlvbjogcmVjdXJyaW5nUmVzLmR1cmF0aW9uLFxuICAgIH1cblxuICAgIHJldHVybiB7IGRlZiwgaW5zdGFuY2U6IG51bGwgfVxuICB9XG4gIGxldCBzaW5nbGVSZXMgPSBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSlcblxuICBpZiAoc2luZ2xlUmVzKSB7XG4gICAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2Uuc291cmNlSWQgOiAnJywgc2luZ2xlUmVzLmFsbERheSwgc2luZ2xlUmVzLmhhc0VuZCwgY29udGV4dClcbiAgICBsZXQgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgc2luZ2xlUmVzLnJhbmdlLCBzaW5nbGVSZXMuZm9yY2VkU3RhcnRUem8sIHNpbmdsZVJlcy5mb3JjZWRFbmRUem8pXG5cbiAgICByZXR1cm4geyBkZWYsIGluc3RhbmNlIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWZpbmVFdmVudERlZihyYXc6IEV2ZW50SW5wdXQsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkpIHtcbiAgcmV0dXJuIHJlZmluZVByb3BzKHJhdywgcmVmaW5lcnMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIHJldHVybiB7IC4uLkVWRU5UX1VJX1JFRklORVJTLCAuLi5FVkVOVF9SRUZJTkVSUywgLi4uY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFJlZmluZXJzIH1cbn1cblxuLypcbldpbGwgTk9UIHBvcHVsYXRlIGV4dGVuZGVkUHJvcHMgd2l0aCB0aGUgbGVmdG92ZXIgcHJvcGVydGllcy5cbldpbGwgTk9UIHBvcHVsYXRlIGRhdGUtcmVsYXRlZCBwcm9wcy5cbiovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdmVudERlZihcbiAgcmVmaW5lZDogRXZlbnRSZWZpbmVkLFxuICBleHRyYTogRGljdGlvbmFyeSxcbiAgc291cmNlSWQ6IHN0cmluZyxcbiAgYWxsRGF5OiBib29sZWFuLFxuICBoYXNFbmQ6IGJvb2xlYW4sXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbik6IEV2ZW50RGVmIHtcbiAgbGV0IGRlZjogRXZlbnREZWYgPSB7XG4gICAgdGl0bGU6IHJlZmluZWQudGl0bGUgfHwgJycsXG4gICAgZ3JvdXBJZDogcmVmaW5lZC5ncm91cElkIHx8ICcnLFxuICAgIHB1YmxpY0lkOiByZWZpbmVkLmlkIHx8ICcnLFxuICAgIHVybDogcmVmaW5lZC51cmwgfHwgJycsXG4gICAgcmVjdXJyaW5nRGVmOiBudWxsLFxuICAgIGRlZklkOiBndWlkKCksXG4gICAgc291cmNlSWQsXG4gICAgYWxsRGF5LFxuICAgIGhhc0VuZCxcbiAgICB1aTogY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSxcbiAgICBleHRlbmRlZFByb3BzOiB7XG4gICAgICAuLi4ocmVmaW5lZC5leHRlbmRlZFByb3BzIHx8IHt9KSxcbiAgICAgIC4uLmV4dHJhLFxuICAgIH0sXG4gIH1cblxuICBmb3IgKGxldCBtZW1iZXJBZGRlciBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSB7XG4gICAgX19hc3NpZ24oZGVmLCBtZW1iZXJBZGRlcihyZWZpbmVkKSlcbiAgfVxuXG4gIC8vIGhlbHAgb3V0IEV2ZW50QXBpIGZyb20gaGF2aW5nIHVzZXIgbW9kaWZ5IHByb3BzXG4gIE9iamVjdC5mcmVlemUoZGVmLnVpLmNsYXNzTmFtZXMpXG4gIE9iamVjdC5mcmVlemUoZGVmLmV4dGVuZGVkUHJvcHMpXG5cbiAgcmV0dXJuIGRlZlxufVxuXG5mdW5jdGlvbiBwYXJzZVNpbmdsZShyZWZpbmVkOiBFdmVudFJlZmluZWQsIGRlZmF1bHRBbGxEYXk6IGJvb2xlYW4gfCBudWxsLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsIGFsbG93T3BlblJhbmdlPzogYm9vbGVhbikge1xuICBsZXQgeyBhbGxEYXkgfSA9IHJlZmluZWRcbiAgbGV0IHN0YXJ0TWV0YVxuICBsZXQgc3RhcnRNYXJrZXIgPSBudWxsXG4gIGxldCBoYXNFbmQgPSBmYWxzZVxuICBsZXQgZW5kTWV0YVxuICBsZXQgZW5kTWFya2VyID0gbnVsbFxuXG4gIGxldCBzdGFydElucHV0ID0gcmVmaW5lZC5zdGFydCAhPSBudWxsID8gcmVmaW5lZC5zdGFydCA6IHJlZmluZWQuZGF0ZVxuICBzdGFydE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KVxuXG4gIGlmIChzdGFydE1ldGEpIHtcbiAgICBzdGFydE1hcmtlciA9IHN0YXJ0TWV0YS5tYXJrZXJcbiAgfSBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKHJlZmluZWQuZW5kICE9IG51bGwpIHtcbiAgICBlbmRNZXRhID0gY29udGV4dC5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEocmVmaW5lZC5lbmQpXG4gIH1cblxuICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICBpZiAoZGVmYXVsdEFsbERheSAhPSBudWxsKSB7XG4gICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgZGF0ZSBwcm9wcyBMQVNUXG4gICAgICBhbGxEYXkgPSAoIXN0YXJ0TWV0YSB8fCBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxEYXkgJiYgc3RhcnRNYXJrZXIpIHtcbiAgICBzdGFydE1hcmtlciA9IHN0YXJ0T2ZEYXkoc3RhcnRNYXJrZXIpXG4gIH1cblxuICBpZiAoZW5kTWV0YSkge1xuICAgIGVuZE1hcmtlciA9IGVuZE1ldGEubWFya2VyXG5cbiAgICBpZiAoYWxsRGF5KSB7XG4gICAgICBlbmRNYXJrZXIgPSBzdGFydE9mRGF5KGVuZE1hcmtlcilcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyIDw9IHN0YXJ0TWFya2VyKSB7XG4gICAgICBlbmRNYXJrZXIgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZE1hcmtlcikge1xuICAgIGhhc0VuZCA9IHRydWVcbiAgfSBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICBoYXNFbmQgPSBjb250ZXh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uIHx8IGZhbHNlXG5cbiAgICBlbmRNYXJrZXIgPSBjb250ZXh0LmRhdGVFbnYuYWRkKFxuICAgICAgc3RhcnRNYXJrZXIsXG4gICAgICBhbGxEYXkgP1xuICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbixcbiAgICApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFsbERheSxcbiAgICBoYXNFbmQsXG4gICAgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0TWFya2VyLCBlbmQ6IGVuZE1hcmtlciB9LFxuICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEgPyBzdGFydE1ldGEuZm9yY2VkVHpvIDogbnVsbCxcbiAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEgPyBlbmRNZXRhLmZvcmNlZFR6byA6IG51bGwsXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PiB8IG51bGwsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IGJvb2xlYW4gfCBudWxsIHtcbiAgbGV0IHJlcyA9IG51bGxcblxuICBpZiAoZXZlbnRTb3VyY2UpIHtcbiAgICByZXMgPSBldmVudFNvdXJjZS5kZWZhdWx0QWxsRGF5XG4gIH1cblxuICBpZiAocmVzID09IG51bGwpIHtcbiAgICByZXMgPSBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheVxuICB9XG5cbiAgcmV0dXJuIHJlc1xufVxuIiwiaW1wb3J0IHsgRGF0ZU1hcmtlciwgc3RhcnRPZkRheSwgYWRkRGF5cywgZGlmZkRheXMsIGRpZmZEYXlBbmRUaW1lIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBEdXJhdGlvbiwgYXNSb3VnaE1zLCBjcmVhdGVEdXJhdGlvbiB9IGZyb20gJy4uL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyBEYXRlRW52IH0gZnJvbSAnLi4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBEYXRlUmFuZ2UsIE9wZW5EYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5cbi8qIERhdGUgc3R1ZmYgdGhhdCBkb2Vzbid0IGJlbG9uZyBpbiBkYXRlbGliIGNvcmVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIHRoYXQgaGFzIHRoZSBzYW1lIGV4YWN0IGR1cmF0aW9uLFxuLy8gYnV0IHdob3NlIHN0YXJ0IHRpbWUgaXMgYWxpZ25lZCB3aXRoIHRoZSBzdGFydCBvZiB0aGUgZGF5LlxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UodGltZWRSYW5nZTogRGF0ZVJhbmdlKTogRGF0ZVJhbmdlIHtcbiAgbGV0IGRheUNudCA9IE1hdGguZmxvb3IoZGlmZkRheXModGltZWRSYW5nZS5zdGFydCwgdGltZWRSYW5nZS5lbmQpKSB8fCAxXG4gIGxldCBzdGFydCA9IHN0YXJ0T2ZEYXkodGltZWRSYW5nZS5zdGFydClcbiAgbGV0IGVuZCA9IGFkZERheXMoc3RhcnQsIGRheUNudClcbiAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9XG59XG5cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgYmFzZWQgb24gaG93IGZvciB0aGUgZW5kIGRhdGUgYmxlZWRzIGludG8gdGhlIG5leHQgZGF5XG4vLyBUT0RPOiBnaXZlIG5leHREYXlUaHJlc2hvbGQgYSBkZWZhdWx0IGFyZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UodGltZWRSYW5nZTogT3BlbkRhdGVSYW5nZSwgbmV4dERheVRocmVzaG9sZDogRHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbigwKSk6IE9wZW5EYXRlUmFuZ2Uge1xuICBsZXQgc3RhcnREYXk6IERhdGVNYXJrZXIgPSBudWxsXG4gIGxldCBlbmREYXk6IERhdGVNYXJrZXIgPSBudWxsXG5cbiAgaWYgKHRpbWVkUmFuZ2UuZW5kKSB7XG4gICAgZW5kRGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLmVuZClcblxuICAgIGxldCBlbmRUaW1lTVM6IG51bWJlciA9IHRpbWVkUmFuZ2UuZW5kLnZhbHVlT2YoKSAtIGVuZERheS52YWx1ZU9mKCkgLy8gIyBvZiBtaWxsaXNlY29uZHMgaW50byBgZW5kRGF5YFxuXG4gICAgLy8gSWYgdGhlIGVuZCB0aW1lIGlzIGFjdHVhbGx5IGluY2x1c2l2ZWx5IHBhcnQgb2YgdGhlIG5leHQgZGF5IGFuZCBpcyBlcXVhbCB0byBvclxuICAgIC8vIGJleW9uZCB0aGUgbmV4dCBkYXkgdGhyZXNob2xkLCBhZGp1c3QgdGhlIGVuZCB0byBiZSB0aGUgZXhjbHVzaXZlIGVuZCBvZiBgZW5kRGF5YC5cbiAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cbiAgICBpZiAoZW5kVGltZU1TICYmIGVuZFRpbWVNUyA+PSBhc1JvdWdoTXMobmV4dERheVRocmVzaG9sZCkpIHtcbiAgICAgIGVuZERheSA9IGFkZERheXMoZW5kRGF5LCAxKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aW1lZFJhbmdlLnN0YXJ0KSB7XG4gICAgc3RhcnREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpIC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2Ugc3RhcnRzXG5cbiAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuICAgIGlmIChlbmREYXkgJiYgZW5kRGF5IDw9IHN0YXJ0RGF5KSB7XG4gICAgICBlbmREYXkgPSBhZGREYXlzKHN0YXJ0RGF5LCAxKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHN0YXJ0OiBzdGFydERheSwgZW5kOiBlbmREYXkgfVxufVxuXG4vLyBzcGFucyBmcm9tIG9uZSBkYXkgaW50byBhbm90aGVyP1xuZXhwb3J0IGZ1bmN0aW9uIGlzTXVsdGlEYXlSYW5nZShyYW5nZTogRGF0ZVJhbmdlKSB7XG4gIGxldCB2aXNpYmxlUmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKVxuXG4gIHJldHVybiBkaWZmRGF5cyh2aXNpYmxlUmFuZ2Uuc3RhcnQsIHZpc2libGVSYW5nZS5lbmQpID4gMVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZkRhdGVzKGRhdGUwOiBEYXRlTWFya2VyLCBkYXRlMTogRGF0ZU1hcmtlciwgZGF0ZUVudjogRGF0ZUVudiwgbGFyZ2VVbml0Pzogc3RyaW5nKSB7XG4gIGlmIChsYXJnZVVuaXQgPT09ICd5ZWFyJykge1xuICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihkYXRlRW52LmRpZmZXaG9sZVllYXJzKGRhdGUwLCBkYXRlMSksICd5ZWFyJykhXG4gIH1cblxuICBpZiAobGFyZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlTW9udGhzKGRhdGUwLCBkYXRlMSksICdtb250aCcpIVxuICB9XG5cbiAgcmV0dXJuIGRpZmZEYXlBbmRUaW1lKGRhdGUwLCBkYXRlMSkgLy8gcmV0dXJucyBhIGR1cmF0aW9uXG59XG4iLCJpbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi9tYXJrZXInXG5pbXBvcnQgeyBEYXRlRW52LCBEYXRlSW5wdXQgfSBmcm9tICcuL2VudidcblxuZXhwb3J0IGludGVyZmFjZSBEYXRlUmFuZ2VJbnB1dCB7XG4gIHN0YXJ0PzogRGF0ZUlucHV0XG4gIGVuZD86IERhdGVJbnB1dFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wZW5EYXRlUmFuZ2Uge1xuICBzdGFydDogRGF0ZU1hcmtlciB8IG51bGxcbiAgZW5kOiBEYXRlTWFya2VyIHwgbnVsbFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVSYW5nZSB7XG4gIHN0YXJ0OiBEYXRlTWFya2VyXG4gIGVuZDogRGF0ZU1hcmtlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSYW5nZShpbnB1dDogRGF0ZVJhbmdlSW5wdXQsIGRhdGVFbnY6IERhdGVFbnYpOiBPcGVuRGF0ZVJhbmdlIHtcbiAgbGV0IHN0YXJ0ID0gbnVsbFxuICBsZXQgZW5kID0gbnVsbFxuXG4gIGlmIChpbnB1dC5zdGFydCkge1xuICAgIHN0YXJ0ID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuc3RhcnQpXG4gIH1cblxuICBpZiAoaW5wdXQuZW5kKSB7XG4gICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuZW5kKVxuICB9XG5cbiAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmIChzdGFydCAmJiBlbmQgJiYgZW5kIDwgc3RhcnQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9XG59XG5cbi8vIFNJREUtRUZGRUNUOiB3aWxsIG11dGF0ZSByYW5nZXMuXG4vLyBXaWxsIHJldHVybiBhIG5ldyBhcnJheSByZXN1bHQuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0UmFuZ2VzKHJhbmdlczogRGF0ZVJhbmdlW10sIGNvbnN0cmFpbnRSYW5nZTogRGF0ZVJhbmdlKTogRGF0ZVJhbmdlW10ge1xuICBsZXQgaW52ZXJ0ZWRSYW5nZXM6IERhdGVSYW5nZVtdID0gW11cbiAgbGV0IHsgc3RhcnQgfSA9IGNvbnN0cmFpbnRSYW5nZSAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2VcbiAgbGV0IGlcbiAgbGV0IGRhdGVSYW5nZVxuXG4gIC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cbiAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcylcblxuICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgZGF0ZVJhbmdlID0gcmFuZ2VzW2ldXG5cbiAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBiZWZvcmUgdGhlIGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXG4gICAgaWYgKGRhdGVSYW5nZS5zdGFydCA+IHN0YXJ0KSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZDogZGF0ZVJhbmdlLnN0YXJ0IH0pXG4gICAgfVxuXG4gICAgaWYgKGRhdGVSYW5nZS5lbmQgPiBzdGFydCkge1xuICAgICAgc3RhcnQgPSBkYXRlUmFuZ2UuZW5kXG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYWZ0ZXIgdGhlIGxhc3QgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgaWYgKHN0YXJ0IDwgY29uc3RyYWludFJhbmdlLmVuZCkgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxuICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydCwgZW5kOiBjb25zdHJhaW50UmFuZ2UuZW5kIH0pXG4gIH1cblxuICByZXR1cm4gaW52ZXJ0ZWRSYW5nZXNcbn1cblxuZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhyYW5nZTA6IERhdGVSYW5nZSwgcmFuZ2UxOiBEYXRlUmFuZ2UpIHtcbiAgcmV0dXJuIHJhbmdlMC5zdGFydC52YWx1ZU9mKCkgLSByYW5nZTEuc3RhcnQudmFsdWVPZigpIC8vIGVhcmxpZXIgcmFuZ2VzIGdvIGZpcnN0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RSYW5nZXMocmFuZ2UwOiBPcGVuRGF0ZVJhbmdlLCByYW5nZTE6IE9wZW5EYXRlUmFuZ2UpOiBPcGVuRGF0ZVJhbmdlIHtcbiAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2UwXG4gIGxldCBuZXdSYW5nZSA9IG51bGxcblxuICBpZiAocmFuZ2UxLnN0YXJ0ICE9PSBudWxsKSB7XG4gICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICBzdGFydCA9IHJhbmdlMS5zdGFydFxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IG5ldyBEYXRlKE1hdGgubWF4KHN0YXJ0LnZhbHVlT2YoKSwgcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkpXG4gICAgfVxuICB9XG5cbiAgaWYgKHJhbmdlMS5lbmQgIT0gbnVsbCkge1xuICAgIGlmIChlbmQgPT09IG51bGwpIHtcbiAgICAgIGVuZCA9IHJhbmdlMS5lbmRcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gbmV3IERhdGUoTWF0aC5taW4oZW5kLnZhbHVlT2YoKSwgcmFuZ2UxLmVuZC52YWx1ZU9mKCkpKVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gbnVsbCB8fCBlbmQgPT09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcbiAgICBuZXdSYW5nZSA9IHsgc3RhcnQsIGVuZCB9XG4gIH1cblxuICByZXR1cm4gbmV3UmFuZ2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlc0VxdWFsKHJhbmdlMDogT3BlbkRhdGVSYW5nZSwgcmFuZ2UxOiBPcGVuRGF0ZVJhbmdlKTogYm9vbGVhbiB7XG4gIHJldHVybiAocmFuZ2UwLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5zdGFydC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpICYmXG4gICAgKHJhbmdlMC5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLmVuZC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTEuZW5kLnZhbHVlT2YoKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlc0ludGVyc2VjdChyYW5nZTA6IE9wZW5EYXRlUmFuZ2UsIHJhbmdlMTogT3BlbkRhdGVSYW5nZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKHJhbmdlMC5lbmQgPT09IG51bGwgfHwgcmFuZ2UxLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMC5lbmQgPiByYW5nZTEuc3RhcnQpICYmXG4gICAgKHJhbmdlMC5zdGFydCA9PT0gbnVsbCB8fCByYW5nZTEuZW5kID09PSBudWxsIHx8IHJhbmdlMC5zdGFydCA8IHJhbmdlMS5lbmQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZTogT3BlbkRhdGVSYW5nZSwgaW5uZXJSYW5nZTogT3BlbkRhdGVSYW5nZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKG91dGVyUmFuZ2Uuc3RhcnQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2Uuc3RhcnQgIT09IG51bGwgJiYgaW5uZXJSYW5nZS5zdGFydCA+PSBvdXRlclJhbmdlLnN0YXJ0KSkgJiZcbiAgICAob3V0ZXJSYW5nZS5lbmQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kICE9PSBudWxsICYmIGlubmVyUmFuZ2UuZW5kIDw9IG91dGVyUmFuZ2UuZW5kKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlQ29udGFpbnNNYXJrZXIocmFuZ2U6IE9wZW5EYXRlUmFuZ2UsIGRhdGU6IERhdGVNYXJrZXIgfCBudW1iZXIpOiBib29sZWFuIHsgLy8gZGF0ZSBjYW4gYmUgYSBtaWxsaXNlY29uZCB0aW1lXG4gIHJldHVybiAocmFuZ2Uuc3RhcnQgPT09IG51bGwgfHwgZGF0ZSA+PSByYW5nZS5zdGFydCkgJiZcbiAgICAocmFuZ2UuZW5kID09PSBudWxsIHx8IGRhdGUgPCByYW5nZS5lbmQpXG59XG5cbi8vIElmIHRoZSBnaXZlbiBkYXRlIGlzIG5vdCB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlLCBtb3ZlIGl0IGluc2lkZS5cbi8vIChJZiBpdCdzIHBhc3QgdGhlIGVuZCwgbWFrZSBpdCBvbmUgbWlsbGlzZWNvbmQgYmVmb3JlIHRoZSBlbmQpLlxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoZGF0ZTogRGF0ZU1hcmtlciwgcmFuZ2U6IERhdGVSYW5nZSk6IERhdGVNYXJrZXIge1xuICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCAmJiBkYXRlIDwgcmFuZ2Uuc3RhcnQpIHtcbiAgICByZXR1cm4gcmFuZ2Uuc3RhcnRcbiAgfVxuXG4gIGlmIChyYW5nZS5lbmQgIT0gbnVsbCAmJiBkYXRlID49IHJhbmdlLmVuZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShyYW5nZS5lbmQudmFsdWVPZigpIC0gMSlcbiAgfVxuXG4gIHJldHVybiBkYXRlXG59XG4iLCJpbXBvcnQgeyBFdmVudERlZiwgRXZlbnREZWZIYXNoIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1kZWYnXG5pbXBvcnQgeyBFdmVudFR1cGxlIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1wYXJzZSdcbmltcG9ydCB7IEV2ZW50U3RvcmUgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgRGF0ZVJhbmdlLCBpbnZlcnRSYW5nZXMsIGludGVyc2VjdFJhbmdlcywgcmFuZ2VDb250YWluc01hcmtlciB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IGNvbXBhcmVCeUZpZWxkU3BlY3MsIE9yZGVyU3BlYyB9IGZyb20gJy4uL3V0aWwvbWlzYydcbmltcG9ydCB7IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UgfSBmcm9tICcuLi91dGlsL2RhdGUnXG5pbXBvcnQgeyBTZWcgfSBmcm9tICcuL0RhdGVDb21wb25lbnQnXG5pbXBvcnQgeyBFdmVudEFwaSB9IGZyb20gJy4uL2FwaS9FdmVudEFwaSdcbmltcG9ydCB7IEV2ZW50VWksIEV2ZW50VWlIYXNoLCBjb21iaW5lRXZlbnRVaXMgfSBmcm9tICcuL2V2ZW50LXVpJ1xuaW1wb3J0IHsgbWFwSGFzaCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgVmlld0NvbnRleHQgfSBmcm9tICcuLi9WaWV3Q29udGV4dCdcbmltcG9ydCB7IERhdGVGb3JtYXR0ZXIgfSBmcm9tICcuLi9kYXRlbGliL0RhdGVGb3JtYXR0ZXInXG5pbXBvcnQgeyBhZGRNcywgRGF0ZU1hcmtlciwgc3RhcnRPZkRheSB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgVmlld0FwaSB9IGZyb20gJy4uL1ZpZXdBcGknXG5pbXBvcnQgeyBNb3VudEFyZyB9IGZyb20gJy4uL2NvbW1vbi9yZW5kZXItaG9vaydcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFJlbmRlclJhbmdlIGV4dGVuZHMgRXZlbnRUdXBsZSB7XG4gIHVpOiBFdmVudFVpXG4gIHJhbmdlOiBEYXRlUmFuZ2VcbiAgaXNTdGFydDogYm9vbGVhblxuICBpc0VuZDogYm9vbGVhblxufVxuXG4vKlxuU3BlY2lmeWluZyBuZXh0RGF5VGhyZXNob2xkIHNpZ25hbHMgdGhhdCBhbGwtZGF5IHJhbmdlcyBzaG91bGQgYmUgc2xpY2VkLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaCwgZnJhbWluZ1JhbmdlOiBEYXRlUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQ/OiBEdXJhdGlvbikge1xuICBsZXQgaW52ZXJzZUJnQnlHcm91cElkOiB7IFtncm91cElkOiBzdHJpbmddOiBEYXRlUmFuZ2VbXSB9ID0ge31cbiAgbGV0IGludmVyc2VCZ0J5RGVmSWQ6IHsgW2RlZklkOiBzdHJpbmddOiBEYXRlUmFuZ2VbXSB9ID0ge31cbiAgbGV0IGRlZkJ5R3JvdXBJZDogeyBbZ3JvdXBJZDogc3RyaW5nXTogRXZlbnREZWYgfSA9IHt9XG4gIGxldCBiZ1JhbmdlczogRXZlbnRSZW5kZXJSYW5nZVtdID0gW11cbiAgbGV0IGZnUmFuZ2VzOiBFdmVudFJlbmRlclJhbmdlW10gPSBbXVxuICBsZXQgZXZlbnRVaXMgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudFVpQmFzZXMpXG5cbiAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF1cbiAgICBsZXQgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdXG5cbiAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICBpbnZlcnNlQmdCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gW11cblxuICAgICAgICBpZiAoIWRlZkJ5R3JvdXBJZFtkZWYuZ3JvdXBJZF0pIHtcbiAgICAgICAgICBkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gZGVmXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdID0gW11cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGV2ZW50U3RvcmUuaW5zdGFuY2VzKSB7XG4gICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF1cbiAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2luc3RhbmNlLmRlZklkXVxuICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF1cbiAgICBsZXQgb3JpZ1JhbmdlID0gaW5zdGFuY2UucmFuZ2VcblxuICAgIGxldCBub3JtYWxSYW5nZSA9ICghZGVmLmFsbERheSAmJiBuZXh0RGF5VGhyZXNob2xkKSA/XG4gICAgICBjb21wdXRlVmlzaWJsZURheVJhbmdlKG9yaWdSYW5nZSwgbmV4dERheVRocmVzaG9sZCkgOlxuICAgICAgb3JpZ1JhbmdlXG5cbiAgICBsZXQgc2xpY2VkUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMobm9ybWFsUmFuZ2UsIGZyYW1pbmdSYW5nZSlcblxuICAgIGlmIChzbGljZWRSYW5nZSkge1xuICAgICAgaWYgKHVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnKSB7XG4gICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICAgIGludmVyc2VCZ0J5R3JvdXBJZFtkZWYuZ3JvdXBJZF0ucHVzaChzbGljZWRSYW5nZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZlcnNlQmdCeURlZklkW2luc3RhbmNlLmRlZklkXS5wdXNoKHNsaWNlZFJhbmdlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHVpLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAodWkuZGlzcGxheSA9PT0gJ2JhY2tncm91bmQnID8gYmdSYW5nZXMgOiBmZ1JhbmdlcykucHVzaCh7XG4gICAgICAgICAgZGVmLFxuICAgICAgICAgIHVpLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgICBpc1N0YXJ0OiBub3JtYWxSYW5nZS5zdGFydCAmJiBub3JtYWxSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcbiAgICAgICAgICBpc0VuZDogbm9ybWFsUmFuZ2UuZW5kICYmIG5vcm1hbFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCksXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgZ3JvdXBJZCBpbiBpbnZlcnNlQmdCeUdyb3VwSWQpIHsgLy8gQlkgR1JPVVBcbiAgICBsZXQgcmFuZ2VzID0gaW52ZXJzZUJnQnlHcm91cElkW2dyb3VwSWRdXG4gICAgbGV0IGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKVxuXG4gICAgZm9yIChsZXQgaW52ZXJ0ZWRSYW5nZSBvZiBpbnZlcnRlZFJhbmdlcykge1xuICAgICAgbGV0IGRlZiA9IGRlZkJ5R3JvdXBJZFtncm91cElkXVxuICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXVxuXG4gICAgICBiZ1Jhbmdlcy5wdXNoKHtcbiAgICAgICAgZGVmLFxuICAgICAgICB1aSxcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIHJhbmdlOiBpbnZlcnRlZFJhbmdlLFxuICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBkZWZJZCBpbiBpbnZlcnNlQmdCeURlZklkKSB7XG4gICAgbGV0IHJhbmdlcyA9IGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdXG4gICAgbGV0IGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKVxuXG4gICAgZm9yIChsZXQgaW52ZXJ0ZWRSYW5nZSBvZiBpbnZlcnRlZFJhbmdlcykge1xuICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgIGRlZjogZXZlbnRTdG9yZS5kZWZzW2RlZklkXSxcbiAgICAgICAgdWk6IGV2ZW50VWlzW2RlZklkXSxcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIHJhbmdlOiBpbnZlcnRlZFJhbmdlLFxuICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBiZzogYmdSYW5nZXMsIGZnOiBmZ1JhbmdlcyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNCZ1JlbmRlcmluZyhkZWY6IEV2ZW50RGVmKSB7XG4gIHJldHVybiBkZWYudWkuZGlzcGxheSA9PT0gJ2JhY2tncm91bmQnIHx8IGRlZi51aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0RWxTZWcoZWw6IEhUTUxFbGVtZW50LCBzZWc6IFNlZykge1xuICAoZWwgYXMgYW55KS5mY1NlZyA9IHNlZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RWxTZWcoZWw6IEhUTUxFbGVtZW50KTogU2VnIHwgbnVsbCB7XG4gIHJldHVybiAoZWwgYXMgYW55KS5mY1NlZyB8fFxuICAgIChlbC5wYXJlbnROb2RlIGFzIGFueSkuZmNTZWcgfHwgLy8gZm9yIHRoZSBoYXJuZXNzXG4gICAgbnVsbFxufVxuXG4vLyBldmVudCB1aSBjb21wdXRhdGlvblxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZUV2ZW50VWlzKGV2ZW50RGVmczogRXZlbnREZWZIYXNoLCBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoKSB7XG4gIHJldHVybiBtYXBIYXNoKGV2ZW50RGVmcywgKGV2ZW50RGVmOiBFdmVudERlZikgPT4gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlRXZlbnRVaShldmVudERlZjogRXZlbnREZWYsIGV2ZW50VWlCYXNlczogRXZlbnRVaUhhc2gpIHtcbiAgbGV0IHVpcyA9IFtdXG5cbiAgaWYgKGV2ZW50VWlCYXNlc1snJ10pIHtcbiAgICB1aXMucHVzaChldmVudFVpQmFzZXNbJyddKVxuICB9XG5cbiAgaWYgKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pIHtcbiAgICB1aXMucHVzaChldmVudFVpQmFzZXNbZXZlbnREZWYuZGVmSWRdKVxuICB9XG5cbiAgdWlzLnB1c2goZXZlbnREZWYudWkpXG5cbiAgcmV0dXJuIGNvbWJpbmVFdmVudFVpcyh1aXMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb3J0RXZlbnRTZWdzKHNlZ3MsIGV2ZW50T3JkZXJTcGVjczogT3JkZXJTcGVjPEV2ZW50QXBpPltdKTogU2VnW10ge1xuICBsZXQgb2JqcyA9IHNlZ3MubWFwKGJ1aWxkU2VnQ29tcGFyZU9iailcblxuICBvYmpzLnNvcnQoKG9iajAsIG9iajEpID0+IGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZXZlbnRPcmRlclNwZWNzKSlcblxuICByZXR1cm4gb2Jqcy5tYXAoKGMpID0+IGMuX3NlZylcbn1cblxuLy8gcmV0dXJucyBhIG9iamVjdCB3aXRoIGFsbCBwcmltaXRpdmUgcHJvcHMgdGhhdCBjYW4gYmUgY29tcGFyZWRcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlZ0NvbXBhcmVPYmooc2VnOiBTZWcpIHtcbiAgbGV0IHsgZXZlbnRSYW5nZSB9ID0gc2VnXG4gIGxldCBldmVudERlZiA9IGV2ZW50UmFuZ2UuZGVmXG4gIGxldCByYW5nZSA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UgPyBldmVudFJhbmdlLmluc3RhbmNlLnJhbmdlIDogZXZlbnRSYW5nZS5yYW5nZVxuICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydCA/IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA6IDAgLy8gVE9ETzogYmV0dGVyIHN1cHBvcnQgZm9yIG9wZW4tcmFuZ2UgZXZlbnRzXG4gIGxldCBlbmQgPSByYW5nZS5lbmQgPyByYW5nZS5lbmQudmFsdWVPZigpIDogMCAvLyBcIlxuXG4gIHJldHVybiB7XG4gICAgLi4uZXZlbnREZWYuZXh0ZW5kZWRQcm9wcyxcbiAgICAuLi5ldmVudERlZixcbiAgICBpZDogZXZlbnREZWYucHVibGljSWQsXG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIGR1cmF0aW9uOiBlbmQgLSBzdGFydCxcbiAgICBhbGxEYXk6IE51bWJlcihldmVudERlZi5hbGxEYXkpLFxuICAgIF9zZWc6IHNlZywgLy8gZm9yIGxhdGVyIHJldHJpZXZhbFxuICB9XG59XG5cbi8vIG90aGVyIHN0dWZmXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRDb250ZW50QXJnIHsgLy8gZm9yICpDb250ZW50IGhhbmRsZXJzXG4gIGV2ZW50OiBFdmVudEFwaVxuICB0aW1lVGV4dDogc3RyaW5nXG4gIGJhY2tncm91bmRDb2xvcjogc3RyaW5nIC8vIFRPRE86IGFkZCBvdGhlciBFdmVudFVpIHByb3BzP1xuICBib3JkZXJDb2xvcjogc3RyaW5nIC8vXG4gIHRleHRDb2xvcjogc3RyaW5nIC8vXG4gIGlzRHJhZ2dhYmxlOiBib29sZWFuXG4gIGlzU3RhcnRSZXNpemFibGU6IGJvb2xlYW5cbiAgaXNFbmRSZXNpemFibGU6IGJvb2xlYW5cbiAgaXNNaXJyb3I6IGJvb2xlYW5cbiAgaXNTdGFydDogYm9vbGVhblxuICBpc0VuZDogYm9vbGVhblxuICBpc1Bhc3Q6IGJvb2xlYW5cbiAgaXNGdXR1cmU6IGJvb2xlYW5cbiAgaXNUb2RheTogYm9vbGVhblxuICBpc1NlbGVjdGVkOiBib29sZWFuXG4gIGlzRHJhZ2dpbmc6IGJvb2xlYW5cbiAgaXNSZXNpemluZzogYm9vbGVhblxuICB2aWV3OiBWaWV3QXBpIC8vIHNwZWNpZmljYWxseSBmb3IgdGhlIEFQSVxufVxuXG5leHBvcnQgdHlwZSBFdmVudE1vdW50QXJnID0gTW91bnRBcmc8RXZlbnRDb250ZW50QXJnPlxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVNlZ0RyYWdnYWJsZShzZWc6IFNlZywgY29udGV4dDogVmlld0NvbnRleHQpIHtcbiAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IGNvbnRleHRcbiAgbGV0IHRyYW5zZm9ybWVycyA9IHBsdWdpbkhvb2tzLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzXG4gIGxldCB7IGRlZiwgdWkgfSA9IHNlZy5ldmVudFJhbmdlXG4gIGxldCB2YWwgPSB1aS5zdGFydEVkaXRhYmxlXG5cbiAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XG4gICAgdmFsID0gdHJhbnNmb3JtZXIodmFsLCBkZWYsIHVpLCBjb250ZXh0KVxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZzogU2VnLCBjb250ZXh0OiBWaWV3Q29udGV4dCkge1xuICByZXR1cm4gc2VnLmlzU3RhcnQgJiYgc2VnLmV2ZW50UmFuZ2UudWkuZHVyYXRpb25FZGl0YWJsZSAmJiBjb250ZXh0Lm9wdGlvbnMuZXZlbnRSZXNpemFibGVGcm9tU3RhcnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnOiBTZWcsIGNvbnRleHQ6IFZpZXdDb250ZXh0KSB7XG4gIHJldHVybiBzZWcuaXNFbmQgJiYgc2VnLmV2ZW50UmFuZ2UudWkuZHVyYXRpb25FZGl0YWJsZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTZWdUaW1lVGV4dChcbiAgc2VnOiBTZWcsXG4gIHRpbWVGb3JtYXQ6IERhdGVGb3JtYXR0ZXIsXG4gIGNvbnRleHQ6IFZpZXdDb250ZXh0LFxuICBkZWZhdWx0RGlzcGxheUV2ZW50VGltZT86IGJvb2xlYW4sIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgZGVmYXVsdERpc3BsYXlFdmVudEVuZD86IGJvb2xlYW4sIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgc3RhcnRPdmVycmlkZT86IERhdGVNYXJrZXIsXG4gIGVuZE92ZXJyaWRlPzogRGF0ZU1hcmtlcixcbikge1xuICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0XG4gIGxldCB7IGRpc3BsYXlFdmVudFRpbWUsIGRpc3BsYXlFdmVudEVuZCB9ID0gb3B0aW9uc1xuICBsZXQgZXZlbnREZWYgPSBzZWcuZXZlbnRSYW5nZS5kZWZcbiAgbGV0IGV2ZW50SW5zdGFuY2UgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZVxuXG4gIGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHsgZGlzcGxheUV2ZW50VGltZSA9IGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lICE9PSBmYWxzZSB9XG4gIGlmIChkaXNwbGF5RXZlbnRFbmQgPT0gbnVsbCkgeyBkaXNwbGF5RXZlbnRFbmQgPSBkZWZhdWx0RGlzcGxheUV2ZW50RW5kICE9PSBmYWxzZSB9XG5cbiAgbGV0IHdob2xlRXZlbnRTdGFydCA9IGV2ZW50SW5zdGFuY2UucmFuZ2Uuc3RhcnRcbiAgbGV0IHdob2xlRXZlbnRFbmQgPSBldmVudEluc3RhbmNlLnJhbmdlLmVuZFxuICBsZXQgc2VnU3RhcnQgPSBzdGFydE92ZXJyaWRlIHx8IHNlZy5zdGFydCB8fCBzZWcuZXZlbnRSYW5nZS5yYW5nZS5zdGFydFxuICBsZXQgc2VnRW5kID0gZW5kT3ZlcnJpZGUgfHwgc2VnLmVuZCB8fCBzZWcuZXZlbnRSYW5nZS5yYW5nZS5lbmRcbiAgbGV0IGlzU3RhcnREYXkgPSBzdGFydE9mRGF5KHdob2xlRXZlbnRTdGFydCkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KHNlZ1N0YXJ0KS52YWx1ZU9mKClcbiAgbGV0IGlzRW5kRGF5ID0gc3RhcnRPZkRheShhZGRNcyh3aG9sZUV2ZW50RW5kLCAtMSkpLnZhbHVlT2YoKSA9PT0gc3RhcnRPZkRheShhZGRNcyhzZWdFbmQsIC0xKSkudmFsdWVPZigpXG5cbiAgaWYgKGRpc3BsYXlFdmVudFRpbWUgJiYgIWV2ZW50RGVmLmFsbERheSAmJiAoaXNTdGFydERheSB8fCBpc0VuZERheSkpIHtcbiAgICBzZWdTdGFydCA9IGlzU3RhcnREYXkgPyB3aG9sZUV2ZW50U3RhcnQgOiBzZWdTdGFydFxuICAgIHNlZ0VuZCA9IGlzRW5kRGF5ID8gd2hvbGVFdmVudEVuZCA6IHNlZ0VuZFxuXG4gICAgaWYgKGRpc3BsYXlFdmVudEVuZCAmJiBldmVudERlZi5oYXNFbmQpIHtcbiAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHNlZ1N0YXJ0LCBzZWdFbmQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0T3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRTdGFydFR6bywgLy8gbm9vb29vb29vb29vb28sIGdpdmUgdHpvIGlmIHNhbWUgZGF0ZVxuICAgICAgICBmb3JjZWRFbmRUem86IGVuZE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KHNlZ1N0YXJ0LCB0aW1lRm9ybWF0LCB7XG4gICAgICBmb3JjZWRUem86IHN0YXJ0T3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRTdGFydFR6bywgLy8gbm9vb29vLCBzYW1lXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiAnJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VnTWV0YShzZWc6IFNlZywgdG9kYXlSYW5nZTogRGF0ZVJhbmdlLCBub3dEYXRlPzogRGF0ZU1hcmtlcikgeyAvLyBUT0RPOiBtYWtlIGFyZyBvcmRlciBjb25zaXN0ZW50IHdpdGggZGF0ZSB1dGlsXG4gIGxldCBzZWdSYW5nZSA9IHNlZy5ldmVudFJhbmdlLnJhbmdlXG5cbiAgcmV0dXJuIHtcbiAgICBpc1Bhc3Q6IHNlZ1JhbmdlLmVuZCA8IChub3dEYXRlIHx8IHRvZGF5UmFuZ2Uuc3RhcnQpLFxuICAgIGlzRnV0dXJlOiBzZWdSYW5nZS5zdGFydCA+PSAobm93RGF0ZSB8fCB0b2RheVJhbmdlLmVuZCksXG4gICAgaXNUb2RheTogdG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIHNlZ1JhbmdlLnN0YXJ0KSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRDbGFzc05hbWVzKHByb3BzOiBFdmVudENvbnRlbnRBcmcpIHsgLy8gd2VpcmQgdGhhdCB3ZSB1c2UgdGhpcyBpbnRlcmZhY2UsIGJ1dCBjb252ZW5pZW50XG4gIGxldCBjbGFzc05hbWVzOiBzdHJpbmdbXSA9IFsnZmMtZXZlbnQnXVxuXG4gIGlmIChwcm9wcy5pc01pcnJvcikge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtbWlycm9yJylcbiAgfVxuXG4gIGlmIChwcm9wcy5pc0RyYWdnYWJsZSkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZHJhZ2dhYmxlJylcbiAgfVxuXG4gIGlmIChwcm9wcy5pc1N0YXJ0UmVzaXphYmxlIHx8IHByb3BzLmlzRW5kUmVzaXphYmxlKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1yZXNpemFibGUnKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzRHJhZ2dpbmcpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnaW5nJylcbiAgfVxuXG4gIGlmIChwcm9wcy5pc1Jlc2l6aW5nKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1yZXNpemluZycpXG4gIH1cblxuICBpZiAocHJvcHMuaXNTZWxlY3RlZCkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtc2VsZWN0ZWQnKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzU3RhcnQpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXN0YXJ0JylcbiAgfVxuXG4gIGlmIChwcm9wcy5pc0VuZCkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZW5kJylcbiAgfVxuXG4gIGlmIChwcm9wcy5pc1Bhc3QpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXBhc3QnKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzVG9kYXkpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXRvZGF5JylcbiAgfVxuXG4gIGlmIChwcm9wcy5pc0Z1dHVyZSkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZnV0dXJlJylcbiAgfVxuXG4gIHJldHVybiBjbGFzc05hbWVzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV2ZW50UmFuZ2VLZXkoZXZlbnRSYW5nZTogRXZlbnRSZW5kZXJSYW5nZSkge1xuICByZXR1cm4gZXZlbnRSYW5nZS5pbnN0YW5jZVxuICAgID8gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXG4gICAgOiBgJHtldmVudFJhbmdlLmRlZi5kZWZJZH06JHtldmVudFJhbmdlLnJhbmdlLnN0YXJ0LnRvSVNPU3RyaW5nKCl9YFxuICAvLyBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzIGRvbid0IGhhdmUgc3BlY2lmaWMgaW5zdGFuY2VzLiBUT0RPOiBiZXR0ZXIgc29sdXRpb25cbn1cbiIsImltcG9ydCB7IERhdGVSYW5nZSwgcmFuZ2VzRXF1YWwsIE9wZW5EYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBEYXRlSW5wdXQsIERhdGVFbnYgfSBmcm9tICcuLi9kYXRlbGliL2VudidcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IGNyZWF0ZUV2ZW50SW5zdGFuY2UgfSBmcm9tICcuL2V2ZW50LWluc3RhbmNlJ1xuaW1wb3J0IHsgcGFyc2VFdmVudERlZiwgcmVmaW5lRXZlbnREZWYgfSBmcm9tICcuL2V2ZW50LXBhcnNlJ1xuaW1wb3J0IHsgRXZlbnRSZW5kZXJSYW5nZSwgY29tcGlsZUV2ZW50VWkgfSBmcm9tICcuLi9jb21wb25lbnQvZXZlbnQtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgRXZlbnRVaUhhc2ggfSBmcm9tICcuLi9jb21wb25lbnQvZXZlbnQtdWknXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyByZWZpbmVQcm9wcywgaWRlbnRpdHksIElkZW50aXR5IH0gZnJvbSAnLi4vb3B0aW9ucydcblxuLypcbkEgZGF0YS1zdHJ1Y3R1cmUgZm9yIGEgZGF0ZS1yYW5nZSB0aGF0IHdpbGwgYmUgdmlzdWFsbHkgZGlzcGxheWVkLlxuQ29udGFpbnMgb3RoZXIgbWV0YWRhdGEgbGlrZSBhbGxEYXksIGFuZCBhbnl0aGluZyBlbHNlIENvbXBvbmVudHMgbWlnaHQgbGlrZSB0byBzdG9yZS5cblxuVE9ETzogaW4gZnV0dXJlLCBwdXQgb3RoZXJQcm9wcyBpbiBvd24gb2JqZWN0LlxuKi9cblxuZXhwb3J0IGludGVyZmFjZSBPcGVuRGF0ZVNwYW5JbnB1dCB7XG4gIHN0YXJ0PzogRGF0ZUlucHV0XG4gIGVuZD86IERhdGVJbnB1dFxuICBhbGxEYXk/OiBib29sZWFuXG4gIFtvdGhlclByb3A6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVTcGFuSW5wdXQgZXh0ZW5kcyBPcGVuRGF0ZVNwYW5JbnB1dCB7XG4gIHN0YXJ0OiBEYXRlSW5wdXRcbiAgZW5kOiBEYXRlSW5wdXRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcGVuRGF0ZVNwYW4ge1xuICByYW5nZTogT3BlbkRhdGVSYW5nZVxuICBhbGxEYXk6IGJvb2xlYW5cbiAgW290aGVyUHJvcDogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVNwYW4gZXh0ZW5kcyBPcGVuRGF0ZVNwYW4ge1xuICByYW5nZTogRGF0ZVJhbmdlXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmFuZ2VBcGkge1xuICBzdGFydDogRGF0ZVxuICBlbmQ6IERhdGVcbiAgc3RhcnRTdHI6IHN0cmluZ1xuICBlbmRTdHI6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVTcGFuQXBpIGV4dGVuZHMgUmFuZ2VBcGkge1xuICBhbGxEYXk6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSYW5nZUFwaVdpdGhUaW1lWm9uZSBleHRlbmRzIFJhbmdlQXBpIHtcbiAgdGltZVpvbmU6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVQb2ludEFwaSB7XG4gIGRhdGU6IERhdGVcbiAgZGF0ZVN0cjogc3RyaW5nXG4gIGFsbERheTogYm9vbGVhblxufVxuXG5jb25zdCBTVEFOREFSRF9QUk9QUyA9IHtcbiAgc3RhcnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERhdGVJbnB1dD4sXG4gIGVuZDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZUlucHV0PixcbiAgYWxsRGF5OiBCb29sZWFuLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEYXRlU3BhbihyYXc6IERhdGVTcGFuSW5wdXQsIGRhdGVFbnY6IERhdGVFbnYsIGRlZmF1bHREdXJhdGlvbj86IER1cmF0aW9uKTogRGF0ZVNwYW4gfCBudWxsIHtcbiAgbGV0IHNwYW4gPSBwYXJzZU9wZW5EYXRlU3BhbihyYXcsIGRhdGVFbnYpXG4gIGxldCB7IHJhbmdlIH0gPSBzcGFuXG5cbiAgaWYgKCFyYW5nZS5zdGFydCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAoIXJhbmdlLmVuZCkge1xuICAgIGlmIChkZWZhdWx0RHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmFuZ2UuZW5kID0gZGF0ZUVudi5hZGQocmFuZ2Uuc3RhcnQsIGRlZmF1bHREdXJhdGlvbilcbiAgfVxuXG4gIHJldHVybiBzcGFuIGFzIERhdGVTcGFuXG59XG5cbi8qXG5UT0RPOiBzb21laG93IGNvbWJpbmUgd2l0aCBwYXJzZVJhbmdlP1xuV2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgc3RhcnQvZW5kIHByb3BzIHdlcmUgcHJlc2VudCBidXQgcGFyc2VkIGludmFsaWRseS5cbiovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3OiBPcGVuRGF0ZVNwYW5JbnB1dCwgZGF0ZUVudjogRGF0ZUVudik6IE9wZW5EYXRlU3BhbiB8IG51bGwge1xuICBsZXQgeyByZWZpbmVkOiBzdGFuZGFyZFByb3BzLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3LCBTVEFOREFSRF9QUk9QUylcbiAgbGV0IHN0YXJ0TWV0YSA9IHN0YW5kYXJkUHJvcHMuc3RhcnQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5zdGFydCkgOiBudWxsXG4gIGxldCBlbmRNZXRhID0gc3RhbmRhcmRQcm9wcy5lbmQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5lbmQpIDogbnVsbFxuICBsZXQgeyBhbGxEYXkgfSA9IHN0YW5kYXJkUHJvcHNcblxuICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICBhbGxEYXkgPSAoc3RhcnRNZXRhICYmIHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByYW5nZToge1xuICAgICAgc3RhcnQ6IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgZW5kOiBlbmRNZXRhID8gZW5kTWV0YS5tYXJrZXIgOiBudWxsLFxuICAgIH0sXG4gICAgYWxsRGF5LFxuICAgIC4uLmV4dHJhLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGVTcGFuc0VxdWFsKHNwYW4wOiBEYXRlU3Bhbiwgc3BhbjE6IERhdGVTcGFuKTogYm9vbGVhbiB7XG4gIHJldHVybiByYW5nZXNFcXVhbChzcGFuMC5yYW5nZSwgc3BhbjEucmFuZ2UpICYmXG4gICAgc3BhbjAuYWxsRGF5ID09PSBzcGFuMS5hbGxEYXkgJiZcbiAgICBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSlcbn1cblxuLy8gdGhlIE5PTi1EQVRFLVJFTEFURUQgcHJvcHNcbmZ1bmN0aW9uIGlzU3BhblByb3BzRXF1YWwoc3BhbjA6IERhdGVTcGFuLCBzcGFuMTogRGF0ZVNwYW4pOiBib29sZWFuIHtcbiAgZm9yIChsZXQgcHJvcE5hbWUgaW4gc3BhbjEpIHtcbiAgICBpZiAocHJvcE5hbWUgIT09ICdyYW5nZScgJiYgcHJvcE5hbWUgIT09ICdhbGxEYXknKSB7XG4gICAgICBpZiAoc3BhbjBbcHJvcE5hbWVdICE9PSBzcGFuMVtwcm9wTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYXJlIHRoZXJlIGFueSBwcm9wcyB0aGF0IHNwYW4wIGhhcyB0aGF0IHNwYW4xIERPRVNOJ1QgaGF2ZT9cbiAgLy8gYm90aCBoYXZlIHJhbmdlL2FsbERheSwgc28gbm8gbmVlZCB0byBzcGVjaWFsLWNhc2UuXG4gIGZvciAobGV0IHByb3BOYW1lIGluIHNwYW4wKSB7XG4gICAgaWYgKCEocHJvcE5hbWUgaW4gc3BhbjEpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaShzcGFuOiBEYXRlU3BhbiwgZGF0ZUVudjogRGF0ZUVudik6IERhdGVTcGFuQXBpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5idWlsZFJhbmdlQXBpKHNwYW4ucmFuZ2UsIGRhdGVFbnYsIHNwYW4uYWxsRGF5KSxcbiAgICBhbGxEYXk6IHNwYW4uYWxsRGF5LFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKHJhbmdlOiBEYXRlUmFuZ2UsIGRhdGVFbnY6IERhdGVFbnYsIG9taXRUaW1lPzogYm9vbGVhbik6IFJhbmdlQXBpV2l0aFRpbWVab25lIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5idWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSksXG4gICAgdGltZVpvbmU6IGRhdGVFbnYudGltZVpvbmUsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkUmFuZ2VBcGkocmFuZ2U6IERhdGVSYW5nZSwgZGF0ZUVudjogRGF0ZUVudiwgb21pdFRpbWU/OiBib29sZWFuKTogUmFuZ2VBcGkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBkYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgZW5kOiBkYXRlRW52LnRvRGF0ZShyYW5nZS5lbmQpLFxuICAgIHN0YXJ0U3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCwgeyBvbWl0VGltZSB9KSxcbiAgICBlbmRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLmVuZCwgeyBvbWl0VGltZSB9KSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbjogRGF0ZVNwYW4sIGV2ZW50VWlCYXNlczogRXZlbnRVaUhhc2gsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IEV2ZW50UmVuZGVyUmFuZ2Uge1xuICBsZXQgcmVzID0gcmVmaW5lRXZlbnREZWYoeyBlZGl0YWJsZTogZmFsc2UgfSwgY29udGV4dClcbiAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYoXG4gICAgcmVzLnJlZmluZWQsXG4gICAgcmVzLmV4dHJhLFxuICAgICcnLCAvLyBzb3VyY2VJZFxuICAgIGRhdGVTcGFuLmFsbERheSxcbiAgICB0cnVlLCAvLyBoYXNFbmRcbiAgICBjb250ZXh0LFxuICApXG5cbiAgcmV0dXJuIHtcbiAgICBkZWYsXG4gICAgdWk6IGNvbXBpbGVFdmVudFVpKGRlZiwgZXZlbnRVaUJhc2VzKSxcbiAgICBpbnN0YW5jZTogY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIGRhdGVTcGFuLnJhbmdlKSxcbiAgICByYW5nZTogZGF0ZVNwYW4ucmFuZ2UsXG4gICAgaXNTdGFydDogdHJ1ZSxcbiAgICBpc0VuZDogdHJ1ZSxcbiAgfVxufVxuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IFBvaW50ZXJEcmFnRXZlbnQgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9wb2ludGVyJ1xuaW1wb3J0IHsgYnVpbGREYXRlU3BhbkFwaSwgRGF0ZVNwYW5BcGksIERhdGVQb2ludEFwaSwgRGF0ZVNwYW4gfSBmcm9tICcuL3N0cnVjdHMvZGF0ZS1zcGFuJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi9WaWV3QXBpJ1xuaW1wb3J0IHsgRGF0ZU1hcmtlciwgc3RhcnRPZkRheSB9IGZyb20gJy4vZGF0ZWxpYi9tYXJrZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZUNsaWNrQXBpIGV4dGVuZHMgRGF0ZVBvaW50QXBpIHtcbiAgZGF5RWw6IEhUTUxFbGVtZW50XG4gIGpzRXZlbnQ6IFVJRXZlbnRcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVTZWxlY3Rpb25BcGkgZXh0ZW5kcyBEYXRlU3BhbkFwaSB7XG4gIGpzRXZlbnQ6IFVJRXZlbnRcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgdHlwZSBEYXRlUG9pbnRUcmFuc2Zvcm0gPSAoZGF0ZVNwYW46IERhdGVTcGFuLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpID0+IGFueVxuZXhwb3J0IHR5cGUgRGF0ZVNwYW5UcmFuc2Zvcm0gPSAoZGF0ZVNwYW46IERhdGVTcGFuLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpID0+IGFueVxuXG5leHBvcnQgdHlwZSBDYWxlbmRhckludGVyYWN0aW9uID0geyBkZXN0cm95OiAoKSA9PiB2b2lkIH1cbmV4cG9ydCB0eXBlIENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyA9IHsgbmV3KGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IENhbGVuZGFySW50ZXJhY3Rpb24gfVxuXG5leHBvcnQgdHlwZSBPcHRpb25DaGFuZ2VIYW5kbGVyID0gKHByb3BWYWx1ZTogYW55LCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpID0+IHZvaWRcbmV4cG9ydCB0eXBlIE9wdGlvbkNoYW5nZUhhbmRsZXJNYXAgPSB7IFtwcm9wTmFtZTogc3RyaW5nXTogT3B0aW9uQ2hhbmdlSGFuZGxlciB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVNlbGVjdEFyZyBleHRlbmRzIERhdGVTcGFuQXBpIHtcbiAganNFdmVudDogTW91c2VFdmVudCB8IG51bGxcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uOiBEYXRlU3BhbiwgcGV2OiBQb2ludGVyRHJhZ0V2ZW50IHwgbnVsbCwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0ICYgeyB2aWV3QXBpPzogVmlld0FwaSB9KSB7XG4gIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdzZWxlY3QnLCB7XG4gICAgLi4uYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHNlbGVjdGlvbiwgY29udGV4dCksXG4gICAganNFdmVudDogcGV2ID8gcGV2Lm9yaWdFdmVudCBhcyBNb3VzZUV2ZW50IDogbnVsbCwgLy8gSXMgdGhpcyBhbHdheXMgYSBtb3VzZSBldmVudD8gU2VlICM0NjU1XG4gICAgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyxcbiAgfSBhcyBEYXRlU2VsZWN0QXJnKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVVbnNlbGVjdEFyZyB7XG4gIGpzRXZlbnQ6IE1vdXNlRXZlbnRcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJpZ2dlckRhdGVVbnNlbGVjdChwZXY6IFBvaW50ZXJEcmFnRXZlbnQgfCBudWxsLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQgJiB7IHZpZXdBcGk/OiBWaWV3QXBpIH0pIHtcbiAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xuICAgIGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLFxuICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXcsXG4gIH0gYXMgRGF0ZVVuc2VsZWN0QXJnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KGRhdGVTcGFuOiBEYXRlU3BhbiwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCBwcm9wcyA9IHt9IGFzIERhdGVTcGFuQXBpXG5cbiAgZm9yIChsZXQgdHJhbnNmb3JtIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVNwYW5UcmFuc2Zvcm1zKSB7XG4gICAgX19hc3NpZ24ocHJvcHMsIHRyYW5zZm9ybShkYXRlU3BhbiwgY29udGV4dCkpXG4gIH1cblxuICBfX2Fzc2lnbihwcm9wcywgYnVpbGREYXRlU3BhbkFwaShkYXRlU3BhbiwgY29udGV4dC5kYXRlRW52KSlcblxuICByZXR1cm4gcHJvcHNcbn1cblxuLy8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxuLy8gVE9ETzogcmVuYW1lIHRvIGNvbXB1dGVEZWZhdWx0RXZlbnRFbmRcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0RXZlbnRFbmQoYWxsRGF5OiBib29sZWFuLCBtYXJrZXI6IERhdGVNYXJrZXIsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IERhdGVNYXJrZXIge1xuICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0XG4gIGxldCBlbmQgPSBtYXJrZXJcblxuICBpZiAoYWxsRGF5KSB7XG4gICAgZW5kID0gc3RhcnRPZkRheShlbmQpXG4gICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKVxuICB9IGVsc2Uge1xuICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKVxuICB9XG5cbiAgcmV0dXJuIGVuZFxufVxuIiwiaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgRXZlbnRTdG9yZSwgY3JlYXRlRW1wdHlFdmVudFN0b3JlIH0gZnJvbSAnLi9ldmVudC1zdG9yZSdcbmltcG9ydCB7IEV2ZW50RGVmIH0gZnJvbSAnLi9ldmVudC1kZWYnXG5pbXBvcnQgeyBFdmVudEluc3RhbmNlIH0gZnJvbSAnLi9ldmVudC1pbnN0YW5jZSdcbmltcG9ydCB7IGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UgfSBmcm9tICcuLi91dGlsL2RhdGUnXG5pbXBvcnQgeyBzdGFydE9mRGF5IH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBFdmVudFVpSGFzaCwgRXZlbnRVaSB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC11aSdcbmltcG9ydCB7IGNvbXBpbGVFdmVudFVpcyB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBnZXREZWZhdWx0RXZlbnRFbmQgfSBmcm9tICcuLi9jYWxlbmRhci11dGlscydcblxuLypcbkEgZGF0YSBzdHJ1Y3R1cmUgZm9yIGhvdyB0byBtb2RpZnkgYW4gRXZlbnREZWYvRXZlbnRJbnN0YW5jZSB3aXRoaW4gYW4gRXZlbnRTdG9yZVxuKi9cblxuZXhwb3J0IGludGVyZmFjZSBFdmVudE11dGF0aW9uIHtcbiAgZGF0ZXNEZWx0YT86IER1cmF0aW9uIC8vIGJvZHkgc3RhcnQrZW5kIG1vdmluZyB0b2dldGhlci4gZm9yIGRyYWdnaW5nXG4gIHN0YXJ0RGVsdGE/OiBEdXJhdGlvbiAvLyBmb3IgcmVzaXppbmdcbiAgZW5kRGVsdGE/OiBEdXJhdGlvbiAvLyBmb3IgcmVzaXppbmdcbiAgc3RhbmRhcmRQcm9wcz86IGFueSAvLyBmb3IgdGhlIGRlZi4gc2hvdWxkIG5vdCBpbmNsdWRlIGV4dGVuZGVkUHJvcHNcbiAgZXh0ZW5kZWRQcm9wcz86IGFueSAvLyBmb3IgdGhlIGRlZlxufVxuXG4vLyBhcHBsaWVzIHRoZSBtdXRhdGlvbiB0byBBTEwgZGVmcy9pbnN0YW5jZXMgd2l0aGluIHRoZSBldmVudCBzdG9yZVxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUoXG4gIGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsXG4gIGV2ZW50Q29uZmlnQmFzZTogRXZlbnRVaUhhc2gsXG4gIG11dGF0aW9uOiBFdmVudE11dGF0aW9uLFxuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4pOiBFdmVudFN0b3JlIHtcbiAgbGV0IGV2ZW50Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50Q29uZmlnQmFzZSlcbiAgbGV0IGRlc3QgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKVxuXG4gIGZvciAobGV0IGRlZklkIGluIGV2ZW50U3RvcmUuZGVmcykge1xuICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdXG5cbiAgICBkZXN0LmRlZnNbZGVmSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZGVmLCBldmVudENvbmZpZ3NbZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dClcbiAgfVxuXG4gIGZvciAobGV0IGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXVxuICAgIGxldCBkZWYgPSBkZXN0LmRlZnNbaW5zdGFuY2UuZGVmSWRdIC8vIGltcG9ydGFudCB0byBncmFiIHRoZSBuZXdseSBtb2RpZmllZCBkZWZcblxuICAgIGRlc3QuaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShpbnN0YW5jZSwgZGVmLCBldmVudENvbmZpZ3NbaW5zdGFuY2UuZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dClcbiAgfVxuXG4gIHJldHVybiBkZXN0XG59XG5cbmV4cG9ydCB0eXBlIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyID0gKGV2ZW50RGVmOiBFdmVudERlZiwgbXV0YXRpb246IEV2ZW50TXV0YXRpb24sIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkgPT4gdm9pZFxuXG5mdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudERlZihldmVudERlZjogRXZlbnREZWYsIGV2ZW50Q29uZmlnOiBFdmVudFVpLCBtdXRhdGlvbjogRXZlbnRNdXRhdGlvbiwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KTogRXZlbnREZWYge1xuICBsZXQgc3RhbmRhcmRQcm9wcyA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgfHwge31cblxuICAvLyBpZiBoYXNFbmQgaGFzIG5vdCBiZWVuIHNwZWNpZmllZCwgZ3Vlc3MgYSBnb29kIHZhbHVlIGJhc2VkIG9uIGRlbHRhcy5cbiAgLy8gaWYgZHVyYXRpb24gd2lsbCBjaGFuZ2UsIHRoZXJlJ3Mgbm8gd2F5IHRoZSBkZWZhdWx0IGR1cmF0aW9uIHdpbGwgcGVyc2lzdCxcbiAgLy8gYW5kIHRodXMsIHdlIG5lZWQgdG8gbWFyayB0aGUgZXZlbnQgYXMgaGF2aW5nIGEgcmVhbCBlbmRcbiAgaWYgKFxuICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID09IG51bGwgJiZcbiAgICBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlICYmXG4gICAgKG11dGF0aW9uLnN0YXJ0RGVsdGEgfHwgbXV0YXRpb24uZW5kRGVsdGEpXG4gICkge1xuICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gdHJ1ZSAvLyBUT0RPOiBpcyB0aGlzIG11dGF0aW9uIG9rYXk/XG4gIH1cblxuICBsZXQgY29weTogRXZlbnREZWYgPSB7XG4gICAgLi4uZXZlbnREZWYsXG4gICAgLi4uc3RhbmRhcmRQcm9wcyxcbiAgICB1aTogeyAuLi5ldmVudERlZi51aSwgLi4uc3RhbmRhcmRQcm9wcy51aSB9LCAvLyB0aGUgb25seSBwcm9wIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgb3ZlcmxheVxuICB9XG5cbiAgaWYgKG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpIHtcbiAgICBjb3B5LmV4dGVuZGVkUHJvcHMgPSB7IC4uLmNvcHkuZXh0ZW5kZWRQcm9wcywgLi4ubXV0YXRpb24uZXh0ZW5kZWRQcm9wcyB9XG4gIH1cblxuICBmb3IgKGxldCBhcHBsaWVyIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzKSB7XG4gICAgYXBwbGllcihjb3B5LCBtdXRhdGlvbiwgY29udGV4dClcbiAgfVxuXG4gIGlmICghY29weS5oYXNFbmQgJiYgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbikge1xuICAgIGNvcHkuaGFzRW5kID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGNvcHlcbn1cblxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShcbiAgZXZlbnRJbnN0YW5jZTogRXZlbnRJbnN0YW5jZSxcbiAgZXZlbnREZWY6IEV2ZW50RGVmLCAvLyBtdXN0IGZpcnN0IGJlIG1vZGlmaWVkIGJ5IGFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmXG4gIGV2ZW50Q29uZmlnOiBFdmVudFVpLFxuICBtdXRhdGlvbjogRXZlbnRNdXRhdGlvbixcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuKTogRXZlbnRJbnN0YW5jZSB7XG4gIGxldCB7IGRhdGVFbnYgfSA9IGNvbnRleHRcbiAgbGV0IGZvcmNlQWxsRGF5ID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyAmJiBtdXRhdGlvbi5zdGFuZGFyZFByb3BzLmFsbERheSA9PT0gdHJ1ZVxuICBsZXQgY2xlYXJFbmQgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuaGFzRW5kID09PSBmYWxzZVxuICBsZXQgY29weSA9IHsgLi4uZXZlbnRJbnN0YW5jZSB9IGFzIEV2ZW50SW5zdGFuY2VcblxuICBpZiAoZm9yY2VBbGxEYXkpIHtcbiAgICBjb3B5LnJhbmdlID0gY29tcHV0ZUFsaWduZWREYXlSYW5nZShjb3B5LnJhbmdlKVxuICB9XG5cbiAgaWYgKG11dGF0aW9uLmRhdGVzRGVsdGEgJiYgZXZlbnRDb25maWcuc3RhcnRFZGl0YWJsZSkge1xuICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICBzdGFydDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5zdGFydCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXG4gICAgICBlbmQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2UuZW5kLCBtdXRhdGlvbi5kYXRlc0RlbHRhKSxcbiAgICB9XG4gIH1cblxuICBpZiAobXV0YXRpb24uc3RhcnREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XG4gICAgY29weS5yYW5nZSA9IHtcbiAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5zdGFydERlbHRhKSxcbiAgICAgIGVuZDogY29weS5yYW5nZS5lbmQsXG4gICAgfVxuICB9XG5cbiAgaWYgKG11dGF0aW9uLmVuZERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgc3RhcnQ6IGNvcHkucmFuZ2Uuc3RhcnQsXG4gICAgICBlbmQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2UuZW5kLCBtdXRhdGlvbi5lbmREZWx0YSksXG4gICAgfVxuICB9XG5cbiAgaWYgKGNsZWFyRW5kKSB7XG4gICAgY29weS5yYW5nZSA9IHtcbiAgICAgIHN0YXJ0OiBjb3B5LnJhbmdlLnN0YXJ0LFxuICAgICAgZW5kOiBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KSxcbiAgICB9XG4gIH1cblxuICAvLyBpbiBjYXNlIGV2ZW50IHdhcyBhbGwtZGF5IGJ1dCB0aGUgc3VwcGxpZWQgZGVsdGFzIHdlcmUgbm90XG4gIC8vIGJldHRlciB1dGlsIGZvciB0aGlzP1xuICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgY29weS5yYW5nZSA9IHtcbiAgICAgIHN0YXJ0OiBzdGFydE9mRGF5KGNvcHkucmFuZ2Uuc3RhcnQpLFxuICAgICAgZW5kOiBzdGFydE9mRGF5KGNvcHkucmFuZ2UuZW5kKSxcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgaW52YWxpZCBkdXJhdGlvbnNcbiAgaWYgKGNvcHkucmFuZ2UuZW5kIDwgY29weS5yYW5nZS5zdGFydCkge1xuICAgIGNvcHkucmFuZ2UuZW5kID0gZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dClcbiAgfVxuXG4gIHJldHVybiBjb3B5XG59XG4iLCJpbXBvcnQgeyBEYXRlRW52IH0gZnJvbSAnLi9kYXRlbGliL2VudidcbmltcG9ydCB7IENhbGVuZGFyRGF0YSB9IGZyb20gJy4vcmVkdWNlcnMvZGF0YS10eXBlcydcblxuLy8gbm8gcHVibGljIHR5cGVzIHlldC4gd2hlbiB0aGVyZSBhcmUsIGV4cG9ydCBmcm9tOlxuLy8gaW1wb3J0IHt9IGZyb20gJy4vYXBpLXR5cGUtZGVwcydcblxuZXhwb3J0IGNsYXNzIFZpZXdBcGkgeyAvLyBhbHdheXMgcmVwcmVzZW50cyB0aGUgY3VycmVudCB2aWV3LiBvdGhlcndpc2UsIGl0J2QgbmVlZCB0byBjaGFuZ2UgdmFsdWUgZXZlcnkgdGltZSBkYXRlIGNoYW5nZXNcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHR5cGU6IHN0cmluZyxcbiAgICBwcml2YXRlIGdldEN1cnJlbnREYXRhOiAoKSA9PiBDYWxlbmRhckRhdGEsXG4gICAgcHJpdmF0ZSBkYXRlRW52OiBEYXRlRW52LFxuICApIHtcbiAgfVxuXG4gIGdldCBjYWxlbmRhcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmNhbGVuZGFyQXBpXG4gIH1cblxuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3VGl0bGVcbiAgfVxuXG4gIGdldCBhY3RpdmVTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2Uuc3RhcnQpXG4gIH1cblxuICBnZXQgYWN0aXZlRW5kKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5lbmQpXG4gIH1cblxuICBnZXQgY3VycmVudFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQpXG4gIH1cblxuICBnZXQgY3VycmVudEVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLmVuZClcbiAgfVxuXG4gIGdldE9wdGlvbihuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLm9wdGlvbnNbbmFtZV0gLy8gYXJlIHRoZSB2aWV3LXNwZWNpZmljIG9wdGlvbnNcbiAgfVxufVxuIiwiaW1wb3J0IHsgRXZlbnRJbnB1dCwgRXZlbnRJbnB1dFRyYW5zZm9ybWVyIH0gZnJvbSAnLi9ldmVudC1wYXJzZSdcbmltcG9ydCB7IEV2ZW50U291cmNlRnVuYyB9IGZyb20gJy4uL2V2ZW50LXNvdXJjZXMvZnVuYy1ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBFdmVudFNvdXJjZSwgRXZlbnRTb3VyY2VTdWNjZXNzUmVzcG9uc2VIYW5kbGVyLCBFdmVudFNvdXJjZUVycm9yUmVzcG9uc2VIYW5kbGVyIH0gZnJvbSAnLi9ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBKU09OX0ZFRURfRVZFTlRfU09VUkNFX1JFRklORVJTIH0gZnJvbSAnLi4vZXZlbnQtc291cmNlcy9qc29uLWZlZWQtZXZlbnQtc291cmNlLXJlZmluZXJzJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgZ3VpZCB9IGZyb20gJy4uL3V0aWwvbWlzYydcbmltcG9ydCB7IEVWRU5UX1VJX1JFRklORVJTLCBjcmVhdGVFdmVudFVpLCBFdmVudFVpSW5wdXQsIEV2ZW50VWlSZWZpbmVkIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXVpJ1xuaW1wb3J0IHsgaWRlbnRpdHksIElkZW50aXR5LCBSYXdPcHRpb25zRnJvbVJlZmluZXJzLCByZWZpbmVQcm9wcywgUmVmaW5lZE9wdGlvbnNGcm9tUmVmaW5lcnMgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5jb25zdCBFVkVOVF9TT1VSQ0VfUkVGSU5FUlMgPSB7IC8vIGRvZXMgTk9UIGluY2x1ZGUgRVZFTlRfVUlfUkVGSU5FUlNcbiAgaWQ6IFN0cmluZyxcbiAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgdXJsOiBTdHJpbmcsXG4gIGZvcm1hdDogU3RyaW5nLFxuICBldmVudHM6IGlkZW50aXR5IGFzIElkZW50aXR5PEV2ZW50SW5wdXRbXSB8IEV2ZW50U291cmNlRnVuYz4sIC8vIGFycmF5IG9yIGZ1bmN0aW9uXG4gIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RXZlbnRJbnB1dFRyYW5zZm9ybWVyPixcblxuICAvLyBmb3IgYW55IG5ldHdvcmstcmVsYXRlZCBzb3VyY2VzXG4gIHN1Y2Nlc3M6IGlkZW50aXR5IGFzIElkZW50aXR5PEV2ZW50U291cmNlU3VjY2Vzc1Jlc3BvbnNlSGFuZGxlcj4sXG4gIGZhaWx1cmU6IGlkZW50aXR5IGFzIElkZW50aXR5PEV2ZW50U291cmNlRXJyb3JSZXNwb25zZUhhbmRsZXI+LFxufVxuXG50eXBlIEJ1aWx0SW5FdmVudFNvdXJjZVJlZmluZXJzID0gdHlwZW9mIEVWRU5UX1NPVVJDRV9SRUZJTkVSUyAmXG4gIHR5cGVvZiBKU09OX0ZFRURfRVZFTlRfU09VUkNFX1JFRklORVJTXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRTb3VyY2VSZWZpbmVycyBleHRlbmRzIEJ1aWx0SW5FdmVudFNvdXJjZVJlZmluZXJzIHtcbiAgLy8gZm9yIGV4dGVuZGluZ1xufVxuXG5leHBvcnQgdHlwZSBFdmVudFNvdXJjZUlucHV0T2JqZWN0ID1cbiAgRXZlbnRVaUlucHV0ICZcbiAgUmF3T3B0aW9uc0Zyb21SZWZpbmVyczxSZXF1aXJlZDxFdmVudFNvdXJjZVJlZmluZXJzPj4gLy8gUmVxdWlyZWQgaGFja1xuXG5leHBvcnQgdHlwZSBFdmVudFNvdXJjZUlucHV0ID1cbiAgRXZlbnRTb3VyY2VJbnB1dE9iamVjdCB8IC8vIG9iamVjdCBpbiBleHRlbmRlZCBmb3JtXG4gIEV2ZW50SW5wdXRbXSB8XG4gIEV2ZW50U291cmNlRnVuYyB8IC8vIGp1c3QgYSBmdW5jdGlvblxuICBzdHJpbmcgLy8gYSBVUkwgZm9yIGEgSlNPTiBmZWVkXG5cbmV4cG9ydCB0eXBlIEV2ZW50U291cmNlUmVmaW5lZCA9XG4gIEV2ZW50VWlSZWZpbmVkICZcbiAgUmVmaW5lZE9wdGlvbnNGcm9tUmVmaW5lcnM8UmVxdWlyZWQ8RXZlbnRTb3VyY2VSZWZpbmVycz4+IC8vIFJlcXVpcmVkIGhhY2tcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRXZlbnRTb3VyY2UoXG4gIHJhdzogRXZlbnRTb3VyY2VJbnB1dCxcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuICByZWZpbmVycyA9IGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KSxcbik6IEV2ZW50U291cmNlPGFueT4gfCBudWxsIHtcbiAgbGV0IHJhd09iajogRXZlbnRTb3VyY2VJbnB1dE9iamVjdFxuXG4gIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgIHJhd09iaiA9IHsgdXJsOiByYXcgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyYXcpKSB7XG4gICAgcmF3T2JqID0geyBldmVudHM6IHJhdyB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ29iamVjdCcgJiYgcmF3KSB7IC8vIG5vdCBudWxsXG4gICAgcmF3T2JqID0gcmF3XG4gIH1cblxuICBpZiAocmF3T2JqKSB7XG4gICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhd09iaiwgcmVmaW5lcnMpXG4gICAgbGV0IG1ldGFSZXMgPSBidWlsZEV2ZW50U291cmNlTWV0YShyZWZpbmVkLCBjb250ZXh0KVxuXG4gICAgaWYgKG1ldGFSZXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9yYXc6IHJhdyxcbiAgICAgICAgaXNGZXRjaGluZzogZmFsc2UsXG4gICAgICAgIGxhdGVzdEZldGNoSWQ6ICcnLFxuICAgICAgICBmZXRjaFJhbmdlOiBudWxsLFxuICAgICAgICBkZWZhdWx0QWxsRGF5OiByZWZpbmVkLmRlZmF1bHRBbGxEYXksXG4gICAgICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogcmVmaW5lZC5ldmVudERhdGFUcmFuc2Zvcm0sXG4gICAgICAgIHN1Y2Nlc3M6IHJlZmluZWQuc3VjY2VzcyxcbiAgICAgICAgZmFpbHVyZTogcmVmaW5lZC5mYWlsdXJlLFxuICAgICAgICBwdWJsaWNJZDogcmVmaW5lZC5pZCB8fCAnJyxcbiAgICAgICAgc291cmNlSWQ6IGd1aWQoKSxcbiAgICAgICAgc291cmNlRGVmSWQ6IG1ldGFSZXMuc291cmNlRGVmSWQsXG4gICAgICAgIG1ldGE6IG1ldGFSZXMubWV0YSxcbiAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IGV4dHJhLFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIHJldHVybiB7IC4uLkVWRU5UX1VJX1JFRklORVJTLCAuLi5FVkVOVF9TT1VSQ0VfUkVGSU5FUlMsIC4uLmNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VSZWZpbmVycyB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJhdzogRXZlbnRTb3VyY2VSZWZpbmVkLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgbGV0IGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmc1xuXG4gIGZvciAobGV0IGkgPSBkZWZzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7IC8vIGxhdGVyLWFkZGVkIHBsdWdpbnMgdGFrZSBwcmVjZWRlbmNlXG4gICAgbGV0IGRlZiA9IGRlZnNbaV1cbiAgICBsZXQgbWV0YSA9IGRlZi5wYXJzZU1ldGEocmF3KVxuXG4gICAgaWYgKG1ldGEpIHtcbiAgICAgIHJldHVybiB7IHNvdXJjZURlZklkOiBpLCBtZXRhIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwiaW1wb3J0IHsgRGF0ZUVudiwgRGF0ZUlucHV0IH0gZnJvbSAnLi4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcbmltcG9ydCB7IEJhc2VPcHRpb25zUmVmaW5lZCB9IGZyb20gJy4uL29wdGlvbnMnXG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VDdXJyZW50RGF0ZShjdXJyZW50RGF0ZTogRGF0ZU1hcmtlciwgYWN0aW9uOiBBY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgIHJldHVybiBhY3Rpb24uZGF0ZU1hcmtlclxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY3VycmVudERhdGVcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5pdGlhbERhdGUob3B0aW9uczogQmFzZU9wdGlvbnNSZWZpbmVkLCBkYXRlRW52OiBEYXRlRW52KSB7XG4gIGxldCBpbml0aWFsRGF0ZUlucHV0ID0gb3B0aW9ucy5pbml0aWFsRGF0ZVxuXG4gIC8vIGNvbXB1dGUgdGhlIGluaXRpYWwgYW1iaWctdGltZXpvbmUgZGF0ZVxuICBpZiAoaW5pdGlhbERhdGVJbnB1dCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKGluaXRpYWxEYXRlSW5wdXQpXG4gIH1cbiAgcmV0dXJuIGdldE5vdyhvcHRpb25zLm5vdywgZGF0ZUVudikgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb3cobm93SW5wdXQ6IERhdGVJbnB1dCB8ICgoKSA9PiBEYXRlSW5wdXQpLCBkYXRlRW52OiBEYXRlRW52KSB7XG4gIGlmICh0eXBlb2Ygbm93SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBub3dJbnB1dCA9IG5vd0lucHV0KClcbiAgfVxuXG4gIGlmIChub3dJbnB1dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTm93TWFya2VyKClcbiAgfVxuXG4gIHJldHVybiBkYXRlRW52LmNyZWF0ZU1hcmtlcihub3dJbnB1dClcbn1cbiIsImltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgY3JlYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi9kYXRlbGliL2Zvcm1hdHRpbmcnXG5pbXBvcnQgeyBjcmVhdGVEdXJhdGlvbiB9IGZyb20gJy4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IHBhcnNlRGF0ZVNwYW4gfSBmcm9tICcuL3N0cnVjdHMvZGF0ZS1zcGFuJ1xuaW1wb3J0IHsgcGFyc2VFdmVudFNvdXJjZSB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zb3VyY2UtcGFyc2UnXG5pbXBvcnQgeyBwYXJzZUV2ZW50IH0gZnJvbSAnLi9zdHJ1Y3RzL2V2ZW50LXBhcnNlJ1xuaW1wb3J0IHsgZXZlbnRUdXBsZVRvU3RvcmUgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBWaWV3U3BlYyB9IGZyb20gJy4vc3RydWN0cy92aWV3LXNwZWMnXG5pbXBvcnQgeyBQb2ludGVyRHJhZ0V2ZW50IH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvcG9pbnRlcidcbmltcG9ydCB7IGdldE5vdyB9IGZyb20gJy4vcmVkdWNlcnMvY3VycmVudC1kYXRlJ1xuaW1wb3J0IHsgdHJpZ2dlckRhdGVTZWxlY3QsIHRyaWdnZXJEYXRlVW5zZWxlY3QgfSBmcm9tICcuL2NhbGVuZGFyLXV0aWxzJ1xuaW1wb3J0IHsgaGFzaFZhbHVlc1RvQXJyYXkgfSBmcm9tICcuL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXRhTWFuYWdlciB9IGZyb20gJy4vcmVkdWNlcnMvQ2FsZW5kYXJEYXRhTWFuYWdlcidcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vcmVkdWNlcnMvQWN0aW9uJ1xuaW1wb3J0IHsgRXZlbnRTb3VyY2UgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc291cmNlJ1xuaW1wb3J0IHsgZXZlbnRBcGlUb1N0b3JlLCBidWlsZEV2ZW50QXBpcyB9IGZyb20gJy4vYXBpL0V2ZW50QXBpJ1xuXG4vLyBwdWJsaWNcbmltcG9ydCB7XG4gIENhbGVuZGFyT3B0aW9ucyxcbiAgQ2FsZW5kYXJMaXN0ZW5lcnMsXG4gIERhdGVJbnB1dCxcbiAgRHVyYXRpb25JbnB1dCxcbiAgRGF0ZVNwYW5JbnB1dCxcbiAgRGF0ZVJhbmdlSW5wdXQsXG4gIEV2ZW50U291cmNlSW5wdXQsXG4gIEV2ZW50SW5wdXQsXG4gIEV2ZW50U291cmNlQXBpLFxuICBFdmVudEFwaSxcbiAgVmlld0FwaSxcbn0gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xuXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJBcGkge1xuICBjdXJyZW50RGF0YU1hbmFnZXI/OiBDYWxlbmRhckRhdGFNYW5hZ2VyIC8vIHdpbGwgYmUgc2V0IGJ5IENhbGVuZGFyRGF0YU1hbmFnZXJcblxuICBnZXRDdXJyZW50RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIhLmdldEN1cnJlbnREYXRhKClcbiAgfVxuXG4gIGRpc3BhdGNoKGFjdGlvbjogQWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyIS5kaXNwYXRjaChhY3Rpb24pXG4gIH1cblxuICBnZXQgdmlldygpOiBWaWV3QXBpIHsgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3QXBpIH0gLy8gZm9yIHB1YmxpYyBBUElcblxuICBiYXRjaFJlbmRlcmluZyhjYWxsYmFjazogKCkgPT4gdm9pZCkgeyAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcbiAgICBjYWxsYmFjaygpXG4gIH1cblxuICB1cGRhdGVTaXplKCkgeyAvLyBwdWJsaWNcbiAgICB0aGlzLnRyaWdnZXIoJ19yZXNpemUnLCB0cnVlKVxuICB9XG5cbiAgLy8gT3B0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHNldE9wdGlvbjxPcHRpb25OYW1lIGV4dGVuZHMga2V5b2YgQ2FsZW5kYXJPcHRpb25zPihuYW1lOiBPcHRpb25OYW1lLCB2YWw6IENhbGVuZGFyT3B0aW9uc1tPcHRpb25OYW1lXSkge1xuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1NFVF9PUFRJT04nLFxuICAgICAgb3B0aW9uTmFtZTogbmFtZSxcbiAgICAgIHJhd09wdGlvblZhbHVlOiB2YWwsXG4gICAgfSlcbiAgfVxuXG4gIGdldE9wdGlvbjxPcHRpb25OYW1lIGV4dGVuZHMga2V5b2YgQ2FsZW5kYXJPcHRpb25zPihuYW1lOiBPcHRpb25OYW1lKTogQ2FsZW5kYXJPcHRpb25zW09wdGlvbk5hbWVdIHsgLy8gZ2V0dGVyLCB1c2VkIGV4dGVybmFsbHkuIFdURiBUU1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlciEuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0W25hbWVdXG4gIH1cblxuICBnZXRBdmFpbGFibGVMb2NhbGVDb2RlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRDdXJyZW50RGF0YSgpLmF2YWlsYWJsZVJhd0xvY2FsZXMpXG4gIH1cblxuICAvLyBUcmlnZ2VyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgb248TGlzdGVuZXJOYW1lIGV4dGVuZHMga2V5b2YgQ2FsZW5kYXJMaXN0ZW5lcnM+KGhhbmRsZXJOYW1lOiBMaXN0ZW5lck5hbWUsIGhhbmRsZXI6IENhbGVuZGFyTGlzdGVuZXJzW0xpc3RlbmVyTmFtZV0pIHtcbiAgICBsZXQgeyBjdXJyZW50RGF0YU1hbmFnZXIgfSA9IHRoaXNcblxuICAgIGlmIChjdXJyZW50RGF0YU1hbmFnZXIuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzW2hhbmRsZXJOYW1lXSkge1xuICAgICAgY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub24oaGFuZGxlck5hbWUsIGhhbmRsZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBsaXN0ZW5lciBuYW1lICcke2hhbmRsZXJOYW1lfSdgKVxuICAgIH1cbiAgfVxuXG4gIG9mZjxMaXN0ZW5lck5hbWUgZXh0ZW5kcyBrZXlvZiBDYWxlbmRhckxpc3RlbmVycz4oaGFuZGxlck5hbWU6IExpc3RlbmVyTmFtZSwgaGFuZGxlcjogQ2FsZW5kYXJMaXN0ZW5lcnNbTGlzdGVuZXJOYW1lXSkge1xuICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyIS5lbWl0dGVyLm9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcilcbiAgfVxuXG4gIC8vIG5vdCBtZWFudCBmb3IgcHVibGljIHVzZVxuICB0cmlnZ2VyPExpc3RlbmVyTmFtZSBleHRlbmRzIGtleW9mIENhbGVuZGFyTGlzdGVuZXJzPihoYW5kbGVyTmFtZTogTGlzdGVuZXJOYW1lLCAuLi5hcmdzOiBQYXJhbWV0ZXJzPENhbGVuZGFyTGlzdGVuZXJzW0xpc3RlbmVyTmFtZV0+KSB7XG4gICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIhLmVtaXR0ZXIudHJpZ2dlcihoYW5kbGVyTmFtZSwgLi4uYXJncylcbiAgfVxuXG4gIC8vIFZpZXdcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBjaGFuZ2VWaWV3KHZpZXdUeXBlOiBzdHJpbmcsIGRhdGVPclJhbmdlPzogRGF0ZVJhbmdlSW5wdXQgfCBEYXRlSW5wdXQpIHtcbiAgICB0aGlzLmJhdGNoUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgIHRoaXMudW5zZWxlY3QoKVxuXG4gICAgICBpZiAoZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgaWYgKChkYXRlT3JSYW5nZSBhcyBEYXRlUmFuZ2VJbnB1dCkuc3RhcnQgJiYgKGRhdGVPclJhbmdlIGFzIERhdGVSYW5nZUlucHV0KS5lbmQpIHsgLy8gYSByYW5nZVxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgdmlld1R5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgLy8gbm90IHZlcnkgZWZmaWNpZW50IHRvIGRvIHR3byBkaXNwYXRjaGVzXG4gICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICBvcHRpb25OYW1lOiAndmlzaWJsZVJhbmdlJyxcbiAgICAgICAgICAgIHJhd09wdGlvblZhbHVlOiBkYXRlT3JSYW5nZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IGRhdGVFbnYuY3JlYXRlTWFya2VyKGRhdGVPclJhbmdlIGFzIERhdGVJbnB1dCksXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBGb3JjZXMgbmF2aWdhdGlvbiB0byBhIHZpZXcgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICAvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cbiAgLy8gbmVlZHMgdG8gY2hhbmdlXG4gIHpvb21UbyhkYXRlTWFya2VyOiBEYXRlTWFya2VyLCB2aWV3VHlwZT86IHN0cmluZykge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuICAgIGxldCBzcGVjXG5cbiAgICB2aWV3VHlwZSA9IHZpZXdUeXBlIHx8ICdkYXknIC8vIGRheSBpcyBkZWZhdWx0IHpvb21cbiAgICBzcGVjID0gc3RhdGUudmlld1NwZWNzW3ZpZXdUeXBlXSB8fCB0aGlzLmdldFVuaXRWaWV3U3BlYyh2aWV3VHlwZSlcblxuICAgIHRoaXMudW5zZWxlY3QoKVxuXG4gICAgaWYgKHNwZWMpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgIHZpZXdUeXBlOiBzcGVjLnR5cGUsXG4gICAgICAgIGRhdGVNYXJrZXIsXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgZGF0ZU1hcmtlcixcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBkdXJhdGlvbiBzaW5ndWxhciB1bml0LCBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIsIGZpbmRzIGEgbWF0Y2hpbmcgdmlldyBzcGVjLlxuICAvLyBQcmVmZXJlbmNlIGlzIGdpdmVuIHRvIHZpZXdzIHRoYXQgaGF2ZSBjb3JyZXNwb25kaW5nIGJ1dHRvbnMuXG4gIHByaXZhdGUgZ2V0VW5pdFZpZXdTcGVjKHVuaXQ6IHN0cmluZyk6IFZpZXdTcGVjIHwgbnVsbCB7XG4gICAgbGV0IHsgdmlld1NwZWNzLCB0b29sYmFyQ29uZmlnIH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICBsZXQgdmlld1R5cGVzID0gW10uY29uY2F0KHRvb2xiYXJDb25maWcudmlld3NXaXRoQnV0dG9ucylcbiAgICBsZXQgaVxuICAgIGxldCBzcGVjXG5cbiAgICBmb3IgKGxldCB2aWV3VHlwZSBpbiB2aWV3U3BlY3MpIHtcbiAgICAgIHZpZXdUeXBlcy5wdXNoKHZpZXdUeXBlKVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB2aWV3VHlwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHNwZWMgPSB2aWV3U3BlY3Nbdmlld1R5cGVzW2ldXVxuICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgaWYgKHNwZWMuc2luZ2xlVW5pdCA9PT0gdW5pdCkge1xuICAgICAgICAgIHJldHVybiBzcGVjXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gQ3VycmVudCBEYXRlXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgcHJldigpIHtcbiAgICB0aGlzLnVuc2VsZWN0KClcbiAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1BSRVYnIH0pXG4gIH1cblxuICBuZXh0KCkge1xuICAgIHRoaXMudW5zZWxlY3QoKVxuICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnTkVYVCcgfSlcbiAgfVxuXG4gIHByZXZZZWFyKCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuICAgIHRoaXMudW5zZWxlY3QoKVxuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIC0xKSxcbiAgICB9KVxuICB9XG5cbiAgbmV4dFllYXIoKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICB0aGlzLnVuc2VsZWN0KClcbiAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmFkZFllYXJzKHN0YXRlLmN1cnJlbnREYXRlLCAxKSxcbiAgICB9KVxuICB9XG5cbiAgdG9kYXkoKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICB0aGlzLnVuc2VsZWN0KClcbiAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICBkYXRlTWFya2VyOiBnZXROb3coc3RhdGUuY2FsZW5kYXJPcHRpb25zLm5vdywgc3RhdGUuZGF0ZUVudiksXG4gICAgfSlcbiAgfVxuXG4gIGdvdG9EYXRlKHpvbmVkRGF0ZUlucHV0KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICB0aGlzLnVuc2VsZWN0KClcbiAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmNyZWF0ZU1hcmtlcih6b25lZERhdGVJbnB1dCksXG4gICAgfSlcbiAgfVxuXG4gIGluY3JlbWVudERhdGUoZGVsdGFJbnB1dCkgeyAvLyBpcyBwdWJsaWMgZmFjaW5nXG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG4gICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dClcblxuICAgIGlmIChkZWx0YSkgeyAvLyBlbHNlLCB3YXJuIGFib3V0IGludmFsaWQgaW5wdXQ/XG4gICAgICB0aGlzLnVuc2VsZWN0KClcbiAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmFkZChzdGF0ZS5jdXJyZW50RGF0ZSwgZGVsdGEpLFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBmb3IgZXh0ZXJuYWwgQVBJXG4gIGdldERhdGUoKTogRGF0ZSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG4gICAgcmV0dXJuIHN0YXRlLmRhdGVFbnYudG9EYXRlKHN0YXRlLmN1cnJlbnREYXRlKVxuICB9XG5cbiAgLy8gRGF0ZSBGb3JtYXR0aW5nIFV0aWxzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgZm9ybWF0RGF0ZShkOiBEYXRlSW5wdXQsIGZvcm1hdHRlcik6IHN0cmluZyB7XG4gICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoXG4gICAgICBkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSxcbiAgICAgIGNyZWF0ZUZvcm1hdHRlcihmb3JtYXR0ZXIpLFxuICAgIClcbiAgfVxuXG4gIC8vIGBzZXR0aW5nc2AgaXMgZm9yIGZvcm1hdHRlciBBTkQgaXNFbmRFeGNsdXNpdmVcbiAgZm9ybWF0UmFuZ2UoZDA6IERhdGVJbnB1dCwgZDE6IERhdGVJbnB1dCwgc2V0dGluZ3MpIHtcbiAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKClcblxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKFxuICAgICAgZGF0ZUVudi5jcmVhdGVNYXJrZXIoZDApLFxuICAgICAgZGF0ZUVudi5jcmVhdGVNYXJrZXIoZDEpLFxuICAgICAgY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzKSxcbiAgICAgIHNldHRpbmdzLFxuICAgIClcbiAgfVxuXG4gIGZvcm1hdElzbyhkOiBEYXRlSW5wdXQsIG9taXRUaW1lPzogYm9vbGVhbikge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuXG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0SXNvKGRhdGVFbnYuY3JlYXRlTWFya2VyKGQpLCB7IG9taXRUaW1lIH0pXG4gIH1cblxuICAvLyBEYXRlIFNlbGVjdGlvbiAvIEV2ZW50IFNlbGVjdGlvbiAvIERheUNsaWNrXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gdGhpcyBwdWJsaWMgbWV0aG9kIHJlY2VpdmVzIHN0YXJ0L2VuZCBkYXRlcyBpbiBhbnkgZm9ybWF0LCB3aXRoIGFueSB0aW1lem9uZVxuICAvLyBOT1RFOiBhcmdzIHdlcmUgY2hhbmdlZCBmcm9tIHYzXG4gIHNlbGVjdChkYXRlT3JPYmo6IERhdGVJbnB1dCB8IGFueSwgZW5kRGF0ZT86IERhdGVJbnB1dCkge1xuICAgIGxldCBzZWxlY3Rpb25JbnB1dDogRGF0ZVNwYW5JbnB1dFxuXG4gICAgaWYgKGVuZERhdGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGRhdGVPck9iai5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHNlbGVjdGlvbklucHV0ID0gZGF0ZU9yT2JqIGFzIERhdGVTcGFuSW5wdXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICBzdGFydDogZGF0ZU9yT2JqLFxuICAgICAgICBlbmQ6IGVuZERhdGUsXG4gICAgICB9IGFzIERhdGVTcGFuSW5wdXRcbiAgICB9XG5cbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICBsZXQgc2VsZWN0aW9uID0gcGFyc2VEYXRlU3BhbihcbiAgICAgIHNlbGVjdGlvbklucHV0LFxuICAgICAgc3RhdGUuZGF0ZUVudixcbiAgICAgIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KSwgLy8gVE9ETzogY2FjaGUgdGhpcz9cbiAgICApXG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7IC8vIHRocm93IHBhcnNlIGVycm9yIG90aGVyd2lzZT9cbiAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0RBVEVTJywgc2VsZWN0aW9uIH0pXG4gICAgICB0cmlnZ2VyRGF0ZVNlbGVjdChzZWxlY3Rpb24sIG51bGwsIHN0YXRlKVxuICAgIH1cbiAgfVxuXG4gIC8vIHB1YmxpYyBtZXRob2RcbiAgdW5zZWxlY3QocGV2PzogUG9pbnRlckRyYWdFdmVudCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuXG4gICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24pIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pXG4gICAgICB0cmlnZ2VyRGF0ZVVuc2VsZWN0KHBldiwgc3RhdGUpXG4gICAgfVxuICB9XG5cbiAgLy8gUHVibGljIEV2ZW50cyBBUElcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBhZGRFdmVudChldmVudElucHV0OiBFdmVudElucHV0LCBzb3VyY2VJbnB1dD86IEV2ZW50U291cmNlQXBpIHwgc3RyaW5nIHwgYm9vbGVhbik6IEV2ZW50QXBpIHwgbnVsbCB7XG4gICAgaWYgKGV2ZW50SW5wdXQgaW5zdGFuY2VvZiBFdmVudEFwaSkge1xuICAgICAgbGV0IGRlZiA9IGV2ZW50SW5wdXQuX2RlZlxuICAgICAgbGV0IGluc3RhbmNlID0gZXZlbnRJbnB1dC5faW5zdGFuY2VcbiAgICAgIGxldCBjdXJyZW50RGF0YSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuXG4gICAgICAvLyBub3QgYWxyZWFkeSBwcmVzZW50PyBkb24ndCB3YW50IHRvIGFkZCBhbiBvbGQgc25hcHNob3RcbiAgICAgIGlmICghY3VycmVudERhdGEuZXZlbnRTdG9yZS5kZWZzW2RlZi5kZWZJZF0pIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ0FERF9FVkVOVFMnLFxuICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHsgZGVmLCBpbnN0YW5jZSB9KSwgLy8gVE9ETzogYmV0dGVyIHV0aWwgZm9yIHR3byBhcmdzP1xuICAgICAgICB9KVxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudEFkZChldmVudElucHV0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnRJbnB1dFxuICAgIH1cblxuICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuICAgIGxldCBldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PlxuXG4gICAgaWYgKHNvdXJjZUlucHV0IGluc3RhbmNlb2YgRXZlbnRTb3VyY2VBcGkpIHtcbiAgICAgIGV2ZW50U291cmNlID0gc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZUlucHV0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGlmIChzb3VyY2VJbnB1dCkgeyAvLyB0cnVlLiBwYXJ0IG9mIHRoZSBmaXJzdCBldmVudCBzb3VyY2VcbiAgICAgICAgW2V2ZW50U291cmNlXSA9IGhhc2hWYWx1ZXNUb0FycmF5KHN0YXRlLmV2ZW50U291cmNlcylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNvdXJjZUlucHV0ICE9IG51bGwpIHsgLy8gYW4gSUQuIGFjY2VwdHMgYSBudW1iZXIgdG9vXG4gICAgICBsZXQgc291cmNlQXBpID0gdGhpcy5nZXRFdmVudFNvdXJjZUJ5SWQoc291cmNlSW5wdXQpIC8vIFRPRE86IHVzZSBhbiBpbnRlcm5hbCBmdW5jdGlvblxuXG4gICAgICBpZiAoIXNvdXJjZUFwaSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGFuIGV2ZW50IHNvdXJjZSB3aXRoIElEIFwiJHtzb3VyY2VJbnB1dH1cImApIC8vIFRPRE86IHRlc3RcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIGV2ZW50U291cmNlID0gc291cmNlQXBpLmludGVybmFsRXZlbnRTb3VyY2VcbiAgICB9XG5cbiAgICBsZXQgdHVwbGUgPSBwYXJzZUV2ZW50KGV2ZW50SW5wdXQsIGV2ZW50U291cmNlLCBzdGF0ZSwgZmFsc2UpXG5cbiAgICBpZiAodHVwbGUpIHtcbiAgICAgIGxldCBuZXdFdmVudEFwaSA9IG5ldyBFdmVudEFwaShcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHR1cGxlLmRlZixcbiAgICAgICAgdHVwbGUuZGVmLnJlY3VycmluZ0RlZiA/IG51bGwgOiB0dXBsZS5pbnN0YW5jZSxcbiAgICAgIClcbiAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlKSxcbiAgICAgIH0pXG4gICAgICB0aGlzLnRyaWdnZXJFdmVudEFkZChuZXdFdmVudEFwaSlcblxuICAgICAgcmV0dXJuIG5ld0V2ZW50QXBpXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHByaXZhdGUgdHJpZ2dlckV2ZW50QWRkKGV2ZW50QXBpOiBFdmVudEFwaSkge1xuICAgIGxldCB7IGVtaXR0ZXIgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuXG4gICAgZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIHtcbiAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgcmV2ZXJ0OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICBldmVudFN0b3JlOiBldmVudEFwaVRvU3RvcmUoZXZlbnRBcGkpLFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgLy8gVE9ETzogb3B0aW1pemVcbiAgZ2V0RXZlbnRCeUlkKGlkOiBzdHJpbmcpOiBFdmVudEFwaSB8IG51bGwge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gc3RhdGUuZXZlbnRTdG9yZVxuICAgIGlkID0gU3RyaW5nKGlkKVxuXG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgbGV0IGRlZiA9IGRlZnNbZGVmSWRdXG5cbiAgICAgIGlmIChkZWYucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEFwaShzdGF0ZSwgZGVmLCBudWxsKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF1cblxuICAgICAgICAgIGlmIChpbnN0YW5jZS5kZWZJZCA9PT0gZGVmLmRlZklkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50QXBpKHN0YXRlLCBkZWYsIGluc3RhbmNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBnZXRFdmVudHMoKTogRXZlbnRBcGlbXSB7XG4gICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICByZXR1cm4gYnVpbGRFdmVudEFwaXMoY3VycmVudERhdGEuZXZlbnRTdG9yZSwgY3VycmVudERhdGEpXG4gIH1cblxuICByZW1vdmVBbGxFdmVudHMoKSB7XG4gICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdSRU1PVkVfQUxMX0VWRU5UUycgfSlcbiAgfVxuXG4gIC8vIFB1YmxpYyBFdmVudCBTb3VyY2VzIEFQSVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGdldEV2ZW50U291cmNlcygpOiBFdmVudFNvdXJjZUFwaVtdIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlc1xuICAgIGxldCBzb3VyY2VBcGlzOiBFdmVudFNvdXJjZUFwaVtdID0gW11cblxuICAgIGZvciAobGV0IGludGVybmFsSWQgaW4gc291cmNlSGFzaCkge1xuICAgICAgc291cmNlQXBpcy5wdXNoKG5ldyBFdmVudFNvdXJjZUFwaShzdGF0ZSwgc291cmNlSGFzaFtpbnRlcm5hbElkXSkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZUFwaXNcbiAgfVxuXG4gIGdldEV2ZW50U291cmNlQnlJZChpZDogc3RyaW5nKTogRXZlbnRTb3VyY2VBcGkgfCBudWxsIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlc1xuICAgIGlkID0gU3RyaW5nKGlkKVxuXG4gICAgZm9yIChsZXQgc291cmNlSWQgaW4gc291cmNlSGFzaCkge1xuICAgICAgaWYgKHNvdXJjZUhhc2hbc291cmNlSWRdLnB1YmxpY0lkID09PSBpZCkge1xuICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlQXBpKHN0YXRlLCBzb3VyY2VIYXNoW3NvdXJjZUlkXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgYWRkRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQ6IEV2ZW50U291cmNlSW5wdXQpOiBFdmVudFNvdXJjZUFwaSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUFwaSkge1xuICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICBpZiAoIXN0YXRlLmV2ZW50U291cmNlc1tzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLFxuICAgICAgICAgIHNvdXJjZXM6IFtzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlXSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNvdXJjZUlucHV0XG4gICAgfVxuXG4gICAgbGV0IGV2ZW50U291cmNlID0gcGFyc2VFdmVudFNvdXJjZShzb3VyY2VJbnB1dCwgc3RhdGUpXG5cbiAgICBpZiAoZXZlbnRTb3VyY2UpIHsgLy8gVE9ETzogZXJyb3Igb3RoZXJ3aXNlP1xuICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdBRERfRVZFTlRfU09VUkNFUycsIHNvdXJjZXM6IFtldmVudFNvdXJjZV0gfSlcblxuICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUFwaShzdGF0ZSwgZXZlbnRTb3VyY2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJlbW92ZUFsbEV2ZW50U291cmNlcygpIHtcbiAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUycgfSlcbiAgfVxuXG4gIHJlZmV0Y2hFdmVudHMoKSB7XG4gICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJywgaXNSZWZldGNoOiB0cnVlIH0pXG4gIH1cblxuICAvLyBTY3JvbGxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBzY3JvbGxUb1RpbWUodGltZUlucHV0OiBEdXJhdGlvbklucHV0KSB7XG4gICAgbGV0IHRpbWUgPSBjcmVhdGVEdXJhdGlvbih0aW1lSW5wdXQpXG5cbiAgICBpZiAodGltZSkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdfc2Nyb2xsUmVxdWVzdCcsIHsgdGltZSB9KVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IEV2ZW50RGVmIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1kZWYnXG5pbXBvcnQgeyBFVkVOVF9OT05fREFURV9SRUZJTkVSUywgRVZFTlRfREFURV9SRUZJTkVSUyB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtcGFyc2UnXG5pbXBvcnQgeyBFdmVudEluc3RhbmNlIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1pbnN0YW5jZSdcbmltcG9ydCB7IEVWRU5UX1VJX1JFRklORVJTLCBFdmVudFVpSGFzaCB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC11aSdcbmltcG9ydCB7IEV2ZW50TXV0YXRpb24sIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LW11dGF0aW9uJ1xuaW1wb3J0IHsgZGlmZkRhdGVzLCBjb21wdXRlQWxpZ25lZERheVJhbmdlIH0gZnJvbSAnLi4vdXRpbC9kYXRlJ1xuaW1wb3J0IHsgY3JlYXRlRHVyYXRpb24sIGR1cmF0aW9uc0VxdWFsIH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IGNyZWF0ZUZvcm1hdHRlciB9IGZyb20gJy4uL2RhdGVsaWIvZm9ybWF0dGluZydcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IGdldFJlbGV2YW50RXZlbnRzLCBFdmVudFN0b3JlIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zdG9yZSdcbmltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG4vLyBwdWJsaWNcbmltcG9ydCB7XG4gIERhdGVJbnB1dCxcbiAgRHVyYXRpb25JbnB1dCxcbiAgRm9ybWF0dGVySW5wdXQsXG4gIEV2ZW50U291cmNlQXBpLFxufSBmcm9tICcuLi9hcGktdHlwZS1kZXBzJ1xuXG5leHBvcnQgY2xhc3MgRXZlbnRBcGkge1xuICBfY29udGV4dDogQ2FsZW5kYXJDb250ZXh0XG4gIF9kZWY6IEV2ZW50RGVmXG4gIF9pbnN0YW5jZTogRXZlbnRJbnN0YW5jZSB8IG51bGxcbiAgLy8gaW5zdGFuY2Ugd2lsbCBiZSBudWxsIGlmIGV4cHJlc3NpbmcgYSByZWN1cnJpbmcgZXZlbnQgdGhhdCBoYXMgbm8gY3VycmVudCBpbnN0YW5jZXMsXG4gIC8vIE9SIGlmIHRyeWluZyB0byB2YWxpZGF0ZSBhbiBpbmNvbWluZyBleHRlcm5hbCBldmVudCB0aGF0IGhhcyBubyBkYXRlcyBhc3NpZ25lZFxuXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCwgZGVmOiBFdmVudERlZiwgaW5zdGFuY2U/OiBFdmVudEluc3RhbmNlKSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHRcbiAgICB0aGlzLl9kZWYgPSBkZWZcbiAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGxcbiAgfVxuXG4gIC8qXG4gIFRPRE86IG1ha2UgZXZlbnQgc3RydWN0IG1vcmUgcmVzcG9uc2libGUgZm9yIHRoaXNcbiAgKi9cbiAgc2V0UHJvcChuYW1lOiBzdHJpbmcsIHZhbDogYW55KSB7XG4gICAgaWYgKG5hbWUgaW4gRVZFTlRfREFURV9SRUZJTkVSUykge1xuICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc2V0IGRhdGUtcmVsYXRlZCBwcm9wIFxcJ25hbWVcXCcuIFVzZSBvbmUgb2YgdGhlIGRhdGUtcmVsYXRlZCBtZXRob2RzIGluc3RlYWQuJylcbiAgICAvLyBUT0RPOiBtYWtlIHByb3BlciBhbGlhc2luZyBzeXN0ZW0/XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnaWQnKSB7XG4gICAgICB2YWwgPSBFVkVOVF9OT05fREFURV9SRUZJTkVSU1tuYW1lXSh2YWwpXG5cbiAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgc3RhbmRhcmRQcm9wczogeyBwdWJsaWNJZDogdmFsIH0sIC8vIGhhcmRjb2RlZCBpbnRlcm5hbCBuYW1lXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAobmFtZSBpbiBFVkVOVF9OT05fREFURV9SRUZJTkVSUykge1xuICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKVxuXG4gICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgIHN0YW5kYXJkUHJvcHM6IHsgW25hbWVdOiB2YWwgfSxcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChuYW1lIGluIEVWRU5UX1VJX1JFRklORVJTKSB7XG4gICAgICBsZXQgdWkgPSBFVkVOVF9VSV9SRUZJTkVSU1tuYW1lXSh2YWwpXG5cbiAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XG4gICAgICAgIHVpID0geyBiYWNrZ3JvdW5kQ29sb3I6IHZhbCwgYm9yZGVyQ29sb3I6IHZhbCB9XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdlZGl0YWJsZScpIHtcbiAgICAgICAgdWkgPSB7IHN0YXJ0RWRpdGFibGU6IHZhbCwgZHVyYXRpb25FZGl0YWJsZTogdmFsIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVpID0geyBbbmFtZV06IHZhbCB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgc3RhbmRhcmRQcm9wczogeyB1aSB9LFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3Qgc2V0IHByb3AgJyR7bmFtZX0nLiBVc2Ugc2V0RXh0ZW5kZWRQcm9wIGluc3RlYWQuYClcbiAgICB9XG4gIH1cblxuICBzZXRFeHRlbmRlZFByb3AobmFtZTogc3RyaW5nLCB2YWw6IGFueSkge1xuICAgIHRoaXMubXV0YXRlKHtcbiAgICAgIGV4dGVuZGVkUHJvcHM6IHsgW25hbWVdOiB2YWwgfSxcbiAgICB9KVxuICB9XG5cbiAgc2V0U3RhcnQoc3RhcnRJbnB1dDogRGF0ZUlucHV0LCBvcHRpb25zOiB7IGdyYW51bGFyaXR5Pzogc3RyaW5nLCBtYWludGFpbkR1cmF0aW9uPzogYm9vbGVhbiB9ID0ge30pIHtcbiAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0XG4gICAgbGV0IHN0YXJ0ID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoc3RhcnRJbnB1dClcblxuICAgIGlmIChzdGFydCAmJiB0aGlzLl9pbnN0YW5jZSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgIGxldCBpbnN0YW5jZVJhbmdlID0gdGhpcy5faW5zdGFuY2UucmFuZ2VcbiAgICAgIGxldCBzdGFydERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIHN0YXJ0LCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KSAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xuXG4gICAgICBpZiAob3B0aW9ucy5tYWludGFpbkR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFydERlbHRhIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0RW5kKGVuZElucHV0OiBEYXRlSW5wdXQgfCBudWxsLCBvcHRpb25zOiB7IGdyYW51bGFyaXR5Pzogc3RyaW5nIH0gPSB7fSkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHRcbiAgICBsZXQgZW5kXG5cbiAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpXG5cbiAgICAgIGlmICghZW5kKSB7XG4gICAgICAgIHJldHVybiAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbGV0IGVuZERlbHRhID0gZGlmZkRhdGVzKHRoaXMuX2luc3RhbmNlLnJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KVxuICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YW5kYXJkUHJvcHM6IHsgaGFzRW5kOiBmYWxzZSB9IH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0RGF0ZXMoc3RhcnRJbnB1dDogRGF0ZUlucHV0LCBlbmRJbnB1dDogRGF0ZUlucHV0IHwgbnVsbCwgb3B0aW9uczogeyBhbGxEYXk/OiBib29sZWFuLCBncmFudWxhcml0eT86IHN0cmluZyB9ID0ge30pIHtcbiAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0XG4gICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheTogb3B0aW9ucy5hbGxEYXkgfSBhcyBhbnlcbiAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KVxuICAgIGxldCBlbmRcblxuICAgIGlmICghc3RhcnQpIHtcbiAgICAgIHJldHVybiAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICB9XG5cbiAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpXG5cbiAgICAgIGlmICghZW5kKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIGxldCBpbnN0YW5jZVJhbmdlID0gdGhpcy5faW5zdGFuY2UucmFuZ2VcblxuICAgICAgLy8gd2hlbiBjb21wdXRpbmcgdGhlIGRpZmYgZm9yIGFuIGV2ZW50IGJlaW5nIGNvbnZlcnRlZCB0byBhbGwtZGF5LFxuICAgICAgLy8gY29tcHV0ZSBkaWZmIG9mZiBvZiB0aGUgYWxsLWRheSB2YWx1ZXMgdGhlIHdheSBldmVudC1tdXRhdGlvbiBkb2VzLlxuICAgICAgaWYgKG9wdGlvbnMuYWxsRGF5ID09PSB0cnVlKSB7XG4gICAgICAgIGluc3RhbmNlUmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGluc3RhbmNlUmFuZ2UpXG4gICAgICB9XG5cbiAgICAgIGxldCBzdGFydERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIHN0YXJ0LCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KVxuXG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KVxuXG4gICAgICAgIGlmIChkdXJhdGlvbnNFcXVhbChzdGFydERlbHRhLCBlbmREZWx0YSkpIHtcbiAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHMgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGEsIGVuZERlbHRhLCBzdGFuZGFyZFByb3BzIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7IC8vIG1lYW5zIFwiY2xlYXIgdGhlIGVuZFwiXG4gICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gZmFsc2VcbiAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBzdGFydERlbHRhLCBzdGFuZGFyZFByb3BzIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbW92ZVN0YXJ0KGRlbHRhSW5wdXQ6IER1cmF0aW9uSW5wdXQpIHtcbiAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KVxuXG4gICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgdGhpcy5tdXRhdGUoeyBzdGFydERlbHRhOiBkZWx0YSB9KVxuICAgIH1cbiAgfVxuXG4gIG1vdmVFbmQoZGVsdGFJbnB1dDogRHVyYXRpb25JbnB1dCkge1xuICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpXG5cbiAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBkZWx0YSB9KVxuICAgIH1cbiAgfVxuXG4gIG1vdmVEYXRlcyhkZWx0YUlucHV0OiBEdXJhdGlvbklucHV0KSB7XG4gICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dClcblxuICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogZGVsdGEgfSlcbiAgICB9XG4gIH1cblxuICBzZXRBbGxEYXkoYWxsRGF5OiBib29sZWFuLCBvcHRpb25zOiB7IG1haW50YWluRHVyYXRpb24/OiBib29sZWFuIH0gPSB7fSkge1xuICAgIGxldCBzdGFuZGFyZFByb3BzID0geyBhbGxEYXkgfSBhcyBhbnlcbiAgICBsZXQgeyBtYWludGFpbkR1cmF0aW9uIH0gPSBvcHRpb25zXG5cbiAgICBpZiAobWFpbnRhaW5EdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICBtYWludGFpbkR1cmF0aW9uID0gdGhpcy5fY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb25cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmLmFsbERheSAhPT0gYWxsRGF5KSB7XG4gICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IG1haW50YWluRHVyYXRpb25cbiAgICB9XG5cbiAgICB0aGlzLm11dGF0ZSh7IHN0YW5kYXJkUHJvcHMgfSlcbiAgfVxuXG4gIGZvcm1hdFJhbmdlKGZvcm1hdElucHV0OiBGb3JtYXR0ZXJJbnB1dCkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHRcbiAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZVxuICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0SW5wdXQpXG5cbiAgICBpZiAodGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLnJhbmdlLmVuZCwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGZvcm1hdHRlciwge1xuICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICB9KVxuICB9XG5cbiAgbXV0YXRlKG11dGF0aW9uOiBFdmVudE11dGF0aW9uKSB7IC8vIG1lYW50IHRvIGJlIHByaXZhdGUuIGJ1dCBwbHVnaW5zIG5lZWQgYWNjZXNzXG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2VcblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgbGV0IGRlZiA9IHRoaXMuX2RlZlxuICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0XG4gICAgICBsZXQgeyBldmVudFN0b3JlIH0gPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKClcbiAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlLmluc3RhbmNlSWQpXG4gICAgICBsZXQgZXZlbnRDb25maWdCYXNlID0ge1xuICAgICAgICAnJzogeyAvLyBIQUNLLiBhbHdheXMgYWxsb3cgQVBJIHRvIG11dGF0ZSBldmVudHNcbiAgICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgICBzdGFydEVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uc3RyYWludHM6IFtdLFxuICAgICAgICAgIG92ZXJsYXA6IG51bGwsXG4gICAgICAgICAgYWxsb3dzOiBbXSxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiAnJyxcbiAgICAgICAgICB0ZXh0Q29sb3I6ICcnLFxuICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICB9LFxuICAgICAgfSBhcyBFdmVudFVpSGFzaFxuXG4gICAgICByZWxldmFudEV2ZW50cyA9IGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUocmVsZXZhbnRFdmVudHMsIGV2ZW50Q29uZmlnQmFzZSwgbXV0YXRpb24sIGNvbnRleHQpXG5cbiAgICAgIGxldCBvbGRFdmVudCA9IG5ldyBFdmVudEFwaShjb250ZXh0LCBkZWYsIGluc3RhbmNlKSAvLyBzbmFwc2hvdFxuICAgICAgdGhpcy5fZGVmID0gcmVsZXZhbnRFdmVudHMuZGVmc1tkZWYuZGVmSWRdXG4gICAgICB0aGlzLl9pbnN0YW5jZSA9IHJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXVxuXG4gICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgfSlcblxuICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2hhbmdlJywge1xuICAgICAgICBvbGRFdmVudCxcbiAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgIHJlbGF0ZWRFdmVudHM6IGJ1aWxkRXZlbnRBcGlzKHJlbGV2YW50RXZlbnRzLCBjb250ZXh0LCBpbnN0YW5jZSksXG4gICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRVNFVF9FVkVOVFMnLFxuICAgICAgICAgICAgZXZlbnRTdG9yZSwgLy8gdGhlIE9SSUdJTkFMIHN0b3JlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlKCkge1xuICAgIGxldCBjb250ZXh0ID0gdGhpcy5fY29udGV4dFxuICAgIGxldCBhc1N0b3JlID0gZXZlbnRBcGlUb1N0b3JlKHRoaXMpXG5cbiAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXG4gICAgfSlcblxuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlbW92ZScsIHtcbiAgICAgIGV2ZW50OiB0aGlzLFxuICAgICAgcmVsYXRlZEV2ZW50czogW10sXG4gICAgICByZXZlcnQoKSB7XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBnZXQgc291cmNlKCk6IEV2ZW50U291cmNlQXBpIHwgbnVsbCB7XG4gICAgbGV0IHsgc291cmNlSWQgfSA9IHRoaXMuX2RlZlxuXG4gICAgaWYgKHNvdXJjZUlkKSB7XG4gICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlQXBpKFxuICAgICAgICB0aGlzLl9jb250ZXh0LFxuICAgICAgICB0aGlzLl9jb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzW3NvdXJjZUlkXSxcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGdldCBzdGFydCgpOiBEYXRlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlID9cbiAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2Uuc3RhcnQpIDpcbiAgICAgIG51bGxcbiAgfVxuXG4gIGdldCBlbmQoKTogRGF0ZSB8IG51bGwge1xuICAgIHJldHVybiAodGhpcy5faW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkgP1xuICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcbiAgICAgIG51bGxcbiAgfVxuXG4gIGdldCBzdGFydFN0cigpOiBzdHJpbmcge1xuICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5kYXRlRW52LmZvcm1hdElzbyhpbnN0YW5jZS5yYW5nZS5zdGFydCwge1xuICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgZ2V0IGVuZFN0cigpOiBzdHJpbmcge1xuICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlXG4gICAgaWYgKGluc3RhbmNlICYmIHRoaXMuX2RlZi5oYXNFbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRhdGVFbnYuZm9ybWF0SXNvKGluc3RhbmNlLnJhbmdlLmVuZCwge1xuICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIGNvbXB1dGFibGUgcHJvcHMgdGhhdCBhbGwgYWNjZXNzIHRoZSBkZWZcbiAgLy8gVE9ETzogZmluZCBhIFR5cGVTY3JpcHQtY29tcGF0aWJsZSB3YXkgdG8gZG8gdGhpcyBhdCBzY2FsZVxuICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLl9kZWYucHVibGljSWQgfVxuICBnZXQgZ3JvdXBJZCgpIHsgcmV0dXJuIHRoaXMuX2RlZi5ncm91cElkIH1cbiAgZ2V0IGFsbERheSgpIHsgcmV0dXJuIHRoaXMuX2RlZi5hbGxEYXkgfVxuICBnZXQgdGl0bGUoKSB7IHJldHVybiB0aGlzLl9kZWYudGl0bGUgfVxuICBnZXQgdXJsKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVybCB9XG4gIGdldCBkaXNwbGF5KCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmRpc3BsYXkgfHwgJ2F1dG8nIH0gLy8gYmFkLiBqdXN0IG5vcm1hbGl6ZSB0aGUgdHlwZSBlYXJsaWVyXG4gIGdldCBzdGFydEVkaXRhYmxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLnN0YXJ0RWRpdGFibGUgfVxuICBnZXQgZHVyYXRpb25FZGl0YWJsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5kdXJhdGlvbkVkaXRhYmxlIH1cbiAgZ2V0IGNvbnN0cmFpbnQoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuY29uc3RyYWludHNbMF0gfHwgbnVsbCB9XG4gIGdldCBvdmVybGFwKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLm92ZXJsYXAgfVxuICBnZXQgYWxsb3coKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYWxsb3dzWzBdIHx8IG51bGwgfVxuICBnZXQgYmFja2dyb3VuZENvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmJhY2tncm91bmRDb2xvciB9XG4gIGdldCBib3JkZXJDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5ib3JkZXJDb2xvciB9XG4gIGdldCB0ZXh0Q29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkudGV4dENvbG9yIH1cblxuICAvLyBOT1RFOiB1c2VyIGNhbid0IG1vZGlmeSB0aGVzZSBiZWNhdXNlIE9iamVjdC5mcmVlemUgd2FzIGNhbGxlZCBpbiBldmVudC1kZWYgcGFyc2luZ1xuICBnZXQgY2xhc3NOYW1lcygpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jbGFzc05hbWVzIH1cbiAgZ2V0IGV4dGVuZGVkUHJvcHMoKSB7IHJldHVybiB0aGlzLl9kZWYuZXh0ZW5kZWRQcm9wcyB9XG5cbiAgdG9QbGFpbk9iamVjdChzZXR0aW5nczogeyBjb2xsYXBzZUV4dGVuZGVkUHJvcHM/OiBib29sZWFuLCBjb2xsYXBzZUNvbG9yPzogYm9vbGVhbiB9ID0ge30pOiBEaWN0aW9uYXJ5IHtcbiAgICBsZXQgZGVmID0gdGhpcy5fZGVmXG4gICAgbGV0IHsgdWkgfSA9IGRlZlxuICAgIGxldCB7IHN0YXJ0U3RyLCBlbmRTdHIgfSA9IHRoaXNcbiAgICBsZXQgcmVzOiBEaWN0aW9uYXJ5ID0ge31cblxuICAgIGlmIChkZWYudGl0bGUpIHtcbiAgICAgIHJlcy50aXRsZSA9IGRlZi50aXRsZVxuICAgIH1cblxuICAgIGlmIChzdGFydFN0cikge1xuICAgICAgcmVzLnN0YXJ0ID0gc3RhcnRTdHJcbiAgICB9XG5cbiAgICBpZiAoZW5kU3RyKSB7XG4gICAgICByZXMuZW5kID0gZW5kU3RyXG4gICAgfVxuXG4gICAgaWYgKGRlZi5wdWJsaWNJZCkge1xuICAgICAgcmVzLmlkID0gZGVmLnB1YmxpY0lkXG4gICAgfVxuXG4gICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICByZXMuZ3JvdXBJZCA9IGRlZi5ncm91cElkXG4gICAgfVxuXG4gICAgaWYgKGRlZi51cmwpIHtcbiAgICAgIHJlcy51cmwgPSBkZWYudXJsXG4gICAgfVxuXG4gICAgaWYgKHVpLmRpc3BsYXkgJiYgdWkuZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXMuZGlzcGxheSA9IHVpLmRpc3BsYXlcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHJlY3VycmluZy1ldmVudCBwcm9wZXJ0aWVzPz8/XG4gICAgLy8gVE9ETzogaW5jbHVkZSBzdGFydEVkaXRhYmxlL2R1cmF0aW9uRWRpdGFibGUvY29uc3RyYWludC9vdmVybGFwL2FsbG93XG5cbiAgICBpZiAoc2V0dGluZ3MuY29sbGFwc2VDb2xvciAmJiB1aS5iYWNrZ3JvdW5kQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yID09PSB1aS5ib3JkZXJDb2xvcikge1xuICAgICAgcmVzLmNvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh1aS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgcmVzLmJhY2tncm91bmRDb2xvciA9IHVpLmJhY2tncm91bmRDb2xvclxuICAgICAgfVxuICAgICAgaWYgKHVpLmJvcmRlckNvbG9yKSB7XG4gICAgICAgIHJlcy5ib3JkZXJDb2xvciA9IHVpLmJvcmRlckNvbG9yXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVpLnRleHRDb2xvcikge1xuICAgICAgcmVzLnRleHRDb2xvciA9IHVpLnRleHRDb2xvclxuICAgIH1cblxuICAgIGlmICh1aS5jbGFzc05hbWVzLmxlbmd0aCkge1xuICAgICAgcmVzLmNsYXNzTmFtZXMgPSB1aS5jbGFzc05hbWVzXG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKGRlZi5leHRlbmRlZFByb3BzKS5sZW5ndGgpIHtcbiAgICAgIGlmIChzZXR0aW5ncy5jb2xsYXBzZUV4dGVuZGVkUHJvcHMpIHtcbiAgICAgICAgX19hc3NpZ24ocmVzLCBkZWYuZXh0ZW5kZWRQcm9wcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcy5leHRlbmRlZFByb3BzID0gZGVmLmV4dGVuZGVkUHJvcHNcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9QbGFpbk9iamVjdCgpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50QXBpVG9TdG9yZShldmVudEFwaTogRXZlbnRBcGkpOiBFdmVudFN0b3JlIHtcbiAgbGV0IGRlZiA9IGV2ZW50QXBpLl9kZWZcbiAgbGV0IGluc3RhbmNlID0gZXZlbnRBcGkuX2luc3RhbmNlXG5cbiAgcmV0dXJuIHtcbiAgICBkZWZzOiB7IFtkZWYuZGVmSWRdOiBkZWYgfSxcbiAgICBpbnN0YW5jZXM6IGluc3RhbmNlXG4gICAgICA/IHsgW2luc3RhbmNlLmluc3RhbmNlSWRdOiBpbnN0YW5jZSB9XG4gICAgICA6IHt9LFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV2ZW50QXBpcyhldmVudFN0b3JlOiBFdmVudFN0b3JlLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsIGV4Y2x1ZGVJbnN0YW5jZT86IEV2ZW50SW5zdGFuY2UpOiBFdmVudEFwaVtdIHtcbiAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlXG4gIGxldCBldmVudEFwaXM6IEV2ZW50QXBpW10gPSBbXVxuICBsZXQgZXhjbHVkZUluc3RhbmNlSWQgPSBleGNsdWRlSW5zdGFuY2UgPyBleGNsdWRlSW5zdGFuY2UuaW5zdGFuY2VJZCA6ICcnXG5cbiAgZm9yIChsZXQgaWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2lkXVxuICAgIGxldCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXVxuXG4gICAgaWYgKGluc3RhbmNlLmluc3RhbmNlSWQgIT09IGV4Y2x1ZGVJbnN0YW5jZUlkKSB7XG4gICAgICBldmVudEFwaXMucHVzaChuZXcgRXZlbnRBcGkoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50QXBpc1xufVxuIiwiaW1wb3J0IHsgRGF0ZU1hcmtlciwgYXJyYXlUb1V0Y0RhdGUsIGRhdGVUb1V0Y0FycmF5IH0gZnJvbSAnLi9tYXJrZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsZW5kYXJTeXN0ZW0ge1xuICBnZXRNYXJrZXJZZWFyKGQ6IERhdGVNYXJrZXIpOiBudW1iZXJcbiAgZ2V0TWFya2VyTW9udGgoZDogRGF0ZU1hcmtlcik6IG51bWJlclxuICBnZXRNYXJrZXJEYXkoZDogRGF0ZU1hcmtlcik6IG51bWJlclxuICBhcnJheVRvTWFya2VyKGFycjogbnVtYmVyW10pOiBEYXRlTWFya2VyXG4gIG1hcmtlclRvQXJyYXkoZDogRGF0ZU1hcmtlcik6IG51bWJlcltdXG59XG5cbmxldCBjYWxlbmRhclN5c3RlbUNsYXNzTWFwID0ge31cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0obmFtZSwgdGhlQ2xhc3MpIHtcbiAgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcFtuYW1lXSA9IHRoZUNsYXNzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYWxlbmRhclN5c3RlbShuYW1lKSB7XG4gIHJldHVybiBuZXcgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcFtuYW1lXSgpXG59XG5cbmNsYXNzIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIGltcGxlbWVudHMgQ2FsZW5kYXJTeXN0ZW0ge1xuICBnZXRNYXJrZXJZZWFyKGQ6IERhdGVNYXJrZXIpIHtcbiAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpXG4gIH1cblxuICBnZXRNYXJrZXJNb250aChkOiBEYXRlTWFya2VyKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDTW9udGgoKVxuICB9XG5cbiAgZ2V0TWFya2VyRGF5KGQ6IERhdGVNYXJrZXIpIHtcbiAgICByZXR1cm4gZC5nZXRVVENEYXRlKClcbiAgfVxuXG4gIGFycmF5VG9NYXJrZXIoYXJyKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGFycilcbiAgfVxuXG4gIG1hcmtlclRvQXJyYXkobWFya2VyKSB7XG4gICAgcmV0dXJuIGRhdGVUb1V0Y0FycmF5KG1hcmtlcilcbiAgfVxufVxuXG5yZWdpc3RlckNhbGVuZGFyU3lzdGVtKCdncmVnb3J5JywgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0pXG4iLCJpbXBvcnQgeyBpc1ZhbGlkRGF0ZSB9IGZyb20gJy4vbWFya2VyJ1xuXG5jb25zdCBJU09fUkUgPSAvXlxccyooXFxkezR9KSgtPyhcXGR7Mn0pKC0/KFxcZHsyfSkoW1QgXShcXGR7Mn0pOj8oXFxkezJ9KSg6PyhcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFstK10pKFxcZHsyfSkoOj8oXFxkezJ9KSk/KSk/KT8pPyk/JC9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBsZXQgbSA9IElTT19SRS5leGVjKHN0cilcblxuICBpZiAobSkge1xuICAgIGxldCBtYXJrZXIgPSBuZXcgRGF0ZShEYXRlLlVUQyhcbiAgICAgIE51bWJlcihtWzFdKSxcbiAgICAgIG1bM10gPyBOdW1iZXIobVszXSkgLSAxIDogMCxcbiAgICAgIE51bWJlcihtWzVdIHx8IDEpLFxuICAgICAgTnVtYmVyKG1bN10gfHwgMCksXG4gICAgICBOdW1iZXIobVs4XSB8fCAwKSxcbiAgICAgIE51bWJlcihtWzEwXSB8fCAwKSxcbiAgICAgIG1bMTJdID8gTnVtYmVyKGAwLiR7bVsxMl19YCkgKiAxMDAwIDogMCxcbiAgICApKVxuXG4gICAgaWYgKGlzVmFsaWREYXRlKG1hcmtlcikpIHtcbiAgICAgIGxldCB0aW1lWm9uZU9mZnNldCA9IG51bGxcblxuICAgICAgaWYgKG1bMTNdKSB7XG4gICAgICAgIHRpbWVab25lT2Zmc2V0ID0gKG1bMTVdID09PSAnLScgPyAtMSA6IDEpICogKFxuICAgICAgICAgIE51bWJlcihtWzE2XSB8fCAwKSAqIDYwICtcbiAgICAgICAgICBOdW1iZXIobVsxOF0gfHwgMClcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXJrZXIsXG4gICAgICAgIGlzVGltZVVuc3BlY2lmaWVkOiAhbVs2XSxcbiAgICAgICAgdGltZVpvbmVPZmZzZXQsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiIsImltcG9ydCB7XG4gIERhdGVNYXJrZXIsIGFkZE1zLFxuICBkaWZmSG91cnMsIGRpZmZNaW51dGVzLCBkaWZmU2Vjb25kcywgZGlmZldob2xlV2Vla3MsIGRpZmZXaG9sZURheXMsXG4gIHN0YXJ0T2ZEYXksIHN0YXJ0T2ZIb3VyLCBzdGFydE9mTWludXRlLCBzdGFydE9mU2Vjb25kLFxuICB3ZWVrT2ZZZWFyLCBhcnJheVRvVXRjRGF0ZSwgZGF0ZVRvVXRjQXJyYXksIGRhdGVUb0xvY2FsQXJyYXksIGFycmF5VG9Mb2NhbERhdGUsIHRpbWVBc01zLCBpc1ZhbGlkRGF0ZSxcbn0gZnJvbSAnLi9tYXJrZXInXG5pbXBvcnQgeyBDYWxlbmRhclN5c3RlbSwgY3JlYXRlQ2FsZW5kYXJTeXN0ZW0gfSBmcm9tICcuL2NhbGVuZGFyLXN5c3RlbSdcbmltcG9ydCB7IExvY2FsZSB9IGZyb20gJy4vbG9jYWxlJ1xuaW1wb3J0IHsgTmFtZWRUaW1lWm9uZUltcGwsIE5hbWVkVGltZVpvbmVJbXBsQ2xhc3MgfSBmcm9tICcuL3RpbWV6b25lJ1xuaW1wb3J0IHsgRHVyYXRpb24sIGFzUm91Z2hZZWFycywgYXNSb3VnaE1vbnRocywgYXNSb3VnaERheXMsIGFzUm91Z2hNcyB9IGZyb20gJy4vZHVyYXRpb24nXG5pbXBvcnQgeyBEYXRlRm9ybWF0dGVyLCBDbWRGb3JtYXR0ZXJGdW5jIH0gZnJvbSAnLi9EYXRlRm9ybWF0dGVyJ1xuaW1wb3J0IHsgYnVpbGRJc29TdHJpbmcgfSBmcm9tICcuL2Zvcm1hdHRpbmctdXRpbHMnXG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJy4vcGFyc2luZydcbmltcG9ydCB7IGlzSW50IH0gZnJvbSAnLi4vdXRpbC9taXNjJ1xuXG5leHBvcnQgdHlwZSBXZWVrTnVtYmVyQ2FsY3VsYXRpb24gPSAnbG9jYWwnIHwgJ0lTTycgfCAoKG06IERhdGUpID0+IG51bWJlcilcblxuZXhwb3J0IGludGVyZmFjZSBEYXRlRW52U2V0dGluZ3Mge1xuICB0aW1lWm9uZTogc3RyaW5nXG4gIG5hbWVkVGltZVpvbmVJbXBsPzogTmFtZWRUaW1lWm9uZUltcGxDbGFzc1xuICBjYWxlbmRhclN5c3RlbTogc3RyaW5nXG4gIGxvY2FsZTogTG9jYWxlXG4gIHdlZWtOdW1iZXJDYWxjdWxhdGlvbj86IFdlZWtOdW1iZXJDYWxjdWxhdGlvblxuICBmaXJzdERheT86IG51bWJlciwgLy8gd2lsbCBvdmVycmlkZSB3aGF0IHRoZSBsb2NhbGUgd2FudHNcbiAgd2Vla1RleHQ/OiBzdHJpbmcsXG4gIGNtZEZvcm1hdHRlcj86IENtZEZvcm1hdHRlckZ1bmNcbiAgZGVmYXVsdFNlcGFyYXRvcj86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBEYXRlSW5wdXQgPSBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyIHwgbnVtYmVyW11cblxuZXhwb3J0IGludGVyZmFjZSBEYXRlTWFya2VyTWV0YSB7XG4gIG1hcmtlcjogRGF0ZU1hcmtlclxuICBpc1RpbWVVbnNwZWNpZmllZDogYm9vbGVhblxuICBmb3JjZWRUem86IG51bWJlciB8IG51bGxcbn1cblxuZXhwb3J0IGNsYXNzIERhdGVFbnYge1xuICB0aW1lWm9uZTogc3RyaW5nXG4gIG5hbWVkVGltZVpvbmVJbXBsOiBOYW1lZFRpbWVab25lSW1wbFxuICBjYW5Db21wdXRlT2Zmc2V0OiBib29sZWFuXG5cbiAgY2FsZW5kYXJTeXN0ZW06IENhbGVuZGFyU3lzdGVtXG4gIGxvY2FsZTogTG9jYWxlXG4gIHdlZWtEb3c6IG51bWJlciAvLyB3aGljaCBkYXkgYmVnaW5zIHRoZSB3ZWVrXG4gIHdlZWtEb3k6IG51bWJlciAvLyB3aGljaCBkYXkgbXVzdCBiZSB3aXRoaW4gdGhlIHllYXIsIGZvciBjb21wdXRpbmcgdGhlIGZpcnN0IHdlZWsgbnVtYmVyXG4gIHdlZWtOdW1iZXJGdW5jOiBhbnlcbiAgd2Vla1RleHQ6IHN0cmluZyAvLyBET04nVCBMSUtFIGhvdyBvcHRpb25zIGFyZSBjb25mdXNlZCB3aXRoIGxvY2FsXG4gIGNtZEZvcm1hdHRlcj86IENtZEZvcm1hdHRlckZ1bmNcbiAgZGVmYXVsdFNlcGFyYXRvcjogc3RyaW5nXG5cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IERhdGVFbnZTZXR0aW5ncykge1xuICAgIGxldCB0aW1lWm9uZSA9IHRoaXMudGltZVpvbmUgPSBzZXR0aW5ncy50aW1lWm9uZVxuICAgIGxldCBpc05hbWVkVGltZVpvbmUgPSB0aW1lWm9uZSAhPT0gJ2xvY2FsJyAmJiB0aW1lWm9uZSAhPT0gJ1VUQydcblxuICAgIGlmIChzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCAmJiBpc05hbWVkVGltZVpvbmUpIHtcbiAgICAgIHRoaXMubmFtZWRUaW1lWm9uZUltcGwgPSBuZXcgc2V0dGluZ3MubmFtZWRUaW1lWm9uZUltcGwodGltZVpvbmUpXG4gICAgfVxuXG4gICAgdGhpcy5jYW5Db21wdXRlT2Zmc2V0ID0gQm9vbGVhbighaXNOYW1lZFRpbWVab25lIHx8IHRoaXMubmFtZWRUaW1lWm9uZUltcGwpXG5cbiAgICB0aGlzLmNhbGVuZGFyU3lzdGVtID0gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0oc2V0dGluZ3MuY2FsZW5kYXJTeXN0ZW0pXG4gICAgdGhpcy5sb2NhbGUgPSBzZXR0aW5ncy5sb2NhbGVcbiAgICB0aGlzLndlZWtEb3cgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3dcbiAgICB0aGlzLndlZWtEb3kgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3lcblxuICAgIGlmIChzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG4gICAgICB0aGlzLndlZWtEb3cgPSAxXG4gICAgICB0aGlzLndlZWtEb3kgPSA0XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5maXJzdERheSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmZpcnN0RGF5XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMud2Vla051bWJlckZ1bmMgPSBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb25cbiAgICB9XG5cbiAgICB0aGlzLndlZWtUZXh0ID0gc2V0dGluZ3Mud2Vla1RleHQgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtUZXh0IDogc2V0dGluZ3MubG9jYWxlLm9wdGlvbnMud2Vla1RleHRcblxuICAgIHRoaXMuY21kRm9ybWF0dGVyID0gc2V0dGluZ3MuY21kRm9ybWF0dGVyXG4gICAgdGhpcy5kZWZhdWx0U2VwYXJhdG9yID0gc2V0dGluZ3MuZGVmYXVsdFNlcGFyYXRvclxuICB9XG5cbiAgLy8gQ3JlYXRpbmcgLyBQYXJzaW5nXG5cbiAgY3JlYXRlTWFya2VyKGlucHV0OiBEYXRlSW5wdXQpOiBEYXRlTWFya2VyIHtcbiAgICBsZXQgbWV0YSA9IHRoaXMuY3JlYXRlTWFya2VyTWV0YShpbnB1dClcbiAgICBpZiAobWV0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIG1ldGEubWFya2VyXG4gIH1cblxuICBjcmVhdGVOb3dNYXJrZXIoKTogRGF0ZU1hcmtlciB7XG4gICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wVG9NYXJrZXIobmV3IERhdGUoKS52YWx1ZU9mKCkpXG4gICAgfVxuICAgIC8vIGlmIHdlIGNhbid0IGNvbXB1dGUgdGhlIGN1cnJlbnQgZGF0ZSB2YWwgZm9yIGEgdGltZXpvbmUsXG4gICAgLy8gYmV0dGVyIHRvIGdpdmUgdGhlIGN1cnJlbnQgbG9jYWwgZGF0ZSB2YWxzIHRoYW4gVVRDXG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGRhdGVUb0xvY2FsQXJyYXkobmV3IERhdGUoKSkpXG4gIH1cblxuICBjcmVhdGVNYXJrZXJNZXRhKGlucHV0OiBEYXRlSW5wdXQpOiBEYXRlTWFya2VyTWV0YSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlKGlucHV0KVxuICAgIH1cblxuICAgIGxldCBtYXJrZXIgPSBudWxsXG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dClcbiAgICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZU9mKClcblxuICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICBtYXJrZXIgPSBhcnJheVRvVXRjRGF0ZShpbnB1dClcbiAgICB9XG5cbiAgICBpZiAobWFya2VyID09PSBudWxsIHx8ICFpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiB7IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IGZhbHNlLCBmb3JjZWRUem86IG51bGwgfVxuICB9XG5cbiAgcGFyc2Uoczogc3RyaW5nKSB7XG4gICAgbGV0IHBhcnRzID0gcGFyc2UocylcbiAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgbGV0IHsgbWFya2VyIH0gPSBwYXJ0c1xuICAgIGxldCBmb3JjZWRUem8gPSBudWxsXG5cbiAgICBpZiAocGFydHMudGltZVpvbmVPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihtYXJrZXIudmFsdWVPZigpIC0gcGFydHMudGltZVpvbmVPZmZzZXQgKiA2MCAqIDEwMDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JjZWRUem8gPSBwYXJ0cy50aW1lWm9uZU9mZnNldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IHBhcnRzLmlzVGltZVVuc3BlY2lmaWVkLCBmb3JjZWRUem8gfVxuICB9XG5cbiAgLy8gQWNjZXNzb3JzXG5cbiAgZ2V0WWVhcihtYXJrZXI6IERhdGVNYXJrZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobWFya2VyKVxuICB9XG5cbiAgZ2V0TW9udGgobWFya2VyOiBEYXRlTWFya2VyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtYXJrZXIpXG4gIH1cblxuICAvLyBBZGRpbmcgLyBTdWJ0cmFjdGluZ1xuXG4gIGFkZChtYXJrZXI6IERhdGVNYXJrZXIsIGR1cjogRHVyYXRpb24pOiBEYXRlTWFya2VyIHtcbiAgICBsZXQgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpXG4gICAgYVswXSArPSBkdXIueWVhcnNcbiAgICBhWzFdICs9IGR1ci5tb250aHNcbiAgICBhWzJdICs9IGR1ci5kYXlzXG4gICAgYVs2XSArPSBkdXIubWlsbGlzZWNvbmRzXG4gICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKVxuICB9XG5cbiAgc3VidHJhY3QobWFya2VyOiBEYXRlTWFya2VyLCBkdXI6IER1cmF0aW9uKTogRGF0ZU1hcmtlciB7XG4gICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKVxuICAgIGFbMF0gLT0gZHVyLnllYXJzXG4gICAgYVsxXSAtPSBkdXIubW9udGhzXG4gICAgYVsyXSAtPSBkdXIuZGF5c1xuICAgIGFbNl0gLT0gZHVyLm1pbGxpc2Vjb25kc1xuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSlcbiAgfVxuXG4gIGFkZFllYXJzKG1hcmtlcjogRGF0ZU1hcmtlciwgbjogbnVtYmVyKSB7XG4gICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKVxuICAgIGFbMF0gKz0gblxuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSlcbiAgfVxuXG4gIGFkZE1vbnRocyhtYXJrZXI6IERhdGVNYXJrZXIsIG46IG51bWJlcikge1xuICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcilcbiAgICBhWzFdICs9IG5cbiAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpXG4gIH1cblxuICAvLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5cbiAgZGlmZldob2xlWWVhcnMobTA6IERhdGVNYXJrZXIsIG0xOiBEYXRlTWFya2VyKTogbnVtYmVyIHtcbiAgICBsZXQgeyBjYWxlbmRhclN5c3RlbSB9ID0gdGhpc1xuXG4gICAgaWYgKFxuICAgICAgdGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkgJiZcbiAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMSkgJiZcbiAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZGlmZldob2xlTW9udGhzKG0wOiBEYXRlTWFya2VyLCBtMTogRGF0ZU1hcmtlcik6IG51bWJlciB7XG4gICAgbGV0IHsgY2FsZW5kYXJTeXN0ZW0gfSA9IHRoaXNcblxuICAgIGlmIChcbiAgICAgIHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gKGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0wKSkgK1xuICAgICAgICAgIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTApKSAqIDEyXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBSYW5nZSAvIER1cmF0aW9uXG5cbiAgZ3JlYXRlc3RXaG9sZVVuaXQobTA6IERhdGVNYXJrZXIsIG0xOiBEYXRlTWFya2VyKSB7XG4gICAgbGV0IG4gPSB0aGlzLmRpZmZXaG9sZVllYXJzKG0wLCBtMSlcblxuICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyB1bml0OiAneWVhcicsIHZhbHVlOiBuIH1cbiAgICB9XG5cbiAgICBuID0gdGhpcy5kaWZmV2hvbGVNb250aHMobTAsIG0xKVxuXG4gICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICdtb250aCcsIHZhbHVlOiBuIH1cbiAgICB9XG5cbiAgICBuID0gZGlmZldob2xlV2Vla3MobTAsIG0xKVxuXG4gICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICd3ZWVrJywgdmFsdWU6IG4gfVxuICAgIH1cblxuICAgIG4gPSBkaWZmV2hvbGVEYXlzKG0wLCBtMSlcblxuICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyB1bml0OiAnZGF5JywgdmFsdWU6IG4gfVxuICAgIH1cblxuICAgIG4gPSBkaWZmSG91cnMobTAsIG0xKVxuXG4gICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICByZXR1cm4geyB1bml0OiAnaG91cicsIHZhbHVlOiBuIH1cbiAgICB9XG5cbiAgICBuID0gZGlmZk1pbnV0ZXMobTAsIG0xKVxuXG4gICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG4gfVxuICAgIH1cblxuICAgIG4gPSBkaWZmU2Vjb25kcyhtMCwgbTEpXG5cbiAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICdzZWNvbmQnLCB2YWx1ZTogbiB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSB9XG4gIH1cblxuICBjb3VudER1cmF0aW9uc0JldHdlZW4obTA6IERhdGVNYXJrZXIsIG0xOiBEYXRlTWFya2VyLCBkOiBEdXJhdGlvbikge1xuICAgIC8vIFRPRE86IGNhbiB1c2UgZ3JlYXRlc3RXaG9sZVVuaXRcbiAgICBsZXQgZGlmZlxuXG4gICAgaWYgKGQueWVhcnMpIHtcbiAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZVllYXJzKG0wLCBtMSlcbiAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaFllYXJzKGQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGQubW9udGhzKSB7XG4gICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVNb250aHMobTAsIG0xKVxuICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoTW9udGhzKGQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGQuZGF5cykge1xuICAgICAgZGlmZiA9IGRpZmZXaG9sZURheXMobTAsIG0xKVxuICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoRGF5cyhkKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIGFzUm91Z2hNcyhkKVxuICB9XG5cbiAgLy8gU3RhcnQtT2ZcbiAgLy8gdGhlc2UgRE9OJ1QgcmV0dXJuIHpvbmVkLWRhdGVzLiBvbmx5IFVUQyBzdGFydC1vZiBkYXRlc1xuXG4gIHN0YXJ0T2YobTogRGF0ZU1hcmtlciwgdW5pdDogc3RyaW5nKSB7XG4gICAgaWYgKHVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZlllYXIobSlcbiAgICB9XG4gICAgaWYgKHVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZNb250aChtKVxuICAgIH1cbiAgICBpZiAodW5pdCA9PT0gJ3dlZWsnKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydE9mV2VlayhtKVxuICAgIH1cbiAgICBpZiAodW5pdCA9PT0gJ2RheScpIHtcbiAgICAgIHJldHVybiBzdGFydE9mRGF5KG0pXG4gICAgfVxuICAgIGlmICh1bml0ID09PSAnaG91cicpIHtcbiAgICAgIHJldHVybiBzdGFydE9mSG91cihtKVxuICAgIH1cbiAgICBpZiAodW5pdCA9PT0gJ21pbnV0ZScpIHtcbiAgICAgIHJldHVybiBzdGFydE9mTWludXRlKG0pXG4gICAgfVxuICAgIGlmICh1bml0ID09PSAnc2Vjb25kJykge1xuICAgICAgcmV0dXJuIHN0YXJ0T2ZTZWNvbmQobSlcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHN0YXJ0T2ZZZWFyKG06IERhdGVNYXJrZXIpOiBEYXRlTWFya2VyIHtcbiAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcbiAgICBdKVxuICB9XG5cbiAgc3RhcnRPZk1vbnRoKG06IERhdGVNYXJrZXIpOiBEYXRlTWFya2VyIHtcbiAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcbiAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobSksXG4gICAgXSlcbiAgfVxuXG4gIHN0YXJ0T2ZXZWVrKG06IERhdGVNYXJrZXIpOiBEYXRlTWFya2VyIHtcbiAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcbiAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobSksXG4gICAgICBtLmdldFVUQ0RhdGUoKSAtICgobS5nZXRVVENEYXkoKSAtIHRoaXMud2Vla0RvdyArIDcpICUgNyksXG4gICAgXSlcbiAgfVxuXG4gIC8vIFdlZWsgTnVtYmVyXG5cbiAgY29tcHV0ZVdlZWtOdW1iZXIobWFya2VyOiBEYXRlTWFya2VyKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy53ZWVrTnVtYmVyRnVuYykge1xuICAgICAgcmV0dXJuIHRoaXMud2Vla051bWJlckZ1bmModGhpcy50b0RhdGUobWFya2VyKSlcbiAgICB9XG4gICAgcmV0dXJuIHdlZWtPZlllYXIobWFya2VyLCB0aGlzLndlZWtEb3csIHRoaXMud2Vla0RveSlcbiAgfVxuXG4gIC8vIFRPRE86IGNob2tlIG9uIHRpbWVab25lTmFtZTogbG9uZ1xuICBmb3JtYXQobWFya2VyOiBEYXRlTWFya2VyLCBmb3JtYXR0ZXI6IERhdGVGb3JtYXR0ZXIsIGRhdGVPcHRpb25zOiB7IGZvcmNlZFR6bz86IG51bWJlciB9ID0ge30pIHtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChcbiAgICAgIHtcbiAgICAgICAgbWFya2VyLFxuICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwgP1xuICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZFR6byA6XG4gICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKSxcbiAgICAgIH0sXG4gICAgICB0aGlzLFxuICAgIClcbiAgfVxuXG4gIGZvcm1hdFJhbmdlKFxuICAgIHN0YXJ0OiBEYXRlTWFya2VyLFxuICAgIGVuZDogRGF0ZU1hcmtlcixcbiAgICBmb3JtYXR0ZXI6IERhdGVGb3JtYXR0ZXIsXG4gICAgZGF0ZU9wdGlvbnM6IHsgZm9yY2VkU3RhcnRUem8/OiBudW1iZXIsIGZvcmNlZEVuZFR6bz86IG51bWJlciwgaXNFbmRFeGNsdXNpdmU/OiBib29sZWFuLCBkZWZhdWx0U2VwYXJhdG9yPzogc3RyaW5nIH0gPSB7fSxcbiAgKSB7XG4gICAgaWYgKGRhdGVPcHRpb25zLmlzRW5kRXhjbHVzaXZlKSB7XG4gICAgICBlbmQgPSBhZGRNcyhlbmQsIC0xKVxuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0UmFuZ2UoXG4gICAgICB7XG4gICAgICAgIG1hcmtlcjogc3RhcnQsXG4gICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byAhPSBudWxsID9cbiAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byA6XG4gICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoc3RhcnQpLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbWFya2VyOiBlbmQsXG4gICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRFbmRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvIDpcbiAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihlbmQpLFxuICAgICAgfSxcbiAgICAgIHRoaXMsXG4gICAgICBkYXRlT3B0aW9ucy5kZWZhdWx0U2VwYXJhdG9yLFxuICAgIClcbiAgfVxuXG4gIC8qXG4gIERVTUI6IHRoZSBvbWl0VGltZSBhcmcgaXMgZHVtYi4gaWYgd2Ugb21pdCB0aGUgdGltZSwgd2Ugd2FudCB0byBvbWl0IHRoZSB0aW1lem9uZSBvZmZzZXQuIGFuZCBpZiB3ZSBkbyB0aGF0LFxuICBtaWdodCBhcyB3ZWxsIHVzZSBidWlsZElzb1N0cmluZyBvciBzb21lIG90aGVyIHV0aWwgZGlyZWN0bHlcbiAgKi9cbiAgZm9ybWF0SXNvKG1hcmtlcjogRGF0ZU1hcmtlciwgZXh0cmFPcHRpb25zOiBhbnkgPSB7fSkge1xuICAgIGxldCB0aW1lWm9uZU9mZnNldCA9IG51bGxcblxuICAgIGlmICghZXh0cmFPcHRpb25zLm9taXRUaW1lWm9uZU9mZnNldCkge1xuICAgICAgaWYgKGV4dHJhT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCkge1xuICAgICAgICB0aW1lWm9uZU9mZnNldCA9IGV4dHJhT3B0aW9ucy5mb3JjZWRUem9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVab25lT2Zmc2V0ID0gdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWlsZElzb1N0cmluZyhtYXJrZXIsIHRpbWVab25lT2Zmc2V0LCBleHRyYU9wdGlvbnMub21pdFRpbWUpXG4gIH1cblxuICAvLyBUaW1lWm9uZVxuXG4gIHRpbWVzdGFtcFRvTWFya2VyKG1zOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGRhdGVUb0xvY2FsQXJyYXkobmV3IERhdGUobXMpKSlcbiAgICB9IGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJyB8fCAhdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUodGhpcy5uYW1lZFRpbWVab25lSW1wbC50aW1lc3RhbXBUb0FycmF5KG1zKSlcbiAgfVxuXG4gIG9mZnNldEZvck1hcmtlcihtOiBEYXRlTWFya2VyKSB7XG4gICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgIHJldHVybiAtYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAvLyBjb252ZXJ0IFwiaW52ZXJzZVwiIG9mZnNldCB0byBcIm5vcm1hbFwiIG9mZnNldFxuICAgIH0gaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH0gaWYgKHRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gQ29udmVyc2lvblxuXG4gIHRvRGF0ZShtOiBEYXRlTWFya2VyLCBmb3JjZWRUem8/OiBudW1iZXIpOiBEYXRlIHtcbiAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgcmV0dXJuIGFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkpIC8vIG1ha2Ugc3VyZSBpdCdzIGEgY29weVxuICAgIH1cblxuICAgIGlmICghdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpIC0gKGZvcmNlZFR6byB8fCAwKSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICBtLnZhbHVlT2YoKSAtXG4gICAgICAgIHRoaXMubmFtZWRUaW1lWm9uZUltcGwub2Zmc2V0Rm9yQXJyYXkoZGF0ZVRvVXRjQXJyYXkobSkpICogMTAwMCAqIDYwLCAvLyBjb252ZXJ0IG1pbnV0ZXMgLT4gbXNcbiAgICApXG4gIH1cbn1cbiIsImltcG9ydCB7IExvY2FsZUlucHV0IH0gZnJvbSAnLi9kYXRlbGliL2xvY2FsZSdcblxuZXhwb3J0IGNvbnN0IGdsb2JhbExvY2FsZXM6IExvY2FsZUlucHV0W10gPSBbXVxuIiwiaW1wb3J0IHsgbWVyZ2VQcm9wcyB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgZ2xvYmFsTG9jYWxlcyB9IGZyb20gJy4uL2dsb2JhbC1sb2NhbGVzJyAvLyB3ZWlyZCB0byBiZSBpbXBvcnRpbmcgdGhpc1xuaW1wb3J0IHsgQ2FsZW5kYXJPcHRpb25zLCBDYWxlbmRhck9wdGlvbnNSZWZpbmVkIH0gZnJvbSAnLi4vb3B0aW9ucydcblxuZXhwb3J0IHR5cGUgTG9jYWxlQ29kZUFyZyA9IHN0cmluZyB8IHN0cmluZ1tdXG5leHBvcnQgdHlwZSBMb2NhbGVTaW5ndWxhckFyZyA9IExvY2FsZUNvZGVBcmcgfCBMb2NhbGVJbnB1dFxuXG5leHBvcnQgaW50ZXJmYWNlIExvY2FsZSB7XG4gIGNvZGVBcmc6IExvY2FsZUNvZGVBcmdcbiAgY29kZXM6IHN0cmluZ1tdXG4gIHdlZWs6IHsgZG93OiBudW1iZXIsIGRveTogbnVtYmVyIH1cbiAgc2ltcGxlTnVtYmVyRm9ybWF0OiBJbnRsLk51bWJlckZvcm1hdFxuICBvcHRpb25zOiBDYWxlbmRhck9wdGlvbnNSZWZpbmVkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxlSW5wdXQgZXh0ZW5kcyBDYWxlbmRhck9wdGlvbnMge1xuICBjb2RlOiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgTG9jYWxlSW5wdXRNYXAgPSB7IFtjb2RlOiBzdHJpbmddOiBMb2NhbGVJbnB1dCB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmF3TG9jYWxlSW5mbyB7XG4gIG1hcDogTG9jYWxlSW5wdXRNYXBcbiAgZGVmYXVsdENvZGU6IHN0cmluZ1xufVxuXG5jb25zdCBSQVdfRU5fTE9DQUxFID0ge1xuICBjb2RlOiAnZW4nLFxuICB3ZWVrOiB7XG4gICAgZG93OiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vla1xuICAgIGRveTogNCwgLy8gNCBkYXlzIG5lZWQgdG8gYmUgd2l0aGluIHRoZSB5ZWFyIHRvIGJlIGNvbnNpZGVyZWQgdGhlIGZpcnN0IHdlZWtcbiAgfSxcbiAgZGlyZWN0aW9uOiAnbHRyJyBhcyAoJ2x0cicgfCAncnRsJyksIC8vIFRPRE86IG1ha2UgYSByZWFsIHR5cGUgZm9yIHRoaXNcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdwcmV2JyxcbiAgICBuZXh0OiAnbmV4dCcsXG4gICAgcHJldlllYXI6ICdwcmV2IHllYXInLFxuICAgIG5leHRZZWFyOiAnbmV4dCB5ZWFyJyxcbiAgICB5ZWFyOiAneWVhcicsXG4gICAgdG9kYXk6ICd0b2RheScsXG4gICAgbW9udGg6ICdtb250aCcsXG4gICAgd2VlazogJ3dlZWsnLFxuICAgIGRheTogJ2RheScsXG4gICAgbGlzdDogJ2xpc3QnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1cnLFxuICBhbGxEYXlUZXh0OiAnYWxsLWRheScsXG4gIG1vcmVMaW5rVGV4dDogJ21vcmUnLFxuICBub0V2ZW50c1RleHQ6ICdObyBldmVudHMgdG8gZGlzcGxheScsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcmdhbml6ZVJhd0xvY2FsZXMoZXhwbGljaXRSYXdMb2NhbGVzOiBMb2NhbGVJbnB1dFtdKTogUmF3TG9jYWxlSW5mbyB7XG4gIGxldCBkZWZhdWx0Q29kZSA9IGV4cGxpY2l0UmF3TG9jYWxlcy5sZW5ndGggPiAwID8gZXhwbGljaXRSYXdMb2NhbGVzWzBdLmNvZGUgOiAnZW4nXG4gIGxldCBhbGxSYXdMb2NhbGVzID0gZ2xvYmFsTG9jYWxlcy5jb25jYXQoZXhwbGljaXRSYXdMb2NhbGVzKVxuICBsZXQgcmF3TG9jYWxlTWFwOiBMb2NhbGVJbnB1dE1hcCA9IHtcbiAgICBlbjogUkFXX0VOX0xPQ0FMRSwgLy8gbmVjZXNzYXJ5P1xuICB9XG5cbiAgZm9yIChsZXQgcmF3TG9jYWxlIG9mIGFsbFJhd0xvY2FsZXMpIHtcbiAgICByYXdMb2NhbGVNYXBbcmF3TG9jYWxlLmNvZGVdID0gcmF3TG9jYWxlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hcDogcmF3TG9jYWxlTWFwLFxuICAgIGRlZmF1bHRDb2RlLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExvY2FsZShpbnB1dFNpbmd1bGFyOiBMb2NhbGVTaW5ndWxhckFyZywgYXZhaWxhYmxlOiBMb2NhbGVJbnB1dE1hcCkge1xuICBpZiAodHlwZW9mIGlucHV0U2luZ3VsYXIgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGlucHV0U2luZ3VsYXIpKSB7XG4gICAgcmV0dXJuIHBhcnNlTG9jYWxlKFxuICAgICAgaW5wdXRTaW5ndWxhci5jb2RlLFxuICAgICAgW2lucHV0U2luZ3VsYXIuY29kZV0sXG4gICAgICBpbnB1dFNpbmd1bGFyLFxuICAgIClcbiAgfVxuICByZXR1cm4gcXVlcnlMb2NhbGUoaW5wdXRTaW5ndWxhciwgYXZhaWxhYmxlKVxufVxuXG5mdW5jdGlvbiBxdWVyeUxvY2FsZShjb2RlQXJnOiBMb2NhbGVDb2RlQXJnLCBhdmFpbGFibGU6IExvY2FsZUlucHV0TWFwKTogTG9jYWxlIHtcbiAgbGV0IGNvZGVzID0gW10uY29uY2F0KGNvZGVBcmcgfHwgW10pIC8vIHdpbGwgY29udmVydCB0byBhcnJheVxuICBsZXQgcmF3ID0gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkgfHwgUkFXX0VOX0xPQ0FMRVxuXG4gIHJldHVybiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KVxufVxuXG5mdW5jdGlvbiBxdWVyeVJhd0xvY2FsZShjb2Rlczogc3RyaW5nW10sIGF2YWlsYWJsZTogTG9jYWxlSW5wdXRNYXApOiBMb2NhbGVJbnB1dCB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBsZXQgcGFydHMgPSBjb2Rlc1tpXS50b0xvY2FsZUxvd2VyQ2FzZSgpLnNwbGl0KCctJylcblxuICAgIGZvciAobGV0IGogPSBwYXJ0cy5sZW5ndGg7IGogPiAwOyBqIC09IDEpIHtcbiAgICAgIGxldCBzaW1wbGVJZCA9IHBhcnRzLnNsaWNlKDAsIGopLmpvaW4oJy0nKVxuXG4gICAgICBpZiAoYXZhaWxhYmxlW3NpbXBsZUlkXSkge1xuICAgICAgICByZXR1cm4gYXZhaWxhYmxlW3NpbXBsZUlkXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBwYXJzZUxvY2FsZShjb2RlQXJnOiBMb2NhbGVDb2RlQXJnLCBjb2Rlczogc3RyaW5nW10sIHJhdzogTG9jYWxlSW5wdXQpOiBMb2NhbGUge1xuICBsZXQgbWVyZ2VkID0gbWVyZ2VQcm9wcyhbUkFXX0VOX0xPQ0FMRSwgcmF3XSwgWydidXR0b25UZXh0J10pXG5cbiAgZGVsZXRlIG1lcmdlZC5jb2RlIC8vIGRvbid0IHdhbnQgdGhpcyBwYXJ0IG9mIHRoZSBvcHRpb25zXG4gIGxldCB7IHdlZWsgfSA9IG1lcmdlZFxuICBkZWxldGUgbWVyZ2VkLndlZWtcblxuICByZXR1cm4ge1xuICAgIGNvZGVBcmcsXG4gICAgY29kZXMsXG4gICAgd2VlayxcbiAgICBzaW1wbGVOdW1iZXJGb3JtYXQ6IG5ldyBJbnRsLk51bWJlckZvcm1hdChjb2RlQXJnKSxcbiAgICBvcHRpb25zOiBtZXJnZWQsXG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVFbnYgfSBmcm9tICcuL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgY3JlYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi9kYXRlbGliL2Zvcm1hdHRpbmcnXG5pbXBvcnQgeyBOYXRpdmVGb3JtYXR0ZXJPcHRpb25zIH0gZnJvbSAnLi9kYXRlbGliL2Zvcm1hdHRpbmctbmF0aXZlJ1xuaW1wb3J0IHsgb3JnYW5pemVSYXdMb2NhbGVzLCBidWlsZExvY2FsZSB9IGZyb20gJy4vZGF0ZWxpYi9sb2NhbGUnXG5pbXBvcnQgeyBCQVNFX09QVElPTl9ERUZBVUxUUyB9IGZyb20gJy4vb3B0aW9ucydcblxuLy8gcHVibGljXG5pbXBvcnQgeyBEYXRlSW5wdXQgfSBmcm9tICcuL2FwaS10eXBlLWRlcHMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0RGF0ZU9wdGlvbnMgZXh0ZW5kcyBOYXRpdmVGb3JtYXR0ZXJPcHRpb25zIHtcbiAgbG9jYWxlPzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0UmFuZ2VPcHRpb25zIGV4dGVuZHMgRm9ybWF0RGF0ZU9wdGlvbnMge1xuICBzZXBhcmF0b3I/OiBzdHJpbmdcbiAgaXNFbmRFeGNsdXNpdmU/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlKGRhdGVJbnB1dDogRGF0ZUlucHV0LCBvcHRpb25zOiBGb3JtYXREYXRlT3B0aW9ucyA9IHt9KSB7XG4gIGxldCBkYXRlRW52ID0gYnVpbGREYXRlRW52KG9wdGlvbnMpXG4gIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucylcbiAgbGV0IGRhdGVNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGRhdGVJbnB1dClcblxuICBpZiAoIWRhdGVNZXRhKSB7IC8vIFRPRE86IHdhcm5pbmc/XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZU1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICBmb3JjZWRUem86IGRhdGVNZXRhLmZvcmNlZFR6byxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJhbmdlKFxuICBzdGFydElucHV0OiBEYXRlSW5wdXQsXG4gIGVuZElucHV0OiBEYXRlSW5wdXQsXG4gIG9wdGlvbnM6IEZvcm1hdFJhbmdlT3B0aW9ucywgLy8gbWl4dHVyZSBvZiBlbnYgYW5kIGZvcm1hdHRlciBzZXR0aW5nc1xuKSB7XG4gIGxldCBkYXRlRW52ID0gYnVpbGREYXRlRW52KHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zID8gb3B0aW9ucyA6IHt9KSAvLyBwYXNzIGluIGlmIG5vbi1udWxsIG9iamVjdFxuICBsZXQgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMpXG4gIGxldCBzdGFydE1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhcnRJbnB1dClcbiAgbGV0IGVuZE1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZW5kSW5wdXQpXG5cbiAgaWYgKCFzdGFydE1ldGEgfHwgIWVuZE1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHN0YXJ0TWV0YS5tYXJrZXIsIGVuZE1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhLmZvcmNlZFR6byxcbiAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEuZm9yY2VkVHpvLFxuICAgIGlzRW5kRXhjbHVzaXZlOiBvcHRpb25zLmlzRW5kRXhjbHVzaXZlLFxuICAgIGRlZmF1bHRTZXBhcmF0b3I6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmRlZmF1bHRSYW5nZVNlcGFyYXRvcixcbiAgfSlcbn1cblxuLy8gVE9ETzogbW9yZSBEUlkgYW5kIG9wdGltaXplZFxuZnVuY3Rpb24gYnVpbGREYXRlRW52KHNldHRpbmdzOiBGb3JtYXRSYW5nZU9wdGlvbnMpIHtcbiAgbGV0IGxvY2FsZSA9IGJ1aWxkTG9jYWxlKHNldHRpbmdzLmxvY2FsZSB8fCAnZW4nLCBvcmdhbml6ZVJhd0xvY2FsZXMoW10pLm1hcCkgLy8gVE9ETzogZG9uJ3QgaGFyZGNvZGUgJ2VuJyBldmVyeXdoZXJlXG5cbiAgcmV0dXJuIG5ldyBEYXRlRW52KHtcbiAgICB0aW1lWm9uZTogQkFTRV9PUFRJT05fREVGQVVMVFMudGltZVpvbmUsXG4gICAgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyxcbiAgICAuLi5zZXR0aW5ncyxcbiAgICBsb2NhbGUsXG4gIH0pXG59XG4iLCJpbXBvcnQgeyBFdmVudElucHV0IH0gZnJvbSAnLi9ldmVudC1wYXJzZSdcbmltcG9ydCB7IEV2ZW50U3RvcmUsIHBhcnNlRXZlbnRzIH0gZnJvbSAnLi9ldmVudC1zdG9yZSdcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcblxuLypcblV0aWxzIGZvciBjb252ZXJ0aW5nIHJhdyBidXNpbmVzcyBob3VyIGlucHV0IGludG8gYW4gRXZlbnRTdG9yZSxcbmZvciBib3RoIHJlbmRlcmluZyBhbmQgdGhlIGNvbnN0cmFpbnQgc3lzdGVtLlxuKi9cblxuZXhwb3J0IHR5cGUgQnVzaW5lc3NIb3Vyc0lucHV0ID0gYm9vbGVhbiB8IEV2ZW50SW5wdXQgfCBFdmVudElucHV0W11cblxuY29uc3QgREVGX0RFRkFVTFRTID0ge1xuICBzdGFydFRpbWU6ICcwOTowMCcsXG4gIGVuZFRpbWU6ICcxNzowMCcsXG4gIGRheXNPZldlZWs6IFsxLCAyLCAzLCA0LCA1XSwgLy8gbW9uZGF5IC0gZnJpZGF5XG4gIGRpc3BsYXk6ICdpbnZlcnNlLWJhY2tncm91bmQnLFxuICBjbGFzc05hbWVzOiAnZmMtbm9uLWJ1c2luZXNzJyxcbiAgZ3JvdXBJZDogJ19idXNpbmVzc0hvdXJzJywgLy8gc28gbXVsdGlwbGUgZGVmcyBnZXQgZ3JvdXBlZFxufVxuXG4vKlxuVE9ETzogcGFzcyBhcm91bmQgYXMgRXZlbnREZWZIYXNoISEhXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQnVzaW5lc3NIb3VycyhpbnB1dDogQnVzaW5lc3NIb3Vyc0lucHV0LCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudFN0b3JlIHtcbiAgcmV0dXJuIHBhcnNlRXZlbnRzKFxuICAgIHJlZmluZUlucHV0cyhpbnB1dCksXG4gICAgbnVsbCxcbiAgICBjb250ZXh0LFxuICApXG59XG5cbmZ1bmN0aW9uIHJlZmluZUlucHV0cyhpbnB1dDogQnVzaW5lc3NIb3Vyc0lucHV0KSB7XG4gIGxldCByYXdEZWZzXG5cbiAgaWYgKGlucHV0ID09PSB0cnVlKSB7XG4gICAgcmF3RGVmcyA9IFt7fV0gLy8gd2lsbCBnZXQgREVGX0RFRkFVTFRTIHZlcmJhdGltXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAvLyBpZiBzcGVjaWZ5aW5nIGFuIGFycmF5LCBldmVyeSBzdWItZGVmaW5pdGlvbiBORUVEUyBhIGRheS1vZi13ZWVrXG4gICAgcmF3RGVmcyA9IGlucHV0LmZpbHRlcigocmF3RGVmKSA9PiByYXdEZWYuZGF5c09mV2VlaylcbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgIHJhd0RlZnMgPSBbaW5wdXRdXG4gIH0gZWxzZSB7IC8vIGlzIHByb2JhYmx5IGZhbHNlXG4gICAgcmF3RGVmcyA9IFtdXG4gIH1cblxuICByYXdEZWZzID0gcmF3RGVmcy5tYXAoKHJhd0RlZikgPT4gKHsgLi4uREVGX0RFRkFVTFRTLCAuLi5yYXdEZWYgfSkpXG5cbiAgcmV0dXJuIHJhd0RlZnNcbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgUG9pbnQge1xuICBsZWZ0OiBudW1iZXJcbiAgdG9wOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWN0IHtcbiAgbGVmdDogbnVtYmVyXG4gIHJpZ2h0OiBudW1iZXJcbiAgdG9wOiBudW1iZXJcbiAgYm90dG9tOiBudW1iZXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50SW5zaWRlUmVjdChwb2ludDogUG9pbnQsIHJlY3Q6IFJlY3QpOiBib29sZWFuIHtcbiAgcmV0dXJuIHBvaW50LmxlZnQgPj0gcmVjdC5sZWZ0ICYmXG4gICAgcG9pbnQubGVmdCA8IHJlY3QucmlnaHQgJiZcbiAgICBwb2ludC50b3AgPj0gcmVjdC50b3AgJiZcbiAgICBwb2ludC50b3AgPCByZWN0LmJvdHRvbVxufVxuXG4vLyBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB0aGF0IGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByZWN0YW5nbGVzLiBJZiB0aGV5IGRvbid0IGludGVyc2VjdCwgcmV0dXJucyBmYWxzZVxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdFJlY3RzKHJlY3QxOiBSZWN0LCByZWN0MjogUmVjdCk6IFJlY3QgfCBmYWxzZSB7XG4gIGxldCByZXMgPSB7XG4gICAgbGVmdDogTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCksXG4gICAgcmlnaHQ6IE1hdGgubWluKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCksXG4gICAgdG9wOiBNYXRoLm1heChyZWN0MS50b3AsIHJlY3QyLnRvcCksXG4gICAgYm90dG9tOiBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSksXG4gIH1cblxuICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZVJlY3QocmVjdDogUmVjdCwgZGVsdGFYOiBudW1iZXIsIGRlbHRhWTogbnVtYmVyKTogUmVjdCB7XG4gIHJldHVybiB7XG4gICAgbGVmdDogcmVjdC5sZWZ0ICsgZGVsdGFYLFxuICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgZGVsdGFYLFxuICAgIHRvcDogcmVjdC50b3AgKyBkZWx0YVksXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSArIGRlbHRhWSxcbiAgfVxufVxuXG4vLyBSZXR1cm5zIGEgbmV3IHBvaW50IHRoYXQgd2lsbCBoYXZlIGJlZW4gbW92ZWQgdG8gcmVzaWRlIHdpdGhpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5leHBvcnQgZnVuY3Rpb24gY29uc3RyYWluUG9pbnQocG9pbnQ6IFBvaW50LCByZWN0OiBSZWN0KTogUG9pbnQge1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LmxlZnQsIHJlY3QubGVmdCksIHJlY3QucmlnaHQpLFxuICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKSxcbiAgfVxufVxuXG4vLyBSZXR1cm5zIGEgcG9pbnQgdGhhdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3Q6IFJlY3QpOiBQb2ludCB7XG4gIHJldHVybiB7XG4gICAgbGVmdDogKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMixcbiAgICB0b3A6IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDIsXG4gIH1cbn1cblxuLy8gU3VidHJhY3RzIHBvaW50MidzIGNvb3JkaW5hdGVzIGZyb20gcG9pbnQxJ3MgY29vcmRpbmF0ZXMsIHJldHVybmluZyBhIGRlbHRhXG5leHBvcnQgZnVuY3Rpb24gZGlmZlBvaW50cyhwb2ludDE6IFBvaW50LCBwb2ludDI6IFBvaW50KTogUG9pbnQge1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXG4gICAgdG9wOiBwb2ludDEudG9wIC0gcG9pbnQyLnRvcCxcbiAgfVxufVxuIiwibGV0IGNhblZHcm93V2l0aGluQ2VsbDogYm9vbGVhblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICBpZiAoY2FuVkdyb3dXaXRoaW5DZWxsID09IG51bGwpIHtcbiAgICBjYW5WR3Jvd1dpdGhpbkNlbGwgPSBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKClcbiAgfVxuICByZXR1cm4gY2FuVkdyb3dXaXRoaW5DZWxsXG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDYW5WR3Jvd1dpdGhpbkNlbGwoKSB7XG4gIC8vIGZvciBTU1IsIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBjYWxsIGltbWVkaWF0ZWx5IGF0IHRvcC1sZXZlbFxuICAvLyBUT0RPOiBqdXN0IG1ha2UgdGhpcyBsb2dpYyBleGVjdXRlIHRvcC1sZXZlbCwgaW1tZWRpYXRlbHksIGluc3RlYWQgb2YgZG9pbmcgbGF6aWx5XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICBlbC5zdHlsZS50b3AgPSAnMHB4J1xuICBlbC5zdHlsZS5sZWZ0ID0gJzBweCdcbiAgZWwuaW5uZXJIVE1MID0gJzx0YWJsZT48dHI+PHRkPjxkaXY+PC9kaXY+PC90ZD48L3RyPjwvdGFibGU+J1xuICBlbC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpLnN0eWxlLmhlaWdodCA9ICcxMDBweCdcbiAgZWwucXVlcnlTZWxlY3RvcignZGl2Jykuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbClcblxuICBsZXQgZGl2ID0gZWwucXVlcnlTZWxlY3RvcignZGl2JylcbiAgbGV0IHBvc3NpYmxlID0gZGl2Lm9mZnNldEhlaWdodCA+IDBcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbClcbiAgcmV0dXJuIHBvc3NpYmxlXG59XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJ1xuaW1wb3J0IHsgRXZlbnRTdG9yZSwgY3JlYXRlRW1wdHlFdmVudFN0b3JlIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zdG9yZSdcbmltcG9ydCB7IEV2ZW50RGVmIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1kZWYnXG5pbXBvcnQgeyBFdmVudEludGVyYWN0aW9uU3RhdGUgfSBmcm9tICcuLi9pbnRlcmFjdGlvbnMvZXZlbnQtaW50ZXJhY3Rpb24tc3RhdGUnXG5pbXBvcnQgeyBtYXBIYXNoIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnLi4vdXRpbC9tZW1vaXplJ1xuaW1wb3J0IHsgRXZlbnRVaUhhc2gsIEV2ZW50VWksIGNvbWJpbmVFdmVudFVpcyB9IGZyb20gJy4vZXZlbnQtdWknXG5pbXBvcnQgeyBEYXRlU3BhbiB9IGZyb20gJy4uL3N0cnVjdHMvZGF0ZS1zcGFuJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFNwbGl0dGFibGVQcm9wcyB7XG4gIGJ1c2luZXNzSG91cnM6IEV2ZW50U3RvcmUgfCBudWxsIC8vIGlzIHRoaXMgcmVhbGx5IGFsbG93ZWQgdG8gYmUgbnVsbD9cbiAgZGF0ZVNlbGVjdGlvbjogRGF0ZVNwYW4gfCBudWxsXG4gIGV2ZW50U3RvcmU6IEV2ZW50U3RvcmVcbiAgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaFxuICBldmVudFNlbGVjdGlvbjogc3RyaW5nXG4gIGV2ZW50RHJhZzogRXZlbnRJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBldmVudFJlc2l6ZTogRXZlbnRJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxufVxuXG5jb25zdCBFTVBUWV9FVkVOVF9TVE9SRSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpIC8vIGZvciBwdXJlY29tcG9uZW50cy4gVE9ETzoga2VlcCBlbHNld2hlcmVcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNwbGl0dGVyPFByb3BzVHlwZSBleHRlbmRzIFNwbGl0dGFibGVQcm9wcyA9IFNwbGl0dGFibGVQcm9wcz4ge1xuICBwcml2YXRlIGdldEtleXNGb3JFdmVudERlZnMgPSBtZW1vaXplKHRoaXMuX2dldEtleXNGb3JFdmVudERlZnMpXG4gIHByaXZhdGUgc3BsaXREYXRlU2VsZWN0aW9uID0gbWVtb2l6ZSh0aGlzLl9zcGxpdERhdGVTcGFuKVxuICBwcml2YXRlIHNwbGl0RXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc3BsaXRFdmVudFN0b3JlKVxuICBwcml2YXRlIHNwbGl0SW5kaXZpZHVhbFVpID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEluZGl2aWR1YWxVaSlcbiAgcHJpdmF0ZSBzcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc3BsaXRJbnRlcmFjdGlvbilcbiAgcHJpdmF0ZSBzcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEludGVyYWN0aW9uKVxuICBwcml2YXRlIGV2ZW50VWlCdWlsZGVycyA9IHt9IC8vIFRPRE86IHR5cGVzY3JpcHQgcHJvdGVjdGlvblxuXG4gIGFic3RyYWN0IGdldEtleUluZm8ocHJvcHM6IFByb3BzVHlwZSk6IHsgW2tleTogc3RyaW5nXTogeyB1aT86IEV2ZW50VWksIGJ1c2luZXNzSG91cnM/OiBFdmVudFN0b3JlIH0gfVxuICBhYnN0cmFjdCBnZXRLZXlzRm9yRGF0ZVNwYW4oZGF0ZVNwYW46IERhdGVTcGFuKTogc3RyaW5nW11cbiAgYWJzdHJhY3QgZ2V0S2V5c0ZvckV2ZW50RGVmKGV2ZW50RGVmOiBFdmVudERlZik6IHN0cmluZ1tdXG5cbiAgc3BsaXRQcm9wcyhwcm9wczogUHJvcHNUeXBlKTogeyBba2V5OiBzdHJpbmddOiBTcGxpdHRhYmxlUHJvcHMgfSB7XG4gICAgbGV0IGtleUluZm9zID0gdGhpcy5nZXRLZXlJbmZvKHByb3BzKVxuICAgIGxldCBkZWZLZXlzID0gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWZzKHByb3BzLmV2ZW50U3RvcmUpXG4gICAgbGV0IGRhdGVTZWxlY3Rpb25zID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbilcbiAgICBsZXQgaW5kaXZpZHVhbFVpID0gdGhpcy5zcGxpdEluZGl2aWR1YWxVaShwcm9wcy5ldmVudFVpQmFzZXMsIGRlZktleXMpIC8vIHRoZSBpbmRpdmlkdWFsICpiYXNlcypcbiAgICBsZXQgZXZlbnRTdG9yZXMgPSB0aGlzLnNwbGl0RXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBkZWZLZXlzKVxuICAgIGxldCBldmVudERyYWdzID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpXG4gICAgbGV0IGV2ZW50UmVzaXplcyA9IHRoaXMuc3BsaXRFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSlcbiAgICBsZXQgc3BsaXRQcm9wczogeyBba2V5OiBzdHJpbmddOiBTcGxpdHRhYmxlUHJvcHMgfSA9IHt9XG5cbiAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IG1hcEhhc2goa2V5SW5mb3MsIChpbmZvLCBrZXkpID0+IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV0gfHwgbWVtb2l6ZShidWlsZEV2ZW50VWlGb3JLZXkpKVxuXG4gICAgZm9yIChsZXQga2V5IGluIGtleUluZm9zKSB7XG4gICAgICBsZXQga2V5SW5mbyA9IGtleUluZm9zW2tleV1cbiAgICAgIGxldCBldmVudFN0b3JlID0gZXZlbnRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRVxuICAgICAgbGV0IGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV1cblxuICAgICAgc3BsaXRQcm9wc1trZXldID0ge1xuICAgICAgICBidXNpbmVzc0hvdXJzOiBrZXlJbmZvLmJ1c2luZXNzSG91cnMgfHwgcHJvcHMuYnVzaW5lc3NIb3VycyxcbiAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxuICAgICAgICBldmVudFN0b3JlLFxuICAgICAgICBldmVudFVpQmFzZXM6IGJ1aWxkRXZlbnRVaShwcm9wcy5ldmVudFVpQmFzZXNbJyddLCBrZXlJbmZvLnVpLCBpbmRpdmlkdWFsVWlba2V5XSksXG4gICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxuICAgICAgICBldmVudERyYWc6IGV2ZW50RHJhZ3Nba2V5XSB8fCBudWxsLFxuICAgICAgICBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVzW2tleV0gfHwgbnVsbCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRQcm9wc1xuICB9XG5cbiAgcHJpdmF0ZSBfc3BsaXREYXRlU3BhbihkYXRlU3BhbjogRGF0ZVNwYW4gfCBudWxsKSB7XG4gICAgbGV0IGRhdGVTcGFucyA9IHt9XG5cbiAgICBpZiAoZGF0ZVNwYW4pIHtcbiAgICAgIGxldCBrZXlzID0gdGhpcy5nZXRLZXlzRm9yRGF0ZVNwYW4oZGF0ZVNwYW4pXG5cbiAgICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGRhdGVTcGFuc1trZXldID0gZGF0ZVNwYW5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZVNwYW5zXG4gIH1cblxuICBwcml2YXRlIF9nZXRLZXlzRm9yRXZlbnREZWZzKGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUpIHtcbiAgICByZXR1cm4gbWFwSGFzaChldmVudFN0b3JlLmRlZnMsIChldmVudERlZjogRXZlbnREZWYpID0+IHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmKGV2ZW50RGVmKSlcbiAgfVxuXG4gIHByaXZhdGUgX3NwbGl0RXZlbnRTdG9yZShldmVudFN0b3JlOiBFdmVudFN0b3JlLCBkZWZLZXlzKTogeyBba2V5OiBzdHJpbmddOiBFdmVudFN0b3JlIH0ge1xuICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZVxuICAgIGxldCBzcGxpdFN0b3JlcyA9IHt9XG5cbiAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tkZWZJZF0pIHtcbiAgICAgICAgaWYgKCFzcGxpdFN0b3Jlc1trZXldKSB7XG4gICAgICAgICAgc3BsaXRTdG9yZXNba2V5XSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpXG4gICAgICAgIH1cblxuICAgICAgICBzcGxpdFN0b3Jlc1trZXldLmRlZnNbZGVmSWRdID0gZGVmc1tkZWZJZF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdXG5cbiAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2luc3RhbmNlLmRlZklkXSkge1xuICAgICAgICBpZiAoc3BsaXRTdG9yZXNba2V5XSkgeyAvLyBtdXN0IGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldLmluc3RhbmNlc1tpbnN0YW5jZUlkXSA9IGluc3RhbmNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRTdG9yZXNcbiAgfVxuXG4gIHByaXZhdGUgX3NwbGl0SW5kaXZpZHVhbFVpKGV2ZW50VWlCYXNlczogRXZlbnRVaUhhc2gsIGRlZktleXMpOiB7IFtrZXk6IHN0cmluZ106IEV2ZW50VWlIYXNoIH0ge1xuICAgIGxldCBzcGxpdEhhc2hlczogeyBba2V5OiBzdHJpbmddOiBFdmVudFVpSGFzaCB9ID0ge31cblxuICAgIGZvciAobGV0IGRlZklkIGluIGV2ZW50VWlCYXNlcykge1xuICAgICAgaWYgKGRlZklkKSB7IC8vIG5vdCB0aGUgJycga2V5XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2RlZklkXSkge1xuICAgICAgICAgIGlmICghc3BsaXRIYXNoZXNba2V5XSkge1xuICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XSA9IHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3BsaXRIYXNoZXNba2V5XVtkZWZJZF0gPSBldmVudFVpQmFzZXNbZGVmSWRdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRIYXNoZXNcbiAgfVxuXG4gIHByaXZhdGUgX3NwbGl0SW50ZXJhY3Rpb24oaW50ZXJhY3Rpb246IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB8IG51bGwpOiB7IFtrZXk6IHN0cmluZ106IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IHtcbiAgICBsZXQgc3BsaXRTdGF0ZXM6IHsgW2tleTogc3RyaW5nXTogRXZlbnRJbnRlcmFjdGlvblN0YXRlIH0gPSB7fVxuXG4gICAgaWYgKGludGVyYWN0aW9uKSB7XG4gICAgICBsZXQgYWZmZWN0ZWRTdG9yZXMgPSB0aGlzLl9zcGxpdEV2ZW50U3RvcmUoXG4gICAgICAgIGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzKSwgLy8gY2FuJ3QgdXNlIGNhY2hlZC4gbWlnaHQgYmUgZXZlbnRzIGZyb20gb3RoZXIgY2FsZW5kYXJcbiAgICAgIClcblxuICAgICAgLy8gY2FuJ3QgcmVseSBvbiBkZWZLZXlzIGJlY2F1c2UgZXZlbnQgZGF0YSBpcyBtdXRhdGVkXG4gICAgICBsZXQgbXV0YXRlZEtleXNCeURlZklkID0gdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzKVxuICAgICAgbGV0IG11dGF0ZWRTdG9yZXMgPSB0aGlzLl9zcGxpdEV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgbXV0YXRlZEtleXNCeURlZklkKVxuXG4gICAgICBsZXQgcG9wdWxhdGUgPSAoa2V5KSA9PiB7XG4gICAgICAgIGlmICghc3BsaXRTdGF0ZXNba2V5XSkge1xuICAgICAgICAgIHNwbGl0U3RhdGVzW2tleV0gPSB7XG4gICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogYWZmZWN0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGtleSBpbiBhZmZlY3RlZFN0b3Jlcykge1xuICAgICAgICBwb3B1bGF0ZShrZXkpXG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGtleSBpbiBtdXRhdGVkU3RvcmVzKSB7XG4gICAgICAgIHBvcHVsYXRlKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRTdGF0ZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEV2ZW50VWlGb3JLZXkoYWxsVWk6IEV2ZW50VWkgfCBudWxsLCBldmVudFVpRm9yS2V5OiBFdmVudFVpIHwgbnVsbCwgaW5kaXZpZHVhbFVpOiBFdmVudFVpSGFzaCB8IG51bGwpIHtcbiAgbGV0IGJhc2VQYXJ0cyA9IFtdXG5cbiAgaWYgKGFsbFVpKSB7XG4gICAgYmFzZVBhcnRzLnB1c2goYWxsVWkpXG4gIH1cblxuICBpZiAoZXZlbnRVaUZvcktleSkge1xuICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpXG4gIH1cblxuICBsZXQgc3R1ZmYgPSB7XG4gICAgJyc6IGNvbWJpbmVFdmVudFVpcyhiYXNlUGFydHMpLFxuICB9XG5cbiAgaWYgKGluZGl2aWR1YWxVaSkge1xuICAgIF9fYXNzaWduKHN0dWZmLCBpbmRpdmlkdWFsVWkpXG4gIH1cblxuICByZXR1cm4gc3R1ZmZcbn1cbiIsImltcG9ydCB7IERhdGVNYXJrZXIsIERBWV9JRFMgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IHJhbmdlQ29udGFpbnNNYXJrZXIsIERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBUaGVtZSB9IGZyb20gJy4uL3RoZW1lL1RoZW1lJ1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVNZXRhIHtcbiAgZG93OiBudW1iZXJcbiAgaXNEaXNhYmxlZDogYm9vbGVhblxuICBpc090aGVyOiBib29sZWFuIC8vIGxpa2UsIGlzIGl0IGluIHRoZSBub24tY3VycmVudCBcIm90aGVyXCIgbW9udGhcbiAgaXNUb2RheTogYm9vbGVhblxuICBpc1Bhc3Q6IGJvb2xlYW5cbiAgaXNGdXR1cmU6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGVNZXRhKGRhdGU6IERhdGVNYXJrZXIsIHRvZGF5UmFuZ2U/OiBEYXRlUmFuZ2UsIG5vd0RhdGU/OiBEYXRlTWFya2VyLCBkYXRlUHJvZmlsZT86IERhdGVQcm9maWxlKTogRGF0ZU1ldGEge1xuICByZXR1cm4ge1xuICAgIGRvdzogZGF0ZS5nZXRVVENEYXkoKSxcbiAgICBpc0Rpc2FibGVkOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBkYXRlKSksXG4gICAgaXNPdGhlcjogQm9vbGVhbihkYXRlUHJvZmlsZSAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGUpKSxcbiAgICBpc1RvZGF5OiBCb29sZWFuKHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBkYXRlKSksXG4gICAgaXNQYXN0OiBCb29sZWFuKG5vd0RhdGUgPyAoZGF0ZSA8IG5vd0RhdGUpIDogdG9kYXlSYW5nZSA/IChkYXRlIDwgdG9kYXlSYW5nZS5zdGFydCkgOiBmYWxzZSksXG4gICAgaXNGdXR1cmU6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlID4gbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPj0gdG9kYXlSYW5nZS5lbmQpIDogZmFsc2UpLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXlDbGFzc05hbWVzKG1ldGE6IERhdGVNZXRhLCB0aGVtZTogVGhlbWUpIHtcbiAgbGV0IGNsYXNzTmFtZXM6IHN0cmluZ1tdID0gW1xuICAgICdmYy1kYXknLFxuICAgIGBmYy1kYXktJHtEQVlfSURTW21ldGEuZG93XX1gLFxuICBdXG5cbiAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LWRpc2FibGVkJylcbiAgfSBlbHNlIHtcbiAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS10b2RheScpXG4gICAgICBjbGFzc05hbWVzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpXG4gICAgfVxuXG4gICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1wYXN0JylcbiAgICB9XG5cbiAgICBpZiAobWV0YS5pc0Z1dHVyZSkge1xuICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktZnV0dXJlJylcbiAgICB9XG5cbiAgICBpZiAobWV0YS5pc090aGVyKSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1vdGhlcicpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsYXNzTmFtZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNsb3RDbGFzc05hbWVzKG1ldGE6IERhdGVNZXRhLCB0aGVtZTogVGhlbWUpIHtcbiAgbGV0IGNsYXNzTmFtZXM6IHN0cmluZ1tdID0gW1xuICAgICdmYy1zbG90JyxcbiAgICBgZmMtc2xvdC0ke0RBWV9JRFNbbWV0YS5kb3ddfWAsXG4gIF1cblxuICBpZiAobWV0YS5pc0Rpc2FibGVkKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LWRpc2FibGVkJylcbiAgfSBlbHNlIHtcbiAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtdG9kYXknKVxuICAgICAgY2xhc3NOYW1lcy5wdXNoKHRoZW1lLmdldENsYXNzKCd0b2RheScpKVxuICAgIH1cblxuICAgIGlmIChtZXRhLmlzUGFzdCkge1xuICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LXBhc3QnKVxuICAgIH1cblxuICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZnV0dXJlJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xhc3NOYW1lc1xufVxuIiwiaW1wb3J0IHsgZm9ybWF0RGF5U3RyaW5nIH0gZnJvbSAnLi4vZGF0ZWxpYi9mb3JtYXR0aW5nLXV0aWxzJ1xuaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGROYXZMaW5rRGF0YShkYXRlOiBEYXRlTWFya2VyLCB0eXBlID0gJ2RheScpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICBkYXRlOiBmb3JtYXREYXlTdHJpbmcoZGF0ZSksXG4gICAgdHlwZSxcbiAgfSlcbn1cbiIsImltcG9ydCB7IHJlbW92ZUVsZW1lbnQsIGFwcGx5U3R5bGUgfSBmcm9tICcuL2RvbS1tYW5pcCdcblxubGV0IF9pc1J0bFNjcm9sbGJhck9uTGVmdDogYm9vbGVhbiB8IG51bGwgPSBudWxsXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHsgLy8gcmVzcG9uc2libGUgZm9yIGNhY2hpbmcgdGhlIGNvbXB1dGF0aW9uXG4gIGlmIChfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPT09IG51bGwpIHtcbiAgICBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQoKVxuICB9XG4gIHJldHVybiBfaXNSdGxTY3JvbGxiYXJPbkxlZnRcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgeyAvLyBjcmVhdGVzIGFuIG9mZnNjcmVlbiB0ZXN0IGVsZW1lbnQsIHRoZW4gcmVtb3ZlcyBpdFxuICBsZXQgb3V0ZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGFwcGx5U3R5bGUob3V0ZXJFbCwge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogLTEwMDAsXG4gICAgbGVmdDogMCxcbiAgICBib3JkZXI6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXG4gICAgZGlyZWN0aW9uOiAncnRsJyxcbiAgfSlcbiAgb3V0ZXJFbC5pbm5lckhUTUwgPSAnPGRpdj48L2Rpdj4nXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlckVsKVxuICBsZXQgaW5uZXJFbCA9IG91dGVyRWwuZmlyc3RDaGlsZCBhcyBIVE1MRWxlbWVudFxuICBsZXQgcmVzID0gaW5uZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4gb3V0ZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0XG5cbiAgcmVtb3ZlRWxlbWVudChvdXRlckVsKVxuICByZXR1cm4gcmVzXG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIFNjcm9sbGJhcldpZHRocyB7XG4gIHg6IG51bWJlclxuICB5OiBudW1iZXIgLy8gVE9ETzogcmVuYW1lIHRvIHZlcnRpY2FsLiBsZXNzIGNvbmZ1c2luZyB3aGVuIGRlYWxpbmcgd2l0aCB3aWR0aC9oZWlnaHQgdmVyYmFnZVxufVxuXG5sZXQgX3Njcm9sbGJhcldpZHRoczogU2Nyb2xsYmFyV2lkdGhzIHwgdW5kZWZpbmVkXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aHMoKSB7IC8vIFRPRE86IHdheSB0byBmb3JjZSByZWNvbXB1dGU/XG4gIGlmICghX3Njcm9sbGJhcldpZHRocykge1xuICAgIF9zY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzKClcbiAgfVxuXG4gIHJldHVybiBfc2Nyb2xsYmFyV2lkdGhzXG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKTogU2Nyb2xsYmFyV2lkdGhzIHtcbiAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJ1xuICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgZWwuc3R5bGUudG9wID0gJy05OTk5cHgnXG4gIGVsLnN0eWxlLmxlZnQgPSAnLTk5OTlweCdcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbClcbiAgbGV0IHJlcyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbClcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbClcbiAgcmV0dXJuIHJlc1xufVxuXG4vLyBXQVJOSU5HOiB3aWxsIGluY2x1ZGUgYm9yZGVyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsOiBIVE1MRWxlbWVudCk6IFNjcm9sbGJhcldpZHRocyB7XG4gIHJldHVybiB7XG4gICAgeDogZWwub2Zmc2V0SGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0LFxuICAgIHk6IGVsLm9mZnNldFdpZHRoIC0gZWwuY2xpZW50V2lkdGgsXG4gIH1cbn1cbiIsImltcG9ydCB7IGludGVyc2VjdFJlY3RzLCBSZWN0IH0gZnJvbSAnLi9nZW9tJ1xuaW1wb3J0IHsgZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQgfSBmcm9tICcuL3Njcm9sbGJhci1zaWRlJ1xuaW1wb3J0IHsgY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsIH0gZnJvbSAnLi9zY3JvbGxiYXItd2lkdGgnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRWRnZUluZm8ge1xuICBib3JkZXJMZWZ0OiBudW1iZXJcbiAgYm9yZGVyUmlnaHQ6IG51bWJlclxuICBib3JkZXJUb3A6IG51bWJlclxuICBib3JkZXJCb3R0b206IG51bWJlclxuICBzY3JvbGxiYXJMZWZ0OiBudW1iZXJcbiAgc2Nyb2xsYmFyUmlnaHQ6IG51bWJlclxuICBzY3JvbGxiYXJCb3R0b206IG51bWJlclxuICBwYWRkaW5nTGVmdD86IG51bWJlclxuICBwYWRkaW5nUmlnaHQ/OiBudW1iZXJcbiAgcGFkZGluZ1RvcD86IG51bWJlclxuICBwYWRkaW5nQm90dG9tPzogbnVtYmVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRWRnZXMoZWw6IEhUTUxFbGVtZW50LCBnZXRQYWRkaW5nID0gZmFsc2UpOiBFZGdlSW5mbyB7IC8vIGNhY2hlIHNvbWVob3c/XG4gIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpXG4gIGxldCBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwXG4gIGxldCBib3JkZXJSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApIHx8IDBcbiAgbGV0IGJvcmRlclRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwXG4gIGxldCBib3JkZXJCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgfHwgMFxuICBsZXQgYmFkU2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKSAvLyBpbmNsdWRlcyBib3JkZXIhXG4gIGxldCBzY3JvbGxiYXJMZWZ0UmlnaHQgPSBiYWRTY3JvbGxiYXJXaWR0aHMueSAtIGJvcmRlckxlZnQgLSBib3JkZXJSaWdodFxuICBsZXQgc2Nyb2xsYmFyQm90dG9tID0gYmFkU2Nyb2xsYmFyV2lkdGhzLnggLSBib3JkZXJUb3AgLSBib3JkZXJCb3R0b21cblxuICBsZXQgcmVzOiBFZGdlSW5mbyA9IHtcbiAgICBib3JkZXJMZWZ0LFxuICAgIGJvcmRlclJpZ2h0LFxuICAgIGJvcmRlclRvcCxcbiAgICBib3JkZXJCb3R0b20sXG4gICAgc2Nyb2xsYmFyQm90dG9tLFxuICAgIHNjcm9sbGJhckxlZnQ6IDAsXG4gICAgc2Nyb2xsYmFyUmlnaHQ6IDAsXG4gIH1cblxuICBpZiAoZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQoKSAmJiBjb21wdXRlZFN0eWxlLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHsgLy8gaXMgdGhlIHNjcm9sbGJhciBvbiB0aGUgbGVmdCBzaWRlP1xuICAgIHJlcy5zY3JvbGxiYXJMZWZ0ID0gc2Nyb2xsYmFyTGVmdFJpZ2h0XG4gIH0gZWxzZSB7XG4gICAgcmVzLnNjcm9sbGJhclJpZ2h0ID0gc2Nyb2xsYmFyTGVmdFJpZ2h0XG4gIH1cblxuICBpZiAoZ2V0UGFkZGluZykge1xuICAgIHJlcy5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQsIDEwKSB8fCAwXG4gICAgcmVzLnBhZGRpbmdSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0LCAxMCkgfHwgMFxuICAgIHJlcy5wYWRkaW5nVG9wID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nVG9wLCAxMCkgfHwgMFxuICAgIHJlcy5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tLCAxMCkgfHwgMFxuICB9XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUlubmVyUmVjdChlbCwgZ29XaXRoaW5QYWRkaW5nID0gZmFsc2UsIGRvRnJvbVdpbmRvd1ZpZXdwb3J0PzogYm9vbGVhbikge1xuICBsZXQgb3V0ZXJSZWN0ID0gZG9Gcm9tV2luZG93Vmlld3BvcnQgPyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IGNvbXB1dGVSZWN0KGVsKVxuICBsZXQgZWRnZXMgPSBjb21wdXRlRWRnZXMoZWwsIGdvV2l0aGluUGFkZGluZylcbiAgbGV0IHJlcyA9IHtcbiAgICBsZWZ0OiBvdXRlclJlY3QubGVmdCArIGVkZ2VzLmJvcmRlckxlZnQgKyBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxuICAgIHJpZ2h0OiBvdXRlclJlY3QucmlnaHQgLSBlZGdlcy5ib3JkZXJSaWdodCAtIGVkZ2VzLnNjcm9sbGJhclJpZ2h0LFxuICAgIHRvcDogb3V0ZXJSZWN0LnRvcCArIGVkZ2VzLmJvcmRlclRvcCxcbiAgICBib3R0b206IG91dGVyUmVjdC5ib3R0b20gLSBlZGdlcy5ib3JkZXJCb3R0b20gLSBlZGdlcy5zY3JvbGxiYXJCb3R0b20sXG4gIH1cblxuICBpZiAoZ29XaXRoaW5QYWRkaW5nKSB7XG4gICAgcmVzLmxlZnQgKz0gZWRnZXMucGFkZGluZ0xlZnRcbiAgICByZXMucmlnaHQgLT0gZWRnZXMucGFkZGluZ1JpZ2h0XG4gICAgcmVzLnRvcCArPSBlZGdlcy5wYWRkaW5nVG9wXG4gICAgcmVzLmJvdHRvbSAtPSBlZGdlcy5wYWRkaW5nQm90dG9tXG4gIH1cblxuICByZXR1cm4gcmVzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUmVjdChlbCk6IFJlY3Qge1xuICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICByaWdodDogcmVjdC5yaWdodCArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICBib3R0b206IHJlY3QuYm90dG9tICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QoZWw6IEhUTUxFbGVtZW50KTogUmVjdCB8IG51bGwge1xuICBsZXQgY2xpcHBpbmdQYXJlbnRzID0gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKVxuICBsZXQgcmVjdDogUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgZm9yIChsZXQgY2xpcHBpbmdQYXJlbnQgb2YgY2xpcHBpbmdQYXJlbnRzKSB7XG4gICAgbGV0IGludGVyc2VjdGlvbiA9IGludGVyc2VjdFJlY3RzKHJlY3QsIGNsaXBwaW5nUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKVxuICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgIHJlY3QgPSBpbnRlcnNlY3Rpb25cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVjdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhlaWdodEFuZE1hcmdpbnMoZWw6IEhUTUxFbGVtZW50KSB7XG4gIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKyBjb21wdXRlVk1hcmdpbnMoZWwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlVk1hcmdpbnMoZWw6IEhUTUxFbGVtZW50KSB7XG4gIGxldCBjb21wdXRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKVxuXG4gIHJldHVybiBwYXJzZUludChjb21wdXRlZC5tYXJnaW5Ub3AsIDEwKSArXG4gICAgcGFyc2VJbnQoY29tcHV0ZWQubWFyZ2luQm90dG9tLCAxMClcbn1cblxuLy8gZG9lcyBub3QgcmV0dXJuIHdpbmRvd1xuZXhwb3J0IGZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbDogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFtdIHtcbiAgbGV0IHBhcmVudHM6IEhUTUxFbGVtZW50W10gPSBbXVxuXG4gIHdoaWxlIChlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7IC8vIHdpbGwgc3RvcCB3aGVuIGdldHMgdG8gZG9jdW1lbnQgb3IgbnVsbFxuICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpXG5cbiAgICBpZiAoY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBpZiAoKC8oYXV0b3xzY3JvbGwpLykudGVzdChjb21wdXRlZFN0eWxlLm92ZXJmbG93ICsgY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1kgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WCkpIHtcbiAgICAgIHBhcmVudHMucHVzaChlbClcbiAgICB9XG5cbiAgICBlbCA9IGVsLnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnRcbiAgfVxuXG4gIHJldHVybiBwYXJlbnRzXG59XG4iLCIvLyBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgYSByZXN1bHQgYXN5bmNocm9ub3VzbHkuXG4vLyB0aGUgZnVuY3Rpb24gY2FuIGVpdGhlciBjYWxsIHBhc3NlZC1pbiBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhbGxiYWNrcyxcbi8vIG9yIGl0IGNhbiByZXR1cm4gYSBwcm9taXNlLlxuLy8gaWYgeW91IG5lZWQgdG8gcGFzcyBhZGRpdGlvbmFsIHBhcmFtcyB0byBmdW5jLCBiaW5kIHRoZW0gZmlyc3QuXG5leHBvcnQgZnVuY3Rpb24gdW5wcm9taXNpZnkoZnVuYywgc3VjY2VzcywgZmFpbHVyZT8pIHtcbiAgLy8gZ3VhcmQgYWdhaW5zdCBzdWNjZXNzL2ZhaWx1cmUgY2FsbGJhY2tzIGJlaW5nIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAvLyBhbmQgZ3VhcmQgYWdhaW5zdCBhIHByb21pc2UgQU5EIGNhbGxiYWNrIGJlaW5nIHVzZWQgdG9nZXRoZXIuXG4gIGxldCBpc1Jlc29sdmVkID0gZmFsc2VcbiAgbGV0IHdyYXBwZWRTdWNjZXNzID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZXNcbiAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlXG4gICAgICBzdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICB9XG4gIH1cbiAgbGV0IHdyYXBwZWRGYWlsdXJlID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZXNcbiAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlXG4gICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICBmYWlsdXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgcmVzID0gZnVuYyh3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpXG4gIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVzLnRoZW4od3JhcHBlZFN1Y2Nlc3MsIHdyYXBwZWRGYWlsdXJlKVxuICB9XG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIEhhbmRsZXJGdW5jVHlwZUhhc2gge1xuICBbZXZlbnROYW1lOiBzdHJpbmddOiAoLi4uYXJnczogYW55W10pID0+IGFueSAvLyB3aXRoIGFsbCBwcm9wZXJ0aWVzIHJlcXVpcmVkXG59XG5cbmV4cG9ydCBjbGFzcyBFbWl0dGVyPEhhbmRsZXJGdW5jcyBleHRlbmRzIEhhbmRsZXJGdW5jVHlwZUhhc2g+IHtcbiAgcHJpdmF0ZSBoYW5kbGVyczogeyBbUHJvcCBpbiBrZXlvZiBIYW5kbGVyRnVuY3NdPzogSGFuZGxlckZ1bmNzW1Byb3BdW10gfSA9IHt9XG5cbiAgcHJpdmF0ZSBvcHRpb25zOiBQYXJ0aWFsPEhhbmRsZXJGdW5jcz5cblxuICBwcml2YXRlIHRoaXNDb250ZXh0OiBhbnkgPSBudWxsXG5cbiAgc2V0VGhpc0NvbnRleHQodGhpc0NvbnRleHQpIHtcbiAgICB0aGlzLnRoaXNDb250ZXh0ID0gdGhpc0NvbnRleHRcbiAgfVxuXG4gIHNldE9wdGlvbnMob3B0aW9uczogUGFydGlhbDxIYW5kbGVyRnVuY3M+KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB9XG5cbiAgb248UHJvcCBleHRlbmRzIGtleW9mIEhhbmRsZXJGdW5jcz4odHlwZTogUHJvcCwgaGFuZGxlcjogSGFuZGxlckZ1bmNzW1Byb3BdKSB7XG4gICAgYWRkVG9IYXNoKHRoaXMuaGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpXG4gIH1cblxuICBvZmY8UHJvcCBleHRlbmRzIGtleW9mIEhhbmRsZXJGdW5jcz4odHlwZTogUHJvcCwgaGFuZGxlcj86IEhhbmRsZXJGdW5jc1tQcm9wXSkge1xuICAgIHJlbW92ZUZyb21IYXNoKHRoaXMuaGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpXG4gIH1cblxuICB0cmlnZ2VyPFByb3AgZXh0ZW5kcyBrZXlvZiBIYW5kbGVyRnVuY3M+KHR5cGU6IFByb3AsIC4uLmFyZ3M6IFBhcmFtZXRlcnM8SGFuZGxlckZ1bmNzW1Byb3BdPikge1xuICAgIGxldCBhdHRhY2hlZEhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1t0eXBlXSB8fCBbXVxuICAgIGxldCBvcHRpb25IYW5kbGVyID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1t0eXBlXVxuICAgIGxldCBoYW5kbGVycyA9IFtdLmNvbmNhdChvcHRpb25IYW5kbGVyIHx8IFtdLCBhdHRhY2hlZEhhbmRsZXJzKVxuXG4gICAgZm9yIChsZXQgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgaGFuZGxlci5hcHBseSh0aGlzLnRoaXNDb250ZXh0LCBhcmdzKVxuICAgIH1cbiAgfVxuXG4gIGhhc0hhbmRsZXJzKHR5cGU6IGtleW9mIEhhbmRsZXJGdW5jcykge1xuICAgIHJldHVybiAodGhpcy5oYW5kbGVyc1t0eXBlXSAmJiB0aGlzLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCkgfHxcbiAgICAgICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zW3R5cGVdKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFRvSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XG4gIChoYXNoW3R5cGVdIHx8IChoYXNoW3R5cGVdID0gW10pKVxuICAgIC5wdXNoKGhhbmRsZXIpXG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZyb21IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXI/KSB7XG4gIGlmIChoYW5kbGVyKSB7XG4gICAgaWYgKGhhc2hbdHlwZV0pIHtcbiAgICAgIGhhc2hbdHlwZV0gPSBoYXNoW3R5cGVdLmZpbHRlcigoZnVuYykgPT4gZnVuYyAhPT0gaGFuZGxlcilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGhhc2hbdHlwZV0gLy8gcmVtb3ZlIGFsbCBoYW5kbGVyIGZ1bmNzIGZvciB0aGlzIHR5cGVcbiAgfVxufVxuIiwiLypcblJlY29yZHMgb2Zmc2V0IGluZm9ybWF0aW9uIGZvciBhIHNldCBvZiBlbGVtZW50cywgcmVsYXRpdmUgdG8gYW4gb3JpZ2luIGVsZW1lbnQuXG5DYW4gcmVjb3JkIHRoZSBsZWZ0L3JpZ2h0IE9SIHRoZSB0b3AvYm90dG9tIE9SIGJvdGguXG5Qcm92aWRlcyBtZXRob2RzIGZvciBxdWVyeWluZyB0aGUgY2FjaGUgYnkgcG9zaXRpb24uXG4qL1xuZXhwb3J0IGNsYXNzIFBvc2l0aW9uQ2FjaGUge1xuICBlbHM6IEhUTUxFbGVtZW50W10gLy8gYXNzdW1lZCB0byBiZSBzaWJsaW5nc1xuICBvcmlnaW5DbGllbnRSZWN0OiBDbGllbnRSZWN0XG5cbiAgLy8gYXJyYXlzIG9mIGNvb3JkaW5hdGVzIChmcm9tIHRvcGxlZnQgb2Ygb3JpZ2luRWwpXG4gIC8vIGNhbGxlciBjYW4gYWNjZXNzIHRoZXNlIGRpcmVjdGx5XG4gIGxlZnRzOiBhbnlcbiAgcmlnaHRzOiBhbnlcbiAgdG9wczogYW55XG4gIGJvdHRvbXM6IGFueVxuXG4gIGNvbnN0cnVjdG9yKG9yaWdpbkVsOiBIVE1MRWxlbWVudCwgZWxzOiBIVE1MRWxlbWVudFtdLCBpc0hvcml6b250YWw6IGJvb2xlYW4sIGlzVmVydGljYWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmVscyA9IGVsc1xuXG4gICAgbGV0IG9yaWdpbkNsaWVudFJlY3QgPSB0aGlzLm9yaWdpbkNsaWVudFJlY3QgPSBvcmlnaW5FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSAvLyByZWxhdGl2ZSB0byB2aWV3cG9ydCB0b3AtbGVmdFxuXG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgdGhpcy5idWlsZEVsSG9yaXpvbnRhbHMob3JpZ2luQ2xpZW50UmVjdC5sZWZ0KVxuICAgIH1cblxuICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICB0aGlzLmJ1aWxkRWxWZXJ0aWNhbHMob3JpZ2luQ2xpZW50UmVjdC50b3ApXG4gICAgfVxuICB9XG5cbiAgLy8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG4gIGJ1aWxkRWxIb3Jpem9udGFscyhvcmlnaW5DbGllbnRMZWZ0OiBudW1iZXIpIHtcbiAgICBsZXQgbGVmdHMgPSBbXVxuICAgIGxldCByaWdodHMgPSBbXVxuXG4gICAgZm9yIChsZXQgZWwgb2YgdGhpcy5lbHMpIHtcbiAgICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGxlZnRzLnB1c2gocmVjdC5sZWZ0IC0gb3JpZ2luQ2xpZW50TGVmdClcbiAgICAgIHJpZ2h0cy5wdXNoKHJlY3QucmlnaHQgLSBvcmlnaW5DbGllbnRMZWZ0KVxuICAgIH1cblxuICAgIHRoaXMubGVmdHMgPSBsZWZ0c1xuICAgIHRoaXMucmlnaHRzID0gcmlnaHRzXG4gIH1cblxuICAvLyBQb3B1bGF0ZXMgdGhlIHRvcC9ib3R0b20gaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcbiAgYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRUb3A6IG51bWJlcikge1xuICAgIGxldCB0b3BzID0gW11cbiAgICBsZXQgYm90dG9tcyA9IFtdXG5cbiAgICBmb3IgKGxldCBlbCBvZiB0aGlzLmVscykge1xuICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgdG9wcy5wdXNoKHJlY3QudG9wIC0gb3JpZ2luQ2xpZW50VG9wKVxuICAgICAgYm90dG9tcy5wdXNoKHJlY3QuYm90dG9tIC0gb3JpZ2luQ2xpZW50VG9wKVxuICAgIH1cblxuICAgIHRoaXMudG9wcyA9IHRvcHNcbiAgICB0aGlzLmJvdHRvbXMgPSBib3R0b21zXG4gIH1cblxuICAvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cbiAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuICBsZWZ0VG9JbmRleChsZWZ0UG9zaXRpb246IG51bWJlcikge1xuICAgIGxldCB7IGxlZnRzLCByaWdodHMgfSA9IHRoaXNcbiAgICBsZXQgbGVuID0gbGVmdHMubGVuZ3RoXG4gICAgbGV0IGlcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKGxlZnRQb3NpdGlvbiA+PSBsZWZ0c1tpXSAmJiBsZWZ0UG9zaXRpb24gPCByaWdodHNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkIC8vIFRPRE86IGJldHRlclxuICB9XG5cbiAgLy8gR2l2ZW4gYSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IHZlcnRpY2FsbHkgaW50ZXJzZWN0cy5cbiAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuICB0b3BUb0luZGV4KHRvcFBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICBsZXQgeyB0b3BzLCBib3R0b21zIH0gPSB0aGlzXG4gICAgbGV0IGxlbiA9IHRvcHMubGVuZ3RoXG4gICAgbGV0IGlcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRvcFBvc2l0aW9uID49IHRvcHNbaV0gJiYgdG9wUG9zaXRpb24gPCBib3R0b21zW2ldKSB7XG4gICAgICAgIHJldHVybiBpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBUT0RPOiBiZXR0ZXJcbiAgfVxuXG4gIC8vIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuICBnZXRXaWR0aChsZWZ0SW5kZXg6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdXG4gIH1cblxuICAvLyBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gIGdldEhlaWdodCh0b3BJbmRleDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLnRvcHNbdG9wSW5kZXhdXG4gIH1cbn1cbiIsIi8qIGVzbGludCBtYXgtY2xhc3Nlcy1wZXItZmlsZTogXCJvZmZcIiAqL1xuXG4vKlxuQW4gb2JqZWN0IGZvciBnZXR0aW5nL3NldHRpbmcgc2Nyb2xsLXJlbGF0ZWQgaW5mb3JtYXRpb24gZm9yIGFuIGVsZW1lbnQuXG5JbnRlcm5hbGx5LCB0aGlzIGlzIGRvbmUgdmVyeSBkaWZmZXJlbnRseSBmb3Igd2luZG93IHZlcnN1cyBET00gZWxlbWVudCxcbnNvIHRoaXMgb2JqZWN0IHNlcnZlcyBhcyBhIGNvbW1vbiBpbnRlcmZhY2UuXG4qL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNjcm9sbENvbnRyb2xsZXIge1xuICBhYnN0cmFjdCBnZXRTY3JvbGxUb3AoKTogbnVtYmVyXG4gIGFic3RyYWN0IGdldFNjcm9sbExlZnQoKTogbnVtYmVyXG4gIGFic3RyYWN0IHNldFNjcm9sbFRvcCh0b3A6IG51bWJlcik6IHZvaWRcbiAgYWJzdHJhY3Qgc2V0U2Nyb2xsTGVmdChsZWZ0OiBudW1iZXIpOiB2b2lkXG4gIGFic3RyYWN0IGdldENsaWVudFdpZHRoKCk6IG51bWJlclxuICBhYnN0cmFjdCBnZXRDbGllbnRIZWlnaHQoKTogbnVtYmVyXG4gIGFic3RyYWN0IGdldFNjcm9sbFdpZHRoKCk6IG51bWJlclxuICBhYnN0cmFjdCBnZXRTY3JvbGxIZWlnaHQoKTogbnVtYmVyXG5cbiAgZ2V0TWF4U2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNjcm9sbEhlaWdodCgpIC0gdGhpcy5nZXRDbGllbnRIZWlnaHQoKVxuICB9XG5cbiAgZ2V0TWF4U2Nyb2xsTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxXaWR0aCgpIC0gdGhpcy5nZXRDbGllbnRXaWR0aCgpXG4gIH1cblxuICBjYW5TY3JvbGxWZXJ0aWNhbGx5KCkge1xuICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbFRvcCgpID4gMFxuICB9XG5cbiAgY2FuU2Nyb2xsSG9yaXpvbnRhbGx5KCkge1xuICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbExlZnQoKSA+IDBcbiAgfVxuXG4gIGNhblNjcm9sbFVwKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpID4gMFxuICB9XG5cbiAgY2FuU2Nyb2xsRG93bigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxUb3AoKSA8IHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKClcbiAgfVxuXG4gIGNhblNjcm9sbExlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpID4gMFxuICB9XG5cbiAgY2FuU2Nyb2xsUmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KClcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIgZXh0ZW5kcyBTY3JvbGxDb250cm9sbGVyIHtcbiAgZWw6IEhUTUxFbGVtZW50XG5cbiAgY29uc3RydWN0b3IoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZWwgPSBlbFxuICB9XG5cbiAgZ2V0U2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFRvcFxuICB9XG5cbiAgZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxMZWZ0XG4gIH1cblxuICBzZXRTY3JvbGxUb3AodG9wOiBudW1iZXIpIHtcbiAgICB0aGlzLmVsLnNjcm9sbFRvcCA9IHRvcFxuICB9XG5cbiAgc2V0U2Nyb2xsTGVmdChsZWZ0OiBudW1iZXIpIHtcbiAgICB0aGlzLmVsLnNjcm9sbExlZnQgPSBsZWZ0XG4gIH1cblxuICBnZXRTY3JvbGxXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxXaWR0aFxuICB9XG5cbiAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbEhlaWdodFxuICB9XG5cbiAgZ2V0Q2xpZW50SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmVsLmNsaWVudEhlaWdodFxuICB9XG5cbiAgZ2V0Q2xpZW50V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50V2lkdGhcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgV2luZG93U2Nyb2xsQ29udHJvbGxlciBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xuICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG5cbiAgZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgICByZXR1cm4gd2luZG93LnBhZ2VYT2Zmc2V0XG4gIH1cblxuICBzZXRTY3JvbGxUb3AobjogbnVtYmVyKSB7XG4gICAgd2luZG93LnNjcm9sbCh3aW5kb3cucGFnZVhPZmZzZXQsIG4pXG4gIH1cblxuICBzZXRTY3JvbGxMZWZ0KG46IG51bWJlcikge1xuICAgIHdpbmRvdy5zY3JvbGwobiwgd2luZG93LnBhZ2VZT2Zmc2V0KVxuICB9XG5cbiAgZ2V0U2Nyb2xsV2lkdGgoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aFxuICB9XG5cbiAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0XG4gIH1cblxuICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgfVxuXG4gIGdldENsaWVudFdpZHRoKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2FsZW5kYXJPcHRpb25zUmVmaW5lZCB9IGZyb20gJy4uL29wdGlvbnMnXG5cbmV4cG9ydCBjbGFzcyBUaGVtZSB7XG4gIC8vIHNldHRpbmdzLiBkZWZhdWx0IHZhbHVlcyBhcmUgc2V0IGFmdGVyIHRoZSBjbGFzc1xuICBjbGFzc2VzOiBhbnlcbiAgaWNvbkNsYXNzZXM6IGFueVxuICBydGxJY29uQ2xhc3NlczogYW55XG4gIGJhc2VJY29uQ2xhc3M6IHN0cmluZyAvLyBjbGFzc05hbWUgdGhhdCBBTEwgaWNvbiBlbGVtZW50cyBmb3IgdGhpcyB0aGVtZSBzaG91bGQgaGF2ZVxuICBpY29uT3ZlcnJpZGVPcHRpb246IGFueSAvLyB0aGUgbmFtZSBvZiB0aGUgc2V0dGluZyB0byB1c2UgZm9yIGljb25zLiB0aGUgc3ViY2xhc3MgbXVzdCBzZXQgdGhpcy5cbiAgaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uOiBhbnkgLy8gdGhlIG5hbWUgb2YgdGhlIHNldHRpbmcsICp3aXRoaW4qIGVhY2ggY3VzdG9tQnV0dG9ucyBvYmplY3QsIHRvIHVzZSBmb3IgaWNvbnNcbiAgaWNvbk92ZXJyaWRlUHJlZml4OiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihjYWxlbmRhck9wdGlvbnM6IENhbGVuZGFyT3B0aW9uc1JlZmluZWQpIHtcbiAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcbiAgICAgIHRoaXMuc2V0SWNvbk92ZXJyaWRlKFxuICAgICAgICBjYWxlbmRhck9wdGlvbnNbdGhpcy5pY29uT3ZlcnJpZGVPcHRpb25dLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHNldEljb25PdmVycmlkZShpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgbGV0IGljb25DbGFzc2VzQ29weVxuICAgIGxldCBidXR0b25OYW1lXG5cbiAgICBpZiAodHlwZW9mIGljb25PdmVycmlkZUhhc2ggPT09ICdvYmplY3QnICYmIGljb25PdmVycmlkZUhhc2gpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICBpY29uQ2xhc3Nlc0NvcHkgPSB7IC4uLnRoaXMuaWNvbkNsYXNzZXMgfVxuXG4gICAgICBmb3IgKGJ1dHRvbk5hbWUgaW4gaWNvbk92ZXJyaWRlSGFzaCkge1xuICAgICAgICBpY29uQ2xhc3Nlc0NvcHlbYnV0dG9uTmFtZV0gPSB0aGlzLmFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KFxuICAgICAgICAgIGljb25PdmVycmlkZUhhc2hbYnV0dG9uTmFtZV0sXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IGljb25DbGFzc2VzQ29weVxuICAgIH0gZWxzZSBpZiAoaWNvbk92ZXJyaWRlSGFzaCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSB7fVxuICAgIH1cbiAgfVxuXG4gIGFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGNsYXNzTmFtZSkge1xuICAgIGxldCBwcmVmaXggPSB0aGlzLmljb25PdmVycmlkZVByZWZpeFxuXG4gICAgaWYgKHByZWZpeCAmJiBjbGFzc05hbWUuaW5kZXhPZihwcmVmaXgpICE9PSAwKSB7IC8vIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgIGNsYXNzTmFtZSA9IHByZWZpeCArIGNsYXNzTmFtZVxuICAgIH1cblxuICAgIHJldHVybiBjbGFzc05hbWVcbiAgfVxuXG4gIGdldENsYXNzKGtleSkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzZXNba2V5XSB8fCAnJ1xuICB9XG5cbiAgZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsPzogYm9vbGVhbikge1xuICAgIGxldCBjbGFzc05hbWVcblxuICAgIGlmIChpc1J0bCAmJiB0aGlzLnJ0bEljb25DbGFzc2VzKSB7XG4gICAgICBjbGFzc05hbWUgPSB0aGlzLnJ0bEljb25DbGFzc2VzW2J1dHRvbk5hbWVdIHx8IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV1cbiAgICB9IGVsc2Uge1xuICAgICAgY2xhc3NOYW1lID0gdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXVxuICAgIH1cblxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VJY29uQ2xhc3N9ICR7Y2xhc3NOYW1lfWBcbiAgICB9XG5cbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykge1xuICAgIGxldCBjbGFzc05hbWVcblxuICAgIGlmICh0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbikge1xuICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dXG5cbiAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuYmFzZUljb25DbGFzc30gJHt0aGlzLmFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGNsYXNzTmFtZSl9YFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJ1xuICB9XG59XG5cblRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge31cblRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHt9XG5UaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICcnXG5UaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJydcblxuZXhwb3J0IHR5cGUgVGhlbWVDbGFzcyA9IHsgbmV3KGNhbGVuZGFyT3B0aW9uczogYW55KTogVGhlbWUgfVxuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4vY29tbW9uL0VtaXR0ZXInXG5pbXBvcnQgeyBDYWxlbmRhckxpc3RlbmVycyB9IGZyb20gJy4vb3B0aW9ucydcblxuZXhwb3J0IGludGVyZmFjZSBTY3JvbGxSZXF1ZXN0IHtcbiAgdGltZT86IER1cmF0aW9uXG4gIFtvdGhlclByb3A6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgdHlwZSBTY3JvbGxSZXF1ZXN0SGFuZGxlciA9IChyZXF1ZXN0OiBTY3JvbGxSZXF1ZXN0KSA9PiBib29sZWFuXG5cbmV4cG9ydCBjbGFzcyBTY3JvbGxSZXNwb25kZXIge1xuICBxdWV1ZWRSZXF1ZXN0OiBTY3JvbGxSZXF1ZXN0XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBleGVjRnVuYzogU2Nyb2xsUmVxdWVzdEhhbmRsZXIsXG4gICAgcHJpdmF0ZSBlbWl0dGVyOiBFbWl0dGVyPENhbGVuZGFyTGlzdGVuZXJzPixcbiAgICBwcml2YXRlIHNjcm9sbFRpbWU6IER1cmF0aW9uLFxuICAgIHByaXZhdGUgc2Nyb2xsVGltZVJlc2V0OiBib29sZWFuLFxuICApIHtcbiAgICBlbWl0dGVyLm9uKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdClcbiAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKClcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmVtaXR0ZXIub2ZmKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdClcbiAgfVxuXG4gIHVwZGF0ZShpc0RhdGVzTmV3OiBib29sZWFuKSB7XG4gICAgaWYgKGlzRGF0ZXNOZXcgJiYgdGhpcy5zY3JvbGxUaW1lUmVzZXQpIHtcbiAgICAgIHRoaXMuZmlyZUluaXRpYWxTY3JvbGwoKSAvLyB3aWxsIGRyYWluXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhaW4oKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZmlyZUluaXRpYWxTY3JvbGwoKSB7XG4gICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KHtcbiAgICAgIHRpbWU6IHRoaXMuc2Nyb2xsVGltZSxcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTY3JvbGxSZXF1ZXN0ID0gKHJlcXVlc3Q6IFNjcm9sbFJlcXVlc3QpID0+IHtcbiAgICB0aGlzLnF1ZXVlZFJlcXVlc3QgPSBfX2Fzc2lnbih7fSwgdGhpcy5xdWV1ZWRSZXF1ZXN0IHx8IHt9LCByZXF1ZXN0KVxuICAgIHRoaXMuZHJhaW4oKVxuICB9XG5cbiAgcHJpdmF0ZSBkcmFpbigpIHtcbiAgICBpZiAodGhpcy5xdWV1ZWRSZXF1ZXN0ICYmIHRoaXMuZXhlY0Z1bmModGhpcy5xdWV1ZWRSZXF1ZXN0KSkge1xuICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gbnVsbFxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2FsZW5kYXJBcGkgfSBmcm9tICcuL0NhbGVuZGFyQXBpJ1xuaW1wb3J0IHsgVmlld0FwaSB9IGZyb20gJy4vVmlld0FwaSdcbmltcG9ydCB7IFRoZW1lIH0gZnJvbSAnLi90aGVtZS9UaGVtZSdcbmltcG9ydCB7IERhdGVFbnYgfSBmcm9tICcuL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgUGx1Z2luSG9va3MgfSBmcm9tICcuL3BsdWdpbi1zeXN0ZW0tc3RydWN0J1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgQ29udGV4dCB9IGZyb20gJy4vdmRvbSdcbmltcG9ydCB7IFNjcm9sbFJlc3BvbmRlciwgU2Nyb2xsUmVxdWVzdEhhbmRsZXIgfSBmcm9tICcuL1Njcm9sbFJlc3BvbmRlcidcbmltcG9ydCB7IERhdGVQcm9maWxlR2VuZXJhdG9yIH0gZnJvbSAnLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IFZpZXdTcGVjIH0gZnJvbSAnLi9zdHJ1Y3RzL3ZpZXctc3BlYydcbmltcG9ydCB7IENhbGVuZGFyRGF0YSB9IGZyb20gJy4vcmVkdWNlcnMvZGF0YS10eXBlcydcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vcmVkdWNlcnMvQWN0aW9uJ1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4vY29tbW9uL0VtaXR0ZXInXG5pbXBvcnQgeyBJbnRlcmFjdGlvblNldHRpbmdzSW5wdXQgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvbidcbmltcG9ydCB7IERhdGVDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudC9EYXRlQ29tcG9uZW50J1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBjcmVhdGVEdXJhdGlvbiB9IGZyb20gJy4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IFZpZXdPcHRpb25zUmVmaW5lZCwgQ2FsZW5kYXJMaXN0ZW5lcnMgfSBmcm9tICcuL29wdGlvbnMnXG5cbmV4cG9ydCBjb25zdCBWaWV3Q29udGV4dFR5cGU6IENvbnRleHQ8YW55PiA9IGNyZWF0ZUNvbnRleHQ8Vmlld0NvbnRleHQ+KHt9IGFzIGFueSkgLy8gZm9yIENvbXBvbmVudHNcbmV4cG9ydCB0eXBlIFJlc2l6ZUhhbmRsZXIgPSAoZm9yY2U6IGJvb2xlYW4pID0+IHZvaWRcblxuLypcbml0J3MgaW1wb3J0YW50IHRoYXQgVmlld0NvbnRleHQgZXh0ZW5kcyBDYWxlbmRhckNvbnRleHQgc28gdGhhdCBjb21wb25lbnRzIHRoYXQgc3Vic2NyaWJlIHRvIFZpZXdDb250ZXh0XG5jYW4gcGFzcyBpbiB0aGVpciBWaWV3Q29udGV4dCB0byB1dGlsIGZ1bmN0aW9ucyB0aGF0IGFjY2VwdCBDYWxlbmRhckNvbnRleHQuXG4qL1xuZXhwb3J0IGludGVyZmFjZSBWaWV3Q29udGV4dCBleHRlbmRzIENhbGVuZGFyQ29udGV4dCB7XG4gIG9wdGlvbnM6IFZpZXdPcHRpb25zUmVmaW5lZCAvLyBtb3JlIHNwZWNpZmljIHRoYW4gQmFzZU9wdGlvbnNSZWZpbmVkXG4gIHRoZW1lOiBUaGVtZVxuICBpc1J0bDogYm9vbGVhblxuICBkYXRlUHJvZmlsZUdlbmVyYXRvcjogRGF0ZVByb2ZpbGVHZW5lcmF0b3JcbiAgdmlld1NwZWM6IFZpZXdTcGVjXG4gIHZpZXdBcGk6IFZpZXdBcGlcbiAgYWRkUmVzaXplSGFuZGxlcjogKGhhbmRsZXI6IFJlc2l6ZUhhbmRsZXIpID0+IHZvaWRcbiAgcmVtb3ZlUmVzaXplSGFuZGxlcjogKGhhbmRsZXI6IFJlc2l6ZUhhbmRsZXIpID0+IHZvaWRcbiAgY3JlYXRlU2Nyb2xsUmVzcG9uZGVyOiAoZXhlY0Z1bmM6IFNjcm9sbFJlcXVlc3RIYW5kbGVyKSA9PiBTY3JvbGxSZXNwb25kZXJcbiAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudDogKGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+LCBzZXR0aW5nc0lucHV0OiBJbnRlcmFjdGlvblNldHRpbmdzSW5wdXQpID0+IHZvaWRcbiAgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50OiAoY29tcG9uZW50OiBEYXRlQ29tcG9uZW50PGFueT4pID0+IHZvaWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkVmlld0NvbnRleHQoXG4gIHZpZXdTcGVjOiBWaWV3U3BlYyxcbiAgdmlld0FwaTogVmlld0FwaSxcbiAgdmlld09wdGlvbnM6IFZpZXdPcHRpb25zUmVmaW5lZCxcbiAgZGF0ZVByb2ZpbGVHZW5lcmF0b3I6IERhdGVQcm9maWxlR2VuZXJhdG9yLFxuICBkYXRlRW52OiBEYXRlRW52LFxuICB0aGVtZTogVGhlbWUsXG4gIHBsdWdpbkhvb2tzOiBQbHVnaW5Ib29rcyxcbiAgZGlzcGF0Y2g6IChhY3Rpb246IEFjdGlvbikgPT4gdm9pZCxcbiAgZ2V0Q3VycmVudERhdGE6ICgpID0+IENhbGVuZGFyRGF0YSxcbiAgZW1pdHRlcjogRW1pdHRlcjxDYWxlbmRhckxpc3RlbmVycz4sXG4gIGNhbGVuZGFyQXBpOiBDYWxlbmRhckFwaSxcbiAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudDogKGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+LCBzZXR0aW5nc0lucHV0OiBJbnRlcmFjdGlvblNldHRpbmdzSW5wdXQpID0+IHZvaWQsXG4gIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudDogKGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+KSA9PiB2b2lkLFxuKTogVmlld0NvbnRleHQge1xuICByZXR1cm4ge1xuICAgIGRhdGVFbnYsXG4gICAgb3B0aW9uczogdmlld09wdGlvbnMsXG4gICAgcGx1Z2luSG9va3MsXG4gICAgZW1pdHRlcixcbiAgICBkaXNwYXRjaCxcbiAgICBnZXRDdXJyZW50RGF0YSxcbiAgICBjYWxlbmRhckFwaSxcbiAgICB2aWV3U3BlYyxcbiAgICB2aWV3QXBpLFxuICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yLFxuICAgIHRoZW1lLFxuICAgIGlzUnRsOiB2aWV3T3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnLFxuICAgIGFkZFJlc2l6ZUhhbmRsZXIoaGFuZGxlcjogUmVzaXplSGFuZGxlcikge1xuICAgICAgZW1pdHRlci5vbignX3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgfSxcbiAgICByZW1vdmVSZXNpemVIYW5kbGVyKGhhbmRsZXI6IFJlc2l6ZUhhbmRsZXIpIHtcbiAgICAgIGVtaXR0ZXIub2ZmKCdfcmVzaXplJywgaGFuZGxlcilcbiAgICB9LFxuICAgIGNyZWF0ZVNjcm9sbFJlc3BvbmRlcihleGVjRnVuYzogU2Nyb2xsUmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBuZXcgU2Nyb2xsUmVzcG9uZGVyKFxuICAgICAgICBleGVjRnVuYyxcbiAgICAgICAgZW1pdHRlcixcbiAgICAgICAgY3JlYXRlRHVyYXRpb24odmlld09wdGlvbnMuc2Nyb2xsVGltZSksXG4gICAgICAgIHZpZXdPcHRpb25zLnNjcm9sbFRpbWVSZXNldCxcbiAgICAgIClcbiAgICB9LFxuICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gICAgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LFxuICB9XG59XG4iLCIvKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xuXG5pbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJ1xuaW1wb3J0IHsgQ29tcG9uZW50LCBSZWYgfSBmcm9tICcuL3Zkb20nXG5pbXBvcnQgeyBWaWV3Q29udGV4dFR5cGUsIFZpZXdDb250ZXh0IH0gZnJvbSAnLi9WaWV3Q29udGV4dCdcbmltcG9ydCB7IGNvbXBhcmVPYmpzLCBFcXVhbGl0eUZ1bmNzLCBnZXRVbmVxdWFsUHJvcHMgfSBmcm9tICcuL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4vb3B0aW9ucydcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFB1cmVDb21wb25lbnQ8UHJvcHM9RGljdGlvbmFyeSwgU3RhdGU9RGljdGlvbmFyeT4gZXh0ZW5kcyBDb21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBhZGRQcm9wc0VxdWFsaXR5ID0gYWRkUHJvcHNFcXVhbGl0eVxuICBzdGF0aWMgYWRkU3RhdGVFcXVhbGl0eSA9IGFkZFN0YXRlRXF1YWxpdHlcbiAgc3RhdGljIGNvbnRleHRUeXBlOiBhbnkgPSBWaWV3Q29udGV4dFR5cGVcblxuICBjb250ZXh0OiBWaWV3Q29udGV4dFxuICBwcm9wRXF1YWxpdHk6IEVxdWFsaXR5RnVuY3M8UHJvcHM+XG4gIHN0YXRlRXF1YWxpdHk6IEVxdWFsaXR5RnVuY3M8U3RhdGU+XG5cbiAgZGVidWc6IGJvb2xlYW5cblxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzOiBQcm9wcywgbmV4dFN0YXRlOiBTdGF0ZSkge1xuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5sb2coZ2V0VW5lcXVhbFByb3BzKG5leHRQcm9wcywgdGhpcy5wcm9wcyksIGdldFVuZXF1YWxQcm9wcyhuZXh0U3RhdGUsIHRoaXMuc3RhdGUpKVxuICAgIH1cblxuICAgIHJldHVybiAhY29tcGFyZU9ianModGhpcy5wcm9wcywgbmV4dFByb3BzLCB0aGlzLnByb3BFcXVhbGl0eSkgfHxcbiAgICAgICFjb21wYXJlT2Jqcyh0aGlzLnN0YXRlLCBuZXh0U3RhdGUsIHRoaXMuc3RhdGVFcXVhbGl0eSlcbiAgfVxufVxuXG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5wcm9wRXF1YWxpdHkgPSB7fVxuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlQ29tcG9uZW50PFByb3BzPURpY3Rpb25hcnksIFN0YXRlPURpY3Rpb25hcnk+IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIGNvbnRleHRUeXBlOiBhbnkgPSBWaWV3Q29udGV4dFR5cGVcblxuICBjb250ZXh0OiBWaWV3Q29udGV4dFxufVxuXG5mdW5jdGlvbiBhZGRQcm9wc0VxdWFsaXR5KHRoaXM6IHsgcHJvdG90eXBlOiB7IHByb3BFcXVhbGl0eTogYW55IH0gfSwgcHJvcEVxdWFsaXR5KSB7XG4gIGxldCBoYXNoID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZS5wcm9wRXF1YWxpdHkpXG4gIF9fYXNzaWduKGhhc2gsIHByb3BFcXVhbGl0eSlcbiAgdGhpcy5wcm90b3R5cGUucHJvcEVxdWFsaXR5ID0gaGFzaFxufVxuXG5mdW5jdGlvbiBhZGRTdGF0ZUVxdWFsaXR5KHRoaXM6IHsgcHJvdG90eXBlOiB7IHN0YXRlRXF1YWxpdHk6IGFueSB9IH0sIHN0YXRlRXF1YWxpdHkpIHtcbiAgbGV0IGhhc2ggPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLnN0YXRlRXF1YWxpdHkpXG4gIF9fYXNzaWduKGhhc2gsIHN0YXRlRXF1YWxpdHkpXG4gIHRoaXMucHJvdG90eXBlLnN0YXRlRXF1YWxpdHkgPSBoYXNoXG59XG5cbi8vIHVzZSBvdGhlciBvbmVcbmV4cG9ydCBmdW5jdGlvbiBzZXRSZWY8UmVmVHlwZT4ocmVmOiBSZWY8UmVmVHlwZT4gfCB2b2lkLCBjdXJyZW50OiBSZWZUeXBlKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKGN1cnJlbnQpXG4gIH0gZWxzZSBpZiAocmVmKSB7XG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMwMjlcbiAgICAocmVmIGFzIGFueSkuY3VycmVudCA9IGN1cnJlbnRcbiAgfVxufVxuIiwiaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL3Zkb20tdXRpbCdcbmltcG9ydCB7IEV2ZW50UmVuZGVyUmFuZ2UgfSBmcm9tICcuL2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IEV2ZW50SW5zdGFuY2VIYXNoIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1pbnN0YW5jZSdcbmltcG9ydCB7IEhpdCB9IGZyb20gJy4uL2ludGVyYWN0aW9ucy9oaXQnXG5pbXBvcnQgeyBlbGVtZW50Q2xvc2VzdCB9IGZyb20gJy4uL3V0aWwvZG9tLW1hbmlwJ1xuaW1wb3J0IHsgZ3VpZCB9IGZyb20gJy4uL3V0aWwvbWlzYydcbmltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5leHBvcnQgdHlwZSBEYXRlQ29tcG9uZW50SGFzaCA9IHsgW3VpZDogc3RyaW5nXTogRGF0ZUNvbXBvbmVudDxhbnksIGFueT4gfVxuXG4vLyBOT1RFOiBmb3IgZmctZXZlbnRzLCBldmVudFJhbmdlLnJhbmdlIGlzIE5PVCBzbGljZWQsXG4vLyB0aHVzLCB3ZSBuZWVkIGlzU3RhcnQvaXNFbmRcbmV4cG9ydCBpbnRlcmZhY2UgU2VnIHtcbiAgY29tcG9uZW50PzogRGF0ZUNvbXBvbmVudDxhbnksIGFueT5cbiAgaXNTdGFydDogYm9vbGVhblxuICBpc0VuZDogYm9vbGVhblxuICBldmVudFJhbmdlPzogRXZlbnRSZW5kZXJSYW5nZVxuICBbb3RoZXJQcm9wOiBzdHJpbmddOiBhbnkgLy8gVE9ETzogcmVtb3ZlIHRoaXMuIGV4dGVuZGluZyBTZWcgd2lsbCBoYW5kbGUgdGhpc1xuICBlbD86IG5ldmVyXG4gIC8vIE5PVEU6IGNhbiBzb21ldGltZXMgaGF2ZSBzdGFydC9lbmQsIHdoaWNoIGFyZSBpbXBvcnRhbnQgdmFsdWVzIDooXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUge1xuICBhZmZlY3RlZEluc3RhbmNlczogRXZlbnRJbnN0YW5jZUhhc2hcbiAgc2VnczogU2VnW11cbiAgaXNFdmVudDogYm9vbGVhblxufVxuXG4vKlxuYW4gSU5URVJBQ1RBQkxFIGRhdGUgY29tcG9uZW50XG5cblBVUlBPU0VTOlxuLSBob29rIHVwIHRvIGZnLCBmaWxsLCBhbmQgbWlycm9yIHJlbmRlcmVyc1xuLSBpbnRlcmZhY2UgZm9yIGRyYWdnaW5nIGFuZCBoaXRzXG4qL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERhdGVDb21wb25lbnQ8UHJvcHM9RGljdGlvbmFyeSwgU3RhdGU9RGljdGlvbmFyeT4gZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICB1aWQgPSBndWlkKClcblxuICAvLyBIaXQgU3lzdGVtXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgcHJlcGFyZUhpdHMoKSB7XG4gIH1cblxuICBxdWVyeUhpdChwb3NpdGlvbkxlZnQ6IG51bWJlciwgcG9zaXRpb25Ub3A6IG51bWJlciwgZWxXaWR0aDogbnVtYmVyLCBlbEhlaWdodDogbnVtYmVyKTogSGl0IHwgbnVsbCB7XG4gICAgcmV0dXJuIG51bGwgLy8gdGhpcyBzaG91bGQgYmUgYWJzdHJhY3RcbiAgfVxuXG4gIC8vIFBvaW50ZXIgSW50ZXJhY3Rpb24gVXRpbHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBpc1ZhbGlkU2VnRG93bkVsKGVsOiBIVE1MRWxlbWVudCkge1xuICAgIHJldHVybiAhKHRoaXMucHJvcHMgYXMgYW55KS5ldmVudERyYWcgJiYgLy8gSEFDS1xuICAgICAgISh0aGlzLnByb3BzIGFzIGFueSkuZXZlbnRSZXNpemUgJiYgLy8gSEFDS1xuICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLWV2ZW50LW1pcnJvcicpXG4gIH1cblxuICBpc1ZhbGlkRGF0ZURvd25FbChlbDogSFRNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLWV2ZW50Om5vdCguZmMtYmctZXZlbnQpJykgJiZcbiAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1tb3JlLWxpbmsnKSAmJiAvLyBhIFwibW9yZS4uXCIgbGlua1xuICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnYVtkYXRhLW5hdmxpbmtdJykgJiYgLy8gYSBjbGlja2FibGUgbmF2IGxpbmtcbiAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1wb3BvdmVyJykgLy8gaGFja1xuICB9XG59XG4iLCJpbXBvcnQgeyBndWlkIH0gZnJvbSAnLi91dGlsL21pc2MnXG5pbXBvcnQgeyBQbHVnaW5EZWZJbnB1dCwgUGx1Z2luRGVmLCBQbHVnaW5Ib29rcyB9IGZyb20gJy4vcGx1Z2luLXN5c3RlbS1zdHJ1Y3QnXG5pbXBvcnQgeyBpc0FycmF5c0VxdWFsIH0gZnJvbSAnLi91dGlsL2FycmF5J1xuXG4vLyBUT0RPOiBlYXNpZXIgd2F5IHRvIGFkZCBuZXcgaG9va3M/IG5lZWQgdG8gdXBkYXRlIGEgbWlsbGlvbiB0aGluZ3NcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBsdWdpbihpbnB1dDogUGx1Z2luRGVmSW5wdXQpOiBQbHVnaW5EZWYge1xuICByZXR1cm4ge1xuICAgIGlkOiBndWlkKCksXG4gICAgZGVwczogaW5wdXQuZGVwcyB8fCBbXSxcbiAgICByZWR1Y2VyczogaW5wdXQucmVkdWNlcnMgfHwgW10sXG4gICAgaXNMb2FkaW5nRnVuY3M6IGlucHV0LmlzTG9hZGluZ0Z1bmNzIHx8IFtdLFxuICAgIGNvbnRleHRJbml0OiBbXS5jb25jYXQoaW5wdXQuY29udGV4dEluaXQgfHwgW10pLFxuICAgIGV2ZW50UmVmaW5lcnM6IGlucHV0LmV2ZW50UmVmaW5lcnMgfHwge30sXG4gICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IGlucHV0LmV2ZW50RGVmTWVtYmVyQWRkZXJzIHx8IFtdLFxuICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IGlucHV0LmV2ZW50U291cmNlUmVmaW5lcnMgfHwge30sXG4gICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGlucHV0LmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBpbnB1dC5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyB8fCBbXSxcbiAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGlucHV0LmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyB8fCBbXSxcbiAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBpbnB1dC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IGlucHV0LmRhdGVQb2ludFRyYW5zZm9ybXMgfHwgW10sXG4gICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBpbnB1dC5kYXRlU3BhblRyYW5zZm9ybXMgfHwgW10sXG4gICAgdmlld3M6IGlucHV0LnZpZXdzIHx8IHt9LFxuICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogaW5wdXQudmlld1Byb3BzVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgIGlzUHJvcHNWYWxpZDogaW5wdXQuaXNQcm9wc1ZhbGlkIHx8IG51bGwsXG4gICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBpbnB1dC5leHRlcm5hbERlZlRyYW5zZm9ybXMgfHwgW10sXG4gICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IGlucHV0LnZpZXdDb250YWluZXJBcHBlbmRzIHx8IFtdLFxuICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaW5wdXQuZXZlbnREcm9wVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaW5wdXQuY29tcG9uZW50SW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBpbnB1dC5jYWxlbmRhckludGVyYWN0aW9ucyB8fCBbXSxcbiAgICB0aGVtZUNsYXNzZXM6IGlucHV0LnRoZW1lQ2xhc3NlcyB8fCB7fSxcbiAgICBldmVudFNvdXJjZURlZnM6IGlucHV0LmV2ZW50U291cmNlRGVmcyB8fCBbXSxcbiAgICBjbWRGb3JtYXR0ZXI6IGlucHV0LmNtZEZvcm1hdHRlcixcbiAgICByZWN1cnJpbmdUeXBlczogaW5wdXQucmVjdXJyaW5nVHlwZXMgfHwgW10sXG4gICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBpbnB1dC5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgaW5pdGlhbFZpZXc6IGlucHV0LmluaXRpYWxWaWV3IHx8ICcnLFxuICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGlucHV0LmVsZW1lbnREcmFnZ2luZ0ltcGwsXG4gICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IGlucHV0Lm9wdGlvbkNoYW5nZUhhbmRsZXJzIHx8IHt9LFxuICAgIHNjcm9sbEdyaWRJbXBsOiBpbnB1dC5zY3JvbGxHcmlkSW1wbCB8fCBudWxsLFxuICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IGlucHV0LmNvbnRlbnRUeXBlSGFuZGxlcnMgfHwge30sXG4gICAgbGlzdGVuZXJSZWZpbmVyczogaW5wdXQubGlzdGVuZXJSZWZpbmVycyB8fCB7fSxcbiAgICBvcHRpb25SZWZpbmVyczogaW5wdXQub3B0aW9uUmVmaW5lcnMgfHwge30sXG4gICAgcHJvcFNldEhhbmRsZXJzOiBpbnB1dC5wcm9wU2V0SGFuZGxlcnMgfHwge30sXG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRQbHVnaW5Ib29rcyhwbHVnaW5EZWZzOiBQbHVnaW5EZWZbXSwgZ2xvYmFsRGVmczogUGx1Z2luRGVmW10pOiBQbHVnaW5Ib29rcyB7XG4gIGxldCBpc0FkZGVkOiB7IFtwbHVnaW5JZDogc3RyaW5nXTogYm9vbGVhbiB9ID0ge31cbiAgbGV0IGhvb2tzOiBQbHVnaW5Ib29rcyA9IHtcbiAgICByZWR1Y2VyczogW10sXG4gICAgaXNMb2FkaW5nRnVuY3M6IFtdLFxuICAgIGNvbnRleHRJbml0OiBbXSxcbiAgICBldmVudFJlZmluZXJzOiB7fSxcbiAgICBldmVudERlZk1lbWJlckFkZGVyczogW10sXG4gICAgZXZlbnRTb3VyY2VSZWZpbmVyczoge30sXG4gICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IFtdLFxuICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBbXSxcbiAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IFtdLFxuICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IFtdLFxuICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IFtdLFxuICAgIGRhdGVTcGFuVHJhbnNmb3JtczogW10sXG4gICAgdmlld3M6IHt9LFxuICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogW10sXG4gICAgaXNQcm9wc1ZhbGlkOiBudWxsLFxuICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogW10sXG4gICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IFtdLFxuICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogW10sXG4gICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBbXSxcbiAgICBjYWxlbmRhckludGVyYWN0aW9uczogW10sXG4gICAgdGhlbWVDbGFzc2VzOiB7fSxcbiAgICBldmVudFNvdXJjZURlZnM6IFtdLFxuICAgIGNtZEZvcm1hdHRlcjogbnVsbCxcbiAgICByZWN1cnJpbmdUeXBlczogW10sXG4gICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBudWxsLFxuICAgIGluaXRpYWxWaWV3OiAnJyxcbiAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBudWxsLFxuICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7fSxcbiAgICBzY3JvbGxHcmlkSW1wbDogbnVsbCxcbiAgICBjb250ZW50VHlwZUhhbmRsZXJzOiB7fSxcbiAgICBsaXN0ZW5lclJlZmluZXJzOiB7fSxcbiAgICBvcHRpb25SZWZpbmVyczoge30sXG4gICAgcHJvcFNldEhhbmRsZXJzOiB7fSxcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZERlZnMoZGVmczogUGx1Z2luRGVmW10pIHtcbiAgICBmb3IgKGxldCBkZWYgb2YgZGVmcykge1xuICAgICAgaWYgKCFpc0FkZGVkW2RlZi5pZF0pIHtcbiAgICAgICAgaXNBZGRlZFtkZWYuaWRdID0gdHJ1ZVxuICAgICAgICBhZGREZWZzKGRlZi5kZXBzKVxuICAgICAgICBob29rcyA9IGNvbWJpbmVIb29rcyhob29rcywgZGVmKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwbHVnaW5EZWZzKSB7XG4gICAgYWRkRGVmcyhwbHVnaW5EZWZzKVxuICB9XG5cbiAgYWRkRGVmcyhnbG9iYWxEZWZzKVxuXG4gIHJldHVybiBob29rc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCkgeyAvLyBtZW1vaXplc1xuICBsZXQgY3VycmVudE92ZXJyaWRlRGVmczogUGx1Z2luRGVmW10gPSBbXVxuICBsZXQgY3VycmVudEdsb2JhbERlZnM6IFBsdWdpbkRlZltdID0gW11cbiAgbGV0IGN1cnJlbnRIb29rczogUGx1Z2luSG9va3NcblxuICByZXR1cm4gKG92ZXJyaWRlRGVmczogUGx1Z2luRGVmW10sIGdsb2JhbERlZnM6IFBsdWdpbkRlZltdKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50SG9va3MgfHwgIWlzQXJyYXlzRXF1YWwob3ZlcnJpZGVEZWZzLCBjdXJyZW50T3ZlcnJpZGVEZWZzKSB8fCAhaXNBcnJheXNFcXVhbChnbG9iYWxEZWZzLCBjdXJyZW50R2xvYmFsRGVmcykpIHtcbiAgICAgIGN1cnJlbnRIb29rcyA9IGJ1aWxkUGx1Z2luSG9va3Mob3ZlcnJpZGVEZWZzLCBnbG9iYWxEZWZzKVxuICAgIH1cbiAgICBjdXJyZW50T3ZlcnJpZGVEZWZzID0gb3ZlcnJpZGVEZWZzXG4gICAgY3VycmVudEdsb2JhbERlZnMgPSBnbG9iYWxEZWZzXG4gICAgcmV0dXJuIGN1cnJlbnRIb29rc1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVIb29rcyhob29rczA6IFBsdWdpbkhvb2tzLCBob29rczE6IFBsdWdpbkhvb2tzKTogUGx1Z2luSG9va3Mge1xuICByZXR1cm4ge1xuICAgIHJlZHVjZXJzOiBob29rczAucmVkdWNlcnMuY29uY2F0KGhvb2tzMS5yZWR1Y2VycyksXG4gICAgaXNMb2FkaW5nRnVuY3M6IGhvb2tzMC5pc0xvYWRpbmdGdW5jcy5jb25jYXQoaG9va3MxLmlzTG9hZGluZ0Z1bmNzKSxcbiAgICBjb250ZXh0SW5pdDogaG9va3MwLmNvbnRleHRJbml0LmNvbmNhdChob29rczEuY29udGV4dEluaXQpLFxuICAgIGV2ZW50UmVmaW5lcnM6IHsgLi4uaG9va3MwLmV2ZW50UmVmaW5lcnMsIC4uLmhvb2tzMS5ldmVudFJlZmluZXJzIH0sXG4gICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IGhvb2tzMC5ldmVudERlZk1lbWJlckFkZGVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSxcbiAgICBldmVudFNvdXJjZVJlZmluZXJzOiB7IC4uLmhvb2tzMC5ldmVudFNvdXJjZVJlZmluZXJzLCAuLi5ob29rczEuZXZlbnRTb3VyY2VSZWZpbmVycyB9LFxuICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBob29rczAuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyksXG4gICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGhvb2tzMC5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2Vycy5jb25jYXQoaG9va3MxLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzKSxcbiAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGhvb2tzMC5ldmVudERlZk11dGF0aW9uQXBwbGllcnMuY29uY2F0KGhvb2tzMS5ldmVudERlZk11dGF0aW9uQXBwbGllcnMpLFxuICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IGhvb2tzMC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyksXG4gICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaG9va3MwLmRhdGVQb2ludFRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlUG9pbnRUcmFuc2Zvcm1zKSxcbiAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlU3BhblRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlU3BhblRyYW5zZm9ybXMpLFxuICAgIHZpZXdzOiB7IC4uLmhvb2tzMC52aWV3cywgLi4uaG9va3MxLnZpZXdzIH0sXG4gICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBob29rczAudmlld1Byb3BzVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEudmlld1Byb3BzVHJhbnNmb3JtZXJzKSxcbiAgICBpc1Byb3BzVmFsaWQ6IGhvb2tzMS5pc1Byb3BzVmFsaWQgfHwgaG9va3MwLmlzUHJvcHNWYWxpZCxcbiAgICBleHRlcm5hbERlZlRyYW5zZm9ybXM6IGhvb2tzMC5leHRlcm5hbERlZlRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5leHRlcm5hbERlZlRyYW5zZm9ybXMpLFxuICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBob29rczAudmlld0NvbnRhaW5lckFwcGVuZHMuY29uY2F0KGhvb2tzMS52aWV3Q29udGFpbmVyQXBwZW5kcyksXG4gICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBob29rczAuZXZlbnREcm9wVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZXZlbnREcm9wVHJhbnNmb3JtZXJzKSxcbiAgICBjYWxlbmRhckludGVyYWN0aW9uczogaG9va3MwLmNhbGVuZGFySW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY2FsZW5kYXJJbnRlcmFjdGlvbnMpLFxuICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaG9va3MwLmNvbXBvbmVudEludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNvbXBvbmVudEludGVyYWN0aW9ucyksXG4gICAgdGhlbWVDbGFzc2VzOiB7IC4uLmhvb2tzMC50aGVtZUNsYXNzZXMsIC4uLmhvb2tzMS50aGVtZUNsYXNzZXMgfSxcbiAgICBldmVudFNvdXJjZURlZnM6IGhvb2tzMC5ldmVudFNvdXJjZURlZnMuY29uY2F0KGhvb2tzMS5ldmVudFNvdXJjZURlZnMpLFxuICAgIGNtZEZvcm1hdHRlcjogaG9va3MxLmNtZEZvcm1hdHRlciB8fCBob29rczAuY21kRm9ybWF0dGVyLFxuICAgIHJlY3VycmluZ1R5cGVzOiBob29rczAucmVjdXJyaW5nVHlwZXMuY29uY2F0KGhvb2tzMS5yZWN1cnJpbmdUeXBlcyksXG4gICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBob29rczEubmFtZWRUaW1lWm9uZWRJbXBsIHx8IGhvb2tzMC5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgaW5pdGlhbFZpZXc6IGhvb2tzMC5pbml0aWFsVmlldyB8fCBob29rczEuaW5pdGlhbFZpZXcsIC8vIHB1dCBlYXJsaWVyIHBsdWdpbnMgRklSU1RcbiAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBob29rczAuZWxlbWVudERyYWdnaW5nSW1wbCB8fCBob29rczEuZWxlbWVudERyYWdnaW5nSW1wbCwgLy8gXCJcbiAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogeyAuLi5ob29rczAub3B0aW9uQ2hhbmdlSGFuZGxlcnMsIC4uLmhvb2tzMS5vcHRpb25DaGFuZ2VIYW5kbGVycyB9LFxuICAgIHNjcm9sbEdyaWRJbXBsOiBob29rczEuc2Nyb2xsR3JpZEltcGwgfHwgaG9va3MwLnNjcm9sbEdyaWRJbXBsLFxuICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IHsgLi4uaG9va3MwLmNvbnRlbnRUeXBlSGFuZGxlcnMsIC4uLmhvb2tzMS5jb250ZW50VHlwZUhhbmRsZXJzIH0sXG4gICAgbGlzdGVuZXJSZWZpbmVyczogeyAuLi5ob29rczAubGlzdGVuZXJSZWZpbmVycywgLi4uaG9va3MxLmxpc3RlbmVyUmVmaW5lcnMgfSxcbiAgICBvcHRpb25SZWZpbmVyczogeyAuLi5ob29rczAub3B0aW9uUmVmaW5lcnMsIC4uLmhvb2tzMS5vcHRpb25SZWZpbmVycyB9LFxuICAgIHByb3BTZXRIYW5kbGVyczogeyAuLi5ob29rczAucHJvcFNldEhhbmRsZXJzLCAuLi5ob29rczEucHJvcFNldEhhbmRsZXJzIH0sXG4gIH1cbn1cbiIsImltcG9ydCB7IFRoZW1lIH0gZnJvbSAnLi9UaGVtZSdcblxuZXhwb3J0IGNsYXNzIFN0YW5kYXJkVGhlbWUgZXh0ZW5kcyBUaGVtZSB7XG59XG5cblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XG4gIHJvb3Q6ICdmYy10aGVtZS1zdGFuZGFyZCcsIC8vIFRPRE86IGNvbXB1dGUgdGhpcyBvZmYgb2YgcmVnaXN0ZXJlZCB0aGVtZSBuYW1lXG4gIHRhYmxlQ2VsbFNoYWRlZDogJ2ZjLWNlbGwtc2hhZGVkJyxcbiAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxuICBidXR0b246ICdmYy1idXR0b24gZmMtYnV0dG9uLXByaW1hcnknLFxuICBidXR0b25BY3RpdmU6ICdmYy1idXR0b24tYWN0aXZlJyxcbn1cblxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYy1pY29uJ1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XG4gIGNsb3NlOiAnZmMtaWNvbi14JyxcbiAgcHJldjogJ2ZjLWljb24tY2hldnJvbi1sZWZ0JyxcbiAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gIHByZXZZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0JyxcbiAgbmV4dFllYXI6ICdmYy1pY29uLWNoZXZyb25zLXJpZ2h0Jyxcbn1cblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLnJ0bEljb25DbGFzc2VzID0ge1xuICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLXJpZ2h0JyxcbiAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1sZWZ0JyxcbiAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLXJpZ2h0JyxcbiAgbmV4dFllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxufVxuXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYnV0dG9uSWNvbnMnIC8vIFRPRE86IG1ha2UgVFMtZnJpZW5kbHlcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdpY29uJ1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJ1xuIiwiaW1wb3J0IHsgVmlld0NvbmZpZ0hhc2gsIFZpZXdDb21wb25lbnRUeXBlIH0gZnJvbSAnLi92aWV3LWNvbmZpZydcbmltcG9ydCB7IFZpZXdPcHRpb25zIH0gZnJvbSAnLi4vb3B0aW9ucydcblxuLypcblJlcHJlc2VudHMgaW5mb3JtYXRpb24gZm9yIGFuIGluc3RhbnRpYXRhYmxlIFZpZXcgY2xhc3MgYWxvbmcgd2l0aCBzZXR0aW5nc1xudGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhhdCB2aWV3LiBObyBvdGhlciBzZXR0aW5ncywgbGlrZSBjYWxlbmRhci13aWRlIHNldHRpbmdzLCBhcmUgc3RvcmVkLlxuKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmlld0RlZiB7XG4gIHR5cGU6IHN0cmluZ1xuICBjb21wb25lbnQ6IFZpZXdDb21wb25lbnRUeXBlXG4gIG92ZXJyaWRlczogVmlld09wdGlvbnNcbiAgZGVmYXVsdHM6IFZpZXdPcHRpb25zXG59XG5cbmV4cG9ydCB0eXBlIFZpZXdEZWZIYXNoID0geyBbdmlld1R5cGU6IHN0cmluZ106IFZpZXdEZWYgfVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVZpZXdEZWZzKGRlZmF1bHRDb25maWdzOiBWaWV3Q29uZmlnSGFzaCwgb3ZlcnJpZGVDb25maWdzOiBWaWV3Q29uZmlnSGFzaCk6IFZpZXdEZWZIYXNoIHtcbiAgbGV0IGhhc2g6IFZpZXdEZWZIYXNoID0ge31cbiAgbGV0IHZpZXdUeXBlOiBzdHJpbmdcblxuICBmb3IgKHZpZXdUeXBlIGluIGRlZmF1bHRDb25maWdzKSB7XG4gICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncylcbiAgfVxuXG4gIGZvciAodmlld1R5cGUgaW4gb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncylcbiAgfVxuXG4gIHJldHVybiBoYXNoXG59XG5cbmZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYoXG4gIHZpZXdUeXBlOiBzdHJpbmcsXG4gIGhhc2g6IFZpZXdEZWZIYXNoLFxuICBkZWZhdWx0Q29uZmlnczogVmlld0NvbmZpZ0hhc2gsXG4gIG92ZXJyaWRlQ29uZmlnczogVmlld0NvbmZpZ0hhc2gsXG4pOiBWaWV3RGVmIHwgbnVsbCB7XG4gIGlmIChoYXNoW3ZpZXdUeXBlXSkge1xuICAgIHJldHVybiBoYXNoW3ZpZXdUeXBlXVxuICB9XG5cbiAgbGV0IHZpZXdEZWYgPSBidWlsZFZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpXG5cbiAgaWYgKHZpZXdEZWYpIHtcbiAgICBoYXNoW3ZpZXdUeXBlXSA9IHZpZXdEZWZcbiAgfVxuXG4gIHJldHVybiB2aWV3RGVmXG59XG5cbmZ1bmN0aW9uIGJ1aWxkVmlld0RlZihcbiAgdmlld1R5cGU6IHN0cmluZyxcbiAgaGFzaDogVmlld0RlZkhhc2gsXG4gIGRlZmF1bHRDb25maWdzOiBWaWV3Q29uZmlnSGFzaCxcbiAgb3ZlcnJpZGVDb25maWdzOiBWaWV3Q29uZmlnSGFzaCxcbik6IFZpZXdEZWYgfCBudWxsIHtcbiAgbGV0IGRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnc1t2aWV3VHlwZV1cbiAgbGV0IG92ZXJyaWRlQ29uZmlnID0gb3ZlcnJpZGVDb25maWdzW3ZpZXdUeXBlXVxuXG4gIGxldCBxdWVyeVByb3AgPSAobmFtZSkgPT4gKFxuICAgIChkZWZhdWx0Q29uZmlnICYmIGRlZmF1bHRDb25maWdbbmFtZV0gIT09IG51bGwpID8gZGVmYXVsdENvbmZpZ1tuYW1lXSA6XG4gICAgICAoKG92ZXJyaWRlQ29uZmlnICYmIG92ZXJyaWRlQ29uZmlnW25hbWVdICE9PSBudWxsKSA/IG92ZXJyaWRlQ29uZmlnW25hbWVdIDogbnVsbClcbiAgKVxuXG4gIGxldCB0aGVDb21wb25lbnQgPSBxdWVyeVByb3AoJ2NvbXBvbmVudCcpIGFzIFZpZXdDb21wb25lbnRUeXBlXG4gIGxldCBzdXBlclR5cGUgPSBxdWVyeVByb3AoJ3N1cGVyVHlwZScpIGFzIHN0cmluZ1xuICBsZXQgc3VwZXJEZWY6IFZpZXdEZWYgfCBudWxsID0gbnVsbFxuXG4gIGlmIChzdXBlclR5cGUpIHtcbiAgICBpZiAoc3VwZXJUeXBlID09PSB2aWV3VHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGhhdmUgYSBjdXN0b20gdmlldyB0eXBlIHRoYXQgcmVmZXJlbmNlcyBpdHNlbGYnKVxuICAgIH1cblxuICAgIHN1cGVyRGVmID0gZW5zdXJlVmlld0RlZihzdXBlclR5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpXG4gIH1cblxuICBpZiAoIXRoZUNvbXBvbmVudCAmJiBzdXBlckRlZikge1xuICAgIHRoZUNvbXBvbmVudCA9IHN1cGVyRGVmLmNvbXBvbmVudFxuICB9XG5cbiAgaWYgKCF0aGVDb21wb25lbnQpIHtcbiAgICByZXR1cm4gbnVsbCAvLyBkb24ndCB0aHJvdyBhIHdhcm5pbmcsIG1pZ2h0IGJlIHNldHRpbmdzIGZvciBhIHNpbmdsZS11bml0IHZpZXdcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogdmlld1R5cGUsXG4gICAgY29tcG9uZW50OiB0aGVDb21wb25lbnQsXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIC4uLihzdXBlckRlZiA/IHN1cGVyRGVmLmRlZmF1bHRzIDoge30pLFxuICAgICAgLi4uKGRlZmF1bHRDb25maWcgPyBkZWZhdWx0Q29uZmlnLnJhd09wdGlvbnMgOiB7fSksXG4gICAgfSxcbiAgICBvdmVycmlkZXM6IHtcbiAgICAgIC4uLihzdXBlckRlZiA/IHN1cGVyRGVmLm92ZXJyaWRlcyA6IHt9KSxcbiAgICAgIC4uLihvdmVycmlkZUNvbmZpZyA/IG92ZXJyaWRlQ29uZmlnLnJhd09wdGlvbnMgOiB7fSksXG4gICAgfSxcbiAgfVxufVxuIiwiLyogZXNsaW50IG1heC1jbGFzc2VzLXBlci1maWxlOiBvZmYgKi9cblxuaW1wb3J0IHsgUmVmLCBjcmVhdGVSZWYsIENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVFbGVtZW50LCBSZWZPYmplY3QsIGNyZWF0ZUNvbnRleHQsIENvbnRleHQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgc2V0UmVmLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgaXNQcm9wc0VxdWFsIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBwYXJzZUNsYXNzTmFtZXMsIENsYXNzTmFtZXNJbnB1dCB9IGZyb20gJy4uL3V0aWwvaHRtbCdcblxuZXhwb3J0IHR5cGUgTW91bnRBcmc8Q29udGVudEFyZz4gPSBDb250ZW50QXJnICYgeyBlbDogSFRNTEVsZW1lbnQgfVxuZXhwb3J0IHR5cGUgRGlkTW91bnRIYW5kbGVyPFRoZU1vdW50QXJnIGV4dGVuZHMgeyBlbDogSFRNTEVsZW1lbnQgfT4gPSAobW91bnRBcmc6IFRoZU1vdW50QXJnKSA9PiB2b2lkXG5leHBvcnQgdHlwZSBXaWxsVW5tb3VudEhhbmRsZXI8VGhlTW91bnRBcmcgZXh0ZW5kcyB7IGVsOiBIVE1MRWxlbWVudCB9PiA9IChtb3VudEFyZzogVGhlTW91bnRBcmcpID0+IHZvaWRcblxuZXhwb3J0IGludGVyZmFjZSBSZW5kZXJIb29rUHJvcHM8Q29udGVudEFyZz4ge1xuICBob29rUHJvcHM6IENvbnRlbnRBcmdcbiAgY2xhc3NOYW1lczogQ2xhc3NOYW1lc0dlbmVyYXRvcjxDb250ZW50QXJnPlxuICBjb250ZW50OiBDdXN0b21Db250ZW50R2VuZXJhdG9yPENvbnRlbnRBcmc+XG4gIGRlZmF1bHRDb250ZW50PzogRGVmYXVsdENvbnRlbnRHZW5lcmF0b3I8Q29udGVudEFyZz5cbiAgZGlkTW91bnQ6IERpZE1vdW50SGFuZGxlcjxNb3VudEFyZzxDb250ZW50QXJnPj5cbiAgd2lsbFVubW91bnQ6IFdpbGxVbm1vdW50SGFuZGxlcjxNb3VudEFyZzxDb250ZW50QXJnPj5cbiAgY2hpbGRyZW46IFJlbmRlckhvb2tQcm9wc0NoaWxkcmVuXG4gIGVsUmVmPzogUmVmPGFueT5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVySG9va1Byb3BzQ2hpbGRyZW4gPSAoXG4gIHJvb3RFbFJlZjogUmVmPGFueT4sXG4gIGNsYXNzTmFtZXM6IHN0cmluZ1tdLFxuICBpbm5lckVsUmVmOiBSZWY8YW55PixcbiAgaW5uZXJDb250ZW50OiBDb21wb25lbnRDaGlsZHJlbiAvLyBpZiBmYWxzeSwgbWVhbnMgaXQgd2Fzbid0IHNwZWNpZmllZFxuKSA9PiBDb21wb25lbnRDaGlsZHJlblxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRlbnRUeXBlSGFuZGxlcnMge1xuICBbY29udGVudEtleTogc3RyaW5nXTogKCkgPT4gKHtcbiAgICByZW5kZXI6IChlbDogSFRNTEVsZW1lbnQsIGNvbnRlbnRWYWw6IGFueSkgPT4gdm9pZFxuICAgIGRlc3Ryb3k/OiAoKSA9PiB2b2lkXG4gIH0pXG59XG5cbi8vIE5PVEU6IGluIEpTWCwgeW91IHNob3VsZCBhbHdheXMgdXNlIHRoaXMgY2xhc3Mgd2l0aCA8SG9va1Byb3BzPiBhcmcuIG90aGVyd2lzZSwgd2lsbCBkZWZhdWx0IHRvIGFueT8/P1xuZXhwb3J0IGNsYXNzIFJlbmRlckhvb2s8SG9va1Byb3BzPiBleHRlbmRzIEJhc2VDb21wb25lbnQ8UmVuZGVySG9va1Byb3BzPEhvb2tQcm9wcz4+IHtcbiAgcHJpdmF0ZSByb290RWxSZWYgPSBjcmVhdGVSZWYoKVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCB7IGhvb2tQcm9wcyB9ID0gcHJvcHNcblxuICAgIHJldHVybiAoXG4gICAgICA8TW91bnRIb29rIGhvb2tQcm9wcz17aG9va1Byb3BzfSBkaWRNb3VudD17cHJvcHMuZGlkTW91bnR9IHdpbGxVbm1vdW50PXtwcm9wcy53aWxsVW5tb3VudH0gZWxSZWY9e3RoaXMuaGFuZGxlUm9vdEVsfT5cbiAgICAgICAgeyhyb290RWxSZWYpID0+IChcbiAgICAgICAgICA8Q29udGVudEhvb2sgaG9va1Byb3BzPXtob29rUHJvcHN9IGNvbnRlbnQ9e3Byb3BzLmNvbnRlbnR9IGRlZmF1bHRDb250ZW50PXtwcm9wcy5kZWZhdWx0Q29udGVudH0gYmFja3VwRWxSZWY9e3RoaXMucm9vdEVsUmVmfT5cbiAgICAgICAgICAgIHsoaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSA9PiBwcm9wcy5jaGlsZHJlbihcbiAgICAgICAgICAgICAgcm9vdEVsUmVmLFxuICAgICAgICAgICAgICBub3JtYWxpemVDbGFzc05hbWVzKHByb3BzLmNsYXNzTmFtZXMsIGhvb2tQcm9wcyksXG4gICAgICAgICAgICAgIGlubmVyRWxSZWYsXG4gICAgICAgICAgICAgIGlubmVyQ29udGVudCxcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9Db250ZW50SG9vaz5cbiAgICAgICAgKX1cbiAgICAgIDwvTW91bnRIb29rPlxuICAgIClcbiAgfVxuXG4gIGhhbmRsZVJvb3RFbCA9IChlbDogSFRNTEVsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgc2V0UmVmKHRoaXMucm9vdEVsUmVmLCBlbClcblxuICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2JqQ3VzdG9tQ29udGVudCB7XG4gIGh0bWw6IHN0cmluZ1xuICBkb21Ob2RlczogYW55W11cbiAgW2N1c3RvbTogc3RyaW5nXTogYW55IC8vIFRPRE86IGV4cG9zZSBob29rIGZvciBwbHVnaW5zIHRvIGFkZCFcbn1cblxuZXhwb3J0IHR5cGUgQ3VzdG9tQ29udGVudCA9IENvbXBvbmVudENoaWxkcmVuIHwgT2JqQ3VzdG9tQ29udGVudFxuZXhwb3J0IHR5cGUgQ3VzdG9tQ29udGVudEdlbmVyYXRvcjxIb29rUHJvcHM+ID0gQ3VzdG9tQ29udGVudCB8ICgoaG9va1Byb3BzOiBIb29rUHJvcHMpID0+IEN1c3RvbUNvbnRlbnQpXG5cbmV4cG9ydCB0eXBlIERlZmF1bHRDb250ZW50R2VuZXJhdG9yPEhvb2tQcm9wcz4gPSAoaG9va1Byb3BzOiBIb29rUHJvcHMpID0+IENvbXBvbmVudENoaWxkcmVuXG4vLyBUT0RPOiByZW5hbWUgdG8gYmUgYWJvdXQgZnVuY3Rpb24sIG5vdCBkZWZhdWx0LiB1c2UgaW4gYWJvdmUgdHlwZVxuXG4vLyBmb3IgZm9yY2luZyByZXJlbmRlciBvZiBjb21wb25lbnRzIHRoYXQgdXNlIHRoZSBDb250ZW50SG9va1xuZXhwb3J0IGNvbnN0IEN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0OiBDb250ZXh0PG51bWJlcj4gPSBjcmVhdGVDb250ZXh0PG51bWJlcj4oMClcblxuZXhwb3J0IGludGVyZmFjZSBDb250ZW50SG9va1Byb3BzPEhvb2tQcm9wcz4ge1xuICBob29rUHJvcHM6IEhvb2tQcm9wcyAvLyBwcm9kdWNlZCBieSBGdWxsQ2FsZW5kYXIgaW50ZXJuYWxseSwgZm9yIHJlbmRlcmluZyBhbiBlbnRpdHkvd2hhdGV2ZXJcbiAgY29udGVudDogQ3VzdG9tQ29udGVudEdlbmVyYXRvcjxIb29rUHJvcHM+IC8vIHRoZSB2YWx1ZSBvZiBhIHVzZXItaG9vaywgbGlrZSBgZXZlbnRDb250ZW50YFxuICBkZWZhdWx0Q29udGVudD86IERlZmF1bHRDb250ZW50R2VuZXJhdG9yPEhvb2tQcm9wcz4gLy8gaWYgY29udGVudCBub3Qgc3BlY2lmaWVkIChUT0RPOiBqdXN0IHVzZSBjb250ZW50PylcbiAgY2hpbGRyZW46ICggLy8gZm9yIHByb2R1Y2luZyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBjb250ZW50XG4gICAgaW5uZXJFbFJlZjogUmVmPGFueT4sXG4gICAgaW5uZXJDb250ZW50OiBDb21wb25lbnRDaGlsZHJlbiAvLyBpZiBmYWxzeSwgbWVhbnMgaXQgd2Fzbid0IHNwZWNpZmllZFxuICApID0+IENvbXBvbmVudENoaWxkcmVuXG4gIGJhY2t1cEVsUmVmPzogUmVmT2JqZWN0PGFueT5cbn1cblxuaW50ZXJmYWNlIENvbnRlbnRIb29rSW5uZXJQcm9wczxIb29rUHJvcHM+IGV4dGVuZHMgQ29udGVudEhvb2tQcm9wczxIb29rUHJvcHM+IHtcbiAgcmVuZGVySWQ6IG51bWJlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29udGVudEhvb2s8SG9va1Byb3BzPihwcm9wczogQ29udGVudEhvb2tQcm9wczxIb29rUHJvcHM+KSB7IC8vIFRPRE86IHJlbmFtZSB0byBDdXN0b21Db250ZW50SG9vaz9cbiAgcmV0dXJuIChcbiAgICA8Q3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQuQ29uc3VtZXI+XG4gICAgICB7KHJlbmRlcklkKSA9PiAoXG4gICAgICAgIDxDb250ZW50SG9va0lubmVyIHJlbmRlcklkPXtyZW5kZXJJZH0gey4uLnByb3BzfSAvPlxuICAgICAgKX1cbiAgICA8L0N1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0LkNvbnN1bWVyPlxuICApXG59XG5cbmNsYXNzIENvbnRlbnRIb29rSW5uZXI8SG9va1Byb3BzPiBleHRlbmRzIEJhc2VDb21wb25lbnQ8Q29udGVudEhvb2tJbm5lclByb3BzPEhvb2tQcm9wcz4+IHtcbiAgcHJpdmF0ZSBpbm5lckVsUmVmID0gY3JlYXRlUmVmKClcblxuICBwcml2YXRlIGN1c3RvbUNvbnRlbnRJbmZvOiB7XG4gICAgY29udGVudEtleTogc3RyaW5nXG4gICAgY29udGVudFZhbDogYW55XG4gICAgcmVuZGVyOiAoZWw6IEhUTUxFbGVtZW50LCBjb250ZW50VmFsOiBhbnkpID0+IHZvaWRcbiAgICBkZXN0cm95PzogKCkgPT4gdm9pZFxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuaW5uZXJFbFJlZiwgdGhpcy5yZW5kZXJJbm5lckNvbnRlbnQoKSlcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudXBkYXRlQ3VzdG9tQ29udGVudCgpXG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVDdXN0b21Db250ZW50KClcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLmN1c3RvbUNvbnRlbnRJbmZvICYmIHRoaXMuY3VzdG9tQ29udGVudEluZm8uZGVzdHJveSkge1xuICAgICAgdGhpcy5jdXN0b21Db250ZW50SW5mby5kZXN0cm95KClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlbmRlcklubmVyQ29udGVudCgpIHtcbiAgICBsZXQgeyBjdXN0b21Db250ZW50SW5mbyB9ID0gdGhpcyAvLyBvbmx5IHBvcHVsYXRlZCBpZiB1c2luZyBub24tW3BdcmVhY3Qgbm9kZShzKVxuICAgIGxldCBpbm5lckNvbnRlbnQgPSB0aGlzLmdldElubmVyQ29udGVudCgpXG4gICAgbGV0IG1ldGEgPSB0aGlzLmdldENvbnRlbnRNZXRhKGlubmVyQ29udGVudClcblxuICAgIC8vIGluaXRpYWwgcnVuLCBvciBjb250ZW50LXR5cGUgY2hhbmdpbmc/IChmcm9tIHZ1ZSAtPiByZWFjdCBmb3IgZXhhbXBsZSlcbiAgICBpZiAoIWN1c3RvbUNvbnRlbnRJbmZvIHx8IGN1c3RvbUNvbnRlbnRJbmZvLmNvbnRlbnRLZXkgIT09IG1ldGEuY29udGVudEtleSkge1xuICAgICAgLy8gY2xlYXJpbmcgb2xkIHZhbHVlXG4gICAgICBpZiAoY3VzdG9tQ29udGVudEluZm8pIHtcbiAgICAgICAgaWYgKGN1c3RvbUNvbnRlbnRJbmZvLmRlc3Ryb3kpIHtcbiAgICAgICAgICBjdXN0b21Db250ZW50SW5mby5kZXN0cm95KClcbiAgICAgICAgfVxuICAgICAgICBjdXN0b21Db250ZW50SW5mbyA9IHRoaXMuY3VzdG9tQ29udGVudEluZm8gPSBudWxsXG4gICAgICB9XG4gICAgICAvLyBhc3NpZ25pbmcgbmV3IHZhbHVlXG4gICAgICBpZiAobWV0YS5jb250ZW50S2V5KSB7XG4gICAgICAgIGN1c3RvbUNvbnRlbnRJbmZvID0gdGhpcy5jdXN0b21Db250ZW50SW5mbyA9IHsgLy8gZm9yIG5vbi1bcF1yZWFjdFxuICAgICAgICAgIGNvbnRlbnRLZXk6IG1ldGEuY29udGVudEtleSxcbiAgICAgICAgICBjb250ZW50VmFsOiBpbm5lckNvbnRlbnRbbWV0YS5jb250ZW50S2V5XSxcbiAgICAgICAgICAuLi5tZXRhLmJ1aWxkTGlmZWN5Y2xlRnVuY3MoKSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIC8vIHVwZGF0aW5nXG4gICAgfSBlbHNlIGlmIChjdXN0b21Db250ZW50SW5mbykge1xuICAgICAgY3VzdG9tQ29udGVudEluZm8uY29udGVudFZhbCA9IGlubmVyQ29udGVudFttZXRhLmNvbnRlbnRLZXldXG4gICAgfVxuXG4gICAgcmV0dXJuIGN1c3RvbUNvbnRlbnRJbmZvXG4gICAgICA/IFtdIC8vIHNpZ25hbCB0aGF0IHNvbWV0aGluZyB3YXMgc3BlY2lmaWVkXG4gICAgICA6IGlubmVyQ29udGVudCAvLyBhc3N1bWUgYSBbcF1yZWFjdCB2ZG9tIG5vZGUuIHVzZSBpdFxuICB9XG5cbiAgcHJpdmF0ZSBnZXRJbm5lckNvbnRlbnQoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgaW5uZXJDb250ZW50ID0gbm9ybWFsaXplQ29udGVudChwcm9wcy5jb250ZW50LCBwcm9wcy5ob29rUHJvcHMpXG5cbiAgICBpZiAoaW5uZXJDb250ZW50ID09PSB1bmRlZmluZWQpIHsgLy8gdXNlIHRoZSBkZWZhdWx0XG4gICAgICBpbm5lckNvbnRlbnQgPSBub3JtYWxpemVDb250ZW50KHByb3BzLmRlZmF1bHRDb250ZW50LCBwcm9wcy5ob29rUHJvcHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIGlubmVyQ29udGVudCA9PSBudWxsID8gbnVsbCA6IGlubmVyQ29udGVudCAvLyBjb252ZXJ0IHVuZGVmaW5lZCB0byBudWxsIChiZXR0ZXIgZm9yIFJlYWN0KVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRDb250ZW50TWV0YShpbm5lckNvbnRlbnQ6IGFueSkge1xuICAgIGxldCB7IGNvbnRlbnRUeXBlSGFuZGxlcnMgfSA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rc1xuICAgIGxldCBjb250ZW50S2V5ID0gJydcbiAgICBsZXQgYnVpbGRMaWZlY3ljbGVGdW5jcyA9IG51bGxcblxuICAgIGlmIChpbm5lckNvbnRlbnQpIHsgLy8gYWxsb3dlZCB0byBiZSBudWxsLCBmb3IgY29udmVuaWVuY2UgdG8gY2FsbGVyXG4gICAgICBmb3IgKGxldCBzZWFyY2hLZXkgaW4gY29udGVudFR5cGVIYW5kbGVycykge1xuICAgICAgICBpZiAoaW5uZXJDb250ZW50W3NlYXJjaEtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnRlbnRLZXkgPSBzZWFyY2hLZXlcbiAgICAgICAgICBidWlsZExpZmVjeWNsZUZ1bmNzID0gY29udGVudFR5cGVIYW5kbGVyc1tzZWFyY2hLZXldXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGNvbnRlbnRLZXksIGJ1aWxkTGlmZWN5Y2xlRnVuY3MgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDdXN0b21Db250ZW50KCkge1xuICAgIGlmICh0aGlzLmN1c3RvbUNvbnRlbnRJbmZvKSB7IC8vIGZvciBub24tW3BdcmVhY3RcbiAgICAgIHRoaXMuY3VzdG9tQ29udGVudEluZm8ucmVuZGVyKFxuICAgICAgICB0aGlzLmlubmVyRWxSZWYuY3VycmVudCB8fCB0aGlzLnByb3BzLmJhY2t1cEVsUmVmLmN1cnJlbnQsIC8vIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpbnRvXG4gICAgICAgIHRoaXMuY3VzdG9tQ29udGVudEluZm8uY29udGVudFZhbCxcbiAgICAgIClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb3VudEhvb2tQcm9wczxDb250ZW50QXJnPiB7XG4gIGhvb2tQcm9wczogQ29udGVudEFyZ1xuICBkaWRNb3VudDogRGlkTW91bnRIYW5kbGVyPE1vdW50QXJnPENvbnRlbnRBcmc+PlxuICB3aWxsVW5tb3VudDogV2lsbFVubW91bnRIYW5kbGVyPE1vdW50QXJnPENvbnRlbnRBcmc+PlxuICBjaGlsZHJlbjogKHJvb3RFbFJlZjogUmVmPGFueT4pID0+IENvbXBvbmVudENoaWxkcmVuXG4gIGVsUmVmPzogUmVmPGFueT4gLy8gbWF5YmUgZ2V0IHJpZCBvZiBvbmNlIHdlIGhhdmUgYmV0dGVyIEFQSSBmb3IgY2FsbGVyIHRvIGNvbWJpbmUgcmVmc1xufVxuXG5leHBvcnQgY2xhc3MgTW91bnRIb29rPENvbnRlbnRBcmc+IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxNb3VudEhvb2tQcm9wczxDb250ZW50QXJnPj4ge1xuICByb290RWw6IEhUTUxFbGVtZW50XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuaGFuZGxlUm9vdEVsKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgbGV0IGNhbGxiYWNrID0gdGhpcy5wcm9wcy5kaWRNb3VudFxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayh7IC4uLnRoaXMucHJvcHMuaG9va1Byb3BzLCBlbDogdGhpcy5yb290RWwgfSlcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBsZXQgY2FsbGJhY2sgPSB0aGlzLnByb3BzLndpbGxVbm1vdW50XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKHsgLi4udGhpcy5wcm9wcy5ob29rUHJvcHMsIGVsOiB0aGlzLnJvb3RFbCB9KVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlUm9vdEVsID0gKHJvb3RFbDogSFRNTEVsZW1lbnQpID0+IHtcbiAgICB0aGlzLnJvb3RFbCA9IHJvb3RFbFxuXG4gICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCByb290RWwpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZENsYXNzTmFtZU5vcm1hbGl6ZXI8SG9va1Byb3BzPigpIHsgLy8gVE9ETzogZ2VuZXJhbCBkZWVwLW1lbW9pemVyP1xuICBsZXQgY3VycmVudEdlbmVyYXRvcjogQ2xhc3NOYW1lc0dlbmVyYXRvcjxIb29rUHJvcHM+XG4gIGxldCBjdXJyZW50SG9va1Byb3BzOiBIb29rUHJvcHNcbiAgbGV0IGN1cnJlbnRDbGFzc05hbWVzOiBzdHJpbmdbXSA9IFtdXG5cbiAgcmV0dXJuIChnZW5lcmF0b3I6IENsYXNzTmFtZXNHZW5lcmF0b3I8SG9va1Byb3BzPiwgaG9va1Byb3BzOiBIb29rUHJvcHMpID0+IHtcbiAgICBpZiAoIWN1cnJlbnRIb29rUHJvcHMgfHwgIWlzUHJvcHNFcXVhbChjdXJyZW50SG9va1Byb3BzLCBob29rUHJvcHMpIHx8IGdlbmVyYXRvciAhPT0gY3VycmVudEdlbmVyYXRvcikge1xuICAgICAgY3VycmVudEdlbmVyYXRvciA9IGdlbmVyYXRvclxuICAgICAgY3VycmVudEhvb2tQcm9wcyA9IGhvb2tQcm9wc1xuICAgICAgY3VycmVudENsYXNzTmFtZXMgPSBub3JtYWxpemVDbGFzc05hbWVzKGdlbmVyYXRvciwgaG9va1Byb3BzKVxuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50Q2xhc3NOYW1lc1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIENsYXNzTmFtZXNHZW5lcmF0b3I8SG9va1Byb3BzPiA9IENsYXNzTmFtZXNJbnB1dCB8ICgoaG9va1Byb3BzOiBIb29rUHJvcHMpID0+IENsYXNzTmFtZXNJbnB1dClcblxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NOYW1lczxIb29rUHJvcHM+KGNsYXNzTmFtZXM6IENsYXNzTmFtZXNHZW5lcmF0b3I8SG9va1Byb3BzPiwgaG9va1Byb3BzOiBIb29rUHJvcHMpOiBzdHJpbmdbXSB7XG4gIGlmICh0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzKGhvb2tQcm9wcylcbiAgfVxuXG4gIHJldHVybiBwYXJzZUNsYXNzTmFtZXMoY2xhc3NOYW1lcylcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGVudChpbnB1dCwgaG9va1Byb3BzKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaW5wdXQoaG9va1Byb3BzLCBjcmVhdGVFbGVtZW50KSAvLyBnaXZlIHRoZSBmdW5jdGlvbiB0aGUgdmRvbS1jcmVhdGlvbiBmdW5jXG4gIH1cbiAgcmV0dXJuIGlucHV0XG59XG4iLCJpbXBvcnQgeyBWaWV3U3BlYyB9IGZyb20gJy4uL3N0cnVjdHMvdmlldy1zcGVjJ1xuaW1wb3J0IHsgTW91bnRIb29rLCBidWlsZENsYXNzTmFtZU5vcm1hbGl6ZXIsIE1vdW50QXJnIH0gZnJvbSAnLi9yZW5kZXItaG9vaydcbmltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVFbGVtZW50LCBSZWYgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL3Zkb20tdXRpbCdcbmltcG9ydCB7IFZpZXdBcGkgfSBmcm9tICcuLi9WaWV3QXBpJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFZpZXdSb290UHJvcHMge1xuICB2aWV3U3BlYzogVmlld1NwZWNcbiAgY2hpbGRyZW46IChyb290RWxSZWY6IFJlZjxhbnk+LCBjbGFzc05hbWVzOiBzdHJpbmdbXSkgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbiAgZWxSZWY/OiBSZWY8YW55PlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZXdDb250ZW50QXJnIHtcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgdHlwZSBWaWV3TW91bnRBcmcgPSBNb3VudEFyZzxWaWV3Q29udGVudEFyZz5cblxuZXhwb3J0IGNsYXNzIFZpZXdSb290IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxWaWV3Um9vdFByb3BzPiB7XG4gIG5vcm1hbGl6ZUNsYXNzTmFtZXMgPSBidWlsZENsYXNzTmFtZU5vcm1hbGl6ZXI8Vmlld0NvbnRlbnRBcmc+KClcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0XG4gICAgbGV0IGhvb2tQcm9wczogVmlld0NvbnRlbnRBcmcgPSB7IHZpZXc6IGNvbnRleHQudmlld0FwaSB9XG4gICAgbGV0IGN1c3RvbUNsYXNzTmFtZXMgPSB0aGlzLm5vcm1hbGl6ZUNsYXNzTmFtZXMob3B0aW9ucy52aWV3Q2xhc3NOYW1lcywgaG9va1Byb3BzKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxNb3VudEhvb2tcbiAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgIGRpZE1vdW50PXtvcHRpb25zLnZpZXdEaWRNb3VudH1cbiAgICAgICAgd2lsbFVubW91bnQ9e29wdGlvbnMudmlld1dpbGxVbm1vdW50fVxuICAgICAgICBlbFJlZj17cHJvcHMuZWxSZWZ9XG4gICAgICA+XG4gICAgICAgIHsocm9vdEVsUmVmKSA9PiBwcm9wcy5jaGlsZHJlbihcbiAgICAgICAgICByb290RWxSZWYsXG4gICAgICAgICAgW2BmYy0ke3Byb3BzLnZpZXdTcGVjLnR5cGV9LXZpZXdgLCAnZmMtdmlldyddLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKSxcbiAgICAgICAgKX1cbiAgICAgIDwvTW91bnRIb29rPlxuICAgIClcbiAgfVxufVxuIiwiaW1wb3J0IHsgVmlld1Byb3BzIH0gZnJvbSAnLi4vVmlldydcbmltcG9ydCB7IG1hcEhhc2ggfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IENvbXBvbmVudFR5cGUsIENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBWaWV3Um9vdCB9IGZyb20gJy4uL2NvbW1vbi9WaWV3Um9vdCdcbmltcG9ydCB7IFJlbmRlckhvb2ssIE1vdW50QXJnIH0gZnJvbSAnLi4vY29tbW9uL3JlbmRlci1ob29rJ1xuaW1wb3J0IHsgVmlld0NvbnRleHQsIFZpZXdDb250ZXh0VHlwZSB9IGZyb20gJy4uL1ZpZXdDb250ZXh0J1xuaW1wb3J0IHsgVmlld09wdGlvbnMgfSBmcm9tICcuLi9vcHRpb25zJ1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuXG4vKlxuQSB2aWV3LWNvbmZpZyByZXByZXNlbnRzIGluZm9ybWF0aW9uIGZvciBlaXRoZXI6XG5BKSBjcmVhdGluZyBhIG5ldyBpbnN0YW50aWF0YWJsZSB2aWV3IGNsYXNzLiBpbiB3aGljaCBjYXNlLCBzdXBwbGllZCBhIGNsYXNzL3R5cGUgaW4gYWRkaXRpb24gdG8gb3B0aW9ucywgT1JcbkIpIG9wdGlvbnMgdG8gY3VzdG9taXplIGFuIGV4aXN0aW5nIHZpZXcsIGluIHdoaWNoIGNhc2Ugb25seSBwcm92aWRlcyBvcHRpb25zLlxuKi9cblxuZXhwb3J0IHR5cGUgVmlld0NvbXBvbmVudCA9IENvbXBvbmVudDxWaWV3UHJvcHM+IC8vIGFuIGluc3RhbmNlXG5leHBvcnQgdHlwZSBWaWV3Q29tcG9uZW50VHlwZSA9IENvbXBvbmVudFR5cGU8Vmlld1Byb3BzPlxuXG5leHBvcnQgdHlwZSBWaWV3Q29uZmlnSW5wdXQgPSBWaWV3Q29tcG9uZW50VHlwZSB8IFZpZXdPcHRpb25zXG5leHBvcnQgdHlwZSBWaWV3Q29uZmlnSW5wdXRIYXNoID0geyBbdmlld1R5cGU6IHN0cmluZ106IFZpZXdDb25maWdJbnB1dCB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlld0NvbmZpZyB7XG4gIHN1cGVyVHlwZTogc3RyaW5nXG4gIGNvbXBvbmVudDogVmlld0NvbXBvbmVudFR5cGUgfCBudWxsXG4gIHJhd09wdGlvbnM6IFZpZXdPcHRpb25zXG59XG5cbmV4cG9ydCB0eXBlIFZpZXdDb25maWdIYXNoID0geyBbdmlld1R5cGU6IHN0cmluZ106IFZpZXdDb25maWcgfVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlncyhpbnB1dHM6IFZpZXdDb25maWdJbnB1dEhhc2gpOiBWaWV3Q29uZmlnSGFzaCB7XG4gIHJldHVybiBtYXBIYXNoKGlucHV0cywgcGFyc2VWaWV3Q29uZmlnKVxufVxuXG5mdW5jdGlvbiBwYXJzZVZpZXdDb25maWcoaW5wdXQ6IFZpZXdDb25maWdJbnB1dCk6IFZpZXdDb25maWcge1xuICBsZXQgcmF3T3B0aW9uczogVmlld09wdGlvbnMgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicgP1xuICAgIHsgY29tcG9uZW50OiBpbnB1dCB9IDpcbiAgICBpbnB1dFxuICBsZXQgeyBjb21wb25lbnQgfSA9IHJhd09wdGlvbnNcblxuICBpZiAocmF3T3B0aW9ucy5jb250ZW50KSB7XG4gICAgY29tcG9uZW50ID0gY3JlYXRlVmlld0hvb2tDb21wb25lbnQocmF3T3B0aW9ucylcbiAgICAvLyBUT0RPOiByZW1vdmUgY29udGVudC9jbGFzc05hbWVzL2RpZE1vdW50L2V0YyBmcm9tIG9wdGlvbnM/XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1cGVyVHlwZTogcmF3T3B0aW9ucy50eXBlIGFzIGFueSxcbiAgICBjb21wb25lbnQ6IGNvbXBvbmVudCBhcyBhbnksXG4gICAgcmF3T3B0aW9ucywgLy8gaW5jbHVkZXMgdHlwZSBhbmQgY29tcG9uZW50IHRvbyA6KFxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BlY2lmaWNWaWV3Q29udGVudEFyZyBleHRlbmRzIFZpZXdQcm9wcyB7XG4gIG5leHREYXlUaHJlc2hvbGQ6IER1cmF0aW9uXG59XG5cbmV4cG9ydCB0eXBlIFNwZWNpZmljVmlld01vdW50QXJnID0gTW91bnRBcmc8U3BlY2lmaWNWaWV3Q29udGVudEFyZz5cblxuZnVuY3Rpb24gY3JlYXRlVmlld0hvb2tDb21wb25lbnQob3B0aW9uczogVmlld09wdGlvbnMpIHtcbiAgcmV0dXJuICh2aWV3UHJvcHM6IFZpZXdQcm9wcykgPT4gKFxuICAgIDxWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXI+XG4gICAgICB7KGNvbnRleHQ6IFZpZXdDb250ZXh0KSA9PiAoXG4gICAgICAgIDxWaWV3Um9vdCB2aWV3U3BlYz17Y29udGV4dC52aWV3U3BlY30+XG4gICAgICAgICAgeyh2aWV3RWxSZWYsIHZpZXdDbGFzc05hbWVzKSA9PiB7XG4gICAgICAgICAgICBsZXQgaG9va1Byb3BzOiBTcGVjaWZpY1ZpZXdDb250ZW50QXJnID0ge1xuICAgICAgICAgICAgICAuLi52aWV3UHJvcHMsXG4gICAgICAgICAgICAgIG5leHREYXlUaHJlc2hvbGQ6IGNvbnRleHQub3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPFJlbmRlckhvb2tcbiAgICAgICAgICAgICAgICBob29rUHJvcHM9e2hvb2tQcm9wc31cbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzPXtvcHRpb25zLmNsYXNzTmFtZXMgYXMgYW55fVxuICAgICAgICAgICAgICAgIGNvbnRlbnQ9e29wdGlvbnMuY29udGVudCBhcyBhbnl9XG4gICAgICAgICAgICAgICAgZGlkTW91bnQ9e29wdGlvbnMuZGlkTW91bnQgYXMgYW55fVxuICAgICAgICAgICAgICAgIHdpbGxVbm1vdW50PXtvcHRpb25zLndpbGxVbm1vdW50IGFzIGFueX1cbiAgICAgICAgICAgICAgICBlbFJlZj17dmlld0VsUmVmfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgeyhyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgPT4gKFxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3ZpZXdDbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKS5qb2luKCcgJyl9IHJlZj17cm9vdEVsUmVmfT5cbiAgICAgICAgICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvUmVuZGVySG9vaz5cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9fVxuICAgICAgICA8L1ZpZXdSb290PlxuICAgICAgKX1cbiAgICA8L1ZpZXdDb250ZXh0VHlwZS5Db25zdW1lcj5cbiAgKVxufVxuIiwiaW1wb3J0IHsgVmlld0RlZiwgY29tcGlsZVZpZXdEZWZzIH0gZnJvbSAnLi92aWV3LWRlZidcbmltcG9ydCB7IER1cmF0aW9uLCBjcmVhdGVEdXJhdGlvbiwgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yLCBEdXJhdGlvbklucHV0IH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IG1hcEhhc2ggfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IFZpZXdPcHRpb25zLCBDYWxlbmRhck9wdGlvbnMsIEJBU0VfT1BUSU9OX0RFRkFVTFRTIH0gZnJvbSAnLi4vb3B0aW9ucydcbmltcG9ydCB7IFZpZXdDb25maWdJbnB1dEhhc2gsIHBhcnNlVmlld0NvbmZpZ3MsIFZpZXdDb25maWdIYXNoLCBWaWV3Q29tcG9uZW50VHlwZSB9IGZyb20gJy4vdmlldy1jb25maWcnXG5cbi8qXG5SZXByZXNlbnRzIGV2ZXJ5dGhpbmcgbmVlZGVkIHRvIGluc3RhbnRpYXRlIGEgbmV3IHZpZXcgaW5zdGFuY2UsXG5pbmNsdWRpbmcgb3B0aW9ucyB0aGF0IGhhdmUgYmVlbiBjb21waWxlZCBmcm9tIHZpZXctc3BlY2lmaWMgYW5kIGNhbGVuZGFyLXdpZGUgb3B0aW9ucyxcbmFzIHdlbGwgYXMgZHVyYXRpb24gaW5mb3JtYXRpb24uXG5cbk92ZXJhbGwgZmxvdzpcblZpZXdDb25maWcgLT4gVmlld0RlZiAtPiBWaWV3U3BlY1xuKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmlld1NwZWMge1xuICB0eXBlOiBzdHJpbmdcbiAgY29tcG9uZW50OiBWaWV3Q29tcG9uZW50VHlwZVxuICBkdXJhdGlvbjogRHVyYXRpb25cbiAgZHVyYXRpb25Vbml0OiBzdHJpbmdcbiAgc2luZ2xlVW5pdDogc3RyaW5nXG4gIG9wdGlvbkRlZmF1bHRzOiBWaWV3T3B0aW9uc1xuICBvcHRpb25PdmVycmlkZXM6IFZpZXdPcHRpb25zXG4gIGJ1dHRvblRleHRPdmVycmlkZTogc3RyaW5nXG4gIGJ1dHRvblRleHREZWZhdWx0OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgVmlld1NwZWNIYXNoID0geyBbdmlld1R5cGU6IHN0cmluZ106IFZpZXdTcGVjIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkVmlld1NwZWNzKFxuICBkZWZhdWx0SW5wdXRzOiBWaWV3Q29uZmlnSW5wdXRIYXNoLFxuICBvcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyxcbiAgZHluYW1pY09wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLFxuICBsb2NhbGVEZWZhdWx0cyxcbik6IFZpZXdTcGVjSGFzaCB7XG4gIGxldCBkZWZhdWx0Q29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3MoZGVmYXVsdElucHV0cylcbiAgbGV0IG92ZXJyaWRlQ29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3Mob3B0aW9uT3ZlcnJpZGVzLnZpZXdzKVxuICBsZXQgdmlld0RlZnMgPSBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncylcblxuICByZXR1cm4gbWFwSGFzaCh2aWV3RGVmcywgKHZpZXdEZWYpID0+IGJ1aWxkVmlld1NwZWModmlld0RlZiwgb3ZlcnJpZGVDb25maWdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKSlcbn1cblxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlYyhcbiAgdmlld0RlZjogVmlld0RlZixcbiAgb3ZlcnJpZGVDb25maWdzOiBWaWV3Q29uZmlnSGFzaCxcbiAgb3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsXG4gIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyxcbiAgbG9jYWxlRGVmYXVsdHMsXG4pOiBWaWV3U3BlYyB7XG4gIGxldCBkdXJhdGlvbklucHV0ID1cbiAgICB2aWV3RGVmLm92ZXJyaWRlcy5kdXJhdGlvbiB8fFxuICAgIHZpZXdEZWYuZGVmYXVsdHMuZHVyYXRpb24gfHxcbiAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgb3B0aW9uT3ZlcnJpZGVzLmR1cmF0aW9uXG5cbiAgbGV0IGR1cmF0aW9uID0gbnVsbFxuICBsZXQgZHVyYXRpb25Vbml0ID0gJydcbiAgbGV0IHNpbmdsZVVuaXQgPSAnJ1xuICBsZXQgc2luZ2xlVW5pdE92ZXJyaWRlczogVmlld09wdGlvbnMgPSB7fVxuXG4gIGlmIChkdXJhdGlvbklucHV0KSB7XG4gICAgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbkNhY2hlZChkdXJhdGlvbklucHV0KVxuXG4gICAgaWYgKGR1cmF0aW9uKSB7IC8vIHZhbGlkP1xuICAgICAgbGV0IGRlbm9tID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cmF0aW9uKVxuICAgICAgZHVyYXRpb25Vbml0ID0gZGVub20udW5pdFxuXG4gICAgICBpZiAoZGVub20udmFsdWUgPT09IDEpIHtcbiAgICAgICAgc2luZ2xlVW5pdCA9IGR1cmF0aW9uVW5pdFxuICAgICAgICBzaW5nbGVVbml0T3ZlcnJpZGVzID0gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0gPyBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XS5yYXdPcHRpb25zIDoge31cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgcXVlcnlCdXR0b25UZXh0ID0gKG9wdGlvbnNTdWJzZXQpID0+IHtcbiAgICBsZXQgYnV0dG9uVGV4dE1hcCA9IG9wdGlvbnNTdWJzZXQuYnV0dG9uVGV4dCB8fCB7fVxuICAgIGxldCBidXR0b25UZXh0S2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5IGFzIHN0cmluZ1xuXG4gICAgaWYgKGJ1dHRvblRleHRLZXkgIT0gbnVsbCAmJiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldXG4gICAgfVxuXG4gICAgaWYgKGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdXG4gICAgfVxuXG4gICAgaWYgKGJ1dHRvblRleHRNYXBbc2luZ2xlVW5pdF0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbc2luZ2xlVW5pdF1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB2aWV3RGVmLnR5cGUsXG4gICAgY29tcG9uZW50OiB2aWV3RGVmLmNvbXBvbmVudCxcbiAgICBkdXJhdGlvbixcbiAgICBkdXJhdGlvblVuaXQsXG4gICAgc2luZ2xlVW5pdCxcbiAgICBvcHRpb25EZWZhdWx0czogdmlld0RlZi5kZWZhdWx0cyxcbiAgICBvcHRpb25PdmVycmlkZXM6IHsgLi4uc2luZ2xlVW5pdE92ZXJyaWRlcywgLi4udmlld0RlZi5vdmVycmlkZXMgfSxcblxuICAgIGJ1dHRvblRleHRPdmVycmlkZTpcbiAgICAgIHF1ZXJ5QnV0dG9uVGV4dChkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbk92ZXJyaWRlcykgfHwgLy8gY29uc3RydWN0b3Itc3BlY2lmaWVkIGJ1dHRvblRleHQgbG9va3VwIGhhc2ggdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgdmlld0RlZi5vdmVycmlkZXMuYnV0dG9uVGV4dCwgLy8gYGJ1dHRvblRleHRgIGZvciB2aWV3LXNwZWNpZmljIG9wdGlvbnMgaXMgYSBzdHJpbmdcblxuICAgIGJ1dHRvblRleHREZWZhdWx0OlxuICAgICAgcXVlcnlCdXR0b25UZXh0KGxvY2FsZURlZmF1bHRzKSB8fFxuICAgICAgdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0IHx8XG4gICAgICBxdWVyeUJ1dHRvblRleHQoQkFTRV9PUFRJT05fREVGQVVMVFMpIHx8XG4gICAgICB2aWV3RGVmLnR5cGUsIC8vIGZhbGwgYmFjayB0byBnaXZlbiB2aWV3IG5hbWVcbiAgfVxufVxuXG4vLyBoYWNrIHRvIGdldCBtZW1vaXphdGlvbiB3b3JraW5nXG5cbmxldCBkdXJhdGlvbklucHV0TWFwOiB7IFtqc29uOiBzdHJpbmddOiBEdXJhdGlvbiB9ID0ge31cblxuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dDogRHVyYXRpb25JbnB1dCkge1xuICBsZXQganNvbiA9IEpTT04uc3RyaW5naWZ5KGR1cmF0aW9uSW5wdXQpXG4gIGxldCByZXMgPSBkdXJhdGlvbklucHV0TWFwW2pzb25dXG5cbiAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmVzID0gY3JlYXRlRHVyYXRpb24oZHVyYXRpb25JbnB1dClcbiAgICBkdXJhdGlvbklucHV0TWFwW2pzb25dID0gcmVzXG4gIH1cblxuICByZXR1cm4gcmVzXG59XG4iLCJpbXBvcnQgeyBEYXRlTWFya2VyLCBzdGFydE9mRGF5LCBhZGREYXlzIH0gZnJvbSAnLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IER1cmF0aW9uLCBjcmVhdGVEdXJhdGlvbiwgYXNSb3VnaERheXMsIGFzUm91Z2hNcywgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yIH0gZnJvbSAnLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHtcbiAgRGF0ZVJhbmdlLFxuICBPcGVuRGF0ZVJhbmdlLFxuICBjb25zdHJhaW5NYXJrZXJUb1JhbmdlLFxuICBpbnRlcnNlY3RSYW5nZXMsXG4gIHJhbmdlc0ludGVyc2VjdCxcbiAgcGFyc2VSYW5nZSxcbiAgRGF0ZVJhbmdlSW5wdXQsXG59IGZyb20gJy4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgRGF0ZUVudiwgRGF0ZUlucHV0IH0gZnJvbSAnLi9kYXRlbGliL2VudidcbmltcG9ydCB7IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UgfSBmcm9tICcuL3V0aWwvZGF0ZSdcbmltcG9ydCB7IGdldE5vdyB9IGZyb20gJy4vcmVkdWNlcnMvY3VycmVudC1kYXRlJ1xuaW1wb3J0IHsgQ2FsZW5kYXJBcGkgfSBmcm9tICcuL0NhbGVuZGFyQXBpJ1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVQcm9maWxlIHtcbiAgY3VycmVudFJhbmdlOiBEYXRlUmFuZ2UgLy8gVE9ETzogZG9lcyB0aGlzIGluY2x1ZGUgc2xvdE1pblRpbWUvc2xvdE1heFRpbWU/XG4gIGN1cnJlbnRSYW5nZVVuaXQ6IHN0cmluZ1xuICBpc1JhbmdlQWxsRGF5OiBib29sZWFuXG4gIHZhbGlkUmFuZ2U6IE9wZW5EYXRlUmFuZ2VcbiAgYWN0aXZlUmFuZ2U6IERhdGVSYW5nZSB8IG51bGxcbiAgcmVuZGVyUmFuZ2U6IERhdGVSYW5nZVxuICBzbG90TWluVGltZTogRHVyYXRpb25cbiAgc2xvdE1heFRpbWU6IER1cmF0aW9uXG4gIGlzVmFsaWQ6IGJvb2xlYW5cbiAgZGF0ZUluY3JlbWVudDogRHVyYXRpb25cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRlUHJvZmlsZUdlbmVyYXRvclByb3BzIGV4dGVuZHMgRGF0ZVByb2ZpbGVPcHRpb25zIHtcbiAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyAvLyBub3QgdXNlZCBieSBEYXRlUHJvZmlsZUdlbmVyYXRvciBpdHNlbGZcbiAgZHVyYXRpb246IER1cmF0aW9uXG4gIGR1cmF0aW9uVW5pdDogc3RyaW5nXG4gIHVzZXNNaW5NYXhUaW1lOiBib29sZWFuXG4gIGRhdGVFbnY6IERhdGVFbnZcbiAgY2FsZW5kYXJBcGk6IENhbGVuZGFyQXBpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVByb2ZpbGVPcHRpb25zIHtcbiAgc2xvdE1pblRpbWU6IER1cmF0aW9uXG4gIHNsb3RNYXhUaW1lOiBEdXJhdGlvblxuICBzaG93Tm9uQ3VycmVudERhdGVzPzogYm9vbGVhblxuICBkYXlDb3VudD86IG51bWJlclxuICBkYXRlQWxpZ25tZW50Pzogc3RyaW5nXG4gIGRhdGVJbmNyZW1lbnQ/OiBEdXJhdGlvblxuICBoaWRkZW5EYXlzPzogbnVtYmVyW11cbiAgd2Vla2VuZHM/OiBib29sZWFuXG4gIG5vd0lucHV0PzogRGF0ZUlucHV0IHwgKCgpID0+IERhdGVJbnB1dClcbiAgdmFsaWRSYW5nZUlucHV0PzogRGF0ZVJhbmdlSW5wdXQgfCAoKHRoaXM6IENhbGVuZGFyQXBpLCBub3dEYXRlOiBEYXRlKSA9PiBEYXRlUmFuZ2VJbnB1dClcbiAgdmlzaWJsZVJhbmdlSW5wdXQ/OiBEYXRlUmFuZ2VJbnB1dCB8ICgodGhpczogQ2FsZW5kYXJBcGksIG5vd0RhdGU6IERhdGUpID0+IERhdGVSYW5nZUlucHV0KVxuICBtb250aE1vZGU/OiBib29sZWFuXG4gIGZpeGVkV2Vla0NvdW50PzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0ge1xuICBuZXcocHJvcHM6IERhdGVQcm9maWxlR2VuZXJhdG9yUHJvcHMpOiBEYXRlUHJvZmlsZUdlbmVyYXRvclxufVxuXG5leHBvcnQgY2xhc3MgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgeyAvLyBvbmx5IHB1YmxpY2x5IHVzZWQgZm9yIGlzSGlkZGVuRGF5IDooXG4gIG5vd0RhdGU6IERhdGVNYXJrZXJcblxuICBpc0hpZGRlbkRheUhhc2g6IGJvb2xlYW5bXVxuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBwcm9wczogRGF0ZVByb2ZpbGVHZW5lcmF0b3JQcm9wcykge1xuICAgIHRoaXMubm93RGF0ZSA9IGdldE5vdyhwcm9wcy5ub3dJbnB1dCwgcHJvcHMuZGF0ZUVudilcbiAgICB0aGlzLmluaXRIaWRkZW5EYXlzKClcbiAgfVxuXG4gIC8qIERhdGUgUmFuZ2UgQ29tcHV0YXRpb25cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cbiAgYnVpbGRQcmV2KGN1cnJlbnREYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlOiBEYXRlTWFya2VyLCBmb3JjZVRvVmFsaWQ/OiBib29sZWFuKTogRGF0ZVByb2ZpbGUge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMucHJvcHNcblxuICAgIGxldCBwcmV2RGF0ZSA9IGRhdGVFbnYuc3VidHJhY3QoXG4gICAgICBkYXRlRW52LnN0YXJ0T2YoY3VycmVudERhdGUsIGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSwgLy8gaW1wb3J0YW50IGZvciBzdGFydC1vZi1tb250aFxuICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQsXG4gICAgKVxuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGQocHJldkRhdGUsIC0xLCBmb3JjZVRvVmFsaWQpXG4gIH1cblxuICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJuZXh0XCIgdmlldy5cbiAgYnVpbGROZXh0KGN1cnJlbnREYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlOiBEYXRlTWFya2VyLCBmb3JjZVRvVmFsaWQ/OiBib29sZWFuKTogRGF0ZVByb2ZpbGUge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMucHJvcHNcblxuICAgIGxldCBuZXh0RGF0ZSA9IGRhdGVFbnYuYWRkKFxuICAgICAgZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgIGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50LFxuICAgIClcblxuICAgIHJldHVybiB0aGlzLmJ1aWxkKG5leHREYXRlLCAxLCBmb3JjZVRvVmFsaWQpXG4gIH1cblxuICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgaG9sZGluZyBkYXRlcy9yYW5nZXMgZm9yIHJlbmRlcmluZyBhcm91bmQgdGhlIGdpdmVuIGRhdGUuXG4gIC8vIE9wdGlvbmFsIGRpcmVjdGlvbiBwYXJhbSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0ZSBpcyBiZWluZyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZFxuICAvLyBmcm9tIGl0cyBwcmV2aW91cyB2YWx1ZS4gZGVjcmVtZW50ZWQgPSAtMSwgaW5jcmVtZW50ZWQgPSAxIChkZWZhdWx0KS5cbiAgYnVpbGQoY3VycmVudERhdGU6IERhdGVNYXJrZXIsIGRpcmVjdGlvbj8sIGZvcmNlVG9WYWxpZCA9IHRydWUpOiBEYXRlUHJvZmlsZSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgdmFsaWRSYW5nZTogRGF0ZVJhbmdlXG4gICAgbGV0IGN1cnJlbnRJbmZvXG4gICAgbGV0IGlzUmFuZ2VBbGxEYXlcbiAgICBsZXQgcmVuZGVyUmFuZ2U6IERhdGVSYW5nZVxuICAgIGxldCBhY3RpdmVSYW5nZTogRGF0ZVJhbmdlXG4gICAgbGV0IGlzVmFsaWRcblxuICAgIHZhbGlkUmFuZ2UgPSB0aGlzLmJ1aWxkVmFsaWRSYW5nZSgpXG4gICAgdmFsaWRSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXModmFsaWRSYW5nZSlcblxuICAgIGlmIChmb3JjZVRvVmFsaWQpIHtcbiAgICAgIGN1cnJlbnREYXRlID0gY29uc3RyYWluTWFya2VyVG9SYW5nZShjdXJyZW50RGF0ZSwgdmFsaWRSYW5nZSlcbiAgICB9XG5cbiAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24pXG4gICAgaXNSYW5nZUFsbERheSA9IC9eKHllYXJ8bW9udGh8d2Vla3xkYXkpJC8udGVzdChjdXJyZW50SW5mby51bml0KVxuICAgIHJlbmRlclJhbmdlID0gdGhpcy5idWlsZFJlbmRlclJhbmdlKFxuICAgICAgdGhpcy50cmltSGlkZGVuRGF5cyhjdXJyZW50SW5mby5yYW5nZSksXG4gICAgICBjdXJyZW50SW5mby51bml0LFxuICAgICAgaXNSYW5nZUFsbERheSxcbiAgICApXG4gICAgcmVuZGVyUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHJlbmRlclJhbmdlKVxuICAgIGFjdGl2ZVJhbmdlID0gcmVuZGVyUmFuZ2VcblxuICAgIGlmICghcHJvcHMuc2hvd05vbkN1cnJlbnREYXRlcykge1xuICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIGN1cnJlbnRJbmZvLnJhbmdlKVxuICAgIH1cblxuICAgIGFjdGl2ZVJhbmdlID0gdGhpcy5hZGp1c3RBY3RpdmVSYW5nZShhY3RpdmVSYW5nZSlcbiAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgdmFsaWRSYW5nZSkgLy8gbWlnaHQgcmV0dXJuIG51bGxcblxuICAgIC8vIGl0J3MgaW52YWxpZCBpZiB0aGUgb3JpZ2luYWxseSByZXF1ZXN0ZWQgZGF0ZSBpcyBub3QgY29udGFpbmVkLFxuICAgIC8vIG9yIGlmIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IG91dHNpZGUgb2YgdGhlIHZhbGlkIHJhbmdlLlxuICAgIGlzVmFsaWQgPSByYW5nZXNJbnRlcnNlY3QoY3VycmVudEluZm8ucmFuZ2UsIHZhbGlkUmFuZ2UpXG5cbiAgICByZXR1cm4ge1xuICAgICAgLy8gY29uc3RyYWludCBmb3Igd2hlcmUgcHJldi9uZXh0IG9wZXJhdGlvbnMgY2FuIGdvIGFuZCB3aGVyZSBldmVudHMgY2FuIGJlIGRyYWdnZWQvcmVzaXplZCB0by5cbiAgICAgIC8vIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIHN0YXJ0IGFuZCBlbmQgcHJvcGVydGllcy5cbiAgICAgIHZhbGlkUmFuZ2UsXG5cbiAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cbiAgICAgIC8vIGZvciBleGFtcGxlLCBhIG1vbnRoIHZpZXcgbWlnaHQgaGF2ZSAxc3QtMzFzdCwgZXhjbHVkaW5nIHBhZGRlZCBkYXRlc1xuICAgICAgY3VycmVudFJhbmdlOiBjdXJyZW50SW5mby5yYW5nZSxcblxuICAgICAgLy8gbmFtZSBvZiBsYXJnZXN0IHVuaXQgYmVpbmcgZGlzcGxheWVkLCBsaWtlIFwibW9udGhcIiBvciBcIndlZWtcIlxuICAgICAgY3VycmVudFJhbmdlVW5pdDogY3VycmVudEluZm8udW5pdCxcblxuICAgICAgaXNSYW5nZUFsbERheSxcblxuICAgICAgLy8gZGF0ZXMgdGhhdCBkaXNwbGF5IGV2ZW50cyBhbmQgYWNjZXB0IGRyYWctbi1kcm9wXG4gICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXG4gICAgICBhY3RpdmVSYW5nZSxcblxuICAgICAgLy8gZGF0ZSByYW5nZSB3aXRoIGEgcmVuZGVyZWQgc2tlbGV0b25cbiAgICAgIC8vIGluY2x1ZGVzIG5vdC1hY3RpdmUgZGF5cyB0aGF0IG5lZWQgc29tZSBzb3J0IG9mIERPTVxuICAgICAgcmVuZGVyUmFuZ2UsXG5cbiAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGZpcnN0IHZpc2libGUgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XG4gICAgICBzbG90TWluVGltZTogcHJvcHMuc2xvdE1pblRpbWUsXG5cbiAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgIHNsb3RNYXhUaW1lOiBwcm9wcy5zbG90TWF4VGltZSxcblxuICAgICAgaXNWYWxpZCxcblxuICAgICAgLy8gaG93IGZhciB0aGUgY3VycmVudCBkYXRlIHdpbGwgbW92ZSBmb3IgYSBwcmV2L25leHQgb3BlcmF0aW9uXG4gICAgICBkYXRlSW5jcmVtZW50OiB0aGlzLmJ1aWxkRGF0ZUluY3JlbWVudChjdXJyZW50SW5mby5kdXJhdGlvbiksXG4gICAgICAvLyBwYXNzIGEgZmFsbGJhY2sgKG1pZ2h0IGJlIG51bGwpIF5cbiAgICB9XG4gIH1cblxuICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXG4gIC8vIEluZGljYXRlcyB0aGUgbWluaW11bS9tYXhpbXVtIGRhdGVzIHRvIGRpc3BsYXkuXG4gIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXG4gIGJ1aWxkVmFsaWRSYW5nZSgpOiBPcGVuRGF0ZVJhbmdlIHtcbiAgICBsZXQgaW5wdXQgPSB0aGlzLnByb3BzLnZhbGlkUmFuZ2VJbnB1dFxuICAgIGxldCBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBpbnB1dC5jYWxsKHRoaXMucHJvcHMuY2FsZW5kYXJBcGksIHRoaXMubm93RGF0ZSlcbiAgICAgIDogaW5wdXRcblxuICAgIHJldHVybiB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KSB8fFxuICAgICAgeyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH0gLy8gY29tcGxldGVseSBvcGVuLWVuZGVkXG4gIH1cblxuICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcbiAgLy8gaGlnaGxpZ2h0ZWQgYXMgYmVpbmcgdGhlIGN1cnJlbnQgbW9udGggZm9yIGV4YW1wbGUuXG4gIC8vIFNlZSBidWlsZCgpIGZvciBhIGRlc2NyaXB0aW9uIG9mIGBkaXJlY3Rpb25gLlxuICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXG4gIGJ1aWxkQ3VycmVudFJhbmdlSW5mbyhkYXRlOiBEYXRlTWFya2VyLCBkaXJlY3Rpb24pIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCBkdXJhdGlvbiA9IG51bGxcbiAgICBsZXQgdW5pdCA9IG51bGxcbiAgICBsZXQgcmFuZ2UgPSBudWxsXG4gICAgbGV0IGRheUNvdW50XG5cbiAgICBpZiAocHJvcHMuZHVyYXRpb24pIHtcbiAgICAgIGR1cmF0aW9uID0gcHJvcHMuZHVyYXRpb25cbiAgICAgIHVuaXQgPSBwcm9wcy5kdXJhdGlvblVuaXRcbiAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpXG4gICAgfSBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLnByb3BzLmRheUNvdW50KSkge1xuICAgICAgdW5pdCA9ICdkYXknXG4gICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EYXlDb3VudChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KVxuICAgIH0gZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcbiAgICAgIHVuaXQgPSBwcm9wcy5kYXRlRW52LmdyZWF0ZXN0V2hvbGVVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpLnVuaXRcbiAgICB9IGVsc2Uge1xuICAgICAgZHVyYXRpb24gPSB0aGlzLmdldEZhbGxiYWNrRHVyYXRpb24oKVxuICAgICAgdW5pdCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbikudW5pdFxuICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdClcbiAgICB9XG5cbiAgICByZXR1cm4geyBkdXJhdGlvbiwgdW5pdCwgcmFuZ2UgfVxuICB9XG5cbiAgZ2V0RmFsbGJhY2tEdXJhdGlvbigpOiBEdXJhdGlvbiB7XG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZGF5OiAxIH0pXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgbmV3IGFjdGl2ZVJhbmdlIHRvIGhhdmUgdGltZSB2YWx1ZXMgKHVuLWFtYmlndWF0ZSlcbiAgLy8gc2xvdE1pblRpbWUgb3Igc2xvdE1heFRpbWUgY2F1c2VzIHRoZSByYW5nZSB0byBleHBhbmQuXG4gIGFkanVzdEFjdGl2ZVJhbmdlKHJhbmdlOiBEYXRlUmFuZ2UpIHtcbiAgICBsZXQgeyBkYXRlRW52LCB1c2VzTWluTWF4VGltZSwgc2xvdE1pblRpbWUsIHNsb3RNYXhUaW1lIH0gPSB0aGlzLnByb3BzXG4gICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2VcblxuICAgIGlmICh1c2VzTWluTWF4VGltZSkge1xuICAgICAgLy8gZXhwYW5kIGFjdGl2ZSByYW5nZSBpZiBzbG90TWluVGltZSBpcyBuZWdhdGl2ZSAod2h5IG5vdCB3aGVuIHBvc2l0aXZlPylcbiAgICAgIGlmIChhc1JvdWdoRGF5cyhzbG90TWluVGltZSkgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCkgLy8gbmVjZXNzYXJ5P1xuICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbG90TWluVGltZSlcbiAgICAgIH1cblxuICAgICAgLy8gZXhwYW5kIGFjdGl2ZSByYW5nZSBpZiBzbG90TWF4VGltZSBpcyBiZXlvbmQgb25lIGRheSAod2h5IG5vdCB3aGVuIG5lZ2F0aXZlPylcbiAgICAgIGlmIChhc1JvdWdoRGF5cyhzbG90TWF4VGltZSkgPiAxKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKSAvLyBuZWNlc3Nhcnk/XG4gICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAtMSlcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBzbG90TWF4VGltZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH1cbiAgfVxuXG4gIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBpdCBpcyBzcGVjaWZpZWQgYXMgYW4gZXhwbGljaXQgZHVyYXRpb24uXG4gIC8vIGB1bml0YCBpcyB0aGUgYWxyZWFkeS1jb21wdXRlZCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgdW5pdCBvZiBkdXJhdGlvbi5cbiAgYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlOiBEYXRlTWFya2VyLCBkaXJlY3Rpb24sIGR1cmF0aW9uOiBEdXJhdGlvbiwgdW5pdCkge1xuICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHNcbiAgICBsZXQgc3RhcnQ6IERhdGVNYXJrZXJcbiAgICBsZXQgZW5kOiBEYXRlTWFya2VyXG4gICAgbGV0IHJlc1xuXG4gICAgLy8gY29tcHV0ZSB3aGF0IHRoZSBhbGlnbm1lbnQgc2hvdWxkIGJlXG4gICAgaWYgKCFkYXRlQWxpZ25tZW50KSB7XG4gICAgICBsZXQgeyBkYXRlSW5jcmVtZW50IH0gPSB0aGlzLnByb3BzXG5cbiAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgIC8vIHVzZSB0aGUgc21hbGxlciBvZiB0aGUgdHdvIHVuaXRzXG4gICAgICAgIGlmIChhc1JvdWdoTXMoZGF0ZUluY3JlbWVudCkgPCBhc1JvdWdoTXMoZHVyYXRpb24pKSB7XG4gICAgICAgICAgZGF0ZUFsaWdubWVudCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkYXRlSW5jcmVtZW50KS51bml0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0ZUFsaWdubWVudCA9IHVuaXRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZUFsaWdubWVudCA9IHVuaXRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxuICAgIGlmIChhc1JvdWdoRGF5cyhkdXJhdGlvbikgPD0gMSkge1xuICAgICAgaWYgKHRoaXMuaXNIaWRkZW5EYXkoc3RhcnQpKSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKVxuICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVJlcygpIHtcbiAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mKGRhdGUsIGRhdGVBbGlnbm1lbnQpXG4gICAgICBlbmQgPSBkYXRlRW52LmFkZChzdGFydCwgZHVyYXRpb24pXG4gICAgICByZXMgPSB7IHN0YXJ0LCBlbmQgfVxuICAgIH1cblxuICAgIGNvbXB1dGVSZXMoKVxuXG4gICAgLy8gaWYgcmFuZ2UgaXMgY29tcGxldGVseSBlbnZlbG9wZWQgYnkgaGlkZGVuIGRheXMsIGdvIHBhc3QgdGhlIGhpZGRlbiBkYXlzXG4gICAgaWYgKCF0aGlzLnRyaW1IaWRkZW5EYXlzKHJlcykpIHtcbiAgICAgIGRhdGUgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGRhdGUsIGRpcmVjdGlvbilcbiAgICAgIGNvbXB1dGVSZXMoKVxuICAgIH1cblxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBhIGRheUNvdW50IGlzIHNwZWNpZmllZC5cbiAgYnVpbGRSYW5nZUZyb21EYXlDb3VudChkYXRlOiBEYXRlTWFya2VyLCBkaXJlY3Rpb24sIGRheUNvdW50KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgZGF0ZUFsaWdubWVudCB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCBydW5uaW5nQ291bnQgPSAwXG4gICAgbGV0IHN0YXJ0OiBEYXRlTWFya2VyID0gZGF0ZVxuICAgIGxldCBlbmQ6IERhdGVNYXJrZXJcblxuICAgIGlmIChkYXRlQWxpZ25tZW50KSB7XG4gICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZihzdGFydCwgZGF0ZUFsaWdubWVudClcbiAgICB9XG5cbiAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpXG4gICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pXG5cbiAgICBlbmQgPSBzdGFydFxuICAgIGRvIHtcbiAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAxKVxuICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuRGF5KGVuZCkpIHtcbiAgICAgICAgcnVubmluZ0NvdW50ICs9IDFcbiAgICAgIH1cbiAgICB9IHdoaWxlIChydW5uaW5nQ291bnQgPCBkYXlDb3VudClcblxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfVxuICB9XG5cbiAgLy8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcbiAgLy8gd2hpY2ggaXMgYSB3YXkgdG8gZGVmaW5lIHRoZSBjdXJyZW50UmFuZ2UgYW5kIGFjdGl2ZVJhbmdlIGF0IHRoZSBzYW1lIHRpbWUuXG4gIGJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGU6IERhdGVNYXJrZXIpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCBpbnB1dCA9IHByb3BzLnZpc2libGVSYW5nZUlucHV0XG4gICAgbGV0IHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGlucHV0LmNhbGwocHJvcHMuY2FsZW5kYXJBcGksIHByb3BzLmRhdGVFbnYudG9EYXRlKGRhdGUpKVxuICAgICAgOiBpbnB1dFxuXG4gICAgbGV0IHJhbmdlID0gdGhpcy5yZWZpbmVSYW5nZShzaW1wbGVJbnB1dClcblxuICAgIGlmIChyYW5nZSAmJiAocmFuZ2Uuc3RhcnQgPT0gbnVsbCB8fCByYW5nZS5lbmQgPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlXG4gIH1cblxuICAvLyBDb21wdXRlcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZWxlbWVudC9jZWxscyBmb3IgKnJlbmRlcmluZyosXG4gIC8vIGJ1dCB3aGljaCBtYXkgaGF2ZSB2b2lkZWQgZGF5cy90aW1lcy5cbiAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2U6IERhdGVSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSkge1xuICAgIHJldHVybiBjdXJyZW50UmFuZ2VcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGR1cmF0aW9uIHZhbHVlIHRoYXQgc2hvdWxkIGJlIGFkZGVkL3N1YnN0cmFjdGVkIHRvIHRoZSBjdXJyZW50IGRhdGVcbiAgLy8gd2hlbiBhIHByZXYvbmV4dCBvcGVyYXRpb24gaGFwcGVucy5cbiAgYnVpbGREYXRlSW5jcmVtZW50KGZhbGxiYWNrKTogRHVyYXRpb24ge1xuICAgIGxldCB7IGRhdGVJbmNyZW1lbnQgfSA9IHRoaXMucHJvcHNcbiAgICBsZXQgY3VzdG9tQWxpZ25tZW50XG5cbiAgICBpZiAoZGF0ZUluY3JlbWVudCkge1xuICAgICAgcmV0dXJuIGRhdGVJbmNyZW1lbnRcbiAgICB9XG5cbiAgICBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMucHJvcHMuZGF0ZUFsaWdubWVudCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbigxLCBjdXN0b21BbGlnbm1lbnQpXG4gICAgfVxuXG4gICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZmFsbGJhY2tcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXlzOiAxIH0pXG4gIH1cblxuICByZWZpbmVSYW5nZShyYW5nZUlucHV0OiBEYXRlUmFuZ2VJbnB1dCB8IHVuZGVmaW5lZCk6IERhdGVSYW5nZSB8IG51bGwge1xuICAgIGlmIChyYW5nZUlucHV0KSB7XG4gICAgICBsZXQgcmFuZ2UgPSBwYXJzZVJhbmdlKHJhbmdlSW5wdXQsIHRoaXMucHJvcHMuZGF0ZUVudilcblxuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZShyYW5nZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmdlXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qIEhpZGRlbiBEYXlzXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gSW5pdGlhbGl6ZXMgaW50ZXJuYWwgdmFyaWFibGVzIHJlbGF0ZWQgdG8gY2FsY3VsYXRpbmcgaGlkZGVuIGRheXMtb2Ytd2Vla1xuICBpbml0SGlkZGVuRGF5cygpIHtcbiAgICBsZXQgaGlkZGVuRGF5cyA9IHRoaXMucHJvcHMuaGlkZGVuRGF5cyB8fCBbXSAvLyBhcnJheSBvZiBkYXktb2Ytd2VlayBpbmRpY2VzIHRoYXQgYXJlIGhpZGRlblxuICAgIGxldCBpc0hpZGRlbkRheUhhc2ggPSBbXSAvLyBpcyB0aGUgZGF5LW9mLXdlZWsgaGlkZGVuPyAoaGFzaCB3aXRoIGRheS1vZi13ZWVrLWluZGV4IC0+IGJvb2wpXG4gICAgbGV0IGRheUNudCA9IDBcbiAgICBsZXQgaVxuXG4gICAgaWYgKHRoaXMucHJvcHMud2Vla2VuZHMgPT09IGZhbHNlKSB7XG4gICAgICBoaWRkZW5EYXlzLnB1c2goMCwgNikgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSArPSAxKSB7XG4gICAgICBpZiAoXG4gICAgICAgICEoaXNIaWRkZW5EYXlIYXNoW2ldID0gaGlkZGVuRGF5cy5pbmRleE9mKGkpICE9PSAtMSlcbiAgICAgICkge1xuICAgICAgICBkYXlDbnQgKz0gMVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZGF5Q250KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGlkZGVuRGF5cycpIC8vIGFsbCBkYXlzIHdlcmUgaGlkZGVuPyBiYWQuXG4gICAgfVxuXG4gICAgdGhpcy5pc0hpZGRlbkRheUhhc2ggPSBpc0hpZGRlbkRheUhhc2hcbiAgfVxuXG4gIC8vIFJlbW92ZSBkYXlzIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSByYW5nZSB0aGF0IGFyZSBjb21wdXRlZCBhcyBoaWRkZW4uXG4gIC8vIElmIHRoZSB3aG9sZSByYW5nZSBpcyB0cmltbWVkIG9mZiwgcmV0dXJucyBudWxsXG4gIHRyaW1IaWRkZW5EYXlzKHJhbmdlOiBEYXRlUmFuZ2UpOiBEYXRlUmFuZ2UgfCBudWxsIHtcbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSByYW5nZVxuXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQpXG4gICAgfVxuXG4gICAgaWYgKGVuZCkge1xuICAgICAgZW5kID0gdGhpcy5za2lwSGlkZGVuRGF5cyhlbmQsIC0xLCB0cnVlKVxuICAgIH1cblxuICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XG4gICAgICByZXR1cm4geyBzdGFydCwgZW5kIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gSXMgdGhlIGN1cnJlbnQgZGF5IGhpZGRlbj9cbiAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBEYXRlICh1c2VkIGZvciBVVEMpXG4gIGlzSGlkZGVuRGF5KGRheSkge1xuICAgIGlmIChkYXkgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBkYXkgPSBkYXkuZ2V0VVRDRGF5KClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNIaWRkZW5EYXlIYXNoW2RheV1cbiAgfVxuXG4gIC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cbiAgLy8gRE9FUyBOT1QgQ09OU0lERVIgdmFsaWRSYW5nZSFcbiAgLy8gSWYgdGhlIGluaXRpYWwgdmFsdWUgb2YgYGRhdGVgIGlzIG5vdCBhIGhpZGRlbiBkYXksIGRvbid0IGRvIGFueXRoaW5nLlxuICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxuICAvLyBgaW5jYCBkZWZhdWx0cyB0byBgMWAgKGluY3JlbWVudCBvbmUgZGF5IGZvcndhcmQgZWFjaCB0aW1lKVxuICBza2lwSGlkZGVuRGF5cyhkYXRlOiBEYXRlTWFya2VyLCBpbmMgPSAxLCBpc0V4Y2x1c2l2ZSA9IGZhbHNlKSB7XG4gICAgd2hpbGUgKFxuICAgICAgdGhpcy5pc0hpZGRlbkRheUhhc2hbKGRhdGUuZ2V0VVRDRGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN11cbiAgICApIHtcbiAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIGluYylcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVcbiAgfVxufVxuIiwiaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9BY3Rpb24nXG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VWaWV3VHlwZSh2aWV3VHlwZTogc3RyaW5nLCBhY3Rpb246IEFjdGlvbik6IHN0cmluZyB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgIHZpZXdUeXBlID0gYWN0aW9uLnZpZXdUeXBlXG4gIH1cblxuICByZXR1cm4gdmlld1R5cGVcbn1cbiIsImltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vQWN0aW9uJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb246IEFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSAnU0VUX09QVElPTic6XG4gICAgICByZXR1cm4geyAuLi5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBbYWN0aW9uLm9wdGlvbk5hbWVdOiBhY3Rpb24ucmF3T3B0aW9uVmFsdWUgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZHluYW1pY09wdGlvbk92ZXJyaWRlc1xuICB9XG59XG4iLCJpbXBvcnQgeyBEYXRlUHJvZmlsZSwgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vQWN0aW9uJ1xuaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlRGF0ZVByb2ZpbGUoXG4gIGN1cnJlbnREYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUgfCBudWxsLFxuICBhY3Rpb246IEFjdGlvbixcbiAgY3VycmVudERhdGU6IERhdGVNYXJrZXIsXG4gIGRhdGVQcm9maWxlR2VuZXJhdG9yOiBEYXRlUHJvZmlsZUdlbmVyYXRvcixcbik6IERhdGVQcm9maWxlIHtcbiAgbGV0IGRwOiBEYXRlUHJvZmlsZVxuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlciB8fCBjdXJyZW50RGF0ZSlcblxuICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlcilcblxuICAgIGNhc2UgJ1BSRVYnOlxuICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSlcbiAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiBkcFxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ05FWFQnOlxuICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSlcbiAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiBkcFxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50RGF0ZVByb2ZpbGVcbn1cbiIsImltcG9ydCB7IEV2ZW50U291cmNlLCBFdmVudFNvdXJjZUhhc2ggfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZSdcbmltcG9ydCB7IHBhcnNlRXZlbnRTb3VyY2UsIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtc291cmNlLXBhcnNlJ1xuaW1wb3J0IHsgYXJyYXlUb0hhc2gsIGZpbHRlckhhc2ggfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcbmltcG9ydCB7IGd1aWQgfSBmcm9tICcuLi91dGlsL21pc2MnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBDYWxlbmRhck9wdGlvbnMgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdEV2ZW50U291cmNlcyhjYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsXG5cbiAgcmV0dXJuIGFkZFNvdXJjZXMoXG4gICAge30sXG4gICAgcGFyc2VJbml0aWFsU291cmNlcyhjYWxlbmRhck9wdGlvbnMsIGNvbnRleHQpLFxuICAgIGFjdGl2ZVJhbmdlLFxuICAgIGNvbnRleHQsXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlcyhcbiAgZXZlbnRTb3VyY2VzOiBFdmVudFNvdXJjZUhhc2gsXG4gIGFjdGlvbjogQWN0aW9uLFxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbik6IEV2ZW50U291cmNlSGFzaCB7XG4gIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsIC8vIG5lZWQgdGhpcyBjaGVjaz9cblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSAnQUREX0VWRU5UX1NPVVJDRVMnOiAvLyBhbHJlYWR5IHBhcnNlZFxuICAgICAgcmV0dXJuIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpXG5cbiAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgIHJldHVybiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQpXG5cbiAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgY2FzZSAnTkVYVCc6XG4gICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgIHJldHVybiBmZXRjaERpcnR5U291cmNlcyhldmVudFNvdXJjZXMsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50U291cmNlc1xuXG4gICAgY2FzZSAnRkVUQ0hfRVZFTlRfU09VUkNFUyc6XG4gICAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoXG4gICAgICAgIGV2ZW50U291cmNlcyxcbiAgICAgICAgKGFjdGlvbiBhcyBhbnkpLnNvdXJjZUlkcyA/IC8vIHdoeSBubyB0eXBlP1xuICAgICAgICAgIGFycmF5VG9IYXNoKChhY3Rpb24gYXMgYW55KS5zb3VyY2VJZHMpIDpcbiAgICAgICAgICBleGNsdWRlU3RhdGljU291cmNlcyhldmVudFNvdXJjZXMsIGNvbnRleHQpLFxuICAgICAgICBhY3RpdmVSYW5nZSxcbiAgICAgICAgYWN0aW9uLmlzUmVmZXRjaCB8fCBmYWxzZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzpcbiAgICBjYXNlICdSRUNFSVZFX0VWRU5UX0VSUk9SJzpcbiAgICAgIHJldHVybiByZWNlaXZlUmVzcG9uc2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQsIGFjdGlvbi5mZXRjaElkLCBhY3Rpb24uZmV0Y2hSYW5nZSlcblxuICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICByZXR1cm4ge31cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZXZlbnRTb3VyY2VzXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lKGV2ZW50U291cmNlczogRXZlbnRTb3VyY2VIYXNoLCBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbCAvLyBuZWVkIHRoaXMgY2hlY2s/XG5cbiAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKFxuICAgIGV2ZW50U291cmNlcyxcbiAgICBleGNsdWRlU3RhdGljU291cmNlcyhldmVudFNvdXJjZXMsIGNvbnRleHQpLFxuICAgIGFjdGl2ZVJhbmdlLFxuICAgIHRydWUsXG4gICAgY29udGV4dCxcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoZXZlbnRTb3VyY2VzOiBFdmVudFNvdXJjZUhhc2gpOiBib29sZWFuIHtcbiAgZm9yIChsZXQgc291cmNlSWQgaW4gZXZlbnRTb3VyY2VzKSB7XG4gICAgaWYgKGV2ZW50U291cmNlc1tzb3VyY2VJZF0uaXNGZXRjaGluZykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWRkU291cmNlcyhcbiAgZXZlbnRTb3VyY2VIYXNoOiBFdmVudFNvdXJjZUhhc2gsXG4gIHNvdXJjZXM6IEV2ZW50U291cmNlPGFueT5bXSxcbiAgZmV0Y2hSYW5nZTogRGF0ZVJhbmdlIHwgbnVsbCxcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuKTogRXZlbnRTb3VyY2VIYXNoIHtcbiAgbGV0IGhhc2g6IEV2ZW50U291cmNlSGFzaCA9IHt9XG5cbiAgZm9yIChsZXQgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICBoYXNoW3NvdXJjZS5zb3VyY2VJZF0gPSBzb3VyY2VcbiAgfVxuXG4gIGlmIChmZXRjaFJhbmdlKSB7XG4gICAgaGFzaCA9IGZldGNoRGlydHlTb3VyY2VzKGhhc2gsIGZldGNoUmFuZ2UsIGNvbnRleHQpXG4gIH1cblxuICByZXR1cm4geyAuLi5ldmVudFNvdXJjZUhhc2gsIC4uLmhhc2ggfVxufVxuXG5mdW5jdGlvbiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VIYXNoOiBFdmVudFNvdXJjZUhhc2gsIHNvdXJjZUlkOiBzdHJpbmcpOiBFdmVudFNvdXJjZUhhc2gge1xuICByZXR1cm4gZmlsdGVySGFzaChldmVudFNvdXJjZUhhc2gsIChldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PikgPT4gZXZlbnRTb3VyY2Uuc291cmNlSWQgIT09IHNvdXJjZUlkKVxufVxuXG5mdW5jdGlvbiBmZXRjaERpcnR5U291cmNlcyhzb3VyY2VIYXNoOiBFdmVudFNvdXJjZUhhc2gsIGZldGNoUmFuZ2U6IERhdGVSYW5nZSwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KTogRXZlbnRTb3VyY2VIYXNoIHtcbiAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKFxuICAgIHNvdXJjZUhhc2gsXG4gICAgZmlsdGVySGFzaChzb3VyY2VIYXNoLCAoZXZlbnRTb3VyY2UpID0+IGlzU291cmNlRGlydHkoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNvbnRleHQpKSxcbiAgICBmZXRjaFJhbmdlLFxuICAgIGZhbHNlLFxuICAgIGNvbnRleHQsXG4gIClcbn1cblxuZnVuY3Rpb24gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PiwgZmV0Y2hSYW5nZTogRGF0ZVJhbmdlLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgaWYgKCFkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSkge1xuICAgIHJldHVybiAhZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZFxuICB9XG4gIHJldHVybiAhY29udGV4dC5vcHRpb25zLmxhenlGZXRjaGluZyB8fFxuICAgICAgIWV2ZW50U291cmNlLmZldGNoUmFuZ2UgfHxcbiAgICAgIGV2ZW50U291cmNlLmlzRmV0Y2hpbmcgfHwgLy8gYWx3YXlzIGNhbmNlbCBvdXRkYXRlZCBpbi1wcm9ncmVzcyBmZXRjaGVzXG4gICAgICBmZXRjaFJhbmdlLnN0YXJ0IDwgZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZS5zdGFydCB8fFxuICAgICAgZmV0Y2hSYW5nZS5lbmQgPiBldmVudFNvdXJjZS5mZXRjaFJhbmdlLmVuZFxufVxuXG5mdW5jdGlvbiBmZXRjaFNvdXJjZXNCeUlkcyhcbiAgcHJldlNvdXJjZXM6IEV2ZW50U291cmNlSGFzaCxcbiAgc291cmNlSWRIYXNoOiB7IFtzb3VyY2VJZDogc3RyaW5nXTogYW55IH0sXG4gIGZldGNoUmFuZ2U6IERhdGVSYW5nZSxcbiAgaXNSZWZldGNoOiBib29sZWFuLFxuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4pOiBFdmVudFNvdXJjZUhhc2gge1xuICBsZXQgbmV4dFNvdXJjZXM6IEV2ZW50U291cmNlSGFzaCA9IHt9XG5cbiAgZm9yIChsZXQgc291cmNlSWQgaW4gcHJldlNvdXJjZXMpIHtcbiAgICBsZXQgc291cmNlID0gcHJldlNvdXJjZXNbc291cmNlSWRdXG5cbiAgICBpZiAoc291cmNlSWRIYXNoW3NvdXJjZUlkXSkge1xuICAgICAgbmV4dFNvdXJjZXNbc291cmNlSWRdID0gZmV0Y2hTb3VyY2Uoc291cmNlLCBmZXRjaFJhbmdlLCBpc1JlZmV0Y2gsIGNvbnRleHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IHNvdXJjZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0U291cmNlc1xufVxuXG5mdW5jdGlvbiBmZXRjaFNvdXJjZShldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PiwgZmV0Y2hSYW5nZTogRGF0ZVJhbmdlLCBpc1JlZmV0Y2g6IGJvb2xlYW4sIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBsZXQgeyBvcHRpb25zLCBjYWxlbmRhckFwaSB9ID0gY29udGV4dFxuICBsZXQgc291cmNlRGVmID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdXG4gIGxldCBmZXRjaElkID0gZ3VpZCgpXG5cbiAgc291cmNlRGVmLmZldGNoKFxuICAgIHtcbiAgICAgIGV2ZW50U291cmNlLFxuICAgICAgcmFuZ2U6IGZldGNoUmFuZ2UsXG4gICAgICBpc1JlZmV0Y2gsXG4gICAgICBjb250ZXh0LFxuICAgIH0sXG4gICAgKHJlcykgPT4geyAvLyBzdWNjZXNzIGNhbGxiYWNrXG4gICAgICBsZXQgeyByYXdFdmVudHMgfSA9IHJlc1xuXG4gICAgICBpZiAob3B0aW9ucy5ldmVudFNvdXJjZVN1Y2Nlc3MpIHtcbiAgICAgICAgcmF3RXZlbnRzID0gb3B0aW9ucy5ldmVudFNvdXJjZVN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMueGhyKSB8fCByYXdFdmVudHNcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50U291cmNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgcmF3RXZlbnRzID0gZXZlbnRTb3VyY2Uuc3VjY2Vzcy5jYWxsKGNhbGVuZGFyQXBpLCByYXdFdmVudHMsIHJlcy54aHIpIHx8IHJhd0V2ZW50c1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRTJyxcbiAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICBmZXRjaElkLFxuICAgICAgICBmZXRjaFJhbmdlLFxuICAgICAgICByYXdFdmVudHMsXG4gICAgICB9KVxuICAgIH0sXG4gICAgKGVycm9yKSA9PiB7IC8vIGZhaWx1cmUgY2FsbGJhY2tcbiAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlLCBlcnJvcilcblxuICAgICAgaWYgKG9wdGlvbnMuZXZlbnRTb3VyY2VGYWlsdXJlKSB7XG4gICAgICAgIG9wdGlvbnMuZXZlbnRTb3VyY2VGYWlsdXJlLmNhbGwoY2FsZW5kYXJBcGksIGVycm9yKVxuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnRTb3VyY2UuZmFpbHVyZSkge1xuICAgICAgICBldmVudFNvdXJjZS5mYWlsdXJlKGVycm9yKVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRfRVJST1InLFxuICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIGZldGNoSWQsXG4gICAgICAgIGZldGNoUmFuZ2UsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSlcbiAgICB9LFxuICApXG5cbiAgcmV0dXJuIHtcbiAgICAuLi5ldmVudFNvdXJjZSxcbiAgICBpc0ZldGNoaW5nOiB0cnVlLFxuICAgIGxhdGVzdEZldGNoSWQ6IGZldGNoSWQsXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjZWl2ZVJlc3BvbnNlKHNvdXJjZUhhc2g6IEV2ZW50U291cmNlSGFzaCwgc291cmNlSWQ6IHN0cmluZywgZmV0Y2hJZDogc3RyaW5nLCBmZXRjaFJhbmdlOiBEYXRlUmFuZ2UpIHtcbiAgbGV0IGV2ZW50U291cmNlOiBFdmVudFNvdXJjZTxhbnk+ID0gc291cmNlSGFzaFtzb3VyY2VJZF1cblxuICBpZiAoXG4gICAgZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgIGZldGNoSWQgPT09IGV2ZW50U291cmNlLmxhdGVzdEZldGNoSWRcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNvdXJjZUhhc2gsXG4gICAgICBbc291cmNlSWRdOiB7XG4gICAgICAgIC4uLmV2ZW50U291cmNlLFxuICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgICAgZmV0Y2hSYW5nZSwgLy8gYWxzbyBzZXJ2ZXMgYXMgYSBtYXJrZXIgdGhhdCBhdCBsZWFzdCBvbmUgZmV0Y2ggaGFzIGNvbXBsZXRlZFxuICAgICAgfSxcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc291cmNlSGFzaFxufVxuXG5mdW5jdGlvbiBleGNsdWRlU3RhdGljU291cmNlcyhldmVudFNvdXJjZXM6IEV2ZW50U291cmNlSGFzaCwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KTogRXZlbnRTb3VyY2VIYXNoIHtcbiAgcmV0dXJuIGZpbHRlckhhc2goZXZlbnRTb3VyY2VzLCAoZXZlbnRTb3VyY2UpID0+IGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpKVxufVxuXG5mdW5jdGlvbiBwYXJzZUluaXRpYWxTb3VyY2VzKHJhd09wdGlvbnM6IENhbGVuZGFyT3B0aW9ucywgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCByZWZpbmVycyA9IGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KVxuICBsZXQgcmF3U291cmNlcyA9IFtdLmNvbmNhdChyYXdPcHRpb25zLmV2ZW50U291cmNlcyB8fCBbXSlcbiAgbGV0IHNvdXJjZXMgPSBbXSAvLyBwYXJzZWRcblxuICBpZiAocmF3T3B0aW9ucy5pbml0aWFsRXZlbnRzKSB7XG4gICAgcmF3U291cmNlcy51bnNoaWZ0KHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cylcbiAgfVxuXG4gIGlmIChyYXdPcHRpb25zLmV2ZW50cykge1xuICAgIHJhd1NvdXJjZXMudW5zaGlmdChyYXdPcHRpb25zLmV2ZW50cylcbiAgfVxuXG4gIGZvciAobGV0IHJhd1NvdXJjZSBvZiByYXdTb3VyY2VzKSB7XG4gICAgbGV0IHNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2UocmF3U291cmNlLCBjb250ZXh0LCByZWZpbmVycylcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3VyY2VzXG59XG5cbmZ1bmN0aW9uIGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2U6IEV2ZW50U291cmNlPGFueT4sIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBsZXQgZGVmcyA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzXG5cbiAgcmV0dXJuICFkZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXS5pZ25vcmVSYW5nZVxufVxuIiwiaW1wb3J0IHsgZmlsdGVySGFzaCwgbWFwSGFzaCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgRXZlbnREZWYgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LWRlZidcbmltcG9ydCB7IEV2ZW50SW5zdGFuY2UsIEV2ZW50SW5zdGFuY2VIYXNoIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1pbnN0YW5jZSdcbmltcG9ydCB7IEV2ZW50SW5wdXQgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXBhcnNlJ1xuaW1wb3J0IHtcbiAgRXZlbnRTdG9yZSxcbiAgbWVyZ2VFdmVudFN0b3JlcyxcbiAgY3JlYXRlRW1wdHlFdmVudFN0b3JlLFxuICBmaWx0ZXJFdmVudFN0b3JlRGVmcyxcbiAgZXhjbHVkZVN1YkV2ZW50U3RvcmUsXG4gIHBhcnNlRXZlbnRzLFxufSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9BY3Rpb24nXG5pbXBvcnQgeyBFdmVudFNvdXJjZUhhc2gsIEV2ZW50U291cmNlIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4uL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgRGF0ZUVudiB9IGZyb20gJy4uL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgZXhwYW5kUmVjdXJyaW5nIH0gZnJvbSAnLi4vc3RydWN0cy9yZWN1cnJpbmctZXZlbnQnXG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VFdmVudFN0b3JlKFxuICBldmVudFN0b3JlOiBFdmVudFN0b3JlLFxuICBhY3Rpb246IEFjdGlvbixcbiAgZXZlbnRTb3VyY2VzOiBFdmVudFNvdXJjZUhhc2gsXG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSxcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuKTogRXZlbnRTdG9yZSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdSRUNFSVZFX0VWRU5UUyc6IC8vIHJhd1xuICAgICAgcmV0dXJuIHJlY2VpdmVSYXdFdmVudHMoXG4gICAgICAgIGV2ZW50U3RvcmUsXG4gICAgICAgIGV2ZW50U291cmNlc1thY3Rpb24uc291cmNlSWRdLFxuICAgICAgICBhY3Rpb24uZmV0Y2hJZCxcbiAgICAgICAgYWN0aW9uLmZldGNoUmFuZ2UsXG4gICAgICAgIGFjdGlvbi5yYXdFdmVudHMsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICBjYXNlICdBRERfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQsIGJ1dCBub3QgZXhwYW5kZWRcbiAgICAgIHJldHVybiBhZGRFdmVudChcbiAgICAgICAgZXZlbnRTdG9yZSxcbiAgICAgICAgYWN0aW9uLmV2ZW50U3RvcmUsIC8vIG5ldyBvbmVzXG4gICAgICAgIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgY2FzZSAnUkVTRVRfRVZFTlRTJzpcbiAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRTdG9yZVxuXG4gICAgY2FzZSAnTUVSR0VfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQgYW5kIGV4cGFuZGVkXG4gICAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSlcblxuICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICBjYXNlICdORVhUJzpcbiAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhldmVudFN0b3JlLCBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dClcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudFN0b3JlXG5cbiAgICBjYXNlICdSRU1PVkVfRVZFTlRTJzpcbiAgICAgIHJldHVybiBleGNsdWRlU3ViRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSlcblxuICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgcmV0dXJuIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGFjdGlvbi5zb3VyY2VJZClcblxuICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICByZXR1cm4gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgKGV2ZW50RGVmOiBFdmVudERlZikgPT4gKFxuICAgICAgICAhZXZlbnREZWYuc291cmNlSWQgLy8gb25seSBrZWVwIGV2ZW50cyB3aXRoIG5vIHNvdXJjZSBpZFxuICAgICAgKSlcblxuICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRTJzpcbiAgICAgIHJldHVybiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBldmVudFN0b3JlXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjZWl2ZVJhd0V2ZW50cyhcbiAgZXZlbnRTdG9yZTogRXZlbnRTdG9yZSxcbiAgZXZlbnRTb3VyY2U6IEV2ZW50U291cmNlPGFueT4sXG4gIGZldGNoSWQ6IHN0cmluZyxcbiAgZmV0Y2hSYW5nZTogRGF0ZVJhbmdlIHwgbnVsbCxcbiAgcmF3RXZlbnRzOiBFdmVudElucHV0W10sXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbik6IEV2ZW50U3RvcmUge1xuICBpZiAoXG4gICAgZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgIGZldGNoSWQgPT09IGV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQgLy8gVE9ETzogd2lzaCB0aGlzIGxvZ2ljIHdhcyBhbHdheXMgaW4gZXZlbnQtc291cmNlc1xuICApIHtcbiAgICBsZXQgc3Vic2V0ID0gcGFyc2VFdmVudHMoXG4gICAgICB0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCksXG4gICAgICBldmVudFNvdXJjZSxcbiAgICAgIGNvbnRleHQsXG4gICAgKVxuXG4gICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGZldGNoUmFuZ2UsIGNvbnRleHQpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoXG4gICAgICBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBldmVudFNvdXJjZS5zb3VyY2VJZCksXG4gICAgICBzdWJzZXQsXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50U3RvcmVcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtUmF3RXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2U6IEV2ZW50U291cmNlPGFueT4sIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBsZXQgY2FsRWFjaFRyYW5zZm9ybSA9IGNvbnRleHQub3B0aW9ucy5ldmVudERhdGFUcmFuc2Zvcm1cbiAgbGV0IHNvdXJjZUVhY2hUcmFuc2Zvcm0gPSBldmVudFNvdXJjZSA/IGV2ZW50U291cmNlLmV2ZW50RGF0YVRyYW5zZm9ybSA6IG51bGxcblxuICBpZiAoc291cmNlRWFjaFRyYW5zZm9ybSkge1xuICAgIHJhd0V2ZW50cyA9IHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIHNvdXJjZUVhY2hUcmFuc2Zvcm0pXG4gIH1cblxuICBpZiAoY2FsRWFjaFRyYW5zZm9ybSkge1xuICAgIHJhd0V2ZW50cyA9IHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGNhbEVhY2hUcmFuc2Zvcm0pXG4gIH1cblxuICByZXR1cm4gcmF3RXZlbnRzXG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGZ1bmMpIHtcbiAgbGV0IHJlZmluZWRFdmVudHNcblxuICBpZiAoIWZ1bmMpIHtcbiAgICByZWZpbmVkRXZlbnRzID0gcmF3RXZlbnRzXG4gIH0gZWxzZSB7XG4gICAgcmVmaW5lZEV2ZW50cyA9IFtdXG5cbiAgICBmb3IgKGxldCByYXdFdmVudCBvZiByYXdFdmVudHMpIHtcbiAgICAgIGxldCByZWZpbmVkRXZlbnQgPSBmdW5jKHJhd0V2ZW50KVxuXG4gICAgICBpZiAocmVmaW5lZEV2ZW50KSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyZWZpbmVkRXZlbnQpXG4gICAgICB9IGVsc2UgaWYgKHJlZmluZWRFdmVudCA9PSBudWxsKSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyYXdFdmVudClcbiAgICAgIH0gLy8gaWYgYSBkaWZmZXJlbnQgZmFsc3kgdmFsdWUsIGRvIG5vdGhpbmdcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVmaW5lZEV2ZW50c1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudChldmVudFN0b3JlOiBFdmVudFN0b3JlLCBzdWJzZXQ6IEV2ZW50U3RvcmUsIGV4cGFuZFJhbmdlOiBEYXRlUmFuZ2UgfCBudWxsLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudFN0b3JlIHtcbiAgaWYgKGV4cGFuZFJhbmdlKSB7XG4gICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZXhwYW5kUmFuZ2UsIGNvbnRleHQpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBzdWJzZXQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSwgb2xkRGF0ZUVudjogRGF0ZUVudiwgbmV3RGF0ZUVudjogRGF0ZUVudik6IEV2ZW50U3RvcmUge1xuICBsZXQgeyBkZWZzIH0gPSBldmVudFN0b3JlXG5cbiAgbGV0IGluc3RhbmNlcyA9IG1hcEhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIChpbnN0YW5jZTogRXZlbnRJbnN0YW5jZSk6IEV2ZW50SW5zdGFuY2UgPT4ge1xuICAgIGxldCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXVxuXG4gICAgaWYgKGRlZi5hbGxEYXkgfHwgZGVmLnJlY3VycmluZ0RlZikge1xuICAgICAgcmV0dXJuIGluc3RhbmNlIC8vIGlzbid0IGRlcGVuZGVudCBvbiB0aW1lem9uZVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uaW5zdGFuY2UsXG4gICAgICByYW5nZToge1xuICAgICAgICBzdGFydDogbmV3RGF0ZUVudi5jcmVhdGVNYXJrZXIob2xkRGF0ZUVudi50b0RhdGUoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvKSksXG4gICAgICAgIGVuZDogbmV3RGF0ZUVudi5jcmVhdGVNYXJrZXIob2xkRGF0ZUVudi50b0RhdGUoaW5zdGFuY2UucmFuZ2UuZW5kLCBpbnN0YW5jZS5mb3JjZWRFbmRUem8pKSxcbiAgICAgIH0sXG4gICAgICBmb3JjZWRTdGFydFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgZm9yY2VkRW5kVHpvOiBuZXdEYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQgPyBudWxsIDogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgIH1cbiAgfSlcblxuICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfVxufVxuXG5mdW5jdGlvbiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlOiBFdmVudFN0b3JlLCBzb3VyY2VJZDogc3RyaW5nKSB7XG4gIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCAoZXZlbnREZWY6IEV2ZW50RGVmKSA9PiBldmVudERlZi5zb3VyY2VJZCAhPT0gc291cmNlSWQpXG59XG5cbi8vIFFVRVNUSU9OOiB3aHkgbm90IGp1c3QgcmV0dXJuIGluc3RhbmNlcz8gZG8gYSBnZW5lcmFsIG9iamVjdC1wcm9wZXJ0eS1leGNsdXNpb24gdXRpbFxuZXhwb3J0IGZ1bmN0aW9uIGV4Y2x1ZGVJbnN0YW5jZXMoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSwgcmVtb3ZhbHM6IEV2ZW50SW5zdGFuY2VIYXNoKTogRXZlbnRTdG9yZSB7XG4gIHJldHVybiB7XG4gICAgZGVmczogZXZlbnRTdG9yZS5kZWZzLFxuICAgIGluc3RhbmNlczogZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlOiBFdmVudEluc3RhbmNlKSA9PiAhcmVtb3ZhbHNbaW5zdGFuY2UuaW5zdGFuY2VJZF0pLFxuICB9XG59XG4iLCJpbXBvcnQgeyBEYXRlU3BhbiB9IGZyb20gJy4uL3N0cnVjdHMvZGF0ZS1zcGFuJ1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9BY3Rpb24nXG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VEYXRlU2VsZWN0aW9uKGN1cnJlbnRTZWxlY3Rpb246IERhdGVTcGFuIHwgbnVsbCwgYWN0aW9uOiBBY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ1VOU0VMRUNUX0RBVEVTJzpcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBjYXNlICdTRUxFQ1RfREFURVMnOlxuICAgICAgcmV0dXJuIGFjdGlvbi5zZWxlY3Rpb25cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvblxuICB9XG59XG4iLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZVNlbGVjdGVkRXZlbnQoY3VycmVudEluc3RhbmNlSWQ6IHN0cmluZywgYWN0aW9uOiBBY3Rpb24pOiBzdHJpbmcge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSAnVU5TRUxFQ1RfRVZFTlQnOlxuICAgICAgcmV0dXJuICcnXG5cbiAgICBjYXNlICdTRUxFQ1RfRVZFTlQnOlxuICAgICAgcmV0dXJuIGFjdGlvbi5ldmVudEluc3RhbmNlSWRcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY3VycmVudEluc3RhbmNlSWRcbiAgfVxufVxuIiwiaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9BY3Rpb24nXG5pbXBvcnQgeyBFdmVudEludGVyYWN0aW9uU3RhdGUgfSBmcm9tICcuLi9pbnRlcmFjdGlvbnMvZXZlbnQtaW50ZXJhY3Rpb24tc3RhdGUnXG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VFdmVudERyYWcoY3VycmVudERyYWc6IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB8IG51bGwsIGFjdGlvbjogQWN0aW9uKTogRXZlbnRJbnRlcmFjdGlvblN0YXRlIHwgbnVsbCB7XG4gIGxldCBuZXdEcmFnOiBFdmVudEludGVyYWN0aW9uU3RhdGVcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSAnVU5TRVRfRVZFTlRfRFJBRyc6XG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgY2FzZSAnU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgbmV3RHJhZyA9IGFjdGlvbi5zdGF0ZVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3RHJhZy5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3RHJhZy5tdXRhdGVkRXZlbnRzLFxuICAgICAgICBpc0V2ZW50OiBuZXdEcmFnLmlzRXZlbnQsXG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGN1cnJlbnREcmFnXG4gIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4uL2ludGVyYWN0aW9ucy9ldmVudC1pbnRlcmFjdGlvbi1zdGF0ZSdcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vQWN0aW9uJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlRXZlbnRSZXNpemUoY3VycmVudFJlc2l6ZTogRXZlbnRJbnRlcmFjdGlvblN0YXRlIHwgbnVsbCwgYWN0aW9uOiBBY3Rpb24pOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsIHtcbiAgbGV0IG5ld1Jlc2l6ZTogRXZlbnRJbnRlcmFjdGlvblN0YXRlXG5cbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ1VOU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgY2FzZSAnU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICBuZXdSZXNpemUgPSBhY3Rpb24uc3RhdGVcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWZmZWN0ZWRFdmVudHM6IG5ld1Jlc2l6ZS5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3UmVzaXplLm11dGF0ZWRFdmVudHMsXG4gICAgICAgIGlzRXZlbnQ6IG5ld1Jlc2l6ZS5pc0V2ZW50LFxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjdXJyZW50UmVzaXplXG4gIH1cbn1cbiIsImltcG9ydCB7IFZpZXdTcGVjLCBWaWV3U3BlY0hhc2ggfSBmcm9tICcuL3N0cnVjdHMvdmlldy1zcGVjJ1xuaW1wb3J0IHsgVGhlbWUgfSBmcm9tICcuL3RoZW1lL1RoZW1lJ1xuaW1wb3J0IHsgbWFwSGFzaCB9IGZyb20gJy4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBDYWxlbmRhckFwaSB9IGZyb20gJy4vQ2FsZW5kYXJBcGknXG5pbXBvcnQgeyBDYWxlbmRhck9wdGlvbnNSZWZpbmVkLCBDYWxlbmRhck9wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMnXG5pbXBvcnQgeyBUb29sYmFySW5wdXQsIFRvb2xiYXJNb2RlbCwgVG9vbGJhcldpZGdldCwgQ3VzdG9tQnV0dG9uSW5wdXQgfSBmcm9tICcuL3Rvb2xiYXItc3RydWN0J1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUb29sYmFycyhcbiAgY2FsZW5kYXJPcHRpb25zOiBDYWxlbmRhck9wdGlvbnNSZWZpbmVkLFxuICBjYWxlbmRhck9wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLFxuICB0aGVtZTogVGhlbWUsXG4gIHZpZXdTcGVjczogVmlld1NwZWNIYXNoLFxuICBjYWxlbmRhckFwaTogQ2FsZW5kYXJBcGksXG4pIHtcbiAgbGV0IHZpZXdzV2l0aEJ1dHRvbnM6IHN0cmluZ1tdID0gW11cbiAgbGV0IGhlYWRlclRvb2xiYXIgPSBjYWxlbmRhck9wdGlvbnMuaGVhZGVyVG9vbGJhciA/IHBhcnNlVG9vbGJhcihcbiAgICBjYWxlbmRhck9wdGlvbnMuaGVhZGVyVG9vbGJhcixcbiAgICBjYWxlbmRhck9wdGlvbnMsXG4gICAgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsXG4gICAgdGhlbWUsXG4gICAgdmlld1NwZWNzLFxuICAgIGNhbGVuZGFyQXBpLFxuICAgIHZpZXdzV2l0aEJ1dHRvbnMsXG4gICkgOiBudWxsXG4gIGxldCBmb290ZXJUb29sYmFyID0gY2FsZW5kYXJPcHRpb25zLmZvb3RlclRvb2xiYXIgPyBwYXJzZVRvb2xiYXIoXG4gICAgY2FsZW5kYXJPcHRpb25zLmZvb3RlclRvb2xiYXIsXG4gICAgY2FsZW5kYXJPcHRpb25zLFxuICAgIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLFxuICAgIHRoZW1lLFxuICAgIHZpZXdTcGVjcyxcbiAgICBjYWxlbmRhckFwaSxcbiAgICB2aWV3c1dpdGhCdXR0b25zLFxuICApIDogbnVsbFxuXG4gIHJldHVybiB7IGhlYWRlclRvb2xiYXIsIGZvb3RlclRvb2xiYXIsIHZpZXdzV2l0aEJ1dHRvbnMgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRvb2xiYXIoXG4gIHNlY3Rpb25TdHJIYXNoOiBUb29sYmFySW5wdXQsXG4gIGNhbGVuZGFyT3B0aW9uczogQ2FsZW5kYXJPcHRpb25zUmVmaW5lZCxcbiAgY2FsZW5kYXJPcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyxcbiAgdGhlbWU6IFRoZW1lLFxuICB2aWV3U3BlY3M6IFZpZXdTcGVjSGFzaCxcbiAgY2FsZW5kYXJBcGk6IENhbGVuZGFyQXBpLFxuICB2aWV3c1dpdGhCdXR0b25zOiBzdHJpbmdbXSwgLy8gZHVtcCBzaWRlIGVmZmVjdHNcbikgOiBUb29sYmFyTW9kZWwge1xuICByZXR1cm4gbWFwSGFzaChcbiAgICBzZWN0aW9uU3RySGFzaCBhcyB7IFtzZWN0aW9uOiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgICAoc2VjdGlvblN0cikgPT4gcGFyc2VTZWN0aW9uKHNlY3Rpb25TdHIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpLCB2aWV3c1dpdGhCdXR0b25zKSxcbiAgKVxufVxuXG4vKlxuQkFEOiBxdWVyeWluZyBpY29ucyBhbmQgdGV4dCBoZXJlLiBzaG91bGQgYmUgZG9uZSBhdCByZW5kZXIgdGltZVxuKi9cbmZ1bmN0aW9uIHBhcnNlU2VjdGlvbihcbiAgc2VjdGlvblN0cjogc3RyaW5nLFxuICBjYWxlbmRhck9wdGlvbnM6IENhbGVuZGFyT3B0aW9uc1JlZmluZWQsXG4gIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsXG4gIHRoZW1lOiBUaGVtZSxcbiAgdmlld1NwZWNzOiBWaWV3U3BlY0hhc2gsXG4gIGNhbGVuZGFyQXBpOiBDYWxlbmRhckFwaSxcbiAgdmlld3NXaXRoQnV0dG9uczogc3RyaW5nW10sIC8vIGR1bXAgc2lkZSBlZmZlY3RzXG4pOiBUb29sYmFyV2lkZ2V0W11bXSB7XG4gIGxldCBpc1J0bCA9IGNhbGVuZGFyT3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnXG4gIGxldCBjYWxlbmRhckN1c3RvbUJ1dHRvbnMgPSBjYWxlbmRhck9wdGlvbnMuY3VzdG9tQnV0dG9ucyB8fCB7fVxuICBsZXQgY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzID0gY2FsZW5kYXJPcHRpb25PdmVycmlkZXMuYnV0dG9uVGV4dCB8fCB7fVxuICBsZXQgY2FsZW5kYXJCdXR0b25UZXh0ID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvblRleHQgfHwge31cbiAgbGV0IHNlY3Rpb25TdWJzdHJzID0gc2VjdGlvblN0ciA/IHNlY3Rpb25TdHIuc3BsaXQoJyAnKSA6IFtdXG5cbiAgcmV0dXJuIHNlY3Rpb25TdWJzdHJzLm1hcChcbiAgICAoYnV0dG9uR3JvdXBTdHIpOiBUb29sYmFyV2lkZ2V0W10gPT4gKFxuICAgICAgYnV0dG9uR3JvdXBTdHIuc3BsaXQoJywnKS5tYXAoKGJ1dHRvbk5hbWUpOiBUb29sYmFyV2lkZ2V0ID0+IHtcbiAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICByZXR1cm4geyBidXR0b25OYW1lIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjdXN0b21CdXR0b25Qcm9wczogQ3VzdG9tQnV0dG9uSW5wdXRcbiAgICAgICAgbGV0IHZpZXdTcGVjOiBWaWV3U3BlY1xuICAgICAgICBsZXQgYnV0dG9uQ2xpY2tcbiAgICAgICAgbGV0IGJ1dHRvbkljb24gLy8gb25seSBvbmUgb2YgdGhlc2Ugd2lsbCBiZSBzZXRcbiAgICAgICAgbGV0IGJ1dHRvblRleHQgLy8gXCJcblxuICAgICAgICBpZiAoKGN1c3RvbUJ1dHRvblByb3BzID0gY2FsZW5kYXJDdXN0b21CdXR0b25zW2J1dHRvbk5hbWVdKSkge1xuICAgICAgICAgIGJ1dHRvbkNsaWNrID0gKGV2OiBVSUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2spIHtcbiAgICAgICAgICAgICAgY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2suY2FsbChldi50YXJnZXQsIGV2LCBldi50YXJnZXQpIC8vIFRPRE86IHVzZSBDYWxlbmRhciB0aGlzIGNvbnRleHQ/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykpIHx8XG4gICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGN1c3RvbUJ1dHRvblByb3BzLnRleHQpXG4gICAgICAgIH0gZWxzZSBpZiAoKHZpZXdTcGVjID0gdmlld1NwZWNzW2J1dHRvbk5hbWVdKSkge1xuICAgICAgICAgIHZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKVxuXG4gICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjYWxlbmRhckFwaS5jaGFuZ2VWaWV3KGJ1dHRvbk5hbWUpXG4gICAgICAgICAgfTtcbiAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSkgfHxcbiAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0KVxuICAgICAgICB9IGVsc2UgaWYgKGNhbGVuZGFyQXBpW2J1dHRvbk5hbWVdKSB7IC8vIGEgY2FsZW5kYXJBcGkgbWV0aG9kXG4gICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjYWxlbmRhckFwaVtidXR0b25OYW1lXSgpXG4gICAgICAgICAgfTtcbiAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlc1tidXR0b25OYW1lXSkgfHxcbiAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKVxuICAgICAgICAgICAgLy8gICAgICAgICAgICBeIGV2ZXJ5dGhpbmcgZWxzZSBpcyBjb25zaWRlcmVkIGRlZmF1bHRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGJ1dHRvbk5hbWUsIGJ1dHRvbkNsaWNrLCBidXR0b25JY29uLCBidXR0b25UZXh0IH1cbiAgICAgIH0pXG4gICAgKSxcbiAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnLi4vcGx1Z2luLXN5c3RlbSdcbmltcG9ydCB7IEV2ZW50U291cmNlRGVmIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zb3VyY2UtZGVmJ1xuaW1wb3J0IHsgRXZlbnRJbnB1dCB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtcGFyc2UnXG5cbmxldCBldmVudFNvdXJjZURlZjogRXZlbnRTb3VyY2VEZWY8RXZlbnRJbnB1dFtdPiA9IHtcbiAgaWdub3JlUmFuZ2U6IHRydWUsXG5cbiAgcGFyc2VNZXRhKHJlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZpbmVkLmV2ZW50cykpIHtcbiAgICAgIHJldHVybiByZWZpbmVkLmV2ZW50c1xuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9LFxuXG4gIGZldGNoKGFyZywgc3VjY2Vzcykge1xuICAgIHN1Y2Nlc3Moe1xuICAgICAgcmF3RXZlbnRzOiBhcmcuZXZlbnRTb3VyY2UubWV0YSxcbiAgICB9KVxuICB9LFxufVxuXG5leHBvcnQgY29uc3QgYXJyYXlFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmXSxcbn0pXG4iLCJpbXBvcnQgeyB1bnByb21pc2lmeSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IEV2ZW50U291cmNlRGVmIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zb3VyY2UtZGVmJ1xuaW1wb3J0IHsgRXZlbnRTb3VyY2VFcnJvciB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtc291cmNlJ1xuaW1wb3J0IHsgRXZlbnRJbnB1dCB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtcGFyc2UnXG5pbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICcuLi9wbHVnaW4tc3lzdGVtJ1xuaW1wb3J0IHsgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZSB9IGZyb20gJy4uL3N0cnVjdHMvZGF0ZS1zcGFuJ1xuXG5leHBvcnQgdHlwZSBFdmVudFNvdXJjZUZ1bmMgPSAoXG4gIGFyZzoge1xuICAgIHN0YXJ0OiBEYXRlXG4gICAgZW5kOiBEYXRlXG4gICAgc3RhcnRTdHI6IHN0cmluZ1xuICAgIGVuZFN0cjogc3RyaW5nXG4gICAgdGltZVpvbmU6IHN0cmluZ1xuICB9LFxuICBzdWNjZXNzQ2FsbGJhY2s6IChldmVudHM6IEV2ZW50SW5wdXRbXSkgPT4gdm9pZCxcbiAgZmFpbHVyZUNhbGxiYWNrOiAoZXJyb3I6IEV2ZW50U291cmNlRXJyb3IpID0+IHZvaWRcbikgPT4gKHZvaWQgfCBQcm9taXNlTGlrZTxFdmVudElucHV0W10+KVxuXG5sZXQgZXZlbnRTb3VyY2VEZWY6IEV2ZW50U291cmNlRGVmPEV2ZW50U291cmNlRnVuYz4gPSB7XG5cbiAgcGFyc2VNZXRhKHJlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHJlZmluZWQuZXZlbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHNcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfSxcblxuICBmZXRjaChhcmcsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICBsZXQgeyBkYXRlRW52IH0gPSBhcmcuY29udGV4dFxuICAgIGxldCBmdW5jID0gYXJnLmV2ZW50U291cmNlLm1ldGFcblxuICAgIHVucHJvbWlzaWZ5KFxuICAgICAgZnVuYy5iaW5kKG51bGwsIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUoYXJnLnJhbmdlLCBkYXRlRW52KSksXG4gICAgICAocmF3RXZlbnRzKSA9PiB7IC8vIHN1Y2Nlc3NcbiAgICAgICAgc3VjY2Vzcyh7IHJhd0V2ZW50cyB9KSAvLyBuZWVkcyBhbiBvYmplY3QgcmVzcG9uc2VcbiAgICAgIH0sXG4gICAgICBmYWlsdXJlLCAvLyBzZW5kIGVycm9yT2JqIGRpcmVjdGx5IHRvIGZhaWx1cmUgY2FsbGJhY2tcbiAgICApXG4gIH0sXG5cbn1cblxuZXhwb3J0IGNvbnN0IGZ1bmNFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmXSxcbn0pXG4iLCJpbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcblxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RKc29uKG1ldGhvZDogc3RyaW5nLCB1cmw6IHN0cmluZywgcGFyYW1zOiBEaWN0aW9uYXJ5LCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICBtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuXG4gIGxldCBib2R5ID0gbnVsbFxuXG4gIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgdXJsID0gaW5qZWN0UXVlcnlTdHJpbmdQYXJhbXModXJsLCBwYXJhbXMpXG4gIH0gZWxzZSB7XG4gICAgYm9keSA9IGVuY29kZVBhcmFtcyhwYXJhbXMpXG4gIH1cblxuICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpXG5cbiAgaWYgKG1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpXG4gIH1cblxuICB4aHIub25sb2FkID0gKCkgPT4ge1xuICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgNDAwKSB7XG4gICAgICBsZXQgcGFyc2VkID0gZmFsc2VcbiAgICAgIGxldCByZXNcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KVxuICAgICAgICBwYXJzZWQgPSB0cnVlXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gd2lsbCBoYW5kbGUgcGFyc2VkPWZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHJlcywgeGhyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFpbHVyZUNhbGxiYWNrKCdGYWlsdXJlIHBhcnNpbmcgSlNPTicsIHhocilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmFpbHVyZUNhbGxiYWNrKCdSZXF1ZXN0IGZhaWxlZCcsIHhocilcbiAgICB9XG4gIH1cblxuICB4aHIub25lcnJvciA9ICgpID0+IHtcbiAgICBmYWlsdXJlQ2FsbGJhY2soJ1JlcXVlc3QgZmFpbGVkJywgeGhyKVxuICB9XG5cbiAgeGhyLnNlbmQoYm9keSlcbn1cblxuZnVuY3Rpb24gaW5qZWN0UXVlcnlTdHJpbmdQYXJhbXModXJsOiBzdHJpbmcsIHBhcmFtcykge1xuICByZXR1cm4gdXJsICtcbiAgICAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICtcbiAgICBlbmNvZGVQYXJhbXMocGFyYW1zKVxufVxuXG5mdW5jdGlvbiBlbmNvZGVQYXJhbXMocGFyYW1zKSB7XG4gIGxldCBwYXJ0cyA9IFtdXG5cbiAgZm9yIChsZXQga2V5IGluIHBhcmFtcykge1xuICAgIHBhcnRzLnB1c2goYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKX1gKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJyYnKVxufVxuIiwiaW1wb3J0IHsgaWRlbnRpdHksIElkZW50aXR5LCBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcblxuZXhwb3J0IGNvbnN0IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMgPSB7XG4gIG1ldGhvZDogU3RyaW5nLFxuICBleHRyYVBhcmFtczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGljdGlvbmFyeSB8ICgoKSA9PiBEaWN0aW9uYXJ5KT4sXG4gIHN0YXJ0UGFyYW06IFN0cmluZyxcbiAgZW5kUGFyYW06IFN0cmluZyxcbiAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxufVxuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IHJlcXVlc3RKc29uIH0gZnJvbSAnLi4vdXRpbC9yZXF1ZXN0SnNvbidcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IEV2ZW50U291cmNlRGVmIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zb3VyY2UtZGVmJ1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnLi4vcGx1Z2luLXN5c3RlbSdcbmltcG9ydCB7IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMgfSBmcm9tICcuL2pzb24tZmVlZC1ldmVudC1zb3VyY2UtcmVmaW5lcnMnXG5cbmludGVyZmFjZSBKc29uRmVlZE1ldGEge1xuICB1cmw6IHN0cmluZ1xuICBmb3JtYXQ6ICdqc29uJyAvLyBmb3IgRXZlbnRTb3VyY2VBcGlcbiAgbWV0aG9kOiBzdHJpbmdcbiAgZXh0cmFQYXJhbXM/OiBhbnlcbiAgc3RhcnRQYXJhbT86IHN0cmluZ1xuICBlbmRQYXJhbT86IHN0cmluZ1xuICB0aW1lWm9uZVBhcmFtPzogc3RyaW5nXG59XG5cbmxldCBldmVudFNvdXJjZURlZjogRXZlbnRTb3VyY2VEZWY8SnNvbkZlZWRNZXRhPiA9IHtcblxuICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgIGlmIChyZWZpbmVkLnVybCAmJiAocmVmaW5lZC5mb3JtYXQgPT09ICdqc29uJyB8fCAhcmVmaW5lZC5mb3JtYXQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHJlZmluZWQudXJsLFxuICAgICAgICBmb3JtYXQ6ICdqc29uJyxcbiAgICAgICAgbWV0aG9kOiAocmVmaW5lZC5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCksXG4gICAgICAgIGV4dHJhUGFyYW1zOiByZWZpbmVkLmV4dHJhUGFyYW1zLFxuICAgICAgICBzdGFydFBhcmFtOiByZWZpbmVkLnN0YXJ0UGFyYW0sXG4gICAgICAgIGVuZFBhcmFtOiByZWZpbmVkLmVuZFBhcmFtLFxuICAgICAgICB0aW1lWm9uZVBhcmFtOiByZWZpbmVkLnRpbWVab25lUGFyYW0sXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH0sXG5cbiAgZmV0Y2goYXJnLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgbGV0IHsgbWV0YSB9ID0gYXJnLmV2ZW50U291cmNlXG4gICAgbGV0IHJlcXVlc3RQYXJhbXMgPSBidWlsZFJlcXVlc3RQYXJhbXMobWV0YSwgYXJnLnJhbmdlLCBhcmcuY29udGV4dClcblxuICAgIHJlcXVlc3RKc29uKFxuICAgICAgbWV0YS5tZXRob2QsIG1ldGEudXJsLCByZXF1ZXN0UGFyYW1zLFxuICAgICAgKHJhd0V2ZW50cywgeGhyKSA9PiB7XG4gICAgICAgIHN1Y2Nlc3MoeyByYXdFdmVudHMsIHhociB9KVxuICAgICAgfSxcbiAgICAgIChlcnJvck1lc3NhZ2UsIHhocikgPT4ge1xuICAgICAgICBmYWlsdXJlKHsgbWVzc2FnZTogZXJyb3JNZXNzYWdlLCB4aHIgfSlcbiAgICAgIH0sXG4gICAgKVxuICB9LFxuXG59XG5cbmV4cG9ydCBjb25zdCBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgZXZlbnRTb3VyY2VSZWZpbmVyczogSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyxcbiAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxufSlcblxuZnVuY3Rpb24gYnVpbGRSZXF1ZXN0UGFyYW1zKG1ldGE6IEpzb25GZWVkTWV0YSwgcmFuZ2U6IERhdGVSYW5nZSwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgbGV0IHN0YXJ0UGFyYW1cbiAgbGV0IGVuZFBhcmFtXG4gIGxldCB0aW1lWm9uZVBhcmFtXG4gIGxldCBjdXN0b21SZXF1ZXN0UGFyYW1zXG4gIGxldCBwYXJhbXMgPSB7fVxuXG4gIHN0YXJ0UGFyYW0gPSBtZXRhLnN0YXJ0UGFyYW1cbiAgaWYgKHN0YXJ0UGFyYW0gPT0gbnVsbCkge1xuICAgIHN0YXJ0UGFyYW0gPSBvcHRpb25zLnN0YXJ0UGFyYW1cbiAgfVxuXG4gIGVuZFBhcmFtID0gbWV0YS5lbmRQYXJhbVxuICBpZiAoZW5kUGFyYW0gPT0gbnVsbCkge1xuICAgIGVuZFBhcmFtID0gb3B0aW9ucy5lbmRQYXJhbVxuICB9XG5cbiAgdGltZVpvbmVQYXJhbSA9IG1ldGEudGltZVpvbmVQYXJhbVxuICBpZiAodGltZVpvbmVQYXJhbSA9PSBudWxsKSB7XG4gICAgdGltZVpvbmVQYXJhbSA9IG9wdGlvbnMudGltZVpvbmVQYXJhbVxuICB9XG5cbiAgLy8gcmV0cmlldmUgYW55IG91dGJvdW5kIEdFVC9QT1NUIGRhdGEgZnJvbSB0aGUgb3B0aW9uc1xuICBpZiAodHlwZW9mIG1ldGEuZXh0cmFQYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBzdXBwbGllZCBhcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleS92YWx1ZSBvYmplY3RcbiAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcygpXG4gIH0gZWxzZSB7XG4gICAgLy8gcHJvYmFibHkgc3VwcGxpZWQgYXMgYSBzdHJhaWdodCBrZXkvdmFsdWUgb2JqZWN0XG4gICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IG1ldGEuZXh0cmFQYXJhbXMgfHwge31cbiAgfVxuXG4gIF9fYXNzaWduKHBhcmFtcywgY3VzdG9tUmVxdWVzdFBhcmFtcylcblxuICBwYXJhbXNbc3RhcnRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydClcbiAgcGFyYW1zW2VuZFBhcmFtXSA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLmVuZClcblxuICBpZiAoZGF0ZUVudi50aW1lWm9uZSAhPT0gJ2xvY2FsJykge1xuICAgIHBhcmFtc1t0aW1lWm9uZVBhcmFtXSA9IGRhdGVFbnYudGltZVpvbmVcbiAgfVxuXG4gIHJldHVybiBwYXJhbXNcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IERhdGVJbnB1dCB9IGZyb20gJy4uL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgaWRlbnRpdHksIElkZW50aXR5IH0gZnJvbSAnLi4vb3B0aW9ucydcblxuZXhwb3J0IGNvbnN0IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMgPSB7XG4gIGRheXNPZldlZWs6IGlkZW50aXR5IGFzIElkZW50aXR5PG51bWJlcltdPixcbiAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgZW5kVGltZTogY3JlYXRlRHVyYXRpb24sXG4gIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgc3RhcnRSZWN1cjogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZUlucHV0PixcbiAgZW5kUmVjdXI6IGlkZW50aXR5IGFzIElkZW50aXR5PERhdGVJbnB1dD4sXG59XG4iLCJpbXBvcnQgeyBzdGFydE9mRGF5LCBhZGREYXlzLCBEYXRlTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBEdXJhdGlvbiwgc3VidHJhY3REdXJhdGlvbnMgfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgYXJyYXlUb0hhc2ggfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IFJlY3VycmluZ1R5cGUgfSBmcm9tICcuL3JlY3VycmluZy1ldmVudCdcbmltcG9ydCB7IEV2ZW50UmVmaW5lZCB9IGZyb20gJy4vZXZlbnQtcGFyc2UnXG5pbXBvcnQgeyBEYXRlUmFuZ2UsIGludGVyc2VjdFJhbmdlcyB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IERhdGVFbnYgfSBmcm9tICcuLi9kYXRlbGliL2VudidcbmltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJy4uL3BsdWdpbi1zeXN0ZW0nXG5pbXBvcnQgeyBTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTIH0gZnJvbSAnLi9yZWN1cnJpbmctZXZlbnQtc2ltcGxlLXJlZmluZXJzJ1xuaW1wb3J0ICcuL3JlY3VycmluZy1ldmVudC1zaW1wbGUtZGVjbGFyZSdcblxuLypcbkFuIGltcGxlbWVudGF0aW9uIG9mIHJlY3VycmluZyBldmVudHMgdGhhdCBvbmx5IHN1cHBvcnRzIGV2ZXJ5LWRheSBvciB3ZWVrbHkgcmVjdXJyZW5jZXMuXG4qL1xuXG5pbnRlcmZhY2UgU2ltcGxlUmVjdXJyaW5nRGF0YSB7XG4gIGRheXNPZldlZWs6IG51bWJlcltdIHwgbnVsbFxuICBzdGFydFRpbWU6IER1cmF0aW9uIHwgbnVsbFxuICBlbmRUaW1lOiBEdXJhdGlvbiB8IG51bGxcbiAgc3RhcnRSZWN1cjogRGF0ZU1hcmtlciB8IG51bGxcbiAgZW5kUmVjdXI6IERhdGVNYXJrZXIgfCBudWxsXG59XG5cbmxldCByZWN1cnJpbmc6IFJlY3VycmluZ1R5cGU8U2ltcGxlUmVjdXJyaW5nRGF0YT4gPSB7XG5cbiAgcGFyc2UocmVmaW5lZDogRXZlbnRSZWZpbmVkLCBkYXRlRW52OiBEYXRlRW52KSB7XG4gICAgaWYgKHJlZmluZWQuZGF5c09mV2VlayB8fCByZWZpbmVkLnN0YXJ0VGltZSB8fCByZWZpbmVkLmVuZFRpbWUgfHwgcmVmaW5lZC5zdGFydFJlY3VyIHx8IHJlZmluZWQuZW5kUmVjdXIpIHtcbiAgICAgIGxldCByZWN1cnJpbmdEYXRhOiBTaW1wbGVSZWN1cnJpbmdEYXRhID0ge1xuICAgICAgICBkYXlzT2ZXZWVrOiByZWZpbmVkLmRheXNPZldlZWsgfHwgbnVsbCxcbiAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICBlbmRUaW1lOiByZWZpbmVkLmVuZFRpbWUgfHwgbnVsbCxcbiAgICAgICAgc3RhcnRSZWN1cjogcmVmaW5lZC5zdGFydFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5zdGFydFJlY3VyKSA6IG51bGwsXG4gICAgICAgIGVuZFJlY3VyOiByZWZpbmVkLmVuZFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5lbmRSZWN1cikgOiBudWxsLFxuICAgICAgfVxuXG4gICAgICBsZXQgZHVyYXRpb246IER1cmF0aW9uXG5cbiAgICAgIGlmIChyZWZpbmVkLmR1cmF0aW9uKSB7XG4gICAgICAgIGR1cmF0aW9uID0gcmVmaW5lZC5kdXJhdGlvblxuICAgICAgfVxuICAgICAgaWYgKCFkdXJhdGlvbiAmJiByZWZpbmVkLnN0YXJ0VGltZSAmJiByZWZpbmVkLmVuZFRpbWUpIHtcbiAgICAgICAgZHVyYXRpb24gPSBzdWJ0cmFjdER1cmF0aW9ucyhyZWZpbmVkLmVuZFRpbWUsIHJlZmluZWQuc3RhcnRUaW1lKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbGxEYXlHdWVzczogQm9vbGVhbighcmVmaW5lZC5zdGFydFRpbWUgJiYgIXJlZmluZWQuZW5kVGltZSksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nRGF0YSwgLy8gZG9lc24ndCBuZWVkIGVuZFRpbWUgYW55bW9yZSBidXQgb2ggd2VsbFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH0sXG5cbiAgZXhwYW5kKHR5cGVEYXRhOiBTaW1wbGVSZWN1cnJpbmdEYXRhLCBmcmFtaW5nUmFuZ2U6IERhdGVSYW5nZSwgZGF0ZUVudjogRGF0ZUVudik6IERhdGVNYXJrZXJbXSB7XG4gICAgbGV0IGNsaXBwZWRGcmFtaW5nUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoXG4gICAgICBmcmFtaW5nUmFuZ2UsXG4gICAgICB7IHN0YXJ0OiB0eXBlRGF0YS5zdGFydFJlY3VyLCBlbmQ6IHR5cGVEYXRhLmVuZFJlY3VyIH0sXG4gICAgKVxuXG4gICAgaWYgKGNsaXBwZWRGcmFtaW5nUmFuZ2UpIHtcbiAgICAgIHJldHVybiBleHBhbmRSYW5nZXMoXG4gICAgICAgIHR5cGVEYXRhLmRheXNPZldlZWssXG4gICAgICAgIHR5cGVEYXRhLnN0YXJ0VGltZSxcbiAgICAgICAgY2xpcHBlZEZyYW1pbmdSYW5nZSxcbiAgICAgICAgZGF0ZUVudixcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIFtdXG4gIH0sXG5cbn1cblxuZXhwb3J0IGNvbnN0IHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gIHJlY3VycmluZ1R5cGVzOiBbcmVjdXJyaW5nXSxcbiAgZXZlbnRSZWZpbmVyczogU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyxcbn0pXG5cbmZ1bmN0aW9uIGV4cGFuZFJhbmdlcyhcbiAgZGF5c09mV2VlazogbnVtYmVyW10gfCBudWxsLFxuICBzdGFydFRpbWU6IER1cmF0aW9uIHwgbnVsbCxcbiAgZnJhbWluZ1JhbmdlOiBEYXRlUmFuZ2UsXG4gIGRhdGVFbnY6IERhdGVFbnYsXG4pOiBEYXRlTWFya2VyW10ge1xuICBsZXQgZG93SGFzaDogeyBbbnVtOiBzdHJpbmddOiB0cnVlIH0gfCBudWxsID0gZGF5c09mV2VlayA/IGFycmF5VG9IYXNoKGRheXNPZldlZWspIDogbnVsbFxuICBsZXQgZGF5TWFya2VyID0gc3RhcnRPZkRheShmcmFtaW5nUmFuZ2Uuc3RhcnQpXG4gIGxldCBlbmRNYXJrZXIgPSBmcmFtaW5nUmFuZ2UuZW5kXG4gIGxldCBpbnN0YW5jZVN0YXJ0czogRGF0ZU1hcmtlcltdID0gW11cblxuICB3aGlsZSAoZGF5TWFya2VyIDwgZW5kTWFya2VyKSB7XG4gICAgbGV0IGluc3RhbmNlU3RhcnRcblxuICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcbiAgICBpZiAoIWRvd0hhc2ggfHwgZG93SGFzaFtkYXlNYXJrZXIuZ2V0VVRDRGF5KCldKSB7XG4gICAgICBpZiAoc3RhcnRUaW1lKSB7XG4gICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXRlRW52LmFkZChkYXlNYXJrZXIsIHN0YXJ0VGltZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXlNYXJrZXJcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2VTdGFydHMucHVzaChpbnN0YW5jZVN0YXJ0KVxuICAgIH1cblxuICAgIGRheU1hcmtlciA9IGFkZERheXMoZGF5TWFya2VyLCAxKVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlU3RhcnRzXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICcuL3BsdWdpbi1zeXN0ZW0nXG5pbXBvcnQgeyBoYXNoVmFsdWVzVG9BcnJheSB9IGZyb20gJy4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBFdmVudFNvdXJjZSB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuL0NhbGVuZGFyQ29udGV4dCdcblxuZXhwb3J0IGNvbnN0IGNoYW5nZUhhbmRsZXJQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge1xuICAgIGV2ZW50cyhldmVudHMsIGNvbnRleHQpIHtcbiAgICAgIGhhbmRsZUV2ZW50U291cmNlcyhbZXZlbnRzXSwgY29udGV4dClcbiAgICB9LFxuICAgIGV2ZW50U291cmNlczogaGFuZGxlRXZlbnRTb3VyY2VzLFxuICB9LFxufSlcblxuLypcbkJVRzogaWYgYGV2ZW50YCB3YXMgc3VwcGxpZWQsIGFsbCBwcmV2aW91c2x5LWdpdmVuIGBldmVudFNvdXJjZXNgIHdpbGwgYmUgd2lwZWQgb3V0XG4qL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnRTb3VyY2VzKGlucHV0cywgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCB1bmZvdW5kU291cmNlczogRXZlbnRTb3VyY2U8YW55PltdID0gaGFzaFZhbHVlc1RvQXJyYXkoY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U291cmNlcylcbiAgbGV0IG5ld0lucHV0cyA9IFtdXG5cbiAgZm9yIChsZXQgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgbGV0IGlucHV0Rm91bmQgPSBmYWxzZVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmZvdW5kU291cmNlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHVuZm91bmRTb3VyY2VzW2ldLl9yYXcgPT09IGlucHV0KSB7XG4gICAgICAgIHVuZm91bmRTb3VyY2VzLnNwbGljZShpLCAxKSAvLyBkZWxldGVcbiAgICAgICAgaW5wdXRGb3VuZCA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlucHV0Rm91bmQpIHtcbiAgICAgIG5ld0lucHV0cy5wdXNoKGlucHV0KVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IHVuZm91bmRTb3VyY2Ugb2YgdW5mb3VuZFNvdXJjZXMpIHtcbiAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcbiAgICAgIHNvdXJjZUlkOiB1bmZvdW5kU291cmNlLnNvdXJjZUlkLFxuICAgIH0pXG4gIH1cblxuICBmb3IgKGxldCBuZXdJbnB1dCBvZiBuZXdJbnB1dHMpIHtcbiAgICBjb250ZXh0LmNhbGVuZGFyQXBpLmFkZEV2ZW50U291cmNlKG5ld0lucHV0KVxuICB9XG59XG4iLCJpbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBDYWxlbmRhckRhdGEgfSBmcm9tICcuL3JlZHVjZXJzL2RhdGEtdHlwZXMnXG5pbXBvcnQgeyBSYW5nZUFwaVdpdGhUaW1lWm9uZSwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZSB9IGZyb20gJy4vc3RydWN0cy9kYXRlLXNwYW4nXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi9WaWV3QXBpJ1xuXG5leHBvcnQgdHlwZSBEYXRlc1NldEFyZyA9IFJhbmdlQXBpV2l0aFRpbWVab25lICYgeyB2aWV3OiBWaWV3QXBpIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZURhdGVQcm9maWxlKGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgY29udGV4dDogQ2FsZW5kYXJEYXRhKSB7XG4gIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkYXRlc1NldCcsIHtcbiAgICAuLi5idWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0LmRhdGVFbnYpLFxuICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgfSlcbn1cbiIsImltcG9ydCB7IEV2ZW50U3RvcmUgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBDYWxlbmRhckRhdGEgfSBmcm9tICcuL3JlZHVjZXJzL2RhdGEtdHlwZXMnXG5pbXBvcnQgeyBFdmVudEFwaSwgYnVpbGRFdmVudEFwaXMgfSBmcm9tICcuL2FwaS9FdmVudEFwaSdcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgVmlld0FwaSB9IGZyb20gJy4vVmlld0FwaSdcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudEFkZEFyZyB7XG4gIGV2ZW50OiBFdmVudEFwaVxuICByZWxhdGVkRXZlbnRzOiBFdmVudEFwaVtdXG4gIHJldmVydDogKCkgPT4gdm9pZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50Q2hhbmdlQXJnIHtcbiAgb2xkRXZlbnQ6IEV2ZW50QXBpXG4gIGV2ZW50OiBFdmVudEFwaVxuICByZWxhdGVkRXZlbnRzOiBFdmVudEFwaVtdXG4gIHJldmVydDogKCkgPT4gdm9pZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50RHJvcEFyZyBleHRlbmRzIEV2ZW50Q2hhbmdlQXJnIHsgLy8gbm90IGJlc3QgcGxhY2UuIGRlYWxzIHcvIFVJXG4gIGVsOiBIVE1MRWxlbWVudFxuICBkZWx0YTogRHVyYXRpb25cbiAganNFdmVudDogTW91c2VFdmVudFxuICB2aWV3OiBWaWV3QXBpXG4gIC8vIGFuZCBvdGhlciBcInRyYW5zZm9ybWVkXCIgdGhpbmdzXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRSZW1vdmVBcmcge1xuICBldmVudDogRXZlbnRBcGlcbiAgcmVsYXRlZEV2ZW50czogRXZlbnRBcGlbXVxuICByZXZlcnQ6ICgpID0+IHZvaWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUV2ZW50U3RvcmUoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSwgY29udGV4dDogQ2FsZW5kYXJEYXRhKSB7XG4gIGxldCB7IGVtaXR0ZXIgfSA9IGNvbnRleHRcblxuICBpZiAoZW1pdHRlci5oYXNIYW5kbGVycygnZXZlbnRzU2V0JykpIHtcbiAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50c1NldCcsIGJ1aWxkRXZlbnRBcGlzKGV2ZW50U3RvcmUsIGNvbnRleHQpKVxuICB9XG59XG4iLCJpbXBvcnQgeyBQbHVnaW5EZWYgfSBmcm9tICcuL3BsdWdpbi1zeXN0ZW0tc3RydWN0J1xuaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnLi9wbHVnaW4tc3lzdGVtJ1xuaW1wb3J0IHsgYXJyYXlFdmVudFNvdXJjZVBsdWdpbiB9IGZyb20gJy4vZXZlbnQtc291cmNlcy9hcnJheS1ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBmdW5jRXZlbnRTb3VyY2VQbHVnaW4gfSBmcm9tICcuL2V2ZW50LXNvdXJjZXMvZnVuYy1ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luIH0gZnJvbSAnLi9ldmVudC1zb3VyY2VzL2pzb24tZmVlZC1ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4gfSBmcm9tICcuL3N0cnVjdHMvcmVjdXJyaW5nLWV2ZW50LXNpbXBsZSdcbmltcG9ydCB7IGNoYW5nZUhhbmRsZXJQbHVnaW4gfSBmcm9tICcuL29wdGlvbi1jaGFuZ2UtaGFuZGxlcnMnXG5pbXBvcnQgeyBoYW5kbGVEYXRlUHJvZmlsZSB9IGZyb20gJy4vZGF0ZXMtc2V0J1xuaW1wb3J0IHsgaGFuZGxlRXZlbnRTdG9yZSB9IGZyb20gJy4vZXZlbnQtY3J1ZCdcbmltcG9ydCB7IGlzQXJyYXlzRXF1YWwgfSBmcm9tICcuL3V0aWwvYXJyYXknXG5pbXBvcnQgeyByZW1vdmVFbGVtZW50IH0gZnJvbSAnLi91dGlsL2RvbS1tYW5pcCdcbmltcG9ydCB7IGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nIH0gZnJvbSAnLi9yZWR1Y2Vycy9ldmVudFNvdXJjZXMnXG5pbXBvcnQgeyBDYWxlbmRhckRhdGFNYW5hZ2VyU3RhdGUgfSBmcm9tICcuL3JlZHVjZXJzL2RhdGEtdHlwZXMnXG5cbi8qXG50aGlzIGFycmF5IGlzIGV4cG9zZWQgb24gdGhlIHJvb3QgbmFtZXNwYWNlIHNvIHRoYXQgVU1EIHBsdWdpbnMgY2FuIGFkZCB0byBpdC5cbnNlZSB0aGUgcm9sbHVwLWJ1bmRsZXMgc2NyaXB0LlxuKi9cbmV4cG9ydCBjb25zdCBnbG9iYWxQbHVnaW5zOiBQbHVnaW5EZWZbXSA9IFsgLy8gVE9ETzogbWFrZSBhIGNvbnN0P1xuICBhcnJheUV2ZW50U291cmNlUGx1Z2luLFxuICBmdW5jRXZlbnRTb3VyY2VQbHVnaW4sXG4gIGpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4sXG4gIHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbixcbiAgY2hhbmdlSGFuZGxlclBsdWdpbixcbiAgY3JlYXRlUGx1Z2luKHsgLy8gbWlzYy4uLlxuICAgIGlzTG9hZGluZ0Z1bmNzOiBbXG4gICAgICAoc3RhdGU6IENhbGVuZGFyRGF0YU1hbmFnZXJTdGF0ZSkgPT4gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoc3RhdGUuZXZlbnRTb3VyY2VzKSxcbiAgICBdLFxuICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IHtcbiAgICAgIGh0bWw6ICgpID0+ICh7IHJlbmRlcjogaW5qZWN0SHRtbCB9KSxcbiAgICAgIGRvbU5vZGVzOiAoKSA9PiAoeyByZW5kZXI6IGluamVjdERvbU5vZGVzIH0pLFxuICAgIH0sXG4gICAgcHJvcFNldEhhbmRsZXJzOiB7XG4gICAgICBkYXRlUHJvZmlsZTogaGFuZGxlRGF0ZVByb2ZpbGUsXG4gICAgICBldmVudFN0b3JlOiBoYW5kbGVFdmVudFN0b3JlLFxuICAgIH0sXG4gIH0pLFxuXVxuXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0SHRtbChlbDogSFRNTEVsZW1lbnQsIGh0bWw6IHN0cmluZykge1xuICBlbC5pbm5lckhUTUwgPSBodG1sXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3REb21Ob2RlcyhlbDogSFRNTEVsZW1lbnQsIGRvbU5vZGVzOiBOb2RlW10gfCBOb2RlTGlzdCkge1xuICBsZXQgb2xkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbC5jaGlsZE5vZGVzKSAvLyBUT0RPOiB1c2UgYXJyYXkgdXRpbFxuICBsZXQgbmV3Tm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb21Ob2RlcykgLy8gVE9ETzogdXNlIGFycmF5IHV0aWxcblxuICBpZiAoIWlzQXJyYXlzRXF1YWwob2xkTm9kZXMsIG5ld05vZGVzKSkge1xuICAgIGZvciAobGV0IG5ld05vZGUgb2YgbmV3Tm9kZXMpIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKG5ld05vZGUpXG4gICAgfVxuICAgIG9sZE5vZGVzLmZvckVhY2gocmVtb3ZlRWxlbWVudClcbiAgfVxufVxuIiwiZXhwb3J0IGNsYXNzIERlbGF5ZWRSdW5uZXIge1xuICBwcml2YXRlIGlzUnVubmluZyA9IGZhbHNlXG4gIHByaXZhdGUgaXNEaXJ0eSA9IGZhbHNlXG4gIHByaXZhdGUgcGF1c2VEZXB0aHM6IHsgW3Njb3BlOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9XG4gIHByaXZhdGUgdGltZW91dElkOiBudW1iZXIgPSAwXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBkcmFpbmVkT3B0aW9uPzogKCkgPT4gdm9pZCxcbiAgKSB7XG4gIH1cblxuICByZXF1ZXN0KGRlbGF5PzogbnVtYmVyKSB7XG4gICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZVxuXG4gICAgaWYgKCF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KClcblxuICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy50cnlEcmFpbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoIC8vIE5PVCBPUFRJTUFMISBUT0RPOiBsb29rIGF0IGRlYm91bmNlXG4gICAgICAgICAgdGhpcy50cnlEcmFpbi5iaW5kKHRoaXMpLFxuICAgICAgICAgIGRlbGF5LFxuICAgICAgICApIGFzIHVua25vd24gYXMgbnVtYmVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGF1c2Uoc2NvcGUgPSAnJykge1xuICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzXG5cbiAgICBwYXVzZURlcHRoc1tzY29wZV0gPSAocGF1c2VEZXB0aHNbc2NvcGVdIHx8IDApICsgMVxuXG4gICAgdGhpcy5jbGVhclRpbWVvdXQoKVxuICB9XG5cbiAgcmVzdW1lKHNjb3BlID0gJycsIGZvcmNlPzogYm9vbGVhbikge1xuICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzXG5cbiAgICBpZiAoc2NvcGUgaW4gcGF1c2VEZXB0aHMpIHtcbiAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICBkZWxldGUgcGF1c2VEZXB0aHNbc2NvcGVdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gLT0gMVxuICAgICAgICBsZXQgZGVwdGggPSBwYXVzZURlcHRoc1tzY29wZV1cblxuICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRyeURyYWluKClcbiAgICB9XG4gIH1cblxuICBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5wYXVzZURlcHRocykubGVuZ3RoXG4gIH1cblxuICB0cnlEcmFpbigpIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZVxuXG4gICAgICB3aGlsZSAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlXG4gICAgICAgIHRoaXMuZHJhaW5lZCgpIC8vIG1pZ2h0IHNldCBpc0RpcnR5IHRvIHRydWUgYWdhaW5cbiAgICAgIH1cblxuICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY2xlYXJUaW1lb3V0KClcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZVxuICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fVxuICB9XG5cbiAgcHJpdmF0ZSBjbGVhclRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMudGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpXG4gICAgICB0aGlzLnRpbWVvdXRJZCA9IDBcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZHJhaW5lZCgpIHsgLy8gc3ViY2xhc3NlcyBjYW4gaW1wbGVtZW50XG4gICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKClcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IERlbGF5ZWRSdW5uZXIgfSBmcm9tICcuL0RlbGF5ZWRSdW5uZXInXG5cbmV4cG9ydCBjbGFzcyBUYXNrUnVubmVyPFRhc2s+IHsgLy8gdGhpcyBjbGFzcyBVU0VTIHRoZSBEZWxheWVkUnVubmVyXG4gIHByaXZhdGUgcXVldWU6IFRhc2tbXSA9IFtdXG5cbiAgcHJpdmF0ZSBkZWxheWVkUnVubmVyOiBEZWxheWVkUnVubmVyIC8vIHdpbGwgbW9zdCBsaWtlbHkgYmUgdXNlZCBXSVRIT1VUIGFueSBkZWxheVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcnVuVGFza09wdGlvbj86ICh0YXNrOiBUYXNrKSA9PiB2b2lkLFxuICAgIHByaXZhdGUgZHJhaW5lZE9wdGlvbj86IChjb21wbGV0ZWRUYXNrczogVGFza1tdKSA9PiB2b2lkLFxuICApIHtcbiAgICB0aGlzLmRlbGF5ZWRSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcih0aGlzLmRyYWluLmJpbmQodGhpcykpXG4gIH1cblxuICByZXF1ZXN0KHRhc2s6IFRhc2ssIGRlbGF5PzogbnVtYmVyKSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spXG4gICAgdGhpcy5kZWxheWVkUnVubmVyLnJlcXVlc3QoZGVsYXkpXG4gIH1cblxuICBwYXVzZShzY29wZT86IHN0cmluZykge1xuICAgIHRoaXMuZGVsYXllZFJ1bm5lci5wYXVzZShzY29wZSlcbiAgfVxuXG4gIHJlc3VtZShzY29wZT86IHN0cmluZywgZm9yY2U/OiBib29sZWFuKSB7XG4gICAgdGhpcy5kZWxheWVkUnVubmVyLnJlc3VtZShzY29wZSwgZm9yY2UpXG4gIH1cblxuICBkcmFpbigpIHtcbiAgICBsZXQgeyBxdWV1ZSB9ID0gdGhpc1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgbGV0IGNvbXBsZXRlZFRhc2tzOiBUYXNrW10gPSBbXVxuICAgICAgbGV0IHRhc2s6IFRhc2tcblxuICAgICAgd2hpbGUgKCh0YXNrID0gcXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgdGhpcy5ydW5UYXNrKHRhc2spXG4gICAgICAgIGNvbXBsZXRlZFRhc2tzLnB1c2godGFzaylcbiAgICAgIH1cblxuICAgICAgdGhpcy5kcmFpbmVkKGNvbXBsZXRlZFRhc2tzKVxuICAgIH0gLy8ga2VlcCBnb2luZywgaW4gY2FzZSBuZXcgdGFza3Mgd2VyZSBhZGRlZCBpbiB0aGUgZHJhaW5lZCBoYW5kbGVyXG4gIH1cblxuICBwcm90ZWN0ZWQgcnVuVGFzayh0YXNrOiBUYXNrKSB7IC8vIHN1YmNsYXNzZXMgY2FuIGltcGxlbWVudFxuICAgIGlmICh0aGlzLnJ1blRhc2tPcHRpb24pIHtcbiAgICAgIHRoaXMucnVuVGFza09wdGlvbih0YXNrKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBkcmFpbmVkKGNvbXBsZXRlZFRhc2tzOiBUYXNrW10pIHsgLy8gc3ViY2xhc3NlcyBjYW4gaW1wbGVtZW50XG4gICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKGNvbXBsZXRlZFRhc2tzKVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgRGF0ZVByb2ZpbGUgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IGRpZmZXaG9sZURheXMgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IGNyZWF0ZUZvcm1hdHRlciwgRm9ybWF0dGVySW5wdXQgfSBmcm9tICcuLi9kYXRlbGliL2Zvcm1hdHRpbmcnXG5pbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBEYXRlRW52IH0gZnJvbSAnLi4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBCYXNlT3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMnXG5cbi8vIENvbXB1dGVzIHdoYXQgdGhlIHRpdGxlIGF0IHRoZSB0b3Agb2YgdGhlIGNhbGVuZGFyQXBpIHNob3VsZCBiZSBmb3IgdGhpcyB2aWV3XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRUaXRsZShkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsIHZpZXdPcHRpb25zOiBCYXNlT3B0aW9ucywgZGF0ZUVudjogRGF0ZUVudikge1xuICBsZXQgcmFuZ2U6IERhdGVSYW5nZVxuXG4gIC8vIGZvciB2aWV3cyB0aGF0IHNwYW4gYSBsYXJnZSB1bml0IG9mIHRpbWUsIHNob3cgdGhlIHByb3BlciBpbnRlcnZhbCwgaWdub3Jpbmcgc3RyYXkgZGF5cyBiZWZvcmUgYW5kIGFmdGVyXG4gIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcbiAgICByYW5nZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVxuICB9IGVsc2UgeyAvLyBmb3IgZGF5IHVuaXRzIG9yIHNtYWxsZXIsIHVzZSB0aGUgYWN0dWFsIGRheSByYW5nZVxuICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2VcbiAgfVxuXG4gIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKFxuICAgIHJhbmdlLnN0YXJ0LFxuICAgIHJhbmdlLmVuZCxcbiAgICBjcmVhdGVGb3JtYXR0ZXIodmlld09wdGlvbnMudGl0bGVGb3JtYXQgfHwgYnVpbGRUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkpLFxuICAgIHtcbiAgICAgIGlzRW5kRXhjbHVzaXZlOiBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5LFxuICAgICAgZGVmYXVsdFNlcGFyYXRvcjogdmlld09wdGlvbnMudGl0bGVSYW5nZVNlcGFyYXRvcixcbiAgICB9LFxuICApXG59XG5cbi8vIEdlbmVyYXRlcyB0aGUgZm9ybWF0IHN0cmluZyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aXRsZSBmb3IgdGhlIGN1cnJlbnQgZGF0ZSByYW5nZS5cbi8vIEF0dGVtcHRzIHRvIGNvbXB1dGUgdGhlIG1vc3QgYXBwcm9wcmlhdGUgZm9ybWF0IGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCB3aXRoIGB0aXRsZUZvcm1hdGAuXG5mdW5jdGlvbiBidWlsZFRpdGxlRm9ybWF0KGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSk6IEZvcm1hdHRlcklucHV0IHtcbiAgbGV0IHsgY3VycmVudFJhbmdlVW5pdCB9ID0gZGF0ZVByb2ZpbGVcblxuICBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnIH0gLy8gbGlrZSBcIlNlcHRlbWJlciAyMDE0XCJcbiAgfVxuXG4gIGxldCBkYXlzID0gZGlmZldob2xlRGF5cyhcbiAgICBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQsXG4gICAgZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLmVuZCxcbiAgKVxuXG4gIGlmIChkYXlzICE9PSBudWxsICYmIGRheXMgPiAxKSB7XG4gICAgLy8gbXVsdGktZGF5IHJhbmdlLiBzaG9ydGVyLCBsaWtlIFwiU2VwIDkgLSAxMCAyMDE0XCJcbiAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJyB9XG4gIH1cblxuICAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcbiAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9XG59XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJ1xuaW1wb3J0IHsgYnVpbGRMb2NhbGUsIFJhd0xvY2FsZUluZm8sIG9yZ2FuaXplUmF3TG9jYWxlcywgTG9jYWxlU2luZ3VsYXJBcmcgfSBmcm9tICcuLi9kYXRlbGliL2xvY2FsZSdcbmltcG9ydCB7IG1lbW9pemUsIG1lbW9pemVPYmpBcmcgfSBmcm9tICcuLi91dGlsL21lbW9pemUnXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcbmltcG9ydCB7IGJ1aWxkQnVpbGRQbHVnaW5Ib29rcyB9IGZyb20gJy4uL3BsdWdpbi1zeXN0ZW0nXG5pbXBvcnQgeyBQbHVnaW5Ib29rcyB9IGZyb20gJy4uL3BsdWdpbi1zeXN0ZW0tc3RydWN0J1xuaW1wb3J0IHsgRGF0ZUVudiB9IGZyb20gJy4uL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgQ2FsZW5kYXJBcGkgfSBmcm9tICcuLi9DYWxlbmRhckFwaSdcbmltcG9ydCB7IFN0YW5kYXJkVGhlbWUgfSBmcm9tICcuLi90aGVtZS9TdGFuZGFyZFRoZW1lJ1xuaW1wb3J0IHsgRXZlbnRTb3VyY2VIYXNoIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBidWlsZFZpZXdTcGVjcywgVmlld1NwZWMgfSBmcm9tICcuLi9zdHJ1Y3RzL3ZpZXctc3BlYydcbmltcG9ydCB7IG1hcEhhc2gsIGlzUHJvcHNFcXVhbCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIERhdGVQcm9maWxlR2VuZXJhdG9yUHJvcHMgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IHJlZHVjZVZpZXdUeXBlIH0gZnJvbSAnLi92aWV3LXR5cGUnXG5pbXBvcnQgeyBnZXRJbml0aWFsRGF0ZSwgcmVkdWNlQ3VycmVudERhdGUgfSBmcm9tICcuL2N1cnJlbnQtZGF0ZSdcbmltcG9ydCB7IHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMgfSBmcm9tICcuL29wdGlvbnMnXG5pbXBvcnQgeyByZWR1Y2VEYXRlUHJvZmlsZSB9IGZyb20gJy4vZGF0ZS1wcm9maWxlJ1xuaW1wb3J0IHsgcmVkdWNlRXZlbnRTb3VyY2VzLCBpbml0RXZlbnRTb3VyY2VzLCByZWR1Y2VFdmVudFNvdXJjZXNOZXdUaW1lWm9uZSwgY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcgfSBmcm9tICcuL2V2ZW50U291cmNlcydcbmltcG9ydCB7IHJlZHVjZUV2ZW50U3RvcmUsIHJlem9uZUV2ZW50U3RvcmVEYXRlcyB9IGZyb20gJy4vZXZlbnRTdG9yZSdcbmltcG9ydCB7IHJlZHVjZURhdGVTZWxlY3Rpb24gfSBmcm9tICcuL2RhdGUtc2VsZWN0aW9uJ1xuaW1wb3J0IHsgcmVkdWNlU2VsZWN0ZWRFdmVudCB9IGZyb20gJy4vc2VsZWN0ZWQtZXZlbnQnXG5pbXBvcnQgeyByZWR1Y2VFdmVudERyYWcgfSBmcm9tICcuL2V2ZW50LWRyYWcnXG5pbXBvcnQgeyByZWR1Y2VFdmVudFJlc2l6ZSB9IGZyb20gJy4vZXZlbnQtcmVzaXplJ1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4uL2NvbW1vbi9FbWl0dGVyJ1xuaW1wb3J0IHsgRXZlbnRVaUhhc2gsIEV2ZW50VWksIGNyZWF0ZUV2ZW50VWkgfSBmcm9tICcuLi9jb21wb25lbnQvZXZlbnQtdWknXG5pbXBvcnQgeyBFdmVudERlZkhhc2ggfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LWRlZidcbmltcG9ydCB7IHBhcnNlVG9vbGJhcnMgfSBmcm9tICcuLi90b29sYmFyLXBhcnNlJ1xuaW1wb3J0IHtcbiAgQ2FsZW5kYXJPcHRpb25zUmVmaW5lZCwgQ2FsZW5kYXJPcHRpb25zLFxuICBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMsIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTLFxuICBWaWV3T3B0aW9ucywgVmlld09wdGlvbnNSZWZpbmVkLFxuICBCQVNFX09QVElPTl9ERUZBVUxUUywgbWVyZ2VSYXdPcHRpb25zLFxuICBCQVNFX09QVElPTl9SRUZJTkVSUywgVklFV19PUFRJT05fUkVGSU5FUlMsXG4gIENhbGVuZGFyTGlzdGVuZXJzLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUywgRGljdGlvbmFyeSxcbn0gZnJvbSAnLi4vb3B0aW9ucydcbmltcG9ydCB7IHJhbmdlQ29udGFpbnNNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi4vVmlld0FwaSdcbmltcG9ydCB7IHBhcnNlQnVzaW5lc3NIb3VycyB9IGZyb20gJy4uL3N0cnVjdHMvYnVzaW5lc3MtaG91cnMnXG5pbXBvcnQgeyBnbG9iYWxQbHVnaW5zIH0gZnJvbSAnLi4vZ2xvYmFsLXBsdWdpbnMnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUV2ZW50U3RvcmUgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXRhTWFuYWdlclN0YXRlLCBDYWxlbmRhck9wdGlvbnNEYXRhLCBDYWxlbmRhckN1cnJlbnRWaWV3RGF0YSwgQ2FsZW5kYXJEYXRhIH0gZnJvbSAnLi9kYXRhLXR5cGVzJ1xuaW1wb3J0IHsgVGFza1J1bm5lciB9IGZyb20gJy4uL3V0aWwvVGFza1J1bm5lcidcbmltcG9ydCB7IGJ1aWxkVGl0bGUgfSBmcm9tICcuL3RpdGxlLWZvcm1hdHRpbmcnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsZW5kYXJEYXRhTWFuYWdlclByb3BzIHtcbiAgb3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnNcbiAgY2FsZW5kYXJBcGk6IENhbGVuZGFyQXBpXG4gIG9uQWN0aW9uPzogKGFjdGlvbjogQWN0aW9uKSA9PiB2b2lkXG4gIG9uRGF0YT86IChkYXRhOiBDYWxlbmRhckRhdGEpID0+IHZvaWRcbn1cblxuZXhwb3J0IHR5cGUgUmVkdWNlckZ1bmMgPSAoIC8vIFRPRE86IHJlbmFtZSB0byBDYWxlbmRhckRhdGFJbmplY3Rvci4gbW92ZSB2aWV3LXByb3BzLW1hbmlwIGhvb2sgaGVyZSBhcyB3ZWxsP1xuICBjdXJyZW50U3RhdGU6IERpY3Rpb25hcnkgfCBudWxsLFxuICBhY3Rpb246IEFjdGlvbiB8IG51bGwsXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCAmIENhbGVuZGFyRGF0YU1hbmFnZXJTdGF0ZSAvLyBtb3JlIHRoYW4ganVzdCBjb250ZXh0XG4pID0+IERpY3Rpb25hcnlcblxuLy8gaW4gZnV0dXJlIHJlZmFjdG9yLCBkbyB0aGUgcmVkdXgtc3R5bGUgZnVuY3Rpb24oc3RhdGU9aW5pdGlhbCkgZm9yIGluaXRpYWwtc3RhdGVcbi8vIGFsc28sIHdoYXRldmVyIGlzIGhhcHBlbmluZyBpbiBjb25zdHJ1Y3RvciwgaGF2ZSBpdCBoYXBwZW4gaW4gYWN0aW9uIHF1ZXVlIHRvb1xuXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJEYXRhTWFuYWdlciB7XG4gIHByaXZhdGUgY29tcHV0ZU9wdGlvbnNEYXRhID0gbWVtb2l6ZSh0aGlzLl9jb21wdXRlT3B0aW9uc0RhdGEpXG4gIHByaXZhdGUgY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSA9IG1lbW9pemUodGhpcy5fY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSlcbiAgcHJpdmF0ZSBvcmdhbml6ZVJhd0xvY2FsZXMgPSBtZW1vaXplKG9yZ2FuaXplUmF3TG9jYWxlcylcbiAgcHJpdmF0ZSBidWlsZExvY2FsZSA9IG1lbW9pemUoYnVpbGRMb2NhbGUpXG4gIHByaXZhdGUgYnVpbGRQbHVnaW5Ib29rcyA9IGJ1aWxkQnVpbGRQbHVnaW5Ib29rcygpXG4gIHByaXZhdGUgYnVpbGREYXRlRW52ID0gbWVtb2l6ZShidWlsZERhdGVFbnYpXG4gIHByaXZhdGUgYnVpbGRUaGVtZSA9IG1lbW9pemUoYnVpbGRUaGVtZSlcbiAgcHJpdmF0ZSBwYXJzZVRvb2xiYXJzID0gbWVtb2l6ZShwYXJzZVRvb2xiYXJzKVxuICBwcml2YXRlIGJ1aWxkVmlld1NwZWNzID0gbWVtb2l6ZShidWlsZFZpZXdTcGVjcylcbiAgcHJpdmF0ZSBidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yID0gbWVtb2l6ZU9iakFyZyhidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKVxuICBwcml2YXRlIGJ1aWxkVmlld0FwaSA9IG1lbW9pemUoYnVpbGRWaWV3QXBpKVxuICBwcml2YXRlIGJ1aWxkVmlld1VpUHJvcHMgPSBtZW1vaXplT2JqQXJnKGJ1aWxkVmlld1VpUHJvcHMpXG4gIHByaXZhdGUgYnVpbGRFdmVudFVpQnlTb3VyY2UgPSBtZW1vaXplKGJ1aWxkRXZlbnRVaUJ5U291cmNlLCBpc1Byb3BzRXF1YWwpXG4gIHByaXZhdGUgYnVpbGRFdmVudFVpQmFzZXMgPSBtZW1vaXplKGJ1aWxkRXZlbnRVaUJhc2VzKVxuICBwcml2YXRlIHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMgPSBtZW1vaXplT2JqQXJnKHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMpXG4gIHByaXZhdGUgYnVpbGRUaXRsZSA9IG1lbW9pemUoYnVpbGRUaXRsZSlcblxuICBwdWJsaWMgZW1pdHRlciA9IG5ldyBFbWl0dGVyPENhbGVuZGFyTGlzdGVuZXJzPigpXG4gIHByaXZhdGUgYWN0aW9uUnVubmVyID0gbmV3IFRhc2tSdW5uZXIodGhpcy5faGFuZGxlQWN0aW9uLmJpbmQodGhpcyksIHRoaXMudXBkYXRlRGF0YS5iaW5kKHRoaXMpKVxuICBwcml2YXRlIHByb3BzOiBDYWxlbmRhckRhdGFNYW5hZ2VyUHJvcHNcbiAgcHJpdmF0ZSBzdGF0ZTogQ2FsZW5kYXJEYXRhTWFuYWdlclN0YXRlXG4gIHByaXZhdGUgZGF0YTogQ2FsZW5kYXJEYXRhXG5cbiAgcHVibGljIGN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dDogQ2FsZW5kYXJPcHRpb25zID0ge31cbiAgcHJpdmF0ZSBjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZDogQ2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9ICh7fSBhcyBhbnkpXG4gIHByaXZhdGUgY3VycmVudFZpZXdPcHRpb25zSW5wdXQ6IFZpZXdPcHRpb25zID0ge31cbiAgcHJpdmF0ZSBjdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkOiBWaWV3T3B0aW9uc1JlZmluZWQgPSAoe30gYXMgYW55KVxuICBwdWJsaWMgY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzOiBhbnkgPSB7fVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBDYWxlbmRhckRhdGFNYW5hZ2VyUHJvcHMpIHtcbiAgICB0aGlzLnByb3BzID0gcHJvcHNcbiAgICB0aGlzLmFjdGlvblJ1bm5lci5wYXVzZSgpXG5cbiAgICBsZXQgZHluYW1pY09wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zID0ge31cbiAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShcbiAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICApXG5cbiAgICBsZXQgY3VycmVudFZpZXdUeXBlID0gb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLmluaXRpYWxWaWV3IHx8IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLmluaXRpYWxWaWV3XG4gICAgbGV0IGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShcbiAgICAgIGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgIG9wdGlvbnNEYXRhLFxuICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICApXG5cbiAgICAvLyB3aXJlIHRoaW5ncyB1cFxuICAgIC8vIFRPRE86IG5vdCBEUllcbiAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzXG4gICAgdGhpcy5lbWl0dGVyLnNldFRoaXNDb250ZXh0KHByb3BzLmNhbGVuZGFyQXBpKVxuICAgIHRoaXMuZW1pdHRlci5zZXRPcHRpb25zKGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zKVxuXG4gICAgbGV0IGN1cnJlbnREYXRlID0gZ2V0SW5pdGlhbERhdGUob3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLCBvcHRpb25zRGF0YS5kYXRlRW52KVxuICAgIGxldCBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSlcblxuICAgIGlmICghcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydFxuICAgIH1cblxuICAgIGxldCBjYWxlbmRhckNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCA9IHtcbiAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICBvcHRpb25zOiBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsXG4gICAgICBwbHVnaW5Ib29rczogb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgIGVtaXR0ZXI6IHRoaXMuZW1pdHRlcixcbiAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgIH1cblxuICAgIC8vIG5lZWRzIHRvIGJlIGFmdGVyIHNldFRoaXNDb250ZXh0XG4gICAgZm9yIChsZXQgY2FsbGJhY2sgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuY29udGV4dEluaXQpIHtcbiAgICAgIGNhbGxiYWNrKGNhbGVuZGFyQ29udGV4dClcbiAgICB9XG5cbiAgICAvLyBOT1QgRFJZXG4gICAgbGV0IGV2ZW50U291cmNlcyA9IGluaXRFdmVudFNvdXJjZXMob3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KVxuXG4gICAgbGV0IGluaXRpYWxTdGF0ZTogQ2FsZW5kYXJEYXRhTWFuYWdlclN0YXRlID0ge1xuICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgIGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICBidXNpbmVzc0hvdXJzOiB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSwgLy8gd2VpcmQgdG8gaGF2ZSB0aGlzIGluIHN0YXRlXG4gICAgICBldmVudFNvdXJjZXMsXG4gICAgICBldmVudFVpQmFzZXM6IHt9LFxuICAgICAgZXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICBkYXRlU2VsZWN0aW9uOiBudWxsLFxuICAgICAgZXZlbnRTZWxlY3Rpb246ICcnLFxuICAgICAgZXZlbnREcmFnOiBudWxsLFxuICAgICAgZXZlbnRSZXNpemU6IG51bGwsXG4gICAgICBzZWxlY3Rpb25Db25maWc6IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpLnNlbGVjdGlvbkNvbmZpZyxcbiAgICB9XG4gICAgbGV0IGNvbnRleHRBbmRTdGF0ZSA9IHsgLi4uY2FsZW5kYXJDb250ZXh0LCAuLi5pbml0aWFsU3RhdGUgfVxuXG4gICAgZm9yIChsZXQgcmVkdWNlciBvZiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2Vycykge1xuICAgICAgX19hc3NpZ24oaW5pdGlhbFN0YXRlLCByZWR1Y2VyKG51bGwsIG51bGwsIGNvbnRleHRBbmRTdGF0ZSkpXG4gICAgfVxuXG4gICAgaWYgKGNvbXB1dGVJc0xvYWRpbmcoaW5pdGlhbFN0YXRlLCBjYWxlbmRhckNvbnRleHQpKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpIC8vIE5PVCBEUllcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlXG4gICAgdGhpcy51cGRhdGVEYXRhKClcbiAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXN1bWUoKVxuICB9XG5cbiAgZ2V0Q3VycmVudERhdGEgPSAoKSA9PiB0aGlzLmRhdGFcblxuICBkaXNwYXRjaCA9IChhY3Rpb246IEFjdGlvbikgPT4ge1xuICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3QoYWN0aW9uKSAvLyBwcm90ZWN0cyBhZ2FpbnN0IHJlY3Vyc2l2ZSBjYWxscyB0byBfaGFuZGxlQWN0aW9uXG4gIH1cblxuICByZXNldE9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsIGFwcGVuZD86IGJvb2xlYW4pIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuXG4gICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzID0gYXBwZW5kXG4gICAgICA/IHsgLi4ucHJvcHMub3B0aW9uT3ZlcnJpZGVzLCAuLi5vcHRpb25PdmVycmlkZXMgfVxuICAgICAgOiBvcHRpb25PdmVycmlkZXNcblxuICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3QoeyAvLyBoYWNrLiB3aWxsIGNhdXNlIHVwZGF0ZURhdGFcbiAgICAgIHR5cGU6ICdOT1RISU5HJyxcbiAgICB9KVxuICB9XG5cbiAgX2hhbmRsZUFjdGlvbihhY3Rpb246IEFjdGlvbikge1xuICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgZW1pdHRlciB9ID0gdGhpc1xuXG4gICAgbGV0IGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSByZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGFjdGlvbilcbiAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShcbiAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICApXG5cbiAgICBsZXQgY3VycmVudFZpZXdUeXBlID0gcmVkdWNlVmlld1R5cGUoc3RhdGUuY3VycmVudFZpZXdUeXBlLCBhY3Rpb24pXG4gICAgbGV0IGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShcbiAgICAgIGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgIG9wdGlvbnNEYXRhLFxuICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICApXG5cbiAgICAvLyB3aXJlIHRoaW5ncyB1cFxuICAgIC8vIFRPRE86IG5vdCBEUllcbiAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzXG4gICAgZW1pdHRlci5zZXRUaGlzQ29udGV4dChwcm9wcy5jYWxlbmRhckFwaSlcbiAgICBlbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpXG5cbiAgICBsZXQgY2FsZW5kYXJDb250ZXh0OiBDYWxlbmRhckNvbnRleHQgPSB7XG4gICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxuICAgICAgb3B0aW9uczogb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLFxuICAgICAgcGx1Z2luSG9va3M6IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLFxuICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsXG4gICAgICBlbWl0dGVyLFxuICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXG4gICAgfVxuXG4gICAgbGV0IHsgY3VycmVudERhdGUsIGRhdGVQcm9maWxlIH0gPSBzdGF0ZVxuXG4gICAgaWYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IgIT09IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcikgeyAvLyBoYWNrXG4gICAgICBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSlcbiAgICB9XG5cbiAgICBjdXJyZW50RGF0ZSA9IHJlZHVjZUN1cnJlbnREYXRlKGN1cnJlbnREYXRlLCBhY3Rpb24pXG4gICAgZGF0ZVByb2ZpbGUgPSByZWR1Y2VEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yKVxuXG4gICAgaWYgKFxuICAgICAgYWN0aW9uLnR5cGUgPT09ICdQUkVWJyB8fCAvLyBUT0RPOiBtb3ZlIHRoaXMgbG9naWMgaW50byBEYXRlUHJvZmlsZUdlbmVyYXRvclxuICAgICAgYWN0aW9uLnR5cGUgPT09ICdORVhUJyB8fCAvLyBcIlxuICAgICAgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBjdXJyZW50RGF0ZSlcbiAgICApIHtcbiAgICAgIGN1cnJlbnREYXRlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0XG4gICAgfVxuXG4gICAgbGV0IGV2ZW50U291cmNlcyA9IHJlZHVjZUV2ZW50U291cmNlcyhzdGF0ZS5ldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dClcbiAgICBsZXQgZXZlbnRTdG9yZSA9IHJlZHVjZUV2ZW50U3RvcmUoc3RhdGUuZXZlbnRTdG9yZSwgYWN0aW9uLCBldmVudFNvdXJjZXMsIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpXG4gICAgbGV0IGlzRXZlbnRzTG9hZGluZyA9IGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcykgLy8gQkFELiBhbHNvIGNhbGxlZCBpbiB0aGlzIGZ1bmMgaW4gY29tcHV0ZUlzTG9hZGluZ1xuXG4gICAgbGV0IHJlbmRlcmFibGVFdmVudFN0b3JlID1cbiAgICAgIChpc0V2ZW50c0xvYWRpbmcgJiYgIWN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLnByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmcpID9cbiAgICAgICAgKHN0YXRlLnJlbmRlcmFibGVFdmVudFN0b3JlIHx8IGV2ZW50U3RvcmUpIDogLy8gdHJ5IGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICAgICAgZXZlbnRTdG9yZVxuXG4gICAgbGV0IHsgZXZlbnRVaVNpbmdsZUJhc2UsIHNlbGVjdGlvbkNvbmZpZyB9ID0gdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkgLy8gd2lsbCBtZW1vaXplIG9ialxuICAgIGxldCBldmVudFVpQnlTb3VyY2UgPSB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlKGV2ZW50U291cmNlcylcbiAgICBsZXQgZXZlbnRVaUJhc2VzID0gdGhpcy5idWlsZEV2ZW50VWlCYXNlcyhyZW5kZXJhYmxlRXZlbnRTdG9yZS5kZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKVxuXG4gICAgbGV0IG5ld1N0YXRlOiBDYWxlbmRhckRhdGFNYW5hZ2VyU3RhdGUgPSB7XG4gICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgY3VycmVudFZpZXdUeXBlLFxuICAgICAgY3VycmVudERhdGUsXG4gICAgICBkYXRlUHJvZmlsZSxcbiAgICAgIGV2ZW50U291cmNlcyxcbiAgICAgIGV2ZW50U3RvcmUsXG4gICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZSxcbiAgICAgIHNlbGVjdGlvbkNvbmZpZyxcbiAgICAgIGV2ZW50VWlCYXNlcyxcbiAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpLCAvLyB3aWxsIG1lbW9pemUgb2JqXG4gICAgICBkYXRlU2VsZWN0aW9uOiByZWR1Y2VEYXRlU2VsZWN0aW9uKHN0YXRlLmRhdGVTZWxlY3Rpb24sIGFjdGlvbiksXG4gICAgICBldmVudFNlbGVjdGlvbjogcmVkdWNlU2VsZWN0ZWRFdmVudChzdGF0ZS5ldmVudFNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgIGV2ZW50RHJhZzogcmVkdWNlRXZlbnREcmFnKHN0YXRlLmV2ZW50RHJhZywgYWN0aW9uKSxcbiAgICAgIGV2ZW50UmVzaXplOiByZWR1Y2VFdmVudFJlc2l6ZShzdGF0ZS5ldmVudFJlc2l6ZSwgYWN0aW9uKSxcbiAgICB9XG4gICAgbGV0IGNvbnRleHRBbmRTdGF0ZSA9IHsgLi4uY2FsZW5kYXJDb250ZXh0LCAuLi5uZXdTdGF0ZSB9XG5cbiAgICBmb3IgKGxldCByZWR1Y2VyIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLnJlZHVjZXJzKSB7XG4gICAgICBfX2Fzc2lnbihuZXdTdGF0ZSwgcmVkdWNlcihzdGF0ZSwgYWN0aW9uLCBjb250ZXh0QW5kU3RhdGUpKSAvLyBnaXZlIHRoZSBPTEQgc3RhdGUsIGZvciBvbGQgdmFsdWVcbiAgICB9XG5cbiAgICBsZXQgd2FzTG9hZGluZyA9IGNvbXB1dGVJc0xvYWRpbmcoc3RhdGUsIGNhbGVuZGFyQ29udGV4dClcbiAgICBsZXQgaXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhuZXdTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KVxuXG4gICAgLy8gVE9ETzogdXNlIHByb3BTZXRIYW5kbGVycyBpbiBwbHVnaW4gc3lzdGVtXG4gICAgaWYgKCF3YXNMb2FkaW5nICYmIGlzTG9hZGluZykge1xuICAgICAgZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgdHJ1ZSlcbiAgICB9IGVsc2UgaWYgKHdhc0xvYWRpbmcgJiYgIWlzTG9hZGluZykge1xuICAgICAgZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgZmFsc2UpXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlXG5cbiAgICBpZiAocHJvcHMub25BY3Rpb24pIHtcbiAgICAgIHByb3BzLm9uQWN0aW9uKGFjdGlvbilcbiAgICB9XG4gIH1cblxuICB1cGRhdGVEYXRhKCkge1xuICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGxldCBvbGREYXRhID0gdGhpcy5kYXRhXG5cbiAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShcbiAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgIHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICApXG5cbiAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKFxuICAgICAgc3RhdGUuY3VycmVudFZpZXdUeXBlLFxuICAgICAgb3B0aW9uc0RhdGEsXG4gICAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMsXG4gICAgICBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgIClcblxuICAgIGxldCBkYXRhOiBDYWxlbmRhckRhdGEgPSB0aGlzLmRhdGEgPSB7XG4gICAgICB2aWV3VGl0bGU6IHRoaXMuYnVpbGRUaXRsZShzdGF0ZS5kYXRlUHJvZmlsZSwgY3VycmVudFZpZXdEYXRhLm9wdGlvbnMsIG9wdGlvbnNEYXRhLmRhdGVFbnYpLFxuICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsXG4gICAgICBlbWl0dGVyOiB0aGlzLmVtaXR0ZXIsXG4gICAgICBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSxcbiAgICAgIC4uLm9wdGlvbnNEYXRhLFxuICAgICAgLi4uY3VycmVudFZpZXdEYXRhLFxuICAgICAgLi4uc3RhdGUsXG4gICAgfVxuXG4gICAgbGV0IGNoYW5nZUhhbmRsZXJzID0gb3B0aW9uc0RhdGEucGx1Z2luSG9va3Mub3B0aW9uQ2hhbmdlSGFuZGxlcnNcbiAgICBsZXQgb2xkQ2FsZW5kYXJPcHRpb25zID0gb2xkRGF0YSAmJiBvbGREYXRhLmNhbGVuZGFyT3B0aW9uc1xuICAgIGxldCBuZXdDYWxlbmRhck9wdGlvbnMgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnNcblxuICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnMgJiYgb2xkQ2FsZW5kYXJPcHRpb25zICE9PSBuZXdDYWxlbmRhck9wdGlvbnMpIHtcbiAgICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnMudGltZVpvbmUgIT09IG5ld0NhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSkge1xuICAgICAgICAvLyBoYWNrXG4gICAgICAgIHN0YXRlLmV2ZW50U291cmNlcyA9IGRhdGEuZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZGF0YS5ldmVudFNvdXJjZXMsIHN0YXRlLmRhdGVQcm9maWxlLCBkYXRhKVxuICAgICAgICBzdGF0ZS5ldmVudFN0b3JlID0gZGF0YS5ldmVudFN0b3JlID0gcmV6b25lRXZlbnRTdG9yZURhdGVzKGRhdGEuZXZlbnRTdG9yZSwgb2xkRGF0YS5kYXRlRW52LCBkYXRhLmRhdGVFbnYpXG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gY2hhbmdlSGFuZGxlcnMpIHtcbiAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgY2hhbmdlSGFuZGxlcnNbb3B0aW9uTmFtZV0obmV3Q2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdLCBkYXRhKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLm9uRGF0YSkge1xuICAgICAgcHJvcHMub25EYXRhKGRhdGEpXG4gICAgfVxuICB9XG5cbiAgX2NvbXB1dGVPcHRpb25zRGF0YShcbiAgICBvcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyxcbiAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsXG4gICAgY2FsZW5kYXJBcGk6IENhbGVuZGFyQXBpLFxuICApOiBDYWxlbmRhck9wdGlvbnNEYXRhIHtcbiAgICAvLyBUT0RPOiBibGFja2xpc3Qgb3B0aW9ucyB0aGF0IGFyZSBoYW5kbGVkIGJ5IG9wdGlvbkNoYW5nZUhhbmRsZXJzXG5cbiAgICBsZXQge1xuICAgICAgcmVmaW5lZE9wdGlvbnMsIHBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgZXh0cmEsXG4gICAgfSA9IHRoaXMucHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpXG5cbiAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpXG5cbiAgICBsZXQgZGF0ZUVudiA9IHRoaXMuYnVpbGREYXRlRW52KFxuICAgICAgcmVmaW5lZE9wdGlvbnMudGltZVpvbmUsXG4gICAgICByZWZpbmVkT3B0aW9ucy5sb2NhbGUsXG4gICAgICByZWZpbmVkT3B0aW9ucy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24sXG4gICAgICByZWZpbmVkT3B0aW9ucy5maXJzdERheSxcbiAgICAgIHJlZmluZWRPcHRpb25zLndlZWtUZXh0LFxuICAgICAgcGx1Z2luSG9va3MsXG4gICAgICBhdmFpbGFibGVMb2NhbGVEYXRhLFxuICAgICAgcmVmaW5lZE9wdGlvbnMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yLFxuICAgIClcblxuICAgIGxldCB2aWV3U3BlY3MgPSB0aGlzLmJ1aWxkVmlld1NwZWNzKHBsdWdpbkhvb2tzLnZpZXdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKVxuICAgIGxldCB0aGVtZSA9IHRoaXMuYnVpbGRUaGVtZShyZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MpXG4gICAgbGV0IHRvb2xiYXJDb25maWcgPSB0aGlzLnBhcnNlVG9vbGJhcnMocmVmaW5lZE9wdGlvbnMsIG9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpXG5cbiAgICByZXR1cm4ge1xuICAgICAgY2FsZW5kYXJPcHRpb25zOiByZWZpbmVkT3B0aW9ucyxcbiAgICAgIHBsdWdpbkhvb2tzLFxuICAgICAgZGF0ZUVudixcbiAgICAgIHZpZXdTcGVjcyxcbiAgICAgIHRoZW1lLFxuICAgICAgdG9vbGJhckNvbmZpZyxcbiAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgYXZhaWxhYmxlUmF3TG9jYWxlczogYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXAsXG4gICAgfVxuICB9XG5cbiAgLy8gYWx3YXlzIGNhbGxlZCBmcm9tIGJlaGluZCBhIG1lbW9pemVyXG4gIHByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucykge1xuICAgIGxldCB7IGxvY2FsZXMsIGxvY2FsZSB9ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICBdKVxuICAgIGxldCBhdmFpbGFibGVMb2NhbGVEYXRhID0gdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMobG9jYWxlcylcbiAgICBsZXQgYXZhaWxhYmxlUmF3TG9jYWxlcyA9IGF2YWlsYWJsZUxvY2FsZURhdGEubWFwXG4gICAgbGV0IGxvY2FsZURlZmF1bHRzID0gdGhpcy5idWlsZExvY2FsZShsb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlUmF3TG9jYWxlcykub3B0aW9uc1xuICAgIGxldCBwbHVnaW5Ib29rcyA9IHRoaXMuYnVpbGRQbHVnaW5Ib29rcyhvcHRpb25PdmVycmlkZXMucGx1Z2lucyB8fCBbXSwgZ2xvYmFsUGx1Z2lucylcbiAgICBsZXQgcmVmaW5lcnMgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVycyA9IHtcbiAgICAgIC4uLkJBU0VfT1BUSU9OX1JFRklORVJTLFxuICAgICAgLi4uQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMsXG4gICAgICAuLi5DQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMsXG4gICAgICAuLi5wbHVnaW5Ib29rcy5saXN0ZW5lclJlZmluZXJzLFxuICAgICAgLi4ucGx1Z2luSG9va3Mub3B0aW9uUmVmaW5lcnMsXG4gICAgfVxuICAgIGxldCBleHRyYSA9IHt9XG5cbiAgICBsZXQgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgIF0pXG4gICAgbGV0IHJlZmluZWQ6IFBhcnRpYWw8Q2FsZW5kYXJPcHRpb25zUmVmaW5lZD4gPSB7fVxuICAgIGxldCBjdXJyZW50UmF3ID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRcbiAgICBsZXQgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkXG4gICAgbGV0IGFueUNoYW5nZXMgPSBmYWxzZVxuXG4gICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgIGlmIChvcHRpb25OYW1lICE9PSAncGx1Z2lucycpIHsgLy8gYmVjYXVzZSBwbHVnaW5zIGlzIHNwZWNpYWwtY2FzZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHJhd1tvcHRpb25OYW1lXSA9PT0gY3VycmVudFJhd1tvcHRpb25OYW1lXSB8fFxuICAgICAgICAgIChcbiAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdICYmXG4gICAgICAgICAgICAob3B0aW9uTmFtZSBpbiBjdXJyZW50UmF3KSAmJlxuICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0oY3VycmVudFJhd1tvcHRpb25OYW1lXSwgcmF3W29wdGlvbk5hbWVdKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IGN1cnJlbnRSZWZpbmVkW29wdGlvbk5hbWVdXG4gICAgICAgIH0gZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gcmVmaW5lcnNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdKVxuICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmF3W29wdGlvbk5hbWVdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQgPSByYXdcbiAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQgPSByZWZpbmVkIGFzIENhbGVuZGFyT3B0aW9uc1JlZmluZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQsXG4gICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCxcbiAgICAgIHBsdWdpbkhvb2tzLFxuICAgICAgYXZhaWxhYmxlTG9jYWxlRGF0YSxcbiAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgZXh0cmEsXG4gICAgfVxuICB9XG5cbiAgX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEoXG4gICAgdmlld1R5cGU6IHN0cmluZyxcbiAgICBvcHRpb25zRGF0YTogQ2FsZW5kYXJPcHRpb25zRGF0YSxcbiAgICBvcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyxcbiAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsXG4gICk6IENhbGVuZGFyQ3VycmVudFZpZXdEYXRhIHtcbiAgICBsZXQgdmlld1NwZWMgPSBvcHRpb25zRGF0YS52aWV3U3BlY3Nbdmlld1R5cGVdXG5cbiAgICBpZiAoIXZpZXdTcGVjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHZpZXdUeXBlIFwiJHt2aWV3VHlwZX1cIiBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSd2ZSBsb2FkZWQgYWxsIG5lY2Nlc3NhcnkgcGx1Z2luc2ApXG4gICAgfVxuXG4gICAgbGV0IHsgcmVmaW5lZE9wdGlvbnMsIGV4dHJhIH0gPSB0aGlzLnByb2Nlc3NSYXdWaWV3T3B0aW9ucyhcbiAgICAgIHZpZXdTcGVjLFxuICAgICAgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICBvcHRpb25zRGF0YS5sb2NhbGVEZWZhdWx0cyxcbiAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgKVxuXG4gICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKVxuXG4gICAgbGV0IGRhdGVQcm9maWxlR2VuZXJhdG9yID0gdGhpcy5idWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKHtcbiAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgYXMgYW55LFxuICAgICAgZHVyYXRpb246IHZpZXdTcGVjLmR1cmF0aW9uLFxuICAgICAgZHVyYXRpb25Vbml0OiB2aWV3U3BlYy5kdXJhdGlvblVuaXQsXG4gICAgICB1c2VzTWluTWF4VGltZTogdmlld1NwZWMub3B0aW9uRGVmYXVsdHMudXNlc01pbk1heFRpbWUgYXMgYW55LFxuICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgIGNhbGVuZGFyQXBpOiB0aGlzLnByb3BzLmNhbGVuZGFyQXBpLCAvLyBzaG91bGQgY29tZSBmcm9tIGVsc2V3aGVyZT9cbiAgICAgIHNsb3RNaW5UaW1lOiByZWZpbmVkT3B0aW9ucy5zbG90TWluVGltZSxcbiAgICAgIHNsb3RNYXhUaW1lOiByZWZpbmVkT3B0aW9ucy5zbG90TWF4VGltZSxcbiAgICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHJlZmluZWRPcHRpb25zLnNob3dOb25DdXJyZW50RGF0ZXMsXG4gICAgICBkYXlDb3VudDogcmVmaW5lZE9wdGlvbnMuZGF5Q291bnQsXG4gICAgICBkYXRlQWxpZ25tZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlQWxpZ25tZW50LFxuICAgICAgZGF0ZUluY3JlbWVudDogcmVmaW5lZE9wdGlvbnMuZGF0ZUluY3JlbWVudCxcbiAgICAgIGhpZGRlbkRheXM6IHJlZmluZWRPcHRpb25zLmhpZGRlbkRheXMsXG4gICAgICB3ZWVrZW5kczogcmVmaW5lZE9wdGlvbnMud2Vla2VuZHMsXG4gICAgICBub3dJbnB1dDogcmVmaW5lZE9wdGlvbnMubm93LFxuICAgICAgdmFsaWRSYW5nZUlucHV0OiByZWZpbmVkT3B0aW9ucy52YWxpZFJhbmdlLFxuICAgICAgdmlzaWJsZVJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZpc2libGVSYW5nZSxcbiAgICAgIG1vbnRoTW9kZTogcmVmaW5lZE9wdGlvbnMubW9udGhNb2RlLFxuICAgICAgZml4ZWRXZWVrQ291bnQ6IHJlZmluZWRPcHRpb25zLmZpeGVkV2Vla0NvdW50LFxuICAgIH0pXG5cbiAgICBsZXQgdmlld0FwaSA9IHRoaXMuYnVpbGRWaWV3QXBpKHZpZXdUeXBlLCB0aGlzLmdldEN1cnJlbnREYXRhLCBvcHRpb25zRGF0YS5kYXRlRW52KVxuXG4gICAgcmV0dXJuIHsgdmlld1NwZWMsIG9wdGlvbnM6IHJlZmluZWRPcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgdmlld0FwaSB9XG4gIH1cblxuICBwcm9jZXNzUmF3Vmlld09wdGlvbnMoXG4gICAgdmlld1NwZWM6IFZpZXdTcGVjLFxuICAgIHBsdWdpbkhvb2tzOiBQbHVnaW5Ib29rcyxcbiAgICBsb2NhbGVEZWZhdWx0czogQ2FsZW5kYXJPcHRpb25zLFxuICAgIG9wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLFxuICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyxcbiAgKSB7XG4gICAgbGV0IHJhdyA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgIHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLFxuICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICB2aWV3U3BlYy5vcHRpb25PdmVycmlkZXMsXG4gICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgIF0pXG4gICAgbGV0IHJlZmluZXJzID0ge1xuICAgICAgLi4uQkFTRV9PUFRJT05fUkVGSU5FUlMsXG4gICAgICAuLi5DQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyxcbiAgICAgIC4uLkNBTEVOREFSX09QVElPTl9SRUZJTkVSUyxcbiAgICAgIC4uLlZJRVdfT1BUSU9OX1JFRklORVJTLFxuICAgICAgLi4ucGx1Z2luSG9va3MubGlzdGVuZXJSZWZpbmVycyxcbiAgICAgIC4uLnBsdWdpbkhvb2tzLm9wdGlvblJlZmluZXJzLFxuICAgIH1cbiAgICBsZXQgcmVmaW5lZDogUGFydGlhbDxWaWV3T3B0aW9uc1JlZmluZWQ+ID0ge31cbiAgICBsZXQgY3VycmVudFJhdyA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXRcbiAgICBsZXQgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWRcbiAgICBsZXQgYW55Q2hhbmdlcyA9IGZhbHNlXG4gICAgbGV0IGV4dHJhID0ge31cblxuICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gcmF3KSB7XG4gICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdKSB7XG4gICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICBpZiAob3B0aW9uTmFtZSBpbiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkKSB7IC8vIG1pZ2h0IGJlIGFuIFwiZXh0cmFcIiBwcm9wXG4gICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZFtvcHRpb25OYW1lXVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWZpbmVyc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSByYXdbb3B0aW9uTmFtZV1cbiAgICAgICAgfVxuXG4gICAgICAgIGFueUNoYW5nZXMgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFueUNoYW5nZXMpIHtcbiAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQgPSByYXdcbiAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCA9IHJlZmluZWQgYXMgVmlld09wdGlvbnNSZWZpbmVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJhd09wdGlvbnM6IHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQsXG4gICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkLFxuICAgICAgZXh0cmEsXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRGF0ZUVudihcbiAgdGltZVpvbmU6IHN0cmluZyxcbiAgZXhwbGljaXRMb2NhbGU6IExvY2FsZVNpbmd1bGFyQXJnLFxuICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sXG4gIGZpcnN0RGF5OiBudW1iZXIgfCB1bmRlZmluZWQsXG4gIHdlZWtUZXh0LFxuICBwbHVnaW5Ib29rczogUGx1Z2luSG9va3MsXG4gIGF2YWlsYWJsZUxvY2FsZURhdGE6IFJhd0xvY2FsZUluZm8sXG4gIGRlZmF1bHRTZXBhcmF0b3I6IHN0cmluZyxcbikge1xuICBsZXQgbG9jYWxlID0gYnVpbGRMb2NhbGUoZXhwbGljaXRMb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXApXG5cbiAgcmV0dXJuIG5ldyBEYXRlRW52KHtcbiAgICBjYWxlbmRhclN5c3RlbTogJ2dyZWdvcnknLCAvLyBUT0RPOiBtYWtlIHRoaXMgYSBzZXR0aW5nXG4gICAgdGltZVpvbmUsXG4gICAgbmFtZWRUaW1lWm9uZUltcGw6IHBsdWdpbkhvb2tzLm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICBsb2NhbGUsXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uLFxuICAgIGZpcnN0RGF5LFxuICAgIHdlZWtUZXh0LFxuICAgIGNtZEZvcm1hdHRlcjogcGx1Z2luSG9va3MuY21kRm9ybWF0dGVyLFxuICAgIGRlZmF1bHRTZXBhcmF0b3IsXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGJ1aWxkVGhlbWUob3B0aW9uczogQ2FsZW5kYXJPcHRpb25zUmVmaW5lZCwgcGx1Z2luSG9va3M6IFBsdWdpbkhvb2tzKSB7XG4gIGxldCBUaGVtZUNsYXNzID0gcGx1Z2luSG9va3MudGhlbWVDbGFzc2VzW29wdGlvbnMudGhlbWVTeXN0ZW1dIHx8IFN0YW5kYXJkVGhlbWVcblxuICByZXR1cm4gbmV3IFRoZW1lQ2xhc3Mob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcihwcm9wczogRGF0ZVByb2ZpbGVHZW5lcmF0b3JQcm9wcyk6IERhdGVQcm9maWxlR2VuZXJhdG9yIHtcbiAgbGV0IERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIHx8IERhdGVQcm9maWxlR2VuZXJhdG9yXG5cbiAgcmV0dXJuIG5ldyBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKHByb3BzKVxufVxuXG5mdW5jdGlvbiBidWlsZFZpZXdBcGkodHlwZTogc3RyaW5nLCBnZXRDdXJyZW50RGF0YTogKCkgPT4gQ2FsZW5kYXJEYXRhLCBkYXRlRW52OiBEYXRlRW52KSB7XG4gIHJldHVybiBuZXcgVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudilcbn1cblxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzOiBFdmVudFNvdXJjZUhhc2gpOiBFdmVudFVpSGFzaCB7XG4gIHJldHVybiBtYXBIYXNoKGV2ZW50U291cmNlcywgKGV2ZW50U291cmNlKSA9PiBldmVudFNvdXJjZS51aSlcbn1cblxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQmFzZXMoZXZlbnREZWZzOiBFdmVudERlZkhhc2gsIGV2ZW50VWlTaW5nbGVCYXNlOiBFdmVudFVpLCBldmVudFVpQnlTb3VyY2U6IEV2ZW50VWlIYXNoKSB7XG4gIGxldCBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoID0geyAnJzogZXZlbnRVaVNpbmdsZUJhc2UgfVxuXG4gIGZvciAobGV0IGRlZklkIGluIGV2ZW50RGVmcykge1xuICAgIGxldCBkZWYgPSBldmVudERlZnNbZGVmSWRdXG5cbiAgICBpZiAoZGVmLnNvdXJjZUlkICYmIGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdKSB7XG4gICAgICBldmVudFVpQmFzZXNbZGVmSWRdID0gZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnRVaUJhc2VzXG59XG5cbmZ1bmN0aW9uIGJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgbGV0IHsgb3B0aW9ucyB9ID0gY2FsZW5kYXJDb250ZXh0XG5cbiAgcmV0dXJuIHtcbiAgICBldmVudFVpU2luZ2xlQmFzZTogY3JlYXRlRXZlbnRVaShcbiAgICAgIHtcbiAgICAgICAgZGlzcGxheTogb3B0aW9ucy5ldmVudERpc3BsYXksXG4gICAgICAgIGVkaXRhYmxlOiBvcHRpb25zLmVkaXRhYmxlLCAvLyB3aXRob3V0IFwiZXZlbnRcIiBhdCBzdGFydFxuICAgICAgICBzdGFydEVkaXRhYmxlOiBvcHRpb25zLmV2ZW50U3RhcnRFZGl0YWJsZSxcbiAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogb3B0aW9ucy5ldmVudER1cmF0aW9uRWRpdGFibGUsXG4gICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuZXZlbnRDb25zdHJhaW50LFxuICAgICAgICBvdmVybGFwOiB0eXBlb2Ygb3B0aW9ucy5ldmVudE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZXZlbnRPdmVybGFwIDogdW5kZWZpbmVkLFxuICAgICAgICBhbGxvdzogb3B0aW9ucy5ldmVudEFsbG93LFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuZXZlbnRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmV2ZW50Qm9yZGVyQ29sb3IsXG4gICAgICAgIHRleHRDb2xvcjogb3B0aW9ucy5ldmVudFRleHRDb2xvcixcbiAgICAgICAgY29sb3I6IG9wdGlvbnMuZXZlbnRDb2xvcixcbiAgICAgICAgLy8gY2xhc3NOYW1lczogb3B0aW9ucy5ldmVudENsYXNzTmFtZXMgLy8gcmVuZGVyIGhvb2sgd2lsbCBoYW5kbGUgdGhpc1xuICAgICAgfSxcbiAgICAgIGNhbGVuZGFyQ29udGV4dCxcbiAgICApLFxuICAgIHNlbGVjdGlvbkNvbmZpZzogY3JlYXRlRXZlbnRVaShcbiAgICAgIHtcbiAgICAgICAgY29uc3RyYWludDogb3B0aW9ucy5zZWxlY3RDb25zdHJhaW50LFxuICAgICAgICBvdmVybGFwOiB0eXBlb2Ygb3B0aW9ucy5zZWxlY3RPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNlbGVjdE92ZXJsYXAgOiB1bmRlZmluZWQsXG4gICAgICAgIGFsbG93OiBvcHRpb25zLnNlbGVjdEFsbG93LFxuICAgICAgfSxcbiAgICAgIGNhbGVuZGFyQ29udGV4dCxcbiAgICApLFxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVJc0xvYWRpbmcoc3RhdGU6IENhbGVuZGFyRGF0YU1hbmFnZXJTdGF0ZSwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGZvciAobGV0IGlzTG9hZGluZ0Z1bmMgb2YgY29udGV4dC5wbHVnaW5Ib29rcy5pc0xvYWRpbmdGdW5jcykge1xuICAgIGlmIChpc0xvYWRpbmdGdW5jKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICByZXR1cm4gcGFyc2VCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dC5vcHRpb25zLmJ1c2luZXNzSG91cnMsIGNhbGVuZGFyQ29udGV4dClcbn1cblxuZnVuY3Rpb24gd2FyblVua25vd25PcHRpb25zKG9wdGlvbnM6IGFueSwgdmlld05hbWU/OiBzdHJpbmcpIHtcbiAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFVua25vd24gb3B0aW9uICcke29wdGlvbk5hbWV9J2AgK1xuICAgICAgKHZpZXdOYW1lID8gYCBmb3IgdmlldyAnJHt2aWV3TmFtZX0nYCA6ICcnKSxcbiAgICApXG4gIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q2hpbGRyZW4gfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXRhTWFuYWdlciB9IGZyb20gJy4uL3JlZHVjZXJzL0NhbGVuZGFyRGF0YU1hbmFnZXInXG5pbXBvcnQgeyBDYWxlbmRhckFwaSB9IGZyb20gJy4uL0NhbGVuZGFyQXBpJ1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXRhIH0gZnJvbSAnLi4vcmVkdWNlcnMvZGF0YS10eXBlcydcblxuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhckRhdGFQcm92aWRlclByb3BzIHtcbiAgb3B0aW9uT3ZlcnJpZGVzOiBhbnlcbiAgY2FsZW5kYXJBcGk6IENhbGVuZGFyQXBpXG4gIGNoaWxkcmVuPzogKGRhdGE6IENhbGVuZGFyRGF0YSkgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbn1cblxuLy8gVE9ETzogbW92ZSB0aGlzIHRvIHJlYWN0IHBsdWdpbj9cbmV4cG9ydCBjbGFzcyBDYWxlbmRhckRhdGFQcm92aWRlciBleHRlbmRzIENvbXBvbmVudDxDYWxlbmRhckRhdGFQcm92aWRlclByb3BzLCBDYWxlbmRhckRhdGE+IHtcbiAgZGF0YU1hbmFnZXI6IENhbGVuZGFyRGF0YU1hbmFnZXJcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogQ2FsZW5kYXJEYXRhUHJvdmlkZXJQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgdGhpcy5kYXRhTWFuYWdlciA9IG5ldyBDYWxlbmRhckRhdGFNYW5hZ2VyKHtcbiAgICAgIG9wdGlvbk92ZXJyaWRlczogcHJvcHMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgb25EYXRhOiB0aGlzLmhhbmRsZURhdGEsXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZURhdGEgPSAoZGF0YTogQ2FsZW5kYXJEYXRhKSA9PiB7XG4gICAgaWYgKCF0aGlzLmRhdGFNYW5hZ2VyKSB7IC8vIHN0aWxsIHdpdGhpbiBpbml0aWFsIHJ1biwgYmVmb3JlIGFzc2lnbm1lbnQgaW4gY29uc3RydWN0b3JcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1kaXJlY3QtbXV0YXRpb24tc3RhdGVcbiAgICAgIHRoaXMuc3RhdGUgPSBkYXRhIC8vIGNhbid0IHVzZSBzZXRTdGF0ZSB5ZXRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTdGF0ZShkYXRhKVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnN0YXRlKVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogQ2FsZW5kYXJEYXRhUHJvdmlkZXJQcm9wcykge1xuICAgIGxldCBuZXdPcHRpb25PdmVycmlkZXMgPSB0aGlzLnByb3BzLm9wdGlvbk92ZXJyaWRlc1xuXG4gICAgaWYgKG5ld09wdGlvbk92ZXJyaWRlcyAhPT0gcHJldlByb3BzLm9wdGlvbk92ZXJyaWRlcykgeyAvLyBwcmV2ZW50IHJlY3Vyc2l2ZSBoYW5kbGVEYXRhXG4gICAgICB0aGlzLmRhdGFNYW5hZ2VyLnJlc2V0T3B0aW9ucyhuZXdPcHRpb25PdmVycmlkZXMpXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBFdmVudFN0b3JlIH0gZnJvbSAnLi9zdHJ1Y3RzL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgRXZlbnRVaUhhc2ggfSBmcm9tICcuL2NvbXBvbmVudC9ldmVudC11aSdcbmltcG9ydCB7IHNsaWNlRXZlbnRTdG9yZSwgRXZlbnRSZW5kZXJSYW5nZSB9IGZyb20gJy4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IERhdGVTcGFuIH0gZnJvbSAnLi9zdHJ1Y3RzL2RhdGUtc3BhbidcbmltcG9ydCB7IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL2V2ZW50LWludGVyYWN0aW9uLXN0YXRlJ1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuL2RhdGVsaWIvZHVyYXRpb24nXG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlld1Byb3BzIHtcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlXG4gIGJ1c2luZXNzSG91cnM6IEV2ZW50U3RvcmVcbiAgZXZlbnRTdG9yZTogRXZlbnRTdG9yZVxuICBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoXG4gIGRhdGVTZWxlY3Rpb246IERhdGVTcGFuIHwgbnVsbFxuICBldmVudFNlbGVjdGlvbjogc3RyaW5nXG4gIGV2ZW50RHJhZzogRXZlbnRJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBldmVudFJlc2l6ZTogRXZlbnRJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBpc0hlaWdodEF1dG86IGJvb2xlYW5cbiAgZm9yUHJpbnQ6IGJvb2xlYW5cbn1cblxuLy8gSEVMUEVSU1xuXG4vKlxuaWYgbmV4dERheVRocmVzaG9sZCBpcyBzcGVjaWZpZWQsIHNsaWNpbmcgaXMgZG9uZSBpbiBhbiBhbGwtZGF5IGZhc2hpb24uXG55b3UgY2FuIGdldCBuZXh0RGF5VGhyZXNob2xkIGZyb20gY29udGV4dC5uZXh0RGF5VGhyZXNob2xkXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlRXZlbnRzKFxuICBwcm9wczogVmlld1Byb3BzICYgeyBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQ6IER1cmF0aW9uIH0sXG4gIGFsbERheT86IGJvb2xlYW4sXG4pOiBFdmVudFJlbmRlclJhbmdlW10ge1xuICByZXR1cm4gc2xpY2VFdmVudFN0b3JlKFxuICAgIHByb3BzLmV2ZW50U3RvcmUsXG4gICAgcHJvcHMuZXZlbnRVaUJhc2VzLFxuICAgIHByb3BzLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLFxuICAgIGFsbERheSA/IHByb3BzLm5leHREYXlUaHJlc2hvbGQgOiBudWxsLFxuICApLmZnXG59XG4iLCJleHBvcnQgYWJzdHJhY3QgY2xhc3MgTmFtZWRUaW1lWm9uZUltcGwge1xuICB0aW1lWm9uZU5hbWU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKHRpbWVab25lTmFtZTogc3RyaW5nKSB7XG4gICAgdGhpcy50aW1lWm9uZU5hbWUgPSB0aW1lWm9uZU5hbWVcbiAgfVxuXG4gIGFic3RyYWN0IG9mZnNldEZvckFycmF5KGE6IG51bWJlcltdKTogbnVtYmVyXG5cbiAgYWJzdHJhY3QgdGltZXN0YW1wVG9BcnJheShtczogbnVtYmVyKTogbnVtYmVyW11cbn1cblxuZXhwb3J0IHR5cGUgTmFtZWRUaW1lWm9uZUltcGxDbGFzcyA9IHsgbmV3KHRpbWVab25lTmFtZTogc3RyaW5nKTogTmFtZWRUaW1lWm9uZUltcGwgfVxuIiwiZXhwb3J0IGludGVyZmFjZSBTZWdTcGFuIHtcbiAgc3RhcnQ6IG51bWJlclxuICBlbmQ6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlZ0VudHJ5IHtcbiAgaW5kZXg6IG51bWJlclxuICB0aGlja25lc3M6IG51bWJlciAvLyBzaG91bGQgYmUgYW4gaW50ZWdlclxuICBzcGFuOiBTZWdTcGFuXG59XG5cbi8vIHVzZWQgaW50ZXJuYWxseS4gZXhwb3NlZCBmb3Igc3ViY2xhc3NlcyBvZiBTZWdIaWVyYXJjaHlcbmV4cG9ydCBpbnRlcmZhY2UgU2VnSW5zZXJ0aW9uIHtcbiAgbGV2ZWw6IG51bWJlciAvLyB3aWxsIGhhdmUgYW4gZXF1YWwgY29vcmQsIG9yIHNsaWdodGx5IGJlZm9yZSwgZW50cmllcyBpbiBleGlzdGluZyBsZXZlbFxuICBsZXZlbENvb3JkOiBudW1iZXJcbiAgbGF0ZXJhbDogbnVtYmVyIC8vIHdoZXJlIHRvIGluc2VydCBpbiB0aGUgZXhpc3RpbmcgbGV2ZWwuIC0xIGlmIGNyZWF0aW5nIGEgbmV3IGxldmVsXG4gIHRvdWNoaW5nTGV2ZWw6IG51bWJlciAvLyAtMSBpZiBubyB0b3VjaGluZ1xuICB0b3VjaGluZ0xhdGVyYWw6IG51bWJlciAvLyAtMSBpZiBubyB0b3VjaGluZ1xuICB0b3VjaGluZ0VudHJ5OiBTZWdFbnRyeSAvLyB0aGUgbGFzdCB0b3VjaGluZyBlbnRyeSBpbiB0aGUgbGV2ZWxcbiAgc3RhY2tDbnQ6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlZ1JlY3QgZXh0ZW5kcyBTZWdFbnRyeSB7XG4gIGxldmVsQ29vcmQ6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlZ0VudHJ5R3JvdXAge1xuICBlbnRyaWVzOiBTZWdFbnRyeVtdXG4gIHNwYW46IFNlZ1NwYW5cbn1cblxuZXhwb3J0IGNsYXNzIFNlZ0hpZXJhcmNoeSB7XG4gIC8vIHNldHRpbmdzXG4gIHN0cmljdE9yZGVyOiBib29sZWFuID0gZmFsc2VcbiAgYWxsb3dSZXNsaWNpbmc6IGJvb2xlYW4gPSBmYWxzZVxuICBtYXhDb29yZDogbnVtYmVyID0gLTEgLy8gLTEgbWVhbnMgbm8gbWF4XG4gIG1heFN0YWNrQ250OiBudW1iZXIgPSAtMSAvLyAtMSBtZWFucyBubyBtYXhcblxuICBsZXZlbENvb3JkczogbnVtYmVyW10gPSBbXSAvLyBvcmRlcmVkXG4gIGVudHJpZXNCeUxldmVsOiBTZWdFbnRyeVtdW10gPSBbXSAvLyBwYXJhbGxlbCB3aXRoIGxldmVsQ29vcmRzXG4gIHN0YWNrQ250czogeyBbZW50cnlJZDogc3RyaW5nXTogbnVtYmVyIH0gPSB7fSAvLyBUT0RPOiB1c2UgYmV0dGVyIHRlY2huaXF1ZSE/XG5cbiAgYWRkU2VncyhpbnB1dHM6IFNlZ0VudHJ5W10pOiBTZWdFbnRyeVtdIHtcbiAgICBsZXQgaGlkZGVuRW50cmllczogU2VnRW50cnlbXSA9IFtdXG5cbiAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgIHRoaXMuaW5zZXJ0RW50cnkoaW5wdXQsIGhpZGRlbkVudHJpZXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIGhpZGRlbkVudHJpZXNcbiAgfVxuXG4gIGluc2VydEVudHJ5KGVudHJ5OiBTZWdFbnRyeSwgaGlkZGVuRW50cmllczogU2VnRW50cnlbXSk6IG51bWJlciB7XG4gICAgbGV0IGluc2VydGlvbiA9IHRoaXMuZmluZEluc2VydGlvbihlbnRyeSlcblxuICAgIGlmICh0aGlzLmlzSW5zZXJ0aW9uVmFsaWQoaW5zZXJ0aW9uLCBlbnRyeSkpIHtcbiAgICAgIHRoaXMuaW5zZXJ0RW50cnlBdChlbnRyeSwgaW5zZXJ0aW9uKVxuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpXG4gIH1cblxuICBpc0luc2VydGlvblZhbGlkKGluc2VydGlvbjogU2VnSW5zZXJ0aW9uLCBlbnRyeTogU2VnRW50cnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMubWF4Q29vcmQgPT09IC0xIHx8IGluc2VydGlvbi5sZXZlbENvb3JkICsgZW50cnkudGhpY2tuZXNzIDw9IHRoaXMubWF4Q29vcmQpICYmXG4gICAgICAodGhpcy5tYXhTdGFja0NudCA9PT0gLTEgfHwgaW5zZXJ0aW9uLnN0YWNrQ250IDwgdGhpcy5tYXhTdGFja0NudClcbiAgfVxuXG4gIC8vIHJldHVybnMgbnVtYmVyIG9mIG5ldyBlbnRyaWVzIGluc2VydGVkXG4gIGhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uOiBTZWdJbnNlcnRpb24sIGVudHJ5OiBTZWdFbnRyeSwgaGlkZGVuRW50cmllczogU2VnRW50cnlbXSk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuYWxsb3dSZXNsaWNpbmcgJiYgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwbGl0RW50cnkoZW50cnksIGluc2VydGlvbi50b3VjaGluZ0VudHJ5LCBoaWRkZW5FbnRyaWVzKVxuICAgIH1cblxuICAgIGhpZGRlbkVudHJpZXMucHVzaChlbnRyeSlcbiAgICByZXR1cm4gMFxuICB9XG5cbiAgc3BsaXRFbnRyeShlbnRyeTogU2VnRW50cnksIGJhcnJpZXI6IFNlZ0VudHJ5LCBoaWRkZW5FbnRyaWVzOiBTZWdFbnRyeVtdKTogbnVtYmVyIHtcbiAgICBsZXQgcGFydENudCA9IDBcbiAgICBsZXQgc3BsaXRIaWRkZW5FbnRyaWVzOiBTZWdFbnRyeVtdID0gW11cbiAgICBsZXQgZW50cnlTcGFuID0gZW50cnkuc3BhblxuICAgIGxldCBiYXJyaWVyU3BhbiA9IGJhcnJpZXIuc3BhblxuXG4gICAgaWYgKGVudHJ5U3Bhbi5zdGFydCA8IGJhcnJpZXJTcGFuLnN0YXJ0KSB7XG4gICAgICBwYXJ0Q250ICs9IHRoaXMuaW5zZXJ0RW50cnkoe1xuICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxuICAgICAgICBzcGFuOiB7IHN0YXJ0OiBlbnRyeVNwYW4uc3RhcnQsIGVuZDogYmFycmllclNwYW4uc3RhcnQgfSxcbiAgICAgIH0sIHNwbGl0SGlkZGVuRW50cmllcylcbiAgICB9XG5cbiAgICBpZiAoZW50cnlTcGFuLmVuZCA+IGJhcnJpZXJTcGFuLmVuZCkge1xuICAgICAgcGFydENudCArPSB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcbiAgICAgICAgc3BhbjogeyBzdGFydDogYmFycmllclNwYW4uZW5kLCBlbmQ6IGVudHJ5U3Bhbi5lbmQgfSxcbiAgICAgIH0sIHNwbGl0SGlkZGVuRW50cmllcylcbiAgICB9XG5cbiAgICBpZiAocGFydENudCkge1xuICAgICAgaGlkZGVuRW50cmllcy5wdXNoKHtcbiAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcbiAgICAgICAgc3BhbjogaW50ZXJzZWN0U3BhbnMoYmFycmllclNwYW4sIGVudHJ5U3BhbiksIC8vIGd1YXJhbnRlZWQgdG8gaW50ZXJzZWN0XG4gICAgICB9LCAuLi5zcGxpdEhpZGRlbkVudHJpZXMpXG4gICAgICByZXR1cm4gcGFydENudFxuICAgIH1cblxuICAgIGhpZGRlbkVudHJpZXMucHVzaChlbnRyeSlcbiAgICByZXR1cm4gMFxuICB9XG5cbiAgaW5zZXJ0RW50cnlBdChlbnRyeTogU2VnRW50cnksIGluc2VydGlvbjogU2VnSW5zZXJ0aW9uKTogdm9pZCB7XG4gICAgbGV0IHsgZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzIH0gPSB0aGlzXG5cbiAgICBpZiAoaW5zZXJ0aW9uLmxhdGVyYWwgPT09IC0xKSB7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgbGV2ZWxcbiAgICAgIGluc2VydEF0KGxldmVsQ29vcmRzLCBpbnNlcnRpb24ubGV2ZWwsIGluc2VydGlvbi5sZXZlbENvb3JkKVxuICAgICAgaW5zZXJ0QXQoZW50cmllc0J5TGV2ZWwsIGluc2VydGlvbi5sZXZlbCwgW2VudHJ5XSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5zZXJ0IGludG8gZXhpc3RpbmcgbGV2ZWxcbiAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsW2luc2VydGlvbi5sZXZlbF0sIGluc2VydGlvbi5sYXRlcmFsLCBlbnRyeSlcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrQ250c1tidWlsZEVudHJ5S2V5KGVudHJ5KV0gPSBpbnNlcnRpb24uc3RhY2tDbnRcbiAgfVxuXG4gIGZpbmRJbnNlcnRpb24obmV3RW50cnk6IFNlZ0VudHJ5KTogU2VnSW5zZXJ0aW9uIHtcbiAgICBsZXQgeyBsZXZlbENvb3JkcywgZW50cmllc0J5TGV2ZWwsIHN0cmljdE9yZGVyLCBzdGFja0NudHMgfSA9IHRoaXNcbiAgICBsZXQgbGV2ZWxDbnQgPSBsZXZlbENvb3Jkcy5sZW5ndGhcbiAgICBsZXQgY2FuZGlkYXRlQ29vcmQgPSAwXG4gICAgbGV0IHRvdWNoaW5nTGV2ZWw6IG51bWJlciA9IC0xXG4gICAgbGV0IHRvdWNoaW5nTGF0ZXJhbDogbnVtYmVyID0gLTFcbiAgICBsZXQgdG91Y2hpbmdFbnRyeTogU2VnRW50cnkgPSBudWxsXG4gICAgbGV0IHN0YWNrQ250ID0gMFxuXG4gICAgZm9yIChsZXQgdHJhY2tpbmdMZXZlbCA9IDA7IHRyYWNraW5nTGV2ZWwgPCBsZXZlbENudDsgdHJhY2tpbmdMZXZlbCArPSAxKSB7XG4gICAgICBsZXQgdHJhY2tpbmdDb29yZCA9IGxldmVsQ29vcmRzW3RyYWNraW5nTGV2ZWxdXG5cbiAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIHBhc3QgdGhlIHBsYWNlZCBlbnRyeSwgd2UgaGF2ZSBmb3VuZCBhIGdvb2QgZW1wdHkgc3BhY2UgYW5kIGNhbiBzdG9wLlxuICAgICAgLy8gaWYgc3RyaWN0T3JkZXIsIGtlZXAgZmluZGluZyBtb3JlIGxhdGVyYWwgaW50ZXJzZWN0aW9ucy5cbiAgICAgIGlmICghc3RyaWN0T3JkZXIgJiYgdHJhY2tpbmdDb29yZCA+PSBjYW5kaWRhdGVDb29yZCArIG5ld0VudHJ5LnRoaWNrbmVzcykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBsZXQgdHJhY2tpbmdFbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbdHJhY2tpbmdMZXZlbF1cbiAgICAgIGxldCB0cmFja2luZ0VudHJ5OiBTZWdFbnRyeVxuICAgICAgbGV0IHNlYXJjaFJlcyA9IGJpbmFyeVNlYXJjaCh0cmFja2luZ0VudHJpZXMsIG5ld0VudHJ5LnNwYW4uc3RhcnQsIGdldEVudHJ5U3BhbkVuZCkgLy8gZmluZCBmaXJzdCBlbnRyeSBhZnRlciBuZXdFbnRyeSdzIGVuZFxuICAgICAgbGV0IGxhdGVyYWxJbmRleCA9IHNlYXJjaFJlc1swXSArIHNlYXJjaFJlc1sxXSAvLyBpZiBleGFjdCBtYXRjaCAod2hpY2ggZG9lc24ndCBjb2xsaWRlKSwgZ28gdG8gbmV4dCBvbmVcblxuICAgICAgd2hpbGUgKCAvLyBsb29wIHRocm91Z2ggZW50cmllcyB0aGF0IGhvcml6b250YWxseSBpbnRlcnNlY3RcbiAgICAgICAgKHRyYWNraW5nRW50cnkgPSB0cmFja2luZ0VudHJpZXNbbGF0ZXJhbEluZGV4XSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBlbnRyeSBsaXN0XG4gICAgICAgIHRyYWNraW5nRW50cnkuc3Bhbi5zdGFydCA8IG5ld0VudHJ5LnNwYW4uZW5kIC8vIGFuZCBub3QgZW50aXJlbHkgcGFzdCBuZXdFbnRyeVxuICAgICAgKSB7XG4gICAgICAgIGxldCB0cmFja2luZ0VudHJ5Qm90dG9tID0gdHJhY2tpbmdDb29yZCArIHRyYWNraW5nRW50cnkudGhpY2tuZXNzXG4gICAgICAgIC8vIGludGVyc2VjdHMgaW50byB0aGUgdG9wIG9mIHRoZSBjYW5kaWRhdGU/XG4gICAgICAgIGlmICh0cmFja2luZ0VudHJ5Qm90dG9tID4gY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICBjYW5kaWRhdGVDb29yZCA9IHRyYWNraW5nRW50cnlCb3R0b21cbiAgICAgICAgICB0b3VjaGluZ0VudHJ5ID0gdHJhY2tpbmdFbnRyeVxuICAgICAgICAgIHRvdWNoaW5nTGV2ZWwgPSB0cmFja2luZ0xldmVsXG4gICAgICAgICAgdG91Y2hpbmdMYXRlcmFsID0gbGF0ZXJhbEluZGV4XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnV0dHMgdXAgYWdhaW5zdCB0b3Agb2YgY2FuZGlkYXRlPyAod2lsbCBoYXBwZW4gaWYganVzdCBpbnRlcnNlY3RlZCBhcyB3ZWxsKVxuICAgICAgICBpZiAodHJhY2tpbmdFbnRyeUJvdHRvbSA9PT0gY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICAvLyBhY2N1bXVsYXRlIHRoZSBoaWdoZXN0IHBvc3NpYmxlIHN0YWNrQ250IG9mIHRoZSB0cmFja2luZ0VudHJpZXMgdGhhdCBidXR0IHVwXG4gICAgICAgICAgc3RhY2tDbnQgPSBNYXRoLm1heChzdGFja0NudCwgc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkodHJhY2tpbmdFbnRyeSldICsgMSlcbiAgICAgICAgfVxuICAgICAgICBsYXRlcmFsSW5kZXggKz0gMVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBsZXZlbCB3aWxsIGJlIGFmdGVyIHRvdWNoaW5nRW50cnkncyBsZXZlbC4gZmluZCBpdFxuICAgIGxldCBkZXN0TGV2ZWwgPSAwXG4gICAgaWYgKHRvdWNoaW5nRW50cnkpIHtcbiAgICAgIGRlc3RMZXZlbCA9IHRvdWNoaW5nTGV2ZWwgKyAxXG4gICAgICB3aGlsZSAoZGVzdExldmVsIDwgbGV2ZWxDbnQgJiYgbGV2ZWxDb29yZHNbZGVzdExldmVsXSA8IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgIGRlc3RMZXZlbCArPSAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgYWRkaW5nIHRvIGFuIGV4aXN0aW5nIGxldmVsLCBmaW5kIHdoZXJlIHRvIGluc2VydFxuICAgIGxldCBkZXN0TGF0ZXJhbCA9IC0xXG4gICAgaWYgKGRlc3RMZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2Rlc3RMZXZlbF0gPT09IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICBkZXN0TGF0ZXJhbCA9IGJpbmFyeVNlYXJjaChlbnRyaWVzQnlMZXZlbFtkZXN0TGV2ZWxdLCBuZXdFbnRyeS5zcGFuLmVuZCwgZ2V0RW50cnlTcGFuRW5kKVswXVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0b3VjaGluZ0xldmVsLFxuICAgICAgdG91Y2hpbmdMYXRlcmFsLFxuICAgICAgdG91Y2hpbmdFbnRyeSxcbiAgICAgIHN0YWNrQ250LFxuICAgICAgbGV2ZWxDb29yZDogY2FuZGlkYXRlQ29vcmQsXG4gICAgICBsZXZlbDogZGVzdExldmVsLFxuICAgICAgbGF0ZXJhbDogZGVzdExhdGVyYWwsXG4gICAgfVxuICB9XG5cbiAgLy8gc29ydGVkIGJ5IGxldmVsQ29vcmQgKGxvd2VzdCB0byBoaWdoZXN0KVxuICB0b1JlY3RzKCk6IFNlZ1JlY3RbXSB7XG4gICAgbGV0IHsgZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzIH0gPSB0aGlzXG4gICAgbGV0IGxldmVsQ250ID0gZW50cmllc0J5TGV2ZWwubGVuZ3RoXG4gICAgbGV0IHJlY3RzOiBTZWdSZWN0W10gPSBbXVxuXG4gICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IGxldmVsQ250OyBsZXZlbCArPSAxKSB7XG4gICAgICBsZXQgZW50cmllcyA9IGVudHJpZXNCeUxldmVsW2xldmVsXVxuICAgICAgbGV0IGxldmVsQ29vcmQgPSBsZXZlbENvb3Jkc1tsZXZlbF1cblxuICAgICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICByZWN0cy5wdXNoKHsgLi4uZW50cnksIGxldmVsQ29vcmQgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdHNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW50cnlTcGFuRW5kKGVudHJ5OiBTZWdFbnRyeSkge1xuICByZXR1cm4gZW50cnkuc3Bhbi5lbmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRW50cnlLZXkoZW50cnk6IFNlZ0VudHJ5KSB7IC8vIFRPRE86IHVzZSBNYXAgaW5zdGVhZD9cbiAgcmV0dXJuIGVudHJ5LmluZGV4ICsgJzonICsgZW50cnkuc3Bhbi5zdGFydFxufVxuXG4vLyByZXR1cm5zIGdyb3VwcyB3aXRoIGVudHJpZXMgc29ydGVkIGJ5IGlucHV0IG9yZGVyXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzKGVudHJpZXM6IFNlZ0VudHJ5W10pOiBTZWdFbnRyeUdyb3VwW10ge1xuICBsZXQgbWVyZ2VzOiBTZWdFbnRyeUdyb3VwW10gPSBbXVxuXG4gIGZvciAobGV0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBsZXQgZmlsdGVyZWRNZXJnZXM6IFNlZ0VudHJ5R3JvdXBbXSA9IFtdXG4gICAgbGV0IGh1bmdyeU1lcmdlOiBTZWdFbnRyeUdyb3VwID0geyAvLyB0aGUgbWVyZ2UgdGhhdCB3aWxsIGVhdCB3aGF0IGl0IGNvbGxpZGVzIHdpdGhcbiAgICAgIHNwYW46IGVudHJ5LnNwYW4sXG4gICAgICBlbnRyaWVzOiBbZW50cnldLFxuICAgIH1cblxuICAgIGZvciAobGV0IG1lcmdlIG9mIG1lcmdlcykge1xuICAgICAgaWYgKGludGVyc2VjdFNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pKSB7XG4gICAgICAgIGh1bmdyeU1lcmdlID0ge1xuICAgICAgICAgIGVudHJpZXM6IG1lcmdlLmVudHJpZXMuY29uY2F0KGh1bmdyeU1lcmdlLmVudHJpZXMpLCAvLyBrZWVwIHByZWV4aXN0aW5nIG1lcmdlJ3MgaXRlbXMgZmlyc3QuIG1haW50YWlucyBvcmRlclxuICAgICAgICAgIHNwYW46IGpvaW5TcGFucyhtZXJnZS5zcGFuLCBodW5ncnlNZXJnZS5zcGFuKSxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsdGVyZWRNZXJnZXMucHVzaChtZXJnZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKGh1bmdyeU1lcmdlKVxuICAgIG1lcmdlcyA9IGZpbHRlcmVkTWVyZ2VzXG4gIH1cblxuICByZXR1cm4gbWVyZ2VzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBqb2luU3BhbnMoc3BhbjA6IFNlZ1NwYW4sIHNwYW4xOiBTZWdTcGFuKTogU2VnU3BhbiB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IE1hdGgubWluKHNwYW4wLnN0YXJ0LCBzcGFuMS5zdGFydCksXG4gICAgZW5kOiBNYXRoLm1heChzcGFuMC5lbmQsIHNwYW4xLmVuZCksXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdFNwYW5zKHNwYW4wOiBTZWdTcGFuLCBzcGFuMTogU2VnU3Bhbik6IFNlZ1NwYW4gfCBudWxsIHtcbiAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoc3BhbjAuc3RhcnQsIHNwYW4xLnN0YXJ0KVxuICBsZXQgZW5kID0gTWF0aC5taW4oc3BhbjAuZW5kLCBzcGFuMS5lbmQpXG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG4vLyBnZW5lcmFsIHV0aWxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBpbnNlcnRBdDxJdGVtPihhcnI6IEl0ZW1bXSwgaW5kZXg6IG51bWJlciwgaXRlbTogSXRlbSkge1xuICBhcnIuc3BsaWNlKGluZGV4LCAwLCBpdGVtKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoPEl0ZW0+KFxuICBhOiBJdGVtW10sXG4gIHNlYXJjaFZhbDogbnVtYmVyLFxuICBnZXRJdGVtVmFsOiAoaXRlbTogSXRlbSkgPT4gbnVtYmVyLFxuKTogW251bWJlciwgbnVtYmVyXSB7IC8vIHJldHVybnMgW2xldmVsLCBpc0V4YWN0TWF0Y2ggPyAxIDogMF1cbiAgbGV0IHN0YXJ0SW5kZXggPSAwXG4gIGxldCBlbmRJbmRleCA9IGEubGVuZ3RoIC8vIGV4Y2x1c2l2ZVxuXG4gIGlmICghZW5kSW5kZXggfHwgc2VhcmNoVmFsIDwgZ2V0SXRlbVZhbChhW3N0YXJ0SW5kZXhdKSkgeyAvLyBubyBpdGVtcyBPUiBiZWZvcmUgZmlyc3QgaXRlbVxuICAgIHJldHVybiBbMCwgMF1cbiAgfVxuICBpZiAoc2VhcmNoVmFsID4gZ2V0SXRlbVZhbChhW2VuZEluZGV4IC0gMV0pKSB7IC8vIGFmdGVyIGxhc3QgaXRlbVxuICAgIHJldHVybiBbZW5kSW5kZXgsIDBdXG4gIH1cblxuICB3aGlsZSAoc3RhcnRJbmRleCA8IGVuZEluZGV4KSB7XG4gICAgbGV0IG1pZGRsZUluZGV4ID0gTWF0aC5mbG9vcihzdGFydEluZGV4ICsgKGVuZEluZGV4IC0gc3RhcnRJbmRleCkgLyAyKVxuICAgIGxldCBtaWRkbGVWYWwgPSBnZXRJdGVtVmFsKGFbbWlkZGxlSW5kZXhdKVxuXG4gICAgaWYgKHNlYXJjaFZhbCA8IG1pZGRsZVZhbCkge1xuICAgICAgZW5kSW5kZXggPSBtaWRkbGVJbmRleFxuICAgIH0gZWxzZSBpZiAoc2VhcmNoVmFsID4gbWlkZGxlVmFsKSB7XG4gICAgICBzdGFydEluZGV4ID0gbWlkZGxlSW5kZXggKyAxXG4gICAgfSBlbHNlIHsgLy8gZXF1YWwhXG4gICAgICByZXR1cm4gW21pZGRsZUluZGV4LCAxXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbc3RhcnRJbmRleCwgMF1cbn1cbiIsImltcG9ydCB7IERhdGVDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnQvRGF0ZUNvbXBvbmVudCdcbmltcG9ydCB7IEhpdCB9IGZyb20gJy4vaGl0J1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW50ZXJhY3Rpb24ge1xuICBjb21wb25lbnQ6IERhdGVDb21wb25lbnQ8YW55PlxuICBpc0hpdENvbWJvQWxsb3dlZDogKChoaXQwOiBIaXQsIGhpdDE6IEhpdCkgPT4gYm9vbGVhbikgfCBudWxsXG5cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IEludGVyYWN0aW9uU2V0dGluZ3MpIHtcbiAgICB0aGlzLmNvbXBvbmVudCA9IHNldHRpbmdzLmNvbXBvbmVudFxuICAgIHRoaXMuaXNIaXRDb21ib0FsbG93ZWQgPSBzZXR0aW5ncy5pc0hpdENvbWJvQWxsb3dlZCB8fCBudWxsXG4gIH1cblxuICBkZXN0cm95KCkge1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEludGVyYWN0aW9uQ2xhc3MgPSB7IG5ldyhzZXR0aW5nczogSW50ZXJhY3Rpb25TZXR0aW5ncyk6IEludGVyYWN0aW9uIH1cblxuZXhwb3J0IGludGVyZmFjZSBJbnRlcmFjdGlvblNldHRpbmdzSW5wdXQge1xuICBlbDogSFRNTEVsZW1lbnRcbiAgdXNlRXZlbnRDZW50ZXI/OiBib29sZWFuXG4gIGlzSGl0Q29tYm9BbGxvd2VkPzogKGhpdDA6IEhpdCwgaGl0MTogSGl0KSA9PiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW50ZXJhY3Rpb25TZXR0aW5ncyB7XG4gIGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+XG4gIGVsOiBIVE1MRWxlbWVudFxuICB1c2VFdmVudENlbnRlcjogYm9vbGVhblxuICBpc0hpdENvbWJvQWxsb3dlZDogKChoaXQwOiBIaXQsIGhpdDE6IEhpdCkgPT4gYm9vbGVhbikgfCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIEludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSA9IHsgW2NvbXBvbmVuVWlkOiBzdHJpbmddOiBJbnRlcmFjdGlvblNldHRpbmdzIH1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyhjb21wb25lbnQ6IERhdGVDb21wb25lbnQ8YW55PiwgaW5wdXQ6IEludGVyYWN0aW9uU2V0dGluZ3NJbnB1dCk6IEludGVyYWN0aW9uU2V0dGluZ3Mge1xuICByZXR1cm4ge1xuICAgIGNvbXBvbmVudCxcbiAgICBlbDogaW5wdXQuZWwsXG4gICAgdXNlRXZlbnRDZW50ZXI6IGlucHV0LnVzZUV2ZW50Q2VudGVyICE9IG51bGwgPyBpbnB1dC51c2VFdmVudENlbnRlciA6IHRydWUsXG4gICAgaXNIaXRDb21ib0FsbG93ZWQ6IGlucHV0LmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGwsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzOiBJbnRlcmFjdGlvblNldHRpbmdzKSB7XG4gIHJldHVybiB7XG4gICAgW3NldHRpbmdzLmNvbXBvbmVudC51aWRdOiBzZXR0aW5ncyxcbiAgfVxufVxuXG4vLyBnbG9iYWwgc3RhdGVcbmV4cG9ydCBjb25zdCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmU6IEludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSA9IHt9XG4iLCJpbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi4vY29tbW9uL0VtaXR0ZXInXG5cbi8qXG5BbiBhYnN0cmFjdGlvbiBmb3IgYSBkcmFnZ2luZyBpbnRlcmFjdGlvbiBvcmlnaW5hdGluZyBvbiBhbiBldmVudC5cbkRvZXMgaGlnaGVyLWxldmVsIHRoaW5ncyB0aGFuIFBvaW50ZXJEcmFnZ2VyLCBzdWNoIGFzIHBvc3NpYmx5OlxuLSBhIFwibWlycm9yXCIgdGhhdCBtb3ZlcyB3aXRoIHRoZSBwb2ludGVyXG4tIGEgbWluaW11bSBudW1iZXIgb2YgcGl4ZWxzIG9yIG90aGVyIGNyaXRlcmlhIGZvciBhIHRydWUgZHJhZyB0byBiZWdpblxuXG5zdWJjbGFzc2VzIG11c3QgZW1pdDpcbi0gcG9pbnRlcmRvd25cbi0gZHJhZ3N0YXJ0XG4tIGRyYWdtb3ZlXG4tIHBvaW50ZXJ1cFxuLSBkcmFnZW5kXG4qL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEVsZW1lbnREcmFnZ2luZyB7IC8vIFRPRE86IHJlbmFtZSB0byAqSW50ZXJmYWNlP1xuICBlbWl0dGVyOiBFbWl0dGVyPGFueT5cblxuICBjb25zdHJ1Y3RvcihlbDogSFRNTEVsZW1lbnQsIHNlbGVjdG9yPzogc3RyaW5nKSB7XG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgfVxuXG4gIC8vIGlmIGdpdmVuIHRydWUsIHNob3VsZCBwcmV2ZW50IGRyYWdzdGFydCtkcmFnbW92ZStkcmFnZW5kIGZyb20gZmlyaW5nXG4gIGFic3RyYWN0IHNldElnbm9yZU1vdmUoYm9vbDogYm9vbGVhbik6IHZvaWRcblxuICBzZXRNaXJyb3JJc1Zpc2libGUoYm9vbDogYm9vbGVhbikge1xuICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXG4gIH1cblxuICBzZXRNaXJyb3JOZWVkc1JldmVydChib29sOiBib29sZWFuKSB7XG4gICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgfVxuXG4gIHNldEF1dG9TY3JvbGxFbmFibGVkKGJvb2w6IGJvb2xlYW4pIHtcbiAgICAvLyBvcHRpb25hbFxuICB9XG59XG5cbmV4cG9ydCB0eXBlIEVsZW1lbnREcmFnZ2luZ0NsYXNzID0geyBuZXcoZWw6IEhUTUxFbGVtZW50LCBzZWxlY3Rvcj86IHN0cmluZyk6IEVsZW1lbnREcmFnZ2luZyB9XG4iLCIvLyBUT0RPOiBnZXQgcmlkIG9mIHRoaXMgaW4gZmF2b3Igb2Ygb3B0aW9ucyBzeXN0ZW0sXG4vLyB0aG8gaXQncyByZWFsbHkgZWFzeSB0byBhY2Nlc3MgdGhpcyBnbG9iYWxseSByYXRoZXIgdGhhbiBwYXNzIHRocnUgb3B0aW9ucy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSB7fSBhcyBhbnlcbiIsImltcG9ydCB7IGNyZWF0ZUR1cmF0aW9uLCBEdXJhdGlvbiB9IGZyb20gJy4uL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyByZWZpbmVQcm9wcywgUmF3T3B0aW9uc0Zyb21SZWZpbmVycywgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5cbi8qXG5JbmZvcm1hdGlvbiBhYm91dCB3aGF0IHdpbGwgaGFwcGVuIHdoZW4gYW4gZXh0ZXJuYWwgZWxlbWVudCBpcyBkcmFnZ2VkLWFuZC1kcm9wcGVkXG5vbnRvIGEgY2FsZW5kYXIuIENvbnRhaW5zIGluZm9ybWF0aW9uIGZvciBjcmVhdGluZyBhbiBldmVudC5cbiovXG5cbmNvbnN0IERSQUdfTUVUQV9SRUZJTkVSUyA9IHtcbiAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICBjcmVhdGU6IEJvb2xlYW4sXG4gIHNvdXJjZUlkOiBTdHJpbmcsXG59XG5cbmV4cG9ydCB0eXBlIERyYWdNZXRhSW5wdXQgPVxuICBSYXdPcHRpb25zRnJvbVJlZmluZXJzPHR5cGVvZiBEUkFHX01FVEFfUkVGSU5FUlM+ICZcbiAgeyBbb3RoZXJQcm9wOiBzdHJpbmddOiBhbnkgfSAvLyBmb3IgbGVmdG92ZXJQcm9wc1xuXG5leHBvcnQgaW50ZXJmYWNlIERyYWdNZXRhIHtcbiAgc3RhcnRUaW1lOiBEdXJhdGlvbiB8IG51bGxcbiAgZHVyYXRpb246IER1cmF0aW9uIHwgbnVsbFxuICBjcmVhdGU6IGJvb2xlYW4gLy8gY3JlYXRlIGFuIGV2ZW50IHdoZW4gZHJvcHBlZD9cbiAgc291cmNlSWQ6IHN0cmluZyAvLyBzaW1pbGFyIHRvIGFkZEV2ZW50J3MgcGFyYW1ldGVyXG4gIGxlZnRvdmVyUHJvcHM6IERpY3Rpb25hcnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRHJhZ01ldGEocmF3OiBEcmFnTWV0YUlucHV0KTogRHJhZ01ldGEge1xuICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3LCBEUkFHX01FVEFfUkVGSU5FUlMpXG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFRpbWU6IHJlZmluZWQuc3RhcnRUaW1lIHx8IG51bGwsXG4gICAgZHVyYXRpb246IHJlZmluZWQuZHVyYXRpb24gfHwgbnVsbCxcbiAgICBjcmVhdGU6IHJlZmluZWQuY3JlYXRlICE9IG51bGwgPyByZWZpbmVkLmNyZWF0ZSA6IHRydWUsXG4gICAgc291cmNlSWQ6IHJlZmluZWQuc291cmNlSWQsXG4gICAgbGVmdG92ZXJQcm9wczogZXh0cmEsXG4gIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIFZOb2RlIH0gZnJvbSAnLi92ZG9tJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgVG9vbGJhcldpZGdldCB9IGZyb20gJy4vdG9vbGJhci1zdHJ1Y3QnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbGJhckNvbnRlbnQge1xuICB0aXRsZTogc3RyaW5nXG4gIGFjdGl2ZUJ1dHRvbjogc3RyaW5nXG4gIGlzVG9kYXlFbmFibGVkOiBib29sZWFuXG4gIGlzUHJldkVuYWJsZWQ6IGJvb2xlYW5cbiAgaXNOZXh0RW5hYmxlZDogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xiYXJTZWN0aW9uUHJvcHMgZXh0ZW5kcyBUb29sYmFyQ29udGVudCB7XG4gIHdpZGdldEdyb3VwczogVG9vbGJhcldpZGdldFtdW11cbn1cblxuZXhwb3J0IGNsYXNzIFRvb2xiYXJTZWN0aW9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxUb29sYmFyU2VjdGlvblByb3BzPiB7XG4gIHJlbmRlcigpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLnByb3BzLndpZGdldEdyb3Vwcy5tYXAoKHdpZGdldEdyb3VwKSA9PiB0aGlzLnJlbmRlcldpZGdldEdyb3VwKHdpZGdldEdyb3VwKSlcblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogJ2ZjLXRvb2xiYXItY2h1bmsnIH0sIC4uLmNoaWxkcmVuKVxuICB9XG5cbiAgcmVuZGVyV2lkZ2V0R3JvdXAod2lkZ2V0R3JvdXA6IFRvb2xiYXJXaWRnZXRbXSkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IHsgdGhlbWUgfSA9IHRoaXMuY29udGV4dFxuICAgIGxldCBjaGlsZHJlbjogVk5vZGVbXSA9IFtdXG4gICAgbGV0IGlzT25seUJ1dHRvbnMgPSB0cnVlXG5cbiAgICBmb3IgKGxldCB3aWRnZXQgb2Ygd2lkZ2V0R3JvdXApIHtcbiAgICAgIGxldCB7IGJ1dHRvbk5hbWUsIGJ1dHRvbkNsaWNrLCBidXR0b25UZXh0LCBidXR0b25JY29uIH0gPSB3aWRnZXRcblxuICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgaXNPbmx5QnV0dG9ucyA9IGZhbHNlXG4gICAgICAgIGNoaWxkcmVuLnB1c2goXG4gICAgICAgICAgPGgyIGNsYXNzTmFtZT1cImZjLXRvb2xiYXItdGl0bGVcIj57cHJvcHMudGl0bGV9PC9oMj4sXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBhcmlhQXR0cnMgPSBidXR0b25JY29uID8geyAnYXJpYS1sYWJlbCc6IGJ1dHRvbk5hbWUgfSA6IHt9XG5cbiAgICAgICAgbGV0IGJ1dHRvbkNsYXNzZXMgPSBbYGZjLSR7YnV0dG9uTmFtZX0tYnV0dG9uYCwgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbicpXVxuICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gcHJvcHMuYWN0aXZlQnV0dG9uKSB7XG4gICAgICAgICAgYnV0dG9uQ2xhc3Nlcy5wdXNoKHRoZW1lLmdldENsYXNzKCdidXR0b25BY3RpdmUnKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpc0Rpc2FibGVkID1cbiAgICAgICAgICAoIXByb3BzLmlzVG9kYXlFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICd0b2RheScpIHx8XG4gICAgICAgICAgKCFwcm9wcy5pc1ByZXZFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICdwcmV2JykgfHxcbiAgICAgICAgICAoIXByb3BzLmlzTmV4dEVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ25leHQnKVxuXG4gICAgICAgIGNoaWxkcmVuLnB1c2goXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgZGlzYWJsZWQ9e2lzRGlzYWJsZWR9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2J1dHRvbkNsYXNzZXMuam9pbignICcpfVxuICAgICAgICAgICAgb25DbGljaz17YnV0dG9uQ2xpY2t9XG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIHsuLi5hcmlhQXR0cnN9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2J1dHRvblRleHQgfHwgKGJ1dHRvbkljb24gPyA8c3BhbiBjbGFzc05hbWU9e2J1dHRvbkljb259IC8+IDogJycpfVxuICAgICAgICAgIDwvYnV0dG9uPixcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgZ3JvdXBDbGFzc05hbWUgPSAoaXNPbmx5QnV0dG9ucyAmJiB0aGVtZS5nZXRDbGFzcygnYnV0dG9uR3JvdXAnKSkgfHwgJydcblxuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiBncm91cENsYXNzTmFtZSB9LCAuLi5jaGlsZHJlbilcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuWzBdXG4gIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuL3Zkb20nXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBUb29sYmFyTW9kZWwsIFRvb2xiYXJXaWRnZXQgfSBmcm9tICcuL3Rvb2xiYXItc3RydWN0J1xuaW1wb3J0IHsgVG9vbGJhclNlY3Rpb24sIFRvb2xiYXJDb250ZW50IH0gZnJvbSAnLi9Ub29sYmFyU2VjdGlvbidcblxuZXhwb3J0IGludGVyZmFjZSBUb29sYmFyUHJvcHMgZXh0ZW5kcyBUb29sYmFyQ29udGVudCB7XG4gIGV4dHJhQ2xhc3NOYW1lOiBzdHJpbmcgLy8gd2lzaCB0aGlzIGNvdWxkIGJlIGFycmF5LCBidXQgZWFzaWVyIGZvciBwdXJlbmVzc1xuICBtb2RlbDogVG9vbGJhck1vZGVsXG59XG5cbmV4cG9ydCBjbGFzcyBUb29sYmFyIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxUb29sYmFyUHJvcHM+IHtcbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IG1vZGVsLCBleHRyYUNsYXNzTmFtZSB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCBmb3JjZUx0ciA9IGZhbHNlXG4gICAgbGV0IHN0YXJ0Q29udGVudFxuICAgIGxldCBlbmRDb250ZW50XG4gICAgbGV0IGNlbnRlckNvbnRlbnQgPSBtb2RlbC5jZW50ZXJcblxuICAgIGlmIChtb2RlbC5sZWZ0KSB7XG4gICAgICBmb3JjZUx0ciA9IHRydWVcbiAgICAgIHN0YXJ0Q29udGVudCA9IG1vZGVsLmxlZnRcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRDb250ZW50ID0gbW9kZWwuc3RhcnRcbiAgICB9XG5cbiAgICBpZiAobW9kZWwucmlnaHQpIHtcbiAgICAgIGZvcmNlTHRyID0gdHJ1ZVxuICAgICAgZW5kQ29udGVudCA9IG1vZGVsLnJpZ2h0XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZENvbnRlbnQgPSBtb2RlbC5lbmRcbiAgICB9XG5cbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgIGV4dHJhQ2xhc3NOYW1lIHx8ICcnLFxuICAgICAgJ2ZjLXRvb2xiYXInLFxuICAgICAgZm9yY2VMdHIgPyAnZmMtdG9vbGJhci1sdHInIDogJycsXG4gICAgXVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzLmpvaW4oJyAnKX0+XG4gICAgICAgIHt0aGlzLnJlbmRlclNlY3Rpb24oJ3N0YXJ0Jywgc3RhcnRDb250ZW50IHx8IFtdKX1cbiAgICAgICAge3RoaXMucmVuZGVyU2VjdGlvbignY2VudGVyJywgY2VudGVyQ29udGVudCB8fCBbXSl9XG4gICAgICAgIHt0aGlzLnJlbmRlclNlY3Rpb24oJ2VuZCcsIGVuZENvbnRlbnQgfHwgW10pfVxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyU2VjdGlvbihrZXk6IHN0cmluZywgd2lkZ2V0R3JvdXBzOiBUb29sYmFyV2lkZ2V0W11bXSkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFRvb2xiYXJTZWN0aW9uXG4gICAgICAgIGtleT17a2V5fVxuICAgICAgICB3aWRnZXRHcm91cHM9e3dpZGdldEdyb3Vwc31cbiAgICAgICAgdGl0bGU9e3Byb3BzLnRpdGxlfVxuICAgICAgICBhY3RpdmVCdXR0b249e3Byb3BzLmFjdGl2ZUJ1dHRvbn1cbiAgICAgICAgaXNUb2RheUVuYWJsZWQ9e3Byb3BzLmlzVG9kYXlFbmFibGVkfVxuICAgICAgICBpc1ByZXZFbmFibGVkPXtwcm9wcy5pc1ByZXZFbmFibGVkfVxuICAgICAgICBpc05leHRFbmFibGVkPXtwcm9wcy5pc05leHRFbmFibGVkfVxuICAgICAgLz5cbiAgICApXG4gIH1cbn1cbiIsImltcG9ydCB7IEJhc2VDb21wb25lbnQsIHNldFJlZiB9IGZyb20gJy4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIFJlZiwgY3JlYXRlRWxlbWVudCwgVlVJRXZlbnQgfSBmcm9tICcuL3Zkb20nXG5pbXBvcnQgeyBDc3NEaW1WYWx1ZSB9IGZyb20gJy4vc2Nyb2xsZ3JpZC91dGlsJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFZpZXdDb250YWluZXJQcm9wcyB7XG4gIGxpcXVpZD86IGJvb2xlYW5cbiAgaGVpZ2h0PzogQ3NzRGltVmFsdWVcbiAgYXNwZWN0UmF0aW8/OiBudW1iZXJcbiAgb25DbGljaz86IChldjogVlVJRXZlbnQpID0+IHZvaWRcbiAgZWxSZWY/OiBSZWY8SFRNTERpdkVsZW1lbnQ+XG4gIGNoaWxkcmVuPzogQ29tcG9uZW50Q2hpbGRyZW5cbn1cblxuaW50ZXJmYWNlIFZpZXdDb250YWluZXJTdGF0ZSB7XG4gIGF2YWlsYWJsZVdpZHRoOiBudW1iZXIgfCBudWxsXG59XG5cbi8vIFRPRE86IGRvIGZ1bmN0aW9uIGNvbXBvbmVudD9cbmV4cG9ydCBjbGFzcyBWaWV3Q29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxWaWV3Q29udGFpbmVyUHJvcHMsIFZpZXdDb250YWluZXJTdGF0ZT4ge1xuICBlbDogSFRNTEVsZW1lbnRcblxuICBzdGF0ZTogVmlld0NvbnRhaW5lclN0YXRlID0ge1xuICAgIGF2YWlsYWJsZVdpZHRoOiBudWxsLFxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGxldCB7IGFzcGVjdFJhdGlvIH0gPSBwcm9wc1xuXG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAnZmMtdmlldy1oYXJuZXNzJyxcbiAgICAgIChhc3BlY3RSYXRpbyB8fCBwcm9wcy5saXF1aWQgfHwgcHJvcHMuaGVpZ2h0KVxuICAgICAgICA/ICdmYy12aWV3LWhhcm5lc3MtYWN0aXZlJyAvLyBoYXJuZXNzIGNvbnRyb2xzIHRoZSBoZWlnaHRcbiAgICAgICAgOiAnZmMtdmlldy1oYXJuZXNzLXBhc3NpdmUnLCAvLyBsZXQgdGhlIHZpZXcgZG8gdGhlIGhlaWdodFxuICAgIF1cbiAgICBsZXQgaGVpZ2h0OiBDc3NEaW1WYWx1ZSA9ICcnXG4gICAgbGV0IHBhZGRpbmdCb3R0b206IENzc0RpbVZhbHVlID0gJydcblxuICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgaWYgKHN0YXRlLmF2YWlsYWJsZVdpZHRoICE9PSBudWxsKSB7XG4gICAgICAgIGhlaWdodCA9IHN0YXRlLmF2YWlsYWJsZVdpZHRoIC8gYXNwZWN0UmF0aW9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdoaWxlIHdhaXRpbmcgdG8ga25vdyBhdmFpbGFibGVXaWR0aCwgd2UgY2FuJ3Qgc2V0IGhlaWdodCB0byAqemVybypcbiAgICAgICAgLy8gYmVjYXVzZSB3aWxsIGNhdXNlIGxvdHMgb2YgdW5uZWNlc3Nhcnkgc2Nyb2xsYmFycyB3aXRoaW4gc2Nyb2xsZ3JpZC5cbiAgICAgICAgLy8gQkVUVEVSOiBkb24ndCBzdGFydCByZW5kZXJpbmcgQU5ZVEhJTkcgeWV0IHVudGlsIHdlIGtub3cgY29udGFpbmVyIHdpZHRoXG4gICAgICAgIC8vIE5PVEU6IHdoeSBub3QgYWx3YXlzIHVzZSBwYWRkaW5nQm90dG9tPyBDYXVzZXMgaGVpZ2h0IG9zY2lsbGF0aW9uIChpc3N1ZSA1NjA2KVxuICAgICAgICBwYWRkaW5nQm90dG9tID0gYCR7KDEgLyBhc3BlY3RSYXRpbykgKiAxMDB9JWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0IHx8ICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgcmVmPXt0aGlzLmhhbmRsZUVsfVxuICAgICAgICBvbkNsaWNrPXtwcm9wcy5vbkNsaWNrfVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMuam9pbignICcpfVxuICAgICAgICBzdHlsZT17eyBoZWlnaHQsIHBhZGRpbmdCb3R0b20gfX1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpXG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSlcbiAgfVxuXG4gIGhhbmRsZUVsID0gKGVsOiBIVE1MRWxlbWVudCB8IG51bGwpID0+IHtcbiAgICB0aGlzLmVsID0gZWxcbiAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpXG4gICAgdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpXG4gIH1cblxuICBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpXG4gIH1cblxuICB1cGRhdGVBdmFpbGFibGVXaWR0aCgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmVsICYmIC8vIG5lZWRlZC4gYnV0IHdoeT9cbiAgICAgIHRoaXMucHJvcHMuYXNwZWN0UmF0aW8gLy8gYXNwZWN0UmF0aW8gaXMgdGhlIG9ubHkgaGVpZ2h0IHNldHRpbmcgdGhhdCBuZWVkcyBhdmFpbGFibGVXaWR0aFxuICAgICkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGF2YWlsYWJsZVdpZHRoOiB0aGlzLmVsLm9mZnNldFdpZHRoIH0pXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBsaXN0ZW5CeVNlbGVjdG9yIH0gZnJvbSAnLi4vdXRpbC9kb20tZXZlbnQnXG5pbXBvcnQgeyBFdmVudEFwaSB9IGZyb20gJy4uL2FwaS9FdmVudEFwaSdcbmltcG9ydCB7IGVsZW1lbnRDbG9zZXN0IH0gZnJvbSAnLi4vdXRpbC9kb20tbWFuaXAnXG5pbXBvcnQgeyBnZXRFbFNlZyB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcnXG5pbXBvcnQgeyBJbnRlcmFjdGlvbiwgSW50ZXJhY3Rpb25TZXR0aW5ncyB9IGZyb20gJy4vaW50ZXJhY3Rpb24nXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi4vVmlld0FwaSdcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudENsaWNrQXJnIHtcbiAgZWw6IEhUTUxFbGVtZW50XG4gIGV2ZW50OiBFdmVudEFwaVxuICBqc0V2ZW50OiBNb3VzZUV2ZW50XG4gIHZpZXc6IFZpZXdBcGlcbn1cblxuLypcbkRldGVjdHMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gZXZlbnQgd2l0aGluIGEgRGF0ZUNvbXBvbmVudFxuKi9cbmV4cG9ydCBjbGFzcyBFdmVudENsaWNraW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5nczogSW50ZXJhY3Rpb25TZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKVxuXG4gICAgdGhpcy5kZXN0cm95ID0gbGlzdGVuQnlTZWxlY3RvcihcbiAgICAgIHNldHRpbmdzLmVsLFxuICAgICAgJ2NsaWNrJyxcbiAgICAgICcuZmMtZXZlbnQnLCAvLyBvbiBib3RoIGZnIGFuZCBiZyBldmVudHNcbiAgICAgIHRoaXMuaGFuZGxlU2VnQ2xpY2ssXG4gICAgKVxuICB9XG5cbiAgaGFuZGxlU2VnQ2xpY2sgPSAoZXY6IEV2ZW50LCBzZWdFbDogSFRNTEVsZW1lbnQpID0+IHtcbiAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXNcbiAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnRcbiAgICBsZXQgc2VnID0gZ2V0RWxTZWcoc2VnRWwpXG5cbiAgICBpZiAoXG4gICAgICBzZWcgJiYgLy8gbWlnaHQgYmUgdGhlIDxkaXY+IHN1cnJvdW5kaW5nIHRoZSBtb3JlIGxpbmtcbiAgICAgIGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2LnRhcmdldCBhcyBIVE1MRWxlbWVudClcbiAgICApIHtcbiAgICAgIC8vIG91ciB3YXkgdG8gc2ltdWxhdGUgYSBsaW5rIGNsaWNrIGZvciBlbGVtZW50cyB0aGF0IGNhbid0IGJlIDxhPiB0YWdzXG4gICAgICAvLyBncmFiIGJlZm9yZSB0cmlnZ2VyIGZpcmVkIGluIGNhc2UgdHJpZ2dlciB0cmFzaGVzIERPTSB0aHJ1IHJlcmVuZGVyaW5nXG4gICAgICBsZXQgaGFzVXJsQ29udGFpbmVyID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCAnLmZjLWV2ZW50LWZvcmNlZC11cmwnKVxuICAgICAgbGV0IHVybCA9IGhhc1VybENvbnRhaW5lciA/IChoYXNVcmxDb250YWluZXIucXVlcnlTZWxlY3RvcignYVtocmVmXScpIGFzIGFueSkuaHJlZiA6ICcnXG5cbiAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENsaWNrJywge1xuICAgICAgICBlbDogc2VnRWwsXG4gICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoXG4gICAgICAgICAgY29tcG9uZW50LmNvbnRleHQsXG4gICAgICAgICAgc2VnLmV2ZW50UmFuZ2UuZGVmLFxuICAgICAgICAgIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLFxuICAgICAgICApLFxuICAgICAgICBqc0V2ZW50OiBldiBhcyBNb3VzZUV2ZW50LCAvLyBJcyB0aGlzIGFsd2F5cyBhIG1vdXNlIGV2ZW50PyBTZWUgIzQ2NTVcbiAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgfSBhcyBFdmVudENsaWNrQXJnKVxuXG4gICAgICBpZiAodXJsICYmICFldi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciB9IGZyb20gJy4uL3V0aWwvZG9tLWV2ZW50J1xuaW1wb3J0IHsgRXZlbnRBcGkgfSBmcm9tICcuLi9hcGkvRXZlbnRBcGknXG5pbXBvcnQgeyBnZXRFbFNlZyB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcnXG5pbXBvcnQgeyBJbnRlcmFjdGlvbiwgSW50ZXJhY3Rpb25TZXR0aW5ncyB9IGZyb20gJy4vaW50ZXJhY3Rpb24nXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi4vVmlld0FwaSdcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudEhvdmVyaW5nQXJnIHtcbiAgZWw6IEhUTUxFbGVtZW50XG4gIGV2ZW50OiBFdmVudEFwaVxuICBqc0V2ZW50OiBNb3VzZUV2ZW50XG4gIHZpZXc6IFZpZXdBcGlcbn1cblxuLypcblRyaWdnZXJzIGV2ZW50cyBhbmQgYWRkcy9yZW1vdmVzIGNvcmUgY2xhc3NOYW1lcyB3aGVuIHRoZSB1c2VyJ3MgcG9pbnRlclxuZW50ZXJzL2xlYXZlcyBldmVudC1lbGVtZW50cyBvZiBhIGNvbXBvbmVudC5cbiovXG5leHBvcnQgY2xhc3MgRXZlbnRIb3ZlcmluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgcmVtb3ZlSG92ZXJMaXN0ZW5lcnM6ICgpID0+IHZvaWRcblxuICBjdXJyZW50U2VnRWw6IEhUTUxFbGVtZW50XG5cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IEludGVyYWN0aW9uU2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncylcblxuICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvcihcbiAgICAgIHNldHRpbmdzLmVsLFxuICAgICAgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgdGhpcy5oYW5kbGVTZWdFbnRlcixcbiAgICAgIHRoaXMuaGFuZGxlU2VnTGVhdmUsXG4gICAgKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZUhvdmVyTGlzdGVuZXJzKClcbiAgfVxuXG4gIC8vIGZvciBzaW11bGF0aW5nIGFuIGV2ZW50TW91c2VMZWF2ZSB3aGVuIHRoZSBldmVudCBlbCBpcyBkZXN0cm95ZWQgd2hpbGUgbW91c2UgaXMgb3ZlciBpdFxuICBoYW5kbGVFdmVudEVsUmVtb3ZlID0gKGVsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGlmIChlbCA9PT0gdGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2VnTGVhdmUobnVsbCwgdGhpcy5jdXJyZW50U2VnRWwpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU2VnRW50ZXIgPSAoZXY6IEV2ZW50LCBzZWdFbDogSFRNTEVsZW1lbnQpID0+IHtcbiAgICBpZiAoZ2V0RWxTZWcoc2VnRWwpKSB7IC8vIFRPRE86IGJldHRlciB3YXkgdG8gbWFrZSBzdXJlIG5vdCBob3ZlcmluZyBvdmVyIG1vcmUrIGxpbmsgb3IgaXRzIHdyYXBwZXJcbiAgICAgIHRoaXMuY3VycmVudFNlZ0VsID0gc2VnRWxcbiAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdldmVudE1vdXNlRW50ZXInLCBldiwgc2VnRWwpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU2VnTGVhdmUgPSAoZXY6IEV2ZW50IHwgbnVsbCwgc2VnRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNlZ0VsKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTZWdFbCA9IG51bGxcbiAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdldmVudE1vdXNlTGVhdmUnLCBldiwgc2VnRWwpXG4gICAgfVxuICB9XG5cbiAgdHJpZ2dlckV2ZW50KHB1YmxpY0V2TmFtZTogJ2V2ZW50TW91c2VFbnRlcicgfCAnZXZlbnRNb3VzZUxlYXZlJywgZXY6IEV2ZW50IHwgbnVsbCwgc2VnRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzXG4gICAgbGV0IHsgY29udGV4dCB9ID0gY29tcG9uZW50XG4gICAgbGV0IHNlZyA9IGdldEVsU2VnKHNlZ0VsKSFcblxuICAgIGlmICghZXYgfHwgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0IGFzIEhUTUxFbGVtZW50KSkge1xuICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIocHVibGljRXZOYW1lLCB7XG4gICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIHNlZy5ldmVudFJhbmdlLmRlZixcbiAgICAgICAgICBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSxcbiAgICAgICAgKSxcbiAgICAgICAganNFdmVudDogZXYgYXMgTW91c2VFdmVudCwgLy8gSXMgdGhpcyBhbHdheXMgYSBtb3VzZSBldmVudD8gU2VlICM0NjU1XG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgIH0gYXMgRXZlbnRIb3ZlcmluZ0FyZylcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInXG5pbXBvcnQgeyBWaWV3Q29udGV4dFR5cGUsIGJ1aWxkVmlld0NvbnRleHQgfSBmcm9tICcuL1ZpZXdDb250ZXh0J1xuaW1wb3J0IHsgVmlld1NwZWMgfSBmcm9tICcuL3N0cnVjdHMvdmlldy1zcGVjJ1xuaW1wb3J0IHsgVmlld1Byb3BzIH0gZnJvbSAnLi9WaWV3J1xuaW1wb3J0IHsgVG9vbGJhciB9IGZyb20gJy4vVG9vbGJhcidcbmltcG9ydCB7IERhdGVQcm9maWxlR2VuZXJhdG9yLCBEYXRlUHJvZmlsZSB9IGZyb20gJy4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyByYW5nZUNvbnRhaW5zTWFya2VyIH0gZnJvbSAnLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnLi91dGlsL21lbW9pemUnXG5pbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IENhbGVuZGFyRGF0YSB9IGZyb20gJy4vcmVkdWNlcnMvZGF0YS10eXBlcydcbmltcG9ydCB7IFZpZXdQcm9wc1RyYW5zZm9ybWVyQ2xhc3MgfSBmcm9tICcuL3BsdWdpbi1zeXN0ZW0tc3RydWN0J1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgY3JlYXRlUmVmLCBWVUlFdmVudCwgRnJhZ21lbnQsIFZOb2RlIH0gZnJvbSAnLi92ZG9tJ1xuaW1wb3J0IHsgYnVpbGREZWxlZ2F0aW9uSGFuZGxlciB9IGZyb20gJy4vdXRpbC9kb20tZXZlbnQnXG5pbXBvcnQgeyBWaWV3Q29udGFpbmVyIH0gZnJvbSAnLi9WaWV3Q29udGFpbmVyJ1xuaW1wb3J0IHtcbiAgSW50ZXJhY3Rpb24sXG4gIEludGVyYWN0aW9uU2V0dGluZ3NJbnB1dCxcbiAgSW50ZXJhY3Rpb25DbGFzcyxcbiAgcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzLFxuICBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsXG59IGZyb20gJy4vaW50ZXJhY3Rpb25zL2ludGVyYWN0aW9uJ1xuaW1wb3J0IHsgRGF0ZUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50L0RhdGVDb21wb25lbnQnXG5pbXBvcnQgeyBFdmVudENsaWNraW5nIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvRXZlbnRDbGlja2luZydcbmltcG9ydCB7IEV2ZW50SG92ZXJpbmcgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9FdmVudEhvdmVyaW5nJ1xuaW1wb3J0IHsgZ2V0Tm93IH0gZnJvbSAnLi9yZWR1Y2Vycy9jdXJyZW50LWRhdGUnXG5pbXBvcnQgeyBDYWxlbmRhckludGVyYWN0aW9uIH0gZnJvbSAnLi9jYWxlbmRhci11dGlscydcbmltcG9ydCB7IERlbGF5ZWRSdW5uZXIgfSBmcm9tICcuL3V0aWwvRGVsYXllZFJ1bm5lcidcbmltcG9ydCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICcuL3Zkb20tdXRpbCdcblxuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhckNvbnRlbnRQcm9wcyBleHRlbmRzIENhbGVuZGFyRGF0YSB7XG4gIGZvclByaW50OiBib29sZWFuXG4gIGlzSGVpZ2h0QXV0bzogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJDb250ZW50IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxDYWxlbmRhckNvbnRlbnRQcm9wcz4ge1xuICBwcml2YXRlIGJ1aWxkVmlld0NvbnRleHQgPSBtZW1vaXplKGJ1aWxkVmlld0NvbnRleHQpXG4gIHByaXZhdGUgYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyA9IG1lbW9pemUoYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycylcbiAgcHJpdmF0ZSBidWlsZFRvb2xiYXJQcm9wcyA9IG1lbW9pemUoYnVpbGRUb29sYmFyUHJvcHMpXG4gIHByaXZhdGUgaGFuZGxlTmF2TGlua0NsaWNrID0gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcignYVtkYXRhLW5hdmxpbmtdJywgdGhpcy5faGFuZGxlTmF2TGlua0NsaWNrLmJpbmQodGhpcykpXG4gIHByaXZhdGUgaGVhZGVyUmVmID0gY3JlYXRlUmVmPFRvb2xiYXI+KClcbiAgcHJpdmF0ZSBmb290ZXJSZWYgPSBjcmVhdGVSZWY8VG9vbGJhcj4oKVxuICBwcml2YXRlIGludGVyYWN0aW9uc1N0b3JlOiB7IFtjb21wb25lbnRVaWQ6IHN0cmluZ106IEludGVyYWN0aW9uW10gfSA9IHt9XG4gIHByaXZhdGUgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IENhbGVuZGFySW50ZXJhY3Rpb25bXVxuXG4gIC8qXG4gIHJlbmRlcnMgSU5TSURFIG9mIGFuIG91dGVyIGRpdlxuICAqL1xuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgeyB0b29sYmFyQ29uZmlnLCBvcHRpb25zIH0gPSBwcm9wc1xuXG4gICAgbGV0IHRvb2xiYXJQcm9wcyA9IHRoaXMuYnVpbGRUb29sYmFyUHJvcHMoXG4gICAgICBwcm9wcy52aWV3U3BlYyxcbiAgICAgIHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICBwcm9wcy5jdXJyZW50RGF0ZSxcbiAgICAgIGdldE5vdyhwcm9wcy5vcHRpb25zLm5vdywgcHJvcHMuZGF0ZUVudiksIC8vIFRPRE86IHVzZSBOb3dUaW1lcj8/Pz9cbiAgICAgIHByb3BzLnZpZXdUaXRsZSxcbiAgICApXG5cbiAgICBsZXQgdmlld1ZHcm93ID0gZmFsc2VcbiAgICBsZXQgdmlld0hlaWdodDogc3RyaW5nIHwgbnVtYmVyID0gJydcbiAgICBsZXQgdmlld0FzcGVjdFJhdGlvOiBudW1iZXIgfCB1bmRlZmluZWRcblxuICAgIGlmIChwcm9wcy5pc0hlaWdodEF1dG8gfHwgcHJvcHMuZm9yUHJpbnQpIHtcbiAgICAgIHZpZXdIZWlnaHQgPSAnJ1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgdmlld1ZHcm93ID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jb250ZW50SGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgIHZpZXdIZWlnaHQgPSBvcHRpb25zLmNvbnRlbnRIZWlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld0FzcGVjdFJhdGlvID0gTWF0aC5tYXgob3B0aW9ucy5hc3BlY3RSYXRpbywgMC41KSAvLyBwcmV2ZW50IGZyb20gZ2V0dGluZyB0b28gdGFsbFxuICAgIH1cblxuICAgIGxldCB2aWV3Q29udGV4dCA9IHRoaXMuYnVpbGRWaWV3Q29udGV4dChcbiAgICAgIHByb3BzLnZpZXdTcGVjLFxuICAgICAgcHJvcHMudmlld0FwaSxcbiAgICAgIHByb3BzLm9wdGlvbnMsXG4gICAgICBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgICAgIHByb3BzLmRhdGVFbnYsXG4gICAgICBwcm9wcy50aGVtZSxcbiAgICAgIHByb3BzLnBsdWdpbkhvb2tzLFxuICAgICAgcHJvcHMuZGlzcGF0Y2gsXG4gICAgICBwcm9wcy5nZXRDdXJyZW50RGF0YSxcbiAgICAgIHByb3BzLmVtaXR0ZXIsXG4gICAgICBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICAgIHRoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LFxuICAgIClcblxuICAgIHJldHVybiAoXG4gICAgICA8Vmlld0NvbnRleHRUeXBlLlByb3ZpZGVyIHZhbHVlPXt2aWV3Q29udGV4dH0+XG4gICAgICAgIHt0b29sYmFyQ29uZmlnLmhlYWRlclRvb2xiYXIgJiYgKFxuICAgICAgICAgIDxUb29sYmFyXG4gICAgICAgICAgICByZWY9e3RoaXMuaGVhZGVyUmVmfVxuICAgICAgICAgICAgZXh0cmFDbGFzc05hbWU9XCJmYy1oZWFkZXItdG9vbGJhclwiXG4gICAgICAgICAgICBtb2RlbD17dG9vbGJhckNvbmZpZy5oZWFkZXJUb29sYmFyfVxuICAgICAgICAgICAgey4uLnRvb2xiYXJQcm9wc31cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgICA8Vmlld0NvbnRhaW5lclxuICAgICAgICAgIGxpcXVpZD17dmlld1ZHcm93fVxuICAgICAgICAgIGhlaWdodD17dmlld0hlaWdodH1cbiAgICAgICAgICBhc3BlY3RSYXRpbz17dmlld0FzcGVjdFJhdGlvfVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlTmF2TGlua0NsaWNrfVxuICAgICAgICA+XG4gICAgICAgICAge3RoaXMucmVuZGVyVmlldyhwcm9wcyl9XG4gICAgICAgICAge3RoaXMuYnVpbGRBcHBlbmRDb250ZW50KCl9XG4gICAgICAgIDwvVmlld0NvbnRhaW5lcj5cbiAgICAgICAge3Rvb2xiYXJDb25maWcuZm9vdGVyVG9vbGJhciAmJiAoXG4gICAgICAgICAgPFRvb2xiYXJcbiAgICAgICAgICAgIHJlZj17dGhpcy5mb290ZXJSZWZ9XG4gICAgICAgICAgICBleHRyYUNsYXNzTmFtZT1cImZjLWZvb3Rlci10b29sYmFyXCJcbiAgICAgICAgICAgIG1vZGVsPXt0b29sYmFyQ29uZmlnLmZvb3RlclRvb2xiYXJ9XG4gICAgICAgICAgICB7Li4udG9vbGJhclByb3BzfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICA8L1ZpZXdDb250ZXh0VHlwZS5Qcm92aWRlcj5cbiAgICApXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuXG4gICAgdGhpcy5jYWxlbmRhckludGVyYWN0aW9ucyA9IHByb3BzLnBsdWdpbkhvb2tzLmNhbGVuZGFySW50ZXJhY3Rpb25zXG4gICAgICAubWFwKChDYWxlbmRhckludGVyYWN0aW9uQ2xhc3MpID0+IG5ldyBDYWxlbmRhckludGVyYWN0aW9uQ2xhc3MocHJvcHMpKVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlV2luZG93UmVzaXplKVxuXG4gICAgbGV0IHsgcHJvcFNldEhhbmRsZXJzIH0gPSBwcm9wcy5wbHVnaW5Ib29rc1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHByb3BTZXRIYW5kbGVycykge1xuICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IENhbGVuZGFyQ29udGVudFByb3BzKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcblxuICAgIGxldCB7IHByb3BTZXRIYW5kbGVycyB9ID0gcHJvcHMucGx1Z2luSG9va3NcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gIT09IHByZXZQcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSlcbiAgICB0aGlzLnJlc2l6ZVJ1bm5lci5jbGVhcigpXG5cbiAgICBmb3IgKGxldCBpbnRlcmFjdGlvbiBvZiB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zKSB7XG4gICAgICBpbnRlcmFjdGlvbi5kZXN0cm95KClcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3VubW91bnQnKVxuICB9XG5cbiAgX2hhbmRsZU5hdkxpbmtDbGljayhldjogVlVJRXZlbnQsIGFuY2hvckVsOiBIVE1MRWxlbWVudCkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSB0aGlzLnByb3BzXG5cbiAgICBsZXQgbmF2TGlua09wdGlvbnM6IGFueSA9IGFuY2hvckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1uYXZsaW5rJylcbiAgICBuYXZMaW5rT3B0aW9ucyA9IG5hdkxpbmtPcHRpb25zID8gSlNPTi5wYXJzZShuYXZMaW5rT3B0aW9ucykgOiB7fVxuXG4gICAgbGV0IGRhdGVNYXJrZXIgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihuYXZMaW5rT3B0aW9ucy5kYXRlKVxuICAgIGxldCB2aWV3VHlwZSA9IG5hdkxpbmtPcHRpb25zLnR5cGVcblxuICAgIGxldCBjdXN0b21BY3Rpb24gPVxuICAgICAgdmlld1R5cGUgPT09ICdkYXknID8gb3B0aW9ucy5uYXZMaW5rRGF5Q2xpY2sgOlxuICAgICAgICB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gb3B0aW9ucy5uYXZMaW5rV2Vla0NsaWNrIDogbnVsbFxuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1c3RvbUFjdGlvbi5jYWxsKGNhbGVuZGFyQXBpLCBkYXRlRW52LnRvRGF0ZShkYXRlTWFya2VyKSwgZXYpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvblxuICAgICAgfVxuXG4gICAgICBjYWxlbmRhckFwaS56b29tVG8oZGF0ZU1hcmtlciwgdmlld1R5cGUpXG4gICAgfVxuICB9XG5cbiAgYnVpbGRBcHBlbmRDb250ZW50KCk6IFZOb2RlIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuXG4gICAgbGV0IGNoaWxkcmVuID0gcHJvcHMucGx1Z2luSG9va3Mudmlld0NvbnRhaW5lckFwcGVuZHMubWFwKFxuICAgICAgKGJ1aWxkQXBwZW5kQ29udGVudCkgPT4gYnVpbGRBcHBlbmRDb250ZW50KHByb3BzKSxcbiAgICApXG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwge30sIC4uLmNoaWxkcmVuKVxuICB9XG5cbiAgcmVuZGVyVmlldyhwcm9wczogQ2FsZW5kYXJDb250ZW50UHJvcHMpIHtcbiAgICBsZXQgeyBwbHVnaW5Ib29rcyB9ID0gcHJvcHNcbiAgICBsZXQgeyB2aWV3U3BlYyB9ID0gcHJvcHNcblxuICAgIGxldCB2aWV3UHJvcHM6IFZpZXdQcm9wcyA9IHtcbiAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgIGJ1c2luZXNzSG91cnM6IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICBldmVudFN0b3JlOiBwcm9wcy5yZW5kZXJhYmxlRXZlbnRTdG9yZSwgLy8gIVxuICAgICAgZXZlbnRVaUJhc2VzOiBwcm9wcy5ldmVudFVpQmFzZXMsXG4gICAgICBkYXRlU2VsZWN0aW9uOiBwcm9wcy5kYXRlU2VsZWN0aW9uLFxuICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxuICAgICAgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsXG4gICAgICBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsXG4gICAgICBpc0hlaWdodEF1dG86IHByb3BzLmlzSGVpZ2h0QXV0byxcbiAgICAgIGZvclByaW50OiBwcm9wcy5mb3JQcmludCxcbiAgICB9XG5cbiAgICBsZXQgdHJhbnNmb3JtZXJzID0gdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHBsdWdpbkhvb2tzLnZpZXdQcm9wc1RyYW5zZm9ybWVycylcblxuICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgICAgX19hc3NpZ24oXG4gICAgICAgIHZpZXdQcm9wcyxcbiAgICAgICAgdHJhbnNmb3JtZXIudHJhbnNmb3JtKHZpZXdQcm9wcywgcHJvcHMpLFxuICAgICAgKVxuICAgIH1cblxuICAgIGxldCBWaWV3Q29tcG9uZW50ID0gdmlld1NwZWMuY29tcG9uZW50XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFZpZXdDb21wb25lbnQgey4uLnZpZXdQcm9wc30gLz5cbiAgICApXG4gIH1cblxuICAvLyBDb21wb25lbnQgUmVnaXN0cmF0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCA9IChjb21wb25lbnQ6IERhdGVDb21wb25lbnQ8YW55Piwgc2V0dGluZ3NJbnB1dDogSW50ZXJhY3Rpb25TZXR0aW5nc0lucHV0KSA9PiB7XG4gICAgbGV0IHNldHRpbmdzID0gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dClcbiAgICBsZXQgREVGQVVMVF9JTlRFUkFDVElPTlM6IEludGVyYWN0aW9uQ2xhc3NbXSA9IFtcbiAgICAgIEV2ZW50Q2xpY2tpbmcsXG4gICAgICBFdmVudEhvdmVyaW5nLFxuICAgIF1cbiAgICBsZXQgaW50ZXJhY3Rpb25DbGFzc2VzOiBJbnRlcmFjdGlvbkNsYXNzW10gPSBERUZBVUxUX0lOVEVSQUNUSU9OUy5jb25jYXQoXG4gICAgICB0aGlzLnByb3BzLnBsdWdpbkhvb2tzLmNvbXBvbmVudEludGVyYWN0aW9ucyxcbiAgICApXG4gICAgbGV0IGludGVyYWN0aW9ucyA9IGludGVyYWN0aW9uQ2xhc3Nlcy5tYXAoKFRoZUludGVyYWN0aW9uQ2xhc3MpID0+IG5ldyBUaGVJbnRlcmFjdGlvbkNsYXNzKHNldHRpbmdzKSlcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF0gPSBpbnRlcmFjdGlvbnNcbiAgICBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF0gPSBzZXR0aW5nc1xuICB9XG5cbiAgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gKGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+KSA9PiB7XG4gICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXSkge1xuICAgICAgbGlzdGVuZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF1cbiAgICBkZWxldGUgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlW2NvbXBvbmVudC51aWRdXG4gIH1cblxuICAvLyBSZXNpemluZ1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHJlc2l6ZVJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKCgpID0+IHtcbiAgICB0aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpIC8vIHNob3VsZCB3aW5kb3cgcmVzaXplcyBiZSBjb25zaWRlcmVkIFwiZm9yY2VkXCIgP1xuICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCd3aW5kb3dSZXNpemUnLCB7IHZpZXc6IHRoaXMucHJvcHMudmlld0FwaSB9KVxuICB9KVxuXG4gIGhhbmRsZVdpbmRvd1Jlc2l6ZSA9IChldjogVUlFdmVudCkgPT4ge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IHRoaXMucHJvcHNcblxuICAgIGlmIChcbiAgICAgIG9wdGlvbnMuaGFuZGxlV2luZG93UmVzaXplICYmXG4gICAgICBldi50YXJnZXQgPT09IHdpbmRvdyAvLyBhdm9pZCBqcXVpIGV2ZW50c1xuICAgICkge1xuICAgICAgdGhpcy5yZXNpemVSdW5uZXIucmVxdWVzdChvcHRpb25zLndpbmRvd1Jlc2l6ZURlbGF5KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFRvb2xiYXJQcm9wcyhcbiAgdmlld1NwZWM6IFZpZXdTcGVjLFxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsXG4gIGRhdGVQcm9maWxlR2VuZXJhdG9yOiBEYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgY3VycmVudERhdGU6IERhdGVNYXJrZXIsXG4gIG5vdzogRGF0ZU1hcmtlcixcbiAgdGl0bGU6IHN0cmluZyxcbikge1xuICAvLyBkb24ndCBmb3JjZSBhbnkgZGF0ZS1wcm9maWxlcyB0byB2YWxpZCBkYXRlIHByb2ZpbGVzICh0aGUgYGZhbHNlYCkgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBpdCdzIGludmFsaWRcbiAgbGV0IHRvZGF5SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKG5vdywgdW5kZWZpbmVkLCBmYWxzZSkgLy8gVE9ETzogbmVlZCBgdW5kZWZpbmVkYCBvciBlbHNlIElORklOSVRFIExPT1AgZm9yIHNvbWUgcmVhc29uXG4gIGxldCBwcmV2SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkUHJldihkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKVxuICBsZXQgbmV4dEluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQoZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmYWxzZSlcblxuICByZXR1cm4ge1xuICAgIHRpdGxlLFxuICAgIGFjdGl2ZUJ1dHRvbjogdmlld1NwZWMudHlwZSxcbiAgICBpc1RvZGF5RW5hYmxlZDogdG9kYXlJbmZvLmlzVmFsaWQgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBub3cpLFxuICAgIGlzUHJldkVuYWJsZWQ6IHByZXZJbmZvLmlzVmFsaWQsXG4gICAgaXNOZXh0RW5hYmxlZDogbmV4dEluZm8uaXNWYWxpZCxcbiAgfVxufVxuXG4vLyBQbHVnaW5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnModGhlQ2xhc3NlczogVmlld1Byb3BzVHJhbnNmb3JtZXJDbGFzc1tdKSB7XG4gIHJldHVybiB0aGVDbGFzc2VzLm1hcCgoVGhlQ2xhc3MpID0+IG5ldyBUaGVDbGFzcygpKVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4gfSBmcm9tICcuL3Zkb20nXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBDc3NEaW1WYWx1ZSB9IGZyb20gJy4vc2Nyb2xsZ3JpZC91dGlsJ1xuaW1wb3J0IHsgQ2FsZW5kYXJPcHRpb25zLCBDYWxlbmRhckxpc3RlbmVycyB9IGZyb20gJy4vb3B0aW9ucydcbmltcG9ydCB7IFRoZW1lIH0gZnJvbSAnLi90aGVtZS9UaGVtZSdcbmltcG9ydCB7IGdldENhblZHcm93V2l0aGluQ2VsbCB9IGZyb20gJy4vdXRpbC90YWJsZS1zdHlsaW5nJ1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4vY29tbW9uL0VtaXR0ZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsZW5kYXJSb290UHJvcHMge1xuICBvcHRpb25zOiBDYWxlbmRhck9wdGlvbnNcbiAgdGhlbWU6IFRoZW1lXG4gIGVtaXR0ZXI6IEVtaXR0ZXI8Q2FsZW5kYXJMaXN0ZW5lcnM+XG4gIGNoaWxkcmVuOiAoY2xhc3NOYW1lczogc3RyaW5nW10sIGhlaWdodDogQ3NzRGltVmFsdWUsIGlzSGVpZ2h0QXV0bzogYm9vbGVhbiwgZm9yUHJpbnQ6IGJvb2xlYW4pID0+IENvbXBvbmVudENoaWxkcmVuXG59XG5cbmludGVyZmFjZSBDYWxlbmRhclJvb3RTdGF0ZSB7XG4gIGZvclByaW50OiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBDYWxlbmRhclJvb3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PENhbGVuZGFyUm9vdFByb3BzLCBDYWxlbmRhclJvb3RTdGF0ZT4ge1xuICBzdGF0ZSA9IHtcbiAgICBmb3JQcmludDogZmFsc2UsXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBwcm9wc1xuICAgIGxldCB7IGZvclByaW50IH0gPSB0aGlzLnN0YXRlXG5cbiAgICBsZXQgaXNIZWlnaHRBdXRvID0gZm9yUHJpbnQgfHwgb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLmNvbnRlbnRIZWlnaHQgPT09ICdhdXRvJ1xuICAgIGxldCBoZWlnaHQgPSAoIWlzSGVpZ2h0QXV0byAmJiBvcHRpb25zLmhlaWdodCAhPSBudWxsKSA/IG9wdGlvbnMuaGVpZ2h0IDogJydcblxuICAgIGxldCBjbGFzc05hbWVzOiBzdHJpbmdbXSA9IFtcbiAgICAgICdmYycsXG4gICAgICBmb3JQcmludCA/ICdmYy1tZWRpYS1wcmludCcgOiAnZmMtbWVkaWEtc2NyZWVuJyxcbiAgICAgIGBmYy1kaXJlY3Rpb24tJHtvcHRpb25zLmRpcmVjdGlvbn1gLFxuICAgICAgcHJvcHMudGhlbWUuZ2V0Q2xhc3MoJ3Jvb3QnKSxcbiAgICBdXG5cbiAgICBpZiAoIWdldENhblZHcm93V2l0aGluQ2VsbCgpKSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWxpcXVpZC1oYWNrJylcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5wcm9wc1xuICAgIGVtaXR0ZXIub24oJ19iZWZvcmVwcmludCcsIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQpXG4gICAgZW1pdHRlci5vbignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpXG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBsZXQgeyBlbWl0dGVyIH0gPSB0aGlzLnByb3BzXG4gICAgZW1pdHRlci5vZmYoJ19iZWZvcmVwcmludCcsIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQpXG4gICAgZW1pdHRlci5vZmYoJ19hZnRlcnByaW50JywgdGhpcy5oYW5kbGVBZnRlclByaW50KVxuICB9XG5cbiAgaGFuZGxlQmVmb3JlUHJpbnQgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZvclByaW50OiB0cnVlIH0pXG4gIH1cblxuICBoYW5kbGVBZnRlclByaW50ID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogZmFsc2UgfSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi4vZGF0ZWxpYi9mb3JtYXR0aW5nJ1xuXG4vLyBDb21wdXRlcyBhIGRlZmF1bHQgY29sdW1uIGhlYWRlciBmb3JtYXR0aW5nIHN0cmluZyBpZiBgY29sRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0KGRhdGVzUmVwRGlzdGluY3REYXlzOiBib29sZWFuLCBkYXlDbnQ6IG51bWJlcikge1xuICAvLyBpZiBtb3JlIHRoYW4gb25lIHdlZWsgcm93LCBvciBpZiB0aGVyZSBhcmUgYSBsb3Qgb2YgY29sdW1ucyB3aXRoIG5vdCBtdWNoIHNwYWNlLFxuICAvLyBwdXQganVzdCB0aGUgZGF5IG51bWJlcnMgd2lsbCBiZSBpbiBlYWNoIGNlbGxcbiAgaWYgKCFkYXRlc1JlcERpc3RpbmN0RGF5cyB8fCBkYXlDbnQgPiAxMCkge1xuICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnc2hvcnQnIH0pIC8vIFwiU2F0XCJcbiAgfVxuXG4gIGlmIChkYXlDbnQgPiAxKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnbnVtZXJpYycsIGRheTogJ251bWVyaWMnLCBvbWl0Q29tbWFzOiB0cnVlIH0pIC8vIFwiU2F0IDExLzEyXCJcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnbG9uZycgfSkgLy8gXCJTYXR1cmRheVwiXG59XG4iLCJpbXBvcnQgeyBEYXlIZWFkZXJDb250ZW50QXJnIH0gZnJvbSAnLi4vcmVuZGVyLWhvb2stbWlzYydcblxuZXhwb3J0IGNvbnN0IENMQVNTX05BTUUgPSAnZmMtY29sLWhlYWRlci1jZWxsJyAvLyBkbyB0aGUgY3VzaGlvbiB0b28/IG5vXG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJJbm5lcihob29rUHJvcHM6IERheUhlYWRlckNvbnRlbnRBcmcpIHtcbiAgcmV0dXJuIGhvb2tQcm9wcy50ZXh0XG59XG4iLCJpbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBnZXREYXlDbGFzc05hbWVzLCBnZXREYXRlTWV0YSB9IGZyb20gJy4uL2NvbXBvbmVudC9kYXRlLXJlbmRlcmluZydcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciB9IGZyb20gJy4uL2RhdGVsaWIvRGF0ZUZvcm1hdHRlcidcbmltcG9ydCB7IGZvcm1hdERheVN0cmluZyB9IGZyb20gJy4uL2RhdGVsaWIvZm9ybWF0dGluZy11dGlscydcbmltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBSZW5kZXJIb29rIH0gZnJvbSAnLi9yZW5kZXItaG9vaydcbmltcG9ydCB7IGJ1aWxkTmF2TGlua0RhdGEgfSBmcm9tICcuL25hdi1saW5rJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGUgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IERheUhlYWRlckNvbnRlbnRBcmcgfSBmcm9tICcuLi9yZW5kZXItaG9vay1taXNjJ1xuaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5pbXBvcnQgeyBDTEFTU19OQU1FLCByZW5kZXJJbm5lciB9IGZyb20gJy4vdGFibGUtY2VsbC11dGlsJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlRGF0ZUNlbGxQcm9wcyB7XG4gIGRhdGU6IERhdGVNYXJrZXJcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlXG4gIHRvZGF5UmFuZ2U6IERhdGVSYW5nZVxuICBjb2xDbnQ6IG51bWJlclxuICBkYXlIZWFkZXJGb3JtYXQ6IERhdGVGb3JtYXR0ZXJcbiAgY29sU3Bhbj86IG51bWJlclxuICBpc1N0aWNreT86IGJvb2xlYW4gLy8gVE9ETzogZ2V0IHRoaXMgb3V0dGEgaGVyZSBzb21laG93XG4gIGV4dHJhRGF0YUF0dHJzPzogRGljdGlvbmFyeVxuICBleHRyYUhvb2tQcm9wcz86IERpY3Rpb25hcnlcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlRGF0ZUNlbGwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFRhYmxlRGF0ZUNlbGxQcm9wcz4geyAvLyBCQUQgbmFtZSBmb3IgdGhpcyBjbGFzcyBub3cuIHVzZWQgaW4gdGhlIEhlYWRlclxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucywgdGhlbWUsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dFxuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IHsgZGF0ZSwgZGF0ZVByb2ZpbGUgfSA9IHByb3BzXG4gICAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCBwcm9wcy50b2RheVJhbmdlLCBudWxsLCBkYXRlUHJvZmlsZSlcblxuICAgIGxldCBjbGFzc05hbWVzID0gW0NMQVNTX05BTUVdLmNvbmNhdChcbiAgICAgIGdldERheUNsYXNzTmFtZXMoZGF5TWV0YSwgdGhlbWUpLFxuICAgIClcbiAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIHByb3BzLmRheUhlYWRlckZvcm1hdClcblxuICAgIC8vIGlmIGNvbENudCBpcyAxLCB3ZSBhcmUgYWxyZWFkeSBpbiBhIGRheS12aWV3IGFuZCBkb24ndCBuZWVkIGEgbmF2bGlua1xuICAgIGxldCBuYXZMaW5rQXR0cnMgPSAob3B0aW9ucy5uYXZMaW5rcyAmJiAhZGF5TWV0YS5pc0Rpc2FibGVkICYmIHByb3BzLmNvbENudCA+IDEpXG4gICAgICA/IHsgJ2RhdGEtbmF2bGluayc6IGJ1aWxkTmF2TGlua0RhdGEoZGF0ZSksIHRhYkluZGV4OiAwIH1cbiAgICAgIDoge31cblxuICAgIGxldCBob29rUHJvcHM6IERheUhlYWRlckNvbnRlbnRBcmcgPSB7XG4gICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXRlKSxcbiAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAuLi5wcm9wcy5leHRyYUhvb2tQcm9wcyxcbiAgICAgIHRleHQsXG4gICAgICAuLi5kYXlNZXRhLFxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8UmVuZGVySG9va1xuICAgICAgICBob29rUHJvcHM9e2hvb2tQcm9wc31cbiAgICAgICAgY2xhc3NOYW1lcz17b3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzfVxuICAgICAgICBjb250ZW50PXtvcHRpb25zLmRheUhlYWRlckNvbnRlbnR9XG4gICAgICAgIGRlZmF1bHRDb250ZW50PXtyZW5kZXJJbm5lcn1cbiAgICAgICAgZGlkTW91bnQ9e29wdGlvbnMuZGF5SGVhZGVyRGlkTW91bnR9XG4gICAgICAgIHdpbGxVbm1vdW50PXtvcHRpb25zLmRheUhlYWRlcldpbGxVbm1vdW50fVxuICAgICAgPlxuICAgICAgICB7KHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSA9PiAoXG4gICAgICAgICAgPHRoXG4gICAgICAgICAgICByZWY9e3Jvb3RFbFJlZn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpfVxuICAgICAgICAgICAgZGF0YS1kYXRlPXshZGF5TWV0YS5pc0Rpc2FibGVkID8gZm9ybWF0RGF5U3RyaW5nKGRhdGUpIDogdW5kZWZpbmVkfVxuICAgICAgICAgICAgY29sU3Bhbj17cHJvcHMuY29sU3Bhbn1cbiAgICAgICAgICAgIHsuLi5wcm9wcy5leHRyYURhdGFBdHRyc31cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiPlxuICAgICAgICAgICAgICB7IWRheU1ldGEuaXNEaXNhYmxlZCAmJiAoXG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgIHJlZj17aW5uZXJFbFJlZn1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17W1xuICAgICAgICAgICAgICAgICAgICAnZmMtY29sLWhlYWRlci1jZWxsLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5pc1N0aWNreSA/ICdmYy1zdGlja3knIDogJycsXG4gICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKX1cbiAgICAgICAgICAgICAgICAgIHsuLi5uYXZMaW5rQXR0cnN9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L3RoPlxuICAgICAgICApfVxuICAgICAgPC9SZW5kZXJIb29rPlxuICAgIClcbiAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0RGF5Q2xhc3NOYW1lcywgRGF0ZU1ldGEgfSBmcm9tICcuLi9jb21wb25lbnQvZGF0ZS1yZW5kZXJpbmcnXG5pbXBvcnQgeyBhZGREYXlzIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IERhdGVGb3JtYXR0ZXIgfSBmcm9tICcuLi9kYXRlbGliL0RhdGVGb3JtYXR0ZXInXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgUmVuZGVySG9vayB9IGZyb20gJy4vcmVuZGVyLWhvb2snXG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcbmltcG9ydCB7IENMQVNTX05BTUUsIHJlbmRlcklubmVyIH0gZnJvbSAnLi90YWJsZS1jZWxsLXV0aWwnXG5pbXBvcnQgeyBEYXlIZWFkZXJDb250ZW50QXJnIH0gZnJvbSAnLi4vcmVuZGVyLWhvb2stbWlzYydcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZURvd0NlbGxQcm9wcyB7XG4gIGRvdzogbnVtYmVyXG4gIGRheUhlYWRlckZvcm1hdDogRGF0ZUZvcm1hdHRlclxuICBjb2xTcGFuPzogbnVtYmVyXG4gIGlzU3RpY2t5PzogYm9vbGVhbiAvLyBUT0RPOiBnZXQgdGhpcyBvdXR0YSBoZXJlIHNvbWVob3dcbiAgZXh0cmFIb29rUHJvcHM/OiBEaWN0aW9uYXJ5XG4gIGV4dHJhRGF0YUF0dHJzPzogRGljdGlvbmFyeVxuICBleHRyYUNsYXNzTmFtZXM/OiBzdHJpbmdbXVxufVxuXG5leHBvcnQgY2xhc3MgVGFibGVEb3dDZWxsIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxUYWJsZURvd0NlbGxQcm9wcz4ge1xuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgeyBkYXRlRW52LCB0aGVtZSwgdmlld0FwaSwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0XG4gICAgbGV0IGRhdGUgPSBhZGREYXlzKG5ldyBEYXRlKDI1OTIwMDAwMCksIHByb3BzLmRvdykgLy8gc3RhcnQgd2l0aCBTdW4sIDA0IEphbiAxOTcwIDAwOjAwOjAwIEdNVFxuICAgIGxldCBkYXRlTWV0YTogRGF0ZU1ldGEgPSB7XG4gICAgICBkb3c6IHByb3BzLmRvdyxcbiAgICAgIGlzRGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgaXNGdXR1cmU6IGZhbHNlLFxuICAgICAgaXNQYXN0OiBmYWxzZSxcbiAgICAgIGlzVG9kYXk6IGZhbHNlLFxuICAgICAgaXNPdGhlcjogZmFsc2UsXG4gICAgfVxuICAgIGxldCBjbGFzc05hbWVzID0gW0NMQVNTX05BTUVdLmNvbmNhdChcbiAgICAgIGdldERheUNsYXNzTmFtZXMoZGF0ZU1ldGEsIHRoZW1lKSxcbiAgICAgIHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSxcbiAgICApXG4gICAgbGV0IHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpXG4gICAgbGV0IGhvb2tQcm9wczogRGF5SGVhZGVyQ29udGVudEFyZyA9IHsgLy8gVE9ETzogbWFrZSB0aGlzIHB1YmxpYz9cbiAgICAgIGRhdGUsXG4gICAgICAuLi5kYXRlTWV0YSxcbiAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAuLi5wcm9wcy5leHRyYUhvb2tQcm9wcyxcbiAgICAgIHRleHQsXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxSZW5kZXJIb29rXG4gICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICBjbGFzc05hbWVzPXtvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXN9XG4gICAgICAgIGNvbnRlbnQ9e29wdGlvbnMuZGF5SGVhZGVyQ29udGVudH1cbiAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3JlbmRlcklubmVyfVxuICAgICAgICBkaWRNb3VudD17b3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudH1cbiAgICAgICAgd2lsbFVubW91bnQ9e29wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnR9XG4gICAgICA+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpID0+IChcbiAgICAgICAgICA8dGhcbiAgICAgICAgICAgIHJlZj17cm9vdEVsUmVmfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKS5qb2luKCcgJyl9XG4gICAgICAgICAgICBjb2xTcGFuPXtwcm9wcy5jb2xTcGFufVxuICAgICAgICAgICAgey4uLnByb3BzLmV4dHJhRGF0YUF0dHJzfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCI+XG4gICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtbXG4gICAgICAgICAgICAgICAgICAnZmMtY29sLWhlYWRlci1jZWxsLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgPyAnZmMtc3RpY2t5JyA6ICcnLFxuICAgICAgICAgICAgICAgIF0uam9pbignICcpfVxuICAgICAgICAgICAgICAgIHJlZj17aW5uZXJFbFJlZn1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtpbm5lckNvbnRlbnR9XG4gICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvdGg+XG4gICAgICAgICl9XG4gICAgICA8L1JlbmRlckhvb2s+XG4gICAgKVxuICB9XG59XG4iLCJpbXBvcnQgeyBEYXRlTWFya2VyLCBhZGRNcywgc3RhcnRPZkRheSwgYWRkRGF5cyB9IGZyb20gJy4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBjcmVhdGVEdXJhdGlvbiB9IGZyb20gJy4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IFZpZXdDb250ZXh0LCBWaWV3Q29udGV4dFR5cGUgfSBmcm9tICcuL1ZpZXdDb250ZXh0J1xuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIENvbXBvbmVudCB9IGZyb20gJy4vdmRvbSdcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgZ2V0Tm93IH0gZnJvbSAnLi9yZWR1Y2Vycy9jdXJyZW50LWRhdGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgTm93VGltZXJQcm9wcyB7XG4gIHVuaXQ6IHN0cmluZyAvLyBUT0RPOiBhZGQgdHlwZSBvZiB1bml0XG4gIGNoaWxkcmVuOiAobm93OiBEYXRlTWFya2VyLCB0b2RheVJhbmdlOiBEYXRlUmFuZ2UpID0+IENvbXBvbmVudENoaWxkcmVuXG59XG5cbmludGVyZmFjZSBOb3dUaW1lclN0YXRlIHtcbiAgbm93RGF0ZTogRGF0ZU1hcmtlclxuICB0b2RheVJhbmdlOiBEYXRlUmFuZ2Vcbn1cblxuZXhwb3J0IGNsYXNzIE5vd1RpbWVyIGV4dGVuZHMgQ29tcG9uZW50PE5vd1RpbWVyUHJvcHMsIE5vd1RpbWVyU3RhdGU+IHtcbiAgc3RhdGljIGNvbnRleHRUeXBlOiBhbnkgPSBWaWV3Q29udGV4dFR5cGVcbiAgY29udGV4dDogVmlld0NvbnRleHQgLy8gZG8gdGhpcyBmb3IgYWxsIGNvbXBvbmVudHMgdGhhdCB1c2UgdGhlIGNvbnRleHQhISFcbiAgaW5pdGlhbE5vd0RhdGU6IERhdGVNYXJrZXJcbiAgaW5pdGlhbE5vd1F1ZXJpZWRNczogbnVtYmVyXG4gIHRpbWVvdXRJZDogYW55XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IE5vd1RpbWVyUHJvcHMsIGNvbnRleHQ6IFZpZXdDb250ZXh0KSB7XG4gICAgc3VwZXIocHJvcHMsIGNvbnRleHQpXG5cbiAgICB0aGlzLmluaXRpYWxOb3dEYXRlID0gZ2V0Tm93KGNvbnRleHQub3B0aW9ucy5ub3csIGNvbnRleHQuZGF0ZUVudilcbiAgICB0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuY29tcHV0ZVRpbWluZygpLmN1cnJlbnRTdGF0ZVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpc1xuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbihzdGF0ZS5ub3dEYXRlLCBzdGF0ZS50b2RheVJhbmdlKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zZXRUaW1lb3V0KClcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IE5vd1RpbWVyUHJvcHMpIHtcbiAgICBpZiAocHJldlByb3BzLnVuaXQgIT09IHRoaXMucHJvcHMudW5pdCkge1xuICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKVxuICAgICAgdGhpcy5zZXRUaW1lb3V0KClcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmNsZWFyVGltZW91dCgpXG4gIH1cblxuICBwcml2YXRlIGNvbXB1dGVUaW1pbmcoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgdW5yb3VuZGVkTm93ID0gYWRkTXModGhpcy5pbml0aWFsTm93RGF0ZSwgbmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMpXG4gICAgbGV0IGN1cnJlbnRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuc3RhcnRPZih1bnJvdW5kZWROb3csIHByb3BzLnVuaXQpXG4gICAgbGV0IG5leHRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuYWRkKGN1cnJlbnRVbml0U3RhcnQsIGNyZWF0ZUR1cmF0aW9uKDEsIHByb3BzLnVuaXQpKVxuICAgIGxldCB3YWl0TXMgPSBuZXh0VW5pdFN0YXJ0LnZhbHVlT2YoKSAtIHVucm91bmRlZE5vdy52YWx1ZU9mKClcblxuICAgIC8vIHRoZXJlIGlzIGEgbWF4IHNldFRpbWVvdXQgbXMgdmFsdWUgKGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDY4NjUwLzk2MzQyKVxuICAgIC8vIGVuc3VyZSBubyBsb25nZXIgdGhhbiBhIGRheVxuICAgIHdhaXRNcyA9IE1hdGgubWluKDEwMDAgKiA2MCAqIDYwICogMjQsIHdhaXRNcylcblxuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50U3RhdGU6IHsgbm93RGF0ZTogY3VycmVudFVuaXRTdGFydCwgdG9kYXlSYW5nZTogYnVpbGREYXlSYW5nZShjdXJyZW50VW5pdFN0YXJ0KSB9IGFzIE5vd1RpbWVyU3RhdGUsXG4gICAgICBuZXh0U3RhdGU6IHsgbm93RGF0ZTogbmV4dFVuaXRTdGFydCwgdG9kYXlSYW5nZTogYnVpbGREYXlSYW5nZShuZXh0VW5pdFN0YXJ0KSB9IGFzIE5vd1RpbWVyU3RhdGUsXG4gICAgICB3YWl0TXMsXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRUaW1lb3V0KCkge1xuICAgIGxldCB7IG5leHRTdGF0ZSwgd2FpdE1zIH0gPSB0aGlzLmNvbXB1dGVUaW1pbmcoKVxuXG4gICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0VGltZW91dCgpXG4gICAgICB9KVxuICAgIH0sIHdhaXRNcylcbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZERheVJhbmdlKGRhdGU6IERhdGVNYXJrZXIpOiBEYXRlUmFuZ2UgeyAvLyBUT0RPOiBtYWtlIHRoaXMgYSBnZW5lcmFsIHV0aWxcbiAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheShkYXRlKVxuICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgMSlcblxuICByZXR1cm4geyBzdGFydCwgZW5kIH1cbn1cbiIsImltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQgfSBmcm9tICcuL3RhYmxlLXV0aWxzJ1xuaW1wb3J0IHsgVk5vZGUsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgVGFibGVEYXRlQ2VsbCB9IGZyb20gJy4vVGFibGVEYXRlQ2VsbCdcbmltcG9ydCB7IFRhYmxlRG93Q2VsbCB9IGZyb20gJy4vVGFibGVEb3dDZWxsJ1xuaW1wb3J0IHsgTm93VGltZXIgfSBmcm9tICcuLi9Ob3dUaW1lcidcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tICcuLi91dGlsL21lbW9pemUnXG5pbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4uL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciB9IGZyb20gJy4uL2RhdGVsaWIvRGF0ZUZvcm1hdHRlcidcblxuZXhwb3J0IGludGVyZmFjZSBEYXlIZWFkZXJQcm9wcyB7XG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZVxuICBkYXRlczogRGF0ZU1hcmtlcltdXG4gIGRhdGVzUmVwRGlzdGluY3REYXlzOiBib29sZWFuXG4gIHJlbmRlckludHJvPzogKHJvd0tleTogc3RyaW5nKSA9PiBWTm9kZVxufVxuXG5leHBvcnQgY2xhc3MgRGF5SGVhZGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxEYXlIZWFkZXJQcm9wcz4geyAvLyBUT0RPOiByZW5hbWUgdG8gRGF5SGVhZGVyVHI/XG4gIGNyZWF0ZURheUhlYWRlckZvcm1hdHRlciA9IG1lbW9pemUoY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgZGF0ZXMsIGRhdGVQcm9maWxlLCBkYXRlc1JlcERpc3RpbmN0RGF5cywgcmVuZGVySW50cm8gfSA9IHRoaXMucHJvcHNcblxuICAgIGxldCBkYXlIZWFkZXJGb3JtYXQgPSB0aGlzLmNyZWF0ZURheUhlYWRlckZvcm1hdHRlcihcbiAgICAgIGNvbnRleHQub3B0aW9ucy5kYXlIZWFkZXJGb3JtYXQsXG4gICAgICBkYXRlc1JlcERpc3RpbmN0RGF5cyxcbiAgICAgIGRhdGVzLmxlbmd0aCxcbiAgICApXG5cbiAgICByZXR1cm4gKFxuICAgICAgPE5vd1RpbWVyIHVuaXQ9XCJkYXlcIj5cbiAgICAgICAgeyhub3dEYXRlOiBEYXRlTWFya2VyLCB0b2RheVJhbmdlOiBEYXRlUmFuZ2UpID0+IChcbiAgICAgICAgICA8dHI+XG4gICAgICAgICAgICB7cmVuZGVySW50cm8gJiYgcmVuZGVySW50cm8oJ2RheScpfVxuICAgICAgICAgICAge2RhdGVzLm1hcCgoZGF0ZSkgPT4gKFxuICAgICAgICAgICAgICBkYXRlc1JlcERpc3RpbmN0RGF5cyA/IChcbiAgICAgICAgICAgICAgICA8VGFibGVEYXRlQ2VsbFxuICAgICAgICAgICAgICAgICAga2V5PXtkYXRlLnRvSVNPU3RyaW5nKCl9XG4gICAgICAgICAgICAgICAgICBkYXRlPXtkYXRlfVxuICAgICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU9e2RhdGVQcm9maWxlfVxuICAgICAgICAgICAgICAgICAgdG9kYXlSYW5nZT17dG9kYXlSYW5nZX1cbiAgICAgICAgICAgICAgICAgIGNvbENudD17ZGF0ZXMubGVuZ3RofVxuICAgICAgICAgICAgICAgICAgZGF5SGVhZGVyRm9ybWF0PXtkYXlIZWFkZXJGb3JtYXR9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICA8VGFibGVEb3dDZWxsXG4gICAgICAgICAgICAgICAgICBrZXk9e2RhdGUuZ2V0VVRDRGF5KCl9XG4gICAgICAgICAgICAgICAgICBkb3c9e2RhdGUuZ2V0VVRDRGF5KCl9XG4gICAgICAgICAgICAgICAgICBkYXlIZWFkZXJGb3JtYXQ9e2RheUhlYWRlckZvcm1hdH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L3RyPlxuICAgICAgICApfVxuICAgICAgPC9Ob3dUaW1lcj5cbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGV4cGxpY2l0Rm9ybWF0OiBEYXRlRm9ybWF0dGVyLCBkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCkge1xuICByZXR1cm4gZXhwbGljaXRGb3JtYXQgfHwgY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0KGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlQ250KVxufVxuIiwiaW1wb3J0IHsgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IERhdGVNYXJrZXIsIGFkZERheXMsIGRpZmZEYXlzIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5U2VyaWVzU2VnIHtcbiAgZmlyc3RJbmRleDogbnVtYmVyXG4gIGxhc3RJbmRleDogbnVtYmVyXG4gIGlzU3RhcnQ6IGJvb2xlYW5cbiAgaXNFbmQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIERheVNlcmllc01vZGVsIHtcbiAgY250OiBudW1iZXJcbiAgZGF0ZXM6IERhdGVNYXJrZXJbXSAvLyB3aG9sZS1kYXkgZGF0ZXMgZm9yIGVhY2ggY29sdW1uLiBsZWZ0IHRvIHJpZ2h0XG4gIGluZGljZXM6IG51bWJlcltdIC8vIGZvciBlYWNoIGRheSBmcm9tIHN0YXJ0LCB0aGUgb2Zmc2V0XG5cbiAgY29uc3RydWN0b3IocmFuZ2U6IERhdGVSYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3I6IERhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgbGV0IGRhdGU6IERhdGVNYXJrZXIgPSByYW5nZS5zdGFydFxuICAgIGxldCB7IGVuZCB9ID0gcmFuZ2VcbiAgICBsZXQgaW5kaWNlczogbnVtYmVyW10gPSBbXVxuICAgIGxldCBkYXRlczogRGF0ZU1hcmtlcltdID0gW11cbiAgICBsZXQgZGF5SW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKGRhdGUgPCBlbmQpIHsgLy8gbG9vcCBlYWNoIGRheSBmcm9tIHN0YXJ0IHRvIGVuZFxuICAgICAgaWYgKGRhdGVQcm9maWxlR2VuZXJhdG9yLmlzSGlkZGVuRGF5KGRhdGUpKSB7XG4gICAgICAgIGluZGljZXMucHVzaChkYXlJbmRleCArIDAuNSkgLy8gbWFyayB0aGF0IGl0J3MgYmV0d2VlbiBpbmRpY2VzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXlJbmRleCArPSAxXG4gICAgICAgIGluZGljZXMucHVzaChkYXlJbmRleClcbiAgICAgICAgZGF0ZXMucHVzaChkYXRlKVxuICAgICAgfVxuICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgMSlcbiAgICB9XG5cbiAgICB0aGlzLmRhdGVzID0gZGF0ZXNcbiAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzXG4gICAgdGhpcy5jbnQgPSBkYXRlcy5sZW5ndGhcbiAgfVxuXG4gIHNsaWNlUmFuZ2UocmFuZ2U6IERhdGVSYW5nZSk6IERheVNlcmllc1NlZyB8IG51bGwge1xuICAgIGxldCBmaXJzdEluZGV4ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgocmFuZ2Uuc3RhcnQpIC8vIGluY2x1c2l2ZSBmaXJzdCBpbmRleFxuICAgIGxldCBsYXN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChhZGREYXlzKHJhbmdlLmVuZCwgLTEpKSAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxuXG4gICAgbGV0IGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5tYXgoMCwgZmlyc3RJbmRleClcbiAgICBsZXQgY2xpcHBlZExhc3RJbmRleCA9IE1hdGgubWluKHRoaXMuY250IC0gMSwgbGFzdEluZGV4KVxuXG4gICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xuICAgIGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5jZWlsKGNsaXBwZWRGaXJzdEluZGV4KSAvLyBpbi1iZXR3ZWVuIHN0YXJ0cyByb3VuZCB0byBuZXh0IGNlbGxcbiAgICBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5mbG9vcihjbGlwcGVkTGFzdEluZGV4KSAvLyBpbi1iZXR3ZWVuIGVuZHMgcm91bmQgdG8gcHJldiBjZWxsXG5cbiAgICBpZiAoY2xpcHBlZEZpcnN0SW5kZXggPD0gY2xpcHBlZExhc3RJbmRleCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlyc3RJbmRleDogY2xpcHBlZEZpcnN0SW5kZXgsXG4gICAgICAgIGxhc3RJbmRleDogY2xpcHBlZExhc3RJbmRleCxcbiAgICAgICAgaXNTdGFydDogZmlyc3RJbmRleCA9PT0gY2xpcHBlZEZpcnN0SW5kZXgsXG4gICAgICAgIGlzRW5kOiBsYXN0SW5kZXggPT09IGNsaXBwZWRMYXN0SW5kZXgsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBHaXZlbiBhIGRhdGUsIHJldHVybnMgaXRzIGNocm9ub2xvY2lhbCBjZWxsLWluZGV4IGZyb20gdGhlIGZpcnN0IGNlbGwgb2YgdGhlIGdyaWQuXG4gIC8vIElmIHRoZSBkYXRlIGxpZXMgYmV0d2VlbiBjZWxscyAoYmVjYXVzZSBvZiBoaWRkZW5EYXlzKSwgcmV0dXJucyBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIGJldHdlZW4gb2Zmc2V0cy5cbiAgLy8gSWYgYmVmb3JlIHRoZSBmaXJzdCBvZmZzZXQsIHJldHVybnMgYSBuZWdhdGl2ZSBudW1iZXIuXG4gIC8vIElmIGFmdGVyIHRoZSBsYXN0IG9mZnNldCwgcmV0dXJucyBhbiBvZmZzZXQgcGFzdCB0aGUgbGFzdCBjZWxsIG9mZnNldC5cbiAgLy8gT25seSB3b3JrcyBmb3IgKnN0YXJ0KiBkYXRlcyBvZiBjZWxscy4gV2lsbCBub3Qgd29yayBmb3IgZXhjbHVzaXZlIGVuZCBkYXRlcyBmb3IgY2VsbHMuXG4gIHByaXZhdGUgZ2V0RGF0ZURheUluZGV4KGRhdGU6IERhdGVNYXJrZXIpIHtcbiAgICBsZXQgeyBpbmRpY2VzIH0gPSB0aGlzXG4gICAgbGV0IGRheU9mZnNldCA9IE1hdGguZmxvb3IoZGlmZkRheXModGhpcy5kYXRlc1swXSwgZGF0ZSkpXG5cbiAgICBpZiAoZGF5T2Zmc2V0IDwgMCkge1xuICAgICAgcmV0dXJuIGluZGljZXNbMF0gLSAxXG4gICAgfVxuXG4gICAgaWYgKGRheU9mZnNldCA+PSBpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSArIDFcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kaWNlc1tkYXlPZmZzZXRdXG4gIH1cbn1cbiIsImltcG9ydCB7IERheVNlcmllc01vZGVsIH0gZnJvbSAnLi9EYXlTZXJpZXNNb2RlbCdcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IFNlZyB9IGZyb20gJy4uL2NvbXBvbmVudC9EYXRlQ29tcG9uZW50J1xuaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5VGFibGVTZWcgZXh0ZW5kcyBTZWcge1xuICByb3c6IG51bWJlclxuICBmaXJzdENvbDogbnVtYmVyXG4gIGxhc3RDb2w6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERheVRhYmxlQ2VsbCB7XG4gIGtleTogc3RyaW5nIC8vIHByb2JhYmx5IGp1c3QgdGhlIHNlcmlhbGl6ZWQgZGF0ZSwgYnV0IGNvdWxkIGJlIG90aGVyIG1ldGFkYXRhIGlmIHRoaXMgY29sIGlzIHNwZWNpZmljIHRvIGFub3RoZXIgZW50aXR5XG4gIGRhdGU6IERhdGVNYXJrZXJcbiAgZXh0cmFIb29rUHJvcHM/OiBEaWN0aW9uYXJ5XG4gIGV4dHJhRGF0YUF0dHJzPzogRGljdGlvbmFyeVxuICBleHRyYUNsYXNzTmFtZXM/OiBzdHJpbmdbXVxuICBleHRyYURhdGVTcGFuPzogRGljdGlvbmFyeVxufVxuXG5leHBvcnQgY2xhc3MgRGF5VGFibGVNb2RlbCB7XG4gIHJvd0NudDogbnVtYmVyXG4gIGNvbENudDogbnVtYmVyXG4gIGNlbGxzOiBEYXlUYWJsZUNlbGxbXVtdXG4gIGhlYWRlckRhdGVzOiBEYXRlTWFya2VyW11cblxuICBwcml2YXRlIGRheVNlcmllczogRGF5U2VyaWVzTW9kZWxcblxuICBjb25zdHJ1Y3RvcihkYXlTZXJpZXM6IERheVNlcmllc01vZGVsLCBicmVha09uV2Vla3M6IGJvb2xlYW4pIHtcbiAgICBsZXQgeyBkYXRlcyB9ID0gZGF5U2VyaWVzXG4gICAgbGV0IGRheXNQZXJSb3dcbiAgICBsZXQgZmlyc3REYXlcbiAgICBsZXQgcm93Q250XG5cbiAgICBpZiAoYnJlYWtPbldlZWtzKSB7XG4gICAgICAvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXG4gICAgICBmaXJzdERheSA9IGRhdGVzWzBdLmdldFVUQ0RheSgpXG4gICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93ICs9IDEpIHtcbiAgICAgICAgaWYgKGRhdGVzW2RheXNQZXJSb3ddLmdldFVUQ0RheSgpID09PSBmaXJzdERheSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KVxuICAgIH0gZWxzZSB7XG4gICAgICByb3dDbnQgPSAxXG4gICAgICBkYXlzUGVyUm93ID0gZGF0ZXMubGVuZ3RoXG4gICAgfVxuXG4gICAgdGhpcy5yb3dDbnQgPSByb3dDbnRcbiAgICB0aGlzLmNvbENudCA9IGRheXNQZXJSb3dcbiAgICB0aGlzLmRheVNlcmllcyA9IGRheVNlcmllc1xuICAgIHRoaXMuY2VsbHMgPSB0aGlzLmJ1aWxkQ2VsbHMoKVxuICAgIHRoaXMuaGVhZGVyRGF0ZXMgPSB0aGlzLmJ1aWxkSGVhZGVyRGF0ZXMoKVxuICB9XG5cbiAgcHJpdmF0ZSBidWlsZENlbGxzKCkge1xuICAgIGxldCByb3dzID0gW11cblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3cgKz0gMSkge1xuICAgICAgbGV0IGNlbGxzID0gW11cblxuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICAgIGNlbGxzLnB1c2goXG4gICAgICAgICAgdGhpcy5idWlsZENlbGwocm93LCBjb2wpLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJvd3MucHVzaChjZWxscylcbiAgICB9XG5cbiAgICByZXR1cm4gcm93c1xuICB9XG5cbiAgcHJpdmF0ZSBidWlsZENlbGwocm93LCBjb2wpOiBEYXlUYWJsZUNlbGwge1xuICAgIGxldCBkYXRlID0gdGhpcy5kYXlTZXJpZXMuZGF0ZXNbcm93ICogdGhpcy5jb2xDbnQgKyBjb2xdXG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgZGF0ZSxcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkSGVhZGVyRGF0ZXMoKSB7XG4gICAgbGV0IGRhdGVzID0gW11cblxuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgZGF0ZXMucHVzaCh0aGlzLmNlbGxzWzBdW2NvbF0uZGF0ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZXNcbiAgfVxuXG4gIHNsaWNlUmFuZ2UocmFuZ2U6IERhdGVSYW5nZSk6IERheVRhYmxlU2VnW10ge1xuICAgIGxldCB7IGNvbENudCB9ID0gdGhpc1xuICAgIGxldCBzZXJpZXNTZWcgPSB0aGlzLmRheVNlcmllcy5zbGljZVJhbmdlKHJhbmdlKVxuICAgIGxldCBzZWdzOiBEYXlUYWJsZVNlZ1tdID0gW11cblxuICAgIGlmIChzZXJpZXNTZWcpIHtcbiAgICAgIGxldCB7IGZpcnN0SW5kZXgsIGxhc3RJbmRleCB9ID0gc2VyaWVzU2VnXG4gICAgICBsZXQgaW5kZXggPSBmaXJzdEluZGV4XG5cbiAgICAgIHdoaWxlIChpbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyBjb2xDbnQpXG4gICAgICAgIGxldCBuZXh0SW5kZXggPSBNYXRoLm1pbigocm93ICsgMSkgKiBjb2xDbnQsIGxhc3RJbmRleCArIDEpXG5cbiAgICAgICAgc2Vncy5wdXNoKHtcbiAgICAgICAgICByb3csXG4gICAgICAgICAgZmlyc3RDb2w6IGluZGV4ICUgY29sQ250LFxuICAgICAgICAgIGxhc3RDb2w6IChuZXh0SW5kZXggLSAxKSAlIGNvbENudCxcbiAgICAgICAgICBpc1N0YXJ0OiBzZXJpZXNTZWcuaXNTdGFydCAmJiBpbmRleCA9PT0gZmlyc3RJbmRleCxcbiAgICAgICAgICBpc0VuZDogc2VyaWVzU2VnLmlzRW5kICYmIChuZXh0SW5kZXggLSAxKSA9PT0gbGFzdEluZGV4LFxuICAgICAgICB9KVxuXG4gICAgICAgIGluZGV4ID0gbmV4dEluZGV4XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlZ3NcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgRXZlbnRTdG9yZSB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBFdmVudFVpSGFzaCB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC11aSdcbmltcG9ydCB7IHNsaWNlRXZlbnRTdG9yZSwgRXZlbnRSZW5kZXJSYW5nZSB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcnXG5pbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4uL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgU2VnLCBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4uL2NvbXBvbmVudC9EYXRlQ29tcG9uZW50JyAvLyBUT0RPOiByZW5hbWUgRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUsIG1vdmUgaGVyZVxuaW1wb3J0IHsgRGF0ZVNwYW4sIGZhYnJpY2F0ZUV2ZW50UmFuZ2UgfSBmcm9tICcuLi9zdHJ1Y3RzL2RhdGUtc3BhbidcbmltcG9ydCB7IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4uL2ludGVyYWN0aW9ucy9ldmVudC1pbnRlcmFjdGlvbi1zdGF0ZSdcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tICcuLi91dGlsL21lbW9pemUnXG5pbXBvcnQgeyBEYXRlTWFya2VyLCBhZGRNcywgYWRkRGF5cyB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgZXhwYW5kUmVjdXJyaW5nIH0gZnJvbSAnLi4vc3RydWN0cy9yZWN1cnJpbmctZXZlbnQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpY2VhYmxlUHJvcHMge1xuICBkYXRlU2VsZWN0aW9uOiBEYXRlU3BhblxuICBidXNpbmVzc0hvdXJzOiBFdmVudFN0b3JlXG4gIGV2ZW50U3RvcmU6IEV2ZW50U3RvcmVcbiAgZXZlbnREcmFnOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGV2ZW50UmVzaXplOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGV2ZW50U2VsZWN0aW9uOiBzdHJpbmdcbiAgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWNlZFByb3BzPFNlZ1R5cGUgZXh0ZW5kcyBTZWc+IHtcbiAgZGF0ZVNlbGVjdGlvblNlZ3M6IFNlZ1R5cGVbXVxuICBidXNpbmVzc0hvdXJTZWdzOiBTZWdUeXBlW11cbiAgZmdFdmVudFNlZ3M6IFNlZ1R5cGVbXVxuICBiZ0V2ZW50U2VnczogU2VnVHlwZVtdXG4gIGV2ZW50RHJhZzogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGV2ZW50UmVzaXplOiBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgZXZlbnRTZWxlY3Rpb246IHN0cmluZ1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2xpY2VyPFNlZ1R5cGUgZXh0ZW5kcyBTZWcsIEV4dHJhQXJncyBleHRlbmRzIGFueVtdID0gW10+IHtcbiAgcHJpdmF0ZSBzbGljZUJ1c2luZXNzSG91cnMgPSBtZW1vaXplKHRoaXMuX3NsaWNlQnVzaW5lc3NIb3VycylcbiAgcHJpdmF0ZSBzbGljZURhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NsaWNlRGF0ZVNwYW4pXG4gIHByaXZhdGUgc2xpY2VFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zbGljZUV2ZW50U3RvcmUpXG4gIHByaXZhdGUgc2xpY2VFdmVudERyYWcgPSBtZW1vaXplKHRoaXMuX3NsaWNlSW50ZXJhY3Rpb24pXG4gIHByaXZhdGUgc2xpY2VFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbilcblxuICBhYnN0cmFjdCBzbGljZVJhbmdlKGRhdGVSYW5nZTogRGF0ZVJhbmdlLCAuLi5leHRyYUFyZ3M6IEV4dHJhQXJncyk6IFNlZ1R5cGVbXVxuICBwcm90ZWN0ZWQgZm9yY2VEYXlJZkxpc3RJdGVtID0gZmFsc2UgLy8gaGFja1xuXG4gIHNsaWNlUHJvcHMoXG4gICAgcHJvcHM6IFNsaWNlYWJsZVByb3BzLFxuICAgIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSxcbiAgICBuZXh0RGF5VGhyZXNob2xkOiBEdXJhdGlvbiB8IG51bGwsXG4gICAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuICAgIC4uLmV4dHJhQXJnczogRXh0cmFBcmdzXG4gICk6IFNsaWNlZFByb3BzPFNlZ1R5cGU+IHtcbiAgICBsZXQgeyBldmVudFVpQmFzZXMgfSA9IHByb3BzXG4gICAgbGV0IGV2ZW50U2VncyA9IHRoaXMuc2xpY2VFdmVudFN0b3JlKHByb3BzLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncylcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRlU2VsZWN0aW9uU2VnczogdGhpcy5zbGljZURhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpLFxuICAgICAgYnVzaW5lc3NIb3VyU2VnczogdGhpcy5zbGljZUJ1c2luZXNzSG91cnMocHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncyksXG4gICAgICBmZ0V2ZW50U2VnczogZXZlbnRTZWdzLmZnLFxuICAgICAgYmdFdmVudFNlZ3M6IGV2ZW50U2Vncy5iZyxcbiAgICAgIGV2ZW50RHJhZzogdGhpcy5zbGljZUV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncyksXG4gICAgICBldmVudFJlc2l6ZTogdGhpcy5zbGljZUV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpLFxuICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxuICAgIH0gLy8gVE9ETzogZ2l2ZSBpbnRlcmFjdGlvblNlZ3M/XG4gIH1cblxuICBzbGljZU5vd0RhdGUoIC8vIGRvZXMgbm90IG1lbW9pemVcbiAgICBkYXRlOiBEYXRlTWFya2VyLFxuICAgIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbiAgICAuLi5leHRyYUFyZ3M6IEV4dHJhQXJnc1xuICApOiBTZWdUeXBlW10ge1xuICAgIHJldHVybiB0aGlzLl9zbGljZURhdGVTcGFuKFxuICAgICAgeyByYW5nZTogeyBzdGFydDogZGF0ZSwgZW5kOiBhZGRNcyhkYXRlLCAxKSB9LCBhbGxEYXk6IGZhbHNlIH0sIC8vIGFkZCAxIG1zLCBwcm90ZWN0IGFnYWluc3QgbnVsbCByYW5nZVxuICAgICAge30sXG4gICAgICBjb250ZXh0LFxuICAgICAgLi4uZXh0cmFBcmdzLFxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgX3NsaWNlQnVzaW5lc3NIb3VycyhcbiAgICBidXNpbmVzc0hvdXJzOiBFdmVudFN0b3JlLFxuICAgIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSxcbiAgICBuZXh0RGF5VGhyZXNob2xkOiBEdXJhdGlvbiB8IG51bGwsXG4gICAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuICAgIC4uLmV4dHJhQXJnczogRXh0cmFBcmdzXG4gICk6IFNlZ1R5cGVbXSB7XG4gICAgaWYgKCFidXNpbmVzc0hvdXJzKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc2xpY2VFdmVudFN0b3JlKFxuICAgICAgZXhwYW5kUmVjdXJyaW5nKFxuICAgICAgICBidXNpbmVzc0hvdXJzLFxuICAgICAgICBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKSxcbiAgICAgIHt9LFxuICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICBuZXh0RGF5VGhyZXNob2xkLFxuICAgICAgLi4uZXh0cmFBcmdzLFxuICAgICkuYmdcbiAgfVxuXG4gIHByaXZhdGUgX3NsaWNlRXZlbnRTdG9yZShcbiAgICBldmVudFN0b3JlOiBFdmVudFN0b3JlLFxuICAgIGV2ZW50VWlCYXNlczogRXZlbnRVaUhhc2gsXG4gICAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6IER1cmF0aW9uIHwgbnVsbCxcbiAgICAuLi5leHRyYUFyZ3M6IEV4dHJhQXJnc1xuICApOiB7IGJnOiBTZWdUeXBlW10sIGZnOiBTZWdUeXBlW10gfSB7XG4gICAgaWYgKGV2ZW50U3RvcmUpIHtcbiAgICAgIGxldCByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShcbiAgICAgICAgZXZlbnRTdG9yZSxcbiAgICAgICAgZXZlbnRVaUJhc2VzLFxuICAgICAgICBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLFxuICAgICAgICBuZXh0RGF5VGhyZXNob2xkLFxuICAgICAgKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBiZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmJnLCBleHRyYUFyZ3MpLFxuICAgICAgICBmZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmZnLCBleHRyYUFyZ3MpLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBiZzogW10sIGZnOiBbXSB9XG4gIH1cblxuICBwcml2YXRlIF9zbGljZUludGVyYWN0aW9uKFxuICAgIGludGVyYWN0aW9uOiBFdmVudEludGVyYWN0aW9uU3RhdGUsXG4gICAgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaCxcbiAgICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsXG4gICAgbmV4dERheVRocmVzaG9sZDogRHVyYXRpb24gfCBudWxsLFxuICAgIC4uLmV4dHJhQXJnczogRXh0cmFBcmdzXG4gICk6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHtcbiAgICBpZiAoIWludGVyYWN0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGxldCByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShcbiAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsXG4gICAgICBldmVudFVpQmFzZXMsXG4gICAgICBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLFxuICAgICAgbmV4dERheVRocmVzaG9sZCxcbiAgICApXG5cbiAgICByZXR1cm4ge1xuICAgICAgc2VnczogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmZnLCBleHRyYUFyZ3MpLFxuICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLmluc3RhbmNlcyxcbiAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfc2xpY2VEYXRlU3BhbihcbiAgICBkYXRlU3BhbjogRGF0ZVNwYW4sXG4gICAgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaCxcbiAgICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4gICAgLi4uZXh0cmFBcmdzOiBFeHRyYUFyZ3NcbiAgKTogU2VnVHlwZVtdIHtcbiAgICBpZiAoIWRhdGVTcGFuKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBsZXQgZXZlbnRSYW5nZSA9IGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dClcbiAgICBsZXQgc2VncyA9IHRoaXMuc2xpY2VSYW5nZShkYXRlU3Bhbi5yYW5nZSwgLi4uZXh0cmFBcmdzKVxuXG4gICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgIHNlZy5ldmVudFJhbmdlID0gZXZlbnRSYW5nZVxuICAgIH1cblxuICAgIHJldHVybiBzZWdzXG4gIH1cblxuICAvKlxuICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcbiAgKi9cbiAgcHJpdmF0ZSBzbGljZUV2ZW50UmFuZ2VzKFxuICAgIGV2ZW50UmFuZ2VzOiBFdmVudFJlbmRlclJhbmdlW10sXG4gICAgZXh0cmFBcmdzOiBFeHRyYUFyZ3MsXG4gICk6IFNlZ1R5cGVbXSB7XG4gICAgbGV0IHNlZ3M6IFNlZ1R5cGVbXSA9IFtdXG5cbiAgICBmb3IgKGxldCBldmVudFJhbmdlIG9mIGV2ZW50UmFuZ2VzKSB7XG4gICAgICBzZWdzLnB1c2goLi4udGhpcy5zbGljZUV2ZW50UmFuZ2UoZXZlbnRSYW5nZSwgZXh0cmFBcmdzKSlcbiAgICB9XG5cbiAgICByZXR1cm4gc2Vnc1xuICB9XG5cbiAgLypcbiAgXCJjb21wbGV0ZVwiIHNlZyBtZWFucyBpdCBoYXMgY29tcG9uZW50IGFuZCBldmVudFJhbmdlXG4gICovXG4gIHByaXZhdGUgc2xpY2VFdmVudFJhbmdlKFxuICAgIGV2ZW50UmFuZ2U6IEV2ZW50UmVuZGVyUmFuZ2UsXG4gICAgZXh0cmFBcmdzOiBFeHRyYUFyZ3MsXG4gICk6IFNlZ1R5cGVbXSB7XG4gICAgbGV0IGRhdGVSYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2VcblxuICAgIC8vIGhhY2sgdG8gbWFrZSBtdWx0aS1kYXkgZXZlbnRzIHRoYXQgYXJlIGJlaW5nIGZvcmNlLWRpc3BsYXllZCBhcyBsaXN0LWl0ZW1zIHRvIHRha2UgdXAgb25seSBvbmUgZGF5XG4gICAgaWYgKHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtICYmIGV2ZW50UmFuZ2UudWkuZGlzcGxheSA9PT0gJ2xpc3QtaXRlbScpIHtcbiAgICAgIGRhdGVSYW5nZSA9IHtcbiAgICAgICAgc3RhcnQ6IGRhdGVSYW5nZS5zdGFydCxcbiAgICAgICAgZW5kOiBhZGREYXlzKGRhdGVSYW5nZS5zdGFydCwgMSksXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlLCAuLi5leHRyYUFyZ3MpXG5cbiAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlXG4gICAgICBzZWcuaXNTdGFydCA9IGV2ZW50UmFuZ2UuaXNTdGFydCAmJiBzZWcuaXNTdGFydFxuICAgICAgc2VnLmlzRW5kID0gZXZlbnRSYW5nZS5pc0VuZCAmJiBzZWcuaXNFbmRcbiAgICB9XG5cbiAgICByZXR1cm4gc2Vnc1xuICB9XG59XG5cbi8qXG5mb3IgaW5jb3Jwb3JhdGluZyBzbG90TWluVGltZS9zbG90TWF4VGltZSBpZiBhcHByb3ByaWF0ZVxuVE9ETzogc2hvdWxkIGJlIHBhcnQgb2YgRGF0ZVByb2ZpbGUhXG5UaW1lbGluZURhdGVQcm9maWxlIGFscmVhZHkgZG9lcyB0aGlzIGJ0d1xuKi9cbmZ1bmN0aW9uIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsIGlzQ29tcG9uZW50QWxsRGF5OiBib29sZWFuKTogRGF0ZVJhbmdlIHtcbiAgbGV0IHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2VcblxuICBpZiAoaXNDb21wb25lbnRBbGxEYXkpIHtcbiAgICByZXR1cm4gcmFuZ2VcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGFkZE1zKHJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5zbG90TWluVGltZS5taWxsaXNlY29uZHMpLFxuICAgIGVuZDogYWRkTXMocmFuZ2UuZW5kLCBkYXRlUHJvZmlsZS5zbG90TWF4VGltZS5taWxsaXNlY29uZHMgLSA4NjRlNSksIC8vIDg2NGU1ID0gbXMgaW4gYSBkYXlcbiAgfVxufVxuIiwiaW1wb3J0IHsgRXZlbnRTdG9yZSwgZmlsdGVyRXZlbnRTdG9yZURlZnMgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBEYXRlU3BhbiB9IGZyb20gJy4vc3RydWN0cy9kYXRlLXNwYW4nXG5pbXBvcnQgeyByYW5nZUNvbnRhaW5zUmFuZ2UsIHJhbmdlc0ludGVyc2VjdCwgRGF0ZVJhbmdlLCBPcGVuRGF0ZVJhbmdlIH0gZnJvbSAnLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBFdmVudEFwaSB9IGZyb20gJy4vYXBpL0V2ZW50QXBpJ1xuaW1wb3J0IHsgY29tcGlsZUV2ZW50VWlzIH0gZnJvbSAnLi9jb21wb25lbnQvZXZlbnQtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgZXhjbHVkZUluc3RhbmNlcyB9IGZyb20gJy4vcmVkdWNlcnMvZXZlbnRTdG9yZSdcbmltcG9ydCB7IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL2V2ZW50LWludGVyYWN0aW9uLXN0YXRlJ1xuaW1wb3J0IHsgU3BsaXR0YWJsZVByb3BzIH0gZnJvbSAnLi9jb21wb25lbnQvZXZlbnQtc3BsaXR0aW5nJ1xuaW1wb3J0IHsgbWFwSGFzaCB9IGZyb20gJy4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dCB9IGZyb20gJy4vY2FsZW5kYXItdXRpbHMnXG5pbXBvcnQgeyBDb25zdHJhaW50IH0gZnJvbSAnLi9zdHJ1Y3RzL2NvbnN0cmFpbnQnXG5pbXBvcnQgeyBleHBhbmRSZWN1cnJpbmcgfSBmcm9tICcuL3N0cnVjdHMvcmVjdXJyaW5nLWV2ZW50J1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGUgfSBmcm9tICcuL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuXG4vLyBoaWdoLWxldmVsIHNlZ21lbnRpbmctYXdhcmUgdGVzdGVyIGZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVyYWN0aW9uVmFsaWQoXG4gIGludGVyYWN0aW9uOiBFdmVudEludGVyYWN0aW9uU3RhdGUsXG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSxcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuKSB7XG4gIGxldCB7IGluc3RhbmNlcyB9ID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50c1xuICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgIGlmICghcmFuZ2VDb250YWluc1JhbmdlKGRhdGVQcm9maWxlLnZhbGlkUmFuZ2UsIGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZXZlbnREcmFnOiBpbnRlcmFjdGlvbiB9LCBjb250ZXh0KSAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGlvblZhbGlkKFxuICBkYXRlU2VsZWN0aW9uOiBEYXRlU3BhbixcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLFxuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4pIHtcbiAgaWYgKCFyYW5nZUNvbnRhaW5zUmFuZ2UoZGF0ZVByb2ZpbGUudmFsaWRSYW5nZSwgZGF0ZVNlbGVjdGlvbi5yYW5nZSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZGF0ZVNlbGVjdGlvbiB9LCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBpc05ld1Byb3BzVmFsaWQobmV3UHJvcHMsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBsZXQgY2FsZW5kYXJTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKVxuXG4gIGxldCBwcm9wcyA9IHtcbiAgICBidXNpbmVzc0hvdXJzOiBjYWxlbmRhclN0YXRlLmJ1c2luZXNzSG91cnMsXG4gICAgZGF0ZVNlbGVjdGlvbjogJycsXG4gICAgZXZlbnRTdG9yZTogY2FsZW5kYXJTdGF0ZS5ldmVudFN0b3JlLFxuICAgIGV2ZW50VWlCYXNlczogY2FsZW5kYXJTdGF0ZS5ldmVudFVpQmFzZXMsXG4gICAgZXZlbnRTZWxlY3Rpb246ICcnLFxuICAgIGV2ZW50RHJhZzogbnVsbCxcbiAgICBldmVudFJlc2l6ZTogbnVsbCxcbiAgICAuLi5uZXdQcm9wcyxcbiAgfVxuXG4gIHJldHVybiAoY29udGV4dC5wbHVnaW5Ib29rcy5pc1Byb3BzVmFsaWQgfHwgaXNQcm9wc1ZhbGlkKShwcm9wcywgY29udGV4dClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvcHNWYWxpZChzdGF0ZTogU3BsaXR0YWJsZVByb3BzLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsIGRhdGVTcGFuTWV0YSA9IHt9LCBmaWx0ZXJDb25maWc/KTogYm9vbGVhbiB7XG4gIGlmIChzdGF0ZS5ldmVudERyYWcgJiYgIWlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChzdGF0ZS5kYXRlU2VsZWN0aW9uICYmICFpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vIE1vdmluZyBFdmVudCBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGU6IFNwbGl0dGFibGVQcm9wcywgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LCBkYXRlU3Bhbk1ldGE6IGFueSwgZmlsdGVyQ29uZmlnKTogYm9vbGVhbiB7XG4gIGxldCBjdXJyZW50U3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKClcbiAgbGV0IGludGVyYWN0aW9uID0gc3RhdGUuZXZlbnREcmFnIC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xuXG4gIGxldCBzdWJqZWN0RXZlbnRTdG9yZSA9IGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHNcbiAgbGV0IHN1YmplY3REZWZzID0gc3ViamVjdEV2ZW50U3RvcmUuZGVmc1xuICBsZXQgc3ViamVjdEluc3RhbmNlcyA9IHN1YmplY3RFdmVudFN0b3JlLmluc3RhbmNlc1xuICBsZXQgc3ViamVjdENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoXG4gICAgc3ViamVjdERlZnMsXG4gICAgaW50ZXJhY3Rpb24uaXNFdmVudCA/XG4gICAgICBzdGF0ZS5ldmVudFVpQmFzZXMgOlxuICAgICAgeyAnJzogY3VycmVudFN0YXRlLnNlbGVjdGlvbkNvbmZpZyB9LCAvLyBpZiBub3QgYSByZWFsIGV2ZW50LCB2YWxpZGF0ZSBhcyBhIHNlbGVjdGlvblxuICApXG5cbiAgaWYgKGZpbHRlckNvbmZpZykge1xuICAgIHN1YmplY3RDb25maWdzID0gbWFwSGFzaChzdWJqZWN0Q29uZmlncywgZmlsdGVyQ29uZmlnKVxuICB9XG5cbiAgLy8gZXhjbHVkZSB0aGUgc3ViamVjdCBldmVudHMuIFRPRE86IGV4Y2x1ZGUgZGVmcyB0b28/XG4gIGxldCBvdGhlckV2ZW50U3RvcmUgPSBleGNsdWRlSW5zdGFuY2VzKHN0YXRlLmV2ZW50U3RvcmUsIGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLmluc3RhbmNlcylcblxuICBsZXQgb3RoZXJEZWZzID0gb3RoZXJFdmVudFN0b3JlLmRlZnNcbiAgbGV0IG90aGVySW5zdGFuY2VzID0gb3RoZXJFdmVudFN0b3JlLmluc3RhbmNlc1xuICBsZXQgb3RoZXJDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKG90aGVyRGVmcywgc3RhdGUuZXZlbnRVaUJhc2VzKVxuXG4gIGZvciAobGV0IHN1YmplY3RJbnN0YW5jZUlkIGluIHN1YmplY3RJbnN0YW5jZXMpIHtcbiAgICBsZXQgc3ViamVjdEluc3RhbmNlID0gc3ViamVjdEluc3RhbmNlc1tzdWJqZWN0SW5zdGFuY2VJZF1cbiAgICBsZXQgc3ViamVjdFJhbmdlID0gc3ViamVjdEluc3RhbmNlLnJhbmdlXG4gICAgbGV0IHN1YmplY3RDb25maWcgPSBzdWJqZWN0Q29uZmlnc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdXG4gICAgbGV0IHN1YmplY3REZWYgPSBzdWJqZWN0RGVmc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdXG5cbiAgICAvLyBjb25zdHJhaW50XG4gICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc3ViamVjdENvbmZpZy5jb25zdHJhaW50cywgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBvdmVybGFwXG5cbiAgICBsZXQgeyBldmVudE92ZXJsYXAgfSA9IGNvbnRleHQub3B0aW9uc1xuICAgIGxldCBldmVudE92ZXJsYXBGdW5jID0gdHlwZW9mIGV2ZW50T3ZlcmxhcCA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50T3ZlcmxhcCA6IG51bGxcblxuICAgIGZvciAobGV0IG90aGVySW5zdGFuY2VJZCBpbiBvdGhlckluc3RhbmNlcykge1xuICAgICAgbGV0IG90aGVySW5zdGFuY2UgPSBvdGhlckluc3RhbmNlc1tvdGhlckluc3RhbmNlSWRdXG5cbiAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc3ViamVjdFJhbmdlLCBvdGhlckluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgICBsZXQgb3RoZXJPdmVybGFwID0gb3RoZXJDb25maWdzW290aGVySW5zdGFuY2UuZGVmSWRdLm92ZXJsYXBcblxuICAgICAgICAvLyBjb25zaWRlciB0aGUgb3RoZXIgZXZlbnQncyBvdmVybGFwLiBvbmx5IGRvIHRoaXMgaWYgdGhlIHN1YmplY3QgZXZlbnQgaXMgYSBcInJlYWxcIiBldmVudFxuICAgICAgICBpZiAob3RoZXJPdmVybGFwID09PSBmYWxzZSAmJiBpbnRlcmFjdGlvbi5pc0V2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3ViamVjdENvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50T3ZlcmxhcEZ1bmMgJiYgIWV2ZW50T3ZlcmxhcEZ1bmMoXG4gICAgICAgICAgbmV3IEV2ZW50QXBpKGNvbnRleHQsIG90aGVyRGVmc1tvdGhlckluc3RhbmNlLmRlZklkXSwgb3RoZXJJbnN0YW5jZSksIC8vIHN0aWxsIGV2ZW50XG4gICAgICAgICAgbmV3IEV2ZW50QXBpKGNvbnRleHQsIHN1YmplY3REZWYsIHN1YmplY3RJbnN0YW5jZSksIC8vIG1vdmluZyBldmVudFxuICAgICAgICApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGxvdyAoYSBmdW5jdGlvbilcblxuICAgIGxldCBjYWxlbmRhckV2ZW50U3RvcmUgPSBjdXJyZW50U3RhdGUuZXZlbnRTdG9yZSAvLyBuZWVkIGdsb2JhbC10by1jYWxlbmRhciwgbm90IGxvY2FsIHRvIGNvbXBvbmVudCAoc3BsaXR0YWJsZSlzdGF0ZVxuXG4gICAgZm9yIChsZXQgc3ViamVjdEFsbG93IG9mIHN1YmplY3RDb25maWcuYWxsb3dzKSB7XG4gICAgICBsZXQgc3ViamVjdERhdGVTcGFuOiBEYXRlU3BhbiA9IHtcbiAgICAgICAgLi4uZGF0ZVNwYW5NZXRhLFxuICAgICAgICByYW5nZTogc3ViamVjdEluc3RhbmNlLnJhbmdlLFxuICAgICAgICBhbGxEYXk6IHN1YmplY3REZWYuYWxsRGF5LFxuICAgICAgfVxuXG4gICAgICBsZXQgb3JpZ0RlZiA9IGNhbGVuZGFyRXZlbnRTdG9yZS5kZWZzW3N1YmplY3REZWYuZGVmSWRdXG4gICAgICBsZXQgb3JpZ0luc3RhbmNlID0gY2FsZW5kYXJFdmVudFN0b3JlLmluc3RhbmNlc1tzdWJqZWN0SW5zdGFuY2VJZF1cbiAgICAgIGxldCBldmVudEFwaVxuXG4gICAgICBpZiAob3JpZ0RlZikgeyAvLyB3YXMgcHJldmlvdXNseSBpbiB0aGUgY2FsZW5kYXJcbiAgICAgICAgZXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoY29udGV4dCwgb3JpZ0RlZiwgb3JpZ0luc3RhbmNlKVxuICAgICAgfSBlbHNlIHsgLy8gd2FzIGFuIGV4dGVybmFsIGV2ZW50XG4gICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNvbnRleHQsIHN1YmplY3REZWYpIC8vIG5vIGluc3RhbmNlLCBiZWNhdXNlIGhhZCBubyBkYXRlc1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN1YmplY3RBbGxvdyhcbiAgICAgICAgYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHN1YmplY3REYXRlU3BhbiwgY29udGV4dCksXG4gICAgICAgIGV2ZW50QXBpLFxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBEYXRlIFNlbGVjdGlvbiBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZChzdGF0ZTogU3BsaXR0YWJsZVByb3BzLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsIGRhdGVTcGFuTWV0YTogYW55LCBmaWx0ZXJDb25maWcpOiBib29sZWFuIHtcbiAgbGV0IHJlbGV2YW50RXZlbnRTdG9yZSA9IHN0YXRlLmV2ZW50U3RvcmVcbiAgbGV0IHJlbGV2YW50RGVmcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5kZWZzXG4gIGxldCByZWxldmFudEluc3RhbmNlcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5pbnN0YW5jZXNcblxuICBsZXQgc2VsZWN0aW9uID0gc3RhdGUuZGF0ZVNlbGVjdGlvblxuICBsZXQgc2VsZWN0aW9uUmFuZ2UgPSBzZWxlY3Rpb24ucmFuZ2VcbiAgbGV0IHsgc2VsZWN0aW9uQ29uZmlnIH0gPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKClcblxuICBpZiAoZmlsdGVyQ29uZmlnKSB7XG4gICAgc2VsZWN0aW9uQ29uZmlnID0gZmlsdGVyQ29uZmlnKHNlbGVjdGlvbkNvbmZpZylcbiAgfVxuXG4gIC8vIGNvbnN0cmFpbnRcbiAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc2VsZWN0aW9uQ29uZmlnLmNvbnN0cmFpbnRzLCBzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRFdmVudFN0b3JlLCBzdGF0ZS5idXNpbmVzc0hvdXJzLCBjb250ZXh0KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gb3ZlcmxhcFxuXG4gIGxldCB7IHNlbGVjdE92ZXJsYXAgfSA9IGNvbnRleHQub3B0aW9uc1xuICBsZXQgc2VsZWN0T3ZlcmxhcEZ1bmMgPSB0eXBlb2Ygc2VsZWN0T3ZlcmxhcCA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdE92ZXJsYXAgOiBudWxsXG5cbiAgZm9yIChsZXQgcmVsZXZhbnRJbnN0YW5jZUlkIGluIHJlbGV2YW50SW5zdGFuY2VzKSB7XG4gICAgbGV0IHJlbGV2YW50SW5zdGFuY2UgPSByZWxldmFudEluc3RhbmNlc1tyZWxldmFudEluc3RhbmNlSWRdXG5cbiAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXG4gICAgaWYgKHJhbmdlc0ludGVyc2VjdChzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRJbnN0YW5jZS5yYW5nZSkpIHtcbiAgICAgIGlmIChzZWxlY3Rpb25Db25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RPdmVybGFwRnVuYyAmJiAhc2VsZWN0T3ZlcmxhcEZ1bmMoXG4gICAgICAgIG5ldyBFdmVudEFwaShjb250ZXh0LCByZWxldmFudERlZnNbcmVsZXZhbnRJbnN0YW5jZS5kZWZJZF0sIHJlbGV2YW50SW5zdGFuY2UpLFxuICAgICAgICBudWxsLFxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhbGxvdyAoYSBmdW5jdGlvbilcbiAgZm9yIChsZXQgc2VsZWN0aW9uQWxsb3cgb2Ygc2VsZWN0aW9uQ29uZmlnLmFsbG93cykge1xuICAgIGxldCBmdWxsRGF0ZVNwYW4gPSB7IC4uLmRhdGVTcGFuTWV0YSwgLi4uc2VsZWN0aW9uIH1cblxuICAgIGlmICghc2VsZWN0aW9uQWxsb3coXG4gICAgICBidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZnVsbERhdGVTcGFuLCBjb250ZXh0KSxcbiAgICAgIG51bGwsXG4gICAgKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gQ29uc3RyYWludCBVdGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGFsbENvbnN0cmFpbnRzUGFzcyhcbiAgY29uc3RyYWludHM6IENvbnN0cmFpbnRbXSxcbiAgc3ViamVjdFJhbmdlOiBEYXRlUmFuZ2UsXG4gIG90aGVyRXZlbnRTdG9yZTogRXZlbnRTdG9yZSxcbiAgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQ6IEV2ZW50U3RvcmUsXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbik6IGJvb2xlYW4ge1xuICBmb3IgKGxldCBjb25zdHJhaW50IG9mIGNvbnN0cmFpbnRzKSB7XG4gICAgaWYgKCFhbnlSYW5nZXNDb250YWluUmFuZ2UoXG4gICAgICBjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCBjb250ZXh0KSxcbiAgICAgIHN1YmplY3RSYW5nZSxcbiAgICApKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjb25zdHJhaW50VG9SYW5nZXMoXG4gIGNvbnN0cmFpbnQ6IENvbnN0cmFpbnQsXG4gIHN1YmplY3RSYW5nZTogRGF0ZVJhbmdlLCAvLyBmb3IgZXhwYW5kaW5nIGEgcmVjdXJyaW5nIGNvbnN0cmFpbnQsIG9yIGV4cGFuZGluZyBidXNpbmVzcyBob3Vyc1xuICBvdGhlckV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIC8vIGZvciBpZiBjb25zdHJhaW50IGlzIGFuIGV2ZW4gZ3JvdXAgSURcbiAgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQ6IEV2ZW50U3RvcmUsIC8vIGZvciBpZiBjb25zdHJhaW50IGlzICdidXNpbmVzc0hvdXJzJ1xuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsIC8vIGZvciBleHBhbmRpbmcgYnVzaW5lc3Nob3Vyc1xuKTogT3BlbkRhdGVSYW5nZVtdIHtcbiAgaWYgKGNvbnN0cmFpbnQgPT09ICdidXNpbmVzc0hvdXJzJykge1xuICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoXG4gICAgICBleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIHN1YmplY3RSYW5nZSwgY29udGV4dCksXG4gICAgKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnc3RyaW5nJykgeyAvLyBhbiBncm91cCBJRFxuICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoXG4gICAgICBmaWx0ZXJFdmVudFN0b3JlRGVmcyhvdGhlckV2ZW50U3RvcmUsIChldmVudERlZikgPT4gZXZlbnREZWYuZ3JvdXBJZCA9PT0gY29uc3RyYWludCksXG4gICAgKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnb2JqZWN0JyAmJiBjb25zdHJhaW50KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoXG4gICAgICBleHBhbmRSZWN1cnJpbmcoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSxcbiAgICApXG4gIH1cblxuICByZXR1cm4gW10gLy8gaWYgaXQncyBmYWxzZVxufVxuXG4vLyBUT0RPOiBtb3ZlIHRvIGV2ZW50LXN0b3JlIGZpbGU/XG5mdW5jdGlvbiBldmVudFN0b3JlVG9SYW5nZXMoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSk6IERhdGVSYW5nZVtdIHtcbiAgbGV0IHsgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlXG4gIGxldCByYW5nZXM6IERhdGVSYW5nZVtdID0gW11cblxuICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgIHJhbmdlcy5wdXNoKGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSlcbiAgfVxuXG4gIHJldHVybiByYW5nZXNcbn1cblxuLy8gVE9ETzogbW92ZSB0byBnZW9tIGZpbGU/XG5mdW5jdGlvbiBhbnlSYW5nZXNDb250YWluUmFuZ2Uob3V0ZXJSYW5nZXM6IERhdGVSYW5nZVtdLCBpbm5lclJhbmdlOiBEYXRlUmFuZ2UpOiBib29sZWFuIHtcbiAgZm9yIChsZXQgb3V0ZXJSYW5nZSBvZiBvdXRlclJhbmdlcykge1xuICAgIGlmIChyYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBDb21wb25lbnRDaGlsZHJlbiwgUmVmIH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IEJhc2VDb21wb25lbnQsIHNldFJlZiB9IGZyb20gJy4uL3Zkb20tdXRpbCdcbmltcG9ydCB7IENzc0RpbVZhbHVlLCBTY3JvbGxlckxpa2UgfSBmcm9tICcuL3V0aWwnXG5cbmV4cG9ydCB0eXBlIE92ZXJmbG93VmFsdWUgPSAnYXV0bycgfCAnaGlkZGVuJyB8ICdzY3JvbGwnIHwgJ3Zpc2libGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsZXJQcm9wcyB7XG4gIG92ZXJmbG93WDogT3ZlcmZsb3dWYWx1ZVxuICBvdmVyZmxvd1k6IE92ZXJmbG93VmFsdWVcbiAgb3ZlcmNvbWVMZWZ0PzogbnVtYmVyXG4gIG92ZXJjb21lUmlnaHQ/OiBudW1iZXJcbiAgb3ZlcmNvbWVCb3R0b20/OiBudW1iZXJcbiAgbWF4SGVpZ2h0PzogQ3NzRGltVmFsdWVcbiAgbGlxdWlkPzogYm9vbGVhblxuICBsaXF1aWRJc0Fic29sdXRlPzogYm9vbGVhblxuICBjaGlsZHJlbj86IENvbXBvbmVudENoaWxkcmVuXG4gIGVsUmVmPzogUmVmPEhUTUxFbGVtZW50PlxufVxuXG5jb25zdCBWSVNJQkxFX0hJRERFTl9SRSA9IC9eKHZpc2libGV8aGlkZGVuKSQvXG5cbmV4cG9ydCBjbGFzcyBTY3JvbGxlciBleHRlbmRzIEJhc2VDb21wb25lbnQ8U2Nyb2xsZXJQcm9wcz4gaW1wbGVtZW50cyBTY3JvbGxlckxpa2Uge1xuICBwcml2YXRlIGVsOiBIVE1MRWxlbWVudCAvLyBUT0RPOiBqdXN0IHVzZSB0aGlzLmJhc2U/XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IHsgbGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIH0gPSBwcm9wc1xuICAgIGxldCBpc0Fic29sdXRlID0gbGlxdWlkICYmIGxpcXVpZElzQWJzb2x1dGVcbiAgICBsZXQgY2xhc3NOYW1lID0gWydmYy1zY3JvbGxlciddXG5cbiAgICBpZiAobGlxdWlkKSB7XG4gICAgICBpZiAobGlxdWlkSXNBYnNvbHV0ZSkge1xuICAgICAgICBjbGFzc05hbWUucHVzaCgnZmMtc2Nyb2xsZXItbGlxdWlkLWFic29sdXRlJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXNzTmFtZS5wdXNoKCdmYy1zY3JvbGxlci1saXF1aWQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIHJlZj17dGhpcy5oYW5kbGVFbH1cbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWUuam9pbignICcpfVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIG92ZXJmbG93WDogcHJvcHMub3ZlcmZsb3dYLFxuICAgICAgICAgIG92ZXJmbG93WTogcHJvcHMub3ZlcmZsb3dZLFxuICAgICAgICAgIGxlZnQ6IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICByaWdodDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICBib3R0b206IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxuICAgICAgICAgIG1hcmdpbkxlZnQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lTGVmdCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgbWFyZ2luUmlnaHQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgIG1hcmdpbkJvdHRvbTogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxuICAgICAgICAgIG1heEhlaWdodDogcHJvcHMubWF4SGVpZ2h0IHx8ICcnLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICBoYW5kbGVFbCA9IChlbDogSFRNTEVsZW1lbnQpID0+IHtcbiAgICB0aGlzLmVsID0gZWxcbiAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpXG4gIH1cblxuICBuZWVkc1hTY3JvbGxpbmcoKSB7XG4gICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyB0ZXN0aW5nIHNjcm9sbFdpZHRoPmNsaWVudFdpZHRoIGlzIHVucmVsaWFibGUgY3Jvc3MtYnJvd3NlciB3aGVuIHBpeGVsIGhlaWdodHMgYXJlbid0IGludGVnZXJzLlxuICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxuICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cbiAgICBsZXQgeyBlbCB9ID0gdGhpc1xuICAgIGxldCByZWFsQ2xpZW50V2lkdGggPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gdGhpcy5nZXRZU2Nyb2xsYmFyV2lkdGgoKVxuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBlbFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGV0IGNoaWxkRWwgPSBjaGlsZHJlbltpXVxuXG4gICAgICBpZiAoY2hpbGRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA+IHJlYWxDbGllbnRXaWR0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgbmVlZHNZU2Nyb2xsaW5nKCkge1xuICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gdGVzdGluZyBzY3JvbGxIZWlnaHQ+Y2xpZW50SGVpZ2h0IGlzIHVucmVsaWFibGUgY3Jvc3MtYnJvd3NlciB3aGVuIHBpeGVsIGhlaWdodHMgYXJlbid0IGludGVnZXJzLlxuICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxuICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cbiAgICBsZXQgeyBlbCB9ID0gdGhpc1xuICAgIGxldCByZWFsQ2xpZW50SGVpZ2h0ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgLSB0aGlzLmdldFhTY3JvbGxiYXJXaWR0aCgpXG4gICAgbGV0IHsgY2hpbGRyZW4gfSA9IGVsXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsZXQgY2hpbGRFbCA9IGNoaWxkcmVuW2ldXG5cbiAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA+IHJlYWxDbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGdldFhTY3JvbGxiYXJXaWR0aCgpIHtcbiAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WCkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVsLm9mZnNldEhlaWdodCAtIHRoaXMuZWwuY2xpZW50SGVpZ2h0IC8vIG9ubHkgd29ya3MgYmVjYXVzZSB3ZSBndWFyYW50ZWUgbm8gYm9yZGVycy4gVE9ETzogYWRkIHRvIENTUyB3aXRoIGltcG9ydGFudD9cbiAgfVxuXG4gIGdldFlTY3JvbGxiYXJXaWR0aCgpIHtcbiAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WSkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVsLm9mZnNldFdpZHRoIC0gdGhpcy5lbC5jbGllbnRXaWR0aCAvLyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlIG5vIGJvcmRlcnMuIFRPRE86IGFkZCB0byBDU1Mgd2l0aCBpbXBvcnRhbnQ/XG4gIH1cbn1cbiIsImltcG9ydCB7IGhhc2hWYWx1ZXNUb0FycmF5LCBjb2xsZWN0RnJvbUhhc2ggfSBmcm9tICcuL29iamVjdCdcblxuLypcblRPRE86IHNvbWVob3cgaW5mZXIgT3RoZXJBcmdzIGZyb20gbWFzdGVyQ2FsbGJhY2s/XG5UT0RPOiBpbmZlciBSZWZUeXBlIGZyb20gbWFzdGVyQ2FsbGJhY2sgaWYgcHJvdmlkZWRcbiovXG5leHBvcnQgY2xhc3MgUmVmTWFwPFJlZlR5cGU+IHtcbiAgcHVibGljIGN1cnJlbnRNYXA6IHsgW2tleTogc3RyaW5nXTogUmVmVHlwZSB9ID0ge31cbiAgcHJpdmF0ZSBkZXB0aHM6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7fVxuICBwcml2YXRlIGNhbGxiYWNrTWFwOiB7IFtrZXk6IHN0cmluZ106ICh2YWw6IFJlZlR5cGUgfCBudWxsKSA9PiB2b2lkIH0gPSB7fVxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBtYXN0ZXJDYWxsYmFjaz86ICh2YWw6IFJlZlR5cGUgfCBudWxsLCBrZXk6IHN0cmluZykgPT4gdm9pZCkge1xuICB9XG5cbiAgY3JlYXRlUmVmKGtleTogc3RyaW5nIHwgbnVtYmVyKSB7XG4gICAgbGV0IHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldXG5cbiAgICBpZiAoIXJlZkNhbGxiYWNrKSB7XG4gICAgICByZWZDYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tNYXBba2V5XSA9ICh2YWw6IFJlZlR5cGUgfCBudWxsKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlVmFsdWUodmFsLCBTdHJpbmcoa2V5KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVmQ2FsbGJhY2tcbiAgfVxuXG4gIGhhbmRsZVZhbHVlID0gKHZhbDogUmVmVHlwZSB8IG51bGwsIGtleTogc3RyaW5nKSA9PiB7IC8vIGJpbmQgaW4gY2FzZSB1c2VycyB3YW50IHRvIHBhc3MgaXQgYXJvdW5kXG4gICAgbGV0IHsgZGVwdGhzLCBjdXJyZW50TWFwIH0gPSB0aGlzXG4gICAgbGV0IHJlbW92ZWQgPSBmYWxzZVxuICAgIGxldCBhZGRlZCA9IGZhbHNlXG5cbiAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICAvLyBmb3IgYnVnLi4uIEFDVFVBTExZOiBjYW4gcHJvYmFibHkgZG8gYXdheSB3aXRoIHRoaXMgbm93IHRoYXQgY2FsbGVycyBkb24ndCBzaGFyZSBudW1lcmljIGluZGljZXMgYW55bW9yZVxuICAgICAgcmVtb3ZlZCA9IChrZXkgaW4gY3VycmVudE1hcClcblxuICAgICAgY3VycmVudE1hcFtrZXldID0gdmFsXG4gICAgICBkZXB0aHNba2V5XSA9IChkZXB0aHNba2V5XSB8fCAwKSArIDFcbiAgICAgIGFkZGVkID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkZXB0aHNba2V5XSAtPSAxXG5cbiAgICAgIGlmICghZGVwdGhzW2tleV0pIHtcbiAgICAgICAgZGVsZXRlIGN1cnJlbnRNYXBba2V5XVxuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja01hcFtrZXldXG4gICAgICAgIHJlbW92ZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFzdGVyQ2FsbGJhY2spIHtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHRoaXMubWFzdGVyQ2FsbGJhY2sobnVsbCwgU3RyaW5nKGtleSkpXG4gICAgICB9XG4gICAgICBpZiAoYWRkZWQpIHtcbiAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayh2YWwsIFN0cmluZyhrZXkpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IGNoZWNrIGNhbGxlcnMgdGhhdCBkb24ndCBjYXJlIGFib3V0IG9yZGVyLiBzaG91bGQgdXNlIGdldEFsbCBpbnN0ZWFkXG4gIC8vIE5PVEU6IHRoaXMgbWV0aG9kIGhhcyBiZWNvbWUgbGVzcyB2YWx1YWJsZSBub3cgdGhhdCB3ZSBhcmUgZW5jb3VyYWdlZCB0byBtYXAgb3JkZXIgYnkgc29tZSBvdGhlciBpbmRleFxuICAvLyBUT0RPOiBwcm92aWRlIE9ORSBhcnJheS1leHBvcnQgZnVuY3Rpb24sIGJ1aWxkQXJyYXksIHdoaWNoIGZhaWxzIG9uIG5vbi1udW1lcmljIGluZGV4ZXMuIGNhbGxlciBjYW4gbWFuaXB1bGF0ZSBhbmQgXCJjb2xsZWN0XCJcbiAgY29sbGVjdChcbiAgICBzdGFydEluZGV4PzogbnVtYmVyLFxuICAgIGVuZEluZGV4PzogbnVtYmVyLFxuICAgIHN0ZXA/OiBudW1iZXIsXG4gICkge1xuICAgIHJldHVybiBjb2xsZWN0RnJvbUhhc2godGhpcy5jdXJyZW50TWFwLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcClcbiAgfVxuXG4gIGdldEFsbCgpOiBSZWZUeXBlW10geyAvLyByZXR1cm5zIGluIG5vIHBhcnRpY2FsIG9yZGVyIVxuICAgIHJldHVybiBoYXNoVmFsdWVzVG9BcnJheSh0aGlzLmN1cnJlbnRNYXApXG4gIH1cbn1cbiIsImltcG9ydCB7IFZOb2RlLCBjcmVhdGVFbGVtZW50LCBSZWYgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgZmluZEVsZW1lbnRzIH0gZnJvbSAnLi4vdXRpbC9kb20tbWFuaXAnXG5pbXBvcnQgeyBWaWV3Q29udGV4dCB9IGZyb20gJy4uL1ZpZXdDb250ZXh0J1xuaW1wb3J0IHsgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoIH0gZnJvbSAnLi4vdXRpbC9taXNjJ1xuaW1wb3J0IHsgaXNQcm9wc0VxdWFsIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBpc0FycmF5c0VxdWFsIH0gZnJvbSAnLi4vdXRpbC9hcnJheSdcbmltcG9ydCB7IEJhc2VPcHRpb25zUmVmaW5lZCB9IGZyb20gJy4uL29wdGlvbnMnXG5cbmV4cG9ydCB0eXBlIENzc0RpbVZhbHVlID0gc3RyaW5nIHwgbnVtYmVyIC8vIFRPRE86IG1vdmUgdG8gbW9yZSBnZW5lcmFsIGZpbGVcblxuZXhwb3J0IGludGVyZmFjZSBDb2xQcm9wcyB7XG4gIHdpZHRoPzogQ3NzRGltVmFsdWVcbiAgbWluV2lkdGg/OiBDc3NEaW1WYWx1ZVxuICBzcGFuPzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VjdGlvbkNvbmZpZyB7XG4gIG91dGVyQ29udGVudD86IFZOb2RlXG4gIHR5cGU6ICdib2R5JyB8ICdoZWFkZXInIHwgJ2Zvb3RlcidcbiAgY2xhc3NOYW1lPzogc3RyaW5nXG4gIG1heEhlaWdodD86IG51bWJlclxuICBsaXF1aWQ/OiBib29sZWFuXG4gIGV4cGFuZFJvd3M/OiBib29sZWFuIC8vIFRPRE86IGhvdyB0byBnZXQgYSBib3R0b20gcnVsZT9cbiAgc3luY1Jvd0hlaWdodHM/OiBib29sZWFuIC8vIHl1Y2tcbiAgaXNTdGlja3k/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIENodW5rQ29uZmlnQ29udGVudCA9IChjb250ZW50UHJvcHM6IENodW5rQ29udGVudENhbGxiYWNrQXJncykgPT4gVk5vZGVcbmV4cG9ydCB0eXBlIENodW5rQ29uZmlnUm93Q29udGVudCA9IFZOb2RlIHwgQ2h1bmtDb25maWdDb250ZW50XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2h1bmtDb25maWcge1xuICBvdXRlckNvbnRlbnQ/OiBWTm9kZVxuICBjb250ZW50PzogQ2h1bmtDb25maWdDb250ZW50XG4gIHJvd0NvbnRlbnQ/OiBDaHVua0NvbmZpZ1Jvd0NvbnRlbnRcbiAgc2Nyb2xsZXJFbFJlZj86IFJlZjxIVE1MRGl2RWxlbWVudD5cbiAgZWxSZWY/OiBSZWY8SFRNTFRhYmxlQ2VsbEVsZW1lbnQ+XG4gIHRhYmxlQ2xhc3NOYW1lPzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2h1bmtDb250ZW50Q2FsbGJhY2tBcmdzIHsgLy8gVE9ETzogdXRpbCBmb3Igd3JhcHBpbmcgdGFibGVzIT9cbiAgdGFibGVDb2xHcm91cE5vZGU6IFZOb2RlXG4gIHRhYmxlTWluV2lkdGg6IENzc0RpbVZhbHVlXG4gIGNsaWVudFdpZHRoOiBudW1iZXIgfCBudWxsIC8vIGltcG9ydGFudCB0byBrbm93IHdoZXRoZXIgMCBvciBub3QteWV0LWRldGVybWluZWQuIGZvciBoZWFkbGVzcyB0ZXN0aW5nXG4gIGNsaWVudEhlaWdodDogbnVtYmVyIHwgbnVsbCAvL1xuICBleHBhbmRSb3dzOiBib29sZWFuXG4gIHN5bmNSb3dIZWlnaHRzOiBib29sZWFuXG4gIHJvd1N5bmNIZWlnaHRzOiBudW1iZXJbXVxuICByZXBvcnRSb3dIZWlnaHRDaGFuZ2U6IChyb3dFbDogSFRNTEVsZW1lbnQsIGlzU3RhYmxlOiBib29sZWFuKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU2hyaW5rV2lkdGgoY2h1bmtFbHM6IEhUTUxFbGVtZW50W10pIHsgLy8gYWxsIGluIHNhbWUgQ09MIVxuICBsZXQgc2hyaW5rQ2VsbHMgPSBmaW5kRWxlbWVudHMoY2h1bmtFbHMsICcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnKVxuICBsZXQgbGFyZ2VzdFdpZHRoID0gMFxuXG4gIGZvciAobGV0IHNocmlua0NlbGwgb2Ygc2hyaW5rQ2VsbHMpIHtcbiAgICBsYXJnZXN0V2lkdGggPSBNYXRoLm1heChcbiAgICAgIGxhcmdlc3RXaWR0aCxcbiAgICAgIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChzaHJpbmtDZWxsKSxcbiAgICApXG4gIH1cblxuICByZXR1cm4gTWF0aC5jZWlsKGxhcmdlc3RXaWR0aCkgLy8gPHRhYmxlPiBlbGVtZW50cyB3b3JrIGJlc3Qgd2l0aCBpbnRlZ2Vycy4gcm91bmQgdXAgdG8gZW5zdXJlIGNvbnRlbnRzIGZpdHNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY3JvbGxlckxpa2UgeyAvLyBoYXZlIHNjcm9sbGVycyBpbXBsZW1lbnQ/XG4gIG5lZWRzWVNjcm9sbGluZygpOiBib29sZWFuXG4gIG5lZWRzWFNjcm9sbGluZygpOiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzOiB7IGxpcXVpZDogYm9vbGVhbiB9LCBzZWN0aW9uQ29uZmlnOiBTZWN0aW9uQ29uZmlnKSB7XG4gIHJldHVybiBwcm9wcy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQgLy8gZG9lcyB0aGUgc2VjdGlvbiBkbyBsaXF1aWQtaGVpZ2h0PyAobmVlZCB0byBoYXZlIHdob2xlIHNjcm9sbGdyaWQgbGlxdWlkLWhlaWdodCBhcyB3ZWxsKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzOiB7IGxpcXVpZDogYm9vbGVhbiB9LCBzZWN0aW9uQ29uZmlnOiBTZWN0aW9uQ29uZmlnKSB7XG4gIHJldHVybiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCAhPSBudWxsIHx8IC8vIGlmIGl0cyBwb3NzaWJsZSBmb3IgdGhlIGhlaWdodCB0byBtYXggb3V0LCB3ZSBtaWdodCBuZWVkIHNjcm9sbGJhcnNcbiAgICBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKSAvLyBpZiB0aGUgc2VjdGlvbiBpcyBsaXF1aWQgaGVpZ2h0LCBpdCBtaWdodCBjb25kZW5zZSBlbm91Z2ggdG8gcmVxdWlyZSBzY3JvbGxiYXJzXG59XG5cbi8vIFRPRE86IE9OTFkgdXNlIGBhcmdgLiBmb3JjZSBvdXQgaW50ZXJuYWwgZnVuY3Rpb24gdG8gdXNlIHNhbWUgQVBJXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyQ2h1bmtDb250ZW50KHNlY3Rpb25Db25maWc6IFNlY3Rpb25Db25maWcsIGNodW5rQ29uZmlnOiBDaHVua0NvbmZpZywgYXJnOiBDaHVua0NvbnRlbnRDYWxsYmFja0FyZ3MpIHtcbiAgbGV0IHsgZXhwYW5kUm93cyB9ID0gYXJnXG5cbiAgbGV0IGNvbnRlbnQ6IFZOb2RlID0gdHlwZW9mIGNodW5rQ29uZmlnLmNvbnRlbnQgPT09ICdmdW5jdGlvbicgP1xuICAgIGNodW5rQ29uZmlnLmNvbnRlbnQoYXJnKSA6XG4gICAgY3JlYXRlRWxlbWVudCgndGFibGUnLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFtcbiAgICAgICAgICBjaHVua0NvbmZpZy50YWJsZUNsYXNzTmFtZSxcbiAgICAgICAgICBzZWN0aW9uQ29uZmlnLnN5bmNSb3dIZWlnaHRzID8gJ2ZjLXNjcm9sbGdyaWQtc3luYy10YWJsZScgOiAnJyxcbiAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgbWluV2lkdGg6IGFyZy50YWJsZU1pbldpZHRoLCAvLyBiZWNhdXNlIGNvbE1pbldpZHRocyBhcmVudCBlbm91Z2hcbiAgICAgICAgICB3aWR0aDogYXJnLmNsaWVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IGFyZy5jbGllbnRIZWlnaHQgOiAnJywgLy8gY3NzIGBoZWlnaHRgIG9uIGEgPHRhYmxlPiBzZXJ2ZXMgYXMgYSBtaW4taGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgYXJnLnRhYmxlQ29sR3JvdXBOb2RlLFxuICAgICAgY3JlYXRlRWxlbWVudCgndGJvZHknLCB7fSwgdHlwZW9mIGNodW5rQ29uZmlnLnJvd0NvbnRlbnQgPT09ICdmdW5jdGlvbicgPyBjaHVua0NvbmZpZy5yb3dDb250ZW50KGFyZykgOiBjaHVua0NvbmZpZy5yb3dDb250ZW50KSlcblxuICByZXR1cm4gY29udGVudFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDb2xQcm9wc0VxdWFsKGNvbHMwOiBDb2xQcm9wc1tdLCBjb2xzMTogQ29sUHJvcHNbXSkge1xuICByZXR1cm4gaXNBcnJheXNFcXVhbChjb2xzMCwgY29sczEsIGlzUHJvcHNFcXVhbClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlck1pY3JvQ29sR3JvdXAoY29sczogQ29sUHJvcHNbXSwgc2hyaW5rV2lkdGg/OiBudW1iZXIpOiBWTm9kZSB7XG4gIGxldCBjb2xOb2RlczogVk5vZGVbXSA9IFtdXG5cbiAgLypcbiAgZm9yIENvbFByb3BzIHdpdGggc3BhbnMsIGl0IHdvdWxkIGhhdmUgYmVlbiBncmVhdCB0byBtYWtlIGEgc2luZ2xlIDxjb2wgc3Bhbj1cIlwiPlxuICBIT1dFVkVSLCBDaHJvbWUgd2FzIGdldHRpbmcgbWVzc2luZyB1cCBkaXN0cmlidXRpbmcgdGhlIHdpZHRoIHRvIDx0ZD4vPHRoPiBlbGVtZW50cyB3aXRoIGNvbHNwYW5zLlxuICBTT0xVVElPTjogbWFraW5nIGluZGl2aWR1YWwgPGNvbD4gZWxlbWVudHMgbWFrZXMgQ2hyb21lIGJlaGF2ZS5cbiAgKi9cbiAgZm9yIChsZXQgY29sUHJvcHMgb2YgY29scykge1xuICAgIGxldCBzcGFuID0gY29sUHJvcHMuc3BhbiB8fCAxXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW47IGkgKz0gMSkge1xuICAgICAgY29sTm9kZXMucHVzaChcbiAgICAgICAgPGNvbFxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICB3aWR0aDogY29sUHJvcHMud2lkdGggPT09ICdzaHJpbmsnID8gc2FuaXRpemVTaHJpbmtXaWR0aChzaHJpbmtXaWR0aCkgOiAoY29sUHJvcHMud2lkdGggfHwgJycpLFxuICAgICAgICAgICAgbWluV2lkdGg6IGNvbFByb3BzLm1pbldpZHRoIHx8ICcnLFxuICAgICAgICAgIH19XG4gICAgICAgIC8+LFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50KCdjb2xncm91cCcsIHt9LCAuLi5jb2xOb2Rlcylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplU2hyaW5rV2lkdGgoc2hyaW5rV2lkdGg/OiBudW1iZXIpIHtcbiAgLyogd2h5IDQ/IGlmIHdlIGRvIDAsIGl0IHdpbGwga2lsbCBhbnkgYm9yZGVyLCB3aGljaCBhcmUgbmVlZGVkIGZvciBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGhcbiAgNCBhY2NvdW50cyBmb3IgMiAyLXBpeGVsIGJvcmRlcnMuIFRPRE86IGJldHRlciBzb2x1dGlvbj8gKi9cbiAgcmV0dXJuIHNocmlua1dpZHRoID09IG51bGwgPyA0IDogc2hyaW5rV2lkdGhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1Nocmlua1dpZHRoKGNvbHM6IENvbFByb3BzW10pIHtcbiAgZm9yIChsZXQgY29sIG9mIGNvbHMpIHtcbiAgICBpZiAoY29sLndpZHRoID09PSAnc2hyaW5rJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKGxpcXVpZDogYm9vbGVhbiwgY29udGV4dDogVmlld0NvbnRleHQpIHtcbiAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgJ2ZjLXNjcm9sbGdyaWQnLFxuICAgIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksXG4gIF1cblxuICBpZiAobGlxdWlkKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLWxpcXVpZCcpXG4gIH1cblxuICByZXR1cm4gY2xhc3NOYW1lc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZzogU2VjdGlvbkNvbmZpZywgd2hvbGVUYWJsZVZHcm93OiBib29sZWFuKSB7XG4gIGxldCBjbGFzc05hbWVzID0gW1xuICAgICdmYy1zY3JvbGxncmlkLXNlY3Rpb24nLFxuICAgIGBmYy1zY3JvbGxncmlkLXNlY3Rpb24tJHtzZWN0aW9uQ29uZmlnLnR5cGV9YCxcbiAgICBzZWN0aW9uQ29uZmlnLmNsYXNzTmFtZSwgLy8gdXNlZD9cbiAgXVxuXG4gIGlmICh3aG9sZVRhYmxlVkdyb3cgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQgPT0gbnVsbCkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWxpcXVpZCcpXG4gIH1cblxuICBpZiAoc2VjdGlvbkNvbmZpZy5pc1N0aWNreSkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreScpXG4gIH1cblxuICByZXR1cm4gY2xhc3NOYW1lc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyU2Nyb2xsU2hpbShhcmc6IENodW5rQ29udGVudENhbGxiYWNrQXJncykge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cImZjLXNjcm9sbGdyaWQtc3RpY2t5LXNoaW1cIlxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgbWluV2lkdGg6IGFyZy50YWJsZU1pbldpZHRoLFxuICAgICAgfX1cbiAgICAvPlxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGlja3lIZWFkZXJEYXRlcyhvcHRpb25zOiBCYXNlT3B0aW9uc1JlZmluZWQpIHtcbiAgbGV0IHsgc3RpY2t5SGVhZGVyRGF0ZXMgfSA9IG9wdGlvbnNcblxuICBpZiAoc3RpY2t5SGVhZGVyRGF0ZXMgPT0gbnVsbCB8fCBzdGlja3lIZWFkZXJEYXRlcyA9PT0gJ2F1dG8nKSB7XG4gICAgc3RpY2t5SGVhZGVyRGF0ZXMgPSBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMudmlld0hlaWdodCA9PT0gJ2F1dG8nXG4gIH1cblxuICByZXR1cm4gc3RpY2t5SGVhZGVyRGF0ZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihvcHRpb25zOiBCYXNlT3B0aW9uc1JlZmluZWQpIHtcbiAgbGV0IHsgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIH0gPSBvcHRpb25zXG5cbiAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhciA9PSBudWxsIHx8IHN0aWNreUZvb3RlclNjcm9sbGJhciA9PT0gJ2F1dG8nKSB7XG4gICAgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLnZpZXdIZWlnaHQgPT09ICdhdXRvJ1xuICB9XG5cbiAgcmV0dXJuIHN0aWNreUZvb3RlclNjcm9sbGJhclxufVxuIiwiaW1wb3J0IHsgVk5vZGUsIGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IEJhc2VDb21wb25lbnQsIHNldFJlZiB9IGZyb20gJy4uL3Zkb20tdXRpbCdcbmltcG9ydCB7IFNjcm9sbGVyLCBPdmVyZmxvd1ZhbHVlIH0gZnJvbSAnLi9TY3JvbGxlcidcbmltcG9ydCB7IFJlZk1hcCB9IGZyb20gJy4uL3V0aWwvUmVmTWFwJ1xuaW1wb3J0IHtcbiAgQ29sUHJvcHMsIFNlY3Rpb25Db25maWcsIHJlbmRlck1pY3JvQ29sR3JvdXAsIGNvbXB1dGVTaHJpbmtXaWR0aCwgZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMsIGdldFNlY3Rpb25DbGFzc05hbWVzLCBnZXRBbGxvd1lTY3JvbGxpbmcsXG4gIHJlbmRlckNodW5rQ29udGVudCwgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodCwgQ2h1bmtDb25maWcsIGhhc1Nocmlua1dpZHRoLCBDc3NEaW1WYWx1ZSxcbiAgaXNDb2xQcm9wc0VxdWFsLFxufSBmcm9tICcuL3V0aWwnXG5pbXBvcnQgeyBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgfSBmcm9tICcuLi91dGlsL3RhYmxlLXN0eWxpbmcnXG5pbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnLi4vdXRpbC9tZW1vaXplJ1xuaW1wb3J0IHsgaXNQcm9wc0VxdWFsIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBnZXRTY3JvbGxiYXJXaWR0aHMgfSBmcm9tICcuLi91dGlsL3Njcm9sbGJhci13aWR0aCdcblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVTY3JvbGxHcmlkUHJvcHMge1xuICBjb2xzOiBDb2xQcm9wc1tdXG4gIHNlY3Rpb25zOiBTaW1wbGVTY3JvbGxHcmlkU2VjdGlvbltdXG4gIGxpcXVpZDogYm9vbGVhbiAvLyBsaXF1aWQgKmhlaWdodCpcbiAgY29sbGFwc2libGVXaWR0aDogYm9vbGVhbiAvLyBjYW4gQUxMIHNlY3Rpb25zIGJlIGZ1bGx5IGNvbGxhcHNlZCBpbiB3aWR0aD9cbiAgaGVpZ2h0PzogQ3NzRGltVmFsdWUgLy8gVE9ETzogZ2l2ZSB0byByZWFsIFNjcm9sbEdyaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVTY3JvbGxHcmlkU2VjdGlvbiBleHRlbmRzIFNlY3Rpb25Db25maWcge1xuICBrZXk6IHN0cmluZ1xuICBjaHVuaz86IENodW5rQ29uZmlnXG59XG5cbmludGVyZmFjZSBTaW1wbGVTY3JvbGxHcmlkU3RhdGUge1xuICBzaHJpbmtXaWR0aDogbnVtYmVyIHwgbnVsbFxuICBmb3JjZVlTY3JvbGxiYXJzOiBib29sZWFuXG4gIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9XG4gIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfVxufVxuXG5leHBvcnQgY2xhc3MgU2ltcGxlU2Nyb2xsR3JpZCBleHRlbmRzIEJhc2VDb21wb25lbnQ8U2ltcGxlU2Nyb2xsR3JpZFByb3BzLCBTaW1wbGVTY3JvbGxHcmlkU3RhdGU+IHtcbiAgcHJvY2Vzc0NvbHMgPSBtZW1vaXplKChhKSA9PiBhLCBpc0NvbFByb3BzRXF1YWwpIC8vIHNvIHdlIGdldCBzYW1lIGBjb2xzYCBwcm9wcyBldmVyeSB0aW1lXG5cbiAgLy8geXVja3kgdG8gbWVtb2l6ZSBWTm9kZXMsIGJ1dCBtdWNoIG1vcmUgZWZmaWNpZW50IGZvciBjb25zdW1lcnNcbiAgcmVuZGVyTWljcm9Db2xHcm91cDogdHlwZW9mIHJlbmRlck1pY3JvQ29sR3JvdXAgPSBtZW1vaXplKHJlbmRlck1pY3JvQ29sR3JvdXApXG5cbiAgc2Nyb2xsZXJSZWZzID0gbmV3IFJlZk1hcDxTY3JvbGxlcj4oKVxuICBzY3JvbGxlckVsUmVmcyA9IG5ldyBSZWZNYXA8SFRNTEVsZW1lbnQ+KHRoaXMuX2hhbmRsZVNjcm9sbGVyRWwuYmluZCh0aGlzKSlcblxuICBzdGF0ZTogU2ltcGxlU2Nyb2xsR3JpZFN0YXRlID0ge1xuICAgIHNocmlua1dpZHRoOiBudWxsLFxuICAgIGZvcmNlWVNjcm9sbGJhcnM6IGZhbHNlLFxuICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiB7fSxcbiAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IHt9LFxuICB9XG5cbiAgcmVuZGVyKCk6IFZOb2RlIHtcbiAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgc2VjdGlvbkNvbmZpZ3MgPSBwcm9wcy5zZWN0aW9ucyB8fCBbXVxuICAgIGxldCBjb2xzID0gdGhpcy5wcm9jZXNzQ29scyhwcm9wcy5jb2xzKVxuXG4gICAgbGV0IG1pY3JvQ29sR3JvdXBOb2RlID0gdGhpcy5yZW5kZXJNaWNyb0NvbEdyb3VwKGNvbHMsIHN0YXRlLnNocmlua1dpZHRoKVxuICAgIGxldCBjbGFzc05hbWVzID0gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMocHJvcHMubGlxdWlkLCBjb250ZXh0KVxuXG4gICAgaWYgKHByb3BzLmNvbGxhcHNpYmxlV2lkdGgpIHtcbiAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1jb2xsYXBzaWJsZScpXG4gICAgfVxuXG4gICAgLy8gVE9ETzogbWFrZSBEUllcbiAgICBsZXQgY29uZmlnQ250ID0gc2VjdGlvbkNvbmZpZ3MubGVuZ3RoXG4gICAgbGV0IGNvbmZpZ0kgPSAwXG4gICAgbGV0IGN1cnJlbnRDb25maWc6IFNpbXBsZVNjcm9sbEdyaWRTZWN0aW9uXG4gICAgbGV0IGhlYWRTZWN0aW9uTm9kZXM6IFZOb2RlW10gPSBbXVxuICAgIGxldCBib2R5U2VjdGlvbk5vZGVzOiBWTm9kZVtdID0gW11cbiAgICBsZXQgZm9vdFNlY3Rpb25Ob2RlczogVk5vZGVbXSA9IFtdXG5cbiAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnaGVhZGVyJykge1xuICAgICAgaGVhZFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSkpXG4gICAgICBjb25maWdJICs9IDFcbiAgICB9XG5cbiAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnYm9keScpIHtcbiAgICAgIGJvZHlTZWN0aW9uTm9kZXMucHVzaCh0aGlzLnJlbmRlclNlY3Rpb24oY3VycmVudENvbmZpZywgbWljcm9Db2xHcm91cE5vZGUpKVxuICAgICAgY29uZmlnSSArPSAxXG4gICAgfVxuXG4gICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2Zvb3RlcicpIHtcbiAgICAgIGZvb3RTZWN0aW9uTm9kZXMucHVzaCh0aGlzLnJlbmRlclNlY3Rpb24oY3VycmVudENvbmZpZywgbWljcm9Db2xHcm91cE5vZGUpKVxuICAgICAgY29uZmlnSSArPSAxXG4gICAgfVxuXG4gICAgLy8gZmlyZWZveCBidWc6IHdoZW4gc2V0dGluZyBoZWlnaHQgb24gdGFibGUgYW5kIHRoZXJlIGlzIGEgdGhlYWQgb3IgdGZvb3QsXG4gICAgLy8gdGhlIG5lY2Vzc2FyeSBoZWlnaHQ6MTAwJSBvbiB0aGUgbGlxdWlkLWhlaWdodCBib2R5IHNlY3Rpb24gZm9yY2VzIHRoZSAqd2hvbGUqIHRhYmxlIHRvIGJlIHRhbGxlci4gKGJ1ZyAjNTUyNClcbiAgICAvLyB1c2UgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIGFzIGEgd2F5IHRvIGRldGVjdCB0YWJsZS1zdHVwaWQgZmlyZWZveC5cbiAgICAvLyBpZiBzbywgdXNlIGEgc2ltcGxlciBkb20gc3RydWN0dXJlLCBqYW0gZXZlcnl0aGluZyBpbnRvIGEgbG9uZSB0Ym9keS5cbiAgICBsZXQgaXNCdWdneSA9ICFnZXRDYW5WR3Jvd1dpdGhpbkNlbGwoKVxuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICAndGFibGUnLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLFxuICAgICAgICBzdHlsZTogeyBoZWlnaHQ6IHByb3BzLmhlaWdodCB9LFxuICAgICAgfSxcbiAgICAgIEJvb2xlYW4oIWlzQnVnZ3kgJiYgaGVhZFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQoJ3RoZWFkJywge30sIC4uLmhlYWRTZWN0aW9uTm9kZXMpLFxuICAgICAgQm9vbGVhbighaXNCdWdneSAmJiBib2R5U2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgY3JlYXRlRWxlbWVudCgndGJvZHknLCB7fSwgLi4uYm9keVNlY3Rpb25Ob2RlcyksXG4gICAgICBCb29sZWFuKCFpc0J1Z2d5ICYmIGZvb3RTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50KCd0Zm9vdCcsIHt9LCAuLi5mb290U2VjdGlvbk5vZGVzKSxcbiAgICAgIGlzQnVnZ3kgJiYgY3JlYXRlRWxlbWVudCgndGJvZHknLCB7fSwgLi4uaGVhZFNlY3Rpb25Ob2RlcywgLi4uYm9keVNlY3Rpb25Ob2RlcywgLi4uZm9vdFNlY3Rpb25Ob2RlcyksXG4gICAgKVxuICB9XG5cbiAgcmVuZGVyU2VjdGlvbihzZWN0aW9uQ29uZmlnOiBTaW1wbGVTY3JvbGxHcmlkU2VjdGlvbiwgbWljcm9Db2xHcm91cE5vZGU6IFZOb2RlKSB7XG4gICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIHNlY3Rpb25Db25maWcpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxGcmFnbWVudCBrZXk9e3NlY3Rpb25Db25maWcua2V5fT5cbiAgICAgICAgICB7c2VjdGlvbkNvbmZpZy5vdXRlckNvbnRlbnR9XG4gICAgICAgIDwvRnJhZ21lbnQ+XG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0ciBrZXk9e3NlY3Rpb25Db25maWcua2V5fSBjbGFzc05hbWU9e2dldFNlY3Rpb25DbGFzc05hbWVzKHNlY3Rpb25Db25maWcsIHRoaXMucHJvcHMubGlxdWlkKS5qb2luKCcgJyl9PlxuICAgICAgICB7dGhpcy5yZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBzZWN0aW9uQ29uZmlnLmNodW5rKX1cbiAgICAgIDwvdHI+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyQ2h1bmtUZChzZWN0aW9uQ29uZmlnOiBTaW1wbGVTY3JvbGxHcmlkU2VjdGlvbiwgbWljcm9Db2xHcm91cE5vZGU6IFZOb2RlLCBjaHVua0NvbmZpZzogQ2h1bmtDb25maWcpIHtcbiAgICBpZiAoJ291dGVyQ29udGVudCcgaW4gY2h1bmtDb25maWcpIHtcbiAgICAgIHJldHVybiBjaHVua0NvbmZpZy5vdXRlckNvbnRlbnRcbiAgICB9XG5cbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCB7IGZvcmNlWVNjcm9sbGJhcnMsIHNjcm9sbGVyQ2xpZW50V2lkdGhzLCBzY3JvbGxlckNsaWVudEhlaWdodHMgfSA9IHRoaXMuc3RhdGVcblxuICAgIGxldCBuZWVkc1lTY3JvbGxpbmcgPSBnZXRBbGxvd1lTY3JvbGxpbmcocHJvcHMsIHNlY3Rpb25Db25maWcpIC8vIFRPRE86IGRvIGxhemlseS4gZG8gaW4gc2VjdGlvbiBjb25maWc/XG4gICAgbGV0IGlzTGlxdWlkID0gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZylcblxuICAgIC8vIGZvciBgIXByb3BzLmxpcXVpZGAgLSBpcyBXSE9MRSBzY3JvbGxncmlkIG5hdHVyYWwgaGVpZ2h0P1xuICAgIC8vIFRPRE86IGRvIHNhbWUgdGhpbmcgaW4gYWR2YW5jZWQgc2Nyb2xsZ3JpZD8gcHJvbGx5IG5vdCBiL2MgYWx3YXlzIGhhcyBob3Jpem9udGFsIHNjcm9sbGJhcnNcbiAgICBsZXQgb3ZlcmZsb3dZOiBPdmVyZmxvd1ZhbHVlID1cbiAgICAgICFwcm9wcy5saXF1aWQgPyAndmlzaWJsZScgOlxuICAgICAgICBmb3JjZVlTY3JvbGxiYXJzID8gJ3Njcm9sbCcgOlxuICAgICAgICAgICFuZWVkc1lTY3JvbGxpbmcgPyAnaGlkZGVuJyA6XG4gICAgICAgICAgICAnYXV0bydcblxuICAgIGxldCBzZWN0aW9uS2V5ID0gc2VjdGlvbkNvbmZpZy5rZXlcbiAgICBsZXQgY29udGVudCA9IHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywge1xuICAgICAgdGFibGVDb2xHcm91cE5vZGU6IG1pY3JvQ29sR3JvdXBOb2RlLFxuICAgICAgdGFibGVNaW5XaWR0aDogJycsXG4gICAgICBjbGllbnRXaWR0aDogKCFwcm9wcy5jb2xsYXBzaWJsZVdpZHRoICYmIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQpID8gc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gOiBudWxsLFxuICAgICAgY2xpZW50SGVpZ2h0OiBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCA/IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA6IG51bGwsXG4gICAgICBleHBhbmRSb3dzOiBzZWN0aW9uQ29uZmlnLmV4cGFuZFJvd3MsXG4gICAgICBzeW5jUm93SGVpZ2h0czogZmFsc2UsXG4gICAgICByb3dTeW5jSGVpZ2h0czogW10sXG4gICAgICByZXBvcnRSb3dIZWlnaHRDaGFuZ2U6ICgpID0+IHt9LFxuICAgIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgPHRkIHJlZj17Y2h1bmtDb25maWcuZWxSZWZ9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YGZjLXNjcm9sbGVyLWhhcm5lc3Mke2lzTGlxdWlkID8gJyBmYy1zY3JvbGxlci1oYXJuZXNzLWxpcXVpZCcgOiAnJ31gfT5cbiAgICAgICAgICA8U2Nyb2xsZXJcbiAgICAgICAgICAgIHJlZj17dGhpcy5zY3JvbGxlclJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpfVxuICAgICAgICAgICAgZWxSZWY9e3RoaXMuc2Nyb2xsZXJFbFJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpfVxuICAgICAgICAgICAgb3ZlcmZsb3dZPXtvdmVyZmxvd1l9XG4gICAgICAgICAgICBvdmVyZmxvd1g9eyFwcm9wcy5saXF1aWQgPyAndmlzaWJsZScgOiAnaGlkZGVuJyAvKiBuYXR1cmFsIGhlaWdodD8gKi99XG4gICAgICAgICAgICBtYXhIZWlnaHQ9e3NlY3Rpb25Db25maWcubWF4SGVpZ2h0fVxuICAgICAgICAgICAgbGlxdWlkPXtpc0xpcXVpZH1cbiAgICAgICAgICAgIGxpcXVpZElzQWJzb2x1dGUgLy8gYmVjYXVzZSBpdHMgd2l0aGluIGEgaGFybmVzc1xuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgIDwvU2Nyb2xsZXI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC90ZD5cbiAgICApXG4gIH1cblxuICBfaGFuZGxlU2Nyb2xsZXJFbChzY3JvbGxlckVsOiBIVE1MRWxlbWVudCB8IG51bGwsIGtleTogc3RyaW5nKSB7XG4gICAgbGV0IHNlY3Rpb24gPSBnZXRTZWN0aW9uQnlLZXkodGhpcy5wcm9wcy5zZWN0aW9ucywga2V5KVxuXG4gICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgIHNldFJlZihzZWN0aW9uLmNodW5rLnNjcm9sbGVyRWxSZWYsIHNjcm9sbGVyRWwpXG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogY2FuIGRvIGEgcmVhbGx5IHNpbXBsZSBwcmludC12aWV3LiBkb250IG5lZWQgdG8gam9pbiByb3dzXG4gIGhhbmRsZVNpemluZyA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNocmlua1dpZHRoOiB0aGlzLmNvbXB1dGVTaHJpbmtXaWR0aCgpLCAvLyB3aWxsIGNyZWF0ZSBlYWNoIGNodW5rJ3MgPGNvbGdyb3VwPi4gVE9ETzogcHJlY29tcHV0ZSBoYXNTaHJpbmtXaWR0aFxuICAgICAgLi4udGhpcy5jb21wdXRlU2Nyb2xsZXJEaW1zKCksXG4gICAgfSlcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuaGFuZGxlU2l6aW5nKClcbiAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVNpemluZylcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAvLyBUT0RPOiBuZWVkIGJldHRlciBzb2x1dGlvbiB3aGVuIHN0YXRlIGNvbnRhaW5zIG5vbi1zaXppbmcgdGhpbmdzXG4gICAgdGhpcy5oYW5kbGVTaXppbmcoKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpXG4gIH1cblxuICBjb21wdXRlU2hyaW5rV2lkdGgoKSB7XG4gICAgcmV0dXJuIGhhc1Nocmlua1dpZHRoKHRoaXMucHJvcHMuY29scylcbiAgICAgID8gY29tcHV0ZVNocmlua1dpZHRoKHRoaXMuc2Nyb2xsZXJFbFJlZnMuZ2V0QWxsKCkpXG4gICAgICA6IDBcbiAgfVxuXG4gIGNvbXB1dGVTY3JvbGxlckRpbXMoKSB7XG4gICAgbGV0IHNjcm9sbGJhcldpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGhzKClcbiAgICBsZXQgeyBzY3JvbGxlclJlZnMsIHNjcm9sbGVyRWxSZWZzIH0gPSB0aGlzXG5cbiAgICBsZXQgZm9yY2VZU2Nyb2xsYmFycyA9IGZhbHNlXG4gICAgbGV0IHNjcm9sbGVyQ2xpZW50V2lkdGhzOiB7IFtpbmRleDogc3RyaW5nXTogbnVtYmVyIH0gPSB7fVxuICAgIGxldCBzY3JvbGxlckNsaWVudEhlaWdodHM6IHsgW2luZGV4OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9XG5cbiAgICBmb3IgKGxldCBzZWN0aW9uS2V5IGluIHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwKSB7XG4gICAgICBsZXQgc2Nyb2xsZXIgPSBzY3JvbGxlclJlZnMuY3VycmVudE1hcFtzZWN0aW9uS2V5XVxuXG4gICAgICBpZiAoc2Nyb2xsZXIgJiYgc2Nyb2xsZXIubmVlZHNZU2Nyb2xsaW5nKCkpIHtcbiAgICAgICAgZm9yY2VZU2Nyb2xsYmFycyA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBzZWN0aW9uIG9mIHRoaXMucHJvcHMuc2VjdGlvbnMpIHtcbiAgICAgIGxldCBzZWN0aW9uS2V5ID0gc2VjdGlvbi5rZXlcbiAgICAgIGxldCBzY3JvbGxlckVsID0gc2Nyb2xsZXJFbFJlZnMuY3VycmVudE1hcFtzZWN0aW9uS2V5XVxuXG4gICAgICBpZiAoc2Nyb2xsZXJFbCkge1xuICAgICAgICBsZXQgaGFybmVzc0VsID0gc2Nyb2xsZXJFbC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50IC8vIFRPRE86IHdlaXJkIHdheSB0byBnZXQgdGhpcy4gbmVlZCBoYXJuZXNzIGIvYyBkb2Vzbid0IGluY2x1ZGUgdGFibGUgYm9yZGVyc1xuXG4gICAgICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldID0gTWF0aC5mbG9vcihcbiAgICAgICAgICBoYXJuZXNzRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSAoXG4gICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzXG4gICAgICAgICAgICAgID8gc2Nyb2xsYmFyV2lkdGgueSAvLyB1c2UgZ2xvYmFsIGJlY2F1c2Ugc2Nyb2xsZXIgbWlnaHQgbm90IGhhdmUgc2Nyb2xsYmFycyB5ZXQgYnV0IHdpbGwgbmVlZCB0aGVtIGluIGZ1dHVyZVxuICAgICAgICAgICAgICA6IDBcbiAgICAgICAgICApLFxuICAgICAgICApXG5cbiAgICAgICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldID0gTWF0aC5mbG9vcihcbiAgICAgICAgICBoYXJuZXNzRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LCAvLyBuZXZlciBoYXMgaG9yaXpvbnRhbCBzY3JvbGxiYXJzXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBmb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzIH1cbiAgfVxufVxuXG5TaW1wbGVTY3JvbGxHcmlkLmFkZFN0YXRlRXF1YWxpdHkoe1xuICBzY3JvbGxlckNsaWVudFdpZHRoczogaXNQcm9wc0VxdWFsLFxuICBzY3JvbGxlckNsaWVudEhlaWdodHM6IGlzUHJvcHNFcXVhbCxcbn0pXG5cbmZ1bmN0aW9uIGdldFNlY3Rpb25CeUtleShzZWN0aW9uczogU2ltcGxlU2Nyb2xsR3JpZFNlY3Rpb25bXSwga2V5OiBzdHJpbmcpOiBTaW1wbGVTY3JvbGxHcmlkU2VjdGlvbiB8IG51bGwge1xuICBmb3IgKGxldCBzZWN0aW9uIG9mIHNlY3Rpb25zKSB7XG4gICAgaWYgKHNlY3Rpb24ua2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBzZWN0aW9uXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiIsImltcG9ydCB7IFNlZyB9IGZyb20gJy4uL2NvbXBvbmVudC9EYXRlQ29tcG9uZW50J1xuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUVsZW1lbnQsIFJlZiwgY3JlYXRlUmVmLCBSZWZPYmplY3QgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgRXZlbnRBcGkgfSBmcm9tICcuLi9hcGkvRXZlbnRBcGknXG5pbXBvcnQge1xuICBjb21wdXRlU2VnRHJhZ2dhYmxlLFxuICBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUsXG4gIGNvbXB1dGVTZWdFbmRSZXNpemFibGUsXG4gIHNldEVsU2VnLFxuICBFdmVudENvbnRlbnRBcmcsXG4gIGdldEV2ZW50Q2xhc3NOYW1lcyxcbn0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IFJlbmRlckhvb2sgfSBmcm9tICcuL3JlbmRlci1ob29rJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL3Zkb20tdXRpbCdcblxuZXhwb3J0IGludGVyZmFjZSBNaW5pbWFsRXZlbnRQcm9wcyB7XG4gIHNlZzogU2VnXG4gIGlzRHJhZ2dpbmc6IGJvb2xlYW4gLy8gcmVuYW1lIHRvIGlzTWlycm9yRHJhZ2dpbmc/IG1ha2Ugb3B0aW9uYWw/XG4gIGlzUmVzaXppbmc6IGJvb2xlYW4gLy8gcmVuYW1lIHRvIGlzTWlycm9yUmVzaXppbmc/IG1ha2Ugb3B0aW9uYWw/XG4gIGlzRGF0ZVNlbGVjdGluZzogYm9vbGVhbiAvLyByZW5hbWUgdG8gaXNNaXJyb3JEYXRlU2VsZWN0aW5nPyBtYWtlIG9wdGlvbmFsP1xuICBpc1NlbGVjdGVkOiBib29sZWFuXG4gIGlzUGFzdDogYm9vbGVhblxuICBpc0Z1dHVyZTogYm9vbGVhblxuICBpc1RvZGF5OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRSb290UHJvcHMgZXh0ZW5kcyBNaW5pbWFsRXZlbnRQcm9wcyB7XG4gIHRpbWVUZXh0OiBzdHJpbmdcbiAgZGlzYWJsZURyYWdnaW5nPzogYm9vbGVhblxuICBkaXNhYmxlUmVzaXppbmc/OiBib29sZWFuXG4gIGRlZmF1bHRDb250ZW50OiAoaG9va1Byb3BzOiBFdmVudENvbnRlbnRBcmcpID0+IENvbXBvbmVudENoaWxkcmVuXG4gIGNoaWxkcmVuOiAoXG4gICAgcm9vdEVsUmVmOiBSZWY8YW55PixcbiAgICBjbGFzc05hbWVzOiBzdHJpbmdbXSxcbiAgICBpbm5lckVsUmVmOiBSZWY8YW55PixcbiAgICBpbm5lckNvbnRlbnQ6IENvbXBvbmVudENoaWxkcmVuLFxuICAgIGhvb2tQcm9wczogRXZlbnRDb250ZW50QXJnXG4gICkgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbn1cblxuZXhwb3J0IGNsYXNzIEV2ZW50Um9vdCBleHRlbmRzIEJhc2VDb21wb25lbnQ8RXZlbnRSb290UHJvcHM+IHtcbiAgZWxSZWY6IFJlZk9iamVjdDxIVE1MRWxlbWVudD4gPSBjcmVhdGVSZWY8SFRNTEVsZW1lbnQ+KClcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0XG4gICAgbGV0IHsgc2VnIH0gPSBwcm9wc1xuICAgIGxldCB7IGV2ZW50UmFuZ2UgfSA9IHNlZ1xuICAgIGxldCB7IHVpIH0gPSBldmVudFJhbmdlXG5cbiAgICBsZXQgaG9va1Byb3BzOiBFdmVudENvbnRlbnRBcmcgPSB7XG4gICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbnRleHQsIGV2ZW50UmFuZ2UuZGVmLCBldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgIHRpbWVUZXh0OiBwcm9wcy50aW1lVGV4dCxcbiAgICAgIHRleHRDb2xvcjogdWkudGV4dENvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB1aS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJDb2xvcjogdWkuYm9yZGVyQ29sb3IsXG4gICAgICBpc0RyYWdnYWJsZTogIXByb3BzLmRpc2FibGVEcmFnZ2luZyAmJiBjb21wdXRlU2VnRHJhZ2dhYmxlKHNlZywgY29udGV4dCksXG4gICAgICBpc1N0YXJ0UmVzaXphYmxlOiAhcHJvcHMuZGlzYWJsZVJlc2l6aW5nICYmIGNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZShzZWcsIGNvbnRleHQpLFxuICAgICAgaXNFbmRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcsIGNvbnRleHQpLFxuICAgICAgaXNNaXJyb3I6IEJvb2xlYW4ocHJvcHMuaXNEcmFnZ2luZyB8fCBwcm9wcy5pc1Jlc2l6aW5nIHx8IHByb3BzLmlzRGF0ZVNlbGVjdGluZyksXG4gICAgICBpc1N0YXJ0OiBCb29sZWFuKHNlZy5pc1N0YXJ0KSxcbiAgICAgIGlzRW5kOiBCb29sZWFuKHNlZy5pc0VuZCksXG4gICAgICBpc1Bhc3Q6IEJvb2xlYW4ocHJvcHMuaXNQYXN0KSwgLy8gVE9ETzogZG9uJ3QgY2FzdC4gZ2V0RGF0ZU1ldGEgZG9lcyBpdFxuICAgICAgaXNGdXR1cmU6IEJvb2xlYW4ocHJvcHMuaXNGdXR1cmUpLCAvLyBUT0RPOiBkb24ndCBjYXN0LiBnZXREYXRlTWV0YSBkb2VzIGl0XG4gICAgICBpc1RvZGF5OiBCb29sZWFuKHByb3BzLmlzVG9kYXkpLCAvLyBUT0RPOiBkb24ndCBjYXN0LiBnZXREYXRlTWV0YSBkb2VzIGl0XG4gICAgICBpc1NlbGVjdGVkOiBCb29sZWFuKHByb3BzLmlzU2VsZWN0ZWQpLFxuICAgICAgaXNEcmFnZ2luZzogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nKSxcbiAgICAgIGlzUmVzaXppbmc6IEJvb2xlYW4ocHJvcHMuaXNSZXNpemluZyksXG4gICAgfVxuXG4gICAgbGV0IHN0YW5kYXJkQ2xhc3NOYW1lcyA9IGdldEV2ZW50Q2xhc3NOYW1lcyhob29rUHJvcHMpLmNvbmNhdCh1aS5jbGFzc05hbWVzKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxSZW5kZXJIb29rXG4gICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICBjbGFzc05hbWVzPXtvcHRpb25zLmV2ZW50Q2xhc3NOYW1lc31cbiAgICAgICAgY29udGVudD17b3B0aW9ucy5ldmVudENvbnRlbnR9XG4gICAgICAgIGRlZmF1bHRDb250ZW50PXtwcm9wcy5kZWZhdWx0Q29udGVudH1cbiAgICAgICAgZGlkTW91bnQ9e29wdGlvbnMuZXZlbnREaWRNb3VudH1cbiAgICAgICAgd2lsbFVubW91bnQ9e29wdGlvbnMuZXZlbnRXaWxsVW5tb3VudH1cbiAgICAgICAgZWxSZWY9e3RoaXMuZWxSZWZ9XG4gICAgICA+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpID0+IHByb3BzLmNoaWxkcmVuKFxuICAgICAgICAgIHJvb3RFbFJlZiwgc3RhbmRhcmRDbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKSwgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCBob29rUHJvcHMsXG4gICAgICAgICl9XG4gICAgICA8L1JlbmRlckhvb2s+XG4gICAgKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgc2V0RWxTZWcodGhpcy5lbFJlZi5jdXJyZW50LCB0aGlzLnByb3BzLnNlZylcbiAgfVxuXG4gIC8qXG4gIG5lZWQgdG8gcmUtYXNzaWduIHNlZyB0byB0aGUgZWxlbWVudCBpZiBzZWcgY2hhbmdlcywgZXZlbiBpZiB0aGUgZWxlbWVudCBpcyB0aGUgc2FtZVxuICAqL1xuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBFdmVudFJvb3RQcm9wcykge1xuICAgIGxldCB7IHNlZyB9ID0gdGhpcy5wcm9wc1xuXG4gICAgaWYgKHNlZyAhPT0gcHJldlByb3BzLnNlZykge1xuICAgICAgc2V0RWxTZWcodGhpcy5lbFJlZi5jdXJyZW50LCBzZWcpXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL3Zkb20tdXRpbCdcbmltcG9ydCB7IGJ1aWxkU2VnVGltZVRleHQsIEV2ZW50Q29udGVudEFyZyB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcnXG5pbXBvcnQgeyBFdmVudFJvb3QsIE1pbmltYWxFdmVudFByb3BzIH0gZnJvbSAnLi9FdmVudFJvb3QnXG5pbXBvcnQgeyBTZWcgfSBmcm9tICcuLi9jb21wb25lbnQvRGF0ZUNvbXBvbmVudCdcbmltcG9ydCB7IERhdGVGb3JtYXR0ZXIgfSBmcm9tICcuLi9kYXRlbGliL0RhdGVGb3JtYXR0ZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhbmRhcmRFdmVudFByb3BzIGV4dGVuZHMgTWluaW1hbEV2ZW50UHJvcHMge1xuICBleHRyYUNsYXNzTmFtZXM6IHN0cmluZ1tdXG4gIGRlZmF1bHRUaW1lRm9ybWF0OiBEYXRlRm9ybWF0dGVyXG4gIGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lPzogYm9vbGVhbiAvLyBkZWZhdWx0IHRydWVcbiAgZGVmYXVsdERpc3BsYXlFdmVudEVuZD86IGJvb2xlYW4gLy8gZGVmYXVsdCB0cnVlXG4gIGRpc2FibGVEcmFnZ2luZz86IGJvb2xlYW4gLy8gZGVmYXVsdCBmYWxzZVxuICBkaXNhYmxlUmVzaXppbmc/OiBib29sZWFuIC8vIGRlZmF1bHQgZmFsc2VcbiAgZGVmYXVsdENvbnRlbnQ/OiAoaG9va1Byb3BzOiBFdmVudENvbnRlbnRBcmcpID0+IENvbXBvbmVudENoaWxkcmVuIC8vIG5vdCB1c2VkIGJ5IGFueW9uZSB5ZXRcbn1cblxuLy8gc2hvdWxkIG5vdCBiZSBhIHB1cmVjb21wb25lbnRcbmV4cG9ydCBjbGFzcyBTdGFuZGFyZEV2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxTdGFuZGFyZEV2ZW50UHJvcHM+IHtcbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgc2VnIH0gPSBwcm9wc1xuICAgIGxldCB0aW1lRm9ybWF0ID0gY29udGV4dC5vcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBwcm9wcy5kZWZhdWx0VGltZUZvcm1hdFxuICAgIGxldCB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoXG4gICAgICBzZWcsXG4gICAgICB0aW1lRm9ybWF0LFxuICAgICAgY29udGV4dCxcbiAgICAgIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLFxuICAgICAgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCxcbiAgICApXG5cbiAgICByZXR1cm4gKFxuICAgICAgPEV2ZW50Um9vdFxuICAgICAgICBzZWc9e3NlZ31cbiAgICAgICAgdGltZVRleHQ9e3RpbWVUZXh0fVxuICAgICAgICBkaXNhYmxlRHJhZ2dpbmc9e3Byb3BzLmRpc2FibGVEcmFnZ2luZ31cbiAgICAgICAgZGlzYWJsZVJlc2l6aW5nPXtwcm9wcy5kaXNhYmxlUmVzaXppbmd9XG4gICAgICAgIGRlZmF1bHRDb250ZW50PXtwcm9wcy5kZWZhdWx0Q29udGVudCB8fCByZW5kZXJJbm5lckNvbnRlbnR9XG4gICAgICAgIGlzRHJhZ2dpbmc9e3Byb3BzLmlzRHJhZ2dpbmd9XG4gICAgICAgIGlzUmVzaXppbmc9e3Byb3BzLmlzUmVzaXppbmd9XG4gICAgICAgIGlzRGF0ZVNlbGVjdGluZz17cHJvcHMuaXNEYXRlU2VsZWN0aW5nfVxuICAgICAgICBpc1NlbGVjdGVkPXtwcm9wcy5pc1NlbGVjdGVkfVxuICAgICAgICBpc1Bhc3Q9e3Byb3BzLmlzUGFzdH1cbiAgICAgICAgaXNGdXR1cmU9e3Byb3BzLmlzRnV0dXJlfVxuICAgICAgICBpc1RvZGF5PXtwcm9wcy5pc1RvZGF5fVxuICAgICAgPlxuICAgICAgICB7KHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCBob29rUHJvcHMpID0+IChcbiAgICAgICAgICA8YVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtwcm9wcy5leHRyYUNsYXNzTmFtZXMuY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKX1cbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBob29rUHJvcHMuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogaG9va1Byb3BzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICByZWY9e3Jvb3RFbFJlZn1cbiAgICAgICAgICAgIHsuLi5nZXRTZWdBbmNob3JBdHRycyhzZWcpfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtZXZlbnQtbWFpblwiIHJlZj17aW5uZXJFbFJlZn0gc3R5bGU9e3sgY29sb3I6IGhvb2tQcm9wcy50ZXh0Q29sb3IgfX0+XG4gICAgICAgICAgICAgIHtpbm5lckNvbnRlbnR9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHtob29rUHJvcHMuaXNTdGFydFJlc2l6YWJsZSAmJlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1zdGFydFwiIC8+fVxuICAgICAgICAgICAge2hvb2tQcm9wcy5pc0VuZFJlc2l6YWJsZSAmJlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1lbmRcIiAvPn1cbiAgICAgICAgICA8L2E+XG4gICAgICAgICl9XG4gICAgICA8L0V2ZW50Um9vdD5cbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KGlubmVyUHJvcHM6IEV2ZW50Q29udGVudEFyZykge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtZXZlbnQtbWFpbi1mcmFtZVwiPlxuICAgICAge2lubmVyUHJvcHMudGltZVRleHQgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZjLWV2ZW50LXRpbWVcIj57aW5uZXJQcm9wcy50aW1lVGV4dH08L2Rpdj5cbiAgICAgICl9XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZjLWV2ZW50LXRpdGxlLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZjLWV2ZW50LXRpdGxlIGZjLXN0aWNreVwiPlxuICAgICAgICAgIHtpbm5lclByb3BzLmV2ZW50LnRpdGxlIHx8IDxGcmFnbWVudD4mbmJzcDs8L0ZyYWdtZW50Pn1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5mdW5jdGlvbiBnZXRTZWdBbmNob3JBdHRycyhzZWc6IFNlZykge1xuICBsZXQgeyB1cmwgfSA9IHNlZy5ldmVudFJhbmdlLmRlZlxuICByZXR1cm4gdXJsID8geyBocmVmOiB1cmwgfSA6IHt9XG59XG4iLCJpbXBvcnQgeyBSZW5kZXJIb29rLCBSZW5kZXJIb29rUHJvcHNDaGlsZHJlbiwgTW91bnRBcmcgfSBmcm9tICcuL3JlbmRlci1ob29rJ1xuaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgVmlld0NvbnRleHQsIFZpZXdDb250ZXh0VHlwZSB9IGZyb20gJy4uL1ZpZXdDb250ZXh0J1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi4vVmlld0FwaSdcblxuZXhwb3J0IGludGVyZmFjZSBOb3dJbmRpY2F0b3JSb290UHJvcHMge1xuICBpc0F4aXM6IGJvb2xlYW5cbiAgZGF0ZTogRGF0ZU1hcmtlclxuICBjaGlsZHJlbjogUmVuZGVySG9va1Byb3BzQ2hpbGRyZW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3dJbmRpY2F0b3JDb250ZW50QXJnIHtcbiAgaXNBeGlzOiBib29sZWFuXG4gIGRhdGU6IERhdGVcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgdHlwZSBOb3dJbmRpY2F0b3JNb3VudEFyZyA9IE1vdW50QXJnPE5vd0luZGljYXRvckNvbnRlbnRBcmc+XG5cbmV4cG9ydCBjb25zdCBOb3dJbmRpY2F0b3JSb290ID0gKHByb3BzOiBOb3dJbmRpY2F0b3JSb290UHJvcHMpID0+IChcbiAgPFZpZXdDb250ZXh0VHlwZS5Db25zdW1lcj5cbiAgICB7KGNvbnRleHQ6IFZpZXdDb250ZXh0KSA9PiB7XG4gICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0XG4gICAgICBsZXQgaG9va1Byb3BzOiBOb3dJbmRpY2F0b3JDb250ZW50QXJnID0ge1xuICAgICAgICBpc0F4aXM6IHByb3BzLmlzQXhpcyxcbiAgICAgICAgZGF0ZTogY29udGV4dC5kYXRlRW52LnRvRGF0ZShwcm9wcy5kYXRlKSxcbiAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8UmVuZGVySG9va1xuICAgICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICAgIGNsYXNzTmFtZXM9e29wdGlvbnMubm93SW5kaWNhdG9yQ2xhc3NOYW1lc31cbiAgICAgICAgICBjb250ZW50PXtvcHRpb25zLm5vd0luZGljYXRvckNvbnRlbnR9XG4gICAgICAgICAgZGlkTW91bnQ9e29wdGlvbnMubm93SW5kaWNhdG9yRGlkTW91bnR9XG4gICAgICAgICAgd2lsbFVubW91bnQ9e29wdGlvbnMubm93SW5kaWNhdG9yV2lsbFVubW91bnR9XG4gICAgICAgID5cbiAgICAgICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgICAgIDwvUmVuZGVySG9vaz5cbiAgICAgIClcbiAgICB9fVxuICA8L1ZpZXdDb250ZXh0VHlwZS5Db25zdW1lcj5cbilcbiIsImltcG9ydCB7IFJlZiwgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgZ2V0RGF0ZU1ldGEsIERhdGVNZXRhIH0gZnJvbSAnLi4vY29tcG9uZW50L2RhdGUtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgY3JlYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi4vZGF0ZWxpYi9mb3JtYXR0aW5nJ1xuaW1wb3J0IHsgQ29udGVudEhvb2sgfSBmcm9tICcuL3JlbmRlci1ob29rJ1xuaW1wb3J0IHsgVmlld0FwaSB9IGZyb20gJy4uL1ZpZXdBcGknXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGUgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuaW1wb3J0IHsgRGF0ZUVudiB9IGZyb20gJy4uL2RhdGVsaWIvZW52J1xuXG5jb25zdCBEQVlfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IGRheTogJ251bWVyaWMnIH0pXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5Q2VsbENvbnRlbnRQcm9wcyB7XG4gIGRhdGU6IERhdGVNYXJrZXJcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlXG4gIHRvZGF5UmFuZ2U6IERhdGVSYW5nZVxuICBzaG93RGF5TnVtYmVyPzogYm9vbGVhbiAvLyBkZWZhdWx0cyB0byBmYWxzZVxuICBleHRyYUhvb2tQcm9wcz86IERpY3Rpb25hcnlcbiAgZGVmYXVsdENvbnRlbnQ/OiAoaG9va1Byb3BzOiBEYXlDZWxsQ29udGVudEFyZykgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbiAgY2hpbGRyZW46IChcbiAgICBpbm5lckVsUmVmOiBSZWY8YW55PixcbiAgICBpbm5lckNvbnRlbnQ6IENvbXBvbmVudENoaWxkcmVuXG4gICkgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXlDZWxsQ29udGVudEFyZyBleHRlbmRzIERhdGVNZXRhIHtcbiAgZGF0ZTogRGF0ZU1hcmtlciAvLyBsb2NhbGl6ZWRcbiAgdmlldzogVmlld0FwaVxuICBkYXlOdW1iZXJUZXh0OiBzdHJpbmdcbiAgW2V4dHJhUHJvcDogc3RyaW5nXTogYW55IC8vIHNvIGNhbiBpbmNsdWRlIGEgcmVzb3VyY2Vcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXlDZWxsSG9va1Byb3BzSW5wdXQge1xuICBkYXRlOiBEYXRlTWFya2VyIC8vIGdlbmVyaWNcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlXG4gIHRvZGF5UmFuZ2U6IERhdGVSYW5nZVxuICBkYXRlRW52OiBEYXRlRW52XG4gIHZpZXdBcGk6IFZpZXdBcGlcbiAgc2hvd0RheU51bWJlcj86IGJvb2xlYW4gLy8gZGVmYXVsdHMgdG8gZmFsc2VcbiAgZXh0cmFQcm9wcz86IERpY3Rpb25hcnkgLy8gc28gY2FuIGluY2x1ZGUgYSByZXNvdXJjZVxufVxuXG5leHBvcnQgY2xhc3MgRGF5Q2VsbENvbnRlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PERheUNlbGxDb250ZW50UHJvcHM+IHtcbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dFxuICAgIGxldCBob29rUHJvcHMgPSByZWZpbmVEYXlDZWxsSG9va1Byb3BzKHtcbiAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLFxuICAgICAgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcixcbiAgICAgIGV4dHJhUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzLFxuICAgICAgdmlld0FwaTogY29udGV4dC52aWV3QXBpLFxuICAgICAgZGF0ZUVudjogY29udGV4dC5kYXRlRW52LFxuICAgIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgPENvbnRlbnRIb29rXG4gICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICBjb250ZW50PXtvcHRpb25zLmRheUNlbGxDb250ZW50fVxuICAgICAgICBkZWZhdWx0Q29udGVudD17cHJvcHMuZGVmYXVsdENvbnRlbnR9XG4gICAgICA+XG4gICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICAgIDwvQ29udGVudEhvb2s+XG4gICAgKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWZpbmVEYXlDZWxsSG9va1Byb3BzKHJhdzogRGF5Q2VsbEhvb2tQcm9wc0lucHV0KTogRGF5Q2VsbENvbnRlbnRBcmcge1xuICBsZXQgeyBkYXRlLCBkYXRlRW52IH0gPSByYXdcbiAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCByYXcudG9kYXlSYW5nZSwgbnVsbCwgcmF3LmRhdGVQcm9maWxlKVxuXG4gIHJldHVybiB7XG4gICAgZGF0ZTogZGF0ZUVudi50b0RhdGUoZGF0ZSksXG4gICAgdmlldzogcmF3LnZpZXdBcGksXG4gICAgLi4uZGF5TWV0YSxcbiAgICBkYXlOdW1iZXJUZXh0OiByYXcuc2hvd0RheU51bWJlciA/IGRhdGVFbnYuZm9ybWF0KGRhdGUsIERBWV9OVU1fRk9STUFUKSA6ICcnLFxuICAgIC4uLnJhdy5leHRyYVByb3BzLFxuICB9XG59XG4iLCJpbXBvcnQgeyBSZWYsIENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IGdldERheUNsYXNzTmFtZXMsIERhdGVNZXRhIH0gZnJvbSAnLi4vY29tcG9uZW50L2RhdGUtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgZm9ybWF0RGF5U3RyaW5nIH0gZnJvbSAnLi4vZGF0ZWxpYi9mb3JtYXR0aW5nLXV0aWxzJ1xuaW1wb3J0IHsgYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyLCBNb3VudEhvb2ssIE1vdW50QXJnIH0gZnJvbSAnLi9yZW5kZXItaG9vaydcbmltcG9ydCB7IFZpZXdBcGkgfSBmcm9tICcuLi9WaWV3QXBpJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL3Zkb20tdXRpbCdcbmltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBtZW1vaXplT2JqQXJnIH0gZnJvbSAnLi4vdXRpbC9tZW1vaXplJ1xuaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5pbXBvcnQgeyByZWZpbmVEYXlDZWxsSG9va1Byb3BzIH0gZnJvbSAnLi9EYXlDZWxsQ29udGVudCdcblxuZXhwb3J0IGludGVyZmFjZSBEYXlDZWxsQ29udGVudEFyZyBleHRlbmRzIERhdGVNZXRhIHtcbiAgZGF0ZTogRGF0ZU1hcmtlciAvLyBsb2NhbGl6ZWRcbiAgdmlldzogVmlld0FwaVxuICBkYXlOdW1iZXJUZXh0OiBzdHJpbmdcbiAgW2V4dHJhUHJvcDogc3RyaW5nXTogYW55IC8vIHNvIGNhbiBpbmNsdWRlIGEgcmVzb3VyY2Vcbn1cbmV4cG9ydCB0eXBlIERheUNlbGxNb3VudEFyZyA9IE1vdW50QXJnPERheUNlbGxDb250ZW50QXJnPlxuXG5leHBvcnQgaW50ZXJmYWNlIERheUNlbGxSb290UHJvcHMge1xuICBlbFJlZj86IFJlZjxhbnk+XG4gIGRhdGU6IERhdGVNYXJrZXJcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlXG4gIHRvZGF5UmFuZ2U6IERhdGVSYW5nZVxuICBzaG93RGF5TnVtYmVyPzogYm9vbGVhbiAvLyBkZWZhdWx0cyB0byBmYWxzZVxuICBleHRyYUhvb2tQcm9wcz86IERpY3Rpb25hcnlcbiAgY2hpbGRyZW46IChcbiAgICByb290RWxSZWY6IFJlZjxhbnk+LFxuICAgIGNsYXNzTmFtZXM6IHN0cmluZ1tdLFxuICAgIHJvb3REYXRhQXR0cnMsXG4gICAgaXNEaXNhYmxlZDogYm9vbGVhblxuICApID0+IENvbXBvbmVudENoaWxkcmVuXG59XG5cbmV4cG9ydCBjbGFzcyBEYXlDZWxsUm9vdCBleHRlbmRzIEJhc2VDb21wb25lbnQ8RGF5Q2VsbFJvb3RQcm9wcz4ge1xuICByZWZpbmVIb29rUHJvcHMgPSBtZW1vaXplT2JqQXJnKHJlZmluZURheUNlbGxIb29rUHJvcHMpXG4gIG5vcm1hbGl6ZUNsYXNzTmFtZXMgPSBidWlsZENsYXNzTmFtZU5vcm1hbGl6ZXI8RGF5Q2VsbENvbnRlbnRBcmc+KClcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0XG4gICAgbGV0IGhvb2tQcm9wcyA9IHRoaXMucmVmaW5lSG9va1Byb3BzKHtcbiAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLFxuICAgICAgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcixcbiAgICAgIGV4dHJhUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzLFxuICAgICAgdmlld0FwaTogY29udGV4dC52aWV3QXBpLFxuICAgICAgZGF0ZUVudjogY29udGV4dC5kYXRlRW52LFxuICAgIH0pXG5cbiAgICBsZXQgY2xhc3NOYW1lcyA9IGdldERheUNsYXNzTmFtZXMoaG9va1Byb3BzLCBjb250ZXh0LnRoZW1lKS5jb25jYXQoXG4gICAgICBob29rUHJvcHMuaXNEaXNhYmxlZFxuICAgICAgICA/IFtdIC8vIGRvbid0IHVzZSBjdXN0b20gY2xhc3NOYW1lcyBpZiBkaXNhYmxlZFxuICAgICAgICA6IHRoaXMubm9ybWFsaXplQ2xhc3NOYW1lcyhvcHRpb25zLmRheUNlbGxDbGFzc05hbWVzLCBob29rUHJvcHMpLFxuICAgIClcblxuICAgIGxldCBkYXRhQXR0cnMgPSBob29rUHJvcHMuaXNEaXNhYmxlZCA/IHt9IDoge1xuICAgICAgJ2RhdGEtZGF0ZSc6IGZvcm1hdERheVN0cmluZyhwcm9wcy5kYXRlKSxcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPE1vdW50SG9va1xuICAgICAgICBob29rUHJvcHM9e2hvb2tQcm9wc31cbiAgICAgICAgZGlkTW91bnQ9e29wdGlvbnMuZGF5Q2VsbERpZE1vdW50fVxuICAgICAgICB3aWxsVW5tb3VudD17b3B0aW9ucy5kYXlDZWxsV2lsbFVubW91bnR9XG4gICAgICAgIGVsUmVmPXtwcm9wcy5lbFJlZn1cbiAgICAgID5cbiAgICAgICAgeyhyb290RWxSZWYpID0+IHByb3BzLmNoaWxkcmVuKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgZGF0YUF0dHJzLCBob29rUHJvcHMuaXNEaXNhYmxlZCl9XG4gICAgICA8L01vdW50SG9vaz5cbiAgICApXG4gIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgRXZlbnRSb290IH0gZnJvbSAnLi9FdmVudFJvb3QnXG5pbXBvcnQgeyBTZWcgfSBmcm9tICcuLi9jb21wb25lbnQvRGF0ZUNvbXBvbmVudCdcbmltcG9ydCB7IEV2ZW50Q29udGVudEFyZyB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJGaWxsKGZpbGxUeXBlOiBzdHJpbmcpIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17YGZjLSR7ZmlsbFR5cGV9YH0gLz5cbiAgKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJnRXZlbnRQcm9wcyB7XG4gIHNlZzogU2VnXG4gIGlzUGFzdDogYm9vbGVhblxuICBpc0Z1dHVyZTogYm9vbGVhblxuICBpc1RvZGF5OiBib29sZWFuXG59XG5cbmV4cG9ydCBjb25zdCBCZ0V2ZW50ID0gKHByb3BzOiBCZ0V2ZW50UHJvcHMpID0+IChcbiAgPEV2ZW50Um9vdFxuICAgIGRlZmF1bHRDb250ZW50PXtyZW5kZXJJbm5lckNvbnRlbnR9XG4gICAgc2VnPXtwcm9wcy5zZWcgLyogdXNlbGVzc3MgaSB0aGluayAqL31cbiAgICB0aW1lVGV4dD1cIlwiXG4gICAgZGlzYWJsZURyYWdnaW5nXG4gICAgZGlzYWJsZVJlc2l6aW5nXG4gICAgaXNEcmFnZ2luZz17ZmFsc2V9XG4gICAgaXNSZXNpemluZz17ZmFsc2V9XG4gICAgaXNEYXRlU2VsZWN0aW5nPXtmYWxzZX1cbiAgICBpc1NlbGVjdGVkPXtmYWxzZX1cbiAgICBpc1Bhc3Q9e3Byb3BzLmlzUGFzdH1cbiAgICBpc0Z1dHVyZT17cHJvcHMuaXNGdXR1cmV9XG4gICAgaXNUb2RheT17cHJvcHMuaXNUb2RheX1cbiAgPlxuICAgIHsocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhvb2tQcm9wcykgPT4gKFxuICAgICAgPGRpdlxuICAgICAgICByZWY9e3Jvb3RFbFJlZn1cbiAgICAgICAgY2xhc3NOYW1lPXtbJ2ZjLWJnLWV2ZW50J10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKX1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhvb2tQcm9wcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtpbm5lckNvbnRlbnR9XG4gICAgICA8L2Rpdj5cbiAgICApfVxuICA8L0V2ZW50Um9vdD5cbilcblxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzOiBFdmVudENvbnRlbnRBcmcpIHtcbiAgbGV0IHsgdGl0bGUgfSA9IHByb3BzLmV2ZW50XG5cbiAgcmV0dXJuIHRpdGxlICYmIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZjLWV2ZW50LXRpdGxlXCI+e3Byb3BzLmV2ZW50LnRpdGxlfTwvZGl2PlxuICApXG59XG4iLCJpbXBvcnQgeyBWaWV3Q29udGV4dCwgVmlld0NvbnRleHRUeXBlIH0gZnJvbSAnLi4vVmlld0NvbnRleHQnXG5pbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBSZW5kZXJIb29rLCBSZW5kZXJIb29rUHJvcHNDaGlsZHJlbiwgTW91bnRBcmcgfSBmcm9tICcuL3JlbmRlci1ob29rJ1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBEYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi4vZGF0ZWxpYi9EYXRlRm9ybWF0dGVyJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFdlZWtOdW1iZXJSb290UHJvcHMge1xuICBkYXRlOiBEYXRlTWFya2VyXG4gIGRlZmF1bHRGb3JtYXQ6IERhdGVGb3JtYXR0ZXJcbiAgY2hpbGRyZW46IFJlbmRlckhvb2tQcm9wc0NoaWxkcmVuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2Vla051bWJlckNvbnRlbnRBcmcge1xuICBudW06IG51bWJlclxuICB0ZXh0OiBzdHJpbmdcbiAgZGF0ZTogRGF0ZVxufVxuZXhwb3J0IHR5cGUgV2Vla051bWJlck1vdW50QXJnID0gTW91bnRBcmc8V2Vla051bWJlckNvbnRlbnRBcmc+XG5cbmV4cG9ydCBjb25zdCBXZWVrTnVtYmVyUm9vdCA9IChwcm9wczogV2Vla051bWJlclJvb3RQcm9wcykgPT4gKFxuICA8Vmlld0NvbnRleHRUeXBlLkNvbnN1bWVyPlxuICAgIHsoY29udGV4dDogVmlld0NvbnRleHQpID0+IHtcbiAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgICAgIGxldCB7IGRhdGUgfSA9IHByb3BzXG4gICAgICBsZXQgZm9ybWF0ID0gb3B0aW9ucy53ZWVrTnVtYmVyRm9ybWF0IHx8IHByb3BzLmRlZmF1bHRGb3JtYXRcbiAgICAgIGxldCBudW0gPSBkYXRlRW52LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUpIC8vIFRPRE86IHNvbWVob3cgdXNlIGZvciBmb3JtYXR0aW5nIGFzIHdlbGw/XG4gICAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIGZvcm1hdClcbiAgICAgIGxldCBob29rUHJvcHM6IFdlZWtOdW1iZXJDb250ZW50QXJnID0geyBudW0sIHRleHQsIGRhdGUgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8UmVuZGVySG9vazxXZWVrTnVtYmVyQ29udGVudEFyZz4gLy8gd2h5IGlzbid0IFdlZWtOdW1iZXJDb250ZW50QXJnIGJlaW5nIGF1dG8tZGV0ZWN0ZWQ/XG4gICAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgICAgY2xhc3NOYW1lcz17b3B0aW9ucy53ZWVrTnVtYmVyQ2xhc3NOYW1lc31cbiAgICAgICAgICBjb250ZW50PXtvcHRpb25zLndlZWtOdW1iZXJDb250ZW50fVxuICAgICAgICAgIGRlZmF1bHRDb250ZW50PXtyZW5kZXJJbm5lcn1cbiAgICAgICAgICBkaWRNb3VudD17b3B0aW9ucy53ZWVrTnVtYmVyRGlkTW91bnR9XG4gICAgICAgICAgd2lsbFVubW91bnQ9e29wdGlvbnMud2Vla051bWJlcldpbGxVbm1vdW50fVxuICAgICAgICA+XG4gICAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgICA8L1JlbmRlckhvb2s+XG4gICAgICApXG4gICAgfX1cbiAgPC9WaWV3Q29udGV4dFR5cGUuQ29uc3VtZXI+XG4pXG5cbmZ1bmN0aW9uIHJlbmRlcklubmVyKGlubmVyUHJvcHMpIHtcbiAgcmV0dXJuIGlubmVyUHJvcHMudGV4dFxufVxuIiwiaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5pbXBvcnQgeyBjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QgfSBmcm9tICcuLi91dGlsL2RvbS1nZW9tJ1xuaW1wb3J0IHsgYXBwbHlTdHlsZSwgZWxlbWVudENsb3Nlc3QsIGdldEV2ZW50VGFyZ2V0VmlhUm9vdCB9IGZyb20gJy4uL3V0aWwvZG9tLW1hbmlwJ1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgQ29tcG9uZW50Q2hpbGRyZW4sIFJlZiwgY3JlYXRlUG9ydGFsIH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IEJhc2VDb21wb25lbnQsIHNldFJlZiB9IGZyb20gJy4uL3Zkb20tdXRpbCdcblxuZXhwb3J0IGludGVyZmFjZSBQb3BvdmVyUHJvcHMge1xuICBlbFJlZj86IFJlZjxIVE1MRWxlbWVudD5cbiAgdGl0bGU6IHN0cmluZ1xuICBleHRyYUNsYXNzTmFtZXM/OiBzdHJpbmdbXVxuICBleHRyYUF0dHJzPzogRGljdGlvbmFyeVxuICBwYXJlbnRFbDogSFRNTEVsZW1lbnRcbiAgYWxpZ25tZW50RWw6IEhUTUxFbGVtZW50XG4gIGFsaWduR3JpZFRvcD86IGJvb2xlYW5cbiAgY2hpbGRyZW4/OiBDb21wb25lbnRDaGlsZHJlblxuICBvbkNsb3NlPzogKCkgPT4gdm9pZFxufVxuXG5jb25zdCBQQURESU5HX0ZST01fVklFV1BPUlQgPSAxMFxuXG5leHBvcnQgY2xhc3MgUG9wb3ZlciBleHRlbmRzIEJhc2VDb21wb25lbnQ8UG9wb3ZlclByb3BzPiB7XG4gIHByaXZhdGUgcm9vdEVsOiBIVE1MRWxlbWVudFxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyB0aGVtZSB9ID0gdGhpcy5jb250ZXh0XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICdmYy1wb3BvdmVyJyxcbiAgICAgIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyJyksXG4gICAgXS5jb25jYXQoXG4gICAgICBwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10sXG4gICAgKVxuXG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzLmpvaW4oJyAnKX0gey4uLnByb3BzLmV4dHJhQXR0cnN9IHJlZj17dGhpcy5oYW5kbGVSb290RWx9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17J2ZjLXBvcG92ZXItaGVhZGVyICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckhlYWRlcicpfT5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYy1wb3BvdmVyLXRpdGxlXCI+XG4gICAgICAgICAgICB7cHJvcHMudGl0bGV9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17J2ZjLXBvcG92ZXItY2xvc2UgJyArIHRoZW1lLmdldEljb25DbGFzcygnY2xvc2UnKX0gb25DbGljaz17dGhpcy5oYW5kbGVDbG9zZUNsaWNrfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9eydmYy1wb3BvdmVyLWJvZHkgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyQ29udGVudCcpfT5cbiAgICAgICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+LFxuICAgICAgcHJvcHMucGFyZW50RWwsXG4gICAgKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlZG93bilcbiAgICB0aGlzLnVwZGF0ZVNpemUoKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlZG93bilcbiAgfVxuXG4gIGhhbmRsZVJvb3RFbCA9IChlbDogSFRNTEVsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgdGhpcy5yb290RWwgPSBlbFxuXG4gICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbClcbiAgICB9XG4gIH1cblxuICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKmFueXdoZXJlKiBpbiB0aGUgZG9jdW1lbnQsIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZVxuICBoYW5kbGVEb2N1bWVudE1vdXNlZG93biA9IChldikgPT4ge1xuICAgIC8vIG9ubHkgaGlkZSB0aGUgcG9wb3ZlciBpZiB0aGUgY2xpY2sgaGFwcGVuZWQgb3V0c2lkZSB0aGUgcG9wb3ZlclxuICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldikgYXMgSFRNTEVsZW1lbnRcbiAgICBpZiAoIXRoaXMucm9vdEVsLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlQ2xvc2VDbGljaygpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQ2xvc2VDbGljayA9ICgpID0+IHtcbiAgICBsZXQgeyBvbkNsb3NlIH0gPSB0aGlzLnByb3BzXG4gICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgIG9uQ2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU2l6ZSgpIHtcbiAgICBsZXQgeyBpc1J0bCB9ID0gdGhpcy5jb250ZXh0XG4gICAgbGV0IHsgYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcCB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCB7IHJvb3RFbCB9ID0gdGhpc1xuXG4gICAgbGV0IGFsaWdubWVudFJlY3QgPSBjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QoYWxpZ25tZW50RWwpXG4gICAgaWYgKGFsaWdubWVudFJlY3QpIHtcbiAgICAgIGxldCBwb3BvdmVyRGltcyA9IHJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICAvLyBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgbGV0IHBvcG92ZXJUb3AgPSBhbGlnbkdyaWRUb3BcbiAgICAgICAgPyBlbGVtZW50Q2xvc2VzdChhbGlnbm1lbnRFbCwgJy5mYy1zY3JvbGxncmlkJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICAgIDogYWxpZ25tZW50UmVjdC50b3BcbiAgICAgIGxldCBwb3BvdmVyTGVmdCA9IGlzUnRsID8gYWxpZ25tZW50UmVjdC5yaWdodCAtIHBvcG92ZXJEaW1zLndpZHRoIDogYWxpZ25tZW50UmVjdC5sZWZ0XG5cbiAgICAgIC8vIGNvbnN0cmFpblxuICAgICAgcG9wb3ZlclRvcCA9IE1hdGgubWF4KHBvcG92ZXJUb3AsIFBBRERJTkdfRlJPTV9WSUVXUE9SVClcbiAgICAgIHBvcG92ZXJMZWZ0ID0gTWF0aC5taW4ocG9wb3ZlckxlZnQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAtIFBBRERJTkdfRlJPTV9WSUVXUE9SVCAtIHBvcG92ZXJEaW1zLndpZHRoKVxuICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1heChwb3BvdmVyTGVmdCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKVxuXG4gICAgICBsZXQgb3JpZ2luID0gcm9vdEVsLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgYXBwbHlTdHlsZShyb290RWwsIHtcbiAgICAgICAgdG9wOiBwb3BvdmVyVG9wIC0gb3JpZ2luLnRvcCxcbiAgICAgICAgbGVmdDogcG9wb3ZlckxlZnQgLSBvcmlnaW4ubGVmdCxcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBEYXRlQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50L0RhdGVDb21wb25lbnQnXG5pbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4uL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgSGl0IH0gZnJvbSAnLi4vaW50ZXJhY3Rpb25zL2hpdCdcbmltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgQ29tcG9uZW50Q2hpbGRyZW4gfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgRGF5Q2VsbENvbnRlbnQgfSBmcm9tICcuL0RheUNlbGxDb250ZW50J1xuaW1wb3J0IHsgRGF5Q2VsbFJvb3QgfSBmcm9tICcuL0RheUNlbGxSb290J1xuaW1wb3J0IHsgUG9wb3ZlciB9IGZyb20gJy4vUG9wb3ZlcidcblxuZXhwb3J0IGludGVyZmFjZSBNb3JlUG9wb3ZlclByb3BzIHtcbiAgc3RhcnREYXRlOiBEYXRlTWFya2VyXG4gIGVuZERhdGU6IERhdGVNYXJrZXJcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlXG4gIHBhcmVudEVsOiBIVE1MRWxlbWVudFxuICBhbGlnbm1lbnRFbDogSFRNTEVsZW1lbnRcbiAgYWxpZ25HcmlkVG9wPzogYm9vbGVhblxuICB0b2RheVJhbmdlOiBEYXRlUmFuZ2VcbiAgZXh0cmFEYXRlU3BhbjogRGljdGlvbmFyeVxuICBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW5cbiAgb25DbG9zZT86ICgpID0+IHZvaWRcbn1cblxuZXhwb3J0IGNsYXNzIE1vcmVQb3BvdmVyIGV4dGVuZHMgRGF0ZUNvbXBvbmVudDxNb3JlUG9wb3ZlclByb3BzPiB7XG4gIHJvb3RFbDogSFRNTEVsZW1lbnRcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgb3B0aW9ucywgZGF0ZUVudiB9ID0gdGhpcy5jb250ZXh0XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgeyBzdGFydERhdGUsIHRvZGF5UmFuZ2UsIGRhdGVQcm9maWxlIH0gPSBwcm9wc1xuICAgIGxldCB0aXRsZSA9IGRhdGVFbnYuZm9ybWF0KHN0YXJ0RGF0ZSwgb3B0aW9ucy5kYXlQb3BvdmVyRm9ybWF0KVxuICAgIHJldHVybiAoXG4gICAgICA8RGF5Q2VsbFJvb3QgZGF0ZT17c3RhcnREYXRlfSBkYXRlUHJvZmlsZT17ZGF0ZVByb2ZpbGV9IHRvZGF5UmFuZ2U9e3RvZGF5UmFuZ2V9IGVsUmVmPXt0aGlzLmhhbmRsZVJvb3RFbH0+XG4gICAgICAgIHsocm9vdEVsUmVmLCBkYXlDbGFzc05hbWVzLCBkYXRhQXR0cnMpID0+IChcbiAgICAgICAgICA8UG9wb3ZlclxuICAgICAgICAgICAgZWxSZWY9e3Jvb3RFbFJlZn1cbiAgICAgICAgICAgIHRpdGxlPXt0aXRsZX1cbiAgICAgICAgICAgIGV4dHJhQ2xhc3NOYW1lcz17WydmYy1tb3JlLXBvcG92ZXInXS5jb25jYXQoZGF5Q2xhc3NOYW1lcyl9XG4gICAgICAgICAgICBleHRyYUF0dHJzPXtkYXRhQXR0cnMgLyogVE9ETzogbWFrZSB0aGVzZSB0aW1lLWJhc2VkIHdoZW4gbm90IHdob2xlLWRheT8gKi99XG4gICAgICAgICAgICBwYXJlbnRFbD17cHJvcHMucGFyZW50RWx9XG4gICAgICAgICAgICBhbGlnbm1lbnRFbD17cHJvcHMuYWxpZ25tZW50RWx9XG4gICAgICAgICAgICBhbGlnbkdyaWRUb3A9e3Byb3BzLmFsaWduR3JpZFRvcH1cbiAgICAgICAgICAgIG9uQ2xvc2U9e3Byb3BzLm9uQ2xvc2V9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPERheUNlbGxDb250ZW50IGRhdGU9e3N0YXJ0RGF0ZX0gZGF0ZVByb2ZpbGU9e2RhdGVQcm9maWxlfSB0b2RheVJhbmdlPXt0b2RheVJhbmdlfT5cbiAgICAgICAgICAgICAgeyhpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpID0+IChcbiAgICAgICAgICAgICAgICBpbm5lckNvbnRlbnQgJiZcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtbW9yZS1wb3BvdmVyLW1pc2NcIiByZWY9e2lubmVyRWxSZWZ9Pntpbm5lckNvbnRlbnR9PC9kaXY+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L0RheUNlbGxDb250ZW50PlxuICAgICAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgICAgIDwvUG9wb3Zlcj5cbiAgICAgICAgKX1cbiAgICAgIDwvRGF5Q2VsbFJvb3Q+XG4gICAgKVxuICB9XG5cbiAgaGFuZGxlUm9vdEVsID0gKHJvb3RFbDogSFRNTERpdkVsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgdGhpcy5yb290RWwgPSByb290RWxcbiAgICBpZiAocm9vdEVsKSB7XG4gICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgIGVsOiByb290RWwsXG4gICAgICAgIHVzZUV2ZW50Q2VudGVyOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcylcbiAgICB9XG4gIH1cblxuICBxdWVyeUhpdChwb3NpdGlvbkxlZnQ6IG51bWJlciwgcG9zaXRpb25Ub3A6IG51bWJlciwgZWxXaWR0aDogbnVtYmVyLCBlbEhlaWdodDogbnVtYmVyKTogSGl0IHtcbiAgICBsZXQgeyByb290RWwsIHByb3BzIH0gPSB0aGlzXG5cbiAgICBpZiAoXG4gICAgICBwb3NpdGlvbkxlZnQgPj0gMCAmJiBwb3NpdGlvbkxlZnQgPCBlbFdpZHRoICYmXG4gICAgICBwb3NpdGlvblRvcCA+PSAwICYmIHBvc2l0aW9uVG9wIDwgZWxIZWlnaHRcbiAgICApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgZGF0ZVNwYW46IHtcbiAgICAgICAgICBhbGxEYXk6IHRydWUsXG4gICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9wcy5zdGFydERhdGUsXG4gICAgICAgICAgICBlbmQ6IHByb3BzLmVuZERhdGUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAuLi5wcm9wcy5leHRyYURhdGVTcGFuLFxuICAgICAgICB9LFxuICAgICAgICBkYXlFbDogcm9vdEVsLFxuICAgICAgICByZWN0OiB7XG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgcmlnaHQ6IGVsV2lkdGgsXG4gICAgICAgICAgYm90dG9tOiBlbEhlaWdodCxcbiAgICAgICAgfSxcbiAgICAgICAgbGF5ZXI6IDEsIC8vIGltcG9ydGFudCB3aGVuIGNvbXBhcmluZyB3aXRoIGhpdHMgZnJvbSBvdGhlciBjb21wb25lbnRzXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwiaW1wb3J0IHsgRXZlbnRBcGkgfSBmcm9tICcuLi9hcGkvRXZlbnRBcGknXG5pbXBvcnQgeyBTZWcgfSBmcm9tICcuLi9jb21wb25lbnQvRGF0ZUNvbXBvbmVudCdcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IGFkZERheXMsIERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcbmltcG9ydCB7IGVsZW1lbnRDbG9zZXN0IH0gZnJvbSAnLi4vdXRpbC9kb20tbWFuaXAnXG5pbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlRWxlbWVudCwgY3JlYXRlUmVmLCBGcmFnbWVudCwgUmVmLCBSZWZPYmplY3QsIFZOb2RlIH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi4vVmlld0FwaSdcbmltcG9ydCB7IFZpZXdDb250ZXh0LCBWaWV3Q29udGV4dFR5cGUgfSBmcm9tICcuLi9WaWV3Q29udGV4dCdcbmltcG9ydCB7IE1vcmVQb3BvdmVyIH0gZnJvbSAnLi9Nb3JlUG9wb3ZlcidcbmltcG9ydCB7IE1vdW50QXJnLCBSZW5kZXJIb29rIH0gZnJvbSAnLi9yZW5kZXItaG9vaydcblxuZXhwb3J0IHR5cGUgTW9yZUxpbmtDaGlsZHJlbiA9IChcbiAgcm9vdEVsUmVmOiBSZWY8YW55PixcbiAgY2xhc3NOYW1lczogc3RyaW5nW10sXG4gIGlubmVyRWxSZWY6IFJlZjxhbnk+LFxuICBpbm5lckNvbnRlbnQ6IENvbXBvbmVudENoaWxkcmVuLFxuICBoYW5kbGVDbGljazogKGV2OiBNb3VzZUV2ZW50KSA9PiB2b2lkLFxuKSA9PiBDb21wb25lbnRDaGlsZHJlblxuXG5leHBvcnQgaW50ZXJmYWNlIE1vcmVMaW5rUm9vdFByb3BzIHsgLy8gd2hhdCB0aGUgTW9yZUxpbmtSb290IGNvbXBvbmVudCByZWNlaXZlc1xuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgdG9kYXlSYW5nZTogRGF0ZVJhbmdlXG4gIGFsbERheURhdGU6IERhdGVNYXJrZXIgfCBudWxsXG4gIG1vcmVDbnQ6IG51bWJlciAvLyBjYW4ndCBhbHdheXMgZGVyaXZlIGZyb20gaGlkZGVuU2Vncy4gc29tZSBoaWRkZW5TZWdzIG1pZ2h0IGJlIGR1ZSB0byBsYWNrIG9mIGRpbWVuc2lvbnNcbiAgYWxsU2VnczogU2VnW11cbiAgaGlkZGVuU2VnczogU2VnW11cbiAgZXh0cmFEYXRlU3Bhbj86IERpY3Rpb25hcnlcbiAgYWxpZ25tZW50RWxSZWY6IFJlZk9iamVjdDxIVE1MRWxlbWVudD4gLy8gZm9yIHBvcG92ZXJcbiAgYWxpZ25HcmlkVG9wPzogYm9vbGVhbiAvLyBmb3IgcG9wb3ZlclxuICB0b3BBbGlnbm1lbnRFbFJlZj86IFJlZk9iamVjdDxIVE1MRWxlbWVudD5cbiAgZGVmYXVsdENvbnRlbnQ/OiAoaG9va1Byb3BzOiBNb3JlTGlua0NvbnRlbnRBcmcpID0+IENvbXBvbmVudENoaWxkcmVuXG4gIHBvcG92ZXJDb250ZW50OiAoKSA9PiBWTm9kZVxuICBjaGlsZHJlbjogTW9yZUxpbmtDaGlsZHJlblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vcmVMaW5rQ29udGVudEFyZyB7IC8vIHdoYXQgdGhlIHJlbmRlci1ob29rcyByZWNlaXZlXG4gIG51bTogbnVtYmVyXG4gIHRleHQ6IHN0cmluZ1xuICBzaG9ydFRleHQ6IHN0cmluZ1xuICB2aWV3OiBWaWV3QXBpXG59XG5cbmV4cG9ydCB0eXBlIE1vcmVMaW5rTW91bnRBcmcgPSBNb3VudEFyZzxNb3JlTGlua0NvbnRlbnRBcmc+XG5cbmludGVyZmFjZSBNb3JlTGlua1Jvb3RTdGF0ZSB7XG4gIGlzUG9wb3Zlck9wZW46IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIE1vcmVMaW5rUm9vdCBleHRlbmRzIEJhc2VDb21wb25lbnQ8TW9yZUxpbmtSb290UHJvcHMsIE1vcmVMaW5rUm9vdFN0YXRlPiB7XG4gIHByaXZhdGUgbGlua0VsUmVmID0gY3JlYXRlUmVmPEhUTUxFbGVtZW50PigpXG4gIHByaXZhdGUgcGFyZW50RWw6IEhUTUxFbGVtZW50XG5cbiAgc3RhdGUgPSB7XG4gICAgaXNQb3BvdmVyT3BlbjogZmFsc2UsXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICByZXR1cm4gKFxuICAgICAgPFZpZXdDb250ZXh0VHlwZS5Db25zdW1lcj5cbiAgICAgICAgeyhjb250ZXh0OiBWaWV3Q29udGV4dCkgPT4ge1xuICAgICAgICAgIGxldCB7IHZpZXdBcGksIG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSBjb250ZXh0XG4gICAgICAgICAgbGV0IHsgbW9yZUxpbmtUZXh0IH0gPSBvcHRpb25zXG4gICAgICAgICAgbGV0IHsgbW9yZUNudCB9ID0gcHJvcHNcbiAgICAgICAgICBsZXQgcmFuZ2UgPSBjb21wdXRlUmFuZ2UocHJvcHMpXG5cbiAgICAgICAgICBsZXQgaG9va1Byb3BzOiBNb3JlTGlua0NvbnRlbnRBcmcgPSB7XG4gICAgICAgICAgICBudW06IG1vcmVDbnQsXG4gICAgICAgICAgICBzaG9ydFRleHQ6IGArJHttb3JlQ250fWAsIC8vIFRPRE86IG9mZmVyIGhvb2sgb3IgaTE4bj9cbiAgICAgICAgICAgIHRleHQ6IHR5cGVvZiBtb3JlTGlua1RleHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgPyBtb3JlTGlua1RleHQuY2FsbChjYWxlbmRhckFwaSwgbW9yZUNudClcbiAgICAgICAgICAgICAgOiBgKyR7bW9yZUNudH0gJHttb3JlTGlua1RleHR9YCxcbiAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxGcmFnbWVudD5cbiAgICAgICAgICAgICAge0Jvb2xlYW4ocHJvcHMubW9yZUNudCkgJiYgKFxuICAgICAgICAgICAgICAgIDxSZW5kZXJIb29rPE1vcmVMaW5rQ29udGVudEFyZz5cbiAgICAgICAgICAgICAgICAgIGVsUmVmPXt0aGlzLmxpbmtFbFJlZn1cbiAgICAgICAgICAgICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcz17b3B0aW9ucy5tb3JlTGlua0NsYXNzTmFtZXN9XG4gICAgICAgICAgICAgICAgICBjb250ZW50PXtvcHRpb25zLm1vcmVMaW5rQ29udGVudH1cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb250ZW50PXtwcm9wcy5kZWZhdWx0Q29udGVudCB8fCByZW5kZXJNb3JlTGlua0lubmVyfVxuICAgICAgICAgICAgICAgICAgZGlkTW91bnQ9e29wdGlvbnMubW9yZUxpbmtEaWRNb3VudH1cbiAgICAgICAgICAgICAgICAgIHdpbGxVbm1vdW50PXtvcHRpb25zLm1vcmVMaW5rV2lsbFVubW91bnR9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgeyhyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgPT4gcHJvcHMuY2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbFJlZiwgWydmYy1tb3JlLWxpbmsnXS5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcyksIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgdGhpcy5oYW5kbGVDbGljayxcbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9SZW5kZXJIb29rPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5pc1BvcG92ZXJPcGVuICYmIChcbiAgICAgICAgICAgICAgICA8TW9yZVBvcG92ZXJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZT17cmFuZ2Uuc3RhcnR9XG4gICAgICAgICAgICAgICAgICBlbmREYXRlPXtyYW5nZS5lbmR9XG4gICAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZT17cHJvcHMuZGF0ZVByb2ZpbGV9XG4gICAgICAgICAgICAgICAgICB0b2RheVJhbmdlPXtwcm9wcy50b2RheVJhbmdlfVxuICAgICAgICAgICAgICAgICAgZXh0cmFEYXRlU3Bhbj17cHJvcHMuZXh0cmFEYXRlU3Bhbn1cbiAgICAgICAgICAgICAgICAgIHBhcmVudEVsPXt0aGlzLnBhcmVudEVsfVxuICAgICAgICAgICAgICAgICAgYWxpZ25tZW50RWw9e3Byb3BzLmFsaWdubWVudEVsUmVmLmN1cnJlbnR9XG4gICAgICAgICAgICAgICAgICBhbGlnbkdyaWRUb3A9e3Byb3BzLmFsaWduR3JpZFRvcH1cbiAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9e3RoaXMuaGFuZGxlUG9wb3ZlckNsb3NlfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtwcm9wcy5wb3BvdmVyQ29udGVudCgpfVxuICAgICAgICAgICAgICAgIDwvTW9yZVBvcG92ZXI+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L0ZyYWdtZW50PlxuICAgICAgICAgIClcbiAgICAgICAgfX1cbiAgICAgIDwvVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyPlxuICAgIClcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudXBkYXRlUGFyZW50RWwoKVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMudXBkYXRlUGFyZW50RWwoKVxuICB9XG5cbiAgdXBkYXRlUGFyZW50RWwoKSB7XG4gICAgaWYgKHRoaXMubGlua0VsUmVmLmN1cnJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50RWwgPSBlbGVtZW50Q2xvc2VzdCh0aGlzLmxpbmtFbFJlZi5jdXJyZW50LCAnLmZjLXZpZXctaGFybmVzcycpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQ2xpY2sgPSAoZXY6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCB7IG1vcmVMaW5rQ2xpY2sgfSA9IGNvbnRleHQub3B0aW9uc1xuICAgIGxldCBkYXRlID0gY29tcHV0ZVJhbmdlKHByb3BzKS5zdGFydFxuXG4gICAgZnVuY3Rpb24gYnVpbGRQdWJsaWNTZWcoc2VnOiBTZWcpIHtcbiAgICAgIGxldCB7IGRlZiwgaW5zdGFuY2UsIHJhbmdlIH0gPSBzZWcuZXZlbnRSYW5nZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShjb250ZXh0LCBkZWYsIGluc3RhbmNlKSxcbiAgICAgICAgc3RhcnQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxuICAgICAgICBlbmQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICAgICAgaXNTdGFydDogc2VnLmlzU3RhcnQsXG4gICAgICAgIGlzRW5kOiBzZWcuaXNFbmQsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtb3JlTGlua0NsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtb3JlTGlua0NsaWNrID0gbW9yZUxpbmtDbGljayh7XG4gICAgICAgIGRhdGUsXG4gICAgICAgIGFsbERheTogQm9vbGVhbihwcm9wcy5hbGxEYXlEYXRlKSxcbiAgICAgICAgYWxsU2VnczogcHJvcHMuYWxsU2Vncy5tYXAoYnVpbGRQdWJsaWNTZWcpLFxuICAgICAgICBoaWRkZW5TZWdzOiBwcm9wcy5oaWRkZW5TZWdzLm1hcChidWlsZFB1YmxpY1NlZyksXG4gICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICB9KSBhcyBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAoIW1vcmVMaW5rQ2xpY2sgfHwgbW9yZUxpbmtDbGljayA9PT0gJ3BvcG92ZXInKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgaXNQb3BvdmVyT3BlbjogdHJ1ZSB9KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vcmVMaW5rQ2xpY2sgPT09ICdzdHJpbmcnKSB7IC8vIGEgdmlldyBuYW1lXG4gICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnpvb21UbyhkYXRlLCBtb3JlTGlua0NsaWNrKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVBvcG92ZXJDbG9zZSA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgaXNQb3BvdmVyT3BlbjogZmFsc2UgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNb3JlTGlua0lubmVyKHByb3BzOiBNb3JlTGlua0NvbnRlbnRBcmcpIHtcbiAgcmV0dXJuIHByb3BzLnRleHRcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVJhbmdlKHByb3BzOiBNb3JlTGlua1Jvb3RQcm9wcyk6IERhdGVSYW5nZSB7XG4gIGlmIChwcm9wcy5hbGxEYXlEYXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwcm9wcy5hbGxEYXlEYXRlLFxuICAgICAgZW5kOiBhZGREYXlzKHByb3BzLmFsbERheURhdGUsIDEpLFxuICAgIH1cbiAgfVxuXG4gIGxldCB7IGhpZGRlblNlZ3MgfSA9IHByb3BzXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KGhpZGRlblNlZ3MpLFxuICAgIGVuZDogY29tcHV0ZUxhdGVzdFNlZ0VuZChoaWRkZW5TZWdzKSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoc2VnczogU2VnW10pOiBEYXRlTWFya2VyIHtcbiAgcmV0dXJuIHNlZ3MucmVkdWNlKHBpY2tFYXJsaWVzdFN0YXJ0KS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0XG59XG5cbmZ1bmN0aW9uIHBpY2tFYXJsaWVzdFN0YXJ0KHNlZzA6IFNlZywgc2VnMTogU2VnKTogU2VnIHtcbiAgcmV0dXJuIHNlZzAuZXZlbnRSYW5nZS5yYW5nZS5zdGFydCA8IHNlZzEuZXZlbnRSYW5nZS5yYW5nZS5zdGFydCA/IHNlZzAgOiBzZWcxXG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVMYXRlc3RTZWdFbmQoc2VnczogU2VnW10pOiBEYXRlTWFya2VyIHtcbiAgcmV0dXJuIHNlZ3MucmVkdWNlKHBpY2tMYXRlc3RFbmQpLmV2ZW50UmFuZ2UucmFuZ2UuZW5kXG59XG5cbmZ1bmN0aW9uIHBpY2tMYXRlc3RFbmQoc2VnMDogU2VnLCBzZWcxOiBTZWcpOiBTZWcge1xuICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLmVuZCA+IHNlZzEuZXZlbnRSYW5nZS5yYW5nZS5lbmQgPyBzZWcwIDogc2VnMVxufVxuIiwiaW1wb3J0ICcuL21haW4uY3NzJ1xuXG4vLyBleHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgdmVyc2lvbjogc3RyaW5nID0gJzwlPSB2ZXJzaW9uICU+JyAvLyBpbXBvcnRhbnQgdG8gdHlwZSBpdCwgc28gLmQudHMgaGFzIGdlbmVyaWMgc3RyaW5nXG5cbi8vIGV4cGxpY2l0IEFQSVxuZXhwb3J0IHsgRXZlbnRTb3VyY2VBcGkgfSBmcm9tICcuL2FwaS9FdmVudFNvdXJjZUFwaSdcbmV4cG9ydCB7IEV2ZW50QXBpLCBidWlsZEV2ZW50QXBpcyB9IGZyb20gJy4vYXBpL0V2ZW50QXBpJ1xuZXhwb3J0IHsgQ2FsZW5kYXJBcGkgfSBmcm9tICcuL0NhbGVuZGFyQXBpJ1xuZXhwb3J0IHsgZm9ybWF0RGF0ZSwgZm9ybWF0UmFuZ2UsIEZvcm1hdERhdGVPcHRpb25zLCBGb3JtYXRSYW5nZU9wdGlvbnMgfSBmcm9tICcuL2Zvcm1hdHRpbmctYXBpJ1xuZXhwb3J0IHsgVmlld0FwaSB9IGZyb20gJy4vVmlld0FwaSdcbmV4cG9ydCAqIGZyb20gJy4vYXBpLXR5cGUtZGVwcydcblxuZXhwb3J0IHsgLy8gdGhpbmdzIGZvciBwbHVnaW5zLiBldmVyeXRoaW5nIGVsc2UgaXMgZXhwb3J0ZWQgaW4gYXBpLXR5cGUtZGVwc1xuICBCQVNFX09QVElPTl9ERUZBVUxUUywgQkFTRV9PUFRJT05fUkVGSU5FUlMsIGlkZW50aXR5LCBJZGVudGl0eSwgRGljdGlvbmFyeSwgcmVmaW5lUHJvcHMsXG4gIEJhc2VPcHRpb25SZWZpbmVycywgQmFzZU9wdGlvbnNSZWZpbmVkLCBDYWxlbmRhck9wdGlvblJlZmluZXJzLCBDYWxlbmRhck9wdGlvbnNSZWZpbmVkLFxuICBWaWV3T3B0aW9uUmVmaW5lcnMsIFZpZXdPcHRpb25zUmVmaW5lZCwgUmF3T3B0aW9uc0Zyb21SZWZpbmVycywgUmVmaW5lZE9wdGlvbnNGcm9tUmVmaW5lcnMsXG4gIENhbGVuZGFyTGlzdGVuZXJSZWZpbmVycyxcbn0gZnJvbSAnLi9vcHRpb25zJ1xuXG5leHBvcnQgeyBFdmVudERlZiwgRXZlbnREZWZIYXNoIH0gZnJvbSAnLi9zdHJ1Y3RzL2V2ZW50LWRlZidcbmV4cG9ydCB7IEV2ZW50SW5zdGFuY2UsIEV2ZW50SW5zdGFuY2VIYXNoLCBjcmVhdGVFdmVudEluc3RhbmNlIH0gZnJvbSAnLi9zdHJ1Y3RzL2V2ZW50LWluc3RhbmNlJ1xuZXhwb3J0IHsgRXZlbnRJbnB1dCwgRXZlbnRSZWZpbmVkLCBwYXJzZUV2ZW50RGVmLCBFdmVudFR1cGxlLCBFdmVudFJlZmluZXJzLCByZWZpbmVFdmVudERlZiB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1wYXJzZSdcbmV4cG9ydCB7IEJ1c2luZXNzSG91cnNJbnB1dCwgcGFyc2VCdXNpbmVzc0hvdXJzIH0gZnJvbSAnLi9zdHJ1Y3RzL2J1c2luZXNzLWhvdXJzJ1xuXG5leHBvcnQge1xuICBwYWRTdGFydCxcbiAgaXNJbnQsXG4gIHBhcnNlRmllbGRTcGVjcyxcbiAgY29tcGFyZUJ5RmllbGRTcGVjcyxcbiAgY29tcGFyZUJ5RmllbGRTcGVjLFxuICBmbGV4aWJsZUNvbXBhcmUsXG4gIHByZXZlbnRTZWxlY3Rpb24sIGFsbG93U2VsZWN0aW9uLCBwcmV2ZW50Q29udGV4dE1lbnUsIGFsbG93Q29udGV4dE1lbnUsXG4gIGNvbXBhcmVOdW1iZXJzLCBlbmFibGVDdXJzb3IsIGRpc2FibGVDdXJzb3IsXG4gIGd1aWQsXG4gIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aCxcbiAgT3JkZXJTcGVjLFxufSBmcm9tICcuL3V0aWwvbWlzYydcblxuZXhwb3J0IHtcbiAgY29tcHV0ZVZpc2libGVEYXlSYW5nZSxcbiAgaXNNdWx0aURheVJhbmdlLFxuICBkaWZmRGF0ZXMsXG59IGZyb20gJy4vdXRpbC9kYXRlJ1xuXG5leHBvcnQge1xuICByZW1vdmVFeGFjdCxcbiAgaXNBcnJheXNFcXVhbCxcbn0gZnJvbSAnLi91dGlsL2FycmF5J1xuXG5leHBvcnQgeyBtZW1vaXplLCBtZW1vaXplT2JqQXJnLCBtZW1vaXplQXJyYXlsaWtlLCBtZW1vaXplSGFzaGxpa2UgfSBmcm9tICcuL3V0aWwvbWVtb2l6ZSdcblxuZXhwb3J0IHtcbiAgaW50ZXJzZWN0UmVjdHMsXG4gIFJlY3QsIHBvaW50SW5zaWRlUmVjdCxcbiAgY29uc3RyYWluUG9pbnQsXG4gIGdldFJlY3RDZW50ZXIsIGRpZmZQb2ludHMsIFBvaW50LFxuICB0cmFuc2xhdGVSZWN0LFxufSBmcm9tICcuL3V0aWwvZ2VvbSdcblxuZXhwb3J0IHsgbWFwSGFzaCwgZmlsdGVySGFzaCwgaXNQcm9wc0VxdWFsLCBjb21wYXJlT2JqcywgYnVpbGRIYXNoRnJvbUFycmF5LCBjb2xsZWN0RnJvbUhhc2gsIGdldFVuZXF1YWxQcm9wcyB9IGZyb20gJy4vdXRpbC9vYmplY3QnXG5cbmV4cG9ydCB7XG4gIGZpbmRFbGVtZW50cyxcbiAgZmluZERpcmVjdENoaWxkcmVuLFxuICByZW1vdmVFbGVtZW50LFxuICBhcHBseVN0eWxlLFxuICBhcHBseVN0eWxlUHJvcCxcbiAgZWxlbWVudE1hdGNoZXMsXG4gIGVsZW1lbnRDbG9zZXN0LFxuICBnZXRFbFJvb3QsXG4gIGdldEV2ZW50VGFyZ2V0VmlhUm9vdCxcbn0gZnJvbSAnLi91dGlsL2RvbS1tYW5pcCdcbmV4cG9ydCB7IHBhcnNlQ2xhc3NOYW1lcyB9IGZyb20gJy4vdXRpbC9odG1sJ1xuXG5leHBvcnQgeyBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgfSBmcm9tICcuL3V0aWwvdGFibGUtc3R5bGluZydcblxuZXhwb3J0IHtcbiAgRXZlbnRTdG9yZSxcbiAgZmlsdGVyRXZlbnRTdG9yZURlZnMsXG4gIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSxcbiAgbWVyZ2VFdmVudFN0b3JlcyxcbiAgZ2V0UmVsZXZhbnRFdmVudHMsXG4gIGV2ZW50VHVwbGVUb1N0b3JlLFxufSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc3RvcmUnXG5leHBvcnQgeyBFdmVudFVpSGFzaCwgRXZlbnRVaSwgY29tYmluZUV2ZW50VWlzLCBjcmVhdGVFdmVudFVpIH0gZnJvbSAnLi9jb21wb25lbnQvZXZlbnQtdWknXG5leHBvcnQgeyBTcGxpdHRlciwgU3BsaXR0YWJsZVByb3BzIH0gZnJvbSAnLi9jb21wb25lbnQvZXZlbnQtc3BsaXR0aW5nJ1xuZXhwb3J0IHsgZ2V0RGF5Q2xhc3NOYW1lcywgZ2V0RGF0ZU1ldGEsIERhdGVNZXRhLCBnZXRTbG90Q2xhc3NOYW1lcyB9IGZyb20gJy4vY29tcG9uZW50L2RhdGUtcmVuZGVyaW5nJ1xuZXhwb3J0IHsgYnVpbGROYXZMaW5rRGF0YSB9IGZyb20gJy4vY29tbW9uL25hdi1saW5rJ1xuXG5leHBvcnQge1xuICBwcmV2ZW50RGVmYXVsdCxcbiAgbGlzdGVuQnlTZWxlY3RvcixcbiAgd2hlblRyYW5zaXRpb25Eb25lLFxufSBmcm9tICcuL3V0aWwvZG9tLWV2ZW50J1xuXG5leHBvcnQge1xuICBjb21wdXRlSW5uZXJSZWN0LFxuICBjb21wdXRlRWRnZXMsXG4gIGNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zLFxuICBnZXRDbGlwcGluZ1BhcmVudHMsXG4gIGNvbXB1dGVSZWN0LFxufSBmcm9tICcuL3V0aWwvZG9tLWdlb20nXG5cbmV4cG9ydCB7IHVucHJvbWlzaWZ5IH0gZnJvbSAnLi91dGlsL3Byb21pc2UnXG5cbmV4cG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuL2NvbW1vbi9FbWl0dGVyJ1xuZXhwb3J0IHsgRGF0ZVJhbmdlLCByYW5nZUNvbnRhaW5zTWFya2VyLCBpbnRlcnNlY3RSYW5nZXMsIHJhbmdlc0VxdWFsLCByYW5nZXNJbnRlcnNlY3QsIHJhbmdlQ29udGFpbnNSYW5nZSB9IGZyb20gJy4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuZXhwb3J0IHsgUG9zaXRpb25DYWNoZSB9IGZyb20gJy4vY29tbW9uL1Bvc2l0aW9uQ2FjaGUnXG5leHBvcnQgeyBTY3JvbGxDb250cm9sbGVyLCBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciwgV2luZG93U2Nyb2xsQ29udHJvbGxlciB9IGZyb20gJy4vY29tbW9uL3Njcm9sbC1jb250cm9sbGVyJ1xuZXhwb3J0IHsgVGhlbWUgfSBmcm9tICcuL3RoZW1lL1RoZW1lJ1xuZXhwb3J0IHsgVmlld0NvbnRleHQsIFZpZXdDb250ZXh0VHlwZSB9IGZyb20gJy4vVmlld0NvbnRleHQnXG5leHBvcnQgeyBEYXRlQ29tcG9uZW50LCBTZWcsIEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIH0gZnJvbSAnLi9jb21wb25lbnQvRGF0ZUNvbXBvbmVudCdcbmV4cG9ydCB7IENhbGVuZGFyRGF0YSB9IGZyb20gJy4vcmVkdWNlcnMvZGF0YS10eXBlcydcbmV4cG9ydCB7IENhbGVuZGFyRGF0YU1hbmFnZXIgfSBmcm9tICcuL3JlZHVjZXJzL0NhbGVuZGFyRGF0YU1hbmFnZXInXG5leHBvcnQgeyBDYWxlbmRhckRhdGFQcm92aWRlciwgQ2FsZW5kYXJEYXRhUHJvdmlkZXJQcm9wcyB9IGZyb20gJy4vY29tcG9uZW50L0NhbGVuZGFyRGF0YVByb3ZpZGVyJ1xuZXhwb3J0IHsgVmlld1Byb3BzLCBzbGljZUV2ZW50cyB9IGZyb20gJy4vVmlldydcblxuZXhwb3J0IHsgRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIERhdGVQcm9maWxlIH0gZnJvbSAnLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmV4cG9ydCB7IFZpZXdEZWYgfSBmcm9tICcuL3N0cnVjdHMvdmlldy1kZWYnXG5leHBvcnQgeyBWaWV3U3BlYyB9IGZyb20gJy4vc3RydWN0cy92aWV3LXNwZWMnXG5leHBvcnQgeyBEYXRlU3BhbiwgRGF0ZVNwYW5BcGksIERhdGVQb2ludEFwaSwgaXNEYXRlU3BhbnNFcXVhbCB9IGZyb20gJy4vc3RydWN0cy9kYXRlLXNwYW4nXG5cbmV4cG9ydCB7XG4gIERhdGVNYXJrZXIsXG4gIGFkZERheXMsXG4gIHN0YXJ0T2ZEYXksXG4gIGFkZE1zLFxuICBhZGRXZWVrcyxcbiAgZGlmZldlZWtzLFxuICBkaWZmV2hvbGVXZWVrcyxcbiAgZGlmZldob2xlRGF5cyxcbiAgZGlmZkRheUFuZFRpbWUsXG4gIGRpZmZEYXlzLFxuICBpc1ZhbGlkRGF0ZSxcbn0gZnJvbSAnLi9kYXRlbGliL21hcmtlcidcbmV4cG9ydCB7XG4gIER1cmF0aW9uLCBjcmVhdGVEdXJhdGlvbixcbiAgYXNDbGVhbkRheXMsIG11bHRpcGx5RHVyYXRpb24sIGFkZER1cmF0aW9ucyxcbiAgYXNSb3VnaE1pbnV0ZXMsIGFzUm91Z2hTZWNvbmRzLCBhc1JvdWdoTXMsXG4gIHdob2xlRGl2aWRlRHVyYXRpb25zLCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IsXG59IGZyb20gJy4vZGF0ZWxpYi9kdXJhdGlvbidcbmV4cG9ydCB7IERhdGVFbnYsIERhdGVNYXJrZXJNZXRhIH0gZnJvbSAnLi9kYXRlbGliL2VudidcblxuZXhwb3J0IHtcbiAgY3JlYXRlRm9ybWF0dGVyLFxuICBGb3JtYXR0ZXJJbnB1dCxcbn0gZnJvbSAnLi9kYXRlbGliL2Zvcm1hdHRpbmcnXG5leHBvcnQge1xuICBEYXRlRm9ybWF0dGVyLFxuICBWZXJib3NlRm9ybWF0dGluZ0FyZyxcbn0gZnJvbSAnLi9kYXRlbGliL0RhdGVGb3JtYXR0ZXInXG5leHBvcnQge1xuICBmb3JtYXRJc29UaW1lU3RyaW5nLFxuICBmb3JtYXREYXlTdHJpbmcsXG4gIGJ1aWxkSXNvU3RyaW5nLFxufSBmcm9tICcuL2RhdGVsaWIvZm9ybWF0dGluZy11dGlscydcbmV4cG9ydCB7IE5hbWVkVGltZVpvbmVJbXBsIH0gZnJvbSAnLi9kYXRlbGliL3RpbWV6b25lJ1xuZXhwb3J0IHsgcGFyc2UgYXMgcGFyc2VNYXJrZXIgfSBmcm9tICcuL2RhdGVsaWIvcGFyc2luZydcbmV4cG9ydCB7IExvY2FsZUlucHV0IH0gZnJvbSAnLi9kYXRlbGliL2xvY2FsZSdcblxuZXhwb3J0IHsgRXZlbnRTb3VyY2VEZWYgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc291cmNlLWRlZidcbmV4cG9ydCB7IEV2ZW50U291cmNlLCBFdmVudFNvdXJjZUhhc2ggfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc291cmNlJ1xuZXhwb3J0IHsgRXZlbnRTb3VyY2VSZWZpbmVycywgRXZlbnRTb3VyY2VSZWZpbmVkIH0gZnJvbSAnLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZS1wYXJzZSdcblxuZXhwb3J0IHtcbiAgU2VnU3BhbiwgU2VnUmVjdCwgU2VnSGllcmFyY2h5LCBTZWdFbnRyeSwgU2VnSW5zZXJ0aW9uLCBidWlsZEVudHJ5S2V5LFxuICBnZXRFbnRyeVNwYW5FbmQsIGJpbmFyeVNlYXJjaCwgU2VnRW50cnlHcm91cCwgZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzLFxuICBqb2luU3BhbnMsIGludGVyc2VjdFNwYW5zLFxufSBmcm9tICcuL3NlZy1oaWVyYXJjaHknXG5cbmV4cG9ydCB7XG4gIEludGVyYWN0aW9uLFxuICBJbnRlcmFjdGlvblNldHRpbmdzLFxuICBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZSxcbiAgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlLFxuICBJbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsXG59IGZyb20gJy4vaW50ZXJhY3Rpb25zL2ludGVyYWN0aW9uJ1xuZXhwb3J0IHsgUG9pbnRlckRyYWdFdmVudCB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL3BvaW50ZXInXG5leHBvcnQgeyBIaXQgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9oaXQnXG5leHBvcnQgeyBkYXRlU2VsZWN0aW9uSm9pblRyYW5zZm9ybWVyIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvZGF0ZS1zZWxlY3RpbmcnXG5leHBvcnQgeyBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyLCBFdmVudERyb3BUcmFuc2Zvcm1lcnMgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9ldmVudC1kcmFnZ2luZydcbmV4cG9ydCB7IEVsZW1lbnREcmFnZ2luZyB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL0VsZW1lbnREcmFnZ2luZydcblxuZXhwb3J0IHsgY29uZmlnIH0gZnJvbSAnLi9nbG9iYWwtY29uZmlnJ1xuZXhwb3J0IHsgZ2xvYmFsTG9jYWxlcyB9IGZyb20gJy4vZ2xvYmFsLWxvY2FsZXMnXG5cbmV4cG9ydCB7IFJlY3VycmluZ1R5cGUsIFBhcnNlZFJlY3VycmluZyB9IGZyb20gJy4vc3RydWN0cy9yZWN1cnJpbmctZXZlbnQnXG5cbmV4cG9ydCB7IERyYWdNZXRhSW5wdXQsIERyYWdNZXRhLCBwYXJzZURyYWdNZXRhIH0gZnJvbSAnLi9zdHJ1Y3RzL2RyYWctbWV0YSdcblxuZXhwb3J0IHsgUGx1Z2luRGVmLCBQbHVnaW5EZWZJbnB1dCwgVmlld1Byb3BzVHJhbnNmb3JtZXIsIFZpZXdDb250YWluZXJBcHBlbmQgfSBmcm9tICcuL3BsdWdpbi1zeXN0ZW0tc3RydWN0J1xuZXhwb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnLi9wbHVnaW4tc3lzdGVtJ1xuZXhwb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9yZWR1Y2Vycy9BY3Rpb24nXG5leHBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuL0NhbGVuZGFyQ29udGV4dCdcbmV4cG9ydCB7IENhbGVuZGFyQ29udGVudFByb3BzLCBDYWxlbmRhckNvbnRlbnQgfSBmcm9tICcuL0NhbGVuZGFyQ29udGVudCdcbmV4cG9ydCB7IENhbGVuZGFyUm9vdCB9IGZyb20gJy4vQ2FsZW5kYXJSb290J1xuXG5leHBvcnQgeyBEYXlIZWFkZXIgfSBmcm9tICcuL2NvbW1vbi9EYXlIZWFkZXInXG5leHBvcnQgeyBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQgfSBmcm9tICcuL2NvbW1vbi90YWJsZS11dGlscydcbmV4cG9ydCB7IFRhYmxlRGF0ZUNlbGwgfSBmcm9tICcuL2NvbW1vbi9UYWJsZURhdGVDZWxsJ1xuZXhwb3J0IHsgVGFibGVEb3dDZWxsIH0gZnJvbSAnLi9jb21tb24vVGFibGVEb3dDZWxsJ1xuXG5leHBvcnQgeyBEYXlTZXJpZXNNb2RlbCB9IGZyb20gJy4vY29tbW9uL0RheVNlcmllc01vZGVsJ1xuXG5leHBvcnQgeyBFdmVudEludGVyYWN0aW9uU3RhdGUgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9ldmVudC1pbnRlcmFjdGlvbi1zdGF0ZSdcbmV4cG9ydCB7XG4gIEV2ZW50UmVuZGVyUmFuZ2UsIHNsaWNlRXZlbnRTdG9yZSwgaGFzQmdSZW5kZXJpbmcsIHNldEVsU2VnLCBnZXRFbFNlZyxcbiAgY29tcHV0ZVNlZ0RyYWdnYWJsZSwgY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlLCBjb21wdXRlU2VnRW5kUmVzaXphYmxlLFxuICBnZXRFdmVudENsYXNzTmFtZXMsIGJ1aWxkU2VnVGltZVRleHQsXG4gIGJ1aWxkU2VnQ29tcGFyZU9iaiwgc29ydEV2ZW50U2VncyxcbiAgZ2V0U2VnTWV0YSwgRXZlbnRDb250ZW50QXJnLCBidWlsZEV2ZW50UmFuZ2VLZXksXG59IGZyb20gJy4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcblxuZXhwb3J0IHsgRGF5VGFibGVNb2RlbCwgRGF5VGFibGVTZWcsIERheVRhYmxlQ2VsbCB9IGZyb20gJy4vY29tbW9uL0RheVRhYmxlTW9kZWwnXG5cbmV4cG9ydCB7IFNsaWNlciwgU2xpY2VkUHJvcHMgfSBmcm9tICcuL2NvbW1vbi9zbGljaW5nLXV0aWxzJ1xuXG5leHBvcnQgeyBFdmVudE11dGF0aW9uLCBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlIH0gZnJvbSAnLi9zdHJ1Y3RzL2V2ZW50LW11dGF0aW9uJ1xuZXhwb3J0IHsgQ29uc3RyYWludCwgQ29uc3RyYWludElucHV0LCBBbGxvd0Z1bmMgfSBmcm9tICcuL3N0cnVjdHMvY29uc3RyYWludCdcbmV4cG9ydCB7IGlzUHJvcHNWYWxpZCwgaXNJbnRlcmFjdGlvblZhbGlkLCBpc0RhdGVTZWxlY3Rpb25WYWxpZCB9IGZyb20gJy4vdmFsaWRhdGlvbidcblxuZXhwb3J0IHsgcmVxdWVzdEpzb24gfSBmcm9tICcuL3V0aWwvcmVxdWVzdEpzb24nXG5cbmV4cG9ydCAqIGZyb20gJy4vdmRvbSdcbmV4cG9ydCB7IEJhc2VDb21wb25lbnQsIHNldFJlZiB9IGZyb20gJy4vdmRvbS11dGlsJ1xuZXhwb3J0IHsgRGVsYXllZFJ1bm5lciB9IGZyb20gJy4vdXRpbC9EZWxheWVkUnVubmVyJ1xuXG5leHBvcnQge1xuICBTY3JvbGxHcmlkUHJvcHMsXG4gIFNjcm9sbEdyaWRTZWN0aW9uQ29uZmlnLFxuICBDb2xHcm91cENvbmZpZyxcbiAgU2Nyb2xsR3JpZEltcGwsXG4gIFNjcm9sbEdyaWRDaHVua0NvbmZpZyxcbn0gZnJvbSAnLi9zY3JvbGxncmlkL1Njcm9sbEdyaWRJbXBsJ1xuZXhwb3J0IHsgU2ltcGxlU2Nyb2xsR3JpZCwgU2ltcGxlU2Nyb2xsR3JpZFNlY3Rpb24gfSBmcm9tICcuL3Njcm9sbGdyaWQvU2ltcGxlU2Nyb2xsR3JpZCdcbmV4cG9ydCB7XG4gIENzc0RpbVZhbHVlLCBTY3JvbGxlckxpa2UsIFNlY3Rpb25Db25maWcsIENvbFByb3BzLCBDaHVua0NvbmZpZywgaGFzU2hyaW5rV2lkdGgsIHJlbmRlck1pY3JvQ29sR3JvdXAsXG4gIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzLCBnZXRTZWN0aW9uQ2xhc3NOYW1lcywgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodCwgZ2V0QWxsb3dZU2Nyb2xsaW5nLCByZW5kZXJDaHVua0NvbnRlbnQsIGNvbXB1dGVTaHJpbmtXaWR0aCxcbiAgQ2h1bmtDb250ZW50Q2FsbGJhY2tBcmdzLFxuICBzYW5pdGl6ZVNocmlua1dpZHRoLFxuICBDaHVua0NvbmZpZ1Jvd0NvbnRlbnQsIENodW5rQ29uZmlnQ29udGVudCxcbiAgaXNDb2xQcm9wc0VxdWFsLFxuICByZW5kZXJTY3JvbGxTaGltLFxuICBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsXG4gIGdldFN0aWNreUhlYWRlckRhdGVzLFxufSBmcm9tICcuL3Njcm9sbGdyaWQvdXRpbCdcbmV4cG9ydCB7IFNjcm9sbGVyLCBTY3JvbGxlclByb3BzLCBPdmVyZmxvd1ZhbHVlIH0gZnJvbSAnLi9zY3JvbGxncmlkL1Njcm9sbGVyJ1xuZXhwb3J0IHsgZ2V0U2Nyb2xsYmFyV2lkdGhzIH0gZnJvbSAnLi91dGlsL3Njcm9sbGJhci13aWR0aCdcbmV4cG9ydCB7IFJlZk1hcCB9IGZyb20gJy4vdXRpbC9SZWZNYXAnXG5leHBvcnQgeyBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCB9IGZyb20gJy4vdXRpbC9zY3JvbGxiYXItc2lkZSdcblxuZXhwb3J0IHsgTm93VGltZXIgfSBmcm9tICcuL05vd1RpbWVyJ1xuZXhwb3J0IHsgU2Nyb2xsUmVzcG9uZGVyLCBTY3JvbGxSZXF1ZXN0IH0gZnJvbSAnLi9TY3JvbGxSZXNwb25kZXInXG5leHBvcnQgeyBnbG9iYWxQbHVnaW5zIH0gZnJvbSAnLi9nbG9iYWwtcGx1Z2lucydcbmV4cG9ydCB7XG4gIFJlbmRlckhvb2ssIFJlbmRlckhvb2tQcm9wcywgUmVuZGVySG9va1Byb3BzQ2hpbGRyZW4sIE1vdW50SG9vaywgTW91bnRIb29rUHJvcHMsIGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplciwgQ29udGVudEhvb2ssXG4gIEN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0LCBDbGFzc05hbWVzR2VuZXJhdG9yLCBDdXN0b21Db250ZW50R2VuZXJhdG9yLCBEaWRNb3VudEhhbmRsZXIsIFdpbGxVbm1vdW50SGFuZGxlciwgTW91bnRBcmcsXG59IGZyb20gJy4vY29tbW9uL3JlbmRlci1ob29rJ1xuZXhwb3J0IHsgU3RhbmRhcmRFdmVudCwgU3RhbmRhcmRFdmVudFByb3BzIH0gZnJvbSAnLi9jb21tb24vU3RhbmRhcmRFdmVudCdcbmV4cG9ydCB7IE5vd0luZGljYXRvclJvb3QsIE5vd0luZGljYXRvclJvb3RQcm9wcyB9IGZyb20gJy4vY29tbW9uL05vd0luZGljYXRvclJvb3QnXG5cbmV4cG9ydCB7IERheUNlbGxSb290LCBEYXlDZWxsUm9vdFByb3BzLCBEYXlDZWxsQ29udGVudEFyZyB9IGZyb20gJy4vY29tbW9uL0RheUNlbGxSb290J1xuZXhwb3J0IHsgRGF5Q2VsbENvbnRlbnQsIERheUNlbGxDb250ZW50UHJvcHMgfSBmcm9tICcuL2NvbW1vbi9EYXlDZWxsQ29udGVudCdcbmV4cG9ydCB7IEV2ZW50Um9vdCwgTWluaW1hbEV2ZW50UHJvcHMgfSBmcm9tICcuL2NvbW1vbi9FdmVudFJvb3QnXG5leHBvcnQgeyByZW5kZXJGaWxsLCBCZ0V2ZW50LCBCZ0V2ZW50UHJvcHMgfSBmcm9tICcuL2NvbW1vbi9iZy1maWxsJ1xuZXhwb3J0IHsgV2Vla051bWJlclJvb3QsIFdlZWtOdW1iZXJSb290UHJvcHMgfSBmcm9tICcuL2NvbW1vbi9XZWVrTnVtYmVyUm9vdCdcbmV4cG9ydCB7IE1vcmVMaW5rUm9vdCwgTW9yZUxpbmtSb290UHJvcHMsIE1vcmVMaW5rQ29udGVudEFyZywgTW9yZUxpbmtNb3VudEFyZywgY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQgfSBmcm9tICcuL2NvbW1vbi9Nb3JlTGlua1Jvb3QnXG5cbmV4cG9ydCB7IFZpZXdSb290LCBWaWV3Um9vdFByb3BzIH0gZnJvbSAnLi9jb21tb24vVmlld1Jvb3QnXG5leHBvcnQgeyB0cmlnZ2VyRGF0ZVNlbGVjdCwgRGF0ZVBvaW50VHJhbnNmb3JtLCBEYXRlU3BhblRyYW5zZm9ybSwgRGF0ZVNlbGVjdGlvbkFwaSwgZ2V0RGVmYXVsdEV2ZW50RW5kIH0gZnJvbSAnLi9jYWxlbmRhci11dGlscydcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/vdom.js":
/*!***************************************************!*\
  !*** ./node_modules/@fullcalendar/common/vdom.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Component\": () => (/* binding */ Component),\n/* harmony export */   \"Fragment\": () => (/* binding */ Fragment),\n/* harmony export */   \"createContext\": () => (/* binding */ createContext),\n/* harmony export */   \"createElement\": () => (/* binding */ createElement),\n/* harmony export */   \"createPortal\": () => (/* binding */ createPortal),\n/* harmony export */   \"createRef\": () => (/* binding */ createRef),\n/* harmony export */   \"flushToDom\": () => (/* binding */ flushToDom),\n/* harmony export */   \"render\": () => (/* binding */ render),\n/* harmony export */   \"unmountComponentAtNode\": () => (/* binding */ unmountComponentAtNode)\n/* harmony export */ });\n/// <reference types=\"@fullcalendar/core-preact\" />\nif (typeof FullCalendarVDom === 'undefined') {\n  throw new Error('Please import the top-level fullcalendar lib before attempting to import a plugin.');\n}\n\nvar Component = FullCalendarVDom.Component;\nvar createElement = FullCalendarVDom.createElement;\nvar render = FullCalendarVDom.render;\nvar createRef = FullCalendarVDom.createRef;\nvar Fragment = FullCalendarVDom.Fragment;\nvar createContext = FullCalendarVDom.createContext;\nvar createPortal = FullCalendarVDom.createPortal;\nvar flushToDom = FullCalendarVDom.flushToDom;\nvar unmountComponentAtNode = FullCalendarVDom.unmountComponentAtNode;\n/* eslint-enable */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vdmRvbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29tbW9uL3Zkb20uanM/ZGU4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cIkBmdWxsY2FsZW5kYXIvY29yZS1wcmVhY3RcIiAvPlxuaWYgKHR5cGVvZiBGdWxsQ2FsZW5kYXJWRG9tID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGltcG9ydCB0aGUgdG9wLWxldmVsIGZ1bGxjYWxlbmRhciBsaWIgYmVmb3JlIGF0dGVtcHRpbmcgdG8gaW1wb3J0IGEgcGx1Z2luLicpO1xufVxudmFyIENvbXBvbmVudCA9IEZ1bGxDYWxlbmRhclZEb20uQ29tcG9uZW50O1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBGdWxsQ2FsZW5kYXJWRG9tLmNyZWF0ZUVsZW1lbnQ7XG52YXIgcmVuZGVyID0gRnVsbENhbGVuZGFyVkRvbS5yZW5kZXI7XG52YXIgY3JlYXRlUmVmID0gRnVsbENhbGVuZGFyVkRvbS5jcmVhdGVSZWY7XG52YXIgRnJhZ21lbnQgPSBGdWxsQ2FsZW5kYXJWRG9tLkZyYWdtZW50O1xudmFyIGNyZWF0ZUNvbnRleHQgPSBGdWxsQ2FsZW5kYXJWRG9tLmNyZWF0ZUNvbnRleHQ7XG52YXIgY3JlYXRlUG9ydGFsID0gRnVsbENhbGVuZGFyVkRvbS5jcmVhdGVQb3J0YWw7XG52YXIgZmx1c2hUb0RvbSA9IEZ1bGxDYWxlbmRhclZEb20uZmx1c2hUb0RvbTtcbnZhciB1bm1vdW50Q29tcG9uZW50QXROb2RlID0gRnVsbENhbGVuZGFyVkRvbS51bm1vdW50Q29tcG9uZW50QXROb2RlO1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5leHBvcnQgeyBDb21wb25lbnQsIEZyYWdtZW50LCBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBjcmVhdGVQb3J0YWwsIGNyZWF0ZVJlZiwgZmx1c2hUb0RvbSwgcmVuZGVyLCB1bm1vdW50Q29tcG9uZW50QXROb2RlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/vdom.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/core/locales-all.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/core/locales-all.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar l0 = {\n  code: 'af',\n  week: {\n    dow: 1,\n    // Maandag is die eerste dag van die week.\n    doy: 4 // Die week wat die 4de Januarie bevat is die eerste week van die jaar.\n\n  },\n  buttonText: {\n    prev: 'Vorige',\n    next: 'Volgende',\n    today: 'Vandag',\n    year: 'Jaar',\n    month: 'Maand',\n    week: 'Week',\n    day: 'Dag',\n    list: 'Agenda'\n  },\n  allDayText: 'Heeldag',\n  moreLinkText: 'Addisionele',\n  noEventsText: 'Daar is geen gebeurtenisse nie'\n};\nvar l1 = {\n  code: 'ar-dz',\n  week: {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 4 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: '',\n  noEventsText: '  '\n};\nvar l2 = {\n  code: 'ar-kw',\n  week: {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: '',\n  noEventsText: '  '\n};\nvar l3 = {\n  code: 'ar-ly',\n  week: {\n    dow: 6,\n    // Saturday is the first day of the week.\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: '',\n  noEventsText: '  '\n};\nvar l4 = {\n  code: 'ar-ma',\n  week: {\n    dow: 6,\n    // Saturday is the first day of the week.\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: '',\n  noEventsText: '  '\n};\nvar l5 = {\n  code: 'ar-sa',\n  week: {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 6 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: '',\n  noEventsText: '  '\n};\nvar l6 = {\n  code: 'ar-tn',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: '',\n  noEventsText: '  '\n};\nvar l7 = {\n  code: 'ar',\n  week: {\n    dow: 6,\n    // Saturday is the first day of the week.\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: '',\n  noEventsText: '  '\n};\nvar l8 = {\n  code: 'az',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'vvl',\n    next: 'Sonra',\n    today: 'Bu Gn',\n    month: 'Ay',\n    week: 'Hft',\n    day: 'Gn',\n    list: 'Gndm'\n  },\n  weekText: 'Hft',\n  allDayText: 'Btn Gn',\n  moreLinkText: function (n) {\n    return '+ daha ox ' + n;\n  },\n  noEventsText: 'Gstrmk n hadis yoxdur'\n};\nvar l9 = {\n  code: 'bg',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  allDayText: ' ',\n  moreLinkText: function (n) {\n    return '+ ' + n;\n  },\n  noEventsText: '   '\n};\nvar l10 = {\n  code: 'bn',\n  week: {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 6 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: '',\n  moreLinkText: function (n) {\n    return '+ ' + n;\n  },\n  noEventsText: '  '\n};\nvar l11 = {\n  code: 'bs',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Proli',\n    next: 'Sljedei',\n    today: 'Danas',\n    month: 'Mjesec',\n    week: 'Sedmica',\n    day: 'Dan',\n    list: 'Raspored'\n  },\n  weekText: 'Sed',\n  allDayText: 'Cijeli dan',\n  moreLinkText: function (n) {\n    return '+ jo ' + n;\n  },\n  noEventsText: 'Nema dogaaja za prikazivanje'\n};\nvar l12 = {\n  code: 'ca',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Anterior',\n    next: 'Segent',\n    today: 'Avui',\n    month: 'Mes',\n    week: 'Setmana',\n    day: 'Dia',\n    list: 'Agenda'\n  },\n  weekText: 'Set',\n  allDayText: 'Tot el dia',\n  moreLinkText: 'ms',\n  noEventsText: 'No hi ha esdeveniments per mostrar'\n};\nvar l13 = {\n  code: 'cs',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Dve',\n    next: 'Pozdji',\n    today: 'Nyn',\n    month: 'Msc',\n    week: 'Tden',\n    day: 'Den',\n    list: 'Agenda'\n  },\n  weekText: 'Td',\n  allDayText: 'Cel den',\n  moreLinkText: function (n) {\n    return '+dal: ' + n;\n  },\n  noEventsText: 'dn akce k zobrazen'\n};\nvar l14 = {\n  code: 'cy',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Blaenorol',\n    next: 'Nesaf',\n    today: 'Heddiw',\n    year: 'Blwyddyn',\n    month: 'Mis',\n    week: 'Wythnos',\n    day: 'Dydd',\n    list: 'Rhestr'\n  },\n  weekText: 'Wythnos',\n  allDayText: 'Trwy\\'r dydd',\n  moreLinkText: 'Mwy',\n  noEventsText: 'Dim digwyddiadau'\n};\nvar l15 = {\n  code: 'da',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Forrige',\n    next: 'Nste',\n    today: 'I dag',\n    month: 'Mned',\n    week: 'Uge',\n    day: 'Dag',\n    list: 'Agenda'\n  },\n  weekText: 'Uge',\n  allDayText: 'Hele dagen',\n  moreLinkText: 'flere',\n  noEventsText: 'Ingen arrangementer at vise'\n};\nvar l16 = {\n  code: 'de-at',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Zurck',\n    next: 'Vor',\n    today: 'Heute',\n    year: 'Jahr',\n    month: 'Monat',\n    week: 'Woche',\n    day: 'Tag',\n    list: 'Terminbersicht'\n  },\n  weekText: 'KW',\n  allDayText: 'Ganztgig',\n  moreLinkText: function (n) {\n    return '+ weitere ' + n;\n  },\n  noEventsText: 'Keine Ereignisse anzuzeigen'\n};\nvar l17 = {\n  code: 'de',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Zurck',\n    next: 'Vor',\n    today: 'Heute',\n    year: 'Jahr',\n    month: 'Monat',\n    week: 'Woche',\n    day: 'Tag',\n    list: 'Terminbersicht'\n  },\n  weekText: 'KW',\n  allDayText: 'Ganztgig',\n  moreLinkText: function (n) {\n    return '+ weitere ' + n;\n  },\n  noEventsText: 'Keine Ereignisse anzuzeigen'\n};\nvar l18 = {\n  code: 'el',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: '',\n  moreLinkText: '',\n  noEventsText: '    '\n};\nvar l19 = {\n  code: 'en-au',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  }\n};\nvar l20 = {\n  code: 'en-gb',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  }\n};\nvar l21 = {\n  code: 'en-nz',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  }\n};\nvar l22 = {\n  code: 'eo',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Antaa',\n    next: 'Sekva',\n    today: 'Hodia',\n    month: 'Monato',\n    week: 'Semajno',\n    day: 'Tago',\n    list: 'Tagordo'\n  },\n  weekText: 'Sm',\n  allDayText: 'Tuta tago',\n  moreLinkText: 'pli',\n  noEventsText: 'Neniuj eventoj por montri'\n};\nvar l23 = {\n  code: 'es',\n  week: {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 6 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Ant',\n    next: 'Sig',\n    today: 'Hoy',\n    month: 'Mes',\n    week: 'Semana',\n    day: 'Da',\n    list: 'Agenda'\n  },\n  weekText: 'Sm',\n  allDayText: 'Todo el da',\n  moreLinkText: 'ms',\n  noEventsText: 'No hay eventos para mostrar'\n};\nvar l24 = {\n  code: 'es',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Ant',\n    next: 'Sig',\n    today: 'Hoy',\n    month: 'Mes',\n    week: 'Semana',\n    day: 'Da',\n    list: 'Agenda'\n  },\n  weekText: 'Sm',\n  allDayText: 'Todo el da',\n  moreLinkText: 'ms',\n  noEventsText: 'No hay eventos para mostrar'\n};\nvar l25 = {\n  code: 'et',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Eelnev',\n    next: 'Jrgnev',\n    today: 'Tna',\n    month: 'Kuu',\n    week: 'Ndal',\n    day: 'Pev',\n    list: 'Pevakord'\n  },\n  weekText: 'nd',\n  allDayText: 'Kogu pev',\n  moreLinkText: function (n) {\n    return '+ veel ' + n;\n  },\n  noEventsText: 'Kuvamiseks puuduvad sndmused'\n};\nvar l26 = {\n  code: 'eu',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Aur',\n    next: 'Hur',\n    today: 'Gaur',\n    month: 'Hilabetea',\n    week: 'Astea',\n    day: 'Eguna',\n    list: 'Agenda'\n  },\n  weekText: 'As',\n  allDayText: 'Egun osoa',\n  moreLinkText: 'gehiago',\n  noEventsText: 'Ez dago ekitaldirik erakusteko'\n};\nvar l27 = {\n  code: 'fa',\n  week: {\n    dow: 6,\n    // Saturday is the first day of the week.\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: function (n) {\n    return '  ' + n;\n  },\n  noEventsText: '   '\n};\nvar l28 = {\n  code: 'fi',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Edellinen',\n    next: 'Seuraava',\n    today: 'Tnn',\n    month: 'Kuukausi',\n    week: 'Viikko',\n    day: 'Piv',\n    list: 'Tapahtumat'\n  },\n  weekText: 'Vk',\n  allDayText: 'Koko piv',\n  moreLinkText: 'lis',\n  noEventsText: 'Ei nytettvi tapahtumia'\n};\nvar l29 = {\n  code: 'fr',\n  buttonText: {\n    prev: 'Prcdent',\n    next: 'Suivant',\n    today: \"Aujourd'hui\",\n    year: 'Anne',\n    month: 'Mois',\n    week: 'Semaine',\n    day: 'Jour',\n    list: 'Mon planning'\n  },\n  weekText: 'Sem.',\n  allDayText: 'Toute la journe',\n  moreLinkText: 'en plus',\n  noEventsText: 'Aucun vnement  afficher'\n};\nvar l30 = {\n  code: 'fr-ch',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Prcdent',\n    next: 'Suivant',\n    today: 'Courant',\n    year: 'Anne',\n    month: 'Mois',\n    week: 'Semaine',\n    day: 'Jour',\n    list: 'Mon planning'\n  },\n  weekText: 'Sm',\n  allDayText: 'Toute la journe',\n  moreLinkText: 'en plus',\n  noEventsText: 'Aucun vnement  afficher'\n};\nvar l31 = {\n  code: 'fr',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Prcdent',\n    next: 'Suivant',\n    today: \"Aujourd'hui\",\n    year: 'Anne',\n    month: 'Mois',\n    week: 'Semaine',\n    day: 'Jour',\n    list: 'Planning'\n  },\n  weekText: 'Sem.',\n  allDayText: 'Toute la journe',\n  moreLinkText: 'en plus',\n  noEventsText: 'Aucun vnement  afficher'\n};\nvar l32 = {\n  code: 'gl',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Ant',\n    next: 'Seg',\n    today: 'Hoxe',\n    month: 'Mes',\n    week: 'Semana',\n    day: 'Da',\n    list: 'Axenda'\n  },\n  weekText: 'Sm',\n  allDayText: 'Todo o da',\n  moreLinkText: 'mis',\n  noEventsText: 'Non hai eventos para amosar'\n};\nvar l33 = {\n  code: 'he',\n  direction: 'rtl',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ' '\n  },\n  allDayText: ' ',\n  moreLinkText: '',\n  noEventsText: '  ',\n  weekText: ''\n};\nvar l34 = {\n  code: 'hi',\n  week: {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 6 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: function (n) {\n    return '+ ' + n;\n  },\n  noEventsText: '      '\n};\nvar l35 = {\n  code: 'hr',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Prijanji',\n    next: 'Sljedei',\n    today: 'Danas',\n    month: 'Mjesec',\n    week: 'Tjedan',\n    day: 'Dan',\n    list: 'Raspored'\n  },\n  weekText: 'Tje',\n  allDayText: 'Cijeli dan',\n  moreLinkText: function (n) {\n    return '+ jo ' + n;\n  },\n  noEventsText: 'Nema dogaaja za prikaz'\n};\nvar l36 = {\n  code: 'hu',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'vissza',\n    next: 'elre',\n    today: 'ma',\n    month: 'Hnap',\n    week: 'Ht',\n    day: 'Nap',\n    list: 'Lista'\n  },\n  weekText: 'Ht',\n  allDayText: 'Egsz nap',\n  moreLinkText: 'tovbbi',\n  noEventsText: 'Nincs megjelenthet esemny'\n};\nvar l37 = {\n  code: 'hy-am',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ' '\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: function (n) {\n    return '+  ' + n;\n  },\n  noEventsText: '   '\n};\nvar l38 = {\n  code: 'id',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'mundur',\n    next: 'maju',\n    today: 'hari ini',\n    month: 'Bulan',\n    week: 'Minggu',\n    day: 'Hari',\n    list: 'Agenda'\n  },\n  weekText: 'Mg',\n  allDayText: 'Sehari penuh',\n  moreLinkText: 'lebih',\n  noEventsText: 'Tidak ada acara untuk ditampilkan'\n};\nvar l39 = {\n  code: 'is',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Fyrri',\n    next: 'Nsti',\n    today: ' dag',\n    month: 'Mnuur',\n    week: 'Vika',\n    day: 'Dagur',\n    list: 'Dagskr'\n  },\n  weekText: 'Vika',\n  allDayText: 'Allan daginn',\n  moreLinkText: 'meira',\n  noEventsText: 'Engir viburir til a sna'\n};\nvar l40 = {\n  code: 'it',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Prec',\n    next: 'Succ',\n    today: 'Oggi',\n    month: 'Mese',\n    week: 'Settimana',\n    day: 'Giorno',\n    list: 'Agenda'\n  },\n  weekText: 'Sm',\n  allDayText: 'Tutto il giorno',\n  moreLinkText: function (n) {\n    return '+altri ' + n;\n  },\n  noEventsText: 'Non ci sono eventi da visualizzare'\n};\nvar l41 = {\n  code: 'ja',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: '',\n  moreLinkText: function (n) {\n    return ' ' + n + ' ';\n  },\n  noEventsText: ''\n};\nvar l42 = {\n  code: 'ka',\n  week: {\n    dow: 1,\n    doy: 7\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ' '\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: function (n) {\n    return '+  ' + n;\n  },\n  noEventsText: '  '\n};\nvar l43 = {\n  code: 'kk',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ' '\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: function (n) {\n    return '+  ' + n;\n  },\n  noEventsText: '   '\n};\nvar l44 = {\n  code: 'km',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    year: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: '',\n  moreLinkText: '',\n  noEventsText: ''\n};\nvar l45 = {\n  code: 'ko',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: '',\n  moreLinkText: '',\n  noEventsText: ' '\n};\nvar l46 = {\n  code: 'ku',\n  week: {\n    dow: 6,\n    // Saturday is the first day of the week.\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: '',\n  noEventsText: '  '\n};\nvar l47 = {\n  code: 'lb',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Zrck',\n    next: 'Weider',\n    today: 'Haut',\n    month: 'Mount',\n    week: 'Woch',\n    day: 'Dag',\n    list: 'Terminiwwersiicht'\n  },\n  weekText: 'W',\n  allDayText: 'Ganzen Dag',\n  moreLinkText: 'mi',\n  noEventsText: 'Nee Evenementer ze affichieren'\n};\nvar l48 = {\n  code: 'lt',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Atgal',\n    next: 'Pirmyn',\n    today: 'iandien',\n    month: 'Mnuo',\n    week: 'Savait',\n    day: 'Diena',\n    list: 'Darbotvark'\n  },\n  weekText: 'SAV',\n  allDayText: 'Vis dien',\n  moreLinkText: 'daugiau',\n  noEventsText: 'Nra vyki rodyti'\n};\nvar l49 = {\n  code: 'lv',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Iepr.',\n    next: 'Nk.',\n    today: 'odien',\n    month: 'Mnesis',\n    week: 'Neda',\n    day: 'Diena',\n    list: 'Dienas krtba'\n  },\n  weekText: 'Ned.',\n  allDayText: 'Visu dienu',\n  moreLinkText: function (n) {\n    return '+vl ' + n;\n  },\n  noEventsText: 'Nav notikumu'\n};\nvar l50 = {\n  code: 'mk',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: function (n) {\n    return '+ ' + n;\n  },\n  noEventsText: '   '\n};\nvar l51 = {\n  code: 'ms',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Sebelum',\n    next: 'Selepas',\n    today: 'hari ini',\n    month: 'Bulan',\n    week: 'Minggu',\n    day: 'Hari',\n    list: 'Agenda'\n  },\n  weekText: 'Mg',\n  allDayText: 'Sepanjang hari',\n  moreLinkText: function (n) {\n    return 'masih ada ' + n + ' acara';\n  },\n  noEventsText: 'Tiada peristiwa untuk dipaparkan'\n};\nvar l52 = {\n  code: 'nb',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Forrige',\n    next: 'Neste',\n    today: 'I dag',\n    month: 'Mned',\n    week: 'Uke',\n    day: 'Dag',\n    list: 'Agenda'\n  },\n  weekText: 'Uke',\n  allDayText: 'Hele dagen',\n  moreLinkText: 'til',\n  noEventsText: 'Ingen hendelser  vise'\n};\nvar l53 = {\n  code: 'ne',\n  // code for nepal\n  week: {\n    dow: 7,\n    // Sunday is the first day of the week.\n    doy: 1 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: '',\n  moreLinkText: ' ',\n  noEventsText: '    '\n};\nvar l54 = {\n  code: 'nl',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Vorige',\n    next: 'Volgende',\n    today: 'Vandaag',\n    year: 'Jaar',\n    month: 'Maand',\n    week: 'Week',\n    day: 'Dag',\n    list: 'Agenda'\n  },\n  allDayText: 'Hele dag',\n  moreLinkText: 'extra',\n  noEventsText: 'Geen evenementen om te laten zien'\n};\nvar l55 = {\n  code: 'nn',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Frre',\n    next: 'Neste',\n    today: 'I dag',\n    month: 'Mnad',\n    week: 'Veke',\n    day: 'Dag',\n    list: 'Agenda'\n  },\n  weekText: 'Veke',\n  allDayText: 'Heile dagen',\n  moreLinkText: 'til',\n  noEventsText: 'Ingen hendelser  vise'\n};\nvar l56 = {\n  code: 'pl',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Poprzedni',\n    next: 'Nastpny',\n    today: 'Dzi',\n    month: 'Miesic',\n    week: 'Tydzie',\n    day: 'Dzie',\n    list: 'Plan dnia'\n  },\n  weekText: 'Tydz',\n  allDayText: 'Cay dzie',\n  moreLinkText: 'wicej',\n  noEventsText: 'Brak wydarze do wywietlenia'\n};\nvar l57 = {\n  code: 'pt-br',\n  buttonText: {\n    prev: 'Anterior',\n    next: 'Prximo',\n    today: 'Hoje',\n    month: 'Ms',\n    week: 'Semana',\n    day: 'Dia',\n    list: 'Lista'\n  },\n  weekText: 'Sm',\n  allDayText: 'dia inteiro',\n  moreLinkText: function (n) {\n    return 'mais +' + n;\n  },\n  noEventsText: 'No h eventos para mostrar'\n};\nvar l58 = {\n  code: 'pt',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Anterior',\n    next: 'Seguinte',\n    today: 'Hoje',\n    month: 'Ms',\n    week: 'Semana',\n    day: 'Dia',\n    list: 'Agenda'\n  },\n  weekText: 'Sem',\n  allDayText: 'Todo o dia',\n  moreLinkText: 'mais',\n  noEventsText: 'No h eventos para mostrar'\n};\nvar l59 = {\n  code: 'ro',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'precedent',\n    next: 'urmtoare',\n    today: 'Azi',\n    month: 'Lun',\n    week: 'Sptmn',\n    day: 'Zi',\n    list: 'Agend'\n  },\n  weekText: 'Spt',\n  allDayText: 'Toat ziua',\n  moreLinkText: function (n) {\n    return '+alte ' + n;\n  },\n  noEventsText: 'Nu exist evenimente de afiat'\n};\nvar l60 = {\n  code: 'ru',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ' '\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: function (n) {\n    return '+  ' + n;\n  },\n  noEventsText: '   '\n};\nvar l61 = {\n  code: 'sk',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Predchdzajci',\n    next: 'Nasledujci',\n    today: 'Dnes',\n    month: 'Mesiac',\n    week: 'Tde',\n    day: 'De',\n    list: 'Rozvrh'\n  },\n  weekText: 'Ty',\n  allDayText: 'Cel de',\n  moreLinkText: function (n) {\n    return '+alie: ' + n;\n  },\n  noEventsText: 'iadne akcie na zobrazenie'\n};\nvar l62 = {\n  code: 'sl',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Prejnji',\n    next: 'Naslednji',\n    today: 'Trenutni',\n    month: 'Mesec',\n    week: 'Teden',\n    day: 'Dan',\n    list: 'Dnevni red'\n  },\n  weekText: 'Teden',\n  allDayText: 'Ves dan',\n  moreLinkText: 've',\n  noEventsText: 'Ni dogodkov za prikaz'\n};\nvar l63 = {\n  code: 'sm',\n  buttonText: {\n    prev: 'Talu ai',\n    next: 'Mulimuli atu',\n    today: 'Aso nei',\n    month: 'Masina',\n    week: 'Vaiaso',\n    day: 'Aso',\n    list: 'Faasologa'\n  },\n  weekText: 'Vaiaso',\n  allDayText: 'Aso atoa',\n  moreLinkText: 'sili atu',\n  noEventsText: 'Leai ni mea na tutupu'\n};\nvar l64 = {\n  code: 'sq',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'mbrapa',\n    next: 'Prpara',\n    today: 'sot',\n    month: 'Muaj',\n    week: 'Jav',\n    day: 'Dit',\n    list: 'List'\n  },\n  weekText: 'Ja',\n  allDayText: 'Gjith ditn',\n  moreLinkText: function (n) {\n    return '+m tepr ' + n;\n  },\n  noEventsText: 'Nuk ka evente pr t shfaqur'\n};\nvar l65 = {\n  code: 'sr-cyrl',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: function (n) {\n    return '+  ' + n;\n  },\n  noEventsText: '   '\n};\nvar l66 = {\n  code: 'sr',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Prethodna',\n    next: 'Sledeci',\n    today: 'Danas',\n    month: 'Msc',\n    week: 'Ndlja',\n    day: 'Dan',\n    list: 'Planr'\n  },\n  weekText: 'Sed',\n  allDayText: 'Co dan',\n  moreLinkText: function (n) {\n    return '+ jo ' + n;\n  },\n  noEventsText: 'Nma dogaaja za prikaz'\n};\nvar l67 = {\n  code: 'sv',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Frra',\n    next: 'Nsta',\n    today: 'Idag',\n    month: 'Mnad',\n    week: 'Vecka',\n    day: 'Dag',\n    list: 'Program'\n  },\n  weekText: 'v.',\n  allDayText: 'Heldag',\n  moreLinkText: 'till',\n  noEventsText: 'Inga hndelser att visa'\n};\nvar l68 = {\n  code: 'ta-in',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ' '\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: function (n) {\n    return '+  ' + n;\n  },\n  noEventsText: '  '\n};\nvar l69 = {\n  code: 'th',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    prevYear: '',\n    nextYear: '',\n    year: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: '',\n  moreLinkText: '',\n  noEventsText: ''\n};\nvar l70 = {\n  code: 'tr',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'geri',\n    next: 'ileri',\n    today: 'bugn',\n    month: 'Ay',\n    week: 'Hafta',\n    day: 'Gn',\n    list: 'Ajanda'\n  },\n  weekText: 'Hf',\n  allDayText: 'Tm gn',\n  moreLinkText: 'daha fazla',\n  noEventsText: 'Gsterilecek etkinlik yok'\n};\nvar l71 = {\n  code: 'ug',\n  buttonText: {\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  allDayText: ' '\n};\nvar l72 = {\n  code: 'uk',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ' '\n  },\n  weekText: '',\n  allDayText: ' ',\n  moreLinkText: function (n) {\n    return '+ ' + n + '...';\n  },\n  noEventsText: '   '\n};\nvar l73 = {\n  code: 'uz',\n  buttonText: {\n    month: 'Oy',\n    week: 'Xafta',\n    day: 'Kun',\n    list: 'Kun tartibi'\n  },\n  allDayText: \"Kun bo'yi\",\n  moreLinkText: function (n) {\n    return '+ yana ' + n;\n  },\n  noEventsText: \"Ko'rsatish uchun voqealar yo'q\"\n};\nvar l74 = {\n  code: 'vi',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Trc',\n    next: 'Tip',\n    today: 'Hm nay',\n    month: 'Thng',\n    week: 'Tun',\n    day: 'Ngy',\n    list: 'Lch biu'\n  },\n  weekText: 'Tu',\n  allDayText: 'C ngy',\n  moreLinkText: function (n) {\n    return '+ thm ' + n;\n  },\n  noEventsText: 'Khng c s kin  hin th'\n};\nvar l75 = {\n  code: 'zh-cn',\n  week: {\n    // GB/T 7408-1994ISO 8601:1988\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: '',\n  moreLinkText: function (n) {\n    return ' ' + n + ' ';\n  },\n  noEventsText: ''\n};\nvar l76 = {\n  code: 'zh-tw',\n  buttonText: {\n    prev: '',\n    next: '',\n    today: '',\n    month: '',\n    week: '',\n    day: '',\n    list: ''\n  },\n  weekText: '',\n  allDayText: '',\n  moreLinkText: '',\n  noEventsText: ''\n};\n/* eslint max-len: off */\n\nvar localesAll = [l0, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22, l23, l24, l25, l26, l27, l28, l29, l30, l31, l32, l33, l34, l35, l36, l37, l38, l39, l40, l41, l42, l43, l44, l45, l46, l47, l48, l49, l50, l51, l52, l53, l54, l55, l56, l57, l58, l59, l60, l61, l62, l63, l64, l65, l66, l67, l68, l69, l70, l71, l72, l73, l74, l75, l76];\nexports[\"default\"] = localesAll;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2xvY2FsZXMtYWxsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFGQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUZBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBRkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFxQkE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBaUJBOztBQUVBO0FBSUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbG9jYWxlcy1hbGwuanM/NzgyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBsMCA9IHtcbiAgY29kZTogJ2FmJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTWFhbmRhZyBpcyBkaWUgZWVyc3RlIGRhZyB2YW4gZGllIHdlZWsuXG4gICAgZG95OiA0LCAvLyBEaWUgd2VlayB3YXQgZGllIDRkZSBKYW51YXJpZSBiZXZhdCBpcyBkaWUgZWVyc3RlIHdlZWsgdmFuIGRpZSBqYWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ1ZvcmlnZScsXG4gICAgbmV4dDogJ1ZvbGdlbmRlJyxcbiAgICB0b2RheTogJ1ZhbmRhZycsXG4gICAgeWVhcjogJ0phYXInLFxuICAgIG1vbnRoOiAnTWFhbmQnLFxuICAgIHdlZWs6ICdXZWVrJyxcbiAgICBkYXk6ICdEYWcnLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICBhbGxEYXlUZXh0OiAnSGVlbGRhZycsXG4gIG1vcmVMaW5rVGV4dDogJ0FkZGlzaW9uZWxlJyxcbiAgbm9FdmVudHNUZXh0OiAnRGFhciBpcyBnZWVuIGdlYmV1cnRlbmlzc2UgbmllJyxcbn07XG5cbnZhciBsMSA9IHtcbiAgY29kZTogJ2FyLWR6JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGRpcmVjdGlvbjogJ3J0bCcsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn2KfZhNiz2KfYqNmCJyxcbiAgICBuZXh0OiAn2KfZhNiq2KfZhNmKJyxcbiAgICB0b2RheTogJ9in2YTZitmI2YUnLFxuICAgIG1vbnRoOiAn2LTZh9ixJyxcbiAgICB3ZWVrOiAn2KPYs9io2YjYuScsXG4gICAgZGF5OiAn2YrZiNmFJyxcbiAgICBsaXN0OiAn2KPYrNmG2K/YqScsXG4gIH0sXG4gIHdlZWtUZXh0OiAn2KPYs9io2YjYuScsXG4gIGFsbERheVRleHQ6ICfYp9mE2YrZiNmFINmD2YTZhycsXG4gIG1vcmVMaW5rVGV4dDogJ9ij2K7YsdmJJyxcbiAgbm9FdmVudHNUZXh0OiAn2KPZiiDYo9it2K/Yp9irINmE2LnYsdi2Jyxcbn07XG5cbnZhciBsMiA9IHtcbiAgY29kZTogJ2FyLWt3JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiAxMiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBkaXJlY3Rpb246ICdydGwnLFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9in2YTYs9in2KjZgicsXG4gICAgbmV4dDogJ9in2YTYqtin2YTZiicsXG4gICAgdG9kYXk6ICfYp9mE2YrZiNmFJyxcbiAgICBtb250aDogJ9i02YfYsScsXG4gICAgd2VlazogJ9ij2LPYqNmI2LknLFxuICAgIGRheTogJ9mK2YjZhScsXG4gICAgbGlzdDogJ9ij2KzZhtiv2KknLFxuICB9LFxuICB3ZWVrVGV4dDogJ9ij2LPYqNmI2LknLFxuICBhbGxEYXlUZXh0OiAn2KfZhNmK2YjZhSDZg9mE2YcnLFxuICBtb3JlTGlua1RleHQ6ICfYo9iu2LHZiScsXG4gIG5vRXZlbnRzVGV4dDogJ9ij2Yog2KPYrdiv2KfYqyDZhNi52LHYticsXG59O1xuXG52YXIgbDMgPSB7XG4gIGNvZGU6ICdhci1seScsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDYsIC8vIFNhdHVyZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiAxMiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBkaXJlY3Rpb246ICdydGwnLFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9in2YTYs9in2KjZgicsXG4gICAgbmV4dDogJ9in2YTYqtin2YTZiicsXG4gICAgdG9kYXk6ICfYp9mE2YrZiNmFJyxcbiAgICBtb250aDogJ9i02YfYsScsXG4gICAgd2VlazogJ9ij2LPYqNmI2LknLFxuICAgIGRheTogJ9mK2YjZhScsXG4gICAgbGlzdDogJ9ij2KzZhtiv2KknLFxuICB9LFxuICB3ZWVrVGV4dDogJ9ij2LPYqNmI2LknLFxuICBhbGxEYXlUZXh0OiAn2KfZhNmK2YjZhSDZg9mE2YcnLFxuICBtb3JlTGlua1RleHQ6ICfYo9iu2LHZiScsXG4gIG5vRXZlbnRzVGV4dDogJ9ij2Yog2KPYrdiv2KfYqyDZhNi52LHYticsXG59O1xuXG52YXIgbDQgPSB7XG4gIGNvZGU6ICdhci1tYScsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDYsIC8vIFNhdHVyZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiAxMiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBkaXJlY3Rpb246ICdydGwnLFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9in2YTYs9in2KjZgicsXG4gICAgbmV4dDogJ9in2YTYqtin2YTZiicsXG4gICAgdG9kYXk6ICfYp9mE2YrZiNmFJyxcbiAgICBtb250aDogJ9i02YfYsScsXG4gICAgd2VlazogJ9ij2LPYqNmI2LknLFxuICAgIGRheTogJ9mK2YjZhScsXG4gICAgbGlzdDogJ9ij2KzZhtiv2KknLFxuICB9LFxuICB3ZWVrVGV4dDogJ9ij2LPYqNmI2LknLFxuICBhbGxEYXlUZXh0OiAn2KfZhNmK2YjZhSDZg9mE2YcnLFxuICBtb3JlTGlua1RleHQ6ICfYo9iu2LHZiScsXG4gIG5vRXZlbnRzVGV4dDogJ9ij2Yog2KPYrdiv2KfYqyDZhNi52LHYticsXG59O1xuXG52YXIgbDUgPSB7XG4gIGNvZGU6ICdhci1zYScsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBkaXJlY3Rpb246ICdydGwnLFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9in2YTYs9in2KjZgicsXG4gICAgbmV4dDogJ9in2YTYqtin2YTZiicsXG4gICAgdG9kYXk6ICfYp9mE2YrZiNmFJyxcbiAgICBtb250aDogJ9i02YfYsScsXG4gICAgd2VlazogJ9ij2LPYqNmI2LknLFxuICAgIGRheTogJ9mK2YjZhScsXG4gICAgbGlzdDogJ9ij2KzZhtiv2KknLFxuICB9LFxuICB3ZWVrVGV4dDogJ9ij2LPYqNmI2LknLFxuICBhbGxEYXlUZXh0OiAn2KfZhNmK2YjZhSDZg9mE2YcnLFxuICBtb3JlTGlua1RleHQ6ICfYo9iu2LHZiScsXG4gIG5vRXZlbnRzVGV4dDogJ9ij2Yog2KPYrdiv2KfYqyDZhNi52LHYticsXG59O1xuXG52YXIgbDYgPSB7XG4gIGNvZGU6ICdhci10bicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBkaXJlY3Rpb246ICdydGwnLFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9in2YTYs9in2KjZgicsXG4gICAgbmV4dDogJ9in2YTYqtin2YTZiicsXG4gICAgdG9kYXk6ICfYp9mE2YrZiNmFJyxcbiAgICBtb250aDogJ9i02YfYsScsXG4gICAgd2VlazogJ9ij2LPYqNmI2LknLFxuICAgIGRheTogJ9mK2YjZhScsXG4gICAgbGlzdDogJ9ij2KzZhtiv2KknLFxuICB9LFxuICB3ZWVrVGV4dDogJ9ij2LPYqNmI2LknLFxuICBhbGxEYXlUZXh0OiAn2KfZhNmK2YjZhSDZg9mE2YcnLFxuICBtb3JlTGlua1RleHQ6ICfYo9iu2LHZiScsXG4gIG5vRXZlbnRzVGV4dDogJ9ij2Yog2KPYrdiv2KfYqyDZhNi52LHYticsXG59O1xuXG52YXIgbDcgPSB7XG4gIGNvZGU6ICdhcicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDYsIC8vIFNhdHVyZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiAxMiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBkaXJlY3Rpb246ICdydGwnLFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9in2YTYs9in2KjZgicsXG4gICAgbmV4dDogJ9in2YTYqtin2YTZiicsXG4gICAgdG9kYXk6ICfYp9mE2YrZiNmFJyxcbiAgICBtb250aDogJ9i02YfYsScsXG4gICAgd2VlazogJ9ij2LPYqNmI2LknLFxuICAgIGRheTogJ9mK2YjZhScsXG4gICAgbGlzdDogJ9ij2KzZhtiv2KknLFxuICB9LFxuICB3ZWVrVGV4dDogJ9ij2LPYqNmI2LknLFxuICBhbGxEYXlUZXh0OiAn2KfZhNmK2YjZhSDZg9mE2YcnLFxuICBtb3JlTGlua1RleHQ6ICfYo9iu2LHZiScsXG4gIG5vRXZlbnRzVGV4dDogJ9ij2Yog2KPYrdiv2KfYqyDZhNi52LHYticsXG59O1xuXG52YXIgbDggPSB7XG4gIGNvZGU6ICdheicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ8aPdnbJmWwnLFxuICAgIG5leHQ6ICdTb25yYScsXG4gICAgdG9kYXk6ICdCdSBHw7xuJyxcbiAgICBtb250aDogJ0F5JyxcbiAgICB3ZWVrOiAnSMmZZnTJmScsXG4gICAgZGF5OiAnR8O8bicsXG4gICAgbGlzdDogJ0fDvG5kyZltJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdIyZlmdMmZJyxcbiAgYWxsRGF5VGV4dDogJ0LDvHTDvG4gR8O8bicsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyBkYWhhIMOnb3ggJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAnR8O2c3TJmXJtyZlrIMO8w6fDvG4gaGFkaXPJmSB5b3hkdXInLFxufTtcblxudmFyIGw5ID0ge1xuICBjb2RlOiAnYmcnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfQvdCw0LfQsNC0JyxcbiAgICBuZXh0OiAn0L3QsNC/0YDQtdC0JyxcbiAgICB0b2RheTogJ9C00L3QtdGBJyxcbiAgICBtb250aDogJ9Cc0LXRgdC10YYnLFxuICAgIHdlZWs6ICfQodC10LTQvNC40YbQsCcsXG4gICAgZGF5OiAn0JTQtdC9JyxcbiAgICBsaXN0OiAn0JPRgNCw0YTQuNC6JyxcbiAgfSxcbiAgYWxsRGF5VGV4dDogJ9Cm0Y/QuyDQtNC10L0nLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJyvQvtGJ0LUgJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAn0J3Rj9C80LAg0YHRitCx0LjRgtC40Y8g0LfQsCDQv9C+0LrQsNC30LLQsNC90LUnLFxufTtcblxudmFyIGwxMCA9IHtcbiAgY29kZTogJ2JuJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA2LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn4Kaq4KeH4Kab4Kao4KeHJyxcbiAgICBuZXh0OiAn4Ka44Ka+4Kau4Kao4KeHJyxcbiAgICB0b2RheTogJ+CmhuCmnCcsXG4gICAgbW9udGg6ICfgpq7gpr7gprgnLFxuICAgIHdlZWs6ICfgprjgpqrgp43gpqTgpr7gprknLFxuICAgIGRheTogJ+CmpuCmv+CmqCcsXG4gICAgbGlzdDogJ+CmpOCmvuCmsuCmv+CmleCmvicsXG4gIH0sXG4gIHdlZWtUZXh0OiAn4Ka44Kaq4KeN4Kak4Ka+4Ka5JyxcbiAgYWxsRGF5VGV4dDogJ+CmuOCmvuCmsOCmvuCmpuCmv+CmqCcsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnK+CmheCmqOCnjeCmr+CmvuCmqOCnjeCmryAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICfgppXgp4vgpqjgp4sg4KaH4Kat4KeH4Kao4KeN4KafIOCmqOCnh+CmhycsXG59O1xuXG52YXIgbDExID0ge1xuICBjb2RlOiAnYnMnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdQcm/FoWxpJyxcbiAgICBuZXh0OiAnU2xqZWRlxIdpJyxcbiAgICB0b2RheTogJ0RhbmFzJyxcbiAgICBtb250aDogJ01qZXNlYycsXG4gICAgd2VlazogJ1NlZG1pY2EnLFxuICAgIGRheTogJ0RhbicsXG4gICAgbGlzdDogJ1Jhc3BvcmVkJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdTZWQnLFxuICBhbGxEYXlUZXh0OiAnQ2lqZWxpIGRhbicsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyBqb8WhICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ05lbWEgZG9nYcSRYWphIHphIHByaWtheml2YW5qZScsXG59O1xuXG52YXIgbDEyID0ge1xuICBjb2RlOiAnY2EnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdBbnRlcmlvcicsXG4gICAgbmV4dDogJ1NlZ8O8ZW50JyxcbiAgICB0b2RheTogJ0F2dWknLFxuICAgIG1vbnRoOiAnTWVzJyxcbiAgICB3ZWVrOiAnU2V0bWFuYScsXG4gICAgZGF5OiAnRGlhJyxcbiAgICBsaXN0OiAnQWdlbmRhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdTZXQnLFxuICBhbGxEYXlUZXh0OiAnVG90IGVsIGRpYScsXG4gIG1vcmVMaW5rVGV4dDogJ23DqXMnLFxuICBub0V2ZW50c1RleHQ6ICdObyBoaSBoYSBlc2RldmVuaW1lbnRzIHBlciBtb3N0cmFyJyxcbn07XG5cbnZhciBsMTMgPSB7XG4gIGNvZGU6ICdjcycsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ0TFmcOtdmUnLFxuICAgIG5leHQ6ICdQb3pkxJtqaScsXG4gICAgdG9kYXk6ICdOeW7DrScsXG4gICAgbW9udGg6ICdNxJtzw61jJyxcbiAgICB3ZWVrOiAnVMO9ZGVuJyxcbiAgICBkYXk6ICdEZW4nLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1TDvWQnLFxuICBhbGxEYXlUZXh0OiAnQ2Vsw70gZGVuJyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICcrZGFsxaHDrTogJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAnxb3DoWRuw6kgYWtjZSBrIHpvYnJhemVuw60nLFxufTtcblxudmFyIGwxNCA9IHtcbiAgY29kZTogJ2N5JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQmxhZW5vcm9sJyxcbiAgICBuZXh0OiAnTmVzYWYnLFxuICAgIHRvZGF5OiAnSGVkZGl3JyxcbiAgICB5ZWFyOiAnQmx3eWRkeW4nLFxuICAgIG1vbnRoOiAnTWlzJyxcbiAgICB3ZWVrOiAnV3l0aG5vcycsXG4gICAgZGF5OiAnRHlkZCcsXG4gICAgbGlzdDogJ1JoZXN0cicsXG4gIH0sXG4gIHdlZWtUZXh0OiAnV3l0aG5vcycsXG4gIGFsbERheVRleHQ6ICdUcnd5XFwnciBkeWRkJyxcbiAgbW9yZUxpbmtUZXh0OiAnTXd5JyxcbiAgbm9FdmVudHNUZXh0OiAnRGltIGRpZ3d5ZGRpYWRhdScsXG59O1xuXG52YXIgbDE1ID0ge1xuICBjb2RlOiAnZGEnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdGb3JyaWdlJyxcbiAgICBuZXh0OiAnTsOmc3RlJyxcbiAgICB0b2RheTogJ0kgZGFnJyxcbiAgICBtb250aDogJ03DpW5lZCcsXG4gICAgd2VlazogJ1VnZScsXG4gICAgZGF5OiAnRGFnJyxcbiAgICBsaXN0OiAnQWdlbmRhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdVZ2UnLFxuICBhbGxEYXlUZXh0OiAnSGVsZSBkYWdlbicsXG4gIG1vcmVMaW5rVGV4dDogJ2ZsZXJlJyxcbiAgbm9FdmVudHNUZXh0OiAnSW5nZW4gYXJyYW5nZW1lbnRlciBhdCB2aXNlJyxcbn07XG5cbnZhciBsMTYgPSB7XG4gIGNvZGU6ICdkZS1hdCcsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ1p1csO8Y2snLFxuICAgIG5leHQ6ICdWb3InLFxuICAgIHRvZGF5OiAnSGV1dGUnLFxuICAgIHllYXI6ICdKYWhyJyxcbiAgICBtb250aDogJ01vbmF0JyxcbiAgICB3ZWVrOiAnV29jaGUnLFxuICAgIGRheTogJ1RhZycsXG4gICAgbGlzdDogJ1Rlcm1pbsO8YmVyc2ljaHQnLFxuICB9LFxuICB3ZWVrVGV4dDogJ0tXJyxcbiAgYWxsRGF5VGV4dDogJ0dhbnp0w6RnaWcnLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJysgd2VpdGVyZSAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICdLZWluZSBFcmVpZ25pc3NlIGFuenV6ZWlnZW4nLFxufTtcblxudmFyIGwxNyA9IHtcbiAgY29kZTogJ2RlJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnWnVyw7xjaycsXG4gICAgbmV4dDogJ1ZvcicsXG4gICAgdG9kYXk6ICdIZXV0ZScsXG4gICAgeWVhcjogJ0phaHInLFxuICAgIG1vbnRoOiAnTW9uYXQnLFxuICAgIHdlZWs6ICdXb2NoZScsXG4gICAgZGF5OiAnVGFnJyxcbiAgICBsaXN0OiAnVGVybWluw7xiZXJzaWNodCcsXG4gIH0sXG4gIHdlZWtUZXh0OiAnS1cnLFxuICBhbGxEYXlUZXh0OiAnR2FuenTDpGdpZycsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyB3ZWl0ZXJlICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ0tlaW5lIEVyZWlnbmlzc2UgYW56dXplaWdlbicsXG59O1xuXG52YXIgbDE4ID0ge1xuICBjb2RlOiAnZWwnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDRzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfOoM+Bzr/Ot86zzr/Pjc68zrXOvc6/z4InLFxuICAgIG5leHQ6ICfOlc+Az4zOvM61zr3Ov8+CJyxcbiAgICB0b2RheTogJ86jzq7OvM61z4HOsScsXG4gICAgbW9udGg6ICfOnM6uzr3Osc+CJyxcbiAgICB3ZWVrOiAnzpXOss60zr/OvM6szrTOsScsXG4gICAgZGF5OiAnzpfOvM6tz4HOsScsXG4gICAgbGlzdDogJ86Rz4TOts6tzr3PhM6xJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfOlc6yzrQnLFxuICBhbGxEYXlUZXh0OiAnzp/Ou86/zq7OvM61z4HOvycsXG4gIG1vcmVMaW5rVGV4dDogJ8+AzrXPgc65z4PPg8+Mz4TOtc+BzrEnLFxuICBub0V2ZW50c1RleHQ6ICfOlM61zr0gz4XPgM6sz4HPh86/z4XOvSDOs861zrPOv869z4zPhM6xIM+Az4HOv8+CIM61zrzPhs6szr3Ouc+DzrcnLFxufTtcblxudmFyIGwxOSA9IHtcbiAgY29kZTogJ2VuLWF1JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG59O1xuXG52YXIgbDIwID0ge1xuICBjb2RlOiAnZW4tZ2InLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbn07XG5cbnZhciBsMjEgPSB7XG4gIGNvZGU6ICdlbi1ueicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxufTtcblxudmFyIGwyMiA9IHtcbiAgY29kZTogJ2VvJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQW50YcWtYScsXG4gICAgbmV4dDogJ1Nla3ZhJyxcbiAgICB0b2RheTogJ0hvZGlhxa0nLFxuICAgIG1vbnRoOiAnTW9uYXRvJyxcbiAgICB3ZWVrOiAnU2VtYWpubycsXG4gICAgZGF5OiAnVGFnbycsXG4gICAgbGlzdDogJ1RhZ29yZG8nLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NtJyxcbiAgYWxsRGF5VGV4dDogJ1R1dGEgdGFnbycsXG4gIG1vcmVMaW5rVGV4dDogJ3BsaScsXG4gIG5vRXZlbnRzVGV4dDogJ05lbml1aiBldmVudG9qIHBvciBtb250cmknLFxufTtcblxudmFyIGwyMyA9IHtcbiAgY29kZTogJ2VzJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA2LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQW50JyxcbiAgICBuZXh0OiAnU2lnJyxcbiAgICB0b2RheTogJ0hveScsXG4gICAgbW9udGg6ICdNZXMnLFxuICAgIHdlZWs6ICdTZW1hbmEnLFxuICAgIGRheTogJ0TDrWEnLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NtJyxcbiAgYWxsRGF5VGV4dDogJ1RvZG8gZWwgZMOtYScsXG4gIG1vcmVMaW5rVGV4dDogJ23DoXMnLFxuICBub0V2ZW50c1RleHQ6ICdObyBoYXkgZXZlbnRvcyBwYXJhIG1vc3RyYXInLFxufTtcblxudmFyIGwyNCA9IHtcbiAgY29kZTogJ2VzJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQW50JyxcbiAgICBuZXh0OiAnU2lnJyxcbiAgICB0b2RheTogJ0hveScsXG4gICAgbW9udGg6ICdNZXMnLFxuICAgIHdlZWs6ICdTZW1hbmEnLFxuICAgIGRheTogJ0TDrWEnLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NtJyxcbiAgYWxsRGF5VGV4dDogJ1RvZG8gZWwgZMOtYScsXG4gIG1vcmVMaW5rVGV4dDogJ23DoXMnLFxuICBub0V2ZW50c1RleHQ6ICdObyBoYXkgZXZlbnRvcyBwYXJhIG1vc3RyYXInLFxufTtcblxudmFyIGwyNSA9IHtcbiAgY29kZTogJ2V0JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnRWVsbmV2JyxcbiAgICBuZXh0OiAnSsOkcmduZXYnLFxuICAgIHRvZGF5OiAnVMOkbmEnLFxuICAgIG1vbnRoOiAnS3V1JyxcbiAgICB3ZWVrOiAnTsOkZGFsJyxcbiAgICBkYXk6ICdQw6RldicsXG4gICAgbGlzdDogJ1DDpGV2YWtvcmQnLFxuICB9LFxuICB3ZWVrVGV4dDogJ27DpGQnLFxuICBhbGxEYXlUZXh0OiAnS29ndSBww6RldicsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyB2ZWVsICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ0t1dmFtaXNla3MgcHV1ZHV2YWQgc8O8bmRtdXNlZCcsXG59O1xuXG52YXIgbDI2ID0ge1xuICBjb2RlOiAnZXUnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdBdXInLFxuICAgIG5leHQ6ICdIdXInLFxuICAgIHRvZGF5OiAnR2F1cicsXG4gICAgbW9udGg6ICdIaWxhYmV0ZWEnLFxuICAgIHdlZWs6ICdBc3RlYScsXG4gICAgZGF5OiAnRWd1bmEnLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ0FzJyxcbiAgYWxsRGF5VGV4dDogJ0VndW4gb3NvYScsXG4gIG1vcmVMaW5rVGV4dDogJ2dlaGlhZ28nLFxuICBub0V2ZW50c1RleHQ6ICdFeiBkYWdvIGVraXRhbGRpcmlrIGVyYWt1c3Rla28nLFxufTtcblxudmFyIGwyNyA9IHtcbiAgY29kZTogJ2ZhJyxcbiAgd2Vlazoge1xuICAgIGRvdzogNiwgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDEyLCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGRpcmVjdGlvbjogJ3J0bCcsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn2YLYqNmE24wnLFxuICAgIG5leHQ6ICfYqNi52K/bjCcsXG4gICAgdG9kYXk6ICfYp9mF2LHZiNiyJyxcbiAgICBtb250aDogJ9mF2KfZhycsXG4gICAgd2VlazogJ9mH2YHYqtmHJyxcbiAgICBkYXk6ICfYsdmI2LInLFxuICAgIGxpc3Q6ICfYqNix2YbYp9mF2YcnLFxuICB9LFxuICB3ZWVrVGV4dDogJ9mH2YEnLFxuICBhbGxEYXlUZXh0OiAn2KrZhdin2YUg2LHZiNiyJyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICfYqNuM2LQg2KfYsiAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICfZh9uM2oYg2LHZiNuM2K/Yp9iv24wg2KjZhyDZhtmF2KfbjNi0Jyxcbn07XG5cbnZhciBsMjggPSB7XG4gIGNvZGU6ICdmaScsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ0VkZWxsaW5lbicsXG4gICAgbmV4dDogJ1NldXJhYXZhJyxcbiAgICB0b2RheTogJ1TDpG7DpMOkbicsXG4gICAgbW9udGg6ICdLdXVrYXVzaScsXG4gICAgd2VlazogJ1ZpaWtrbycsXG4gICAgZGF5OiAnUMOkaXbDpCcsXG4gICAgbGlzdDogJ1RhcGFodHVtYXQnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1ZrJyxcbiAgYWxsRGF5VGV4dDogJ0tva28gcMOkaXbDpCcsXG4gIG1vcmVMaW5rVGV4dDogJ2xpc8Okw6QnLFxuICBub0V2ZW50c1RleHQ6ICdFaSBuw6R5dGV0dMOkdmnDpCB0YXBhaHR1bWlhJyxcbn07XG5cbnZhciBsMjkgPSB7XG4gIGNvZGU6ICdmcicsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnUHLDqWPDqWRlbnQnLFxuICAgIG5leHQ6ICdTdWl2YW50JyxcbiAgICB0b2RheTogXCJBdWpvdXJkJ2h1aVwiLFxuICAgIHllYXI6ICdBbm7DqWUnLFxuICAgIG1vbnRoOiAnTW9pcycsXG4gICAgd2VlazogJ1NlbWFpbmUnLFxuICAgIGRheTogJ0pvdXInLFxuICAgIGxpc3Q6ICdNb24gcGxhbm5pbmcnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NlbS4nLFxuICBhbGxEYXlUZXh0OiAnVG91dGUgbGEgam91cm7DqWUnLFxuICBtb3JlTGlua1RleHQ6ICdlbiBwbHVzJyxcbiAgbm9FdmVudHNUZXh0OiAnQXVjdW4gw6l2w6luZW1lbnQgw6AgYWZmaWNoZXInLFxufTtcblxudmFyIGwzMCA9IHtcbiAgY29kZTogJ2ZyLWNoJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnUHLDqWPDqWRlbnQnLFxuICAgIG5leHQ6ICdTdWl2YW50JyxcbiAgICB0b2RheTogJ0NvdXJhbnQnLFxuICAgIHllYXI6ICdBbm7DqWUnLFxuICAgIG1vbnRoOiAnTW9pcycsXG4gICAgd2VlazogJ1NlbWFpbmUnLFxuICAgIGRheTogJ0pvdXInLFxuICAgIGxpc3Q6ICdNb24gcGxhbm5pbmcnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NtJyxcbiAgYWxsRGF5VGV4dDogJ1RvdXRlIGxhIGpvdXJuw6llJyxcbiAgbW9yZUxpbmtUZXh0OiAnZW4gcGx1cycsXG4gIG5vRXZlbnRzVGV4dDogJ0F1Y3VuIMOpdsOpbmVtZW50IMOgIGFmZmljaGVyJyxcbn07XG5cbnZhciBsMzEgPSB7XG4gIGNvZGU6ICdmcicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ1Byw6ljw6lkZW50JyxcbiAgICBuZXh0OiAnU3VpdmFudCcsXG4gICAgdG9kYXk6IFwiQXVqb3VyZCdodWlcIixcbiAgICB5ZWFyOiAnQW5uw6llJyxcbiAgICBtb250aDogJ01vaXMnLFxuICAgIHdlZWs6ICdTZW1haW5lJyxcbiAgICBkYXk6ICdKb3VyJyxcbiAgICBsaXN0OiAnUGxhbm5pbmcnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NlbS4nLFxuICBhbGxEYXlUZXh0OiAnVG91dGUgbGEgam91cm7DqWUnLFxuICBtb3JlTGlua1RleHQ6ICdlbiBwbHVzJyxcbiAgbm9FdmVudHNUZXh0OiAnQXVjdW4gw6l2w6luZW1lbnQgw6AgYWZmaWNoZXInLFxufTtcblxudmFyIGwzMiA9IHtcbiAgY29kZTogJ2dsJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQW50JyxcbiAgICBuZXh0OiAnU2VnJyxcbiAgICB0b2RheTogJ0hveGUnLFxuICAgIG1vbnRoOiAnTWVzJyxcbiAgICB3ZWVrOiAnU2VtYW5hJyxcbiAgICBkYXk6ICdEw61hJyxcbiAgICBsaXN0OiAnQXhlbmRhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdTbScsXG4gIGFsbERheVRleHQ6ICdUb2RvIG8gZMOtYScsXG4gIG1vcmVMaW5rVGV4dDogJ23DoWlzJyxcbiAgbm9FdmVudHNUZXh0OiAnTm9uIGhhaSBldmVudG9zIHBhcmEgYW1vc2FyJyxcbn07XG5cbnZhciBsMzMgPSB7XG4gIGNvZGU6ICdoZScsXG4gIGRpcmVjdGlvbjogJ3J0bCcsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn15TXp9eV15PXnScsXG4gICAgbmV4dDogJ9eU15HXkCcsXG4gICAgdG9kYXk6ICfXlNeZ15XXnScsXG4gICAgbW9udGg6ICfXl9eV15PXqScsXG4gICAgd2VlazogJ9ep15HXldeiJyxcbiAgICBkYXk6ICfXmdeV150nLFxuICAgIGxpc3Q6ICfXodeT16gg15nXldedJyxcbiAgfSxcbiAgYWxsRGF5VGV4dDogJ9eb15wg15TXmdeV150nLFxuICBtb3JlTGlua1RleHQ6ICfXkNeX16gnLFxuICBub0V2ZW50c1RleHQ6ICfXkNeZ158g15DXmdeo15XXoteZ150g15zXlNem15LXlCcsXG4gIHdlZWtUZXh0OiAn16nXkdeV16InLFxufTtcblxudmFyIGwzNCA9IHtcbiAgY29kZTogJ2hpJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA2LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn4KSq4KS/4KSb4KSy4KS+JyxcbiAgICBuZXh0OiAn4KSF4KSX4KSy4KS+JyxcbiAgICB0b2RheTogJ+CkhuCknCcsXG4gICAgbW9udGg6ICfgpK7gpLngpYDgpKjgpL4nLFxuICAgIHdlZWs6ICfgpLjgpKrgpY3gpKTgpL7gpLknLFxuICAgIGRheTogJ+CkpuCkv+CkqCcsXG4gICAgbGlzdDogJ+CkleCkvuCksOCljeCkr+CkuOClguCkmuClgCcsXG4gIH0sXG4gIHdlZWtUZXh0OiAn4KS54KSr4KWN4KSk4KS+JyxcbiAgYWxsRGF5VGV4dDogJ+CkuOCkreClgCDgpKbgpL/gpKgnLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJyvgpIXgpKfgpL/gpJUgJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAn4KSV4KWL4KSIIOCkmOCkn+CkqOCkvuCkk+CkgiDgpJXgpYsg4KSq4KWN4KSw4KSm4KSw4KWN4KS24KS/4KSkIOCkleCksOCkqOClhyDgpJXgpYcg4KSy4KS/4KSPJyxcbn07XG5cbnZhciBsMzUgPSB7XG4gIGNvZGU6ICdocicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNywgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ1ByaWphxaFuamknLFxuICAgIG5leHQ6ICdTbGplZGXEh2knLFxuICAgIHRvZGF5OiAnRGFuYXMnLFxuICAgIG1vbnRoOiAnTWplc2VjJyxcbiAgICB3ZWVrOiAnVGplZGFuJyxcbiAgICBkYXk6ICdEYW4nLFxuICAgIGxpc3Q6ICdSYXNwb3JlZCcsXG4gIH0sXG4gIHdlZWtUZXh0OiAnVGplJyxcbiAgYWxsRGF5VGV4dDogJ0NpamVsaSBkYW4nLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJysgam/FoSAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICdOZW1hIGRvZ2HEkWFqYSB6YSBwcmlrYXonLFxufTtcblxudmFyIGwzNiA9IHtcbiAgY29kZTogJ2h1JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAndmlzc3phJyxcbiAgICBuZXh0OiAnZWzFkXJlJyxcbiAgICB0b2RheTogJ21hJyxcbiAgICBtb250aDogJ0jDs25hcCcsXG4gICAgd2VlazogJ0jDqXQnLFxuICAgIGRheTogJ05hcCcsXG4gICAgbGlzdDogJ0xpc3RhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdIw6l0JyxcbiAgYWxsRGF5VGV4dDogJ0Vnw6lzeiBuYXAnLFxuICBtb3JlTGlua1RleHQ6ICd0b3bDoWJiaScsXG4gIG5vRXZlbnRzVGV4dDogJ05pbmNzIG1lZ2plbGVuw610aGV0xZEgZXNlbcOpbnknLFxufTtcblxudmFyIGwzNyA9IHtcbiAgY29kZTogJ2h5LWFtJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn1YbVodWt1bjWgNWkJyxcbiAgICBuZXh0OiAn1YDVodW71bjWgNWkJyxcbiAgICB0b2RheTogJ9Sx1bXVvdaF1oAnLFxuICAgIG1vbnRoOiAn1LHVtNWr1b0nLFxuICAgIHdlZWs6ICfVh9Wh1aLVodWpJyxcbiAgICBkYXk6ICfVldaAJyxcbiAgICBsaXN0OiAn1ZXWgNW+1aEg1oHVuNaC1oHVodWvJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfVh9Wh1aInLFxuICBhbGxEYXlUZXh0OiAn1LHVtNWi1bjVstW7INaF1oAnLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJysg1ofVvSAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICfUstWh1oHVodWv1aHVtdW41oLVtCDVpyDVq9aA1aHVpNWh1oDVsdW41oLVqdW11bjWgtW21agg1oHVuNaC1oHVodWk1oDVpdWs1bjWgicsXG59O1xuXG52YXIgbDM4ID0ge1xuICBjb2RlOiAnaWQnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdtdW5kdXInLFxuICAgIG5leHQ6ICdtYWp1JyxcbiAgICB0b2RheTogJ2hhcmkgaW5pJyxcbiAgICBtb250aDogJ0J1bGFuJyxcbiAgICB3ZWVrOiAnTWluZ2d1JyxcbiAgICBkYXk6ICdIYXJpJyxcbiAgICBsaXN0OiAnQWdlbmRhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdNZycsXG4gIGFsbERheVRleHQ6ICdTZWhhcmkgcGVudWgnLFxuICBtb3JlTGlua1RleHQ6ICdsZWJpaCcsXG4gIG5vRXZlbnRzVGV4dDogJ1RpZGFrIGFkYSBhY2FyYSB1bnR1ayBkaXRhbXBpbGthbicsXG59O1xuXG52YXIgbDM5ID0ge1xuICBjb2RlOiAnaXMnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdGeXJyaScsXG4gICAgbmV4dDogJ07DpnN0aScsXG4gICAgdG9kYXk6ICfDjSBkYWcnLFxuICAgIG1vbnRoOiAnTcOhbnXDsHVyJyxcbiAgICB3ZWVrOiAnVmlrYScsXG4gICAgZGF5OiAnRGFndXInLFxuICAgIGxpc3Q6ICdEYWdza3LDoScsXG4gIH0sXG4gIHdlZWtUZXh0OiAnVmlrYScsXG4gIGFsbERheVRleHQ6ICdBbGxhbiBkYWdpbm4nLFxuICBtb3JlTGlua1RleHQ6ICdtZWlyYScsXG4gIG5vRXZlbnRzVGV4dDogJ0VuZ2lyIHZpw7BidXLDsGlyIHRpbCBhw7Agc8O9bmEnLFxufTtcblxudmFyIGw0MCA9IHtcbiAgY29kZTogJ2l0JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnUHJlYycsXG4gICAgbmV4dDogJ1N1Y2MnLFxuICAgIHRvZGF5OiAnT2dnaScsXG4gICAgbW9udGg6ICdNZXNlJyxcbiAgICB3ZWVrOiAnU2V0dGltYW5hJyxcbiAgICBkYXk6ICdHaW9ybm8nLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NtJyxcbiAgYWxsRGF5VGV4dDogJ1R1dHRvIGlsIGdpb3JubycsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnK2FsdHJpICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ05vbiBjaSBzb25vIGV2ZW50aSBkYSB2aXN1YWxpenphcmUnLFxufTtcblxudmFyIGw0MSA9IHtcbiAgY29kZTogJ2phJyxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfliY0nLFxuICAgIG5leHQ6ICfmrKEnLFxuICAgIHRvZGF5OiAn5LuK5pelJyxcbiAgICBtb250aDogJ+aciCcsXG4gICAgd2VlazogJ+mAsScsXG4gICAgZGF5OiAn5pelJyxcbiAgICBsaXN0OiAn5LqI5a6a44Oq44K544OIJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfpgLEnLFxuICBhbGxEYXlUZXh0OiAn57WC5pelJyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICfku5YgJyArIG4gKyAnIOS7tidcbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAn6KGo56S644GZ44KL5LqI5a6a44Gv44GC44KK44G+44Gb44KTJyxcbn07XG5cbnZhciBsNDIgPSB7XG4gIGNvZGU6ICdrYScsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsXG4gICAgZG95OiA3LFxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ+GDrOGDmOGDnOGDkCcsXG4gICAgbmV4dDogJ+GDqOGDlOGDm+GDk+GDlOGDkuGDmCcsXG4gICAgdG9kYXk6ICfhg5Phg6bhg5Thg6EnLFxuICAgIG1vbnRoOiAn4YOX4YOV4YOUJyxcbiAgICB3ZWVrOiAn4YOZ4YOV4YOY4YOg4YOQJyxcbiAgICBkYXk6ICfhg5Phg6bhg5QnLFxuICAgIGxpc3Q6ICfhg5Phg6bhg5jhg6Eg4YOs4YOU4YOh4YOg4YOY4YOS4YOYJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfhg5nhg5UnLFxuICBhbGxEYXlUZXh0OiAn4YOb4YOX4YOU4YOa4YOYIOGDk+GDpuGDlCcsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyDhg5nhg5jhg5Phg5Thg5UgJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAn4YOm4YOd4YOc4YOY4YOh4YOr4YOY4YOU4YOR4YOU4YOR4YOYIOGDkOGDoCDhg5Dhg6Dhg5jhg6EnLFxufTtcblxudmFyIGw0MyA9IHtcbiAgY29kZTogJ2trJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA3LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn0JDQu9C00YvSo9KT0YsnLFxuICAgIG5leHQ6ICfQmtC10LvQtdGB0ZYnLFxuICAgIHRvZGF5OiAn0JHSr9Cz0ZbQvScsXG4gICAgbW9udGg6ICfQkNC5JyxcbiAgICB3ZWVrOiAn0JDQv9GC0LAnLFxuICAgIGRheTogJ9Ca0q/QvScsXG4gICAgbGlzdDogJ9Ca0q/QvSDRgtOZ0YDRgtGW0LHRlicsXG4gIH0sXG4gIHdlZWtUZXh0OiAn0J3QtScsXG4gIGFsbERheVRleHQ6ICfQmtKv0L3RliDQsdC+0LnRiycsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyDRgtCw0pPRiyAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICfQmtOp0YDRgdC10YLRgyDSr9GI0ZbQvSDQvtKb0LjSk9Cw0LvQsNGAINC20L7SmycsXG59O1xuXG52YXIgbDQ0ID0ge1xuICBjb2RlOiAna20nLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfhnpjhnrvhnpMnLFxuICAgIG5leHQ6ICfhnpThnpPhn5LhnpHhnrbhnpThn4snLFxuICAgIHRvZGF5OiAn4Z6Q4Z+S4Z6E4Z+D4Z6T4Z+B4Z+HJyxcbiAgICB5ZWFyOiAn4Z6G4Z+S4Z6T4Z624Z+GJyxcbiAgICBtb250aDogJ+GegeGfgicsXG4gICAgd2VlazogJ+Gen+GelOGfkuGej+GetuGeoOGfjScsXG4gICAgZGF5OiAn4Z6Q4Z+S4Z6E4Z+DJyxcbiAgICBsaXN0OiAn4Z6U4Z6J4Z+S4Z6H4Z64JyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfhnp/hnpThn5Lhno/hnrbhnqDhn40nLFxuICBhbGxEYXlUZXh0OiAn4Z6W4Z+B4Z6J4Z6Y4Z694Z6Z4Z6Q4Z+S4Z6E4Z+DJyxcbiAgbW9yZUxpbmtUZXh0OiAn4Z6F4Z+S4Z6a4Z6+4Z6T4Z6R4Z+A4Z6PJyxcbiAgbm9FdmVudHNUZXh0OiAn4Z6C4Z+S4Z6Y4Z624Z6T4Z6W4Z+S4Z6a4Z654Z6P4Z+S4Z6P4Z634Z6A4Z624Z6a4Z6O4Z+N4Z6P4Z+S4Z6a4Z684Z6c4Z6U4Z6E4Z+S4Z6g4Z624Z6JJyxcbn07XG5cbnZhciBsNDUgPSB7XG4gIGNvZGU6ICdrbycsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn7J207KCE64usJyxcbiAgICBuZXh0OiAn64uk7J2M64usJyxcbiAgICB0b2RheTogJ+yYpOuKmCcsXG4gICAgbW9udGg6ICfsm5QnLFxuICAgIHdlZWs6ICfso7wnLFxuICAgIGRheTogJ+ydvCcsXG4gICAgbGlzdDogJ+ydvOygleuqqeuhnScsXG4gIH0sXG4gIHdlZWtUZXh0OiAn7KO8JyxcbiAgYWxsRGF5VGV4dDogJ+yiheydvCcsXG4gIG1vcmVMaW5rVGV4dDogJ+qwnCcsXG4gIG5vRXZlbnRzVGV4dDogJ+ydvOygleydtCDsl4bsirXri4jri6QnLFxufTtcblxudmFyIGw0NiA9IHtcbiAgY29kZTogJ2t1JyxcbiAgd2Vlazoge1xuICAgIGRvdzogNiwgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDEyLCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGRpcmVjdGlvbjogJ3J0bCcsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn2b7bjti02KrYsScsXG4gICAgbmV4dDogJ9iv2YjYp9iq2LEnLFxuICAgIHRvZGF5OiAn2KbbldmF2pXZiCcsXG4gICAgbW9udGg6ICfZhdin2YbarycsXG4gICAgd2VlazogJ9mH25XZgdiq25UnLFxuICAgIGRheTogJ9qV24bamCcsXG4gICAgbGlzdDogJ9io25XYsdmG2KfZhduVJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfZh9uV2YHYqtuVJyxcbiAgYWxsRGF5VGV4dDogJ9mH25XZhdmI2Ygg2pXbhtqY25XaqduVJyxcbiAgbW9yZUxpbmtUZXh0OiAn2LLbjNin2KrYsScsXG4gIG5vRXZlbnRzVGV4dDogJ9mH24zahiDaldmI2YjYr9in2YjbjtmDINmG24zblScsXG59O1xuXG52YXIgbDQ3ID0ge1xuICBjb2RlOiAnbGInLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdacsOpY2snLFxuICAgIG5leHQ6ICdXZWlkZXInLFxuICAgIHRvZGF5OiAnSGF1dCcsXG4gICAgbW9udGg6ICdNb3VudCcsXG4gICAgd2VlazogJ1dvY2gnLFxuICAgIGRheTogJ0RhZycsXG4gICAgbGlzdDogJ1Rlcm1pbml3d2Vyc2lpY2h0JyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdXJyxcbiAgYWxsRGF5VGV4dDogJ0dhbnplbiBEYWcnLFxuICBtb3JlTGlua1RleHQ6ICdtw6lpJyxcbiAgbm9FdmVudHNUZXh0OiAnTmVlIEV2ZW5lbWVudGVyIHplIGFmZmljaMOpaWVyZW4nLFxufTtcblxudmFyIGw0OCA9IHtcbiAgY29kZTogJ2x0JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQXRnYWwnLFxuICAgIG5leHQ6ICdQaXJteW4nLFxuICAgIHRvZGF5OiAnxaBpYW5kaWVuJyxcbiAgICBtb250aDogJ03El251bycsXG4gICAgd2VlazogJ1NhdmFpdMSXJyxcbiAgICBkYXk6ICdEaWVuYScsXG4gICAgbGlzdDogJ0RhcmJvdHZhcmvElycsXG4gIH0sXG4gIHdlZWtUZXh0OiAnU0FWJyxcbiAgYWxsRGF5VGV4dDogJ1Zpc8SFIGRpZW7EhScsXG4gIG1vcmVMaW5rVGV4dDogJ2RhdWdpYXUnLFxuICBub0V2ZW50c1RleHQ6ICdOxJdyYSDEr3Z5a2nFsyByb2R5dGknLFxufTtcblxudmFyIGw0OSA9IHtcbiAgY29kZTogJ2x2JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnSWVwci4nLFxuICAgIG5leHQ6ICdOxIFrLicsXG4gICAgdG9kYXk6ICfFoG9kaWVuJyxcbiAgICBtb250aDogJ03Ek25lc2lzJyxcbiAgICB3ZWVrOiAnTmVkxJPEvGEnLFxuICAgIGRheTogJ0RpZW5hJyxcbiAgICBsaXN0OiAnRGllbmFzIGvEgXJ0xKtiYScsXG4gIH0sXG4gIHdlZWtUZXh0OiAnTmVkLicsXG4gIGFsbERheVRleHQ6ICdWaXN1IGRpZW51JyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICcrdsSTbCAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICdOYXYgbm90aWt1bXUnLFxufTtcblxudmFyIGw1MCA9IHtcbiAgY29kZTogJ21rJyxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfQv9GA0LXRgtGF0L7QtNC90L4nLFxuICAgIG5leHQ6ICfRgdC70LXQtNC90L4nLFxuICAgIHRvZGF5OiAn0JTQtdC90LXRgScsXG4gICAgbW9udGg6ICfQnNC10YHQtdGGJyxcbiAgICB3ZWVrOiAn0J3QtdC00LXQu9CwJyxcbiAgICBkYXk6ICfQlNC10L0nLFxuICAgIGxpc3Q6ICfQk9GA0LDRhNC40LonLFxuICB9LFxuICB3ZWVrVGV4dDogJ9Ch0LXQtCcsXG4gIGFsbERheVRleHQ6ICfQptC10Lsg0LTQtdC9JyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICcr0L/QvtCy0LXRnNC1ICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ9Cd0LXQvNCwINC90LDRgdGC0LDQvdC4INC30LAg0L/RgNC40LrQsNC20YPQstCw0ZrQtScsXG59O1xuXG52YXIgbDUxID0ge1xuICBjb2RlOiAnbXMnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdTZWJlbHVtJyxcbiAgICBuZXh0OiAnU2VsZXBhcycsXG4gICAgdG9kYXk6ICdoYXJpIGluaScsXG4gICAgbW9udGg6ICdCdWxhbicsXG4gICAgd2VlazogJ01pbmdndScsXG4gICAgZGF5OiAnSGFyaScsXG4gICAgbGlzdDogJ0FnZW5kYScsXG4gIH0sXG4gIHdlZWtUZXh0OiAnTWcnLFxuICBhbGxEYXlUZXh0OiAnU2VwYW5qYW5nIGhhcmknLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJ21hc2loIGFkYSAnICsgbiArICcgYWNhcmEnXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ1RpYWRhIHBlcmlzdGl3YSB1bnR1ayBkaXBhcGFya2FuJyxcbn07XG5cbnZhciBsNTIgPSB7XG4gIGNvZGU6ICduYicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ0ZvcnJpZ2UnLFxuICAgIG5leHQ6ICdOZXN0ZScsXG4gICAgdG9kYXk6ICdJIGRhZycsXG4gICAgbW9udGg6ICdNw6VuZWQnLFxuICAgIHdlZWs6ICdVa2UnLFxuICAgIGRheTogJ0RhZycsXG4gICAgbGlzdDogJ0FnZW5kYScsXG4gIH0sXG4gIHdlZWtUZXh0OiAnVWtlJyxcbiAgYWxsRGF5VGV4dDogJ0hlbGUgZGFnZW4nLFxuICBtb3JlTGlua1RleHQ6ICd0aWwnLFxuICBub0V2ZW50c1RleHQ6ICdJbmdlbiBoZW5kZWxzZXIgw6UgdmlzZScsXG59O1xuXG52YXIgbDUzID0ge1xuICBjb2RlOiAnbmUnLCAvLyBjb2RlIGZvciBuZXBhbFxuICB3ZWVrOiB7XG4gICAgZG93OiA3LCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDEsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfgpIXgpJjgpL/gpLLgpY3gpLLgpYsnLFxuICAgIG5leHQ6ICfgpIXgpLDgpY3gpJXgpYsnLFxuICAgIHRvZGF5OiAn4KSG4KScJyxcbiAgICBtb250aDogJ+CkruCkueCkv+CkqOCkvicsXG4gICAgd2VlazogJ+CkueCkquCljeCkpOCkvicsXG4gICAgZGF5OiAn4KSm4KS/4KSoJyxcbiAgICBsaXN0OiAn4KS44KWC4KSa4KWAJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfgpLngpKrgpY3gpKTgpL4nLFxuICBhbGxEYXlUZXh0OiAn4KSm4KS/4KSo4KSt4KSw4KS/JyxcbiAgbW9yZUxpbmtUZXh0OiAn4KSl4KSqIOCksuCkv+CkguCklScsXG4gIG5vRXZlbnRzVGV4dDogJ+CkpuClh+CkluCkvuCkieCkqOCkleCliyDgpLLgpL7gpJfgpL8g4KSV4KWB4KSo4KWIIOCkmOCkn+CkqOCkvuCkueCksOClgiDgpJvgpYjgpKjgpKjgpY0nLFxufTtcblxudmFyIGw1NCA9IHtcbiAgY29kZTogJ25sJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnVm9yaWdlJyxcbiAgICBuZXh0OiAnVm9sZ2VuZGUnLFxuICAgIHRvZGF5OiAnVmFuZGFhZycsXG4gICAgeWVhcjogJ0phYXInLFxuICAgIG1vbnRoOiAnTWFhbmQnLFxuICAgIHdlZWs6ICdXZWVrJyxcbiAgICBkYXk6ICdEYWcnLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICBhbGxEYXlUZXh0OiAnSGVsZSBkYWcnLFxuICBtb3JlTGlua1RleHQ6ICdleHRyYScsXG4gIG5vRXZlbnRzVGV4dDogJ0dlZW4gZXZlbmVtZW50ZW4gb20gdGUgbGF0ZW4gemllbicsXG59O1xuXG52YXIgbDU1ID0ge1xuICBjb2RlOiAnbm4nLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdGw7hycmUnLFxuICAgIG5leHQ6ICdOZXN0ZScsXG4gICAgdG9kYXk6ICdJIGRhZycsXG4gICAgbW9udGg6ICdNw6VuYWQnLFxuICAgIHdlZWs6ICdWZWtlJyxcbiAgICBkYXk6ICdEYWcnLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1Zla2UnLFxuICBhbGxEYXlUZXh0OiAnSGVpbGUgZGFnZW4nLFxuICBtb3JlTGlua1RleHQ6ICd0aWwnLFxuICBub0V2ZW50c1RleHQ6ICdJbmdlbiBoZW5kZWxzZXIgw6UgdmlzZScsXG59O1xuXG52YXIgbDU2ID0ge1xuICBjb2RlOiAncGwnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdQb3ByemVkbmknLFxuICAgIG5leHQ6ICdOYXN0xJlwbnknLFxuICAgIHRvZGF5OiAnRHppxZsnLFxuICAgIG1vbnRoOiAnTWllc2nEhWMnLFxuICAgIHdlZWs6ICdUeWR6aWXFhCcsXG4gICAgZGF5OiAnRHppZcWEJyxcbiAgICBsaXN0OiAnUGxhbiBkbmlhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdUeWR6JyxcbiAgYWxsRGF5VGV4dDogJ0NhxYJ5IGR6aWXFhCcsXG4gIG1vcmVMaW5rVGV4dDogJ3dpxJljZWonLFxuICBub0V2ZW50c1RleHQ6ICdCcmFrIHd5ZGFyemXFhCBkbyB3ecWbd2lldGxlbmlhJyxcbn07XG5cbnZhciBsNTcgPSB7XG4gIGNvZGU6ICdwdC1icicsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQW50ZXJpb3InLFxuICAgIG5leHQ6ICdQcsOzeGltbycsXG4gICAgdG9kYXk6ICdIb2plJyxcbiAgICBtb250aDogJ03DqnMnLFxuICAgIHdlZWs6ICdTZW1hbmEnLFxuICAgIGRheTogJ0RpYScsXG4gICAgbGlzdDogJ0xpc3RhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdTbScsXG4gIGFsbERheVRleHQ6ICdkaWEgaW50ZWlybycsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnbWFpcyArJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAnTsOjbyBow6EgZXZlbnRvcyBwYXJhIG1vc3RyYXInLFxufTtcblxudmFyIGw1OCA9IHtcbiAgY29kZTogJ3B0JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQW50ZXJpb3InLFxuICAgIG5leHQ6ICdTZWd1aW50ZScsXG4gICAgdG9kYXk6ICdIb2plJyxcbiAgICBtb250aDogJ03DqnMnLFxuICAgIHdlZWs6ICdTZW1hbmEnLFxuICAgIGRheTogJ0RpYScsXG4gICAgbGlzdDogJ0FnZW5kYScsXG4gIH0sXG4gIHdlZWtUZXh0OiAnU2VtJyxcbiAgYWxsRGF5VGV4dDogJ1RvZG8gbyBkaWEnLFxuICBtb3JlTGlua1RleHQ6ICdtYWlzJyxcbiAgbm9FdmVudHNUZXh0OiAnTsOjbyBow6EgZXZlbnRvcyBwYXJhIG1vc3RyYXInLFxufTtcblxudmFyIGw1OSA9IHtcbiAgY29kZTogJ3JvJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA3LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAncHJlY2VkZW50xIMnLFxuICAgIG5leHQ6ICd1cm3Eg3RvYXJlJyxcbiAgICB0b2RheTogJ0F6aScsXG4gICAgbW9udGg6ICdMdW7EgycsXG4gICAgd2VlazogJ1PEg3B0xINtw6JuxIMnLFxuICAgIGRheTogJ1ppJyxcbiAgICBsaXN0OiAnQWdlbmTEgycsXG4gIH0sXG4gIHdlZWtUZXh0OiAnU8SDcHQnLFxuICBhbGxEYXlUZXh0OiAnVG9hdMSDIHppdWEnLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJythbHRlICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ051IGV4aXN0xIMgZXZlbmltZW50ZSBkZSBhZmnImWF0Jyxcbn07XG5cbnZhciBsNjAgPSB7XG4gIGNvZGU6ICdydScsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9Cf0YDQtdC0JyxcbiAgICBuZXh0OiAn0KHQu9C10LQnLFxuICAgIHRvZGF5OiAn0KHQtdCz0L7QtNC90Y8nLFxuICAgIG1vbnRoOiAn0JzQtdGB0Y/RhicsXG4gICAgd2VlazogJ9Cd0LXQtNC10LvRjycsXG4gICAgZGF5OiAn0JTQtdC90YwnLFxuICAgIGxpc3Q6ICfQn9C+0LLQtdGB0YLQutCwINC00L3RjycsXG4gIH0sXG4gIHdlZWtUZXh0OiAn0J3QtdC0JyxcbiAgYWxsRGF5VGV4dDogJ9CS0LXRgdGMINC00LXQvdGMJyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICcrINC10YnRkSAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICfQndC10YIg0YHQvtCx0YvRgtC40Lkg0LTQu9GPINC+0YLQvtCx0YDQsNC20LXQvdC40Y8nLFxufTtcblxudmFyIGw2MSA9IHtcbiAgY29kZTogJ3NrJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnUHJlZGNow6FkemFqw7pjaScsXG4gICAgbmV4dDogJ05hc2xlZHVqw7pjaScsXG4gICAgdG9kYXk6ICdEbmVzJyxcbiAgICBtb250aDogJ01lc2lhYycsXG4gICAgd2VlazogJ1TDvcW+ZGXFiCcsXG4gICAgZGF5OiAnRGXFiCcsXG4gICAgbGlzdDogJ1JvenZyaCcsXG4gIH0sXG4gIHdlZWtUZXh0OiAnVHknLFxuICBhbGxEYXlUZXh0OiAnQ2Vsw70gZGXFiCcsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnK8SPYWzFoWllOiAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICfFvWlhZG5lIGFrY2llIG5hIHpvYnJhemVuaWUnLFxufTtcblxudmFyIGw2MiA9IHtcbiAgY29kZTogJ3NsJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA3LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnUHJlasWhbmppJyxcbiAgICBuZXh0OiAnTmFzbGVkbmppJyxcbiAgICB0b2RheTogJ1RyZW51dG5pJyxcbiAgICBtb250aDogJ01lc2VjJyxcbiAgICB3ZWVrOiAnVGVkZW4nLFxuICAgIGRheTogJ0RhbicsXG4gICAgbGlzdDogJ0RuZXZuaSByZWQnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1RlZGVuJyxcbiAgYWxsRGF5VGV4dDogJ1ZlcyBkYW4nLFxuICBtb3JlTGlua1RleHQ6ICd2ZcSNJyxcbiAgbm9FdmVudHNUZXh0OiAnTmkgZG9nb2Rrb3YgemEgcHJpa2F6Jyxcbn07XG5cbnZhciBsNjMgPSB7XG4gIGNvZGU6ICdzbScsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnVGFsdSBhaScsXG4gICAgbmV4dDogJ011bGltdWxpIGF0dScsXG4gICAgdG9kYXk6ICdBc28gbmVpJyxcbiAgICBtb250aDogJ01hc2luYScsXG4gICAgd2VlazogJ1ZhaWFzbycsXG4gICAgZGF5OiAnQXNvJyxcbiAgICBsaXN0OiAnRmFhc29sb2dhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdWYWlhc28nLFxuICBhbGxEYXlUZXh0OiAnQXNvIGF0b2EnLFxuICBtb3JlTGlua1RleHQ6ICdzaWxpIGF0dScsXG4gIG5vRXZlbnRzVGV4dDogJ0xlYWkgbmkgbWVhIG5hIHR1dHVwdScsXG59O1xuXG52YXIgbDY0ID0ge1xuICBjb2RlOiAnc3EnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdtYnJhcGEnLFxuICAgIG5leHQ6ICdQw6tycGFyYScsXG4gICAgdG9kYXk6ICdzb3QnLFxuICAgIG1vbnRoOiAnTXVhaicsXG4gICAgd2VlazogJ0phdsOrJyxcbiAgICBkYXk6ICdEaXTDqycsXG4gICAgbGlzdDogJ0xpc3TDqycsXG4gIH0sXG4gIHdlZWtUZXh0OiAnSmEnLFxuICBhbGxEYXlUZXh0OiAnR2ppdGjDqyBkaXTDq24nLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJyttw6sgdGVww6tyICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ051ayBrYSBldmVudGUgcMOrciB0w6sgc2hmYXF1cicsXG59O1xuXG52YXIgbDY1ID0ge1xuICBjb2RlOiAnc3ItY3lybCcsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNywgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9Cf0YDQtdGC0YXQvtC00L3QsCcsXG4gICAgbmV4dDogJ9GB0LvQtdC00LXRm9C4JyxcbiAgICB0b2RheTogJ9CU0LDQvdCw0YEnLFxuICAgIG1vbnRoOiAn0JzQtdGB0LXRhicsXG4gICAgd2VlazogJ9Cd0LXQtNC10ZnQsCcsXG4gICAgZGF5OiAn0JTQsNC9JyxcbiAgICBsaXN0OiAn0J/Qu9Cw0L3QtdGAJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfQodC10LQnLFxuICBhbGxEYXlUZXh0OiAn0KbQtdC+INC00LDQvScsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyDRmNC+0YggJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAn0J3QtdC80LAg0LTQvtCz0LDRktCw0ZjQsCDQt9CwINC/0YDQuNC60LDQtycsXG59O1xuXG52YXIgbDY2ID0ge1xuICBjb2RlOiAnc3InLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdQcmV0aG9kbmEnLFxuICAgIG5leHQ6ICdTbGVkZWPMgWknLFxuICAgIHRvZGF5OiAnRGFuYXMnLFxuICAgIG1vbnRoOiAnTdC1c9C1YycsXG4gICAgd2VlazogJ07QtWTQtWxqYScsXG4gICAgZGF5OiAnRGFuJyxcbiAgICBsaXN0OiAnUGxhbtC1cicsXG4gIH0sXG4gIHdlZWtUZXh0OiAnU2VkJyxcbiAgYWxsRGF5VGV4dDogJ0PQtW8gZGFuJyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICcrIGpvxaEgJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAnTtC1bWEgZG9nYcSRYWphIHphIHByaWtheicsXG59O1xuXG52YXIgbDY3ID0ge1xuICBjb2RlOiAnc3YnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdGw7ZycmEnLFxuICAgIG5leHQ6ICdOw6RzdGEnLFxuICAgIHRvZGF5OiAnSWRhZycsXG4gICAgbW9udGg6ICdNw6VuYWQnLFxuICAgIHdlZWs6ICdWZWNrYScsXG4gICAgZGF5OiAnRGFnJyxcbiAgICBsaXN0OiAnUHJvZ3JhbScsXG4gIH0sXG4gIHdlZWtUZXh0OiAndi4nLFxuICBhbGxEYXlUZXh0OiAnSGVsZGFnJyxcbiAgbW9yZUxpbmtUZXh0OiAndGlsbCcsXG4gIG5vRXZlbnRzVGV4dDogJ0luZ2EgaMOkbmRlbHNlciBhdHQgdmlzYScsXG59O1xuXG52YXIgbDY4ID0ge1xuICBjb2RlOiAndGEtaW4nLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfgrq7gr4Hgrqjgr43grqTgr4jgrq8nLFxuICAgIG5leHQ6ICfgroXgrp/gr4HgrqTgr43grqTgrqTgr4EnLFxuICAgIHRvZGF5OiAn4K6H4K6p4K+N4K6x4K+BJyxcbiAgICBtb250aDogJ+CuruCuvuCupOCuruCvjScsXG4gICAgd2VlazogJ+CuteCuvuCusOCuruCvjScsXG4gICAgZGF5OiAn4K6o4K6+4K6z4K+NJyxcbiAgICBsaXN0OiAn4K6k4K6/4K6p4K6a4K6w4K6/IOCuheCun+CvjeCun+CuteCuo+CviCcsXG4gIH0sXG4gIHdlZWtUZXh0OiAn4K614K6+4K6w4K6u4K+NJyxcbiAgYWxsRGF5VGV4dDogJ+CuqOCuvuCus+CvjSDgrq7gr4HgrrTgr4HgrrXgrqTgr4Hgrq7gr40nLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJysg4K6u4K+H4K6y4K+B4K6u4K+NICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ+CuleCuvuCuo+CvjeCuquCuv+CuleCvjeCulSDgrqjgrr/grpXgrrTgr43grrXgr4HgrpXgrrPgr40g4K6H4K6y4K+N4K6y4K+IJyxcbn07XG5cbnZhciBsNjkgPSB7XG4gIGNvZGU6ICd0aCcsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ+C4geC5iOC4reC4meC4q+C4meC5ieC4sicsXG4gICAgbmV4dDogJ+C4luC4seC4lOC5hOC4mycsXG4gICAgcHJldlllYXI6ICfguJvguLXguIHguYjguK3guJnguKvguJnguYnguLInLFxuICAgIG5leHRZZWFyOiAn4Lib4Li14LiW4Lix4LiU4LmE4LibJyxcbiAgICB5ZWFyOiAn4Lib4Li1JyxcbiAgICB0b2RheTogJ+C4p+C4seC4meC4meC4teC5iScsXG4gICAgbW9udGg6ICfguYDguJTguLfguK3guJknLFxuICAgIHdlZWs6ICfguKrguLHguJvguJTguLLguKvguYwnLFxuICAgIGRheTogJ+C4p+C4seC4mScsXG4gICAgbGlzdDogJ+C4geC4s+C4q+C4meC4lOC4geC4suC4oycsXG4gIH0sXG4gIHdlZWtUZXh0OiAn4Liq4Lix4Lib4LiU4Liy4Lir4LmMJyxcbiAgYWxsRGF5VGV4dDogJ+C4leC4peC4reC4lOC4p+C4seC4mScsXG4gIG1vcmVMaW5rVGV4dDogJ+C5gOC4nuC4tOC5iOC4oeC5gOC4leC4tOC4oScsXG4gIG5vRXZlbnRzVGV4dDogJ+C5hOC4oeC5iOC4oeC4teC4geC4tOC4iOC4geC4o+C4o+C4oeC4l+C4teC5iOC4iOC4sOC5geC4quC4lOC4hycsXG59O1xuXG52YXIgbDcwID0ge1xuICBjb2RlOiAndHInLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdnZXJpJyxcbiAgICBuZXh0OiAnaWxlcmknLFxuICAgIHRvZGF5OiAnYnVnw7xuJyxcbiAgICBtb250aDogJ0F5JyxcbiAgICB3ZWVrOiAnSGFmdGEnLFxuICAgIGRheTogJ0fDvG4nLFxuICAgIGxpc3Q6ICdBamFuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ0hmJyxcbiAgYWxsRGF5VGV4dDogJ1TDvG0gZ8O8bicsXG4gIG1vcmVMaW5rVGV4dDogJ2RhaGEgZmF6bGEnLFxuICBub0V2ZW50c1RleHQ6ICdHw7ZzdGVyaWxlY2VrIGV0a2lubGlrIHlvaycsXG59O1xuXG52YXIgbDcxID0ge1xuICBjb2RlOiAndWcnLFxuICBidXR0b25UZXh0OiB7XG4gICAgbW9udGg6ICfYptin2YonLFxuICAgIHdlZWs6ICfavtuV2b7YqtuVJyxcbiAgICBkYXk6ICfZg9uI2YYnLFxuICAgIGxpc3Q6ICfZg9uI2YbYqtuV2LHYqtmJ2b4nLFxuICB9LFxuICBhbGxEYXlUZXh0OiAn2b7biNiq24jZhiDZg9uI2YYnLFxufTtcblxudmFyIGw3MiA9IHtcbiAgY29kZTogJ3VrJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA3LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn0J/QvtC/0LXRgNC10LTQvdGW0LknLFxuICAgIG5leHQ6ICfQtNCw0LvRlicsXG4gICAgdG9kYXk6ICfQodGM0L7Qs9C+0LTQvdGWJyxcbiAgICBtb250aDogJ9Cc0ZbRgdGP0YbRjCcsXG4gICAgd2VlazogJ9Ci0LjQttC00LXQvdGMJyxcbiAgICBkYXk6ICfQlNC10L3RjCcsXG4gICAgbGlzdDogJ9Cf0L7RgNGP0LTQvtC6INC00LXQvdC90LjQuScsXG4gIH0sXG4gIHdlZWtUZXh0OiAn0KLQuNC2JyxcbiAgYWxsRGF5VGV4dDogJ9Cj0LLQtdGB0Ywg0LTQtdC90YwnLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJyvRidC1ICcgKyBuICsgJy4uLidcbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAn0J3QtdC80LDRlCDQv9C+0LTRltC5INC00LvRjyDQstGW0LTQvtCx0YDQsNC20LXQvdC90Y8nLFxufTtcblxudmFyIGw3MyA9IHtcbiAgY29kZTogJ3V6JyxcbiAgYnV0dG9uVGV4dDoge1xuICAgIG1vbnRoOiAnT3knLFxuICAgIHdlZWs6ICdYYWZ0YScsXG4gICAgZGF5OiAnS3VuJyxcbiAgICBsaXN0OiAnS3VuIHRhcnRpYmknLFxuICB9LFxuICBhbGxEYXlUZXh0OiBcIkt1biBibyd5aVwiLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJysgeWFuYSAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6IFwiS28ncnNhdGlzaCB1Y2h1biB2b3FlYWxhciB5bydxXCIsXG59O1xuXG52YXIgbDc0ID0ge1xuICBjb2RlOiAndmknLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdUcsaw4bubYycsXG4gICAgbmV4dDogJ1Rp4bq/cCcsXG4gICAgdG9kYXk6ICdIw7RtIG5heScsXG4gICAgbW9udGg6ICdUaMOhbmcnLFxuICAgIHdlZWs6ICdUdcOizIBuJyxcbiAgICBkYXk6ICdOZ8OgeScsXG4gICAgbGlzdDogJ0zhu4tjaCBiaeG7g3UnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1R1JyxcbiAgYWxsRGF5VGV4dDogJ0PhuqMgbmfDoHknLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJysgdGjDqm0gJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAnS2jDtG5nIGPDsyBz4buxIGtp4buHbiDEkeG7gyBoaeG7g24gdGjhu4snLFxufTtcblxudmFyIGw3NSA9IHtcbiAgY29kZTogJ3poLWNuJyxcbiAgd2Vlazoge1xuICAgIC8vIEdCL1QgNzQwOC0xOTk044CK5pWw5o2u5YWD5ZKM5Lqk5o2i5qC85byPwrfkv6Hmga/kuqTmjaLCt+aXpeacn+WSjOaXtumXtOihqOekuuazleOAi+S4jklTTyA4NjAxOjE5ODjnrYnmlYhcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ+S4iuaciCcsXG4gICAgbmV4dDogJ+S4i+aciCcsXG4gICAgdG9kYXk6ICfku4rlpKknLFxuICAgIG1vbnRoOiAn5pyIJyxcbiAgICB3ZWVrOiAn5ZGoJyxcbiAgICBkYXk6ICfml6UnLFxuICAgIGxpc3Q6ICfml6XnqIsnLFxuICB9LFxuICB3ZWVrVGV4dDogJ+WRqCcsXG4gIGFsbERheVRleHQ6ICflhajlpKknLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJ+WPpuWkliAnICsgbiArICcg5LiqJ1xuICB9LFxuICBub0V2ZW50c1RleHQ6ICfmsqHmnInkuovku7bmmL7npLonLFxufTtcblxudmFyIGw3NiA9IHtcbiAgY29kZTogJ3poLXR3JyxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfkuIrmnIgnLFxuICAgIG5leHQ6ICfkuIvmnIgnLFxuICAgIHRvZGF5OiAn5LuK5aSpJyxcbiAgICBtb250aDogJ+aciCcsXG4gICAgd2VlazogJ+mAsScsXG4gICAgZGF5OiAn5aSpJyxcbiAgICBsaXN0OiAn5rS75YuV5YiX6KGoJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICflkagnLFxuICBhbGxEYXlUZXh0OiAn5pW05aSpJyxcbiAgbW9yZUxpbmtUZXh0OiAn6aGv56S65pu05aSaJyxcbiAgbm9FdmVudHNUZXh0OiAn5rKh5pyJ5Lu75L2V5rS75YuVJyxcbn07XG5cbi8qIGVzbGludCBtYXgtbGVuOiBvZmYgKi9cblxudmFyIGxvY2FsZXNBbGwgPSBbXG4gIGwwLCBsMSwgbDIsIGwzLCBsNCwgbDUsIGw2LCBsNywgbDgsIGw5LCBsMTAsIGwxMSwgbDEyLCBsMTMsIGwxNCwgbDE1LCBsMTYsIGwxNywgbDE4LCBsMTksIGwyMCwgbDIxLCBsMjIsIGwyMywgbDI0LCBsMjUsIGwyNiwgbDI3LCBsMjgsIGwyOSwgbDMwLCBsMzEsIGwzMiwgbDMzLCBsMzQsIGwzNSwgbDM2LCBsMzcsIGwzOCwgbDM5LCBsNDAsIGw0MSwgbDQyLCBsNDMsIGw0NCwgbDQ1LCBsNDYsIGw0NywgbDQ4LCBsNDksIGw1MCwgbDUxLCBsNTIsIGw1MywgbDU0LCBsNTUsIGw1NiwgbDU3LCBsNTgsIGw1OSwgbDYwLCBsNjEsIGw2MiwgbDYzLCBsNjQsIGw2NSwgbDY2LCBsNjcsIGw2OCwgbDY5LCBsNzAsIGw3MSwgbDcyLCBsNzMsIGw3NCwgbDc1LCBsNzYsIFxuXTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gbG9jYWxlc0FsbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/core/locales-all.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/core/main.js":
/*!*************************************************!*\
  !*** ./node_modules/@fullcalendar/core/main.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BASE_OPTION_DEFAULTS\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BASE_OPTION_DEFAULTS),\n/* harmony export */   \"BASE_OPTION_REFINERS\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BASE_OPTION_REFINERS),\n/* harmony export */   \"BaseComponent\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent),\n/* harmony export */   \"BgEvent\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BgEvent),\n/* harmony export */   \"CalendarApi\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarApi),\n/* harmony export */   \"CalendarContent\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarContent),\n/* harmony export */   \"CalendarDataManager\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarDataManager),\n/* harmony export */   \"CalendarDataProvider\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarDataProvider),\n/* harmony export */   \"CalendarRoot\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarRoot),\n/* harmony export */   \"Component\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Component),\n/* harmony export */   \"ContentHook\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ContentHook),\n/* harmony export */   \"CustomContentRenderContext\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CustomContentRenderContext),\n/* harmony export */   \"DateComponent\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent),\n/* harmony export */   \"DateEnv\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateEnv),\n/* harmony export */   \"DateProfileGenerator\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateProfileGenerator),\n/* harmony export */   \"DayCellContent\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayCellContent),\n/* harmony export */   \"DayCellRoot\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayCellRoot),\n/* harmony export */   \"DayHeader\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayHeader),\n/* harmony export */   \"DaySeriesModel\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DaySeriesModel),\n/* harmony export */   \"DayTableModel\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayTableModel),\n/* harmony export */   \"DelayedRunner\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DelayedRunner),\n/* harmony export */   \"ElementDragging\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ElementDragging),\n/* harmony export */   \"ElementScrollController\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ElementScrollController),\n/* harmony export */   \"Emitter\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Emitter),\n/* harmony export */   \"EventApi\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.EventApi),\n/* harmony export */   \"EventRoot\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.EventRoot),\n/* harmony export */   \"EventSourceApi\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.EventSourceApi),\n/* harmony export */   \"Fragment\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment),\n/* harmony export */   \"Interaction\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Interaction),\n/* harmony export */   \"MoreLinkRoot\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.MoreLinkRoot),\n/* harmony export */   \"MountHook\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.MountHook),\n/* harmony export */   \"NamedTimeZoneImpl\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NamedTimeZoneImpl),\n/* harmony export */   \"NowIndicatorRoot\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowIndicatorRoot),\n/* harmony export */   \"NowTimer\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowTimer),\n/* harmony export */   \"PositionCache\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache),\n/* harmony export */   \"RefMap\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap),\n/* harmony export */   \"RenderHook\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RenderHook),\n/* harmony export */   \"ScrollController\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ScrollController),\n/* harmony export */   \"ScrollResponder\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ScrollResponder),\n/* harmony export */   \"Scroller\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Scroller),\n/* harmony export */   \"SegHierarchy\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.SegHierarchy),\n/* harmony export */   \"SimpleScrollGrid\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.SimpleScrollGrid),\n/* harmony export */   \"Slicer\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Slicer),\n/* harmony export */   \"Splitter\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Splitter),\n/* harmony export */   \"StandardEvent\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.StandardEvent),\n/* harmony export */   \"TableDateCell\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.TableDateCell),\n/* harmony export */   \"TableDowCell\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.TableDowCell),\n/* harmony export */   \"Theme\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Theme),\n/* harmony export */   \"ViewApi\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewApi),\n/* harmony export */   \"ViewContextType\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewContextType),\n/* harmony export */   \"ViewRoot\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewRoot),\n/* harmony export */   \"WeekNumberRoot\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.WeekNumberRoot),\n/* harmony export */   \"WindowScrollController\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.WindowScrollController),\n/* harmony export */   \"addDays\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDays),\n/* harmony export */   \"addDurations\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDurations),\n/* harmony export */   \"addMs\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addMs),\n/* harmony export */   \"addWeeks\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addWeeks),\n/* harmony export */   \"allowContextMenu\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.allowContextMenu),\n/* harmony export */   \"allowSelection\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.allowSelection),\n/* harmony export */   \"applyMutationToEventStore\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.applyMutationToEventStore),\n/* harmony export */   \"applyStyle\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.applyStyle),\n/* harmony export */   \"applyStyleProp\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.applyStyleProp),\n/* harmony export */   \"asCleanDays\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asCleanDays),\n/* harmony export */   \"asRoughMinutes\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asRoughMinutes),\n/* harmony export */   \"asRoughMs\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asRoughMs),\n/* harmony export */   \"asRoughSeconds\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asRoughSeconds),\n/* harmony export */   \"binarySearch\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.binarySearch),\n/* harmony export */   \"buildClassNameNormalizer\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildClassNameNormalizer),\n/* harmony export */   \"buildEntryKey\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey),\n/* harmony export */   \"buildEventApis\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEventApis),\n/* harmony export */   \"buildEventRangeKey\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEventRangeKey),\n/* harmony export */   \"buildHashFromArray\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildHashFromArray),\n/* harmony export */   \"buildIsoString\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildIsoString),\n/* harmony export */   \"buildNavLinkData\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildNavLinkData),\n/* harmony export */   \"buildSegCompareObj\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegCompareObj),\n/* harmony export */   \"buildSegTimeText\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegTimeText),\n/* harmony export */   \"collectFromHash\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.collectFromHash),\n/* harmony export */   \"combineEventUis\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.combineEventUis),\n/* harmony export */   \"compareByFieldSpec\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.compareByFieldSpec),\n/* harmony export */   \"compareByFieldSpecs\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.compareByFieldSpecs),\n/* harmony export */   \"compareNumbers\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.compareNumbers),\n/* harmony export */   \"compareObjs\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.compareObjs),\n/* harmony export */   \"computeEarliestSegStart\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeEarliestSegStart),\n/* harmony export */   \"computeEdges\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeEdges),\n/* harmony export */   \"computeFallbackHeaderFormat\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeFallbackHeaderFormat),\n/* harmony export */   \"computeHeightAndMargins\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeHeightAndMargins),\n/* harmony export */   \"computeInnerRect\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeInnerRect),\n/* harmony export */   \"computeRect\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeRect),\n/* harmony export */   \"computeSegDraggable\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeSegDraggable),\n/* harmony export */   \"computeSegEndResizable\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeSegEndResizable),\n/* harmony export */   \"computeSegStartResizable\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeSegStartResizable),\n/* harmony export */   \"computeShrinkWidth\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeShrinkWidth),\n/* harmony export */   \"computeSmallestCellWidth\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeSmallestCellWidth),\n/* harmony export */   \"computeVisibleDayRange\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeVisibleDayRange),\n/* harmony export */   \"config\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.config),\n/* harmony export */   \"constrainPoint\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.constrainPoint),\n/* harmony export */   \"createContext\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createContext),\n/* harmony export */   \"createDuration\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createDuration),\n/* harmony export */   \"createElement\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement),\n/* harmony export */   \"createEmptyEventStore\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createEmptyEventStore),\n/* harmony export */   \"createEventInstance\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createEventInstance),\n/* harmony export */   \"createEventUi\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createEventUi),\n/* harmony export */   \"createFormatter\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter),\n/* harmony export */   \"createPlugin\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createPlugin),\n/* harmony export */   \"createPortal\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createPortal),\n/* harmony export */   \"createRef\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef),\n/* harmony export */   \"diffDates\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffDates),\n/* harmony export */   \"diffDayAndTime\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffDayAndTime),\n/* harmony export */   \"diffDays\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffDays),\n/* harmony export */   \"diffPoints\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffPoints),\n/* harmony export */   \"diffWeeks\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffWeeks),\n/* harmony export */   \"diffWholeDays\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffWholeDays),\n/* harmony export */   \"diffWholeWeeks\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffWholeWeeks),\n/* harmony export */   \"disableCursor\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.disableCursor),\n/* harmony export */   \"elementClosest\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.elementClosest),\n/* harmony export */   \"elementMatches\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.elementMatches),\n/* harmony export */   \"enableCursor\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.enableCursor),\n/* harmony export */   \"eventTupleToStore\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.eventTupleToStore),\n/* harmony export */   \"filterEventStoreDefs\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.filterEventStoreDefs),\n/* harmony export */   \"filterHash\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.filterHash),\n/* harmony export */   \"findDirectChildren\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.findDirectChildren),\n/* harmony export */   \"findElements\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.findElements),\n/* harmony export */   \"flexibleCompare\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.flexibleCompare),\n/* harmony export */   \"flushToDom\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.flushToDom),\n/* harmony export */   \"formatDate\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.formatDate),\n/* harmony export */   \"formatDayString\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.formatDayString),\n/* harmony export */   \"formatIsoTimeString\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.formatIsoTimeString),\n/* harmony export */   \"formatRange\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.formatRange),\n/* harmony export */   \"getAllowYScrolling\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getAllowYScrolling),\n/* harmony export */   \"getCanVGrowWithinCell\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getCanVGrowWithinCell),\n/* harmony export */   \"getClippingParents\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getClippingParents),\n/* harmony export */   \"getDateMeta\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getDateMeta),\n/* harmony export */   \"getDayClassNames\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getDayClassNames),\n/* harmony export */   \"getDefaultEventEnd\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getDefaultEventEnd),\n/* harmony export */   \"getElRoot\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getElRoot),\n/* harmony export */   \"getElSeg\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getElSeg),\n/* harmony export */   \"getEntrySpanEnd\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getEntrySpanEnd),\n/* harmony export */   \"getEventClassNames\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getEventClassNames),\n/* harmony export */   \"getEventTargetViaRoot\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getEventTargetViaRoot),\n/* harmony export */   \"getIsRtlScrollbarOnLeft\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getIsRtlScrollbarOnLeft),\n/* harmony export */   \"getRectCenter\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getRectCenter),\n/* harmony export */   \"getRelevantEvents\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getRelevantEvents),\n/* harmony export */   \"getScrollGridClassNames\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getScrollGridClassNames),\n/* harmony export */   \"getScrollbarWidths\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getScrollbarWidths),\n/* harmony export */   \"getSectionClassNames\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSectionClassNames),\n/* harmony export */   \"getSectionHasLiquidHeight\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSectionHasLiquidHeight),\n/* harmony export */   \"getSegMeta\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta),\n/* harmony export */   \"getSlotClassNames\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSlotClassNames),\n/* harmony export */   \"getStickyFooterScrollbar\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyFooterScrollbar),\n/* harmony export */   \"getStickyHeaderDates\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyHeaderDates),\n/* harmony export */   \"getUnequalProps\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getUnequalProps),\n/* harmony export */   \"globalLocales\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.globalLocales),\n/* harmony export */   \"globalPlugins\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.globalPlugins),\n/* harmony export */   \"greatestDurationDenominator\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.greatestDurationDenominator),\n/* harmony export */   \"groupIntersectingEntries\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.groupIntersectingEntries),\n/* harmony export */   \"guid\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.guid),\n/* harmony export */   \"hasBgRendering\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.hasBgRendering),\n/* harmony export */   \"hasShrinkWidth\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.hasShrinkWidth),\n/* harmony export */   \"identity\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.identity),\n/* harmony export */   \"interactionSettingsStore\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.interactionSettingsStore),\n/* harmony export */   \"interactionSettingsToStore\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.interactionSettingsToStore),\n/* harmony export */   \"intersectRanges\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectRanges),\n/* harmony export */   \"intersectRects\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectRects),\n/* harmony export */   \"intersectSpans\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectSpans),\n/* harmony export */   \"isArraysEqual\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isArraysEqual),\n/* harmony export */   \"isColPropsEqual\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isColPropsEqual),\n/* harmony export */   \"isDateSelectionValid\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isDateSelectionValid),\n/* harmony export */   \"isDateSpansEqual\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isDateSpansEqual),\n/* harmony export */   \"isInt\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isInt),\n/* harmony export */   \"isInteractionValid\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isInteractionValid),\n/* harmony export */   \"isMultiDayRange\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isMultiDayRange),\n/* harmony export */   \"isPropsEqual\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isPropsEqual),\n/* harmony export */   \"isPropsValid\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isPropsValid),\n/* harmony export */   \"isValidDate\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isValidDate),\n/* harmony export */   \"joinSpans\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.joinSpans),\n/* harmony export */   \"listenBySelector\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.listenBySelector),\n/* harmony export */   \"mapHash\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.mapHash),\n/* harmony export */   \"memoize\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize),\n/* harmony export */   \"memoizeArraylike\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoizeArraylike),\n/* harmony export */   \"memoizeHashlike\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoizeHashlike),\n/* harmony export */   \"memoizeObjArg\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoizeObjArg),\n/* harmony export */   \"mergeEventStores\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.mergeEventStores),\n/* harmony export */   \"multiplyDuration\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.multiplyDuration),\n/* harmony export */   \"padStart\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.padStart),\n/* harmony export */   \"parseBusinessHours\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.parseBusinessHours),\n/* harmony export */   \"parseClassNames\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.parseClassNames),\n/* harmony export */   \"parseDragMeta\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.parseDragMeta),\n/* harmony export */   \"parseEventDef\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.parseEventDef),\n/* harmony export */   \"parseFieldSpecs\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.parseFieldSpecs),\n/* harmony export */   \"parseMarker\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.parseMarker),\n/* harmony export */   \"pointInsideRect\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.pointInsideRect),\n/* harmony export */   \"preventContextMenu\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.preventContextMenu),\n/* harmony export */   \"preventDefault\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.preventDefault),\n/* harmony export */   \"preventSelection\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.preventSelection),\n/* harmony export */   \"rangeContainsMarker\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.rangeContainsMarker),\n/* harmony export */   \"rangeContainsRange\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.rangeContainsRange),\n/* harmony export */   \"rangesEqual\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.rangesEqual),\n/* harmony export */   \"rangesIntersect\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.rangesIntersect),\n/* harmony export */   \"refineEventDef\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.refineEventDef),\n/* harmony export */   \"refineProps\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.refineProps),\n/* harmony export */   \"removeElement\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.removeElement),\n/* harmony export */   \"removeExact\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.removeExact),\n/* harmony export */   \"render\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.render),\n/* harmony export */   \"renderChunkContent\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderChunkContent),\n/* harmony export */   \"renderFill\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderFill),\n/* harmony export */   \"renderMicroColGroup\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderMicroColGroup),\n/* harmony export */   \"renderScrollShim\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderScrollShim),\n/* harmony export */   \"requestJson\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.requestJson),\n/* harmony export */   \"sanitizeShrinkWidth\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sanitizeShrinkWidth),\n/* harmony export */   \"setElSeg\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.setElSeg),\n/* harmony export */   \"setRef\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.setRef),\n/* harmony export */   \"sliceEventStore\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sliceEventStore),\n/* harmony export */   \"sliceEvents\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sliceEvents),\n/* harmony export */   \"sortEventSegs\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sortEventSegs),\n/* harmony export */   \"startOfDay\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.startOfDay),\n/* harmony export */   \"translateRect\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.translateRect),\n/* harmony export */   \"triggerDateSelect\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.triggerDateSelect),\n/* harmony export */   \"unmountComponentAtNode\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.unmountComponentAtNode),\n/* harmony export */   \"unpromisify\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.unpromisify),\n/* harmony export */   \"version\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.version),\n/* harmony export */   \"whenTransitionDone\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.whenTransitionDone),\n/* harmony export */   \"wholeDivideDurations\": () => (/* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.wholeDivideDurations),\n/* harmony export */   \"Calendar\": () => (/* binding */ Calendar)\n/* harmony export */ });\n/* harmony import */ var _vdom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vdom.js */ \"./node_modules/@fullcalendar/core/vdom.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/*!\nFullCalendar v5.9.0\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n\n\n\nvar Calendar = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Calendar, _super);\n\n  function Calendar(el, optionOverrides) {\n    if (optionOverrides === void 0) {\n      optionOverrides = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.isRendering = false;\n    _this.isRendered = false;\n    _this.currentClassNames = [];\n    _this.customContentRenderId = 0; // will affect custom generated classNames?\n\n    _this.handleAction = function (action) {\n      // actions we know we want to render immediately\n      switch (action.type) {\n        case 'SET_EVENT_DRAG':\n        case 'SET_EVENT_RESIZE':\n          _this.renderRunner.tryDrain();\n\n      }\n    };\n\n    _this.handleData = function (data) {\n      _this.currentData = data;\n\n      _this.renderRunner.request(data.calendarOptions.rerenderDelay);\n    };\n\n    _this.handleRenderRequest = function () {\n      if (_this.isRendering) {\n        _this.isRendered = true;\n        var currentData_1 = _this.currentData;\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.render)((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarRoot, {\n          options: currentData_1.calendarOptions,\n          theme: currentData_1.theme,\n          emitter: currentData_1.emitter\n        }, function (classNames, height, isHeightAuto, forPrint) {\n          _this.setClassNames(classNames);\n\n          _this.setHeight(height);\n\n          return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CustomContentRenderContext.Provider, {\n            value: _this.customContentRenderId\n          }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarContent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            isHeightAuto: isHeightAuto,\n            forPrint: forPrint\n          }, currentData_1)));\n        }), _this.el);\n      } else if (_this.isRendered) {\n        _this.isRendered = false;\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.unmountComponentAtNode)(_this.el);\n\n        _this.setClassNames([]);\n\n        _this.setHeight('');\n      }\n\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.flushToDom)();\n    };\n\n    _this.el = el;\n    _this.renderRunner = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DelayedRunner(_this.handleRenderRequest);\n    new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarDataManager({\n      optionOverrides: optionOverrides,\n      calendarApi: _this,\n      onAction: _this.handleAction,\n      onData: _this.handleData\n    });\n    return _this;\n  }\n\n  Object.defineProperty(Calendar.prototype, \"view\", {\n    get: function () {\n      return this.currentData.viewApi;\n    } // for public API\n    ,\n    enumerable: false,\n    configurable: true\n  });\n\n  Calendar.prototype.render = function () {\n    var wasRendering = this.isRendering;\n\n    if (!wasRendering) {\n      this.isRendering = true;\n    } else {\n      this.customContentRenderId += 1;\n    }\n\n    this.renderRunner.request();\n\n    if (wasRendering) {\n      this.updateSize();\n    }\n  };\n\n  Calendar.prototype.destroy = function () {\n    if (this.isRendering) {\n      this.isRendering = false;\n      this.renderRunner.request();\n    }\n  };\n\n  Calendar.prototype.updateSize = function () {\n    _super.prototype.updateSize.call(this);\n\n    (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.flushToDom)();\n  };\n\n  Calendar.prototype.batchRendering = function (func) {\n    this.renderRunner.pause('batchRendering');\n    func();\n    this.renderRunner.resume('batchRendering');\n  };\n\n  Calendar.prototype.pauseRendering = function () {\n    this.renderRunner.pause('pauseRendering');\n  };\n\n  Calendar.prototype.resumeRendering = function () {\n    this.renderRunner.resume('pauseRendering', true);\n  };\n\n  Calendar.prototype.resetOptions = function (optionOverrides, append) {\n    this.currentDataManager.resetOptions(optionOverrides, append);\n  };\n\n  Calendar.prototype.setClassNames = function (classNames) {\n    if (!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isArraysEqual)(classNames, this.currentClassNames)) {\n      var classList = this.el.classList;\n\n      for (var _i = 0, _a = this.currentClassNames; _i < _a.length; _i++) {\n        var className = _a[_i];\n        classList.remove(className);\n      }\n\n      for (var _b = 0, classNames_1 = classNames; _b < classNames_1.length; _b++) {\n        var className = classNames_1[_b];\n        classList.add(className);\n      }\n\n      this.currentClassNames = classNames;\n    }\n  };\n\n  Calendar.prototype.setHeight = function (height) {\n    (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.applyStyleProp)(this.el, 'height', height);\n  };\n\n  return Calendar;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarApi);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL21haW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTUE7O0FBV0E7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBUEE7QUFDQTtBQUNBO0FBQ0E7O0FBa0JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUhBO0FBS0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBOztBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFGQTtBQU9BO0FBSUE7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUF6REE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFNQTs7QUFkQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBZ0VBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUExSUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvQ2FsZW5kYXIudHN4PzUwMzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2FsZW5kYXJPcHRpb25zLCBBY3Rpb24sIENhbGVuZGFyQ29udGVudCwgcmVuZGVyLCBjcmVhdGVFbGVtZW50LCBEZWxheWVkUnVubmVyLCBDc3NEaW1WYWx1ZSwgYXBwbHlTdHlsZVByb3AsXG4gIENhbGVuZGFyQXBpLCBDYWxlbmRhclJvb3QsIGlzQXJyYXlzRXF1YWwsIENhbGVuZGFyRGF0YU1hbmFnZXIsIENhbGVuZGFyRGF0YSxcbiAgQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQsIGZsdXNoVG9Eb20sIHVubW91bnRDb21wb25lbnRBdE5vZGUsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXIgZXh0ZW5kcyBDYWxlbmRhckFwaSB7XG4gIGN1cnJlbnREYXRhOiBDYWxlbmRhckRhdGFcbiAgcmVuZGVyUnVubmVyOiBEZWxheWVkUnVubmVyXG4gIGVsOiBIVE1MRWxlbWVudFxuICBpc1JlbmRlcmluZyA9IGZhbHNlXG4gIGlzUmVuZGVyZWQgPSBmYWxzZVxuICBjdXJyZW50Q2xhc3NOYW1lczogc3RyaW5nW10gPSBbXVxuICBjdXN0b21Db250ZW50UmVuZGVySWQgPSAwIC8vIHdpbGwgYWZmZWN0IGN1c3RvbSBnZW5lcmF0ZWQgY2xhc3NOYW1lcz9cblxuICBnZXQgdmlldygpIHsgcmV0dXJuIHRoaXMuY3VycmVudERhdGEudmlld0FwaSB9IC8vIGZvciBwdWJsaWMgQVBJXG5cbiAgY29uc3RydWN0b3IoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5lbCA9IGVsXG4gICAgdGhpcy5yZW5kZXJSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcih0aGlzLmhhbmRsZVJlbmRlclJlcXVlc3QpXG5cbiAgICBuZXcgQ2FsZW5kYXJEYXRhTWFuYWdlcih7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICBjYWxlbmRhckFwaTogdGhpcyxcbiAgICAgIG9uQWN0aW9uOiB0aGlzLmhhbmRsZUFjdGlvbixcbiAgICAgIG9uRGF0YTogdGhpcy5oYW5kbGVEYXRhLFxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVBY3Rpb24gPSAoYWN0aW9uOiBBY3Rpb24pID0+IHtcbiAgICAvLyBhY3Rpb25zIHdlIGtub3cgd2Ugd2FudCB0byByZW5kZXIgaW1tZWRpYXRlbHlcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdTRVRfRVZFTlRfRFJBRyc6XG4gICAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIudHJ5RHJhaW4oKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZURhdGEgPSAoZGF0YTogQ2FsZW5kYXJEYXRhKSA9PiB7XG4gICAgdGhpcy5jdXJyZW50RGF0YSA9IGRhdGFcbiAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KGRhdGEuY2FsZW5kYXJPcHRpb25zLnJlcmVuZGVyRGVsYXkpXG4gIH1cblxuICBoYW5kbGVSZW5kZXJSZXF1ZXN0ID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICB0aGlzLmlzUmVuZGVyZWQgPSB0cnVlXG4gICAgICBsZXQgeyBjdXJyZW50RGF0YSB9ID0gdGhpc1xuXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxDYWxlbmRhclJvb3Qgb3B0aW9ucz17Y3VycmVudERhdGEuY2FsZW5kYXJPcHRpb25zfSB0aGVtZT17Y3VycmVudERhdGEudGhlbWV9IGVtaXR0ZXI9e2N1cnJlbnREYXRhLmVtaXR0ZXJ9PlxuICAgICAgICAgIHsoY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoY2xhc3NOYW1lcylcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodClcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPEN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZH0+XG4gICAgICAgICAgICAgICAgPENhbGVuZGFyQ29udGVudFxuICAgICAgICAgICAgICAgICAgaXNIZWlnaHRBdXRvPXtpc0hlaWdodEF1dG99XG4gICAgICAgICAgICAgICAgICBmb3JQcmludD17Zm9yUHJpbnR9XG4gICAgICAgICAgICAgICAgICB7Li4uY3VycmVudERhdGF9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9DdXN0b21Db250ZW50UmVuZGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9fVxuICAgICAgICA8L0NhbGVuZGFyUm9vdD4sXG4gICAgICAgIHRoaXMuZWwsXG4gICAgICApXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmVuZGVyZWQpIHtcbiAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlXG4gICAgICB1bm1vdW50Q29tcG9uZW50QXROb2RlKHRoaXMuZWwpXG4gICAgICB0aGlzLnNldENsYXNzTmFtZXMoW10pXG4gICAgICB0aGlzLnNldEhlaWdodCgnJylcbiAgICB9XG5cbiAgICBmbHVzaFRvRG9tKClcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgd2FzUmVuZGVyaW5nID0gdGhpcy5pc1JlbmRlcmluZ1xuXG4gICAgaWYgKCF3YXNSZW5kZXJpbmcpIHtcbiAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkICs9IDFcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KClcblxuICAgIGlmICh3YXNSZW5kZXJpbmcpIHtcbiAgICAgIHRoaXMudXBkYXRlU2l6ZSgpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhbHNlXG4gICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KClcbiAgICB9XG4gIH1cblxuICB1cGRhdGVTaXplKCkge1xuICAgIHN1cGVyLnVwZGF0ZVNpemUoKVxuICAgIGZsdXNoVG9Eb20oKVxuICB9XG5cbiAgYmF0Y2hSZW5kZXJpbmcoZnVuYykge1xuICAgIHRoaXMucmVuZGVyUnVubmVyLnBhdXNlKCdiYXRjaFJlbmRlcmluZycpXG4gICAgZnVuYygpXG4gICAgdGhpcy5yZW5kZXJSdW5uZXIucmVzdW1lKCdiYXRjaFJlbmRlcmluZycpXG4gIH1cblxuICBwYXVzZVJlbmRlcmluZygpIHsgLy8gYXZhaWxhYmxlIHRvIHBsdWdpbnNcbiAgICB0aGlzLnJlbmRlclJ1bm5lci5wYXVzZSgncGF1c2VSZW5kZXJpbmcnKVxuICB9XG5cbiAgcmVzdW1lUmVuZGVyaW5nKCkgeyAvLyBhdmFpbGFibGUgdG8gcGx1Z2luc1xuICAgIHRoaXMucmVuZGVyUnVubmVyLnJlc3VtZSgncGF1c2VSZW5kZXJpbmcnLCB0cnVlKVxuICB9XG5cbiAgcmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgYXBwZW5kPykge1xuICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLnJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGFwcGVuZClcbiAgfVxuXG4gIHNldENsYXNzTmFtZXMoY2xhc3NOYW1lczogc3RyaW5nW10pIHtcbiAgICBpZiAoIWlzQXJyYXlzRXF1YWwoY2xhc3NOYW1lcywgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcykpIHtcbiAgICAgIGxldCB7IGNsYXNzTGlzdCB9ID0gdGhpcy5lbFxuXG4gICAgICBmb3IgKGxldCBjbGFzc05hbWUgb2YgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcykge1xuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSlcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudENsYXNzTmFtZXMgPSBjbGFzc05hbWVzXG4gICAgfVxuICB9XG5cbiAgc2V0SGVpZ2h0KGhlaWdodDogQ3NzRGltVmFsdWUpIHtcbiAgICBhcHBseVN0eWxlUHJvcCh0aGlzLmVsLCAnaGVpZ2h0JywgaGVpZ2h0KVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/core/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/core/vdom.js":
/*!*************************************************!*\
  !*** ./node_modules/@fullcalendar/core/vdom.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var preact_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/compat */ \"./node_modules/preact/compat/dist/compat.module.js\");\n\n\n\nvar globalObj = typeof globalThis !== 'undefined' ? globalThis : window; // // TODO: streamline when killing IE11 support\n\nif (globalObj.FullCalendarVDom) {\n  console.warn('FullCalendar VDOM already loaded');\n} else {\n  globalObj.FullCalendarVDom = {\n    Component: preact__WEBPACK_IMPORTED_MODULE_0__.Component,\n    createElement: preact__WEBPACK_IMPORTED_MODULE_0__.createElement,\n    render: preact__WEBPACK_IMPORTED_MODULE_0__.render,\n    createRef: preact__WEBPACK_IMPORTED_MODULE_0__.createRef,\n    Fragment: preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,\n    createContext: createContext,\n    createPortal: preact_compat__WEBPACK_IMPORTED_MODULE_1__.createPortal,\n    flushToDom: flushToDom,\n    unmountComponentAtNode: unmountComponentAtNode\n  };\n} // HACKS...\n// TODO: lock version\n// TODO: link gh issues\n\n\nfunction flushToDom() {\n  var oldDebounceRendering = preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering; // orig\n\n  var callbackQ = [];\n\n  function execCallbackSync(callback) {\n    callbackQ.push(callback);\n  }\n\n  preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering = execCallbackSync;\n  preact__WEBPACK_IMPORTED_MODULE_0__.render(preact__WEBPACK_IMPORTED_MODULE_0__.createElement(FakeComponent, {}), document.createElement('div'));\n\n  while (callbackQ.length) {\n    callbackQ.shift()();\n  }\n\n  preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering = oldDebounceRendering;\n}\n\nvar FakeComponent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(FakeComponent, _super);\n\n  function FakeComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FakeComponent.prototype.render = function () {\n    return preact__WEBPACK_IMPORTED_MODULE_0__.createElement('div', {});\n  };\n\n  FakeComponent.prototype.componentDidMount = function () {\n    this.setState({});\n  };\n\n  return FakeComponent;\n}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);\n\nfunction createContext(defaultValue) {\n  var ContextType = preact__WEBPACK_IMPORTED_MODULE_0__.createContext(defaultValue);\n  var origProvider = ContextType.Provider;\n\n  ContextType.Provider = function () {\n    var _this = this;\n\n    var isNew = !this.getChildContext;\n    var children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params\n\n    if (isNew) {\n      var subs_1 = [];\n\n      this.shouldComponentUpdate = function (_props) {\n        if (_this.props.value !== _props.value) {\n          subs_1.forEach(function (c) {\n            c.context = _props.value;\n            c.forceUpdate();\n          });\n        }\n      };\n\n      this.sub = function (c) {\n        subs_1.push(c);\n        var old = c.componentWillUnmount;\n\n        c.componentWillUnmount = function () {\n          subs_1.splice(subs_1.indexOf(c), 1);\n          old && old.call(c);\n        };\n      };\n    }\n\n    return children;\n  };\n\n  return ContextType;\n}\n\nfunction unmountComponentAtNode(node) {\n  preact__WEBPACK_IMPORTED_MODULE_0__.render(null, node);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL3Zkb20uanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS92ZG9tLmpzPzU1NzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0ICogYXMgcHJlYWN0IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgKiBhcyBwcmVhY3RDb21wYXQgZnJvbSAncHJlYWN0L2NvbXBhdCc7XG5cbnZhciBnbG9iYWxPYmogPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogd2luZG93OyAvLyAvLyBUT0RPOiBzdHJlYW1saW5lIHdoZW4ga2lsbGluZyBJRTExIHN1cHBvcnRcbmlmIChnbG9iYWxPYmouRnVsbENhbGVuZGFyVkRvbSkge1xuICAgIGNvbnNvbGUud2FybignRnVsbENhbGVuZGFyIFZET00gYWxyZWFkeSBsb2FkZWQnKTtcbn1cbmVsc2Uge1xuICAgIGdsb2JhbE9iai5GdWxsQ2FsZW5kYXJWRG9tID0ge1xuICAgICAgICBDb21wb25lbnQ6IHByZWFjdC5Db21wb25lbnQsXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQ6IHByZWFjdC5jcmVhdGVFbGVtZW50LFxuICAgICAgICByZW5kZXI6IHByZWFjdC5yZW5kZXIsXG4gICAgICAgIGNyZWF0ZVJlZjogcHJlYWN0LmNyZWF0ZVJlZixcbiAgICAgICAgRnJhZ21lbnQ6IHByZWFjdC5GcmFnbWVudCxcbiAgICAgICAgY3JlYXRlQ29udGV4dDogY3JlYXRlQ29udGV4dCxcbiAgICAgICAgY3JlYXRlUG9ydGFsOiBwcmVhY3RDb21wYXQuY3JlYXRlUG9ydGFsLFxuICAgICAgICBmbHVzaFRvRG9tOiBmbHVzaFRvRG9tLFxuICAgICAgICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiB1bm1vdW50Q29tcG9uZW50QXROb2RlLFxuICAgIH07XG59XG4vLyBIQUNLUy4uLlxuLy8gVE9ETzogbG9jayB2ZXJzaW9uXG4vLyBUT0RPOiBsaW5rIGdoIGlzc3Vlc1xuZnVuY3Rpb24gZmx1c2hUb0RvbSgpIHtcbiAgICB2YXIgb2xkRGVib3VuY2VSZW5kZXJpbmcgPSBwcmVhY3Qub3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZzsgLy8gb3JpZ1xuICAgIHZhciBjYWxsYmFja1EgPSBbXTtcbiAgICBmdW5jdGlvbiBleGVjQ2FsbGJhY2tTeW5jKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrUS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBleGVjQ2FsbGJhY2tTeW5jO1xuICAgIHByZWFjdC5yZW5kZXIocHJlYWN0LmNyZWF0ZUVsZW1lbnQoRmFrZUNvbXBvbmVudCwge30pLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgd2hpbGUgKGNhbGxiYWNrUS5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2tRLnNoaWZ0KCkoKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBvbGREZWJvdW5jZVJlbmRlcmluZztcbn1cbnZhciBGYWtlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGYWtlQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZha2VDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRmFrZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHt9KTsgfTtcbiAgICBGYWtlQ29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5zZXRTdGF0ZSh7fSk7IH07XG4gICAgcmV0dXJuIEZha2VDb21wb25lbnQ7XG59KHByZWFjdC5Db21wb25lbnQpKTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIENvbnRleHRUeXBlID0gcHJlYWN0LmNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlKTtcbiAgICB2YXIgb3JpZ1Byb3ZpZGVyID0gQ29udGV4dFR5cGUuUHJvdmlkZXI7XG4gICAgQ29udGV4dFR5cGUuUHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpc05ldyA9ICF0aGlzLmdldENoaWxkQ29udGV4dDtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gb3JpZ1Byb3ZpZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgICAgdmFyIHN1YnNfMSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAoX3Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnZhbHVlICE9PSBfcHJvcHMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic18xLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3ViID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBzdWJzXzEucHVzaChjKTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcbiAgICAgICAgICAgICAgICBjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzXzEuc3BsaWNlKHN1YnNfMS5pbmRleE9mKGMpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkICYmIG9sZC5jYWxsKGMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0VHlwZTtcbn1cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUobm9kZSkge1xuICAgIHByZWFjdC5yZW5kZXIobnVsbCwgbm9kZSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/core/vdom.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.js":
/*!****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"DayGridView\": () => (/* binding */ DayTableView),\n/* harmony export */   \"DayTable\": () => (/* binding */ DayTable),\n/* harmony export */   \"DayTableSlicer\": () => (/* binding */ DayTableSlicer),\n/* harmony export */   \"Table\": () => (/* binding */ Table),\n/* harmony export */   \"TableView\": () => (/* binding */ TableView),\n/* harmony export */   \"buildDayTableModel\": () => (/* binding */ buildDayTableModel)\n/* harmony export */ });\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ \"./node_modules/@fullcalendar/daygrid/main.css\");\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/*!\nFullCalendar v5.9.0\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/\n// It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\n\nvar TableView = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableView, _super);\n\n  function TableView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.headerElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    return _this;\n  }\n\n  TableView.prototype.renderSimpleLayout = function (headerRowContent, bodyContent) {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var sections = [];\n    var stickyHeaderDates = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyHeaderDates)(context.options);\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunk: {\n        content: bodyContent\n      }\n    });\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewRoot, {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        ref: rootElRef,\n        className: ['fc-daygrid'].concat(classNames).join(' ')\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.SimpleScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        cols: []\n        /* TODO: make optional? */\n        ,\n        sections: sections\n      }));\n    });\n  };\n\n  TableView.prototype.renderHScrollLayout = function (headerRowContent, bodyContent, colCnt, dayMinWidth) {\n    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var stickyHeaderDates = !props.forPrint && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyHeaderDates)(context.options);\n    var stickyFooterScrollbar = !props.forPrint && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyFooterScrollbar)(context.options);\n    var sections = [];\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunks: [{\n          key: 'main',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunks: [{\n        key: 'main',\n        content: bodyContent\n      }]\n    });\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        type: 'footer',\n        key: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'main',\n          content: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderScrollShim\n        }]\n      });\n    }\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewRoot, {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        ref: rootElRef,\n        className: ['fc-daygrid'].concat(classNames).join(' ')\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        colGroups: [{\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    });\n  };\n\n  return TableView;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\n\nfunction splitSegsByRow(segs, rowCnt) {\n  var byRow = [];\n\n  for (var i = 0; i < rowCnt; i += 1) {\n    byRow[i] = [];\n  }\n\n  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n    var seg = segs_1[_i];\n    byRow[seg.row].push(seg);\n  }\n\n  return byRow;\n}\n\nfunction splitSegsByFirstCol(segs, colCnt) {\n  var byCol = [];\n\n  for (var i = 0; i < colCnt; i += 1) {\n    byCol[i] = [];\n  }\n\n  for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n    var seg = segs_2[_i];\n    byCol[seg.firstCol].push(seg);\n  }\n\n  return byCol;\n}\n\nfunction splitInteractionByRow(ui, rowCnt) {\n  var byRow = [];\n\n  if (!ui) {\n    for (var i = 0; i < rowCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var i = 0; i < rowCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n\n    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n      var seg = _a[_i];\n      byRow[seg.row].segs.push(seg);\n    }\n  }\n\n  return byRow;\n}\n\nvar TableCellTop = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableCellTop, _super);\n\n  function TableCellTop() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableCellTop.prototype.render = function () {\n    var props = this.props;\n    var navLinkAttrs = this.context.options.navLinks ? {\n      'data-navlink': (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildNavLinkData)(props.date),\n      tabIndex: 0\n    } : {};\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayCellContent, {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraHookProps: props.extraHookProps,\n      defaultContent: renderTopInner\n    }, function (innerElRef, innerContent) {\n      return (innerContent || props.forceDayTop) && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-top\",\n        ref: innerElRef\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        className: \"fc-daygrid-day-number\"\n      }, navLinkAttrs), innerContent || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\u00A0\")));\n    });\n  };\n\n  return TableCellTop;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n\nfunction renderTopInner(props) {\n  return props.dayNumberText;\n}\n\nvar DEFAULT_TABLE_EVENT_TIME_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow'\n});\n\nfunction hasListItemDisplay(seg) {\n  var display = seg.eventRange.ui.display;\n  return display === 'list-item' || display === 'auto' && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n  seg.isStart && // \"\n  seg.isEnd // \"\n  ;\n}\n\nvar TableBlockEvent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableBlockEvent, _super);\n\n  function TableBlockEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableBlockEvent.prototype.render = function () {\n    var props = this.props;\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.StandardEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, props, {\n      extraClassNames: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'],\n      defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n      defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n      disableResizing: !props.seg.eventRange.def.allDay\n    }));\n  };\n\n  return TableBlockEvent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n\nvar TableListItemEvent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableListItemEvent, _super);\n\n  function TableListItemEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableListItemEvent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n    var timeText = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegTimeText)(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.EventRoot, {\n      seg: props.seg,\n      timeText: timeText,\n      defaultContent: renderInnerContent,\n      isDragging: props.isDragging,\n      isResizing: false,\n      isDateSelecting: false,\n      isSelected: props.isSelected,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return (// we don't use styles!\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          className: ['fc-daygrid-event', 'fc-daygrid-dot-event'].concat(classNames).join(' '),\n          ref: rootElRef\n        }, getSegAnchorAttrs(props.seg)), innerContent)\n      );\n    });\n  };\n\n  return TableListItemEvent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n\nfunction renderInnerContent(innerProps) {\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-daygrid-event-dot\",\n    style: {\n      borderColor: innerProps.borderColor || innerProps.backgroundColor\n    }\n  }), innerProps.timeText && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-time\"\n  }, innerProps.timeText), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-title\"\n  }, innerProps.event.title || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\u00A0\")));\n}\n\nfunction getSegAnchorAttrs(seg) {\n  var url = seg.eventRange.def.url;\n  return url ? {\n    href: url\n  } : {};\n}\n\nvar TableCellMoreLink = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableCellMoreLink, _super);\n\n  function TableCellMoreLink() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.compileSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(compileSegs);\n    return _this;\n  }\n\n  TableCellMoreLink.prototype.render = function () {\n    var props = this.props;\n\n    var _a = this.compileSegs(props.singlePlacements),\n        allSegs = _a.allSegs,\n        invisibleSegs = _a.invisibleSegs;\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.MoreLinkRoot, {\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      allDayDate: props.allDayDate,\n      moreCnt: props.moreCnt,\n      allSegs: allSegs,\n      hiddenSegs: invisibleSegs,\n      alignmentElRef: props.alignmentElRef,\n      alignGridTop: props.alignGridTop,\n      extraDateSpan: props.extraDateSpan,\n      popoverContent: function () {\n        var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, allSegs.map(function (seg) {\n          var instanceId = seg.eventRange.instance.instanceId;\n          return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-daygrid-event-harness\",\n            key: instanceId,\n            style: {\n              visibility: isForcedInvisible[instanceId] ? 'hidden' : ''\n            }\n          }, hasListItemDisplay(seg) ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            seg: seg,\n            isDragging: false,\n            isSelected: instanceId === props.eventSelection,\n            defaultDisplayEventEnd: false\n          }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, props.todayRange))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            seg: seg,\n            isDragging: false,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: instanceId === props.eventSelection,\n            defaultDisplayEventEnd: false\n          }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, props.todayRange))));\n        }));\n      }\n    }, function (rootElRef, classNames, innerElRef, innerContent, handleClick) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", {\n        ref: rootElRef,\n        className: ['fc-daygrid-more-link'].concat(classNames).join(' '),\n        onClick: handleClick\n      }, innerContent);\n    });\n  };\n\n  return TableCellMoreLink;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n\nfunction compileSegs(singlePlacements) {\n  var allSegs = [];\n  var invisibleSegs = [];\n\n  for (var _i = 0, singlePlacements_1 = singlePlacements; _i < singlePlacements_1.length; _i++) {\n    var placement = singlePlacements_1[_i];\n    allSegs.push(placement.seg);\n\n    if (!placement.isVisible) {\n      invisibleSegs.push(placement.seg);\n    }\n  }\n\n  return {\n    allSegs: allSegs,\n    invisibleSegs: invisibleSegs\n  };\n}\n\nvar DEFAULT_WEEK_NUM_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)({\n  week: 'narrow'\n});\n\nvar TableCell = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableCell, _super);\n\n  function TableCell() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n\n    _this.handleRootEl = function (el) {\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.setRef)(_this.rootElRef, el);\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.setRef)(_this.props.elRef, el);\n    };\n\n    return _this;\n  }\n\n  TableCell.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context,\n        rootElRef = _a.rootElRef;\n\n    var options = context.options;\n    var date = props.date,\n        dateProfile = props.dateProfile;\n    var navLinkAttrs = options.navLinks ? {\n      'data-navlink': (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildNavLinkData)(date, 'week'),\n      tabIndex: 0\n    } : {};\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayCellRoot, {\n      date: date,\n      dateProfile: dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraHookProps: props.extraHookProps,\n      elRef: this.handleRootEl\n    }, function (dayElRef, dayClassNames, rootDataAttrs, isDisabled) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        ref: dayElRef,\n        className: ['fc-daygrid-day'].concat(dayClassNames, props.extraClassNames || []).join(' ')\n      }, rootDataAttrs, props.extraDataAttrs), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n        ref: props.innerElRef\n        /* different from hook system! RENAME */\n\n      }, props.showWeekNumber && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.WeekNumberRoot, {\n        date: date,\n        defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n      }, function (weekElRef, weekClassNames, innerElRef, innerContent) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          ref: weekElRef,\n          className: ['fc-daygrid-week-number'].concat(weekClassNames).join(' ')\n        }, navLinkAttrs), innerContent);\n      }), !isDisabled && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCellTop, {\n        date: date,\n        dateProfile: dateProfile,\n        showDayNumber: props.showDayNumber,\n        forceDayTop: props.forceDayTop,\n        todayRange: props.todayRange,\n        extraHookProps: props.extraHookProps\n      }), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-events\",\n        ref: props.fgContentElRef\n      }, props.fgContent, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-bottom\",\n        style: {\n          marginTop: props.moreMarginTop\n        }\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCellMoreLink, {\n        allDayDate: date,\n        singlePlacements: props.singlePlacements,\n        moreCnt: props.moreCnt,\n        alignmentElRef: rootElRef,\n        alignGridTop: !props.showDayNumber,\n        extraDateSpan: props.extraDateSpan,\n        dateProfile: props.dateProfile,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        todayRange: props.todayRange\n      }))), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-bg\"\n      }, props.bgContent)));\n    });\n  };\n\n  return TableCell;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\n\nfunction computeFgSegPlacement(segs, // assumed already sorted\ndayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {\n  var hierarchy = new DayGridSegHierarchy();\n  hierarchy.allowReslicing = true;\n  hierarchy.strictOrder = strictOrder;\n\n  if (dayMaxEvents === true || dayMaxEventRows === true) {\n    hierarchy.maxCoord = maxContentHeight;\n    hierarchy.hiddenConsumes = true;\n  } else if (typeof dayMaxEvents === 'number') {\n    hierarchy.maxStackCnt = dayMaxEvents;\n  } else if (typeof dayMaxEventRows === 'number') {\n    hierarchy.maxStackCnt = dayMaxEventRows;\n    hierarchy.hiddenConsumes = true;\n  } // create segInputs only for segs with known heights\n\n\n  var segInputs = [];\n  var unknownHeightSegs = [];\n\n  for (var i = 0; i < segs.length; i += 1) {\n    var seg = segs[i];\n    var instanceId = seg.eventRange.instance.instanceId;\n    var eventHeight = eventInstanceHeights[instanceId];\n\n    if (eventHeight != null) {\n      segInputs.push({\n        index: i,\n        thickness: eventHeight,\n        span: {\n          start: seg.firstCol,\n          end: seg.lastCol + 1\n        }\n      });\n    } else {\n      unknownHeightSegs.push(seg);\n    }\n  }\n\n  var hiddenEntries = hierarchy.addSegs(segInputs);\n  var segRects = hierarchy.toRects();\n\n  var _a = placeRects(segRects, segs, cells),\n      singleColPlacements = _a.singleColPlacements,\n      multiColPlacements = _a.multiColPlacements,\n      leftoverMargins = _a.leftoverMargins;\n\n  var moreCnts = [];\n  var moreMarginTops = []; // add segs with unknown heights\n\n  for (var _i = 0, unknownHeightSegs_1 = unknownHeightSegs; _i < unknownHeightSegs_1.length; _i++) {\n    var seg = unknownHeightSegs_1[_i];\n    multiColPlacements[seg.firstCol].push({\n      seg: seg,\n      isVisible: false,\n      isAbsolute: true,\n      absoluteTop: 0,\n      marginTop: 0\n    });\n\n    for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n      singleColPlacements[col].push({\n        seg: resliceSeg(seg, col, col + 1, cells),\n        isVisible: false,\n        isAbsolute: false,\n        absoluteTop: 0,\n        marginTop: 0\n      });\n    }\n  } // add the hidden entries\n\n\n  for (var col = 0; col < cells.length; col += 1) {\n    moreCnts.push(0);\n  }\n\n  for (var _b = 0, hiddenEntries_1 = hiddenEntries; _b < hiddenEntries_1.length; _b++) {\n    var hiddenEntry = hiddenEntries_1[_b];\n    var seg = segs[hiddenEntry.index];\n    var hiddenSpan = hiddenEntry.span;\n    multiColPlacements[hiddenSpan.start].push({\n      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n      isVisible: false,\n      isAbsolute: true,\n      absoluteTop: 0,\n      marginTop: 0\n    });\n\n    for (var col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {\n      moreCnts[col] += 1;\n      singleColPlacements[col].push({\n        seg: resliceSeg(seg, col, col + 1, cells),\n        isVisible: false,\n        isAbsolute: false,\n        absoluteTop: 0,\n        marginTop: 0\n      });\n    }\n  } // deal with leftover margins\n\n\n  for (var col = 0; col < cells.length; col += 1) {\n    moreMarginTops.push(leftoverMargins[col]);\n  }\n\n  return {\n    singleColPlacements: singleColPlacements,\n    multiColPlacements: multiColPlacements,\n    moreCnts: moreCnts,\n    moreMarginTops: moreMarginTops\n  };\n} // rects ordered by top coord, then left\n\n\nfunction placeRects(allRects, segs, cells) {\n  var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n  var singleColPlacements = [];\n  var multiColPlacements = [];\n  var leftoverMargins = [];\n\n  for (var col = 0; col < cells.length; col += 1) {\n    var rects = rectsByEachCol[col]; // compute all static segs in singlePlacements\n\n    var singlePlacements = [];\n    var currentHeight = 0;\n    var currentMarginTop = 0;\n\n    for (var _i = 0, rects_1 = rects; _i < rects_1.length; _i++) {\n      var rect = rects_1[_i];\n      var seg = segs[rect.index];\n      singlePlacements.push({\n        seg: resliceSeg(seg, col, col + 1, cells),\n        isVisible: true,\n        isAbsolute: false,\n        absoluteTop: rect.levelCoord,\n        marginTop: rect.levelCoord - currentHeight\n      });\n      currentHeight = rect.levelCoord + rect.thickness;\n    } // compute mixed static/absolute segs in multiPlacements\n\n\n    var multiPlacements = [];\n    currentHeight = 0;\n    currentMarginTop = 0;\n\n    for (var _a = 0, rects_2 = rects; _a < rects_2.length; _a++) {\n      var rect = rects_2[_a];\n      var seg = segs[rect.index];\n      var isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n\n      var isFirstCol = rect.span.start === col;\n      currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n\n      currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n\n      if (isAbsolute) {\n        currentMarginTop += rect.thickness;\n\n        if (isFirstCol) {\n          multiPlacements.push({\n            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n            isVisible: true,\n            isAbsolute: true,\n            absoluteTop: rect.levelCoord,\n            marginTop: 0\n          });\n        }\n      } else if (isFirstCol) {\n        multiPlacements.push({\n          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n          isVisible: true,\n          isAbsolute: false,\n          absoluteTop: rect.levelCoord,\n          marginTop: currentMarginTop // claim the margin\n\n        });\n        currentMarginTop = 0;\n      }\n    }\n\n    singleColPlacements.push(singlePlacements);\n    multiColPlacements.push(multiPlacements);\n    leftoverMargins.push(currentMarginTop);\n  }\n\n  return {\n    singleColPlacements: singleColPlacements,\n    multiColPlacements: multiColPlacements,\n    leftoverMargins: leftoverMargins\n  };\n}\n\nfunction groupRectsByEachCol(rects, colCnt) {\n  var rectsByEachCol = [];\n\n  for (var col = 0; col < colCnt; col += 1) {\n    rectsByEachCol.push([]);\n  }\n\n  for (var _i = 0, rects_3 = rects; _i < rects_3.length; _i++) {\n    var rect = rects_3[_i];\n\n    for (var col = rect.span.start; col < rect.span.end; col += 1) {\n      rectsByEachCol[col].push(rect);\n    }\n  }\n\n  return rectsByEachCol;\n}\n\nfunction resliceSeg(seg, spanStart, spanEnd, cells) {\n  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n    return seg;\n  }\n\n  var eventRange = seg.eventRange;\n  var origRange = eventRange.range;\n  var slicedRange = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectRanges)(origRange, {\n    start: cells[spanStart].date,\n    end: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDays)(cells[spanEnd - 1].date, 1)\n  });\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, seg), {\n    firstCol: spanStart,\n    lastCol: spanEnd - 1,\n    eventRange: {\n      def: eventRange.def,\n      ui: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventRange.ui), {\n        durationEditable: false\n      }),\n      instance: eventRange.instance,\n      range: slicedRange\n    },\n    isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n    isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n  });\n}\n\nvar DayGridSegHierarchy = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayGridSegHierarchy, _super);\n\n  function DayGridSegHierarchy() {\n    var _this = _super !== null && _super.apply(this, arguments) || this; // config\n\n\n    _this.hiddenConsumes = false; // allows us to keep hidden entries in the hierarchy so they take up space\n\n    _this.forceHidden = {};\n    return _this;\n  }\n\n  DayGridSegHierarchy.prototype.addSegs = function (segInputs) {\n    var _this = this;\n\n    var hiddenSegs = _super.prototype.addSegs.call(this, segInputs);\n\n    var entriesByLevel = this.entriesByLevel;\n\n    var excludeHidden = function (entry) {\n      return !_this.forceHidden[(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey)(entry)];\n    }; // remove the forced-hidden segs\n\n\n    for (var level = 0; level < entriesByLevel.length; level += 1) {\n      entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n    }\n\n    return hiddenSegs;\n  };\n\n  DayGridSegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {\n    var _a = this,\n        entriesByLevel = _a.entriesByLevel,\n        forceHidden = _a.forceHidden;\n\n    var touchingEntry = insertion.touchingEntry,\n        touchingLevel = insertion.touchingLevel,\n        touchingLateral = insertion.touchingLateral;\n\n    if (this.hiddenConsumes && touchingEntry) {\n      var touchingEntryId = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey)(touchingEntry); // if not already hidden\n\n      if (!forceHidden[touchingEntryId]) {\n        if (this.allowReslicing) {\n          var placeholderEntry = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, touchingEntry), {\n            span: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectSpans)(touchingEntry.span, entry.span)\n          });\n\n          var placeholderEntryId = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey)(placeholderEntry);\n          forceHidden[placeholderEntryId] = true;\n          entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder\n\n          this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it\n        } else {\n          forceHidden[touchingEntryId] = true;\n          hiddenEntries.push(touchingEntry);\n        }\n      }\n    }\n\n    return _super.prototype.handleInvalidInsertion.call(this, insertion, entry, hiddenEntries);\n  };\n\n  return DayGridSegHierarchy;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.SegHierarchy);\n\nvar TableRow = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableRow, _super);\n\n  function TableRow() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.cellElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap(); // the <td>\n\n    _this.frameElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap(); // the fc-daygrid-day-frame\n\n    _this.fgElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap(); // the fc-daygrid-day-events\n\n    _this.segHarnessRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap(); // indexed by \"instanceId:firstCol\"\n\n    _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    _this.state = {\n      framePositions: null,\n      maxContentHeight: null,\n      eventInstanceHeights: {}\n    };\n    return _this;\n  }\n\n  TableRow.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var options = context.options;\n    var colCnt = props.cells.length;\n    var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n    var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n    var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n    var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n\n    var _b = computeFgSegPlacement((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sortEventSegs)(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells),\n        singleColPlacements = _b.singleColPlacements,\n        multiColPlacements = _b.multiColPlacements,\n        moreCnts = _b.moreCnts,\n        moreMarginTops = _b.moreMarginTops;\n\n    var isForcedInvisible = // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n      ref: this.rootElRef\n    }, props.renderIntro && props.renderIntro(), props.cells.map(function (cell, col) {\n      var normalFgNodes = _this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n\n      var mirrorFgNodes = _this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCell, {\n        key: cell.key,\n        elRef: _this.cellElRefs.createRef(cell.key),\n        innerElRef: _this.frameElRefs.createRef(cell.key)\n        /* FF <td> problem, but okay to use for left/right. TODO: rename prop */\n        ,\n        dateProfile: props.dateProfile,\n        date: cell.date,\n        showDayNumber: props.showDayNumbers,\n        showWeekNumber: props.showWeekNumbers && col === 0,\n        forceDayTop: props.showWeekNumbers\n        /* even displaying weeknum for row, not necessarily day */\n        ,\n        todayRange: props.todayRange,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        extraHookProps: cell.extraHookProps,\n        extraDataAttrs: cell.extraDataAttrs,\n        extraClassNames: cell.extraClassNames,\n        extraDateSpan: cell.extraDateSpan,\n        moreCnt: moreCnts[col],\n        moreMarginTop: moreMarginTops[col],\n        singlePlacements: singleColPlacements[col],\n        fgContentElRef: _this.fgElRefs.createRef(cell.key),\n        fgContent: // Fragment scopes the keys\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, normalFgNodes), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, mirrorFgNodes)),\n        bgContent: // Fragment scopes the keys\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, _this.renderFillSegs(highlightSegsByCol[col], 'highlight'), _this.renderFillSegs(businessHoursByCol[col], 'non-business'), _this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))\n      });\n    }));\n  };\n\n  TableRow.prototype.componentDidMount = function () {\n    this.updateSizing(true);\n  };\n\n  TableRow.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var currentProps = this.props;\n    this.updateSizing(!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isPropsEqual)(prevProps, currentProps));\n  };\n\n  TableRow.prototype.getHighlightSegs = function () {\n    var props = this.props;\n\n    if (props.eventDrag && props.eventDrag.segs.length) {\n      // messy check\n      return props.eventDrag.segs;\n    }\n\n    if (props.eventResize && props.eventResize.segs.length) {\n      // messy check\n      return props.eventResize.segs;\n    }\n\n    return props.dateSelectionSegs;\n  };\n\n  TableRow.prototype.getMirrorSegs = function () {\n    var props = this.props;\n\n    if (props.eventResize && props.eventResize.segs.length) {\n      // messy check\n      return props.eventResize.segs;\n    }\n\n    return [];\n  };\n\n  TableRow.prototype.renderFgSegs = function (col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n    var context = this.context;\n    var eventSelection = this.props.eventSelection;\n    var framePositions = this.state.framePositions;\n    var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n\n    var isMirror = isDragging || isResizing || isDateSelecting;\n    var nodes = [];\n\n    if (framePositions) {\n      for (var _i = 0, segPlacements_1 = segPlacements; _i < segPlacements_1.length; _i++) {\n        var placement = segPlacements_1[_i];\n        var seg = placement.seg;\n        var instanceId = seg.eventRange.instance.instanceId;\n        var key = instanceId + ':' + col;\n        var isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n        var isAbsolute = placement.isAbsolute;\n        var left = '';\n        var right = '';\n\n        if (isAbsolute) {\n          if (context.isRtl) {\n            right = 0;\n            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n          } else {\n            left = 0;\n            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n          }\n        }\n        /*\n        known bug: events that are force to be list-item but span multiple days still take up space in later columns\n        todo: in print view, for multi-day events, don't display title within non-start/end segs\n        */\n\n\n        nodes.push((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n          className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''),\n          key: key,\n          ref: isMirror ? null : this.segHarnessRefs.createRef(key),\n          style: {\n            visibility: isVisible ? '' : 'hidden',\n            marginTop: isAbsolute ? '' : placement.marginTop,\n            top: isAbsolute ? placement.absoluteTop : '',\n            left: left,\n            right: right\n          }\n        }, hasListItemDisplay(seg) ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          seg: seg,\n          isDragging: isDragging,\n          isSelected: instanceId === eventSelection,\n          defaultDisplayEventEnd: defaultDisplayEventEnd\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          seg: seg,\n          isDragging: isDragging,\n          isResizing: isResizing,\n          isDateSelecting: isDateSelecting,\n          isSelected: instanceId === eventSelection,\n          defaultDisplayEventEnd: defaultDisplayEventEnd\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange)))));\n      }\n    }\n\n    return nodes;\n  };\n\n  TableRow.prototype.renderFillSegs = function (segs, fillType) {\n    var isRtl = this.context.isRtl;\n    var todayRange = this.props.todayRange;\n    var framePositions = this.state.framePositions;\n    var nodes = [];\n\n    if (framePositions) {\n      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n        var seg = segs_1[_i];\n        var leftRightCss = isRtl ? {\n          right: 0,\n          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n        } : {\n          left: 0,\n          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n        };\n        nodes.push((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n          key: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEventRangeKey)(seg.eventRange),\n          className: \"fc-daygrid-bg-harness\",\n          style: leftRightCss\n        }, fillType === 'bg-event' ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BgEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          seg: seg\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderFill)(fillType)));\n      }\n    }\n\n    return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, {}], nodes));\n  };\n\n  TableRow.prototype.updateSizing = function (isExternalSizingChange) {\n    var _a = this,\n        props = _a.props,\n        frameElRefs = _a.frameElRefs;\n\n    if (!props.forPrint && props.clientWidth !== null // positioning ready?\n    ) {\n      if (isExternalSizingChange) {\n        var frameEls = props.cells.map(function (cell) {\n          return frameElRefs.currentMap[cell.key];\n        });\n\n        if (frameEls.length) {\n          var originEl = this.rootElRef.current;\n          this.setState({\n            framePositions: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache(originEl, frameEls, true, // isHorizontal\n            false)\n          });\n        }\n      }\n\n      var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n      this.setState({\n        eventInstanceHeights: this.queryEventInstanceHeights(),\n        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n      });\n    }\n  };\n\n  TableRow.prototype.queryEventInstanceHeights = function () {\n    var segElMap = this.segHarnessRefs.currentMap;\n    var eventInstanceHeights = {}; // get the max height amongst instance segs\n\n    for (var key in segElMap) {\n      var height = Math.round(segElMap[key].getBoundingClientRect().height);\n      var instanceId = key.split(':')[0]; // deconstruct how renderFgSegs makes the key\n\n      eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);\n    }\n\n    return eventInstanceHeights;\n  };\n\n  TableRow.prototype.computeMaxContentHeight = function () {\n    var firstKey = this.props.cells[0].key;\n    var cellEl = this.cellElRefs.currentMap[firstKey];\n    var fcContainerEl = this.fgElRefs.currentMap[firstKey];\n    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n  };\n\n  TableRow.prototype.getCellEls = function () {\n    var elMap = this.cellElRefs.currentMap;\n    return this.props.cells.map(function (cell) {\n      return elMap[cell.key];\n    });\n  };\n\n  return TableRow;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\n\nTableRow.addStateEquality({\n  eventInstanceHeights: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isPropsEqual\n});\n\nfunction buildMirrorPlacements(mirrorSegs, colPlacements) {\n  if (!mirrorSegs.length) {\n    return [];\n  }\n\n  var topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n\n  return mirrorSegs.map(function (seg) {\n    return {\n      seg: seg,\n      isVisible: true,\n      isAbsolute: true,\n      absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n      marginTop: 0\n    };\n  });\n}\n\nfunction buildAbsoluteTopHash(colPlacements) {\n  var topsByInstanceId = {};\n\n  for (var _i = 0, colPlacements_1 = colPlacements; _i < colPlacements_1.length; _i++) {\n    var placements = colPlacements_1[_i];\n\n    for (var _a = 0, placements_1 = placements; _a < placements_1.length; _a++) {\n      var placement = placements_1[_a];\n      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n    }\n  }\n\n  return topsByInstanceId;\n}\n\nvar Table = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Table, _super);\n\n  function Table() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.splitBusinessHourSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByRow);\n    _this.splitBgEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByRow);\n    _this.splitFgEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByRow);\n    _this.splitDateSelectionSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByRow);\n    _this.splitEventDrag = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitInteractionByRow);\n    _this.splitEventResize = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitInteractionByRow);\n    _this.rowRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap();\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl,\n          isHitComboAllowed: _this.props.isHitComboAllowed\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  Table.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var dateProfile = props.dateProfile,\n        dayMaxEventRows = props.dayMaxEventRows,\n        dayMaxEvents = props.dayMaxEvents,\n        expandRows = props.expandRows;\n    var rowCnt = props.cells.length;\n    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n    var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n    var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n    var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true; // if rows can't expand to fill fixed height, can't do balanced-height event limit\n    // TODO: best place to normalize these options?\n\n    if (limitViaBalanced && !expandRows) {\n      limitViaBalanced = false;\n      dayMaxEventRows = null;\n      dayMaxEvents = null;\n    }\n\n    var classNames = ['fc-daygrid-body', limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced', expandRows ? '' : 'fc-daygrid-body-natural' // will height of one row depend on the others?\n    ];\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      className: classNames.join(' '),\n      ref: this.handleRootEl,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowTimer, {\n      unit: \"day\"\n    }, function (nowDate, todayRange) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n        className: \"fc-scrollgrid-sync-table\",\n        style: {\n          width: props.clientWidth,\n          minWidth: props.tableMinWidth,\n          height: expandRows ? props.clientHeight : ''\n        }\n      }, props.colGroupNode, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", null, props.cells.map(function (cells, row) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableRow, {\n          ref: _this.rowRefs.createRef(row),\n          key: cells.length ? cells[0].date.toISOString()\n          /* best? or put key on cell? or use diff formatter? */\n          : row // in case there are no cells (like when resource view is loading)\n          ,\n          showDayNumbers: rowCnt > 1,\n          showWeekNumbers: props.showWeekNumbers,\n          todayRange: todayRange,\n          dateProfile: dateProfile,\n          cells: cells,\n          renderIntro: props.renderRowIntro,\n          businessHourSegs: businessHourSegsByRow[row],\n          eventSelection: props.eventSelection,\n          bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay)\n          /* hack */\n          ,\n          fgEventSegs: fgEventSegsByRow[row],\n          dateSelectionSegs: dateSelectionSegsByRow[row],\n          eventDrag: eventDragByRow[row],\n          eventResize: eventResizeByRow[row],\n          dayMaxEvents: dayMaxEvents,\n          dayMaxEventRows: dayMaxEventRows,\n          clientWidth: props.clientWidth,\n          clientHeight: props.clientHeight,\n          forPrint: props.forPrint\n        });\n      }))));\n    }));\n  }; // Hit System\n  // ----------------------------------------------------------------------------------------------------\n\n\n  Table.prototype.prepareHits = function () {\n    this.rowPositions = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache(this.rootEl, this.rowRefs.collect().map(function (rowObj) {\n      return rowObj.getCellEls()[0];\n    }), // first cell el in each row. TODO: not optimal\n    false, true);\n    this.colPositions = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row\n    true, // horizontal\n    false);\n  };\n\n  Table.prototype.queryHit = function (positionLeft, positionTop) {\n    var _a = this,\n        colPositions = _a.colPositions,\n        rowPositions = _a.rowPositions;\n\n    var col = colPositions.leftToIndex(positionLeft);\n    var row = rowPositions.topToIndex(positionTop);\n\n    if (row != null && col != null) {\n      var cell = this.props.cells[row][col];\n      return {\n        dateProfile: this.props.dateProfile,\n        dateSpan: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          range: this.getCellRange(row, col),\n          allDay: true\n        }, cell.extraDateSpan),\n        dayEl: this.getCellEl(row, col),\n        rect: {\n          left: colPositions.lefts[col],\n          right: colPositions.rights[col],\n          top: rowPositions.tops[row],\n          bottom: rowPositions.bottoms[row]\n        },\n        layer: 0\n      };\n    }\n\n    return null;\n  };\n\n  Table.prototype.getCellEl = function (row, col) {\n    return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n  };\n\n  Table.prototype.getCellRange = function (row, col) {\n    var start = this.props.cells[row][col].date;\n    var end = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDays)(start, 1);\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return Table;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\n\nfunction isSegAllDay(seg) {\n  return seg.eventRange.def.allDay;\n}\n\nvar DayTableSlicer = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayTableSlicer, _super);\n\n  function DayTableSlicer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.forceDayIfListItem = true;\n    return _this;\n  }\n\n  DayTableSlicer.prototype.sliceRange = function (dateRange, dayTableModel) {\n    return dayTableModel.sliceRange(dateRange);\n  };\n\n  return DayTableSlicer;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Slicer);\n\nvar DayTable = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayTable, _super);\n\n  function DayTable() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.slicer = new DayTableSlicer();\n    _this.tableRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    return _this;\n  }\n\n  DayTable.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(Table, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      ref: this.tableRef\n    }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n      dateProfile: props.dateProfile,\n      cells: props.dayTableModel.cells,\n      colGroupNode: props.colGroupNode,\n      tableMinWidth: props.tableMinWidth,\n      renderRowIntro: props.renderRowIntro,\n      dayMaxEvents: props.dayMaxEvents,\n      dayMaxEventRows: props.dayMaxEventRows,\n      showWeekNumbers: props.showWeekNumbers,\n      expandRows: props.expandRows,\n      headerAlignElRef: props.headerAlignElRef,\n      clientWidth: props.clientWidth,\n      clientHeight: props.clientHeight,\n      forPrint: props.forPrint\n    }));\n  };\n\n  return DayTable;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\n\nvar DayTableView = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayTableView, _super);\n\n  function DayTableView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildDayTableModel = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(buildDayTableModel);\n    _this.headerRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    _this.tableRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    return _this;\n  }\n\n  DayTableView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.context,\n        options = _a.options,\n        dateProfileGenerator = _a.dateProfileGenerator;\n    var props = this.props;\n    var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n    var headerContent = options.dayHeaders && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayHeader, {\n      ref: this.headerRef,\n      dateProfile: props.dateProfile,\n      dates: dayTableModel.headerDates,\n      datesRepDistinctDays: dayTableModel.rowCnt === 1\n    });\n\n    var bodyContent = function (contentArg) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayTable, {\n        ref: _this.tableRef,\n        dateProfile: props.dateProfile,\n        dayTableModel: dayTableModel,\n        businessHours: props.businessHours,\n        dateSelection: props.dateSelection,\n        eventStore: props.eventStore,\n        eventUiBases: props.eventUiBases,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        nextDayThreshold: options.nextDayThreshold,\n        colGroupNode: contentArg.tableColGroupNode,\n        tableMinWidth: contentArg.tableMinWidth,\n        dayMaxEvents: options.dayMaxEvents,\n        dayMaxEventRows: options.dayMaxEventRows,\n        showWeekNumbers: options.weekNumbers,\n        expandRows: !props.isHeightAuto,\n        headerAlignElRef: _this.headerElRef,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        forPrint: props.forPrint\n      });\n    };\n\n    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n  };\n\n  return DayTableView;\n}(TableView);\n\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\n\nvar TableDateProfileGenerator = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableDateProfileGenerator, _super);\n\n  function TableDateProfileGenerator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // Computes the date range that will be rendered.\n\n\n  TableDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    var dateEnv = this.props.dateEnv;\n\n    var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n\n    var start = renderRange.start;\n    var end = renderRange.end;\n    var endOfWeek; // year and month views should be aligned with weeks. this is already done for week\n\n    if (/^(year|month)$/.test(currentRangeUnit)) {\n      start = dateEnv.startOfWeek(start); // make end-of-week if not already\n\n      endOfWeek = dateEnv.startOfWeek(end);\n\n      if (endOfWeek.valueOf() !== end.valueOf()) {\n        end = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addWeeks)(endOfWeek, 1);\n      }\n    } // ensure 6 weeks\n\n\n    if (this.props.monthMode && this.props.fixedWeekCount) {\n      var rowCnt = Math.ceil( // could be partial weeks due to hiddenDays\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffWeeks)(start, end));\n      end = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addWeeks)(end, 6 - rowCnt);\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return TableDateProfileGenerator;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateProfileGenerator);\n\nvar main = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createPlugin)({\n  initialView: 'dayGridMonth',\n  views: {\n    dayGrid: {\n      component: DayTableView,\n      dateProfileGeneratorClass: TableDateProfileGenerator\n    },\n    dayGridDay: {\n      type: 'dayGrid',\n      duration: {\n        days: 1\n      }\n    },\n    dayGridWeek: {\n      type: 'dayGrid',\n      duration: {\n        weeks: 1\n      }\n    },\n    dayGridMonth: {\n      type: 'dayGrid',\n      duration: {\n        months: 1\n      },\n      monthMode: true,\n      fixedWeekCount: true\n    }\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (main);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOztBQUVBO0FBQ0E7OztBQUVBOztBQUFBO0FBQUE7O0FBQ0E7O0FBa0hBOztBQWhIQTtBQUlBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSkE7QUFVQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUpBO0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUhBO0FBSUE7QUFKQTtBQU9BO0FBR0E7O0FBRUE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBSkE7QUFXQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSkE7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSkE7QUFTQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUpBO0FBT0E7QUFHQTs7QUFDQTtBQW5IQTs7QUNiQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQ3RDQTtBQUFBOztBQUFBOztBQTZCQTs7QUE1QkE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUtBO0FBR0E7O0FBQ0E7QUE3QkE7O0FBK0JBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU9BO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFMQTtBQU9BOztBQ2JBO0FBQUE7O0FBQUE7O0FBY0E7O0FBYkE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BOztBQUNBO0FBZEE7O0FDTUE7QUFBQTs7QUFBQTs7QUFxQ0E7O0FBcENBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFRQTtBQUdBOztBQUNBO0FBckNBOztBQXVDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUtBO0FBQUE7QUFFQTtBQUFBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQ3RDQTtBQUFBOztBQUFBO0FBQUE7O0FBQ0E7O0FBd0VBOztBQXRFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFZQTtBQUdBO0FBbkRBO0FBcURBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFPQTtBQUdBOztBQUNBO0FBekVBOztBQTJFQTtBQUlBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FDaEZBO0FBQUE7QUFBQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7O0FBQ0E7O0FBaUZBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7QUFuRkE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBQ0E7QUFGQTtBQU1BO0FBQUE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBT0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVVBO0FBQ0E7QUFGQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFlQTtBQUFBO0FBS0E7QUFHQTs7QUFNQTtBQXRGQTs7QUN6QkE7QUFFQTtBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUhBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBRUE7O0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFMQTtBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBVkE7QUFZQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7OztBQUVBOztBQUdBOztBQXlDQTs7QUF2Q0E7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBREE7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUE5Q0E7O0FDM0xBO0FBQUE7O0FBQUE7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBK1NBOztBQXpTQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVVBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFHQTs7QUFPQTs7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBSEE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFSQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBNUJBO0FBb0NBO0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFKQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQUE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFMQTtBQVFBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQXRUQTs7QUF3VEE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFNQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQzlWQTs7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQTZGQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0FBMkRBOztBQS9KQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFNQTtBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUpBO0FBSEE7QUFVQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFGQTtBQVVBO0FBRUE7QUFDQTtBQUVBO0FBREE7QUFIQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBZkE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeEJBO0FBMEJBO0FBSUE7QUFJQTs7OztBQWtCQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQWRBO0FBZ0JBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUEzS0E7O0FBNktBO0FBQ0E7QUFDQTs7O0FDMU5BOztBQUFBO0FBQUE7O0FBQ0E7O0FBS0E7O0FBSEE7QUFDQTtBQUNBOztBQUNBO0FBTkE7OztBQ3NDQTs7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBeUJBOztBQXZCQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUVBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBZ0JBOztBQUNBO0FBM0JBOzs7QUM1QkE7O0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBOENBOztBQTVDQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBUUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXVCQTs7QUFFQTtBQUdBOztBQUNBO0FBakRBOztBQW1EQTtBQUNBO0FBRUE7QUFJQTs7QUNqRUE7QUFBQTs7QUFBQTs7QUFpQ0E7OztBQS9CQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBOztBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUlBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFqQ0E7O0FDT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUpBO0FBakJBO0FBRkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvVGFibGVWaWV3LnRzeD9jNjQwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9UYWJsZVNlZy50cz9lM2M5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9UYWJsZUNlbGxUb3AudHN4P2MxZTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2V2ZW50LXJlbmRlcmluZy50cz9iY2JhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9UYWJsZUJsb2NrRXZlbnQudHN4PzMyMGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1RhYmxlTGlzdEl0ZW1FdmVudC50c3g/MGUyZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvVGFibGVDZWxsTW9yZUxpbmsudHN4PzEzNWYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1RhYmxlQ2VsbC50c3g/MTQzYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZXZlbnQtcGxhY2VtZW50LnRzPzY5NTciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1RhYmxlUm93LnRzeD85NDZjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9UYWJsZS50c3g/NTQxNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvRGF5VGFibGVTbGljZXIudHN4PzQ3ZTEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL0RheVRhYmxlLnRzeD8yODQ2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9EYXlUYWJsZVZpZXcudHN4Pzc2NjkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1RhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IudHM/Y2RkYiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvbWFpbi50cz9iOTljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFZOb2RlLCBjcmVhdGVFbGVtZW50LFxuICBTaW1wbGVTY3JvbGxHcmlkLFxuICBTaW1wbGVTY3JvbGxHcmlkU2VjdGlvbixcbiAgQ2h1bmtDb250ZW50Q2FsbGJhY2tBcmdzLFxuICBjcmVhdGVSZWYsXG4gIFNjcm9sbEdyaWRTZWN0aW9uQ29uZmlnLFxuICBWaWV3Um9vdCxcbiAgRGF0ZUNvbXBvbmVudCxcbiAgVmlld1Byb3BzLFxuICBSZWZPYmplY3QsXG4gIHJlbmRlclNjcm9sbFNoaW0sXG4gIGdldFN0aWNreUhlYWRlckRhdGVzLFxuICBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsXG4gIENodW5rQ29uZmlnUm93Q29udGVudCxcbiAgRGljdGlvbmFyeSxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5cbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciB0aGUgZGF5Z3JpZCB2aWV3cywgYXMgd2VsbCBhcyBtb250aCB2aWV3LiBSZW5kZXJzIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNlbGxzLlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBJdCBpcyBhIG1hbmFnZXIgZm9yIGEgVGFibGUgc3ViY29tcG9uZW50LCB3aGljaCBkb2VzIG1vc3Qgb2YgdGhlIGhlYXZ5IGxpZnRpbmcuXG4vLyBJdCBpcyByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgd2lkdGgvaGVpZ2h0LlxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGFibGVWaWV3PFN0YXRlPURpY3Rpb25hcnk+IGV4dGVuZHMgRGF0ZUNvbXBvbmVudDxWaWV3UHJvcHMsIFN0YXRlPiB7XG4gIHByb3RlY3RlZCBoZWFkZXJFbFJlZjogUmVmT2JqZWN0PEhUTUxUYWJsZUNlbGxFbGVtZW50PiA9IGNyZWF0ZVJlZjxIVE1MVGFibGVDZWxsRWxlbWVudD4oKVxuXG4gIHJlbmRlclNpbXBsZUxheW91dChcbiAgICBoZWFkZXJSb3dDb250ZW50OiBDaHVua0NvbmZpZ1Jvd0NvbnRlbnQsXG4gICAgYm9keUNvbnRlbnQ6IChjb250ZW50QXJnOiBDaHVua0NvbnRlbnRDYWxsYmFja0FyZ3MpID0+IFZOb2RlLFxuICApIHtcbiAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCBzZWN0aW9uczogU2ltcGxlU2Nyb2xsR3JpZFNlY3Rpb25bXSA9IFtdXG4gICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKVxuXG4gICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICBjaHVuazoge1xuICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICB0eXBlOiAnYm9keScsXG4gICAgICBrZXk6ICdib2R5JyxcbiAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgIGNodW5rOiB7IGNvbnRlbnQ6IGJvZHlDb250ZW50IH0sXG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICA8Vmlld1Jvb3Qgdmlld1NwZWM9e2NvbnRleHQudmlld1NwZWN9PlxuICAgICAgICB7KHJvb3RFbFJlZiwgY2xhc3NOYW1lcykgPT4gKFxuICAgICAgICAgIDxkaXYgcmVmPXtyb290RWxSZWZ9IGNsYXNzTmFtZT17WydmYy1kYXlncmlkJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKX0+XG4gICAgICAgICAgICA8U2ltcGxlU2Nyb2xsR3JpZFxuICAgICAgICAgICAgICBsaXF1aWQ9eyFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50fVxuICAgICAgICAgICAgICBjb2xsYXBzaWJsZVdpZHRoPXtwcm9wcy5mb3JQcmludH1cbiAgICAgICAgICAgICAgY29scz17W10gLyogVE9ETzogbWFrZSBvcHRpb25hbD8gKi99XG4gICAgICAgICAgICAgIHNlY3Rpb25zPXtzZWN0aW9uc31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L1ZpZXdSb290PlxuICAgIClcbiAgfVxuXG4gIHJlbmRlckhTY3JvbGxMYXlvdXQoXG4gICAgaGVhZGVyUm93Q29udGVudDogQ2h1bmtDb25maWdSb3dDb250ZW50LFxuICAgIGJvZHlDb250ZW50OiAoY29udGVudEFyZzogQ2h1bmtDb250ZW50Q2FsbGJhY2tBcmdzKSA9PiBWTm9kZSxcbiAgICBjb2xDbnQ6IG51bWJlcixcbiAgICBkYXlNaW5XaWR0aDogbnVtYmVyLFxuICApIHtcbiAgICBsZXQgU2Nyb2xsR3JpZCA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rcy5zY3JvbGxHcmlkSW1wbFxuXG4gICAgaWYgKCFTY3JvbGxHcmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNjcm9sbEdyaWQgaW1wbGVtZW50YXRpb24nKVxuICAgIH1cblxuICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucylcbiAgICBsZXQgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihjb250ZXh0Lm9wdGlvbnMpXG4gICAgbGV0IHNlY3Rpb25zOiBTY3JvbGxHcmlkU2VjdGlvbkNvbmZpZ1tdID0gW11cblxuICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgfV0sXG4gICAgICB9KVxuICAgIH1cblxuICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAga2V5OiAnYm9keScsXG4gICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICBjaHVua3M6IFt7XG4gICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICBjb250ZW50OiBib2R5Q29udGVudCxcbiAgICAgIH1dLFxuICAgIH0pXG5cbiAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKSB7XG4gICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Zvb3RlcicsXG4gICAgICAgIGtleTogJ2Zvb3RlcicsXG4gICAgICAgIGlzU3RpY2t5OiB0cnVlLFxuICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgY29udGVudDogcmVuZGVyU2Nyb2xsU2hpbSxcbiAgICAgICAgfV0sXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Vmlld1Jvb3Qgdmlld1NwZWM9e2NvbnRleHQudmlld1NwZWN9PlxuICAgICAgICB7KHJvb3RFbFJlZiwgY2xhc3NOYW1lcykgPT4gKFxuICAgICAgICAgIDxkaXYgcmVmPXtyb290RWxSZWZ9IGNsYXNzTmFtZT17WydmYy1kYXlncmlkJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKX0+XG4gICAgICAgICAgICA8U2Nyb2xsR3JpZFxuICAgICAgICAgICAgICBsaXF1aWQ9eyFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50fVxuICAgICAgICAgICAgICBjb2xsYXBzaWJsZVdpZHRoPXtwcm9wcy5mb3JQcmludH1cbiAgICAgICAgICAgICAgY29sR3JvdXBzPXtbeyBjb2xzOiBbeyBzcGFuOiBjb2xDbnQsIG1pbldpZHRoOiBkYXlNaW5XaWR0aCB9XSB9XX1cbiAgICAgICAgICAgICAgc2VjdGlvbnM9e3NlY3Rpb25zfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvVmlld1Jvb3Q+XG4gICAgKVxuICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSwgU2VnIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5cbi8vIHRoaXMgaXMgYSBEQVRBIFNUUlVDVFVSRSwgbm90IGEgY29tcG9uZW50XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVTZWcgZXh0ZW5kcyBTZWcge1xuICByb3c6IG51bWJlclxuICBmaXJzdENvbDogbnVtYmVyXG4gIGxhc3RDb2w6IG51bWJlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRTZWdzQnlSb3coc2VnczogVGFibGVTZWdbXSwgcm93Q250OiBudW1iZXIpIHtcbiAgbGV0IGJ5Um93OiBUYWJsZVNlZ1tdW10gPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICBieVJvd1tpXSA9IFtdXG4gIH1cblxuICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgIGJ5Um93W3NlZy5yb3ddLnB1c2goc2VnKVxuICB9XG5cbiAgcmV0dXJuIGJ5Um93XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFNlZ3NCeUZpcnN0Q29sKHNlZ3M6IFRhYmxlU2VnW10sIGNvbENudDogbnVtYmVyKSB7XG4gIGxldCBieUNvbDogVGFibGVTZWdbXVtdID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgYnlDb2xbaV0gPSBbXVxuICB9XG5cbiAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICBieUNvbFtzZWcuZmlyc3RDb2xdLnB1c2goc2VnKVxuICB9XG5cbiAgcmV0dXJuIGJ5Q29sXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdEludGVyYWN0aW9uQnlSb3codWk6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHwgbnVsbCwgcm93Q250OiBudW1iZXIpIHtcbiAgbGV0IGJ5Um93OiBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZVtdID0gW11cblxuICBpZiAoIXVpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgYnlSb3dbaV0gPSBudWxsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgIGJ5Um93W2ldID0ge1xuICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogdWkuYWZmZWN0ZWRJbnN0YW5jZXMsXG4gICAgICAgIGlzRXZlbnQ6IHVpLmlzRXZlbnQsXG4gICAgICAgIHNlZ3M6IFtdLFxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IHNlZyBvZiB1aS5zZWdzKSB7XG4gICAgICBieVJvd1tzZWcucm93XS5zZWdzLnB1c2goc2VnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieVJvd1xufVxuIiwiaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCxcbiAgRGF0ZU1hcmtlcixcbiAgRGF0ZVJhbmdlLFxuICBidWlsZE5hdkxpbmtEYXRhLFxuICBEYXlDZWxsQ29udGVudEFyZyxcbiAgRGF5Q2VsbENvbnRlbnQsXG4gIEJhc2VDb21wb25lbnQsXG4gIERhdGVQcm9maWxlLFxuICBEaWN0aW9uYXJ5LFxuICBGcmFnbWVudCxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5cbmludGVyZmFjZSBUYWJsZUNlbGxUb3BQcm9wcyB7XG4gIGRhdGU6IERhdGVNYXJrZXJcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlXG4gIHNob3dEYXlOdW1iZXI6IGJvb2xlYW5cbiAgZm9yY2VEYXlUb3A6IGJvb2xlYW4gLy8gaGFjayB0byBmb3JjZS1jcmVhdGUgYW4gZWxlbWVudCB3aXRoIGhlaWdodCAoY3JlYXRlZCBieSBhIG5ic3ApXG4gIHRvZGF5UmFuZ2U6IERhdGVSYW5nZVxuICBleHRyYUhvb2tQcm9wcz86IERpY3Rpb25hcnlcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlQ2VsbFRvcCBleHRlbmRzIEJhc2VDb21wb25lbnQ8VGFibGVDZWxsVG9wUHJvcHM+IHtcbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG5cbiAgICBsZXQgbmF2TGlua0F0dHJzID0gdGhpcy5jb250ZXh0Lm9wdGlvbnMubmF2TGlua3NcbiAgICAgID8geyAnZGF0YS1uYXZsaW5rJzogYnVpbGROYXZMaW5rRGF0YShwcm9wcy5kYXRlKSwgdGFiSW5kZXg6IDAgfVxuICAgICAgOiB7fVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxEYXlDZWxsQ29udGVudFxuICAgICAgICBkYXRlPXtwcm9wcy5kYXRlfVxuICAgICAgICBkYXRlUHJvZmlsZT17cHJvcHMuZGF0ZVByb2ZpbGV9XG4gICAgICAgIHRvZGF5UmFuZ2U9e3Byb3BzLnRvZGF5UmFuZ2V9XG4gICAgICAgIHNob3dEYXlOdW1iZXI9e3Byb3BzLnNob3dEYXlOdW1iZXJ9XG4gICAgICAgIGV4dHJhSG9va1Byb3BzPXtwcm9wcy5leHRyYUhvb2tQcm9wc31cbiAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3JlbmRlclRvcElubmVyfVxuICAgICAgPlxuICAgICAgICB7KGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgPT4gKFxuICAgICAgICAgIChpbm5lckNvbnRlbnQgfHwgcHJvcHMuZm9yY2VEYXlUb3ApICYmIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtZGF5Z3JpZC1kYXktdG9wXCIgcmVmPXtpbm5lckVsUmVmfT5cbiAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwiZmMtZGF5Z3JpZC1kYXktbnVtYmVyXCIgey4uLm5hdkxpbmtBdHRyc30+XG4gICAgICAgICAgICAgICAge2lubmVyQ29udGVudCB8fCA8RnJhZ21lbnQ+Jm5ic3A7PC9GcmFnbWVudD59XG4gICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIClcbiAgICAgICAgKX1cbiAgICAgIDwvRGF5Q2VsbENvbnRlbnQ+XG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclRvcElubmVyKHByb3BzOiBEYXlDZWxsQ29udGVudEFyZykge1xuICByZXR1cm4gcHJvcHMuZGF5TnVtYmVyVGV4dFxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRm9ybWF0dGVyIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBUYWJsZVNlZyB9IGZyb20gJy4vVGFibGVTZWcnXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHtcbiAgaG91cjogJ251bWVyaWMnLFxuICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgb21pdFplcm9NaW51dGU6IHRydWUsXG4gIG1lcmlkaWVtOiAnbmFycm93Jyxcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNMaXN0SXRlbURpc3BsYXkoc2VnOiBUYWJsZVNlZykge1xuICBsZXQgeyBkaXNwbGF5IH0gPSBzZWcuZXZlbnRSYW5nZS51aVxuXG4gIHJldHVybiBkaXNwbGF5ID09PSAnbGlzdC1pdGVtJyB8fCAoXG4gICAgZGlzcGxheSA9PT0gJ2F1dG8nICYmXG4gICAgIXNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXkgJiZcbiAgICBzZWcuZmlyc3RDb2wgPT09IHNlZy5sYXN0Q29sICYmIC8vIGNhbid0IGJlIG11bHRpLWRheVxuICAgIHNlZy5pc1N0YXJ0ICYmIC8vIFwiXG4gICAgc2VnLmlzRW5kIC8vIFwiXG4gIClcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIFN0YW5kYXJkRXZlbnQsIEJhc2VDb21wb25lbnQsIE1pbmltYWxFdmVudFByb3BzIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUIH0gZnJvbSAnLi9ldmVudC1yZW5kZXJpbmcnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVCbG9ja0V2ZW50UHJvcHMgZXh0ZW5kcyBNaW5pbWFsRXZlbnRQcm9wcyB7XG4gIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlQmxvY2tFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQ8VGFibGVCbG9ja0V2ZW50UHJvcHM+IHtcbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFN0YW5kYXJkRXZlbnRcbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgICBleHRyYUNsYXNzTmFtZXM9e1snZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWJsb2NrLWV2ZW50JywgJ2ZjLWgtZXZlbnQnXX1cbiAgICAgICAgZGVmYXVsdFRpbWVGb3JtYXQ9e0RFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVR9XG4gICAgICAgIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ9e3Byb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmR9XG4gICAgICAgIGRpc2FibGVSZXNpemluZz17IXByb3BzLnNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXl9XG4gICAgICAvPlxuICAgIClcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgQmFzZUNvbXBvbmVudCwgU2VnLCBFdmVudFJvb3QsIGJ1aWxkU2VnVGltZVRleHQsIEV2ZW50Q29udGVudEFyZywgRnJhZ21lbnQgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQgfSBmcm9tICcuL2V2ZW50LXJlbmRlcmluZydcblxuZXhwb3J0IGludGVyZmFjZSBEb3RUYWJsZUV2ZW50UHJvcHMge1xuICBzZWc6IFNlZ1xuICBpc0RyYWdnaW5nOiBib29sZWFuXG4gIGlzU2VsZWN0ZWQ6IGJvb2xlYW5cbiAgaXNQYXN0OiBib29sZWFuXG4gIGlzRnV0dXJlOiBib29sZWFuXG4gIGlzVG9kYXk6IGJvb2xlYW5cbiAgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgVGFibGVMaXN0SXRlbUV2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxEb3RUYWJsZUV2ZW50UHJvcHM+IHtcbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHRpbWVGb3JtYXQgPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVRcbiAgICBsZXQgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KFxuICAgICAgcHJvcHMuc2VnLFxuICAgICAgdGltZUZvcm1hdCxcbiAgICAgIGNvbnRleHQsXG4gICAgICB0cnVlLFxuICAgICAgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCxcbiAgICApXG5cbiAgICByZXR1cm4gKFxuICAgICAgPEV2ZW50Um9vdFxuICAgICAgICBzZWc9e3Byb3BzLnNlZ31cbiAgICAgICAgdGltZVRleHQ9e3RpbWVUZXh0fVxuICAgICAgICBkZWZhdWx0Q29udGVudD17cmVuZGVySW5uZXJDb250ZW50fVxuICAgICAgICBpc0RyYWdnaW5nPXtwcm9wcy5pc0RyYWdnaW5nfVxuICAgICAgICBpc1Jlc2l6aW5nPXtmYWxzZX1cbiAgICAgICAgaXNEYXRlU2VsZWN0aW5nPXtmYWxzZX1cbiAgICAgICAgaXNTZWxlY3RlZD17cHJvcHMuaXNTZWxlY3RlZH1cbiAgICAgICAgaXNQYXN0PXtwcm9wcy5pc1Bhc3R9XG4gICAgICAgIGlzRnV0dXJlPXtwcm9wcy5pc0Z1dHVyZX1cbiAgICAgICAgaXNUb2RheT17cHJvcHMuaXNUb2RheX1cbiAgICAgID5cbiAgICAgICAgeyhyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgPT4gKCAvLyB3ZSBkb24ndCB1c2Ugc3R5bGVzIVxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBjbGFzc05hbWU9e1snZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWRvdC1ldmVudCddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyl9XG4gICAgICAgICAgICByZWY9e3Jvb3RFbFJlZn1cbiAgICAgICAgICAgIHsuLi5nZXRTZWdBbmNob3JBdHRycyhwcm9wcy5zZWcpfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtpbm5lckNvbnRlbnR9XG4gICAgICAgICAgPC9hPlxuICAgICAgICApfVxuICAgICAgPC9FdmVudFJvb3Q+XG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChpbm5lclByb3BzOiBFdmVudENvbnRlbnRBcmcpIHtcbiAgcmV0dXJuIChcbiAgICA8RnJhZ21lbnQ+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cImZjLWRheWdyaWQtZXZlbnQtZG90XCJcbiAgICAgICAgc3R5bGU9e3sgYm9yZGVyQ29sb3I6IGlubmVyUHJvcHMuYm9yZGVyQ29sb3IgfHwgaW5uZXJQcm9wcy5iYWNrZ3JvdW5kQ29sb3IgfX1cbiAgICAgIC8+XG4gICAgICB7aW5uZXJQcm9wcy50aW1lVGV4dCAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtZXZlbnQtdGltZVwiPntpbm5lclByb3BzLnRpbWVUZXh0fTwvZGl2PlxuICAgICAgKX1cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtZXZlbnQtdGl0bGVcIj5cbiAgICAgICAge2lubmVyUHJvcHMuZXZlbnQudGl0bGUgfHwgPEZyYWdtZW50PiZuYnNwOzwvRnJhZ21lbnQ+fVxuICAgICAgPC9kaXY+XG4gICAgPC9GcmFnbWVudD5cbiAgKVxufVxuXG5mdW5jdGlvbiBnZXRTZWdBbmNob3JBdHRycyhzZWc6IFNlZykgeyAvLyBub3QgZHJ5LiBpbiBTdGFuZGFyZEV2ZW50IHRvb1xuICBsZXQgeyB1cmwgfSA9IHNlZy5ldmVudFJhbmdlLmRlZlxuICByZXR1cm4gdXJsID8geyBocmVmOiB1cmwgfSA6IHt9XG59XG4iLCJpbXBvcnQge1xuICBjcmVhdGVFbGVtZW50LFxuICBNb3JlTGlua1Jvb3QsXG4gIFJlZk9iamVjdCxcbiAgQmFzZUNvbXBvbmVudCxcbiAgbWVtb2l6ZSxcbiAgRGF0ZU1hcmtlcixcbiAgRGljdGlvbmFyeSxcbiAgRGF0ZVByb2ZpbGUsXG4gIERhdGVSYW5nZSxcbiAgRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUsXG4gIGdldFNlZ01ldGEsXG4gIEZyYWdtZW50LFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFRhYmxlU2VnUGxhY2VtZW50IH0gZnJvbSAnLi9ldmVudC1wbGFjZW1lbnQnXG5pbXBvcnQgeyBoYXNMaXN0SXRlbURpc3BsYXkgfSBmcm9tICcuL2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IFRhYmxlQmxvY2tFdmVudCB9IGZyb20gJy4vVGFibGVCbG9ja0V2ZW50J1xuaW1wb3J0IHsgVGFibGVMaXN0SXRlbUV2ZW50IH0gZnJvbSAnLi9UYWJsZUxpc3RJdGVtRXZlbnQnXG5pbXBvcnQgeyBUYWJsZVNlZyB9IGZyb20gJy4vVGFibGVTZWcnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVDZWxsTW9yZUxpbmtQcm9wcyB7XG4gIGFsbERheURhdGU6IERhdGVNYXJrZXJcbiAgc2luZ2xlUGxhY2VtZW50czogVGFibGVTZWdQbGFjZW1lbnRbXVxuICBtb3JlQ250OiBudW1iZXJcbiAgYWxpZ25tZW50RWxSZWY6IFJlZk9iamVjdDxIVE1MRWxlbWVudD4gLy8gZm9yIHBvcG92ZXJcbiAgYWxpZ25HcmlkVG9wOiBib29sZWFuIC8vIGZvciBwb3BvdmVyXG4gIGV4dHJhRGF0ZVNwYW4/OiBEaWN0aW9uYXJ5XG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZVxuICB0b2RheVJhbmdlOiBEYXRlUmFuZ2VcbiAgZXZlbnRTZWxlY3Rpb246IHN0cmluZ1xuICBldmVudERyYWc6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBldmVudFJlc2l6ZTogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUgfCBudWxsXG59XG5cbmV4cG9ydCBjbGFzcyBUYWJsZUNlbGxNb3JlTGluayBleHRlbmRzIEJhc2VDb21wb25lbnQ8VGFibGVDZWxsTW9yZUxpbmtQcm9wcz4ge1xuICBjb21waWxlU2VncyA9IG1lbW9pemUoY29tcGlsZVNlZ3MpXG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IHsgYWxsU2VncywgaW52aXNpYmxlU2VncyB9ID0gdGhpcy5jb21waWxlU2Vncyhwcm9wcy5zaW5nbGVQbGFjZW1lbnRzKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxNb3JlTGlua1Jvb3RcbiAgICAgICAgZGF0ZVByb2ZpbGU9e3Byb3BzLmRhdGVQcm9maWxlfVxuICAgICAgICB0b2RheVJhbmdlPXtwcm9wcy50b2RheVJhbmdlfVxuICAgICAgICBhbGxEYXlEYXRlPXtwcm9wcy5hbGxEYXlEYXRlfVxuICAgICAgICBtb3JlQ250PXtwcm9wcy5tb3JlQ250fVxuICAgICAgICBhbGxTZWdzPXthbGxTZWdzfVxuICAgICAgICBoaWRkZW5TZWdzPXtpbnZpc2libGVTZWdzfVxuICAgICAgICBhbGlnbm1lbnRFbFJlZj17cHJvcHMuYWxpZ25tZW50RWxSZWZ9XG4gICAgICAgIGFsaWduR3JpZFRvcD17cHJvcHMuYWxpZ25HcmlkVG9wfVxuICAgICAgICBleHRyYURhdGVTcGFuPXtwcm9wcy5leHRyYURhdGVTcGFufVxuICAgICAgICBwb3BvdmVyQ29udGVudD17KCkgPT4ge1xuICAgICAgICAgIGxldCBpc0ZvcmNlZEludmlzaWJsZSA9XG4gICAgICAgICAgICAocHJvcHMuZXZlbnREcmFnID8gcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSA/IHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgIHt9XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxGcmFnbWVudD5cbiAgICAgICAgICAgICAge2FsbFNlZ3MubWFwKChzZWcpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3NcIlxuICAgICAgICAgICAgICAgICAgICBrZXk9e2luc3RhbmNlSWR9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogaXNGb3JjZWRJbnZpc2libGVbaW5zdGFuY2VJZF0gPyAnaGlkZGVuJyA6ICgnJyBhcyBhbnkpLFxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7aGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgPFRhYmxlTGlzdEl0ZW1FdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnPXtzZWd9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RyYWdnaW5nPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQ9e2luc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdERpc3BsYXlFdmVudEVuZD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICB7Li4uZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UpfVxuICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgPFRhYmxlQmxvY2tFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnPXtzZWd9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RyYWdnaW5nPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVzaXppbmc9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEYXRlU2VsZWN0aW5nPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQ9e2luc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdERpc3BsYXlFdmVudEVuZD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICB7Li4uZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UpfVxuICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgPC9GcmFnbWVudD5cbiAgICAgICAgICApXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhhbmRsZUNsaWNrKSA9PiAoXG4gICAgICAgICAgPGFcbiAgICAgICAgICAgIHJlZj17cm9vdEVsUmVmfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtbJ2ZjLWRheWdyaWQtbW9yZS1saW5rJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKX1cbiAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNsaWNrfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtpbm5lckNvbnRlbnR9XG4gICAgICAgICAgPC9hPlxuICAgICAgICApfVxuICAgICAgPC9Nb3JlTGlua1Jvb3Q+XG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVTZWdzKHNpbmdsZVBsYWNlbWVudHM6IFRhYmxlU2VnUGxhY2VtZW50W10pOiB7XG4gIGFsbFNlZ3M6IFRhYmxlU2VnW11cbiAgaW52aXNpYmxlU2VnczogVGFibGVTZWdbXVxufSB7XG4gIGxldCBhbGxTZWdzOiBUYWJsZVNlZ1tdID0gW11cbiAgbGV0IGludmlzaWJsZVNlZ3M6IFRhYmxlU2VnW10gPSBbXVxuXG4gIGZvciAobGV0IHBsYWNlbWVudCBvZiBzaW5nbGVQbGFjZW1lbnRzKSB7XG4gICAgYWxsU2Vncy5wdXNoKHBsYWNlbWVudC5zZWcpXG5cbiAgICBpZiAoIXBsYWNlbWVudC5pc1Zpc2libGUpIHtcbiAgICAgIGludmlzaWJsZVNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGFsbFNlZ3MsIGludmlzaWJsZVNlZ3MgfVxufVxuIiwiaW1wb3J0IHtcbiAgUmVmLFxuICBDb21wb25lbnRDaGlsZHJlbixcbiAgY3JlYXRlRWxlbWVudCxcbiAgRGF0ZU1hcmtlcixcbiAgRGF0ZUNvbXBvbmVudCxcbiAgRGF0ZVJhbmdlLFxuICBidWlsZE5hdkxpbmtEYXRhLFxuICBXZWVrTnVtYmVyUm9vdCxcbiAgRGF5Q2VsbFJvb3QsXG4gIERhdGVQcm9maWxlLFxuICBzZXRSZWYsXG4gIGNyZWF0ZUZvcm1hdHRlcixcbiAgRGljdGlvbmFyeSxcbiAgY3JlYXRlUmVmLFxuICBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBUYWJsZUNlbGxUb3AgfSBmcm9tICcuL1RhYmxlQ2VsbFRvcCdcbmltcG9ydCB7IFRhYmxlQ2VsbE1vcmVMaW5rIH0gZnJvbSAnLi9UYWJsZUNlbGxNb3JlTGluaydcbmltcG9ydCB7IFRhYmxlU2VnUGxhY2VtZW50IH0gZnJvbSAnLi9ldmVudC1wbGFjZW1lbnQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVDZWxsUHJvcHMge1xuICBkYXRlOiBEYXRlTWFya2VyXG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZVxuICBleHRyYUhvb2tQcm9wcz86IERpY3Rpb25hcnlcbiAgZXh0cmFEYXRhQXR0cnM/OiBEaWN0aW9uYXJ5XG4gIGV4dHJhQ2xhc3NOYW1lcz86IHN0cmluZ1tdXG4gIGV4dHJhRGF0ZVNwYW4/OiBEaWN0aW9uYXJ5XG4gIGVsUmVmPzogUmVmPEhUTUxUYWJsZUNlbGxFbGVtZW50PlxuICBpbm5lckVsUmVmPzogUmVmPEhUTUxEaXZFbGVtZW50PlxuICBiZ0NvbnRlbnQ6IENvbXBvbmVudENoaWxkcmVuXG4gIGZnQ29udGVudEVsUmVmPzogUmVmPEhUTUxEaXZFbGVtZW50PiAvLyBUT0RPOiByZW5hbWUhISEgY2xhc3NuYW1lIGNvbmZ1c2lvbi4gaXMgdGhlIFwiZXZlbnRcIiBkaXZcbiAgZmdDb250ZW50OiBDb21wb25lbnRDaGlsZHJlblxuICBtb3JlQ250OiBudW1iZXJcbiAgbW9yZU1hcmdpblRvcDogbnVtYmVyXG4gIHNob3dEYXlOdW1iZXI6IGJvb2xlYW5cbiAgc2hvd1dlZWtOdW1iZXI6IGJvb2xlYW5cbiAgZm9yY2VEYXlUb3A6IGJvb2xlYW5cbiAgdG9kYXlSYW5nZTogRGF0ZVJhbmdlXG4gIGV2ZW50U2VsZWN0aW9uOiBzdHJpbmdcbiAgZXZlbnREcmFnOiBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgZXZlbnRSZXNpemU6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBzaW5nbGVQbGFjZW1lbnRzOiBUYWJsZVNlZ1BsYWNlbWVudFtdXG59XG5cbmNvbnN0IERFRkFVTFRfV0VFS19OVU1fRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgd2VlazogJ25hcnJvdycgfSlcblxuZXhwb3J0IGNsYXNzIFRhYmxlQ2VsbCBleHRlbmRzIERhdGVDb21wb25lbnQ8VGFibGVDZWxsUHJvcHM+IHtcbiAgcHJpdmF0ZSByb290RWxSZWYgPSBjcmVhdGVSZWY8SFRNTEVsZW1lbnQ+KClcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQsIHJvb3RFbFJlZiB9ID0gdGhpc1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgICBsZXQgeyBkYXRlLCBkYXRlUHJvZmlsZSB9ID0gcHJvcHNcbiAgICBsZXQgbmF2TGlua0F0dHJzID0gb3B0aW9ucy5uYXZMaW5rc1xuICAgICAgPyB7ICdkYXRhLW5hdmxpbmsnOiBidWlsZE5hdkxpbmtEYXRhKGRhdGUsICd3ZWVrJyksIHRhYkluZGV4OiAwIH1cbiAgICAgIDoge31cblxuICAgIHJldHVybiAoXG4gICAgICA8RGF5Q2VsbFJvb3RcbiAgICAgICAgZGF0ZT17ZGF0ZX1cbiAgICAgICAgZGF0ZVByb2ZpbGU9e2RhdGVQcm9maWxlfVxuICAgICAgICB0b2RheVJhbmdlPXtwcm9wcy50b2RheVJhbmdlfVxuICAgICAgICBzaG93RGF5TnVtYmVyPXtwcm9wcy5zaG93RGF5TnVtYmVyfVxuICAgICAgICBleHRyYUhvb2tQcm9wcz17cHJvcHMuZXh0cmFIb29rUHJvcHN9XG4gICAgICAgIGVsUmVmPXt0aGlzLmhhbmRsZVJvb3RFbH1cbiAgICAgID5cbiAgICAgICAgeyhkYXlFbFJlZiwgZGF5Q2xhc3NOYW1lcywgcm9vdERhdGFBdHRycywgaXNEaXNhYmxlZCkgPT4gKFxuICAgICAgICAgIDx0ZFxuICAgICAgICAgICAgcmVmPXtkYXlFbFJlZn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17WydmYy1kYXlncmlkLWRheSddLmNvbmNhdChkYXlDbGFzc05hbWVzLCBwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLmpvaW4oJyAnKX1cbiAgICAgICAgICAgIHsuLi5yb290RGF0YUF0dHJzfVxuICAgICAgICAgICAgey4uLnByb3BzLmV4dHJhRGF0YUF0dHJzfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtZGF5Z3JpZC1kYXktZnJhbWUgZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgcmVmPXtwcm9wcy5pbm5lckVsUmVmIC8qIGRpZmZlcmVudCBmcm9tIGhvb2sgc3lzdGVtISBSRU5BTUUgKi99PlxuICAgICAgICAgICAgICB7cHJvcHMuc2hvd1dlZWtOdW1iZXIgJiYgKFxuICAgICAgICAgICAgICAgIDxXZWVrTnVtYmVyUm9vdCBkYXRlPXtkYXRlfSBkZWZhdWx0Rm9ybWF0PXtERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVH0+XG4gICAgICAgICAgICAgICAgICB7KHdlZWtFbFJlZiwgd2Vla0NsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgIHJlZj17d2Vla0VsUmVmfVxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17WydmYy1kYXlncmlkLXdlZWstbnVtYmVyJ10uY29uY2F0KHdlZWtDbGFzc05hbWVzKS5qb2luKCcgJyl9XG4gICAgICAgICAgICAgICAgICAgICAgey4uLm5hdkxpbmtBdHRyc31cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIHtpbm5lckNvbnRlbnR9XG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9XZWVrTnVtYmVyUm9vdD5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgeyFpc0Rpc2FibGVkICYmIChcbiAgICAgICAgICAgICAgICA8VGFibGVDZWxsVG9wXG4gICAgICAgICAgICAgICAgICBkYXRlPXtkYXRlfVxuICAgICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU9e2RhdGVQcm9maWxlfVxuICAgICAgICAgICAgICAgICAgc2hvd0RheU51bWJlcj17cHJvcHMuc2hvd0RheU51bWJlcn1cbiAgICAgICAgICAgICAgICAgIGZvcmNlRGF5VG9wPXtwcm9wcy5mb3JjZURheVRvcH1cbiAgICAgICAgICAgICAgICAgIHRvZGF5UmFuZ2U9e3Byb3BzLnRvZGF5UmFuZ2V9XG4gICAgICAgICAgICAgICAgICBleHRyYUhvb2tQcm9wcz17cHJvcHMuZXh0cmFIb29rUHJvcHN9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZjLWRheWdyaWQtZGF5LWV2ZW50c1wiXG4gICAgICAgICAgICAgICAgcmVmPXtwcm9wcy5mZ0NvbnRlbnRFbFJlZn1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtwcm9wcy5mZ0NvbnRlbnR9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmYy1kYXlncmlkLWRheS1ib3R0b21cIiBzdHlsZT17eyBtYXJnaW5Ub3A6IHByb3BzLm1vcmVNYXJnaW5Ub3AgfX0+XG4gICAgICAgICAgICAgICAgICA8VGFibGVDZWxsTW9yZUxpbmtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5RGF0ZT17ZGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlUGxhY2VtZW50cz17cHJvcHMuc2luZ2xlUGxhY2VtZW50c31cbiAgICAgICAgICAgICAgICAgICAgbW9yZUNudD17cHJvcHMubW9yZUNudH1cbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50RWxSZWY9e3Jvb3RFbFJlZn1cbiAgICAgICAgICAgICAgICAgICAgYWxpZ25HcmlkVG9wPXshcHJvcHMuc2hvd0RheU51bWJlcn1cbiAgICAgICAgICAgICAgICAgICAgZXh0cmFEYXRlU3Bhbj17cHJvcHMuZXh0cmFEYXRlU3Bhbn1cbiAgICAgICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU9e3Byb3BzLmRhdGVQcm9maWxlfVxuICAgICAgICAgICAgICAgICAgICBldmVudFNlbGVjdGlvbj17cHJvcHMuZXZlbnRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RHJhZz17cHJvcHMuZXZlbnREcmFnfVxuICAgICAgICAgICAgICAgICAgICBldmVudFJlc2l6ZT17cHJvcHMuZXZlbnRSZXNpemV9XG4gICAgICAgICAgICAgICAgICAgIHRvZGF5UmFuZ2U9e3Byb3BzLnRvZGF5UmFuZ2V9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmYy1kYXlncmlkLWRheS1iZ1wiPlxuICAgICAgICAgICAgICAgIHtwcm9wcy5iZ0NvbnRlbnR9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgKX1cbiAgICAgIDwvRGF5Q2VsbFJvb3Q+XG4gICAgKVxuICB9XG5cbiAgaGFuZGxlUm9vdEVsID0gKGVsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIHNldFJlZih0aGlzLnJvb3RFbFJlZiwgZWwpXG4gICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBTZWdIaWVyYXJjaHksXG4gIFNlZ1JlY3QsXG4gIFNlZ0VudHJ5LFxuICBTZWdJbnNlcnRpb24sXG4gIGJ1aWxkRW50cnlLZXksXG4gIEV2ZW50UmVuZGVyUmFuZ2UsXG4gIGludGVyc2VjdFJhbmdlcyxcbiAgYWRkRGF5cyxcbiAgRGF5VGFibGVDZWxsLFxuICBpbnRlcnNlY3RTcGFucyxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBUYWJsZVNlZyB9IGZyb20gJy4vVGFibGVTZWcnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVTZWdQbGFjZW1lbnQge1xuICBzZWc6IFRhYmxlU2VnXG4gIGlzVmlzaWJsZTogYm9vbGVhblxuICBpc0Fic29sdXRlOiBib29sZWFuXG4gIGFic29sdXRlVG9wOiBudW1iZXIgLy8gcG9wdWxhdGVkIHJlZ2FyZGxlc3Mgb2YgaXNBYnNvbHV0ZVxuICBtYXJnaW5Ub3A6IG51bWJlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUZnU2VnUGxhY2VtZW50KFxuICBzZWdzOiBUYWJsZVNlZ1tdLCAvLyBhc3N1bWVkIGFscmVhZHkgc29ydGVkXG4gIGRheU1heEV2ZW50czogYm9vbGVhbiB8IG51bWJlcixcbiAgZGF5TWF4RXZlbnRSb3dzOiBib29sZWFuIHwgbnVtYmVyLFxuICBzdHJpY3RPcmRlcjogYm9vbGVhbixcbiAgZXZlbnRJbnN0YW5jZUhlaWdodHM6IHsgW2luc3RhbmNlSWQ6IHN0cmluZ106IG51bWJlciB9LFxuICBtYXhDb250ZW50SGVpZ2h0OiBudW1iZXIgfCBudWxsLFxuICBjZWxsczogRGF5VGFibGVDZWxsW10sXG4pIHtcbiAgbGV0IGhpZXJhcmNoeSA9IG5ldyBEYXlHcmlkU2VnSGllcmFyY2h5KClcbiAgaGllcmFyY2h5LmFsbG93UmVzbGljaW5nID0gdHJ1ZVxuICBoaWVyYXJjaHkuc3RyaWN0T3JkZXIgPSBzdHJpY3RPcmRlclxuXG4gIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7XG4gICAgaGllcmFyY2h5Lm1heENvb3JkID0gbWF4Q29udGVudEhlaWdodFxuICAgIGhpZXJhcmNoeS5oaWRkZW5Db25zdW1lcyA9IHRydWVcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF5TWF4RXZlbnRzID09PSAnbnVtYmVyJykge1xuICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IGRheU1heEV2ZW50c1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudFJvd3MgPT09ICdudW1iZXInKSB7XG4gICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gZGF5TWF4RXZlbnRSb3dzXG4gICAgaGllcmFyY2h5LmhpZGRlbkNvbnN1bWVzID0gdHJ1ZVxuICB9XG5cbiAgLy8gY3JlYXRlIHNlZ0lucHV0cyBvbmx5IGZvciBzZWdzIHdpdGgga25vd24gaGVpZ2h0c1xuICBsZXQgc2VnSW5wdXRzOiBTZWdFbnRyeVtdID0gW11cbiAgbGV0IHVua25vd25IZWlnaHRTZWdzOiBUYWJsZVNlZ1tdID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgbGV0IHNlZyA9IHNlZ3NbaV1cbiAgICBsZXQgeyBpbnN0YW5jZUlkIH0gPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZVxuICAgIGxldCBldmVudEhlaWdodCA9IGV2ZW50SW5zdGFuY2VIZWlnaHRzW2luc3RhbmNlSWRdXG5cbiAgICBpZiAoZXZlbnRIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgc2VnSW5wdXRzLnB1c2goe1xuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdGhpY2tuZXNzOiBldmVudEhlaWdodCxcbiAgICAgICAgc3Bhbjoge1xuICAgICAgICAgIHN0YXJ0OiBzZWcuZmlyc3RDb2wsXG4gICAgICAgICAgZW5kOiBzZWcubGFzdENvbCArIDEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB1bmtub3duSGVpZ2h0U2Vncy5wdXNoKHNlZylcbiAgICB9XG4gIH1cblxuICBsZXQgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cylcbiAgbGV0IHNlZ1JlY3RzID0gaGllcmFyY2h5LnRvUmVjdHMoKVxuICBsZXQgeyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIGxlZnRvdmVyTWFyZ2lucyB9ID0gcGxhY2VSZWN0cyhzZWdSZWN0cywgc2VncywgY2VsbHMpXG5cbiAgbGV0IG1vcmVDbnRzOiBudW1iZXJbXSA9IFtdXG4gIGxldCBtb3JlTWFyZ2luVG9wczogbnVtYmVyW10gPSBbXVxuXG4gIC8vIGFkZCBzZWdzIHdpdGggdW5rbm93biBoZWlnaHRzXG4gIGZvciAobGV0IHNlZyBvZiB1bmtub3duSGVpZ2h0U2Vncykge1xuICAgIG11bHRpQ29sUGxhY2VtZW50c1tzZWcuZmlyc3RDb2xdLnB1c2goe1xuICAgICAgc2VnLFxuICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgIG1hcmdpblRvcDogMCxcbiAgICB9KVxuXG4gICAgZm9yIChsZXQgY29sID0gc2VnLmZpcnN0Q29sOyBjb2wgPD0gc2VnLmxhc3RDb2w7IGNvbCArPSAxKSB7XG4gICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaCh7XG4gICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIHRoZSBoaWRkZW4gZW50cmllc1xuICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgbW9yZUNudHMucHVzaCgwKVxuICB9XG4gIGZvciAobGV0IGhpZGRlbkVudHJ5IG9mIGhpZGRlbkVudHJpZXMpIHtcbiAgICBsZXQgc2VnID0gc2Vnc1toaWRkZW5FbnRyeS5pbmRleF1cbiAgICBsZXQgaGlkZGVuU3BhbiA9IGhpZGRlbkVudHJ5LnNwYW5cblxuICAgIG11bHRpQ29sUGxhY2VtZW50c1toaWRkZW5TcGFuLnN0YXJ0XS5wdXNoKHtcbiAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGhpZGRlblNwYW4uc3RhcnQsIGhpZGRlblNwYW4uZW5kLCBjZWxscyksXG4gICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgbWFyZ2luVG9wOiAwLFxuICAgIH0pXG5cbiAgICBmb3IgKGxldCBjb2wgPSBoaWRkZW5TcGFuLnN0YXJ0OyBjb2wgPCBoaWRkZW5TcGFuLmVuZDsgY29sICs9IDEpIHtcbiAgICAgIG1vcmVDbnRzW2NvbF0gKz0gMVxuICAgICAgc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLnB1c2goe1xuICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIGRlYWwgd2l0aCBsZWZ0b3ZlciBtYXJnaW5zXG4gIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICBtb3JlTWFyZ2luVG9wcy5wdXNoKGxlZnRvdmVyTWFyZ2luc1tjb2xdKVxuICB9XG5cbiAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBtb3JlQ250cywgbW9yZU1hcmdpblRvcHMgfVxufVxuXG4vLyByZWN0cyBvcmRlcmVkIGJ5IHRvcCBjb29yZCwgdGhlbiBsZWZ0XG5mdW5jdGlvbiBwbGFjZVJlY3RzKGFsbFJlY3RzOiBTZWdSZWN0W10sIHNlZ3M6IFRhYmxlU2VnW10sIGNlbGxzOiBEYXlUYWJsZUNlbGxbXSkge1xuICBsZXQgcmVjdHNCeUVhY2hDb2wgPSBncm91cFJlY3RzQnlFYWNoQ29sKGFsbFJlY3RzLCBjZWxscy5sZW5ndGgpXG4gIGxldCBzaW5nbGVDb2xQbGFjZW1lbnRzOiBUYWJsZVNlZ1BsYWNlbWVudFtdW10gPSBbXVxuICBsZXQgbXVsdGlDb2xQbGFjZW1lbnRzOiBUYWJsZVNlZ1BsYWNlbWVudFtdW10gPSBbXVxuICBsZXQgbGVmdG92ZXJNYXJnaW5zOiBudW1iZXJbXSA9IFtdXG5cbiAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgIGxldCByZWN0cyA9IHJlY3RzQnlFYWNoQ29sW2NvbF1cblxuICAgIC8vIGNvbXB1dGUgYWxsIHN0YXRpYyBzZWdzIGluIHNpbmdsZVBsYWNlbWVudHNcbiAgICBsZXQgc2luZ2xlUGxhY2VtZW50czogVGFibGVTZWdQbGFjZW1lbnRbXSA9IFtdXG4gICAgbGV0IGN1cnJlbnRIZWlnaHQgPSAwXG4gICAgbGV0IGN1cnJlbnRNYXJnaW5Ub3AgPSAwXG4gICAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xuICAgICAgbGV0IHNlZyA9IHNlZ3NbcmVjdC5pbmRleF1cbiAgICAgIHNpbmdsZVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICBtYXJnaW5Ub3A6IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQsXG4gICAgICB9KVxuICAgICAgY3VycmVudEhlaWdodCA9IHJlY3QubGV2ZWxDb29yZCArIHJlY3QudGhpY2tuZXNzXG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSBtaXhlZCBzdGF0aWMvYWJzb2x1dGUgc2VncyBpbiBtdWx0aVBsYWNlbWVudHNcbiAgICBsZXQgbXVsdGlQbGFjZW1lbnRzOiBUYWJsZVNlZ1BsYWNlbWVudFtdID0gW11cbiAgICBjdXJyZW50SGVpZ2h0ID0gMFxuICAgIGN1cnJlbnRNYXJnaW5Ub3AgPSAwXG4gICAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xuICAgICAgbGV0IHNlZyA9IHNlZ3NbcmVjdC5pbmRleF1cbiAgICAgIGxldCBpc0Fic29sdXRlID0gcmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCA+IDEgLy8gbXVsdGktY29sdW1uP1xuICAgICAgbGV0IGlzRmlyc3RDb2wgPSByZWN0LnNwYW4uc3RhcnQgPT09IGNvbFxuXG4gICAgICBjdXJyZW50TWFyZ2luVG9wICs9IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQgLy8gYW1vdW50IG9mIHNwYWNlIHNpbmNlIGJvdHRvbSBvZiBwcmV2aW91cyBzZWdcbiAgICAgIGN1cnJlbnRIZWlnaHQgPSByZWN0LmxldmVsQ29vcmQgKyByZWN0LnRoaWNrbmVzcyAvLyBoZWlnaHQgd2lsbCBub3cgYmUgYm90dG9tIG9mIGN1cnJlbnQgc2VnXG5cbiAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgKz0gcmVjdC50aGlja25lc3NcbiAgICAgICAgaWYgKGlzRmlyc3RDb2wpIHtcbiAgICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdENvbCkge1xuICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgcmVjdC5zcGFuLnN0YXJ0LCByZWN0LnNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgbWFyZ2luVG9wOiBjdXJyZW50TWFyZ2luVG9wLCAvLyBjbGFpbSB0aGUgbWFyZ2luXG4gICAgICAgIH0pXG4gICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgPSAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2luZ2xlQ29sUGxhY2VtZW50cy5wdXNoKHNpbmdsZVBsYWNlbWVudHMpXG4gICAgbXVsdGlDb2xQbGFjZW1lbnRzLnB1c2gobXVsdGlQbGFjZW1lbnRzKVxuICAgIGxlZnRvdmVyTWFyZ2lucy5wdXNoKGN1cnJlbnRNYXJnaW5Ub3ApXG4gIH1cblxuICByZXR1cm4geyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIGxlZnRvdmVyTWFyZ2lucyB9XG59XG5cbmZ1bmN0aW9uIGdyb3VwUmVjdHNCeUVhY2hDb2wocmVjdHM6IFNlZ1JlY3RbXSwgY29sQ250OiBudW1iZXIpOiBTZWdSZWN0W11bXSB7XG4gIGxldCByZWN0c0J5RWFjaENvbDogU2VnUmVjdFtdW10gPSBbXVxuXG4gIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sICs9IDEpIHtcbiAgICByZWN0c0J5RWFjaENvbC5wdXNoKFtdKVxuICB9XG5cbiAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xuICAgIGZvciAobGV0IGNvbCA9IHJlY3Quc3Bhbi5zdGFydDsgY29sIDwgcmVjdC5zcGFuLmVuZDsgY29sICs9IDEpIHtcbiAgICAgIHJlY3RzQnlFYWNoQ29sW2NvbF0ucHVzaChyZWN0KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWN0c0J5RWFjaENvbFxufVxuXG5mdW5jdGlvbiByZXNsaWNlU2VnKHNlZzogVGFibGVTZWcsIHNwYW5TdGFydDogbnVtYmVyLCBzcGFuRW5kOiBudW1iZXIsIGNlbGxzOiBEYXlUYWJsZUNlbGxbXSk6IFRhYmxlU2VnIHtcbiAgaWYgKHNlZy5maXJzdENvbCA9PT0gc3BhblN0YXJ0ICYmIHNlZy5sYXN0Q29sID09PSBzcGFuRW5kIC0gMSkge1xuICAgIHJldHVybiBzZWdcbiAgfVxuXG4gIGxldCBldmVudFJhbmdlID0gc2VnLmV2ZW50UmFuZ2VcbiAgbGV0IG9yaWdSYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2VcbiAgbGV0IHNsaWNlZFJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKG9yaWdSYW5nZSwge1xuICAgIHN0YXJ0OiBjZWxsc1tzcGFuU3RhcnRdLmRhdGUsXG4gICAgZW5kOiBhZGREYXlzKGNlbGxzW3NwYW5FbmQgLSAxXS5kYXRlLCAxKSxcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIC4uLnNlZyxcbiAgICBmaXJzdENvbDogc3BhblN0YXJ0LFxuICAgIGxhc3RDb2w6IHNwYW5FbmQgLSAxLFxuICAgIGV2ZW50UmFuZ2U6IHtcbiAgICAgIGRlZjogZXZlbnRSYW5nZS5kZWYsXG4gICAgICB1aTogeyAuLi5ldmVudFJhbmdlLnVpLCBkdXJhdGlvbkVkaXRhYmxlOiBmYWxzZSB9LCAvLyBoYWNrIHRvIGRpc2FibGUgcmVzaXppbmdcbiAgICAgIGluc3RhbmNlOiBldmVudFJhbmdlLmluc3RhbmNlLFxuICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxuICAgIH0gYXMgRXZlbnRSZW5kZXJSYW5nZSxcbiAgICBpc1N0YXJ0OiBzZWcuaXNTdGFydCAmJiBzbGljZWRSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgaXNFbmQ6IHNlZy5pc0VuZCAmJiBzbGljZWRSYW5nZS5lbmQudmFsdWVPZigpID09PSBvcmlnUmFuZ2UuZW5kLnZhbHVlT2YoKSxcbiAgfVxufVxuXG5jbGFzcyBEYXlHcmlkU2VnSGllcmFyY2h5IGV4dGVuZHMgU2VnSGllcmFyY2h5IHtcbiAgLy8gY29uZmlnXG4gIGhpZGRlbkNvbnN1bWVzOiBib29sZWFuID0gZmFsc2VcblxuICAvLyBhbGxvd3MgdXMgdG8ga2VlcCBoaWRkZW4gZW50cmllcyBpbiB0aGUgaGllcmFyY2h5IHNvIHRoZXkgdGFrZSB1cCBzcGFjZVxuICBmb3JjZUhpZGRlbjogeyBbZW50cnlJZDogc3RyaW5nXTogdHJ1ZSB9ID0ge31cblxuICBhZGRTZWdzKHNlZ0lucHV0czogU2VnRW50cnlbXSk6IFNlZ0VudHJ5W10ge1xuICAgIGNvbnN0IGhpZGRlblNlZ3MgPSBzdXBlci5hZGRTZWdzKHNlZ0lucHV0cylcbiAgICBjb25zdCB7IGVudHJpZXNCeUxldmVsIH0gPSB0aGlzXG4gICAgY29uc3QgZXhjbHVkZUhpZGRlbiA9IChlbnRyeTogU2VnRW50cnkpID0+ICF0aGlzLmZvcmNlSGlkZGVuW2J1aWxkRW50cnlLZXkoZW50cnkpXVxuXG4gICAgLy8gcmVtb3ZlIHRoZSBmb3JjZWQtaGlkZGVuIHNlZ3NcbiAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgZW50cmllc0J5TGV2ZWwubGVuZ3RoOyBsZXZlbCArPSAxKSB7XG4gICAgICBlbnRyaWVzQnlMZXZlbFtsZXZlbF0gPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF0uZmlsdGVyKGV4Y2x1ZGVIaWRkZW4pXG4gICAgfVxuXG4gICAgcmV0dXJuIGhpZGRlblNlZ3NcbiAgfVxuXG4gIGhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uOiBTZWdJbnNlcnRpb24sIGVudHJ5OiBTZWdFbnRyeSwgaGlkZGVuRW50cmllczogU2VnRW50cnlbXSkge1xuICAgIGNvbnN0IHsgZW50cmllc0J5TGV2ZWwsIGZvcmNlSGlkZGVuIH0gPSB0aGlzXG4gICAgY29uc3QgeyB0b3VjaGluZ0VudHJ5LCB0b3VjaGluZ0xldmVsLCB0b3VjaGluZ0xhdGVyYWwgfSA9IGluc2VydGlvblxuXG4gICAgaWYgKHRoaXMuaGlkZGVuQ29uc3VtZXMgJiYgdG91Y2hpbmdFbnRyeSkge1xuICAgICAgY29uc3QgdG91Y2hpbmdFbnRyeUlkID0gYnVpbGRFbnRyeUtleSh0b3VjaGluZ0VudHJ5KVxuICAgICAgLy8gaWYgbm90IGFscmVhZHkgaGlkZGVuXG4gICAgICBpZiAoIWZvcmNlSGlkZGVuW3RvdWNoaW5nRW50cnlJZF0pIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dSZXNsaWNpbmcpIHtcbiAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlckVudHJ5OiBTZWdFbnRyeSA9IHsgLy8gcGxhY2Vob2xkZXIgb2YgdGhlIFwibW9yZVwiIGxpbmtcbiAgICAgICAgICAgIC4uLnRvdWNoaW5nRW50cnksXG4gICAgICAgICAgICBzcGFuOiBpbnRlcnNlY3RTcGFucyh0b3VjaGluZ0VudHJ5LnNwYW4sIGVudHJ5LnNwYW4pLFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlckVudHJ5SWQgPSBidWlsZEVudHJ5S2V5KHBsYWNlaG9sZGVyRW50cnkpXG4gICAgICAgICAgZm9yY2VIaWRkZW5bcGxhY2Vob2xkZXJFbnRyeUlkXSA9IHRydWVcbiAgICAgICAgICBlbnRyaWVzQnlMZXZlbFt0b3VjaGluZ0xldmVsXVt0b3VjaGluZ0xhdGVyYWxdID0gcGxhY2Vob2xkZXJFbnRyeSAvLyByZXBsYWNlIHRvdWNoaW5nRW50cnkgd2l0aCBvdXIgcGxhY2Vob2xkZXJcbiAgICAgICAgICB0aGlzLnNwbGl0RW50cnkodG91Y2hpbmdFbnRyeSwgZW50cnksIGhpZGRlbkVudHJpZXMpIC8vIHNwbGl0IHVwIHRoZSB0b3VjaGluZ0VudHJ5LCByZWluc2VydCBpdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvcmNlSGlkZGVuW3RvdWNoaW5nRW50cnlJZF0gPSB0cnVlXG4gICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKHRvdWNoaW5nRW50cnkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSxcbiAgVk5vZGUsXG4gIERhdGVDb21wb25lbnQsXG4gIGNyZWF0ZUVsZW1lbnQsXG4gIFBvc2l0aW9uQ2FjaGUsXG4gIFJlZk1hcCxcbiAgQ3NzRGltVmFsdWUsXG4gIERhdGVSYW5nZSxcbiAgZ2V0U2VnTWV0YSxcbiAgRGF0ZVByb2ZpbGUsXG4gIEZyYWdtZW50LFxuICBCZ0V2ZW50LFxuICByZW5kZXJGaWxsLFxuICBpc1Byb3BzRXF1YWwsXG4gIGNyZWF0ZVJlZixcbiAgYnVpbGRFdmVudFJhbmdlS2V5LFxuICBzb3J0RXZlbnRTZWdzLFxuICBEYXlUYWJsZUNlbGwsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgVGFibGVTZWcsIHNwbGl0U2Vnc0J5Rmlyc3RDb2wgfSBmcm9tICcuL1RhYmxlU2VnJ1xuaW1wb3J0IHsgVGFibGVDZWxsIH0gZnJvbSAnLi9UYWJsZUNlbGwnXG5pbXBvcnQgeyBUYWJsZUxpc3RJdGVtRXZlbnQgfSBmcm9tICcuL1RhYmxlTGlzdEl0ZW1FdmVudCdcbmltcG9ydCB7IFRhYmxlQmxvY2tFdmVudCB9IGZyb20gJy4vVGFibGVCbG9ja0V2ZW50J1xuaW1wb3J0IHsgY29tcHV0ZUZnU2VnUGxhY2VtZW50LCBUYWJsZVNlZ1BsYWNlbWVudCB9IGZyb20gJy4vZXZlbnQtcGxhY2VtZW50J1xuaW1wb3J0IHsgaGFzTGlzdEl0ZW1EaXNwbGF5IH0gZnJvbSAnLi9ldmVudC1yZW5kZXJpbmcnXG5cbi8vIFRPRE86IGF0dGFjaCB0byB3aW5kb3cgcmVzaXplP1xuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlUm93UHJvcHMge1xuICBjZWxsczogRGF5VGFibGVDZWxsW11cbiAgcmVuZGVySW50cm8/OiAoKSA9PiBWTm9kZVxuICBidXNpbmVzc0hvdXJTZWdzOiBUYWJsZVNlZ1tdXG4gIGJnRXZlbnRTZWdzOiBUYWJsZVNlZ1tdXG4gIGZnRXZlbnRTZWdzOiBUYWJsZVNlZ1tdXG4gIGRhdGVTZWxlY3Rpb25TZWdzOiBUYWJsZVNlZ1tdXG4gIGV2ZW50U2VsZWN0aW9uOiBzdHJpbmdcbiAgZXZlbnREcmFnOiBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgZXZlbnRSZXNpemU6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBkYXlNYXhFdmVudHM6IGJvb2xlYW4gfCBudW1iZXJcbiAgZGF5TWF4RXZlbnRSb3dzOiBib29sZWFuIHwgbnVtYmVyXG4gIGNsaWVudFdpZHRoOiBudW1iZXIgfCBudWxsXG4gIGNsaWVudEhlaWdodDogbnVtYmVyIHwgbnVsbCAvLyBzaW1wbHkgZm9yIGNhdXNpbmcgYW4gdXBkYXRlU2l6ZSwgZm9yIHdoZW4gbGlxdWlkIGhlaWdodFxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgdG9kYXlSYW5nZTogRGF0ZVJhbmdlXG4gIHNob3dEYXlOdW1iZXJzOiBib29sZWFuXG4gIHNob3dXZWVrTnVtYmVyczogYm9vbGVhblxuICBmb3JQcmludDogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgVGFibGVSb3dTdGF0ZSB7XG4gIGZyYW1lUG9zaXRpb25zOiBQb3NpdGlvbkNhY2hlXG4gIG1heENvbnRlbnRIZWlnaHQ6IG51bWJlciB8IG51bGxcbiAgZXZlbnRJbnN0YW5jZUhlaWdodHM6IHsgW2luc3RhbmNlSWQ6IHN0cmluZ106IG51bWJlciB9IC8vIGludGVnZXJzXG59XG5cbmV4cG9ydCBjbGFzcyBUYWJsZVJvdyBleHRlbmRzIERhdGVDb21wb25lbnQ8VGFibGVSb3dQcm9wcywgVGFibGVSb3dTdGF0ZT4ge1xuICBwcml2YXRlIGNlbGxFbFJlZnMgPSBuZXcgUmVmTWFwPEhUTUxUYWJsZUNlbGxFbGVtZW50PigpIC8vIHRoZSA8dGQ+XG4gIHByaXZhdGUgZnJhbWVFbFJlZnMgPSBuZXcgUmVmTWFwPEhUTUxFbGVtZW50PigpIC8vIHRoZSBmYy1kYXlncmlkLWRheS1mcmFtZVxuICBwcml2YXRlIGZnRWxSZWZzID0gbmV3IFJlZk1hcDxIVE1MRGl2RWxlbWVudD4oKSAvLyB0aGUgZmMtZGF5Z3JpZC1kYXktZXZlbnRzXG4gIHByaXZhdGUgc2VnSGFybmVzc1JlZnMgPSBuZXcgUmVmTWFwPEhUTUxEaXZFbGVtZW50PigpIC8vIGluZGV4ZWQgYnkgXCJpbnN0YW5jZUlkOmZpcnN0Q29sXCJcbiAgcHJpdmF0ZSByb290RWxSZWYgPSBjcmVhdGVSZWY8SFRNTFRhYmxlUm93RWxlbWVudD4oKVxuXG4gIHN0YXRlOiBUYWJsZVJvd1N0YXRlID0ge1xuICAgIGZyYW1lUG9zaXRpb25zOiBudWxsLFxuICAgIG1heENvbnRlbnRIZWlnaHQ6IG51bGwsXG4gICAgZXZlbnRJbnN0YW5jZUhlaWdodHM6IHt9LFxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgICBsZXQgY29sQ250ID0gcHJvcHMuY2VsbHMubGVuZ3RoXG5cbiAgICBsZXQgYnVzaW5lc3NIb3Vyc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbChwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBjb2xDbnQpXG4gICAgbGV0IGJnRXZlbnRTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJnRXZlbnRTZWdzLCBjb2xDbnQpXG4gICAgbGV0IGhpZ2hsaWdodFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wodGhpcy5nZXRIaWdobGlnaHRTZWdzKCksIGNvbENudClcbiAgICBsZXQgbWlycm9yU2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldE1pcnJvclNlZ3MoKSwgY29sQ250KVxuXG4gICAgbGV0IHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBtb3JlQ250cywgbW9yZU1hcmdpblRvcHMgfSA9IGNvbXB1dGVGZ1NlZ1BsYWNlbWVudChcbiAgICAgIHNvcnRFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIG9wdGlvbnMuZXZlbnRPcmRlcikgYXMgVGFibGVTZWdbXSxcbiAgICAgIHByb3BzLmRheU1heEV2ZW50cyxcbiAgICAgIHByb3BzLmRheU1heEV2ZW50Um93cyxcbiAgICAgIG9wdGlvbnMuZXZlbnRPcmRlclN0cmljdCxcbiAgICAgIHN0YXRlLmV2ZW50SW5zdGFuY2VIZWlnaHRzLFxuICAgICAgc3RhdGUubWF4Q29udGVudEhlaWdodCxcbiAgICAgIHByb3BzLmNlbGxzLFxuICAgIClcblxuICAgIGxldCBpc0ZvcmNlZEludmlzaWJsZSA9IC8vIFRPRE86IG1lc3N5IHdheSB0byBjb21wdXRlIHRoaXNcbiAgICAgIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAge31cblxuICAgIHJldHVybiAoXG4gICAgICA8dHIgcmVmPXt0aGlzLnJvb3RFbFJlZn0+XG4gICAgICAgIHtwcm9wcy5yZW5kZXJJbnRybyAmJiBwcm9wcy5yZW5kZXJJbnRybygpfVxuICAgICAgICB7cHJvcHMuY2VsbHMubWFwKChjZWxsLCBjb2wpID0+IHtcbiAgICAgICAgICBsZXQgbm9ybWFsRmdOb2RlcyA9IHRoaXMucmVuZGVyRmdTZWdzKFxuICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgcHJvcHMuZm9yUHJpbnQgPyBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0gOiBtdWx0aUNvbFBsYWNlbWVudHNbY29sXSxcbiAgICAgICAgICAgIHByb3BzLnRvZGF5UmFuZ2UsXG4gICAgICAgICAgICBpc0ZvcmNlZEludmlzaWJsZSxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBsZXQgbWlycm9yRmdOb2RlcyA9IHRoaXMucmVuZGVyRmdTZWdzKFxuICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3NCeUNvbFtjb2xdLCBtdWx0aUNvbFBsYWNlbWVudHMpLFxuICAgICAgICAgICAgcHJvcHMudG9kYXlSYW5nZSxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLFxuICAgICAgICAgICAgQm9vbGVhbihwcm9wcy5ldmVudFJlc2l6ZSksXG4gICAgICAgICAgICBmYWxzZSwgLy8gZGF0ZS1zZWxlY3RpbmcgKGJlY2F1c2UgbWlycm9yIGlzIG5ldmVyIGRyYXduIGZvciBkYXRlIHNlbGVjdGlvbilcbiAgICAgICAgICApXG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFRhYmxlQ2VsbFxuICAgICAgICAgICAgICBrZXk9e2NlbGwua2V5fVxuICAgICAgICAgICAgICBlbFJlZj17dGhpcy5jZWxsRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSl9XG4gICAgICAgICAgICAgIGlubmVyRWxSZWY9e3RoaXMuZnJhbWVFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSAvKiBGRiA8dGQ+IHByb2JsZW0sIGJ1dCBva2F5IHRvIHVzZSBmb3IgbGVmdC9yaWdodC4gVE9ETzogcmVuYW1lIHByb3AgKi99XG4gICAgICAgICAgICAgIGRhdGVQcm9maWxlPXtwcm9wcy5kYXRlUHJvZmlsZX1cbiAgICAgICAgICAgICAgZGF0ZT17Y2VsbC5kYXRlfVxuICAgICAgICAgICAgICBzaG93RGF5TnVtYmVyPXtwcm9wcy5zaG93RGF5TnVtYmVyc31cbiAgICAgICAgICAgICAgc2hvd1dlZWtOdW1iZXI9e3Byb3BzLnNob3dXZWVrTnVtYmVycyAmJiBjb2wgPT09IDB9XG4gICAgICAgICAgICAgIGZvcmNlRGF5VG9wPXtwcm9wcy5zaG93V2Vla051bWJlcnMgLyogZXZlbiBkaXNwbGF5aW5nIHdlZWtudW0gZm9yIHJvdywgbm90IG5lY2Vzc2FyaWx5IGRheSAqL31cbiAgICAgICAgICAgICAgdG9kYXlSYW5nZT17cHJvcHMudG9kYXlSYW5nZX1cbiAgICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb249e3Byb3BzLmV2ZW50U2VsZWN0aW9ufVxuICAgICAgICAgICAgICBldmVudERyYWc9e3Byb3BzLmV2ZW50RHJhZ31cbiAgICAgICAgICAgICAgZXZlbnRSZXNpemU9e3Byb3BzLmV2ZW50UmVzaXplfVxuICAgICAgICAgICAgICBleHRyYUhvb2tQcm9wcz17Y2VsbC5leHRyYUhvb2tQcm9wc31cbiAgICAgICAgICAgICAgZXh0cmFEYXRhQXR0cnM9e2NlbGwuZXh0cmFEYXRhQXR0cnN9XG4gICAgICAgICAgICAgIGV4dHJhQ2xhc3NOYW1lcz17Y2VsbC5leHRyYUNsYXNzTmFtZXN9XG4gICAgICAgICAgICAgIGV4dHJhRGF0ZVNwYW49e2NlbGwuZXh0cmFEYXRlU3Bhbn1cbiAgICAgICAgICAgICAgbW9yZUNudD17bW9yZUNudHNbY29sXX1cbiAgICAgICAgICAgICAgbW9yZU1hcmdpblRvcD17bW9yZU1hcmdpblRvcHNbY29sXX1cbiAgICAgICAgICAgICAgc2luZ2xlUGxhY2VtZW50cz17c2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdfVxuICAgICAgICAgICAgICBmZ0NvbnRlbnRFbFJlZj17dGhpcy5mZ0VsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpfVxuICAgICAgICAgICAgICBmZ0NvbnRlbnQ9eyggLy8gRnJhZ21lbnQgc2NvcGVzIHRoZSBrZXlzXG4gICAgICAgICAgICAgICAgPEZyYWdtZW50PlxuICAgICAgICAgICAgICAgICAgPEZyYWdtZW50Pntub3JtYWxGZ05vZGVzfTwvRnJhZ21lbnQ+XG4gICAgICAgICAgICAgICAgICA8RnJhZ21lbnQ+e21pcnJvckZnTm9kZXN9PC9GcmFnbWVudD5cbiAgICAgICAgICAgICAgICA8L0ZyYWdtZW50PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICBiZ0NvbnRlbnQ9eyggLy8gRnJhZ21lbnQgc2NvcGVzIHRoZSBrZXlzXG4gICAgICAgICAgICAgICAgPEZyYWdtZW50PlxuICAgICAgICAgICAgICAgICAge3RoaXMucmVuZGVyRmlsbFNlZ3MoaGlnaGxpZ2h0U2Vnc0J5Q29sW2NvbF0sICdoaWdobGlnaHQnKX1cbiAgICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlckZpbGxTZWdzKGJ1c2luZXNzSG91cnNCeUNvbFtjb2xdLCAnbm9uLWJ1c2luZXNzJyl9XG4gICAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJGaWxsU2VncyhiZ0V2ZW50U2Vnc0J5Q29sW2NvbF0sICdiZy1ldmVudCcpfVxuICAgICAgICAgICAgICAgIDwvRnJhZ21lbnQ+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIClcbiAgICAgICAgfSl9XG4gICAgICA8L3RyPlxuICAgIClcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpXG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBUYWJsZVJvd1Byb3BzLCBwcmV2U3RhdGU6IFRhYmxlUm93U3RhdGUpIHtcbiAgICBsZXQgY3VycmVudFByb3BzID0gdGhpcy5wcm9wc1xuXG4gICAgdGhpcy51cGRhdGVTaXppbmcoXG4gICAgICAhaXNQcm9wc0VxdWFsKHByZXZQcm9wcywgY3VycmVudFByb3BzKSxcbiAgICApXG4gIH1cblxuICBnZXRIaWdobGlnaHRTZWdzKCk6IFRhYmxlU2VnW10ge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG5cbiAgICBpZiAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgcmV0dXJuIHByb3BzLmV2ZW50RHJhZy5zZWdzIGFzIFRhYmxlU2VnW11cbiAgICB9XG5cbiAgICBpZiAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgIHJldHVybiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzIGFzIFRhYmxlU2VnW11cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3NcbiAgfVxuXG4gIGdldE1pcnJvclNlZ3MoKTogVGFibGVTZWdbXSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcblxuICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MgYXMgVGFibGVTZWdbXVxuICAgIH1cblxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcmVuZGVyRmdTZWdzKFxuICAgIGNvbDogbnVtYmVyLFxuICAgIHNlZ1BsYWNlbWVudHM6IFRhYmxlU2VnUGxhY2VtZW50W10sXG4gICAgdG9kYXlSYW5nZTogRGF0ZVJhbmdlLFxuICAgIGlzRm9yY2VkSW52aXNpYmxlOiB7IFtpbnN0YW5jZUlkOiBzdHJpbmddOiBhbnkgfSxcbiAgICBpc0RyYWdnaW5nPzogYm9vbGVhbixcbiAgICBpc1Jlc2l6aW5nPzogYm9vbGVhbixcbiAgICBpc0RhdGVTZWxlY3Rpbmc/OiBib29sZWFuLFxuICApOiBWTm9kZVtdIHtcbiAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgZXZlbnRTZWxlY3Rpb24gfSA9IHRoaXMucHJvcHNcbiAgICBsZXQgeyBmcmFtZVBvc2l0aW9ucyB9ID0gdGhpcy5zdGF0ZVxuICAgIGxldCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kID0gdGhpcy5wcm9wcy5jZWxscy5sZW5ndGggPT09IDEgLy8gY29sQ250ID09PSAxXG4gICAgbGV0IGlzTWlycm9yID0gaXNEcmFnZ2luZyB8fCBpc1Jlc2l6aW5nIHx8IGlzRGF0ZVNlbGVjdGluZ1xuICAgIGxldCBub2RlczogVk5vZGVbXSA9IFtdXG5cbiAgICBpZiAoZnJhbWVQb3NpdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IHBsYWNlbWVudCBvZiBzZWdQbGFjZW1lbnRzKSB7XG4gICAgICAgIGxldCB7IHNlZyB9ID0gcGxhY2VtZW50XG4gICAgICAgIGxldCB7IGluc3RhbmNlSWQgfSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlXG4gICAgICAgIGxldCBrZXkgPSBpbnN0YW5jZUlkICsgJzonICsgY29sXG4gICAgICAgIGxldCBpc1Zpc2libGUgPSBwbGFjZW1lbnQuaXNWaXNpYmxlICYmICFpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXVxuICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IHBsYWNlbWVudC5pc0Fic29sdXRlXG4gICAgICAgIGxldCBsZWZ0OiBDc3NEaW1WYWx1ZSA9ICcnXG4gICAgICAgIGxldCByaWdodDogQ3NzRGltVmFsdWUgPSAnJ1xuXG4gICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQuaXNSdGwpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gMFxuICAgICAgICAgICAgbGVmdCA9IGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5sYXN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5maXJzdENvbF1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IDBcbiAgICAgICAgICAgIHJpZ2h0ID0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5maXJzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmxhc3RDb2xdXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAga25vd24gYnVnOiBldmVudHMgdGhhdCBhcmUgZm9yY2UgdG8gYmUgbGlzdC1pdGVtIGJ1dCBzcGFuIG11bHRpcGxlIGRheXMgc3RpbGwgdGFrZSB1cCBzcGFjZSBpbiBsYXRlciBjb2x1bW5zXG4gICAgICAgIHRvZG86IGluIHByaW50IHZpZXcsIGZvciBtdWx0aS1kYXkgZXZlbnRzLCBkb24ndCBkaXNwbGF5IHRpdGxlIHdpdGhpbiBub24tc3RhcnQvZW5kIHNlZ3NcbiAgICAgICAgKi9cbiAgICAgICAgbm9kZXMucHVzaChcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9eydmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MnICsgKGlzQWJzb2x1dGUgPyAnIGZjLWRheWdyaWQtZXZlbnQtaGFybmVzcy1hYnMnIDogJycpfVxuICAgICAgICAgICAga2V5PXtrZXl9XG4gICAgICAgICAgICByZWY9e2lzTWlycm9yID8gbnVsbCA6IHRoaXMuc2VnSGFybmVzc1JlZnMuY3JlYXRlUmVmKGtleSl9XG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAoJycgYXMgYW55KSA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICBtYXJnaW5Ub3A6IGlzQWJzb2x1dGUgPyAnJyA6IHBsYWNlbWVudC5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgIHRvcDogaXNBYnNvbHV0ZSA/IHBsYWNlbWVudC5hYnNvbHV0ZVRvcCA6ICcnLFxuICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2hhc0xpc3RJdGVtRGlzcGxheShzZWcpID8gKFxuICAgICAgICAgICAgICA8VGFibGVMaXN0SXRlbUV2ZW50XG4gICAgICAgICAgICAgICAgc2VnPXtzZWd9XG4gICAgICAgICAgICAgICAgaXNEcmFnZ2luZz17aXNEcmFnZ2luZ31cbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkPXtpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBkZWZhdWx0RGlzcGxheUV2ZW50RW5kPXtkZWZhdWx0RGlzcGxheUV2ZW50RW5kfVxuICAgICAgICAgICAgICAgIHsuLi5nZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSl9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICA8VGFibGVCbG9ja0V2ZW50XG4gICAgICAgICAgICAgICAgc2VnPXtzZWd9XG4gICAgICAgICAgICAgICAgaXNEcmFnZ2luZz17aXNEcmFnZ2luZ31cbiAgICAgICAgICAgICAgICBpc1Jlc2l6aW5nPXtpc1Jlc2l6aW5nfVxuICAgICAgICAgICAgICAgIGlzRGF0ZVNlbGVjdGluZz17aXNEYXRlU2VsZWN0aW5nfVxuICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQ9e2luc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ9e2RlZmF1bHREaXNwbGF5RXZlbnRFbmR9XG4gICAgICAgICAgICAgICAgey4uLmdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+LFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cblxuICByZW5kZXJGaWxsU2VncyhzZWdzOiBUYWJsZVNlZ1tdLCBmaWxsVHlwZTogc3RyaW5nKTogVk5vZGUge1xuICAgIGxldCB7IGlzUnRsIH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgeyB0b2RheVJhbmdlIH0gPSB0aGlzLnByb3BzXG4gICAgbGV0IHsgZnJhbWVQb3NpdGlvbnMgfSA9IHRoaXMuc3RhdGVcbiAgICBsZXQgbm9kZXM6IFZOb2RlW10gPSBbXVxuXG4gICAgaWYgKGZyYW1lUG9zaXRpb25zKSB7XG4gICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICBsZXQgbGVmdFJpZ2h0Q3NzID0gaXNSdGwgPyB7XG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgbGVmdDogZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmxhc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmZpcnN0Q29sXSxcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHJpZ2h0OiBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF0sXG4gICAgICAgIH1cblxuICAgICAgICBub2Rlcy5wdXNoKFxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGtleT17YnVpbGRFdmVudFJhbmdlS2V5KHNlZy5ldmVudFJhbmdlKX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImZjLWRheWdyaWQtYmctaGFybmVzc1wiXG4gICAgICAgICAgICBzdHlsZT17bGVmdFJpZ2h0Q3NzfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgIDxCZ0V2ZW50IHNlZz17c2VnfSB7Li4uZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpfSAvPiA6XG4gICAgICAgICAgICAgIHJlbmRlckZpbGwoZmlsbFR5cGUpfVxuICAgICAgICAgIDwvZGl2PixcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgLi4ubm9kZXMpXG4gIH1cblxuICB1cGRhdGVTaXppbmcoaXNFeHRlcm5hbFNpemluZ0NoYW5nZSkge1xuICAgIGxldCB7IHByb3BzLCBmcmFtZUVsUmVmcyB9ID0gdGhpc1xuXG4gICAgaWYgKFxuICAgICAgIXByb3BzLmZvclByaW50ICYmXG4gICAgICBwcm9wcy5jbGllbnRXaWR0aCAhPT0gbnVsbCAvLyBwb3NpdGlvbmluZyByZWFkeT9cbiAgICApIHtcbiAgICAgIGlmIChpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XG4gICAgICAgIGxldCBmcmFtZUVscyA9IHByb3BzLmNlbGxzLm1hcCgoY2VsbCkgPT4gZnJhbWVFbFJlZnMuY3VycmVudE1hcFtjZWxsLmtleV0pXG5cbiAgICAgICAgaWYgKGZyYW1lRWxzLmxlbmd0aCkge1xuICAgICAgICAgIGxldCBvcmlnaW5FbCA9IHRoaXMucm9vdEVsUmVmLmN1cnJlbnRcblxuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyAvLyB3aWxsIHRyaWdnZXIgaXNDZWxsUG9zaXRpb25zQ2hhbmdlZC4uLlxuICAgICAgICAgICAgZnJhbWVQb3NpdGlvbnM6IG5ldyBQb3NpdGlvbkNhY2hlKFxuICAgICAgICAgICAgICBvcmlnaW5FbCxcbiAgICAgICAgICAgICAgZnJhbWVFbHMsXG4gICAgICAgICAgICAgIHRydWUsIC8vIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgbGltaXRCeUNvbnRlbnRIZWlnaHQgPSBwcm9wcy5kYXlNYXhFdmVudHMgPT09IHRydWUgfHwgcHJvcHMuZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlXG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBldmVudEluc3RhbmNlSGVpZ2h0czogdGhpcy5xdWVyeUV2ZW50SW5zdGFuY2VIZWlnaHRzKCksXG4gICAgICAgIG1heENvbnRlbnRIZWlnaHQ6IGxpbWl0QnlDb250ZW50SGVpZ2h0ID8gdGhpcy5jb21wdXRlTWF4Q29udGVudEhlaWdodCgpIDogbnVsbCxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcXVlcnlFdmVudEluc3RhbmNlSGVpZ2h0cygpIHtcbiAgICBsZXQgc2VnRWxNYXAgPSB0aGlzLnNlZ0hhcm5lc3NSZWZzLmN1cnJlbnRNYXBcbiAgICBsZXQgZXZlbnRJbnN0YW5jZUhlaWdodHM6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7fVxuXG4gICAgLy8gZ2V0IHRoZSBtYXggaGVpZ2h0IGFtb25nc3QgaW5zdGFuY2Ugc2Vnc1xuICAgIGZvciAobGV0IGtleSBpbiBzZWdFbE1hcCkge1xuICAgICAgbGV0IGhlaWdodCA9IE1hdGgucm91bmQoc2VnRWxNYXBba2V5XS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpXG4gICAgICBsZXQgaW5zdGFuY2VJZCA9IGtleS5zcGxpdCgnOicpWzBdIC8vIGRlY29uc3RydWN0IGhvdyByZW5kZXJGZ1NlZ3MgbWFrZXMgdGhlIGtleVxuICAgICAgZXZlbnRJbnN0YW5jZUhlaWdodHNbaW5zdGFuY2VJZF0gPSBNYXRoLm1heChldmVudEluc3RhbmNlSGVpZ2h0c1tpbnN0YW5jZUlkXSB8fCAwLCBoZWlnaHQpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50SW5zdGFuY2VIZWlnaHRzXG4gIH1cblxuICBjb21wdXRlTWF4Q29udGVudEhlaWdodCgpIHtcbiAgICBsZXQgZmlyc3RLZXkgPSB0aGlzLnByb3BzLmNlbGxzWzBdLmtleVxuICAgIGxldCBjZWxsRWwgPSB0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV1cbiAgICBsZXQgZmNDb250YWluZXJFbCA9IHRoaXMuZmdFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV1cblxuICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gZmNDb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgfVxuXG4gIHB1YmxpYyBnZXRDZWxsRWxzKCkge1xuICAgIGxldCBlbE1hcCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwXG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jZWxscy5tYXAoKGNlbGwpID0+IGVsTWFwW2NlbGwua2V5XSlcbiAgfVxufVxuXG5UYWJsZVJvdy5hZGRTdGF0ZUVxdWFsaXR5KHtcbiAgZXZlbnRJbnN0YW5jZUhlaWdodHM6IGlzUHJvcHNFcXVhbCxcbn0pXG5cbmZ1bmN0aW9uIGJ1aWxkTWlycm9yUGxhY2VtZW50cyhtaXJyb3JTZWdzOiBUYWJsZVNlZ1tdLCBjb2xQbGFjZW1lbnRzOiBUYWJsZVNlZ1BsYWNlbWVudFtdW10pOiBUYWJsZVNlZ1BsYWNlbWVudFtdIHtcbiAgaWYgKCFtaXJyb3JTZWdzLmxlbmd0aCkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIGxldCB0b3BzQnlJbnN0YW5jZUlkID0gYnVpbGRBYnNvbHV0ZVRvcEhhc2goY29sUGxhY2VtZW50cykgLy8gVE9ETzogY2FjaGUgdGhpcyBhdCBmaXJzdCByZW5kZXI/XG4gIHJldHVybiBtaXJyb3JTZWdzLm1hcCgoc2VnOiBUYWJsZVNlZykgPT4gKHtcbiAgICBzZWcsXG4gICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgYWJzb2x1dGVUb3A6IHRvcHNCeUluc3RhbmNlSWRbc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0sXG4gICAgbWFyZ2luVG9wOiAwLFxuICB9KSlcbn1cblxuZnVuY3Rpb24gYnVpbGRBYnNvbHV0ZVRvcEhhc2goY29sUGxhY2VtZW50czogVGFibGVTZWdQbGFjZW1lbnRbXVtdKTogeyBbaW5zdGFuY2VJZDogc3RyaW5nXTogbnVtYmVyIH0ge1xuICBsZXQgdG9wc0J5SW5zdGFuY2VJZDogeyBbaW5zdGFuY2VJZDogc3RyaW5nXTogbnVtYmVyIH0gPSB7fVxuXG4gIGZvciAobGV0IHBsYWNlbWVudHMgb2YgY29sUGxhY2VtZW50cykge1xuICAgIGZvciAobGV0IHBsYWNlbWVudCBvZiBwbGFjZW1lbnRzKSB7XG4gICAgICB0b3BzQnlJbnN0YW5jZUlkW3BsYWNlbWVudC5zZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSA9IHBsYWNlbWVudC5hYnNvbHV0ZVRvcFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b3BzQnlJbnN0YW5jZUlkXG59XG4iLCJpbXBvcnQge1xuICBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSxcbiAgVk5vZGUsXG4gIERhdGVDb21wb25lbnQsXG4gIFJlZk9iamVjdCxcbiAgQ3NzRGltVmFsdWUsXG4gIGNyZWF0ZUVsZW1lbnQsXG4gIFBvc2l0aW9uQ2FjaGUsXG4gIG1lbW9pemUsXG4gIGFkZERheXMsXG4gIFJlZk1hcCxcbiAgRGF0ZVJhbmdlLFxuICBOb3dUaW1lcixcbiAgRGF0ZU1hcmtlcixcbiAgRGF0ZVByb2ZpbGUsXG4gIEZyYWdtZW50LFxuICBIaXQsXG4gIERheVRhYmxlQ2VsbCxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBUYWJsZVNlZywgc3BsaXRTZWdzQnlSb3csIHNwbGl0SW50ZXJhY3Rpb25CeVJvdyB9IGZyb20gJy4vVGFibGVTZWcnXG5pbXBvcnQgeyBUYWJsZVJvdyB9IGZyb20gJy4vVGFibGVSb3cnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVQcm9wcyB7XG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZVxuICBjZWxsczogRGF5VGFibGVDZWxsW11bXSAvLyBjZWxscy1CWS1ST1dcbiAgcmVuZGVyUm93SW50cm8/OiAoKSA9PiBWTm9kZVxuICBjb2xHcm91cE5vZGU6IFZOb2RlXG4gIHRhYmxlTWluV2lkdGg6IENzc0RpbVZhbHVlXG4gIGV4cGFuZFJvd3M6IGJvb2xlYW5cbiAgc2hvd1dlZWtOdW1iZXJzOiBib29sZWFuXG4gIGNsaWVudFdpZHRoOiBudW1iZXIgfCBudWxsXG4gIGNsaWVudEhlaWdodDogbnVtYmVyIHwgbnVsbFxuICBidXNpbmVzc0hvdXJTZWdzOiBUYWJsZVNlZ1tdXG4gIGJnRXZlbnRTZWdzOiBUYWJsZVNlZ1tdXG4gIGZnRXZlbnRTZWdzOiBUYWJsZVNlZ1tdXG4gIGRhdGVTZWxlY3Rpb25TZWdzOiBUYWJsZVNlZ1tdXG4gIGV2ZW50U2VsZWN0aW9uOiBzdHJpbmdcbiAgZXZlbnREcmFnOiBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgZXZlbnRSZXNpemU6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBkYXlNYXhFdmVudHM6IGJvb2xlYW4gfCBudW1iZXJcbiAgZGF5TWF4RXZlbnRSb3dzOiBib29sZWFuIHwgbnVtYmVyXG4gIGhlYWRlckFsaWduRWxSZWY/OiBSZWZPYmplY3Q8SFRNTEVsZW1lbnQ+XG4gIGZvclByaW50OiBib29sZWFuXG4gIGlzSGl0Q29tYm9BbGxvd2VkPzogKGhpdDA6IEhpdCwgaGl0MTogSGl0KSA9PiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBUYWJsZSBleHRlbmRzIERhdGVDb21wb25lbnQ8VGFibGVQcm9wcz4ge1xuICBwcml2YXRlIHNwbGl0QnVzaW5lc3NIb3VyU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpXG4gIHByaXZhdGUgc3BsaXRCZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpXG4gIHByaXZhdGUgc3BsaXRGZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpXG4gIHByaXZhdGUgc3BsaXREYXRlU2VsZWN0aW9uU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpXG4gIHByaXZhdGUgc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdylcbiAgcHJpdmF0ZSBzcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlSb3cpXG4gIHByaXZhdGUgcm9vdEVsOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIHJvd1JlZnMgPSBuZXcgUmVmTWFwPFRhYmxlUm93PigpXG4gIHByaXZhdGUgcm93UG9zaXRpb25zOiBQb3NpdGlvbkNhY2hlXG4gIHByaXZhdGUgY29sUG9zaXRpb25zOiBQb3NpdGlvbkNhY2hlXG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IHsgZGF0ZVByb2ZpbGUsIGRheU1heEV2ZW50Um93cywgZGF5TWF4RXZlbnRzLCBleHBhbmRSb3dzIH0gPSBwcm9wc1xuICAgIGxldCByb3dDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGhcblxuICAgIGxldCBidXNpbmVzc0hvdXJTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCByb3dDbnQpXG4gICAgbGV0IGJnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QmdFdmVudFNlZ3MocHJvcHMuYmdFdmVudFNlZ3MsIHJvd0NudClcbiAgICBsZXQgZmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRGZ0V2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgcm93Q250KVxuICAgIGxldCBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93ID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCByb3dDbnQpXG4gICAgbGV0IGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIHJvd0NudClcbiAgICBsZXQgZXZlbnRSZXNpemVCeVJvdyA9IHRoaXMuc3BsaXRFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgcm93Q250KVxuXG4gICAgbGV0IGxpbWl0VmlhQmFsYW5jZWQgPSBkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlXG5cbiAgICAvLyBpZiByb3dzIGNhbid0IGV4cGFuZCB0byBmaWxsIGZpeGVkIGhlaWdodCwgY2FuJ3QgZG8gYmFsYW5jZWQtaGVpZ2h0IGV2ZW50IGxpbWl0XG4gICAgLy8gVE9ETzogYmVzdCBwbGFjZSB0byBub3JtYWxpemUgdGhlc2Ugb3B0aW9ucz9cbiAgICBpZiAobGltaXRWaWFCYWxhbmNlZCAmJiAhZXhwYW5kUm93cykge1xuICAgICAgbGltaXRWaWFCYWxhbmNlZCA9IGZhbHNlXG4gICAgICBkYXlNYXhFdmVudFJvd3MgPSBudWxsXG4gICAgICBkYXlNYXhFdmVudHMgPSBudWxsXG4gICAgfVxuXG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAnZmMtZGF5Z3JpZC1ib2R5JyxcbiAgICAgIGxpbWl0VmlhQmFsYW5jZWQgPyAnZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkJyA6ICdmYy1kYXlncmlkLWJvZHktdW5iYWxhbmNlZCcsIC8vIHdpbGwgYWxsIHJvdyBoZWlnaHRzIGJlIGVxdWFsP1xuICAgICAgZXhwYW5kUm93cyA/ICcnIDogJ2ZjLWRheWdyaWQtYm9keS1uYXR1cmFsJywgLy8gd2lsbCBoZWlnaHQgb2Ygb25lIHJvdyBkZXBlbmQgb24gdGhlIG90aGVycz9cbiAgICBdXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMuam9pbignICcpfVxuICAgICAgICByZWY9e3RoaXMuaGFuZGxlUm9vdEVsfVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIC8vIHRoZXNlIHByb3BzIGFyZSBpbXBvcnRhbnQgdG8gZ2l2ZSB0aGlzIHdyYXBwZXIgY29ycmVjdCBkaW1lbnNpb25zIGZvciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSBzZXQgaXQgaGVyZSwgY2FuIHdlIGF2b2lkIGdpdmluZyB0byBpbm5lciB0YWJsZXM/XG4gICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICA8Tm93VGltZXIgdW5pdD1cImRheVwiPlxuICAgICAgICAgIHsobm93RGF0ZTogRGF0ZU1hcmtlciwgdG9kYXlSYW5nZTogRGF0ZVJhbmdlKSA9PiAoXG4gICAgICAgICAgICA8RnJhZ21lbnQ+XG4gICAgICAgICAgICAgIDx0YWJsZVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZjLXNjcm9sbGdyaWQtc3luYy10YWJsZVwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBleHBhbmRSb3dzID8gcHJvcHMuY2xpZW50SGVpZ2h0IDogJycsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtwcm9wcy5jb2xHcm91cE5vZGV9XG4gICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICAge3Byb3BzLmNlbGxzLm1hcCgoY2VsbHMsIHJvdykgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8VGFibGVSb3dcbiAgICAgICAgICAgICAgICAgICAgICByZWY9e3RoaXMucm93UmVmcy5jcmVhdGVSZWYocm93KX1cbiAgICAgICAgICAgICAgICAgICAgICBrZXk9e1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gY2VsbHNbMF0uZGF0ZS50b0lTT1N0cmluZygpIC8qIGJlc3Q/IG9yIHB1dCBrZXkgb24gY2VsbD8gb3IgdXNlIGRpZmYgZm9ybWF0dGVyPyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJvdyAvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBjZWxscyAobGlrZSB3aGVuIHJlc291cmNlIHZpZXcgaXMgbG9hZGluZylcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgc2hvd0RheU51bWJlcnM9e3Jvd0NudCA+IDF9XG4gICAgICAgICAgICAgICAgICAgICAgc2hvd1dlZWtOdW1iZXJzPXtwcm9wcy5zaG93V2Vla051bWJlcnN9XG4gICAgICAgICAgICAgICAgICAgICAgdG9kYXlSYW5nZT17dG9kYXlSYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZT17ZGF0ZVByb2ZpbGV9XG4gICAgICAgICAgICAgICAgICAgICAgY2VsbHM9e2NlbGxzfVxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckludHJvPXtwcm9wcy5yZW5kZXJSb3dJbnRyb31cbiAgICAgICAgICAgICAgICAgICAgICBidXNpbmVzc0hvdXJTZWdzPXtidXNpbmVzc0hvdXJTZWdzQnlSb3dbcm93XX1cbiAgICAgICAgICAgICAgICAgICAgICBldmVudFNlbGVjdGlvbj17cHJvcHMuZXZlbnRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgICAgICAgYmdFdmVudFNlZ3M9e2JnRXZlbnRTZWdzQnlSb3dbcm93XS5maWx0ZXIoaXNTZWdBbGxEYXkpIC8qIGhhY2sgKi99XG4gICAgICAgICAgICAgICAgICAgICAgZmdFdmVudFNlZ3M9e2ZnRXZlbnRTZWdzQnlSb3dbcm93XX1cbiAgICAgICAgICAgICAgICAgICAgICBkYXRlU2VsZWN0aW9uU2Vncz17ZGF0ZVNlbGVjdGlvblNlZ3NCeVJvd1tyb3ddfVxuICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RHJhZz17ZXZlbnREcmFnQnlSb3dbcm93XX1cbiAgICAgICAgICAgICAgICAgICAgICBldmVudFJlc2l6ZT17ZXZlbnRSZXNpemVCeVJvd1tyb3ddfVxuICAgICAgICAgICAgICAgICAgICAgIGRheU1heEV2ZW50cz17ZGF5TWF4RXZlbnRzfVxuICAgICAgICAgICAgICAgICAgICAgIGRheU1heEV2ZW50Um93cz17ZGF5TWF4RXZlbnRSb3dzfVxuICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFdpZHRoPXtwcm9wcy5jbGllbnRXaWR0aH1cbiAgICAgICAgICAgICAgICAgICAgICBjbGllbnRIZWlnaHQ9e3Byb3BzLmNsaWVudEhlaWdodH1cbiAgICAgICAgICAgICAgICAgICAgICBmb3JQcmludD17cHJvcHMuZm9yUHJpbnR9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgPC9GcmFnbWVudD5cbiAgICAgICAgICApfVxuICAgICAgICA8L05vd1RpbWVyPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgaGFuZGxlUm9vdEVsID0gKHJvb3RFbDogSFRNTEVsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgdGhpcy5yb290RWwgPSByb290RWxcblxuICAgIGlmIChyb290RWwpIHtcbiAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcbiAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IHRoaXMucHJvcHMuaXNIaXRDb21ib0FsbG93ZWQsXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpXG4gICAgfVxuICB9XG5cbiAgLy8gSGl0IFN5c3RlbVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgcHJlcGFyZUhpdHMoKSB7XG4gICAgdGhpcy5yb3dQb3NpdGlvbnMgPSBuZXcgUG9zaXRpb25DYWNoZShcbiAgICAgIHRoaXMucm9vdEVsLFxuICAgICAgdGhpcy5yb3dSZWZzLmNvbGxlY3QoKS5tYXAoKHJvd09iaikgPT4gcm93T2JqLmdldENlbGxFbHMoKVswXSksIC8vIGZpcnN0IGNlbGwgZWwgaW4gZWFjaCByb3cuIFRPRE86IG5vdCBvcHRpbWFsXG4gICAgICBmYWxzZSxcbiAgICAgIHRydWUsIC8vIHZlcnRpY2FsXG4gICAgKVxuXG4gICAgdGhpcy5jb2xQb3NpdGlvbnMgPSBuZXcgUG9zaXRpb25DYWNoZShcbiAgICAgIHRoaXMucm9vdEVsLFxuICAgICAgdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbMF0uZ2V0Q2VsbEVscygpLCAvLyBjZWxsIGVscyBpbiBmaXJzdCByb3dcbiAgICAgIHRydWUsIC8vIGhvcml6b250YWxcbiAgICAgIGZhbHNlLFxuICAgIClcbiAgfVxuXG4gIHF1ZXJ5SGl0KHBvc2l0aW9uTGVmdDogbnVtYmVyLCBwb3NpdGlvblRvcDogbnVtYmVyKTogSGl0IHtcbiAgICBsZXQgeyBjb2xQb3NpdGlvbnMsIHJvd1Bvc2l0aW9ucyB9ID0gdGhpc1xuICAgIGxldCBjb2wgPSBjb2xQb3NpdGlvbnMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KVxuICAgIGxldCByb3cgPSByb3dQb3NpdGlvbnMudG9wVG9JbmRleChwb3NpdGlvblRvcClcblxuICAgIGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xuICAgICAgbGV0IGNlbGwgPSB0aGlzLnByb3BzLmNlbGxzW3Jvd11bY29sXVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRlUHJvZmlsZTogdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgZGF0ZVNwYW46IHtcbiAgICAgICAgICByYW5nZTogdGhpcy5nZXRDZWxsUmFuZ2Uocm93LCBjb2wpLFxuICAgICAgICAgIGFsbERheTogdHJ1ZSxcbiAgICAgICAgICAuLi5jZWxsLmV4dHJhRGF0ZVNwYW4sXG4gICAgICAgIH0sXG4gICAgICAgIGRheUVsOiB0aGlzLmdldENlbGxFbChyb3csIGNvbCksXG4gICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICBsZWZ0OiBjb2xQb3NpdGlvbnMubGVmdHNbY29sXSxcbiAgICAgICAgICByaWdodDogY29sUG9zaXRpb25zLnJpZ2h0c1tjb2xdLFxuICAgICAgICAgIHRvcDogcm93UG9zaXRpb25zLnRvcHNbcm93XSxcbiAgICAgICAgICBib3R0b206IHJvd1Bvc2l0aW9ucy5ib3R0b21zW3Jvd10sXG4gICAgICAgIH0sXG4gICAgICAgIGxheWVyOiAwLFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBwcml2YXRlIGdldENlbGxFbChyb3csIGNvbCkge1xuICAgIHJldHVybiB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFtyb3ddLmdldENlbGxFbHMoKVtjb2xdIC8vIFRPRE86IG5vdCBvcHRpbWFsXG4gIH1cblxuICBwcml2YXRlIGdldENlbGxSYW5nZShyb3csIGNvbCkge1xuICAgIGxldCBzdGFydCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdLmRhdGVcbiAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgMSlcbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NlZ0FsbERheShzZWc6IFRhYmxlU2VnKSB7XG4gIHJldHVybiBzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5XG59XG4iLCJpbXBvcnQgeyBEYXlUYWJsZU1vZGVsLCBEYXRlUmFuZ2UsIFNsaWNlciB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgVGFibGVTZWcgfSBmcm9tICcuL1RhYmxlU2VnJ1xuXG5leHBvcnQgY2xhc3MgRGF5VGFibGVTbGljZXIgZXh0ZW5kcyBTbGljZXI8VGFibGVTZWcsIFtEYXlUYWJsZU1vZGVsXT4ge1xuICBmb3JjZURheUlmTGlzdEl0ZW0gPSB0cnVlXG5cbiAgc2xpY2VSYW5nZShkYXRlUmFuZ2U6IERhdGVSYW5nZSwgZGF5VGFibGVNb2RlbDogRGF5VGFibGVNb2RlbCk6IFRhYmxlU2VnW10ge1xuICAgIHJldHVybiBkYXlUYWJsZU1vZGVsLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlKVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBjcmVhdGVFbGVtZW50LCBjcmVhdGVSZWYsIFZOb2RlLFxuICBFdmVudFN0b3JlLFxuICBFdmVudFVpSGFzaCxcbiAgRGF0ZVNwYW4sXG4gIEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSxcbiAgRGF5VGFibGVNb2RlbCxcbiAgRHVyYXRpb24sXG4gIERhdGVDb21wb25lbnQsXG4gIFZpZXdDb250ZXh0LFxuICBSZWZPYmplY3QsXG4gIENzc0RpbVZhbHVlLFxuICBEYXRlUHJvZmlsZSxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBUYWJsZSB9IGZyb20gJy4vVGFibGUnXG5pbXBvcnQgeyBEYXlUYWJsZVNsaWNlciB9IGZyb20gJy4vRGF5VGFibGVTbGljZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5VGFibGVQcm9wcyB7XG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSxcbiAgZGF5VGFibGVNb2RlbDogRGF5VGFibGVNb2RlbFxuICBuZXh0RGF5VGhyZXNob2xkOiBEdXJhdGlvblxuICBidXNpbmVzc0hvdXJzOiBFdmVudFN0b3JlXG4gIGV2ZW50U3RvcmU6IEV2ZW50U3RvcmVcbiAgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaFxuICBkYXRlU2VsZWN0aW9uOiBEYXRlU3BhbiB8IG51bGxcbiAgZXZlbnRTZWxlY3Rpb246IHN0cmluZ1xuICBldmVudERyYWc6IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgZXZlbnRSZXNpemU6IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgY29sR3JvdXBOb2RlOiBWTm9kZVxuICB0YWJsZU1pbldpZHRoOiBDc3NEaW1WYWx1ZVxuICByZW5kZXJSb3dJbnRybz86ICgpID0+IFZOb2RlXG4gIGRheU1heEV2ZW50czogYm9vbGVhbiB8IG51bWJlclxuICBkYXlNYXhFdmVudFJvd3M6IGJvb2xlYW4gfCBudW1iZXJcbiAgZXhwYW5kUm93czogYm9vbGVhblxuICBzaG93V2Vla051bWJlcnM6IGJvb2xlYW5cbiAgaGVhZGVyQWxpZ25FbFJlZj86IFJlZk9iamVjdDxIVE1MRWxlbWVudD4gLy8gZm9yIG1vcmUgcG9wb3ZlciBhbGlnbm1lbnRcbiAgY2xpZW50V2lkdGg6IG51bWJlciB8IG51bGxcbiAgY2xpZW50SGVpZ2h0OiBudW1iZXIgfCBudWxsXG4gIGZvclByaW50OiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBEYXlUYWJsZSBleHRlbmRzIERhdGVDb21wb25lbnQ8RGF5VGFibGVQcm9wcywgVmlld0NvbnRleHQ+IHtcbiAgcHJpdmF0ZSBzbGljZXIgPSBuZXcgRGF5VGFibGVTbGljZXIoKVxuICBwcml2YXRlIHRhYmxlUmVmID0gY3JlYXRlUmVmPFRhYmxlPigpXG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFRhYmxlXG4gICAgICAgIHJlZj17dGhpcy50YWJsZVJlZn1cbiAgICAgICAgey4uLnRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5uZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCBwcm9wcy5kYXlUYWJsZU1vZGVsKX1cbiAgICAgICAgZGF0ZVByb2ZpbGU9e3Byb3BzLmRhdGVQcm9maWxlfVxuICAgICAgICBjZWxscz17cHJvcHMuZGF5VGFibGVNb2RlbC5jZWxsc31cbiAgICAgICAgY29sR3JvdXBOb2RlPXtwcm9wcy5jb2xHcm91cE5vZGV9XG4gICAgICAgIHRhYmxlTWluV2lkdGg9e3Byb3BzLnRhYmxlTWluV2lkdGh9XG4gICAgICAgIHJlbmRlclJvd0ludHJvPXtwcm9wcy5yZW5kZXJSb3dJbnRyb31cbiAgICAgICAgZGF5TWF4RXZlbnRzPXtwcm9wcy5kYXlNYXhFdmVudHN9XG4gICAgICAgIGRheU1heEV2ZW50Um93cz17cHJvcHMuZGF5TWF4RXZlbnRSb3dzfVxuICAgICAgICBzaG93V2Vla051bWJlcnM9e3Byb3BzLnNob3dXZWVrTnVtYmVyc31cbiAgICAgICAgZXhwYW5kUm93cz17cHJvcHMuZXhwYW5kUm93c31cbiAgICAgICAgaGVhZGVyQWxpZ25FbFJlZj17cHJvcHMuaGVhZGVyQWxpZ25FbFJlZn1cbiAgICAgICAgY2xpZW50V2lkdGg9e3Byb3BzLmNsaWVudFdpZHRofVxuICAgICAgICBjbGllbnRIZWlnaHQ9e3Byb3BzLmNsaWVudEhlaWdodH1cbiAgICAgICAgZm9yUHJpbnQ9e3Byb3BzLmZvclByaW50fVxuICAgICAgLz5cbiAgICApXG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQsIGNyZWF0ZVJlZixcbiAgRGF5SGVhZGVyLFxuICBEYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgRGF0ZVByb2ZpbGUsXG4gIG1lbW9pemUsXG4gIERheVNlcmllc01vZGVsLFxuICBEYXlUYWJsZU1vZGVsLFxuICBDaHVua0NvbnRlbnRDYWxsYmFja0FyZ3MsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgVGFibGVWaWV3IH0gZnJvbSAnLi9UYWJsZVZpZXcnXG5pbXBvcnQgeyBEYXlUYWJsZSB9IGZyb20gJy4vRGF5VGFibGUnXG5cbmV4cG9ydCBjbGFzcyBEYXlUYWJsZVZpZXcgZXh0ZW5kcyBUYWJsZVZpZXcge1xuICBwcml2YXRlIGJ1aWxkRGF5VGFibGVNb2RlbCA9IG1lbW9pemUoYnVpbGREYXlUYWJsZU1vZGVsKVxuICBwcml2YXRlIGhlYWRlclJlZiA9IGNyZWF0ZVJlZjxEYXlIZWFkZXI+KClcbiAgcHJpdmF0ZSB0YWJsZVJlZiA9IGNyZWF0ZVJlZjxEYXlUYWJsZT4oKVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBvcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgZGF5VGFibGVNb2RlbCA9IHRoaXMuYnVpbGREYXlUYWJsZU1vZGVsKHByb3BzLmRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcilcblxuICAgIGxldCBoZWFkZXJDb250ZW50ID0gb3B0aW9ucy5kYXlIZWFkZXJzICYmIChcbiAgICAgIDxEYXlIZWFkZXJcbiAgICAgICAgcmVmPXt0aGlzLmhlYWRlclJlZn1cbiAgICAgICAgZGF0ZVByb2ZpbGU9e3Byb3BzLmRhdGVQcm9maWxlfVxuICAgICAgICBkYXRlcz17ZGF5VGFibGVNb2RlbC5oZWFkZXJEYXRlc31cbiAgICAgICAgZGF0ZXNSZXBEaXN0aW5jdERheXM9e2RheVRhYmxlTW9kZWwucm93Q250ID09PSAxfVxuICAgICAgLz5cbiAgICApXG5cbiAgICBsZXQgYm9keUNvbnRlbnQgPSAoY29udGVudEFyZzogQ2h1bmtDb250ZW50Q2FsbGJhY2tBcmdzKSA9PiAoXG4gICAgICA8RGF5VGFibGVcbiAgICAgICAgcmVmPXt0aGlzLnRhYmxlUmVmfVxuICAgICAgICBkYXRlUHJvZmlsZT17cHJvcHMuZGF0ZVByb2ZpbGV9XG4gICAgICAgIGRheVRhYmxlTW9kZWw9e2RheVRhYmxlTW9kZWx9XG4gICAgICAgIGJ1c2luZXNzSG91cnM9e3Byb3BzLmJ1c2luZXNzSG91cnN9XG4gICAgICAgIGRhdGVTZWxlY3Rpb249e3Byb3BzLmRhdGVTZWxlY3Rpb259XG4gICAgICAgIGV2ZW50U3RvcmU9e3Byb3BzLmV2ZW50U3RvcmV9XG4gICAgICAgIGV2ZW50VWlCYXNlcz17cHJvcHMuZXZlbnRVaUJhc2VzfVxuICAgICAgICBldmVudFNlbGVjdGlvbj17cHJvcHMuZXZlbnRTZWxlY3Rpb259XG4gICAgICAgIGV2ZW50RHJhZz17cHJvcHMuZXZlbnREcmFnfVxuICAgICAgICBldmVudFJlc2l6ZT17cHJvcHMuZXZlbnRSZXNpemV9XG4gICAgICAgIG5leHREYXlUaHJlc2hvbGQ9e29wdGlvbnMubmV4dERheVRocmVzaG9sZH1cbiAgICAgICAgY29sR3JvdXBOb2RlPXtjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlfVxuICAgICAgICB0YWJsZU1pbldpZHRoPXtjb250ZW50QXJnLnRhYmxlTWluV2lkdGh9XG4gICAgICAgIGRheU1heEV2ZW50cz17b3B0aW9ucy5kYXlNYXhFdmVudHN9XG4gICAgICAgIGRheU1heEV2ZW50Um93cz17b3B0aW9ucy5kYXlNYXhFdmVudFJvd3N9XG4gICAgICAgIHNob3dXZWVrTnVtYmVycz17b3B0aW9ucy53ZWVrTnVtYmVyc31cbiAgICAgICAgZXhwYW5kUm93cz17IXByb3BzLmlzSGVpZ2h0QXV0b31cbiAgICAgICAgaGVhZGVyQWxpZ25FbFJlZj17dGhpcy5oZWFkZXJFbFJlZn1cbiAgICAgICAgY2xpZW50V2lkdGg9e2NvbnRlbnRBcmcuY2xpZW50V2lkdGh9XG4gICAgICAgIGNsaWVudEhlaWdodD17Y29udGVudEFyZy5jbGllbnRIZWlnaHR9XG4gICAgICAgIGZvclByaW50PXtwcm9wcy5mb3JQcmludH1cbiAgICAgIC8+XG4gICAgKVxuXG4gICAgcmV0dXJuIG9wdGlvbnMuZGF5TWluV2lkdGhcbiAgICAgID8gdGhpcy5yZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlckNvbnRlbnQsIGJvZHlDb250ZW50LCBkYXlUYWJsZU1vZGVsLmNvbENudCwgb3B0aW9ucy5kYXlNaW5XaWR0aClcbiAgICAgIDogdGhpcy5yZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyQ29udGVudCwgYm9keUNvbnRlbnQpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRGF5VGFibGVNb2RlbChkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yOiBEYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICBsZXQgZGF5U2VyaWVzID0gbmV3IERheVNlcmllc01vZGVsKGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcilcblxuICByZXR1cm4gbmV3IERheVRhYmxlTW9kZWwoXG4gICAgZGF5U2VyaWVzLFxuICAgIC95ZWFyfG1vbnRofHdlZWsvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksXG4gIClcbn1cbiIsImltcG9ydCB7XG4gIERhdGVQcm9maWxlR2VuZXJhdG9yLFxuICBhZGRXZWVrcywgZGlmZldlZWtzLFxuICBEYXRlUmFuZ2UsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuXG5leHBvcnQgY2xhc3MgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciBleHRlbmRzIERhdGVQcm9maWxlR2VuZXJhdG9yIHtcbiAgLy8gQ29tcHV0ZXMgdGhlIGRhdGUgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlbmRlcmVkLlxuICBidWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk6IERhdGVSYW5nZSB7XG4gICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCByZW5kZXJSYW5nZSA9IHN1cGVyLmJ1aWxkUmVuZGVyUmFuZ2UoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KVxuICAgIGxldCBzdGFydCA9IHJlbmRlclJhbmdlLnN0YXJ0XG4gICAgbGV0IGVuZCA9IHJlbmRlclJhbmdlLmVuZFxuICAgIGxldCBlbmRPZldlZWtcblxuICAgIC8vIHllYXIgYW5kIG1vbnRoIHZpZXdzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggd2Vla3MuIHRoaXMgaXMgYWxyZWFkeSBkb25lIGZvciB3ZWVrXG4gICAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChjdXJyZW50UmFuZ2VVbml0KSkge1xuICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKHN0YXJ0KVxuXG4gICAgICAvLyBtYWtlIGVuZC1vZi13ZWVrIGlmIG5vdCBhbHJlYWR5XG4gICAgICBlbmRPZldlZWsgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKGVuZClcbiAgICAgIGlmIChlbmRPZldlZWsudmFsdWVPZigpICE9PSBlbmQudmFsdWVPZigpKSB7XG4gICAgICAgIGVuZCA9IGFkZFdlZWtzKGVuZE9mV2VlaywgMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgNiB3ZWVrc1xuICAgIGlmIChcbiAgICAgIHRoaXMucHJvcHMubW9udGhNb2RlICYmXG4gICAgICB0aGlzLnByb3BzLmZpeGVkV2Vla0NvdW50XG4gICAgKSB7XG4gICAgICBsZXQgcm93Q250ID0gTWF0aC5jZWlsKCAvLyBjb3VsZCBiZSBwYXJ0aWFsIHdlZWtzIGR1ZSB0byBoaWRkZW5EYXlzXG4gICAgICAgIGRpZmZXZWVrcyhzdGFydCwgZW5kKSxcbiAgICAgIClcbiAgICAgIGVuZCA9IGFkZFdlZWtzKGVuZCwgNiAtIHJvd0NudClcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBEYXlUYWJsZVZpZXcgfSBmcm9tICcuL0RheVRhYmxlVmlldydcbmltcG9ydCB7IFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSBmcm9tICcuL1RhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgJy4vbWFpbi5jc3MnXG5cbmV4cG9ydCB7IERheVRhYmxlIH0gZnJvbSAnLi9EYXlUYWJsZSdcbmV4cG9ydCB7IERheVRhYmxlU2xpY2VyIH0gZnJvbSAnLi9EYXlUYWJsZVNsaWNlcidcbmV4cG9ydCB7IFRhYmxlIH0gZnJvbSAnLi9UYWJsZSdcbmV4cG9ydCB7IFRhYmxlU2VnIH0gZnJvbSAnLi9UYWJsZVNlZydcbmV4cG9ydCB7IFRhYmxlVmlldyB9IGZyb20gJy4vVGFibGVWaWV3J1xuZXhwb3J0IHsgYnVpbGREYXlUYWJsZU1vZGVsIH0gZnJvbSAnLi9EYXlUYWJsZVZpZXcnXG5leHBvcnQgeyBEYXlUYWJsZVZpZXcgYXMgRGF5R3JpZFZpZXcgfSAvLyBleHBvcnQgYXMgb2xkIG5hbWUhXG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVBsdWdpbih7XG4gIGluaXRpYWxWaWV3OiAnZGF5R3JpZE1vbnRoJyxcbiAgdmlld3M6IHtcblxuICAgIGRheUdyaWQ6IHtcbiAgICAgIGNvbXBvbmVudDogRGF5VGFibGVWaWV3LFxuICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgICB9LFxuXG4gICAgZGF5R3JpZERheToge1xuICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxuICAgIH0sXG5cbiAgICBkYXlHcmlkV2Vlazoge1xuICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcbiAgICB9LFxuXG4gICAgZGF5R3JpZE1vbnRoOiB7XG4gICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICBkdXJhdGlvbjogeyBtb250aHM6IDEgfSxcbiAgICAgIG1vbnRoTW9kZTogdHJ1ZSxcbiAgICAgIGZpeGVkV2Vla0NvdW50OiB0cnVlLFxuICAgIH0sXG5cbiAgfSxcbn0pXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/daygrid/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/interaction/main.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/interaction/main.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"Draggable\": () => (/* binding */ ExternalDraggable),\n/* harmony export */   \"FeaturefulElementDragging\": () => (/* binding */ FeaturefulElementDragging),\n/* harmony export */   \"PointerDragging\": () => (/* binding */ PointerDragging),\n/* harmony export */   \"ThirdPartyDraggable\": () => (/* binding */ ThirdPartyDraggable)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/*!\nFullCalendar v5.9.0\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.touchMouseIgnoreWait = 500;\nvar ignoreMouseDepth = 0;\nvar listenerCnt = 0;\nvar isWindowTouchMoveCancelled = false;\n/*\nUses a \"pointer\" abstraction, which monitors UI events for both mouse and touch.\nTracks when the pointer \"drags\" on a certain element, meaning down+move+up.\n\nAlso, tracks if there was touch-scrolling.\nAlso, can prevent touch-scrolling from happening.\nAlso, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.\n\nemits:\n- pointerdown\n- pointermove\n- pointerup\n*/\n\nvar PointerDragging = function () {\n  function PointerDragging(containerEl) {\n    var _this = this;\n\n    this.subjectEl = null; // options that can be directly assigned by caller\n\n    this.selector = ''; // will cause subjectEl in all emitted events to be this element\n\n    this.handleSelector = '';\n    this.shouldIgnoreMove = false;\n    this.shouldWatchScroll = true; // for simulating pointermove on scroll\n    // internal states\n\n    this.isDragging = false;\n    this.isTouchDragging = false;\n    this.wasTouchScroll = false; // Mouse\n    // ----------------------------------------------------------------------------------------------------\n\n    this.handleMouseDown = function (ev) {\n      if (!_this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && _this.tryStart(ev)) {\n        var pev = _this.createEventFromMouse(ev, true);\n\n        _this.emitter.trigger('pointerdown', pev);\n\n        _this.initScrollWatch(pev);\n\n        if (!_this.shouldIgnoreMove) {\n          document.addEventListener('mousemove', _this.handleMouseMove);\n        }\n\n        document.addEventListener('mouseup', _this.handleMouseUp);\n      }\n    };\n\n    this.handleMouseMove = function (ev) {\n      var pev = _this.createEventFromMouse(ev);\n\n      _this.recordCoords(pev);\n\n      _this.emitter.trigger('pointermove', pev);\n    };\n\n    this.handleMouseUp = function (ev) {\n      document.removeEventListener('mousemove', _this.handleMouseMove);\n      document.removeEventListener('mouseup', _this.handleMouseUp);\n\n      _this.emitter.trigger('pointerup', _this.createEventFromMouse(ev));\n\n      _this.cleanup(); // call last so that pointerup has access to props\n\n    }; // Touch\n    // ----------------------------------------------------------------------------------------------------\n\n\n    this.handleTouchStart = function (ev) {\n      if (_this.tryStart(ev)) {\n        _this.isTouchDragging = true;\n\n        var pev = _this.createEventFromTouch(ev, true);\n\n        _this.emitter.trigger('pointerdown', pev);\n\n        _this.initScrollWatch(pev); // unlike mouse, need to attach to target, not document\n        // https://stackoverflow.com/a/45760014\n\n\n        var targetEl = ev.target;\n\n        if (!_this.shouldIgnoreMove) {\n          targetEl.addEventListener('touchmove', _this.handleTouchMove);\n        }\n\n        targetEl.addEventListener('touchend', _this.handleTouchEnd);\n        targetEl.addEventListener('touchcancel', _this.handleTouchEnd); // treat it as a touch end\n        // attach a handler to get called when ANY scroll action happens on the page.\n        // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n        // http://stackoverflow.com/a/32954565/96342\n\n        window.addEventListener('scroll', _this.handleTouchScroll, true);\n      }\n    };\n\n    this.handleTouchMove = function (ev) {\n      var pev = _this.createEventFromTouch(ev);\n\n      _this.recordCoords(pev);\n\n      _this.emitter.trigger('pointermove', pev);\n    };\n\n    this.handleTouchEnd = function (ev) {\n      if (_this.isDragging) {\n        // done to guard against touchend followed by touchcancel\n        var targetEl = ev.target;\n        targetEl.removeEventListener('touchmove', _this.handleTouchMove);\n        targetEl.removeEventListener('touchend', _this.handleTouchEnd);\n        targetEl.removeEventListener('touchcancel', _this.handleTouchEnd);\n        window.removeEventListener('scroll', _this.handleTouchScroll, true); // useCaptured=true\n\n        _this.emitter.trigger('pointerup', _this.createEventFromTouch(ev));\n\n        _this.cleanup(); // call last so that pointerup has access to props\n\n\n        _this.isTouchDragging = false;\n        startIgnoringMouse();\n      }\n    };\n\n    this.handleTouchScroll = function () {\n      _this.wasTouchScroll = true;\n    };\n\n    this.handleScroll = function (ev) {\n      if (!_this.shouldIgnoreMove) {\n        var pageX = window.pageXOffset - _this.prevScrollX + _this.prevPageX;\n        var pageY = window.pageYOffset - _this.prevScrollY + _this.prevPageY;\n\n        _this.emitter.trigger('pointermove', {\n          origEvent: ev,\n          isTouch: _this.isTouchDragging,\n          subjectEl: _this.subjectEl,\n          pageX: pageX,\n          pageY: pageY,\n          deltaX: pageX - _this.origPageX,\n          deltaY: pageY - _this.origPageY\n        });\n      }\n    };\n\n    this.containerEl = containerEl;\n    this.emitter = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Emitter();\n    containerEl.addEventListener('mousedown', this.handleMouseDown);\n    containerEl.addEventListener('touchstart', this.handleTouchStart, {\n      passive: true\n    });\n    listenerCreated();\n  }\n\n  PointerDragging.prototype.destroy = function () {\n    this.containerEl.removeEventListener('mousedown', this.handleMouseDown);\n    this.containerEl.removeEventListener('touchstart', this.handleTouchStart, {\n      passive: true\n    });\n    listenerDestroyed();\n  };\n\n  PointerDragging.prototype.tryStart = function (ev) {\n    var subjectEl = this.querySubjectEl(ev);\n    var downEl = ev.target;\n\n    if (subjectEl && (!this.handleSelector || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(downEl, this.handleSelector))) {\n      this.subjectEl = subjectEl;\n      this.isDragging = true; // do this first so cancelTouchScroll will work\n\n      this.wasTouchScroll = false;\n      return true;\n    }\n\n    return false;\n  };\n\n  PointerDragging.prototype.cleanup = function () {\n    isWindowTouchMoveCancelled = false;\n    this.isDragging = false;\n    this.subjectEl = null; // keep wasTouchScroll around for later access\n\n    this.destroyScrollWatch();\n  };\n\n  PointerDragging.prototype.querySubjectEl = function (ev) {\n    if (this.selector) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(ev.target, this.selector);\n    }\n\n    return this.containerEl;\n  };\n\n  PointerDragging.prototype.shouldIgnoreMouse = function () {\n    return ignoreMouseDepth || this.isTouchDragging;\n  }; // can be called by user of this class, to cancel touch-based scrolling for the current drag\n\n\n  PointerDragging.prototype.cancelTouchScroll = function () {\n    if (this.isDragging) {\n      isWindowTouchMoveCancelled = true;\n    }\n  }; // Scrolling that simulates pointermoves\n  // ----------------------------------------------------------------------------------------------------\n\n\n  PointerDragging.prototype.initScrollWatch = function (ev) {\n    if (this.shouldWatchScroll) {\n      this.recordCoords(ev);\n      window.addEventListener('scroll', this.handleScroll, true); // useCapture=true\n    }\n  };\n\n  PointerDragging.prototype.recordCoords = function (ev) {\n    if (this.shouldWatchScroll) {\n      this.prevPageX = ev.pageX;\n      this.prevPageY = ev.pageY;\n      this.prevScrollX = window.pageXOffset;\n      this.prevScrollY = window.pageYOffset;\n    }\n  };\n\n  PointerDragging.prototype.destroyScrollWatch = function () {\n    if (this.shouldWatchScroll) {\n      window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true\n    }\n  }; // Event Normalization\n  // ----------------------------------------------------------------------------------------------------\n\n\n  PointerDragging.prototype.createEventFromMouse = function (ev, isFirst) {\n    var deltaX = 0;\n    var deltaY = 0; // TODO: repeat code\n\n    if (isFirst) {\n      this.origPageX = ev.pageX;\n      this.origPageY = ev.pageY;\n    } else {\n      deltaX = ev.pageX - this.origPageX;\n      deltaY = ev.pageY - this.origPageY;\n    }\n\n    return {\n      origEvent: ev,\n      isTouch: false,\n      subjectEl: this.subjectEl,\n      pageX: ev.pageX,\n      pageY: ev.pageY,\n      deltaX: deltaX,\n      deltaY: deltaY\n    };\n  };\n\n  PointerDragging.prototype.createEventFromTouch = function (ev, isFirst) {\n    var touches = ev.touches;\n    var pageX;\n    var pageY;\n    var deltaX = 0;\n    var deltaY = 0; // if touch coords available, prefer,\n    // because FF would give bad ev.pageX ev.pageY\n\n    if (touches && touches.length) {\n      pageX = touches[0].pageX;\n      pageY = touches[0].pageY;\n    } else {\n      pageX = ev.pageX;\n      pageY = ev.pageY;\n    } // TODO: repeat code\n\n\n    if (isFirst) {\n      this.origPageX = pageX;\n      this.origPageY = pageY;\n    } else {\n      deltaX = pageX - this.origPageX;\n      deltaY = pageY - this.origPageY;\n    }\n\n    return {\n      origEvent: ev,\n      isTouch: true,\n      subjectEl: this.subjectEl,\n      pageX: pageX,\n      pageY: pageY,\n      deltaX: deltaX,\n      deltaY: deltaY\n    };\n  };\n\n  return PointerDragging;\n}(); // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\n\n\nfunction isPrimaryMouseButton(ev) {\n  return ev.button === 0 && !ev.ctrlKey;\n} // Ignoring fake mouse events generated by touch\n// ----------------------------------------------------------------------------------------------------\n\n\nfunction startIgnoringMouse() {\n  ignoreMouseDepth += 1;\n  setTimeout(function () {\n    ignoreMouseDepth -= 1;\n  }, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.touchMouseIgnoreWait);\n} // We want to attach touchmove as early as possible for Safari\n// ----------------------------------------------------------------------------------------------------\n\n\nfunction listenerCreated() {\n  listenerCnt += 1;\n\n  if (listenerCnt === 1) {\n    window.addEventListener('touchmove', onWindowTouchMove, {\n      passive: false\n    });\n  }\n}\n\nfunction listenerDestroyed() {\n  listenerCnt -= 1;\n\n  if (!listenerCnt) {\n    window.removeEventListener('touchmove', onWindowTouchMove, {\n      passive: false\n    });\n  }\n}\n\nfunction onWindowTouchMove(ev) {\n  if (isWindowTouchMoveCancelled) {\n    ev.preventDefault();\n  }\n}\n/*\nAn effect in which an element follows the movement of a pointer across the screen.\nThe moving element is a clone of some other element.\nMust call start + handleMove + stop.\n*/\n\n\nvar ElementMirror = function () {\n  function ElementMirror() {\n    this.isVisible = false; // must be explicitly enabled\n\n    this.sourceEl = null;\n    this.mirrorEl = null;\n    this.sourceElRect = null; // screen coords relative to viewport\n    // options that can be set directly by caller\n\n    this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues\n\n    this.zIndex = 9999;\n    this.revertDuration = 0;\n  }\n\n  ElementMirror.prototype.start = function (sourceEl, pageX, pageY) {\n    this.sourceEl = sourceEl;\n    this.sourceElRect = this.sourceEl.getBoundingClientRect();\n    this.origScreenX = pageX - window.pageXOffset;\n    this.origScreenY = pageY - window.pageYOffset;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.updateElPosition();\n  };\n\n  ElementMirror.prototype.handleMove = function (pageX, pageY) {\n    this.deltaX = pageX - window.pageXOffset - this.origScreenX;\n    this.deltaY = pageY - window.pageYOffset - this.origScreenY;\n    this.updateElPosition();\n  }; // can be called before start\n\n\n  ElementMirror.prototype.setIsVisible = function (bool) {\n    if (bool) {\n      if (!this.isVisible) {\n        if (this.mirrorEl) {\n          this.mirrorEl.style.display = '';\n        }\n\n        this.isVisible = bool; // needs to happen before updateElPosition\n\n        this.updateElPosition(); // because was not updating the position while invisible\n      }\n    } else if (this.isVisible) {\n      if (this.mirrorEl) {\n        this.mirrorEl.style.display = 'none';\n      }\n\n      this.isVisible = bool;\n    }\n  }; // always async\n\n\n  ElementMirror.prototype.stop = function (needsRevertAnimation, callback) {\n    var _this = this;\n\n    var done = function () {\n      _this.cleanup();\n\n      callback();\n    };\n\n    if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && (this.deltaX || this.deltaY) // if same coords, transition won't work\n    ) {\n      this.doRevertAnimation(done, this.revertDuration);\n    } else {\n      setTimeout(done, 0);\n    }\n  };\n\n  ElementMirror.prototype.doRevertAnimation = function (callback, revertDuration) {\n    var mirrorEl = this.mirrorEl;\n    var finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened\n\n    mirrorEl.style.transition = 'top ' + revertDuration + 'ms,' + 'left ' + revertDuration + 'ms';\n    (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyStyle)(mirrorEl, {\n      left: finalSourceElRect.left,\n      top: finalSourceElRect.top\n    });\n    (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.whenTransitionDone)(mirrorEl, function () {\n      mirrorEl.style.transition = '';\n      callback();\n    });\n  };\n\n  ElementMirror.prototype.cleanup = function () {\n    if (this.mirrorEl) {\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.removeElement)(this.mirrorEl);\n      this.mirrorEl = null;\n    }\n\n    this.sourceEl = null;\n  };\n\n  ElementMirror.prototype.updateElPosition = function () {\n    if (this.sourceEl && this.isVisible) {\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyStyle)(this.getMirrorEl(), {\n        left: this.sourceElRect.left + this.deltaX,\n        top: this.sourceElRect.top + this.deltaY\n      });\n    }\n  };\n\n  ElementMirror.prototype.getMirrorEl = function () {\n    var sourceElRect = this.sourceElRect;\n    var mirrorEl = this.mirrorEl;\n\n    if (!mirrorEl) {\n      mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true\n      // we don't want long taps or any mouse interaction causing selection/menus.\n      // would use preventSelection(), but that prevents selectstart, causing problems.\n\n      mirrorEl.classList.add('fc-unselectable');\n      mirrorEl.classList.add('fc-event-dragging');\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyStyle)(mirrorEl, {\n        position: 'fixed',\n        zIndex: this.zIndex,\n        visibility: '',\n        boxSizing: 'border-box',\n        width: sourceElRect.right - sourceElRect.left,\n        height: sourceElRect.bottom - sourceElRect.top,\n        right: 'auto',\n        bottom: 'auto',\n        margin: 0\n      });\n      this.parentNode.appendChild(mirrorEl);\n    }\n\n    return mirrorEl;\n  };\n\n  return ElementMirror;\n}();\n/*\nIs a cache for a given element's scroll information (all the info that ScrollController stores)\nin addition the \"client rectangle\" of the element.. the area within the scrollbars.\n\nThe cache can be in one of two modes:\n- doesListening:false - ignores when the container is scrolled by someone else\n- doesListening:true - watch for scrolling and update the cache\n*/\n\n\nvar ScrollGeomCache = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ScrollGeomCache, _super);\n\n  function ScrollGeomCache(scrollController, doesListening) {\n    var _this = _super.call(this) || this;\n\n    _this.handleScroll = function () {\n      _this.scrollTop = _this.scrollController.getScrollTop();\n      _this.scrollLeft = _this.scrollController.getScrollLeft();\n\n      _this.handleScrollChange();\n    };\n\n    _this.scrollController = scrollController;\n    _this.doesListening = doesListening;\n    _this.scrollTop = _this.origScrollTop = scrollController.getScrollTop();\n    _this.scrollLeft = _this.origScrollLeft = scrollController.getScrollLeft();\n    _this.scrollWidth = scrollController.getScrollWidth();\n    _this.scrollHeight = scrollController.getScrollHeight();\n    _this.clientWidth = scrollController.getClientWidth();\n    _this.clientHeight = scrollController.getClientHeight();\n    _this.clientRect = _this.computeClientRect(); // do last in case it needs cached values\n\n    if (_this.doesListening) {\n      _this.getEventTarget().addEventListener('scroll', _this.handleScroll);\n    }\n\n    return _this;\n  }\n\n  ScrollGeomCache.prototype.destroy = function () {\n    if (this.doesListening) {\n      this.getEventTarget().removeEventListener('scroll', this.handleScroll);\n    }\n  };\n\n  ScrollGeomCache.prototype.getScrollTop = function () {\n    return this.scrollTop;\n  };\n\n  ScrollGeomCache.prototype.getScrollLeft = function () {\n    return this.scrollLeft;\n  };\n\n  ScrollGeomCache.prototype.setScrollTop = function (top) {\n    this.scrollController.setScrollTop(top);\n\n    if (!this.doesListening) {\n      // we are not relying on the element to normalize out-of-bounds scroll values\n      // so we need to sanitize ourselves\n      this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);\n      this.handleScrollChange();\n    }\n  };\n\n  ScrollGeomCache.prototype.setScrollLeft = function (top) {\n    this.scrollController.setScrollLeft(top);\n\n    if (!this.doesListening) {\n      // we are not relying on the element to normalize out-of-bounds scroll values\n      // so we need to sanitize ourselves\n      this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);\n      this.handleScrollChange();\n    }\n  };\n\n  ScrollGeomCache.prototype.getClientWidth = function () {\n    return this.clientWidth;\n  };\n\n  ScrollGeomCache.prototype.getClientHeight = function () {\n    return this.clientHeight;\n  };\n\n  ScrollGeomCache.prototype.getScrollWidth = function () {\n    return this.scrollWidth;\n  };\n\n  ScrollGeomCache.prototype.getScrollHeight = function () {\n    return this.scrollHeight;\n  };\n\n  ScrollGeomCache.prototype.handleScrollChange = function () {};\n\n  return ScrollGeomCache;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ScrollController);\n\nvar ElementScrollGeomCache = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ElementScrollGeomCache, _super);\n\n  function ElementScrollGeomCache(el, doesListening) {\n    return _super.call(this, new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ElementScrollController(el), doesListening) || this;\n  }\n\n  ElementScrollGeomCache.prototype.getEventTarget = function () {\n    return this.scrollController.el;\n  };\n\n  ElementScrollGeomCache.prototype.computeClientRect = function () {\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeInnerRect)(this.scrollController.el);\n  };\n\n  return ElementScrollGeomCache;\n}(ScrollGeomCache);\n\nvar WindowScrollGeomCache = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(WindowScrollGeomCache, _super);\n\n  function WindowScrollGeomCache(doesListening) {\n    return _super.call(this, new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.WindowScrollController(), doesListening) || this;\n  }\n\n  WindowScrollGeomCache.prototype.getEventTarget = function () {\n    return window;\n  };\n\n  WindowScrollGeomCache.prototype.computeClientRect = function () {\n    return {\n      left: this.scrollLeft,\n      right: this.scrollLeft + this.clientWidth,\n      top: this.scrollTop,\n      bottom: this.scrollTop + this.clientHeight\n    };\n  }; // the window is the only scroll object that changes it's rectangle relative\n  // to the document's topleft as it scrolls\n\n\n  WindowScrollGeomCache.prototype.handleScrollChange = function () {\n    this.clientRect = this.computeClientRect();\n  };\n\n  return WindowScrollGeomCache;\n}(ScrollGeomCache); // If available we are using native \"performance\" API instead of \"Date\"\n// Read more about it on MDN:\n// https://developer.mozilla.org/en-US/docs/Web/API/Performance\n\n\nvar getTime = typeof performance === 'function' ? performance.now : Date.now;\n/*\nFor a pointer interaction, automatically scrolls certain scroll containers when the pointer\napproaches the edge.\n\nThe caller must call start + handleMove + stop.\n*/\n\nvar AutoScroller = function () {\n  function AutoScroller() {\n    var _this = this; // options that can be set by caller\n\n\n    this.isEnabled = true;\n    this.scrollQuery = [window, '.fc-scroller'];\n    this.edgeThreshold = 50; // pixels\n\n    this.maxVelocity = 300; // pixels per second\n    // internal state\n\n    this.pointerScreenX = null;\n    this.pointerScreenY = null;\n    this.isAnimating = false;\n    this.scrollCaches = null; // protect against the initial pointerdown being too close to an edge and starting the scroll\n\n    this.everMovedUp = false;\n    this.everMovedDown = false;\n    this.everMovedLeft = false;\n    this.everMovedRight = false;\n\n    this.animate = function () {\n      if (_this.isAnimating) {\n        // wasn't cancelled between animation calls\n        var edge = _this.computeBestEdge(_this.pointerScreenX + window.pageXOffset, _this.pointerScreenY + window.pageYOffset);\n\n        if (edge) {\n          var now = getTime();\n\n          _this.handleSide(edge, (now - _this.msSinceRequest) / 1000);\n\n          _this.requestAnimation(now);\n        } else {\n          _this.isAnimating = false; // will stop animation\n        }\n      }\n    };\n  }\n\n  AutoScroller.prototype.start = function (pageX, pageY, scrollStartEl) {\n    if (this.isEnabled) {\n      this.scrollCaches = this.buildCaches(scrollStartEl);\n      this.pointerScreenX = null;\n      this.pointerScreenY = null;\n      this.everMovedUp = false;\n      this.everMovedDown = false;\n      this.everMovedLeft = false;\n      this.everMovedRight = false;\n      this.handleMove(pageX, pageY);\n    }\n  };\n\n  AutoScroller.prototype.handleMove = function (pageX, pageY) {\n    if (this.isEnabled) {\n      var pointerScreenX = pageX - window.pageXOffset;\n      var pointerScreenY = pageY - window.pageYOffset;\n      var yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;\n      var xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;\n\n      if (yDelta < 0) {\n        this.everMovedUp = true;\n      } else if (yDelta > 0) {\n        this.everMovedDown = true;\n      }\n\n      if (xDelta < 0) {\n        this.everMovedLeft = true;\n      } else if (xDelta > 0) {\n        this.everMovedRight = true;\n      }\n\n      this.pointerScreenX = pointerScreenX;\n      this.pointerScreenY = pointerScreenY;\n\n      if (!this.isAnimating) {\n        this.isAnimating = true;\n        this.requestAnimation(getTime());\n      }\n    }\n  };\n\n  AutoScroller.prototype.stop = function () {\n    if (this.isEnabled) {\n      this.isAnimating = false; // will stop animation\n\n      for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n        var scrollCache = _a[_i];\n        scrollCache.destroy();\n      }\n\n      this.scrollCaches = null;\n    }\n  };\n\n  AutoScroller.prototype.requestAnimation = function (now) {\n    this.msSinceRequest = now;\n    requestAnimationFrame(this.animate);\n  };\n\n  AutoScroller.prototype.handleSide = function (edge, seconds) {\n    var scrollCache = edge.scrollCache;\n    var edgeThreshold = this.edgeThreshold;\n    var invDistance = edgeThreshold - edge.distance;\n    var velocity = // the closer to the edge, the faster we scroll\n    invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic\n    this.maxVelocity * seconds;\n    var sign = 1;\n\n    switch (edge.name) {\n      case 'left':\n        sign = -1;\n      // falls through\n\n      case 'right':\n        scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);\n        break;\n\n      case 'top':\n        sign = -1;\n      // falls through\n\n      case 'bottom':\n        scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);\n        break;\n    }\n  }; // left/top are relative to document topleft\n\n\n  AutoScroller.prototype.computeBestEdge = function (left, top) {\n    var edgeThreshold = this.edgeThreshold;\n    var bestSide = null;\n\n    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n      var scrollCache = _a[_i];\n      var rect = scrollCache.clientRect;\n      var leftDist = left - rect.left;\n      var rightDist = rect.right - left;\n      var topDist = top - rect.top;\n      var bottomDist = rect.bottom - top; // completely within the rect?\n\n      if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {\n        if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {\n          bestSide = {\n            scrollCache: scrollCache,\n            name: 'top',\n            distance: topDist\n          };\n        }\n\n        if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {\n          bestSide = {\n            scrollCache: scrollCache,\n            name: 'bottom',\n            distance: bottomDist\n          };\n        }\n\n        if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {\n          bestSide = {\n            scrollCache: scrollCache,\n            name: 'left',\n            distance: leftDist\n          };\n        }\n\n        if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {\n          bestSide = {\n            scrollCache: scrollCache,\n            name: 'right',\n            distance: rightDist\n          };\n        }\n      }\n    }\n\n    return bestSide;\n  };\n\n  AutoScroller.prototype.buildCaches = function (scrollStartEl) {\n    return this.queryScrollEls(scrollStartEl).map(function (el) {\n      if (el === window) {\n        return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls\n      }\n\n      return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls\n    });\n  };\n\n  AutoScroller.prototype.queryScrollEls = function (scrollStartEl) {\n    var els = [];\n\n    for (var _i = 0, _a = this.scrollQuery; _i < _a.length; _i++) {\n      var query = _a[_i];\n\n      if (typeof query === 'object') {\n        els.push(query);\n      } else {\n        els.push.apply(els, Array.prototype.slice.call((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElRoot)(scrollStartEl).querySelectorAll(query)));\n      }\n    }\n\n    return els;\n  };\n\n  return AutoScroller;\n}();\n/*\nMonitors dragging on an element. Has a number of high-level features:\n- minimum distance required before dragging\n- minimum wait time (\"delay\") before dragging\n- a mirror element that follows the pointer\n*/\n\n\nvar FeaturefulElementDragging = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(FeaturefulElementDragging, _super);\n\n  function FeaturefulElementDragging(containerEl, selector) {\n    var _this = _super.call(this, containerEl) || this;\n\n    _this.containerEl = containerEl; // options that can be directly set by caller\n    // the caller can also set the PointerDragging's options as well\n\n    _this.delay = null;\n    _this.minDistance = 0;\n    _this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag\n\n    _this.mirrorNeedsRevert = false;\n    _this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup\n\n    _this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation\n\n    _this.isDelayEnded = false;\n    _this.isDistanceSurpassed = false;\n    _this.delayTimeoutId = null;\n\n    _this.onPointerDown = function (ev) {\n      if (!_this.isDragging) {\n        // so new drag doesn't happen while revert animation is going\n        _this.isInteracting = true;\n        _this.isDelayEnded = false;\n        _this.isDistanceSurpassed = false;\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.preventSelection)(document.body);\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.preventContextMenu)(document.body); // prevent links from being visited if there's an eventual drag.\n        // also prevents selection in older browsers (maybe?).\n        // not necessary for touch, besides, browser would complain about passiveness.\n\n        if (!ev.isTouch) {\n          ev.origEvent.preventDefault();\n        }\n\n        _this.emitter.trigger('pointerdown', ev);\n\n        if (_this.isInteracting && // not destroyed via pointerdown handler\n        !_this.pointer.shouldIgnoreMove) {\n          // actions related to initiating dragstart+dragmove+dragend...\n          _this.mirror.setIsVisible(false); // reset. caller must set-visible\n\n\n          _this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down\n\n\n          _this.startDelay(ev);\n\n          if (!_this.minDistance) {\n            _this.handleDistanceSurpassed(ev);\n          }\n        }\n      }\n    };\n\n    _this.onPointerMove = function (ev) {\n      if (_this.isInteracting) {\n        _this.emitter.trigger('pointermove', ev);\n\n        if (!_this.isDistanceSurpassed) {\n          var minDistance = _this.minDistance;\n          var distanceSq = void 0; // current distance from the origin, squared\n\n          var deltaX = ev.deltaX,\n              deltaY = ev.deltaY;\n          distanceSq = deltaX * deltaX + deltaY * deltaY;\n\n          if (distanceSq >= minDistance * minDistance) {\n            // use pythagorean theorem\n            _this.handleDistanceSurpassed(ev);\n          }\n        }\n\n        if (_this.isDragging) {\n          // a real pointer move? (not one simulated by scrolling)\n          if (ev.origEvent.type !== 'scroll') {\n            _this.mirror.handleMove(ev.pageX, ev.pageY);\n\n            _this.autoScroller.handleMove(ev.pageX, ev.pageY);\n          }\n\n          _this.emitter.trigger('dragmove', ev);\n        }\n      }\n    };\n\n    _this.onPointerUp = function (ev) {\n      if (_this.isInteracting) {\n        _this.isInteracting = false;\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.allowSelection)(document.body);\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.allowContextMenu)(document.body);\n\n        _this.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert\n\n\n        if (_this.isDragging) {\n          _this.autoScroller.stop();\n\n          _this.tryStopDrag(ev); // which will stop the mirror\n\n        }\n\n        if (_this.delayTimeoutId) {\n          clearTimeout(_this.delayTimeoutId);\n          _this.delayTimeoutId = null;\n        }\n      }\n    };\n\n    var pointer = _this.pointer = new PointerDragging(containerEl);\n    pointer.emitter.on('pointerdown', _this.onPointerDown);\n    pointer.emitter.on('pointermove', _this.onPointerMove);\n    pointer.emitter.on('pointerup', _this.onPointerUp);\n\n    if (selector) {\n      pointer.selector = selector;\n    }\n\n    _this.mirror = new ElementMirror();\n    _this.autoScroller = new AutoScroller();\n    return _this;\n  }\n\n  FeaturefulElementDragging.prototype.destroy = function () {\n    this.pointer.destroy(); // HACK: simulate a pointer-up to end the current drag\n    // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)\n\n    this.onPointerUp({});\n  };\n\n  FeaturefulElementDragging.prototype.startDelay = function (ev) {\n    var _this = this;\n\n    if (typeof this.delay === 'number') {\n      this.delayTimeoutId = setTimeout(function () {\n        _this.delayTimeoutId = null;\n\n        _this.handleDelayEnd(ev);\n      }, this.delay); // not assignable to number!\n    } else {\n      this.handleDelayEnd(ev);\n    }\n  };\n\n  FeaturefulElementDragging.prototype.handleDelayEnd = function (ev) {\n    this.isDelayEnded = true;\n    this.tryStartDrag(ev);\n  };\n\n  FeaturefulElementDragging.prototype.handleDistanceSurpassed = function (ev) {\n    this.isDistanceSurpassed = true;\n    this.tryStartDrag(ev);\n  };\n\n  FeaturefulElementDragging.prototype.tryStartDrag = function (ev) {\n    if (this.isDelayEnded && this.isDistanceSurpassed) {\n      if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {\n        this.isDragging = true;\n        this.mirrorNeedsRevert = false;\n        this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);\n        this.emitter.trigger('dragstart', ev);\n\n        if (this.touchScrollAllowed === false) {\n          this.pointer.cancelTouchScroll();\n        }\n      }\n    }\n  };\n\n  FeaturefulElementDragging.prototype.tryStopDrag = function (ev) {\n    // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events\n    // that come from the document to fire beforehand. much more convenient this way.\n    this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));\n  };\n\n  FeaturefulElementDragging.prototype.stopDrag = function (ev) {\n    this.isDragging = false;\n    this.emitter.trigger('dragend', ev);\n  }; // fill in the implementations...\n\n\n  FeaturefulElementDragging.prototype.setIgnoreMove = function (bool) {\n    this.pointer.shouldIgnoreMove = bool;\n  };\n\n  FeaturefulElementDragging.prototype.setMirrorIsVisible = function (bool) {\n    this.mirror.setIsVisible(bool);\n  };\n\n  FeaturefulElementDragging.prototype.setMirrorNeedsRevert = function (bool) {\n    this.mirrorNeedsRevert = bool;\n  };\n\n  FeaturefulElementDragging.prototype.setAutoScrollEnabled = function (bool) {\n    this.autoScroller.isEnabled = bool;\n  };\n\n  return FeaturefulElementDragging;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ElementDragging);\n/*\nWhen this class is instantiated, it records the offset of an element (relative to the document topleft),\nand continues to monitor scrolling, updating the cached coordinates if it needs to.\nDoes not access the DOM after instantiation, so highly performant.\n\nAlso keeps track of all scrolling/overflow:hidden containers that are parents of the given element\nand an determine if a given point is inside the combined clipping rectangle.\n*/\n\n\nvar OffsetTracker = function () {\n  function OffsetTracker(el) {\n    this.origRect = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeRect)(el); // will work fine for divs that have overflow:hidden\n\n    this.scrollCaches = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getClippingParents)(el).map(function (scrollEl) {\n      return new ElementScrollGeomCache(scrollEl, true);\n    });\n  }\n\n  OffsetTracker.prototype.destroy = function () {\n    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n      var scrollCache = _a[_i];\n      scrollCache.destroy();\n    }\n  };\n\n  OffsetTracker.prototype.computeLeft = function () {\n    var left = this.origRect.left;\n\n    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n      var scrollCache = _a[_i];\n      left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();\n    }\n\n    return left;\n  };\n\n  OffsetTracker.prototype.computeTop = function () {\n    var top = this.origRect.top;\n\n    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n      var scrollCache = _a[_i];\n      top += scrollCache.origScrollTop - scrollCache.getScrollTop();\n    }\n\n    return top;\n  };\n\n  OffsetTracker.prototype.isWithinClipping = function (pageX, pageY) {\n    var point = {\n      left: pageX,\n      top: pageY\n    };\n\n    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n      var scrollCache = _a[_i];\n\n      if (!isIgnoredClipping(scrollCache.getEventTarget()) && !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.pointInsideRect)(point, scrollCache.clientRect)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return OffsetTracker;\n}(); // certain clipping containers should never constrain interactions, like <html> and <body>\n// https://github.com/fullcalendar/fullcalendar/issues/3615\n\n\nfunction isIgnoredClipping(node) {\n  var tagName = node.tagName;\n  return tagName === 'HTML' || tagName === 'BODY';\n}\n/*\nTracks movement over multiple droppable areas (aka \"hits\")\nthat exist in one or more DateComponents.\nRelies on an existing draggable.\n\nemits:\n- pointerdown\n- dragstart\n- hitchange - fires initially, even if not over a hit\n- pointerup\n- (hitchange - again, to null, if ended over a hit)\n- dragend\n*/\n\n\nvar HitDragging = function () {\n  function HitDragging(dragging, droppableStore) {\n    var _this = this; // options that can be set by caller\n\n\n    this.useSubjectCenter = false;\n    this.requireInitial = true; // if doesn't start out on a hit, won't emit any events\n\n    this.initialHit = null;\n    this.movingHit = null;\n    this.finalHit = null; // won't ever be populated if shouldIgnoreMove\n\n    this.handlePointerDown = function (ev) {\n      var dragging = _this.dragging;\n      _this.initialHit = null;\n      _this.movingHit = null;\n      _this.finalHit = null;\n\n      _this.prepareHits();\n\n      _this.processFirstCoord(ev);\n\n      if (_this.initialHit || !_this.requireInitial) {\n        dragging.setIgnoreMove(false); // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(\n\n        _this.emitter.trigger('pointerdown', ev);\n      } else {\n        dragging.setIgnoreMove(true);\n      }\n    };\n\n    this.handleDragStart = function (ev) {\n      _this.emitter.trigger('dragstart', ev);\n\n      _this.handleMove(ev, true); // force = fire even if initially null\n\n    };\n\n    this.handleDragMove = function (ev) {\n      _this.emitter.trigger('dragmove', ev);\n\n      _this.handleMove(ev);\n    };\n\n    this.handlePointerUp = function (ev) {\n      _this.releaseHits();\n\n      _this.emitter.trigger('pointerup', ev);\n    };\n\n    this.handleDragEnd = function (ev) {\n      if (_this.movingHit) {\n        _this.emitter.trigger('hitupdate', null, true, ev);\n      }\n\n      _this.finalHit = _this.movingHit;\n      _this.movingHit = null;\n\n      _this.emitter.trigger('dragend', ev);\n    };\n\n    this.droppableStore = droppableStore;\n    dragging.emitter.on('pointerdown', this.handlePointerDown);\n    dragging.emitter.on('dragstart', this.handleDragStart);\n    dragging.emitter.on('dragmove', this.handleDragMove);\n    dragging.emitter.on('pointerup', this.handlePointerUp);\n    dragging.emitter.on('dragend', this.handleDragEnd);\n    this.dragging = dragging;\n    this.emitter = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Emitter();\n  } // sets initialHit\n  // sets coordAdjust\n\n\n  HitDragging.prototype.processFirstCoord = function (ev) {\n    var origPoint = {\n      left: ev.pageX,\n      top: ev.pageY\n    };\n    var adjustedPoint = origPoint;\n    var subjectEl = ev.subjectEl;\n    var subjectRect;\n\n    if (subjectEl instanceof HTMLElement) {\n      // i.e. not a Document/ShadowRoot\n      subjectRect = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeRect)(subjectEl);\n      adjustedPoint = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.constrainPoint)(adjustedPoint, subjectRect);\n    }\n\n    var initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);\n\n    if (initialHit) {\n      if (this.useSubjectCenter && subjectRect) {\n        var slicedSubjectRect = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.intersectRects)(subjectRect, initialHit.rect);\n\n        if (slicedSubjectRect) {\n          adjustedPoint = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getRectCenter)(slicedSubjectRect);\n        }\n      }\n\n      this.coordAdjust = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffPoints)(adjustedPoint, origPoint);\n    } else {\n      this.coordAdjust = {\n        left: 0,\n        top: 0\n      };\n    }\n  };\n\n  HitDragging.prototype.handleMove = function (ev, forceHandle) {\n    var hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);\n\n    if (forceHandle || !isHitsEqual(this.movingHit, hit)) {\n      this.movingHit = hit;\n      this.emitter.trigger('hitupdate', hit, false, ev);\n    }\n  };\n\n  HitDragging.prototype.prepareHits = function () {\n    this.offsetTrackers = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.mapHash)(this.droppableStore, function (interactionSettings) {\n      interactionSettings.component.prepareHits();\n      return new OffsetTracker(interactionSettings.el);\n    });\n  };\n\n  HitDragging.prototype.releaseHits = function () {\n    var offsetTrackers = this.offsetTrackers;\n\n    for (var id in offsetTrackers) {\n      offsetTrackers[id].destroy();\n    }\n\n    this.offsetTrackers = {};\n  };\n\n  HitDragging.prototype.queryHitForOffset = function (offsetLeft, offsetTop) {\n    var _a = this,\n        droppableStore = _a.droppableStore,\n        offsetTrackers = _a.offsetTrackers;\n\n    var bestHit = null;\n\n    for (var id in droppableStore) {\n      var component = droppableStore[id].component;\n      var offsetTracker = offsetTrackers[id];\n\n      if (offsetTracker && // wasn't destroyed mid-drag\n      offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {\n        var originLeft = offsetTracker.computeLeft();\n        var originTop = offsetTracker.computeTop();\n        var positionLeft = offsetLeft - originLeft;\n        var positionTop = offsetTop - originTop;\n        var origRect = offsetTracker.origRect;\n        var width = origRect.right - origRect.left;\n        var height = origRect.bottom - origRect.top;\n\n        if ( // must be within the element's bounds\n        positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height) {\n          var hit = component.queryHit(positionLeft, positionTop, width, height);\n\n          if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell\n          (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.rangeContainsRange)(hit.dateProfile.activeRange, hit.dateSpan.range) && (!bestHit || hit.layer > bestHit.layer)) {\n            hit.componentId = id;\n            hit.context = component.context; // TODO: better way to re-orient rectangle\n\n            hit.rect.left += originLeft;\n            hit.rect.right += originLeft;\n            hit.rect.top += originTop;\n            hit.rect.bottom += originTop;\n            bestHit = hit;\n          }\n        }\n      }\n    }\n\n    return bestHit;\n  };\n\n  return HitDragging;\n}();\n\nfunction isHitsEqual(hit0, hit1) {\n  if (!hit0 && !hit1) {\n    return true;\n  }\n\n  if (Boolean(hit0) !== Boolean(hit1)) {\n    return false;\n  }\n\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isDateSpansEqual)(hit0.dateSpan, hit1.dateSpan);\n}\n\nfunction buildDatePointApiWithContext(dateSpan, context) {\n  var props = {};\n\n  for (var _i = 0, _a = context.pluginHooks.datePointTransforms; _i < _a.length; _i++) {\n    var transform = _a[_i];\n\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, transform(dateSpan, context));\n  }\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, buildDatePointApi(dateSpan, context.dateEnv));\n\n  return props;\n}\n\nfunction buildDatePointApi(span, dateEnv) {\n  return {\n    date: dateEnv.toDate(span.range.start),\n    dateStr: dateEnv.formatIso(span.range.start, {\n      omitTime: span.allDay\n    }),\n    allDay: span.allDay\n  };\n}\n/*\nMonitors when the user clicks on a specific date/time of a component.\nA pointerdown+pointerup on the same \"hit\" constitutes a click.\n*/\n\n\nvar DateClicking = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DateClicking, _super);\n\n  function DateClicking(settings) {\n    var _this = _super.call(this, settings) || this;\n\n    _this.handlePointerDown = function (pev) {\n      var dragging = _this.dragging;\n      var downEl = pev.origEvent.target; // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired\n\n      dragging.setIgnoreMove(!_this.component.isValidDateDownEl(downEl));\n    }; // won't even fire if moving was ignored\n\n\n    _this.handleDragEnd = function (ev) {\n      var component = _this.component;\n      var pointer = _this.dragging.pointer;\n\n      if (!pointer.wasTouchScroll) {\n        var _a = _this.hitDragging,\n            initialHit = _a.initialHit,\n            finalHit = _a.finalHit;\n\n        if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {\n          var context = component.context;\n\n          var arg = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), {\n            dayEl: initialHit.dayEl,\n            jsEvent: ev.origEvent,\n            view: context.viewApi || context.calendarApi.view\n          });\n\n          context.emitter.trigger('dateClick', arg);\n        }\n      }\n    }; // we DO want to watch pointer moves because otherwise finalHit won't get populated\n\n\n    _this.dragging = new FeaturefulElementDragging(settings.el);\n    _this.dragging.autoScroller.isEnabled = false;\n    var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsToStore)(settings));\n    hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n    hitDragging.emitter.on('dragend', _this.handleDragEnd);\n    return _this;\n  }\n\n  DateClicking.prototype.destroy = function () {\n    this.dragging.destroy();\n  };\n\n  return DateClicking;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction);\n/*\nTracks when the user selects a portion of time of a component,\nconstituted by a drag over date cells, with a possible delay at the beginning of the drag.\n*/\n\n\nvar DateSelecting = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DateSelecting, _super);\n\n  function DateSelecting(settings) {\n    var _this = _super.call(this, settings) || this;\n\n    _this.dragSelection = null;\n\n    _this.handlePointerDown = function (ev) {\n      var _a = _this,\n          component = _a.component,\n          dragging = _a.dragging;\n      var options = component.context.options;\n      var canSelect = options.selectable && component.isValidDateDownEl(ev.origEvent.target); // don't bother to watch expensive moves if component won't do selection\n\n      dragging.setIgnoreMove(!canSelect); // if touch, require user to hold down\n\n      dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;\n    };\n\n    _this.handleDragStart = function (ev) {\n      _this.component.context.calendarApi.unselect(ev); // unselect previous selections\n\n    };\n\n    _this.handleHitUpdate = function (hit, isFinal) {\n      var context = _this.component.context;\n      var dragSelection = null;\n      var isInvalid = false;\n\n      if (hit) {\n        var initialHit = _this.hitDragging.initialHit;\n        var disallowed = hit.componentId === initialHit.componentId && _this.isHitComboAllowed && !_this.isHitComboAllowed(initialHit, hit);\n\n        if (!disallowed) {\n          dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);\n        }\n\n        if (!dragSelection || !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isDateSelectionValid)(dragSelection, hit.dateProfile, context)) {\n          isInvalid = true;\n          dragSelection = null;\n        }\n      }\n\n      if (dragSelection) {\n        context.dispatch({\n          type: 'SELECT_DATES',\n          selection: dragSelection\n        });\n      } else if (!isFinal) {\n        // only unselect if moved away while dragging\n        context.dispatch({\n          type: 'UNSELECT_DATES'\n        });\n      }\n\n      if (!isInvalid) {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n      } else {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n      }\n\n      if (!isFinal) {\n        _this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging\n      }\n    };\n\n    _this.handlePointerUp = function (pev) {\n      if (_this.dragSelection) {\n        // selection is already rendered, so just need to report selection\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.triggerDateSelect)(_this.dragSelection, pev, _this.component.context);\n        _this.dragSelection = null;\n      }\n    };\n\n    var component = settings.component;\n    var options = component.context.options;\n    var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n    dragging.touchScrollAllowed = false;\n    dragging.minDistance = options.selectMinDistance || 0;\n    dragging.autoScroller.isEnabled = options.dragScroll;\n    var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsToStore)(settings));\n    hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n    hitDragging.emitter.on('dragstart', _this.handleDragStart);\n    hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);\n    hitDragging.emitter.on('pointerup', _this.handlePointerUp);\n    return _this;\n  }\n\n  DateSelecting.prototype.destroy = function () {\n    this.dragging.destroy();\n  };\n\n  return DateSelecting;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction);\n\nfunction getComponentTouchDelay$1(component) {\n  var options = component.context.options;\n  var delay = options.selectLongPressDelay;\n\n  if (delay == null) {\n    delay = options.longPressDelay;\n  }\n\n  return delay;\n}\n\nfunction joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {\n  var dateSpan0 = hit0.dateSpan;\n  var dateSpan1 = hit1.dateSpan;\n  var ms = [dateSpan0.range.start, dateSpan0.range.end, dateSpan1.range.start, dateSpan1.range.end];\n  ms.sort(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.compareNumbers);\n  var props = {};\n\n  for (var _i = 0, dateSelectionTransformers_1 = dateSelectionTransformers; _i < dateSelectionTransformers_1.length; _i++) {\n    var transformer = dateSelectionTransformers_1[_i];\n    var res = transformer(hit0, hit1);\n\n    if (res === false) {\n      return null;\n    }\n\n    if (res) {\n      (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, res);\n    }\n  }\n\n  props.range = {\n    start: ms[0],\n    end: ms[3]\n  };\n  props.allDay = dateSpan0.allDay;\n  return props;\n}\n\nvar EventDragging = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(EventDragging, _super);\n\n  function EventDragging(settings) {\n    var _this = _super.call(this, settings) || this; // internal state\n\n\n    _this.subjectEl = null;\n    _this.subjectSeg = null; // the seg being selected/dragged\n\n    _this.isDragging = false;\n    _this.eventRange = null;\n    _this.relevantEvents = null; // the events being dragged\n\n    _this.receivingContext = null;\n    _this.validMutation = null;\n    _this.mutatedRelevantEvents = null;\n\n    _this.handlePointerDown = function (ev) {\n      var origTarget = ev.origEvent.target;\n      var _a = _this,\n          component = _a.component,\n          dragging = _a.dragging;\n      var mirror = dragging.mirror;\n      var options = component.context.options;\n      var initialContext = component.context;\n      _this.subjectEl = ev.subjectEl;\n      var subjectSeg = _this.subjectSeg = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElSeg)(ev.subjectEl);\n      var eventRange = _this.eventRange = subjectSeg.eventRange;\n      var eventInstanceId = eventRange.instance.instanceId;\n      _this.relevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getRelevantEvents)(initialContext.getCurrentData().eventStore, eventInstanceId);\n      dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;\n      dragging.delay = // only do a touch delay if touch and this event hasn't been selected yet\n      ev.isTouch && eventInstanceId !== component.props.eventSelection ? getComponentTouchDelay(component) : null;\n\n      if (options.fixedMirrorParent) {\n        mirror.parentNode = options.fixedMirrorParent;\n      } else {\n        mirror.parentNode = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(origTarget, '.fc');\n      }\n\n      mirror.revertDuration = options.dragRevertDuration;\n      var isValid = component.isValidSegDownEl(origTarget) && !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(origTarget, '.fc-event-resizer'); // NOT on a resizer\n\n      dragging.setIgnoreMove(!isValid); // disable dragging for elements that are resizable (ie, selectable)\n      // but are not draggable\n\n      _this.isDragging = isValid && ev.subjectEl.classList.contains('fc-event-draggable');\n    };\n\n    _this.handleDragStart = function (ev) {\n      var initialContext = _this.component.context;\n      var eventRange = _this.eventRange;\n      var eventInstanceId = eventRange.instance.instanceId;\n\n      if (ev.isTouch) {\n        // need to select a different event?\n        if (eventInstanceId !== _this.component.props.eventSelection) {\n          initialContext.dispatch({\n            type: 'SELECT_EVENT',\n            eventInstanceId: eventInstanceId\n          });\n        }\n      } else {\n        // if now using mouse, but was previous touch interaction, clear selected event\n        initialContext.dispatch({\n          type: 'UNSELECT_EVENT'\n        });\n      }\n\n      if (_this.isDragging) {\n        initialContext.calendarApi.unselect(ev); // unselect *date* selection\n\n        initialContext.emitter.trigger('eventDragStart', {\n          el: _this.subjectEl,\n          event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(initialContext, eventRange.def, eventRange.instance),\n          jsEvent: ev.origEvent,\n          view: initialContext.viewApi\n        });\n      }\n    };\n\n    _this.handleHitUpdate = function (hit, isFinal) {\n      if (!_this.isDragging) {\n        return;\n      }\n\n      var relevantEvents = _this.relevantEvents;\n      var initialHit = _this.hitDragging.initialHit;\n      var initialContext = _this.component.context; // states based on new hit\n\n      var receivingContext = null;\n      var mutation = null;\n      var mutatedRelevantEvents = null;\n      var isInvalid = false;\n      var interaction = {\n        affectedEvents: relevantEvents,\n        mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n        isEvent: true\n      };\n\n      if (hit) {\n        receivingContext = hit.context;\n        var receivingOptions = receivingContext.options;\n\n        if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {\n          mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);\n\n          if (mutation) {\n            mutatedRelevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyMutationToEventStore)(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);\n            interaction.mutatedEvents = mutatedRelevantEvents;\n\n            if (!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isInteractionValid)(interaction, hit.dateProfile, receivingContext)) {\n              isInvalid = true;\n              mutation = null;\n              mutatedRelevantEvents = null;\n              interaction.mutatedEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)();\n            }\n          }\n        } else {\n          receivingContext = null;\n        }\n      }\n\n      _this.displayDrag(receivingContext, interaction);\n\n      if (!isInvalid) {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n      } else {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n      }\n\n      if (!isFinal) {\n        if (initialContext === receivingContext && // TODO: write test for this\n        isHitsEqual(initialHit, hit)) {\n          mutation = null;\n        }\n\n        _this.dragging.setMirrorNeedsRevert(!mutation); // render the mirror if no already-rendered mirror\n        // TODO: wish we could somehow wait for dispatch to guarantee render\n\n\n        _this.dragging.setMirrorIsVisible(!hit || !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElRoot)(_this.subjectEl).querySelector('.fc-event-mirror')); // assign states based on new hit\n\n\n        _this.receivingContext = receivingContext;\n        _this.validMutation = mutation;\n        _this.mutatedRelevantEvents = mutatedRelevantEvents;\n      }\n    };\n\n    _this.handlePointerUp = function () {\n      if (!_this.isDragging) {\n        _this.cleanup(); // because handleDragEnd won't fire\n\n      }\n    };\n\n    _this.handleDragEnd = function (ev) {\n      if (_this.isDragging) {\n        var initialContext_1 = _this.component.context;\n        var initialView = initialContext_1.viewApi;\n        var _a = _this,\n            receivingContext_1 = _a.receivingContext,\n            validMutation = _a.validMutation;\n        var eventDef = _this.eventRange.def;\n        var eventInstance = _this.eventRange.instance;\n        var eventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(initialContext_1, eventDef, eventInstance);\n        var relevantEvents_1 = _this.relevantEvents;\n        var mutatedRelevantEvents_1 = _this.mutatedRelevantEvents;\n        var finalHit = _this.hitDragging.finalHit;\n\n        _this.clearDrag(); // must happen after revert animation\n\n\n        initialContext_1.emitter.trigger('eventDragStop', {\n          el: _this.subjectEl,\n          event: eventApi,\n          jsEvent: ev.origEvent,\n          view: initialView\n        });\n\n        if (validMutation) {\n          // dropped within same calendar\n          if (receivingContext_1 === initialContext_1) {\n            var updatedEventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(initialContext_1, mutatedRelevantEvents_1.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents_1.instances[eventInstance.instanceId] : null);\n            initialContext_1.dispatch({\n              type: 'MERGE_EVENTS',\n              eventStore: mutatedRelevantEvents_1\n            });\n            var eventChangeArg = {\n              oldEvent: eventApi,\n              event: updatedEventApi,\n              relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(mutatedRelevantEvents_1, initialContext_1, eventInstance),\n              revert: function () {\n                initialContext_1.dispatch({\n                  type: 'MERGE_EVENTS',\n                  eventStore: relevantEvents_1 // the pre-change data\n\n                });\n              }\n            };\n            var transformed = {};\n\n            for (var _i = 0, _b = initialContext_1.getCurrentData().pluginHooks.eventDropTransformers; _i < _b.length; _i++) {\n              var transformer = _b[_i];\n\n              (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(transformed, transformer(validMutation, initialContext_1));\n            }\n\n            initialContext_1.emitter.trigger('eventDrop', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventChangeArg), transformed), {\n              el: ev.subjectEl,\n              delta: validMutation.datesDelta,\n              jsEvent: ev.origEvent,\n              view: initialView\n            }));\n            initialContext_1.emitter.trigger('eventChange', eventChangeArg); // dropped in different calendar\n          } else if (receivingContext_1) {\n            var eventRemoveArg = {\n              event: eventApi,\n              relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(relevantEvents_1, initialContext_1, eventInstance),\n              revert: function () {\n                initialContext_1.dispatch({\n                  type: 'MERGE_EVENTS',\n                  eventStore: relevantEvents_1\n                });\n              }\n            };\n            initialContext_1.emitter.trigger('eventLeave', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventRemoveArg), {\n              draggedEl: ev.subjectEl,\n              view: initialView\n            }));\n            initialContext_1.dispatch({\n              type: 'REMOVE_EVENTS',\n              eventStore: relevantEvents_1\n            });\n            initialContext_1.emitter.trigger('eventRemove', eventRemoveArg);\n            var addedEventDef = mutatedRelevantEvents_1.defs[eventDef.defId];\n            var addedEventInstance = mutatedRelevantEvents_1.instances[eventInstance.instanceId];\n            var addedEventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(receivingContext_1, addedEventDef, addedEventInstance);\n            receivingContext_1.dispatch({\n              type: 'MERGE_EVENTS',\n              eventStore: mutatedRelevantEvents_1\n            });\n            var eventAddArg = {\n              event: addedEventApi,\n              relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(mutatedRelevantEvents_1, receivingContext_1, addedEventInstance),\n              revert: function () {\n                receivingContext_1.dispatch({\n                  type: 'REMOVE_EVENTS',\n                  eventStore: mutatedRelevantEvents_1\n                });\n              }\n            };\n            receivingContext_1.emitter.trigger('eventAdd', eventAddArg);\n\n            if (ev.isTouch) {\n              receivingContext_1.dispatch({\n                type: 'SELECT_EVENT',\n                eventInstanceId: eventInstance.instanceId\n              });\n            }\n\n            receivingContext_1.emitter.trigger('drop', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext_1)), {\n              draggedEl: ev.subjectEl,\n              jsEvent: ev.origEvent,\n              view: finalHit.context.viewApi\n            }));\n            receivingContext_1.emitter.trigger('eventReceive', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventAddArg), {\n              draggedEl: ev.subjectEl,\n              view: finalHit.context.viewApi\n            }));\n          }\n        } else {\n          initialContext_1.emitter.trigger('_noEventDrop');\n        }\n      }\n\n      _this.cleanup();\n    };\n\n    var component = _this.component;\n    var options = component.context.options;\n    var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n    dragging.pointer.selector = EventDragging.SELECTOR;\n    dragging.touchScrollAllowed = false;\n    dragging.autoScroller.isEnabled = options.dragScroll;\n    var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsStore);\n    hitDragging.useSubjectCenter = settings.useEventCenter;\n    hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n    hitDragging.emitter.on('dragstart', _this.handleDragStart);\n    hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);\n    hitDragging.emitter.on('pointerup', _this.handlePointerUp);\n    hitDragging.emitter.on('dragend', _this.handleDragEnd);\n    return _this;\n  }\n\n  EventDragging.prototype.destroy = function () {\n    this.dragging.destroy();\n  }; // render a drag state on the next receivingCalendar\n\n\n  EventDragging.prototype.displayDrag = function (nextContext, state) {\n    var initialContext = this.component.context;\n    var prevContext = this.receivingContext; // does the previous calendar need to be cleared?\n\n    if (prevContext && prevContext !== nextContext) {\n      // does the initial calendar need to be cleared?\n      // if so, don't clear all the way. we still need to to hide the affectedEvents\n      if (prevContext === initialContext) {\n        prevContext.dispatch({\n          type: 'SET_EVENT_DRAG',\n          state: {\n            affectedEvents: state.affectedEvents,\n            mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n            isEvent: true\n          }\n        }); // completely clear the old calendar if it wasn't the initial\n      } else {\n        prevContext.dispatch({\n          type: 'UNSET_EVENT_DRAG'\n        });\n      }\n    }\n\n    if (nextContext) {\n      nextContext.dispatch({\n        type: 'SET_EVENT_DRAG',\n        state: state\n      });\n    }\n  };\n\n  EventDragging.prototype.clearDrag = function () {\n    var initialCalendar = this.component.context;\n    var receivingContext = this.receivingContext;\n\n    if (receivingContext) {\n      receivingContext.dispatch({\n        type: 'UNSET_EVENT_DRAG'\n      });\n    } // the initial calendar might have an dummy drag state from displayDrag\n\n\n    if (initialCalendar !== receivingContext) {\n      initialCalendar.dispatch({\n        type: 'UNSET_EVENT_DRAG'\n      });\n    }\n  };\n\n  EventDragging.prototype.cleanup = function () {\n    this.subjectSeg = null;\n    this.isDragging = false;\n    this.eventRange = null;\n    this.relevantEvents = null;\n    this.receivingContext = null;\n    this.validMutation = null;\n    this.mutatedRelevantEvents = null;\n  }; // TODO: test this in IE11\n  // QUESTION: why do we need it on the resizable???\n\n\n  EventDragging.SELECTOR = '.fc-event-draggable, .fc-event-resizable';\n  return EventDragging;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction);\n\nfunction computeEventMutation(hit0, hit1, massagers) {\n  var dateSpan0 = hit0.dateSpan;\n  var dateSpan1 = hit1.dateSpan;\n  var date0 = dateSpan0.range.start;\n  var date1 = dateSpan1.range.start;\n  var standardProps = {};\n\n  if (dateSpan0.allDay !== dateSpan1.allDay) {\n    standardProps.allDay = dateSpan1.allDay;\n    standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;\n\n    if (dateSpan1.allDay) {\n      // means date1 is already start-of-day,\n      // but date0 needs to be converted\n      date0 = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.startOfDay)(date0);\n    }\n  }\n\n  var delta = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffDates)(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);\n\n  if (delta.milliseconds) {\n    // has hours/minutes/seconds\n    standardProps.allDay = false;\n  }\n\n  var mutation = {\n    datesDelta: delta,\n    standardProps: standardProps\n  };\n\n  for (var _i = 0, massagers_1 = massagers; _i < massagers_1.length; _i++) {\n    var massager = massagers_1[_i];\n    massager(mutation, hit0, hit1);\n  }\n\n  return mutation;\n}\n\nfunction getComponentTouchDelay(component) {\n  var options = component.context.options;\n  var delay = options.eventLongPressDelay;\n\n  if (delay == null) {\n    delay = options.longPressDelay;\n  }\n\n  return delay;\n}\n\nvar EventResizing = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(EventResizing, _super);\n\n  function EventResizing(settings) {\n    var _this = _super.call(this, settings) || this; // internal state\n\n\n    _this.draggingSegEl = null;\n    _this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?\n\n    _this.eventRange = null;\n    _this.relevantEvents = null;\n    _this.validMutation = null;\n    _this.mutatedRelevantEvents = null;\n\n    _this.handlePointerDown = function (ev) {\n      var component = _this.component;\n\n      var segEl = _this.querySegEl(ev);\n\n      var seg = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElSeg)(segEl);\n      var eventRange = _this.eventRange = seg.eventRange;\n      _this.dragging.minDistance = component.context.options.eventDragMinDistance; // if touch, need to be working with a selected event\n\n      _this.dragging.setIgnoreMove(!_this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && _this.component.props.eventSelection !== eventRange.instance.instanceId);\n    };\n\n    _this.handleDragStart = function (ev) {\n      var context = _this.component.context;\n      var eventRange = _this.eventRange;\n      _this.relevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getRelevantEvents)(context.getCurrentData().eventStore, _this.eventRange.instance.instanceId);\n\n      var segEl = _this.querySegEl(ev);\n\n      _this.draggingSegEl = segEl;\n      _this.draggingSeg = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElSeg)(segEl);\n      context.calendarApi.unselect();\n      context.emitter.trigger('eventResizeStart', {\n        el: segEl,\n        event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(context, eventRange.def, eventRange.instance),\n        jsEvent: ev.origEvent,\n        view: context.viewApi\n      });\n    };\n\n    _this.handleHitUpdate = function (hit, isFinal, ev) {\n      var context = _this.component.context;\n      var relevantEvents = _this.relevantEvents;\n      var initialHit = _this.hitDragging.initialHit;\n      var eventInstance = _this.eventRange.instance;\n      var mutation = null;\n      var mutatedRelevantEvents = null;\n      var isInvalid = false;\n      var interaction = {\n        affectedEvents: relevantEvents,\n        mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n        isEvent: true\n      };\n\n      if (hit) {\n        var disallowed = hit.componentId === initialHit.componentId && _this.isHitComboAllowed && !_this.isHitComboAllowed(initialHit, hit);\n\n        if (!disallowed) {\n          mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-event-resizer-start'), eventInstance.range);\n        }\n      }\n\n      if (mutation) {\n        mutatedRelevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyMutationToEventStore)(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);\n        interaction.mutatedEvents = mutatedRelevantEvents;\n\n        if (!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isInteractionValid)(interaction, hit.dateProfile, context)) {\n          isInvalid = true;\n          mutation = null;\n          mutatedRelevantEvents = null;\n          interaction.mutatedEvents = null;\n        }\n      }\n\n      if (mutatedRelevantEvents) {\n        context.dispatch({\n          type: 'SET_EVENT_RESIZE',\n          state: interaction\n        });\n      } else {\n        context.dispatch({\n          type: 'UNSET_EVENT_RESIZE'\n        });\n      }\n\n      if (!isInvalid) {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n      } else {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n      }\n\n      if (!isFinal) {\n        if (mutation && isHitsEqual(initialHit, hit)) {\n          mutation = null;\n        }\n\n        _this.validMutation = mutation;\n        _this.mutatedRelevantEvents = mutatedRelevantEvents;\n      }\n    };\n\n    _this.handleDragEnd = function (ev) {\n      var context = _this.component.context;\n      var eventDef = _this.eventRange.def;\n      var eventInstance = _this.eventRange.instance;\n      var eventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(context, eventDef, eventInstance);\n      var relevantEvents = _this.relevantEvents;\n      var mutatedRelevantEvents = _this.mutatedRelevantEvents;\n      context.emitter.trigger('eventResizeStop', {\n        el: _this.draggingSegEl,\n        event: eventApi,\n        jsEvent: ev.origEvent,\n        view: context.viewApi\n      });\n\n      if (_this.validMutation) {\n        var updatedEventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n        context.dispatch({\n          type: 'MERGE_EVENTS',\n          eventStore: mutatedRelevantEvents\n        });\n        var eventChangeArg = {\n          oldEvent: eventApi,\n          event: updatedEventApi,\n          relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(mutatedRelevantEvents, context, eventInstance),\n          revert: function () {\n            context.dispatch({\n              type: 'MERGE_EVENTS',\n              eventStore: relevantEvents // the pre-change events\n\n            });\n          }\n        };\n        context.emitter.trigger('eventResize', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventChangeArg), {\n          el: _this.draggingSegEl,\n          startDelta: _this.validMutation.startDelta || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createDuration)(0),\n          endDelta: _this.validMutation.endDelta || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createDuration)(0),\n          jsEvent: ev.origEvent,\n          view: context.viewApi\n        }));\n        context.emitter.trigger('eventChange', eventChangeArg);\n      } else {\n        context.emitter.trigger('_noEventResize');\n      } // reset all internal state\n\n\n      _this.draggingSeg = null;\n      _this.relevantEvents = null;\n      _this.validMutation = null; // okay to keep eventInstance around. useful to set it in handlePointerDown\n    };\n\n    var component = settings.component;\n    var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n    dragging.pointer.selector = '.fc-event-resizer';\n    dragging.touchScrollAllowed = false;\n    dragging.autoScroller.isEnabled = component.context.options.dragScroll;\n    var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsToStore)(settings));\n    hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n    hitDragging.emitter.on('dragstart', _this.handleDragStart);\n    hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);\n    hitDragging.emitter.on('dragend', _this.handleDragEnd);\n    return _this;\n  }\n\n  EventResizing.prototype.destroy = function () {\n    this.dragging.destroy();\n  };\n\n  EventResizing.prototype.querySegEl = function (ev) {\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(ev.subjectEl, '.fc-event');\n  };\n\n  return EventResizing;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction);\n\nfunction computeMutation(hit0, hit1, isFromStart, instanceRange) {\n  var dateEnv = hit0.context.dateEnv;\n  var date0 = hit0.dateSpan.range.start;\n  var date1 = hit1.dateSpan.range.start;\n  var delta = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffDates)(date0, date1, dateEnv, hit0.largeUnit);\n\n  if (isFromStart) {\n    if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {\n      return {\n        startDelta: delta\n      };\n    }\n  } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {\n    return {\n      endDelta: delta\n    };\n  }\n\n  return null;\n}\n\nvar UnselectAuto = function () {\n  function UnselectAuto(context) {\n    var _this = this;\n\n    this.context = context;\n    this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system\n\n    this.matchesCancel = false;\n    this.matchesEvent = false;\n\n    this.onSelect = function (selectInfo) {\n      if (selectInfo.jsEvent) {\n        _this.isRecentPointerDateSelect = true;\n      }\n    };\n\n    this.onDocumentPointerDown = function (pev) {\n      var unselectCancel = _this.context.options.unselectCancel;\n      var downEl = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getEventTargetViaRoot)(pev.origEvent);\n      _this.matchesCancel = !!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(downEl, unselectCancel);\n      _this.matchesEvent = !!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(downEl, EventDragging.SELECTOR); // interaction started on an event?\n    };\n\n    this.onDocumentPointerUp = function (pev) {\n      var context = _this.context;\n      var documentPointer = _this.documentPointer;\n      var calendarState = context.getCurrentData(); // touch-scrolling should never unfocus any type of selection\n\n      if (!documentPointer.wasTouchScroll) {\n        if (calendarState.dateSelection && // an existing date selection?\n        !_this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?\n        ) {\n          var unselectAuto = context.options.unselectAuto;\n\n          if (unselectAuto && (!unselectAuto || !_this.matchesCancel)) {\n            context.calendarApi.unselect(pev);\n          }\n        }\n\n        if (calendarState.eventSelection && // an existing event selected?\n        !_this.matchesEvent // interaction DIDN'T start on an event\n        ) {\n          context.dispatch({\n            type: 'UNSELECT_EVENT'\n          });\n        }\n      }\n\n      _this.isRecentPointerDateSelect = false;\n    };\n\n    var documentPointer = this.documentPointer = new PointerDragging(document);\n    documentPointer.shouldIgnoreMove = true;\n    documentPointer.shouldWatchScroll = false;\n    documentPointer.emitter.on('pointerdown', this.onDocumentPointerDown);\n    documentPointer.emitter.on('pointerup', this.onDocumentPointerUp);\n    /*\n    TODO: better way to know about whether there was a selection with the pointer\n    */\n\n    context.emitter.on('select', this.onSelect);\n  }\n\n  UnselectAuto.prototype.destroy = function () {\n    this.context.emitter.off('select', this.onSelect);\n    this.documentPointer.destroy();\n  };\n\n  return UnselectAuto;\n}();\n\nvar OPTION_REFINERS = {\n  fixedMirrorParent: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity\n};\nvar LISTENER_REFINERS = {\n  dateClick: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventDragStart: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventDragStop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventDrop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventResizeStart: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventResizeStop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventResize: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  drop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventReceive: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventLeave: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity\n};\n/*\nGiven an already instantiated draggable object for one-or-more elements,\nInterprets any dragging as an attempt to drag an events that lives outside\nof a calendar onto a calendar.\n*/\n\nvar ExternalElementDragging = function () {\n  function ExternalElementDragging(dragging, suppliedDragMeta) {\n    var _this = this;\n\n    this.receivingContext = null;\n    this.droppableEvent = null; // will exist for all drags, even if create:false\n\n    this.suppliedDragMeta = null;\n    this.dragMeta = null;\n\n    this.handleDragStart = function (ev) {\n      _this.dragMeta = _this.buildDragMeta(ev.subjectEl);\n    };\n\n    this.handleHitUpdate = function (hit, isFinal, ev) {\n      var dragging = _this.hitDragging.dragging;\n      var receivingContext = null;\n      var droppableEvent = null;\n      var isInvalid = false;\n      var interaction = {\n        affectedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n        mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n        isEvent: _this.dragMeta.create\n      };\n\n      if (hit) {\n        receivingContext = hit.context;\n\n        if (_this.canDropElOnCalendar(ev.subjectEl, receivingContext)) {\n          droppableEvent = computeEventForDateSpan(hit.dateSpan, _this.dragMeta, receivingContext);\n          interaction.mutatedEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.eventTupleToStore)(droppableEvent);\n          isInvalid = !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isInteractionValid)(interaction, hit.dateProfile, receivingContext);\n\n          if (isInvalid) {\n            interaction.mutatedEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)();\n            droppableEvent = null;\n          }\n        }\n      }\n\n      _this.displayDrag(receivingContext, interaction); // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)\n      // TODO: wish we could somehow wait for dispatch to guarantee render\n\n\n      dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector('.fc-event-mirror'));\n\n      if (!isInvalid) {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n      } else {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n      }\n\n      if (!isFinal) {\n        dragging.setMirrorNeedsRevert(!droppableEvent);\n        _this.receivingContext = receivingContext;\n        _this.droppableEvent = droppableEvent;\n      }\n    };\n\n    this.handleDragEnd = function (pev) {\n      var _a = _this,\n          receivingContext = _a.receivingContext,\n          droppableEvent = _a.droppableEvent;\n\n      _this.clearDrag();\n\n      if (receivingContext && droppableEvent) {\n        var finalHit = _this.hitDragging.finalHit;\n        var finalView = finalHit.context.viewApi;\n        var dragMeta = _this.dragMeta;\n        receivingContext.emitter.trigger('drop', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {\n          draggedEl: pev.subjectEl,\n          jsEvent: pev.origEvent,\n          view: finalView\n        }));\n\n        if (dragMeta.create) {\n          var addingEvents_1 = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.eventTupleToStore)(droppableEvent);\n          receivingContext.dispatch({\n            type: 'MERGE_EVENTS',\n            eventStore: addingEvents_1\n          });\n\n          if (pev.isTouch) {\n            receivingContext.dispatch({\n              type: 'SELECT_EVENT',\n              eventInstanceId: droppableEvent.instance.instanceId\n            });\n          } // signal that an external event landed\n\n\n          receivingContext.emitter.trigger('eventReceive', {\n            event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(receivingContext, droppableEvent.def, droppableEvent.instance),\n            relatedEvents: [],\n            revert: function () {\n              receivingContext.dispatch({\n                type: 'REMOVE_EVENTS',\n                eventStore: addingEvents_1\n              });\n            },\n            draggedEl: pev.subjectEl,\n            view: finalView\n          });\n        }\n      }\n\n      _this.receivingContext = null;\n      _this.droppableEvent = null;\n    };\n\n    var hitDragging = this.hitDragging = new HitDragging(dragging, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsStore);\n    hitDragging.requireInitial = false; // will start outside of a component\n\n    hitDragging.emitter.on('dragstart', this.handleDragStart);\n    hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n    hitDragging.emitter.on('dragend', this.handleDragEnd);\n    this.suppliedDragMeta = suppliedDragMeta;\n  }\n\n  ExternalElementDragging.prototype.buildDragMeta = function (subjectEl) {\n    if (typeof this.suppliedDragMeta === 'object') {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseDragMeta)(this.suppliedDragMeta);\n    }\n\n    if (typeof this.suppliedDragMeta === 'function') {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseDragMeta)(this.suppliedDragMeta(subjectEl));\n    }\n\n    return getDragMetaFromEl(subjectEl);\n  };\n\n  ExternalElementDragging.prototype.displayDrag = function (nextContext, state) {\n    var prevContext = this.receivingContext;\n\n    if (prevContext && prevContext !== nextContext) {\n      prevContext.dispatch({\n        type: 'UNSET_EVENT_DRAG'\n      });\n    }\n\n    if (nextContext) {\n      nextContext.dispatch({\n        type: 'SET_EVENT_DRAG',\n        state: state\n      });\n    }\n  };\n\n  ExternalElementDragging.prototype.clearDrag = function () {\n    if (this.receivingContext) {\n      this.receivingContext.dispatch({\n        type: 'UNSET_EVENT_DRAG'\n      });\n    }\n  };\n\n  ExternalElementDragging.prototype.canDropElOnCalendar = function (el, receivingContext) {\n    var dropAccept = receivingContext.options.dropAccept;\n\n    if (typeof dropAccept === 'function') {\n      return dropAccept.call(receivingContext.calendarApi, el);\n    }\n\n    if (typeof dropAccept === 'string' && dropAccept) {\n      return Boolean((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementMatches)(el, dropAccept));\n    }\n\n    return true;\n  };\n\n  return ExternalElementDragging;\n}(); // Utils for computing event store from the DragMeta\n// ----------------------------------------------------------------------------------------------------\n\n\nfunction computeEventForDateSpan(dateSpan, dragMeta, context) {\n  var defProps = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, dragMeta.leftoverProps);\n\n  for (var _i = 0, _a = context.pluginHooks.externalDefTransforms; _i < _a.length; _i++) {\n    var transform = _a[_i];\n\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(defProps, transform(dateSpan, dragMeta));\n  }\n\n  var _b = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.refineEventDef)(defProps, context),\n      refined = _b.refined,\n      extra = _b.extra;\n\n  var def = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseEventDef)(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration), // hasEnd\n  context);\n  var start = dateSpan.range.start; // only rely on time info if drop zone is all-day,\n  // otherwise, we already know the time\n\n  if (dateSpan.allDay && dragMeta.startTime) {\n    start = context.dateEnv.add(start, dragMeta.startTime);\n  }\n\n  var end = dragMeta.duration ? context.dateEnv.add(start, dragMeta.duration) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getDefaultEventEnd)(dateSpan.allDay, start, context);\n  var instance = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEventInstance)(def.defId, {\n    start: start,\n    end: end\n  });\n  return {\n    def: def,\n    instance: instance\n  };\n} // Utils for extracting data from element\n// ----------------------------------------------------------------------------------------------------\n\n\nfunction getDragMetaFromEl(el) {\n  var str = getEmbeddedElData(el, 'event');\n  var obj = str ? JSON.parse(str) : {\n    create: false\n  }; // if no embedded data, assume no event creation\n\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseDragMeta)(obj);\n}\n\n_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.dataAttrPrefix = '';\n\nfunction getEmbeddedElData(el, name) {\n  var prefix = _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.dataAttrPrefix;\n  var prefixedName = (prefix ? prefix + '-' : '') + name;\n  return el.getAttribute('data-' + prefixedName) || '';\n}\n/*\nMakes an element (that is *external* to any calendar) draggable.\nCan pass in data that determines how an event will be created when dropped onto a calendar.\nLeverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.\n*/\n\n\nvar ExternalDraggable = function () {\n  function ExternalDraggable(el, settings) {\n    var _this = this;\n\n    if (settings === void 0) {\n      settings = {};\n    }\n\n    this.handlePointerDown = function (ev) {\n      var dragging = _this.dragging;\n      var _a = _this.settings,\n          minDistance = _a.minDistance,\n          longPressDelay = _a.longPressDelay;\n      dragging.minDistance = minDistance != null ? minDistance : ev.isTouch ? 0 : _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BASE_OPTION_DEFAULTS.eventDragMinDistance;\n      dragging.delay = ev.isTouch ? longPressDelay != null ? longPressDelay : _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BASE_OPTION_DEFAULTS.longPressDelay : 0;\n    };\n\n    this.handleDragStart = function (ev) {\n      if (ev.isTouch && _this.dragging.delay && ev.subjectEl.classList.contains('fc-event')) {\n        _this.dragging.mirror.getMirrorEl().classList.add('fc-event-selected');\n      }\n    };\n\n    this.settings = settings;\n    var dragging = this.dragging = new FeaturefulElementDragging(el);\n    dragging.touchScrollAllowed = false;\n\n    if (settings.itemSelector != null) {\n      dragging.pointer.selector = settings.itemSelector;\n    }\n\n    if (settings.appendTo != null) {\n      dragging.mirror.parentNode = settings.appendTo; // TODO: write tests\n    }\n\n    dragging.emitter.on('pointerdown', this.handlePointerDown);\n    dragging.emitter.on('dragstart', this.handleDragStart);\n    new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n  }\n\n  ExternalDraggable.prototype.destroy = function () {\n    this.dragging.destroy();\n  };\n\n  return ExternalDraggable;\n}();\n/*\nDetects when a *THIRD-PARTY* drag-n-drop system interacts with elements.\nThe third-party system is responsible for drawing the visuals effects of the drag.\nThis class simply monitors for pointer movements and fires events.\nIt also has the ability to hide the moving element (the \"mirror\") during the drag.\n*/\n\n\nvar InferredElementDragging = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(InferredElementDragging, _super);\n\n  function InferredElementDragging(containerEl) {\n    var _this = _super.call(this, containerEl) || this;\n\n    _this.shouldIgnoreMove = false;\n    _this.mirrorSelector = '';\n    _this.currentMirrorEl = null;\n\n    _this.handlePointerDown = function (ev) {\n      _this.emitter.trigger('pointerdown', ev);\n\n      if (!_this.shouldIgnoreMove) {\n        // fire dragstart right away. does not support delay or min-distance\n        _this.emitter.trigger('dragstart', ev);\n      }\n    };\n\n    _this.handlePointerMove = function (ev) {\n      if (!_this.shouldIgnoreMove) {\n        _this.emitter.trigger('dragmove', ev);\n      }\n    };\n\n    _this.handlePointerUp = function (ev) {\n      _this.emitter.trigger('pointerup', ev);\n\n      if (!_this.shouldIgnoreMove) {\n        // fire dragend right away. does not support a revert animation\n        _this.emitter.trigger('dragend', ev);\n      }\n    };\n\n    var pointer = _this.pointer = new PointerDragging(containerEl);\n    pointer.emitter.on('pointerdown', _this.handlePointerDown);\n    pointer.emitter.on('pointermove', _this.handlePointerMove);\n    pointer.emitter.on('pointerup', _this.handlePointerUp);\n    return _this;\n  }\n\n  InferredElementDragging.prototype.destroy = function () {\n    this.pointer.destroy();\n  };\n\n  InferredElementDragging.prototype.setIgnoreMove = function (bool) {\n    this.shouldIgnoreMove = bool;\n  };\n\n  InferredElementDragging.prototype.setMirrorIsVisible = function (bool) {\n    if (bool) {\n      // restore a previously hidden element.\n      // use the reference in case the selector class has already been removed.\n      if (this.currentMirrorEl) {\n        this.currentMirrorEl.style.visibility = '';\n        this.currentMirrorEl = null;\n      }\n    } else {\n      var mirrorEl = this.mirrorSelector // TODO: somehow query FullCalendars WITHIN shadow-roots\n      ? document.querySelector(this.mirrorSelector) : null;\n\n      if (mirrorEl) {\n        this.currentMirrorEl = mirrorEl;\n        mirrorEl.style.visibility = 'hidden';\n      }\n    }\n  };\n\n  return InferredElementDragging;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ElementDragging);\n/*\nBridges third-party drag-n-drop systems with FullCalendar.\nMust be instantiated and destroyed by caller.\n*/\n\n\nvar ThirdPartyDraggable = function () {\n  function ThirdPartyDraggable(containerOrSettings, settings) {\n    var containerEl = document;\n\n    if ( // wish we could just test instanceof EventTarget, but doesn't work in IE11\n    containerOrSettings === document || containerOrSettings instanceof Element) {\n      containerEl = containerOrSettings;\n      settings = settings || {};\n    } else {\n      settings = containerOrSettings || {};\n    }\n\n    var dragging = this.dragging = new InferredElementDragging(containerEl);\n\n    if (typeof settings.itemSelector === 'string') {\n      dragging.pointer.selector = settings.itemSelector;\n    } else if (containerEl === document) {\n      dragging.pointer.selector = '[data-event]';\n    }\n\n    if (typeof settings.mirrorSelector === 'string') {\n      dragging.mirrorSelector = settings.mirrorSelector;\n    }\n\n    new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n  }\n\n  ThirdPartyDraggable.prototype.destroy = function () {\n    this.dragging.destroy();\n  };\n\n  return ThirdPartyDraggable;\n}();\n\nvar main = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createPlugin)({\n  componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],\n  calendarInteractions: [UnselectAuto],\n  elementDraggingImpl: FeaturefulElementDragging,\n  optionRefiners: OPTION_REFINERS,\n  listenerRefiners: LISTENER_REFINERS\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (main);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbi9tYWluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FBbUNBO0FBQUE7O0FBcEJBOztBQUlBOztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUEwREE7QUFDQTtBQUtBOztBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFDQTs7OztBQVNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBS0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQTRCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBOztBQTNMQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQXNDQTtBQUNBO0FBQ0E7OztBQStEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7O0FBQ0E7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDclZBOzs7Ozs7O0FBS0E7QUFBQTtBQUNBOztBQUtBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBQ0E7QUFDQTtBQTZIQTs7QUEzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBO0FDL0lBOzs7Ozs7Ozs7O0FBUUE7QUFBQTs7QUFjQTtBQUFBOztBQTBCQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUE1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFRQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQWhHQTs7QUNQQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBWkE7O0FDQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7QUF2QkE7QUNTQTtBQUNBOzs7QUFDQTtBQUVBOzs7Ozs7O0FBTUE7QUFBQTtBQUFBOzs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQThEQTtBQUNBO0FBQUE7QUFDQTs7QUFLQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1HQTs7QUE5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFiQTtBQWVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQzVNQTs7Ozs7Ozs7O0FBTUE7O0FBa0JBO0FBQUE7O0FBQUE7OztBQVhBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUEwQkE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUVBOztBQUlBOzs7QUFDQTs7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUVBOztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7OztBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFFQTtBQUNBOzs7QUFJQTtBQUNBOztBQXNGQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFsTUE7QUNaQTs7Ozs7Ozs7OztBQVFBO0FBSUE7QUFDQTs7QUFHQTtBQUNBO0FBQUE7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7O0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBO0FBR0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FDOURBOzs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQWdCQTtBQUFBOzs7QUFWQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTs7QUFnQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBOEJBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBbkZBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7OztBQXdCQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBMkJBO0FBQ0E7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFHQTs7QUFDQTtBQUdBO0FBSUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQ3hNQTtBQUNBOztBQUVBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSEE7QUFLQTtBQ3RCQTs7Ozs7O0FBSUE7QUFBQTs7QUFJQTtBQUFBOztBQWdCQTtBQUNBO0FBQ0E7O0FBR0E7QUFHQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7O0FBMUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQWlDQTtBQW5EQTtBQ1RBOzs7Ozs7QUFJQTtBQUFBOztBQUtBO0FBQUE7O0FBRkE7O0FBdUJBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7QUFJQTs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUlBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBOztBQXRGQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFzRUE7QUE5RkE7O0FBZ0dBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBRUE7O0FBRUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTs7QUNqSEE7QUFBQTs7QUFrQkE7QUFBQTs7O0FBVEE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQXlCQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFFQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBSUE7OztBQUlBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBSUE7O0FBRUE7QUFDQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUVBOzs7O0FBSUE7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFPQTs7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUZBO0FBSUE7QUFUQTtBQVlBOztBQUNBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBUkE7QUFXQTtBQUVBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVJBO0FBV0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUVBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUEzVEE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUEyU0E7QUFDQTtBQUNBOztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBRkE7QUFVQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFsWUE7QUFtWUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBUUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDN2JBO0FBQUE7O0FBWUE7QUFBQTs7O0FBUEE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFzQkE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBRUE7O0FBR0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFLQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBOztBQUlBO0FBQ0E7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU9BO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRkE7QUFJQTtBQVRBO0FBWUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBR0E7O0FBcExBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFzS0E7QUFDQTtBQUNBOztBQUNBO0FBdk1BOztBQXlNQTtBQU1BO0FBQ0E7QUFDQTtBQUVBOztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUM1UEE7QUFNQTtBQUFBOztBQUFBO0FBSkE7O0FBQ0E7QUFDQTs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBRkE7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUE0Q0E7QUFBQTs7QUNsRUE7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FDa0JBOzs7Ozs7QUFLQTtBQU9BO0FBQUE7O0FBTEE7QUFDQTs7QUFDQTtBQUNBOztBQVlBO0FBQ0E7QUFDQTs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBbklBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFnSEE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFHQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUNBO0FBTUE7QUFHQTs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FDL1BBOzs7Ozs7OztBQVNBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQW9CQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFLQTtBQUlBOztBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7O0FBMUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQTJCQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQ2xFQTs7Ozs7Ozs7QUFNQTtBQUFBOztBQU1BO0FBQUE7O0FBSkE7QUFDQTtBQUNBOztBQWVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBaENBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUEwQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQW5FQTtBQ0FBOzs7Ozs7O0FBT0E7QUFJQTs7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kbmQvUG9pbnRlckRyYWdnaW5nLnRzPzk0NWEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RuZC9FbGVtZW50TWlycm9yLnRzPzExMTEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1Njcm9sbEdlb21DYWNoZS50cz9hNzA4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9FbGVtZW50U2Nyb2xsR2VvbUNhY2hlLnRzPzJjM2QiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1dpbmRvd1Njcm9sbEdlb21DYWNoZS50cz85YTExIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kbmQvQXV0b1Njcm9sbGVyLnRzPzZmZTkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RuZC9GZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnRzPzRiNGEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL09mZnNldFRyYWNrZXIudHM/NGIzNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaW50ZXJhY3Rpb25zL0hpdERyYWdnaW5nLnRzP2RjNjgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzLnRzP2VhMDUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy9EYXRlQ2xpY2tpbmcudHM/MGIwNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaW50ZXJhY3Rpb25zL0RhdGVTZWxlY3RpbmcudHM/MjBmYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaW50ZXJhY3Rpb25zL0V2ZW50RHJhZ2dpbmcudHM/YTY4NyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaW50ZXJhY3Rpb25zL0V2ZW50UmVzaXppbmcudHM/MDdhNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaW50ZXJhY3Rpb25zL1Vuc2VsZWN0QXV0by50cz9lYjU4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9vcHRpb25zLnRzPzkxODEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy1leHRlcm5hbC9FeHRlcm5hbEVsZW1lbnREcmFnZ2luZy50cz9mOTRhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9pbnRlcmFjdGlvbnMtZXh0ZXJuYWwvRXh0ZXJuYWxEcmFnZ2FibGUudHM/MDkyNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaW50ZXJhY3Rpb25zLWV4dGVybmFsL0luZmVycmVkRWxlbWVudERyYWdnaW5nLnRzP2RjOWQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy1leHRlcm5hbC9UaGlyZFBhcnR5RHJhZ2dhYmxlLnRzP2YxYTgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL21haW4udHM/Yjk5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25maWcsIGVsZW1lbnRDbG9zZXN0LCBFbWl0dGVyLCBQb2ludGVyRHJhZ0V2ZW50IH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5cbmNvbmZpZy50b3VjaE1vdXNlSWdub3JlV2FpdCA9IDUwMFxuXG5sZXQgaWdub3JlTW91c2VEZXB0aCA9IDBcbmxldCBsaXN0ZW5lckNudCA9IDBcbmxldCBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IGZhbHNlXG5cbi8qXG5Vc2VzIGEgXCJwb2ludGVyXCIgYWJzdHJhY3Rpb24sIHdoaWNoIG1vbml0b3JzIFVJIGV2ZW50cyBmb3IgYm90aCBtb3VzZSBhbmQgdG91Y2guXG5UcmFja3Mgd2hlbiB0aGUgcG9pbnRlciBcImRyYWdzXCIgb24gYSBjZXJ0YWluIGVsZW1lbnQsIG1lYW5pbmcgZG93bittb3ZlK3VwLlxuXG5BbHNvLCB0cmFja3MgaWYgdGhlcmUgd2FzIHRvdWNoLXNjcm9sbGluZy5cbkFsc28sIGNhbiBwcmV2ZW50IHRvdWNoLXNjcm9sbGluZyBmcm9tIGhhcHBlbmluZy5cbkFsc28sIGNhbiBmaXJlIHBvaW50ZXJtb3ZlIGV2ZW50cyB3aGVuIHNjcm9sbGluZyBoYXBwZW5zIHVuZGVybmVhdGgsIGV2ZW4gd2hlbiBubyByZWFsIHBvaW50ZXIgbW92ZW1lbnQuXG5cbmVtaXRzOlxuLSBwb2ludGVyZG93blxuLSBwb2ludGVybW92ZVxuLSBwb2ludGVydXBcbiovXG5leHBvcnQgY2xhc3MgUG9pbnRlckRyYWdnaW5nIHtcbiAgY29udGFpbmVyRWw6IEV2ZW50VGFyZ2V0XG4gIHN1YmplY3RFbDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbFxuICBlbWl0dGVyOiBFbWl0dGVyPGFueT5cblxuICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IGFzc2lnbmVkIGJ5IGNhbGxlclxuICBzZWxlY3Rvcjogc3RyaW5nID0gJycgLy8gd2lsbCBjYXVzZSBzdWJqZWN0RWwgaW4gYWxsIGVtaXR0ZWQgZXZlbnRzIHRvIGJlIHRoaXMgZWxlbWVudFxuICBoYW5kbGVTZWxlY3Rvcjogc3RyaW5nID0gJydcbiAgc2hvdWxkSWdub3JlTW92ZTogYm9vbGVhbiA9IGZhbHNlXG4gIHNob3VsZFdhdGNoU2Nyb2xsOiBib29sZWFuID0gdHJ1ZSAvLyBmb3Igc2ltdWxhdGluZyBwb2ludGVybW92ZSBvbiBzY3JvbGxcblxuICAvLyBpbnRlcm5hbCBzdGF0ZXNcbiAgaXNEcmFnZ2luZzogYm9vbGVhbiA9IGZhbHNlXG4gIGlzVG91Y2hEcmFnZ2luZzogYm9vbGVhbiA9IGZhbHNlXG4gIHdhc1RvdWNoU2Nyb2xsOiBib29sZWFuID0gZmFsc2VcbiAgb3JpZ1BhZ2VYOiBudW1iZXJcbiAgb3JpZ1BhZ2VZOiBudW1iZXJcbiAgcHJldlBhZ2VYOiBudW1iZXJcbiAgcHJldlBhZ2VZOiBudW1iZXJcbiAgcHJldlNjcm9sbFg6IG51bWJlciAvLyBhdCB0aW1lIG9mIGxhc3QgcG9pbnRlciBwYWdlWC9wYWdlWSBjYXB0dXJlXG4gIHByZXZTY3JvbGxZOiBudW1iZXIgLy8gXCJcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJFbDogRXZlbnRUYXJnZXQpIHtcbiAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWxcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpXG4gICAgY29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24gYXMgRXZlbnRMaXN0ZW5lcilcbiAgICBjb250YWluZXJFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0IGFzIEV2ZW50TGlzdGVuZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KVxuICAgIGxpc3RlbmVyQ3JlYXRlZCgpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY29udGFpbmVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24gYXMgRXZlbnRMaXN0ZW5lcilcbiAgICB0aGlzLmNvbnRhaW5lckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQgYXMgRXZlbnRMaXN0ZW5lciwgeyBwYXNzaXZlOiB0cnVlIH0gYXMgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpXG4gICAgbGlzdGVuZXJEZXN0cm95ZWQoKVxuICB9XG5cbiAgdHJ5U3RhcnQoZXY6IFVJRXZlbnQpOiBib29sZWFuIHtcbiAgICBsZXQgc3ViamVjdEVsID0gdGhpcy5xdWVyeVN1YmplY3RFbChldilcbiAgICBsZXQgZG93bkVsID0gZXYudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG5cbiAgICBpZiAoXG4gICAgICBzdWJqZWN0RWwgJiZcbiAgICAgICghdGhpcy5oYW5kbGVTZWxlY3RvciB8fCBlbGVtZW50Q2xvc2VzdChkb3duRWwsIHRoaXMuaGFuZGxlU2VsZWN0b3IpKVxuICAgICkge1xuICAgICAgdGhpcy5zdWJqZWN0RWwgPSBzdWJqZWN0RWxcbiAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWUgLy8gZG8gdGhpcyBmaXJzdCBzbyBjYW5jZWxUb3VjaFNjcm9sbCB3aWxsIHdvcmtcbiAgICAgIHRoaXMud2FzVG91Y2hTY3JvbGwgPSBmYWxzZVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY2xlYW51cCgpIHtcbiAgICBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IGZhbHNlXG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICB0aGlzLnN1YmplY3RFbCA9IG51bGxcbiAgICAvLyBrZWVwIHdhc1RvdWNoU2Nyb2xsIGFyb3VuZCBmb3IgbGF0ZXIgYWNjZXNzXG4gICAgdGhpcy5kZXN0cm95U2Nyb2xsV2F0Y2goKVxuICB9XG5cbiAgcXVlcnlTdWJqZWN0RWwoZXY6IFVJRXZlbnQpOiBIVE1MRWxlbWVudCB7XG4gICAgaWYgKHRoaXMuc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIHRoaXMuc2VsZWN0b3IpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckVsIGFzIEhUTUxFbGVtZW50XG4gIH1cblxuICAvLyBNb3VzZVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgaGFuZGxlTW91c2VEb3duID0gKGV2OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSAmJlxuICAgICAgaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpICYmXG4gICAgICB0aGlzLnRyeVN0YXJ0KGV2KVxuICAgICkge1xuICAgICAgbGV0IHBldiA9IHRoaXMuY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYsIHRydWUpXG4gICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpXG4gICAgICB0aGlzLmluaXRTY3JvbGxXYXRjaChwZXYpXG5cbiAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKVxuICAgICAgfVxuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU1vdXNlTW92ZSA9IChldjogTW91c2VFdmVudCkgPT4ge1xuICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2KVxuICAgIHRoaXMucmVjb3JkQ29vcmRzKHBldilcbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBwZXYpXG4gIH1cblxuICBoYW5kbGVNb3VzZVVwID0gKGV2OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcClcblxuICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2KSlcblxuICAgIHRoaXMuY2xlYW51cCgpIC8vIGNhbGwgbGFzdCBzbyB0aGF0IHBvaW50ZXJ1cCBoYXMgYWNjZXNzIHRvIHByb3BzXG4gIH1cblxuICBzaG91bGRJZ25vcmVNb3VzZSgpIHtcbiAgICByZXR1cm4gaWdub3JlTW91c2VEZXB0aCB8fCB0aGlzLmlzVG91Y2hEcmFnZ2luZ1xuICB9XG5cbiAgLy8gVG91Y2hcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGhhbmRsZVRvdWNoU3RhcnQgPSAoZXY6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBpZiAodGhpcy50cnlTdGFydChldikpIHtcbiAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gdHJ1ZVxuXG4gICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldiwgdHJ1ZSlcbiAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIHBldilcbiAgICAgIHRoaXMuaW5pdFNjcm9sbFdhdGNoKHBldilcblxuICAgICAgLy8gdW5saWtlIG1vdXNlLCBuZWVkIHRvIGF0dGFjaCB0byB0YXJnZXQsIG5vdCBkb2N1bWVudFxuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ1NzYwMDE0XG4gICAgICBsZXQgdGFyZ2V0RWwgPSBldi50YXJnZXQgYXMgSFRNTEVsZW1lbnRcblxuICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmUpXG4gICAgICB9XG5cbiAgICAgIHRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZClcbiAgICAgIHRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5oYW5kbGVUb3VjaEVuZCkgLy8gdHJlYXQgaXQgYXMgYSB0b3VjaCBlbmRcblxuICAgICAgLy8gYXR0YWNoIGEgaGFuZGxlciB0byBnZXQgY2FsbGVkIHdoZW4gQU5ZIHNjcm9sbCBhY3Rpb24gaGFwcGVucyBvbiB0aGUgcGFnZS5cbiAgICAgIC8vIHRoaXMgd2FzIGltcG9zc2libGUgdG8gZG8gd2l0aCBub3JtYWwgb24vb2ZmIGJlY2F1c2UgJ3Njcm9sbCcgZG9lc24ndCBidWJibGUuXG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMjk1NDU2NS85NjM0MlxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdzY3JvbGwnLFxuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoU2Nyb2xsLFxuICAgICAgICB0cnVlLCAvLyB1c2VDYXB0dXJlXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlVG91Y2hNb3ZlID0gKGV2OiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgbGV0IHBldiA9IHRoaXMuY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYpXG4gICAgdGhpcy5yZWNvcmRDb29yZHMocGV2KVxuICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIHBldilcbiAgfVxuXG4gIGhhbmRsZVRvdWNoRW5kID0gKGV2OiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgaWYgKHRoaXMuaXNEcmFnZ2luZykgeyAvLyBkb25lIHRvIGd1YXJkIGFnYWluc3QgdG91Y2hlbmQgZm9sbG93ZWQgYnkgdG91Y2hjYW5jZWxcbiAgICAgIGxldCB0YXJnZXRFbCA9IGV2LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuXG4gICAgICB0YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRvdWNoTW92ZSlcbiAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZClcbiAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5oYW5kbGVUb3VjaEVuZClcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVRvdWNoU2Nyb2xsLCB0cnVlKSAvLyB1c2VDYXB0dXJlZD10cnVlXG5cbiAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCB0aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2KSlcblxuICAgICAgdGhpcy5jbGVhbnVwKCkgLy8gY2FsbCBsYXN0IHNvIHRoYXQgcG9pbnRlcnVwIGhhcyBhY2Nlc3MgdG8gcHJvcHNcbiAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gZmFsc2VcbiAgICAgIHN0YXJ0SWdub3JpbmdNb3VzZSgpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlVG91Y2hTY3JvbGwgPSAoKSA9PiB7XG4gICAgdGhpcy53YXNUb3VjaFNjcm9sbCA9IHRydWVcbiAgfVxuXG4gIC8vIGNhbiBiZSBjYWxsZWQgYnkgdXNlciBvZiB0aGlzIGNsYXNzLCB0byBjYW5jZWwgdG91Y2gtYmFzZWQgc2Nyb2xsaW5nIGZvciB0aGUgY3VycmVudCBkcmFnXG4gIGNhbmNlbFRvdWNoU2Nyb2xsKCkge1xuICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgIGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNjcm9sbGluZyB0aGF0IHNpbXVsYXRlcyBwb2ludGVybW92ZXNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGluaXRTY3JvbGxXYXRjaChldjogUG9pbnRlckRyYWdFdmVudCkge1xuICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XG4gICAgICB0aGlzLnJlY29yZENvb3JkcyhldilcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCwgdHJ1ZSkgLy8gdXNlQ2FwdHVyZT10cnVlXG4gICAgfVxuICB9XG5cbiAgcmVjb3JkQ29vcmRzKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwpIHtcbiAgICAgIHRoaXMucHJldlBhZ2VYID0gKGV2IGFzIGFueSkucGFnZVhcbiAgICAgIHRoaXMucHJldlBhZ2VZID0gKGV2IGFzIGFueSkucGFnZVlcbiAgICAgIHRoaXMucHJldlNjcm9sbFggPSB3aW5kb3cucGFnZVhPZmZzZXRcbiAgICAgIHRoaXMucHJldlNjcm9sbFkgPSB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTY3JvbGwgPSAoZXY6IFVJRXZlbnQpID0+IHtcbiAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgbGV0IHBhZ2VYID0gKHdpbmRvdy5wYWdlWE9mZnNldCAtIHRoaXMucHJldlNjcm9sbFgpICsgdGhpcy5wcmV2UGFnZVhcbiAgICAgIGxldCBwYWdlWSA9ICh3aW5kb3cucGFnZVlPZmZzZXQgLSB0aGlzLnByZXZTY3JvbGxZKSArIHRoaXMucHJldlBhZ2VZXG5cbiAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIHtcbiAgICAgICAgb3JpZ0V2ZW50OiBldixcbiAgICAgICAgaXNUb3VjaDogdGhpcy5pc1RvdWNoRHJhZ2dpbmcsXG4gICAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgIHBhZ2VYLFxuICAgICAgICBwYWdlWSxcbiAgICAgICAgZGVsdGFYOiBwYWdlWCAtIHRoaXMub3JpZ1BhZ2VYLFxuICAgICAgICBkZWx0YVk6IHBhZ2VZIC0gdGhpcy5vcmlnUGFnZVksXG4gICAgICB9IGFzIFBvaW50ZXJEcmFnRXZlbnQpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveVNjcm9sbFdhdGNoKCkge1xuICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwsIHRydWUpIC8vIHVzZUNhcHR1cmVkPXRydWVcbiAgICB9XG4gIH1cblxuICAvLyBFdmVudCBOb3JtYWxpemF0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBjcmVhdGVFdmVudEZyb21Nb3VzZShldjogTW91c2VFdmVudCwgaXNGaXJzdD86IGJvb2xlYW4pOiBQb2ludGVyRHJhZ0V2ZW50IHtcbiAgICBsZXQgZGVsdGFYID0gMFxuICAgIGxldCBkZWx0YVkgPSAwXG5cbiAgICAvLyBUT0RPOiByZXBlYXQgY29kZVxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICB0aGlzLm9yaWdQYWdlWCA9IGV2LnBhZ2VYXG4gICAgICB0aGlzLm9yaWdQYWdlWSA9IGV2LnBhZ2VZXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbHRhWCA9IGV2LnBhZ2VYIC0gdGhpcy5vcmlnUGFnZVhcbiAgICAgIGRlbHRhWSA9IGV2LnBhZ2VZIC0gdGhpcy5vcmlnUGFnZVlcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb3JpZ0V2ZW50OiBldixcbiAgICAgIGlzVG91Y2g6IGZhbHNlLFxuICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgIHBhZ2VYOiBldi5wYWdlWCxcbiAgICAgIHBhZ2VZOiBldi5wYWdlWSxcbiAgICAgIGRlbHRhWCxcbiAgICAgIGRlbHRhWSxcbiAgICB9XG4gIH1cblxuICBjcmVhdGVFdmVudEZyb21Ub3VjaChldjogVG91Y2hFdmVudCwgaXNGaXJzdD86IGJvb2xlYW4pOiBQb2ludGVyRHJhZ0V2ZW50IHtcbiAgICBsZXQgdG91Y2hlcyA9IGV2LnRvdWNoZXNcbiAgICBsZXQgcGFnZVhcbiAgICBsZXQgcGFnZVlcbiAgICBsZXQgZGVsdGFYID0gMFxuICAgIGxldCBkZWx0YVkgPSAwXG5cbiAgICAvLyBpZiB0b3VjaCBjb29yZHMgYXZhaWxhYmxlLCBwcmVmZXIsXG4gICAgLy8gYmVjYXVzZSBGRiB3b3VsZCBnaXZlIGJhZCBldi5wYWdlWCBldi5wYWdlWVxuICAgIGlmICh0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICBwYWdlWCA9IHRvdWNoZXNbMF0ucGFnZVhcbiAgICAgIHBhZ2VZID0gdG91Y2hlc1swXS5wYWdlWVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWdlWCA9IChldiBhcyBhbnkpLnBhZ2VYXG4gICAgICBwYWdlWSA9IChldiBhcyBhbnkpLnBhZ2VZXG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVwZWF0IGNvZGVcbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgdGhpcy5vcmlnUGFnZVggPSBwYWdlWFxuICAgICAgdGhpcy5vcmlnUGFnZVkgPSBwYWdlWVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWx0YVggPSBwYWdlWCAtIHRoaXMub3JpZ1BhZ2VYXG4gICAgICBkZWx0YVkgPSBwYWdlWSAtIHRoaXMub3JpZ1BhZ2VZXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICBpc1RvdWNoOiB0cnVlLFxuICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVksXG4gICAgICBkZWx0YVgsXG4gICAgICBkZWx0YVksXG4gICAgfVxuICB9XG59XG5cbi8vIFJldHVybnMgYSBib29sZWFuIHdoZXRoZXIgdGhpcyB3YXMgYSBsZWZ0IG1vdXNlIGNsaWNrIGFuZCBubyBjdHJsIGtleSAod2hpY2ggbWVhbnMgcmlnaHQgY2xpY2sgb24gTWFjKVxuZnVuY3Rpb24gaXNQcmltYXJ5TW91c2VCdXR0b24oZXY6IE1vdXNlRXZlbnQpIHtcbiAgcmV0dXJuIGV2LmJ1dHRvbiA9PT0gMCAmJiAhZXYuY3RybEtleVxufVxuXG4vLyBJZ25vcmluZyBmYWtlIG1vdXNlIGV2ZW50cyBnZW5lcmF0ZWQgYnkgdG91Y2hcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gc3RhcnRJZ25vcmluZ01vdXNlKCkgeyAvLyBjYW4gYmUgbWFkZSBub24tY2xhc3MgZnVuY3Rpb25cbiAgaWdub3JlTW91c2VEZXB0aCArPSAxXG5cbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWdub3JlTW91c2VEZXB0aCAtPSAxXG4gIH0sIGNvbmZpZy50b3VjaE1vdXNlSWdub3JlV2FpdClcbn1cblxuLy8gV2Ugd2FudCB0byBhdHRhY2ggdG91Y2htb3ZlIGFzIGVhcmx5IGFzIHBvc3NpYmxlIGZvciBTYWZhcmlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gbGlzdGVuZXJDcmVhdGVkKCkge1xuICBsaXN0ZW5lckNudCArPSAxXG5cbiAgaWYgKGxpc3RlbmVyQ250ID09PSAxKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uV2luZG93VG91Y2hNb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gbGlzdGVuZXJEZXN0cm95ZWQoKSB7XG4gIGxpc3RlbmVyQ250IC09IDFcblxuICBpZiAoIWxpc3RlbmVyQ250KSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uV2luZG93VG91Y2hNb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0gYXMgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpXG4gIH1cbn1cblxuZnVuY3Rpb24gb25XaW5kb3dUb3VjaE1vdmUoZXY6IFVJRXZlbnQpIHtcbiAgaWYgKGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkKSB7XG4gICAgZXYucHJldmVudERlZmF1bHQoKVxuICB9XG59XG4iLCJpbXBvcnQgeyByZW1vdmVFbGVtZW50LCBhcHBseVN0eWxlLCB3aGVuVHJhbnNpdGlvbkRvbmUsIFJlY3QgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcblxuLypcbkFuIGVmZmVjdCBpbiB3aGljaCBhbiBlbGVtZW50IGZvbGxvd3MgdGhlIG1vdmVtZW50IG9mIGEgcG9pbnRlciBhY3Jvc3MgdGhlIHNjcmVlbi5cblRoZSBtb3ZpbmcgZWxlbWVudCBpcyBhIGNsb25lIG9mIHNvbWUgb3RoZXIgZWxlbWVudC5cbk11c3QgY2FsbCBzdGFydCArIGhhbmRsZU1vdmUgKyBzdG9wLlxuKi9cbmV4cG9ydCBjbGFzcyBFbGVtZW50TWlycm9yIHtcbiAgaXNWaXNpYmxlOiBib29sZWFuID0gZmFsc2UgLy8gbXVzdCBiZSBleHBsaWNpdGx5IGVuYWJsZWRcbiAgb3JpZ1NjcmVlblg/OiBudW1iZXJcbiAgb3JpZ1NjcmVlblk/OiBudW1iZXJcbiAgZGVsdGFYPzogbnVtYmVyXG4gIGRlbHRhWT86IG51bWJlclxuICBzb3VyY2VFbDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbFxuICBtaXJyb3JFbDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbFxuICBzb3VyY2VFbFJlY3Q6IFJlY3QgfCBudWxsID0gbnVsbCAvLyBzY3JlZW4gY29vcmRzIHJlbGF0aXZlIHRvIHZpZXdwb3J0XG5cbiAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgZGlyZWN0bHkgYnkgY2FsbGVyXG4gIHBhcmVudE5vZGU6IEhUTUxFbGVtZW50ID0gZG9jdW1lbnQuYm9keSAvLyBISUdITFkgU1VHR0VTVEVEIHRvIHNldCB0aGlzIHRvIHNpZGVzdGVwIFNoYWRvd0RPTSBpc3N1ZXNcbiAgekluZGV4OiBudW1iZXIgPSA5OTk5XG4gIHJldmVydER1cmF0aW9uOiBudW1iZXIgPSAwXG5cbiAgc3RhcnQoc291cmNlRWw6IEhUTUxFbGVtZW50LCBwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyKSB7XG4gICAgdGhpcy5zb3VyY2VFbCA9IHNvdXJjZUVsXG4gICAgdGhpcy5zb3VyY2VFbFJlY3QgPSB0aGlzLnNvdXJjZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgdGhpcy5vcmlnU2NyZWVuWCA9IHBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0XG4gICAgdGhpcy5vcmlnU2NyZWVuWSA9IHBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgdGhpcy5kZWx0YVggPSAwXG4gICAgdGhpcy5kZWx0YVkgPSAwXG4gICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKClcbiAgfVxuXG4gIGhhbmRsZU1vdmUocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlcikge1xuICAgIHRoaXMuZGVsdGFYID0gKHBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0KSAtIHRoaXMub3JpZ1NjcmVlblghXG4gICAgdGhpcy5kZWx0YVkgPSAocGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQpIC0gdGhpcy5vcmlnU2NyZWVuWSFcbiAgICB0aGlzLnVwZGF0ZUVsUG9zaXRpb24oKVxuICB9XG5cbiAgLy8gY2FuIGJlIGNhbGxlZCBiZWZvcmUgc3RhcnRcbiAgc2V0SXNWaXNpYmxlKGJvb2w6IGJvb2xlYW4pIHtcbiAgICBpZiAoYm9vbCkge1xuICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICBpZiAodGhpcy5taXJyb3JFbCkge1xuICAgICAgICAgIHRoaXMubWlycm9yRWwuc3R5bGUuZGlzcGxheSA9ICcnXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGJvb2wgLy8gbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB1cGRhdGVFbFBvc2l0aW9uXG4gICAgICAgIHRoaXMudXBkYXRlRWxQb3NpdGlvbigpIC8vIGJlY2F1c2Ugd2FzIG5vdCB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgaW52aXNpYmxlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgdGhpcy5taXJyb3JFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNWaXNpYmxlID0gYm9vbFxuICAgIH1cbiAgfVxuXG4gIC8vIGFsd2F5cyBhc3luY1xuICBzdG9wKG5lZWRzUmV2ZXJ0QW5pbWF0aW9uOiBib29sZWFuLCBjYWxsYmFjazogKCkgPT4gdm9pZCkge1xuICAgIGxldCBkb25lID0gKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhbnVwKClcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBuZWVkc1JldmVydEFuaW1hdGlvbiAmJlxuICAgICAgdGhpcy5taXJyb3JFbCAmJlxuICAgICAgdGhpcy5pc1Zpc2libGUgJiZcbiAgICAgIHRoaXMucmV2ZXJ0RHVyYXRpb24gJiYgLy8gaWYgMCwgdHJhbnNpdGlvbiB3b24ndCB3b3JrXG4gICAgICAodGhpcy5kZWx0YVggfHwgdGhpcy5kZWx0YVkpIC8vIGlmIHNhbWUgY29vcmRzLCB0cmFuc2l0aW9uIHdvbid0IHdvcmtcbiAgICApIHtcbiAgICAgIHRoaXMuZG9SZXZlcnRBbmltYXRpb24oZG9uZSwgdGhpcy5yZXZlcnREdXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChkb25lLCAwKVxuICAgIH1cbiAgfVxuXG4gIGRvUmV2ZXJ0QW5pbWF0aW9uKGNhbGxiYWNrOiAoKSA9PiB2b2lkLCByZXZlcnREdXJhdGlvbjogbnVtYmVyKSB7XG4gICAgbGV0IG1pcnJvckVsID0gdGhpcy5taXJyb3JFbCFcbiAgICBsZXQgZmluYWxTb3VyY2VFbFJlY3QgPSB0aGlzLnNvdXJjZUVsIS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSAvLyBiZWNhdXNlIGF1dG9zY3JvbGxpbmcgbWlnaHQgaGF2ZSBoYXBwZW5lZFxuXG4gICAgbWlycm9yRWwuc3R5bGUudHJhbnNpdGlvbiA9XG4gICAgICAndG9wICcgKyByZXZlcnREdXJhdGlvbiArICdtcywnICtcbiAgICAgICdsZWZ0ICcgKyByZXZlcnREdXJhdGlvbiArICdtcydcblxuICAgIGFwcGx5U3R5bGUobWlycm9yRWwsIHtcbiAgICAgIGxlZnQ6IGZpbmFsU291cmNlRWxSZWN0LmxlZnQsXG4gICAgICB0b3A6IGZpbmFsU291cmNlRWxSZWN0LnRvcCxcbiAgICB9KVxuXG4gICAgd2hlblRyYW5zaXRpb25Eb25lKG1pcnJvckVsLCAoKSA9PiB7XG4gICAgICBtaXJyb3JFbC5zdHlsZS50cmFuc2l0aW9uID0gJydcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9KVxuICB9XG5cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5taXJyb3JFbCkge1xuICAgICAgcmVtb3ZlRWxlbWVudCh0aGlzLm1pcnJvckVsKVxuICAgICAgdGhpcy5taXJyb3JFbCA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLnNvdXJjZUVsID0gbnVsbFxuICB9XG5cbiAgdXBkYXRlRWxQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy5zb3VyY2VFbCAmJiB0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgYXBwbHlTdHlsZSh0aGlzLmdldE1pcnJvckVsKCksIHtcbiAgICAgICAgbGVmdDogdGhpcy5zb3VyY2VFbFJlY3QhLmxlZnQgKyB0aGlzLmRlbHRhWCEsXG4gICAgICAgIHRvcDogdGhpcy5zb3VyY2VFbFJlY3QhLnRvcCArIHRoaXMuZGVsdGFZISxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZ2V0TWlycm9yRWwoKTogSFRNTEVsZW1lbnQge1xuICAgIGxldCBzb3VyY2VFbFJlY3QgPSB0aGlzLnNvdXJjZUVsUmVjdCFcbiAgICBsZXQgbWlycm9yRWwgPSB0aGlzLm1pcnJvckVsXG5cbiAgICBpZiAoIW1pcnJvckVsKSB7XG4gICAgICBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWwgPSB0aGlzLnNvdXJjZUVsIS5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEVsZW1lbnQgLy8gY2xvbmVDaGlsZHJlbj10cnVlXG5cbiAgICAgIC8vIHdlIGRvbid0IHdhbnQgbG9uZyB0YXBzIG9yIGFueSBtb3VzZSBpbnRlcmFjdGlvbiBjYXVzaW5nIHNlbGVjdGlvbi9tZW51cy5cbiAgICAgIC8vIHdvdWxkIHVzZSBwcmV2ZW50U2VsZWN0aW9uKCksIGJ1dCB0aGF0IHByZXZlbnRzIHNlbGVjdHN0YXJ0LCBjYXVzaW5nIHByb2JsZW1zLlxuICAgICAgbWlycm9yRWwuY2xhc3NMaXN0LmFkZCgnZmMtdW5zZWxlY3RhYmxlJylcblxuICAgICAgbWlycm9yRWwuY2xhc3NMaXN0LmFkZCgnZmMtZXZlbnQtZHJhZ2dpbmcnKVxuXG4gICAgICBhcHBseVN0eWxlKG1pcnJvckVsLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICB6SW5kZXg6IHRoaXMuekluZGV4LFxuICAgICAgICB2aXNpYmlsaXR5OiAnJywgLy8gaW4gY2FzZSBvcmlnaW5hbCBlbGVtZW50IHdhcyBoaWRkZW4gYnkgdGhlIGRyYWcgZWZmZWN0XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLCAvLyBmb3IgZWFzeSB3aWR0aC9oZWlnaHRcbiAgICAgICAgd2lkdGg6IHNvdXJjZUVsUmVjdC5yaWdodCAtIHNvdXJjZUVsUmVjdC5sZWZ0LCAvLyBleHBsaWNpdCBoZWlnaHQgaW4gY2FzZSB0aGVyZSB3YXMgYSAncmlnaHQnIHZhbHVlXG4gICAgICAgIGhlaWdodDogc291cmNlRWxSZWN0LmJvdHRvbSAtIHNvdXJjZUVsUmVjdC50b3AsIC8vIGV4cGxpY2l0IHdpZHRoIGluIGNhc2UgdGhlcmUgd2FzIGEgJ2JvdHRvbScgdmFsdWVcbiAgICAgICAgcmlnaHQ6ICdhdXRvJywgLy8gZXJhc2UgYW5kIHNldCB3aWR0aCBpbnN0ZWFkXG4gICAgICAgIGJvdHRvbTogJ2F1dG8nLCAvLyBlcmFzZSBhbmQgc2V0IGhlaWdodCBpbnN0ZWFkXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChtaXJyb3JFbClcbiAgICB9XG5cbiAgICByZXR1cm4gbWlycm9yRWxcbiAgfVxufVxuIiwiaW1wb3J0IHsgUmVjdCwgU2Nyb2xsQ29udHJvbGxlciB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuXG4vKlxuSXMgYSBjYWNoZSBmb3IgYSBnaXZlbiBlbGVtZW50J3Mgc2Nyb2xsIGluZm9ybWF0aW9uIChhbGwgdGhlIGluZm8gdGhhdCBTY3JvbGxDb250cm9sbGVyIHN0b3JlcylcbmluIGFkZGl0aW9uIHRoZSBcImNsaWVudCByZWN0YW5nbGVcIiBvZiB0aGUgZWxlbWVudC4uIHRoZSBhcmVhIHdpdGhpbiB0aGUgc2Nyb2xsYmFycy5cblxuVGhlIGNhY2hlIGNhbiBiZSBpbiBvbmUgb2YgdHdvIG1vZGVzOlxuLSBkb2VzTGlzdGVuaW5nOmZhbHNlIC0gaWdub3JlcyB3aGVuIHRoZSBjb250YWluZXIgaXMgc2Nyb2xsZWQgYnkgc29tZW9uZSBlbHNlXG4tIGRvZXNMaXN0ZW5pbmc6dHJ1ZSAtIHdhdGNoIGZvciBzY3JvbGxpbmcgYW5kIHVwZGF0ZSB0aGUgY2FjaGVcbiovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2Nyb2xsR2VvbUNhY2hlIGV4dGVuZHMgU2Nyb2xsQ29udHJvbGxlciB7XG4gIGNsaWVudFJlY3Q6IFJlY3RcbiAgb3JpZ1Njcm9sbFRvcDogbnVtYmVyXG4gIG9yaWdTY3JvbGxMZWZ0OiBudW1iZXJcblxuICBwcm90ZWN0ZWQgc2Nyb2xsQ29udHJvbGxlcjogU2Nyb2xsQ29udHJvbGxlclxuICBwcm90ZWN0ZWQgZG9lc0xpc3RlbmluZzogYm9vbGVhblxuICBwcm90ZWN0ZWQgc2Nyb2xsVG9wOiBudW1iZXJcbiAgcHJvdGVjdGVkIHNjcm9sbExlZnQ6IG51bWJlclxuICBwcm90ZWN0ZWQgc2Nyb2xsV2lkdGg6IG51bWJlclxuICBwcm90ZWN0ZWQgc2Nyb2xsSGVpZ2h0OiBudW1iZXJcbiAgcHJvdGVjdGVkIGNsaWVudFdpZHRoOiBudW1iZXJcbiAgcHJvdGVjdGVkIGNsaWVudEhlaWdodDogbnVtYmVyXG5cbiAgY29uc3RydWN0b3Ioc2Nyb2xsQ29udHJvbGxlcjogU2Nyb2xsQ29udHJvbGxlciwgZG9lc0xpc3RlbmluZzogYm9vbGVhbikge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIgPSBzY3JvbGxDb250cm9sbGVyXG4gICAgdGhpcy5kb2VzTGlzdGVuaW5nID0gZG9lc0xpc3RlbmluZ1xuICAgIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5vcmlnU2Nyb2xsVG9wID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxUb3AoKVxuICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMub3JpZ1Njcm9sbExlZnQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbExlZnQoKVxuICAgIHRoaXMuc2Nyb2xsV2lkdGggPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbFdpZHRoKClcbiAgICB0aGlzLnNjcm9sbEhlaWdodCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsSGVpZ2h0KClcbiAgICB0aGlzLmNsaWVudFdpZHRoID0gc2Nyb2xsQ29udHJvbGxlci5nZXRDbGllbnRXaWR0aCgpXG4gICAgdGhpcy5jbGllbnRIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldENsaWVudEhlaWdodCgpXG4gICAgdGhpcy5jbGllbnRSZWN0ID0gdGhpcy5jb21wdXRlQ2xpZW50UmVjdCgpIC8vIGRvIGxhc3QgaW4gY2FzZSBpdCBuZWVkcyBjYWNoZWQgdmFsdWVzXG5cbiAgICBpZiAodGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICB0aGlzLmdldEV2ZW50VGFyZ2V0KCkuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwpXG4gICAgfVxuICB9XG5cbiAgYWJzdHJhY3QgZ2V0RXZlbnRUYXJnZXQoKTogRXZlbnRUYXJnZXRcbiAgYWJzdHJhY3QgY29tcHV0ZUNsaWVudFJlY3QoKTogUmVjdFxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZG9lc0xpc3RlbmluZykge1xuICAgICAgdGhpcy5nZXRFdmVudFRhcmdldCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVNjcm9sbCA9ICgpID0+IHtcbiAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxUb3AoKVxuICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KClcbiAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpXG4gIH1cblxuICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG9wXG4gIH1cblxuICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLnNjcm9sbExlZnRcbiAgfVxuXG4gIHNldFNjcm9sbFRvcCh0b3A6IG51bWJlcikge1xuICAgIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5zZXRTY3JvbGxUb3AodG9wKVxuXG4gICAgaWYgKCF0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgIC8vIHdlIGFyZSBub3QgcmVseWluZyBvbiB0aGUgZWxlbWVudCB0byBub3JtYWxpemUgb3V0LW9mLWJvdW5kcyBzY3JvbGwgdmFsdWVzXG4gICAgICAvLyBzbyB3ZSBuZWVkIHRvIHNhbml0aXplIG91cnNlbHZlc1xuICAgICAgdGhpcy5zY3JvbGxUb3AgPSBNYXRoLm1heChNYXRoLm1pbih0b3AsIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkpLCAwKVxuXG4gICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpXG4gICAgfVxuICB9XG5cbiAgc2V0U2Nyb2xsTGVmdCh0b3A6IG51bWJlcikge1xuICAgIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5zZXRTY3JvbGxMZWZ0KHRvcClcblxuICAgIGlmICghdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAvLyB3ZSBhcmUgbm90IHJlbHlpbmcgb24gdGhlIGVsZW1lbnQgdG8gbm9ybWFsaXplIG91dC1vZi1ib3VuZHMgc2Nyb2xsIHZhbHVlc1xuICAgICAgLy8gc28gd2UgbmVlZCB0byBzYW5pdGl6ZSBvdXJzZWx2ZXNcbiAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KE1hdGgubWluKHRvcCwgdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCkpLCAwKVxuXG4gICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpXG4gICAgfVxuICB9XG5cbiAgZ2V0Q2xpZW50V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50V2lkdGhcbiAgfVxuXG4gIGdldENsaWVudEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRIZWlnaHRcbiAgfVxuXG4gIGdldFNjcm9sbFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnNjcm9sbFdpZHRoXG4gIH1cblxuICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsSGVpZ2h0XG4gIH1cblxuICBoYW5kbGVTY3JvbGxDaGFuZ2UoKSB7XG4gIH1cbn1cbiIsImltcG9ydCB7IGNvbXB1dGVJbm5lclJlY3QsIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBTY3JvbGxHZW9tQ2FjaGUgfSBmcm9tICcuL1Njcm9sbEdlb21DYWNoZSdcblxuZXhwb3J0IGNsYXNzIEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUgZXh0ZW5kcyBTY3JvbGxHZW9tQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihlbDogSFRNTEVsZW1lbnQsIGRvZXNMaXN0ZW5pbmc6IGJvb2xlYW4pIHtcbiAgICBzdXBlcihuZXcgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIoZWwpLCBkb2VzTGlzdGVuaW5nKVxuICB9XG5cbiAgZ2V0RXZlbnRUYXJnZXQoKTogRXZlbnRUYXJnZXQge1xuICAgIHJldHVybiAodGhpcy5zY3JvbGxDb250cm9sbGVyIGFzIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyKS5lbFxuICB9XG5cbiAgY29tcHV0ZUNsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVJbm5lclJlY3QoKHRoaXMuc2Nyb2xsQ29udHJvbGxlciBhcyBFbGVtZW50U2Nyb2xsQ29udHJvbGxlcikuZWwpXG4gIH1cbn1cbiIsImltcG9ydCB7IFJlY3QsIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFNjcm9sbEdlb21DYWNoZSB9IGZyb20gJy4vU2Nyb2xsR2VvbUNhY2hlJ1xuXG5leHBvcnQgY2xhc3MgV2luZG93U2Nyb2xsR2VvbUNhY2hlIGV4dGVuZHMgU2Nyb2xsR2VvbUNhY2hlIHtcbiAgY29uc3RydWN0b3IoZG9lc0xpc3RlbmluZzogYm9vbGVhbikge1xuICAgIHN1cGVyKG5ldyBXaW5kb3dTY3JvbGxDb250cm9sbGVyKCksIGRvZXNMaXN0ZW5pbmcpXG4gIH1cblxuICBnZXRFdmVudFRhcmdldCgpOiBFdmVudFRhcmdldCB7XG4gICAgcmV0dXJuIHdpbmRvd1xuICB9XG5cbiAgY29tcHV0ZUNsaWVudFJlY3QoKTogUmVjdCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgIHJpZ2h0OiB0aGlzLnNjcm9sbExlZnQgKyB0aGlzLmNsaWVudFdpZHRoLFxuICAgICAgdG9wOiB0aGlzLnNjcm9sbFRvcCxcbiAgICAgIGJvdHRvbTogdGhpcy5zY3JvbGxUb3AgKyB0aGlzLmNsaWVudEhlaWdodCxcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgd2luZG93IGlzIHRoZSBvbmx5IHNjcm9sbCBvYmplY3QgdGhhdCBjaGFuZ2VzIGl0J3MgcmVjdGFuZ2xlIHJlbGF0aXZlXG4gIC8vIHRvIHRoZSBkb2N1bWVudCdzIHRvcGxlZnQgYXMgaXQgc2Nyb2xsc1xuICBoYW5kbGVTY3JvbGxDaGFuZ2UoKSB7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gdGhpcy5jb21wdXRlQ2xpZW50UmVjdCgpXG4gIH1cbn1cbiIsImltcG9ydCB7IGdldEVsUm9vdCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgU2Nyb2xsR2VvbUNhY2hlIH0gZnJvbSAnLi4vU2Nyb2xsR2VvbUNhY2hlJ1xuaW1wb3J0IHsgRWxlbWVudFNjcm9sbEdlb21DYWNoZSB9IGZyb20gJy4uL0VsZW1lbnRTY3JvbGxHZW9tQ2FjaGUnXG5pbXBvcnQgeyBXaW5kb3dTY3JvbGxHZW9tQ2FjaGUgfSBmcm9tICcuLi9XaW5kb3dTY3JvbGxHZW9tQ2FjaGUnXG5cbmludGVyZmFjZSBFZGdlIHtcbiAgc2Nyb2xsQ2FjaGU6IFNjcm9sbEdlb21DYWNoZVxuICBuYW1lOiAndG9wJyB8ICdsZWZ0JyB8ICdyaWdodCcgfCAnYm90dG9tJ1xuICBkaXN0YW5jZTogbnVtYmVyIC8vIGhvdyBtYW55IHBpeGVscyB0aGUgY3VycmVudCBwb2ludGVyIGlzIGZyb20gdGhlIGVkZ2Vcbn1cblxuLy8gSWYgYXZhaWxhYmxlIHdlIGFyZSB1c2luZyBuYXRpdmUgXCJwZXJmb3JtYW5jZVwiIEFQSSBpbnN0ZWFkIG9mIFwiRGF0ZVwiXG4vLyBSZWFkIG1vcmUgYWJvdXQgaXQgb24gTUROOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BlcmZvcm1hbmNlXG5jb25zdCBnZXRUaW1lID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnZnVuY3Rpb24nID8gKHBlcmZvcm1hbmNlIGFzIGFueSkubm93IDogRGF0ZS5ub3dcblxuLypcbkZvciBhIHBvaW50ZXIgaW50ZXJhY3Rpb24sIGF1dG9tYXRpY2FsbHkgc2Nyb2xscyBjZXJ0YWluIHNjcm9sbCBjb250YWluZXJzIHdoZW4gdGhlIHBvaW50ZXJcbmFwcHJvYWNoZXMgdGhlIGVkZ2UuXG5cblRoZSBjYWxsZXIgbXVzdCBjYWxsIHN0YXJ0ICsgaGFuZGxlTW92ZSArIHN0b3AuXG4qL1xuZXhwb3J0IGNsYXNzIEF1dG9TY3JvbGxlciB7XG4gIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGJ5IGNhbGxlclxuICBpc0VuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlXG4gIHNjcm9sbFF1ZXJ5OiAoV2luZG93IHwgc3RyaW5nKVtdID0gW3dpbmRvdywgJy5mYy1zY3JvbGxlciddXG4gIGVkZ2VUaHJlc2hvbGQ6IG51bWJlciA9IDUwIC8vIHBpeGVsc1xuICBtYXhWZWxvY2l0eTogbnVtYmVyID0gMzAwIC8vIHBpeGVscyBwZXIgc2Vjb25kXG5cbiAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgcG9pbnRlclNjcmVlblg6IG51bWJlciB8IG51bGwgPSBudWxsXG4gIHBvaW50ZXJTY3JlZW5ZOiBudW1iZXIgfCBudWxsID0gbnVsbFxuICBpc0FuaW1hdGluZzogYm9vbGVhbiA9IGZhbHNlXG4gIHNjcm9sbENhY2hlczogU2Nyb2xsR2VvbUNhY2hlW10gfCBudWxsID0gbnVsbFxuICBtc1NpbmNlUmVxdWVzdD86IG51bWJlclxuXG4gIC8vIHByb3RlY3QgYWdhaW5zdCB0aGUgaW5pdGlhbCBwb2ludGVyZG93biBiZWluZyB0b28gY2xvc2UgdG8gYW4gZWRnZSBhbmQgc3RhcnRpbmcgdGhlIHNjcm9sbFxuICBldmVyTW92ZWRVcDogYm9vbGVhbiA9IGZhbHNlXG4gIGV2ZXJNb3ZlZERvd246IGJvb2xlYW4gPSBmYWxzZVxuICBldmVyTW92ZWRMZWZ0OiBib29sZWFuID0gZmFsc2VcbiAgZXZlck1vdmVkUmlnaHQ6IGJvb2xlYW4gPSBmYWxzZVxuXG4gIHN0YXJ0KHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIsIHNjcm9sbFN0YXJ0RWw6IEhUTUxFbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IHRoaXMuYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbClcbiAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBudWxsXG4gICAgICB0aGlzLnBvaW50ZXJTY3JlZW5ZID0gbnVsbFxuICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IGZhbHNlXG4gICAgICB0aGlzLmV2ZXJNb3ZlZERvd24gPSBmYWxzZVxuICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gZmFsc2VcbiAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSBmYWxzZVxuICAgICAgdGhpcy5oYW5kbGVNb3ZlKHBhZ2VYLCBwYWdlWSlcbiAgICB9XG4gIH1cblxuICBoYW5kbGVNb3ZlKHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgIGxldCBwb2ludGVyU2NyZWVuWCA9IHBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0XG4gICAgICBsZXQgcG9pbnRlclNjcmVlblkgPSBwYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldFxuXG4gICAgICBsZXQgeURlbHRhID0gdGhpcy5wb2ludGVyU2NyZWVuWSA9PT0gbnVsbCA/IDAgOiBwb2ludGVyU2NyZWVuWSAtIHRoaXMucG9pbnRlclNjcmVlbllcbiAgICAgIGxldCB4RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5YID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5YIC0gdGhpcy5wb2ludGVyU2NyZWVuWFxuXG4gICAgICBpZiAoeURlbHRhIDwgMCkge1xuICAgICAgICB0aGlzLmV2ZXJNb3ZlZFVwID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmICh5RGVsdGEgPiAwKSB7XG4gICAgICAgIHRoaXMuZXZlck1vdmVkRG93biA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHhEZWx0YSA8IDApIHtcbiAgICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmICh4RGVsdGEgPiAwKSB7XG4gICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBwb2ludGVyU2NyZWVuWFxuICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWSA9IHBvaW50ZXJTY3JlZW5ZXG5cbiAgICAgIGlmICghdGhpcy5pc0FuaW1hdGluZykge1xuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZVxuICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb24oZ2V0VGltZSgpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2UgLy8gd2lsbCBzdG9wIGFuaW1hdGlvblxuXG4gICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcyEpIHtcbiAgICAgICAgc2Nyb2xsQ2FjaGUuZGVzdHJveSgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3RBbmltYXRpb24obm93OiBudW1iZXIpIHtcbiAgICB0aGlzLm1zU2luY2VSZXF1ZXN0ID0gbm93XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSlcbiAgfVxuXG4gIHByaXZhdGUgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5pc0FuaW1hdGluZykgeyAvLyB3YXNuJ3QgY2FuY2VsbGVkIGJldHdlZW4gYW5pbWF0aW9uIGNhbGxzXG4gICAgICBsZXQgZWRnZSA9IHRoaXMuY29tcHV0ZUJlc3RFZGdlKFxuICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YISArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWSEgKyB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICApXG5cbiAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgIGxldCBub3cgPSBnZXRUaW1lKClcbiAgICAgICAgdGhpcy5oYW5kbGVTaWRlKGVkZ2UsIChub3cgLSB0aGlzLm1zU2luY2VSZXF1ZXN0ISkgLyAxMDAwKVxuICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb24obm93KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlIC8vIHdpbGwgc3RvcCBhbmltYXRpb25cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVNpZGUoZWRnZTogRWRnZSwgc2Vjb25kczogbnVtYmVyKSB7XG4gICAgbGV0IHsgc2Nyb2xsQ2FjaGUgfSA9IGVkZ2VcbiAgICBsZXQgeyBlZGdlVGhyZXNob2xkIH0gPSB0aGlzXG4gICAgbGV0IGludkRpc3RhbmNlID0gZWRnZVRocmVzaG9sZCAtIGVkZ2UuZGlzdGFuY2VcbiAgICBsZXQgdmVsb2NpdHkgPSAvLyB0aGUgY2xvc2VyIHRvIHRoZSBlZGdlLCB0aGUgZmFzdGVyIHdlIHNjcm9sbFxuICAgICAgKChpbnZEaXN0YW5jZSAqIGludkRpc3RhbmNlKSAvIChlZGdlVGhyZXNob2xkICogZWRnZVRocmVzaG9sZCkpICogLy8gcXVhZHJhdGljXG4gICAgICB0aGlzLm1heFZlbG9jaXR5ICogc2Vjb25kc1xuICAgIGxldCBzaWduID0gMVxuXG4gICAgc3dpdGNoIChlZGdlLm5hbWUpIHtcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBzaWduID0gLTFcbiAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBzY3JvbGxDYWNoZS5zZXRTY3JvbGxMZWZ0KHNjcm9sbENhY2hlLmdldFNjcm9sbExlZnQoKSArIHZlbG9jaXR5ICogc2lnbilcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgc2lnbiA9IC0xXG4gICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHNjcm9sbENhY2hlLnNldFNjcm9sbFRvcChzY3JvbGxDYWNoZS5nZXRTY3JvbGxUb3AoKSArIHZlbG9jaXR5ICogc2lnbilcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBsZWZ0L3RvcCBhcmUgcmVsYXRpdmUgdG8gZG9jdW1lbnQgdG9wbGVmdFxuICBwcml2YXRlIGNvbXB1dGVCZXN0RWRnZShsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyKTogRWRnZSB8IG51bGwge1xuICAgIGxldCB7IGVkZ2VUaHJlc2hvbGQgfSA9IHRoaXNcbiAgICBsZXQgYmVzdFNpZGU6IEVkZ2UgfCBudWxsID0gbnVsbFxuXG4gICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMhKSB7XG4gICAgICBsZXQgcmVjdCA9IHNjcm9sbENhY2hlLmNsaWVudFJlY3RcbiAgICAgIGxldCBsZWZ0RGlzdCA9IGxlZnQgLSByZWN0LmxlZnRcbiAgICAgIGxldCByaWdodERpc3QgPSByZWN0LnJpZ2h0IC0gbGVmdFxuICAgICAgbGV0IHRvcERpc3QgPSB0b3AgLSByZWN0LnRvcFxuICAgICAgbGV0IGJvdHRvbURpc3QgPSByZWN0LmJvdHRvbSAtIHRvcFxuXG4gICAgICAvLyBjb21wbGV0ZWx5IHdpdGhpbiB0aGUgcmVjdD9cbiAgICAgIGlmIChsZWZ0RGlzdCA+PSAwICYmIHJpZ2h0RGlzdCA+PSAwICYmIHRvcERpc3QgPj0gMCAmJiBib3R0b21EaXN0ID49IDApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRvcERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZFVwICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbFVwKCkgJiZcbiAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gdG9wRGlzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlLCBuYW1lOiAndG9wJywgZGlzdGFuY2U6IHRvcERpc3QgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGJvdHRvbURpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZERvd24gJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsRG93bigpICYmXG4gICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGJvdHRvbURpc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZSwgbmFtZTogJ2JvdHRvbScsIGRpc3RhbmNlOiBib3R0b21EaXN0IH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBsZWZ0RGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkTGVmdCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxMZWZ0KCkgJiZcbiAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gbGVmdERpc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZSwgbmFtZTogJ2xlZnQnLCBkaXN0YW5jZTogbGVmdERpc3QgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHJpZ2h0RGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkUmlnaHQgJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsUmlnaHQoKSAmJlxuICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiByaWdodERpc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZSwgbmFtZTogJ3JpZ2h0JywgZGlzdGFuY2U6IHJpZ2h0RGlzdCB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdFNpZGVcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbDogSFRNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNjcm9sbEVscyhzY3JvbGxTdGFydEVsKS5tYXAoKGVsKSA9PiB7XG4gICAgICBpZiAoZWwgPT09IHdpbmRvdykge1xuICAgICAgICByZXR1cm4gbmV3IFdpbmRvd1Njcm9sbEdlb21DYWNoZShmYWxzZSkgLy8gZmFsc2UgPSBkb24ndCBsaXN0ZW4gdG8gdXNlci1nZW5lcmF0ZWQgc2Nyb2xsc1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKGVsLCBmYWxzZSkgLy8gZmFsc2UgPSBkb24ndCBsaXN0ZW4gdG8gdXNlci1nZW5lcmF0ZWQgc2Nyb2xsc1xuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIHF1ZXJ5U2Nyb2xsRWxzKHNjcm9sbFN0YXJ0RWw6IEhUTUxFbGVtZW50KSB7XG4gICAgbGV0IGVscyA9IFtdXG5cbiAgICBmb3IgKGxldCBxdWVyeSBvZiB0aGlzLnNjcm9sbFF1ZXJ5KSB7XG4gICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBlbHMucHVzaChxdWVyeSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVscy5wdXNoKC4uLkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKFxuICAgICAgICAgIGdldEVsUm9vdChzY3JvbGxTdGFydEVsKS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSxcbiAgICAgICAgKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWxzXG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIFBvaW50ZXJEcmFnRXZlbnQsXG4gIHByZXZlbnRTZWxlY3Rpb24sXG4gIGFsbG93U2VsZWN0aW9uLFxuICBwcmV2ZW50Q29udGV4dE1lbnUsXG4gIGFsbG93Q29udGV4dE1lbnUsXG4gIEVsZW1lbnREcmFnZ2luZyxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBQb2ludGVyRHJhZ2dpbmcgfSBmcm9tICcuL1BvaW50ZXJEcmFnZ2luZydcbmltcG9ydCB7IEVsZW1lbnRNaXJyb3IgfSBmcm9tICcuL0VsZW1lbnRNaXJyb3InXG5pbXBvcnQgeyBBdXRvU2Nyb2xsZXIgfSBmcm9tICcuL0F1dG9TY3JvbGxlcidcblxuLypcbk1vbml0b3JzIGRyYWdnaW5nIG9uIGFuIGVsZW1lbnQuIEhhcyBhIG51bWJlciBvZiBoaWdoLWxldmVsIGZlYXR1cmVzOlxuLSBtaW5pbXVtIGRpc3RhbmNlIHJlcXVpcmVkIGJlZm9yZSBkcmFnZ2luZ1xuLSBtaW5pbXVtIHdhaXQgdGltZSAoXCJkZWxheVwiKSBiZWZvcmUgZHJhZ2dpbmdcbi0gYSBtaXJyb3IgZWxlbWVudCB0aGF0IGZvbGxvd3MgdGhlIHBvaW50ZXJcbiovXG5leHBvcnQgY2xhc3MgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyBleHRlbmRzIEVsZW1lbnREcmFnZ2luZyB7XG4gIHBvaW50ZXI6IFBvaW50ZXJEcmFnZ2luZ1xuICBtaXJyb3I6IEVsZW1lbnRNaXJyb3JcbiAgYXV0b1Njcm9sbGVyOiBBdXRvU2Nyb2xsZXJcblxuICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IHNldCBieSBjYWxsZXJcbiAgLy8gdGhlIGNhbGxlciBjYW4gYWxzbyBzZXQgdGhlIFBvaW50ZXJEcmFnZ2luZydzIG9wdGlvbnMgYXMgd2VsbFxuICBkZWxheTogbnVtYmVyIHwgbnVsbCA9IG51bGxcbiAgbWluRGlzdGFuY2U6IG51bWJlciA9IDBcbiAgdG91Y2hTY3JvbGxBbGxvd2VkOiBib29sZWFuID0gdHJ1ZSAvLyBwcmV2ZW50cyBkcmFnIGZyb20gc3RhcnRpbmcgYW5kIGJsb2NrcyBzY3JvbGxpbmcgZHVyaW5nIGRyYWdcblxuICBtaXJyb3JOZWVkc1JldmVydDogYm9vbGVhbiA9IGZhbHNlXG4gIGlzSW50ZXJhY3Rpbmc6IGJvb2xlYW4gPSBmYWxzZSAvLyBpcyB0aGUgdXNlciB2YWxpZGx5IG1vdmluZyB0aGUgcG9pbnRlcj8gbGFzdHMgdW50aWwgcG9pbnRlcnVwXG4gIGlzRHJhZ2dpbmc6IGJvb2xlYW4gPSBmYWxzZSAvLyBpcyBpdCBJTlRFTlRGVUxMWSBkcmFnZ2luZz8gbGFzdHMgdW50aWwgYWZ0ZXIgcmV2ZXJ0IGFuaW1hdGlvblxuICBpc0RlbGF5RW5kZWQ6IGJvb2xlYW4gPSBmYWxzZVxuICBpc0Rpc3RhbmNlU3VycGFzc2VkOiBib29sZWFuID0gZmFsc2VcbiAgZGVsYXlUaW1lb3V0SWQ6IG51bWJlciB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHNlbGVjdG9yPzogc3RyaW5nKSB7XG4gICAgc3VwZXIoY29udGFpbmVyRWwpXG5cbiAgICBsZXQgcG9pbnRlciA9IHRoaXMucG9pbnRlciA9IG5ldyBQb2ludGVyRHJhZ2dpbmcoY29udGFpbmVyRWwpXG4gICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMub25Qb2ludGVyRG93bilcbiAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKVxuICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5vblBvaW50ZXJVcClcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcG9pbnRlci5zZWxlY3RvciA9IHNlbGVjdG9yXG4gICAgfVxuXG4gICAgdGhpcy5taXJyb3IgPSBuZXcgRWxlbWVudE1pcnJvcigpXG4gICAgdGhpcy5hdXRvU2Nyb2xsZXIgPSBuZXcgQXV0b1Njcm9sbGVyKClcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKVxuXG4gICAgLy8gSEFDSzogc2ltdWxhdGUgYSBwb2ludGVyLXVwIHRvIGVuZCB0aGUgY3VycmVudCBkcmFnXG4gICAgLy8gVE9ETzogZmlyZSAnZHJhZ2VuZCcgZGlyZWN0bHkgYW5kIHN0b3AgaW50ZXJhY3Rpb24uIGRpc2NvdXJhZ2UgdXNlIG9mIHBvaW50ZXJ1cCBldmVudCAoYi9jIG1pZ2h0IG5vdCBmaXJlKVxuICAgIHRoaXMub25Qb2ludGVyVXAoe30gYXMgYW55KVxuICB9XG5cbiAgb25Qb2ludGVyRG93biA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7IC8vIHNvIG5ldyBkcmFnIGRvZXNuJ3QgaGFwcGVuIHdoaWxlIHJldmVydCBhbmltYXRpb24gaXMgZ29pbmdcbiAgICAgIHRoaXMuaXNJbnRlcmFjdGluZyA9IHRydWVcbiAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2VcbiAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlXG5cbiAgICAgIHByZXZlbnRTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSlcbiAgICAgIHByZXZlbnRDb250ZXh0TWVudShkb2N1bWVudC5ib2R5KVxuXG4gICAgICAvLyBwcmV2ZW50IGxpbmtzIGZyb20gYmVpbmcgdmlzaXRlZCBpZiB0aGVyZSdzIGFuIGV2ZW50dWFsIGRyYWcuXG4gICAgICAvLyBhbHNvIHByZXZlbnRzIHNlbGVjdGlvbiBpbiBvbGRlciBicm93c2VycyAobWF5YmU/KS5cbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgZm9yIHRvdWNoLCBiZXNpZGVzLCBicm93c2VyIHdvdWxkIGNvbXBsYWluIGFib3V0IHBhc3NpdmVuZXNzLlxuICAgICAgaWYgKCFldi5pc1RvdWNoKSB7XG4gICAgICAgIGV2Lm9yaWdFdmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KVxuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuaXNJbnRlcmFjdGluZyAmJiAvLyBub3QgZGVzdHJveWVkIHZpYSBwb2ludGVyZG93biBoYW5kbGVyXG4gICAgICAgICF0aGlzLnBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZVxuICAgICAgKSB7XG4gICAgICAgIC8vIGFjdGlvbnMgcmVsYXRlZCB0byBpbml0aWF0aW5nIGRyYWdzdGFydCtkcmFnbW92ZStkcmFnZW5kLi4uXG5cbiAgICAgICAgdGhpcy5taXJyb3Iuc2V0SXNWaXNpYmxlKGZhbHNlKSAvLyByZXNldC4gY2FsbGVyIG11c3Qgc2V0LXZpc2libGVcbiAgICAgICAgdGhpcy5taXJyb3Iuc3RhcnQoZXYuc3ViamVjdEVsIGFzIEhUTUxFbGVtZW50LCBldi5wYWdlWCwgZXYucGFnZVkpIC8vIG11c3QgaGFwcGVuIG9uIGZpcnN0IHBvaW50ZXIgZG93blxuXG4gICAgICAgIHRoaXMuc3RhcnREZWxheShldilcblxuICAgICAgICBpZiAoIXRoaXMubWluRGlzdGFuY2UpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Qb2ludGVyTW92ZSA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpbmcpIHtcbiAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIGV2KVxuXG4gICAgICBpZiAoIXRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xuICAgICAgICBsZXQgbWluRGlzdGFuY2UgPSB0aGlzLm1pbkRpc3RhbmNlXG4gICAgICAgIGxldCBkaXN0YW5jZVNxIC8vIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luLCBzcXVhcmVkXG4gICAgICAgIGxldCB7IGRlbHRhWCwgZGVsdGFZIH0gPSBldlxuXG4gICAgICAgIGRpc3RhbmNlU3EgPSBkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVlcbiAgICAgICAgaWYgKGRpc3RhbmNlU3EgPj0gbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSkgeyAvLyB1c2UgcHl0aGFnb3JlYW4gdGhlb3JlbVxuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAvLyBhIHJlYWwgcG9pbnRlciBtb3ZlPyAobm90IG9uZSBzaW11bGF0ZWQgYnkgc2Nyb2xsaW5nKVxuICAgICAgICBpZiAoZXYub3JpZ0V2ZW50LnR5cGUgIT09ICdzY3JvbGwnKSB7XG4gICAgICAgICAgdGhpcy5taXJyb3IuaGFuZGxlTW92ZShldi5wYWdlWCwgZXYucGFnZVkpXG4gICAgICAgICAgdGhpcy5hdXRvU2Nyb2xsZXIuaGFuZGxlTW92ZShldi5wYWdlWCwgZXYucGFnZVkpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ21vdmUnLCBldilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvblBvaW50ZXJVcCA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpbmcpIHtcbiAgICAgIHRoaXMuaXNJbnRlcmFjdGluZyA9IGZhbHNlXG5cbiAgICAgIGFsbG93U2VsZWN0aW9uKGRvY3VtZW50LmJvZHkpXG4gICAgICBhbGxvd0NvbnRleHRNZW51KGRvY3VtZW50LmJvZHkpXG5cbiAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBldikgLy8gY2FuIHBvdGVudGlhbGx5IHNldCBtaXJyb3JOZWVkc1JldmVydFxuXG4gICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLnN0b3AoKVxuICAgICAgICB0aGlzLnRyeVN0b3BEcmFnKGV2KSAvLyB3aGljaCB3aWxsIHN0b3AgdGhlIG1pcnJvclxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kZWxheVRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVvdXRJZClcbiAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGFydERlbGF5KGV2OiBQb2ludGVyRHJhZ0V2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbFxuICAgICAgICB0aGlzLmhhbmRsZURlbGF5RW5kKGV2KVxuICAgICAgfSwgdGhpcy5kZWxheSkgYXMgYW55IC8vIG5vdCBhc3NpZ25hYmxlIHRvIG51bWJlciFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVEZWxheUVuZChldilcbiAgICB9XG4gIH1cblxuICBoYW5kbGVEZWxheUVuZChldjogUG9pbnRlckRyYWdFdmVudCkge1xuICAgIHRoaXMuaXNEZWxheUVuZGVkID0gdHJ1ZVxuICAgIHRoaXMudHJ5U3RhcnREcmFnKGV2KVxuICB9XG5cbiAgaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXY6IFBvaW50ZXJEcmFnRXZlbnQpIHtcbiAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSB0cnVlXG4gICAgdGhpcy50cnlTdGFydERyYWcoZXYpXG4gIH1cblxuICB0cnlTdGFydERyYWcoZXY6IFBvaW50ZXJEcmFnRXZlbnQpIHtcbiAgICBpZiAodGhpcy5pc0RlbGF5RW5kZWQgJiYgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XG4gICAgICBpZiAoIXRoaXMucG9pbnRlci53YXNUb3VjaFNjcm9sbCB8fCB0aGlzLnRvdWNoU2Nyb2xsQWxsb3dlZCkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlXG4gICAgICAgIHRoaXMubWlycm9yTmVlZHNSZXZlcnQgPSBmYWxzZVxuXG4gICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLnN0YXJ0KGV2LnBhZ2VYLCBldi5wYWdlWSwgdGhpcy5jb250YWluZXJFbClcbiAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KVxuXG4gICAgICAgIGlmICh0aGlzLnRvdWNoU2Nyb2xsQWxsb3dlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnBvaW50ZXIuY2FuY2VsVG91Y2hTY3JvbGwoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdHJ5U3RvcERyYWcoZXY6IFBvaW50ZXJEcmFnRXZlbnQpIHtcbiAgICAvLyAuc3RvcCgpIGlzIEFMV0FZUyBhc3luY2hyb25vdXMsIHdoaWNoIHdlIE5FRUQgYmVjYXVzZSB3ZSB3YW50IGFsbCBwb2ludGVydXAgZXZlbnRzXG4gICAgLy8gdGhhdCBjb21lIGZyb20gdGhlIGRvY3VtZW50IHRvIGZpcmUgYmVmb3JlaGFuZC4gbXVjaCBtb3JlIGNvbnZlbmllbnQgdGhpcyB3YXkuXG4gICAgdGhpcy5taXJyb3Iuc3RvcChcbiAgICAgIHRoaXMubWlycm9yTmVlZHNSZXZlcnQsXG4gICAgICB0aGlzLnN0b3BEcmFnLmJpbmQodGhpcywgZXYpLCAvLyBib3VuZCB3aXRoIGFyZ3NcbiAgICApXG4gIH1cblxuICBzdG9wRHJhZyhldjogUG9pbnRlckRyYWdFdmVudCkge1xuICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldilcbiAgfVxuXG4gIC8vIGZpbGwgaW4gdGhlIGltcGxlbWVudGF0aW9ucy4uLlxuXG4gIHNldElnbm9yZU1vdmUoYm9vbDogYm9vbGVhbikge1xuICAgIHRoaXMucG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlID0gYm9vbFxuICB9XG5cbiAgc2V0TWlycm9ySXNWaXNpYmxlKGJvb2w6IGJvb2xlYW4pIHtcbiAgICB0aGlzLm1pcnJvci5zZXRJc1Zpc2libGUoYm9vbClcbiAgfVxuXG4gIHNldE1pcnJvck5lZWRzUmV2ZXJ0KGJvb2w6IGJvb2xlYW4pIHtcbiAgICB0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gYm9vbFxuICB9XG5cbiAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbDogYm9vbGVhbikge1xuICAgIHRoaXMuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGJvb2xcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgZ2V0Q2xpcHBpbmdQYXJlbnRzLCBjb21wdXRlUmVjdCxcbiAgcG9pbnRJbnNpZGVSZWN0LCBSZWN0LFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUgfSBmcm9tICcuL0VsZW1lbnRTY3JvbGxHZW9tQ2FjaGUnXG5cbi8qXG5XaGVuIHRoaXMgY2xhc3MgaXMgaW5zdGFudGlhdGVkLCBpdCByZWNvcmRzIHRoZSBvZmZzZXQgb2YgYW4gZWxlbWVudCAocmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50IHRvcGxlZnQpLFxuYW5kIGNvbnRpbnVlcyB0byBtb25pdG9yIHNjcm9sbGluZywgdXBkYXRpbmcgdGhlIGNhY2hlZCBjb29yZGluYXRlcyBpZiBpdCBuZWVkcyB0by5cbkRvZXMgbm90IGFjY2VzcyB0aGUgRE9NIGFmdGVyIGluc3RhbnRpYXRpb24sIHNvIGhpZ2hseSBwZXJmb3JtYW50LlxuXG5BbHNvIGtlZXBzIHRyYWNrIG9mIGFsbCBzY3JvbGxpbmcvb3ZlcmZsb3c6aGlkZGVuIGNvbnRhaW5lcnMgdGhhdCBhcmUgcGFyZW50cyBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuYW5kIGFuIGRldGVybWluZSBpZiBhIGdpdmVuIHBvaW50IGlzIGluc2lkZSB0aGUgY29tYmluZWQgY2xpcHBpbmcgcmVjdGFuZ2xlLlxuKi9cbmV4cG9ydCBjbGFzcyBPZmZzZXRUcmFja2VyIHsgLy8gRWxlbWVudE9mZnNldFRyYWNrZXJcbiAgc2Nyb2xsQ2FjaGVzOiBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlW11cbiAgb3JpZ1JlY3Q6IFJlY3RcblxuICBjb25zdHJ1Y3RvcihlbDogSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLm9yaWdSZWN0ID0gY29tcHV0ZVJlY3QoZWwpXG5cbiAgICAvLyB3aWxsIHdvcmsgZmluZSBmb3IgZGl2cyB0aGF0IGhhdmUgb3ZlcmZsb3c6aGlkZGVuXG4gICAgdGhpcy5zY3JvbGxDYWNoZXMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpLm1hcChcbiAgICAgIChzY3JvbGxFbCkgPT4gbmV3IEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUoc2Nyb2xsRWwsIHRydWUpLCAvLyBsaXN0ZW49dHJ1ZVxuICAgIClcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMpIHtcbiAgICAgIHNjcm9sbENhY2hlLmRlc3Ryb3koKVxuICAgIH1cbiAgfVxuXG4gIGNvbXB1dGVMZWZ0KCkge1xuICAgIGxldCBsZWZ0ID0gdGhpcy5vcmlnUmVjdC5sZWZ0XG5cbiAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgbGVmdCArPSBzY3JvbGxDYWNoZS5vcmlnU2Nyb2xsTGVmdCAtIHNjcm9sbENhY2hlLmdldFNjcm9sbExlZnQoKVxuICAgIH1cblxuICAgIHJldHVybiBsZWZ0XG4gIH1cblxuICBjb21wdXRlVG9wKCkge1xuICAgIGxldCB0b3AgPSB0aGlzLm9yaWdSZWN0LnRvcFxuXG4gICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMpIHtcbiAgICAgIHRvcCArPSBzY3JvbGxDYWNoZS5vcmlnU2Nyb2xsVG9wIC0gc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsVG9wKClcbiAgICB9XG5cbiAgICByZXR1cm4gdG9wXG4gIH1cblxuICBpc1dpdGhpbkNsaXBwaW5nKHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBsZXQgcG9pbnQgPSB7IGxlZnQ6IHBhZ2VYLCB0b3A6IHBhZ2VZIH1cblxuICAgIGZvciAobGV0IHNjcm9sbENhY2hlIG9mIHRoaXMuc2Nyb2xsQ2FjaGVzKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFpc0lnbm9yZWRDbGlwcGluZyhzY3JvbGxDYWNoZS5nZXRFdmVudFRhcmdldCgpKSAmJlxuICAgICAgICAhcG9pbnRJbnNpZGVSZWN0KHBvaW50LCBzY3JvbGxDYWNoZS5jbGllbnRSZWN0KVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuLy8gY2VydGFpbiBjbGlwcGluZyBjb250YWluZXJzIHNob3VsZCBuZXZlciBjb25zdHJhaW4gaW50ZXJhY3Rpb25zLCBsaWtlIDxodG1sPiBhbmQgPGJvZHk+XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvMzYxNVxuZnVuY3Rpb24gaXNJZ25vcmVkQ2xpcHBpbmcobm9kZTogRXZlbnRUYXJnZXQpIHtcbiAgbGV0IHRhZ05hbWUgPSAobm9kZSBhcyBIVE1MRWxlbWVudCkudGFnTmFtZVxuXG4gIHJldHVybiB0YWdOYW1lID09PSAnSFRNTCcgfHwgdGFnTmFtZSA9PT0gJ0JPRFknXG59XG4iLCJpbXBvcnQge1xuICBFbWl0dGVyLCBQb2ludGVyRHJhZ0V2ZW50LFxuICBpc0RhdGVTcGFuc0VxdWFsLFxuICBjb21wdXRlUmVjdCxcbiAgY29uc3RyYWluUG9pbnQsIGludGVyc2VjdFJlY3RzLCBnZXRSZWN0Q2VudGVyLCBkaWZmUG9pbnRzLCBQb2ludCxcbiAgcmFuZ2VDb250YWluc1JhbmdlLFxuICBIaXQsXG4gIEludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSxcbiAgbWFwSGFzaCxcbiAgRWxlbWVudERyYWdnaW5nLFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IE9mZnNldFRyYWNrZXIgfSBmcm9tICcuLi9PZmZzZXRUcmFja2VyJ1xuXG4vKlxuVHJhY2tzIG1vdmVtZW50IG92ZXIgbXVsdGlwbGUgZHJvcHBhYmxlIGFyZWFzIChha2EgXCJoaXRzXCIpXG50aGF0IGV4aXN0IGluIG9uZSBvciBtb3JlIERhdGVDb21wb25lbnRzLlxuUmVsaWVzIG9uIGFuIGV4aXN0aW5nIGRyYWdnYWJsZS5cblxuZW1pdHM6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBoaXRjaGFuZ2UgLSBmaXJlcyBpbml0aWFsbHksIGV2ZW4gaWYgbm90IG92ZXIgYSBoaXRcbi0gcG9pbnRlcnVwXG4tIChoaXRjaGFuZ2UgLSBhZ2FpbiwgdG8gbnVsbCwgaWYgZW5kZWQgb3ZlciBhIGhpdClcbi0gZHJhZ2VuZFxuKi9cbmV4cG9ydCBjbGFzcyBIaXREcmFnZ2luZyB7XG4gIGRyb3BwYWJsZVN0b3JlOiBJbnRlcmFjdGlvblNldHRpbmdzU3RvcmVcbiAgZHJhZ2dpbmc6IEVsZW1lbnREcmFnZ2luZ1xuICBlbWl0dGVyOiBFbWl0dGVyPGFueT5cblxuICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBieSBjYWxsZXJcbiAgdXNlU3ViamVjdENlbnRlcjogYm9vbGVhbiA9IGZhbHNlXG4gIHJlcXVpcmVJbml0aWFsOiBib29sZWFuID0gdHJ1ZSAvLyBpZiBkb2Vzbid0IHN0YXJ0IG91dCBvbiBhIGhpdCwgd29uJ3QgZW1pdCBhbnkgZXZlbnRzXG5cbiAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgb2Zmc2V0VHJhY2tlcnM6IHsgW2NvbXBvbmVudFVpZDogc3RyaW5nXTogT2Zmc2V0VHJhY2tlciB9XG4gIGluaXRpYWxIaXQ6IEhpdCB8IG51bGwgPSBudWxsXG4gIG1vdmluZ0hpdDogSGl0IHwgbnVsbCA9IG51bGxcbiAgZmluYWxIaXQ6IEhpdCB8IG51bGwgPSBudWxsIC8vIHdvbid0IGV2ZXIgYmUgcG9wdWxhdGVkIGlmIHNob3VsZElnbm9yZU1vdmVcbiAgY29vcmRBZGp1c3Q/OiBQb2ludFxuXG4gIGNvbnN0cnVjdG9yKGRyYWdnaW5nOiBFbGVtZW50RHJhZ2dpbmcsIGRyb3BwYWJsZVN0b3JlOiBJbnRlcmFjdGlvblNldHRpbmdzU3RvcmUpIHtcbiAgICB0aGlzLmRyb3BwYWJsZVN0b3JlID0gZHJvcHBhYmxlU3RvcmVcblxuICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bilcbiAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydClcbiAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnbW92ZScsIHRoaXMuaGFuZGxlRHJhZ01vdmUpXG4gICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5oYW5kbGVQb2ludGVyVXApXG4gICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZClcblxuICAgIHRoaXMuZHJhZ2dpbmcgPSBkcmFnZ2luZ1xuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKClcbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJEb3duID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXNcblxuICAgIHRoaXMuaW5pdGlhbEhpdCA9IG51bGxcbiAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGxcbiAgICB0aGlzLmZpbmFsSGl0ID0gbnVsbFxuXG4gICAgdGhpcy5wcmVwYXJlSGl0cygpXG4gICAgdGhpcy5wcm9jZXNzRmlyc3RDb29yZChldilcblxuICAgIGlmICh0aGlzLmluaXRpYWxIaXQgfHwgIXRoaXMucmVxdWlyZUluaXRpYWwpIHtcbiAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoZmFsc2UpXG5cbiAgICAgIC8vIFRPRE86IGZpcmUgdGhpcyBiZWZvcmUgY29tcHV0aW5nIHByb2Nlc3NGaXJzdENvb3JkLCBzbyBsaXN0ZW5lcnMgY2FuIGNhbmNlbC4gdGhpcyBnZXRzIGZpcmVkIGJ5IGFsbW9zdCBldmVyeSBoYW5kbGVyIDooXG4gICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBldilcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSh0cnVlKVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldHMgaW5pdGlhbEhpdFxuICAvLyBzZXRzIGNvb3JkQWRqdXN0XG4gIHByb2Nlc3NGaXJzdENvb3JkKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSB7XG4gICAgbGV0IG9yaWdQb2ludCA9IHsgbGVmdDogZXYucGFnZVgsIHRvcDogZXYucGFnZVkgfVxuICAgIGxldCBhZGp1c3RlZFBvaW50ID0gb3JpZ1BvaW50XG4gICAgbGV0IHN1YmplY3RFbCA9IGV2LnN1YmplY3RFbFxuICAgIGxldCBzdWJqZWN0UmVjdFxuXG4gICAgaWYgKHN1YmplY3RFbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7IC8vIGkuZS4gbm90IGEgRG9jdW1lbnQvU2hhZG93Um9vdFxuICAgICAgc3ViamVjdFJlY3QgPSBjb21wdXRlUmVjdChzdWJqZWN0RWwpXG4gICAgICBhZGp1c3RlZFBvaW50ID0gY29uc3RyYWluUG9pbnQoYWRqdXN0ZWRQb2ludCwgc3ViamVjdFJlY3QpXG4gICAgfVxuXG4gICAgbGV0IGluaXRpYWxIaXQgPSB0aGlzLmluaXRpYWxIaXQgPSB0aGlzLnF1ZXJ5SGl0Rm9yT2Zmc2V0KGFkanVzdGVkUG9pbnQubGVmdCwgYWRqdXN0ZWRQb2ludC50b3ApXG4gICAgaWYgKGluaXRpYWxIaXQpIHtcbiAgICAgIGlmICh0aGlzLnVzZVN1YmplY3RDZW50ZXIgJiYgc3ViamVjdFJlY3QpIHtcbiAgICAgICAgbGV0IHNsaWNlZFN1YmplY3RSZWN0ID0gaW50ZXJzZWN0UmVjdHMoc3ViamVjdFJlY3QsIGluaXRpYWxIaXQucmVjdClcbiAgICAgICAgaWYgKHNsaWNlZFN1YmplY3RSZWN0KSB7XG4gICAgICAgICAgYWRqdXN0ZWRQb2ludCA9IGdldFJlY3RDZW50ZXIoc2xpY2VkU3ViamVjdFJlY3QpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jb29yZEFkanVzdCA9IGRpZmZQb2ludHMoYWRqdXN0ZWRQb2ludCwgb3JpZ1BvaW50KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvb3JkQWRqdXN0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZURyYWdTdGFydCA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldilcbiAgICB0aGlzLmhhbmRsZU1vdmUoZXYsIHRydWUpIC8vIGZvcmNlID0gZmlyZSBldmVuIGlmIGluaXRpYWxseSBudWxsXG4gIH1cblxuICBoYW5kbGVEcmFnTW92ZSA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnbW92ZScsIGV2KVxuICAgIHRoaXMuaGFuZGxlTW92ZShldilcbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJVcCA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIHRoaXMucmVsZWFzZUhpdHMoKVxuICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBldilcbiAgfVxuXG4gIGhhbmRsZURyYWdFbmQgPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBpZiAodGhpcy5tb3ZpbmdIaXQpIHtcbiAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdoaXR1cGRhdGUnLCBudWxsLCB0cnVlLCBldilcbiAgICB9XG5cbiAgICB0aGlzLmZpbmFsSGl0ID0gdGhpcy5tb3ZpbmdIaXRcbiAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGxcbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ2VuZCcsIGV2KVxuICB9XG5cbiAgaGFuZGxlTW92ZShldjogUG9pbnRlckRyYWdFdmVudCwgZm9yY2VIYW5kbGU/OiBib29sZWFuKSB7XG4gICAgbGV0IGhpdCA9IHRoaXMucXVlcnlIaXRGb3JPZmZzZXQoXG4gICAgICBldi5wYWdlWCArIHRoaXMuY29vcmRBZGp1c3QhLmxlZnQsXG4gICAgICBldi5wYWdlWSArIHRoaXMuY29vcmRBZGp1c3QhLnRvcCxcbiAgICApXG5cbiAgICBpZiAoZm9yY2VIYW5kbGUgfHwgIWlzSGl0c0VxdWFsKHRoaXMubW92aW5nSGl0LCBoaXQpKSB7XG4gICAgICB0aGlzLm1vdmluZ0hpdCA9IGhpdFxuICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2hpdHVwZGF0ZScsIGhpdCwgZmFsc2UsIGV2KVxuICAgIH1cbiAgfVxuXG4gIHByZXBhcmVIaXRzKCkge1xuICAgIHRoaXMub2Zmc2V0VHJhY2tlcnMgPSBtYXBIYXNoKHRoaXMuZHJvcHBhYmxlU3RvcmUsIChpbnRlcmFjdGlvblNldHRpbmdzKSA9PiB7XG4gICAgICBpbnRlcmFjdGlvblNldHRpbmdzLmNvbXBvbmVudC5wcmVwYXJlSGl0cygpXG4gICAgICByZXR1cm4gbmV3IE9mZnNldFRyYWNrZXIoaW50ZXJhY3Rpb25TZXR0aW5ncy5lbClcbiAgICB9KVxuICB9XG5cbiAgcmVsZWFzZUhpdHMoKSB7XG4gICAgbGV0IHsgb2Zmc2V0VHJhY2tlcnMgfSA9IHRoaXNcblxuICAgIGZvciAobGV0IGlkIGluIG9mZnNldFRyYWNrZXJzKSB7XG4gICAgICBvZmZzZXRUcmFja2Vyc1tpZF0uZGVzdHJveSgpXG4gICAgfVxuXG4gICAgdGhpcy5vZmZzZXRUcmFja2VycyA9IHt9XG4gIH1cblxuICBxdWVyeUhpdEZvck9mZnNldChvZmZzZXRMZWZ0OiBudW1iZXIsIG9mZnNldFRvcDogbnVtYmVyKTogSGl0IHwgbnVsbCB7XG4gICAgbGV0IHsgZHJvcHBhYmxlU3RvcmUsIG9mZnNldFRyYWNrZXJzIH0gPSB0aGlzXG4gICAgbGV0IGJlc3RIaXQ6IEhpdCB8IG51bGwgPSBudWxsXG5cbiAgICBmb3IgKGxldCBpZCBpbiBkcm9wcGFibGVTdG9yZSkge1xuICAgICAgbGV0IGNvbXBvbmVudCA9IGRyb3BwYWJsZVN0b3JlW2lkXS5jb21wb25lbnRcbiAgICAgIGxldCBvZmZzZXRUcmFja2VyID0gb2Zmc2V0VHJhY2tlcnNbaWRdXG5cbiAgICAgIGlmIChcbiAgICAgICAgb2Zmc2V0VHJhY2tlciAmJiAvLyB3YXNuJ3QgZGVzdHJveWVkIG1pZC1kcmFnXG4gICAgICAgIG9mZnNldFRyYWNrZXIuaXNXaXRoaW5DbGlwcGluZyhvZmZzZXRMZWZ0LCBvZmZzZXRUb3ApXG4gICAgICApIHtcbiAgICAgICAgbGV0IG9yaWdpbkxlZnQgPSBvZmZzZXRUcmFja2VyLmNvbXB1dGVMZWZ0KClcbiAgICAgICAgbGV0IG9yaWdpblRvcCA9IG9mZnNldFRyYWNrZXIuY29tcHV0ZVRvcCgpXG4gICAgICAgIGxldCBwb3NpdGlvbkxlZnQgPSBvZmZzZXRMZWZ0IC0gb3JpZ2luTGVmdFxuICAgICAgICBsZXQgcG9zaXRpb25Ub3AgPSBvZmZzZXRUb3AgLSBvcmlnaW5Ub3BcbiAgICAgICAgbGV0IHsgb3JpZ1JlY3QgfSA9IG9mZnNldFRyYWNrZXJcbiAgICAgICAgbGV0IHdpZHRoID0gb3JpZ1JlY3QucmlnaHQgLSBvcmlnUmVjdC5sZWZ0XG4gICAgICAgIGxldCBoZWlnaHQgPSBvcmlnUmVjdC5ib3R0b20gLSBvcmlnUmVjdC50b3BcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gbXVzdCBiZSB3aXRoaW4gdGhlIGVsZW1lbnQncyBib3VuZHNcbiAgICAgICAgICBwb3NpdGlvbkxlZnQgPj0gMCAmJiBwb3NpdGlvbkxlZnQgPCB3aWR0aCAmJlxuICAgICAgICAgIHBvc2l0aW9uVG9wID49IDAgJiYgcG9zaXRpb25Ub3AgPCBoZWlnaHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgbGV0IGhpdCA9IGNvbXBvbmVudC5xdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGhpdCAmJiAoXG4gICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgaGl0IGlzIHdpdGhpbiBhY3RpdmVSYW5nZSwgbWVhbmluZyBpdCdzIG5vdCBhIGRlYWQgY2VsbFxuICAgICAgICAgICAgICByYW5nZUNvbnRhaW5zUmFuZ2UoaGl0LmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBoaXQuZGF0ZVNwYW4ucmFuZ2UpXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICAoIWJlc3RIaXQgfHwgaGl0LmxheWVyID4gYmVzdEhpdC5sYXllcilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGhpdC5jb21wb25lbnRJZCA9IGlkXG4gICAgICAgICAgICBoaXQuY29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0XG5cbiAgICAgICAgICAgIC8vIFRPRE86IGJldHRlciB3YXkgdG8gcmUtb3JpZW50IHJlY3RhbmdsZVxuICAgICAgICAgICAgaGl0LnJlY3QubGVmdCArPSBvcmlnaW5MZWZ0XG4gICAgICAgICAgICBoaXQucmVjdC5yaWdodCArPSBvcmlnaW5MZWZ0XG4gICAgICAgICAgICBoaXQucmVjdC50b3AgKz0gb3JpZ2luVG9wXG4gICAgICAgICAgICBoaXQucmVjdC5ib3R0b20gKz0gb3JpZ2luVG9wXG5cbiAgICAgICAgICAgIGJlc3RIaXQgPSBoaXRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdEhpdFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hpdHNFcXVhbChoaXQwOiBIaXQgfCBudWxsLCBoaXQxOiBIaXQgfCBudWxsKTogYm9vbGVhbiB7XG4gIGlmICghaGl0MCAmJiAhaGl0MSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoQm9vbGVhbihoaXQwKSAhPT0gQm9vbGVhbihoaXQxKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGlzRGF0ZVNwYW5zRXF1YWwoaGl0MCEuZGF0ZVNwYW4sIGhpdDEhLmRhdGVTcGFuKVxufVxuIiwiaW1wb3J0IHsgRGF0ZVNwYW4sIENhbGVuZGFyQ29udGV4dCwgRGF0ZVBvaW50QXBpLCBEYXRlRW52LCBWaWV3QXBpLCBFdmVudEFwaSB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcblxuZXhwb3J0IGludGVyZmFjZSBEcm9wQXJnIGV4dGVuZHMgRGF0ZVBvaW50QXBpIHtcbiAgZHJhZ2dlZEVsOiBIVE1MRWxlbWVudFxuICBqc0V2ZW50OiBNb3VzZUV2ZW50XG4gIHZpZXc6IFZpZXdBcGlcbn1cblxuZXhwb3J0IHR5cGUgRXZlbnRSZWNlaXZlQXJnID0gRXZlbnRSZWNlaXZlTGVhdmVBcmdcbmV4cG9ydCB0eXBlIEV2ZW50TGVhdmVBcmcgPSBFdmVudFJlY2VpdmVMZWF2ZUFyZ1xuZXhwb3J0IGludGVyZmFjZSBFdmVudFJlY2VpdmVMZWF2ZUFyZyB7IC8vIHdpbGwgdGhpcyBiZWNvbWUgcHVibGljP1xuICBkcmFnZ2VkRWw6IEhUTUxFbGVtZW50XG4gIGV2ZW50OiBFdmVudEFwaVxuICByZWxhdGVkRXZlbnRzOiBFdmVudEFwaVtdXG4gIHJldmVydDogKCkgPT4gdm9pZFxuICB2aWV3OiBWaWV3QXBpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGRhdGVTcGFuOiBEYXRlU3BhbiwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCBwcm9wcyA9IHt9IGFzIERhdGVQb2ludEFwaVxuXG4gIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVQb2ludFRyYW5zZm9ybXMpIHtcbiAgICBfX2Fzc2lnbihwcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCBjb250ZXh0KSlcbiAgfVxuXG4gIF9fYXNzaWduKHByb3BzLCBidWlsZERhdGVQb2ludEFwaShkYXRlU3BhbiwgY29udGV4dC5kYXRlRW52KSlcblxuICByZXR1cm4gcHJvcHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRGF0ZVBvaW50QXBpKHNwYW46IERhdGVTcGFuLCBkYXRlRW52OiBEYXRlRW52KTogRGF0ZVBvaW50QXBpIHtcbiAgcmV0dXJuIHtcbiAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShzcGFuLnJhbmdlLnN0YXJ0KSxcbiAgICBkYXRlU3RyOiBkYXRlRW52LmZvcm1hdElzbyhzcGFuLnJhbmdlLnN0YXJ0LCB7IG9taXRUaW1lOiBzcGFuLmFsbERheSB9KSxcbiAgICBhbGxEYXk6IHNwYW4uYWxsRGF5LFxuICB9XG59XG4iLCJpbXBvcnQge1xuICBQb2ludGVyRHJhZ0V2ZW50LCBJbnRlcmFjdGlvbiwgSW50ZXJhY3Rpb25TZXR0aW5ncywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUsXG4gIERhdGVQb2ludEFwaSxcbiAgVmlld0FwaSxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nIH0gZnJvbSAnLi4vZG5kL0ZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcnXG5pbXBvcnQgeyBIaXREcmFnZ2luZywgaXNIaXRzRXF1YWwgfSBmcm9tICcuL0hpdERyYWdnaW5nJ1xuaW1wb3J0IHsgYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dCB9IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVDbGlja0FyZyBleHRlbmRzIERhdGVQb2ludEFwaSB7XG4gIGRheUVsOiBIVE1MRWxlbWVudFxuICBqc0V2ZW50OiBNb3VzZUV2ZW50XG4gIHZpZXc6IFZpZXdBcGlcbn1cblxuLypcbk1vbml0b3JzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGEgc3BlY2lmaWMgZGF0ZS90aW1lIG9mIGEgY29tcG9uZW50LlxuQSBwb2ludGVyZG93bitwb2ludGVydXAgb24gdGhlIHNhbWUgXCJoaXRcIiBjb25zdGl0dXRlcyBhIGNsaWNrLlxuKi9cbmV4cG9ydCBjbGFzcyBEYXRlQ2xpY2tpbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIGRyYWdnaW5nOiBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nXG4gIGhpdERyYWdnaW5nOiBIaXREcmFnZ2luZ1xuXG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzOiBJbnRlcmFjdGlvblNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpXG5cbiAgICAvLyB3ZSBETyB3YW50IHRvIHdhdGNoIHBvaW50ZXIgbW92ZXMgYmVjYXVzZSBvdGhlcndpc2UgZmluYWxIaXQgd29uJ3QgZ2V0IHBvcHVsYXRlZFxuICAgIHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbClcbiAgICB0aGlzLmRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBmYWxzZVxuXG4gICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyh0aGlzLmRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykpXG4gICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKVxuICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpXG4gIH1cblxuICBoYW5kbGVQb2ludGVyRG93biA9IChwZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBsZXQgeyBkcmFnZ2luZyB9ID0gdGhpc1xuICAgIGxldCBkb3duRWwgPSBwZXYub3JpZ0V2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuXG4gICAgLy8gZG8gdGhpcyBpbiBwb2ludGVyZG93biAobm90IGRyYWdlbmQpIGJlY2F1c2UgRE9NIG1pZ2h0IGJlIG11dGF0ZWQgYnkgdGhlIHRpbWUgZHJhZ2VuZCBpcyBmaXJlZFxuICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoXG4gICAgICAhdGhpcy5jb21wb25lbnQuaXNWYWxpZERhdGVEb3duRWwoZG93bkVsKSxcbiAgICApXG4gIH1cblxuICAvLyB3b24ndCBldmVuIGZpcmUgaWYgbW92aW5nIHdhcyBpZ25vcmVkXG4gIGhhbmRsZURyYWdFbmQgPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXNcbiAgICBsZXQgeyBwb2ludGVyIH0gPSB0aGlzLmRyYWdnaW5nXG5cbiAgICBpZiAoIXBvaW50ZXIud2FzVG91Y2hTY3JvbGwpIHtcbiAgICAgIGxldCB7IGluaXRpYWxIaXQsIGZpbmFsSGl0IH0gPSB0aGlzLmhpdERyYWdnaW5nXG5cbiAgICAgIGlmIChpbml0aWFsSGl0ICYmIGZpbmFsSGl0ICYmIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGZpbmFsSGl0KSkge1xuICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnRcbiAgICAgICAgbGV0IGFyZzogRGF0ZUNsaWNrQXJnID0ge1xuICAgICAgICAgIC4uLmJ1aWxkRGF0ZVBvaW50QXBpV2l0aENvbnRleHQoaW5pdGlhbEhpdC5kYXRlU3BhbiwgY29udGV4dCksXG4gICAgICAgICAgZGF5RWw6IGluaXRpYWxIaXQuZGF5RWwsXG4gICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50IGFzIE1vdXNlRXZlbnQsXG4gICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkYXRlQ2xpY2snLCBhcmcpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBjb21wYXJlTnVtYmVycywgZW5hYmxlQ3Vyc29yLCBkaXNhYmxlQ3Vyc29yLCBEYXRlQ29tcG9uZW50LCBIaXQsXG4gIERhdGVTcGFuLCBQb2ludGVyRHJhZ0V2ZW50LCBkYXRlU2VsZWN0aW9uSm9pblRyYW5zZm9ybWVyLFxuICBJbnRlcmFjdGlvbiwgSW50ZXJhY3Rpb25TZXR0aW5ncywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUsXG4gIHRyaWdnZXJEYXRlU2VsZWN0LCBpc0RhdGVTZWxlY3Rpb25WYWxpZCxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJ1xuaW1wb3J0IHsgSGl0RHJhZ2dpbmcgfSBmcm9tICcuL0hpdERyYWdnaW5nJ1xuaW1wb3J0IHsgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyB9IGZyb20gJy4uL2RuZC9GZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nJ1xuXG4vKlxuVHJhY2tzIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIHBvcnRpb24gb2YgdGltZSBvZiBhIGNvbXBvbmVudCxcbmNvbnN0aXR1dGVkIGJ5IGEgZHJhZyBvdmVyIGRhdGUgY2VsbHMsIHdpdGggYSBwb3NzaWJsZSBkZWxheSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkcmFnLlxuKi9cbmV4cG9ydCBjbGFzcyBEYXRlU2VsZWN0aW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICBkcmFnZ2luZzogRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZ1xuICBoaXREcmFnZ2luZzogSGl0RHJhZ2dpbmdcbiAgZHJhZ1NlbGVjdGlvbjogRGF0ZVNwYW4gfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzOiBJbnRlcmFjdGlvblNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpXG4gICAgbGV0IHsgY29tcG9uZW50IH0gPSBzZXR0aW5nc1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0XG5cbiAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpXG4gICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2VcbiAgICBkcmFnZ2luZy5taW5EaXN0YW5jZSA9IG9wdGlvbnMuc2VsZWN0TWluRGlzdGFuY2UgfHwgMFxuICAgIGRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBvcHRpb25zLmRyYWdTY3JvbGxcblxuICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKVxuICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bilcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydClcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSlcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcClcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KClcbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJEb3duID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgbGV0IHsgY29tcG9uZW50LCBkcmFnZ2luZyB9ID0gdGhpc1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0XG5cbiAgICBsZXQgY2FuU2VsZWN0ID0gb3B0aW9ucy5zZWxlY3RhYmxlICYmXG4gICAgICBjb21wb25lbnQuaXNWYWxpZERhdGVEb3duRWwoZXYub3JpZ0V2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudClcblxuICAgIC8vIGRvbid0IGJvdGhlciB0byB3YXRjaCBleHBlbnNpdmUgbW92ZXMgaWYgY29tcG9uZW50IHdvbid0IGRvIHNlbGVjdGlvblxuICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIWNhblNlbGVjdClcblxuICAgIC8vIGlmIHRvdWNoLCByZXF1aXJlIHVzZXIgdG8gaG9sZCBkb3duXG4gICAgZHJhZ2dpbmcuZGVsYXkgPSBldi5pc1RvdWNoID8gZ2V0Q29tcG9uZW50VG91Y2hEZWxheShjb21wb25lbnQpIDogbnVsbFxuICB9XG5cbiAgaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgdGhpcy5jb21wb25lbnQuY29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdChldikgLy8gdW5zZWxlY3QgcHJldmlvdXMgc2VsZWN0aW9uc1xuICB9XG5cbiAgaGFuZGxlSGl0VXBkYXRlID0gKGhpdDogSGl0IHwgbnVsbCwgaXNGaW5hbDogYm9vbGVhbikgPT4ge1xuICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXMuY29tcG9uZW50XG4gICAgbGV0IGRyYWdTZWxlY3Rpb246IERhdGVTcGFuIHwgbnVsbCA9IG51bGxcbiAgICBsZXQgaXNJbnZhbGlkID0gZmFsc2VcblxuICAgIGlmIChoaXQpIHtcbiAgICAgIGxldCBpbml0aWFsSGl0ID0gdGhpcy5oaXREcmFnZ2luZy5pbml0aWFsSGl0IVxuICAgICAgbGV0IGRpc2FsbG93ZWQgPSBoaXQuY29tcG9uZW50SWQgPT09IGluaXRpYWxIaXQuY29tcG9uZW50SWRcbiAgICAgICAgJiYgdGhpcy5pc0hpdENvbWJvQWxsb3dlZFxuICAgICAgICAmJiAhdGhpcy5pc0hpdENvbWJvQWxsb3dlZChpbml0aWFsSGl0LCBoaXQpXG5cbiAgICAgIGlmICghZGlzYWxsb3dlZCkge1xuICAgICAgICBkcmFnU2VsZWN0aW9uID0gam9pbkhpdHNJbnRvU2VsZWN0aW9uKFxuICAgICAgICAgIGluaXRpYWxIaXQsXG4gICAgICAgICAgaGl0LFxuICAgICAgICAgIGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRyYWdTZWxlY3Rpb24gfHwgIWlzRGF0ZVNlbGVjdGlvblZhbGlkKGRyYWdTZWxlY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgY29udGV4dCkpIHtcbiAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZVxuICAgICAgICBkcmFnU2VsZWN0aW9uID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkcmFnU2VsZWN0aW9uKSB7XG4gICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9EQVRFUycsIHNlbGVjdGlvbjogZHJhZ1NlbGVjdGlvbiB9KVxuICAgIH0gZWxzZSBpZiAoIWlzRmluYWwpIHsgLy8gb25seSB1bnNlbGVjdCBpZiBtb3ZlZCBhd2F5IHdoaWxlIGRyYWdnaW5nXG4gICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0RBVEVTJyB9KVxuICAgIH1cblxuICAgIGlmICghaXNJbnZhbGlkKSB7XG4gICAgICBlbmFibGVDdXJzb3IoKVxuICAgIH0gZWxzZSB7XG4gICAgICBkaXNhYmxlQ3Vyc29yKClcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluYWwpIHtcbiAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IGRyYWdTZWxlY3Rpb24gLy8gb25seSBjbGVhciBpZiBtb3ZlZCBhd2F5IGZyb20gYWxsIGhpdHMgd2hpbGUgZHJhZ2dpbmdcbiAgICB9XG4gIH1cblxuICBoYW5kbGVQb2ludGVyVXAgPSAocGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgaWYgKHRoaXMuZHJhZ1NlbGVjdGlvbikge1xuICAgICAgLy8gc2VsZWN0aW9uIGlzIGFscmVhZHkgcmVuZGVyZWQsIHNvIGp1c3QgbmVlZCB0byByZXBvcnQgc2VsZWN0aW9uXG4gICAgICB0cmlnZ2VyRGF0ZVNlbGVjdCh0aGlzLmRyYWdTZWxlY3Rpb24sIHBldiwgdGhpcy5jb21wb25lbnQuY29udGV4dClcblxuICAgICAgdGhpcy5kcmFnU2VsZWN0aW9uID0gbnVsbFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRUb3VjaERlbGF5KGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+KTogbnVtYmVyIHtcbiAgbGV0IHsgb3B0aW9ucyB9ID0gY29tcG9uZW50LmNvbnRleHRcbiAgbGV0IGRlbGF5ID0gb3B0aW9ucy5zZWxlY3RMb25nUHJlc3NEZWxheVxuXG4gIGlmIChkZWxheSA9PSBudWxsKSB7XG4gICAgZGVsYXkgPSBvcHRpb25zLmxvbmdQcmVzc0RlbGF5XG4gIH1cblxuICByZXR1cm4gZGVsYXlcbn1cblxuZnVuY3Rpb24gam9pbkhpdHNJbnRvU2VsZWN0aW9uKGhpdDA6IEhpdCwgaGl0MTogSGl0LCBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBkYXRlU2VsZWN0aW9uSm9pblRyYW5zZm9ybWVyW10pOiBEYXRlU3BhbiB7XG4gIGxldCBkYXRlU3BhbjAgPSBoaXQwLmRhdGVTcGFuXG4gIGxldCBkYXRlU3BhbjEgPSBoaXQxLmRhdGVTcGFuXG4gIGxldCBtcyA9IFtcbiAgICBkYXRlU3BhbjAucmFuZ2Uuc3RhcnQsXG4gICAgZGF0ZVNwYW4wLnJhbmdlLmVuZCxcbiAgICBkYXRlU3BhbjEucmFuZ2Uuc3RhcnQsXG4gICAgZGF0ZVNwYW4xLnJhbmdlLmVuZCxcbiAgXVxuXG4gIG1zLnNvcnQoY29tcGFyZU51bWJlcnMpXG5cbiAgbGV0IHByb3BzID0ge30gYXMgRGF0ZVNwYW5cblxuICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzKSB7XG4gICAgbGV0IHJlcyA9IHRyYW5zZm9ybWVyKGhpdDAsIGhpdDEpXG5cbiAgICBpZiAocmVzID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAocmVzKSB7XG4gICAgICBfX2Fzc2lnbihwcm9wcywgcmVzKVxuICAgIH1cbiAgfVxuXG4gIHByb3BzLnJhbmdlID0geyBzdGFydDogbXNbMF0sIGVuZDogbXNbM10gfVxuICBwcm9wcy5hbGxEYXkgPSBkYXRlU3BhbjAuYWxsRGF5XG5cbiAgcmV0dXJuIHByb3BzXG59XG4iLCJpbXBvcnQge1xuICBEYXRlQ29tcG9uZW50LCBTZWcsXG4gIFBvaW50ZXJEcmFnRXZlbnQsIEhpdCxcbiAgRXZlbnRNdXRhdGlvbiwgYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSxcbiAgc3RhcnRPZkRheSxcbiAgZWxlbWVudENsb3Nlc3QsXG4gIEV2ZW50U3RvcmUsIGdldFJlbGV2YW50RXZlbnRzLCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsXG4gIEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSxcbiAgZGlmZkRhdGVzLCBlbmFibGVDdXJzb3IsIGRpc2FibGVDdXJzb3IsXG4gIEV2ZW50UmVuZGVyUmFuZ2UsIGdldEVsU2VnLFxuICBFdmVudEFwaSxcbiAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcixcbiAgSW50ZXJhY3Rpb24sIEludGVyYWN0aW9uU2V0dGluZ3MsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSxcbiAgRXZlbnREcm9wVHJhbnNmb3JtZXJzLFxuICBDYWxlbmRhckNvbnRleHQsXG4gIFZpZXdBcGksXG4gIEV2ZW50Q2hhbmdlQXJnLFxuICBidWlsZEV2ZW50QXBpcyxcbiAgRXZlbnRBZGRBcmcsXG4gIEV2ZW50UmVtb3ZlQXJnLFxuICBpc0ludGVyYWN0aW9uVmFsaWQsXG4gIGdldEVsUm9vdCxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJ1xuaW1wb3J0IHsgSGl0RHJhZ2dpbmcsIGlzSGl0c0VxdWFsIH0gZnJvbSAnLi9IaXREcmFnZ2luZydcbmltcG9ydCB7IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcgfSBmcm9tICcuLi9kbmQvRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZydcbmltcG9ydCB7IGJ1aWxkRGF0ZVBvaW50QXBpV2l0aENvbnRleHQgfSBmcm9tICcuLi91dGlscydcblxuZXhwb3J0IHR5cGUgRXZlbnREcmFnU3RvcEFyZyA9IEV2ZW50RHJhZ0FyZ1xuZXhwb3J0IHR5cGUgRXZlbnREcmFnU3RhcnRBcmcgPSBFdmVudERyYWdBcmdcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudERyYWdBcmcge1xuICBlbDogSFRNTEVsZW1lbnRcbiAgZXZlbnQ6IEV2ZW50QXBpXG4gIGpzRXZlbnQ6IE1vdXNlRXZlbnRcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgY2xhc3MgRXZlbnREcmFnZ2luZyBleHRlbmRzIEludGVyYWN0aW9uIHsgLy8gVE9ETzogcmVuYW1lIHRvIEV2ZW50U2VsZWN0aW5nQW5kRHJhZ2dpbmdcbiAgLy8gVE9ETzogdGVzdCB0aGlzIGluIElFMTFcbiAgLy8gUVVFU1RJT046IHdoeSBkbyB3ZSBuZWVkIGl0IG9uIHRoZSByZXNpemFibGU/Pz9cbiAgc3RhdGljIFNFTEVDVE9SID0gJy5mYy1ldmVudC1kcmFnZ2FibGUsIC5mYy1ldmVudC1yZXNpemFibGUnXG5cbiAgZHJhZ2dpbmc6IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmdcbiAgaGl0RHJhZ2dpbmc6IEhpdERyYWdnaW5nXG5cbiAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgc3ViamVjdEVsOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsXG4gIHN1YmplY3RTZWc6IFNlZyB8IG51bGwgPSBudWxsIC8vIHRoZSBzZWcgYmVpbmcgc2VsZWN0ZWQvZHJhZ2dlZFxuICBpc0RyYWdnaW5nOiBib29sZWFuID0gZmFsc2VcbiAgZXZlbnRSYW5nZTogRXZlbnRSZW5kZXJSYW5nZSB8IG51bGwgPSBudWxsXG4gIHJlbGV2YW50RXZlbnRzOiBFdmVudFN0b3JlIHwgbnVsbCA9IG51bGwgLy8gdGhlIGV2ZW50cyBiZWluZyBkcmFnZ2VkXG4gIHJlY2VpdmluZ0NvbnRleHQ6IENhbGVuZGFyQ29udGV4dCB8IG51bGwgPSBudWxsXG4gIHZhbGlkTXV0YXRpb246IEV2ZW50TXV0YXRpb24gfCBudWxsID0gbnVsbFxuICBtdXRhdGVkUmVsZXZhbnRFdmVudHM6IEV2ZW50U3RvcmUgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzOiBJbnRlcmFjdGlvblNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpXG4gICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzXG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29tcG9uZW50LmNvbnRleHRcblxuICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbClcbiAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gRXZlbnREcmFnZ2luZy5TRUxFQ1RPUlxuICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlXG4gICAgZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IG9wdGlvbnMuZHJhZ1Njcm9sbFxuXG4gICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyh0aGlzLmRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUpXG4gICAgaGl0RHJhZ2dpbmcudXNlU3ViamVjdENlbnRlciA9IHNldHRpbmdzLnVzZUV2ZW50Q2VudGVyXG4gICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKVxuICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KVxuICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIHRoaXMuaGFuZGxlSGl0VXBkYXRlKVxuICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKVxuICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpXG4gIH1cblxuICBoYW5kbGVQb2ludGVyRG93biA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGxldCBvcmlnVGFyZ2V0ID0gZXYub3JpZ0V2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuICAgIGxldCB7IGNvbXBvbmVudCwgZHJhZ2dpbmcgfSA9IHRoaXNcbiAgICBsZXQgeyBtaXJyb3IgfSA9IGRyYWdnaW5nXG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29tcG9uZW50LmNvbnRleHRcbiAgICBsZXQgaW5pdGlhbENvbnRleHQgPSBjb21wb25lbnQuY29udGV4dFxuICAgIHRoaXMuc3ViamVjdEVsID0gZXYuc3ViamVjdEVsIGFzIEhUTUxFbGVtZW50XG4gICAgbGV0IHN1YmplY3RTZWcgPSB0aGlzLnN1YmplY3RTZWcgPSBnZXRFbFNlZyhldi5zdWJqZWN0RWwgYXMgSFRNTEVsZW1lbnQpIVxuICAgIGxldCBldmVudFJhbmdlID0gdGhpcy5ldmVudFJhbmdlID0gc3ViamVjdFNlZy5ldmVudFJhbmdlIVxuICAgIGxldCBldmVudEluc3RhbmNlSWQgPSBldmVudFJhbmdlLmluc3RhbmNlIS5pbnN0YW5jZUlkXG5cbiAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoXG4gICAgICBpbml0aWFsQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmUsXG4gICAgICBldmVudEluc3RhbmNlSWQsXG4gICAgKVxuXG4gICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBldi5pc1RvdWNoID8gMCA6IG9wdGlvbnMuZXZlbnREcmFnTWluRGlzdGFuY2VcbiAgICBkcmFnZ2luZy5kZWxheSA9XG4gICAgICAvLyBvbmx5IGRvIGEgdG91Y2ggZGVsYXkgaWYgdG91Y2ggYW5kIHRoaXMgZXZlbnQgaGFzbid0IGJlZW4gc2VsZWN0ZWQgeWV0XG4gICAgICAoZXYuaXNUb3VjaCAmJiBldmVudEluc3RhbmNlSWQgIT09IGNvbXBvbmVudC5wcm9wcy5ldmVudFNlbGVjdGlvbikgP1xuICAgICAgICBnZXRDb21wb25lbnRUb3VjaERlbGF5KGNvbXBvbmVudCkgOlxuICAgICAgICBudWxsXG5cbiAgICBpZiAob3B0aW9ucy5maXhlZE1pcnJvclBhcmVudCkge1xuICAgICAgbWlycm9yLnBhcmVudE5vZGUgPSBvcHRpb25zLmZpeGVkTWlycm9yUGFyZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pcnJvci5wYXJlbnROb2RlID0gZWxlbWVudENsb3Nlc3Qob3JpZ1RhcmdldCwgJy5mYycpXG4gICAgfVxuXG4gICAgbWlycm9yLnJldmVydER1cmF0aW9uID0gb3B0aW9ucy5kcmFnUmV2ZXJ0RHVyYXRpb25cblxuICAgIGxldCBpc1ZhbGlkID1cbiAgICAgIGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKG9yaWdUYXJnZXQpICYmXG4gICAgICAhZWxlbWVudENsb3Nlc3Qob3JpZ1RhcmdldCwgJy5mYy1ldmVudC1yZXNpemVyJykgLy8gTk9UIG9uIGEgcmVzaXplclxuXG4gICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghaXNWYWxpZClcblxuICAgIC8vIGRpc2FibGUgZHJhZ2dpbmcgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIHJlc2l6YWJsZSAoaWUsIHNlbGVjdGFibGUpXG4gICAgLy8gYnV0IGFyZSBub3QgZHJhZ2dhYmxlXG4gICAgdGhpcy5pc0RyYWdnaW5nID0gaXNWYWxpZCAmJlxuICAgICAgKGV2LnN1YmplY3RFbCBhcyBIVE1MRWxlbWVudCkuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1ldmVudC1kcmFnZ2FibGUnKVxuICB9XG5cbiAgaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dFxuICAgIGxldCBldmVudFJhbmdlID0gdGhpcy5ldmVudFJhbmdlIVxuICAgIGxldCBldmVudEluc3RhbmNlSWQgPSBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRcblxuICAgIGlmIChldi5pc1RvdWNoKSB7XG4gICAgICAvLyBuZWVkIHRvIHNlbGVjdCBhIGRpZmZlcmVudCBldmVudD9cbiAgICAgIGlmIChldmVudEluc3RhbmNlSWQgIT09IHRoaXMuY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uKSB7XG4gICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9FVkVOVCcsIGV2ZW50SW5zdGFuY2VJZCB9KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBub3cgdXNpbmcgbW91c2UsIGJ1dCB3YXMgcHJldmlvdXMgdG91Y2ggaW50ZXJhY3Rpb24sIGNsZWFyIHNlbGVjdGVkIGV2ZW50XG4gICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9FVkVOVCcgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICBpbml0aWFsQ29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdChldikgLy8gdW5zZWxlY3QgKmRhdGUqIHNlbGVjdGlvblxuICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudERyYWdTdGFydCcsIHtcbiAgICAgICAgZWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGluaXRpYWxDb250ZXh0LCBldmVudFJhbmdlLmRlZiwgZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCBhcyBNb3VzZUV2ZW50LCAvLyBJcyB0aGlzIGFsd2F5cyBhIG1vdXNlIGV2ZW50PyBTZWUgIzQ2NTVcbiAgICAgICAgdmlldzogaW5pdGlhbENvbnRleHQudmlld0FwaSxcbiAgICAgIH0gYXMgRXZlbnREcmFnU3RhcnRBcmcpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlSGl0VXBkYXRlID0gKGhpdDogSGl0IHwgbnVsbCwgaXNGaW5hbDogYm9vbGVhbikgPT4ge1xuICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgcmVsZXZhbnRFdmVudHMgPSB0aGlzLnJlbGV2YW50RXZlbnRzIVxuICAgIGxldCBpbml0aWFsSGl0ID0gdGhpcy5oaXREcmFnZ2luZy5pbml0aWFsSGl0IVxuICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHRcblxuICAgIC8vIHN0YXRlcyBiYXNlZCBvbiBuZXcgaGl0XG4gICAgbGV0IHJlY2VpdmluZ0NvbnRleHQ6IENhbGVuZGFyQ29udGV4dCB8IG51bGwgPSBudWxsXG4gICAgbGV0IG11dGF0aW9uOiBFdmVudE11dGF0aW9uIHwgbnVsbCA9IG51bGxcbiAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzOiBFdmVudFN0b3JlIHwgbnVsbCA9IG51bGxcbiAgICBsZXQgaXNJbnZhbGlkID0gZmFsc2VcbiAgICBsZXQgaW50ZXJhY3Rpb246IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSA9IHtcbiAgICAgIGFmZmVjdGVkRXZlbnRzOiByZWxldmFudEV2ZW50cyxcbiAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICB9XG5cbiAgICBpZiAoaGl0KSB7XG4gICAgICByZWNlaXZpbmdDb250ZXh0ID0gaGl0LmNvbnRleHRcbiAgICAgIGxldCByZWNlaXZpbmdPcHRpb25zID0gcmVjZWl2aW5nQ29udGV4dC5vcHRpb25zXG5cbiAgICAgIGlmIChcbiAgICAgICAgaW5pdGlhbENvbnRleHQgPT09IHJlY2VpdmluZ0NvbnRleHQgfHxcbiAgICAgICAgKHJlY2VpdmluZ09wdGlvbnMuZWRpdGFibGUgJiYgcmVjZWl2aW5nT3B0aW9ucy5kcm9wcGFibGUpXG4gICAgICApIHtcbiAgICAgICAgbXV0YXRpb24gPSBjb21wdXRlRXZlbnRNdXRhdGlvbihpbml0aWFsSGl0LCBoaXQsIHJlY2VpdmluZ0NvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5wbHVnaW5Ib29rcy5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycylcblxuICAgICAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKFxuICAgICAgICAgICAgcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLFxuICAgICAgICAgICAgbXV0YXRpb24sXG4gICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LFxuICAgICAgICAgIClcbiAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzXG5cbiAgICAgICAgICBpZiAoIWlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCByZWNlaXZpbmdDb250ZXh0KSkge1xuICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZVxuICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsXG4gICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsXG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwbGF5RHJhZyhyZWNlaXZpbmdDb250ZXh0LCBpbnRlcmFjdGlvbilcblxuICAgIGlmICghaXNJbnZhbGlkKSB7XG4gICAgICBlbmFibGVDdXJzb3IoKVxuICAgIH0gZWxzZSB7XG4gICAgICBkaXNhYmxlQ3Vyc29yKClcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluYWwpIHtcbiAgICAgIGlmIChcbiAgICAgICAgaW5pdGlhbENvbnRleHQgPT09IHJlY2VpdmluZ0NvbnRleHQgJiYgLy8gVE9ETzogd3JpdGUgdGVzdCBmb3IgdGhpc1xuICAgICAgICBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBoaXQpXG4gICAgICApIHtcbiAgICAgICAgbXV0YXRpb24gPSBudWxsXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJhZ2dpbmcuc2V0TWlycm9yTmVlZHNSZXZlcnQoIW11dGF0aW9uKVxuXG4gICAgICAvLyByZW5kZXIgdGhlIG1pcnJvciBpZiBubyBhbHJlYWR5LXJlbmRlcmVkIG1pcnJvclxuICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCBzb21laG93IHdhaXQgZm9yIGRpc3BhdGNoIHRvIGd1YXJhbnRlZSByZW5kZXJcbiAgICAgIHRoaXMuZHJhZ2dpbmcuc2V0TWlycm9ySXNWaXNpYmxlKFxuICAgICAgICAhaGl0IHx8ICFnZXRFbFJvb3QodGhpcy5zdWJqZWN0RWwpLnF1ZXJ5U2VsZWN0b3IoJy5mYy1ldmVudC1taXJyb3InKSwgLy8gVE9ETzogdHVybiBjbGFzc05hbWUgaW50byBjb25zdGFudFxuICAgICAgKVxuXG4gICAgICAvLyBhc3NpZ24gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcbiAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IHJlY2VpdmluZ0NvbnRleHRcbiAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG11dGF0aW9uXG4gICAgICB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50c1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJVcCA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgdGhpcy5jbGVhbnVwKCkgLy8gYmVjYXVzZSBoYW5kbGVEcmFnRW5kIHdvbid0IGZpcmVcbiAgICB9XG4gIH1cblxuICBoYW5kbGVEcmFnRW5kID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dFxuICAgICAgbGV0IGluaXRpYWxWaWV3ID0gaW5pdGlhbENvbnRleHQudmlld0FwaVxuICAgICAgbGV0IHsgcmVjZWl2aW5nQ29udGV4dCwgdmFsaWRNdXRhdGlvbiB9ID0gdGhpc1xuICAgICAgbGV0IGV2ZW50RGVmID0gdGhpcy5ldmVudFJhbmdlIS5kZWZcbiAgICAgIGxldCBldmVudEluc3RhbmNlID0gdGhpcy5ldmVudFJhbmdlIS5pbnN0YW5jZVxuICAgICAgbGV0IGV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGluaXRpYWxDb250ZXh0LCBldmVudERlZiwgZXZlbnRJbnN0YW5jZSlcbiAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHMhXG4gICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMhXG4gICAgICBsZXQgeyBmaW5hbEhpdCB9ID0gdGhpcy5oaXREcmFnZ2luZ1xuXG4gICAgICB0aGlzLmNsZWFyRHJhZygpIC8vIG11c3QgaGFwcGVuIGFmdGVyIHJldmVydCBhbmltYXRpb25cblxuICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudERyYWdTdG9wJywge1xuICAgICAgICBlbDogdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50IGFzIE1vdXNlRXZlbnQsIC8vIElzIHRoaXMgYWx3YXlzIGEgbW91c2UgZXZlbnQ/IFNlZSAjNDY1NVxuICAgICAgICB2aWV3OiBpbml0aWFsVmlldyxcbiAgICAgIH0gYXMgRXZlbnREcmFnU3RvcEFyZylcblxuICAgICAgaWYgKHZhbGlkTXV0YXRpb24pIHtcbiAgICAgICAgLy8gZHJvcHBlZCB3aXRoaW4gc2FtZSBjYWxlbmRhclxuICAgICAgICBpZiAocmVjZWl2aW5nQ29udGV4dCA9PT0gaW5pdGlhbENvbnRleHQpIHtcbiAgICAgICAgICBsZXQgdXBkYXRlZEV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKFxuICAgICAgICAgICAgaW5pdGlhbENvbnRleHQsXG4gICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMuZGVmc1tldmVudERlZi5kZWZJZF0sXG4gICAgICAgICAgICBldmVudEluc3RhbmNlID8gbXV0YXRlZFJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tldmVudEluc3RhbmNlLmluc3RhbmNlSWRdIDogbnVsbCxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50cyxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgbGV0IGV2ZW50Q2hhbmdlQXJnOiBFdmVudENoYW5nZUFyZyA9IHtcbiAgICAgICAgICAgIG9sZEV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgIGV2ZW50OiB1cGRhdGVkRXZlbnRBcGksXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHMsIGluaXRpYWxDb250ZXh0LCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLCAvLyB0aGUgcHJlLWNoYW5nZSBkYXRhXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZDogUmV0dXJuVHlwZTxFdmVudERyb3BUcmFuc2Zvcm1lcnM+ID0ge31cbiAgICAgICAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiBpbml0aWFsQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLnBsdWdpbkhvb2tzLmV2ZW50RHJvcFRyYW5zZm9ybWVycykge1xuICAgICAgICAgICAgX19hc3NpZ24odHJhbnNmb3JtZWQsIHRyYW5zZm9ybWVyKHZhbGlkTXV0YXRpb24sIGluaXRpYWxDb250ZXh0KSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJvcCcsIHtcbiAgICAgICAgICAgIC4uLmV2ZW50Q2hhbmdlQXJnLFxuICAgICAgICAgICAgLi4udHJhbnNmb3JtZWQsXG4gICAgICAgICAgICBlbDogZXYuc3ViamVjdEVsIGFzIEhUTUxFbGVtZW50LFxuICAgICAgICAgICAgZGVsdGE6IHZhbGlkTXV0YXRpb24uZGF0ZXNEZWx0YSEsXG4gICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQgYXMgTW91c2VFdmVudCwgLy8gYmFkXG4gICAgICAgICAgICB2aWV3OiBpbml0aWFsVmlldyxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIGV2ZW50Q2hhbmdlQXJnKVxuXG4gICAgICAgIC8vIGRyb3BwZWQgaW4gZGlmZmVyZW50IGNhbGVuZGFyXG4gICAgICAgIH0gZWxzZSBpZiAocmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgIGxldCBldmVudFJlbW92ZUFyZzogRXZlbnRSZW1vdmVBcmcgPSB7XG4gICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhyZWxldmFudEV2ZW50cywgaW5pdGlhbENvbnRleHQsIGV2ZW50SW5zdGFuY2UpLFxuICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRMZWF2ZScsIHtcbiAgICAgICAgICAgIC4uLmV2ZW50UmVtb3ZlQXJnLFxuICAgICAgICAgICAgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwgYXMgSFRNTEVsZW1lbnQsXG4gICAgICAgICAgICB2aWV3OiBpbml0aWFsVmlldyxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZW1vdmUnLCBldmVudFJlbW92ZUFyZylcblxuICAgICAgICAgIGxldCBhZGRlZEV2ZW50RGVmID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzLmRlZnNbZXZlbnREZWYuZGVmSWRdXG4gICAgICAgICAgbGV0IGFkZGVkRXZlbnRJbnN0YW5jZSA9IG11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXVxuICAgICAgICAgIGxldCBhZGRlZEV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKHJlY2VpdmluZ0NvbnRleHQsIGFkZGVkRXZlbnREZWYsIGFkZGVkRXZlbnRJbnN0YW5jZSlcblxuICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBtdXRhdGVkUmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGxldCBldmVudEFkZEFyZzogRXZlbnRBZGRBcmcgPSB7XG4gICAgICAgICAgICBldmVudDogYWRkZWRFdmVudEFwaSxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IGJ1aWxkRXZlbnRBcGlzKG11dGF0ZWRSZWxldmFudEV2ZW50cywgcmVjZWl2aW5nQ29udGV4dCwgYWRkZWRFdmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50QWRkJywgZXZlbnRBZGRBcmcpXG5cbiAgICAgICAgICBpZiAoZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxuICAgICAgICAgICAgICBldmVudEluc3RhbmNlSWQ6IGV2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2Ryb3AnLCB7XG4gICAgICAgICAgICAuLi5idWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0KSxcbiAgICAgICAgICAgIGRyYWdnZWRFbDogZXYuc3ViamVjdEVsIGFzIEhUTUxFbGVtZW50LFxuICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50IGFzIE1vdXNlRXZlbnQsIC8vIElzIHRoaXMgYWx3YXlzIGEgbW91c2UgZXZlbnQ/IFNlZSAjNDY1NVxuICAgICAgICAgICAgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZWNlaXZlJywge1xuICAgICAgICAgICAgLi4uZXZlbnRBZGRBcmcsXG4gICAgICAgICAgICBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCBhcyBIVE1MRWxlbWVudCxcbiAgICAgICAgICAgIHZpZXc6IGZpbmFsSGl0LmNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ19ub0V2ZW50RHJvcCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhbnVwKClcbiAgfVxuXG4gIC8vIHJlbmRlciBhIGRyYWcgc3RhdGUgb24gdGhlIG5leHQgcmVjZWl2aW5nQ2FsZW5kYXJcbiAgZGlzcGxheURyYWcobmV4dENvbnRleHQ6IENhbGVuZGFyQ29udGV4dCB8IG51bGwsIHN0YXRlOiBFdmVudEludGVyYWN0aW9uU3RhdGUpIHtcbiAgICBsZXQgaW5pdGlhbENvbnRleHQgPSB0aGlzLmNvbXBvbmVudC5jb250ZXh0XG4gICAgbGV0IHByZXZDb250ZXh0ID0gdGhpcy5yZWNlaXZpbmdDb250ZXh0XG5cbiAgICAvLyBkb2VzIHRoZSBwcmV2aW91cyBjYWxlbmRhciBuZWVkIHRvIGJlIGNsZWFyZWQ/XG4gICAgaWYgKHByZXZDb250ZXh0ICYmIHByZXZDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuICAgICAgLy8gZG9lcyB0aGUgaW5pdGlhbCBjYWxlbmRhciBuZWVkIHRvIGJlIGNsZWFyZWQ/XG4gICAgICAvLyBpZiBzbywgZG9uJ3QgY2xlYXIgYWxsIHRoZSB3YXkuIHdlIHN0aWxsIG5lZWQgdG8gdG8gaGlkZSB0aGUgYWZmZWN0ZWRFdmVudHNcbiAgICAgIGlmIChwcmV2Q29udGV4dCA9PT0gaW5pdGlhbENvbnRleHQpIHtcbiAgICAgICAgcHJldkNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdTRVRfRVZFTlRfRFJBRycsXG4gICAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBzdGF0ZS5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAvLyBjb21wbGV0ZWx5IGNsZWFyIHRoZSBvbGQgY2FsZW5kYXIgaWYgaXQgd2Fzbid0IHRoZSBpbml0aWFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2Q29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXh0Q29udGV4dCkge1xuICAgICAgbmV4dENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLCBzdGF0ZSB9KVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyRHJhZygpIHtcbiAgICBsZXQgaW5pdGlhbENhbGVuZGFyID0gdGhpcy5jb21wb25lbnQuY29udGV4dFxuICAgIGxldCB7IHJlY2VpdmluZ0NvbnRleHQgfSA9IHRoaXNcblxuICAgIGlmIChyZWNlaXZpbmdDb250ZXh0KSB7XG4gICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pXG4gICAgfVxuXG4gICAgLy8gdGhlIGluaXRpYWwgY2FsZW5kYXIgbWlnaHQgaGF2ZSBhbiBkdW1teSBkcmFnIHN0YXRlIGZyb20gZGlzcGxheURyYWdcbiAgICBpZiAoaW5pdGlhbENhbGVuZGFyICE9PSByZWNlaXZpbmdDb250ZXh0KSB7XG4gICAgICBpbml0aWFsQ2FsZW5kYXIuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSlcbiAgICB9XG4gIH1cblxuICBjbGVhbnVwKCkgeyAvLyByZXNldCBhbGwgaW50ZXJuYWwgc3RhdGVcbiAgICB0aGlzLnN1YmplY3RTZWcgPSBudWxsXG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICB0aGlzLmV2ZW50UmFuZ2UgPSBudWxsXG4gICAgdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGxcbiAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSBudWxsXG4gICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbFxuICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFdmVudE11dGF0aW9uKGhpdDA6IEhpdCwgaGl0MTogSGl0LCBtYXNzYWdlcnM6IGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJbXSk6IEV2ZW50TXV0YXRpb24ge1xuICBsZXQgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhblxuICBsZXQgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhblxuICBsZXQgZGF0ZTAgPSBkYXRlU3BhbjAucmFuZ2Uuc3RhcnRcbiAgbGV0IGRhdGUxID0gZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0XG4gIGxldCBzdGFuZGFyZFByb3BzID0ge30gYXMgYW55XG5cbiAgaWYgKGRhdGVTcGFuMC5hbGxEYXkgIT09IGRhdGVTcGFuMS5hbGxEYXkpIHtcbiAgICBzdGFuZGFyZFByb3BzLmFsbERheSA9IGRhdGVTcGFuMS5hbGxEYXlcbiAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IGhpdDEuY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb25cblxuICAgIGlmIChkYXRlU3BhbjEuYWxsRGF5KSB7XG4gICAgICAvLyBtZWFucyBkYXRlMSBpcyBhbHJlYWR5IHN0YXJ0LW9mLWRheSxcbiAgICAgIC8vIGJ1dCBkYXRlMCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcbiAgICAgIGRhdGUwID0gc3RhcnRPZkRheShkYXRlMClcbiAgICB9XG4gIH1cblxuICBsZXQgZGVsdGEgPSBkaWZmRGF0ZXMoXG4gICAgZGF0ZTAsIGRhdGUxLFxuICAgIGhpdDAuY29udGV4dC5kYXRlRW52LFxuICAgIGhpdDAuY29tcG9uZW50SWQgPT09IGhpdDEuY29tcG9uZW50SWQgP1xuICAgICAgaGl0MC5sYXJnZVVuaXQgOlxuICAgICAgbnVsbCxcbiAgKVxuXG4gIGlmIChkZWx0YS5taWxsaXNlY29uZHMpIHsgLy8gaGFzIGhvdXJzL21pbnV0ZXMvc2Vjb25kc1xuICAgIHN0YW5kYXJkUHJvcHMuYWxsRGF5ID0gZmFsc2VcbiAgfVxuXG4gIGxldCBtdXRhdGlvbjogRXZlbnRNdXRhdGlvbiA9IHtcbiAgICBkYXRlc0RlbHRhOiBkZWx0YSxcbiAgICBzdGFuZGFyZFByb3BzLFxuICB9XG5cbiAgZm9yIChsZXQgbWFzc2FnZXIgb2YgbWFzc2FnZXJzKSB7XG4gICAgbWFzc2FnZXIobXV0YXRpb24sIGhpdDAsIGhpdDEpXG4gIH1cblxuICByZXR1cm4gbXV0YXRpb25cbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VG91Y2hEZWxheShjb21wb25lbnQ6IERhdGVDb21wb25lbnQ8YW55Pik6IG51bWJlciB8IG51bGwge1xuICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dFxuICBsZXQgZGVsYXkgPSBvcHRpb25zLmV2ZW50TG9uZ1ByZXNzRGVsYXlcblxuICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgIGRlbGF5ID0gb3B0aW9ucy5sb25nUHJlc3NEZWxheVxuICB9XG5cbiAgcmV0dXJuIGRlbGF5XG59XG4iLCJpbXBvcnQge1xuICBTZWcsIEhpdCxcbiAgRXZlbnRNdXRhdGlvbiwgYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSxcbiAgZWxlbWVudENsb3Nlc3QsXG4gIFBvaW50ZXJEcmFnRXZlbnQsXG4gIEV2ZW50U3RvcmUsIGdldFJlbGV2YW50RXZlbnRzLCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsXG4gIGRpZmZEYXRlcywgZW5hYmxlQ3Vyc29yLCBkaXNhYmxlQ3Vyc29yLFxuICBEYXRlUmFuZ2UsXG4gIEV2ZW50QXBpLFxuICBFdmVudFJlbmRlclJhbmdlLCBnZXRFbFNlZyxcbiAgY3JlYXRlRHVyYXRpb24sXG4gIEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSxcbiAgSW50ZXJhY3Rpb24sIEludGVyYWN0aW9uU2V0dGluZ3MsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlLCBWaWV3QXBpLCBEdXJhdGlvbiwgRXZlbnRDaGFuZ2VBcmcsIGJ1aWxkRXZlbnRBcGlzLCBpc0ludGVyYWN0aW9uVmFsaWQsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IEhpdERyYWdnaW5nLCBpc0hpdHNFcXVhbCB9IGZyb20gJy4vSGl0RHJhZ2dpbmcnXG5pbXBvcnQgeyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nIH0gZnJvbSAnLi4vZG5kL0ZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcnXG5cbmV4cG9ydCB0eXBlIEV2ZW50UmVzaXplU3RhcnRBcmcgPSBFdmVudFJlc2l6ZVN0YXJ0U3RvcEFyZ1xuZXhwb3J0IHR5cGUgRXZlbnRSZXNpemVTdG9wQXJnID0gRXZlbnRSZXNpemVTdGFydFN0b3BBcmdcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFJlc2l6ZVN0YXJ0U3RvcEFyZyB7XG4gIGVsOiBIVE1MRWxlbWVudFxuICBldmVudDogRXZlbnRBcGlcbiAganNFdmVudDogTW91c2VFdmVudFxuICB2aWV3OiBWaWV3QXBpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRSZXNpemVEb25lQXJnIGV4dGVuZHMgRXZlbnRDaGFuZ2VBcmcge1xuICBlbDogSFRNTEVsZW1lbnRcbiAgc3RhcnREZWx0YTogRHVyYXRpb25cbiAgZW5kRGVsdGE6IER1cmF0aW9uXG4gIGpzRXZlbnQ6IE1vdXNlRXZlbnRcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgY2xhc3MgRXZlbnRSZXNpemluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgZHJhZ2dpbmc6IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmdcbiAgaGl0RHJhZ2dpbmc6IEhpdERyYWdnaW5nXG5cbiAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgZHJhZ2dpbmdTZWdFbDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbFxuICBkcmFnZ2luZ1NlZzogU2VnIHwgbnVsbCA9IG51bGwgLy8gVE9ETzogcmVuYW1lIHRvIHJlc2l6aW5nU2VnPyBzdWJqZWN0U2VnP1xuICBldmVudFJhbmdlOiBFdmVudFJlbmRlclJhbmdlIHwgbnVsbCA9IG51bGxcbiAgcmVsZXZhbnRFdmVudHM6IEV2ZW50U3RvcmUgfCBudWxsID0gbnVsbFxuICB2YWxpZE11dGF0aW9uOiBFdmVudE11dGF0aW9uIHwgbnVsbCA9IG51bGxcbiAgbXV0YXRlZFJlbGV2YW50RXZlbnRzOiBFdmVudFN0b3JlIHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcihzZXR0aW5nczogSW50ZXJhY3Rpb25TZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKVxuICAgIGxldCB7IGNvbXBvbmVudCB9ID0gc2V0dGluZ3NcblxuICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbClcbiAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gJy5mYy1ldmVudC1yZXNpemVyJ1xuICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlXG4gICAgZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnMuZHJhZ1Njcm9sbFxuXG4gICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyh0aGlzLmRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykpXG4gICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKVxuICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KVxuICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIHRoaXMuaGFuZGxlSGl0VXBkYXRlKVxuICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpXG4gIH1cblxuICBoYW5kbGVQb2ludGVyRG93biA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpc1xuICAgIGxldCBzZWdFbCA9IHRoaXMucXVlcnlTZWdFbChldilcbiAgICBsZXQgc2VnID0gZ2V0RWxTZWcoc2VnRWwpXG4gICAgbGV0IGV2ZW50UmFuZ2UgPSB0aGlzLmV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZSFcblxuICAgIHRoaXMuZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zLmV2ZW50RHJhZ01pbkRpc3RhbmNlXG5cbiAgICAvLyBpZiB0b3VjaCwgbmVlZCB0byBiZSB3b3JraW5nIHdpdGggYSBzZWxlY3RlZCBldmVudFxuICAgIHRoaXMuZHJhZ2dpbmcuc2V0SWdub3JlTW92ZShcbiAgICAgICF0aGlzLmNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2Lm9yaWdFdmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpIHx8XG4gICAgICAoZXYuaXNUb3VjaCAmJiB0aGlzLmNvbXBvbmVudC5wcm9wcy5ldmVudFNlbGVjdGlvbiAhPT0gZXZlbnRSYW5nZS5pbnN0YW5jZSEuaW5zdGFuY2VJZCksXG4gICAgKVxuICB9XG5cbiAgaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnRcbiAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZSFcblxuICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhcbiAgICAgIGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFN0b3JlLFxuICAgICAgdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlIS5pbnN0YW5jZUlkLFxuICAgIClcblxuICAgIGxldCBzZWdFbCA9IHRoaXMucXVlcnlTZWdFbChldilcbiAgICB0aGlzLmRyYWdnaW5nU2VnRWwgPSBzZWdFbFxuICAgIHRoaXMuZHJhZ2dpbmdTZWcgPSBnZXRFbFNlZyhzZWdFbClcblxuICAgIGNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoKVxuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZVN0YXJ0Jywge1xuICAgICAgZWw6IHNlZ0VsLFxuICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShjb250ZXh0LCBldmVudFJhbmdlLmRlZiwgZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQgYXMgTW91c2VFdmVudCwgLy8gSXMgdGhpcyBhbHdheXMgYSBtb3VzZSBldmVudD8gU2VlICM0NjU1XG4gICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgfSBhcyBFdmVudFJlc2l6ZVN0YXJ0QXJnKVxuICB9XG5cbiAgaGFuZGxlSGl0VXBkYXRlID0gKGhpdDogSGl0IHwgbnVsbCwgaXNGaW5hbDogYm9vbGVhbiwgZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudFxuICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHMhXG4gICAgbGV0IGluaXRpYWxIaXQgPSB0aGlzLmhpdERyYWdnaW5nLmluaXRpYWxIaXQhXG4gICAgbGV0IGV2ZW50SW5zdGFuY2UgPSB0aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2UhXG4gICAgbGV0IG11dGF0aW9uOiBFdmVudE11dGF0aW9uIHwgbnVsbCA9IG51bGxcbiAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzOiBFdmVudFN0b3JlIHwgbnVsbCA9IG51bGxcbiAgICBsZXQgaXNJbnZhbGlkID0gZmFsc2VcbiAgICBsZXQgaW50ZXJhY3Rpb246IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSA9IHtcbiAgICAgIGFmZmVjdGVkRXZlbnRzOiByZWxldmFudEV2ZW50cyxcbiAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICB9XG5cbiAgICBpZiAoaGl0KSB7XG4gICAgICBsZXQgZGlzYWxsb3dlZCA9IGhpdC5jb21wb25lbnRJZCA9PT0gaW5pdGlhbEhpdC5jb21wb25lbnRJZFxuICAgICAgICAmJiB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkXG4gICAgICAgICYmICF0aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdClcblxuICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XG4gICAgICAgIG11dGF0aW9uID0gY29tcHV0ZU11dGF0aW9uKFxuICAgICAgICAgIGluaXRpYWxIaXQsXG4gICAgICAgICAgaGl0LFxuICAgICAgICAgIChldi5zdWJqZWN0RWwgYXMgSFRNTEVsZW1lbnQpLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQtcmVzaXplci1zdGFydCcpLFxuICAgICAgICAgIGV2ZW50SW5zdGFuY2UucmFuZ2UsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgIG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUocmVsZXZhbnRFdmVudHMsIGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFVpQmFzZXMsIG11dGF0aW9uLCBjb250ZXh0KVxuICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50c1xuXG4gICAgICBpZiAoIWlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCBjb250ZXh0KSkge1xuICAgICAgICBpc0ludmFsaWQgPSB0cnVlXG4gICAgICAgIG11dGF0aW9uID0gbnVsbFxuICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsXG4gICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG11dGF0ZWRSZWxldmFudEV2ZW50cykge1xuICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdTRVRfRVZFTlRfUkVTSVpFJyxcbiAgICAgICAgc3RhdGU6IGludGVyYWN0aW9uLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9SRVNJWkUnIH0pXG4gICAgfVxuXG4gICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgIGVuYWJsZUN1cnNvcigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc2FibGVDdXJzb3IoKVxuICAgIH1cblxuICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgaWYgKG11dGF0aW9uICYmIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcbiAgICAgICAgbXV0YXRpb24gPSBudWxsXG4gICAgICB9XG5cbiAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG11dGF0aW9uXG4gICAgICB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50c1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZURyYWdFbmQgPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudFxuICAgIGxldCBldmVudERlZiA9IHRoaXMuZXZlbnRSYW5nZSEuZGVmXG4gICAgbGV0IGV2ZW50SW5zdGFuY2UgPSB0aGlzLmV2ZW50UmFuZ2UhLmluc3RhbmNlXG4gICAgbGV0IGV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNvbnRleHQsIGV2ZW50RGVmLCBldmVudEluc3RhbmNlKVxuICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHMhXG4gICAgbGV0IG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzIVxuXG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVzaXplU3RvcCcsIHtcbiAgICAgIGVsOiB0aGlzLmRyYWdnaW5nU2VnRWwsXG4gICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQgYXMgTW91c2VFdmVudCwgLy8gSXMgdGhpcyBhbHdheXMgYSBtb3VzZSBldmVudD8gU2VlICM0NjU1XG4gICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgfSBhcyBFdmVudFJlc2l6ZVN0b3BBcmcpXG5cbiAgICBpZiAodGhpcy52YWxpZE11dGF0aW9uKSB7XG4gICAgICBsZXQgdXBkYXRlZEV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMuZGVmc1tldmVudERlZi5kZWZJZF0sXG4gICAgICAgIGV2ZW50SW5zdGFuY2UgPyBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF0gOiBudWxsLFxuICAgICAgKVxuXG4gICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50cyxcbiAgICAgIH0pXG5cbiAgICAgIGxldCBldmVudENoYW5nZUFyZzogRXZlbnRDaGFuZ2VBcmcgPSB7XG4gICAgICAgIG9sZEV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgZXZlbnQ6IHVwZGF0ZWRFdmVudEFwaSxcbiAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCBjb250ZXh0LCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50cywgLy8gdGhlIHByZS1jaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVzaXplJywge1xuICAgICAgICAuLi5ldmVudENoYW5nZUFyZyxcbiAgICAgICAgZWw6IHRoaXMuZHJhZ2dpbmdTZWdFbCxcbiAgICAgICAgc3RhcnREZWx0YTogdGhpcy52YWxpZE11dGF0aW9uLnN0YXJ0RGVsdGEgfHwgY3JlYXRlRHVyYXRpb24oMCksXG4gICAgICAgIGVuZERlbHRhOiB0aGlzLnZhbGlkTXV0YXRpb24uZW5kRGVsdGEgfHwgY3JlYXRlRHVyYXRpb24oMCksXG4gICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCBhcyBNb3VzZUV2ZW50LFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICB9KVxuXG4gICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCBldmVudENoYW5nZUFyZylcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ19ub0V2ZW50UmVzaXplJylcbiAgICB9XG5cbiAgICAvLyByZXNldCBhbGwgaW50ZXJuYWwgc3RhdGVcbiAgICB0aGlzLmRyYWdnaW5nU2VnID0gbnVsbFxuICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsXG4gICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbFxuXG4gICAgLy8gb2theSB0byBrZWVwIGV2ZW50SW5zdGFuY2UgYXJvdW5kLiB1c2VmdWwgdG8gc2V0IGl0IGluIGhhbmRsZVBvaW50ZXJEb3duXG4gIH1cblxuICBxdWVyeVNlZ0VsKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnRDbG9zZXN0KGV2LnN1YmplY3RFbCBhcyBIVE1MRWxlbWVudCwgJy5mYy1ldmVudCcpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZU11dGF0aW9uKFxuICBoaXQwOiBIaXQsXG4gIGhpdDE6IEhpdCxcbiAgaXNGcm9tU3RhcnQ6IGJvb2xlYW4sXG4gIGluc3RhbmNlUmFuZ2U6IERhdGVSYW5nZSxcbik6IEV2ZW50TXV0YXRpb24gfCBudWxsIHtcbiAgbGV0IGRhdGVFbnYgPSBoaXQwLmNvbnRleHQuZGF0ZUVudlxuICBsZXQgZGF0ZTAgPSBoaXQwLmRhdGVTcGFuLnJhbmdlLnN0YXJ0XG4gIGxldCBkYXRlMSA9IGhpdDEuZGF0ZVNwYW4ucmFuZ2Uuc3RhcnRcblxuICBsZXQgZGVsdGEgPSBkaWZmRGF0ZXMoXG4gICAgZGF0ZTAsIGRhdGUxLFxuICAgIGRhdGVFbnYsXG4gICAgaGl0MC5sYXJnZVVuaXQsXG4gIClcblxuICBpZiAoaXNGcm9tU3RhcnQpIHtcbiAgICBpZiAoZGF0ZUVudi5hZGQoaW5zdGFuY2VSYW5nZS5zdGFydCwgZGVsdGEpIDwgaW5zdGFuY2VSYW5nZS5lbmQpIHtcbiAgICAgIHJldHVybiB7IHN0YXJ0RGVsdGE6IGRlbHRhIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0ZUVudi5hZGQoaW5zdGFuY2VSYW5nZS5lbmQsIGRlbHRhKSA+IGluc3RhbmNlUmFuZ2Uuc3RhcnQpIHtcbiAgICByZXR1cm4geyBlbmREZWx0YTogZGVsdGEgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiIsImltcG9ydCB7XG4gIERhdGVTZWxlY3Rpb25BcGksXG4gIFBvaW50ZXJEcmFnRXZlbnQsXG4gIGVsZW1lbnRDbG9zZXN0LFxuICBDYWxlbmRhckNvbnRleHQsXG4gIGdldEV2ZW50VGFyZ2V0VmlhUm9vdCxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBQb2ludGVyRHJhZ2dpbmcgfSBmcm9tICcuLi9kbmQvUG9pbnRlckRyYWdnaW5nJ1xuaW1wb3J0IHsgRXZlbnREcmFnZ2luZyB9IGZyb20gJy4vRXZlbnREcmFnZ2luZydcblxuZXhwb3J0IGNsYXNzIFVuc2VsZWN0QXV0byB7XG4gIGRvY3VtZW50UG9pbnRlcjogUG9pbnRlckRyYWdnaW5nIC8vIGZvciB1bmZvY3VzaW5nXG4gIGlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgPSBmYWxzZSAvLyB3aXNoIHdlIGNvdWxkIHVzZSBhIHNlbGVjdG9yIHRvIGRldGVjdCBkYXRlIHNlbGVjdGlvbiwgYnV0IHVzZXMgaGl0IHN5c3RlbVxuICBtYXRjaGVzQ2FuY2VsID0gZmFsc2VcbiAgbWF0Y2hlc0V2ZW50ID0gZmFsc2VcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICAgIGxldCBkb2N1bWVudFBvaW50ZXIgPSB0aGlzLmRvY3VtZW50UG9pbnRlciA9IG5ldyBQb2ludGVyRHJhZ2dpbmcoZG9jdW1lbnQpXG4gICAgZG9jdW1lbnRQb2ludGVyLnNob3VsZElnbm9yZU1vdmUgPSB0cnVlXG4gICAgZG9jdW1lbnRQb2ludGVyLnNob3VsZFdhdGNoU2Nyb2xsID0gZmFsc2VcbiAgICBkb2N1bWVudFBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLm9uRG9jdW1lbnRQb2ludGVyRG93bilcbiAgICBkb2N1bWVudFBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwKVxuXG4gICAgLypcbiAgICBUT0RPOiBiZXR0ZXIgd2F5IHRvIGtub3cgYWJvdXQgd2hldGhlciB0aGVyZSB3YXMgYSBzZWxlY3Rpb24gd2l0aCB0aGUgcG9pbnRlclxuICAgICovXG4gICAgY29udGV4dC5lbWl0dGVyLm9uKCdzZWxlY3QnLCB0aGlzLm9uU2VsZWN0KVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNvbnRleHQuZW1pdHRlci5vZmYoJ3NlbGVjdCcsIHRoaXMub25TZWxlY3QpXG4gICAgdGhpcy5kb2N1bWVudFBvaW50ZXIuZGVzdHJveSgpXG4gIH1cblxuICBvblNlbGVjdCA9IChzZWxlY3RJbmZvOiBEYXRlU2VsZWN0aW9uQXBpKSA9PiB7XG4gICAgaWYgKHNlbGVjdEluZm8uanNFdmVudCkge1xuICAgICAgdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIG9uRG9jdW1lbnRQb2ludGVyRG93biA9IChwZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBsZXQgdW5zZWxlY3RDYW5jZWwgPSB0aGlzLmNvbnRleHQub3B0aW9ucy51bnNlbGVjdENhbmNlbFxuICAgIGxldCBkb3duRWwgPSBnZXRFdmVudFRhcmdldFZpYVJvb3QocGV2Lm9yaWdFdmVudCkgYXMgSFRNTEVsZW1lbnRcblxuICAgIHRoaXMubWF0Y2hlc0NhbmNlbCA9ICEhZWxlbWVudENsb3Nlc3QoZG93bkVsLCB1bnNlbGVjdENhbmNlbClcbiAgICB0aGlzLm1hdGNoZXNFdmVudCA9ICEhZWxlbWVudENsb3Nlc3QoZG93bkVsLCBFdmVudERyYWdnaW5nLlNFTEVDVE9SKSAvLyBpbnRlcmFjdGlvbiBzdGFydGVkIG9uIGFuIGV2ZW50P1xuICB9XG5cbiAgb25Eb2N1bWVudFBvaW50ZXJVcCA9IChwZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgZG9jdW1lbnRQb2ludGVyIH0gPSB0aGlzXG4gICAgbGV0IGNhbGVuZGFyU3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKClcblxuICAgIC8vIHRvdWNoLXNjcm9sbGluZyBzaG91bGQgbmV2ZXIgdW5mb2N1cyBhbnkgdHlwZSBvZiBzZWxlY3Rpb25cbiAgICBpZiAoIWRvY3VtZW50UG9pbnRlci53YXNUb3VjaFNjcm9sbCkge1xuICAgICAgaWYgKFxuICAgICAgICBjYWxlbmRhclN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgLy8gYW4gZXhpc3RpbmcgZGF0ZSBzZWxlY3Rpb24/XG4gICAgICAgICF0aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgLy8gYSBuZXcgcG9pbnRlci1pbml0aWF0ZWQgZGF0ZSBzZWxlY3Rpb24gc2luY2UgbGFzdCBvbkRvY3VtZW50UG9pbnRlclVwP1xuICAgICAgKSB7XG4gICAgICAgIGxldCB1bnNlbGVjdEF1dG8gPSBjb250ZXh0Lm9wdGlvbnMudW5zZWxlY3RBdXRvXG5cbiAgICAgICAgaWYgKHVuc2VsZWN0QXV0byAmJiAoIXVuc2VsZWN0QXV0byB8fCAhdGhpcy5tYXRjaGVzQ2FuY2VsKSkge1xuICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QocGV2KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgY2FsZW5kYXJTdGF0ZS5ldmVudFNlbGVjdGlvbiAmJiAvLyBhbiBleGlzdGluZyBldmVudCBzZWxlY3RlZD9cbiAgICAgICAgIXRoaXMubWF0Y2hlc0V2ZW50IC8vIGludGVyYWN0aW9uIERJRE4nVCBzdGFydCBvbiBhbiBldmVudFxuICAgICAgKSB7XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfRVZFTlQnIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gZmFsc2VcbiAgfVxufVxuIiwiaW1wb3J0IHsgaWRlbnRpdHksIElkZW50aXR5LCBFdmVudERyb3BBcmcgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcblxuLy8gcHVibGljXG5pbXBvcnQge1xuICBEYXRlQ2xpY2tBcmcsXG4gIEV2ZW50RHJhZ1N0YXJ0QXJnLCBFdmVudERyYWdTdG9wQXJnLFxuICBFdmVudFJlc2l6ZVN0YXJ0QXJnLCBFdmVudFJlc2l6ZVN0b3BBcmcsIEV2ZW50UmVzaXplRG9uZUFyZyxcbiAgRHJvcEFyZywgRXZlbnRSZWNlaXZlQXJnLCBFdmVudExlYXZlQXJnLFxufSBmcm9tICcuL2FwaS10eXBlLWRlcHMnXG5cbmV4cG9ydCBjb25zdCBPUFRJT05fUkVGSU5FUlMgPSB7XG4gIGZpeGVkTWlycm9yUGFyZW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxIVE1MRWxlbWVudD4sXG59XG5cbmV4cG9ydCBjb25zdCBMSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgZGF0ZUNsaWNrOiBpZGVudGl0eSBhcyBJZGVudGl0eTwoYXJnOiBEYXRlQ2xpY2tBcmcpID0+IHZvaWQ+LFxuICBldmVudERyYWdTdGFydDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnREcmFnU3RhcnRBcmcpID0+IHZvaWQ+LFxuICBldmVudERyYWdTdG9wOiBpZGVudGl0eSBhcyBJZGVudGl0eTwoYXJnOiBFdmVudERyYWdTdG9wQXJnKSA9PiB2b2lkPixcbiAgZXZlbnREcm9wOiBpZGVudGl0eSBhcyBJZGVudGl0eTwoYXJnOiBFdmVudERyb3BBcmcpID0+IHZvaWQ+LFxuICBldmVudFJlc2l6ZVN0YXJ0OiBpZGVudGl0eSBhcyBJZGVudGl0eTwoYXJnOiBFdmVudFJlc2l6ZVN0YXJ0QXJnKSA9PiB2b2lkPixcbiAgZXZlbnRSZXNpemVTdG9wOiBpZGVudGl0eSBhcyBJZGVudGl0eTwoYXJnOiBFdmVudFJlc2l6ZVN0b3BBcmcpID0+IHZvaWQ+LFxuICBldmVudFJlc2l6ZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnRSZXNpemVEb25lQXJnKSA9PiB2b2lkPixcbiAgZHJvcDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRHJvcEFyZykgPT4gdm9pZD4sXG4gIGV2ZW50UmVjZWl2ZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnRSZWNlaXZlQXJnKSA9PiB2b2lkPixcbiAgZXZlbnRMZWF2ZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnRMZWF2ZUFyZykgPT4gdm9pZD4sXG59XG4iLCJpbXBvcnQge1xuICBIaXQsXG4gIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSxcbiAgUG9pbnRlckRyYWdFdmVudCxcbiAgcGFyc2VFdmVudERlZiwgY3JlYXRlRXZlbnRJbnN0YW5jZSwgRXZlbnRUdXBsZSxcbiAgY3JlYXRlRW1wdHlFdmVudFN0b3JlLCBldmVudFR1cGxlVG9TdG9yZSxcbiAgY29uZmlnLFxuICBEYXRlU3BhbiwgRGF0ZVBvaW50QXBpLFxuICBFdmVudEludGVyYWN0aW9uU3RhdGUsXG4gIERyYWdNZXRhSW5wdXQsIERyYWdNZXRhLCBwYXJzZURyYWdNZXRhLFxuICBFdmVudEFwaSxcbiAgZWxlbWVudE1hdGNoZXMsXG4gIGVuYWJsZUN1cnNvciwgZGlzYWJsZUN1cnNvcixcbiAgaXNJbnRlcmFjdGlvblZhbGlkLFxuICBFbGVtZW50RHJhZ2dpbmcsXG4gIFZpZXdBcGksXG4gIENhbGVuZGFyQ29udGV4dCxcbiAgZ2V0RGVmYXVsdEV2ZW50RW5kLFxuICByZWZpbmVFdmVudERlZixcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJ1xuaW1wb3J0IHsgSGl0RHJhZ2dpbmcgfSBmcm9tICcuLi9pbnRlcmFjdGlvbnMvSGl0RHJhZ2dpbmcnXG5pbXBvcnQgeyBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0IH0gZnJvbSAnLi4vdXRpbHMnXG5cbmV4cG9ydCB0eXBlIERyYWdNZXRhR2VuZXJhdG9yID0gRHJhZ01ldGFJbnB1dCB8ICgoZWw6IEhUTUxFbGVtZW50KSA9PiBEcmFnTWV0YUlucHV0KVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVybmFsRHJvcEFwaSBleHRlbmRzIERhdGVQb2ludEFwaSB7XG4gIGRyYWdnZWRFbDogSFRNTEVsZW1lbnRcbiAganNFdmVudDogVUlFdmVudFxuICB2aWV3OiBWaWV3QXBpXG59XG5cbi8qXG5HaXZlbiBhbiBhbHJlYWR5IGluc3RhbnRpYXRlZCBkcmFnZ2FibGUgb2JqZWN0IGZvciBvbmUtb3ItbW9yZSBlbGVtZW50cyxcbkludGVycHJldHMgYW55IGRyYWdnaW5nIGFzIGFuIGF0dGVtcHQgdG8gZHJhZyBhbiBldmVudHMgdGhhdCBsaXZlcyBvdXRzaWRlXG5vZiBhIGNhbGVuZGFyIG9udG8gYSBjYWxlbmRhci5cbiovXG5leHBvcnQgY2xhc3MgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcge1xuICBoaXREcmFnZ2luZzogSGl0RHJhZ2dpbmdcbiAgcmVjZWl2aW5nQ29udGV4dDogQ2FsZW5kYXJDb250ZXh0IHwgbnVsbCA9IG51bGxcbiAgZHJvcHBhYmxlRXZlbnQ6IEV2ZW50VHVwbGUgfCBudWxsID0gbnVsbCAvLyB3aWxsIGV4aXN0IGZvciBhbGwgZHJhZ3MsIGV2ZW4gaWYgY3JlYXRlOmZhbHNlXG4gIHN1cHBsaWVkRHJhZ01ldGE6IERyYWdNZXRhR2VuZXJhdG9yIHwgbnVsbCA9IG51bGxcbiAgZHJhZ01ldGE6IERyYWdNZXRhIHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcihkcmFnZ2luZzogRWxlbWVudERyYWdnaW5nLCBzdXBwbGllZERyYWdNZXRhPzogRHJhZ01ldGFHZW5lcmF0b3IpIHtcbiAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKGRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUpXG4gICAgaGl0RHJhZ2dpbmcucmVxdWlyZUluaXRpYWwgPSBmYWxzZSAvLyB3aWxsIHN0YXJ0IG91dHNpZGUgb2YgYSBjb21wb25lbnRcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydClcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSlcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKVxuXG4gICAgdGhpcy5zdXBwbGllZERyYWdNZXRhID0gc3VwcGxpZWREcmFnTWV0YVxuICB9XG5cbiAgaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgdGhpcy5kcmFnTWV0YSA9IHRoaXMuYnVpbGREcmFnTWV0YShldi5zdWJqZWN0RWwgYXMgSFRNTEVsZW1lbnQpXG4gIH1cblxuICBidWlsZERyYWdNZXRhKHN1YmplY3RFbDogSFRNTEVsZW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBwYXJzZURyYWdNZXRhKHRoaXMuc3VwcGxpZWREcmFnTWV0YSlcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBwYXJzZURyYWdNZXRhKHRoaXMuc3VwcGxpZWREcmFnTWV0YShzdWJqZWN0RWwpKVxuICAgIH1cbiAgICByZXR1cm4gZ2V0RHJhZ01ldGFGcm9tRWwoc3ViamVjdEVsKVxuICB9XG5cbiAgaGFuZGxlSGl0VXBkYXRlID0gKGhpdDogSGl0IHwgbnVsbCwgaXNGaW5hbDogYm9vbGVhbiwgZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBsZXQgeyBkcmFnZ2luZyB9ID0gdGhpcy5oaXREcmFnZ2luZ1xuICAgIGxldCByZWNlaXZpbmdDb250ZXh0OiBDYWxlbmRhckNvbnRleHQgfCBudWxsID0gbnVsbFxuICAgIGxldCBkcm9wcGFibGVFdmVudDogRXZlbnRUdXBsZSB8IG51bGwgPSBudWxsXG4gICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlXG4gICAgbGV0IGludGVyYWN0aW9uOiBFdmVudEludGVyYWN0aW9uU3RhdGUgPSB7XG4gICAgICBhZmZlY3RlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgIGlzRXZlbnQ6IHRoaXMuZHJhZ01ldGEhLmNyZWF0ZSxcbiAgICB9XG5cbiAgICBpZiAoaGl0KSB7XG4gICAgICByZWNlaXZpbmdDb250ZXh0ID0gaGl0LmNvbnRleHRcblxuICAgICAgaWYgKHRoaXMuY2FuRHJvcEVsT25DYWxlbmRhcihldi5zdWJqZWN0RWwgYXMgSFRNTEVsZW1lbnQsIHJlY2VpdmluZ0NvbnRleHQpKSB7XG4gICAgICAgIGRyb3BwYWJsZUV2ZW50ID0gY29tcHV0ZUV2ZW50Rm9yRGF0ZVNwYW4oXG4gICAgICAgICAgaGl0LmRhdGVTcGFuLFxuICAgICAgICAgIHRoaXMuZHJhZ01ldGEhLFxuICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gZXZlbnRUdXBsZVRvU3RvcmUoZHJvcHBhYmxlRXZlbnQpXG4gICAgICAgIGlzSW52YWxpZCA9ICFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgcmVjZWl2aW5nQ29udGV4dClcblxuICAgICAgICBpZiAoaXNJbnZhbGlkKSB7XG4gICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpXG4gICAgICAgICAgZHJvcHBhYmxlRXZlbnQgPSBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpc3BsYXlEcmFnKHJlY2VpdmluZ0NvbnRleHQsIGludGVyYWN0aW9uKVxuXG4gICAgLy8gc2hvdyBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3IgZWxlbWVudCBPUiBpZiB3ZSBhcmUgc2h1dHRpbmcgZG93biB0aGUgbWlycm9yICg/KVxuICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgc29tZWhvdyB3YWl0IGZvciBkaXNwYXRjaCB0byBndWFyYW50ZWUgcmVuZGVyXG4gICAgZHJhZ2dpbmcuc2V0TWlycm9ySXNWaXNpYmxlKFxuICAgICAgaXNGaW5hbCB8fCAhZHJvcHBhYmxlRXZlbnQgfHwgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mYy1ldmVudC1taXJyb3InKSwgLy8gVE9ETzogdHVybiBjbGFzc05hbWUgaW50byBjb25zdGFudFxuICAgICAgLy8gVE9ETzogc29tZWhvdyBxdWVyeSBGdWxsQ2FsZW5kYXJzIFdJVEhJTiBzaGFkb3ctcm9vdHMgZm9yIGV4aXN0aW5nIGV2ZW50LW1pcnJvciBlbHNcbiAgICApXG5cbiAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgZW5hYmxlQ3Vyc29yKClcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzYWJsZUN1cnNvcigpXG4gICAgfVxuXG4gICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICBkcmFnZ2luZy5zZXRNaXJyb3JOZWVkc1JldmVydCghZHJvcHBhYmxlRXZlbnQpXG5cbiAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IHJlY2VpdmluZ0NvbnRleHRcbiAgICAgIHRoaXMuZHJvcHBhYmxlRXZlbnQgPSBkcm9wcGFibGVFdmVudFxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZURyYWdFbmQgPSAocGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgbGV0IHsgcmVjZWl2aW5nQ29udGV4dCwgZHJvcHBhYmxlRXZlbnQgfSA9IHRoaXNcblxuICAgIHRoaXMuY2xlYXJEcmFnKClcblxuICAgIGlmIChyZWNlaXZpbmdDb250ZXh0ICYmIGRyb3BwYWJsZUV2ZW50KSB7XG4gICAgICBsZXQgZmluYWxIaXQgPSB0aGlzLmhpdERyYWdnaW5nLmZpbmFsSGl0IVxuICAgICAgbGV0IGZpbmFsVmlldyA9IGZpbmFsSGl0LmNvbnRleHQudmlld0FwaVxuICAgICAgbGV0IGRyYWdNZXRhID0gdGhpcy5kcmFnTWV0YSFcblxuICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2Ryb3AnLCB7XG4gICAgICAgIC4uLmJ1aWxkRGF0ZVBvaW50QXBpV2l0aENvbnRleHQoZmluYWxIaXQuZGF0ZVNwYW4sIHJlY2VpdmluZ0NvbnRleHQpLFxuICAgICAgICBkcmFnZ2VkRWw6IHBldi5zdWJqZWN0RWwgYXMgSFRNTEVsZW1lbnQsXG4gICAgICAgIGpzRXZlbnQ6IHBldi5vcmlnRXZlbnQgYXMgTW91c2VFdmVudCwgLy8gSXMgdGhpcyBhbHdheXMgYSBtb3VzZSBldmVudD8gU2VlICM0NjU1XG4gICAgICAgIHZpZXc6IGZpbmFsVmlldyxcbiAgICAgIH0pXG5cbiAgICAgIGlmIChkcmFnTWV0YS5jcmVhdGUpIHtcbiAgICAgICAgbGV0IGFkZGluZ0V2ZW50cyA9IGV2ZW50VHVwbGVUb1N0b3JlKGRyb3BwYWJsZUV2ZW50KVxuXG4gICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgIGV2ZW50U3RvcmU6IGFkZGluZ0V2ZW50cyxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAocGV2LmlzVG91Y2gpIHtcbiAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUlkOiBkcm9wcGFibGVFdmVudC5pbnN0YW5jZS5pbnN0YW5jZUlkLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaWduYWwgdGhhdCBhbiBleHRlcm5hbCBldmVudCBsYW5kZWRcbiAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVjZWl2ZScsIHtcbiAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKFxuICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCxcbiAgICAgICAgICAgIGRyb3BwYWJsZUV2ZW50LmRlZixcbiAgICAgICAgICAgIGRyb3BwYWJsZUV2ZW50Lmluc3RhbmNlLFxuICAgICAgICAgICksXG4gICAgICAgICAgcmVsYXRlZEV2ZW50czogW10sXG4gICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYWRkaW5nRXZlbnRzLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRyYWdnZWRFbDogcGV2LnN1YmplY3RFbCBhcyBIVE1MRWxlbWVudCxcbiAgICAgICAgICB2aWV3OiBmaW5hbFZpZXcsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbFxuICAgIHRoaXMuZHJvcHBhYmxlRXZlbnQgPSBudWxsXG4gIH1cblxuICBkaXNwbGF5RHJhZyhuZXh0Q29udGV4dDogQ2FsZW5kYXJDb250ZXh0IHwgbnVsbCwgc3RhdGU6IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSkge1xuICAgIGxldCBwcmV2Q29udGV4dCA9IHRoaXMucmVjZWl2aW5nQ29udGV4dFxuXG4gICAgaWYgKHByZXZDb250ZXh0ICYmIHByZXZDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuICAgICAgcHJldkNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSlcbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRleHQpIHtcbiAgICAgIG5leHRDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJywgc3RhdGUgfSlcbiAgICB9XG4gIH1cblxuICBjbGVhckRyYWcoKSB7XG4gICAgaWYgKHRoaXMucmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pXG4gICAgfVxuICB9XG5cbiAgY2FuRHJvcEVsT25DYWxlbmRhcihlbDogSFRNTEVsZW1lbnQsIHJlY2VpdmluZ0NvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IGJvb2xlYW4ge1xuICAgIGxldCBkcm9wQWNjZXB0ID0gcmVjZWl2aW5nQ29udGV4dC5vcHRpb25zLmRyb3BBY2NlcHRcblxuICAgIGlmICh0eXBlb2YgZHJvcEFjY2VwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGRyb3BBY2NlcHQuY2FsbChyZWNlaXZpbmdDb250ZXh0LmNhbGVuZGFyQXBpLCBlbClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRyb3BBY2NlcHQgPT09ICdzdHJpbmcnICYmIGRyb3BBY2NlcHQpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKGVsZW1lbnRNYXRjaGVzKGVsLCBkcm9wQWNjZXB0KSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbi8vIFV0aWxzIGZvciBjb21wdXRpbmcgZXZlbnQgc3RvcmUgZnJvbSB0aGUgRHJhZ01ldGFcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gY29tcHV0ZUV2ZW50Rm9yRGF0ZVNwYW4oZGF0ZVNwYW46IERhdGVTcGFuLCBkcmFnTWV0YTogRHJhZ01ldGEsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IEV2ZW50VHVwbGUge1xuICBsZXQgZGVmUHJvcHMgPSB7IC4uLmRyYWdNZXRhLmxlZnRvdmVyUHJvcHMgfVxuXG4gIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmV4dGVybmFsRGVmVHJhbnNmb3Jtcykge1xuICAgIF9fYXNzaWduKGRlZlByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGRyYWdNZXRhKSlcbiAgfVxuXG4gIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVFdmVudERlZihkZWZQcm9wcywgY29udGV4dClcbiAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYoXG4gICAgcmVmaW5lZCxcbiAgICBleHRyYSxcbiAgICBkcmFnTWV0YS5zb3VyY2VJZCxcbiAgICBkYXRlU3Bhbi5hbGxEYXksXG4gICAgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbiB8fCBCb29sZWFuKGRyYWdNZXRhLmR1cmF0aW9uKSwgLy8gaGFzRW5kXG4gICAgY29udGV4dCxcbiAgKVxuXG4gIGxldCBzdGFydCA9IGRhdGVTcGFuLnJhbmdlLnN0YXJ0XG5cbiAgLy8gb25seSByZWx5IG9uIHRpbWUgaW5mbyBpZiBkcm9wIHpvbmUgaXMgYWxsLWRheSxcbiAgLy8gb3RoZXJ3aXNlLCB3ZSBhbHJlYWR5IGtub3cgdGhlIHRpbWVcbiAgaWYgKGRhdGVTcGFuLmFsbERheSAmJiBkcmFnTWV0YS5zdGFydFRpbWUpIHtcbiAgICBzdGFydCA9IGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnQsIGRyYWdNZXRhLnN0YXJ0VGltZSlcbiAgfVxuXG4gIGxldCBlbmQgPSBkcmFnTWV0YS5kdXJhdGlvbiA/XG4gICAgY29udGV4dC5kYXRlRW52LmFkZChzdGFydCwgZHJhZ01ldGEuZHVyYXRpb24pIDpcbiAgICBnZXREZWZhdWx0RXZlbnRFbmQoZGF0ZVNwYW4uYWxsRGF5LCBzdGFydCwgY29udGV4dClcblxuICBsZXQgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgeyBzdGFydCwgZW5kIH0pXG5cbiAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZSB9XG59XG5cbi8vIFV0aWxzIGZvciBleHRyYWN0aW5nIGRhdGEgZnJvbSBlbGVtZW50XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGdldERyYWdNZXRhRnJvbUVsKGVsOiBIVE1MRWxlbWVudCk6IERyYWdNZXRhIHtcbiAgbGV0IHN0ciA9IGdldEVtYmVkZGVkRWxEYXRhKGVsLCAnZXZlbnQnKVxuICBsZXQgb2JqID0gc3RyID9cbiAgICBKU09OLnBhcnNlKHN0cikgOlxuICAgIHsgY3JlYXRlOiBmYWxzZSB9IC8vIGlmIG5vIGVtYmVkZGVkIGRhdGEsIGFzc3VtZSBubyBldmVudCBjcmVhdGlvblxuXG4gIHJldHVybiBwYXJzZURyYWdNZXRhKG9iailcbn1cblxuY29uZmlnLmRhdGFBdHRyUHJlZml4ID0gJydcblxuZnVuY3Rpb24gZ2V0RW1iZWRkZWRFbERhdGEoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgcHJlZml4ID0gY29uZmlnLmRhdGFBdHRyUHJlZml4XG4gIGxldCBwcmVmaXhlZE5hbWUgPSAocHJlZml4ID8gcHJlZml4ICsgJy0nIDogJycpICsgbmFtZVxuXG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIHByZWZpeGVkTmFtZSkgfHwgJydcbn1cbiIsImltcG9ydCB7IEJBU0VfT1BUSU9OX0RFRkFVTFRTLCBQb2ludGVyRHJhZ0V2ZW50IH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nIH0gZnJvbSAnLi4vZG5kL0ZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcnXG5pbXBvcnQgeyBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZywgRHJhZ01ldGFHZW5lcmF0b3IgfSBmcm9tICcuL0V4dGVybmFsRWxlbWVudERyYWdnaW5nJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVybmFsRHJhZ2dhYmxlU2V0dGluZ3Mge1xuICBldmVudERhdGE/OiBEcmFnTWV0YUdlbmVyYXRvclxuICBpdGVtU2VsZWN0b3I/OiBzdHJpbmdcbiAgbWluRGlzdGFuY2U/OiBudW1iZXJcbiAgbG9uZ1ByZXNzRGVsYXk/OiBudW1iZXJcbiAgYXBwZW5kVG8/OiBIVE1MRWxlbWVudFxufVxuXG4vKlxuTWFrZXMgYW4gZWxlbWVudCAodGhhdCBpcyAqZXh0ZXJuYWwqIHRvIGFueSBjYWxlbmRhcikgZHJhZ2dhYmxlLlxuQ2FuIHBhc3MgaW4gZGF0YSB0aGF0IGRldGVybWluZXMgaG93IGFuIGV2ZW50IHdpbGwgYmUgY3JlYXRlZCB3aGVuIGRyb3BwZWQgb250byBhIGNhbGVuZGFyLlxuTGV2ZXJhZ2VzIEZ1bGxDYWxlbmRhcidzIGludGVybmFsIGRyYWctbi1kcm9wIGZ1bmN0aW9uYWxpdHkgV0lUSE9VVCBhIHRoaXJkLXBhcnR5IGRyYWcgc3lzdGVtLlxuKi9cbmV4cG9ydCBjbGFzcyBFeHRlcm5hbERyYWdnYWJsZSB7XG4gIGRyYWdnaW5nOiBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nXG4gIHNldHRpbmdzOiBFeHRlcm5hbERyYWdnYWJsZVNldHRpbmdzXG5cbiAgY29uc3RydWN0b3IoZWw6IEhUTUxFbGVtZW50LCBzZXR0aW5nczogRXh0ZXJuYWxEcmFnZ2FibGVTZXR0aW5ncyA9IHt9KSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzXG5cbiAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoZWwpXG4gICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2VcblxuICAgIGlmIChzZXR0aW5ncy5pdGVtU2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IHNldHRpbmdzLml0ZW1TZWxlY3RvclxuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncy5hcHBlbmRUbyAhPSBudWxsKSB7XG4gICAgICBkcmFnZ2luZy5taXJyb3IucGFyZW50Tm9kZSA9IHNldHRpbmdzLmFwcGVuZFRvIC8vIFRPRE86IHdyaXRlIHRlc3RzXG4gICAgfVxuXG4gICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKVxuICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KVxuXG4gICAgbmV3IEV4dGVybmFsRWxlbWVudERyYWdnaW5nKGRyYWdnaW5nLCBzZXR0aW5ncy5ldmVudERhdGEpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH1cblxuICBoYW5kbGVQb2ludGVyRG93biA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzXG4gICAgbGV0IHsgbWluRGlzdGFuY2UsIGxvbmdQcmVzc0RlbGF5IH0gPSB0aGlzLnNldHRpbmdzXG5cbiAgICBkcmFnZ2luZy5taW5EaXN0YW5jZSA9XG4gICAgICBtaW5EaXN0YW5jZSAhPSBudWxsID9cbiAgICAgICAgbWluRGlzdGFuY2UgOlxuICAgICAgICAoZXYuaXNUb3VjaCA/IDAgOiBCQVNFX09QVElPTl9ERUZBVUxUUy5ldmVudERyYWdNaW5EaXN0YW5jZSlcblxuICAgIGRyYWdnaW5nLmRlbGF5ID1cbiAgICAgIGV2LmlzVG91Y2ggPyAvLyBUT0RPOiBldmVudHVhbGx5IHJlYWQgZXZlbnRMb25nUHJlc3NEZWxheSBpbnN0ZWFkIHZ2dlxuICAgICAgICAobG9uZ1ByZXNzRGVsYXkgIT0gbnVsbCA/IGxvbmdQcmVzc0RlbGF5IDogQkFTRV9PUFRJT05fREVGQVVMVFMubG9uZ1ByZXNzRGVsYXkpIDpcbiAgICAgICAgMFxuICB9XG5cbiAgaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgaWYgKFxuICAgICAgZXYuaXNUb3VjaCAmJlxuICAgICAgdGhpcy5kcmFnZ2luZy5kZWxheSAmJlxuICAgICAgKGV2LnN1YmplY3RFbCBhcyBIVE1MRWxlbWVudCkuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1ldmVudCcpXG4gICAgKSB7XG4gICAgICB0aGlzLmRyYWdnaW5nLm1pcnJvci5nZXRNaXJyb3JFbCgpLmNsYXNzTGlzdC5hZGQoJ2ZjLWV2ZW50LXNlbGVjdGVkJylcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpXG4gIH1cbn1cbiIsImltcG9ydCB7IFBvaW50ZXJEcmFnRXZlbnQsIEVsZW1lbnREcmFnZ2luZyB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgUG9pbnRlckRyYWdnaW5nIH0gZnJvbSAnLi4vZG5kL1BvaW50ZXJEcmFnZ2luZydcblxuLypcbkRldGVjdHMgd2hlbiBhICpUSElSRC1QQVJUWSogZHJhZy1uLWRyb3Agc3lzdGVtIGludGVyYWN0cyB3aXRoIGVsZW1lbnRzLlxuVGhlIHRoaXJkLXBhcnR5IHN5c3RlbSBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyB0aGUgdmlzdWFscyBlZmZlY3RzIG9mIHRoZSBkcmFnLlxuVGhpcyBjbGFzcyBzaW1wbHkgbW9uaXRvcnMgZm9yIHBvaW50ZXIgbW92ZW1lbnRzIGFuZCBmaXJlcyBldmVudHMuXG5JdCBhbHNvIGhhcyB0aGUgYWJpbGl0eSB0byBoaWRlIHRoZSBtb3ZpbmcgZWxlbWVudCAodGhlIFwibWlycm9yXCIpIGR1cmluZyB0aGUgZHJhZy5cbiovXG5leHBvcnQgY2xhc3MgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcgZXh0ZW5kcyBFbGVtZW50RHJhZ2dpbmcge1xuICBwb2ludGVyOiBQb2ludGVyRHJhZ2dpbmdcbiAgc2hvdWxkSWdub3JlTW92ZTogYm9vbGVhbiA9IGZhbHNlXG4gIG1pcnJvclNlbGVjdG9yOiBzdHJpbmcgPSAnJ1xuICBjdXJyZW50TWlycm9yRWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJFbDogSFRNTEVsZW1lbnQpIHtcbiAgICBzdXBlcihjb250YWluZXJFbClcblxuICAgIGxldCBwb2ludGVyID0gdGhpcy5wb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbClcbiAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bilcbiAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJtb3ZlJywgdGhpcy5oYW5kbGVQb2ludGVyTW92ZSlcbiAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBvaW50ZXIuZGVzdHJveSgpXG4gIH1cblxuICBoYW5kbGVQb2ludGVyRG93biA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KVxuXG4gICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgIC8vIGZpcmUgZHJhZ3N0YXJ0IHJpZ2h0IGF3YXkuIGRvZXMgbm90IHN1cHBvcnQgZGVsYXkgb3IgbWluLWRpc3RhbmNlXG4gICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlUG9pbnRlck1vdmUgPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlUG9pbnRlclVwID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KVxuXG4gICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgIC8vIGZpcmUgZHJhZ2VuZCByaWdodCBhd2F5LiBkb2VzIG5vdCBzdXBwb3J0IGEgcmV2ZXJ0IGFuaW1hdGlvblxuICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldilcbiAgICB9XG4gIH1cblxuICBzZXRJZ25vcmVNb3ZlKGJvb2w6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBib29sXG4gIH1cblxuICBzZXRNaXJyb3JJc1Zpc2libGUoYm9vbDogYm9vbGVhbikge1xuICAgIGlmIChib29sKSB7XG4gICAgICAvLyByZXN0b3JlIGEgcHJldmlvdXNseSBoaWRkZW4gZWxlbWVudC5cbiAgICAgIC8vIHVzZSB0aGUgcmVmZXJlbmNlIGluIGNhc2UgdGhlIHNlbGVjdG9yIGNsYXNzIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRNaXJyb3JFbCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbC5zdHlsZS52aXNpYmlsaXR5ID0gJydcbiAgICAgICAgdGhpcy5jdXJyZW50TWlycm9yRWwgPSBudWxsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtaXJyb3JFbCA9IHRoaXMubWlycm9yU2VsZWN0b3JcbiAgICAgICAgLy8gVE9ETzogc29tZWhvdyBxdWVyeSBGdWxsQ2FsZW5kYXJzIFdJVEhJTiBzaGFkb3ctcm9vdHNcbiAgICAgICAgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMubWlycm9yU2VsZWN0b3IpIGFzIEhUTUxFbGVtZW50XG4gICAgICAgIDogbnVsbFxuXG4gICAgICBpZiAobWlycm9yRWwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TWlycm9yRWwgPSBtaXJyb3JFbFxuICAgICAgICBtaXJyb3JFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IEV4dGVybmFsRWxlbWVudERyYWdnaW5nLCBEcmFnTWV0YUdlbmVyYXRvciB9IGZyb20gJy4vRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcnXG5pbXBvcnQgeyBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyB9IGZyb20gJy4vSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhpcmRQYXJ0eURyYWdnYWJsZVNldHRpbmdzIHtcbiAgZXZlbnREYXRhPzogRHJhZ01ldGFHZW5lcmF0b3JcbiAgaXRlbVNlbGVjdG9yPzogc3RyaW5nXG4gIG1pcnJvclNlbGVjdG9yPzogc3RyaW5nXG59XG5cbi8qXG5CcmlkZ2VzIHRoaXJkLXBhcnR5IGRyYWctbi1kcm9wIHN5c3RlbXMgd2l0aCBGdWxsQ2FsZW5kYXIuXG5NdXN0IGJlIGluc3RhbnRpYXRlZCBhbmQgZGVzdHJveWVkIGJ5IGNhbGxlci5cbiovXG5leHBvcnQgY2xhc3MgVGhpcmRQYXJ0eURyYWdnYWJsZSB7XG4gIGRyYWdnaW5nOiBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZ1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNvbnRhaW5lck9yU2V0dGluZ3M/OiBFdmVudFRhcmdldCB8IFRoaXJkUGFydHlEcmFnZ2FibGVTZXR0aW5ncyxcbiAgICBzZXR0aW5ncz86IFRoaXJkUGFydHlEcmFnZ2FibGVTZXR0aW5ncyxcbiAgKSB7XG4gICAgbGV0IGNvbnRhaW5lckVsOiBFdmVudFRhcmdldCA9IGRvY3VtZW50XG5cbiAgICBpZiAoXG4gICAgICAvLyB3aXNoIHdlIGNvdWxkIGp1c3QgdGVzdCBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0LCBidXQgZG9lc24ndCB3b3JrIGluIElFMTFcbiAgICAgIGNvbnRhaW5lck9yU2V0dGluZ3MgPT09IGRvY3VtZW50IHx8XG4gICAgICBjb250YWluZXJPclNldHRpbmdzIGluc3RhbmNlb2YgRWxlbWVudFxuICAgICkge1xuICAgICAgY29udGFpbmVyRWwgPSBjb250YWluZXJPclNldHRpbmdzIGFzIEV2ZW50VGFyZ2V0XG4gICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldHRpbmdzID0gKGNvbnRhaW5lck9yU2V0dGluZ3MgfHwge30pIGFzIFRoaXJkUGFydHlEcmFnZ2FibGVTZXR0aW5nc1xuICAgIH1cblxuICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcoY29udGFpbmVyRWwgYXMgSFRNTEVsZW1lbnQpXG5cbiAgICBpZiAodHlwZW9mIHNldHRpbmdzLml0ZW1TZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3JcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5lckVsID09PSBkb2N1bWVudCkge1xuICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9ICdbZGF0YS1ldmVudF0nXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5taXJyb3JTZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRyYWdnaW5nLm1pcnJvclNlbGVjdG9yID0gc2V0dGluZ3MubWlycm9yU2VsZWN0b3JcbiAgICB9XG5cbiAgICBuZXcgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHNldHRpbmdzLmV2ZW50RGF0YSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KClcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBEYXRlQ2xpY2tpbmcgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9EYXRlQ2xpY2tpbmcnXG5pbXBvcnQgeyBEYXRlU2VsZWN0aW5nIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvRGF0ZVNlbGVjdGluZydcbmltcG9ydCB7IEV2ZW50RHJhZ2dpbmcgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9FdmVudERyYWdnaW5nJ1xuaW1wb3J0IHsgRXZlbnRSZXNpemluZyB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL0V2ZW50UmVzaXppbmcnXG5pbXBvcnQgeyBVbnNlbGVjdEF1dG8gfSBmcm9tICcuL2ludGVyYWN0aW9ucy9VbnNlbGVjdEF1dG8nXG5pbXBvcnQgeyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nIH0gZnJvbSAnLi9kbmQvRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZydcbmltcG9ydCB7IE9QVElPTl9SRUZJTkVSUywgTElTVEVORVJfUkVGSU5FUlMgfSBmcm9tICcuL29wdGlvbnMnXG5pbXBvcnQgJy4vb3B0aW9ucy1kZWNsYXJlJ1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVQbHVnaW4oe1xuICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IFtEYXRlQ2xpY2tpbmcsIERhdGVTZWxlY3RpbmcsIEV2ZW50RHJhZ2dpbmcsIEV2ZW50UmVzaXppbmddLFxuICBjYWxlbmRhckludGVyYWN0aW9uczogW1Vuc2VsZWN0QXV0b10sXG4gIGVsZW1lbnREcmFnZ2luZ0ltcGw6IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcsXG4gIG9wdGlvblJlZmluZXJzOiBPUFRJT05fUkVGSU5FUlMsXG4gIGxpc3RlbmVyUmVmaW5lcnM6IExJU1RFTkVSX1JFRklORVJTLFxufSlcblxuZXhwb3J0ICogZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xuZXhwb3J0IHsgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyB9XG5leHBvcnQgeyBQb2ludGVyRHJhZ2dpbmcgfSBmcm9tICcuL2RuZC9Qb2ludGVyRHJhZ2dpbmcnXG5leHBvcnQgeyBFeHRlcm5hbERyYWdnYWJsZSBhcyBEcmFnZ2FibGUgfSBmcm9tICcuL2ludGVyYWN0aW9ucy1leHRlcm5hbC9FeHRlcm5hbERyYWdnYWJsZSdcbmV4cG9ydCB7IFRoaXJkUGFydHlEcmFnZ2FibGUgfSBmcm9tICcuL2ludGVyYWN0aW9ucy1leHRlcm5hbC9UaGlyZFBhcnR5RHJhZ2dhYmxlJ1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/interaction/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/list/main.js":
/*!*************************************************!*\
  !*** ./node_modules/@fullcalendar/list/main.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"ListView\": () => (/* binding */ ListView)\n/* harmony export */ });\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ \"./node_modules/@fullcalendar/list/main.css\");\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/*!\nFullCalendar v5.9.0\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n\n\nvar ListViewHeaderRow = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ListViewHeaderRow, _super);\n\n  function ListViewHeaderRow() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ListViewHeaderRow.prototype.render = function () {\n    var _a = this.props,\n        dayDate = _a.dayDate,\n        todayRange = _a.todayRange;\n    var _b = this.context,\n        theme = _b.theme,\n        dateEnv = _b.dateEnv,\n        options = _b.options,\n        viewApi = _b.viewApi;\n    var dayMeta = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getDateMeta)(dayDate, todayRange); // will ever be falsy?\n\n    var text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : ''; // will ever be falsy? also, BAD NAME \"alt\"\n\n    var sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : '';\n    var navLinkData = options.navLinks ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildNavLinkData)(dayDate) : null;\n\n    var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      date: dateEnv.toDate(dayDate),\n      view: viewApi,\n      text: text,\n      sideText: sideText,\n      navLinkData: navLinkData\n    }, dayMeta);\n\n    var classNames = ['fc-list-day'].concat((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getDayClassNames)(dayMeta, theme)); // TODO: make a reusable HOC for dayHeader (used in daygrid/timegrid too)\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RenderHook, {\n      hookProps: hookProps,\n      classNames: options.dayHeaderClassNames,\n      content: options.dayHeaderContent,\n      defaultContent: renderInnerContent,\n      didMount: options.dayHeaderDidMount,\n      willUnmount: options.dayHeaderWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-date\": (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.formatDayString)(dayDate)\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"th\", {\n        colSpan: 3\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: 'fc-list-day-cushion ' + theme.getClass('tableCellShaded'),\n        ref: innerElRef\n      }, innerContent)));\n    });\n  };\n\n  return ListViewHeaderRow;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n\nfunction renderInnerContent(props) {\n  var navLinkAttrs = props.navLinkData // is there a type for this?\n  ? {\n    'data-navlink': props.navLinkData,\n    tabIndex: 0\n  } : {};\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, props.text && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n    className: \"fc-list-day-text\"\n  }, navLinkAttrs), props.text), props.sideText && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n    className: \"fc-list-day-side-text\"\n  }, navLinkAttrs), props.sideText));\n}\n\nvar DEFAULT_TIME_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: 'short'\n});\n\nvar ListViewEventRow = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ListViewEventRow, _super);\n\n  function ListViewEventRow() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ListViewEventRow.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var seg = props.seg;\n    var timeFormat = context.options.eventTimeFormat || DEFAULT_TIME_FORMAT;\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.EventRoot, {\n      seg: seg,\n      timeText: \"\" // BAD. because of all-day content\n      ,\n      disableDragging: true,\n      disableResizing: true,\n      defaultContent: renderEventInnerContent,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday,\n      isSelected: props.isSelected,\n      isDragging: props.isDragging,\n      isResizing: props.isResizing,\n      isDateSelecting: props.isDateSelecting\n    }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n        className: ['fc-list-event', hookProps.event.url ? 'fc-event-forced-url' : ''].concat(classNames).join(' '),\n        ref: rootElRef\n      }, buildTimeContent(seg, timeFormat, context), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n        className: \"fc-list-event-graphic\"\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n        className: \"fc-list-event-dot\",\n        style: {\n          borderColor: hookProps.borderColor || hookProps.backgroundColor\n        }\n      })), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n        className: \"fc-list-event-title\",\n        ref: innerElRef\n      }, innerContent));\n    });\n  };\n\n  return ListViewEventRow;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n\nfunction renderEventInnerContent(props) {\n  var event = props.event;\n  var url = event.url;\n  var anchorAttrs = url ? {\n    href: url\n  } : {};\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, anchorAttrs), event.title);\n}\n\nfunction buildTimeContent(seg, timeFormat, context) {\n  var options = context.options;\n\n  if (options.displayEventTime !== false) {\n    var eventDef = seg.eventRange.def;\n    var eventInstance = seg.eventRange.instance;\n    var doAllDay = false;\n    var timeText = void 0;\n\n    if (eventDef.allDay) {\n      doAllDay = true;\n    } else if ((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isMultiDayRange)(seg.eventRange.range)) {\n      // TODO: use (!isStart || !isEnd) instead?\n      if (seg.isStart) {\n        timeText = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegTimeText)(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);\n      } else if (seg.isEnd) {\n        timeText = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegTimeText)(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);\n      } else {\n        doAllDay = true;\n      }\n    } else {\n      timeText = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegTimeText)(seg, timeFormat, context);\n    }\n\n    if (doAllDay) {\n      var hookProps = {\n        text: context.options.allDayText,\n        view: context.viewApi\n      };\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RenderHook, {\n        hookProps: hookProps,\n        classNames: options.allDayClassNames,\n        content: options.allDayContent,\n        defaultContent: renderAllDayInner,\n        didMount: options.allDayDidMount,\n        willUnmount: options.allDayWillUnmount\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n          className: ['fc-list-event-time'].concat(classNames).join(' '),\n          ref: rootElRef\n        }, innerContent);\n      });\n    }\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n      className: \"fc-list-event-time\"\n    }, timeText);\n  }\n\n  return null;\n}\n\nfunction renderAllDayInner(hookProps) {\n  return hookProps.text;\n}\n/*\nResponsible for the scroller, and forwarding event-related actions into the \"grid\".\n*/\n\n\nvar ListView = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ListView, _super);\n\n  function ListView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.computeDateVars = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(computeDateVars);\n    _this.eventStoreToSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(_this._eventStoreToSegs);\n\n    _this.setRootEl = function (rootEl) {\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  ListView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var extraClassNames = ['fc-list', context.theme.getClass('table'), context.options.stickyHeaderDates !== false ? 'fc-list-sticky' : ''];\n\n    var _b = this.computeDateVars(props.dateProfile),\n        dayDates = _b.dayDates,\n        dayRanges = _b.dayRanges;\n\n    var eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewRoot, {\n      viewSpec: context.viewSpec,\n      elRef: this.setRootEl\n    }, function (rootElRef, classNames) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        ref: rootElRef,\n        className: extraClassNames.concat(classNames).join(' ')\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Scroller, {\n        liquid: !props.isHeightAuto,\n        overflowX: props.isHeightAuto ? 'visible' : 'hidden',\n        overflowY: props.isHeightAuto ? 'visible' : 'auto'\n      }, eventSegs.length > 0 ? _this.renderSegList(eventSegs, dayDates) : _this.renderEmptyMessage()));\n    });\n  };\n\n  ListView.prototype.renderEmptyMessage = function () {\n    var _a = this.context,\n        options = _a.options,\n        viewApi = _a.viewApi;\n    var hookProps = {\n      text: options.noEventsText,\n      view: viewApi\n    };\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RenderHook, {\n      hookProps: hookProps,\n      classNames: options.noEventsClassNames,\n      content: options.noEventsContent,\n      defaultContent: renderNoEventsInner,\n      didMount: options.noEventsDidMount,\n      willUnmount: options.noEventsWillUnmount\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: ['fc-list-empty'].concat(classNames).join(' '),\n        ref: rootElRef\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-list-empty-cushion\",\n        ref: innerElRef\n      }, innerContent));\n    });\n  };\n\n  ListView.prototype.renderSegList = function (allSegs, dayDates) {\n    var _a = this.context,\n        theme = _a.theme,\n        options = _a.options;\n    var segsByDay = groupSegsByDay(allSegs); // sparse array\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowTimer, {\n      unit: \"day\"\n    }, function (nowDate, todayRange) {\n      var innerNodes = [];\n\n      for (var dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1) {\n        var daySegs = segsByDay[dayIndex];\n\n        if (daySegs) {\n          // sparse array, so might be undefined\n          var dayStr = dayDates[dayIndex].toISOString(); // append a day header\n\n          innerNodes.push((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(ListViewHeaderRow, {\n            key: dayStr,\n            dayDate: dayDates[dayIndex],\n            todayRange: todayRange\n          }));\n          daySegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sortEventSegs)(daySegs, options.eventOrder);\n\n          for (var _i = 0, daySegs_1 = daySegs; _i < daySegs_1.length; _i++) {\n            var seg = daySegs_1[_i];\n            innerNodes.push((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(ListViewEventRow, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n              key: dayStr + ':' + seg.eventRange.instance.instanceId\n              /* are multiple segs for an instanceId */\n              ,\n              seg: seg,\n              isDragging: false,\n              isResizing: false,\n              isDateSelecting: false,\n              isSelected: false\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange, nowDate))));\n          }\n        }\n      }\n\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n        className: 'fc-list-table ' + theme.getClass('table')\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", null, innerNodes));\n    });\n  };\n\n  ListView.prototype._eventStoreToSegs = function (eventStore, eventUiBases, dayRanges) {\n    return this.eventRangesToSegs((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sliceEventStore)(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);\n  };\n\n  ListView.prototype.eventRangesToSegs = function (eventRanges, dayRanges) {\n    var segs = [];\n\n    for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {\n      var eventRange = eventRanges_1[_i];\n      segs.push.apply(segs, this.eventRangeToSegs(eventRange, dayRanges));\n    }\n\n    return segs;\n  };\n\n  ListView.prototype.eventRangeToSegs = function (eventRange, dayRanges) {\n    var dateEnv = this.context.dateEnv;\n    var nextDayThreshold = this.context.options.nextDayThreshold;\n    var range = eventRange.range;\n    var allDay = eventRange.def.allDay;\n    var dayIndex;\n    var segRange;\n    var seg;\n    var segs = [];\n\n    for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1) {\n      segRange = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectRanges)(range, dayRanges[dayIndex]);\n\n      if (segRange) {\n        seg = {\n          component: this,\n          eventRange: eventRange,\n          start: segRange.start,\n          end: segRange.end,\n          isStart: eventRange.isStart && segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: eventRange.isEnd && segRange.end.valueOf() === range.end.valueOf(),\n          dayIndex: dayIndex\n        };\n        segs.push(seg); // detect when range won't go fully into the next day,\n        // and mutate the latest seg to the be the end.\n\n        if (!seg.isEnd && !allDay && dayIndex + 1 < dayRanges.length && range.end < dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {\n          seg.end = range.end;\n          seg.isEnd = true;\n          break;\n        }\n      }\n    }\n\n    return segs;\n  };\n\n  return ListView;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\n\nfunction renderNoEventsInner(hookProps) {\n  return hookProps.text;\n}\n\nfunction computeDateVars(dateProfile) {\n  var dayStart = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.startOfDay)(dateProfile.renderRange.start);\n  var viewEnd = dateProfile.renderRange.end;\n  var dayDates = [];\n  var dayRanges = [];\n\n  while (dayStart < viewEnd) {\n    dayDates.push(dayStart);\n    dayRanges.push({\n      start: dayStart,\n      end: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDays)(dayStart, 1)\n    });\n    dayStart = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDays)(dayStart, 1);\n  }\n\n  return {\n    dayDates: dayDates,\n    dayRanges: dayRanges\n  };\n} // Returns a sparse array of arrays, segs grouped by their dayIndex\n\n\nfunction groupSegsByDay(segs) {\n  var segsByDay = []; // sparse array\n\n  var i;\n  var seg;\n\n  for (i = 0; i < segs.length; i += 1) {\n    seg = segs[i];\n    (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);\n  }\n\n  return segsByDay;\n}\n\nvar OPTION_REFINERS = {\n  listDayFormat: createFalsableFormatter,\n  listDaySideFormat: createFalsableFormatter,\n  noEventsClassNames: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.identity,\n  noEventsContent: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.identity,\n  noEventsDidMount: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.identity,\n  noEventsWillUnmount: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.identity // noEventsText is defined in base options\n\n};\n\nfunction createFalsableFormatter(input) {\n  return input === false ? null : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)(input);\n}\n\nvar main = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createPlugin)({\n  optionRefiners: OPTION_REFINERS,\n  views: {\n    list: {\n      component: ListView,\n      buttonTextKey: 'list',\n      listDayFormat: {\n        month: 'long',\n        day: 'numeric',\n        year: 'numeric'\n      } // like \"January 1, 2016\"\n\n    },\n    listDay: {\n      type: 'list',\n      duration: {\n        days: 1\n      },\n      listDayFormat: {\n        weekday: 'long'\n      } // day-of-week is all we need. full date is probably in headerToolbar\n\n    },\n    listWeek: {\n      type: 'list',\n      duration: {\n        weeks: 1\n      },\n      listDayFormat: {\n        weekday: 'long'\n      },\n      listDaySideFormat: {\n        month: 'long',\n        day: 'numeric',\n        year: 'numeric'\n      }\n    },\n    listMonth: {\n      type: 'list',\n      duration: {\n        month: 1\n      },\n      listDaySideFormat: {\n        weekday: 'long'\n      } // day-of-week is nice-to-have\n\n    },\n    listYear: {\n      type: 'list',\n      duration: {\n        year: 1\n      },\n      listDaySideFormat: {\n        weekday: 'long'\n      } // day-of-week is nice-to-have\n\n    }\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (main);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9saXN0L21haW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUFBOztBQUFBOztBQXVEQTs7QUF0REE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBR0E7O0FBR0E7QUFFQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFTQTs7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFFQTtBQUNBO0FBQUE7QUFGQTtBQUtBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFLQTtBQUdBOztBQUNBO0FBdkRBOztBQXlEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUdBO0FBQUE7QUFLQTtBQUFBO0FBTUE7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFBQTs7QUFBQTs7QUFvQ0E7O0FBbkNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFGQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBSUE7QUFHQTs7QUFDQTtBQXBDQTs7QUFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFNQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFHQTs7QUFFQTtBQUNBO0FBQUE7QUFJQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQ3pHQTs7Ozs7O0FBR0E7O0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQWlDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQXFKQTs7QUE1TEE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBRUE7O0FBTUE7QUFBQTtBQUFBOztBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBVUE7QUFHQTs7QUFZQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFHQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFPQTs7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFVQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBSUE7QUFHQTs7QUFFQTtBQUNBO0FBU0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7OztBQUlBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFoTUE7O0FBa01BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7O0FDN1BBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQVBBOztBQVlBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7O0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7O0FBSEE7QUEzQkE7QUFGQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9MaXN0Vmlld0hlYWRlclJvdy50c3g/MzBmNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvTGlzdFZpZXdFdmVudFJvdy50c3g/MGEzNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvTGlzdFZpZXcudHN4PzY5NmIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL29wdGlvbnMudHM/OTE4MSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvbWFpbi50cz9iOTljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJhc2VDb21wb25lbnQsIERhdGVNYXJrZXIsIGNyZWF0ZUVsZW1lbnQsIERhdGVSYW5nZSwgZ2V0RGF0ZU1ldGEsXG4gIFJlbmRlckhvb2ssIGJ1aWxkTmF2TGlua0RhdGEsIERheUhlYWRlckNvbnRlbnRBcmcsIGdldERheUNsYXNzTmFtZXMsIGZvcm1hdERheVN0cmluZywgRnJhZ21lbnQsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuXG5leHBvcnQgaW50ZXJmYWNlIExpc3RWaWV3SGVhZGVyUm93UHJvcHMge1xuICBkYXlEYXRlOiBEYXRlTWFya2VyXG4gIHRvZGF5UmFuZ2U6IERhdGVSYW5nZVxufVxuXG5pbnRlcmZhY2UgSG9va1Byb3BzIGV4dGVuZHMgRGF5SGVhZGVyQ29udGVudEFyZyB7IC8vIGRvZXNuJ3QgZW5mb3JjZSBtdWNoIHNpbmNlIERheUNlbGxDb250ZW50QXJnIGFsbG93IGV4dHJhIHByb3BzXG4gIHRleHQ6IHN0cmluZ1xuICBzaWRlVGV4dDogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBMaXN0Vmlld0hlYWRlclJvdyBleHRlbmRzIEJhc2VDb21wb25lbnQ8TGlzdFZpZXdIZWFkZXJSb3dQcm9wcz4ge1xuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgZGF5RGF0ZSwgdG9kYXlSYW5nZSB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCB7IHRoZW1lLCBkYXRlRW52LCBvcHRpb25zLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRheURhdGUsIHRvZGF5UmFuZ2UpXG5cbiAgICAvLyB3aWxsIGV2ZXIgYmUgZmFsc3k/XG4gICAgbGV0IHRleHQgPSBvcHRpb25zLmxpc3REYXlGb3JtYXQgPyBkYXRlRW52LmZvcm1hdChkYXlEYXRlLCBvcHRpb25zLmxpc3REYXlGb3JtYXQpIDogJydcblxuICAgIC8vIHdpbGwgZXZlciBiZSBmYWxzeT8gYWxzbywgQkFEIE5BTUUgXCJhbHRcIlxuICAgIGxldCBzaWRlVGV4dCA9IG9wdGlvbnMubGlzdERheVNpZGVGb3JtYXQgPyBkYXRlRW52LmZvcm1hdChkYXlEYXRlLCBvcHRpb25zLmxpc3REYXlTaWRlRm9ybWF0KSA6ICcnXG5cbiAgICBsZXQgbmF2TGlua0RhdGEgPSBvcHRpb25zLm5hdkxpbmtzXG4gICAgICA/IGJ1aWxkTmF2TGlua0RhdGEoZGF5RGF0ZSlcbiAgICAgIDogbnVsbFxuXG4gICAgbGV0IGhvb2tQcm9wczogSG9va1Byb3BzID0ge1xuICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUoZGF5RGF0ZSksXG4gICAgICB2aWV3OiB2aWV3QXBpLFxuICAgICAgdGV4dCxcbiAgICAgIHNpZGVUZXh0LFxuICAgICAgbmF2TGlua0RhdGEsXG4gICAgICAuLi5kYXlNZXRhLFxuICAgIH1cblxuICAgIGxldCBjbGFzc05hbWVzID0gWydmYy1saXN0LWRheSddLmNvbmNhdChcbiAgICAgIGdldERheUNsYXNzTmFtZXMoZGF5TWV0YSwgdGhlbWUpLFxuICAgIClcblxuICAgIC8vIFRPRE86IG1ha2UgYSByZXVzYWJsZSBIT0MgZm9yIGRheUhlYWRlciAodXNlZCBpbiBkYXlncmlkL3RpbWVncmlkIHRvbylcbiAgICByZXR1cm4gKFxuICAgICAgPFJlbmRlckhvb2s8SG9va1Byb3BzPlxuICAgICAgICBob29rUHJvcHM9e2hvb2tQcm9wc31cbiAgICAgICAgY2xhc3NOYW1lcz17b3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzfVxuICAgICAgICBjb250ZW50PXtvcHRpb25zLmRheUhlYWRlckNvbnRlbnR9XG4gICAgICAgIGRlZmF1bHRDb250ZW50PXtyZW5kZXJJbm5lckNvbnRlbnR9XG4gICAgICAgIGRpZE1vdW50PXtvcHRpb25zLmRheUhlYWRlckRpZE1vdW50fVxuICAgICAgICB3aWxsVW5tb3VudD17b3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudH1cbiAgICAgID5cbiAgICAgICAgeyhyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgPT4gKFxuICAgICAgICAgIDx0clxuICAgICAgICAgICAgcmVmPXtyb290RWxSZWZ9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMuY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLmpvaW4oJyAnKX1cbiAgICAgICAgICAgIGRhdGEtZGF0ZT17Zm9ybWF0RGF5U3RyaW5nKGRheURhdGUpfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDx0aCBjb2xTcGFuPXszfT5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9eydmYy1saXN0LWRheS1jdXNoaW9uICcgKyB0aGVtZS5nZXRDbGFzcygndGFibGVDZWxsU2hhZGVkJyl9IHJlZj17aW5uZXJFbFJlZn0+XG4gICAgICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L3RoPlxuICAgICAgICAgIDwvdHI+XG4gICAgICAgICl9XG4gICAgICA8L1JlbmRlckhvb2s+XG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChwcm9wczogSG9va1Byb3BzKSB7XG4gIGxldCBuYXZMaW5rQXR0cnMgPSBwcm9wcy5uYXZMaW5rRGF0YSAvLyBpcyB0aGVyZSBhIHR5cGUgZm9yIHRoaXM/XG4gICAgPyB7ICdkYXRhLW5hdmxpbmsnOiBwcm9wcy5uYXZMaW5rRGF0YSwgdGFiSW5kZXg6IDAgfVxuICAgIDoge31cblxuICByZXR1cm4gKFxuICAgIDxGcmFnbWVudD5cbiAgICAgIHtwcm9wcy50ZXh0ICYmIChcbiAgICAgICAgPGEgY2xhc3NOYW1lPVwiZmMtbGlzdC1kYXktdGV4dFwiIHsuLi5uYXZMaW5rQXR0cnN9PlxuICAgICAgICAgIHtwcm9wcy50ZXh0fVxuICAgICAgICA8L2E+XG4gICAgICApfVxuICAgICAge3Byb3BzLnNpZGVUZXh0ICYmIChcbiAgICAgICAgPGEgY2xhc3NOYW1lPVwiZmMtbGlzdC1kYXktc2lkZS10ZXh0XCIgey4uLm5hdkxpbmtBdHRyc30+XG4gICAgICAgICAge3Byb3BzLnNpZGVUZXh0fVxuICAgICAgICA8L2E+XG4gICAgICApfVxuICAgIDwvRnJhZ21lbnQ+XG4gIClcbn1cbiIsImltcG9ydCB7XG4gIE1pbmltYWxFdmVudFByb3BzLCBCYXNlQ29tcG9uZW50LCBWaWV3Q29udGV4dCwgY3JlYXRlRWxlbWVudCwgQWxsRGF5Q29udGVudEFyZyxcbiAgU2VnLCBpc011bHRpRGF5UmFuZ2UsIERhdGVGb3JtYXR0ZXIsIGJ1aWxkU2VnVGltZVRleHQsIGNyZWF0ZUZvcm1hdHRlciwgRXZlbnRDb250ZW50QXJnLCBFdmVudFJvb3QsIENvbXBvbmVudENoaWxkcmVuLCBSZW5kZXJIb29rLFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcblxuY29uc3QgREVGQVVMVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XG4gIGhvdXI6ICdudW1lcmljJyxcbiAgbWludXRlOiAnMi1kaWdpdCcsXG4gIG1lcmlkaWVtOiAnc2hvcnQnLFxufSlcblxuZXhwb3J0IGNsYXNzIExpc3RWaWV3RXZlbnRSb3cgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PE1pbmltYWxFdmVudFByb3BzPiB7XG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCB7IHNlZyB9ID0gcHJvcHNcblxuICAgIGxldCB0aW1lRm9ybWF0ID0gY29udGV4dC5vcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBERUZBVUxUX1RJTUVfRk9STUFUXG5cbiAgICByZXR1cm4gKFxuICAgICAgPEV2ZW50Um9vdFxuICAgICAgICBzZWc9e3NlZ31cbiAgICAgICAgdGltZVRleHQ9XCJcIiAvLyBCQUQuIGJlY2F1c2Ugb2YgYWxsLWRheSBjb250ZW50XG4gICAgICAgIGRpc2FibGVEcmFnZ2luZ1xuICAgICAgICBkaXNhYmxlUmVzaXppbmdcbiAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3JlbmRlckV2ZW50SW5uZXJDb250ZW50fVxuICAgICAgICBpc1Bhc3Q9e3Byb3BzLmlzUGFzdH1cbiAgICAgICAgaXNGdXR1cmU9e3Byb3BzLmlzRnV0dXJlfVxuICAgICAgICBpc1RvZGF5PXtwcm9wcy5pc1RvZGF5fVxuICAgICAgICBpc1NlbGVjdGVkPXtwcm9wcy5pc1NlbGVjdGVkfVxuICAgICAgICBpc0RyYWdnaW5nPXtwcm9wcy5pc0RyYWdnaW5nfVxuICAgICAgICBpc1Jlc2l6aW5nPXtwcm9wcy5pc1Jlc2l6aW5nfVxuICAgICAgICBpc0RhdGVTZWxlY3Rpbmc9e3Byb3BzLmlzRGF0ZVNlbGVjdGluZ31cbiAgICAgID5cbiAgICAgICAgeyhyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaG9va1Byb3BzKSA9PiAoXG4gICAgICAgICAgPHRyIGNsYXNzTmFtZT17WydmYy1saXN0LWV2ZW50JywgaG9va1Byb3BzLmV2ZW50LnVybCA/ICdmYy1ldmVudC1mb3JjZWQtdXJsJyA6ICcnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpfSByZWY9e3Jvb3RFbFJlZn0+XG4gICAgICAgICAgICB7YnVpbGRUaW1lQ29udGVudChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQpfVxuICAgICAgICAgICAgPHRkIGNsYXNzTmFtZT1cImZjLWxpc3QtZXZlbnQtZ3JhcGhpY1wiPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYy1saXN0LWV2ZW50LWRvdFwiIHN0eWxlPXt7IGJvcmRlckNvbG9yOiBob29rUHJvcHMuYm9yZGVyQ29sb3IgfHwgaG9va1Byb3BzLmJhY2tncm91bmRDb2xvciB9fSAvPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZCBjbGFzc05hbWU9XCJmYy1saXN0LWV2ZW50LXRpdGxlXCIgcmVmPXtpbm5lckVsUmVmfT5cbiAgICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgKX1cbiAgICAgIDwvRXZlbnRSb290PlxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJFdmVudElubmVyQ29udGVudChwcm9wczogRXZlbnRDb250ZW50QXJnKSB7XG4gIGxldCB7IGV2ZW50IH0gPSBwcm9wc1xuICBsZXQgdXJsID0gZXZlbnQudXJsXG4gIGxldCBhbmNob3JBdHRycyA9IHVybCA/IHsgaHJlZjogdXJsIH0gOiB7fVxuXG4gIHJldHVybiAoXG4gICAgPGEgey4uLmFuY2hvckF0dHJzfT5cbiAgICAgIHsvKiBUT0RPOiBkb2N1bWVudCBob3cgd2hvbGUgcm93IGJlY29tZSBjbGlja2FibGUgKi99XG4gICAgICB7ZXZlbnQudGl0bGV9XG4gICAgPC9hPlxuICApXG59XG5cbmZ1bmN0aW9uIGJ1aWxkVGltZUNvbnRlbnQoc2VnOiBTZWcsIHRpbWVGb3JtYXQ6IERhdGVGb3JtYXR0ZXIsIGNvbnRleHQ6IFZpZXdDb250ZXh0KTogQ29tcG9uZW50Q2hpbGRyZW4ge1xuICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0XG5cbiAgaWYgKG9wdGlvbnMuZGlzcGxheUV2ZW50VGltZSAhPT0gZmFsc2UpIHtcbiAgICBsZXQgZXZlbnREZWYgPSBzZWcuZXZlbnRSYW5nZS5kZWZcbiAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlXG4gICAgbGV0IGRvQWxsRGF5ID0gZmFsc2VcbiAgICBsZXQgdGltZVRleHQ6IHN0cmluZ1xuXG4gICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgICAgZG9BbGxEYXkgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChpc011bHRpRGF5UmFuZ2Uoc2VnLmV2ZW50UmFuZ2UucmFuZ2UpKSB7IC8vIFRPRE86IHVzZSAoIWlzU3RhcnQgfHwgIWlzRW5kKSBpbnN0ZWFkP1xuICAgICAgaWYgKHNlZy5pc1N0YXJ0KSB7XG4gICAgICAgIHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChcbiAgICAgICAgICBzZWcsXG4gICAgICAgICAgdGltZUZvcm1hdCxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBldmVudEluc3RhbmNlLnJhbmdlLnN0YXJ0LFxuICAgICAgICAgIHNlZy5lbmQsXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAoc2VnLmlzRW5kKSB7XG4gICAgICAgIHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChcbiAgICAgICAgICBzZWcsXG4gICAgICAgICAgdGltZUZvcm1hdCxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBzZWcuc3RhcnQsXG4gICAgICAgICAgZXZlbnRJbnN0YW5jZS5yYW5nZS5lbmQsXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvQWxsRGF5ID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoXG4gICAgICAgIHNlZyxcbiAgICAgICAgdGltZUZvcm1hdCxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoZG9BbGxEYXkpIHtcbiAgICAgIGxldCBob29rUHJvcHM6IEFsbERheUNvbnRlbnRBcmcgPSB7XG4gICAgICAgIHRleHQ6IGNvbnRleHQub3B0aW9ucy5hbGxEYXlUZXh0LFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxSZW5kZXJIb29rPEFsbERheUNvbnRlbnRBcmc+IC8vIG5lZWRlZD9cbiAgICAgICAgICBob29rUHJvcHM9e2hvb2tQcm9wc31cbiAgICAgICAgICBjbGFzc05hbWVzPXtvcHRpb25zLmFsbERheUNsYXNzTmFtZXN9XG4gICAgICAgICAgY29udGVudD17b3B0aW9ucy5hbGxEYXlDb250ZW50fVxuICAgICAgICAgIGRlZmF1bHRDb250ZW50PXtyZW5kZXJBbGxEYXlJbm5lcn1cbiAgICAgICAgICBkaWRNb3VudD17b3B0aW9ucy5hbGxEYXlEaWRNb3VudH1cbiAgICAgICAgICB3aWxsVW5tb3VudD17b3B0aW9ucy5hbGxEYXlXaWxsVW5tb3VudH1cbiAgICAgICAgPlxuICAgICAgICAgIHsocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpID0+IChcbiAgICAgICAgICAgIDx0ZCBjbGFzc05hbWU9e1snZmMtbGlzdC1ldmVudC10aW1lJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKX0gcmVmPXtyb290RWxSZWZ9PlxuICAgICAgICAgICAgICB7aW5uZXJDb250ZW50fVxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICApfVxuICAgICAgICA8L1JlbmRlckhvb2s+XG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0ZCBjbGFzc05hbWU9XCJmYy1saXN0LWV2ZW50LXRpbWVcIj5cbiAgICAgICAge3RpbWVUZXh0fVxuICAgICAgPC90ZD5cbiAgICApXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiByZW5kZXJBbGxEYXlJbm5lcihob29rUHJvcHMpIHtcbiAgcmV0dXJuIGhvb2tQcm9wcy50ZXh0XG59XG4iLCJpbXBvcnQge1xuICBjcmVhdGVFbGVtZW50LFxuICBWaWV3UHJvcHMsXG4gIFNjcm9sbGVyLFxuICBEYXRlTWFya2VyLFxuICBhZGREYXlzLFxuICBzdGFydE9mRGF5LFxuICBEYXRlUmFuZ2UsXG4gIGludGVyc2VjdFJhbmdlcyxcbiAgRGF0ZVByb2ZpbGUsXG4gIEV2ZW50VWlIYXNoLFxuICBFdmVudFJlbmRlclJhbmdlLFxuICBzbGljZUV2ZW50U3RvcmUsXG4gIEV2ZW50U3RvcmUsXG4gIG1lbW9pemUsXG4gIFNlZyxcbiAgVk5vZGUsXG4gIHNvcnRFdmVudFNlZ3MsXG4gIGdldFNlZ01ldGEsXG4gIE5vd1RpbWVyLFxuICBWaWV3Um9vdCxcbiAgUmVuZGVySG9vayxcbiAgRGF0ZUNvbXBvbmVudCxcbiAgVmlld0FwaSxcbiAgTW91bnRBcmcsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgTGlzdFZpZXdIZWFkZXJSb3cgfSBmcm9tICcuL0xpc3RWaWV3SGVhZGVyUm93J1xuaW1wb3J0IHsgTGlzdFZpZXdFdmVudFJvdyB9IGZyb20gJy4vTGlzdFZpZXdFdmVudFJvdydcblxuZXhwb3J0IGludGVyZmFjZSBOb0V2ZW50c0NvbnRlbnRBcmcge1xuICB0ZXh0OiBzdHJpbmdcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgdHlwZSBOb0V2ZW50c01vdW50QXJnID0gTW91bnRBcmc8Tm9FdmVudHNDb250ZW50QXJnPlxuXG4vKlxuUmVzcG9uc2libGUgZm9yIHRoZSBzY3JvbGxlciwgYW5kIGZvcndhcmRpbmcgZXZlbnQtcmVsYXRlZCBhY3Rpb25zIGludG8gdGhlIFwiZ3JpZFwiLlxuKi9cbmV4cG9ydCBjbGFzcyBMaXN0VmlldyBleHRlbmRzIERhdGVDb21wb25lbnQ8Vmlld1Byb3BzPiB7XG4gIHByaXZhdGUgY29tcHV0ZURhdGVWYXJzID0gbWVtb2l6ZShjb21wdXRlRGF0ZVZhcnMpXG4gIHByaXZhdGUgZXZlbnRTdG9yZVRvU2VncyA9IG1lbW9pemUodGhpcy5fZXZlbnRTdG9yZVRvU2VncylcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIGxldCBleHRyYUNsYXNzTmFtZXMgPSBbXG4gICAgICAnZmMtbGlzdCcsXG4gICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLCAvLyBqdXN0IGZvciB0aGUgb3V0ZXIgYm9yZGVyLiB3aWxsIGJlIG9uIGRpdlxuICAgICAgY29udGV4dC5vcHRpb25zLnN0aWNreUhlYWRlckRhdGVzICE9PSBmYWxzZSA/ICdmYy1saXN0LXN0aWNreScgOiAnJyxcbiAgICBdXG5cbiAgICBsZXQgeyBkYXlEYXRlcywgZGF5UmFuZ2VzIH0gPSB0aGlzLmNvbXB1dGVEYXRlVmFycyhwcm9wcy5kYXRlUHJvZmlsZSlcbiAgICBsZXQgZXZlbnRTZWdzID0gdGhpcy5ldmVudFN0b3JlVG9TZWdzKHByb3BzLmV2ZW50U3RvcmUsIHByb3BzLmV2ZW50VWlCYXNlcywgZGF5UmFuZ2VzKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxWaWV3Um9vdCB2aWV3U3BlYz17Y29udGV4dC52aWV3U3BlY30gZWxSZWY9e3RoaXMuc2V0Um9vdEVsfT5cbiAgICAgICAgeyhyb290RWxSZWYsIGNsYXNzTmFtZXMpID0+IChcbiAgICAgICAgICA8ZGl2IHJlZj17cm9vdEVsUmVmfSBjbGFzc05hbWU9e2V4dHJhQ2xhc3NOYW1lcy5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpfT5cbiAgICAgICAgICAgIDxTY3JvbGxlclxuICAgICAgICAgICAgICBsaXF1aWQ9eyFwcm9wcy5pc0hlaWdodEF1dG99XG4gICAgICAgICAgICAgIG92ZXJmbG93WD17cHJvcHMuaXNIZWlnaHRBdXRvID8gJ3Zpc2libGUnIDogJ2hpZGRlbid9XG4gICAgICAgICAgICAgIG92ZXJmbG93WT17cHJvcHMuaXNIZWlnaHRBdXRvID8gJ3Zpc2libGUnIDogJ2F1dG8nfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7ZXZlbnRTZWdzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU2VnTGlzdChldmVudFNlZ3MsIGRheURhdGVzKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFbXB0eU1lc3NhZ2UoKX1cbiAgICAgICAgICAgIDwvU2Nyb2xsZXI+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L1ZpZXdSb290PlxuICAgIClcbiAgfVxuXG4gIHNldFJvb3RFbCA9IChyb290RWw6IEhUTUxEaXZFbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgIGlmIChyb290RWwpIHtcbiAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHsgLy8gVE9ETzogbWFrZSBhd2FyZSB0aGF0IGl0IGRvZXNuJ3QgZG8gSGl0c1xuICAgICAgICBlbDogcm9vdEVsLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlckVtcHR5TWVzc2FnZSgpIHtcbiAgICBsZXQgeyBvcHRpb25zLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgaG9va1Byb3BzOiBOb0V2ZW50c0NvbnRlbnRBcmcgPSB7XG4gICAgICB0ZXh0OiBvcHRpb25zLm5vRXZlbnRzVGV4dCxcbiAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxSZW5kZXJIb29rPE5vRXZlbnRzQ29udGVudEFyZz4gLy8gbmVlZGVkPz8/XG4gICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICBjbGFzc05hbWVzPXtvcHRpb25zLm5vRXZlbnRzQ2xhc3NOYW1lc31cbiAgICAgICAgY29udGVudD17b3B0aW9ucy5ub0V2ZW50c0NvbnRlbnR9XG4gICAgICAgIGRlZmF1bHRDb250ZW50PXtyZW5kZXJOb0V2ZW50c0lubmVyfVxuICAgICAgICBkaWRNb3VudD17b3B0aW9ucy5ub0V2ZW50c0RpZE1vdW50fVxuICAgICAgICB3aWxsVW5tb3VudD17b3B0aW9ucy5ub0V2ZW50c1dpbGxVbm1vdW50fVxuICAgICAgPlxuICAgICAgICB7KHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSA9PiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e1snZmMtbGlzdC1lbXB0eSddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyl9IHJlZj17cm9vdEVsUmVmfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtbGlzdC1lbXB0eS1jdXNoaW9uXCIgcmVmPXtpbm5lckVsUmVmfT5cbiAgICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9SZW5kZXJIb29rPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlclNlZ0xpc3QoYWxsU2VnczogU2VnW10sIGRheURhdGVzOiBEYXRlTWFya2VyW10pIHtcbiAgICBsZXQgeyB0aGVtZSwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0XG4gICAgbGV0IHNlZ3NCeURheSA9IGdyb3VwU2Vnc0J5RGF5KGFsbFNlZ3MpIC8vIHNwYXJzZSBhcnJheVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxOb3dUaW1lciB1bml0PVwiZGF5XCI+XG4gICAgICAgIHsobm93RGF0ZTogRGF0ZU1hcmtlciwgdG9kYXlSYW5nZTogRGF0ZVJhbmdlKSA9PiB7XG4gICAgICAgICAgbGV0IGlubmVyTm9kZXM6IFZOb2RlW10gPSBbXVxuXG4gICAgICAgICAgZm9yIChsZXQgZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IHNlZ3NCeURheS5sZW5ndGg7IGRheUluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBkYXlTZWdzID0gc2Vnc0J5RGF5W2RheUluZGV4XVxuXG4gICAgICAgICAgICBpZiAoZGF5U2VncykgeyAvLyBzcGFyc2UgYXJyYXksIHNvIG1pZ2h0IGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgICBsZXQgZGF5U3RyID0gZGF5RGF0ZXNbZGF5SW5kZXhdLnRvSVNPU3RyaW5nKClcblxuICAgICAgICAgICAgICAvLyBhcHBlbmQgYSBkYXkgaGVhZGVyXG4gICAgICAgICAgICAgIGlubmVyTm9kZXMucHVzaChcbiAgICAgICAgICAgICAgICA8TGlzdFZpZXdIZWFkZXJSb3dcbiAgICAgICAgICAgICAgICAgIGtleT17ZGF5U3RyfVxuICAgICAgICAgICAgICAgICAgZGF5RGF0ZT17ZGF5RGF0ZXNbZGF5SW5kZXhdfVxuICAgICAgICAgICAgICAgICAgdG9kYXlSYW5nZT17dG9kYXlSYW5nZX1cbiAgICAgICAgICAgICAgICAvPixcbiAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgIGRheVNlZ3MgPSBzb3J0RXZlbnRTZWdzKGRheVNlZ3MsIG9wdGlvbnMuZXZlbnRPcmRlcilcblxuICAgICAgICAgICAgICBmb3IgKGxldCBzZWcgb2YgZGF5U2Vncykge1xuICAgICAgICAgICAgICAgIGlubmVyTm9kZXMucHVzaChcbiAgICAgICAgICAgICAgICAgIDxMaXN0Vmlld0V2ZW50Um93XG4gICAgICAgICAgICAgICAgICAgIGtleT17ZGF5U3RyICsgJzonICsgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCAvKiBhcmUgbXVsdGlwbGUgc2VncyBmb3IgYW4gaW5zdGFuY2VJZCAqL31cbiAgICAgICAgICAgICAgICAgICAgc2VnPXtzZWd9XG4gICAgICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmc9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgICBpc1Jlc2l6aW5nPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgaXNEYXRlU2VsZWN0aW5nPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3RlZD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgIHsuLi5nZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSl9XG4gICAgICAgICAgICAgICAgICAvPixcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT17J2ZjLWxpc3QtdGFibGUgJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZScpfT5cbiAgICAgICAgICAgICAgPHRib2R5Pntpbm5lck5vZGVzfTwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgIClcbiAgICAgICAgfX1cbiAgICAgIDwvTm93VGltZXI+XG4gICAgKVxuICB9XG5cbiAgX2V2ZW50U3RvcmVUb1NlZ3MoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaCwgZGF5UmFuZ2VzOiBEYXRlUmFuZ2VbXSk6IFNlZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudFJhbmdlc1RvU2VncyhcbiAgICAgIHNsaWNlRXZlbnRTdG9yZShcbiAgICAgICAgZXZlbnRTdG9yZSxcbiAgICAgICAgZXZlbnRVaUJhc2VzLFxuICAgICAgICB0aGlzLnByb3BzLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLFxuICAgICAgICB0aGlzLmNvbnRleHQub3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkLFxuICAgICAgKS5mZyxcbiAgICAgIGRheVJhbmdlcyxcbiAgICApXG4gIH1cblxuICBldmVudFJhbmdlc1RvU2VncyhldmVudFJhbmdlczogRXZlbnRSZW5kZXJSYW5nZVtdLCBkYXlSYW5nZXM6IERhdGVSYW5nZVtdKSB7XG4gICAgbGV0IHNlZ3MgPSBbXVxuXG4gICAgZm9yIChsZXQgZXZlbnRSYW5nZSBvZiBldmVudFJhbmdlcykge1xuICAgICAgc2Vncy5wdXNoKC4uLnRoaXMuZXZlbnRSYW5nZVRvU2VncyhldmVudFJhbmdlLCBkYXlSYW5nZXMpKVxuICAgIH1cblxuICAgIHJldHVybiBzZWdzXG4gIH1cblxuICBldmVudFJhbmdlVG9TZWdzKGV2ZW50UmFuZ2U6IEV2ZW50UmVuZGVyUmFuZ2UsIGRheVJhbmdlczogRGF0ZVJhbmdlW10pIHtcbiAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgeyBuZXh0RGF5VGhyZXNob2xkIH0gPSB0aGlzLmNvbnRleHQub3B0aW9uc1xuICAgIGxldCByYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2VcbiAgICBsZXQgYWxsRGF5ID0gZXZlbnRSYW5nZS5kZWYuYWxsRGF5XG4gICAgbGV0IGRheUluZGV4XG4gICAgbGV0IHNlZ1JhbmdlXG4gICAgbGV0IHNlZ1xuICAgIGxldCBzZWdzID0gW11cblxuICAgIGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IGRheVJhbmdlcy5sZW5ndGg7IGRheUluZGV4ICs9IDEpIHtcbiAgICAgIHNlZ1JhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKHJhbmdlLCBkYXlSYW5nZXNbZGF5SW5kZXhdKVxuXG4gICAgICBpZiAoc2VnUmFuZ2UpIHtcbiAgICAgICAgc2VnID0ge1xuICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcbiAgICAgICAgICBldmVudFJhbmdlLFxuICAgICAgICAgIHN0YXJ0OiBzZWdSYW5nZS5zdGFydCxcbiAgICAgICAgICBlbmQ6IHNlZ1JhbmdlLmVuZCxcbiAgICAgICAgICBpc1N0YXJ0OiBldmVudFJhbmdlLmlzU3RhcnQgJiYgc2VnUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSByYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgaXNFbmQ6IGV2ZW50UmFuZ2UuaXNFbmQgJiYgc2VnUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gcmFuZ2UuZW5kLnZhbHVlT2YoKSxcbiAgICAgICAgICBkYXlJbmRleCxcbiAgICAgICAgfVxuXG4gICAgICAgIHNlZ3MucHVzaChzZWcpXG5cbiAgICAgICAgLy8gZGV0ZWN0IHdoZW4gcmFuZ2Ugd29uJ3QgZ28gZnVsbHkgaW50byB0aGUgbmV4dCBkYXksXG4gICAgICAgIC8vIGFuZCBtdXRhdGUgdGhlIGxhdGVzdCBzZWcgdG8gdGhlIGJlIHRoZSBlbmQuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhc2VnLmlzRW5kICYmICFhbGxEYXkgJiZcbiAgICAgICAgICBkYXlJbmRleCArIDEgPCBkYXlSYW5nZXMubGVuZ3RoICYmXG4gICAgICAgICAgcmFuZ2UuZW5kIDxcbiAgICAgICAgICAgIGRhdGVFbnYuYWRkKFxuICAgICAgICAgICAgICBkYXlSYW5nZXNbZGF5SW5kZXggKyAxXS5zdGFydCxcbiAgICAgICAgICAgICAgbmV4dERheVRocmVzaG9sZCxcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgc2VnLmVuZCA9IHJhbmdlLmVuZFxuICAgICAgICAgIHNlZy5pc0VuZCA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlZ3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJOb0V2ZW50c0lubmVyKGhvb2tQcm9wcykge1xuICByZXR1cm4gaG9va1Byb3BzLnRleHRcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURhdGVWYXJzKGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSkge1xuICBsZXQgZGF5U3RhcnQgPSBzdGFydE9mRGF5KGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLnN0YXJ0KVxuICBsZXQgdmlld0VuZCA9IGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLmVuZFxuICBsZXQgZGF5RGF0ZXM6IERhdGVNYXJrZXJbXSA9IFtdXG4gIGxldCBkYXlSYW5nZXM6IERhdGVSYW5nZVtdID0gW11cblxuICB3aGlsZSAoZGF5U3RhcnQgPCB2aWV3RW5kKSB7XG4gICAgZGF5RGF0ZXMucHVzaChkYXlTdGFydClcblxuICAgIGRheVJhbmdlcy5wdXNoKHtcbiAgICAgIHN0YXJ0OiBkYXlTdGFydCxcbiAgICAgIGVuZDogYWRkRGF5cyhkYXlTdGFydCwgMSksXG4gICAgfSlcblxuICAgIGRheVN0YXJ0ID0gYWRkRGF5cyhkYXlTdGFydCwgMSlcbiAgfVxuXG4gIHJldHVybiB7IGRheURhdGVzLCBkYXlSYW5nZXMgfVxufVxuXG4vLyBSZXR1cm5zIGEgc3BhcnNlIGFycmF5IG9mIGFycmF5cywgc2VncyBncm91cGVkIGJ5IHRoZWlyIGRheUluZGV4XG5mdW5jdGlvbiBncm91cFNlZ3NCeURheShzZWdzKTogU2VnW11bXSB7XG4gIGxldCBzZWdzQnlEYXkgPSBbXSAvLyBzcGFyc2UgYXJyYXlcbiAgbGV0IGlcbiAgbGV0IHNlZ1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgc2VnID0gc2Vnc1tpXTtcbiAgICAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gfHwgKHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdID0gW10pKVxuICAgICAgLnB1c2goc2VnKVxuICB9XG5cbiAgcmV0dXJuIHNlZ3NCeURheVxufVxuIiwiaW1wb3J0IHtcbiAgaWRlbnRpdHksXG4gIElkZW50aXR5LFxuICBDbGFzc05hbWVzR2VuZXJhdG9yLFxuICBDdXN0b21Db250ZW50R2VuZXJhdG9yLFxuICBEaWRNb3VudEhhbmRsZXIsXG4gIFdpbGxVbm1vdW50SGFuZGxlcixcbiAgY3JlYXRlRm9ybWF0dGVyLFxuICBGb3JtYXR0ZXJJbnB1dCxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5cbi8vIHB1YmxpY1xuaW1wb3J0IHtcbiAgTm9FdmVudHNDb250ZW50QXJnLFxuICBOb0V2ZW50c01vdW50QXJnLFxufSBmcm9tICcuL2FwaS10eXBlLWRlcHMnXG5cbmV4cG9ydCBjb25zdCBPUFRJT05fUkVGSU5FUlMgPSB7XG4gIGxpc3REYXlGb3JtYXQ6IGNyZWF0ZUZhbHNhYmxlRm9ybWF0dGVyLCAvLyBkZWZhdWx0cyBzcGVjaWZpZWQgaW4gbGlzdCBwbHVnaW5zXG4gIGxpc3REYXlTaWRlRm9ybWF0OiBjcmVhdGVGYWxzYWJsZUZvcm1hdHRlciwgLy8gXCJcblxuICBub0V2ZW50c0NsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8Tm9FdmVudHNDb250ZW50QXJnPj4sXG4gIG5vRXZlbnRzQ29udGVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3VzdG9tQ29udGVudEdlbmVyYXRvcjxOb0V2ZW50c0NvbnRlbnRBcmc+PixcbiAgbm9FdmVudHNEaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPE5vRXZlbnRzTW91bnRBcmc+PixcbiAgbm9FdmVudHNXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPE5vRXZlbnRzTW91bnRBcmc+PixcblxuICAvLyBub0V2ZW50c1RleHQgaXMgZGVmaW5lZCBpbiBiYXNlIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmFsc2FibGVGb3JtYXR0ZXIoaW5wdXQ6IEZvcm1hdHRlcklucHV0IHwgZmFsc2UpIHtcbiAgcmV0dXJuIGlucHV0ID09PSBmYWxzZSA/IG51bGwgOiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IExpc3RWaWV3IH0gZnJvbSAnLi9MaXN0VmlldydcbmltcG9ydCB7IE9QVElPTl9SRUZJTkVSUyB9IGZyb20gJy4vb3B0aW9ucydcbmltcG9ydCAnLi9vcHRpb25zLWRlY2xhcmUnXG5pbXBvcnQgJy4vbWFpbi5jc3MnXG5cbmV4cG9ydCB7IExpc3RWaWV3IH1cbmV4cG9ydCAqIGZyb20gJy4vYXBpLXR5cGUtZGVwcydcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUGx1Z2luKHtcbiAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgdmlld3M6IHtcblxuICAgIGxpc3Q6IHtcbiAgICAgIGNvbXBvbmVudDogTGlzdFZpZXcsXG4gICAgICBidXR0b25UZXh0S2V5OiAnbGlzdCcsIC8vIHdoYXQgdG8gbG9va3VwIGluIGxvY2FsZSBmaWxlc1xuICAgICAgbGlzdERheUZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0sIC8vIGxpa2UgXCJKYW51YXJ5IDEsIDIwMTZcIlxuICAgIH0sXG5cbiAgICBsaXN0RGF5OiB7XG4gICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG4gICAgICBsaXN0RGF5Rm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9LCAvLyBkYXktb2Ytd2VlayBpcyBhbGwgd2UgbmVlZC4gZnVsbCBkYXRlIGlzIHByb2JhYmx5IGluIGhlYWRlclRvb2xiYXJcbiAgICB9LFxuXG4gICAgbGlzdFdlZWs6IHtcbiAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXG4gICAgICBsaXN0RGF5Rm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9LCAvLyBkYXktb2Ytd2VlayBpcyBtb3JlIGltcG9ydGFudFxuICAgICAgbGlzdERheVNpZGVGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxuICAgIH0sXG5cbiAgICBsaXN0TW9udGg6IHtcbiAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgIGR1cmF0aW9uOiB7IG1vbnRoOiAxIH0sXG4gICAgICBsaXN0RGF5U2lkZUZvcm1hdDogeyB3ZWVrZGF5OiAnbG9uZycgfSwgLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXG4gICAgfSxcblxuICAgIGxpc3RZZWFyOiB7XG4gICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICBkdXJhdGlvbjogeyB5ZWFyOiAxIH0sXG4gICAgICBsaXN0RGF5U2lkZUZvcm1hdDogeyB3ZWVrZGF5OiAnbG9uZycgfSwgLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXG4gICAgfSxcblxuICB9LFxufSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/list/main.js\n");

/***/ }),

/***/ "./node_modules/preact/compat/dist/compat.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/preact/compat/dist/compat.module.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useCallback\": () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useCallback),\n/* harmony export */   \"useContext\": () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useContext),\n/* harmony export */   \"useDebugValue\": () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useDebugValue),\n/* harmony export */   \"useEffect\": () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useEffect),\n/* harmony export */   \"useErrorBoundary\": () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useErrorBoundary),\n/* harmony export */   \"useImperativeHandle\": () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle),\n/* harmony export */   \"useLayoutEffect\": () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect),\n/* harmony export */   \"useMemo\": () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useMemo),\n/* harmony export */   \"useReducer\": () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useReducer),\n/* harmony export */   \"useRef\": () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useRef),\n/* harmony export */   \"useState\": () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useState),\n/* harmony export */   \"createElement\": () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_1__.createElement),\n/* harmony export */   \"createContext\": () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_1__.createContext),\n/* harmony export */   \"createRef\": () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_1__.createRef),\n/* harmony export */   \"Fragment\": () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_1__.Fragment),\n/* harmony export */   \"Component\": () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_1__.Component),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"version\": () => (/* binding */ B),\n/* harmony export */   \"Children\": () => (/* binding */ R),\n/* harmony export */   \"render\": () => (/* binding */ T),\n/* harmony export */   \"hydrate\": () => (/* binding */ V),\n/* harmony export */   \"unmountComponentAtNode\": () => (/* binding */ Q),\n/* harmony export */   \"createPortal\": () => (/* binding */ z),\n/* harmony export */   \"createFactory\": () => (/* binding */ G),\n/* harmony export */   \"cloneElement\": () => (/* binding */ K),\n/* harmony export */   \"isValidElement\": () => (/* binding */ J),\n/* harmony export */   \"findDOMNode\": () => (/* binding */ X),\n/* harmony export */   \"PureComponent\": () => (/* binding */ C),\n/* harmony export */   \"memo\": () => (/* binding */ _),\n/* harmony export */   \"forwardRef\": () => (/* binding */ S),\n/* harmony export */   \"unstable_batchedUpdates\": () => (/* binding */ Y),\n/* harmony export */   \"Suspense\": () => (/* binding */ U),\n/* harmony export */   \"SuspenseList\": () => (/* binding */ O),\n/* harmony export */   \"lazy\": () => (/* binding */ L)\n/* harmony export */ });\n/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact/hooks */ \"./node_modules/preact/hooks/dist/hooks.module.js\");\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n\n\n\n\n\nfunction E(n, t) {\n  for (var e in t) n[e] = t[e];\n\n  return n;\n}\n\nfunction w(n, t) {\n  for (var e in n) if (\"__source\" !== e && !(e in t)) return !0;\n\n  for (var r in t) if (\"__source\" !== r && n[r] !== t[r]) return !0;\n\n  return !1;\n}\n\nvar C = function (n) {\n  var t, e;\n\n  function r(t) {\n    var e;\n    return (e = n.call(this, t) || this).isPureReactComponent = !0, e;\n  }\n\n  return e = n, (t = r).prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e, r.prototype.shouldComponentUpdate = function (n, t) {\n    return w(this.props, n) || w(this.state, t);\n  }, r;\n}(preact__WEBPACK_IMPORTED_MODULE_1__.Component);\n\nfunction _(n, t) {\n  function e(n) {\n    var e = this.props.ref,\n        r = e == n.ref;\n    return !r && e && (e.call ? e(null) : e.current = null), t ? !t(this.props, n) || !r : w(this.props, n);\n  }\n\n  function r(t) {\n    return this.shouldComponentUpdate = e, (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(n, E({}, t));\n  }\n\n  return r.prototype.isReactComponent = !0, r.displayName = \"Memo(\" + (n.displayName || n.name) + \")\", r.t = !0, r;\n}\n\nvar A = preact__WEBPACK_IMPORTED_MODULE_1__.options.__b;\n\nfunction S(n) {\n  function t(t) {\n    var e = E({}, t);\n    return delete e.ref, n(e, t.ref);\n  }\n\n  return t.prototype.isReactComponent = t.t = !0, t.displayName = \"ForwardRef(\" + (n.displayName || n.name) + \")\", t;\n}\n\npreact__WEBPACK_IMPORTED_MODULE_1__.options.__b = function (n) {\n  n.type && n.type.t && n.ref && (n.props.ref = n.ref, n.ref = null), A && A(n);\n};\n\nvar k = function (n, t) {\n  return n ? (0,preact__WEBPACK_IMPORTED_MODULE_1__.toChildArray)(n).reduce(function (n, e, r) {\n    return n.concat(t(e, r));\n  }, []) : null;\n},\n    R = {\n  map: k,\n  forEach: k,\n  count: function (n) {\n    return n ? (0,preact__WEBPACK_IMPORTED_MODULE_1__.toChildArray)(n).length : 0;\n  },\n  only: function (n) {\n    if (1 !== (n = (0,preact__WEBPACK_IMPORTED_MODULE_1__.toChildArray)(n)).length) throw new Error(\"Children.only() expects only one child.\");\n    return n[0];\n  },\n  toArray: preact__WEBPACK_IMPORTED_MODULE_1__.toChildArray\n},\n    F = preact__WEBPACK_IMPORTED_MODULE_1__.options.__e;\n\nfunction N(n) {\n  return n && ((n = E({}, n)).__c = null, n.__k = n.__k && n.__k.map(N)), n;\n}\n\nfunction U() {\n  this.__u = 0, this.o = null, this.__b = null;\n}\n\nfunction M(n) {\n  var t = n.__.__c;\n  return t && t.u && t.u(n);\n}\n\nfunction L(n) {\n  var t, e, r;\n\n  function o(o) {\n    if (t || (t = n()).then(function (n) {\n      e = n.default || n;\n    }, function (n) {\n      r = n;\n    }), r) throw r;\n    if (!e) throw t;\n    return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(e, o);\n  }\n\n  return o.displayName = \"Lazy\", o.t = !0, o;\n}\n\nfunction O() {\n  this.i = null, this.l = null;\n}\n\npreact__WEBPACK_IMPORTED_MODULE_1__.options.__e = function (n, t, e) {\n  if (n.then) for (var r, o = t; o = o.__;) if ((r = o.__c) && r.__c) return r.__c(n, t.__c);\n  F(n, t, e);\n}, (U.prototype = new preact__WEBPACK_IMPORTED_MODULE_1__.Component()).__c = function (n, t) {\n  var e = this;\n  null == e.o && (e.o = []), e.o.push(t);\n\n  var r = M(e.__v),\n      o = !1,\n      u = function () {\n    o || (o = !0, r ? r(i) : i());\n  };\n\n  t.__c = t.componentWillUnmount, t.componentWillUnmount = function () {\n    u(), t.__c && t.__c();\n  };\n\n  var i = function () {\n    var n;\n    if (! --e.__u) for (e.__v.__k[0] = e.state.u, e.setState({\n      u: e.__b = null\n    }); n = e.o.pop();) n.forceUpdate();\n  };\n\n  e.__u++ || e.setState({\n    u: e.__b = e.__v.__k[0]\n  }), n.then(u, u);\n}, U.prototype.render = function (n, t) {\n  return this.__b && (this.__v.__k[0] = N(this.__b), this.__b = null), [(0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(preact__WEBPACK_IMPORTED_MODULE_1__.Component, null, t.u ? null : n.children), t.u && n.fallback];\n};\n\nvar P = function (n, t, e) {\n  if (++e[1] === e[0] && n.l.delete(t), n.props.revealOrder && (\"t\" !== n.props.revealOrder[0] || !n.l.size)) for (e = n.i; e;) {\n    for (; e.length > 3;) e.pop()();\n\n    if (e[1] < e[0]) break;\n    n.i = e = e[2];\n  }\n};\n\n(O.prototype = new preact__WEBPACK_IMPORTED_MODULE_1__.Component()).u = function (n) {\n  var t = this,\n      e = M(t.__v),\n      r = t.l.get(n);\n  return r[0]++, function (o) {\n    var u = function () {\n      t.props.revealOrder ? (r.push(o), P(t, n, r)) : o();\n    };\n\n    e ? e(u) : u();\n  };\n}, O.prototype.render = function (n) {\n  this.i = null, this.l = new Map();\n  var t = (0,preact__WEBPACK_IMPORTED_MODULE_1__.toChildArray)(n.children);\n  n.revealOrder && \"b\" === n.revealOrder[0] && t.reverse();\n\n  for (var e = t.length; e--;) this.l.set(t[e], this.i = [1, 0, this.i]);\n\n  return n.children;\n}, O.prototype.componentDidUpdate = O.prototype.componentDidMount = function () {\n  var n = this;\n  n.l.forEach(function (t, e) {\n    P(n, e, t);\n  });\n};\n\nvar W = function () {\n  function n() {}\n\n  var t = n.prototype;\n  return t.getChildContext = function () {\n    return this.props.context;\n  }, t.render = function (n) {\n    return n.children;\n  }, n;\n}();\n\nfunction j(n) {\n  var t = this,\n      e = n.container,\n      r = (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(W, {\n    context: t.context\n  }, n.vnode);\n  return t.s && t.s !== e && (t.v.parentNode && t.s.removeChild(t.v), (0,preact__WEBPACK_IMPORTED_MODULE_1__._unmount)(t.h), t.p = !1), n.vnode ? t.p ? (e.__k = t.__k, (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)(r, e), t.__k = e.__k) : (t.v = document.createTextNode(\"\"), (0,preact__WEBPACK_IMPORTED_MODULE_1__.hydrate)(\"\", e), e.appendChild(t.v), t.p = !0, t.s = e, (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)(r, e, t.v), t.__k = t.v.__k) : t.p && (t.v.parentNode && t.s.removeChild(t.v), (0,preact__WEBPACK_IMPORTED_MODULE_1__._unmount)(t.h)), t.h = r, t.componentWillUnmount = function () {\n    t.v.parentNode && t.s.removeChild(t.v), (0,preact__WEBPACK_IMPORTED_MODULE_1__._unmount)(t.h);\n  }, null;\n}\n\nfunction z(n, t) {\n  return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(j, {\n    vnode: n,\n    container: t\n  });\n}\n\nvar D = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\npreact__WEBPACK_IMPORTED_MODULE_1__.Component.prototype.isReactComponent = {};\nvar H = \"undefined\" != typeof Symbol && Symbol.for && Symbol.for(\"react.element\") || 60103;\n\nfunction T(n, t, e) {\n  if (null == t.__k) for (; t.firstChild;) t.removeChild(t.firstChild);\n  return (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)(n, t), \"function\" == typeof e && e(), n ? n.__c : null;\n}\n\nfunction V(n, t, e) {\n  return (0,preact__WEBPACK_IMPORTED_MODULE_1__.hydrate)(n, t), \"function\" == typeof e && e(), n ? n.__c : null;\n}\n\nvar Z = preact__WEBPACK_IMPORTED_MODULE_1__.options.event;\n\nfunction I(n, t) {\n  n[\"UNSAFE_\" + t] && !n[t] && Object.defineProperty(n, t, {\n    configurable: !1,\n    get: function () {\n      return this[\"UNSAFE_\" + t];\n    },\n    set: function (n) {\n      this[\"UNSAFE_\" + t] = n;\n    }\n  });\n}\n\npreact__WEBPACK_IMPORTED_MODULE_1__.options.event = function (n) {\n  Z && (n = Z(n)), n.persist = function () {};\n  var t = !1,\n      e = !1,\n      r = n.stopPropagation;\n\n  n.stopPropagation = function () {\n    r.call(n), t = !0;\n  };\n\n  var o = n.preventDefault;\n  return n.preventDefault = function () {\n    o.call(n), e = !0;\n  }, n.isPropagationStopped = function () {\n    return t;\n  }, n.isDefaultPrevented = function () {\n    return e;\n  }, n.nativeEvent = n;\n};\n\nvar $ = {\n  configurable: !0,\n  get: function () {\n    return this.class;\n  }\n},\n    q = preact__WEBPACK_IMPORTED_MODULE_1__.options.vnode;\n\npreact__WEBPACK_IMPORTED_MODULE_1__.options.vnode = function (n) {\n  n.$$typeof = H;\n  var t = n.type,\n      e = n.props;\n\n  if (t) {\n    if (e.class != e.className && ($.enumerable = \"className\" in e, null != e.className && (e.class = e.className), Object.defineProperty(e, \"className\", $)), \"function\" != typeof t) {\n      var r, o, u;\n\n      for (u in e.defaultValue && void 0 !== e.value && (e.value || 0 === e.value || (e.value = e.defaultValue), delete e.defaultValue), Array.isArray(e.value) && e.multiple && \"select\" === t && ((0,preact__WEBPACK_IMPORTED_MODULE_1__.toChildArray)(e.children).forEach(function (n) {\n        -1 != e.value.indexOf(n.props.value) && (n.props.selected = !0);\n      }), delete e.value), e) if (r = D.test(u)) break;\n\n      if (r) for (u in o = n.props = {}, e) o[D.test(u) ? u.replace(/[A-Z0-9]/, \"-$&\").toLowerCase() : u] = e[u];\n    }\n\n    !function (t) {\n      var e = n.type,\n          r = n.props;\n\n      if (r && \"string\" == typeof e) {\n        var o = {};\n\n        for (var u in r) /^on(Ani|Tra|Tou)/.test(u) && (r[u.toLowerCase()] = r[u], delete r[u]), o[u.toLowerCase()] = u;\n\n        if (o.ondoubleclick && (r.ondblclick = r[o.ondoubleclick], delete r[o.ondoubleclick]), o.onbeforeinput && (r.onbeforeinput = r[o.onbeforeinput], delete r[o.onbeforeinput]), o.onchange && (\"textarea\" === e || \"input\" === e.toLowerCase() && !/^fil|che|ra/i.test(r.type))) {\n          var i = o.oninput || \"oninput\";\n          r[i] || (r[i] = r[o.onchange], delete r[o.onchange]);\n        }\n      }\n    }(), \"function\" == typeof t && !t.m && t.prototype && (I(t.prototype, \"componentWillMount\"), I(t.prototype, \"componentWillReceiveProps\"), I(t.prototype, \"componentWillUpdate\"), t.m = !0);\n  }\n\n  q && q(n);\n};\n\nvar B = \"16.8.0\";\n\nfunction G(n) {\n  return preact__WEBPACK_IMPORTED_MODULE_1__.createElement.bind(null, n);\n}\n\nfunction J(n) {\n  return !!n && n.$$typeof === H;\n}\n\nfunction K(n) {\n  return J(n) ? preact__WEBPACK_IMPORTED_MODULE_1__.cloneElement.apply(null, arguments) : n;\n}\n\nfunction Q(n) {\n  return !!n.__k && ((0,preact__WEBPACK_IMPORTED_MODULE_1__.render)(null, n), !0);\n}\n\nfunction X(n) {\n  return n && (n.base || 1 === n.nodeType && n) || null;\n}\n\nvar Y = function (n, t) {\n  return n(t);\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  useState: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useState,\n  useReducer: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useReducer,\n  useEffect: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n  useLayoutEffect: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect,\n  useRef: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useRef,\n  useImperativeHandle: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle,\n  useMemo: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n  useCallback: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n  useContext: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useContext,\n  useDebugValue: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useDebugValue,\n  version: \"16.8.0\",\n  Children: R,\n  render: T,\n  hydrate: T,\n  unmountComponentAtNode: Q,\n  createPortal: z,\n  createElement: preact__WEBPACK_IMPORTED_MODULE_1__.createElement,\n  createContext: preact__WEBPACK_IMPORTED_MODULE_1__.createContext,\n  createFactory: G,\n  cloneElement: K,\n  createRef: preact__WEBPACK_IMPORTED_MODULE_1__.createRef,\n  Fragment: preact__WEBPACK_IMPORTED_MODULE_1__.Fragment,\n  isValidElement: J,\n  findDOMNode: X,\n  Component: preact__WEBPACK_IMPORTED_MODULE_1__.Component,\n  PureComponent: C,\n  memo: _,\n  forwardRef: S,\n  unstable_batchedUpdates: Y,\n  Suspense: U,\n  SuspenseList: O,\n  lazy: L\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9kaXN0L2NvbXBhdC5tb2R1bGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPQTtBQUFBOztBQUNBO0FBVUE7O0FBQUE7QUFBQTs7QUFDQTs7QUFDQTtBQUNBOztBQUFBO0FDZkE7O0FBQUE7QUFDQTtBQUFBO0FBR0E7O0FBQUE7QUFHQTtBQUVBO0FBVEE7O0FDSUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQU1BOztBQUFBO0FBTUE7QUFFQTs7QUFBQTtBQ3hCQTs7QUFBQTs7QUFnQkE7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7QUFBQTtBQW5CQTs7QUFBQTtBQUNBO0FBSUE7O0FBQUE7QUNQQTtBQUdBO0FBQUE7QUFGQTtBRE1BO0FDR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFHQTtBQUVBO0FBRUE7QUFiQTtBREZBOztBRVdBO0FBQUE7QUFVQTs7QUFBQTtBQUFBO0FBaUdBOztBQUFBO0FBQUE7QUFDQTtBQUlBOztBQUFBO0FBQUE7O0FBR0E7QUFFQTtBQUtBO0FBQUE7QUFHQTtBQUFBO0FBTUE7QUFJQTtBQUdBOztBQUFBO0FDckpBOztBQUFBO0FBQUE7QURMQTs7QUFBQTtBQUFBO0FBYUE7QUFBQTtBQTZCQTtBQUlBOztBQUdBO0FBQUE7QUFBQTtBQU1BO0FBT0E7O0FBSUE7QUFHQTtBQUdBOztBQUFBO0FBSUE7QUFLQTtBQUZBO0FBQUE7QUFJQTs7QUFLQTtBQUNBO0FBQUE7QUFFQTtBQUdBO0FBUUE7O0FDeEZBO0FBQUE7QUF5QkE7O0FBRUE7QUFLQTtBQTVDQTtBQUFBOztBQUFBO0FBcURBO0FBQUE7QUFBQTtBQUlBO0FBR0E7QUFFQTtBQUdBOztBQU1BO0FBR0E7QUFBQTtBQUtBO0FBRUE7QUFHQTs7QUFJQTs7QUFnQkE7QUFFQTtBQUdBO0FBUUE7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUMxSEE7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7O0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFpREE7QUFDQTtBQVdBOztBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUMxRUE7O0FBQUE7QUFHQTtBQUVBOztBQVdBO0FBQUE7QUFLQTtBQVVBOztBQUFBO0FBQUE7QUFPQTs7QUFBQTs7QUF5QkE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFBQTtBQUNBO0FBVkE7QUExQkE7O0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFLQTtBQUNBO0FBQ0E7O0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOztBQXNCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSEE7QUFBQTs7QUFRQTtBQUNBO0FBQUE7QUFBQTs7QUFHQTtBQUVBO0FBU0E7O0FBb0JBO0FBVEE7QUFFQTs7QUFRQTtBQU1BOztBQUFBO0FDeElBO0FBQUE7O0FBQUE7QUFDQTs7QUFDQTs7QUFPQTtBQWVBO0FBRUE7QUFFQTtBQUFBO0FEa0hBO0FBa0JBOztBQUFBO0FBQUE7O0FBQUE7O0FFaElBO0FBQUE7QUFTQTs7QUFBQTtBQUFBO0FBV0E7O0FBQUE7QUFBQTtBQVVBOztBQUFBO0FBQUE7QUFhQTs7QUFBQTtBQUFBO0FBZ0JBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaENBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWwuanM/NDIyOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvUHVyZUNvbXBvbmVudC5qcz9kZTlmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9tZW1vLmpzPzY0OTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2ZvcndhcmRSZWYuanM/MDdhOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvQ2hpbGRyZW4uanM/ZjAxZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvc3VzcGVuc2UuanM/MTQ0ZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvc3VzcGVuc2UtbGlzdC5qcz8wZGUzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9wb3J0YWxzLmpzPzQ2M2UiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlbmRlci5qcz81MGZmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9ldmVudHMuanM/Y2U5OCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5kZXguanM/YTE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG9iamVjdHMgaGF2ZSBhIGRpZmZlcmVudCBzaGFwZVxuICogQHBhcmFtIHtvYmplY3R9IGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dEaWZmZXJzKGEsIGIpIHtcblx0Zm9yIChsZXQgaSBpbiBhKSBpZiAoaSAhPT0gJ19fc291cmNlJyAmJiAhKGkgaW4gYikpIHJldHVybiB0cnVlO1xuXHRmb3IgKGxldCBpIGluIGIpIGlmIChpICE9PSAnX19zb3VyY2UnICYmIGFbaV0gIT09IGJbaV0pIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0RpZmZlcnMgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIENvbXBvbmVudCBjbGFzcyB3aXRoIGEgcHJlZGVmaW5lZCBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCBpbXBsZW1lbnRhdGlvblxuICovXG5leHBvcnQgY2xhc3MgUHVyZUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXHRcdC8vIFNvbWUgdGhpcmQtcGFydHkgbGlicmFyaWVzIGNoZWNrIGlmIHRoaXMgcHJvcGVydHkgaXMgcHJlc2VudFxuXHRcdHRoaXMuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXHR9XG5cblx0c2hvdWxkQ29tcG9uZW50VXBkYXRlKHByb3BzLCBzdGF0ZSkge1xuXHRcdHJldHVybiAoXG5cdFx0XHRzaGFsbG93RGlmZmVycyh0aGlzLnByb3BzLCBwcm9wcykgfHwgc2hhbGxvd0RpZmZlcnModGhpcy5zdGF0ZSwgc3RhdGUpXG5cdFx0KTtcblx0fVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzaGFsbG93RGlmZmVycywgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBNZW1vaXplIGEgY29tcG9uZW50LCBzbyB0aGF0IGl0IG9ubHkgdXBkYXRlcyB3aGVuIHRoZSBwcm9wcyBhY3R1YWxseSBoYXZlXG4gKiBjaGFuZ2VkLiBUaGlzIHdhcyBwcmV2aW91c2x5IGtub3duIGFzIGBSZWFjdC5wdXJlYC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25hbENvbXBvbmVudH0gYyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICogQHBhcmFtIHsocHJldjogb2JqZWN0LCBuZXh0OiBvYmplY3QpID0+IGJvb2xlYW59IFtjb21wYXJlcl0gQ3VzdG9tIGVxdWFsaXR5IGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25hbENvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW8oYywgY29tcGFyZXIpIHtcblx0ZnVuY3Rpb24gc2hvdWxkVXBkYXRlKG5leHRQcm9wcykge1xuXHRcdGxldCByZWYgPSB0aGlzLnByb3BzLnJlZjtcblx0XHRsZXQgdXBkYXRlUmVmID0gcmVmID09IG5leHRQcm9wcy5yZWY7XG5cdFx0aWYgKCF1cGRhdGVSZWYgJiYgcmVmKSB7XG5cdFx0XHRyZWYuY2FsbCA/IHJlZihudWxsKSA6IChyZWYuY3VycmVudCA9IG51bGwpO1xuXHRcdH1cblxuXHRcdGlmICghY29tcGFyZXIpIHtcblx0XHRcdHJldHVybiBzaGFsbG93RGlmZmVycyh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiAhY29tcGFyZXIodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fCAhdXBkYXRlUmVmO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWVtb2VkKHByb3BzKSB7XG5cdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBzaG91bGRVcGRhdGU7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoYywgYXNzaWduKHt9LCBwcm9wcykpO1xuXHR9XG5cdE1lbW9lZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cdE1lbW9lZC5kaXNwbGF5TmFtZSA9ICdNZW1vKCcgKyAoYy5kaXNwbGF5TmFtZSB8fCBjLm5hbWUpICsgJyknO1xuXHRNZW1vZWQuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBNZW1vZWQ7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmxldCBvbGREaWZmSG9vayA9IG9wdGlvbnMuX2RpZmY7XG5vcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRpZiAodm5vZGUudHlwZSAmJiB2bm9kZS50eXBlLl9mb3J3YXJkZWQgJiYgdm5vZGUucmVmKSB7XG5cdFx0dm5vZGUucHJvcHMucmVmID0gdm5vZGUucmVmO1xuXHRcdHZub2RlLnJlZiA9IG51bGw7XG5cdH1cblx0aWYgKG9sZERpZmZIb29rKSBvbGREaWZmSG9vayh2bm9kZSk7XG59O1xuXG4vKipcbiAqIFBhc3MgcmVmIGRvd24gdG8gYSBjaGlsZC4gVGhpcyBpcyBtYWlubHkgdXNlZCBpbiBsaWJyYXJpZXMgd2l0aCBIT0NzIHRoYXRcbiAqIHdyYXAgY29tcG9uZW50cy4gVXNpbmcgYGZvcndhcmRSZWZgIHRoZXJlIGlzIGFuIGVhc3kgd2F5IHRvIGdldCBhIHJlZmVyZW5jZVxuICogb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50IGluc3RlYWQgb2Ygb25lIG9mIHRoZSB3cmFwcGVyIGl0c2VsZi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuRm9yd2FyZEZufSBmblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uYWxDb21wb25lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkUmVmKGZuKSB7XG5cdGZ1bmN0aW9uIEZvcndhcmRlZChwcm9wcykge1xuXHRcdGxldCBjbG9uZSA9IGFzc2lnbih7fSwgcHJvcHMpO1xuXHRcdGRlbGV0ZSBjbG9uZS5yZWY7XG5cdFx0cmV0dXJuIGZuKGNsb25lLCBwcm9wcy5yZWYpO1xuXHR9XG5cdEZvcndhcmRlZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IEZvcndhcmRlZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0Rm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gJ0ZvcndhcmRSZWYoJyArIChmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lKSArICcpJztcblx0cmV0dXJuIEZvcndhcmRlZDtcbn1cbiIsImltcG9ydCB7IHRvQ2hpbGRBcnJheSB9IGZyb20gJ3ByZWFjdCc7XG5cbmNvbnN0IG1hcEZuID0gKGNoaWxkcmVuLCBmbikgPT4ge1xuXHRpZiAoIWNoaWxkcmVuKSByZXR1cm4gbnVsbDtcblx0cmV0dXJuIHRvQ2hpbGRBcnJheShjaGlsZHJlbikucmVkdWNlKFxuXHRcdChhY2MsIHZhbHVlLCBpbmRleCkgPT4gYWNjLmNvbmNhdChmbih2YWx1ZSwgaW5kZXgpKSxcblx0XHRbXVxuXHQpO1xufTtcblxuLy8gVGhpcyBBUEkgaXMgY29tcGxldGVseSB1bm5lY2Vzc2FyeSBmb3IgUHJlYWN0LCBzbyBpdCdzIGJhc2ljYWxseSBwYXNzdGhyb3VnaC5cbmV4cG9ydCBjb25zdCBDaGlsZHJlbiA9IHtcblx0bWFwOiBtYXBGbixcblx0Zm9yRWFjaDogbWFwRm4sXG5cdGNvdW50KGNoaWxkcmVuKSB7XG5cdFx0cmV0dXJuIGNoaWxkcmVuID8gdG9DaGlsZEFycmF5KGNoaWxkcmVuKS5sZW5ndGggOiAwO1xuXHR9LFxuXHRvbmx5KGNoaWxkcmVuKSB7XG5cdFx0Y2hpbGRyZW4gPSB0b0NoaWxkQXJyYXkoY2hpbGRyZW4pO1xuXHRcdGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDEpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2hpbGRyZW4ub25seSgpIGV4cGVjdHMgb25seSBvbmUgY2hpbGQuJyk7XG5cdFx0fVxuXHRcdHJldHVybiBjaGlsZHJlblswXTtcblx0fSxcblx0dG9BcnJheTogdG9DaGlsZEFycmF5XG59O1xuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IG9sZENhdGNoRXJyb3IgPSBvcHRpb25zLl9jYXRjaEVycm9yO1xub3B0aW9ucy5fY2F0Y2hFcnJvciA9IGZ1bmN0aW9uKGVycm9yLCBuZXdWTm9kZSwgb2xkVk5vZGUpIHtcblx0aWYgKGVycm9yLnRoZW4pIHtcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0XHRsZXQgY29tcG9uZW50O1xuXHRcdGxldCB2bm9kZSA9IG5ld1ZOb2RlO1xuXG5cdFx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRcdGlmICgoY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudCkgJiYgY29tcG9uZW50Ll9jaGlsZERpZFN1c3BlbmQpIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY2FsbCBvbGRDYXRjaEVycm9yIGlmIHdlIGZvdW5kIGEgU3VzcGVuc2Vcblx0XHRcdFx0cmV0dXJuIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKGVycm9yLCBuZXdWTm9kZS5fY29tcG9uZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0b2xkQ2F0Y2hFcnJvcihlcnJvciwgbmV3Vk5vZGUsIG9sZFZOb2RlKTtcbn07XG5cbmZ1bmN0aW9uIGRldGFjaGVkQ2xvbmUodm5vZGUpIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0dm5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHR2bm9kZS5fY29tcG9uZW50ID0gbnVsbDtcblx0XHR2bm9kZS5fY2hpbGRyZW4gPSB2bm9kZS5fY2hpbGRyZW4gJiYgdm5vZGUuX2NoaWxkcmVuLm1hcChkZXRhY2hlZENsb25lKTtcblx0fVxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbi8vIGhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXNcbmV4cG9ydCBmdW5jdGlvbiBTdXNwZW5zZSgpIHtcblx0Ly8gd2UgZG8gbm90IGNhbGwgc3VwZXIgaGVyZSB0byBnb2xmIHNvbWUgYnl0ZXMuLi5cblx0dGhpcy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCA9IDA7XG5cdHRoaXMuX3N1c3BlbmRlcnMgPSBudWxsO1xuXHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsO1xufVxuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8qKlxuICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlIFRoZSB0aHJvd24gcHJvbWlzZVxuICogQHBhcmFtIHtDb21wb25lbnQ8YW55LCBhbnk+fSBzdXNwZW5kaW5nQ29tcG9uZW50IFRoZSBzdXNwZW5kaW5nIGNvbXBvbmVudFxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUuX2NoaWxkRGlkU3VzcGVuZCA9IGZ1bmN0aW9uKHByb21pc2UsIHN1c3BlbmRpbmdDb21wb25lbnQpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH0gKi9cblx0Y29uc3QgYyA9IHRoaXM7XG5cblx0aWYgKGMuX3N1c3BlbmRlcnMgPT0gbnVsbCkge1xuXHRcdGMuX3N1c3BlbmRlcnMgPSBbXTtcblx0fVxuXHRjLl9zdXNwZW5kZXJzLnB1c2goc3VzcGVuZGluZ0NvbXBvbmVudCk7XG5cblx0Y29uc3QgcmVzb2x2ZSA9IHN1c3BlbmRlZChjLl92bm9kZSk7XG5cblx0bGV0IHJlc29sdmVkID0gZmFsc2U7XG5cdGNvbnN0IG9uUmVzb2x2ZWQgPSAoKSA9PiB7XG5cdFx0aWYgKHJlc29sdmVkKSByZXR1cm47XG5cblx0XHRyZXNvbHZlZCA9IHRydWU7XG5cblx0XHRpZiAocmVzb2x2ZSkge1xuXHRcdFx0cmVzb2x2ZShvblN1c3BlbnNpb25Db21wbGV0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9uU3VzcGVuc2lvbkNvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdHN1c3BlbmRpbmdDb21wb25lbnQuX3N1c3BlbmRlZENvbXBvbmVudFdpbGxVbm1vdW50ID1cblx0XHRzdXNwZW5kaW5nQ29tcG9uZW50LmNvbXBvbmVudFdpbGxVbm1vdW50O1xuXHRzdXNwZW5kaW5nQ29tcG9uZW50LmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuXHRcdG9uUmVzb2x2ZWQoKTtcblxuXHRcdGlmIChzdXNwZW5kaW5nQ29tcG9uZW50Ll9zdXNwZW5kZWRDb21wb25lbnRXaWxsVW5tb3VudCkge1xuXHRcdFx0c3VzcGVuZGluZ0NvbXBvbmVudC5fc3VzcGVuZGVkQ29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3Qgb25TdXNwZW5zaW9uQ29tcGxldGUgPSAoKSA9PiB7XG5cdFx0aWYgKCEtLWMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQpIHtcblx0XHRcdGMuX3Zub2RlLl9jaGlsZHJlblswXSA9IGMuc3RhdGUuX3N1c3BlbmRlZDtcblx0XHRcdGMuc2V0U3RhdGUoeyBfc3VzcGVuZGVkOiAoYy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbCkgfSk7XG5cblx0XHRcdGxldCBzdXNwZW5kZWQ7XG5cdFx0XHR3aGlsZSAoKHN1c3BlbmRlZCA9IGMuX3N1c3BlbmRlcnMucG9wKCkpKSB7XG5cdFx0XHRcdHN1c3BlbmRlZC5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRpZiAoIWMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQrKykge1xuXHRcdGMuc2V0U3RhdGUoeyBfc3VzcGVuZGVkOiAoYy5fZGV0YWNoT25OZXh0UmVuZGVyID0gYy5fdm5vZGUuX2NoaWxkcmVuWzBdKSB9KTtcblx0fVxuXHRwcm9taXNlLnRoZW4ob25SZXNvbHZlZCwgb25SZXNvbHZlZCk7XG59O1xuXG5TdXNwZW5zZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocHJvcHMsIHN0YXRlKSB7XG5cdGlmICh0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIpIHtcblx0XHR0aGlzLl92bm9kZS5fY2hpbGRyZW5bMF0gPSBkZXRhY2hlZENsb25lKHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlcik7XG5cdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbDtcblx0fVxuXG5cdHJldHVybiBbXG5cdFx0Y3JlYXRlRWxlbWVudChDb21wb25lbnQsIG51bGwsIHN0YXRlLl9zdXNwZW5kZWQgPyBudWxsIDogcHJvcHMuY2hpbGRyZW4pLFxuXHRcdHN0YXRlLl9zdXNwZW5kZWQgJiYgcHJvcHMuZmFsbGJhY2tcblx0XTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGFuZCBjYWxscyB0aGUgcGFyZW50IGNvbXBvbmVudCdzIF9zdXNwZW5kZWQgbWV0aG9kLCBwYXNzaW5nIGluIHRoZVxuICogc3VzcGVuZGVkIHZub2RlLiBUaGlzIGlzIGEgd2F5IGZvciBhIHBhcmVudCAoZS5nLiBTdXNwZW5zZUxpc3QpIHRvIGdldCBub3RpZmllZFxuICogdGhhdCBvbmUgb2YgaXRzIGNoaWxkcmVuL2Rlc2NlbmRhbnRzIHN1c3BlbmRlZC5cbiAqXG4gKiBUaGUgcGFyZW50IE1BWSByZXR1cm4gYSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIHdpbGwgZ2V0IGNhbGxlZCB3aGVuIHRoZVxuICogc3VzcGVuc2lvbiByZXNvbHZlcywgbm90aWZ5aW5nIHRoZSBwYXJlbnQgb2YgdGhlIGZhY3QuXG4gKiBNb3Jlb3ZlciwgdGhlIGNhbGxiYWNrIGdldHMgZnVuY3Rpb24gYHVuc3VzcGVuZGAgYXMgYSBwYXJhbWV0ZXIuIFRoZSByZXNvbHZlZFxuICogY2hpbGQgZGVzY2VuZGFudCB3aWxsIG5vdCBhY3R1YWxseSBnZXQgdW5zdXNwZW5kZWQgdW50aWwgYHVuc3VzcGVuZGAgZ2V0cyBjYWxsZWQuXG4gKiBUaGlzIGlzIGEgd2F5IGZvciB0aGUgcGFyZW50IHRvIGRlbGF5IHVuc3VzcGVuZGluZy5cbiAqXG4gKiBJZiB0aGUgcGFyZW50IGRvZXMgbm90IHJldHVybiBhIGNhbGxiYWNrIHRoZW4gdGhlIHJlc29sdmVkIHZub2RlXG4gKiBnZXRzIHVuc3VzcGVuZGVkIGltbWVkaWF0ZWx5IHdoZW4gaXQgcmVzb2x2ZXMuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3NyYy9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMgeygodW5zdXNwZW5kOiAoKSA9PiB2b2lkKSA9PiB2b2lkKT99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXNwZW5kZWQodm5vZGUpIHtcblx0bGV0IGNvbXBvbmVudCA9IHZub2RlLl9wYXJlbnQuX2NvbXBvbmVudDtcblx0cmV0dXJuIGNvbXBvbmVudCAmJiBjb21wb25lbnQuX3N1c3BlbmRlZCAmJiBjb21wb25lbnQuX3N1c3BlbmRlZCh2bm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXp5KGxvYWRlcikge1xuXHRsZXQgcHJvbTtcblx0bGV0IGNvbXBvbmVudDtcblx0bGV0IGVycm9yO1xuXG5cdGZ1bmN0aW9uIExhenkocHJvcHMpIHtcblx0XHRpZiAoIXByb20pIHtcblx0XHRcdHByb20gPSBsb2FkZXIoKTtcblx0XHRcdHByb20udGhlbihcblx0XHRcdFx0ZXhwb3J0cyA9PiB7XG5cdFx0XHRcdFx0Y29tcG9uZW50ID0gZXhwb3J0cy5kZWZhdWx0IHx8IGV4cG9ydHM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGUgPT4ge1xuXHRcdFx0XHRcdGVycm9yID0gZTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdGlmICghY29tcG9uZW50KSB7XG5cdFx0XHR0aHJvdyBwcm9tO1xuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpO1xuXHR9XG5cblx0TGF6eS5kaXNwbGF5TmFtZSA9ICdMYXp5Jztcblx0TGF6eS5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIExhenk7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIHRvQ2hpbGRBcnJheSB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzdXNwZW5kZWQgfSBmcm9tICcuL3N1c3BlbnNlLmpzJztcblxuLy8gSW5kZXhlcyB0byBsaW5rZWQgbGlzdCBub2RlcyAobm9kZXMgYXJlIHN0b3JlZCBhcyBhcnJheXMgdG8gc2F2ZSBieXRlcykuXG5jb25zdCBTVVNQRU5ERURfQ09VTlQgPSAwO1xuY29uc3QgUkVTT0xWRURfQ09VTlQgPSAxO1xuY29uc3QgTkVYVF9OT0RFID0gMjtcblxuLy8gSGF2aW5nIGN1c3RvbSBpbmhlcml0YW5jZSBpbnN0ZWFkIG9mIGEgY2xhc3MgaGVyZSBzYXZlcyBhIGxvdCBvZiBieXRlcy5cbmV4cG9ydCBmdW5jdGlvbiBTdXNwZW5zZUxpc3QoKSB7XG5cdHRoaXMuX25leHQgPSBudWxsO1xuXHR0aGlzLl9tYXAgPSBudWxsO1xufVxuXG4vLyBNYXJrIG9uZSBvZiBjaGlsZCdzIGVhcmxpZXIgc3VzcGVuc2lvbnMgYXMgcmVzb2x2ZWQuXG4vLyBTb21lIHBlbmRpbmcgY2FsbGJhY2tzIG1heSBiZWNvbWUgY2FsbGFibGUgZHVlIHRvIHRoaXNcbi8vIChlLmcuIHRoZSBsYXN0IHN1c3BlbmRlZCBkZXNjZW5kYW50IGdldHMgcmVzb2x2ZWQgd2hlblxuLy8gcmV2ZWFsT3JkZXIgPT09ICd0b2dldGhlcicpLiBQcm9jZXNzIHRob3NlIGNhbGxiYWNrcyBhcyB3ZWxsLlxuY29uc3QgcmVzb2x2ZSA9IChsaXN0LCBjaGlsZCwgbm9kZSkgPT4ge1xuXHRpZiAoKytub2RlW1JFU09MVkVEX0NPVU5UXSA9PT0gbm9kZVtTVVNQRU5ERURfQ09VTlRdKSB7XG5cdFx0Ly8gVGhlIG51bWJlciBhIGNoaWxkIChvciBhbnkgb2YgaXRzIGRlc2NlbmRhbnRzKSBoYXMgYmVlbiBzdXNwZW5kZWRcblx0XHQvLyBtYXRjaGVzIHRoZSBudW1iZXIgb2YgdGltZXMgaXQncyBiZWVuIHJlc29sdmVkLiBUaGVyZWZvcmUgd2Vcblx0XHQvLyBtYXJrIHRoZSBjaGlsZCBhcyBjb21wbGV0ZWx5IHJlc29sdmVkIGJ5IGRlbGV0aW5nIGl0IGZyb20gLl9tYXAuXG5cdFx0Ly8gVGhpcyBpcyB1c2VkIHRvIGZpZ3VyZSBvdXQgd2hlbiAqYWxsKiBjaGlsZHJlbiBoYXZlIGJlZW4gY29tcGxldGVseVxuXHRcdC8vIHJlc29sdmVkIHdoZW4gcmV2ZWFsT3JkZXIgaXMgJ3RvZ2V0aGVyJy5cblx0XHRsaXN0Ll9tYXAuZGVsZXRlKGNoaWxkKTtcblx0fVxuXG5cdC8vIElmIHJldmVhbE9yZGVyIGlzIGZhbHN5IHRoZW4gd2UgY2FuIGRvIGFuIGVhcmx5IGV4aXQsIGFzIHRoZVxuXHQvLyBjYWxsYmFja3Mgd29uJ3QgZ2V0IHF1ZXVlZCBpbiB0aGUgbm9kZSBhbnl3YXkuXG5cdC8vIElmIHJldmVhbE9yZGVyIGlzICd0b2dldGhlcicgdGhlbiBhbHNvIGRvIGFuIGVhcmx5IGV4aXRcblx0Ly8gaWYgYWxsIHN1c3BlbmRlZCBkZXNjZW5kYW50cyBoYXZlIG5vdCB5ZXQgYmVlbiByZXNvbHZlZC5cblx0aWYgKFxuXHRcdCFsaXN0LnByb3BzLnJldmVhbE9yZGVyIHx8XG5cdFx0KGxpc3QucHJvcHMucmV2ZWFsT3JkZXJbMF0gPT09ICd0JyAmJiBsaXN0Ll9tYXAuc2l6ZSlcblx0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gV2FsayB0aGUgY3VycmVudGx5IHN1c3BlbmRlZCBjaGlsZHJlbiBpbiBvcmRlciwgY2FsbGluZyB0aGVpclxuXHQvLyBzdG9yZWQgY2FsbGJhY2tzIG9uIHRoZSB3YXkuIFN0b3AgaWYgd2UgZW5jb3VudGVyIGEgY2hpbGQgdGhhdFxuXHQvLyBoYXMgbm90IGJlZW4gY29tcGxldGVseSByZXNvbHZlZCB5ZXQuXG5cdG5vZGUgPSBsaXN0Ll9uZXh0O1xuXHR3aGlsZSAobm9kZSkge1xuXHRcdHdoaWxlIChub2RlLmxlbmd0aCA+IDMpIHtcblx0XHRcdG5vZGUucG9wKCkoKTtcblx0XHR9XG5cdFx0aWYgKG5vZGVbUkVTT0xWRURfQ09VTlRdIDwgbm9kZVtTVVNQRU5ERURfQ09VTlRdKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0bGlzdC5fbmV4dCA9IG5vZGUgPSBub2RlW05FWFRfTk9ERV07XG5cdH1cbn07XG5cbi8vIFRoaW5ncyB3ZSBkbyBoZXJlIHRvIHNhdmUgc29tZSBieXRlcyBidXQgYXJlIG5vdCBwcm9wZXIgSlMgaW5oZXJpdGFuY2U6XG4vLyAtIGNhbGwgYG5ldyBDb21wb25lbnQoKWAgYXMgdGhlIHByb3RvdHlwZVxuLy8gLSBkbyBub3Qgc2V0IGBTdXNwZW5zZS5wcm90b3R5cGUuY29uc3RydWN0b3JgIHRvIGBTdXNwZW5zZWBcblN1c3BlbnNlTGlzdC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUuX3N1c3BlbmRlZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdGNvbnN0IGxpc3QgPSB0aGlzO1xuXHRjb25zdCBkZWxlZ2F0ZWQgPSBzdXNwZW5kZWQobGlzdC5fdm5vZGUpO1xuXG5cdGxldCBub2RlID0gbGlzdC5fbWFwLmdldChjaGlsZCk7XG5cdG5vZGVbU1VTUEVOREVEX0NPVU5UXSsrO1xuXG5cdHJldHVybiB1bnN1c3BlbmQgPT4ge1xuXHRcdGNvbnN0IHdyYXBwZWRVbnN1c3BlbmQgPSAoKSA9PiB7XG5cdFx0XHRpZiAoIWxpc3QucHJvcHMucmV2ZWFsT3JkZXIpIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRoZSB1bmRlZmluZWQgKGZhbHN5KSByZXZlYWxPcmRlciwgYXMgdGhlcmVcblx0XHRcdFx0Ly8gaXMgbm8gbmVlZCB0byBjb29yZGluYXRlIGEgc3BlY2lmaWMgb3JkZXIgb3IgdW5zdXNwZW5kcy5cblx0XHRcdFx0dW5zdXNwZW5kKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLnB1c2godW5zdXNwZW5kKTtcblx0XHRcdFx0cmVzb2x2ZShsaXN0LCBjaGlsZCwgbm9kZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRpZiAoZGVsZWdhdGVkKSB7XG5cdFx0XHRkZWxlZ2F0ZWQod3JhcHBlZFVuc3VzcGVuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdyYXBwZWRVbnN1c3BlbmQoKTtcblx0XHR9XG5cdH07XG59O1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdHRoaXMuX25leHQgPSBudWxsO1xuXHR0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG5cblx0Y29uc3QgY2hpbGRyZW4gPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pO1xuXHRpZiAocHJvcHMucmV2ZWFsT3JkZXIgJiYgcHJvcHMucmV2ZWFsT3JkZXJbMF0gPT09ICdiJykge1xuXHRcdC8vIElmIG9yZGVyID09PSAnYmFja3dhcmRzJyAob3IsIHdlbGwsIGFueXRoaW5nIHN0YXJ0aW5nIHdpdGggYSAnYicpXG5cdFx0Ly8gdGhlbiBmbGlwIHRoZSBjaGlsZCBsaXN0IGFyb3VuZCBzbyB0aGF0IHRoZSBsYXN0IGNoaWxkIHdpbGwgYmVcblx0XHQvLyB0aGUgZmlyc3QgaW4gdGhlIGxpbmtlZCBsaXN0LlxuXHRcdGNoaWxkcmVuLnJldmVyc2UoKTtcblx0fVxuXHQvLyBCdWlsZCB0aGUgbGlua2VkIGxpc3QuIEl0ZXJhdGUgdGhyb3VnaCB0aGUgY2hpbGRyZW4gaW4gcmV2ZXJzZSBvcmRlclxuXHQvLyBzbyB0aGF0IGBfbmV4dGAgcG9pbnRzIHRvIHRoZSBmaXJzdCBsaW5rZWQgbGlzdCBub2RlIHRvIGJlIHJlc29sdmVkLlxuXHRmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoOyBpLS07ICkge1xuXHRcdC8vIENyZWF0ZSBhIG5ldyBsaW5rZWQgbGlzdCBub2RlIGFzIGFuIGFycmF5IG9mIGZvcm06XG5cdFx0Ly8gXHRbc3VzcGVuZGVkX2NvdW50LCByZXNvbHZlZF9jb3VudCwgbmV4dF9ub2RlXVxuXHRcdC8vIHdoZXJlIHN1c3BlbmRlZF9jb3VudCBhbmQgcmVzb2x2ZWRfY291bnQgYXJlIG51bWVyaWMgY291bnRlcnMgZm9yXG5cdFx0Ly8ga2VlcGluZyB0cmFjayBob3cgbWFueSB0aW1lcyBhIG5vZGUgaGFzIGJlZW4gc3VzcGVuZGVkIGFuZCByZXNvbHZlZC5cblx0XHQvL1xuXHRcdC8vIE5vdGUgdGhhdCBzdXNwZW5kZWRfY291bnQgc3RhcnRzIGZyb20gMSBpbnN0ZWFkIG9mIDAsIHNvIHdlIGNhbiBibG9ja1xuXHRcdC8vIHByb2Nlc3NpbmcgY2FsbGJhY2tzIHVudGlsIGNvbXBvbmVudERpZE1vdW50IGhhcyBiZWVuIGNhbGxlZC4gSW4gYSBzZW5zZVxuXHRcdC8vIG5vZGUgaXMgc3VzcGVuZGVkIGF0IGxlYXN0IHVudGlsIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkIVxuXHRcdC8vXG5cdFx0Ly8gUGVuZGluZyBjYWxsYmFja3MgYXJlIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIG5vZGU6XG5cdFx0Ly8gXHRbc3VzcGVuZGVkX2NvdW50LCByZXNvbHZlZF9jb3VudCwgbmV4dF9ub2RlLCBjYWxsYmFja18wLCBjYWxsYmFja18xLCAuLi5dXG5cdFx0dGhpcy5fbWFwLnNldChjaGlsZHJlbltpXSwgKHRoaXMuX25leHQgPSBbMSwgMCwgdGhpcy5fbmV4dF0pKTtcblx0fVxuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59O1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IFN1c3BlbnNlTGlzdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbigpIHtcblx0Ly8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBjaGlsZHJlbiBhZnRlciBtb3VudGluZyBmb3IgdHdvIHJlYXNvbnM6XG5cdC8vIDEuIEFzIGVhY2ggbm9kZVtTVVNQRU5ERURfQ09VTlRdIHN0YXJ0cyBmcm9tIDEsIHRoaXMgaXRlcmF0aW9uIGluY3JlYXNlc1xuXHQvLyAgICBlYWNoIG5vZGVbUkVMRUFTRURfQ09VTlRdIGJ5IDEsIHRoZXJlZm9yZSBiYWxhbmNpbmcgdGhlIGNvdW50ZXJzLlxuXHQvLyAgICBUaGUgbm9kZXMgY2FuIG5vdyBiZSBjb21wbGV0ZWx5IGNvbnN1bWVkIGZyb20gdGhlIGxpbmtlZCBsaXN0LlxuXHQvLyAyLiBIYW5kbGUgbm9kZXMgdGhhdCBtaWdodCBoYXZlIGdvdHRlbiByZXNvbHZlZCBiZXR3ZWVuIHJlbmRlciBhbmRcblx0Ly8gICAgY29tcG9uZW50RGlkTW91bnQuXG5cdGNvbnN0IGxpc3QgPSB0aGlzO1xuXHRsaXN0Ll9tYXAuZm9yRWFjaCgobm9kZSwgY2hpbGQpID0+IHtcblx0XHRyZXNvbHZlKGxpc3QsIGNoaWxkLCBub2RlKTtcblx0fSk7XG59O1xuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgaHlkcmF0ZSwgcmVuZGVyLCBfdW5tb3VudCB9IGZyb20gJ3ByZWFjdCc7XG5cbmNsYXNzIENvbnRleHRQcm92aWRlciB7XG5cdGdldENoaWxkQ29udGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpcy5wcm9wcy5jb250ZXh0O1xuXHR9XG5cdHJlbmRlcihwcm9wcykge1xuXHRcdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcblx0fVxufVxuXG4vKipcbiAqIFBvcnRhbCBjb21wb25lbnRcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gUG9ydGFsKHByb3BzKSB7XG5cdGxldCBfdGhpcyA9IHRoaXM7XG5cdGxldCBjb250YWluZXIgPSBwcm9wcy5jb250YWluZXI7XG5cdGxldCB3cmFwID0gY3JlYXRlRWxlbWVudChcblx0XHRDb250ZXh0UHJvdmlkZXIsXG5cdFx0eyBjb250ZXh0OiBfdGhpcy5jb250ZXh0IH0sXG5cdFx0cHJvcHMudm5vZGVcblx0KTtcblxuXHQvLyBXaGVuIHdlIGNoYW5nZSBjb250YWluZXIgd2Ugc2hvdWxkIGNsZWFyIG91ciBvbGQgY29udGFpbmVyIGFuZFxuXHQvLyBpbmRpY2F0ZSBhIG5ldyBtb3VudC5cblx0aWYgKF90aGlzLl9jb250YWluZXIgJiYgX3RoaXMuX2NvbnRhaW5lciAhPT0gY29udGFpbmVyKSB7XG5cdFx0aWYgKF90aGlzLl90ZW1wLnBhcmVudE5vZGUpIF90aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQoX3RoaXMuX3RlbXApO1xuXHRcdF91bm1vdW50KF90aGlzLl93cmFwKTtcblx0XHRfdGhpcy5faGFzTW91bnRlZCA9IGZhbHNlO1xuXHR9XG5cblx0Ly8gV2hlbiBwcm9wcy52bm9kZSBpcyB1bmRlZmluZWQvZmFsc2UvbnVsbCB3ZSBhcmUgZGVhbGluZyB3aXRoIHNvbWUga2luZCBvZlxuXHQvLyBjb25kaXRpb25hbCB2bm9kZS4gVGhpcyBzaG91bGQgbm90IHRyaWdnZXIgYSByZW5kZXIuXG5cdGlmIChwcm9wcy52bm9kZSkge1xuXHRcdGlmICghX3RoaXMuX2hhc01vdW50ZWQpIHtcblx0XHRcdC8vIENyZWF0ZSBhIHBsYWNlaG9sZGVyIHRoYXQgd2UgY2FuIHVzZSB0byBpbnNlcnQgaW50by5cblx0XHRcdF90aGlzLl90ZW1wID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuXHRcdFx0Ly8gSHlkcmF0ZSBleGlzdGluZyBub2RlcyB0byBrZWVwIHRoZSBkb20gaW50YWN0LCB3aGVuIHJlbmRlcmluZ1xuXHRcdFx0Ly8gd3JhcCBpbnRvIHRoZSBjb250YWluZXIuXG5cdFx0XHRoeWRyYXRlKCcnLCBjb250YWluZXIpO1xuXHRcdFx0Ly8gQXBwZW5kIHRvIHRoZSBjb250YWluZXIgKHRoaXMgbWF0Y2hlcyBSZWFjdCdzIGJlaGF2aW9yKVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKF90aGlzLl90ZW1wKTtcblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBtb3VudGVkIGFuZCBzaG91bGQgc2V0IG91ciBjb250YWluZXIuXG5cdFx0XHRfdGhpcy5faGFzTW91bnRlZCA9IHRydWU7XG5cdFx0XHRfdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXHRcdFx0Ly8gUmVuZGVyIG91ciB3cmFwcGluZyBlbGVtZW50IGludG8gdGVtcC5cblx0XHRcdHJlbmRlcih3cmFwLCBjb250YWluZXIsIF90aGlzLl90ZW1wKTtcblx0XHRcdF90aGlzLl9jaGlsZHJlbiA9IF90aGlzLl90ZW1wLl9jaGlsZHJlbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gV2hlbiB3ZSBoYXZlIG1vdW50ZWQgYW5kIHRoZSB2bm9kZSBpcyBwcmVzZW50IGl0IG1lYW5zIHRoZVxuXHRcdFx0Ly8gcHJvcHMgaGF2ZSBjaGFuZ2VkIG9yIGEgcGFyZW50IGlzIHRyaWdnZXJpbmcgYSByZXJlbmRlci5cblx0XHRcdC8vIFRoaXMgaW1wbGllcyB3ZSBvbmx5IG5lZWQgdG8gY2FsbCByZW5kZXIuIEJ1dCB3ZSBuZWVkIHRvIGtlZXBcblx0XHRcdC8vIHRoZSBvbGQgdHJlZSBhcm91bmQsIG90aGVyd2lzZSB3aWxsIHRyZWF0IHRoZSB2bm9kZXMgYXMgbmV3IGFuZFxuXHRcdFx0Ly8gd2lsbCB3cm9uZ2x5IGNhbGwgYGNvbXBvbmVudERpZE1vdW50YCBvbiB0aGVtXG5cdFx0XHRjb250YWluZXIuX2NoaWxkcmVuID0gX3RoaXMuX2NoaWxkcmVuO1xuXHRcdFx0cmVuZGVyKHdyYXAsIGNvbnRhaW5lcik7XG5cdFx0XHRfdGhpcy5fY2hpbGRyZW4gPSBjb250YWluZXIuX2NoaWxkcmVuO1xuXHRcdH1cblx0fVxuXHQvLyBXaGVuIHdlIGNvbWUgZnJvbSBhIGNvbmRpdGlvbmFsIHJlbmRlciwgb24gYSBtb3VudGVkXG5cdC8vIHBvcnRhbCB3ZSBzaG91bGQgY2xlYXIgdGhlIERPTS5cblx0ZWxzZSBpZiAoX3RoaXMuX2hhc01vdW50ZWQpIHtcblx0XHRpZiAoX3RoaXMuX3RlbXAucGFyZW50Tm9kZSkgX3RoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZChfdGhpcy5fdGVtcCk7XG5cdFx0X3VubW91bnQoX3RoaXMuX3dyYXApO1xuXHR9XG5cdC8vIFNldCB0aGUgd3JhcHBpbmcgZWxlbWVudCBmb3IgZnV0dXJlIHVubW91bnRpbmcuXG5cdF90aGlzLl93cmFwID0gd3JhcDtcblxuXHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcblx0XHRpZiAoX3RoaXMuX3RlbXAucGFyZW50Tm9kZSkgX3RoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZChfdGhpcy5fdGVtcCk7XG5cdFx0X3VubW91bnQoX3RoaXMuX3dyYXApO1xuXHR9O1xuXG5cdHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBQb3J0YWxgIHRvIGNvbnRpbnVlIHJlbmRlcmluZyB0aGUgdm5vZGUgdHJlZSBhdCBhIGRpZmZlcmVudCBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBjb250YWluZXIgVGhlIERPTSBub2RlIHRvIGNvbnRpbnVlIHJlbmRlcmluZyBpbiB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCh2bm9kZSwgY29udGFpbmVyKSB7XG5cdHJldHVybiBjcmVhdGVFbGVtZW50KFBvcnRhbCwgeyB2bm9kZSwgY29udGFpbmVyIH0pO1xufVxuIiwiaW1wb3J0IHtcblx0cmVuZGVyIGFzIHByZWFjdFJlbmRlcixcblx0aHlkcmF0ZSBhcyBwcmVhY3RIeWRyYXRlLFxuXHRvcHRpb25zLFxuXHR0b0NoaWxkQXJyYXksXG5cdENvbXBvbmVudFxufSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXBwbHlFdmVudE5vcm1hbGl6YXRpb24gfSBmcm9tICcuL2V2ZW50cyc7XG5cbmNvbnN0IENBTUVMX1BST1BTID0gL14oPzphY2NlbnR8YWxpZ25tZW50fGFyYWJpY3xiYXNlbGluZXxjYXB8Y2xpcCg/IVBhdGhVKXxjb2xvcnxmaWxsfGZsb29kfGZvbnR8Z2x5cGgoPyFSKXxob3JpenxtYXJrZXIoPyFIfFd8VSl8b3ZlcmxpbmV8cGFpbnR8c3RvcHxzdHJpa2V0aHJvdWdofHN0cm9rZXx0ZXh0KD8hTCl8dW5kZXJsaW5lfHVuaWNvZGV8dW5pdHN8dnx2ZWN0b3J8dmVydHx3b3JkfHdyaXRpbmd8eCg/IUMpKVtBLVpdLztcblxuLy8gU29tZSBsaWJyYXJpZXMgbGlrZSBgcmVhY3QtdmlydHVhbGl6ZWRgIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoaXMuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuZXhwb3J0IGNvbnN0IFJFQUNUX0VMRU1FTlRfVFlQRSA9XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmIFN5bWJvbC5mb3IgJiYgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuXHQweGVhYzc7XG5cbi8qKlxuICogUHJveHkgcmVuZGVyKCkgc2luY2UgUmVhY3QgcmV0dXJucyBhIENvbXBvbmVudCByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBWTm9kZSB0cmVlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnQgRE9NIG5vZGUgdG8gcmVuZGVyIHZub2RlIHRyZWUgaW50b1xuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50IHwgbnVsbH0gVGhlIHJvb3QgY29tcG9uZW50IHJlZmVyZW5jZSBvciBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0Ly8gUmVhY3QgZGVzdHJveXMgYW55IGV4aXN0aW5nIERPTSBub2Rlcywgc2VlICMxNzI3XG5cdC8vIC4uLmJ1dCBvbmx5IG9uIHRoZSBmaXJzdCByZW5kZXIsIHNlZSAjMTgyOFxuXHRpZiAocGFyZW50Ll9jaGlsZHJlbiA9PSBudWxsKSB7XG5cdFx0d2hpbGUgKHBhcmVudC5maXJzdENoaWxkKSB7XG5cdFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmZpcnN0Q2hpbGQpO1xuXHRcdH1cblx0fVxuXG5cdHByZWFjdFJlbmRlcih2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHRwcmVhY3RIeWRyYXRlKHZub2RlLCBwYXJlbnQpO1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG5cblx0cmV0dXJuIHZub2RlID8gdm5vZGUuX2NvbXBvbmVudCA6IG51bGw7XG59XG5cbmxldCBvbGRFdmVudEhvb2sgPSBvcHRpb25zLmV2ZW50O1xub3B0aW9ucy5ldmVudCA9IGUgPT4ge1xuXHRpZiAob2xkRXZlbnRIb29rKSBlID0gb2xkRXZlbnRIb29rKGUpO1xuXHRlLnBlcnNpc3QgPSAoKSA9PiB7fTtcblx0bGV0IHN0b3BwZWRQcm9wYWdhdGluZyA9IGZhbHNlLFxuXHRcdGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuXHRjb25zdCBvcmlnU3RvcFByb3BhZ2F0aW9uID0gZS5zdG9wUHJvcGFnYXRpb247XG5cdGUuc3RvcFByb3BhZ2F0aW9uID0gKCkgPT4ge1xuXHRcdG9yaWdTdG9wUHJvcGFnYXRpb24uY2FsbChlKTtcblx0XHRzdG9wcGVkUHJvcGFnYXRpbmcgPSB0cnVlO1xuXHR9O1xuXG5cdGNvbnN0IG9yaWdQcmV2ZW50RGVmYXVsdCA9IGUucHJldmVudERlZmF1bHQ7XG5cdGUucHJldmVudERlZmF1bHQgPSAoKSA9PiB7XG5cdFx0b3JpZ1ByZXZlbnREZWZhdWx0LmNhbGwoZSk7XG5cdFx0ZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG5cdH07XG5cblx0ZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9ICgpID0+IHN0b3BwZWRQcm9wYWdhdGluZztcblx0ZS5pc0RlZmF1bHRQcmV2ZW50ZWQgPSAoKSA9PiBkZWZhdWx0UHJldmVudGVkO1xuXHRyZXR1cm4gKGUubmF0aXZlRXZlbnQgPSBlKTtcbn07XG5cbi8vIFBhdGNoIGluIGBVTlNBRkVfKmAgbGlmZWN5Y2xlIGhvb2tzXG5mdW5jdGlvbiBzZXRTYWZlRGVzY3JpcHRvcihwcm90bywga2V5KSB7XG5cdGlmIChwcm90b1snVU5TQUZFXycgKyBrZXldICYmICFwcm90b1trZXldKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBrZXksIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzWydVTlNBRkVfJyArIGtleV07XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVGhpcyBgc2V0YCBpcyBvbmx5IHVzZWQgaWYgYSB1c2VyIHNldHMgYSBsaWZlY3ljbGUgbGlrZSBjV1Vcblx0XHRcdC8vIGFmdGVyIHNldHRpbmcgYSBsaWZlY3ljbGUgbGlrZSBVTlNBRkVfY1dVLiBJIGRvdWJ0IGFueW9uZVxuXHRcdFx0Ly8gYWN0dWFsbHkgZG9lcyB0aGlzIGluIHByYWN0aWNlIHNvIG5vdCB0ZXN0aW5nIGl0XG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdFx0c2V0KHYpIHtcblx0XHRcdFx0dGhpc1snVU5TQUZFXycgKyBrZXldID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuXG5sZXQgY2xhc3NOYW1lRGVzY3JpcHRvciA9IHtcblx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRnZXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3M7XG5cdH1cbn07XG5cbmxldCBvbGRWTm9kZUhvb2sgPSBvcHRpb25zLnZub2RlO1xub3B0aW9ucy52bm9kZSA9IHZub2RlID0+IHtcblx0dm5vZGUuJCR0eXBlb2YgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cblx0bGV0IHR5cGUgPSB2bm9kZS50eXBlO1xuXHRsZXQgcHJvcHMgPSB2bm9kZS5wcm9wcztcblxuXHRpZiAodHlwZSkge1xuXHRcdC8vIEFsaWFzIGBjbGFzc2AgcHJvcCB0byBgY2xhc3NOYW1lYCBpZiBhdmFpbGFibGVcblx0XHRpZiAocHJvcHMuY2xhc3MgIT0gcHJvcHMuY2xhc3NOYW1lKSB7XG5cdFx0XHRjbGFzc05hbWVEZXNjcmlwdG9yLmVudW1lcmFibGUgPSAnY2xhc3NOYW1lJyBpbiBwcm9wcztcblx0XHRcdGlmIChwcm9wcy5jbGFzc05hbWUgIT0gbnVsbCkgcHJvcHMuY2xhc3MgPSBwcm9wcy5jbGFzc05hbWU7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdjbGFzc05hbWUnLCBjbGFzc05hbWVEZXNjcmlwdG9yKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBET00gVk5vZGUgY29tcGF0XG5cdFx0aWYgKHR5cGVvZiB0eXBlICE9ICdmdW5jdGlvbicpIHtcblx0XHRcdC8vIEFwcGx5IGRlZmF1bHRWYWx1ZSB0byB2YWx1ZVxuXHRcdFx0aWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAmJiBwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICghcHJvcHMudmFsdWUgJiYgcHJvcHMudmFsdWUgIT09IDApIHtcblx0XHRcdFx0XHRwcm9wcy52YWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgcHJvcHMuZGVmYXVsdFZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgc3VwcG9ydCBmb3IgYXJyYXkgc2VsZWN0IHZhbHVlczogPHNlbGVjdCB2YWx1ZT17W119IC8+XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShwcm9wcy52YWx1ZSkgJiYgcHJvcHMubXVsdGlwbGUgJiYgdHlwZSA9PT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0dG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdFx0XHRpZiAocHJvcHMudmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTEpIHtcblx0XHRcdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRkZWxldGUgcHJvcHMudmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vcm1hbGl6ZSBET00gdm5vZGUgcHJvcGVydGllcy5cblx0XHRcdGxldCBzaG91bGRTYW5pdGl6ZSwgYXR0cnMsIGk7XG5cdFx0XHRmb3IgKGkgaW4gcHJvcHMpIGlmICgoc2hvdWxkU2FuaXRpemUgPSBDQU1FTF9QUk9QUy50ZXN0KGkpKSkgYnJlYWs7XG5cdFx0XHRpZiAoc2hvdWxkU2FuaXRpemUpIHtcblx0XHRcdFx0YXR0cnMgPSB2bm9kZS5wcm9wcyA9IHt9O1xuXHRcdFx0XHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRcdFx0XHRhdHRyc1tcblx0XHRcdFx0XHRcdENBTUVMX1BST1BTLnRlc3QoaSkgPyBpLnJlcGxhY2UoL1tBLVowLTldLywgJy0kJicpLnRvTG93ZXJDYXNlKCkgOiBpXG5cdFx0XHRcdFx0XSA9IHByb3BzW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRXZlbnRzXG5cdFx0YXBwbHlFdmVudE5vcm1hbGl6YXRpb24odm5vZGUpO1xuXG5cdFx0Ly8gQ29tcG9uZW50IGJhc2UgY2xhc3MgY29tcGF0XG5cdFx0Ly8gV2UgY2FuJ3QganVzdCBwYXRjaCB0aGUgYmFzZSBjb21wb25lbnQgY2xhc3MsIGJlY2F1c2UgY29tcG9uZW50cyB0aGF0IHVzZVxuXHRcdC8vIGluaGVyaXRhbmNlIGFuZCBhcmUgdHJhbnNwaWxlZCBkb3duIHRvIEVTNSB3aWxsIG92ZXJ3cml0ZSBvdXIgcGF0Y2hlZFxuXHRcdC8vIGdldHRlcnMgYW5kIHNldHRlcnMuIFNlZSAjMTk0MVxuXHRcdGlmIChcblx0XHRcdHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgJiZcblx0XHRcdCF0eXBlLl9wYXRjaGVkTGlmZWN5Y2xlcyAmJlxuXHRcdFx0dHlwZS5wcm90b3R5cGVcblx0XHQpIHtcblx0XHRcdHNldFNhZmVEZXNjcmlwdG9yKHR5cGUucHJvdG90eXBlLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG5cdFx0XHRzZXRTYWZlRGVzY3JpcHRvcih0eXBlLnByb3RvdHlwZSwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcblx0XHRcdHNldFNhZmVEZXNjcmlwdG9yKHR5cGUucHJvdG90eXBlLCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuXHRcdFx0dHlwZS5fcGF0Y2hlZExpZmVjeWNsZXMgPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdGlmIChvbGRWTm9kZUhvb2spIG9sZFZOb2RlSG9vayh2bm9kZSk7XG59O1xuIiwiLyoqXG4gKiBOb3JtYWxpemUgZXZlbnQgaGFuZGxlcnMgbGlrZSByZWFjdCBkb2VzLiBNb3N0IGZhbW91c2x5IGl0IHVzZXMgYG9uQ2hhbmdlYCBmb3IgYW55IGlucHV0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdG8gbm9ybWFsaXplIGV2ZW50cyBvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlFdmVudE5vcm1hbGl6YXRpb24oeyB0eXBlLCBwcm9wcyB9KSB7XG5cdGlmICghcHJvcHMgfHwgdHlwZW9mIHR5cGUgIT0gJ3N0cmluZycpIHJldHVybjtcblx0bGV0IG5ld1Byb3BzID0ge307XG5cblx0Zm9yIChsZXQgaSBpbiBwcm9wcykge1xuXHRcdGlmICgvXm9uKEFuaXxUcmF8VG91KS8udGVzdChpKSkge1xuXHRcdFx0cHJvcHNbaS50b0xvd2VyQ2FzZSgpXSA9IHByb3BzW2ldO1xuXHRcdFx0ZGVsZXRlIHByb3BzW2ldO1xuXHRcdH1cblx0XHRuZXdQcm9wc1tpLnRvTG93ZXJDYXNlKCldID0gaTtcblx0fVxuXHRpZiAobmV3UHJvcHMub25kb3VibGVjbGljaykge1xuXHRcdHByb3BzLm9uZGJsY2xpY2sgPSBwcm9wc1tuZXdQcm9wcy5vbmRvdWJsZWNsaWNrXTtcblx0XHRkZWxldGUgcHJvcHNbbmV3UHJvcHMub25kb3VibGVjbGlja107XG5cdH1cblx0aWYgKG5ld1Byb3BzLm9uYmVmb3JlaW5wdXQpIHtcblx0XHRwcm9wcy5vbmJlZm9yZWlucHV0ID0gcHJvcHNbbmV3UHJvcHMub25iZWZvcmVpbnB1dF07XG5cdFx0ZGVsZXRlIHByb3BzW25ld1Byb3BzLm9uYmVmb3JlaW5wdXRdO1xuXHR9XG5cdC8vIGZvciAqdGV4dHVhbCBpbnB1dHMqIChpbmNsIHRleHRhcmVhKSwgbm9ybWFsaXplIGBvbkNoYW5nZWAgLT4gYG9uSW5wdXRgOlxuXHRpZiAoXG5cdFx0bmV3UHJvcHMub25jaGFuZ2UgJiZcblx0XHQodHlwZSA9PT0gJ3RleHRhcmVhJyB8fFxuXHRcdFx0KHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAhL15maWx8Y2hlfHJhL2kudGVzdChwcm9wcy50eXBlKSkpXG5cdCkge1xuXHRcdGxldCBub3JtYWxpemVkID0gbmV3UHJvcHMub25pbnB1dCB8fCAnb25pbnB1dCc7XG5cdFx0aWYgKCFwcm9wc1tub3JtYWxpemVkXSkge1xuXHRcdFx0cHJvcHNbbm9ybWFsaXplZF0gPSBwcm9wc1tuZXdQcm9wcy5vbmNoYW5nZV07XG5cdFx0XHRkZWxldGUgcHJvcHNbbmV3UHJvcHMub25jaGFuZ2VdO1xuXHRcdH1cblx0fVxufVxuIiwiaW1wb3J0IHtcblx0Y3JlYXRlRWxlbWVudCxcblx0cmVuZGVyIGFzIHByZWFjdFJlbmRlcixcblx0Y2xvbmVFbGVtZW50IGFzIHByZWFjdENsb25lRWxlbWVudCxcblx0Y3JlYXRlUmVmLFxuXHRDb21wb25lbnQsXG5cdGNyZWF0ZUNvbnRleHQsXG5cdEZyYWdtZW50XG59IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQge1xuXHR1c2VTdGF0ZSxcblx0dXNlUmVkdWNlcixcblx0dXNlRWZmZWN0LFxuXHR1c2VMYXlvdXRFZmZlY3QsXG5cdHVzZVJlZixcblx0dXNlSW1wZXJhdGl2ZUhhbmRsZSxcblx0dXNlTWVtbyxcblx0dXNlQ2FsbGJhY2ssXG5cdHVzZUNvbnRleHQsXG5cdHVzZURlYnVnVmFsdWVcbn0gZnJvbSAncHJlYWN0L2hvb2tzJztcbmltcG9ydCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICcuL1B1cmVDb21wb25lbnQnO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gJy4vbWVtbyc7XG5pbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAnLi9mb3J3YXJkUmVmJztcbmltcG9ydCB7IENoaWxkcmVuIH0gZnJvbSAnLi9DaGlsZHJlbic7XG5pbXBvcnQgeyBTdXNwZW5zZSwgbGF6eSB9IGZyb20gJy4vc3VzcGVuc2UnO1xuaW1wb3J0IHsgU3VzcGVuc2VMaXN0IH0gZnJvbSAnLi9zdXNwZW5zZS1saXN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJy4vcG9ydGFscyc7XG5pbXBvcnQgeyBoeWRyYXRlLCByZW5kZXIsIFJFQUNUX0VMRU1FTlRfVFlQRSB9IGZyb20gJy4vcmVuZGVyJztcblxuY29uc3QgdmVyc2lvbiA9ICcxNi44LjAnOyAvLyB0cmljayBsaWJyYXJpZXMgdG8gdGhpbmsgd2UgYXJlIHJlYWN0XG5cbi8qKlxuICogTGVnYWN5IHZlcnNpb24gb2YgY3JlYXRlRWxlbWVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50IGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnkodHlwZSkge1xuXHRyZXR1cm4gY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwYXNzZWQgZWxlbWVudCBpcyBhIHZhbGlkIChwKXJlYWN0IG5vZGUuXG4gKiBAcGFyYW0geyp9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChlbGVtZW50KSB7XG5cdHJldHVybiAhIWVsZW1lbnQgJiYgZWxlbWVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG4vKipcbiAqIFdyYXAgYGNsb25lRWxlbWVudGAgdG8gYWJvcnQgaWYgdGhlIHBhc3NlZCBlbGVtZW50IGlzIG5vdCBhIHZhbGlkIGVsZW1lbnQgYW5kIGFwcGx5XG4gKiBhbGwgdm5vZGUgbm9ybWFsaXphdGlvbnMuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSBlbGVtZW50IFRoZSB2bm9kZSB0byBjbG9uZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIHRvIGFkZCB3aGVuIGNsb25pbmdcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW4+fSByZXN0IE9wdGlvbmFsIGNvbXBvbmVudCBjaGlsZHJlblxuICovXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCkge1xuXHRpZiAoIWlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSByZXR1cm4gZWxlbWVudDtcblx0cmV0dXJuIHByZWFjdENsb25lRWxlbWVudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNvbXBvbmVudCB0cmVlIGZyb20gdGhlIERPTSwgaW5jbHVkaW5nIHN0YXRlIGFuZCBldmVudCBoYW5kbGVycy5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gY29udGFpbmVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpIHtcblx0aWYgKGNvbnRhaW5lci5fY2hpbGRyZW4pIHtcblx0XHRwcmVhY3RSZW5kZXIobnVsbCwgY29udGFpbmVyKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogR2V0IHRoZSBtYXRjaGluZyBET00gbm9kZSBmb3IgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50KSB7XG5cdHJldHVybiAoXG5cdFx0KGNvbXBvbmVudCAmJlxuXHRcdFx0KGNvbXBvbmVudC5iYXNlIHx8IChjb21wb25lbnQubm9kZVR5cGUgPT09IDEgJiYgY29tcG9uZW50KSkpIHx8XG5cdFx0bnVsbFxuXHQpO1xufVxuXG4vKipcbiAqIERlcHJlY2F0ZWQgd2F5IHRvIGNvbnRyb2wgYmF0Y2hlZCByZW5kZXJpbmcgaW5zaWRlIHRoZSByZWNvbmNpbGVyLCBidXQgd2VcbiAqIGFscmVhZHkgc2NoZWR1bGUgaW4gYmF0Y2hlcyBpbnNpZGUgb3VyIHJlbmRlcmluZyBjb2RlXG4gKiBAdGVtcGxhdGUgQXJnXG4gKiBAcGFyYW0geyhhcmc6IEFyZykgPT4gdm9pZH0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB0cmlnZ2VycyB0aGUgdXBkYXRlZFxuICogQHBhcmFtIHtBcmd9IFthcmddIE9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2tcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuY29uc3QgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPSAoY2FsbGJhY2ssIGFyZykgPT4gY2FsbGJhY2soYXJnKTtcblxuZXhwb3J0ICogZnJvbSAncHJlYWN0L2hvb2tzJztcbmV4cG9ydCB7XG5cdHZlcnNpb24sXG5cdENoaWxkcmVuLFxuXHRyZW5kZXIsXG5cdGh5ZHJhdGUsXG5cdHVubW91bnRDb21wb25lbnRBdE5vZGUsXG5cdGNyZWF0ZVBvcnRhbCxcblx0Y3JlYXRlRWxlbWVudCxcblx0Y3JlYXRlQ29udGV4dCxcblx0Y3JlYXRlRmFjdG9yeSxcblx0Y2xvbmVFbGVtZW50LFxuXHRjcmVhdGVSZWYsXG5cdEZyYWdtZW50LFxuXHRpc1ZhbGlkRWxlbWVudCxcblx0ZmluZERPTU5vZGUsXG5cdENvbXBvbmVudCxcblx0UHVyZUNvbXBvbmVudCxcblx0bWVtbyxcblx0Zm9yd2FyZFJlZixcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuXHR1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcblx0U3VzcGVuc2UsXG5cdFN1c3BlbnNlTGlzdCxcblx0bGF6eVxufTtcblxuLy8gUmVhY3QgY29waWVzIHRoZSBuYW1lZCBleHBvcnRzIHRvIHRoZSBkZWZhdWx0IG9uZS5cbmV4cG9ydCBkZWZhdWx0IHtcblx0dXNlU3RhdGUsXG5cdHVzZVJlZHVjZXIsXG5cdHVzZUVmZmVjdCxcblx0dXNlTGF5b3V0RWZmZWN0LFxuXHR1c2VSZWYsXG5cdHVzZUltcGVyYXRpdmVIYW5kbGUsXG5cdHVzZU1lbW8sXG5cdHVzZUNhbGxiYWNrLFxuXHR1c2VDb250ZXh0LFxuXHR1c2VEZWJ1Z1ZhbHVlLFxuXHR2ZXJzaW9uLFxuXHRDaGlsZHJlbixcblx0cmVuZGVyLFxuXHRoeWRyYXRlOiByZW5kZXIsXG5cdHVubW91bnRDb21wb25lbnRBdE5vZGUsXG5cdGNyZWF0ZVBvcnRhbCxcblx0Y3JlYXRlRWxlbWVudCxcblx0Y3JlYXRlQ29udGV4dCxcblx0Y3JlYXRlRmFjdG9yeSxcblx0Y2xvbmVFbGVtZW50LFxuXHRjcmVhdGVSZWYsXG5cdEZyYWdtZW50LFxuXHRpc1ZhbGlkRWxlbWVudCxcblx0ZmluZERPTU5vZGUsXG5cdENvbXBvbmVudCxcblx0UHVyZUNvbXBvbmVudCxcblx0bWVtbyxcblx0Zm9yd2FyZFJlZixcblx0dW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsXG5cdFN1c3BlbnNlLFxuXHRTdXNwZW5zZUxpc3QsXG5cdGxhenlcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/preact/compat/dist/compat.module.js\n");

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ H),\n/* harmony export */   \"hydrate\": () => (/* binding */ I),\n/* harmony export */   \"createElement\": () => (/* binding */ h),\n/* harmony export */   \"h\": () => (/* binding */ h),\n/* harmony export */   \"Fragment\": () => (/* binding */ d),\n/* harmony export */   \"createRef\": () => (/* binding */ y),\n/* harmony export */   \"isValidElement\": () => (/* binding */ l),\n/* harmony export */   \"Component\": () => (/* binding */ m),\n/* harmony export */   \"cloneElement\": () => (/* binding */ L),\n/* harmony export */   \"createContext\": () => (/* binding */ M),\n/* harmony export */   \"toChildArray\": () => (/* binding */ x),\n/* harmony export */   \"_unmount\": () => (/* binding */ D),\n/* harmony export */   \"options\": () => (/* binding */ n)\n/* harmony export */ });\nvar n,\n    l,\n    u,\n    i,\n    t,\n    r,\n    o,\n    f,\n    e = {},\n    c = [],\n    s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\nfunction a(n, l) {\n  for (var u in l) n[u] = l[u];\n\n  return n;\n}\n\nfunction v(n) {\n  var l = n.parentNode;\n  l && l.removeChild(n);\n}\n\nfunction h(n, l, u) {\n  var i,\n      t = arguments,\n      r = {};\n\n  for (i in l) \"key\" !== i && \"ref\" !== i && (r[i] = l[i]);\n\n  if (arguments.length > 3) for (u = [u], i = 3; i < arguments.length; i++) u.push(t[i]);\n  if (null != u && (r.children = u), \"function\" == typeof n && null != n.defaultProps) for (i in n.defaultProps) void 0 === r[i] && (r[i] = n.defaultProps[i]);\n  return p(n, r, l && l.key, l && l.ref, null);\n}\n\nfunction p(l, u, i, t, r) {\n  var o = {\n    type: l,\n    props: u,\n    key: i,\n    ref: t,\n    __k: null,\n    __: null,\n    __b: 0,\n    __e: null,\n    __d: void 0,\n    __c: null,\n    constructor: void 0,\n    __v: r\n  };\n  return null == r && (o.__v = o), n.vnode && n.vnode(o), o;\n}\n\nfunction y() {\n  return {};\n}\n\nfunction d(n) {\n  return n.children;\n}\n\nfunction m(n, l) {\n  this.props = n, this.context = l;\n}\n\nfunction w(n, l) {\n  if (null == l) return n.__ ? w(n.__, n.__.__k.indexOf(n) + 1) : null;\n\n  for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;\n\n  return \"function\" == typeof n.type ? w(n) : null;\n}\n\nfunction k(n) {\n  var l, u;\n\n  if (null != (n = n.__) && null != n.__c) {\n    for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {\n      n.__e = n.__c.base = u.__e;\n      break;\n    }\n\n    return k(n);\n  }\n}\n\nfunction g(l) {\n  (!l.__d && (l.__d = !0) && u.push(l) && !i++ || r !== n.debounceRendering) && ((r = n.debounceRendering) || t)(_);\n}\n\nfunction _() {\n  for (var n; i = u.length;) n = u.sort(function (n, l) {\n    return n.__v.__b - l.__v.__b;\n  }), u = [], n.some(function (n) {\n    var l, u, i, t, r, o, f;\n    n.__d && (o = (r = (l = n).__v).__e, (f = l.__P) && (u = [], (i = a({}, r)).__v = i, t = A(f, r, i, l.__n, void 0 !== f.ownerSVGElement, null, u, null == o ? w(r) : o), T(u, r), t != o && k(r)));\n  });\n}\n\nfunction b(n, l, u, i, t, r, o, f, s) {\n  var a,\n      h,\n      p,\n      y,\n      d,\n      m,\n      k,\n      g = u && u.__k || c,\n      _ = g.length;\n  if (f == e && (f = null != r ? r[0] : _ ? w(u, 0) : null), a = 0, l.__k = x(l.__k, function (u) {\n    if (null != u) {\n      if (u.__ = l, u.__b = l.__b + 1, null === (p = g[a]) || p && u.key == p.key && u.type === p.type) g[a] = void 0;else for (h = 0; h < _; h++) {\n        if ((p = g[h]) && u.key == p.key && u.type === p.type) {\n          g[h] = void 0;\n          break;\n        }\n\n        p = null;\n      }\n\n      if (y = A(n, u, p = p || e, i, t, r, o, f, s), (h = u.ref) && p.ref != h && (k || (k = []), p.ref && k.push(p.ref, null, u), k.push(h, u.__c || y, u)), null != y) {\n        var c;\n        if (null == m && (m = y), void 0 !== u.__d) c = u.__d, u.__d = void 0;else if (r == p || y != f || null == y.parentNode) {\n          n: if (null == f || f.parentNode !== n) n.appendChild(y), c = null;else {\n            for (d = f, h = 0; (d = d.nextSibling) && h < _; h += 2) if (d == y) break n;\n\n            n.insertBefore(y, f), c = f;\n          }\n\n          \"option\" == l.type && (n.value = \"\");\n        }\n        f = void 0 !== c ? c : y.nextSibling, \"function\" == typeof l.type && (l.__d = f);\n      } else f && p.__e == f && f.parentNode != n && (f = w(p));\n    }\n\n    return a++, u;\n  }), l.__e = m, null != r && \"function\" != typeof l.type) for (a = r.length; a--;) null != r[a] && v(r[a]);\n\n  for (a = _; a--;) null != g[a] && D(g[a], g[a]);\n\n  if (k) for (a = 0; a < k.length; a++) j(k[a], k[++a], k[++a]);\n}\n\nfunction x(n, l, u) {\n  if (null == u && (u = []), null == n || \"boolean\" == typeof n) l && u.push(l(null));else if (Array.isArray(n)) for (var i = 0; i < n.length; i++) x(n[i], l, u);else u.push(l ? l(\"string\" == typeof n || \"number\" == typeof n ? p(null, n, null, null, n) : null != n.__e || null != n.__c ? p(n.type, n.props, n.key, null, n.__v) : n) : n);\n  return u;\n}\n\nfunction P(n, l, u, i, t) {\n  var r;\n\n  for (r in u) \"children\" === r || \"key\" === r || r in l || N(n, r, null, u[r], i);\n\n  for (r in l) t && \"function\" != typeof l[r] || \"children\" === r || \"key\" === r || \"value\" === r || \"checked\" === r || u[r] === l[r] || N(n, r, l[r], u[r], i);\n}\n\nfunction C(n, l, u) {\n  \"-\" === l[0] ? n.setProperty(l, u) : n[l] = \"number\" == typeof u && !1 === s.test(l) ? u + \"px\" : null == u ? \"\" : u;\n}\n\nfunction N(n, l, u, i, t) {\n  var r, o, f, e, c;\n  if (t ? \"className\" === l && (l = \"class\") : \"class\" === l && (l = \"className\"), \"style\" === l) {\n    if (r = n.style, \"string\" == typeof u) r.cssText = u;else {\n      if (\"string\" == typeof i && (r.cssText = \"\", i = null), i) for (e in i) u && e in u || C(r, e, \"\");\n      if (u) for (c in u) i && u[c] === i[c] || C(r, c, u[c]);\n    }\n  } else \"o\" === l[0] && \"n\" === l[1] ? (o = l !== (l = l.replace(/Capture$/, \"\")), f = l.toLowerCase(), l = (f in n ? f : l).slice(2), u ? (i || n.addEventListener(l, z, o), (n.l || (n.l = {}))[l] = u) : n.removeEventListener(l, z, o)) : \"list\" !== l && \"tagName\" !== l && \"form\" !== l && \"type\" !== l && \"size\" !== l && !t && l in n ? n[l] = null == u ? \"\" : u : \"function\" != typeof u && \"dangerouslySetInnerHTML\" !== l && (l !== (l = l.replace(/^xlink:?/, \"\")) ? null == u || !1 === u ? n.removeAttributeNS(\"http://www.w3.org/1999/xlink\", l.toLowerCase()) : n.setAttributeNS(\"http://www.w3.org/1999/xlink\", l.toLowerCase(), u) : null == u || !1 === u && !/^ar/.test(l) ? n.removeAttribute(l) : n.setAttribute(l, u));\n}\n\nfunction z(l) {\n  this.l[l.type](n.event ? n.event(l) : l);\n}\n\nfunction A(l, u, i, t, r, o, f, e, c) {\n  var s,\n      v,\n      h,\n      p,\n      y,\n      w,\n      k,\n      g,\n      _,\n      x,\n      P = u.type;\n\n  if (void 0 !== u.constructor) return null;\n  (s = n.__b) && s(u);\n\n  try {\n    n: if (\"function\" == typeof P) {\n      if (g = u.props, _ = (s = P.contextType) && t[s.__c], x = s ? _ ? _.props.value : s.__ : t, i.__c ? k = (v = u.__c = i.__c).__ = v.__E : (\"prototype\" in P && P.prototype.render ? u.__c = v = new P(g, x) : (u.__c = v = new m(g, x), v.constructor = P, v.render = E), _ && _.sub(v), v.props = g, v.state || (v.state = {}), v.context = x, v.__n = t, h = v.__d = !0, v.__h = []), null == v.__s && (v.__s = v.state), null != P.getDerivedStateFromProps && (v.__s == v.state && (v.__s = a({}, v.__s)), a(v.__s, P.getDerivedStateFromProps(g, v.__s))), p = v.props, y = v.state, h) null == P.getDerivedStateFromProps && null != v.componentWillMount && v.componentWillMount(), null != v.componentDidMount && v.__h.push(v.componentDidMount);else {\n        if (null == P.getDerivedStateFromProps && g !== p && null != v.componentWillReceiveProps && v.componentWillReceiveProps(g, x), !v.__e && null != v.shouldComponentUpdate && !1 === v.shouldComponentUpdate(g, v.__s, x) || u.__v === i.__v && !v.__) {\n          for (v.props = g, v.state = v.__s, u.__v !== i.__v && (v.__d = !1), v.__v = u, u.__e = i.__e, u.__k = i.__k, v.__h.length && f.push(v), s = 0; s < u.__k.length; s++) u.__k[s] && (u.__k[s].__ = u);\n\n          break n;\n        }\n\n        null != v.componentWillUpdate && v.componentWillUpdate(g, v.__s, x), null != v.componentDidUpdate && v.__h.push(function () {\n          v.componentDidUpdate(p, y, w);\n        });\n      }\n      v.context = x, v.props = g, v.state = v.__s, (s = n.__r) && s(u), v.__d = !1, v.__v = u, v.__P = l, s = v.render(v.props, v.state, v.context), u.__k = null != s && s.type == d && null == s.key ? s.props.children : Array.isArray(s) ? s : [s], null != v.getChildContext && (t = a(a({}, t), v.getChildContext())), h || null == v.getSnapshotBeforeUpdate || (w = v.getSnapshotBeforeUpdate(p, y)), b(l, u, i, t, r, o, f, e, c), v.base = u.__e, v.__h.length && f.push(v), k && (v.__E = v.__ = null), v.__e = !1;\n    } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = $(i.__e, u, i, t, r, o, f, c);\n\n    (s = n.diffed) && s(u);\n  } catch (l) {\n    u.__v = null, n.__e(l, u, i);\n  }\n\n  return u.__e;\n}\n\nfunction T(l, u) {\n  n.__c && n.__c(u, l), l.some(function (u) {\n    try {\n      l = u.__h, u.__h = [], l.some(function (n) {\n        n.call(u);\n      });\n    } catch (l) {\n      n.__e(l, u.__v);\n    }\n  });\n}\n\nfunction $(n, l, u, i, t, r, o, f) {\n  var s,\n      a,\n      v,\n      h,\n      p,\n      y = u.props,\n      d = l.props;\n  if (t = \"svg\" === l.type || t, null != r) for (s = 0; s < r.length; s++) if (null != (a = r[s]) && ((null === l.type ? 3 === a.nodeType : a.localName === l.type) || n == a)) {\n    n = a, r[s] = null;\n    break;\n  }\n\n  if (null == n) {\n    if (null === l.type) return document.createTextNode(d);\n    n = t ? document.createElementNS(\"http://www.w3.org/2000/svg\", l.type) : document.createElement(l.type, d.is && {\n      is: d.is\n    }), r = null, f = !1;\n  }\n\n  if (null === l.type) y !== d && n.data != d && (n.data = d);else {\n    if (null != r && (r = c.slice.call(n.childNodes)), v = (y = u.props || e).dangerouslySetInnerHTML, h = d.dangerouslySetInnerHTML, !f) {\n      if (y === e) for (y = {}, p = 0; p < n.attributes.length; p++) y[n.attributes[p].name] = n.attributes[p].value;\n      (h || v) && (h && v && h.__html == v.__html || (n.innerHTML = h && h.__html || \"\"));\n    }\n\n    P(n, d, y, t, f), h ? l.__k = [] : (l.__k = l.props.children, b(n, l, u, i, \"foreignObject\" !== l.type && t, r, o, e, f)), f || (\"value\" in d && void 0 !== (s = d.value) && s !== n.value && N(n, \"value\", s, y.value, !1), \"checked\" in d && void 0 !== (s = d.checked) && s !== n.checked && N(n, \"checked\", s, y.checked, !1));\n  }\n  return n;\n}\n\nfunction j(l, u, i) {\n  try {\n    \"function\" == typeof l ? l(u) : l.current = u;\n  } catch (l) {\n    n.__e(l, i);\n  }\n}\n\nfunction D(l, u, i) {\n  var t, r, o;\n\n  if (n.unmount && n.unmount(l), (t = l.ref) && (t.current && t.current !== l.__e || j(t, null, u)), i || \"function\" == typeof l.type || (i = null != (r = l.__e)), l.__e = l.__d = void 0, null != (t = l.__c)) {\n    if (t.componentWillUnmount) try {\n      t.componentWillUnmount();\n    } catch (l) {\n      n.__e(l, u);\n    }\n    t.base = t.__P = null;\n  }\n\n  if (t = l.__k) for (o = 0; o < t.length; o++) t[o] && D(t[o], u, i);\n  null != r && v(r);\n}\n\nfunction E(n, l, u) {\n  return this.constructor(n, u);\n}\n\nfunction H(l, u, i) {\n  var t, r, f;\n  n.__ && n.__(l, u), r = (t = i === o) ? null : i && i.__k || u.__k, l = h(d, null, [l]), f = [], A(u, (t ? u : i || u).__k = l, r || e, e, void 0 !== u.ownerSVGElement, i && !t ? [i] : r ? null : c.slice.call(u.childNodes), f, i || e, t), T(f, l);\n}\n\nfunction I(n, l) {\n  H(n, l, o);\n}\n\nfunction L(n, l) {\n  var u, i;\n\n  for (i in l = a(a({}, n.props), l), arguments.length > 2 && (l.children = c.slice.call(arguments, 2)), u = {}, l) \"key\" !== i && \"ref\" !== i && (u[i] = l[i]);\n\n  return p(n.type, u, l.key || n.key, l.ref || n.ref, null);\n}\n\nfunction M(n) {\n  var l = {},\n      u = {\n    __c: \"__cC\" + f++,\n    __: n,\n    Consumer: function (n, l) {\n      return n.children(l);\n    },\n    Provider: function (n) {\n      var i,\n          t = this;\n      return this.getChildContext || (i = [], this.getChildContext = function () {\n        return l[u.__c] = t, l;\n      }, this.shouldComponentUpdate = function (n) {\n        t.props.value !== n.value && i.some(function (l) {\n          l.context = n.value, g(l);\n        });\n      }, this.sub = function (n) {\n        i.push(n);\n        var l = n.componentWillUnmount;\n\n        n.componentWillUnmount = function () {\n          i.splice(i.indexOf(n), 1), l && l.call(n);\n        };\n      }), n.children;\n    }\n  };\n  return u.Consumer.contextType = u, u.Provider.__ = u, u;\n}\n\nn = {\n  __e: function (n, l) {\n    for (var u, i; l = l.__;) if ((u = l.__c) && !u.__) try {\n      if (u.constructor && null != u.constructor.getDerivedStateFromError && (i = !0, u.setState(u.constructor.getDerivedStateFromError(n))), null != u.componentDidCatch && (i = !0, u.componentDidCatch(n)), i) return g(u.__E = u);\n    } catch (l) {\n      n = l;\n    }\n\n    throw n;\n  }\n}, l = function (n) {\n  return null != n && void 0 === n.constructor;\n}, m.prototype.setState = function (n, l) {\n  var u;\n  u = this.__s !== this.state ? this.__s : this.__s = a({}, this.state), \"function\" == typeof n && (n = n(u, this.props)), n && a(u, n), null != n && this.__v && (l && this.__h.push(l), g(this));\n}, m.prototype.forceUpdate = function (n) {\n  this.__v && (this.__e = !0, n && this.__h.push(n), g(this));\n}, m.prototype.render = d, u = [], i = 0, t = \"function\" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o = e, f = 0;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0Lm1vZHVsZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QU1PQTtBQUFBOztBQUNBO0FBVUE7O0FBQUE7QUFBQTtBQUVBO0FKVkE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7O0FBR0E7QUFPQTtBQVlBO0FBMEJBOztBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFnQkE7QUFTQTs7QUFBQTtBQUFBO0FBSUE7O0FBQUE7QUFBQTtBQy9FQTs7QUFBQTtBQUFBO0FBdUVBOztBQUFBO0FBQUE7O0FBS0E7O0FBV0E7QUErQ0E7O0FBQUE7QUFBQTs7QUFJQTtBQUhBO0FBS0E7QUFBQTtBQUFBOztBQUFBO0FBS0E7QUFxQ0E7O0FBQUE7QUFBQTtBQWNBOztBQUFBO0FBQUE7QUFHQTtBQUFBO0FBaEdBO0FBcUdBO0FBOUVBO0FJakhBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBaUJBO0FBbUJBO0FBQ0E7QUFvQkE7QUFTQTtBQUFBO0FBR0E7O0FBQUE7QUFBQTs7QUFBQTtBQTBCQTtBQUtBO0FBcUJBO0FBR0E7O0FBV0E7QUFjQTs7QUFBQTtBQVNBO0FBQUE7QUFjQTtBQVNBOztBQUFBO0FBS0E7O0FBU0E7O0FBTUE7QUFvQkE7O0FBQUE7QUFBQTtBQVVBO0FDcFBBOztBQUFBO0FBQUE7O0FBQ0E7O0FBSUE7QUFrQkE7O0FBQUE7QUFDQTtBQXNCQTs7QUFBQTtBQUFBO0FBK0JBO0FBcEJBO0FBS0E7QUFTQTtBQVFBO0FBRkE7QUFxRUE7O0FBQUE7QUFBQTtBQ3RJQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBWUE7QUFJQTs7QUFFQTtBQUdBO0FBQUE7QUFtRUE7QUFrQkE7O0FBY0E7QUFPQTs7QUFBQTtBQU1BO0FBQUE7QUFLQTtBQUFBO0FBaURBOztBQWdCQTtBQUtBO0FBQ0E7QUFDQTs7QUFBQTtBQVdBOztBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBbUJBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFZQTtBQW1CQTtBQUNBO0FBQUE7O0FBQUE7QUFNQTtBQUtBO0FBSUE7QUFBQTtBQUtBOztBQUFBO0FBT0E7QUFZQTtBQUlBO0FBWUE7O0FBQUE7QUFrQ0E7QUFBQTtBQWNBOztBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQVlBOztBQUFBO0FBQUE7O0FBOEJBO0FBYkE7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQUE7O0FBQUE7QUFTQTtBQUlBOztBQUFBO0FBQUE7QUxuY0E7O0FBQUE7QUFBQTtBQUNBO0FBK0NBOztBQUFBO0FBQ0E7QU1yREE7O0FBQUE7QUFBQTs7QUFJQTs7QUFDQTtBTFpBOztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFBQTtBQU1BO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQWpDQTtBQWlDQTtBSjdCQTs7QUFBQTtBQUNBO0FVSEE7QUFLQTtBQW1CQTtBQUNBO0FBQUE7O0FBQUE7QUFLQTtBVjVCQTtBQ3lGQTtBQUNBO0FDNUVBO0FBSUE7QUFrQkE7QUFVQTtBQU1BIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2NvbnN0YW50cy5qcz80N2M4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9vcHRpb25zLmpzPzFhZTUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2NyZWF0ZS1lbGVtZW50LmpzPzQ2ZGUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2NvbXBvbmVudC5qcz9kY2IyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZW5kZXIuanM/NTBmZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvY3JlYXRlLWNvbnRleHQuanM/M2VmMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbC5qcz80MjI4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9kaWZmL2NoaWxkcmVuLmpzP2IwZWMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2RpZmYvcHJvcHMuanM/YzFkYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvZGlmZi9pbmRleC5qcz9jOTg4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9jbG9uZS1lbGVtZW50LmpzP2FlY2UiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2RpZmYvY2F0Y2gtZXJyb3IuanM/ODhhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgRU1QVFlfT0JKID0ge307XG5leHBvcnQgY29uc3QgRU1QVFlfQVJSID0gW107XG5leHBvcnQgY29uc3QgSVNfTk9OX0RJTUVOU0lPTkFMID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmQvaTtcbiIsImltcG9ydCB7IF9jYXRjaEVycm9yIH0gZnJvbSAnLi9kaWZmL2NhdGNoLWVycm9yJztcblxuLyoqXG4gKiBUaGUgYG9wdGlvbmAgb2JqZWN0IGNhbiBwb3RlbnRpYWxseSBjb250YWluIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICogdGhhdCBhcmUgY2FsbGVkIGR1cmluZyB2YXJpb3VzIHN0YWdlcyBvZiBvdXIgcmVuZGVyZXIuIFRoaXMgaXMgdGhlXG4gKiBmb3VuZGF0aW9uIG9uIHdoaWNoIGFsbCBvdXIgYWRkb25zIGxpa2UgYHByZWFjdC9kZWJ1Z2AsIGBwcmVhY3QvY29tcGF0YCxcbiAqIGFuZCBgcHJlYWN0L2hvb2tzYCBhcmUgYmFzZWQgb24uIFNlZSB0aGUgYE9wdGlvbnNgIHR5cGUgaW4gYGludGVybmFsLmQudHNgXG4gKiBmb3IgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbiBob29rcyAobW9zdCBlZGl0b3JzL0lERXMgYWxsb3cgeW91IHRvXG4gKiBjdHJsK2NsaWNrIG9yIGNtZCtjbGljayBvbiBtYWMgdGhlIHR5cGUgZGVmaW5pdGlvbiBiZWxvdykuXG4gKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuT3B0aW9uc31cbiAqL1xuY29uc3Qgb3B0aW9ucyA9IHtcblx0X2NhdGNoRXJyb3Jcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG9wdGlvbnM7XG4iLCJpbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiB2aXJ0dWFsIG5vZGUgKHVzZWQgZm9yIEpTWClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBjb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Byb3BzXSBUaGUgcHJvcGVydGllcyBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLicpLkNvbXBvbmVudENoaWxkcmVuPn0gW2NoaWxkcmVuXSBUaGUgY2hpbGRyZW4gb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHt9LFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpICE9PSAna2V5JyAmJiBpICE9PSAncmVmJykgbm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdH1cblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcblx0XHRjaGlsZHJlbiA9IFtjaGlsZHJlbl07XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMTkxNlxuXHRcdGZvciAoaSA9IDM7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW2ldKTtcblx0XHR9XG5cdH1cblx0aWYgKGNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRub3JtYWxpemVkUHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblx0fVxuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wc1xuXHQvLyBOb3RlOiB0eXBlIG1heSBiZSB1bmRlZmluZWQgaW4gZGV2ZWxvcG1lbnQsIG11c3QgbmV2ZXIgZXJyb3IgaGVyZS5cblx0aWYgKHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgJiYgdHlwZS5kZWZhdWx0UHJvcHMgIT0gbnVsbCkge1xuXHRcdGZvciAoaSBpbiB0eXBlLmRlZmF1bHRQcm9wcykge1xuXHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHR5cGUuZGVmYXVsdFByb3BzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjcmVhdGVWTm9kZShcblx0XHR0eXBlLFxuXHRcdG5vcm1hbGl6ZWRQcm9wcyxcblx0XHRwcm9wcyAmJiBwcm9wcy5rZXksXG5cdFx0cHJvcHMgJiYgcHJvcHMucmVmLFxuXHRcdG51bGxcblx0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBWTm9kZSAodXNlZCBpbnRlcm5hbGx5IGJ5IFByZWFjdClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBDb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgb2YgdGhpcyB2aXJ0dWFsIG5vZGUuXG4gKiBJZiB0aGlzIHZpcnR1YWwgbm9kZSByZXByZXNlbnRzIGEgdGV4dCBub2RlLCB0aGlzIGlzIHRoZSB0ZXh0IG9mIHRoZSBub2RlIChzdHJpbmcgb3IgbnVtYmVyKS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0ga2V5IFRoZSBrZXkgZm9yIHRoaXMgdmlydHVhbCBub2RlLCB1c2VkIHdoZW5cbiAqIGRpZmZpbmcgaXQgYWdhaW5zdCBpdHMgY2hpbGRyZW5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJyZWZcIl19IHJlZiBUaGUgcmVmIHByb3BlcnR5IHRoYXQgd2lsbFxuICogcmVjZWl2ZSBhIHJlZmVyZW5jZSB0byBpdHMgY3JlYXRlZCBjaGlsZFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgcmVmLCBvcmlnaW5hbCkge1xuXHQvLyBWOCBzZWVtcyB0byBiZSBiZXR0ZXIgYXQgZGV0ZWN0aW5nIHR5cGUgc2hhcGVzIGlmIHRoZSBvYmplY3QgaXMgYWxsb2NhdGVkIGZyb20gdGhlIHNhbWUgY2FsbCBzaXRlXG5cdC8vIERvIG5vdCBpbmxpbmUgaW50byBjcmVhdGVFbGVtZW50IGFuZCBjb2VyY2VUb1ZOb2RlIVxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0Ly8gX25leHREb20gbXVzdCBiZSBpbml0aWFsaXplZCB0byB1bmRlZmluZWQgYi9jIGl0IHdpbGwgZXZlbnR1YWxseVxuXHRcdC8vIGJlIHNldCB0byBkb20ubmV4dFNpYmxpbmcgd2hpY2ggY2FuIHJldHVybiBgbnVsbGAgYW5kIGl0IGlzIGltcG9ydGFudFxuXHRcdC8vIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbiB1bmluaXRpYWxpemVkIF9uZXh0RG9tIGFuZFxuXHRcdC8vIGEgX25leHREb20gdGhhdCBoYXMgYmVlbiBzZXQgdG8gYG51bGxgXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdGNvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG5cdFx0X29yaWdpbmFsOiBvcmlnaW5hbFxuXHR9O1xuXG5cdGlmIChvcmlnaW5hbCA9PSBudWxsKSB2bm9kZS5fb3JpZ2luYWwgPSB2bm9kZTtcblx0aWYgKG9wdGlvbnMudm5vZGUpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcblx0cmV0dXJuIHt9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRnJhZ21lbnQocHJvcHMpIHtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQgUHJlYWN0IFZOb2RlLlxuICogQHBhcmFtIHsqfSB2bm9kZVxuICogQHJldHVybnMge3Zub2RlIGlzIGltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZEVsZW1lbnQgPSB2bm9kZSA9PlxuXHR2bm9kZSAhPSBudWxsICYmIHZub2RlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQ7XG4iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZGlmZiwgY29tbWl0Um9vdCB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcblxuLyoqXG4gKiBCYXNlIENvbXBvbmVudCBjbGFzcy4gUHJvdmlkZXMgYHNldFN0YXRlKClgIGFuZCBgZm9yY2VVcGRhdGUoKWAsIHdoaWNoXG4gKiB0cmlnZ2VyIHJlbmRlcmluZ1xuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFRoZSBpbml0aWFsIGNvbXBvbmVudCBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgVGhlIGluaXRpYWwgY29udGV4dCBmcm9tIHBhcmVudCBjb21wb25lbnRzJ1xuICogZ2V0Q2hpbGRDb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG4vKipcbiAqIFVwZGF0ZSBjb21wb25lbnQgc3RhdGUgYW5kIHNjaGVkdWxlIGEgcmUtcmVuZGVyLlxuICogQHBhcmFtIHtvYmplY3QgfCAoKHM6IG9iamVjdCwgcDogb2JqZWN0KSA9PiBvYmplY3QpfSB1cGRhdGUgQSBoYXNoIG9mIHN0YXRlXG4gKiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIHRoZSBjdXJyZW50XG4gKiBzdGF0ZSBhbmQgcHJvcHMgcmV0dXJucyBhIG5ldyBwYXJ0aWFsIHN0YXRlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXNcbiAqIHVwZGF0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0Ly8gb25seSBjbG9uZSBzdGF0ZSB3aGVuIGNvcHlpbmcgdG8gbmV4dFN0YXRlIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgcztcblx0aWYgKHRoaXMuX25leHRTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGU7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVwZGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dXBkYXRlID0gdXBkYXRlKHMsIHRoaXMucHJvcHMpO1xuXHR9XG5cblx0aWYgKHVwZGF0ZSkge1xuXHRcdGFzc2lnbihzLCB1cGRhdGUpO1xuXHR9XG5cblx0Ly8gU2tpcCB1cGRhdGUgaWYgdXBkYXRlciBmdW5jdGlvbiByZXR1cm5lZCBudWxsXG5cdGlmICh1cGRhdGUgPT0gbnVsbCkgcmV0dXJuO1xuXG5cdGlmICh0aGlzLl92bm9kZSkge1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogSW1tZWRpYXRlbHkgcGVyZm9ybSBhIHN5bmNocm9ub3VzIHJlLXJlbmRlciBvZiB0aGUgY29tcG9uZW50XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzXG4gKiByZS1yZW5kZXJlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSBvbGRWTm9kZTtcblxuXHRcdGxldCBuZXdEb20gPSBkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0dm5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGNvbXBvbmVudC5fZ2xvYmFsQ29udGV4dCxcblx0XHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHRcdG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb21cblx0XHQpO1xuXHRcdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcblxuXHRcdGlmIChuZXdEb20gIT0gb2xkRG9tKSB7XG5cdFx0XHR1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpIHtcblx0aWYgKCh2bm9kZSA9IHZub2RlLl9wYXJlbnQpICE9IG51bGwgJiYgdm5vZGUuX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0dm5vZGUuX2RvbSA9IHZub2RlLl9jb21wb25lbnQuYmFzZSA9IG51bGw7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBjaGlsZCA9IHZub2RlLl9jaGlsZHJlbltpXTtcblx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLl9kb20gIT0gbnVsbCkge1xuXHRcdFx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gY2hpbGQuX2RvbTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSByZW5kZXIgcXVldWVcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fVxuICovXG5sZXQgcmVyZW5kZXJRdWV1ZSA9IFtdO1xubGV0IHJlcmVuZGVyQ291bnQgPSAwO1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAqIEB0eXBlIHsoY2I6ICgpID0+IHZvaWQpID0+IHZvaWR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vLyBOb3RlIHRoZSBmb2xsb3dpbmcgbGluZSBpc24ndCB0cmVlLXNoYWtlbiBieSByb2xsdXAgY3V6IG9mIHJvbGx1cC9yb2xsdXAjMjU2NlxuY29uc3QgZGVmZXIgPVxuXHR0eXBlb2YgUHJvbWlzZSA9PSAnZnVuY3Rpb24nXG5cdFx0PyBQcm9taXNlLnByb3RvdHlwZS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpXG5cdFx0OiBzZXRUaW1lb3V0O1xuXG4vKlxuICogVGhlIHZhbHVlIG9mIGBDb21wb25lbnQuZGVib3VuY2VgIG11c3QgYXN5bmNocm9ub3VzbHkgaW52b2tlIHRoZSBwYXNzZWQgaW4gY2FsbGJhY2suIEl0IGlzXG4gKiBpbXBvcnRhbnQgdGhhdCBjb250cmlidXRvcnMgdG8gUHJlYWN0IGNhbiBjb25zaXN0ZW50bHkgcmVhc29uIGFib3V0IHdoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCwgZXRjLlxuICogZG8sIGFuZCB3aGVuIHRoZWlyIGVmZmVjdHMgd2lsbCBiZSBhcHBsaWVkLiBTZWUgdGhlIGxpbmtzIGJlbG93IGZvciBzb21lIGZ1cnRoZXIgcmVhZGluZyBvbiBkZXNpZ25pbmdcbiAqIGFzeW5jaHJvbm91cyBBUElzLlxuICogKiBbRGVzaWduaW5nIEFQSXMgZm9yIEFzeW5jaHJvbnldKGh0dHBzOi8vYmxvZy5penMubWUvMjAxMy8wOC9kZXNpZ25pbmctYXBpcy1mb3ItYXN5bmNocm9ueSlcbiAqICogW0NhbGxiYWNrcyBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzXShodHRwczovL2Jsb2cub21ldGVyLmNvbS8yMDExLzA3LzI0L2NhbGxiYWNrcy1zeW5jaHJvbm91cy1hbmQtYXN5bmNocm9ub3VzLylcbiAqL1xuXG5sZXQgcHJldkRlYm91bmNlO1xuXG4vKipcbiAqIEVucXVldWUgYSByZXJlbmRlciBvZiBhIGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9IGMgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5xdWV1ZVJlbmRlcihjKSB7XG5cdGlmIChcblx0XHQoIWMuX2RpcnR5ICYmXG5cdFx0XHQoYy5fZGlydHkgPSB0cnVlKSAmJlxuXHRcdFx0cmVyZW5kZXJRdWV1ZS5wdXNoKGMpICYmXG5cdFx0XHQhcmVyZW5kZXJDb3VudCsrKSB8fFxuXHRcdHByZXZEZWJvdW5jZSAhPT0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZ1xuXHQpIHtcblx0XHRwcmV2RGVib3VuY2UgPSBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nO1xuXHRcdChwcmV2RGVib3VuY2UgfHwgZGVmZXIpKHByb2Nlc3MpO1xuXHR9XG59XG5cbi8qKiBGbHVzaCB0aGUgcmVuZGVyIHF1ZXVlIGJ5IHJlcmVuZGVyaW5nIGFsbCBxdWV1ZWQgY29tcG9uZW50cyAqL1xuZnVuY3Rpb24gcHJvY2VzcygpIHtcblx0bGV0IHF1ZXVlO1xuXHR3aGlsZSAoKHJlcmVuZGVyQ291bnQgPSByZXJlbmRlclF1ZXVlLmxlbmd0aCkpIHtcblx0XHRxdWV1ZSA9IHJlcmVuZGVyUXVldWUuc29ydCgoYSwgYikgPT4gYS5fdm5vZGUuX2RlcHRoIC0gYi5fdm5vZGUuX2RlcHRoKTtcblx0XHRyZXJlbmRlclF1ZXVlID0gW107XG5cdFx0Ly8gRG9uJ3QgdXBkYXRlIGByZW5kZXJDb3VudGAgeWV0LiBLZWVwIGl0cyB2YWx1ZSBub24temVybyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5XG5cdFx0Ly8gcHJvY2VzcygpIGNhbGxzIGZyb20gZ2V0dGluZyBzY2hlZHVsZWQgd2hpbGUgYHF1ZXVlYCBpcyBzdGlsbCBiZWluZyBjb25zdW1lZC5cblx0XHRxdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0aWYgKGMuX2RpcnR5KSByZW5kZXJDb21wb25lbnQoYyk7XG5cdFx0fSk7XG5cdH1cbn1cbiIsImltcG9ydCB7IEVNUFRZX09CSiwgRU1QVFlfQVJSIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY29tbWl0Um9vdCwgZGlmZiB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcblxuY29uc3QgSVNfSFlEUkFURSA9IEVNUFRZX09CSjtcblxuLyoqXG4gKiBSZW5kZXIgYSBQcmVhY3QgdmlydHVhbCBub2RlIGludG8gYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogcmVuZGVyIGludG9cbiAqIEBwYXJhbSB7RWxlbWVudCB8IFRleHR9IFtyZXBsYWNlTm9kZV0gT3B0aW9uYWw6IEF0dGVtcHQgdG8gcmUtdXNlIGFuXG4gKiBleGlzdGluZyBET00gdHJlZSByb290ZWQgYXQgYHJlcGxhY2VOb2RlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnREb20sIHJlcGxhY2VOb2RlKSB7XG5cdGlmIChvcHRpb25zLl9yb290KSBvcHRpb25zLl9yb290KHZub2RlLCBwYXJlbnREb20pO1xuXG5cdC8vIFdlIGFidXNlIHRoZSBgcmVwbGFjZU5vZGVgIHBhcmFtZXRlciBpbiBgaHlkcmF0ZSgpYCB0byBzaWduYWwgaWYgd2Vcblx0Ly8gYXJlIGluIGh5ZHJhdGlvbiBtb2RlIG9yIG5vdCBieSBwYXNzaW5nIGBJU19IWURSQVRFYCBpbnN0ZWFkIG9mIGFcblx0Ly8gRE9NIGVsZW1lbnQuXG5cdGxldCBpc0h5ZHJhdGluZyA9IHJlcGxhY2VOb2RlID09PSBJU19IWURSQVRFO1xuXG5cdC8vIFRvIGJlIGFibGUgdG8gc3VwcG9ydCBjYWxsaW5nIGByZW5kZXIoKWAgbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWVcblx0Ly8gRE9NIG5vZGUsIHdlIG5lZWQgdG8gb2J0YWluIGEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyB0cmVlLiBXZSBkb1xuXHQvLyB0aGlzIGJ5IGFzc2lnbmluZyBhIG5ldyBgX2NoaWxkcmVuYCBwcm9wZXJ0eSB0byBET00gbm9kZXMgd2hpY2ggcG9pbnRzXG5cdC8vIHRvIHRoZSBsYXN0IHJlbmRlcmVkIHRyZWUuIEJ5IGRlZmF1bHQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCwgd2hpY2hcblx0Ly8gbWVhbnMgdGhhdCB3ZSBhcmUgbW91bnRpbmcgYSBuZXcgdHJlZSBmb3IgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBvbGRWTm9kZSA9IGlzSHlkcmF0aW5nXG5cdFx0PyBudWxsXG5cdFx0OiAocmVwbGFjZU5vZGUgJiYgcmVwbGFjZU5vZGUuX2NoaWxkcmVuKSB8fCBwYXJlbnREb20uX2NoaWxkcmVuO1xuXHR2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFt2bm9kZV0pO1xuXG5cdC8vIExpc3Qgb2YgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyIGRpZmZpbmcuXG5cdGxldCBjb21taXRRdWV1ZSA9IFtdO1xuXHRkaWZmKFxuXHRcdHBhcmVudERvbSxcblx0XHQvLyBEZXRlcm1pbmUgdGhlIG5ldyB2bm9kZSB0cmVlIGFuZCBzdG9yZSBpdCBvbiB0aGUgRE9NIGVsZW1lbnQgb25cblx0XHQvLyBvdXIgY3VzdG9tIGBfY2hpbGRyZW5gIHByb3BlcnR5LlxuXHRcdCgoaXNIeWRyYXRpbmcgPyBwYXJlbnREb20gOiByZXBsYWNlTm9kZSB8fCBwYXJlbnREb20pLl9jaGlsZHJlbiA9IHZub2RlKSxcblx0XHRvbGRWTm9kZSB8fCBFTVBUWV9PQkosXG5cdFx0RU1QVFlfT0JKLFxuXHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHRyZXBsYWNlTm9kZSAmJiAhaXNIeWRyYXRpbmdcblx0XHRcdD8gW3JlcGxhY2VOb2RlXVxuXHRcdFx0OiBvbGRWTm9kZVxuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IEVNUFRZX0FSUi5zbGljZS5jYWxsKHBhcmVudERvbS5jaGlsZE5vZGVzKSxcblx0XHRjb21taXRRdWV1ZSxcblx0XHRyZXBsYWNlTm9kZSB8fCBFTVBUWV9PQkosXG5cdFx0aXNIeWRyYXRpbmdcblx0KTtcblxuXHQvLyBGbHVzaCBhbGwgcXVldWVkIGVmZmVjdHNcblx0Y29tbWl0Um9vdChjb21taXRRdWV1ZSwgdm5vZGUpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBET00gZWxlbWVudCB3aXRoIGRhdGEgZnJvbSBhIFByZWFjdCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHVwZGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50RG9tKSB7XG5cdHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCBJU19IWURSQVRFKTtcbn1cbiIsImltcG9ydCB7IGVucXVldWVSZW5kZXIgfSBmcm9tICcuL2NvbXBvbmVudCc7XG5cbmV4cG9ydCBsZXQgaSA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuXHRjb25zdCBjdHggPSB7fTtcblxuXHRjb25zdCBjb250ZXh0ID0ge1xuXHRcdF9pZDogJ19fY0MnICsgaSsrLFxuXHRcdF9kZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcblx0XHRDb25zdW1lcihwcm9wcywgY29udGV4dCkge1xuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuKGNvbnRleHQpO1xuXHRcdH0sXG5cdFx0UHJvdmlkZXIocHJvcHMpIHtcblx0XHRcdGlmICghdGhpcy5nZXRDaGlsZENvbnRleHQpIHtcblx0XHRcdFx0Y29uc3Qgc3VicyA9IFtdO1xuXHRcdFx0XHR0aGlzLmdldENoaWxkQ29udGV4dCA9ICgpID0+IHtcblx0XHRcdFx0XHRjdHhbY29udGV4dC5faWRdID0gdGhpcztcblx0XHRcdFx0XHRyZXR1cm4gY3R4O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gX3Byb3BzID0+IHtcblx0XHRcdFx0XHRpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gX3Byb3BzLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHRzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHRcdGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnN1YiA9IGMgPT4ge1xuXHRcdFx0XHRcdHN1YnMucHVzaChjKTtcblx0XHRcdFx0XHRsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcblx0XHRcdFx0XHRcdG9sZCAmJiBvbGQuY2FsbChjKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnRleHQuQ29uc3VtZXIuY29udGV4dFR5cGUgPSBjb250ZXh0O1xuXG5cdC8vIERldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3Qgd2hlbiBpdFxuXHQvLyBlbmNvdW50ZXJzIGEgUHJvdmlkZXIuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHN1cHBvcnRcblx0Ly8gc2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIHRoZSBjb250ZXh0IG9iamVjdCBpbnN0ZWFkXG5cdC8vIG9mIG9uIHRoZSBjb21wb25lbnQgaXRzZWxmLiBTZWU6XG5cdC8vIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9jb250ZXh0Lmh0bWwjY29udGV4dGRpc3BsYXluYW1lXG5cdGNvbnRleHQuUHJvdmlkZXIuX2NvbnRleHRSZWYgPSBjb250ZXh0O1xuXG5cdHJldHVybiBjb250ZXh0O1xufVxuIiwiLyoqXG4gKiBBc3NpZ24gcHJvcGVydGllcyBmcm9tIGBwcm9wc2AgdG8gYG9iamBcbiAqIEB0ZW1wbGF0ZSBPLCBQIFRoZSBvYmogYW5kIHByb3BzIHR5cGVzXG4gKiBAcGFyYW0ge099IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIHtQfSBwcm9wcyBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJucyB7TyAmIFB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSBpdHMgcGFyZW50IGlmIGF0dGFjaGVkLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3JcbiAqIElFMTEgd2hpY2ggZG9lc24ndCBzdXBwb3J0IGBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUoKWAuIFVzaW5nIHRoaXMgZnVuY3Rpb25cbiAqIGlzIHNtYWxsZXIgdGhhbiBpbmNsdWRpbmcgYSBkZWRpY2F0ZWQgcG9seWZpbGwuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuIiwiaW1wb3J0IHsgZGlmZiwgdW5tb3VudCwgYXBwbHlSZWYgfSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZVZOb2RlIH0gZnJvbSAnLi4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IHsgRU1QVFlfT0JKLCBFTVBUWV9BUlIgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgcmVtb3ZlTm9kZSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgZ2V0RG9tU2libGluZyB9IGZyb20gJy4uL2NvbXBvbmVudCc7XG5cbi8qKlxuICogRGlmZiB0aGUgY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgd2hvc2VcbiAqIGNoaWxkcmVuIGFyZSBiZWluZyBkaWZmZWRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdQYXJlbnRWTm9kZSBUaGUgbmV3IHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBvbGRQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFBhcmVudFZOb2RlIFRoZSBvbGQgdmlydHVhbFxuICogbm9kZSB3aG9zZSBjaGlsZHJlbiBzaG91bGQgYmUgZGlmZidlZCBhZ2FpbnN0IG5ld1BhcmVudFZOb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdCAtIG1vZGlmaWVkIGJ5IGdldENoaWxkQ29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7Tm9kZSB8IFRleHR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQ2hpbGRyZW4oXG5cdHBhcmVudERvbSxcblx0bmV3UGFyZW50Vk5vZGUsXG5cdG9sZFBhcmVudFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IGksIGosIG9sZFZOb2RlLCBuZXdEb20sIHNpYkRvbSwgZmlyc3RDaGlsZERvbSwgcmVmcztcblxuXHQvLyBUaGlzIGlzIGEgY29tcHJlc3Npb24gb2Ygb2xkUGFyZW50Vk5vZGUhPW51bGwgJiYgb2xkUGFyZW50Vk5vZGUgIT0gRU1QVFlfT0JKICYmIG9sZFBhcmVudFZOb2RlLl9jaGlsZHJlbiB8fCBFTVBUWV9BUlJcblx0Ly8gYXMgRU1QVFlfT0JKLl9jaGlsZHJlbiBzaG91bGQgYmUgYHVuZGVmaW5lZGAuXG5cdGxldCBvbGRDaGlsZHJlbiA9IChvbGRQYXJlbnRWTm9kZSAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4pIHx8IEVNUFRZX0FSUjtcblxuXHRsZXQgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cblx0Ly8gT25seSBpbiB2ZXJ5IHNwZWNpZmljIHBsYWNlcyBzaG91bGQgdGhpcyBsb2dpYyBiZSBpbnZva2VkICh0b3AgbGV2ZWwgYHJlbmRlcmAgYW5kIGBkaWZmRWxlbWVudE5vZGVzYCkuXG5cdC8vIEknbSB1c2luZyBgRU1QVFlfT0JKYCB0byBzaWduYWwgd2hlbiBgZGlmZkNoaWxkcmVuYCBpcyBpbnZva2VkIGluIHRoZXNlIHNpdHVhdGlvbnMuIEkgY2FuJ3QgdXNlIGBudWxsYFxuXHQvLyBmb3IgdGhpcyBwdXJwb3NlLCBiZWNhdXNlIGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlIGZvciBgb2xkRG9tYCB3aGljaCBjYW4gbWVhbiB0byBza2lwIHRvIHRoaXMgbG9naWNcblx0Ly8gKGUuZy4gaWYgbW91bnRpbmcgYSBuZXcgdHJlZSBpbiB3aGljaCB0aGUgb2xkIERPTSBzaG91bGQgYmUgaWdub3JlZCAodXN1YWxseSBmb3IgRnJhZ21lbnRzKS5cblx0aWYgKG9sZERvbSA9PSBFTVBUWV9PQkopIHtcblx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0b2xkRG9tID0gZXhjZXNzRG9tQ2hpbGRyZW5bMF07XG5cdFx0fSBlbHNlIGlmIChvbGRDaGlsZHJlbkxlbmd0aCkge1xuXHRcdFx0b2xkRG9tID0gZ2V0RG9tU2libGluZyhvbGRQYXJlbnRWTm9kZSwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9sZERvbSA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0aSA9IDA7XG5cdG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbiA9IHRvQ2hpbGRBcnJheShcblx0XHRuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW4sXG5cdFx0Y2hpbGRWTm9kZSA9PiB7XG5cdFx0XHRpZiAoY2hpbGRWTm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNoaWxkVk5vZGUuX3BhcmVudCA9IG5ld1BhcmVudFZOb2RlO1xuXHRcdFx0XHRjaGlsZFZOb2RlLl9kZXB0aCA9IG5ld1BhcmVudFZOb2RlLl9kZXB0aCArIDE7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgZmluZCBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBvbGRDaGlsZHJlbi5cblx0XHRcdFx0Ly8gSWYgZm91bmQsIGRlbGV0ZSB0aGUgYXJyYXkgaXRlbSBieSBzZXR0aW5nIHRvIGB1bmRlZmluZWRgLlxuXHRcdFx0XHQvLyBXZSB1c2UgYHVuZGVmaW5lZGAsIGFzIGBudWxsYCBpcyByZXNlcnZlZCBmb3IgZW1wdHkgcGxhY2Vob2xkZXJzXG5cdFx0XHRcdC8vIChob2xlcykuXG5cdFx0XHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG9sZFZOb2RlID09PSBudWxsIHx8XG5cdFx0XHRcdFx0KG9sZFZOb2RlICYmXG5cdFx0XHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0XHRcdGNoaWxkVk5vZGUudHlwZSA9PT0gb2xkVk5vZGUudHlwZSlcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0b2xkQ2hpbGRyZW5baV0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gRWl0aGVyIG9sZFZOb2RlID09PSB1bmRlZmluZWQgb3Igb2xkQ2hpbGRyZW5MZW5ndGggPiAwLFxuXHRcdFx0XHRcdC8vIHNvIGFmdGVyIHRoaXMgbG9vcCBvbGRWTm9kZSA9PSBudWxsIG9yIG9sZFZOb2RlIGlzIGEgdmFsaWQgdmFsdWUuXG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IG9sZENoaWxkcmVuTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5bal07XG5cdFx0XHRcdFx0XHQvLyBJZiBjaGlsZFZOb2RlIGlzIHVua2V5ZWQsIHdlIG9ubHkgbWF0Y2ggc2ltaWxhcmx5IHVua2V5ZWQgbm9kZXMsIG90aGVyd2lzZSB3ZSBtYXRjaCBieSBrZXkuXG5cdFx0XHRcdFx0XHQvLyBXZSBhbHdheXMgbWF0Y2ggYnkgdHlwZSAoaW4gZWl0aGVyIGNhc2UpLlxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRvbGRWTm9kZSAmJlxuXHRcdFx0XHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlID09PSBvbGRWTm9kZS50eXBlXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0b2xkQ2hpbGRyZW5bal0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b2xkVk5vZGUgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9sZFZOb2RlID0gb2xkVk5vZGUgfHwgRU1QVFlfT0JKO1xuXG5cdFx0XHRcdC8vIE1vcnBoIHRoZSBvbGQgZWxlbWVudCBpbnRvIHRoZSBuZXcgb25lLCBidXQgZG9uJ3QgYXBwZW5kIGl0IHRvIHRoZSBkb20geWV0XG5cdFx0XHRcdG5ld0RvbSA9IGRpZmYoXG5cdFx0XHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoKGogPSBjaGlsZFZOb2RlLnJlZikgJiYgb2xkVk5vZGUucmVmICE9IGopIHtcblx0XHRcdFx0XHRpZiAoIXJlZnMpIHJlZnMgPSBbXTtcblx0XHRcdFx0XHRpZiAob2xkVk5vZGUucmVmKSByZWZzLnB1c2gob2xkVk5vZGUucmVmLCBudWxsLCBjaGlsZFZOb2RlKTtcblx0XHRcdFx0XHRyZWZzLnB1c2goaiwgY2hpbGRWTm9kZS5fY29tcG9uZW50IHx8IG5ld0RvbSwgY2hpbGRWTm9kZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPbmx5IHByb2NlZWQgaWYgdGhlIHZub2RlIGhhcyBub3QgYmVlbiB1bm1vdW50ZWQgYnkgYGRpZmYoKWAgYWJvdmUuXG5cdFx0XHRcdGlmIChuZXdEb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChmaXJzdENoaWxkRG9tID09IG51bGwpIHtcblx0XHRcdFx0XHRcdGZpcnN0Q2hpbGREb20gPSBuZXdEb207XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IG5leHREb207XG5cdFx0XHRcdFx0aWYgKGNoaWxkVk5vZGUuX25leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Ly8gT25seSBGcmFnbWVudHMgb3IgY29tcG9uZW50cyB0aGF0IHJldHVybiBGcmFnbWVudCBsaWtlIFZOb2RlcyB3aWxsXG5cdFx0XHRcdFx0XHQvLyBoYXZlIGEgbm9uLXVuZGVmaW5lZCBfbmV4dERvbS4gQ29udGludWUgdGhlIGRpZmYgZnJvbSB0aGUgc2libGluZ1xuXHRcdFx0XHRcdFx0Ly8gb2YgbGFzdCBET00gY2hpbGQgb2YgdGhpcyBjaGlsZCBWTm9kZVxuXHRcdFx0XHRcdFx0bmV4dERvbSA9IGNoaWxkVk5vZGUuX25leHREb207XG5cblx0XHRcdFx0XHRcdC8vIEVhZ2VybHkgY2xlYW51cCBfbmV4dERvbS4gV2UgZG9uJ3QgbmVlZCB0byBwZXJzaXN0IHRoZSB2YWx1ZSBiZWNhdXNlXG5cdFx0XHRcdFx0XHQvLyBpdCBpcyBvbmx5IHVzZWQgYnkgYGRpZmZDaGlsZHJlbmAgdG8gZGV0ZXJtaW5lIHdoZXJlIHRvIHJlc3VtZSB0aGUgZGlmZiBhZnRlclxuXHRcdFx0XHRcdFx0Ly8gZGlmZmluZyBDb21wb25lbnRzIGFuZCBGcmFnbWVudHMuIE9uY2Ugd2Ugc3RvcmUgaXQgdGhlIG5leHRET00gbG9jYWwgdmFyLCB3ZVxuXHRcdFx0XHRcdFx0Ly8gY2FuIGNsZWFuIHVwIHRoZSBwcm9wZXJ0eVxuXHRcdFx0XHRcdFx0Y2hpbGRWTm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPT0gb2xkVk5vZGUgfHxcblx0XHRcdFx0XHRcdG5ld0RvbSAhPSBvbGREb20gfHxcblx0XHRcdFx0XHRcdG5ld0RvbS5wYXJlbnROb2RlID09IG51bGxcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdC8vIE5PVEU6IGV4Y2Vzc0RvbUNoaWxkcmVuPT1vbGRWTm9kZSBhYm92ZTpcblx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBjb21wcmVzc2lvbiBvZiBleGNlc3NEb21DaGlsZHJlbj09bnVsbCAmJiBvbGRWTm9kZT09bnVsbCFcblx0XHRcdFx0XHRcdC8vIFRoZSB2YWx1ZXMgb25seSBoYXZlIHRoZSBzYW1lIHR5cGUgd2hlbiBgbnVsbGAuXG5cblx0XHRcdFx0XHRcdG91dGVyOiBpZiAob2xkRG9tID09IG51bGwgfHwgb2xkRG9tLnBhcmVudE5vZGUgIT09IHBhcmVudERvbSkge1xuXHRcdFx0XHRcdFx0XHRwYXJlbnREb20uYXBwZW5kQ2hpbGQobmV3RG9tKTtcblx0XHRcdFx0XHRcdFx0bmV4dERvbSA9IG51bGw7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBgajxvbGRDaGlsZHJlbkxlbmd0aDsgais9MmAgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gYGorKzxvbGRDaGlsZHJlbkxlbmd0aC8yYFxuXHRcdFx0XHRcdFx0XHRmb3IgKFxuXHRcdFx0XHRcdFx0XHRcdHNpYkRvbSA9IG9sZERvbSwgaiA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0KHNpYkRvbSA9IHNpYkRvbS5uZXh0U2libGluZykgJiYgaiA8IG9sZENoaWxkcmVuTGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdGogKz0gMlxuXHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoc2liRG9tID09IG5ld0RvbSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHBhcmVudERvbS5pbnNlcnRCZWZvcmUobmV3RG9tLCBvbGREb20pO1xuXHRcdFx0XHRcdFx0XHRuZXh0RG9tID0gb2xkRG9tO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBCcm93c2VycyB3aWxsIGluZmVyIGFuIG9wdGlvbidzIGB2YWx1ZWAgZnJvbSBgdGV4dENvbnRlbnRgIHdoZW5cblx0XHRcdFx0XHRcdC8vIG5vIHZhbHVlIGlzIHByZXNlbnQuIFRoaXMgZXNzZW50aWFsbHkgYnlwYXNzZXMgb3VyIGNvZGUgdG8gc2V0IGl0XG5cdFx0XHRcdFx0XHQvLyBsYXRlciBpbiBgZGlmZigpYC4gSXQgd29ya3MgZmluZSBpbiBhbGwgYnJvd3NlcnMgZXhjZXB0IGZvciBJRTExXG5cdFx0XHRcdFx0XHQvLyB3aGVyZSBpdCBicmVha3Mgc2V0dGluZyBgc2VsZWN0LnZhbHVlYC4gVGhlcmUgaXQgd2lsbCBiZSBhbHdheXMgc2V0XG5cdFx0XHRcdFx0XHQvLyB0byBhbiBlbXB0eSBzdHJpbmcuIFJlLWFwcGx5aW5nIGFuIG9wdGlvbnMgdmFsdWUgd2lsbCBmaXggdGhhdCwgc29cblx0XHRcdFx0XHRcdC8vIHRoZXJlIGFyZSBwcm9iYWJseSBzb21lIGludGVybmFsIGRhdGEgc3RydWN0dXJlcyB0aGF0IGFyZW4ndFxuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlZCBwcm9wZXJseS5cblx0XHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0XHQvLyBUbyBmaXggaXQgd2UgbWFrZSBzdXJlIHRvIHJlc2V0IHRoZSBpbmZlcnJlZCB2YWx1ZSwgc28gdGhhdCBvdXIgb3duXG5cdFx0XHRcdFx0XHQvLyB2YWx1ZSBjaGVjayBpbiBgZGlmZigpYCB3b24ndCBiZSBza2lwcGVkLlxuXHRcdFx0XHRcdFx0aWYgKG5ld1BhcmVudFZOb2RlLnR5cGUgPT0gJ29wdGlvbicpIHtcblx0XHRcdFx0XHRcdFx0cGFyZW50RG9tLnZhbHVlID0gJyc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBwcmUtY2FsY3VsYXRlZCB0aGUgbmV4dERPTSBub2RlLCB1c2UgaXQuIEVsc2UgY2FsY3VsYXRlIGl0IG5vd1xuXHRcdFx0XHRcdC8vIFN0cmljdGx5IGNoZWNrIGZvciBgdW5kZWZpbmVkYCBoZXJlIGN1eiBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZSBvZiBgbmV4dERvbWAuXG5cdFx0XHRcdFx0Ly8gU2VlIG1vcmUgZGV0YWlsIGluIGNyZWF0ZS1lbGVtZW50LmpzOmNyZWF0ZVZOb2RlXG5cdFx0XHRcdFx0aWYgKG5leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0b2xkRG9tID0gbmV4dERvbTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b2xkRG9tID0gbmV3RG9tLm5leHRTaWJsaW5nO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHQvLyBCZWNhdXNlIHRoZSBuZXdQYXJlbnRWTm9kZSBpcyBGcmFnbWVudC1saWtlLCB3ZSBuZWVkIHRvIHNldCBpdCdzXG5cdFx0XHRcdFx0XHQvLyBfbmV4dERvbSBwcm9wZXJ0eSB0byB0aGUgbmV4dFNpYmxpbmcgb2YgaXRzIGxhc3QgY2hpbGQgRE9NIG5vZGUuXG5cdFx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdFx0Ly8gYG9sZERvbWAgY29udGFpbnMgdGhlIGNvcnJlY3QgdmFsdWUgaGVyZSBiZWNhdXNlIGlmIHRoZSBsYXN0IGNoaWxkXG5cdFx0XHRcdFx0XHQvLyBpcyBhIEZyYWdtZW50LWxpa2UsIHRoZW4gb2xkRG9tIGhhcyBhbHJlYWR5IGJlZW4gc2V0IHRvIHRoYXQgY2hpbGQncyBfbmV4dERvbS5cblx0XHRcdFx0XHRcdC8vIElmIHRoZSBsYXN0IGNoaWxkIGlzIGEgRE9NIFZOb2RlLCB0aGVuIG9sZERvbSB3aWxsIGJlIHNldCB0byB0aGF0IERPTVxuXHRcdFx0XHRcdFx0Ly8gbm9kZSdzIG5leHRTaWJsaW5nLlxuXG5cdFx0XHRcdFx0XHRuZXdQYXJlbnRWTm9kZS5fbmV4dERvbSA9IG9sZERvbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0b2xkRG9tICYmXG5cdFx0XHRcdFx0b2xkVk5vZGUuX2RvbSA9PSBvbGREb20gJiZcblx0XHRcdFx0XHRvbGREb20ucGFyZW50Tm9kZSAhPSBwYXJlbnREb21cblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gVGhlIGFib3ZlIGNvbmRpdGlvbiBpcyB0byBoYW5kbGUgbnVsbCBwbGFjZWhvbGRlcnMuIFNlZSB0ZXN0IGluIHBsYWNlaG9sZGVyLnRlc3QuanM6XG5cdFx0XHRcdFx0Ly8gYGVmZmljaWVudGx5IHJlcGxhY2UgbnVsbCBwbGFjZWhvbGRlcnMgaW4gcGFyZW50IHJlcmVuZGVyc2Bcblx0XHRcdFx0XHRvbGREb20gPSBnZXREb21TaWJsaW5nKG9sZFZOb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpKys7XG5cdFx0XHRyZXR1cm4gY2hpbGRWTm9kZTtcblx0XHR9XG5cdCk7XG5cblx0bmV3UGFyZW50Vk5vZGUuX2RvbSA9IGZpcnN0Q2hpbGREb207XG5cblx0Ly8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIGFueSB2bm9kZS5cblx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwgJiYgdHlwZW9mIG5ld1BhcmVudFZOb2RlLnR5cGUgIT0gJ2Z1bmN0aW9uJykge1xuXHRcdGZvciAoaSA9IGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbltpXSAhPSBudWxsKSByZW1vdmVOb2RlKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgcmVtYWluaW5nIG9sZENoaWxkcmVuIGlmIHRoZXJlIGFyZSBhbnkuXG5cdGZvciAoaSA9IG9sZENoaWxkcmVuTGVuZ3RoOyBpLS07ICkge1xuXHRcdGlmIChvbGRDaGlsZHJlbltpXSAhPSBudWxsKSB1bm1vdW50KG9sZENoaWxkcmVuW2ldLCBvbGRDaGlsZHJlbltpXSk7XG5cdH1cblxuXHQvLyBTZXQgcmVmcyBvbmx5IGFmdGVyIHVubW91bnRcblx0aWYgKHJlZnMpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXBwbHlSZWYocmVmc1tpXSwgcmVmc1srK2ldLCByZWZzWysraV0pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEZsYXR0ZW4gYW5kIGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVufSBjaGlsZHJlbiBUaGUgdW5mbGF0dGVuZWRcbiAqIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0geyh2bm9kZTogaW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlKSA9PiBpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IFtjYWxsYmFja11cbiAqIEEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIGNoaWxkIGJlZm9yZSBpdCBpcyBhZGRlZCB0byB0aGUgZmxhdHRlbmVkIGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZSB8IHN0cmluZyB8IG51bWJlcj59IFtmbGF0dGVuZWRdIEFuIGZsYXQgYXJyYXkgb2YgY2hpbGRyZW4gdG8gbW9kaWZ5XG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0NoaWxkQXJyYXkoY2hpbGRyZW4sIGNhbGxiYWNrLCBmbGF0dGVuZWQpIHtcblx0aWYgKGZsYXR0ZW5lZCA9PSBudWxsKSBmbGF0dGVuZWQgPSBbXTtcblxuXHRpZiAoY2hpbGRyZW4gPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGRyZW4gPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0aWYgKGNhbGxiYWNrKSBmbGF0dGVuZWQucHVzaChjYWxsYmFjayhudWxsKSk7XG5cdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0b0NoaWxkQXJyYXkoY2hpbGRyZW5baV0sIGNhbGxiYWNrLCBmbGF0dGVuZWQpO1xuXHRcdH1cblx0fSBlbHNlIGlmICghY2FsbGJhY2spIHtcblx0XHRmbGF0dGVuZWQucHVzaChjaGlsZHJlbik7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZHJlbiA9PSAnbnVtYmVyJykge1xuXHRcdGZsYXR0ZW5lZC5wdXNoKGNhbGxiYWNrKGNyZWF0ZVZOb2RlKG51bGwsIGNoaWxkcmVuLCBudWxsLCBudWxsLCBjaGlsZHJlbikpKTtcblx0fSBlbHNlIGlmIChjaGlsZHJlbi5fZG9tICE9IG51bGwgfHwgY2hpbGRyZW4uX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0ZmxhdHRlbmVkLnB1c2goXG5cdFx0XHRjYWxsYmFjayhcblx0XHRcdFx0Y3JlYXRlVk5vZGUoXG5cdFx0XHRcdFx0Y2hpbGRyZW4udHlwZSxcblx0XHRcdFx0XHRjaGlsZHJlbi5wcm9wcyxcblx0XHRcdFx0XHRjaGlsZHJlbi5rZXksXG5cdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRjaGlsZHJlbi5fb3JpZ2luYWxcblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0gZWxzZSB7XG5cdFx0ZmxhdHRlbmVkLnB1c2goY2FsbGJhY2soY2hpbGRyZW4pKTtcblx0fVxuXG5cdHJldHVybiBmbGF0dGVuZWQ7XG59XG4iLCJpbXBvcnQgeyBJU19OT05fRElNRU5TSU9OQUwgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi4vb3B0aW9ucyc7XG5cbi8qKlxuICogRGlmZiB0aGUgb2xkIGFuZCBuZXcgcHJvcGVydGllcyBvZiBhIFZOb2RlIGFuZCBhcHBseSBjaGFuZ2VzIHRvIHRoZSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBhcHBseVxuICogY2hhbmdlcyB0b1xuICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzIFRoZSBuZXcgcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbGRQcm9wcyBUaGUgb2xkIHByb3BzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBoeWRyYXRlIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb24gbW9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZlByb3BzKGRvbSwgbmV3UHJvcHMsIG9sZFByb3BzLCBpc1N2ZywgaHlkcmF0ZSkge1xuXHRsZXQgaTtcblxuXHRmb3IgKGkgaW4gb2xkUHJvcHMpIHtcblx0XHRpZiAoaSAhPT0gJ2NoaWxkcmVuJyAmJiBpICE9PSAna2V5JyAmJiAhKGkgaW4gbmV3UHJvcHMpKSB7XG5cdFx0XHRzZXRQcm9wZXJ0eShkb20sIGksIG51bGwsIG9sZFByb3BzW2ldLCBpc1N2Zyk7XG5cdFx0fVxuXHR9XG5cblx0Zm9yIChpIGluIG5ld1Byb3BzKSB7XG5cdFx0aWYgKFxuXHRcdFx0KCFoeWRyYXRlIHx8IHR5cGVvZiBuZXdQcm9wc1tpXSA9PSAnZnVuY3Rpb24nKSAmJlxuXHRcdFx0aSAhPT0gJ2NoaWxkcmVuJyAmJlxuXHRcdFx0aSAhPT0gJ2tleScgJiZcblx0XHRcdGkgIT09ICd2YWx1ZScgJiZcblx0XHRcdGkgIT09ICdjaGVja2VkJyAmJlxuXHRcdFx0b2xkUHJvcHNbaV0gIT09IG5ld1Byb3BzW2ldXG5cdFx0KSB7XG5cdFx0XHRzZXRQcm9wZXJ0eShkb20sIGksIG5ld1Byb3BzW2ldLCBvbGRQcm9wc1tpXSwgaXNTdmcpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwga2V5LCB2YWx1ZSkge1xuXHRpZiAoa2V5WzBdID09PSAnLScpIHtcblx0XHRzdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcblx0fSBlbHNlIGlmIChcblx0XHR0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcblx0XHRJU19OT05fRElNRU5TSU9OQUwudGVzdChrZXkpID09PSBmYWxzZVxuXHQpIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWUgKyAncHgnO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRzdHlsZVtrZXldID0gJyc7XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlO1xuXHR9XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgdmFsdWUgb24gYSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBtb2RpZnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgcHJvcGVydHkgdG9cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSB0aGUgcHJvcGVydHkgaGFkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGUgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eShkb20sIG5hbWUsIHZhbHVlLCBvbGRWYWx1ZSwgaXNTdmcpIHtcblx0bGV0IHMsIHVzZUNhcHR1cmUsIG5hbWVMb3dlcjtcblxuXHRpZiAoaXNTdmcpIHtcblx0XHRpZiAobmFtZSA9PT0gJ2NsYXNzTmFtZScpIHtcblx0XHRcdG5hbWUgPSAnY2xhc3MnO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG5cdFx0bmFtZSA9ICdjbGFzc05hbWUnO1xuXHR9XG5cblx0aWYgKG5hbWUgPT09ICdzdHlsZScpIHtcblx0XHRzID0gZG9tLnN0eWxlO1xuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0cy5jc3NUZXh0ID0gdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkVmFsdWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cy5jc3NUZXh0ID0gJyc7XG5cdFx0XHRcdG9sZFZhbHVlID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9sZFZhbHVlKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgaW4gb2xkVmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoISh2YWx1ZSAmJiBpIGluIHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUocywgaSwgJycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICghb2xkVmFsdWUgfHwgdmFsdWVbaV0gIT09IG9sZFZhbHVlW2ldKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShzLCBpLCB2YWx1ZVtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIEJlbmNobWFyayBmb3IgY29tcGFyaXNvbjogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81NzRjOTU0YmRiOTY1YjlhMDA5NjVhYzZcblx0ZWxzZSBpZiAobmFtZVswXSA9PT0gJ28nICYmIG5hbWVbMV0gPT09ICduJykge1xuXHRcdHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuXHRcdG5hbWVMb3dlciA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRuYW1lID0gKG5hbWVMb3dlciBpbiBkb20gPyBuYW1lTG93ZXIgOiBuYW1lKS5zbGljZSgyKTtcblxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCFvbGRWYWx1ZSkgZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZXZlbnRQcm94eSwgdXNlQ2FwdHVyZSk7XG5cdFx0XHQoZG9tLl9saXN0ZW5lcnMgfHwgKGRvbS5fbGlzdGVuZXJzID0ge30pKVtuYW1lXSA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudFByb3h5LCB1c2VDYXB0dXJlKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoXG5cdFx0bmFtZSAhPT0gJ2xpc3QnICYmXG5cdFx0bmFtZSAhPT0gJ3RhZ05hbWUnICYmXG5cdFx0Ly8gSFRNTEJ1dHRvbkVsZW1lbnQuZm9ybSBhbmQgSFRNTElucHV0RWxlbWVudC5mb3JtIGFyZSByZWFkLW9ubHkgYnV0IGNhbiBiZSBzZXQgdXNpbmdcblx0XHQvLyBzZXRBdHRyaWJ1dGVcblx0XHRuYW1lICE9PSAnZm9ybScgJiZcblx0XHRuYW1lICE9PSAndHlwZScgJiZcblx0XHRuYW1lICE9PSAnc2l6ZScgJiZcblx0XHQhaXNTdmcgJiZcblx0XHRuYW1lIGluIGRvbVxuXHQpIHtcblx0XHRkb21bbmFtZV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT0gJ2Z1bmN0aW9uJyAmJiBuYW1lICE9PSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnKSB7XG5cdFx0aWYgKG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9eeGxpbms6Py8sICcnKSkpIHtcblx0XHRcdGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlTlMoXG5cdFx0XHRcdFx0J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXHRcdFx0XHRcdG5hbWUudG9Mb3dlckNhc2UoKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9tLnNldEF0dHJpYnV0ZU5TKFxuXHRcdFx0XHRcdCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0XHRcdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0dmFsdWUgPT0gbnVsbCB8fFxuXHRcdFx0KHZhbHVlID09PSBmYWxzZSAmJlxuXHRcdFx0XHQvLyBBUklBLWF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBub3Rpb24gb2YgYm9vbGVhbiB2YWx1ZXMuXG5cdFx0XHRcdC8vIFRoZSB2YWx1ZSBgZmFsc2VgIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhdHRyaWJ1dGUgbm90XG5cdFx0XHRcdC8vIGV4aXN0aW5nIG9uIHRoZSBET00sIHNvIHdlIGNhbid0IHJlbW92ZSBpdC4gRm9yIG5vbi1ib29sZWFuXG5cdFx0XHRcdC8vIEFSSUEtYXR0cmlidXRlcyB3ZSBjb3VsZCB0cmVhdCBmYWxzZSBhcyBhIHJlbW92YWwsIGJ1dCB0aGVcblx0XHRcdFx0Ly8gYW1vdW50IG9mIGV4Y2VwdGlvbnMgd291bGQgY29zdCB1cyB0b28gbWFueSBieXRlcy4gT24gdG9wIG9mXG5cdFx0XHRcdC8vIHRoYXQgb3RoZXIgVkRPTSBmcmFtZXdvcmtzIGFsc28gYWx3YXlzIHN0cmluZ2lmeSBgZmFsc2VgLlxuXHRcdFx0XHQhL15hci8udGVzdChuYW1lKSlcblx0XHQpIHtcblx0XHRcdGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFByb3h5IGFuIGV2ZW50IHRvIGhvb2tlZCBldmVudCBoYW5kbGVyc1xuICogQHBhcmFtIHtFdmVudH0gZSBUaGUgZXZlbnQgb2JqZWN0IGZyb20gdGhlIGJyb3dzZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV2ZW50UHJveHkoZSkge1xuXHR0aGlzLl9saXN0ZW5lcnNbZS50eXBlXShvcHRpb25zLmV2ZW50ID8gb3B0aW9ucy5ldmVudChlKSA6IGUpO1xufVxuIiwiaW1wb3J0IHsgRU1QVFlfT0JKLCBFTVBUWV9BUlIgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IHsgZGlmZkNoaWxkcmVuIH0gZnJvbSAnLi9jaGlsZHJlbic7XG5pbXBvcnQgeyBkaWZmUHJvcHMsIHNldFByb3BlcnR5IH0gZnJvbSAnLi9wcm9wcyc7XG5pbXBvcnQgeyBhc3NpZ24sIHJlbW92ZU5vZGUgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgYW5kIGFwcGx5IHByb3BlciBjaGFuZ2VzIHRvIHRoZSBET01cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgcGFyZW50IG9mIHRoZSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0LiBNb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBlbGVtZW50IGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7RWxlbWVudCB8IFRleHR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNIeWRyYXRpbmddIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmYoXG5cdHBhcmVudERvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IHRtcCxcblx0XHRuZXdUeXBlID0gbmV3Vk5vZGUudHlwZTtcblxuXHQvLyBXaGVuIHBhc3NpbmcgdGhyb3VnaCBjcmVhdGVFbGVtZW50IGl0IGFzc2lnbnMgdGhlIG9iamVjdFxuXHQvLyBjb25zdHJ1Y3RvciBhcyB1bmRlZmluZWQuIFRoaXMgdG8gcHJldmVudCBKU09OLWluamVjdGlvbi5cblx0aWYgKG5ld1ZOb2RlLmNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG5cdGlmICgodG1wID0gb3B0aW9ucy5fZGlmZikpIHRtcChuZXdWTm9kZSk7XG5cblx0dHJ5IHtcblx0XHRvdXRlcjogaWYgKHR5cGVvZiBuZXdUeXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdGxldCBjLCBpc05ldywgb2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCwgY2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uO1xuXHRcdFx0bGV0IG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHM7XG5cblx0XHRcdC8vIE5lY2Vzc2FyeSBmb3IgY3JlYXRlQ29udGV4dCBhcGkuIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB3aWxsIHBhc3Ncblx0XHRcdC8vIHRoZSBjb250ZXh0IHZhbHVlIGFzIGB0aGlzLmNvbnRleHRgIGp1c3QgZm9yIHRoaXMgY29tcG9uZW50LlxuXHRcdFx0dG1wID0gbmV3VHlwZS5jb250ZXh0VHlwZTtcblx0XHRcdGxldCBwcm92aWRlciA9IHRtcCAmJiBnbG9iYWxDb250ZXh0W3RtcC5faWRdO1xuXHRcdFx0bGV0IGNvbXBvbmVudENvbnRleHQgPSB0bXBcblx0XHRcdFx0PyBwcm92aWRlclxuXHRcdFx0XHRcdD8gcHJvdmlkZXIucHJvcHMudmFsdWVcblx0XHRcdFx0XHQ6IHRtcC5fZGVmYXVsdFZhbHVlXG5cdFx0XHRcdDogZ2xvYmFsQ29udGV4dDtcblxuXHRcdFx0Ly8gR2V0IGNvbXBvbmVudCBhbmQgc2V0IGl0IHRvIGBjYFxuXHRcdFx0aWYgKG9sZFZOb2RlLl9jb21wb25lbnQpIHtcblx0XHRcdFx0YyA9IG5ld1ZOb2RlLl9jb21wb25lbnQgPSBvbGRWTm9kZS5fY29tcG9uZW50O1xuXHRcdFx0XHRjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24gPSBjLl9wcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcGVuZGluZ0Vycm9yO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSW5zdGFudGlhdGUgdGhlIG5ldyBjb21wb25lbnRcblx0XHRcdFx0aWYgKCdwcm90b3R5cGUnIGluIG5ld1R5cGUgJiYgbmV3VHlwZS5wcm90b3R5cGUucmVuZGVyKSB7XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgbmV3VHlwZShuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IENvbXBvbmVudChuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdFx0Yy5jb25zdHJ1Y3RvciA9IG5ld1R5cGU7XG5cdFx0XHRcdFx0Yy5yZW5kZXIgPSBkb1JlbmRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvdmlkZXIpIHByb3ZpZGVyLnN1YihjKTtcblxuXHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdGlmICghYy5zdGF0ZSkgYy5zdGF0ZSA9IHt9O1xuXHRcdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0XHRjLl9nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcblx0XHRcdFx0aXNOZXcgPSBjLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnZva2UgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG5cdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IG51bGwpIHtcblx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYy5zdGF0ZTtcblx0XHRcdH1cblx0XHRcdGlmIChuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChjLl9uZXh0U3RhdGUgPT0gYy5zdGF0ZSkge1xuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgYy5fbmV4dFN0YXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFzc2lnbihcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV3UHJvcHMsIGMuX25leHRTdGF0ZSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0b2xkUHJvcHMgPSBjLnByb3BzO1xuXHRcdFx0b2xkU3RhdGUgPSBjLnN0YXRlO1xuXG5cdFx0XHQvLyBJbnZva2UgcHJlLXJlbmRlciBsaWZlY3ljbGUgbWV0aG9kc1xuXHRcdFx0aWYgKGlzTmV3KSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkTW91bnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuY29tcG9uZW50RGlkTW91bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdG5ld1Byb3BzICE9PSBvbGRQcm9wcyAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KCFjLl9mb3JjZSAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUoXG5cdFx0XHRcdFx0XHRcdG5ld1Byb3BzLFxuXHRcdFx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0XHRcdGNvbXBvbmVudENvbnRleHRcblx0XHRcdFx0XHRcdCkgPT09IGZhbHNlKSB8fFxuXHRcdFx0XHRcdChuZXdWTm9kZS5fb3JpZ2luYWwgPT09IG9sZFZOb2RlLl9vcmlnaW5hbCAmJiAhYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbilcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdFx0Ly8gTW9yZSBpbmZvIGFib3V0IHRoaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vSm92aURlQ3Jvb2NrL2JlYzVmMmNlOTM1NDRkMmU2MDcwZWY4ZTAwMzZlNGU4XG5cdFx0XHRcdFx0aWYgKG5ld1ZOb2RlLl9vcmlnaW5hbCAhPT0gb2xkVk5vZGUuX29yaWdpbmFsKSBjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdGMuX3Zub2RlID0gbmV3Vk5vZGU7XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjb21taXRRdWV1ZS5wdXNoKGMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAodG1wID0gMDsgdG1wIDwgbmV3Vk5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgdG1wKyspIHtcblx0XHRcdFx0XHRcdGlmIChuZXdWTm9kZS5fY2hpbGRyZW5bdG1wXSkge1xuXHRcdFx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW5bdG1wXS5fcGFyZW50ID0gbmV3Vk5vZGU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnRXaWxsVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIGMuX25leHRTdGF0ZSwgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnREaWRVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKCgpID0+IHtcblx0XHRcdFx0XHRcdGMuY29tcG9uZW50RGlkVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGMuY29udGV4dCA9IGNvbXBvbmVudENvbnRleHQ7XG5cdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXG5cdFx0XHRpZiAoKHRtcCA9IG9wdGlvbnMuX3JlbmRlcikpIHRtcChuZXdWTm9kZSk7XG5cblx0XHRcdGMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRjLl92bm9kZSA9IG5ld1ZOb2RlO1xuXHRcdFx0Yy5fcGFyZW50RG9tID0gcGFyZW50RG9tO1xuXG5cdFx0XHR0bXAgPSBjLnJlbmRlcihjLnByb3BzLCBjLnN0YXRlLCBjLmNvbnRleHQpO1xuXHRcdFx0bGV0IGlzVG9wTGV2ZWxGcmFnbWVudCA9XG5cdFx0XHRcdHRtcCAhPSBudWxsICYmIHRtcC50eXBlID09IEZyYWdtZW50ICYmIHRtcC5rZXkgPT0gbnVsbDtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IGlzVG9wTGV2ZWxGcmFnbWVudFxuXHRcdFx0XHQ/IHRtcC5wcm9wcy5jaGlsZHJlblxuXHRcdFx0XHQ6IEFycmF5LmlzQXJyYXkodG1wKVxuXHRcdFx0XHQ/IHRtcFxuXHRcdFx0XHQ6IFt0bXBdO1xuXG5cdFx0XHRpZiAoYy5nZXRDaGlsZENvbnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRnbG9iYWxDb250ZXh0ID0gYXNzaWduKGFzc2lnbih7fSwgZ2xvYmFsQ29udGV4dCksIGMuZ2V0Q2hpbGRDb250ZXh0KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWlzTmV3ICYmIGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRzbmFwc2hvdCA9IGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlKTtcblx0XHRcdH1cblxuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Yy5iYXNlID0gbmV3Vk5vZGUuX2RvbTtcblxuXHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbikge1xuXHRcdFx0XHRjLl9wZW5kaW5nRXJyb3IgPSBjLl9wcm9jZXNzaW5nRXhjZXB0aW9uID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Yy5fZm9yY2UgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPT0gbnVsbCAmJlxuXHRcdFx0bmV3Vk5vZGUuX29yaWdpbmFsID09PSBvbGRWTm9kZS5fb3JpZ2luYWxcblx0XHQpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gZGlmZkVsZW1lbnROb2Rlcyhcblx0XHRcdFx0b2xkVk5vZGUuX2RvbSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoKHRtcCA9IG9wdGlvbnMuZGlmZmVkKSkgdG1wKG5ld1ZOb2RlKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9IG51bGw7XG5cdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBuZXdWTm9kZSwgb2xkVk5vZGUpO1xuXHR9XG5cblx0cmV0dXJuIG5ld1ZOb2RlLl9kb207XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHJvb3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHJvb3QpIHtcblx0aWYgKG9wdGlvbnMuX2NvbW1pdCkgb3B0aW9ucy5fY29tbWl0KHJvb3QsIGNvbW1pdFF1ZXVlKTtcblxuXHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb21taXRRdWV1ZSA9IGMuX3JlbmRlckNhbGxiYWNrcztcblx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0Y29tbWl0UXVldWUuc29tZShjYiA9PiB7XG5cdFx0XHRcdGNiLmNhbGwoYyk7XG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGMuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgcmVwcmVzZW50aW5nIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZ1xuICogdGhlIHZpcnR1YWwgbm9kZXMgYmVpbmcgZGlmZmVkXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRWTm9kZSBUaGUgb2xkIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHsqfSBleGNlc3NEb21DaGlsZHJlblxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGRpZmZFbGVtZW50Tm9kZXMoXG5cdGRvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCBpO1xuXHRsZXQgb2xkUHJvcHMgPSBvbGRWTm9kZS5wcm9wcztcblx0bGV0IG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHM7XG5cblx0Ly8gVHJhY2tzIGVudGVyaW5nIGFuZCBleGl0aW5nIFNWRyBuYW1lc3BhY2Ugd2hlbiBkZXNjZW5kaW5nIHRocm91Z2ggdGhlIHRyZWUuXG5cdGlzU3ZnID0gbmV3Vk5vZGUudHlwZSA9PT0gJ3N2ZycgfHwgaXNTdmc7XG5cblx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNoaWxkID0gZXhjZXNzRG9tQ2hpbGRyZW5baV07XG5cblx0XHRcdC8vIGlmIG5ld1ZOb2RlIG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiBvciB0aGUgYGRvbWBcblx0XHRcdC8vIGFyZ3VtZW50IG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiwgcmVtb3ZlIGl0IGZyb21cblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuIHNvIGl0IGlzbid0IGxhdGVyIHJlbW92ZWQgaW4gZGlmZkNoaWxkcmVuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNoaWxkICE9IG51bGwgJiZcblx0XHRcdFx0KChuZXdWTm9kZS50eXBlID09PSBudWxsXG5cdFx0XHRcdFx0PyBjaGlsZC5ub2RlVHlwZSA9PT0gM1xuXHRcdFx0XHRcdDogY2hpbGQubG9jYWxOYW1lID09PSBuZXdWTm9kZS50eXBlKSB8fFxuXHRcdFx0XHRcdGRvbSA9PSBjaGlsZClcblx0XHRcdCkge1xuXHRcdFx0XHRkb20gPSBjaGlsZDtcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoZG9tID09IG51bGwpIHtcblx0XHRpZiAobmV3Vk5vZGUudHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld1Byb3BzKTtcblx0XHR9XG5cblx0XHRkb20gPSBpc1N2Z1xuXHRcdFx0PyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmV3Vk5vZGUudHlwZSlcblx0XHRcdDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0XHRuZXdWTm9kZS50eXBlLFxuXHRcdFx0XHRcdG5ld1Byb3BzLmlzICYmIHsgaXM6IG5ld1Byb3BzLmlzIH1cblx0XHRcdCAgKTtcblx0XHQvLyB3ZSBjcmVhdGVkIGEgbmV3IHBhcmVudCwgc28gbm9uZSBvZiB0aGUgcHJldmlvdXNseSBhdHRhY2hlZCBjaGlsZHJlbiBjYW4gYmUgcmV1c2VkOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gbnVsbDtcblx0XHQvLyB3ZSBhcmUgY3JlYXRpbmcgYSBuZXcgbm9kZSwgc28gd2UgY2FuIGFzc3VtZSB0aGlzIGlzIGEgbmV3IHN1YnRyZWUgKGluIGNhc2Ugd2UgYXJlIGh5ZHJhdGluZyksIHRoaXMgZGVvcHRzIHRoZSBoeWRyYXRlXG5cdFx0aXNIeWRyYXRpbmcgPSBmYWxzZTtcblx0fVxuXG5cdGlmIChuZXdWTm9kZS50eXBlID09PSBudWxsKSB7XG5cdFx0aWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyAmJiBkb20uZGF0YSAhPSBuZXdQcm9wcykge1xuXHRcdFx0ZG9tLmRhdGEgPSBuZXdQcm9wcztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gRU1QVFlfQVJSLnNsaWNlLmNhbGwoZG9tLmNoaWxkTm9kZXMpO1xuXHRcdH1cblxuXHRcdG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuXG5cdFx0bGV0IG9sZEh0bWwgPSBvbGRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblx0XHRsZXQgbmV3SHRtbCA9IG5ld1Byb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXG5cdFx0Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgcHJvcHMgYXJlIG5vdCBkaWZmZWQgYXQgYWxsIChpbmNsdWRpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpXG5cdFx0Ly8gQFRPRE8gd2Ugc2hvdWxkIHdhcm4gaW4gZGVidWcgbW9kZSB3aGVuIHByb3BzIGRvbid0IG1hdGNoIGhlcmUuXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0aWYgKG9sZFByb3BzID09PSBFTVBUWV9PQkopIHtcblx0XHRcdFx0b2xkUHJvcHMgPSB7fTtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkb20uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG9sZFByb3BzW2RvbS5hdHRyaWJ1dGVzW2ldLm5hbWVdID0gZG9tLmF0dHJpYnV0ZXNbaV0udmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld0h0bWwgfHwgb2xkSHRtbCkge1xuXHRcdFx0XHQvLyBBdm9pZCByZS1hcHBseWluZyB0aGUgc2FtZSAnX19odG1sJyBpZiBpdCBkaWQgbm90IGNoYW5nZWQgYmV0d2VlbiByZS1yZW5kZXJcblx0XHRcdFx0aWYgKCFuZXdIdG1sIHx8ICFvbGRIdG1sIHx8IG5ld0h0bWwuX19odG1sICE9IG9sZEh0bWwuX19odG1sKSB7XG5cdFx0XHRcdFx0ZG9tLmlubmVySFRNTCA9IChuZXdIdG1sICYmIG5ld0h0bWwuX19odG1sKSB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGlzSHlkcmF0aW5nKTtcblxuXHRcdC8vIElmIHRoZSBuZXcgdm5vZGUgZGlkbid0IGhhdmUgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIGRpZmYgaXRzIGNoaWxkcmVuXG5cdFx0aWYgKG5ld0h0bWwpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBuZXdWTm9kZS5wcm9wcy5jaGlsZHJlbjtcblx0XHRcdGRpZmZDaGlsZHJlbihcblx0XHRcdFx0ZG9tLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdG5ld1ZOb2RlLnR5cGUgPT09ICdmb3JlaWduT2JqZWN0JyA/IGZhbHNlIDogaXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0RU1QVFlfT0JKLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyAoYXMgYWJvdmUsIGRvbid0IGRpZmYgcHJvcHMgZHVyaW5nIGh5ZHJhdGlvbilcblx0XHRpZiAoIWlzSHlkcmF0aW5nKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCd2YWx1ZScgaW4gbmV3UHJvcHMgJiZcblx0XHRcdFx0KGkgPSBuZXdQcm9wcy52YWx1ZSkgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRpICE9PSBkb20udmFsdWVcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICd2YWx1ZScsIGksIG9sZFByb3BzLnZhbHVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCdjaGVja2VkJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLmNoZWNrZWQpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0aSAhPT0gZG9tLmNoZWNrZWRcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICdjaGVja2VkJywgaSwgb2xkUHJvcHMuY2hlY2tlZCwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkb207XG59XG5cbi8qKlxuICogSW52b2tlIG9yIHVwZGF0ZSBhIHJlZiwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgYSBmdW5jdGlvbiBvciBvYmplY3QgcmVmLlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHJlZlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UmVmKHJlZiwgdmFsdWUsIHZub2RlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykgcmVmKHZhbHVlKTtcblx0XHRlbHNlIHJlZi5jdXJyZW50ID0gdmFsdWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFVubW91bnQgYSB2aXJ0dWFsIG5vZGUgZnJvbSB0aGUgdHJlZSBhbmQgYXBwbHkgRE9NIGNoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHVubW91bnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBwYXJlbnRWTm9kZSBUaGUgcGFyZW50IG9mIHRoZSBWTm9kZSB0aGF0XG4gKiBpbml0aWF0ZWQgdGhlIHVubW91bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBSZW1vdmVdIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhIHBhcmVudCBub2RlIG9mIHRoZVxuICogY3VycmVudCBlbGVtZW50IGlzIGFscmVhZHkgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSwgcGFyZW50Vk5vZGUsIHNraXBSZW1vdmUpIHtcblx0bGV0IHI7XG5cdGlmIChvcHRpb25zLnVubW91bnQpIG9wdGlvbnMudW5tb3VudCh2bm9kZSk7XG5cblx0aWYgKChyID0gdm5vZGUucmVmKSkge1xuXHRcdGlmICghci5jdXJyZW50IHx8IHIuY3VycmVudCA9PT0gdm5vZGUuX2RvbSkgYXBwbHlSZWYociwgbnVsbCwgcGFyZW50Vk5vZGUpO1xuXHR9XG5cblx0bGV0IGRvbTtcblx0aWYgKCFza2lwUmVtb3ZlICYmIHR5cGVvZiB2bm9kZS50eXBlICE9ICdmdW5jdGlvbicpIHtcblx0XHRza2lwUmVtb3ZlID0gKGRvbSA9IHZub2RlLl9kb20pICE9IG51bGw7XG5cdH1cblxuXHQvLyBNdXN0IGJlIHNldCB0byBgdW5kZWZpbmVkYCB0byBwcm9wZXJseSBjbGVhbiB1cCBgX25leHREb21gXG5cdC8vIGZvciB3aGljaCBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZS4gU2VlIGNvbW1lbnQgaW4gYGNyZWF0ZS1lbGVtZW50LmpzYFxuXHR2bm9kZS5fZG9tID0gdm5vZGUuX25leHREb20gPSB1bmRlZmluZWQ7XG5cblx0aWYgKChyID0gdm5vZGUuX2NvbXBvbmVudCkgIT0gbnVsbCkge1xuXHRcdGlmIChyLmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgcGFyZW50Vk5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHIuYmFzZSA9IHIuX3BhcmVudERvbSA9IG51bGw7XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY2hpbGRyZW4pKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocltpXSkgdW5tb3VudChyW2ldLCBwYXJlbnRWTm9kZSwgc2tpcFJlbW92ZSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGRvbSAhPSBudWxsKSByZW1vdmVOb2RlKGRvbSk7XG59XG5cbi8qKiBUaGUgYC5yZW5kZXIoKWAgbWV0aG9kIGZvciBhIFBGQyBiYWNraW5nIGluc3RhbmNlLiAqL1xuZnVuY3Rpb24gZG9SZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KSB7XG5cdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KTtcbn1cbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBFTVBUWV9BUlIgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIENsb25lcyB0aGUgZ2l2ZW4gVk5vZGUsIG9wdGlvbmFsbHkgYWRkaW5nIGF0dHJpYnV0ZXMvcHJvcHMgYW5kIHJlcGxhY2luZyBpdHMgY2hpbGRyZW4uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBET00gZWxlbWVudCB0byBjbG9uZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIEF0dHJpYnV0ZXMvcHJvcHMgdG8gYWRkIHdoZW4gY2xvbmluZ1xuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4vaW5kZXgnKS5Db21wb25lbnRDaGlsZHJlbj59IHJlc3QgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHdpbGwgYmUgdXNlZCBhcyByZXBsYWNlbWVudCBjaGlsZHJlbi5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRWxlbWVudCh2bm9kZSwgcHJvcHMpIHtcblx0cHJvcHMgPSBhc3NpZ24oYXNzaWduKHt9LCB2bm9kZS5wcm9wcyksIHByb3BzKTtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSBwcm9wcy5jaGlsZHJlbiA9IEVNUFRZX0FSUi5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSB7fTtcblx0Zm9yIChjb25zdCBpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgIT09ICdrZXknICYmIGkgIT09ICdyZWYnKSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdHJldHVybiBjcmVhdGVWTm9kZShcblx0XHR2bm9kZS50eXBlLFxuXHRcdG5vcm1hbGl6ZWRQcm9wcyxcblx0XHRwcm9wcy5rZXkgfHwgdm5vZGUua2V5LFxuXHRcdHByb3BzLnJlZiB8fCB2bm9kZS5yZWYsXG5cdFx0bnVsbFxuXHQpO1xufVxuIiwiaW1wb3J0IHsgZW5xdWV1ZVJlbmRlciB9IGZyb20gJy4uL2NvbXBvbmVudCc7XG5cbi8qKlxuICogRmluZCB0aGUgY2xvc2VzdCBlcnJvciBib3VuZGFyeSB0byBhIHRocm93biBlcnJvciBhbmQgY2FsbCBpdFxuICogQHBhcmFtIHtvYmplY3R9IGVycm9yIFRoZSB0aHJvd24gdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdGhhdCB0aHJld1xuICogdGhlIGVycm9yIHRoYXQgd2FzIGNhdWdodCAoZXhjZXB0IGZvciB1bm1vdW50aW5nIHdoZW4gdGhpcyBwYXJhbWV0ZXJcbiAqIGlzIHRoZSBoaWdoZXN0IHBhcmVudCB0aGF0IHdhcyBiZWluZyB1bm1vdW50ZWQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2F0Y2hFcnJvcihlcnJvciwgdm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRsZXQgY29tcG9uZW50LCBoYXNDYXVnaHQ7XG5cblx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmICFjb21wb25lbnQuX3Byb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRjb21wb25lbnQuY29uc3RydWN0b3IgJiZcblx0XHRcdFx0XHRjb21wb25lbnQuY29uc3RydWN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0aGFzQ2F1Z2h0ID0gdHJ1ZTtcblx0XHRcdFx0XHRjb21wb25lbnQuc2V0U3RhdGUoXG5cdFx0XHRcdFx0XHRjb21wb25lbnQuY29uc3RydWN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoICE9IG51bGwpIHtcblx0XHRcdFx0XHRoYXNDYXVnaHQgPSB0cnVlO1xuXHRcdFx0XHRcdGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaChlcnJvcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaGFzQ2F1Z2h0KVxuXHRcdFx0XHRcdHJldHVybiBlbnF1ZXVlUmVuZGVyKChjb21wb25lbnQuX3BlbmRpbmdFcnJvciA9IGNvbXBvbmVudCkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgZXJyb3I7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/preact/dist/preact.module.js\n");

/***/ }),

/***/ "./node_modules/preact/hooks/dist/hooks.module.js":
/*!********************************************************!*\
  !*** ./node_modules/preact/hooks/dist/hooks.module.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useState\": () => (/* binding */ m),\n/* harmony export */   \"useReducer\": () => (/* binding */ p),\n/* harmony export */   \"useEffect\": () => (/* binding */ l),\n/* harmony export */   \"useLayoutEffect\": () => (/* binding */ y),\n/* harmony export */   \"useRef\": () => (/* binding */ d),\n/* harmony export */   \"useImperativeHandle\": () => (/* binding */ s),\n/* harmony export */   \"useMemo\": () => (/* binding */ h),\n/* harmony export */   \"useCallback\": () => (/* binding */ T),\n/* harmony export */   \"useContext\": () => (/* binding */ w),\n/* harmony export */   \"useDebugValue\": () => (/* binding */ A),\n/* harmony export */   \"useErrorBoundary\": () => (/* binding */ F)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n\nvar t,\n    u,\n    r,\n    i = 0,\n    o = [],\n    c = preact__WEBPACK_IMPORTED_MODULE_0__.options.__r,\n    f = preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed,\n    e = preact__WEBPACK_IMPORTED_MODULE_0__.options.__c,\n    a = preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;\n\nfunction v(t, r) {\n  preact__WEBPACK_IMPORTED_MODULE_0__.options.__h && preact__WEBPACK_IMPORTED_MODULE_0__.options.__h(u, t, i || r), i = 0;\n  var o = u.__H || (u.__H = {\n    __: [],\n    __h: []\n  });\n  return t >= o.__.length && o.__.push({}), o.__[t];\n}\n\nfunction m(n) {\n  return i = 1, p(E, n);\n}\n\nfunction p(n, r, i) {\n  var o = v(t++, 2);\n  return o.__c || (o.__c = u, o.__ = [i ? i(r) : E(void 0, r), function (t) {\n    var u = n(o.__[0], t);\n    o.__[0] !== u && (o.__[0] = u, o.__c.setState({}));\n  }]), o.__;\n}\n\nfunction l(r, i) {\n  var o = v(t++, 3);\n  !preact__WEBPACK_IMPORTED_MODULE_0__.options.__s && x(o.__H, i) && (o.__ = r, o.__H = i, u.__H.__h.push(o));\n}\n\nfunction y(r, i) {\n  var o = v(t++, 4);\n  !preact__WEBPACK_IMPORTED_MODULE_0__.options.__s && x(o.__H, i) && (o.__ = r, o.__H = i, u.__h.push(o));\n}\n\nfunction d(n) {\n  return i = 5, h(function () {\n    return {\n      current: n\n    };\n  }, []);\n}\n\nfunction s(n, t, u) {\n  i = 6, y(function () {\n    \"function\" == typeof n ? n(t()) : n && (n.current = t());\n  }, null == u ? u : u.concat(n));\n}\n\nfunction h(n, u) {\n  var r = v(t++, 7);\n  return x(r.__H, u) ? (r.__H = u, r.__h = n, r.__ = n()) : r.__;\n}\n\nfunction T(n, t) {\n  return i = 8, h(function () {\n    return n;\n  }, t);\n}\n\nfunction w(n) {\n  var r = u.context[n.__c],\n      i = v(t++, 9);\n  return i.__c = n, r ? (null == i.__ && (i.__ = !0, r.sub(u)), r.props.value) : n.__;\n}\n\nfunction A(t, u) {\n  preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue && preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue(u ? u(t) : t);\n}\n\nfunction F(n) {\n  var r = v(t++, 10),\n      i = m();\n  return r.__ = n, u.componentDidCatch || (u.componentDidCatch = function (n) {\n    r.__ && r.__(n), i[1](n);\n  }), [i[0], function () {\n    i[1](void 0);\n  }];\n}\n\nfunction _() {\n  o.some(function (t) {\n    if (t.__P) try {\n      t.__H.__h.forEach(g), t.__H.__h.forEach(q), t.__H.__h = [];\n    } catch (u) {\n      return t.__H.__h = [], preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u, t.__v), !0;\n    }\n  }), o = [];\n}\n\nfunction g(n) {\n  n.t && n.t();\n}\n\nfunction q(n) {\n  var t = n.__();\n\n  \"function\" == typeof t && (n.t = t);\n}\n\nfunction x(n, t) {\n  return !n || t.some(function (t, u) {\n    return t !== n[u];\n  });\n}\n\nfunction E(n, t) {\n  return \"function\" == typeof t ? t(n) : t;\n}\n\npreact__WEBPACK_IMPORTED_MODULE_0__.options.__r = function (n) {\n  c && c(n), t = 0, (u = n.__c).__H && (u.__H.__h.forEach(g), u.__H.__h.forEach(q), u.__H.__h = []);\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed = function (t) {\n  f && f(t);\n  var u = t.__c;\n\n  if (u) {\n    var i = u.__H;\n    i && i.__h.length && (1 !== o.push(u) && r === preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame || ((r = preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame) || function (n) {\n      var t,\n          u = function () {\n        clearTimeout(r), cancelAnimationFrame(t), setTimeout(n);\n      },\n          r = setTimeout(u, 100);\n\n      \"undefined\" != typeof window && (t = requestAnimationFrame(u));\n    })(_));\n  }\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.__c = function (t, u) {\n  u.some(function (t) {\n    try {\n      t.__h.forEach(g), t.__h = t.__h.filter(function (n) {\n        return !n.__ || q(n);\n      });\n    } catch (r) {\n      u.some(function (n) {\n        n.__h && (n.__h = []);\n      }), u = [], preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(r, t.__v);\n    }\n  }), e && e(t, u);\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount = function (t) {\n  a && a(t);\n  var u = t.__c;\n\n  if (u) {\n    var r = u.__H;\n    if (r) try {\n      r.__.forEach(function (n) {\n        return n.t && n.t();\n      });\n    } catch (t) {\n      preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(t, u.__v);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL2Rpc3QvaG9va3MubW9kdWxlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBdUZBO0FBQ0E7QUFHQTtBQVVBO0FBQ0E7QUFGQTtBQUVBO0FBWUE7O0FBQUE7QUFBQTtBQVdBOztBQUFBO0FBQUE7QUFFQTtBQU9BO0FBRUE7QUFFQTtBQWFBOztBQUFBO0FBQUE7QUFFQTtBQWFBOztBQUFBO0FBQUE7QUFFQTtBQVNBOztBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQVFBOztBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBVUE7O0FBQUE7QUFBQTtBQUVBO0FBY0E7O0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFNQTs7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQWtCQTs7QUFBQTtBQUNBO0FBS0E7O0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFJQTtBQUNBO0FBTUE7QUFBQTtBQVFBOztBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBR0E7QUFBQTtBQUdBO0FBQUE7QUFnREE7O0FBQUE7QUFDQTtBQU9BOztBQUFBO0FBQUE7O0FBRUE7QUFPQTs7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUdBOztBQUFBO0FBQUE7QUFoVkE7O0FBQUE7QUFDQTtBQVFBO0FBS0E7QUFBQTs7QUFFQTtBQUNBO0FBR0E7QUF3UUE7QUFBQTtBQUVBO0FBRUE7QUFKQTs7QUFTQTtBQUNBO0FBY0E7QUFBQTtBQXhSQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBSUE7QUFJQTtBQUFBOztBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5kZXguanM/YTE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEluZGV4O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBjdXJyZW50Q29tcG9uZW50O1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SG9vayA9IDA7XG5cbi8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn0gKi9cbmxldCBhZnRlclBhaW50RWZmZWN0cyA9IFtdO1xuXG5sZXQgb2xkQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5fcmVuZGVyO1xubGV0IG9sZEFmdGVyRGlmZiA9IG9wdGlvbnMuZGlmZmVkO1xubGV0IG9sZENvbW1pdCA9IG9wdGlvbnMuX2NvbW1pdDtcbmxldCBvbGRCZWZvcmVVbm1vdW50ID0gb3B0aW9ucy51bm1vdW50O1xuXG5jb25zdCBSQUZfVElNRU9VVCA9IDEwMDtcbmxldCBwcmV2UmFmO1xuXG5vcHRpb25zLl9yZW5kZXIgPSB2bm9kZSA9PiB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIG9sZEJlZm9yZVJlbmRlcih2bm9kZSk7XG5cblx0Y3VycmVudENvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGN1cnJlbnRJbmRleCA9IDA7XG5cblx0aWYgKGN1cnJlbnRDb21wb25lbnQuX19ob29rcykge1xuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdH1cbn07XG5cbm9wdGlvbnMuZGlmZmVkID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQWZ0ZXJEaWZmKSBvbGRBZnRlckRpZmYodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoIWMpIHJldHVybjtcblxuXHRjb25zdCBob29rcyA9IGMuX19ob29rcztcblx0aWYgKGhvb2tzKSB7XG5cdFx0aWYgKGhvb2tzLl9wZW5kaW5nRWZmZWN0cy5sZW5ndGgpIHtcblx0XHRcdGFmdGVyUGFpbnQoYWZ0ZXJQYWludEVmZmVjdHMucHVzaChjKSk7XG5cdFx0fVxuXHR9XG59O1xuXG5vcHRpb25zLl9jb21taXQgPSAodm5vZGUsIGNvbW1pdFF1ZXVlKSA9PiB7XG5cdGNvbW1pdFF1ZXVlLnNvbWUoY29tcG9uZW50ID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzID0gY29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZmlsdGVyKGNiID0+XG5cdFx0XHRcdGNiLl92YWx1ZSA/IGludm9rZUVmZmVjdChjYikgOiB0cnVlXG5cdFx0XHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MpIGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fSk7XG5cdFx0XHRjb21taXRRdWV1ZSA9IFtdO1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjb21wb25lbnQuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChvbGRDb21taXQpIG9sZENvbW1pdCh2bm9kZSwgY29tbWl0UXVldWUpO1xufTtcblxub3B0aW9ucy51bm1vdW50ID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQmVmb3JlVW5tb3VudCkgb2xkQmVmb3JlVW5tb3VudCh2bm9kZSk7XG5cblx0Y29uc3QgYyA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmICghYykgcmV0dXJuO1xuXG5cdGNvbnN0IGhvb2tzID0gYy5fX2hvb2tzO1xuXHRpZiAoaG9va3MpIHtcblx0XHR0cnkge1xuXHRcdFx0aG9va3MuX2xpc3QuZm9yRWFjaChob29rID0+IGhvb2suX2NsZWFudXAgJiYgaG9vay5fY2xlYW51cCgpKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGMuX3Zub2RlKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogR2V0IGEgaG9vaydzIHN0YXRlIGZyb20gdGhlIGN1cnJlbnRDb21wb25lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuSG9va1N0YXRlfVxuICovXG5mdW5jdGlvbiBnZXRIb29rU3RhdGUoaW5kZXgsIHR5cGUpIHtcblx0aWYgKG9wdGlvbnMuX2hvb2spIHtcblx0XHRvcHRpb25zLl9ob29rKGN1cnJlbnRDb21wb25lbnQsIGluZGV4LCBjdXJyZW50SG9vayB8fCB0eXBlKTtcblx0fVxuXHRjdXJyZW50SG9vayA9IDA7XG5cblx0Ly8gTGFyZ2VseSBpbnNwaXJlZCBieTpcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iL2Y2YmU3MzQ2OGU2ZWM0NmIwZmY1YWEzY2M0YzliYWY3MmEyOTAyNWEvc3JjL2hvb2tzL2NvcmVfaG9va3MubWpzXG5cdC8vICogaHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWwta2xlaW4vZnVuY3kuanMvYmxvYi82NTBiZWFhNThjNDNjMzNhNzQ4MjBhM2M5OGIzYzcwNzljZjJlMzMzL3NyYy9yZW5kZXJlci5tanNcblx0Ly8gT3RoZXIgaW1wbGVtZW50YXRpb25zIHRvIGxvb2sgYXQ6XG5cdC8vICogaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL21ub3gwNXFwOFxuXHRjb25zdCBob29rcyA9XG5cdFx0Y3VycmVudENvbXBvbmVudC5fX2hvb2tzIHx8XG5cdFx0KGN1cnJlbnRDb21wb25lbnQuX19ob29rcyA9IHtcblx0XHRcdF9saXN0OiBbXSxcblx0XHRcdF9wZW5kaW5nRWZmZWN0czogW11cblx0XHR9KTtcblxuXHRpZiAoaW5kZXggPj0gaG9va3MuX2xpc3QubGVuZ3RoKSB7XG5cdFx0aG9va3MuX2xpc3QucHVzaCh7fSk7XG5cdH1cblx0cmV0dXJuIGhvb2tzLl9saXN0W2luZGV4XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlN0YXRlVXBkYXRlcjxhbnk+fSBpbml0aWFsU3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuXHRjdXJyZW50SG9vayA9IDE7XG5cdHJldHVybiB1c2VSZWR1Y2VyKGludm9rZU9yUmV0dXJuLCBpbml0aWFsU3RhdGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuUmVkdWNlcjxhbnksIGFueT59IHJlZHVjZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuU3RhdGVVcGRhdGVyPGFueT59IGluaXRpYWxTdGF0ZVxuICogQHBhcmFtIHsoaW5pdGlhbFN0YXRlOiBhbnkpID0+IHZvaWR9IFtpbml0XVxuICogQHJldHVybnMge1sgYW55LCAoc3RhdGU6IGFueSkgPT4gdm9pZCBdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGluaXQpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5SZWR1Y2VySG9va1N0YXRlfSAqL1xuXHRjb25zdCBob29rU3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDIpO1xuXHRpZiAoIWhvb2tTdGF0ZS5fY29tcG9uZW50KSB7XG5cdFx0aG9va1N0YXRlLl9jb21wb25lbnQgPSBjdXJyZW50Q29tcG9uZW50O1xuXG5cdFx0aG9va1N0YXRlLl92YWx1ZSA9IFtcblx0XHRcdCFpbml0ID8gaW52b2tlT3JSZXR1cm4odW5kZWZpbmVkLCBpbml0aWFsU3RhdGUpIDogaW5pdChpbml0aWFsU3RhdGUpLFxuXG5cdFx0XHRhY3Rpb24gPT4ge1xuXHRcdFx0XHRjb25zdCBuZXh0VmFsdWUgPSByZWR1Y2VyKGhvb2tTdGF0ZS5fdmFsdWVbMF0sIGFjdGlvbik7XG5cdFx0XHRcdGlmIChob29rU3RhdGUuX3ZhbHVlWzBdICE9PSBuZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRob29rU3RhdGUuX3ZhbHVlWzBdID0gbmV4dFZhbHVlO1xuXHRcdFx0XHRcdGhvb2tTdGF0ZS5fY29tcG9uZW50LnNldFN0YXRlKHt9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF07XG5cdH1cblxuXHRyZXR1cm4gaG9va1N0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDMpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9hcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDQpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9hcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcy5wdXNoKHN0YXRlKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuXHRjdXJyZW50SG9vayA9IDU7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+ICh7IGN1cnJlbnQ6IGluaXRpYWxWYWx1ZSB9KSwgW10pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7KCkgPT4gb2JqZWN0fSBjcmVhdGVIYW5kbGVcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGVIYW5kbGUsIGFyZ3MpIHtcblx0Y3VycmVudEhvb2sgPSA2O1xuXHR1c2VMYXlvdXRFZmZlY3QoXG5cdFx0KCkgPT4ge1xuXHRcdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykgcmVmKGNyZWF0ZUhhbmRsZSgpKTtcblx0XHRcdGVsc2UgaWYgKHJlZikgcmVmLmN1cnJlbnQgPSBjcmVhdGVIYW5kbGUoKTtcblx0XHR9LFxuXHRcdGFyZ3MgPT0gbnVsbCA/IGFyZ3MgOiBhcmdzLmNvbmNhdChyZWYpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbW8oZmFjdG9yeSwgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk1lbW9Ib29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA3KTtcblx0aWYgKGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl9hcmdzID0gYXJncztcblx0XHRzdGF0ZS5fZmFjdG9yeSA9IGZhY3Rvcnk7XG5cdFx0cmV0dXJuIChzdGF0ZS5fdmFsdWUgPSBmYWN0b3J5KCkpO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDg7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+IGNhbGxiYWNrLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdENvbnRleHR9IGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCkge1xuXHRjb25zdCBwcm92aWRlciA9IGN1cnJlbnRDb21wb25lbnQuY29udGV4dFtjb250ZXh0Ll9pZF07XG5cdC8vIFdlIGNvdWxkIHNraXAgdGhpcyBjYWxsIGhlcmUsIGJ1dCB0aGFuIHdlJ2Qgbm90IGNhbGxcblx0Ly8gYG9wdGlvbnMuX2hvb2tgLiBXZSBuZWVkIHRvIGRvIHRoYXQgaW4gb3JkZXIgdG8gbWFrZVxuXHQvLyB0aGUgZGV2dG9vbHMgYXdhcmUgb2YgdGhpcyBob29rLlxuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgOSk7XG5cdC8vIFRoZSBkZXZ0b29scyBuZWVkcyBhY2Nlc3MgdG8gdGhlIGNvbnRleHQgb2JqZWN0IHRvXG5cdC8vIGJlIGFibGUgdG8gcHVsbCBvZiB0aGUgZGVmYXVsdCB2YWx1ZSB3aGVuIG5vIHByb3ZpZGVyXG5cdC8vIGlzIHByZXNlbnQgaW4gdGhlIHRyZWUuXG5cdHN0YXRlLl9jb250ZXh0ID0gY29udGV4dDtcblx0aWYgKCFwcm92aWRlcikgcmV0dXJuIGNvbnRleHQuX2RlZmF1bHRWYWx1ZTtcblx0Ly8gVGhpcyBpcyBwcm9iYWJseSBub3Qgc2FmZSB0byBjb252ZXJ0IHRvIFwiIVwiXG5cdGlmIChzdGF0ZS5fdmFsdWUgPT0gbnVsbCkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IHRydWU7XG5cdFx0cHJvdmlkZXIuc3ViKGN1cnJlbnRDb21wb25lbnQpO1xuXHR9XG5cdHJldHVybiBwcm92aWRlci5wcm9wcy52YWx1ZTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IGEgY3VzdG9tIGxhYmVsIGZvciBhIGN1c3RvbSBob29rIGZvciB0aGUgZGV2dG9vbHMgcGFuZWxcbiAqIEB0eXBlIHs8VD4odmFsdWU6IFQsIGNiPzogKHZhbHVlOiBUKSA9PiBzdHJpbmcgfCBudW1iZXIpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXIpIHtcblx0aWYgKG9wdGlvbnMudXNlRGVidWdWYWx1ZSkge1xuXHRcdG9wdGlvbnMudXNlRGVidWdWYWx1ZShmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIodmFsdWUpIDogdmFsdWUpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VFcnJvckJvdW5kYXJ5KGNiKSB7XG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMCk7XG5cdGNvbnN0IGVyclN0YXRlID0gdXNlU3RhdGUoKTtcblx0c3RhdGUuX3ZhbHVlID0gY2I7XG5cdGlmICghY3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCkge1xuXHRcdGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2ggPSBlcnIgPT4ge1xuXHRcdFx0aWYgKHN0YXRlLl92YWx1ZSkgc3RhdGUuX3ZhbHVlKGVycik7XG5cdFx0XHRlcnJTdGF0ZVsxXShlcnIpO1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIFtcblx0XHRlcnJTdGF0ZVswXSxcblx0XHQoKSA9PiB7XG5cdFx0XHRlcnJTdGF0ZVsxXSh1bmRlZmluZWQpO1xuXHRcdH1cblx0XTtcbn1cblxuLyoqXG4gKiBBZnRlciBwYWludCBlZmZlY3RzIGNvbnN1bWVyLlxuICovXG5mdW5jdGlvbiBmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKCkge1xuXHRhZnRlclBhaW50RWZmZWN0cy5zb21lKGNvbXBvbmVudCA9PiB7XG5cdFx0aWYgKGNvbXBvbmVudC5fcGFyZW50RG9tKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGNvbXBvbmVudC5fdm5vZGUpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHRhZnRlclBhaW50RWZmZWN0cyA9IFtdO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgYnJvd3NlciBoYXMgYSBjaGFuY2UgdG8gcGFpbnQgYSBuZXcgZnJhbWUuXG4gKiBEbyB0aGlzIGJ5IGNvbWJpbmluZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHJBRikgKyBzZXRUaW1lb3V0IHRvIGludm9rZSBhIGNhbGxiYWNrIGFmdGVyXG4gKiB0aGUgbmV4dCBicm93c2VyIGZyYW1lLlxuICpcbiAqIEFsc28sIHNjaGVkdWxlIGEgdGltZW91dCBpbiBwYXJhbGxlbCB0byB0aGUgdGhlIHJBRiB0byBlbnN1cmUgdGhlIGNhbGxiYWNrIGlzIGludm9rZWRcbiAqIGV2ZW4gaWYgUkFGIGRvZXNuJ3QgZmlyZSAoZm9yIGV4YW1wbGUgaWYgdGhlIGJyb3dzZXIgdGFiIGlzIG5vdCB2aXNpYmxlKVxuICpcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJOZXh0RnJhbWUoY2FsbGJhY2spIHtcblx0Y29uc3QgZG9uZSA9ICgpID0+IHtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0Y2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcblx0XHRzZXRUaW1lb3V0KGNhbGxiYWNrKTtcblx0fTtcblx0Y29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoZG9uZSwgUkFGX1RJTUVPVVQpO1xuXG5cdGxldCByYWY7XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnKSB7XG5cdFx0cmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRvbmUpO1xuXHR9XG59XG5cbi8vIE5vdGU6IGlmIHNvbWVvbmUgdXNlZCBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuLy8gdGhlbiBlZmZlY3RzIHdpbGwgQUxXQVlTIHJ1biBvbiB0aGUgTkVYVCBmcmFtZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IG9uZSwgaW5jdXJyaW5nIGEgfjE2bXMgZGVsYXkuXG4vLyBQZXJoYXBzIHRoaXMgaXMgbm90IHN1Y2ggYSBiaWcgZGVhbC5cbi8qKlxuICogU2NoZWR1bGUgYWZ0ZXJQYWludEVmZmVjdHMgZmx1c2ggYWZ0ZXIgdGhlIGJyb3dzZXIgcGFpbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3UXVldWVMZW5ndGhcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJQYWludChuZXdRdWV1ZUxlbmd0aCkge1xuXHRpZiAobmV3UXVldWVMZW5ndGggPT09IDEgfHwgcHJldlJhZiAhPT0gb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRwcmV2UmFmID0gb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0KHByZXZSYWYgfHwgYWZ0ZXJOZXh0RnJhbWUpKGZsdXNoQWZ0ZXJQYWludEVmZmVjdHMpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9IGhvb2tcbiAqL1xuZnVuY3Rpb24gaW52b2tlQ2xlYW51cChob29rKSB7XG5cdGlmIChob29rLl9jbGVhbnVwKSBob29rLl9jbGVhbnVwKCk7XG59XG5cbi8qKlxuICogSW52b2tlIGEgSG9vaydzIGVmZmVjdFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9IGhvb2tcbiAqL1xuZnVuY3Rpb24gaW52b2tlRWZmZWN0KGhvb2spIHtcblx0Y29uc3QgcmVzdWx0ID0gaG9vay5fdmFsdWUoKTtcblx0aWYgKHR5cGVvZiByZXN1bHQgPT0gJ2Z1bmN0aW9uJykgaG9vay5fY2xlYW51cCA9IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueVtdfSBvbGRBcmdzXG4gKiBAcGFyYW0ge2FueVtdfSBuZXdBcmdzXG4gKi9cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3MsIG5ld0FyZ3MpIHtcblx0cmV0dXJuICFvbGRBcmdzIHx8IG5ld0FyZ3Muc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSk7XG59XG5cbmZ1bmN0aW9uIGludm9rZU9yUmV0dXJuKGFyZywgZikge1xuXHRyZXR1cm4gdHlwZW9mIGYgPT0gJ2Z1bmN0aW9uJyA/IGYoYXJnKSA6IGY7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/preact/hooks/dist/hooks.module.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/main.css":
/*!****************************************************!*\
  !*** ./node_modules/@fullcalendar/common/main.css ***!
  \****************************************************/
/***/ ((module) => {

module.exports = "\n/* classes attached to <body> */\n/* TODO: make fc-event selector work when calender in shadow DOM */\n.fc-not-allowed,\n.fc-not-allowed .fc-event { /* override events' custom cursors */\n  cursor: not-allowed;\n}\n\n/* TODO: not attached to body. attached to specific els. move */\n.fc-unselectable {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  -webkit-touch-callout: none;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n.fc {\n  /* layout of immediate children */\n  display: flex;\n  flex-direction: column;\n\n  font-size: 1em\n}\n.fc,\n  .fc *,\n  .fc *:before,\n  .fc *:after {\n    box-sizing: border-box;\n  }\n.fc table {\n    border-collapse: collapse;\n    border-spacing: 0;\n    font-size: 1em; /* normalize cross-browser */\n  }\n.fc th {\n    text-align: center;\n  }\n.fc th,\n  .fc td {\n    vertical-align: top;\n    padding: 0;\n  }\n.fc a[data-navlink] {\n    cursor: pointer;\n  }\n.fc a[data-navlink]:hover {\n    text-decoration: underline;\n  }\n.fc-direction-ltr {\n  direction: ltr;\n  text-align: left;\n}\n.fc-direction-rtl {\n  direction: rtl;\n  text-align: right;\n}\n.fc-theme-standard td,\n  .fc-theme-standard th {\n    border: 1px solid #ddd;\n    border: 1px solid var(--fc-border-color, #ddd);\n  }\n/* for FF, which doesn't expand a 100% div within a table cell. use absolute positioning */\n/* inner-wrappers are responsible for being absolute */\n/* TODO: best place for this? */\n.fc-liquid-hack td,\n  .fc-liquid-hack th {\n    position: relative;\n  }\n\n@font-face {\n  font-family: 'fcicons';\n  src: url(\"data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\") format('truetype');\n  font-weight: normal;\n  font-style: normal;\n}\n\n.fc-icon {\n  /* added for fc */\n  display: inline-block;\n  width: 1em;\n  height: 1em;\n  text-align: center;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n\n  /* use !important to prevent issues with browser extensions that change fonts */\n  font-family: 'fcicons' !important;\n  speak: none;\n  font-style: normal;\n  font-weight: normal;\n  font-variant: normal;\n  text-transform: none;\n  line-height: 1;\n\n  /* Better Font Rendering =========== */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.fc-icon-chevron-left:before {\n  content: \"\\e900\";\n}\n\n.fc-icon-chevron-right:before {\n  content: \"\\e901\";\n}\n\n.fc-icon-chevrons-left:before {\n  content: \"\\e902\";\n}\n\n.fc-icon-chevrons-right:before {\n  content: \"\\e903\";\n}\n\n.fc-icon-minus-square:before {\n  content: \"\\e904\";\n}\n\n.fc-icon-plus-square:before {\n  content: \"\\e905\";\n}\n\n.fc-icon-x:before {\n  content: \"\\e906\";\n}\n/*\nLots taken from Flatly (MIT): https://bootswatch.com/4/flatly/bootstrap.css\n\nThese styles only apply when the standard-theme is activated.\nWhen it's NOT activated, the fc-button classes won't even be in the DOM.\n*/\n.fc {\n\n  /* reset */\n\n}\n.fc .fc-button {\n    border-radius: 0;\n    overflow: visible;\n    text-transform: none;\n    margin: 0;\n    font-family: inherit;\n    font-size: inherit;\n    line-height: inherit;\n  }\n.fc .fc-button:focus {\n    outline: 1px dotted;\n    outline: 5px auto -webkit-focus-ring-color;\n  }\n.fc .fc-button {\n    -webkit-appearance: button;\n  }\n.fc .fc-button:not(:disabled) {\n    cursor: pointer;\n  }\n.fc .fc-button::-moz-focus-inner {\n    padding: 0;\n    border-style: none;\n  }\n.fc {\n\n  /* theme */\n\n}\n.fc .fc-button {\n    display: inline-block;\n    font-weight: 400;\n    text-align: center;\n    vertical-align: middle;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    background-color: transparent;\n    border: 1px solid transparent;\n    padding: 0.4em 0.65em;\n    font-size: 1em;\n    line-height: 1.5;\n    border-radius: 0.25em;\n  }\n.fc .fc-button:hover {\n    text-decoration: none;\n  }\n.fc .fc-button:focus {\n    outline: 0;\n    box-shadow: 0 0 0 0.2rem rgba(44, 62, 80, 0.25);\n  }\n.fc .fc-button:disabled {\n    opacity: 0.65;\n  }\n.fc {\n\n  /* \"primary\" coloring */\n\n}\n.fc .fc-button-primary {\n    color: #fff;\n    color: var(--fc-button-text-color, #fff);\n    background-color: #2C3E50;\n    background-color: var(--fc-button-bg-color, #2C3E50);\n    border-color: #2C3E50;\n    border-color: var(--fc-button-border-color, #2C3E50);\n  }\n.fc .fc-button-primary:hover {\n    color: #fff;\n    color: var(--fc-button-text-color, #fff);\n    background-color: #1e2b37;\n    background-color: var(--fc-button-hover-bg-color, #1e2b37);\n    border-color: #1a252f;\n    border-color: var(--fc-button-hover-border-color, #1a252f);\n  }\n.fc .fc-button-primary:disabled { /* not DRY */\n    color: #fff;\n    color: var(--fc-button-text-color, #fff);\n    background-color: #2C3E50;\n    background-color: var(--fc-button-bg-color, #2C3E50);\n    border-color: #2C3E50;\n    border-color: var(--fc-button-border-color, #2C3E50); /* overrides :hover */\n  }\n.fc .fc-button-primary:focus {\n    box-shadow: 0 0 0 0.2rem rgba(76, 91, 106, 0.5);\n  }\n.fc .fc-button-primary:not(:disabled):active,\n  .fc .fc-button-primary:not(:disabled).fc-button-active {\n    color: #fff;\n    color: var(--fc-button-text-color, #fff);\n    background-color: #1a252f;\n    background-color: var(--fc-button-active-bg-color, #1a252f);\n    border-color: #151e27;\n    border-color: var(--fc-button-active-border-color, #151e27);\n  }\n.fc .fc-button-primary:not(:disabled):active:focus,\n  .fc .fc-button-primary:not(:disabled).fc-button-active:focus {\n    box-shadow: 0 0 0 0.2rem rgba(76, 91, 106, 0.5);\n  }\n.fc {\n\n  /* icons within buttons */\n\n}\n.fc .fc-button .fc-icon {\n    vertical-align: middle;\n    font-size: 1.5em; /* bump up the size (but don't make it bigger than line-height of button, which is 1.5em also) */\n  }\n.fc .fc-button-group {\n    position: relative;\n    display: inline-flex;\n    vertical-align: middle;\n  }\n.fc .fc-button-group > .fc-button {\n    position: relative;\n    flex: 1 1 auto;\n  }\n.fc .fc-button-group > .fc-button:hover {\n    z-index: 1;\n  }\n.fc .fc-button-group > .fc-button:focus,\n  .fc .fc-button-group > .fc-button:active,\n  .fc .fc-button-group > .fc-button.fc-button-active {\n    z-index: 1;\n  }\n.fc-direction-ltr .fc-button-group > .fc-button:not(:first-child) {\n    margin-left: -1px;\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n.fc-direction-ltr .fc-button-group > .fc-button:not(:last-child) {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n.fc-direction-rtl .fc-button-group > .fc-button:not(:first-child) {\n    margin-right: -1px;\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n.fc-direction-rtl .fc-button-group > .fc-button:not(:last-child) {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n.fc .fc-toolbar {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n.fc .fc-toolbar.fc-header-toolbar {\n    margin-bottom: 1.5em;\n  }\n.fc .fc-toolbar.fc-footer-toolbar {\n    margin-top: 1.5em;\n  }\n.fc .fc-toolbar-title {\n    font-size: 1.75em;\n    margin: 0;\n  }\n.fc-direction-ltr .fc-toolbar > * > :not(:first-child) {\n    margin-left: .75em; /* space between */\n  }\n.fc-direction-rtl .fc-toolbar > * > :not(:first-child) {\n    margin-right: .75em; /* space between */\n  }\n.fc-direction-rtl .fc-toolbar-ltr { /* when the toolbar-chunk positioning system is explicitly left-to-right */\n    flex-direction: row-reverse;\n  }\n.fc .fc-scroller {\n    -webkit-overflow-scrolling: touch;\n    position: relative; /* for abs-positioned elements within */\n  }\n.fc .fc-scroller-liquid {\n    height: 100%;\n  }\n.fc .fc-scroller-liquid-absolute {\n    position: absolute;\n    top: 0;\n    right: 0;\n    left: 0;\n    bottom: 0;\n  }\n.fc .fc-scroller-harness {\n    position: relative;\n    overflow: hidden;\n    direction: ltr;\n      /* hack for chrome computing the scroller's right/left wrong for rtl. undone below... */\n      /* TODO: demonstrate in codepen */\n  }\n.fc .fc-scroller-harness-liquid {\n    height: 100%;\n  }\n.fc-direction-rtl .fc-scroller-harness > .fc-scroller { /* undo above hack */\n    direction: rtl;\n  }\n.fc-theme-standard .fc-scrollgrid {\n    border: 1px solid #ddd;\n    border: 1px solid var(--fc-border-color, #ddd); /* bootstrap does this. match */\n  }\n.fc .fc-scrollgrid,\n    .fc .fc-scrollgrid table { /* all tables (self included) */\n      width: 100%; /* because tables don't normally do this */\n      table-layout: fixed;\n    }\n.fc .fc-scrollgrid table { /* inner tables */\n      border-top-style: hidden;\n      border-left-style: hidden;\n      border-right-style: hidden;\n    }\n.fc .fc-scrollgrid {\n\n    border-collapse: separate;\n    border-right-width: 0;\n    border-bottom-width: 0;\n\n  }\n.fc .fc-scrollgrid-liquid {\n    height: 100%;\n  }\n.fc .fc-scrollgrid-section { /* a <tr> */\n    height: 1px /* better than 0, for firefox */\n\n  }\n.fc .fc-scrollgrid-section > td {\n      height: 1px; /* needs a height so inner div within grow. better than 0, for firefox */\n    }\n.fc .fc-scrollgrid-section table {\n      height: 1px;\n        /* for most browsers, if a height isn't set on the table, can't do liquid-height within cells */\n        /* serves as a min-height. harmless */\n    }\n.fc .fc-scrollgrid-section-liquid > td {\n      height: 100%; /* better than `auto`, for firefox */\n    }\n.fc .fc-scrollgrid-section > * {\n    border-top-width: 0;\n    border-left-width: 0;\n  }\n.fc .fc-scrollgrid-section-header > *,\n  .fc .fc-scrollgrid-section-footer > * {\n    border-bottom-width: 0;\n  }\n.fc .fc-scrollgrid-section-body table,\n  .fc .fc-scrollgrid-section-footer table {\n    border-bottom-style: hidden; /* head keeps its bottom border tho */\n  }\n.fc {\n\n  /* stickiness */\n\n}\n.fc .fc-scrollgrid-section-sticky > * {\n    background: #fff;\n    background: var(--fc-page-bg-color, #fff);\n    position: sticky;\n    z-index: 3; /* TODO: var */\n    /* TODO: box-shadow when sticking */\n  }\n.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky > * {\n    top: 0; /* because border-sharing causes a gap at the top */\n      /* TODO: give safari -1. has bug */\n  }\n.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky > * {\n    bottom: 0; /* known bug: bottom-stickiness doesn't work in safari */\n  }\n.fc .fc-scrollgrid-sticky-shim { /* for horizontal scrollbar */\n    height: 1px; /* needs height to create scrollbars */\n    margin-bottom: -1px;\n  }\n.fc-sticky { /* no .fc wrap because used as child of body */\n  position: sticky;\n}\n.fc .fc-view-harness {\n    flex-grow: 1; /* because this harness is WITHIN the .fc's flexbox */\n    position: relative;\n  }\n.fc {\n\n  /* when the harness controls the height, make the view liquid */\n\n}\n.fc .fc-view-harness-active > .fc-view {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n.fc .fc-col-header-cell-cushion {\n    display: inline-block; /* x-browser for when sticky (when multi-tier header) */\n    padding: 2px 4px;\n  }\n.fc .fc-bg-event,\n  .fc .fc-non-business,\n  .fc .fc-highlight {\n    /* will always have a harness with position:relative/absolute, so absolutely expand */\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n  }\n.fc .fc-non-business {\n    background: rgba(215, 215, 215, 0.3);\n    background: var(--fc-non-business-color, rgba(215, 215, 215, 0.3));\n  }\n.fc .fc-bg-event {\n    background: rgb(143, 223, 130);\n    background: var(--fc-bg-event-color, rgb(143, 223, 130));\n    opacity: 0.3;\n    opacity: var(--fc-bg-event-opacity, 0.3)\n  }\n.fc .fc-bg-event .fc-event-title {\n      margin: .5em;\n      font-size: .85em;\n      font-size: var(--fc-small-font-size, .85em);\n      font-style: italic;\n    }\n.fc .fc-highlight {\n    background: rgba(188, 232, 241, 0.3);\n    background: var(--fc-highlight-color, rgba(188, 232, 241, 0.3));\n  }\n.fc .fc-cell-shaded,\n  .fc .fc-day-disabled {\n    background: rgba(208, 208, 208, 0.3);\n    background: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n  }\n/* link resets */\n/* ---------------------------------------------------------------------------------------------------- */\na.fc-event,\na.fc-event:hover {\n  text-decoration: none;\n}\n/* cursor */\n.fc-event[href],\n.fc-event.fc-event-draggable {\n  cursor: pointer;\n}\n/* event text content */\n/* ---------------------------------------------------------------------------------------------------- */\n.fc-event .fc-event-main {\n    position: relative;\n    z-index: 2;\n  }\n/* dragging */\n/* ---------------------------------------------------------------------------------------------------- */\n.fc-event-dragging:not(.fc-event-selected) { /* MOUSE */\n    opacity: 0.75;\n  }\n.fc-event-dragging.fc-event-selected { /* TOUCH */\n    box-shadow: 0 2px 7px rgba(0, 0, 0, 0.3);\n  }\n/* resizing */\n/* ---------------------------------------------------------------------------------------------------- */\n/* (subclasses should hone positioning for touch and non-touch) */\n.fc-event .fc-event-resizer {\n    display: none;\n    position: absolute;\n    z-index: 4;\n  }\n.fc-event:hover, /* MOUSE */\n.fc-event-selected { /* TOUCH */\n\n}\n.fc-event:hover .fc-event-resizer, .fc-event-selected .fc-event-resizer {\n    display: block;\n  }\n.fc-event-selected .fc-event-resizer {\n    border-radius: 4px;\n    border-radius: calc(var(--fc-event-resizer-dot-total-width, 8px) / 2);\n    border-width: 1px;\n    border-width: var(--fc-event-resizer-dot-border-width, 1px);\n    width: 8px;\n    width: var(--fc-event-resizer-dot-total-width, 8px);\n    height: 8px;\n    height: var(--fc-event-resizer-dot-total-width, 8px);\n    border-style: solid;\n    border-color: inherit;\n    background: #fff;\n    background: var(--fc-page-bg-color, #fff)\n\n    /* expand hit area */\n\n  }\n.fc-event-selected .fc-event-resizer:before {\n      content: '';\n      position: absolute;\n      top: -20px;\n      left: -20px;\n      right: -20px;\n      bottom: -20px;\n    }\n/* selecting (always TOUCH) */\n/* ---------------------------------------------------------------------------------------------------- */\n.fc-event-selected {\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2)\n\n  /* expand hit area (subclasses should expand) */\n\n}\n.fc-event-selected:before {\n    content: \"\";\n    position: absolute;\n    z-index: 3;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n  }\n.fc-event-selected {\n\n  /* dimmer effect */\n\n}\n.fc-event-selected:after {\n    content: \"\";\n    background: rgba(0, 0, 0, 0.25);\n    background: var(--fc-event-selected-overlay-color, rgba(0, 0, 0, 0.25));\n    position: absolute;\n    z-index: 1;\n\n    /* assume there's a border on all sides. overcome it. */\n    /* sometimes there's NOT a border, in which case the dimmer will go over */\n    /* an adjacent border, which looks fine. */\n    top: -1px;\n    left: -1px;\n    right: -1px;\n    bottom: -1px;\n  }\n/*\nA HORIZONTAL event\n*/\n.fc-h-event { /* allowed to be top-level */\n  display: block;\n  border: 1px solid #3788d8;\n  border: 1px solid var(--fc-event-border-color, #3788d8);\n  background-color: #3788d8;\n  background-color: var(--fc-event-bg-color, #3788d8)\n\n}\n.fc-h-event .fc-event-main {\n    color: #fff;\n    color: var(--fc-event-text-color, #fff);\n  }\n.fc-h-event .fc-event-main-frame {\n    display: flex; /* for make fc-event-title-container expand */\n  }\n.fc-h-event .fc-event-time {\n    max-width: 100%; /* clip overflow on this element */\n    overflow: hidden;\n  }\n.fc-h-event .fc-event-title-container { /* serves as a container for the sticky cushion */\n    flex-grow: 1;\n    flex-shrink: 1;\n    min-width: 0; /* important for allowing to shrink all the way */\n  }\n.fc-h-event .fc-event-title {\n    display: inline-block; /* need this to be sticky cross-browser */\n    vertical-align: top; /* for not messing up line-height */\n    left: 0;  /* for sticky */\n    right: 0; /* for sticky */\n    max-width: 100%; /* clip overflow on this element */\n    overflow: hidden;\n  }\n.fc-h-event.fc-event-selected:before {\n    /* expand hit area */\n    top: -10px;\n    bottom: -10px;\n  }\n/* adjust border and border-radius (if there is any) for non-start/end */\n.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),\n.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-left-width: 0;\n}\n.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),\n.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-right-width: 0;\n}\n/* resizers */\n.fc-h-event:not(.fc-event-selected) .fc-event-resizer {\n  top: 0;\n  bottom: 0;\n  width: 8px;\n  width: var(--fc-event-resizer-thickness, 8px);\n}\n.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,\n.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end {\n  cursor: w-resize;\n  left: -4px;\n  left: calc(var(--fc-event-resizer-thickness, 8px) / -2);\n}\n.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,\n.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start {\n  cursor: e-resize;\n  right: -4px;\n  right: calc(var(--fc-event-resizer-thickness, 8px) / -2);\n}\n/* resizers for TOUCH */\n.fc-h-event.fc-event-selected .fc-event-resizer {\n  top: 50%;\n  margin-top: -4px;\n  margin-top: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\n}\n.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,\n.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end {\n  left: -4px;\n  left: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\n}\n.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,\n.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start {\n  right: -4px;\n  right: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\n}\n.fc .fc-popover {\n    position: absolute;\n    z-index: 9999;\n    box-shadow: 0 2px 6px rgba(0,0,0,.15);\n  }\n.fc .fc-popover-header {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    padding: 3px 4px;\n  }\n.fc .fc-popover-title {\n    margin: 0 2px;\n  }\n.fc .fc-popover-close {\n    cursor: pointer;\n    opacity: 0.65;\n    font-size: 1.1em;\n  }\n.fc-theme-standard .fc-popover {\n    border: 1px solid #ddd;\n    border: 1px solid var(--fc-border-color, #ddd);\n    background: #fff;\n    background: var(--fc-page-bg-color, #fff);\n  }\n.fc-theme-standard .fc-popover-header {\n    background: rgba(208, 208, 208, 0.3);\n    background: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n  }\n";

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.css":
/*!*****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.css ***!
  \*****************************************************/
/***/ ((module) => {

module.exports = "\n:root {\n  --fc-daygrid-event-dot-width: 8px;\n}\n/* help things clear margins of inner content */\n.fc-daygrid-day-frame,\n.fc-daygrid-day-events,\n.fc-daygrid-event-harness { /* for event top/bottom margins */\n}\n.fc-daygrid-day-frame:before, .fc-daygrid-day-events:before, .fc-daygrid-event-harness:before {\n  content: \"\";\n  clear: both;\n  display: table; }\n.fc-daygrid-day-frame:after, .fc-daygrid-day-events:after, .fc-daygrid-event-harness:after {\n  content: \"\";\n  clear: both;\n  display: table; }\n.fc .fc-daygrid-body { /* a <div> that wraps the table */\n    position: relative;\n    z-index: 1; /* container inner z-index's because <tr>s can't do it */\n  }\n.fc .fc-daygrid-day.fc-day-today {\n      background-color: rgba(255, 220, 40, 0.15);\n      background-color: var(--fc-today-bg-color, rgba(255, 220, 40, 0.15));\n    }\n.fc .fc-daygrid-day-frame {\n    position: relative;\n    min-height: 100%; /* seems to work better than `height` because sets height after rows/cells naturally do it */\n  }\n.fc {\n\n  /* cell top */\n\n}\n.fc .fc-daygrid-day-top {\n    display: flex;\n    flex-direction: row-reverse;\n  }\n.fc .fc-day-other .fc-daygrid-day-top {\n    opacity: 0.3;\n  }\n.fc {\n\n  /* day number (within cell top) */\n\n}\n.fc .fc-daygrid-day-number {\n    position: relative;\n    z-index: 4;\n    padding: 4px;\n  }\n.fc {\n\n  /* event container */\n\n}\n.fc .fc-daygrid-day-events {\n    margin-top: 1px; /* needs to be margin, not padding, so that available cell height can be computed */\n  }\n.fc {\n\n  /* positioning for balanced vs natural */\n\n}\n.fc .fc-daygrid-body-balanced .fc-daygrid-day-events {\n      position: absolute;\n      left: 0;\n      right: 0;\n    }\n.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events {\n      position: relative; /* for containing abs positioned event harnesses */\n      min-height: 2em; /* in addition to being a min-height during natural height, equalizes the heights a little bit */\n    }\n.fc .fc-daygrid-body-natural { /* can coexist with -unbalanced */\n  }\n.fc .fc-daygrid-body-natural .fc-daygrid-day-events {\n      margin-bottom: 1em;\n    }\n.fc {\n\n  /* event harness */\n\n}\n.fc .fc-daygrid-event-harness {\n    position: relative;\n  }\n.fc .fc-daygrid-event-harness-abs {\n    position: absolute;\n    top: 0; /* fallback coords for when cannot yet be computed */\n    left: 0; /* */\n    right: 0; /* */\n  }\n.fc .fc-daygrid-bg-harness {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n  }\n.fc {\n\n  /* bg content */\n\n}\n.fc .fc-daygrid-day-bg .fc-non-business { z-index: 1 }\n.fc .fc-daygrid-day-bg .fc-bg-event { z-index: 2 }\n.fc .fc-daygrid-day-bg .fc-highlight { z-index: 3 }\n.fc {\n\n  /* events */\n\n}\n.fc .fc-daygrid-event {\n    z-index: 6;\n    margin-top: 1px;\n  }\n.fc .fc-daygrid-event.fc-event-mirror {\n    z-index: 7;\n  }\n.fc {\n\n  /* cell bottom (within day-events) */\n\n}\n.fc .fc-daygrid-day-bottom {\n    font-size: .85em;\n    padding: 2px 3px 0\n  }\n.fc .fc-daygrid-day-bottom:before {\n  content: \"\";\n  clear: both;\n  display: table; }\n.fc .fc-daygrid-more-link {\n    position: relative;\n    z-index: 4;\n    cursor: pointer;\n  }\n.fc {\n\n  /* week number (within frame) */\n\n}\n.fc .fc-daygrid-week-number {\n    position: absolute;\n    z-index: 5;\n    top: 0;\n    padding: 2px;\n    min-width: 1.5em;\n    text-align: center;\n    background-color: rgba(208, 208, 208, 0.3);\n    background-color: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n    color: #808080;\n    color: var(--fc-neutral-text-color, #808080);\n  }\n.fc {\n\n  /* popover */\n\n}\n.fc .fc-more-popover .fc-popover-body {\n    min-width: 220px;\n    padding: 10px;\n  }\n.fc-direction-ltr .fc-daygrid-event.fc-event-start,\n.fc-direction-rtl .fc-daygrid-event.fc-event-end {\n  margin-left: 2px;\n}\n.fc-direction-ltr .fc-daygrid-event.fc-event-end,\n.fc-direction-rtl .fc-daygrid-event.fc-event-start {\n  margin-right: 2px;\n}\n.fc-direction-ltr .fc-daygrid-week-number {\n    left: 0;\n    border-radius: 0 0 3px 0;\n  }\n.fc-direction-rtl .fc-daygrid-week-number {\n    right: 0;\n    border-radius: 0 0 0 3px;\n  }\n.fc-liquid-hack .fc-daygrid-day-frame {\n    position: static; /* will cause inner absolute stuff to expand to <td> */\n  }\n.fc-daygrid-event { /* make root-level, because will be dragged-and-dropped outside of a component root */\n  position: relative; /* for z-indexes assigned later */\n  white-space: nowrap;\n  border-radius: 3px; /* dot event needs this to when selected */\n  font-size: .85em;\n  font-size: var(--fc-small-font-size, .85em);\n}\n/* --- the rectangle (\"block\") style of event --- */\n.fc-daygrid-block-event .fc-event-time {\n    font-weight: bold;\n  }\n.fc-daygrid-block-event .fc-event-time,\n  .fc-daygrid-block-event .fc-event-title {\n    padding: 1px;\n  }\n/* --- the dot style of event --- */\n.fc-daygrid-dot-event {\n  display: flex;\n  align-items: center;\n  padding: 2px 0\n\n}\n.fc-daygrid-dot-event .fc-event-title {\n    flex-grow: 1;\n    flex-shrink: 1;\n    min-width: 0; /* important for allowing to shrink all the way */\n    overflow: hidden;\n    font-weight: bold;\n  }\n.fc-daygrid-dot-event:hover,\n  .fc-daygrid-dot-event.fc-event-mirror {\n    background: rgba(0, 0, 0, 0.1);\n  }\n.fc-daygrid-dot-event.fc-event-selected:before {\n    /* expand hit area */\n    top: -10px;\n    bottom: -10px;\n  }\n.fc-daygrid-event-dot { /* the actual dot */\n  margin: 0 4px;\n  box-sizing: content-box;\n  width: 0;\n  height: 0;\n  border: 4px solid #3788d8;\n  border: calc(var(--fc-daygrid-event-dot-width, 8px) / 2) solid var(--fc-event-border-color, #3788d8);\n  border-radius: 4px;\n  border-radius: calc(var(--fc-daygrid-event-dot-width, 8px) / 2);\n}\n/* --- spacing between time and title --- */\n.fc-direction-ltr .fc-daygrid-event .fc-event-time {\n    margin-right: 3px;\n  }\n.fc-direction-rtl .fc-daygrid-event .fc-event-time {\n    margin-left: 3px;\n  }\n";

/***/ }),

/***/ "./node_modules/@fullcalendar/list/main.css":
/*!**************************************************!*\
  !*** ./node_modules/@fullcalendar/list/main.css ***!
  \**************************************************/
/***/ ((module) => {

module.exports = "\n:root {\n  --fc-list-event-dot-width: 10px;\n  --fc-list-event-hover-bg-color: #f5f5f5;\n}\n.fc-theme-standard .fc-list {\n    border: 1px solid #ddd;\n    border: 1px solid var(--fc-border-color, #ddd);\n  }\n.fc {\n\n  /* message when no events */\n\n}\n.fc .fc-list-empty {\n    background-color: rgba(208, 208, 208, 0.3);\n    background-color: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center; /* vertically aligns fc-list-empty-inner */\n  }\n.fc .fc-list-empty-cushion {\n    margin: 5em 0;\n  }\n.fc {\n\n  /* table within the scroller */\n  /* ---------------------------------------------------------------------------------------------------- */\n\n}\n.fc .fc-list-table {\n    width: 100%;\n    border-style: hidden; /* kill outer border on theme */\n  }\n.fc .fc-list-table tr > * {\n    border-left: 0;\n    border-right: 0;\n  }\n.fc .fc-list-sticky .fc-list-day > * { /* the cells */\n      position: sticky;\n      top: 0;\n      background: #fff;\n      background: var(--fc-page-bg-color, #fff); /* for when headers are styled to be transparent and sticky */\n    }\n.fc .fc-list-table th {\n    padding: 0; /* uses an inner-wrapper instead... */\n  }\n.fc .fc-list-table td,\n  .fc .fc-list-day-cushion {\n    padding: 8px 14px;\n  }\n.fc {\n\n\n  /* date heading rows */\n  /* ---------------------------------------------------------------------------------------------------- */\n\n}\n.fc .fc-list-day-cushion:after {\n  content: \"\";\n  clear: both;\n  display: table; /* clear floating */\n    }\n.fc-theme-standard .fc-list-day-cushion {\n    background-color: rgba(208, 208, 208, 0.3);\n    background-color: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n  }\n.fc-direction-ltr .fc-list-day-text,\n.fc-direction-rtl .fc-list-day-side-text {\n  float: left;\n}\n.fc-direction-ltr .fc-list-day-side-text,\n.fc-direction-rtl .fc-list-day-text {\n  float: right;\n}\n/* make the dot closer to the event title */\n.fc-direction-ltr .fc-list-table .fc-list-event-graphic { padding-right: 0 }\n.fc-direction-rtl .fc-list-table .fc-list-event-graphic { padding-left: 0 }\n.fc .fc-list-event.fc-event-forced-url {\n    cursor: pointer; /* whole row will seem clickable */\n  }\n.fc .fc-list-event:hover td {\n    background-color: #f5f5f5;\n    background-color: var(--fc-list-event-hover-bg-color, #f5f5f5);\n  }\n.fc {\n\n  /* shrink certain cols */\n\n}\n.fc .fc-list-event-graphic,\n  .fc .fc-list-event-time {\n    white-space: nowrap;\n    width: 1px;\n  }\n.fc .fc-list-event-dot {\n    display: inline-block;\n    box-sizing: content-box;\n    width: 0;\n    height: 0;\n    border: 5px solid #3788d8;\n    border: calc(var(--fc-list-event-dot-width, 10px) / 2) solid var(--fc-event-border-color, #3788d8);\n    border-radius: 5px;\n    border-radius: calc(var(--fc-list-event-dot-width, 10px) / 2);\n  }\n.fc {\n\n  /* reset <a> styling */\n\n}\n.fc .fc-list-event-title a {\n    color: inherit;\n    text-decoration: none;\n  }\n.fc {\n\n  /* underline link when hovering over any part of row */\n\n}\n.fc .fc-list-event.fc-event-forced-url:hover a {\n    text-decoration: underline;\n  }\n";

/***/ })

}]);