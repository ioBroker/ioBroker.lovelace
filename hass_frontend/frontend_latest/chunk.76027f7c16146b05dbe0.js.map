{"version":3,"sources":["webpack:///./src/panels/lovelace/common/structs/struct.ts","webpack:///./src/panels/lovelace/common/structs/is-entity-id.ts","webpack:///./src/panels/lovelace/common/structs/is-icon.ts","webpack:///../src/error.js","webpack:///../node_modules/kind-of/index.js","webpack:///../src/constants.js","webpack:///../src/utils.js","webpack:///../src/kinds.js","webpack:///../src/types.js","webpack:///../src/superstruct.js","webpack:///../src/index.js","webpack:///./src/resources/codemirror.ondemand.ts","webpack:///./src/components/ha-code-editor.ts","webpack:///./src/panels/lovelace/hui-editor.ts"],"names":["struct","superstruct","types","value","includes","icon","StructError","TypeError","type","path","JSON","errors","Error","this","toString","Object","prototype","val","ctorName","Array","isArray","constructor","isBuffer","length","callee","err","message","indexOf","isArguments","Date","toDateString","getDate","setDate","isDate","stackTraceLimit","isError","RegExp","flags","ignoreCase","multiline","global","isRegexp","throw","return","next","isGeneratorObj","call","slice","toLowerCase","replace","name","IS_STRUCT","KIND","isStruct","resolveDefaults","defaults","Kind","any","schema","kindOf","tuple","list","func","object","required","union","intersection","scalar","optional","en","s","e","String","undefined","data","result","failure","reason","isValid","array","element","error","ret","i","v","r","singleE","concat","obj","ks","properties","kind","valueKeys","propertiesKeys","Set","key","fn","kinds","k","Math","t","Kinds","keys","values","resolved","e2","r2","createSchema","Types","config","options","Struct","TYPES","isNaN","loaded","customElement","HaCodeEditor","property","_value","codemirror","getValue","shadowRoot","querySelector","refresh","autofocus","focus","changedProps","has","setOption","mode","setValue","_calcGutters","_setScrollBarDirection","classList","toggle","_load","async","loadCodeMirror","codeMirror","attachShadow","innerHTML","codeMirrorCss","lineNumbers","tabSize","viewportMargin","Infinity","extraKeys","Tab","gutters","on","_onChange","newValue","fireEvent","rtl","getWrapperElement","UpdatingElement","lovelaceStruct","interface","title","views","resources","LovelaceFullConfigEditor","LitElement","hass","lovelace","closeEditor","_saving","_changed","render","html","_closeEditor","localize","classMap","saved","_handleSave","computeRTL","_yamlChanged","firstUpdated","yamlEditor","safeDump","haStyle","css","getDoc","isClean","_generation","window","onbeforeunload","confirm","hasComments","safeLoad","alert","saveConfig","changeGeneration","customElements","define"],"mappings":"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","file":"chunk.76027f7c16146b05dbe0.js","sourcesContent":["import { superstruct } from \"superstruct\";\nimport { isEntityId } from \"./is-entity-id\";\nimport { isIcon } from \"./is-icon\";\n\nexport const struct = superstruct({\n  types: {\n    \"entity-id\": isEntityId,\n    icon: isIcon,\n  },\n});\n","export function isEntityId(value: any): string | boolean {\n  if (typeof value !== \"string\") {\n    return \"entity id should be a string\";\n  }\n  if (!value.includes(\".\")) {\n    return \"entity id should be in the format 'domain.entity'\";\n  }\n  return true;\n}\n","export function isIcon(value: any): string | boolean {\n  if (typeof value !== \"string\") {\n    return \"icon should be a string\";\n  }\n  if (!value.includes(\":\")) {\n    return \"icon should be in the format 'mdi:icon'\";\n  }\n  return true;\n}\n","/**\n * Define a struct error.\n *\n * @type {StructError}\n */\n\nclass StructError extends TypeError {\n  static format(attrs) {\n    const { type, path, value } = attrs\n    const message = `Expected a value of type \\`${type}\\`${\n      path.length ? ` for \\`${path.join('.')}\\`` : ''\n    } but received \\`${JSON.stringify(value)}\\`.`\n    return message\n  }\n\n  constructor(attrs) {\n    const message = StructError.format(attrs)\n    super(message)\n\n    const { data, path, value, reason, type, errors = [] } = attrs\n    this.data = data\n    this.path = path\n    this.value = value\n    this.reason = reason\n    this.type = type\n    this.errors = errors\n\n    if (!errors.length) {\n      errors.push(this)\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      this.stack = new Error().stack\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {StructError}\n */\n\nexport default StructError\n","var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n","/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\nconst IS_STRUCT = '@@__STRUCT__@@'\n\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nconst KIND = '@@__KIND__@@'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport { IS_STRUCT, KIND }\n","import { IS_STRUCT } from './constants'\n\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nexport function isStruct(value) {\n  return !!(value && value[IS_STRUCT])\n}\n\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\nexport function resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults\n}\n","import kindOf from 'kind-of'\n\nimport { KIND } from './constants'\nimport { isStruct, resolveDefaults } from './utils'\n\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\nclass Kind {\n  constructor(name, type, validate) {\n    this.name = name\n    this.type = type\n    this.validate = validate\n  }\n}\n\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction any(schema, defaults, options) {\n  if (isStruct(schema)) {\n    return schema[KIND]\n  }\n\n  if (schema instanceof Kind) {\n    return schema\n  }\n\n  switch (kindOf(schema)) {\n    case 'array': {\n      return schema.length > 1\n        ? tuple(schema, defaults, options)\n        : list(schema, defaults, options)\n    }\n\n    case 'function': {\n      return func(schema, defaults, options)\n    }\n\n    case 'object': {\n      return object(schema, defaults, options)\n    }\n\n    case 'string': {\n      let required = true\n      let type\n\n      if (schema.endsWith('?')) {\n        required = false\n        schema = schema.slice(0, -1)\n      }\n\n      if (schema.includes('|')) {\n        const scalars = schema.split(/\\s*\\|\\s*/g)\n        type = union(scalars, defaults, options)\n      } else if (schema.includes('&')) {\n        const scalars = schema.split(/\\s*&\\s*/g)\n        type = intersection(scalars, defaults, options)\n      } else {\n        type = scalar(schema, defaults, options)\n      }\n\n      if (!required) {\n        type = optional(type, undefined, options)\n      }\n\n      return type\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(\n      `A schema definition must be an object, array, string or function, but you passed: ${schema}`\n    )\n  } else {\n    throw new Error(`Invalid schema: ${schema}`)\n  }\n}\n\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction dict(schema, defaults, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Dict structs must be defined as an array with two elements, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const keys = any(schema[0], undefined, options)\n  const values = any(schema[1], undefined, options)\n  const name = 'dict'\n  const type = `dict<${keys.type},${values.type}>`\n  const validate = value => {\n    const resolved = resolveDefaults(defaults)\n    value = resolved ? { ...resolved, ...value } : value\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const ret = {}\n    const errors = []\n\n    for (let k in value) {\n      const v = value[k]\n      const [e, r] = keys.validate(k)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      k = r\n      const [e2, r2] = values.validate(v)\n\n      if (e2) {\n        const allE2 = e2.errors || [e2]\n        allE2.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[k] = r2\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction en(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Enum structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const name = 'enum'\n  const type = schema\n    .map(s => {\n      try {\n        return JSON.stringify(s)\n      } catch (e) {\n        return String(s)\n      }\n    })\n    .join(' | ')\n\n  const validate = (value = resolveDefaults(defaults)) => {\n    return schema.includes(value)\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction enums(schema, defaults, options) {\n  const e = en(schema, undefined, options)\n  const l = list([e], defaults, options)\n  return l\n}\n\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction func(schema, defaults, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Function structs must be defined as a function, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const name = 'function'\n  const type = '<function>'\n  const validate = (value = resolveDefaults(defaults), data) => {\n    const result = schema(value, data)\n    let failure = { path: [], reason: null }\n    let isValid\n\n    switch (kindOf(result)) {\n      case 'boolean': {\n        isValid = result\n        break\n      }\n      case 'string': {\n        isValid = false\n        failure.reason = result\n        break\n      }\n      case 'object': {\n        isValid = false\n        failure = { ...failure, ...result }\n        break\n      }\n      default: {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            `Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`\n          )\n        } else {\n          throw new Error(`Invalid result: ${result}`)\n        }\n      }\n    }\n\n    return isValid\n      ? [undefined, value]\n      : [{ type, value, data: value, ...failure }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction instance(schema, defaults, options) {\n  const name = 'instance'\n  const type = `instance<${schema.name}>`\n  const validate = (value = resolveDefaults(defaults)) => {\n    return value instanceof schema\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction inter(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Interface structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'interface'\n  const type = `{${ks.join()}}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = value\n\n    for (const key in properties) {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction lazy(schema, defaults, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  let kind\n  let struct\n  const name = 'lazy'\n  const type = `lazy...`\n  const compile = value => {\n    struct = schema()\n    kind.name = struct.kind\n    kind.type = struct.type\n    kind.validate = struct.validate\n    return kind.validate(value)\n  }\n\n  kind = new Kind(name, type, compile)\n  return kind\n}\n\n/**\n * Dynamic.\n *\n * @param {Function} createSchema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction dynamic(createSchema, defaults, options) {\n  if (kindOf(createSchema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Dynamic structs must be defined as a function, but you passed: ${createSchema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${createSchema}`)\n    }\n  }\n\n  const name = 'dynamic'\n  const type = 'dynamic...'\n  const validate = (value = resolveDefaults(defaults), data) => {\n    const schema = createSchema(value, data)\n\n    if (kindOf(schema) !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(\n          `Dynamic structs must return a schema, but you passed: ${schema}`\n        )\n      } else {\n        throw new Error(`Invalid schema: ${schema}`)\n      }\n    }\n\n    const [error, result] = schema.validate(value)\n\n    if (error) {\n      return [error]\n    }\n\n    return [undefined, result]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction list(schema, defaults, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `List structs must be defined as an array with a single element, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const array = scalar('array', undefined, options)\n  const element = any(schema[0], undefined, options)\n  const name = 'list'\n  const type = `[${element.type}]`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error, result] = array.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    value = result\n    const errors = []\n    const ret = []\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i]\n      const [e, r] = element.validate(v)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[i] = r\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction literal(schema, defaults, options) {\n  const name = 'literal'\n  const type = `literal: ${JSON.stringify(schema)}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    return value === schema\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction object(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Object structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'object'\n  const type = `{${ks.join()}}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = {}\n    const valueKeys = Object.keys(value)\n    const propertiesKeys = Object.keys(properties)\n    const keys = new Set(valueKeys.concat(propertiesKeys))\n\n    keys.forEach(key => {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      if (!kind) {\n        const e = { data: value, path: [key], value: v }\n        errors.push(e)\n        return\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        return\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    })\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction optional(schema, defaults, options) {\n  return union([schema, 'undefined'], defaults, options)\n}\n\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction partial(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Partial structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'partial'\n  const type = `{${ks.join()},...}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = {}\n\n    for (const key in properties) {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction scalar(schema, defaults, options) {\n  if (kindOf(schema) !== 'string') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Scalar structs must be defined as a string, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const { types } = options\n  const fn = types[schema]\n\n  if (kindOf(fn) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `No struct validator function found for type \"${schema}\".`\n      )\n    } else {\n      throw new Error(`Invalid type: ${schema}`)\n    }\n  }\n\n  const kind = func(fn, defaults, options)\n  const name = 'scalar'\n  const type = schema\n  const validate = value => {\n    const [error, result] = kind.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    return [undefined, result]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction tuple(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Tuple structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options))\n  const array = scalar('array', undefined, options)\n  const name = 'tuple'\n  const type = `[${kinds.map(k => k.type).join()}]`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = array.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const ret = []\n    const errors = []\n    const length = Math.max(value.length, kinds.length)\n\n    for (let i = 0; i < length; i++) {\n      const kind = kinds[i]\n      const v = value[i]\n\n      if (!kind) {\n        const e = { data: value, path: [i], value: v }\n        errors.push(e)\n        continue\n      }\n\n      const [e, r] = kind.validate(v)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[i] = r\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction union(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Union structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options))\n  const name = 'union'\n  const type = kinds.map(k => k.type).join(' | ')\n  const validate = (value = resolveDefaults(defaults)) => {\n    const errors = []\n\n    for (const k of kinds) {\n      const [e, r] = k.validate(value)\n\n      if (!e) {\n        return [undefined, r]\n      }\n\n      errors.push(e)\n    }\n    errors[0].type = type\n    return errors\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction intersection(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Intersection structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const types = schema.map(s => any(s, undefined, options))\n  const name = 'intersection'\n  const type = types.map(t => t.type).join(' & ')\n  const validate = (value = resolveDefaults(defaults)) => {\n    let v = value\n\n    for (const t of types) {\n      const [e, r] = t.validate(v)\n\n      if (e) {\n        e.type = type\n        return [e]\n      }\n\n      v = r\n    }\n\n    return [undefined, v]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\nconst Kinds = {\n  any,\n  dict,\n  enum: en,\n  enums,\n  function: func,\n  instance,\n  interface: inter,\n  lazy,\n  list,\n  literal,\n  object,\n  optional,\n  partial,\n  scalar,\n  tuple,\n  union,\n  intersection,\n  dynamic,\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Kinds\n","import kindOf from 'kind-of'\n\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nconst TYPES = [\n  'arguments',\n  'array',\n  'boolean',\n  'buffer',\n  'error',\n  'float32array',\n  'float64array',\n  'function',\n  'generatorfunction',\n  'int16array',\n  'int32array',\n  'int8array',\n  'map',\n  'null',\n  'number',\n  'object',\n  'promise',\n  'regexp',\n  'set',\n  'string',\n  'symbol',\n  'uint16array',\n  'uint32array',\n  'uint8array',\n  'uint8clampedarray',\n  'undefined',\n  'weakmap',\n  'weakset',\n]\n\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nconst Types = {\n  any: value => value !== undefined,\n}\n\nTYPES.forEach(type => {\n  Types[type] = value => kindOf(value) === type\n})\n\n/**\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\n *\n * @param {Mixed} value\n * @return {Boolean}\n */\n\nTypes.date = value => kindOf(value) === 'date' && !isNaN(value)\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Types\n","import Kinds from './kinds'\nimport StructError from './error'\nimport Types from './types'\nimport { isStruct } from './utils'\nimport { IS_STRUCT, KIND } from './constants'\n\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\nfunction superstruct(config = {}) {\n  const types = {\n    ...Types,\n    ...(config.types || {}),\n  }\n\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n  function struct(schema, defaults, options = {}) {\n    if (isStruct(schema)) {\n      schema = schema.schema\n    }\n\n    const kind = Kinds.any(schema, defaults, { ...options, types })\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            'The `Struct` creation function should not be used with the `new` keyword.'\n          )\n        } else {\n          throw new Error('Invalid `new` keyword!')\n        }\n      }\n\n      return Struct.assert(data)\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, { value: true })\n    Object.defineProperty(Struct, KIND, { value: kind })\n\n    Struct.kind = kind.name\n    Struct.type = kind.type\n    Struct.schema = schema\n    Struct.defaults = defaults\n    Struct.options = options\n\n    Struct.assert = value => {\n      const [error, result] = kind.validate(value)\n\n      if (error) {\n        throw new StructError(error)\n      }\n\n      return result\n    }\n\n    Struct.test = value => {\n      const [error] = kind.validate(value)\n      return !error\n    }\n\n    Struct.validate = value => {\n      const [error, result] = kind.validate(value)\n\n      if (error) {\n        return [new StructError(error)]\n      }\n\n      return [undefined, result]\n    }\n\n    return Struct\n  }\n\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n  Object.keys(Kinds).forEach(name => {\n    const kind = Kinds[name]\n\n    struct[name] = (schema, defaults, options) => {\n      const type = kind(schema, defaults, { ...options, types })\n      const s = struct(type, defaults, options)\n      return s\n    }\n  })\n\n  /**\n   * Return the struct factory.\n   */\n\n  return struct\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default superstruct\n","import StructError from './error'\nimport superstruct from './superstruct'\nimport { isStruct } from './utils'\n\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\nconst struct = superstruct()\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport { struct, superstruct, isStruct, StructError }\n","interface LoadedCodeMirror {\n  codeMirror: any;\n  codeMirrorCss: any;\n}\n\nlet loaded: Promise<LoadedCodeMirror>;\n\nexport const loadCodeMirror = async (): Promise<LoadedCodeMirror> => {\n  if (!loaded) {\n    loaded = import(/* webpackChunkName: \"codemirror\" */ \"./codemirror\");\n  }\n  return loaded;\n};\n","import { loadCodeMirror } from \"../resources/codemirror.ondemand\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport {\n  UpdatingElement,\n  property,\n  customElement,\n  PropertyValues,\n} from \"lit-element\";\nimport { Editor } from \"codemirror\";\n\ndeclare global {\n  interface HASSDomEvents {\n    \"editor-save\": undefined;\n  }\n}\n\n@customElement(\"ha-code-editor\")\nexport class HaCodeEditor extends UpdatingElement {\n  public codemirror?: Editor;\n  @property() public mode?: string;\n  @property() public autofocus = false;\n  @property() public rtl = false;\n  @property() public error = false;\n  @property() private _value = \"\";\n\n  public set value(value: string) {\n    this._value = value;\n  }\n\n  public get value(): string {\n    return this.codemirror ? this.codemirror.getValue() : this._value;\n  }\n\n  public get hasComments(): boolean {\n    return this.shadowRoot!.querySelector(\"span.cm-comment\") ? true : false;\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    if (!this.codemirror) {\n      return;\n    }\n    this.codemirror.refresh();\n    if (this.autofocus !== false) {\n      this.codemirror.focus();\n    }\n  }\n\n  protected update(changedProps: PropertyValues): void {\n    super.update(changedProps);\n\n    if (!this.codemirror) {\n      return;\n    }\n\n    if (changedProps.has(\"mode\")) {\n      this.codemirror.setOption(\"mode\", this.mode);\n    }\n    if (changedProps.has(\"autofocus\")) {\n      this.codemirror.setOption(\"autofocus\", this.autofocus !== false);\n    }\n    if (changedProps.has(\"_value\") && this._value !== this.value) {\n      this.codemirror.setValue(this._value);\n    }\n    if (changedProps.has(\"rtl\")) {\n      this.codemirror.setOption(\"gutters\", this._calcGutters());\n      this._setScrollBarDirection();\n    }\n    if (changedProps.has(\"error\")) {\n      this.classList.toggle(\"error-state\", this.error);\n    }\n  }\n\n  protected firstUpdated(changedProps: PropertyValues): void {\n    super.firstUpdated(changedProps);\n    this._load();\n  }\n\n  private async _load(): Promise<void> {\n    const loaded = await loadCodeMirror();\n\n    const codeMirror = loaded.codeMirror;\n\n    const shadowRoot = this.attachShadow({ mode: \"open\" });\n\n    shadowRoot!.innerHTML = `\n    <style>\n      ${loaded.codeMirrorCss}\n      .CodeMirror {\n        height: var(--code-mirror-height, auto);\n        direction: var(--code-mirror-direction, ltr);\n      }\n      .CodeMirror-scroll {\n        max-height: var(--code-mirror-max-height, --code-mirror-height);\n      }\n      .CodeMirror-gutters {\n        border-right: 1px solid var(--paper-input-container-color, var(--secondary-text-color));\n        background-color: var(--paper-dialog-background-color, var(--primary-background-color));\n        transition: 0.2s ease border-right;\n      }\n      :host(.error-state) .CodeMirror-gutters {\n        border-color: var(--error-state-color, red);\n      }\n      .CodeMirror-focused .CodeMirror-gutters {\n        border-right: 2px solid var(--paper-input-container-focus-color, var(--primary-color));\n      }\n      .CodeMirror-linenumber {\n        color: var(--paper-dialog-color, var(--primary-text-color));\n      }\n      .rtl .CodeMirror-vscrollbar {\n        right: auto;\n        left: 0px;\n      }\n      .rtl-gutter {\n        width: 20px;\n      }\n    </style>`;\n\n    this.codemirror = codeMirror(shadowRoot, {\n      value: this._value,\n      lineNumbers: true,\n      tabSize: 2,\n      mode: this.mode,\n      autofocus: this.autofocus !== false,\n      viewportMargin: Infinity,\n      extraKeys: {\n        Tab: \"indentMore\",\n        \"Shift-Tab\": \"indentLess\",\n      },\n      gutters: this._calcGutters(),\n    });\n    this._setScrollBarDirection();\n    this.codemirror!.on(\"changes\", () => this._onChange());\n  }\n\n  private _onChange(): void {\n    const newValue = this.value;\n    if (newValue === this._value) {\n      return;\n    }\n    this._value = newValue;\n    fireEvent(this, \"value-changed\", { value: this._value });\n  }\n\n  private _calcGutters(): string[] {\n    return this.rtl ? [\"rtl-gutter\", \"CodeMirror-linenumbers\"] : [];\n  }\n\n  private _setScrollBarDirection(): void {\n    if (this.codemirror) {\n      this.codemirror.getWrapperElement().classList.toggle(\"rtl\", this.rtl);\n    }\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-code-editor\": HaCodeEditor;\n  }\n}\n","import { LitElement, html, TemplateResult, CSSResult, css } from \"lit-element\";\nimport { classMap } from \"lit-html/directives/class-map\";\nimport { safeDump, safeLoad } from \"js-yaml\";\n\nimport \"@polymer/app-layout/app-header-layout/app-header-layout\";\nimport \"@polymer/app-layout/app-header/app-header\";\nimport \"@polymer/app-layout/app-toolbar/app-toolbar\";\nimport \"@material/mwc-button\";\nimport \"@polymer/paper-icon-button/paper-icon-button\";\nimport \"@polymer/paper-spinner/paper-spinner\";\n\nimport { struct } from \"./common/structs/struct\";\nimport { Lovelace } from \"./types\";\n\nimport \"../../components/ha-icon\";\nimport { haStyle } from \"../../resources/styles\";\nimport \"../../components/ha-code-editor\";\n// This is not a duplicate import, one is for types, one is for element.\n// tslint:disable-next-line\nimport { HaCodeEditor } from \"../../components/ha-code-editor\";\nimport { HomeAssistant } from \"../../types\";\nimport { computeRTL } from \"../../common/util/compute_rtl\";\n\nconst lovelaceStruct = struct.interface({\n  title: \"string?\",\n  views: [\"object\"],\n  resources: struct.optional([\"object\"]),\n});\n\nclass LovelaceFullConfigEditor extends LitElement {\n  public hass!: HomeAssistant;\n  public lovelace?: Lovelace;\n  public closeEditor?: () => void;\n  private _saving?: boolean;\n  private _changed?: boolean;\n  private _generation = 1;\n\n  static get properties() {\n    return {\n      hass: {},\n      lovelace: {},\n      closeEditor: {},\n      _saving: {},\n      _changed: {},\n    };\n  }\n\n  public render(): TemplateResult | void {\n    return html`\n      <app-header-layout>\n        <app-header>\n          <app-toolbar>\n            <paper-icon-button\n              icon=\"hass:close\"\n              @click=\"${this._closeEditor}\"\n            ></paper-icon-button>\n            <div main-title>\n              ${this.hass!.localize(\n                \"ui.panel.lovelace.editor.raw_editor.header\"\n              )}\n            </div>\n            <div\n              class=\"save-button\n              ${classMap({\n                saved: this._saving! === false || this._changed === true,\n              })}\"\n            >\n              ${this._changed\n                ? this.hass!.localize(\n                    \"ui.panel.lovelace.editor.raw_editor.unsaved_changes\"\n                  )\n                : this.hass!.localize(\n                    \"ui.panel.lovelace.editor.raw_editor.saved\"\n                  )}\n            </div>\n            <mwc-button raised @click=\"${this._handleSave}\"\n              >${this.hass!.localize(\n                \"ui.panel.lovelace.editor.raw_editor.save\"\n              )}</mwc-button\n            >\n          </app-toolbar>\n        </app-header>\n        <div class=\"content\">\n          <ha-code-editor\n            mode=\"yaml\"\n            autofocus\n            .rtl=${computeRTL(this.hass)}\n            .hass=\"${this.hass}\"\n            @value-changed=\"${this._yamlChanged}\"\n            @editor-save=\"${this._handleSave}\"\n          >\n          </ha-code-editor>\n        </div>\n      </app-header-layout>\n    `;\n  }\n\n  protected firstUpdated() {\n    this.yamlEditor.value = safeDump(this.lovelace!.config);\n  }\n\n  static get styles(): CSSResult[] {\n    return [\n      haStyle,\n      css`\n        :host {\n          --code-mirror-height: 100%;\n        }\n\n        app-header-layout {\n          height: 100vh;\n        }\n\n        app-toolbar {\n          background-color: var(--dark-background-color, #455a64);\n          color: var(--dark-text-color);\n        }\n\n        .comments {\n          font-size: 16px;\n        }\n\n        .content {\n          height: calc(100vh - 68px);\n        }\n\n        hui-code-editor {\n          height: 100%;\n        }\n\n        .save-button {\n          opacity: 0;\n          font-size: 14px;\n          padding: 0px 10px;\n        }\n\n        .saved {\n          opacity: 1;\n        }\n      `,\n    ];\n  }\n\n  private _yamlChanged() {\n    this._changed = !this.yamlEditor\n      .codemirror!.getDoc()\n      .isClean(this._generation);\n    if (this._changed && !window.onbeforeunload) {\n      window.onbeforeunload = () => {\n        return true;\n      };\n    } else if (!this._changed && window.onbeforeunload) {\n      window.onbeforeunload = null;\n    }\n  }\n\n  private _closeEditor() {\n    if (this._changed) {\n      if (\n        !confirm(\n          this.hass.localize(\n            \"ui.panel.lovelace.editor.raw_editor.confirm_unsaved_changes\"\n          )\n        )\n      ) {\n        return;\n      }\n    }\n    window.onbeforeunload = null;\n    if (this.closeEditor) {\n      this.closeEditor();\n    }\n  }\n\n  private async _handleSave() {\n    this._saving = true;\n\n    if (this.yamlEditor.hasComments) {\n      if (\n        !confirm(\n          this.hass.localize(\n            \"ui.panel.lovelace.editor.raw_editor.confirm_unsaved_comments\"\n          )\n        )\n      ) {\n        return;\n      }\n    }\n\n    let value;\n    try {\n      value = safeLoad(this.yamlEditor.value);\n    } catch (err) {\n      alert(\n        this.hass.localize(\n          \"ui.panel.lovelace.editor.raw_editor.error_parse_yaml\",\n          \"error\",\n          err\n        )\n      );\n      this._saving = false;\n      return;\n    }\n    try {\n      value = lovelaceStruct(value);\n    } catch (err) {\n      alert(\n        this.hass.localize(\n          \"ui.panel.lovelace.editor.raw_editor.error_invalid_config\",\n          \"error\",\n          err\n        )\n      );\n      return;\n    }\n    try {\n      await this.lovelace!.saveConfig(value);\n    } catch (err) {\n      alert(\n        this.hass.localize(\n          \"ui.panel.lovelace.editor.raw_editor.error_save_yaml\",\n          \"error\",\n          err\n        )\n      );\n    }\n    this._generation = this.yamlEditor\n      .codemirror!.getDoc()\n      .changeGeneration(true);\n    window.onbeforeunload = null;\n    this._saving = false;\n    this._changed = false;\n  }\n\n  private get yamlEditor(): HaCodeEditor {\n    return this.shadowRoot!.querySelector(\"ha-code-editor\")! as HaCodeEditor;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-editor\": LovelaceFullConfigEditor;\n  }\n}\n\ncustomElements.define(\"hui-editor\", LovelaceFullConfigEditor);\n"],"sourceRoot":""}