"use strict";(self.webpackChunkhome_assistant_frontend=self.webpackChunkhome_assistant_frontend||[]).push([[43047],{43047:(e,t,n)=>{n.r(t),n.d(t,{ExternalAuth:()=>d,createExternalAuth:()=>l});var s=n(40788);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class a{constructor(){i(this,"commands",{}),i(this,"connection",void 0),i(this,"cache",{}),i(this,"msgId",0)}attach(){var e;e=this,window.addEventListener("connection-status",(t=>e.fireMessage({type:"connection-status",payload:{event:t.detail}}))),(e=>{window.addEventListener("haptic",(t=>e.fireMessage({type:"haptic",payload:{hapticType:t.detail}})))})(this),window.externalBus=e=>this.receiveMessage(e)}sendMessage(e){const t=++this.msgId;return e.id=t,this.fireMessage(e),new Promise(((e,n)=>{this.commands[t]={resolve:e,reject:n}}))}fireMessage(e){e.id||(e.id=++this.msgId),this._sendExternal(e)}receiveMessage(e){if("command"===e.type)return void(this.connection?"restart"===e.command?(this.connection.reconnect(!0),this.fireMessage({id:e.id,type:"result",success:!0,result:null})):(console.warn("Received unknown command",e.command,e),this.fireMessage({id:e.id,type:"result",success:!1,error:{code:"unknown_command",message:`Unknown command ${e.command}`}})):(console.warn("Received command without having connection set",e),this.fireMessage({id:e.id,type:"result",success:!1,error:{code:"commands_not_init",message:"Commands connection not set"}})));const t=this.commands[e.id];t?"result"===e.type&&(e.success?t.resolve(e.result):t.reject(e.error)):console.warn("Received unknown msg ID",e.id)}_sendExternal(e){window.externalApp?window.externalApp.externalBus(JSON.stringify(e)):window.webkit.messageHandlers.externalBus.postMessage(e)}}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const r="externalAuthSetToken",c="externalAuthRevokeToken";if(!window.externalApp&&!window.webkit)throw new Error("External auth requires either externalApp or webkit defined on Window object.");class d extends s.gx{constructor(e){super({hassUrl:e,clientId:"",refresh_token:"",access_token:"",expires_in:0,expires:0}),o(this,"external",void 0),o(this,"_tokenCallbackPromise",void 0)}async refreshAccessToken(e){if(this._tokenCallbackPromise&&!e)try{return void await this._tokenCallbackPromise}catch(e){this._tokenCallbackPromise=void 0}const t={callback:r};e&&(t.force=!0),this._tokenCallbackPromise=new Promise(((e,t)=>{window[r]=(n,s)=>n?e(s):t(s)})),await Promise.resolve(),window.externalApp?window.externalApp.getExternalAuth(JSON.stringify(t)):window.webkit.messageHandlers.getExternalAuth.postMessage(t);const n=await this._tokenCallbackPromise;this.data.access_token=n.access_token,this.data.expires=1e3*n.expires_in+Date.now(),this._tokenCallbackPromise=void 0}async revoke(){const e={callback:c},t=new Promise(((e,t)=>{window[c]=(n,s)=>n?e(s):t(s)}));await Promise.resolve(),window.externalApp?window.externalApp.revokeExternalAuth(JSON.stringify(e)):window.webkit.messageHandlers.revokeExternalAuth.postMessage(e),await t}}const l=e=>{const t=new d(e);return(window.externalApp&&window.externalApp.externalBus||window.webkit&&window.webkit.messageHandlers.externalBus)&&(t.external=new a,t.external.attach()),t}}}]);