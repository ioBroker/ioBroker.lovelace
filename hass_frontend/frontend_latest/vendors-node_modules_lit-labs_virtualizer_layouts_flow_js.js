"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_layouts_flow_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/layouts/flow.js":
/*!************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/flow.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FlowLayout: () => (/* binding */ FlowLayout),\n/* harmony export */   flow: () => (/* binding */ flow)\n/* harmony export */ });\n/* harmony import */ var _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/SizeCache.js */ \"./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js\");\n/* harmony import */ var _shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/BaseLayout.js */ \"./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\nconst flow = config => Object.assign({\n  type: FlowLayout\n}, config);\nfunction leadingMargin(direction) {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n  const m = [a, b].sort();\n  return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n  constructor() {\n    this._childSizeCache = new _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__.SizeCache();\n    this._marginSizeCache = new _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__.SizeCache();\n    this._metricsCache = new Map();\n  }\n  update(metrics, direction) {\n    var _a, _b;\n    const marginsToUpdate = new Set();\n    Object.keys(metrics).forEach(key => {\n      const k = Number(key);\n      this._metricsCache.set(k, metrics[k]);\n      this._childSizeCache.set(k, metrics[k][(0,_shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__.dim1)(direction)]);\n      marginsToUpdate.add(k);\n      marginsToUpdate.add(k + 1);\n    });\n    for (const k of marginsToUpdate) {\n      const a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n      const b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n      this._marginSizeCache.set(k, collapseMargins(a, b));\n    }\n  }\n  get averageChildSize() {\n    return this._childSizeCache.averageSize;\n  }\n  get totalChildSize() {\n    return this._childSizeCache.totalSize;\n  }\n  get averageMarginSize() {\n    return this._marginSizeCache.averageSize;\n  }\n  get totalMarginSize() {\n    return this._marginSizeCache.totalSize;\n  }\n  getLeadingMarginValue(index, direction) {\n    var _a;\n    return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n  }\n  getChildSize(index) {\n    return this._childSizeCache.getSize(index);\n  }\n  getMarginSize(index) {\n    return this._marginSizeCache.getSize(index);\n  }\n  clear() {\n    this._childSizeCache.clear();\n    this._marginSizeCache.clear();\n    this._metricsCache.clear();\n  }\n}\nclass FlowLayout extends _shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__.BaseLayout {\n  constructor() {\n    super(...arguments);\n    /**\n     * Initial estimate of item size\n     */\n    this._itemSize = {\n      width: 100,\n      height: 100\n    };\n    /**\n     * Indices of children mapped to their (position and length) in the scrolling\n     * direction. Used to keep track of children that are in range.\n     */\n    this._physicalItems = new Map();\n    /**\n     * Used in tandem with _physicalItems to track children in range across\n     * reflows.\n     */\n    this._newPhysicalItems = new Map();\n    /**\n     * Width and height of children by their index.\n     */\n    this._metricsCache = new MetricsCache();\n    /**\n     * anchorIdx is the anchor around which we reflow. It is designed to allow\n     * jumping to any point of the scroll size. We choose it once and stick with\n     * it until stable. _first and _last are deduced around it.\n     */\n    this._anchorIdx = null;\n    /**\n     * Position in the scrolling direction of the anchor child.\n     */\n    this._anchorPos = null;\n    /**\n     * Whether all children in range were in range during the previous reflow.\n     */\n    this._stable = true;\n    this._measureChildren = true;\n    this._estimate = true;\n  }\n  // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n  // })\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n  get measureChildren() {\n    return this._measureChildren;\n  }\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n  updateItemSizes(sizes) {\n    this._metricsCache.update(sizes, this.direction);\n    // if (this._nMeasured) {\n    // this._updateItemSize();\n    this._scheduleReflow();\n    // }\n  }\n  /**\n   * Set the average item size based on the total length and number of children\n   * in range.\n   */\n  // _updateItemSize() {\n  //   // Keep integer values.\n  //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n  // }\n  _getPhysicalItem(idx) {\n    var _a;\n    return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n  }\n  _getSize(idx) {\n    const item = this._getPhysicalItem(idx);\n    return item && this._metricsCache.getChildSize(idx);\n  }\n  _getAverageSize() {\n    return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n  }\n  _estimatePosition(idx) {\n    const c = this._metricsCache;\n    if (this._first === -1 || this._last === -1) {\n      return c.averageMarginSize + idx * (c.averageMarginSize + this._getAverageSize());\n    } else {\n      if (idx < this._first) {\n        const delta = this._first - idx;\n        const refItem = this._getPhysicalItem(this._first);\n        return refItem.pos - (c.getMarginSize(this._first - 1) || c.averageMarginSize) - (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize);\n      } else {\n        const delta = idx - this._last;\n        const refItem = this._getPhysicalItem(this._last);\n        return refItem.pos + (c.getChildSize(this._last) || c.averageChildSize) + (c.getMarginSize(this._last) || c.averageMarginSize) + delta * (c.averageChildSize + c.averageMarginSize);\n      }\n    }\n  }\n  /**\n   * Returns the position in the scrolling direction of the item at idx.\n   * Estimates it if the item at idx is not in the DOM.\n   */\n  _getPosition(idx) {\n    var _a;\n    const item = this._getPhysicalItem(idx);\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    return idx === 0 ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize : item ? item.pos : this._estimatePosition(idx);\n  }\n  _calculateAnchor(lower, upper) {\n    if (lower <= 0) {\n      return 0;\n    }\n    if (upper > this._scrollSize - this._viewDim1) {\n      return this.items.length - 1;\n    }\n    return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n  }\n  _getAnchor(lower, upper) {\n    if (this._physicalItems.size === 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._first < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._last < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    const firstItem = this._getPhysicalItem(this._first),\n      lastItem = this._getPhysicalItem(this._last),\n      firstMin = firstItem.pos,\n      lastMin = lastItem.pos,\n      lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n    if (lastMax < lower) {\n      // Window is entirely past physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    if (firstMin > upper) {\n      // Window is entirely before physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    // Window contains a physical item\n    // Find one, starting with the one that was previously first visible\n    let candidateIdx = this._firstVisible - 1;\n    let cMax = -Infinity;\n    while (cMax < lower) {\n      const candidate = this._getPhysicalItem(++candidateIdx);\n      cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n    }\n    return candidateIdx;\n  }\n  /**\n   * Updates _first and _last based on items that should be in the current\n   * viewed range.\n   */\n  _getActiveItems() {\n    if (this._viewDim1 === 0 || this.items.length === 0) {\n      this._clearItems();\n    } else {\n      this._getItems();\n    }\n  }\n  /**\n   * Sets the range to empty.\n   */\n  _clearItems() {\n    this._first = -1;\n    this._last = -1;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    const items = this._newPhysicalItems;\n    this._newPhysicalItems = this._physicalItems;\n    this._newPhysicalItems.clear();\n    this._physicalItems = items;\n    this._stable = true;\n  }\n  /*\n   * Updates _first and _last based on items that should be in the given range.\n   */\n  _getItems() {\n    var _a, _b;\n    const items = this._newPhysicalItems;\n    this._stable = true;\n    let lower, upper;\n    // The anchorIdx is the anchor around which we reflow. It is designed to\n    // allow jumping to any point of the scroll size. We choose it once and\n    // stick with it until stable. first and last are deduced around it.\n    // If we have a pinned item, we anchor on it\n    if (this.pin !== null) {\n      const {\n        index\n      } = this.pin;\n      this._anchorIdx = index;\n      this._anchorPos = this._getPosition(index);\n    }\n    // Determine the lower and upper bounds of the region to be\n    // rendered, relative to the viewport\n    lower = this._scrollPosition - this._overhang; //leadingOverhang;\n    upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n    if (upper < 0 || lower > this._scrollSize) {\n      this._clearItems();\n      return;\n    }\n    // If we are scrolling to a specific index or if we are doing another\n    // pass to stabilize a previously started reflow, we will already\n    // have an anchor. If not, establish an anchor now.\n    if (this._anchorIdx === null || this._anchorPos === null) {\n      this._anchorIdx = this._getAnchor(lower, upper);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n    }\n    let anchorSize = this._getSize(this._anchorIdx);\n    if (anchorSize === undefined) {\n      this._stable = false;\n      anchorSize = this._getAverageSize();\n    }\n    const anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n    const anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n    if (this._anchorIdx === 0) {\n      this._anchorPos = anchorLeadingMargin;\n    }\n    if (this._anchorIdx === this.items.length - 1) {\n      this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n    }\n    // Anchor might be outside bounds, so prefer correcting the error and keep\n    // that anchorIdx.\n    let anchorErr = 0;\n    if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n      anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n    }\n    if (this._anchorPos - anchorLeadingMargin > upper) {\n      anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n    }\n    if (anchorErr) {\n      this._scrollPosition -= anchorErr;\n      lower -= anchorErr;\n      upper -= anchorErr;\n      this._scrollError += anchorErr;\n    }\n    items.set(this._anchorIdx, {\n      pos: this._anchorPos,\n      size: anchorSize\n    });\n    this._first = this._last = this._anchorIdx;\n    this._physicalMin = this._anchorPos - anchorLeadingMargin;\n    this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n    while (this._physicalMin > lower && this._first > 0) {\n      let size = this._getSize(--this._first);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._first);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      this._physicalMin -= size;\n      const pos = this._physicalMin;\n      items.set(this._first, {\n        pos,\n        size\n      });\n      this._physicalMin -= margin;\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    }\n    while (this._physicalMax < upper && this._last < this.items.length - 1) {\n      let size = this._getSize(++this._last);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._last);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      const pos = this._physicalMax;\n      items.set(this._last, {\n        pos,\n        size\n      });\n      this._physicalMax += size + margin;\n      if (!this._stable && !this._estimate) {\n        break;\n      }\n    }\n    // This handles the cases where we were relying on estimated sizes.\n    const extentErr = this._calculateError();\n    if (extentErr) {\n      this._physicalMin -= extentErr;\n      this._physicalMax -= extentErr;\n      this._anchorPos -= extentErr;\n      this._scrollPosition -= extentErr;\n      items.forEach(item => item.pos -= extentErr);\n      this._scrollError += extentErr;\n    }\n    if (this._stable) {\n      this._newPhysicalItems = this._physicalItems;\n      this._newPhysicalItems.clear();\n      this._physicalItems = items;\n    }\n  }\n  _calculateError() {\n    if (this._first === 0) {\n      return this._physicalMin;\n    } else if (this._physicalMin <= 0) {\n      return this._physicalMin - this._first * this._delta;\n    } else if (this._last === this.items.length - 1) {\n      return this._physicalMax - this._scrollSize;\n    } else if (this._physicalMax >= this._scrollSize) {\n      return this._physicalMax - this._scrollSize + (this.items.length - 1 - this._last) * this._delta;\n    }\n    return 0;\n  }\n  _reflow() {\n    const {\n      _first,\n      _last\n    } = this;\n    super._reflow();\n    if (this._first === -1 && this._last == -1 || this._first === _first && this._last === _last) {\n      this._resetReflowState();\n    }\n  }\n  _resetReflowState() {\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n  }\n  _updateScrollSize() {\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) + averageMarginSize);\n  }\n  /**\n   * Returns the average size (precise or estimated) of an item in the scrolling direction,\n   * including any surrounding space.\n   */\n  get _delta() {\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    return this._getAverageSize() + averageMarginSize;\n  }\n  /**\n   * Returns the top and left positioning of the item at idx.\n   */\n  _getItemPosition(idx) {\n    var _a;\n    return {\n      [this._positionDim]: this._getPosition(idx),\n      [this._secondaryPositionDim]: 0,\n      [offset(this.direction)]: -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize)\n    };\n  }\n  /**\n   * Returns the height and width of the item at idx.\n   */\n  _getItemSize(idx) {\n    return {\n      [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n      [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim]\n    };\n  }\n  _viewDim2Changed() {\n    this._metricsCache.clear();\n    this._scheduleReflow();\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvZmxvdy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7O0FBTUE7QUFDQTtBQStCQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFtREE7QUFqREE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFBQTs7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFFQTs7OztBQUlBO0FBRUE7Ozs7QUFJQTtBQUVBOzs7QUFHQTtBQUVBOzs7OztBQUtBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7QUFFQTtBQXNZQTtBQXBZQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7O0FBUUE7QUFFQTs7OztBQUlBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFHQTtBQUlBO0FBQ0E7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFJQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvbGF5b3V0cy9mbG93LnRzP2M5MDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbmltcG9ydCB7U2l6ZUNhY2hlfSBmcm9tICcuL3NoYXJlZC9TaXplQ2FjaGUuanMnO1xuaW1wb3J0IHtCYXNlTGF5b3V0LCBkaW0xfSBmcm9tICcuL3NoYXJlZC9CYXNlTGF5b3V0LmpzJztcbmltcG9ydCB7XG4gIFBvc2l0aW9ucyxcbiAgU2l6ZSxcbiAgTWFyZ2lucyxcbiAgbWFyZ2luLFxuICBTY3JvbGxEaXJlY3Rpb24sXG4gIG9mZnNldEF4aXMsXG4gIENoaWxkTWVhc3VyZW1lbnRzLFxuICBCYXNlTGF5b3V0Q29uZmlnLFxuICBMYXlvdXRIb3N0U2luayxcbn0gZnJvbSAnLi9zaGFyZWQvTGF5b3V0LmpzJztcblxudHlwZSBJdGVtQm91bmRzID0ge1xuICBwb3M6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xufTtcblxudHlwZSBGbG93TGF5b3V0Q29uc3RydWN0b3IgPSB7XG4gIHByb3RvdHlwZTogRmxvd0xheW91dDtcbiAgbmV3IChob3N0U2luazogTGF5b3V0SG9zdFNpbmssIGNvbmZpZz86IEJhc2VMYXlvdXRDb25maWcpOiBGbG93TGF5b3V0O1xufTtcblxudHlwZSBGbG93TGF5b3V0U3BlY2lmaWVyID0gQmFzZUxheW91dENvbmZpZyAmIHtcbiAgdHlwZTogRmxvd0xheW91dENvbnN0cnVjdG9yO1xufTtcblxudHlwZSBGbG93TGF5b3V0U3BlY2lmaWVyRmFjdG9yeSA9IChcbiAgY29uZmlnPzogQmFzZUxheW91dENvbmZpZ1xuKSA9PiBGbG93TGF5b3V0U3BlY2lmaWVyO1xuXG5leHBvcnQgY29uc3QgZmxvdzogRmxvd0xheW91dFNwZWNpZmllckZhY3RvcnkgPSAoY29uZmlnPzogQmFzZUxheW91dENvbmZpZykgPT5cbiAgT2JqZWN0LmFzc2lnbihcbiAgICB7XG4gICAgICB0eXBlOiBGbG93TGF5b3V0LFxuICAgIH0sXG4gICAgY29uZmlnXG4gICk7XG5cbmZ1bmN0aW9uIGxlYWRpbmdNYXJnaW4oZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBtYXJnaW4ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luVG9wJztcbn1cblxuZnVuY3Rpb24gdHJhaWxpbmdNYXJnaW4oZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBtYXJnaW4ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnbWFyZ2luUmlnaHQnIDogJ21hcmdpbkJvdHRvbSc7XG59XG5cbmZ1bmN0aW9uIG9mZnNldChkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbik6IG9mZnNldEF4aXMge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAneE9mZnNldCcgOiAneU9mZnNldCc7XG59XG5cbmZ1bmN0aW9uIGNvbGxhcHNlTWFyZ2lucyhhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IG0gPSBbYSwgYl0uc29ydCgpO1xuICByZXR1cm4gbVsxXSA8PSAwID8gTWF0aC5taW4oLi4ubSkgOiBtWzBdID49IDAgPyBNYXRoLm1heCguLi5tKSA6IG1bMF0gKyBtWzFdO1xufVxuXG5jbGFzcyBNZXRyaWNzQ2FjaGUge1xuICBwcml2YXRlIF9jaGlsZFNpemVDYWNoZSA9IG5ldyBTaXplQ2FjaGUoKTtcbiAgcHJpdmF0ZSBfbWFyZ2luU2l6ZUNhY2hlID0gbmV3IFNpemVDYWNoZSgpO1xuICBwcml2YXRlIF9tZXRyaWNzQ2FjaGU6IE1hcDxudW1iZXIsIFNpemUgJiBNYXJnaW5zPiA9IG5ldyBNYXAoKTtcblxuICB1cGRhdGUobWV0cmljczoge1trZXk6IG51bWJlcl06IFNpemUgJiBNYXJnaW5zfSwgZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pIHtcbiAgICBjb25zdCBtYXJnaW5zVG9VcGRhdGU6IFNldDxudW1iZXI+ID0gbmV3IFNldCgpO1xuICAgIE9iamVjdC5rZXlzKG1ldHJpY3MpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgayA9IE51bWJlcihrZXkpO1xuICAgICAgdGhpcy5fbWV0cmljc0NhY2hlLnNldChrLCBtZXRyaWNzW2tdKTtcbiAgICAgIHRoaXMuX2NoaWxkU2l6ZUNhY2hlLnNldChrLCBtZXRyaWNzW2tdW2RpbTEoZGlyZWN0aW9uKV0pO1xuICAgICAgbWFyZ2luc1RvVXBkYXRlLmFkZChrKTtcbiAgICAgIG1hcmdpbnNUb1VwZGF0ZS5hZGQoayArIDEpO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3QgayBvZiBtYXJnaW5zVG9VcGRhdGUpIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0KGspPy5bbGVhZGluZ01hcmdpbihkaXJlY3Rpb24pXSB8fCAwO1xuICAgICAgY29uc3QgYiA9IHRoaXMuX21ldHJpY3NDYWNoZS5nZXQoayAtIDEpPy5bdHJhaWxpbmdNYXJnaW4oZGlyZWN0aW9uKV0gfHwgMDtcbiAgICAgIHRoaXMuX21hcmdpblNpemVDYWNoZS5zZXQoaywgY29sbGFwc2VNYXJnaW5zKGEsIGIpKTtcbiAgICB9XG4gIH1cblxuICBnZXQgYXZlcmFnZUNoaWxkU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZFNpemVDYWNoZS5hdmVyYWdlU2l6ZTtcbiAgfVxuXG4gIGdldCB0b3RhbENoaWxkU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZFNpemVDYWNoZS50b3RhbFNpemU7XG4gIH1cblxuICBnZXQgYXZlcmFnZU1hcmdpblNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fbWFyZ2luU2l6ZUNhY2hlLmF2ZXJhZ2VTaXplO1xuICB9XG5cbiAgZ2V0IHRvdGFsTWFyZ2luU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9tYXJnaW5TaXplQ2FjaGUudG90YWxTaXplO1xuICB9XG5cbiAgZ2V0TGVhZGluZ01hcmdpblZhbHVlKGluZGV4OiBudW1iZXIsIGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldHJpY3NDYWNoZS5nZXQoaW5kZXgpPy5bbGVhZGluZ01hcmdpbihkaXJlY3Rpb24pXSB8fCAwO1xuICB9XG5cbiAgZ2V0Q2hpbGRTaXplKGluZGV4OiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRTaXplQ2FjaGUuZ2V0U2l6ZShpbmRleCk7XG4gIH1cblxuICBnZXRNYXJnaW5TaXplKGluZGV4OiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFyZ2luU2l6ZUNhY2hlLmdldFNpemUoaW5kZXgpO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fY2hpbGRTaXplQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9tYXJnaW5TaXplQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9tZXRyaWNzQ2FjaGUuY2xlYXIoKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmxvd0xheW91dCBleHRlbmRzIEJhc2VMYXlvdXQ8QmFzZUxheW91dENvbmZpZz4ge1xuICAvKipcbiAgICogSW5pdGlhbCBlc3RpbWF0ZSBvZiBpdGVtIHNpemVcbiAgICovXG4gIF9pdGVtU2l6ZTogU2l6ZSA9IHt3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMH07XG5cbiAgLyoqXG4gICAqIEluZGljZXMgb2YgY2hpbGRyZW4gbWFwcGVkIHRvIHRoZWlyIChwb3NpdGlvbiBhbmQgbGVuZ3RoKSBpbiB0aGUgc2Nyb2xsaW5nXG4gICAqIGRpcmVjdGlvbi4gVXNlZCB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIHRoYXQgYXJlIGluIHJhbmdlLlxuICAgKi9cbiAgX3BoeXNpY2FsSXRlbXM6IE1hcDxudW1iZXIsIEl0ZW1Cb3VuZHM+ID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGluIHRhbmRlbSB3aXRoIF9waHlzaWNhbEl0ZW1zIHRvIHRyYWNrIGNoaWxkcmVuIGluIHJhbmdlIGFjcm9zc1xuICAgKiByZWZsb3dzLlxuICAgKi9cbiAgX25ld1BoeXNpY2FsSXRlbXM6IE1hcDxudW1iZXIsIEl0ZW1Cb3VuZHM+ID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBXaWR0aCBhbmQgaGVpZ2h0IG9mIGNoaWxkcmVuIGJ5IHRoZWlyIGluZGV4LlxuICAgKi9cbiAgX21ldHJpY3NDYWNoZSA9IG5ldyBNZXRyaWNzQ2FjaGUoKTtcblxuICAvKipcbiAgICogYW5jaG9ySWR4IGlzIHRoZSBhbmNob3IgYXJvdW5kIHdoaWNoIHdlIHJlZmxvdy4gSXQgaXMgZGVzaWduZWQgdG8gYWxsb3dcbiAgICoganVtcGluZyB0byBhbnkgcG9pbnQgb2YgdGhlIHNjcm9sbCBzaXplLiBXZSBjaG9vc2UgaXQgb25jZSBhbmQgc3RpY2sgd2l0aFxuICAgKiBpdCB1bnRpbCBzdGFibGUuIF9maXJzdCBhbmQgX2xhc3QgYXJlIGRlZHVjZWQgYXJvdW5kIGl0LlxuICAgKi9cbiAgX2FuY2hvcklkeDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIGluIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uIG9mIHRoZSBhbmNob3IgY2hpbGQuXG4gICAqL1xuICBfYW5jaG9yUG9zOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogV2hldGhlciBhbGwgY2hpbGRyZW4gaW4gcmFuZ2Ugd2VyZSBpbiByYW5nZSBkdXJpbmcgdGhlIHByZXZpb3VzIHJlZmxvdy5cbiAgICovXG4gIF9zdGFibGUgPSB0cnVlO1xuXG4gIHByaXZhdGUgX21lYXN1cmVDaGlsZHJlbiA9IHRydWU7XG5cbiAgX2VzdGltYXRlID0gdHJ1ZTtcblxuICAvLyBwcm90ZWN0ZWQgX2RlZmF1bHRDb25maWc6IEJhc2VMYXlvdXRDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBzdXBlci5fZGVmYXVsdENvbmZpZywge1xuXG4gIC8vIH0pXG5cbiAgLy8gY29uc3RydWN0b3IoY29uZmlnOiBMYXlvdXQxZENvbmZpZykge1xuICAvLyAgIHN1cGVyKGNvbmZpZyk7XG4gIC8vIH1cblxuICBnZXQgbWVhc3VyZUNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWFzdXJlQ2hpbGRyZW47XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBhdmVyYWdlIHNpemUgb2YgYWxsIGNoaWxkcmVuIHJlcHJlc2VudGVkIGluIHRoZSBzaXplc1xuICAgKiBhcmd1bWVudC5cbiAgICovXG4gIHVwZGF0ZUl0ZW1TaXplcyhzaXplczogQ2hpbGRNZWFzdXJlbWVudHMpIHtcbiAgICB0aGlzLl9tZXRyaWNzQ2FjaGUudXBkYXRlKHNpemVzIGFzIFNpemUgJiBNYXJnaW5zLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgLy8gaWYgKHRoaXMuX25NZWFzdXJlZCkge1xuICAgIC8vIHRoaXMuX3VwZGF0ZUl0ZW1TaXplKCk7XG4gICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgICAvLyB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhdmVyYWdlIGl0ZW0gc2l6ZSBiYXNlZCBvbiB0aGUgdG90YWwgbGVuZ3RoIGFuZCBudW1iZXIgb2YgY2hpbGRyZW5cbiAgICogaW4gcmFuZ2UuXG4gICAqL1xuICAvLyBfdXBkYXRlSXRlbVNpemUoKSB7XG4gIC8vICAgLy8gS2VlcCBpbnRlZ2VyIHZhbHVlcy5cbiAgLy8gICB0aGlzLl9pdGVtU2l6ZVt0aGlzLl9zaXplRGltXSA9IHRoaXMuX21ldHJpY3NDYWNoZS5hdmVyYWdlQ2hpbGRTaXplO1xuICAvLyB9XG5cbiAgX2dldFBoeXNpY2FsSXRlbShpZHg6IG51bWJlcik6IEl0ZW1Cb3VuZHMgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zLmdldChpZHgpID8/IHRoaXMuX3BoeXNpY2FsSXRlbXMuZ2V0KGlkeCk7XG4gIH1cblxuICBfZ2V0U2l6ZShpZHg6IG51bWJlcik6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2dldFBoeXNpY2FsSXRlbShpZHgpO1xuICAgIHJldHVybiBpdGVtICYmIHRoaXMuX21ldHJpY3NDYWNoZS5nZXRDaGlsZFNpemUoaWR4KTtcbiAgfVxuXG4gIF9nZXRBdmVyYWdlU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9tZXRyaWNzQ2FjaGUuYXZlcmFnZUNoaWxkU2l6ZSB8fCB0aGlzLl9pdGVtU2l6ZVt0aGlzLl9zaXplRGltXTtcbiAgfVxuXG4gIF9lc3RpbWF0ZVBvc2l0aW9uKGlkeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBjID0gdGhpcy5fbWV0cmljc0NhY2hlO1xuICAgIGlmICh0aGlzLl9maXJzdCA9PT0gLTEgfHwgdGhpcy5fbGFzdCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGMuYXZlcmFnZU1hcmdpblNpemUgK1xuICAgICAgICBpZHggKiAoYy5hdmVyYWdlTWFyZ2luU2l6ZSArIHRoaXMuX2dldEF2ZXJhZ2VTaXplKCkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaWR4IDwgdGhpcy5fZmlyc3QpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLl9maXJzdCAtIGlkeDtcbiAgICAgICAgY29uc3QgcmVmSXRlbSA9IHRoaXMuX2dldFBoeXNpY2FsSXRlbSh0aGlzLl9maXJzdCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVmSXRlbSEucG9zIC1cbiAgICAgICAgICAoYy5nZXRNYXJnaW5TaXplKHRoaXMuX2ZpcnN0IC0gMSkgfHwgYy5hdmVyYWdlTWFyZ2luU2l6ZSkgLVxuICAgICAgICAgIChkZWx0YSAqIGMuYXZlcmFnZUNoaWxkU2l6ZSArIChkZWx0YSAtIDEpICogYy5hdmVyYWdlTWFyZ2luU2l6ZSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gaWR4IC0gdGhpcy5fbGFzdDtcbiAgICAgICAgY29uc3QgcmVmSXRlbSA9IHRoaXMuX2dldFBoeXNpY2FsSXRlbSh0aGlzLl9sYXN0KTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICByZWZJdGVtIS5wb3MgK1xuICAgICAgICAgIChjLmdldENoaWxkU2l6ZSh0aGlzLl9sYXN0KSB8fCBjLmF2ZXJhZ2VDaGlsZFNpemUpICtcbiAgICAgICAgICAoYy5nZXRNYXJnaW5TaXplKHRoaXMuX2xhc3QpIHx8IGMuYXZlcmFnZU1hcmdpblNpemUpICtcbiAgICAgICAgICBkZWx0YSAqIChjLmF2ZXJhZ2VDaGlsZFNpemUgKyBjLmF2ZXJhZ2VNYXJnaW5TaXplKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbiBvZiB0aGUgaXRlbSBhdCBpZHguXG4gICAqIEVzdGltYXRlcyBpdCBpZiB0aGUgaXRlbSBhdCBpZHggaXMgbm90IGluIHRoZSBET00uXG4gICAqL1xuICBfZ2V0UG9zaXRpb24oaWR4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0oaWR4KTtcbiAgICBjb25zdCB7YXZlcmFnZU1hcmdpblNpemV9ID0gdGhpcy5fbWV0cmljc0NhY2hlO1xuICAgIHJldHVybiBpZHggPT09IDBcbiAgICAgID8gdGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUoMCkgPz8gYXZlcmFnZU1hcmdpblNpemVcbiAgICAgIDogaXRlbVxuICAgICAgPyBpdGVtLnBvc1xuICAgICAgOiB0aGlzLl9lc3RpbWF0ZVBvc2l0aW9uKGlkeCk7XG4gIH1cblxuICBfY2FsY3VsYXRlQW5jaG9yKGxvd2VyOiBudW1iZXIsIHVwcGVyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChsb3dlciA8PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHVwcGVyID4gdGhpcy5fc2Nyb2xsU2l6ZSAtIHRoaXMuX3ZpZXdEaW0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAwLFxuICAgICAgTWF0aC5taW4oXG4gICAgICAgIHRoaXMuaXRlbXMubGVuZ3RoIC0gMSxcbiAgICAgICAgTWF0aC5mbG9vcigobG93ZXIgKyB1cHBlcikgLyAyIC8gdGhpcy5fZGVsdGEpXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRBbmNob3IobG93ZXI6IG51bWJlciwgdXBwZXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuX3BoeXNpY2FsSXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZmlyc3QgPCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlQW5jaG9yKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9sYXN0IDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0SXRlbSA9IHRoaXMuX2dldFBoeXNpY2FsSXRlbSh0aGlzLl9maXJzdCksXG4gICAgICBsYXN0SXRlbSA9IHRoaXMuX2dldFBoeXNpY2FsSXRlbSh0aGlzLl9sYXN0KSxcbiAgICAgIGZpcnN0TWluID0gZmlyc3RJdGVtIS5wb3MsXG4gICAgICBsYXN0TWluID0gbGFzdEl0ZW0hLnBvcyxcbiAgICAgIGxhc3RNYXggPSBsYXN0TWluICsgdGhpcy5fbWV0cmljc0NhY2hlLmdldENoaWxkU2l6ZSh0aGlzLl9sYXN0KSE7XG5cbiAgICBpZiAobGFzdE1heCA8IGxvd2VyKSB7XG4gICAgICAvLyBXaW5kb3cgaXMgZW50aXJlbHkgcGFzdCBwaHlzaWNhbCBpdGVtcywgY2FsY3VsYXRlIG5ldyBhbmNob3JcbiAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICB9XG4gICAgaWYgKGZpcnN0TWluID4gdXBwZXIpIHtcbiAgICAgIC8vIFdpbmRvdyBpcyBlbnRpcmVseSBiZWZvcmUgcGh5c2ljYWwgaXRlbXMsIGNhbGN1bGF0ZSBuZXcgYW5jaG9yXG4gICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlQW5jaG9yKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuICAgIC8vIFdpbmRvdyBjb250YWlucyBhIHBoeXNpY2FsIGl0ZW1cbiAgICAvLyBGaW5kIG9uZSwgc3RhcnRpbmcgd2l0aCB0aGUgb25lIHRoYXQgd2FzIHByZXZpb3VzbHkgZmlyc3QgdmlzaWJsZVxuICAgIGxldCBjYW5kaWRhdGVJZHggPSB0aGlzLl9maXJzdFZpc2libGUgLSAxO1xuICAgIGxldCBjTWF4ID0gLUluZmluaXR5O1xuICAgIHdoaWxlIChjTWF4IDwgbG93ZXIpIHtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHRoaXMuX2dldFBoeXNpY2FsSXRlbSgrK2NhbmRpZGF0ZUlkeCk7XG4gICAgICBjTWF4ID0gY2FuZGlkYXRlIS5wb3MgKyB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0Q2hpbGRTaXplKGNhbmRpZGF0ZUlkeCkhO1xuICAgIH1cbiAgICByZXR1cm4gY2FuZGlkYXRlSWR4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgX2ZpcnN0IGFuZCBfbGFzdCBiYXNlZCBvbiBpdGVtcyB0aGF0IHNob3VsZCBiZSBpbiB0aGUgY3VycmVudFxuICAgKiB2aWV3ZWQgcmFuZ2UuXG4gICAqL1xuICBfZ2V0QWN0aXZlSXRlbXMoKSB7XG4gICAgaWYgKHRoaXMuX3ZpZXdEaW0xID09PSAwIHx8IHRoaXMuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9jbGVhckl0ZW1zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2dldEl0ZW1zKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJhbmdlIHRvIGVtcHR5LlxuICAgKi9cbiAgX2NsZWFySXRlbXMoKSB7XG4gICAgdGhpcy5fZmlyc3QgPSAtMTtcbiAgICB0aGlzLl9sYXN0ID0gLTE7XG4gICAgdGhpcy5fcGh5c2ljYWxNaW4gPSAwO1xuICAgIHRoaXMuX3BoeXNpY2FsTWF4ID0gMDtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX25ld1BoeXNpY2FsSXRlbXM7XG4gICAgdGhpcy5fbmV3UGh5c2ljYWxJdGVtcyA9IHRoaXMuX3BoeXNpY2FsSXRlbXM7XG4gICAgdGhpcy5fbmV3UGh5c2ljYWxJdGVtcy5jbGVhcigpO1xuICAgIHRoaXMuX3BoeXNpY2FsSXRlbXMgPSBpdGVtcztcbiAgICB0aGlzLl9zdGFibGUgPSB0cnVlO1xuICB9XG5cbiAgLypcbiAgICogVXBkYXRlcyBfZmlyc3QgYW5kIF9sYXN0IGJhc2VkIG9uIGl0ZW1zIHRoYXQgc2hvdWxkIGJlIGluIHRoZSBnaXZlbiByYW5nZS5cbiAgICovXG4gIF9nZXRJdGVtcygpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX25ld1BoeXNpY2FsSXRlbXM7XG4gICAgdGhpcy5fc3RhYmxlID0gdHJ1ZTtcbiAgICBsZXQgbG93ZXIsIHVwcGVyO1xuXG4gICAgLy8gVGhlIGFuY2hvcklkeCBpcyB0aGUgYW5jaG9yIGFyb3VuZCB3aGljaCB3ZSByZWZsb3cuIEl0IGlzIGRlc2lnbmVkIHRvXG4gICAgLy8gYWxsb3cganVtcGluZyB0byBhbnkgcG9pbnQgb2YgdGhlIHNjcm9sbCBzaXplLiBXZSBjaG9vc2UgaXQgb25jZSBhbmRcbiAgICAvLyBzdGljayB3aXRoIGl0IHVudGlsIHN0YWJsZS4gZmlyc3QgYW5kIGxhc3QgYXJlIGRlZHVjZWQgYXJvdW5kIGl0LlxuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIHBpbm5lZCBpdGVtLCB3ZSBhbmNob3Igb24gaXRcbiAgICBpZiAodGhpcy5waW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtpbmRleH0gPSB0aGlzLnBpbjtcbiAgICAgIHRoaXMuX2FuY2hvcklkeCA9IGluZGV4O1xuICAgICAgdGhpcy5fYW5jaG9yUG9zID0gdGhpcy5fZ2V0UG9zaXRpb24oaW5kZXgpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSB0aGUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kcyBvZiB0aGUgcmVnaW9uIHRvIGJlXG4gICAgLy8gcmVuZGVyZWQsIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydFxuICAgIGxvd2VyID0gdGhpcy5fc2Nyb2xsUG9zaXRpb24gLSB0aGlzLl9vdmVyaGFuZzsgLy9sZWFkaW5nT3Zlcmhhbmc7XG4gICAgdXBwZXIgPSB0aGlzLl9zY3JvbGxQb3NpdGlvbiArIHRoaXMuX3ZpZXdEaW0xICsgdGhpcy5fb3Zlcmhhbmc7IC8vIHRyYWlsaW5nT3Zlcmhhbmc7XG5cbiAgICBpZiAodXBwZXIgPCAwIHx8IGxvd2VyID4gdGhpcy5fc2Nyb2xsU2l6ZSkge1xuICAgICAgdGhpcy5fY2xlYXJJdGVtcygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFyZSBzY3JvbGxpbmcgdG8gYSBzcGVjaWZpYyBpbmRleCBvciBpZiB3ZSBhcmUgZG9pbmcgYW5vdGhlclxuICAgIC8vIHBhc3MgdG8gc3RhYmlsaXplIGEgcHJldmlvdXNseSBzdGFydGVkIHJlZmxvdywgd2Ugd2lsbCBhbHJlYWR5XG4gICAgLy8gaGF2ZSBhbiBhbmNob3IuIElmIG5vdCwgZXN0YWJsaXNoIGFuIGFuY2hvciBub3cuXG4gICAgaWYgKHRoaXMuX2FuY2hvcklkeCA9PT0gbnVsbCB8fCB0aGlzLl9hbmNob3JQb3MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2FuY2hvcklkeCA9IHRoaXMuX2dldEFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgICAgdGhpcy5fYW5jaG9yUG9zID0gdGhpcy5fZ2V0UG9zaXRpb24odGhpcy5fYW5jaG9ySWR4KTtcbiAgICB9XG5cbiAgICBsZXQgYW5jaG9yU2l6ZSA9IHRoaXMuX2dldFNpemUodGhpcy5fYW5jaG9ySWR4KTtcbiAgICBpZiAoYW5jaG9yU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgIGFuY2hvclNpemUgPSB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvckxlYWRpbmdNYXJnaW4gPVxuICAgICAgdGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUodGhpcy5fYW5jaG9ySWR4KSA/P1xuICAgICAgdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplO1xuICAgIGNvbnN0IGFuY2hvclRyYWlsaW5nTWFyZ2luID1cbiAgICAgIHRoaXMuX21ldHJpY3NDYWNoZS5nZXRNYXJnaW5TaXplKHRoaXMuX2FuY2hvcklkeCArIDEpID8/XG4gICAgICB0aGlzLl9tZXRyaWNzQ2FjaGUuYXZlcmFnZU1hcmdpblNpemU7XG5cbiAgICBpZiAodGhpcy5fYW5jaG9ySWR4ID09PSAwKSB7XG4gICAgICB0aGlzLl9hbmNob3JQb3MgPSBhbmNob3JMZWFkaW5nTWFyZ2luO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9hbmNob3JJZHggPT09IHRoaXMuaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5fYW5jaG9yUG9zID0gdGhpcy5fc2Nyb2xsU2l6ZSAtIGFuY2hvclRyYWlsaW5nTWFyZ2luIC0gYW5jaG9yU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBBbmNob3IgbWlnaHQgYmUgb3V0c2lkZSBib3VuZHMsIHNvIHByZWZlciBjb3JyZWN0aW5nIHRoZSBlcnJvciBhbmQga2VlcFxuICAgIC8vIHRoYXQgYW5jaG9ySWR4LlxuICAgIGxldCBhbmNob3JFcnIgPSAwO1xuXG4gICAgaWYgKHRoaXMuX2FuY2hvclBvcyArIGFuY2hvclNpemUgKyBhbmNob3JUcmFpbGluZ01hcmdpbiA8IGxvd2VyKSB7XG4gICAgICBhbmNob3JFcnIgPSBsb3dlciAtICh0aGlzLl9hbmNob3JQb3MgKyBhbmNob3JTaXplICsgYW5jaG9yVHJhaWxpbmdNYXJnaW4pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9hbmNob3JQb3MgLSBhbmNob3JMZWFkaW5nTWFyZ2luID4gdXBwZXIpIHtcbiAgICAgIGFuY2hvckVyciA9IHVwcGVyIC0gKHRoaXMuX2FuY2hvclBvcyAtIGFuY2hvckxlYWRpbmdNYXJnaW4pO1xuICAgIH1cblxuICAgIGlmIChhbmNob3JFcnIpIHtcbiAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uIC09IGFuY2hvckVycjtcbiAgICAgIGxvd2VyIC09IGFuY2hvckVycjtcbiAgICAgIHVwcGVyIC09IGFuY2hvckVycjtcbiAgICAgIHRoaXMuX3Njcm9sbEVycm9yICs9IGFuY2hvckVycjtcbiAgICB9XG5cbiAgICBpdGVtcy5zZXQodGhpcy5fYW5jaG9ySWR4LCB7cG9zOiB0aGlzLl9hbmNob3JQb3MsIHNpemU6IGFuY2hvclNpemV9KTtcblxuICAgIHRoaXMuX2ZpcnN0ID0gdGhpcy5fbGFzdCA9IHRoaXMuX2FuY2hvcklkeDtcbiAgICB0aGlzLl9waHlzaWNhbE1pbiA9IHRoaXMuX2FuY2hvclBvcyAtIGFuY2hvckxlYWRpbmdNYXJnaW47XG4gICAgdGhpcy5fcGh5c2ljYWxNYXggPSB0aGlzLl9hbmNob3JQb3MgKyBhbmNob3JTaXplICsgYW5jaG9yVHJhaWxpbmdNYXJnaW47XG5cbiAgICB3aGlsZSAodGhpcy5fcGh5c2ljYWxNaW4gPiBsb3dlciAmJiB0aGlzLl9maXJzdCA+IDApIHtcbiAgICAgIGxldCBzaXplID0gdGhpcy5fZ2V0U2l6ZSgtLXRoaXMuX2ZpcnN0KTtcbiAgICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc3RhYmxlID0gZmFsc2U7XG4gICAgICAgIHNpemUgPSB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpO1xuICAgICAgfVxuICAgICAgbGV0IG1hcmdpbiA9IHRoaXMuX21ldHJpY3NDYWNoZS5nZXRNYXJnaW5TaXplKHRoaXMuX2ZpcnN0KTtcbiAgICAgIGlmIChtYXJnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgbWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGh5c2ljYWxNaW4gLT0gc2l6ZTtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX3BoeXNpY2FsTWluO1xuICAgICAgaXRlbXMuc2V0KHRoaXMuX2ZpcnN0LCB7cG9zLCBzaXplfSk7XG4gICAgICB0aGlzLl9waHlzaWNhbE1pbiAtPSBtYXJnaW47XG4gICAgICBpZiAodGhpcy5fc3RhYmxlID09PSBmYWxzZSAmJiB0aGlzLl9lc3RpbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMuX3BoeXNpY2FsTWF4IDwgdXBwZXIgJiYgdGhpcy5fbGFzdCA8IHRoaXMuaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgbGV0IHNpemUgPSB0aGlzLl9nZXRTaXplKCsrdGhpcy5fbGFzdCk7XG4gICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3N0YWJsZSA9IGZhbHNlO1xuICAgICAgICBzaXplID0gdGhpcy5fZ2V0QXZlcmFnZVNpemUoKTtcbiAgICAgIH1cbiAgICAgIGxldCBtYXJnaW4gPSB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TWFyZ2luU2l6ZSh0aGlzLl9sYXN0KTtcbiAgICAgIGlmIChtYXJnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgbWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zID0gdGhpcy5fcGh5c2ljYWxNYXg7XG4gICAgICBpdGVtcy5zZXQodGhpcy5fbGFzdCwge3Bvcywgc2l6ZX0pO1xuICAgICAgdGhpcy5fcGh5c2ljYWxNYXggKz0gc2l6ZSArIG1hcmdpbjtcbiAgICAgIGlmICghdGhpcy5fc3RhYmxlICYmICF0aGlzLl9lc3RpbWF0ZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIGNhc2VzIHdoZXJlIHdlIHdlcmUgcmVseWluZyBvbiBlc3RpbWF0ZWQgc2l6ZXMuXG4gICAgY29uc3QgZXh0ZW50RXJyID0gdGhpcy5fY2FsY3VsYXRlRXJyb3IoKTtcbiAgICBpZiAoZXh0ZW50RXJyKSB7XG4gICAgICB0aGlzLl9waHlzaWNhbE1pbiAtPSBleHRlbnRFcnI7XG4gICAgICB0aGlzLl9waHlzaWNhbE1heCAtPSBleHRlbnRFcnI7XG4gICAgICB0aGlzLl9hbmNob3JQb3MgLT0gZXh0ZW50RXJyO1xuICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gLT0gZXh0ZW50RXJyO1xuICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4gKGl0ZW0ucG9zIC09IGV4dGVudEVycikpO1xuICAgICAgdGhpcy5fc2Nyb2xsRXJyb3IgKz0gZXh0ZW50RXJyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGFibGUpIHtcbiAgICAgIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMgPSB0aGlzLl9waHlzaWNhbEl0ZW1zO1xuICAgICAgdGhpcy5fbmV3UGh5c2ljYWxJdGVtcy5jbGVhcigpO1xuICAgICAgdGhpcy5fcGh5c2ljYWxJdGVtcyA9IGl0ZW1zO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVFcnJvcigpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLl9maXJzdCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BoeXNpY2FsTWluO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGh5c2ljYWxNaW4gPD0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BoeXNpY2FsTWluIC0gdGhpcy5fZmlyc3QgKiB0aGlzLl9kZWx0YTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2xhc3QgPT09IHRoaXMuaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BoeXNpY2FsTWF4IC0gdGhpcy5fc2Nyb2xsU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BoeXNpY2FsTWF4ID49IHRoaXMuX3Njcm9sbFNpemUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuX3BoeXNpY2FsTWF4IC1cbiAgICAgICAgdGhpcy5fc2Nyb2xsU2l6ZSArXG4gICAgICAgICh0aGlzLml0ZW1zLmxlbmd0aCAtIDEgLSB0aGlzLl9sYXN0KSAqIHRoaXMuX2RlbHRhXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIG92ZXJyaWRlIF9yZWZsb3coKSB7XG4gICAgY29uc3Qge19maXJzdCwgX2xhc3R9ID0gdGhpcztcbiAgICBzdXBlci5fcmVmbG93KCk7XG4gICAgaWYgKFxuICAgICAgKHRoaXMuX2ZpcnN0ID09PSAtMSAmJiB0aGlzLl9sYXN0ID09IC0xKSB8fFxuICAgICAgKHRoaXMuX2ZpcnN0ID09PSBfZmlyc3QgJiYgdGhpcy5fbGFzdCA9PT0gX2xhc3QpXG4gICAgKSB7XG4gICAgICB0aGlzLl9yZXNldFJlZmxvd1N0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3Jlc2V0UmVmbG93U3RhdGUoKSB7XG4gICAgdGhpcy5fYW5jaG9ySWR4ID0gbnVsbDtcbiAgICB0aGlzLl9hbmNob3JQb3MgPSBudWxsO1xuICAgIHRoaXMuX3N0YWJsZSA9IHRydWU7XG4gIH1cblxuICBfdXBkYXRlU2Nyb2xsU2l6ZSgpIHtcbiAgICBjb25zdCB7YXZlcmFnZU1hcmdpblNpemV9ID0gdGhpcy5fbWV0cmljc0NhY2hlO1xuICAgIHRoaXMuX3Njcm9sbFNpemUgPSBNYXRoLm1heChcbiAgICAgIDEsXG4gICAgICB0aGlzLml0ZW1zLmxlbmd0aCAqIChhdmVyYWdlTWFyZ2luU2l6ZSArIHRoaXMuX2dldEF2ZXJhZ2VTaXplKCkpICtcbiAgICAgICAgYXZlcmFnZU1hcmdpblNpemVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGF2ZXJhZ2Ugc2l6ZSAocHJlY2lzZSBvciBlc3RpbWF0ZWQpIG9mIGFuIGl0ZW0gaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24sXG4gICAqIGluY2x1ZGluZyBhbnkgc3Vycm91bmRpbmcgc3BhY2UuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0IF9kZWx0YSgpOiBudW1iZXIge1xuICAgIGNvbnN0IHthdmVyYWdlTWFyZ2luU2l6ZX0gPSB0aGlzLl9tZXRyaWNzQ2FjaGU7XG4gICAgcmV0dXJuIHRoaXMuX2dldEF2ZXJhZ2VTaXplKCkgKyBhdmVyYWdlTWFyZ2luU2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3AgYW5kIGxlZnQgcG9zaXRpb25pbmcgb2YgdGhlIGl0ZW0gYXQgaWR4LlxuICAgKi9cbiAgX2dldEl0ZW1Qb3NpdGlvbihpZHg6IG51bWJlcik6IFBvc2l0aW9ucyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFt0aGlzLl9wb3NpdGlvbkRpbV06IHRoaXMuX2dldFBvc2l0aW9uKGlkeCksXG4gICAgICBbdGhpcy5fc2Vjb25kYXJ5UG9zaXRpb25EaW1dOiAwLFxuICAgICAgW29mZnNldCh0aGlzLmRpcmVjdGlvbildOiAtKFxuICAgICAgICB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TGVhZGluZ01hcmdpblZhbHVlKGlkeCwgdGhpcy5kaXJlY3Rpb24pID8/XG4gICAgICAgIHRoaXMuX21ldHJpY3NDYWNoZS5hdmVyYWdlTWFyZ2luU2l6ZVxuICAgICAgKSxcbiAgICB9IGFzIFBvc2l0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSBpdGVtIGF0IGlkeC5cbiAgICovXG4gIF9nZXRJdGVtU2l6ZShpZHg6IG51bWJlcik6IFNpemUge1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5fc2l6ZURpbV06IHRoaXMuX2dldFNpemUoaWR4KSB8fCB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpLFxuICAgICAgW3RoaXMuX3NlY29uZGFyeVNpemVEaW1dOiB0aGlzLl9pdGVtU2l6ZVt0aGlzLl9zZWNvbmRhcnlTaXplRGltXSxcbiAgICB9IGFzIFNpemU7XG4gIH1cblxuICBfdmlld0RpbTJDaGFuZ2VkKCkge1xuICAgIHRoaXMuX21ldHJpY3NDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/flow.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SizeCache: () => (/* binding */ SizeCache)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nclass SizeCache {\n  constructor(config) {\n    this._map = new Map();\n    this._roundAverageSize = false;\n    this.totalSize = 0;\n    if ((config === null || config === void 0 ? void 0 : config.roundAverageSize) === true) {\n      this._roundAverageSize = true;\n    }\n  }\n  set(index, value) {\n    const prev = this._map.get(index) || 0;\n    this._map.set(index, value);\n    this.totalSize += value - prev;\n  }\n  get averageSize() {\n    if (this._map.size > 0) {\n      const average = this.totalSize / this._map.size;\n      return this._roundAverageSize ? Math.round(average) : average;\n    }\n    return 0;\n  }\n  getSize(index) {\n    return this._map.get(index);\n  }\n  clear() {\n    this._map.clear();\n    this.totalSize = 0;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvc2hhcmVkL1NpemVDYWNoZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0FBVUE7QUFLQTtBQUpBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vc3JjL2xheW91dHMvc2hhcmVkL1NpemVDYWNoZS50cz9lZTljIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFNpemVDYWNoZUNvbmZpZyB7XG4gIHJvdW5kQXZlcmFnZVNpemU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgU2l6ZUNhY2hlIHtcbiAgcHJpdmF0ZSBfbWFwOiBNYXA8bnVtYmVyIHwgc3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIF9yb3VuZEF2ZXJhZ2VTaXplID0gZmFsc2U7XG4gIHRvdGFsU2l6ZSA9IDA7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnPzogU2l6ZUNhY2hlQ29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZz8ucm91bmRBdmVyYWdlU2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fcm91bmRBdmVyYWdlU2l6ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgc2V0KGluZGV4OiBudW1iZXIgfCBzdHJpbmcsIHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBwcmV2ID0gdGhpcy5fbWFwLmdldChpbmRleCkgfHwgMDtcbiAgICB0aGlzLl9tYXAuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgdGhpcy50b3RhbFNpemUgKz0gdmFsdWUgLSBwcmV2O1xuICB9XG5cbiAgZ2V0IGF2ZXJhZ2VTaXplKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuX21hcC5zaXplID4gMCkge1xuICAgICAgY29uc3QgYXZlcmFnZSA9IHRoaXMudG90YWxTaXplIC8gdGhpcy5fbWFwLnNpemU7XG4gICAgICByZXR1cm4gdGhpcy5fcm91bmRBdmVyYWdlU2l6ZSA/IE1hdGgucm91bmQoYXZlcmFnZSkgOiBhdmVyYWdlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldFNpemUoaW5kZXg6IG51bWJlciB8IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KGluZGV4KTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgIHRoaXMudG90YWxTaXplID0gMDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js\n");

/***/ })

}]);