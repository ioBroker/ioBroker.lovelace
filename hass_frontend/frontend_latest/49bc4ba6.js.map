{"version":3,"file":"49bc4ba6.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrDA;;ACsCA;;AAGA;;;;AAIA;AACA;;;AAGA;AAEA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AAEA;;;AAMA;;AAIA;AACA;AACA;AACA;;;;AAKA;;;;AAMA;AACA;;AAEA;AACA;;;;;AAKA;;;;;AAKA;AAEA;;;AAKA;AACA;;AAEA;AAEA;;AAGA;;;AAKA;AACA;AACA;;;AAGA;AAEA;;AAGA;;;AAKA;AACA;AACA;;;;AAIA;;;AAKA;AACA;AACA;;;AAGA;;AAIA;;;;AAMA;;;;AAIA;AACA;;AAEA;AAEA;AACA;;;;;AAMA;AAEA;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzMA","sources":["webpack://home-assistant-frontend/./src/components/ha-color-picker.js","webpack://home-assistant-frontend/./src/components/ha-labeled-slider.js","webpack://home-assistant-frontend/./src/dialogs/more-info/controls/more-info-light.ts"],"sourcesContent":["import { html } from \"@polymer/polymer/lib/utils/html-tag\";\n/* eslint-plugin-disable lit */\nimport { PolymerElement } from \"@polymer/polymer/polymer-element\";\nimport { hs2rgb, rgb2hs } from \"../common/color/convert-color\";\nimport { EventsMixin } from \"../mixins/events-mixin\";\n/**\n * Color-picker custom element\n *\n * @appliesMixin EventsMixin\n */\nclass HaColorPicker extends EventsMixin(PolymerElement) {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          user-select: none;\n          -webkit-user-select: none;\n        }\n\n        #canvas {\n          position: relative;\n          width: 100%;\n          max-width: 330px;\n        }\n        #canvas > * {\n          display: block;\n        }\n        #interactionLayer {\n          color: white;\n          position: absolute;\n          cursor: crosshair;\n          width: 100%;\n          height: 100%;\n          overflow: visible;\n        }\n        #backgroundLayer {\n          width: 100%;\n          overflow: visible;\n          --wheel-bordercolor: var(--ha-color-picker-wheel-bordercolor, white);\n          --wheel-borderwidth: var(--ha-color-picker-wheel-borderwidth, 3);\n          --wheel-shadow: var(\n            --ha-color-picker-wheel-shadow,\n            rgb(15, 15, 15) 10px 5px 5px 0px\n          );\n        }\n\n        #marker {\n          fill: currentColor;\n          stroke: var(--ha-color-picker-marker-bordercolor, white);\n          stroke-width: var(--ha-color-picker-marker-borderwidth, 3);\n          filter: url(#marker-shadow);\n        }\n        .dragging #marker {\n        }\n\n        #colorTooltip {\n          display: none;\n          fill: currentColor;\n          stroke: var(--ha-color-picker-tooltip-bordercolor, white);\n          stroke-width: var(--ha-color-picker-tooltip-borderwidth, 3);\n        }\n\n        .touch.dragging #colorTooltip {\n          display: inherit;\n        }\n      </style>\n      <div id=\"canvas\">\n        <svg id=\"interactionLayer\">\n          <defs>\n            <filter\n              id=\"marker-shadow\"\n              x=\"-50%\"\n              y=\"-50%\"\n              width=\"200%\"\n              height=\"200%\"\n              filterUnits=\"objectBoundingBox\"\n            >\n              <feOffset\n                result=\"offOut\"\n                in=\"SourceAlpha\"\n                dx=\"2\"\n                dy=\"2\"\n              ></feOffset>\n              <feGaussianBlur\n                result=\"blurOut\"\n                in=\"offOut\"\n                stdDeviation=\"2\"\n              ></feGaussianBlur>\n              <feComponentTransfer in=\"blurOut\" result=\"alphaOut\">\n                <feFuncA type=\"linear\" slope=\"0.3\"></feFuncA>\n              </feComponentTransfer>\n              <feBlend\n                in=\"SourceGraphic\"\n                in2=\"alphaOut\"\n                mode=\"normal\"\n              ></feBlend>\n            </filter>\n          </defs>\n        </svg>\n        <canvas id=\"backgroundLayer\"></canvas>\n      </div>\n    `;\n  }\n\n  static get properties() {\n    return {\n      hsColor: {\n        type: Object,\n      },\n\n      // use these properties to update the state via attributes\n      desiredHsColor: {\n        type: Object,\n        observer: \"applyHsColor\",\n      },\n\n      // use these properties to update the state via attributes\n      desiredRgbColor: {\n        type: Object,\n        observer: \"applyRgbColor\",\n      },\n\n      // width, height and radius apply to the coordinates of\n      // of the canvas.\n      // border width are relative to these numbers\n      // the onscreen displayed size should be controlled with css\n      // and should be the same or smaller\n      width: {\n        type: Number,\n        value: 500,\n      },\n\n      height: {\n        type: Number,\n        value: 500,\n      },\n\n      radius: {\n        type: Number,\n        value: 225,\n      },\n\n      // the amount segments for the hue\n      // 0 = continuous gradient\n      // other than 0 gives 'pie-pieces'\n      hueSegments: {\n        type: Number,\n        value: 0,\n        observer: \"segmentationChange\",\n      },\n\n      // the amount segments for the hue\n      // 0 = continuous gradient\n      // 1 = only fully saturated\n      // > 1 = segments from white to fully saturated\n      saturationSegments: {\n        type: Number,\n        value: 0,\n        observer: \"segmentationChange\",\n      },\n\n      // set to true to make the segments purely esthetical\n      // this allows selection off all collors, also\n      // interpolated between the segments\n      ignoreSegments: {\n        type: Boolean,\n        value: false,\n      },\n\n      // throttle te amount of 'colorselected' events fired\n      // value is timeout in milliseconds\n      throttle: {\n        type: Number,\n        value: 500,\n      },\n    };\n  }\n\n  ready() {\n    super.ready();\n    this.setupLayers();\n    this.drawColorWheel();\n    this.drawMarker();\n\n    if (this.desiredHsColor) {\n      this.applyHsColor(this.desiredHsColor);\n    }\n\n    if (this.desiredRgbColor) {\n      this.applyRgbColor(this.desiredRgbColor);\n    }\n\n    this.interactionLayer.addEventListener(\"mousedown\", (ev) =>\n      this.onMouseDown(ev)\n    );\n    this.interactionLayer.addEventListener(\"touchstart\", (ev) =>\n      this.onTouchStart(ev)\n    );\n  }\n\n  // converts browser coordinates to canvas canvas coordinates\n  // origin is wheel center\n  // returns {x: X, y: Y} object\n  convertToCanvasCoordinates(clientX, clientY) {\n    const svgPoint = this.interactionLayer.createSVGPoint();\n    svgPoint.x = clientX;\n    svgPoint.y = clientY;\n    const cc = svgPoint.matrixTransform(\n      this.interactionLayer.getScreenCTM().inverse()\n    );\n    return { x: cc.x, y: cc.y };\n  }\n\n  // Mouse events\n\n  onMouseDown(ev) {\n    const cc = this.convertToCanvasCoordinates(ev.clientX, ev.clientY);\n    // return if we're not on the wheel\n    if (!this.isInWheel(cc.x, cc.y)) {\n      return;\n    }\n    // a mousedown in wheel is always a color select action\n    this.onMouseSelect(ev);\n    // allow dragging\n    this.canvas.classList.add(\"mouse\", \"dragging\");\n    this.addEventListener(\"mousemove\", this.onMouseSelect);\n    this.addEventListener(\"mouseup\", this.onMouseUp);\n  }\n\n  onMouseUp() {\n    this.canvas.classList.remove(\"mouse\", \"dragging\");\n    this.removeEventListener(\"mousemove\", this.onMouseSelect);\n  }\n\n  onMouseSelect(ev) {\n    requestAnimationFrame(() => this.processUserSelect(ev));\n  }\n\n  // Touch events\n\n  onTouchStart(ev) {\n    const touch = ev.changedTouches[0];\n    const cc = this.convertToCanvasCoordinates(touch.clientX, touch.clientY);\n    // return if we're not on the wheel\n    if (!this.isInWheel(cc.x, cc.y)) {\n      return;\n    }\n    if (ev.target === this.marker) {\n      // drag marker\n      ev.preventDefault();\n      this.canvas.classList.add(\"touch\", \"dragging\");\n      this.addEventListener(\"touchmove\", this.onTouchSelect);\n      this.addEventListener(\"touchend\", this.onTouchEnd);\n      return;\n    }\n    // don't fire color selection immediately,\n    // wait for touchend and invalidate when we scroll\n    this.tapBecameScroll = false;\n    this.addEventListener(\"touchend\", this.onTap);\n    this.addEventListener(\n      \"touchmove\",\n      () => {\n        this.tapBecameScroll = true;\n      },\n      { passive: true }\n    );\n  }\n\n  onTap(ev) {\n    if (this.tapBecameScroll) {\n      return;\n    }\n    ev.preventDefault();\n    this.onTouchSelect(ev);\n  }\n\n  onTouchEnd() {\n    this.canvas.classList.remove(\"touch\", \"dragging\");\n    this.removeEventListener(\"touchmove\", this.onTouchSelect);\n  }\n\n  onTouchSelect(ev) {\n    requestAnimationFrame(() => this.processUserSelect(ev.changedTouches[0]));\n  }\n\n  /*\n   * General event/selection handling\n   */\n\n  // Process user input to color\n  processUserSelect(ev) {\n    const canvasXY = this.convertToCanvasCoordinates(ev.clientX, ev.clientY);\n    const hs = this.getColor(canvasXY.x, canvasXY.y);\n    let rgb;\n    if (!this.isInWheel(canvasXY.x, canvasXY.y)) {\n      const [r, g, b] = hs2rgb([hs.h, hs.s]);\n      rgb = { r, g, b };\n    } else {\n      rgb = this.getRgbColor(canvasXY.x, canvasXY.y);\n    }\n    this.onColorSelect(hs, rgb);\n  }\n\n  // apply color to marker position and canvas\n  onColorSelect(hs, rgb) {\n    this.setMarkerOnColor(hs); // marker always follows mouse 'raw' hs value (= mouse position)\n    if (!this.ignoreSegments) {\n      // apply segments if needed\n      hs = this.applySegmentFilter(hs);\n    }\n    // always apply the new color to the interface / canvas\n    this.applyColorToCanvas(hs);\n    // throttling is applied to updating the exposed colors (properties)\n    // and firing of events\n    if (this.colorSelectIsThrottled) {\n      // make sure we apply the last selected color\n      // eventually after throttle limit has passed\n      clearTimeout(this.ensureFinalSelect);\n      this.ensureFinalSelect = setTimeout(() => {\n        this.fireColorSelected(hs, rgb); // do it for the final time\n      }, this.throttle);\n      return;\n    }\n    this.fireColorSelected(hs, rgb); // do it\n    this.colorSelectIsThrottled = true;\n    setTimeout(() => {\n      this.colorSelectIsThrottled = false;\n    }, this.throttle);\n  }\n\n  // set color values and fire colorselected event\n  fireColorSelected(hs, rgb) {\n    this.hsColor = hs;\n    this.fire(\"colorselected\", { hs, rgb });\n  }\n\n  /*\n   * Interface updating\n   */\n\n  // set marker position to the given color\n  setMarkerOnColor(hs) {\n    if (!this.marker || !this.tooltip) {\n      return;\n    }\n    const dist = hs.s * this.radius;\n    const theta = ((hs.h - 180) / 180) * Math.PI;\n    const markerdX = -dist * Math.cos(theta);\n    const markerdY = -dist * Math.sin(theta);\n    const translateString = `translate(${markerdX},${markerdY})`;\n    this.marker.setAttribute(\"transform\", translateString);\n    this.tooltip.setAttribute(\"transform\", translateString);\n  }\n\n  // apply given color to interface elements\n  applyColorToCanvas(hs) {\n    if (!this.interactionLayer) {\n      return;\n    }\n    // we're not really converting hs to hsl here, but we keep it cheap\n    // setting the color on the interactionLayer, the svg elements can inherit\n    this.interactionLayer.style.color = `hsl(${hs.h}, 100%, ${\n      100 - hs.s * 50\n    }%)`;\n  }\n\n  applyHsColor(hs) {\n    // do nothing is we already have the same color\n    if (this.hsColor && this.hsColor.h === hs.h && this.hsColor.s === hs.s) {\n      return;\n    }\n    this.setMarkerOnColor(hs); // marker is always set on 'raw' hs position\n    if (!this.ignoreSegments) {\n      // apply segments if needed\n      hs = this.applySegmentFilter(hs);\n    }\n    this.hsColor = hs;\n    // always apply the new color to the interface / canvas\n    this.applyColorToCanvas(hs);\n  }\n\n  applyRgbColor(rgb) {\n    const [h, s] = rgb2hs(rgb);\n    this.applyHsColor({ h, s });\n  }\n\n  /*\n   * input processing helpers\n   */\n\n  // get angle (degrees)\n  getAngle(dX, dY) {\n    const theta = Math.atan2(-dY, -dX); // radians from the left edge, clockwise = positive\n    const angle = (theta / Math.PI) * 180 + 180; // degrees, clockwise from right\n    return angle;\n  }\n\n  // returns true when coordinates are in the colorwheel\n  isInWheel(x, y) {\n    return this.getDistance(x, y) <= 1;\n  }\n\n  // returns distance from wheel center, 0 = center, 1 = edge, >1 = outside\n  getDistance(dX, dY) {\n    return Math.sqrt(dX * dX + dY * dY) / this.radius;\n  }\n\n  /*\n   * Getting colors\n   */\n\n  getColor(x, y) {\n    const hue = this.getAngle(x, y); // degrees, clockwise from right\n    const relativeDistance = this.getDistance(x, y); // edge of radius = 1\n    const sat = Math.min(relativeDistance, 1); // Distance from center\n    return { h: hue, s: sat };\n  }\n\n  getRgbColor(x, y) {\n    // get current pixel\n    const imageData = this.backgroundLayer\n      .getContext(\"2d\")\n      .getImageData(x + 250, y + 250, 1, 1);\n    const pixel = imageData.data;\n    return { r: pixel[0], g: pixel[1], b: pixel[2] };\n  }\n\n  applySegmentFilter(hs) {\n    // apply hue segment steps\n    if (this.hueSegments) {\n      const angleStep = 360 / this.hueSegments;\n      const halfAngleStep = angleStep / 2;\n      hs.h -= halfAngleStep; // take the 'centered segemnts' into account\n      if (hs.h < 0) {\n        hs.h += 360;\n      } // don't end up below 0\n      const rest = hs.h % angleStep;\n      hs.h -= rest - angleStep;\n    }\n\n    // apply saturation segment steps\n    if (this.saturationSegments) {\n      if (this.saturationSegments === 1) {\n        hs.s = 1;\n      } else {\n        const segmentSize = 1 / this.saturationSegments;\n        const saturationStep = 1 / (this.saturationSegments - 1);\n        const calculatedSat = Math.floor(hs.s / segmentSize) * saturationStep;\n        hs.s = Math.min(calculatedSat, 1);\n      }\n    }\n    return hs;\n  }\n\n  /*\n   * Drawing related stuff\n   */\n\n  setupLayers() {\n    this.canvas = this.$.canvas;\n    this.backgroundLayer = this.$.backgroundLayer;\n    this.interactionLayer = this.$.interactionLayer;\n\n    // coordinate origin position (center of the wheel)\n    this.originX = this.width / 2;\n    this.originY = this.originX;\n\n    // synchronise width/height coordinates\n    this.backgroundLayer.width = this.width;\n    this.backgroundLayer.height = this.height;\n    this.interactionLayer.setAttribute(\n      \"viewBox\",\n      `${-this.originX} ${-this.originY} ${this.width} ${this.height}`\n    );\n  }\n\n  drawColorWheel() {\n    /*\n     *  Setting up all paremeters\n     */\n    let shadowColor;\n    let shadowOffsetX;\n    let shadowOffsetY;\n    let shadowBlur;\n    const context = this.backgroundLayer.getContext(\"2d\");\n    // postioning and sizing\n    const cX = this.originX;\n    const cY = this.originY;\n    const radius = this.radius;\n    const counterClockwise = false;\n    // styling of the wheel\n    const wheelStyle = window.getComputedStyle(this.backgroundLayer, null);\n    const borderWidth = parseInt(\n      wheelStyle.getPropertyValue(\"--wheel-borderwidth\"),\n      10\n    );\n    const borderColor = wheelStyle\n      .getPropertyValue(\"--wheel-bordercolor\")\n      .trim();\n    const wheelShadow = wheelStyle.getPropertyValue(\"--wheel-shadow\").trim();\n    // extract shadow properties from CSS variable\n    // the shadow should be defined as: \"10px 5px 5px 0px COLOR\"\n    if (wheelShadow !== \"none\") {\n      const values = wheelShadow.split(\"px \");\n      shadowColor = values.pop();\n      shadowOffsetX = parseInt(values[0], 10);\n      shadowOffsetY = parseInt(values[1], 10);\n      shadowBlur = parseInt(values[2], 10) || 0;\n    }\n    const borderRadius = radius + borderWidth / 2;\n    const wheelRadius = radius;\n    const shadowRadius = radius + borderWidth;\n\n    /*\n     *  Drawing functions\n     */\n    function drawCircle(hueSegments, saturationSegments) {\n      hueSegments = hueSegments || 360; // reset 0 segments to 360\n      const angleStep = 360 / hueSegments;\n      const halfAngleStep = angleStep / 2; // center segments on color\n      for (let angle = 0; angle <= 360; angle += angleStep) {\n        const startAngle = (angle - halfAngleStep) * (Math.PI / 180);\n        const endAngle = (angle + halfAngleStep + 1) * (Math.PI / 180);\n        context.beginPath();\n        context.moveTo(cX, cY);\n        context.arc(\n          cX,\n          cY,\n          wheelRadius,\n          startAngle,\n          endAngle,\n          counterClockwise\n        );\n        context.closePath();\n        // gradient\n        const gradient = context.createRadialGradient(\n          cX,\n          cY,\n          0,\n          cX,\n          cY,\n          wheelRadius\n        );\n        let lightness = 100;\n        // first gradient stop\n        gradient.addColorStop(0, `hsl(${angle}, 100%, ${lightness}%)`);\n        // segment gradient stops\n        if (saturationSegments > 0) {\n          const ratioStep = 1 / saturationSegments;\n          let ratio = 0;\n          for (let stop = 1; stop < saturationSegments; stop += 1) {\n            const prevLighness = lightness;\n            ratio = stop * ratioStep;\n            lightness = 100 - 50 * ratio;\n            gradient.addColorStop(\n              ratio,\n              `hsl(${angle}, 100%, ${prevLighness}%)`\n            );\n            gradient.addColorStop(ratio, `hsl(${angle}, 100%, ${lightness}%)`);\n          }\n          gradient.addColorStop(ratio, `hsl(${angle}, 100%, 50%)`);\n        }\n        // last gradient stop\n        gradient.addColorStop(1, `hsl(${angle}, 100%, 50%)`);\n\n        context.fillStyle = gradient;\n        context.fill();\n      }\n    }\n\n    function drawShadow() {\n      context.save();\n      context.beginPath();\n      context.arc(cX, cY, shadowRadius, 0, 2 * Math.PI, false);\n      context.shadowColor = shadowColor;\n      context.shadowOffsetX = shadowOffsetX;\n      context.shadowOffsetY = shadowOffsetY;\n      context.shadowBlur = shadowBlur;\n      context.fillStyle = \"white\";\n      context.fill();\n      context.restore();\n    }\n\n    function drawBorder() {\n      context.beginPath();\n      context.arc(cX, cY, borderRadius, 0, 2 * Math.PI, false);\n      context.lineWidth = borderWidth;\n      context.strokeStyle = borderColor;\n      context.stroke();\n    }\n\n    /*\n     *   Call the drawing functions\n     *   draws the shadow, wheel and border\n     */\n    if (wheelStyle.shadow !== \"none\") {\n      drawShadow();\n    }\n    drawCircle(this.hueSegments, this.saturationSegments);\n    if (borderWidth > 0) {\n      drawBorder();\n    }\n  }\n\n  /*\n   *   Draw the (draggable) marker and tooltip\n   *   on the interactionLayer)\n   */\n\n  drawMarker() {\n    const svgElement = this.interactionLayer;\n    const markerradius = this.radius * 0.08;\n    const tooltipradius = this.radius * 0.15;\n    const TooltipOffsetY = -(tooltipradius * 3);\n    const TooltipOffsetX = 0;\n\n    svgElement.marker = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"circle\"\n    );\n    svgElement.marker.setAttribute(\"id\", \"marker\");\n    svgElement.marker.setAttribute(\"r\", markerradius);\n    this.marker = svgElement.marker;\n    svgElement.appendChild(svgElement.marker);\n\n    svgElement.tooltip = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"circle\"\n    );\n    svgElement.tooltip.setAttribute(\"id\", \"colorTooltip\");\n    svgElement.tooltip.setAttribute(\"r\", tooltipradius);\n    svgElement.tooltip.setAttribute(\"cx\", TooltipOffsetX);\n    svgElement.tooltip.setAttribute(\"cy\", TooltipOffsetY);\n    this.tooltip = svgElement.tooltip;\n    svgElement.appendChild(svgElement.tooltip);\n  }\n\n  segmentationChange() {\n    if (this.backgroundLayer) {\n      this.drawColorWheel();\n    }\n  }\n}\ncustomElements.define(\"ha-color-picker\", HaColorPicker);\n","import { html } from \"@polymer/polymer/lib/utils/html-tag\";\n/* eslint-plugin-disable lit */\nimport { PolymerElement } from \"@polymer/polymer/polymer-element\";\nimport \"./ha-icon\";\nimport \"./ha-slider\";\n\nclass HaLabeledSlider extends PolymerElement {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: block;\n        }\n\n        .title {\n          margin: 5px 0 8px;\n          color: var(--primary-text-color);\n        }\n\n        .slider-container {\n          display: flex;\n        }\n\n        ha-icon {\n          margin-top: 4px;\n          color: var(--secondary-text-color);\n        }\n\n        ha-slider {\n          flex-grow: 1;\n          background-image: var(--ha-slider-background);\n          border-radius: 4px;\n        }\n      </style>\n\n      <div class=\"title\">[[caption]]</div>\n      <div class=\"extra-container\"><slot name=\"extra\"></slot></div>\n      <div class=\"slider-container\">\n        <ha-icon icon=\"[[icon]]\" hidden$=\"[[!icon]]\"></ha-icon>\n        <ha-slider\n          min=\"[[min]]\"\n          max=\"[[max]]\"\n          step=\"[[step]]\"\n          pin=\"[[pin]]\"\n          disabled=\"[[disabled]]\"\n          value=\"{{value}}\"\n        ></ha-slider>\n      </div>\n    `;\n  }\n\n  static get properties() {\n    return {\n      caption: String,\n      disabled: Boolean,\n      min: Number,\n      max: Number,\n      pin: Boolean,\n      step: Number,\n\n      extra: {\n        type: Boolean,\n        value: false,\n      },\n      ignoreBarTouch: {\n        type: Boolean,\n        value: true,\n      },\n      icon: {\n        type: String,\n        value: \"\",\n      },\n      value: {\n        type: Number,\n        notify: true,\n      },\n    };\n  }\n}\n\ncustomElements.define(\"ha-labeled-slider\", HaLabeledSlider);\n","import { mdiPalette } from \"@mdi/js\";\nimport \"@polymer/paper-item/paper-item\";\nimport \"@polymer/paper-listbox/paper-listbox\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { supportsFeature } from \"../../../common/entity/supports-feature\";\nimport \"../../../components/ha-attributes\";\nimport \"../../../components/ha-button-toggle-group\";\nimport \"../../../components/ha-color-picker\";\nimport \"../../../components/ha-icon-button\";\nimport \"../../../components/ha-labeled-slider\";\nimport \"../../../components/ha-paper-dropdown-menu\";\nimport {\n  getLightCurrentModeRgbColor,\n  LightColorModes,\n  LightEntity,\n  lightIsInColorMode,\n  lightSupportsColor,\n  lightSupportsColorMode,\n  lightSupportsDimming,\n  SUPPORT_EFFECT,\n} from \"../../../data/light\";\nimport type { HomeAssistant } from \"../../../types\";\n\n@customElement(\"more-info-light\")\nclass MoreInfoLight extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public stateObj?: LightEntity;\n\n  @state() private _brightnessSliderValue = 0;\n\n  @state() private _ctSliderValue?: number;\n\n  @state() private _cwSliderValue?: number;\n\n  @state() private _wwSliderValue?: number;\n\n  @state() private _wvSliderValue?: number;\n\n  @state() private _colorBrightnessSliderValue?: number;\n\n  @state() private _brightnessAdjusted?: number;\n\n  @state() private _hueSegments = 24;\n\n  @state() private _saturationSegments = 8;\n\n  @state() private _colorPickerColor?: [number, number, number];\n\n  @state() private _mode?: \"color\" | LightColorModes;\n\n  protected render(): TemplateResult {\n    if (!this.hass || !this.stateObj) {\n      return html``;\n    }\n\n    const supportsTemp = lightSupportsColorMode(\n      this.stateObj,\n      LightColorModes.COLOR_TEMP\n    );\n\n    const supportsWhite = lightSupportsColorMode(\n      this.stateObj,\n      LightColorModes.WHITE\n    );\n\n    const supportsRgbww = lightSupportsColorMode(\n      this.stateObj,\n      LightColorModes.RGBWW\n    );\n\n    const supportsRgbw =\n      !supportsRgbww &&\n      lightSupportsColorMode(this.stateObj, LightColorModes.RGBW);\n\n    const supportsColor =\n      supportsRgbww || supportsRgbw || lightSupportsColor(this.stateObj);\n\n    return html`\n      <div class=\"content\">\n        ${lightSupportsDimming(this.stateObj)\n          ? html`\n              <ha-labeled-slider\n                caption=${this.hass.localize(\"ui.card.light.brightness\")}\n                icon=\"hass:brightness-5\"\n                min=\"1\"\n                max=\"100\"\n                value=${this._brightnessSliderValue}\n                @change=${this._brightnessSliderChanged}\n                pin\n              ></ha-labeled-slider>\n            `\n          : \"\"}\n        ${this.stateObj.state === \"on\"\n          ? html`\n              ${supportsTemp || supportsColor ? html`<hr />` : \"\"}\n              ${supportsColor && (supportsTemp || supportsWhite)\n                ? html`<ha-button-toggle-group\n                    fullWidth\n                    .buttons=${this._toggleButtons(supportsTemp, supportsWhite)}\n                    .active=${this._mode}\n                    @value-changed=${this._modeChanged}\n                  ></ha-button-toggle-group>`\n                : \"\"}\n              ${supportsTemp &&\n              ((!supportsColor && !supportsWhite) ||\n                this._mode === LightColorModes.COLOR_TEMP)\n                ? html`\n                    <ha-labeled-slider\n                      class=\"color_temp\"\n                      caption=${this.hass.localize(\n                        \"ui.card.light.color_temperature\"\n                      )}\n                      icon=\"hass:thermometer\"\n                      .min=${this.stateObj.attributes.min_mireds}\n                      .max=${this.stateObj.attributes.max_mireds}\n                      .value=${this._ctSliderValue}\n                      @change=${this._ctSliderChanged}\n                      pin\n                    ></ha-labeled-slider>\n                  `\n                : \"\"}\n              ${supportsColor &&\n              ((!supportsTemp && !supportsWhite) || this._mode === \"color\")\n                ? html`\n                    <div class=\"segmentationContainer\">\n                      <ha-color-picker\n                        class=\"color\"\n                        @colorselected=${this._colorPicked}\n                        .desiredRgbColor=${this._colorPickerColor}\n                        throttle=\"500\"\n                        .hueSegments=${this._hueSegments}\n                        .saturationSegments=${this._saturationSegments}\n                      >\n                      </ha-color-picker>\n                      <ha-icon-button\n                        .path=${mdiPalette}\n                        @click=${this._segmentClick}\n                        class=\"segmentationButton\"\n                      ></ha-icon-button>\n                    </div>\n\n                    ${supportsRgbw || supportsRgbww\n                      ? html`<ha-labeled-slider\n                          .caption=${this.hass.localize(\n                            \"ui.card.light.color_brightness\"\n                          )}\n                          icon=\"hass:brightness-7\"\n                          max=\"100\"\n                          .value=${this._colorBrightnessSliderValue}\n                          @change=${this._colorBrightnessSliderChanged}\n                          pin\n                        ></ha-labeled-slider>`\n                      : \"\"}\n                    ${supportsRgbw\n                      ? html`\n                          <ha-labeled-slider\n                            .caption=${this.hass.localize(\n                              \"ui.card.light.white_value\"\n                            )}\n                            icon=\"hass:file-word-box\"\n                            max=\"100\"\n                            .name=${\"wv\"}\n                            .value=${this._wvSliderValue}\n                            @change=${this._wvSliderChanged}\n                            pin\n                          ></ha-labeled-slider>\n                        `\n                      : \"\"}\n                    ${supportsRgbww\n                      ? html`\n                          <ha-labeled-slider\n                            .caption=${this.hass.localize(\n                              \"ui.card.light.cold_white_value\"\n                            )}\n                            icon=\"hass:file-word-box-outline\"\n                            max=\"100\"\n                            .name=${\"cw\"}\n                            .value=${this._cwSliderValue}\n                            @change=${this._wvSliderChanged}\n                            pin\n                          ></ha-labeled-slider>\n                          <ha-labeled-slider\n                            .caption=${this.hass.localize(\n                              \"ui.card.light.warm_white_value\"\n                            )}\n                            icon=\"hass:file-word-box\"\n                            max=\"100\"\n                            .name=${\"ww\"}\n                            .value=${this._wwSliderValue}\n                            @change=${this._wvSliderChanged}\n                            pin\n                          ></ha-labeled-slider>\n                        `\n                      : \"\"}\n                  `\n                : \"\"}\n              ${supportsFeature(this.stateObj, SUPPORT_EFFECT) &&\n              this.stateObj!.attributes.effect_list?.length\n                ? html`\n                    <hr />\n                    <ha-paper-dropdown-menu\n                      dynamic-align\n                      .label=${this.hass.localize(\"ui.card.light.effect\")}\n                    >\n                      <paper-listbox\n                        slot=\"dropdown-content\"\n                        .selected=${this.stateObj.attributes.effect || \"\"}\n                        @iron-select=${this._effectChanged}\n                        attr-for-selected=\"item-name\"\n                        >${this.stateObj.attributes.effect_list.map(\n                          (effect: string) => html`\n                            <paper-item .itemName=${effect}\n                              >${effect}</paper-item\n                            >\n                          `\n                        )}\n                      </paper-listbox>\n                    </ha-paper-dropdown-menu>\n                  `\n                : \"\"}\n            `\n          : \"\"}\n        <ha-attributes\n          .hass=${this.hass}\n          .stateObj=${this.stateObj}\n          extra-filters=\"brightness,color_temp,white_value,effect_list,effect,hs_color,rgb_color,rgbw_color,rgbww_color,xy_color,min_mireds,max_mireds,entity_id,supported_color_modes,color_mode\"\n        ></ha-attributes>\n      </div>\n    `;\n  }\n\n  public willUpdate(changedProps: PropertyValues<this>) {\n    super.willUpdate(changedProps);\n\n    if (!changedProps.has(\"stateObj\")) {\n      return;\n    }\n    const stateObj = this.stateObj! as LightEntity;\n    const oldStateObj = changedProps.get(\"stateObj\") as LightEntity | undefined;\n\n    if (stateObj.state === \"on\") {\n      // Don't change tab when the color mode changes\n      if (\n        oldStateObj?.entity_id !== stateObj.entity_id ||\n        oldStateObj?.state !== stateObj.state\n      ) {\n        this._mode = lightIsInColorMode(this.stateObj!)\n          ? \"color\"\n          : this.stateObj!.attributes.color_mode;\n      }\n\n      let brightnessAdjust = 100;\n      this._brightnessAdjusted = undefined;\n      if (\n        stateObj.attributes.color_mode === LightColorModes.RGB &&\n        !lightSupportsColorMode(stateObj, LightColorModes.RGBWW) &&\n        !lightSupportsColorMode(stateObj, LightColorModes.RGBW)\n      ) {\n        const maxVal = Math.max(...stateObj.attributes.rgb_color);\n        if (maxVal < 255) {\n          this._brightnessAdjusted = maxVal;\n          brightnessAdjust = (this._brightnessAdjusted / 255) * 100;\n        }\n      }\n      this._brightnessSliderValue = Math.round(\n        (stateObj.attributes.brightness * brightnessAdjust) / 255\n      );\n      this._ctSliderValue = stateObj.attributes.color_temp;\n      this._wvSliderValue =\n        stateObj.attributes.color_mode === LightColorModes.RGBW\n          ? Math.round((stateObj.attributes.rgbw_color[3] * 100) / 255)\n          : undefined;\n      this._cwSliderValue =\n        stateObj.attributes.color_mode === LightColorModes.RGBWW\n          ? Math.round((stateObj.attributes.rgbww_color[3] * 100) / 255)\n          : undefined;\n      this._wwSliderValue =\n        stateObj.attributes.color_mode === LightColorModes.RGBWW\n          ? Math.round((stateObj.attributes.rgbww_color[4] * 100) / 255)\n          : undefined;\n\n      const currentRgbColor = getLightCurrentModeRgbColor(stateObj);\n\n      this._colorBrightnessSliderValue = currentRgbColor\n        ? Math.round((Math.max(...currentRgbColor.slice(0, 3)) * 100) / 255)\n        : undefined;\n\n      this._colorPickerColor = currentRgbColor?.slice(0, 3) as [\n        number,\n        number,\n        number\n      ];\n    } else {\n      this._brightnessSliderValue = 0;\n    }\n  }\n\n  private _toggleButtons = memoizeOne(\n    (supportsTemp: boolean, supportsWhite: boolean) => {\n      const modes = [{ label: \"Color\", value: \"color\" }];\n      if (supportsTemp) {\n        modes.push({ label: \"Temperature\", value: LightColorModes.COLOR_TEMP });\n      }\n      if (supportsWhite) {\n        modes.push({ label: \"White\", value: LightColorModes.WHITE });\n      }\n      return modes;\n    }\n  );\n\n  private _modeChanged(ev: CustomEvent) {\n    this._mode = ev.detail.value;\n  }\n\n  private _effectChanged(ev: CustomEvent) {\n    const newVal = ev.detail.item.itemName;\n\n    if (!newVal || this.stateObj!.attributes.effect === newVal) {\n      return;\n    }\n\n    this.hass.callService(\"light\", \"turn_on\", {\n      entity_id: this.stateObj!.entity_id,\n      effect: newVal,\n    });\n  }\n\n  private _brightnessSliderChanged(ev: CustomEvent) {\n    const bri = Number((ev.target as any).value);\n\n    if (isNaN(bri)) {\n      return;\n    }\n\n    this._brightnessSliderValue = bri;\n\n    if (this._mode === LightColorModes.WHITE) {\n      this.hass.callService(\"light\", \"turn_on\", {\n        entity_id: this.stateObj!.entity_id,\n        white: Math.min(255, Math.round((bri * 255) / 100)),\n      });\n      return;\n    }\n\n    if (this._brightnessAdjusted) {\n      const rgb =\n        this.stateObj!.attributes.rgb_color ||\n        ([0, 0, 0] as [number, number, number]);\n\n      this.hass.callService(\"light\", \"turn_on\", {\n        entity_id: this.stateObj!.entity_id,\n        brightness_pct: bri,\n        rgb_color: this._adjustColorBrightness(\n          rgb,\n          this._brightnessAdjusted,\n          true\n        ),\n      });\n      return;\n    }\n\n    this.hass.callService(\"light\", \"turn_on\", {\n      entity_id: this.stateObj!.entity_id,\n      brightness_pct: bri,\n    });\n  }\n\n  private _ctSliderChanged(ev: CustomEvent) {\n    const ct = Number((ev.target as any).value);\n\n    if (isNaN(ct)) {\n      return;\n    }\n\n    this._ctSliderValue = ct;\n\n    this.hass.callService(\"light\", \"turn_on\", {\n      entity_id: this.stateObj!.entity_id,\n      color_temp: ct,\n    });\n  }\n\n  private _wvSliderChanged(ev: CustomEvent) {\n    const target = ev.target as any;\n    let wv = Number(target.value);\n    const name = target.name;\n\n    if (isNaN(wv)) {\n      return;\n    }\n\n    if (name === \"wv\") {\n      this._wvSliderValue = wv;\n    } else if (name === \"cw\") {\n      this._cwSliderValue = wv;\n    } else if (name === \"ww\") {\n      this._wwSliderValue = wv;\n    }\n\n    wv = Math.min(255, Math.round((wv * 255) / 100));\n\n    const rgb = getLightCurrentModeRgbColor(this.stateObj!);\n\n    if (name === \"wv\") {\n      const rgbw_color = rgb || [0, 0, 0, 0];\n      rgbw_color[3] = wv;\n      this.hass.callService(\"light\", \"turn_on\", {\n        entity_id: this.stateObj!.entity_id,\n        rgbw_color,\n      });\n      return;\n    }\n\n    const rgbww_color = rgb || [0, 0, 0, 0, 0];\n    while (rgbww_color.length < 5) {\n      rgbww_color.push(0);\n    }\n    rgbww_color[name === \"cw\" ? 3 : 4] = wv;\n    this.hass.callService(\"light\", \"turn_on\", {\n      entity_id: this.stateObj!.entity_id,\n      rgbww_color,\n    });\n  }\n\n  private _colorBrightnessSliderChanged(ev: CustomEvent) {\n    const target = ev.target as any;\n    let value = Number(target.value);\n\n    if (isNaN(value)) {\n      return;\n    }\n\n    const oldValue = this._colorBrightnessSliderValue;\n    this._colorBrightnessSliderValue = value;\n\n    value = (value * 255) / 100;\n\n    const rgb = (getLightCurrentModeRgbColor(this.stateObj!)?.slice(0, 3) || [\n      255, 255, 255,\n    ]) as [number, number, number];\n\n    this._setRgbWColor(\n      this._adjustColorBrightness(\n        // first normalize the value\n        oldValue\n          ? this._adjustColorBrightness(rgb, (oldValue * 255) / 100, true)\n          : rgb,\n        value\n      )\n    );\n  }\n\n  private _segmentClick() {\n    if (this._hueSegments === 24 && this._saturationSegments === 8) {\n      this._hueSegments = 0;\n      this._saturationSegments = 0;\n    } else {\n      this._hueSegments = 24;\n      this._saturationSegments = 8;\n    }\n  }\n\n  private _adjustColorBrightness(\n    rgbColor: [number, number, number],\n    value?: number,\n    invert = false\n  ) {\n    if (value !== undefined && value !== 255) {\n      let ratio = value / 255;\n      if (invert) {\n        ratio = 1 / ratio;\n      }\n      rgbColor[0] = Math.min(255, Math.round(rgbColor[0] * ratio));\n      rgbColor[1] = Math.min(255, Math.round(rgbColor[1] * ratio));\n      rgbColor[2] = Math.min(255, Math.round(rgbColor[2] * ratio));\n    }\n    return rgbColor;\n  }\n\n  private _setRgbWColor(rgbColor: [number, number, number]) {\n    if (lightSupportsColorMode(this.stateObj!, LightColorModes.RGBWW)) {\n      const rgbww_color: [number, number, number, number, number] = this\n        .stateObj!.attributes.rgbww_color\n        ? [...this.stateObj!.attributes.rgbww_color]\n        : [0, 0, 0, 0, 0];\n      this.hass.callService(\"light\", \"turn_on\", {\n        entity_id: this.stateObj!.entity_id,\n        rgbww_color: rgbColor.concat(rgbww_color.slice(3)),\n      });\n    } else if (lightSupportsColorMode(this.stateObj!, LightColorModes.RGBW)) {\n      const rgbw_color: [number, number, number, number] = this.stateObj!\n        .attributes.rgbw_color\n        ? [...this.stateObj!.attributes.rgbw_color]\n        : [0, 0, 0, 0];\n      this.hass.callService(\"light\", \"turn_on\", {\n        entity_id: this.stateObj!.entity_id,\n        rgbw_color: rgbColor.concat(rgbw_color.slice(3)),\n      });\n    }\n  }\n\n  /**\n   * Called when a new color has been picked.\n   * should be throttled with the 'throttle=' attribute of the color picker\n   */\n  private _colorPicked(\n    ev: CustomEvent<{\n      hs: { h: number; s: number };\n      rgb: { r: number; g: number; b: number };\n    }>\n  ) {\n    this._colorPickerColor = [\n      ev.detail.rgb.r,\n      ev.detail.rgb.g,\n      ev.detail.rgb.b,\n    ];\n\n    if (\n      lightSupportsColorMode(this.stateObj!, LightColorModes.RGBWW) ||\n      lightSupportsColorMode(this.stateObj!, LightColorModes.RGBW)\n    ) {\n      this._setRgbWColor(\n        this._colorBrightnessSliderValue\n          ? this._adjustColorBrightness(\n              [ev.detail.rgb.r, ev.detail.rgb.g, ev.detail.rgb.b],\n              (this._colorBrightnessSliderValue * 255) / 100\n            )\n          : [ev.detail.rgb.r, ev.detail.rgb.g, ev.detail.rgb.b]\n      );\n    } else if (lightSupportsColorMode(this.stateObj!, LightColorModes.RGB)) {\n      const rgb_color: [number, number, number] = [\n        ev.detail.rgb.r,\n        ev.detail.rgb.g,\n        ev.detail.rgb.b,\n      ];\n      if (this._brightnessAdjusted) {\n        this.hass.callService(\"light\", \"turn_on\", {\n          entity_id: this.stateObj!.entity_id,\n          brightness_pct: this._brightnessSliderValue,\n          rgb_color: this._adjustColorBrightness(\n            rgb_color,\n            this._brightnessAdjusted,\n            true\n          ),\n        });\n      } else {\n        this.hass.callService(\"light\", \"turn_on\", {\n          entity_id: this.stateObj!.entity_id,\n          rgb_color,\n        });\n      }\n    } else {\n      this.hass.callService(\"light\", \"turn_on\", {\n        entity_id: this.stateObj!.entity_id,\n        hs_color: [ev.detail.hs.h, ev.detail.hs.s * 100],\n      });\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      .content {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      }\n\n      .content > * {\n        width: 100%;\n      }\n\n      .color_temp {\n        --ha-slider-background: -webkit-linear-gradient(\n          right,\n          rgb(255, 160, 0) 0%,\n          white 50%,\n          rgb(166, 209, 255) 100%\n        );\n        /* The color temp minimum value shouldn't be rendered differently. It's not \"off\". */\n        --paper-slider-knob-start-border-color: var(--primary-color);\n        margin-bottom: 4px;\n      }\n\n      .segmentationContainer {\n        position: relative;\n        max-height: 500px;\n        display: flex;\n        justify-content: center;\n      }\n\n      ha-button-toggle-group {\n        margin-bottom: 8px;\n      }\n\n      ha-color-picker {\n        --ha-color-picker-wheel-borderwidth: 5;\n        --ha-color-picker-wheel-bordercolor: white;\n        --ha-color-picker-wheel-shadow: none;\n        --ha-color-picker-marker-borderwidth: 2;\n        --ha-color-picker-marker-bordercolor: white;\n      }\n\n      .segmentationButton {\n        position: absolute;\n        top: 5%;\n        left: 0;\n        color: var(--secondary-text-color);\n      }\n\n      paper-item {\n        cursor: pointer;\n      }\n\n      hr {\n        border-color: var(--divider-color);\n        border-bottom: none;\n        margin: 16px 0;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"more-info-light\": MoreInfoLight;\n  }\n}\n"],"names":[],"sourceRoot":""}