{"version":3,"file":"d4f713b2.js","mappings":";;AAsGA;AACA;AACA;AACA;AACA;AACA;;AAWA;AACA;AACA;AACA;AACA;AAIA;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;;AAOA;AAFA;;AAgDA;AACA;AACA;AACA;AACA;AAEA;;;AAOA;;;;AAKA;;;AAGA;;;;;;AC9KA;;;AAMA","sources":["webpack://home-assistant-frontend/slider-base.ts","webpack://home-assistant-frontend/slider-single-base.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\nimport '@material/mwc-ripple/mwc-ripple';\n\nimport {ariaProperty} from '@material/mwc-base/aria-property';\nimport {FormElement} from '@material/mwc-base/form-element';\nimport {Ripple} from '@material/mwc-ripple/mwc-ripple';\nimport {RippleHandlers} from '@material/mwc-ripple/ripple-handlers';\nimport {MDCSliderFoundation} from '@material/slider/foundation';\nimport {Thumb, TickMark} from '@material/slider/types';\nimport {html, nothing, PropertyValues, TemplateResult} from 'lit';\nimport {property, query, queryAsync, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {ifDefined} from 'lit/directives/if-defined.js';\nimport {styleMap} from 'lit/directives/style-map.js';\n\nexport {Thumb} from '@material/slider/types';\n\nexport class SliderBase extends FormElement {\n  protected mdcFoundation!: MDCSliderFoundation;\n  protected readonly mdcFoundationClass = MDCSliderFoundation;\n  @query('input.end') protected formElement!: HTMLInputElement;\n  @query('.mdc-slider') protected mdcRoot!: HTMLElement;\n  @query('.end.mdc-slider__thumb') protected endThumb!: HTMLElement;\n  @query('.end.mdc-slider__thumb .mdc-slider__thumb-knob')\n  protected endThumbKnob!: HTMLElement;\n  @queryAsync('.end .ripple') protected endRipple!: Promise<Ripple|null>;\n  @property({type: Boolean, reflect: true}) override disabled = false;\n  @property({type: Number}) min = 0;\n  @property({type: Number}) max = 100;\n  @property({type: Number}) valueEnd = 0;\n  @property({type: String}) name = '';\n  @property({type: Number}) step: number = 1;\n  @property({type: Boolean}) withTickMarks: boolean = false;\n  @property({type: Boolean}) discrete: boolean = false;\n  @state() protected tickMarks: TickMark[] = [];\n  @state() protected trackTransformOriginStyle: string = '';\n  @state() protected trackLeftStyle: string = '';\n  @state() protected trackRightStyle: string = '';\n  @state() protected trackTransitionStyle: string = '';\n  @state() protected endThumbWithIndicator = false;\n  @state() protected endThumbTop = false;\n  @state() protected shouldRenderEndRipple = false;\n  @state() protected endThumbTransformStyle: string = '';\n  @state() protected endThumbTransitionStyle: string = '';\n\n  /** @soyPrefixAttribute */\n  @ariaProperty\n  @property({type: String, attribute: 'aria-label'})\n  ariaLabel!: string;\n\n  /** @soyPrefixAttribute */\n  @ariaProperty\n  @property({type: String, attribute: 'aria-labelledby'})\n  ariaLabelledBy!: string;\n\n  /** @soyPrefixAttribute */\n  @ariaProperty\n  @property({type: String, attribute: 'aria-describedby'})\n  ariaDescribedBy!: string;\n\n  valueToAriaTextTransform: ((value: number) => string)|null = null;\n  valueToValueIndicatorTransform: ((value: number) => string) = (value) => {\n    return `${value}`;\n  };\n\n  private boundMoveListener:\n      ((event: PointerEvent|MouseEvent|TouchEvent) => void)|null = null;\n\n  protected endRippleHandlers = new RippleHandlers(() => {\n    this.shouldRenderEndRipple = true;\n    return this.endRipple;\n  });\n\n  override update(changed: PropertyValues) {\n    if (changed.has('valueEnd') && this.mdcFoundation) {\n      this.mdcFoundation.setValue(this.valueEnd);\n      const validVal = this.mdcFoundation.getValue();\n\n      if (validVal !== this.valueEnd) {\n        this.valueEnd = validVal;\n      }\n    }\n\n    if (changed.has('discrete')) {\n      if (!this.discrete) {\n        this.tickMarks = [];\n      }\n    }\n\n    super.update(changed);\n  }\n\n  protected override render() {\n    return this.renderRootEl(html`\n      ${this.renderStartInput()}\n      ${this.renderEndInput()}\n      ${this.renderTrack()}\n      ${this.renderTickMarks()}\n      ${this.renderStartThumb()}\n      ${this.renderEndThumb()}`);\n  }\n\n  protected renderRootEl(content: TemplateResult) {\n    const rootClasses = classMap({\n      'mdc-slider--disabled': this.disabled,\n      'mdc-slider--discrete': this.discrete,\n    });\n\n    return html`\n    <div\n        class=\"mdc-slider ${rootClasses}\"\n        @pointerdown=${this.onPointerdown}\n        @pointerup=${this.onPointerup}\n        @contextmenu=${this.onContextmenu}>\n      ${content}\n    </div>`;\n  }\n\n  protected renderStartInput(): typeof nothing|TemplateResult {\n    return nothing;\n  }\n\n  protected renderEndInput() {\n    return html`\n      <input\n          class=\"mdc-slider__input end\"\n          type=\"range\"\n          step=${this.step}\n          min=${this.min}\n          max=${this.max}\n          .value=${this.valueEnd as unknown as string}\n          @change=${this.onEndChange}\n          @focus=${this.onEndFocus}\n          @blur=${this.onEndBlur}\n          ?disabled=${this.disabled}\n          name=${this.name}\n          aria-label=${ifDefined(this.ariaLabel)}\n          aria-labelledby=${ifDefined(this.ariaLabelledBy)}\n          aria-describedby=${ifDefined(this.ariaDescribedBy)}\n          aria-valuetext=${\n        ifDefined(this.valueToAriaTextTransform?.(this.valueEnd))}>\n    `;\n  }\n\n  protected renderTrack(): typeof nothing|TemplateResult {\n    return nothing;\n  }\n\n  protected renderTickMarks() {\n    return !this.withTickMarks ? nothing : html`\n      <div class=\"mdc-slider__tick-marks\">\n        ${this.tickMarks.map((tickMark) => {\n      const isActive = tickMark === TickMark.ACTIVE;\n\n      return html`<div class=\"${\n          isActive ? 'mdc-slider__tick-mark--active' :\n                     'mdc-slider__tick-mark--inactive'}\"></div>`;\n    })}\n      </div>`;\n  }\n\n  protected renderStartThumb(): typeof nothing|TemplateResult {\n    return nothing;\n  }\n\n  protected renderEndThumb() {\n    const endThumbClasses = classMap({\n      'mdc-slider__thumb--with-indicator': this.endThumbWithIndicator,\n      'mdc-slider__thumb--top': this.endThumbTop,\n    });\n\n    const endThumbStyles = styleMap({\n      '-webkit-transform': this.endThumbTransformStyle,\n      'transform': this.endThumbTransformStyle,\n      '-webkit-transition': this.endThumbTransitionStyle,\n      'transition': this.endThumbTransitionStyle,\n      'left': this.endThumbTransformStyle ?\n          '' :\n          getComputedStyle(this).direction === 'rtl' ?\n          '' :\n          `calc(${\n              (this.valueEnd - this.min) / (this.max - this.min) *\n              100}% - 24px)`,\n      'right': this.endThumbTransformStyle ?\n          '' :\n          getComputedStyle(this).direction !== 'rtl' ?\n          '' :\n          `calc(${\n              (this.valueEnd - this.min) / (this.max - this.min) *\n              100}% - 24px)`,\n    });\n\n    const ripple = !this.shouldRenderEndRipple ?\n        nothing :\n        html`<mwc-ripple class=\"ripple\" unbounded></mwc-ripple>`;\n    return html`\n      <div\n          class=\"mdc-slider__thumb end ${endThumbClasses}\"\n          style=${endThumbStyles}\n          @mouseenter=${this.onEndMouseenter}\n          @mouseleave=${this.onEndMouseleave}>\n        ${ripple}\n        ${\n        this.renderValueIndicator(\n            this.valueToValueIndicatorTransform(this.valueEnd))}\n        <div class=\"mdc-slider__thumb-knob\"></div>\n      </div>\n    `;\n  }\n\n  protected renderValueIndicator(text: string|number|null) {\n    return this.discrete ? html`\n    <div class=\"mdc-slider__value-indicator-container\" aria-hidden=\"true\">\n      <div class=\"mdc-slider__value-indicator\">\n        <span class=\"mdc-slider__value-indicator-text\">\n          ${text}\n        </span>\n      </div>\n    </div>` :\n                           nothing;\n  }\n\n  override disconnectedCallback() {\n    super.disconnectedCallback();\n    if (this.mdcFoundation) {\n      this.mdcFoundation.destroy();\n    }\n  }\n\n  protected createAdapter() {}\n\n  override async firstUpdated() {\n    super.firstUpdated();\n    await this.layout(true);\n  }\n\n  override updated(changed: PropertyValues) {\n    super.updated(changed);\n\n    if (!this.mdcFoundation) {\n      return;\n    }\n\n    if (changed.has('disabled')) {\n      this.mdcFoundation.setDisabled(this.disabled);\n    }\n\n    if (changed.has('min')) {\n      this.mdcFoundation.setMin(this.min);\n    }\n\n    if (changed.has('max')) {\n      this.mdcFoundation.setMax(this.max);\n    }\n\n    if (changed.has('step')) {\n      this.mdcFoundation.setStep(this.step);\n    }\n\n    if (changed.has('discrete')) {\n      this.mdcFoundation.setIsDiscrete(this.discrete);\n    }\n\n    if (changed.has('withTickMarks')) {\n      this.mdcFoundation.setHasTickMarks(this.withTickMarks);\n    }\n  }\n\n  async layout(skipUpdateUI = false) {\n    this.mdcFoundation?.layout({skipUpdateUI});\n    this.requestUpdate();\n    await this.updateComplete;\n  }\n\n  protected onEndChange(e: Event) {\n    this.valueEnd = Number((e.target as HTMLInputElement).value);\n    this.mdcFoundation?.handleInputChange(Thumb.END);\n  }\n\n  protected onEndFocus() {\n    this.mdcFoundation?.handleInputFocus(Thumb.END);\n    this.endRippleHandlers.startFocus();\n  }\n\n  protected onEndBlur() {\n    this.mdcFoundation?.handleInputBlur(Thumb.END);\n    this.endRippleHandlers.endFocus();\n  }\n\n  protected onEndMouseenter() {\n    this.mdcFoundation?.handleThumbMouseenter();\n    this.endRippleHandlers.startHover();\n  }\n\n  protected onEndMouseleave() {\n    this.mdcFoundation?.handleThumbMouseleave();\n    this.endRippleHandlers.endHover();\n  }\n\n  protected onPointerdown(e: PointerEvent) {\n    this.layout();\n\n    if (this.mdcFoundation) {\n      this.mdcFoundation.handlePointerdown(e);\n      this.boundMoveListener =\n          this.mdcFoundation.handleMove.bind(this.mdcFoundation);\n      this.mdcRoot.addEventListener('pointermove', this.boundMoveListener);\n    }\n  }\n\n  protected onPointerup() {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.handleUp();\n      if (this.boundMoveListener) {\n        this.mdcRoot.removeEventListener('pointermove', this.boundMoveListener);\n        this.boundMoveListener = null;\n      }\n    }\n  }\n\n  protected onContextmenu(e: Event) {\n    // prevents context menu otherwise pointerdown will fire but not pointerup\n    e.preventDefault();\n  }\n\n  protected setFormData(formData: FormData) {\n    if (this.name) {\n      formData.append(this.name, `${this.valueEnd}`);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\nimport '@material/mwc-ripple/mwc-ripple';\n\nimport {deepActiveElementPath} from '@material/mwc-base/utils';\nimport {MDCSliderAdapter} from '@material/slider/adapter';\nimport {Thumb, TickMark} from '@material/slider/types';\nimport {html} from 'lit';\nimport {property} from 'lit/decorators.js';\nimport {styleMap} from 'lit/directives/style-map.js';\n\nimport {SliderBase} from './slider-base';\n\nexport {Thumb} from '@material/slider/types';\n\n\nexport class SliderSingleBase extends SliderBase {\n  @property({type: Number})\n  get value(): number {\n    return this.valueEnd;\n  }\n\n  set value(newVal: number) {\n    this.valueEnd = newVal;\n  }\n\n  protected override renderTrack() {\n    const trackStyles = styleMap({\n      'transform-origin': this.trackTransformOriginStyle,\n      'left': this.trackLeftStyle,\n      'right': this.trackRightStyle,\n      '-webkit-transform':\n          `scaleX(${(this.valueEnd - this.min) / (this.max - this.min)})`,\n      'transform':\n          `scaleX(${(this.valueEnd - this.min) / (this.max - this.min)})`,\n      '-webkit-transition': this.trackTransitionStyle,\n      'transition': this.trackTransitionStyle,\n    });\n\n    return html`\n      <div class=\"mdc-slider__track\">\n        <div class=\"mdc-slider__track--inactive\"></div>\n        <div class=\"mdc-slider__track--active\">\n          <div\n              class=\"mdc-slider__track--active_fill\"\n              style=${trackStyles}>\n          </div>\n        </div>\n      </div>`;\n  }\n\n  protected override createAdapter(): MDCSliderAdapter {\n    return {\n      addClass: (className) => {\n        switch (className) {\n          case 'mdc-slider--disabled':\n            this.disabled = true;\n            break;\n        }\n      },\n      removeClass: (className) => {\n        switch (className) {\n          case 'mdc-slider--disabled':\n            this.disabled = false;\n            break;\n        }\n      },\n      hasClass: (className) => {\n        switch (className) {\n          case 'mdc-slider--disabled':\n            return this.disabled;\n          case 'mdc-slider--discrete':\n            return this.discrete;\n          default:\n            return false;\n        }\n      },\n      addThumbClass: (className, thumb) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n\n        switch (className) {\n          case 'mdc-slider__thumb--with-indicator':\n            this.endThumbWithIndicator = true;\n            break;\n        }\n      },\n      removeThumbClass: (className, thumb) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n\n        switch (className) {\n          case 'mdc-slider__thumb--with-indicator':\n            this.endThumbWithIndicator = false;\n            break;\n        }\n      },\n      registerEventHandler: () => {\n        // handled in bindings\n      },\n      deregisterEventHandler: () => {\n        // handled in bindings\n      },\n      registerBodyEventHandler: (eventName, handler) => {\n        document.body.addEventListener(eventName, handler);\n      },\n      deregisterBodyEventHandler: (eventName, handler) => {\n        document.body.removeEventListener(eventName, handler);\n      },\n      registerInputEventHandler: (thumb, eventName, handler) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n\n        this.formElement.addEventListener(eventName, handler);\n      },\n      deregisterInputEventHandler: (thumb, eventName, handler) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n\n        this.formElement.removeEventListener(eventName, handler);\n      },\n      registerThumbEventHandler: () => {\n        // handled by bindings\n      },\n      deregisterThumbEventHandler: () => {\n        // handled by bindings\n      },\n      registerWindowEventHandler: (eventName, handler) => {\n        window.addEventListener(eventName, handler);\n      },\n      deregisterWindowEventHandler: (eventName, handler) => {\n        window.addEventListener(eventName, handler);\n      },\n      emitChangeEvent: (value, thumb) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n\n        const event = new CustomEvent(\n            'change', {bubbles: true, composed: true, detail: {value, thumb}});\n        this.dispatchEvent(event)\n      },\n      emitDragEndEvent: (_value, thumb) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n        // Emitting event is not yet implemented. See issue:\n        // https://github.com/material-components/material-components-web/issues/6448\n\n        this.endRippleHandlers.endPress();\n      },\n      emitDragStartEvent: (_value, thumb) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n        // Emitting event is not yet implemented. See issue:\n        // https://github.com/material-components/material-components-web/issues/6448\n\n        this.endRippleHandlers.startPress();\n      },\n      emitInputEvent: (value, thumb) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n\n        const event = new CustomEvent(\n            'input', {bubbles: true, composed: true, detail: {value, thumb}});\n        this.dispatchEvent(event)\n      },\n      focusInput: (thumb) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n\n        this.formElement.focus();\n      },\n      getAttribute: () => {\n        // never seems to actually be used\n        return '';\n      },\n      getBoundingClientRect: () => {\n        return this.mdcRoot.getBoundingClientRect();\n      },\n      getInputAttribute: (attrName, thumb) => {\n        if (thumb === Thumb.START) {\n          return null;\n        }\n\n        switch (attrName) {\n          case 'min':\n            return this.min.toString();\n          case 'max':\n            return this.max.toString();\n          case 'value':\n            return this.valueEnd.toString();\n          case 'step':\n            return this.step.toString();\n          default:\n            return null;\n        }\n      },\n      getInputValue: (thumb) => {\n        if (thumb === Thumb.START) {\n          return '';\n        }\n\n        return this.valueEnd.toString();\n      },\n      getThumbBoundingClientRect: (thumb) => {\n        if (thumb === Thumb.START) {\n          return this.getBoundingClientRect();\n        }\n\n        return this.endThumb.getBoundingClientRect();\n      },\n      getThumbKnobWidth: (thumb) => {\n        if (thumb === Thumb.START) {\n          return 0;\n        }\n\n        return this.endThumbKnob.getBoundingClientRect().width;\n      },\n      getValueToAriaValueTextFn: () => {\n        return this.valueToAriaTextTransform\n      },\n      isInputFocused: (thumb) => {\n        if (thumb === Thumb.START) {\n          return false;\n        }\n\n        const activeElements = deepActiveElementPath();\n        return activeElements[activeElements.length - 1] === this.formElement;\n      },\n      isRTL: () => {\n        return getComputedStyle(this).direction === 'rtl';\n      },\n      setInputAttribute: (attribute, _value, thumb) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n\n        switch (attribute) {\n          case 'disabled':\n          case 'value':\n          case 'aria-valuetext':\n            // handled by bindings\n            break;\n        }\n      },\n      removeInputAttribute: (attribute) => {\n        switch (attribute) {\n          case 'disabled':\n            // handled by bindings\n            break;\n        }\n      },\n      setThumbStyleProperty: (name, value, thumb) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n\n        switch (name) {\n          case 'transform':\n          case '-webkit-transform':\n            this.endThumbTransformStyle = value;\n            break;\n          case 'transition':\n          case '-webkit-transition':\n            this.endThumbTransitionStyle = value;\n            break;\n        }\n      },\n      removeThumbStyleProperty: (name, thumb) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n\n        switch (name) {\n          case 'left':\n          case 'right':\n            // handled by bindings\n            break;\n          case 'transition':\n          case '-webkit-transition':\n            this.endThumbTransitionStyle = '';\n            break;\n        }\n      },\n      setTrackActiveStyleProperty: (name, value) => {\n        switch (name) {\n          case 'transform-origin':\n            this.trackTransformOriginStyle = value;\n            break;\n          case 'left':\n            this.trackLeftStyle = value;\n            break;\n          case 'right':\n            this.trackRightStyle = value;\n            break;\n          case 'transform':\n          case '-webkit-transform':\n            // handled by bindings\n            break;\n          case 'transition':\n          case '-webkit-transition':\n            this.trackTransitionStyle = value;\n            break;\n        }\n      },\n      removeTrackActiveStyleProperty: (name) => {\n        switch (name) {\n          case 'transition':\n          case '-webkit-transition':\n            this.trackTransitionStyle = '';\n            break;\n        }\n      },\n      setInputValue: (value, thumb) => {\n        if (thumb === Thumb.START) {\n          return;\n        }\n\n        this.valueEnd = Number(value);\n      },\n      setPointerCapture: (pointerId) => {\n        this.mdcRoot.setPointerCapture(pointerId);\n      },\n      setValueIndicatorText: () => {\n        // handled by bindings\n      },\n      updateTickMarks: (tickMarks: TickMark[]) => {\n        this.tickMarks = tickMarks;\n      },\n    };\n  }\n}\n"],"names":[],"sourceRoot":""}