{"version":3,"file":"3b397285.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoGA;AChEA;;;AAJA;;;;AAXA;ACsEA;;AAIA;;AAGA;;AAIA;AACA;;;;AAMA;AAlEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA","sources":["webpack://home-assistant-frontend/./src/layouts/ha-app-layout.js","webpack://home-assistant-frontend/./src/panels/lovelace/badges/hui-error-badge.ts","webpack://home-assistant-frontend/./src/panels/lovelace/views/hui-masonry-view.ts"],"sourcesContent":["/* eslint-plugin-disable lit */\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\nThis code is copied from app-header-layout.\n'fullbleed' support is removed as Home Assisstant doesn't use it.\ntransform: translate(0) is added.\n*/\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\nimport \"@polymer/app-layout/app-header-layout/app-header-layout\";\nimport { html } from \"@polymer/polymer/lib/utils/html-tag\";\nimport \"@polymer/polymer/polymer-element\";\n\nclass HaAppLayout extends customElements.get(\"app-header-layout\") {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: block;\n          /**\n         * Force app-header-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements (e.g. app-drawer-layout).\n         * This could be done using \\`isolation: isolate\\`, but that's not well supported\n         * across browsers.\n         */\n          position: relative;\n          z-index: 0;\n        }\n\n        #wrapper ::slotted([slot=\"header\"]) {\n          @apply --layout-fixed-top;\n          z-index: 1;\n        }\n\n        #wrapper.initializing ::slotted([slot=\"header\"]) {\n          position: relative;\n        }\n\n        :host([has-scrolling-region]) {\n          height: 100%;\n        }\n\n        :host([has-scrolling-region]) #wrapper ::slotted([slot=\"header\"]) {\n          position: absolute;\n        }\n\n        :host([has-scrolling-region])\n          #wrapper.initializing\n          ::slotted([slot=\"header\"]) {\n          position: relative;\n        }\n\n        :host([has-scrolling-region]) #wrapper #contentContainer {\n          @apply --layout-fit;\n          overflow-y: auto;\n          -webkit-overflow-scrolling: touch;\n        }\n\n        :host([has-scrolling-region]) #wrapper.initializing #contentContainer {\n          position: relative;\n        }\n\n        #contentContainer {\n          /* Create a stacking context here so that all children appear below the header. */\n          position: relative;\n          z-index: 0;\n          /* Using 'transform' will cause 'position: fixed' elements to behave like\n           'position: absolute' relative to this element. */\n          transform: translate(0);\n          margin-left: env(safe-area-inset-left);\n          margin-right: env(safe-area-inset-right);\n        }\n\n        @media print {\n          :host([has-scrolling-region]) #wrapper #contentContainer {\n            overflow-y: visible;\n          }\n        }\n      </style>\n\n      <div id=\"wrapper\" class=\"initializing\">\n        <slot id=\"headerSlot\" name=\"header\"></slot>\n\n        <div id=\"contentContainer\"><slot></slot></div>\n        <slot id=\"fab\" name=\"fab\"></slot>\n      </div>\n    `;\n  }\n}\ncustomElements.define(\"ha-app-layout\", HaAppLayout);\n","import { mdiAlert } from \"@mdi/js\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, state } from \"lit/decorators\";\nimport \"../../../components/ha-label-badge\";\nimport \"../../../components/ha-svg-icon\";\nimport { HomeAssistant } from \"../../../types\";\nimport { LovelaceBadge } from \"../types\";\nimport { ErrorBadgeConfig } from \"./types\";\n\nexport const createErrorBadgeElement = (config) => {\n  const el = document.createElement(\"hui-error-badge\");\n  el.setConfig(config);\n  return el;\n};\n\nexport const createErrorBadgeConfig = (error) => ({\n  type: \"error\",\n  error,\n});\n\n@customElement(\"hui-error-badge\")\nexport class HuiErrorBadge extends LitElement implements LovelaceBadge {\n  public hass?: HomeAssistant;\n\n  @state() private _config?: ErrorBadgeConfig;\n\n  public setConfig(config: ErrorBadgeConfig): void {\n    this._config = config;\n  }\n\n  protected render(): TemplateResult {\n    if (!this._config) {\n      return html``;\n    }\n\n    return html`\n      <ha-label-badge label=\"Error\" description=${this._config.error}>\n        <ha-svg-icon .path=${mdiAlert}></ha-svg-icon>\n      </ha-label-badge>\n    `;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        --ha-label-badge-color: var(--label-badge-red, #fce588);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-error-badge\": HuiErrorBadge;\n  }\n}\n","import { mdiPlus } from \"@mdi/js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { fireEvent } from \"../../../common/dom/fire_event\";\nimport { computeRTL } from \"../../../common/util/compute_rtl\";\nimport { nextRender } from \"../../../common/util/render-status\";\nimport \"../../../components/entity/ha-state-label-badge\";\nimport \"../../../components/ha-svg-icon\";\nimport type {\n  LovelaceViewConfig,\n  LovelaceViewElement,\n} from \"../../../data/lovelace\";\nimport type { HomeAssistant } from \"../../../types\";\nimport type { HuiErrorCard } from \"../cards/hui-error-card\";\nimport { computeCardSize } from \"../common/compute-card-size\";\nimport type { Lovelace, LovelaceBadge, LovelaceCard } from \"../types\";\n\n// Find column with < 5 size, else smallest column\nconst getColumnIndex = (columnSizes: number[], size: number) => {\n  let minIndex = 0;\n  for (let i = 0; i < columnSizes.length; i++) {\n    if (columnSizes[i] < 5) {\n      minIndex = i;\n      break;\n    }\n    if (columnSizes[i] < columnSizes[minIndex]) {\n      minIndex = i;\n    }\n  }\n\n  columnSizes[minIndex] += size;\n\n  return minIndex;\n};\n\nexport class MasonryView extends LitElement implements LovelaceViewElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public lovelace?: Lovelace;\n\n  @property({ type: Boolean }) public narrow!: boolean;\n\n  @property({ type: Number }) public index?: number;\n\n  @property({ type: Boolean }) public isStrategy = false;\n\n  @property({ attribute: false }) public cards: Array<\n    LovelaceCard | HuiErrorCard\n  > = [];\n\n  @property({ attribute: false }) public badges: LovelaceBadge[] = [];\n\n  @state() private _columns?: number;\n\n  private _createColumnsIteration = 0;\n\n  private _mqls?: MediaQueryList[];\n\n  private _mqlListenerRef?: () => void;\n\n  public constructor() {\n    super();\n    this.addEventListener(\"iron-resize\", (ev: Event) => ev.stopPropagation());\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    this._initMqls();\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    this._mqls?.forEach((mql) => {\n      mql.removeListener(this._mqlListenerRef!);\n    });\n    this._mqlListenerRef = undefined;\n    this._mqls = undefined;\n  }\n\n  public setConfig(_config: LovelaceViewConfig): void {}\n\n  protected render(): TemplateResult {\n    return html`\n      ${this.badges.length > 0\n        ? html` <div class=\"badges\">${this.badges}</div>`\n        : \"\"}\n      <div id=\"columns\"></div>\n      ${this.lovelace?.editMode\n        ? html`\n            <ha-fab\n              .label=${this.hass!.localize(\n                \"ui.panel.lovelace.editor.edit_card.add\"\n              )}\n              extended\n              @click=${this._addCard}\n              class=${classMap({\n                rtl: computeRTL(this.hass!),\n              })}\n            >\n              <ha-svg-icon slot=\"icon\" .path=${mdiPlus}></ha-svg-icon>\n            </ha-fab>\n          `\n        : \"\"}\n    `;\n  }\n\n  private _initMqls() {\n    this._mqls = [300, 600, 900, 1200].map((width) => {\n      const mql = window.matchMedia(`(min-width: ${width}px)`);\n      if (!this._mqlListenerRef) {\n        this._mqlListenerRef = this._updateColumns.bind(this);\n      }\n      mql.addListener(this._mqlListenerRef);\n      return mql;\n    });\n  }\n\n  private get mqls(): MediaQueryList[] {\n    if (!this._mqls) {\n      this._initMqls();\n    }\n    return this._mqls!;\n  }\n\n  public willUpdate(changedProperties: PropertyValues) {\n    super.willUpdate(changedProperties);\n\n    if (this.lovelace?.editMode) {\n      import(\"./default-view-editable\");\n    }\n\n    if (changedProperties.has(\"hass\")) {\n      const oldHass = changedProperties.get(\"hass\") as\n        | HomeAssistant\n        | undefined;\n\n      if (this.hass!.dockedSidebar !== oldHass?.dockedSidebar) {\n        this._updateColumns();\n        return;\n      }\n    }\n\n    if (changedProperties.has(\"narrow\")) {\n      this._updateColumns();\n      return;\n    }\n\n    const oldLovelace = changedProperties.get(\"lovelace\") as\n      | Lovelace\n      | undefined;\n\n    if (\n      changedProperties.has(\"cards\") ||\n      (changedProperties.has(\"lovelace\") &&\n        oldLovelace &&\n        (oldLovelace.config !== this.lovelace!.config ||\n          oldLovelace.editMode !== this.lovelace!.editMode))\n    ) {\n      this._createColumns();\n    }\n  }\n\n  private _addCard(): void {\n    fireEvent(this, \"ll-create-card\");\n  }\n\n  private _createRootElement(columns: HTMLDivElement[]) {\n    const root = this.shadowRoot!.getElementById(\"columns\") as HTMLDivElement;\n\n    // Remove old columns\n    while (root.lastChild) {\n      root.removeChild(root.lastChild);\n    }\n\n    columns.forEach((column) => root.appendChild(column));\n  }\n\n  private async _createColumns() {\n    if (!this._columns) {\n      return;\n    }\n\n    this._createColumnsIteration++;\n    const iteration = this._createColumnsIteration;\n\n    // Track the total height of cards in a columns\n    const columnSizes: number[] = [];\n    const columnElements: HTMLDivElement[] = [];\n    // Add columns to DOM, limit number of columns to the number of cards\n    for (let i = 0; i < Math.min(this._columns, this.cards.length); i++) {\n      const columnEl = document.createElement(\"div\");\n      columnEl.classList.add(\"column\");\n      columnSizes.push(0);\n      columnElements.push(columnEl);\n    }\n\n    if (!this.hasUpdated) {\n      this.updateComplete.then(() => {\n        this._createRootElement(columnElements);\n      });\n    } else {\n      this._createRootElement(columnElements);\n    }\n\n    let tillNextRender: Promise<unknown> | undefined;\n    let start: Date | undefined;\n\n    // Calculate the size of every card and determine in what column it should go\n    for (const [index, el] of this.cards.entries()) {\n      if (tillNextRender === undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-loop-func\n        tillNextRender = nextRender().then(() => {\n          tillNextRender = undefined;\n          start = undefined;\n        });\n      }\n\n      let waitProm: Promise<unknown> | undefined;\n\n      // We should work for max 16ms (60fps) before allowing a frame to render\n      if (start === undefined) {\n        // Save the time we start for this frame, no need to wait yet\n        start = new Date();\n      } else if (new Date().getTime() - start.getTime() > 16) {\n        // We are working too long, we will prevent a render, wait to allow for a render\n        waitProm = tillNextRender;\n      }\n\n      const cardSizeProm = computeCardSize(el);\n      // @ts-ignore\n      // eslint-disable-next-line no-await-in-loop\n      const [cardSize] = await Promise.all([cardSizeProm, waitProm]);\n\n      if (iteration !== this._createColumnsIteration) {\n        // An other create columns is started, abort this one\n        return;\n      }\n      // Calculate in wich column the card should go based on the size and the cards already in there\n      this._addCardToColumn(\n        columnElements[getColumnIndex(columnSizes, cardSize as number)],\n        index,\n        this.lovelace!.editMode\n      );\n    }\n\n    // Remove empty columns\n    columnElements.forEach((column) => {\n      if (!column.lastChild) {\n        column.parentElement!.removeChild(column);\n      }\n    });\n  }\n\n  private _addCardToColumn(columnEl, index, editMode) {\n    const card: LovelaceCard = this.cards[index];\n    if (!editMode || this.isStrategy) {\n      card.editMode = false;\n      columnEl.appendChild(card);\n    } else {\n      const wrapper = document.createElement(\"hui-card-options\");\n      wrapper.hass = this.hass;\n      wrapper.lovelace = this.lovelace;\n      wrapper.path = [this.index!, index];\n      card.editMode = true;\n      wrapper.appendChild(card);\n      columnEl.appendChild(wrapper);\n    }\n  }\n\n  private _updateColumns() {\n    const matchColumns = this.mqls.reduce(\n      (cols, mql) => cols + Number(mql.matches),\n      0\n    );\n    // Do -1 column if the menu is docked and open\n    const newColumns = Math.max(\n      1,\n      matchColumns -\n        Number(!this.narrow && this.hass!.dockedSidebar === \"docked\")\n    );\n    if (newColumns === this._columns) {\n      return;\n    }\n    this._columns = newColumns;\n    this._createColumns();\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        padding-top: 4px;\n        height: 100%;\n        box-sizing: border-box;\n      }\n\n      .badges {\n        margin: 8px 16px;\n        font-size: 85%;\n        text-align: center;\n      }\n\n      #columns {\n        display: flex;\n        flex-direction: row;\n        justify-content: center;\n        margin-left: 4px;\n        margin-right: 4px;\n      }\n\n      .column {\n        flex: 1 0 0;\n        max-width: 500px;\n        min-width: 0;\n      }\n\n      .column > * {\n        display: block;\n        margin: var(--masonry-view-card-margin, 4px 4px 8px);\n      }\n\n      ha-fab {\n        position: sticky;\n        float: right;\n        right: calc(16px + env(safe-area-inset-right));\n        bottom: calc(16px + env(safe-area-inset-bottom));\n        z-index: 1;\n      }\n\n      ha-fab.rtl {\n        float: left;\n        right: auto;\n        left: calc(16px + env(safe-area-inset-left));\n      }\n\n      @media (max-width: 500px) {\n        .column > * {\n          margin-left: 0;\n          margin-right: 0;\n        }\n      }\n\n      @media (max-width: 599px) {\n        .column {\n          max-width: 600px;\n        }\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-masonry-view\": MasonryView;\n  }\n}\n\ncustomElements.define(\"hui-masonry-view\", MasonryView);\n"],"names":[],"sourceRoot":""}