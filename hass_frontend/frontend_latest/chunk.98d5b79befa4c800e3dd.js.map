{"version":3,"sources":["webpack:///./src/panels/lovelace/common/structs/struct.ts","webpack:///./src/panels/lovelace/common/structs/is-entity-id.ts","webpack:///./src/panels/lovelace/common/structs/is-icon.ts","webpack:///./node_modules/superstruct/lib/index.es.js","webpack:///./src/panels/lovelace/editor/config-elements/hui-shopping-list-editor.ts"],"names":["__webpack_require__","d","__webpack_exports__","struct","Object","index_es","types","entity-id","value","includes","icon","superstruct","StructError","TypeError","[object Object]","attrs","type","path","length","join","JSON","stringify","super","format","data","reason","errors","this","push","Error","captureStackTrace","constructor","stack","toString","prototype","kindOf","val","ctorName","Array","isArray","isBuffer","callee","err","message","indexOf","isArguments","Date","toDateString","getDate","setDate","isDate","stackTraceLimit","isError","RegExp","flags","ignoreCase","multiline","global","isRegexp","throw","return","next","isGeneratorObj","call","slice","toLowerCase","replace","name","IS_STRUCT","KIND","isStruct","resolveDefaults","defaults","_extends","assign","target","i","arguments","source","key","hasOwnProperty","Kind","validate","any","schema","defaults$$1","options","tuple","list","func","object","required","endsWith","union","split","intersection","scalar","optional","undefined","en","map","s","e","String","result","isValid","failure","array","element","error","ret","v","r","forEach","singleE","concat","first","obj","ks","properties","kind","valueKeys","keys","propertiesKeys","Set","fn","kinds","k","Math","max","t","Kinds","dict","values","resolved","e2","r2","enum","enums","function","instance","interface","lazy","literal","partial","dynamic","createSchema","Types","config","Struct","assert","defineProperty","test","date","isNaN","cardConfigStruct","_common_structs_struct__WEBPACK_IMPORTED_MODULE_3__","title","HuiShoppingListEditor","lit_element__WEBPACK_IMPORTED_MODULE_1__","_config","_title","hass","_valueChanged","ev","configValue","_common_dom_fire_event__WEBPACK_IMPORTED_MODULE_4__","tslib__WEBPACK_IMPORTED_MODULE_0__"],"mappings":"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","file":"chunk.98d5b79befa4c800e3dd.js","sourcesContent":["import { superstruct } from \"superstruct\";\nimport { isEntityId } from \"./is-entity-id\";\nimport { isIcon } from \"./is-icon\";\n\nexport const struct = superstruct({\n  types: {\n    \"entity-id\": isEntityId,\n    icon: isIcon,\n  },\n});\n","export function isEntityId(value: any): string | boolean {\n  if (typeof value !== \"string\") {\n    return \"entity id should be a string\";\n  }\n  if (!value.includes(\".\")) {\n    return \"entity id should be in the format 'domain.entity'\";\n  }\n  return true;\n}\n","export function isIcon(value: any): string | boolean {\n  if (typeof value !== \"string\") {\n    return \"icon should be a string\";\n  }\n  if (!value.includes(\":\")) {\n    return \"icon should be in the format 'mdi:icon'\";\n  }\n  return true;\n}\n","/**\n * Define a struct error.\n *\n * @type {StructError}\n */\n\nclass StructError extends TypeError {\n  static format(attrs) {\n    const { type, path, value } = attrs;\n    const message = `Expected a value of type \\`${type}\\`${path.length ? ` for \\`${path.join('.')}\\`` : ''} but received \\`${JSON.stringify(value)}\\`.`;\n    return message;\n  }\n\n  constructor(attrs) {\n    const message = StructError.format(attrs);\n    super(message);\n\n    const { data, path, value, reason, type, errors = [] } = attrs;\n    this.data = data;\n    this.path = path;\n    this.value = value;\n    this.reason = reason;\n    this.type = type;\n    this.errors = errors;\n\n    if (!errors.length) {\n      errors.push(this);\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error().stack;\n    }\n  }\n}\n\nvar toString = Object.prototype.toString;\n\nvar kindOf = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n\n/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\nconst IS_STRUCT = '@@__STRUCT__@@';\n\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nconst KIND = '@@__KIND__@@';\n\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nfunction isStruct(value) {\n  return !!(value && value[IS_STRUCT]);\n}\n\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\nfunction resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults;\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\nclass Kind {\n  constructor(name, type, validate) {\n    this.name = name;\n    this.type = type;\n    this.validate = validate;\n  }\n}\n\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction any(schema, defaults$$1, options) {\n  if (isStruct(schema)) {\n    return schema[KIND];\n  }\n\n  if (schema instanceof Kind) {\n    return schema;\n  }\n\n  switch (kindOf(schema)) {\n    case 'array':\n      {\n        return schema.length > 1 ? tuple(schema, defaults$$1, options) : list(schema, defaults$$1, options);\n      }\n\n    case 'function':\n      {\n        return func(schema, defaults$$1, options);\n      }\n\n    case 'object':\n      {\n        return object(schema, defaults$$1, options);\n      }\n\n    case 'string':\n      {\n        let required = true;\n        let type;\n\n        if (schema.endsWith('?')) {\n          required = false;\n          schema = schema.slice(0, -1);\n        }\n\n        if (schema.includes('|')) {\n          const scalars = schema.split(/\\s*\\|\\s*/g);\n          type = union(scalars, defaults$$1, options);\n        } else if (schema.includes('&')) {\n          const scalars = schema.split(/\\s*&\\s*/g);\n          type = intersection(scalars, defaults$$1, options);\n        } else {\n          type = scalar(schema, defaults$$1, options);\n        }\n\n        if (!required) {\n          type = optional(type, undefined, options);\n        }\n\n        return type;\n      }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(`A schema definition must be an object, array, string or function, but you passed: ${schema}`);\n  } else {\n    throw new Error(`Invalid schema: ${schema}`);\n  }\n}\n\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction dict(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Dict structs must be defined as an array with two elements, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const keys = any(schema[0], undefined, options);\n  const values = any(schema[1], undefined, options);\n  const name = 'dict';\n  const type = `dict<${keys.type},${values.type}>`;\n  const validate = value => {\n    const resolved = resolveDefaults(defaults$$1);\n    value = resolved ? _extends({}, resolved, value) : value;\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const ret = {};\n    const errors = [];\n\n    for (let k in value) {\n      const v = value[k];\n      const [e, r] = keys.validate(k);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      k = r;\n      const [e2, r2] = values.validate(v);\n\n      if (e2) {\n        const allE2 = e2.errors || [e2];\n        allE2.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      ret[k] = r2;\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction en(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Enum structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const name = 'enum';\n  const type = schema.map(s => {\n    try {\n      return JSON.stringify(s);\n    } catch (e) {\n      return String(s);\n    }\n  }).join(' | ');\n\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    return schema.includes(value) ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction enums(schema, defaults$$1, options) {\n  const e = en(schema, undefined, options);\n  const l = list([e], defaults$$1, options);\n  return l;\n}\n\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction func(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Function structs must be defined as a function, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const name = 'function';\n  const type = '<function>';\n  const validate = (value = resolveDefaults(defaults$$1), data) => {\n    const result = schema(value, data);\n    let failure = { path: [], reason: null };\n    let isValid;\n\n    switch (kindOf(result)) {\n      case 'boolean':\n        {\n          isValid = result;\n          break;\n        }\n      case 'string':\n        {\n          isValid = false;\n          failure.reason = result;\n          break;\n        }\n      case 'object':\n        {\n          isValid = false;\n          failure = _extends({}, failure, result);\n          break;\n        }\n      default:\n        {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`);\n          } else {\n            throw new Error(`Invalid result: ${result}`);\n          }\n        }\n    }\n\n    return isValid ? [undefined, value] : [_extends({ type, value, data: value }, failure)];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction instance(schema, defaults$$1, options) {\n  const name = 'instance';\n  const type = `instance<${schema.name}>`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    return value instanceof schema ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction inter(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Interface structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'interface';\n  const type = `{${ks.join()}}`;\n  const validate = value => {\n    const resolved = resolveDefaults(defaults$$1);\n    value = resolved ? _extends({}, resolved, value) : value;\n    const errors = [];\n    const ret = value;\n\n    for (const key in properties) {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      const [e, r] = kind.validate(v, value);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction lazy(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  let kind;\n  let struct;\n  const name = 'lazy';\n  const type = `lazy...`;\n  const compile = value => {\n    struct = schema();\n    kind.name = struct.kind;\n    kind.type = struct.type;\n    kind.validate = struct.validate;\n    return kind.validate(value);\n  };\n\n  kind = new Kind(name, type, compile);\n  return kind;\n}\n\n/**\n * Dynamic.\n *\n * @param {Function} createSchema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction dynamic(createSchema, defaults$$1, options) {\n  if (kindOf(createSchema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Dynamic structs must be defined as a function, but you passed: ${createSchema}`);\n    } else {\n      throw new Error(`Invalid schema: ${createSchema}`);\n    }\n  }\n\n  const name = 'dynamic';\n  const type = 'dynamic...';\n  const validate = (value = resolveDefaults(defaults$$1), data) => {\n    const schema = createSchema(value, data);\n\n    if (kindOf(schema) !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(`Dynamic structs must return a schema, but you passed: ${schema}`);\n      } else {\n        throw new Error(`Invalid schema: ${schema}`);\n      }\n    }\n\n    const [error, result] = schema.validate(value);\n\n    if (error) {\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction list(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`List structs must be defined as an array with a single element, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const array = scalar('array', undefined, options);\n  const element = any(schema[0], undefined, options);\n  const name = 'list';\n  const type = `[${element.type}]`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error, result] = array.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    value = result;\n    const errors = [];\n    const ret = [];\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i];\n      const [e, r] = element.validate(v);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      ret[i] = r;\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction literal(schema, defaults$$1, options) {\n  const name = 'literal';\n  const type = `literal: ${JSON.stringify(schema)}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    return value === schema ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction object(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Object structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'object';\n  const type = `{${ks.join()}}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const errors = [];\n    const ret = {};\n    const valueKeys = Object.keys(value);\n    const propertiesKeys = Object.keys(properties);\n    const keys = new Set(valueKeys.concat(propertiesKeys));\n\n    keys.forEach(key => {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      if (!kind) {\n        const e = { data: value, path: [key], value: v };\n        errors.push(e);\n        return;\n      }\n\n      const [e, r] = kind.validate(v, value);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    });\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction optional(schema, defaults$$1, options) {\n  return union([schema, 'undefined'], defaults$$1, options);\n}\n\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction partial(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Partial structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'partial';\n  const type = `{${ks.join()},...}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const errors = [];\n    const ret = {};\n\n    for (const key in properties) {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      const [e, r] = kind.validate(v, value);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction scalar(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'string') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Scalar structs must be defined as a string, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const { types } = options;\n  const fn = types[schema];\n\n  if (kindOf(fn) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`No struct validator function found for type \"${schema}\".`);\n    } else {\n      throw new Error(`Invalid type: ${schema}`);\n    }\n  }\n\n  const kind = func(fn, defaults$$1, options);\n  const name = 'scalar';\n  const type = schema;\n  const validate = value => {\n    const [error, result] = kind.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction tuple(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Tuple structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options));\n  const array = scalar('array', undefined, options);\n  const name = 'tuple';\n  const type = `[${kinds.map(k => k.type).join()}]`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = array.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const ret = [];\n    const errors = [];\n    const length = Math.max(value.length, kinds.length);\n\n    for (let i = 0; i < length; i++) {\n      const kind = kinds[i];\n      const v = value[i];\n\n      if (!kind) {\n        const e = { data: value, path: [i], value: v };\n        errors.push(e);\n        continue;\n      }\n\n      const [e, r] = kind.validate(v);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      ret[i] = r;\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction union(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Union structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options));\n  const name = 'union';\n  const type = kinds.map(k => k.type).join(' | ');\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const errors = [];\n\n    for (const k of kinds) {\n      const [e, r] = k.validate(value);\n\n      if (!e) {\n        return [undefined, r];\n      }\n\n      errors.push(e);\n    }\n    errors[0].type = type;\n    return errors;\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction intersection(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Intersection structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const types = schema.map(s => any(s, undefined, options));\n  const name = 'intersection';\n  const type = types.map(t => t.type).join(' & ');\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    let v = value;\n\n    for (const t of types) {\n      const [e, r] = t.validate(v);\n\n      if (e) {\n        e.type = type;\n        return [e];\n      }\n\n      v = r;\n    }\n\n    return [undefined, v];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\nconst Kinds = {\n  any,\n  dict,\n  enum: en,\n  enums,\n  function: func,\n  instance,\n  interface: inter,\n  lazy,\n  list,\n  literal,\n  object,\n  optional,\n  partial,\n  scalar,\n  tuple,\n  union,\n  intersection,\n  dynamic\n\n  /**\n   * Export.\n   *\n   * @type {Object}\n   */\n\n};\n\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nconst TYPES = ['arguments', 'array', 'boolean', 'buffer', 'error', 'float32array', 'float64array', 'function', 'generatorfunction', 'int16array', 'int32array', 'int8array', 'map', 'null', 'number', 'object', 'promise', 'regexp', 'set', 'string', 'symbol', 'uint16array', 'uint32array', 'uint8array', 'uint8clampedarray', 'undefined', 'weakmap', 'weakset'];\n\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nconst Types = {\n  any: value => value !== undefined\n};\n\nTYPES.forEach(type => {\n  Types[type] = value => kindOf(value) === type;\n});\n\n/**\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\n *\n * @param {Mixed} value\n * @return {Boolean}\n */\n\nTypes.date = value => kindOf(value) === 'date' && !isNaN(value);\n\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\nfunction superstruct(config = {}) {\n  const types = _extends({}, Types, config.types || {});\n\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n  function struct(schema, defaults$$1, options = {}) {\n    if (isStruct(schema)) {\n      schema = schema.schema;\n    }\n\n    const kind = Kinds.any(schema, defaults$$1, _extends({}, options, { types }));\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error('The `Struct` creation function should not be used with the `new` keyword.');\n        } else {\n          throw new Error('Invalid `new` keyword!');\n        }\n      }\n\n      return Struct.assert(data);\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, { value: true });\n    Object.defineProperty(Struct, KIND, { value: kind });\n\n    Struct.kind = kind.name;\n    Struct.type = kind.type;\n    Struct.schema = schema;\n    Struct.defaults = defaults$$1;\n    Struct.options = options;\n\n    Struct.assert = value => {\n      const [error, result] = kind.validate(value);\n\n      if (error) {\n        throw new StructError(error);\n      }\n\n      return result;\n    };\n\n    Struct.test = value => {\n      const [error] = kind.validate(value);\n      return !error;\n    };\n\n    Struct.validate = value => {\n      const [error, result] = kind.validate(value);\n\n      if (error) {\n        return [new StructError(error)];\n      }\n\n      return [undefined, result];\n    };\n\n    return Struct;\n  }\n\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n  Object.keys(Kinds).forEach(name => {\n    const kind = Kinds[name];\n\n    struct[name] = (schema, defaults$$1, options) => {\n      const type = kind(schema, defaults$$1, _extends({}, options, { types }));\n      const s = struct(type, defaults$$1, options);\n      return s;\n    };\n  });\n\n  /**\n   * Return the struct factory.\n   */\n\n  return struct;\n}\n\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\nconst struct = superstruct();\n\nexport { struct, superstruct, isStruct, StructError };\n//# sourceMappingURL=index.es.js.map\n","import {\n  html,\n  LitElement,\n  TemplateResult,\n  customElement,\n  property,\n} from \"lit-element\";\nimport \"@polymer/paper-input/paper-input\";\n\nimport { struct } from \"../../common/structs/struct\";\nimport { EntitiesEditorEvent, EditorTarget } from \"../types\";\nimport { HomeAssistant } from \"../../../../types\";\nimport { LovelaceCardEditor } from \"../../types\";\nimport { fireEvent } from \"../../../../common/dom/fire_event\";\nimport { ShoppingListCardConfig } from \"../../cards/types\";\n\nconst cardConfigStruct = struct({\n  type: \"string\",\n  title: \"string?\",\n});\n\n@customElement(\"hui-shopping-list-card-editor\")\nexport class HuiShoppingListEditor extends LitElement\n  implements LovelaceCardEditor {\n  @property() public hass?: HomeAssistant;\n\n  @property() private _config?: ShoppingListCardConfig;\n\n  public setConfig(config: ShoppingListCardConfig): void {\n    config = cardConfigStruct(config);\n    this._config = config;\n  }\n\n  get _title(): string {\n    return this._config!.title || \"\";\n  }\n\n  protected render(): TemplateResult | void {\n    if (!this.hass) {\n      return html``;\n    }\n\n    return html`\n      <div class=\"card-config\">\n        <paper-input\n          label=\"Title\"\n          .value=\"${this._title}\"\n          .configValue=\"${\"title\"}\"\n          @value-changed=\"${this._valueChanged}\"\n        ></paper-input>\n      </div>\n    `;\n  }\n\n  private _valueChanged(ev: EntitiesEditorEvent): void {\n    if (!this._config || !this.hass) {\n      return;\n    }\n    const target = ev.target! as EditorTarget;\n\n    if (this[`_${target.configValue}`] === target.value) {\n      return;\n    }\n    if (target.configValue) {\n      if (target.value === \"\") {\n        delete this._config[target.configValue!];\n      } else {\n        this._config = {\n          ...this._config,\n          [target.configValue!]: target.value,\n        };\n      }\n    }\n    fireEvent(this, \"config-changed\", { config: this._config });\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-shopping-list-card-editor\": HuiShoppingListEditor;\n  }\n}\n"],"sourceRoot":""}