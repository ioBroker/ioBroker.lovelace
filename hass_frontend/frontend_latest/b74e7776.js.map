{"version":3,"file":"b74e7776.js","mappings":";;AA4CA;;;AAMA;;AAEA;;;;;AAKA;;;;;AAKA;AAEA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBA;AAoEA;;AApEA;;ACUA;;;;;;;;;;;;;;;;;;;;AANA;;;;ACQA;AACA;;;;;;;AAZA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;ACEA;;ACgCA;AACA;;AAEA;;AApCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2HA;;;;;;;;;;AAWA;;AC5HA;;;;AAOA;;;;;;AAlBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AC4GA;AACA;AAMA;;AAQA;AACA;AACA;AACA;;AAEA;;AAEA;;;;AAIA;;AAGA;AACA;;AAEA;AAEA;;;AAKA;;AAKA;;AAGA;;;;;;AASA;;AAGA;AACA;;AAEA;;;;;;;AAaA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AAGA;AAEA;;AAKA;AAEA;;;AAKA;;;;AAIA;AAIA;AAGA;;AAMA;AAOA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAMA;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAMA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;;;AAQA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtOA","sources":["webpack://home-assistant-frontend/./src/components/ha-alert.ts","webpack://home-assistant-frontend/./src/components/ha-card.ts","webpack://home-assistant-frontend/./src/components/ha-select.ts","webpack://home-assistant-frontend/./src/components/ha-settings-row.ts","webpack://home-assistant-frontend/./src/components/ha-switch.ts","webpack://home-assistant-frontend/./src/components/ha-textfield.ts","webpack://home-assistant-frontend/./src/panels/config/ha-config-section.ts","webpack://home-assistant-frontend/./src/panels/config/integrations/integration-panels/zwave_js/zwave_js-node-config.ts"],"sourcesContent":["import {\n  mdiAlertCircleOutline,\n  mdiAlertOutline,\n  mdiCheckboxMarkedCircleOutline,\n  mdiClose,\n  mdiInformationOutline,\n} from \"@mdi/js\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport \"./ha-icon-button\";\nimport \"./ha-svg-icon\";\n\nconst ALERT_ICONS = {\n  info: mdiInformationOutline,\n  warning: mdiAlertOutline,\n  error: mdiAlertCircleOutline,\n  success: mdiCheckboxMarkedCircleOutline,\n};\n\ndeclare global {\n  interface HASSDomEvents {\n    \"alert-dismissed-clicked\": undefined;\n  }\n}\n\n@customElement(\"ha-alert\")\nclass HaAlert extends LitElement {\n  @property() public title = \"\";\n\n  @property({ attribute: \"alert-type\" }) public alertType:\n    | \"info\"\n    | \"warning\"\n    | \"error\"\n    | \"success\" = \"info\";\n\n  @property({ type: Boolean }) public dismissable = false;\n\n  @property({ type: Boolean }) public rtl = false;\n\n  public render() {\n    return html`\n      <div\n        class=\"issue-type ${classMap({\n          rtl: this.rtl,\n          [this.alertType]: true,\n        })}\"\n        role=\"alert\"\n      >\n        <div class=\"icon ${this.title ? \"\" : \"no-title\"}\">\n          <slot name=\"icon\">\n            <ha-svg-icon .path=${ALERT_ICONS[this.alertType]}></ha-svg-icon>\n          </slot>\n        </div>\n        <div class=\"content\">\n          <div class=\"main-content\">\n            ${this.title ? html`<div class=\"title\">${this.title}</div>` : \"\"}\n            <slot></slot>\n          </div>\n          <div class=\"action\">\n            <slot name=\"action\">\n              ${this.dismissable\n                ? html`<ha-icon-button\n                    @click=${this._dismiss_clicked}\n                    label=\"Dismiss alert\"\n                    .path=${mdiClose}\n                  ></ha-icon-button>`\n                : \"\"}\n            </slot>\n          </div>\n        </div>\n      </div>\n    `;\n  }\n\n  private _dismiss_clicked() {\n    fireEvent(this, \"alert-dismissed-clicked\");\n  }\n\n  static styles = css`\n    .issue-type {\n      position: relative;\n      padding: 8px;\n      display: flex;\n      margin: 4px 0;\n    }\n    .issue-type.rtl {\n      flex-direction: row-reverse;\n    }\n    .issue-type::after {\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      opacity: 0.12;\n      pointer-events: none;\n      content: \"\";\n      border-radius: 4px;\n    }\n    .icon {\n      z-index: 1;\n    }\n    .icon.no-title {\n      align-self: center;\n    }\n    .issue-type.rtl > .content {\n      flex-direction: row-reverse;\n      text-align: right;\n    }\n    .content {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      width: 100%;\n    }\n    .action {\n      z-index: 1;\n      width: min-content;\n      --mdc-theme-primary: var(--primary-text-color);\n    }\n    .main-content {\n      overflow-wrap: anywhere;\n      word-break: break-word;\n      margin-left: 8px;\n      margin-right: 0;\n    }\n    .issue-type.rtl > .content > .main-content {\n      margin-left: 0;\n      margin-right: 8px;\n    }\n    .title {\n      margin-top: 2px;\n      font-weight: bold;\n    }\n    .action mwc-button,\n    .action ha-icon-button {\n      --mdc-theme-primary: var(--primary-text-color);\n      --mdc-icon-button-size: 36px;\n    }\n    .issue-type.info > .icon {\n      color: var(--info-color);\n    }\n    .issue-type.info::after {\n      background-color: var(--info-color);\n    }\n\n    .issue-type.warning > .icon {\n      color: var(--warning-color);\n    }\n    .issue-type.warning::after {\n      background-color: var(--warning-color);\n    }\n\n    .issue-type.error > .icon {\n      color: var(--error-color);\n    }\n    .issue-type.error::after {\n      background-color: var(--error-color);\n    }\n\n    .issue-type.success > .icon {\n      color: var(--success-color);\n    }\n    .issue-type.success::after {\n      background-color: var(--success-color);\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-alert\": HaAlert;\n  }\n}\n","import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"ha-card\")\nexport class HaCard extends LitElement {\n  @property() public header?: string;\n\n  @property({ type: Boolean, reflect: true }) public outlined = false;\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        background: var(\n          --ha-card-background,\n          var(--card-background-color, white)\n        );\n        border-radius: var(--ha-card-border-radius, 4px);\n        box-shadow: var(\n          --ha-card-box-shadow,\n          0px 2px 1px -1px rgba(0, 0, 0, 0.2),\n          0px 1px 1px 0px rgba(0, 0, 0, 0.14),\n          0px 1px 3px 0px rgba(0, 0, 0, 0.12)\n        );\n        color: var(--primary-text-color);\n        display: block;\n        transition: all 0.3s ease-out;\n        position: relative;\n      }\n\n      :host([outlined]) {\n        box-shadow: none;\n        border-width: var(--ha-card-border-width, 1px);\n        border-style: solid;\n        border-color: var(\n          --ha-card-border-color,\n          var(--divider-color, #e0e0e0)\n        );\n      }\n\n      .card-header,\n      :host ::slotted(.card-header) {\n        color: var(--ha-card-header-color, --primary-text-color);\n        font-family: var(--ha-card-header-font-family, inherit);\n        font-size: var(--ha-card-header-font-size, 24px);\n        letter-spacing: -0.012em;\n        line-height: 48px;\n        padding: 12px 16px 16px;\n        display: block;\n        margin-block-start: 0px;\n        margin-block-end: 0px;\n        font-weight: normal;\n      }\n\n      :host ::slotted(.card-content:not(:first-child)),\n      slot:not(:first-child)::slotted(.card-content) {\n        padding-top: 0px;\n        margin-top: -8px;\n      }\n\n      :host ::slotted(.card-content) {\n        padding: 16px;\n      }\n\n      :host ::slotted(.card-actions) {\n        border-top: 1px solid var(--divider-color, #e8e8e8);\n        padding: 5px 16px;\n      }\n    `;\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      ${this.header\n        ? html`<h1 class=\"card-header\">${this.header}</h1>`\n        : html``}\n      <slot></slot>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-card\": HaCard;\n  }\n}\n","import { SelectBase } from \"@material/mwc-select/mwc-select-base\";\nimport { styles } from \"@material/mwc-select/mwc-select.css\";\nimport { css, html, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { debounce } from \"../common/util/debounce\";\nimport { nextRender } from \"../common/util/render-status\";\n\n@customElement(\"ha-select\")\nexport class HaSelect extends SelectBase {\n  // @ts-ignore\n  @property({ type: Boolean }) public icon?: boolean;\n\n  protected override renderLeadingIcon() {\n    if (!this.icon) {\n      return nothing;\n    }\n\n    return html`<span class=\"mdc-select__icon\"\n      ><slot name=\"icon\"></slot\n    ></span>`;\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    window.addEventListener(\"translations-updated\", this._translationsUpdated);\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    window.removeEventListener(\n      \"translations-updated\",\n      this._translationsUpdated\n    );\n  }\n\n  private _translationsUpdated = debounce(async () => {\n    await nextRender();\n    this.layoutOptions();\n  }, 500);\n\n  static override styles = [\n    styles,\n    css`\n      .mdc-select:not(.mdc-select--disabled) .mdc-select__icon {\n        color: var(--secondary-text-color);\n      }\n      .mdc-select__anchor {\n        width: var(--ha-select-min-width, 200px);\n      }\n      .mdc-select--filled .mdc-floating-label {\n        inset-inline-start: 12px;\n        inset-inline-end: initial;\n        direction: var(--direction);\n      }\n      .mdc-select .mdc-select__anchor {\n        padding-inline-start: 12px;\n        padding-inline-end: 0px;\n        direction: var(--direction);\n      }\n      .mdc-select__anchor .mdc-floating-label--float-above {\n        transform-origin: var(--float-start);\n      }\n    `,\n  ];\n}\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-select\": HaSelect;\n  }\n}\n","import \"@polymer/paper-item/paper-item-body\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"ha-settings-row\")\nexport class HaSettingsRow extends LitElement {\n  @property({ type: Boolean, reflect: true }) public narrow!: boolean;\n\n  @property({ type: Boolean, attribute: \"three-line\" })\n  public threeLine = false;\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"prefix-wrap\">\n        <slot name=\"prefix\"></slot>\n        <paper-item-body\n          ?two-line=${!this.threeLine}\n          ?three-line=${this.threeLine}\n        >\n          <slot name=\"heading\"></slot>\n          <div secondary><slot name=\"description\"></slot></div>\n        </paper-item-body>\n      </div>\n      <div class=\"content\"><slot></slot></div>\n    `;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: flex;\n        padding: 0 16px;\n        align-content: normal;\n        align-self: auto;\n        align-items: center;\n      }\n      paper-item-body {\n        padding: 8px 16px 8px 0;\n      }\n      paper-item-body[two-line] {\n        min-height: calc(\n          var(--paper-item-body-two-line-min-height, 72px) - 16px\n        );\n        flex: 1;\n      }\n      .content {\n        display: contents;\n      }\n      :host(:not([narrow])) .content {\n        display: var(--settings-row-content-display, flex);\n        justify-content: flex-end;\n        flex: 1;\n        padding: 16px 0;\n      }\n      .content ::slotted(*) {\n        width: var(--settings-row-content-width);\n      }\n      :host([narrow]) {\n        align-items: normal;\n        flex-direction: column;\n        border-top: 1px solid var(--divider-color);\n        padding-bottom: 8px;\n      }\n      ::slotted(ha-switch) {\n        padding: 16px 0;\n      }\n      div[secondary] {\n        white-space: normal;\n      }\n      .prefix-wrap {\n        display: var(--settings-row-prefix-display);\n      }\n      :host([narrow]) .prefix-wrap {\n        display: flex;\n        align-items: center;\n      }\n    `;\n  }\n}\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-settings-row\": HaSettingsRow;\n  }\n}\n","import { SwitchBase } from \"@material/mwc-switch/deprecated/mwc-switch-base\";\nimport { styles } from \"@material/mwc-switch/deprecated/mwc-switch.css\";\nimport { css } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { forwardHaptic } from \"../data/haptics\";\n\n@customElement(\"ha-switch\")\nexport class HaSwitch extends SwitchBase {\n  // Generate a haptic vibration.\n  // Only set to true if the new value of the switch is applied right away when toggling.\n  // Do not add haptic when a user is required to press save.\n  @property({ type: Boolean }) public haptic = false;\n\n  protected firstUpdated() {\n    super.firstUpdated();\n    this.addEventListener(\"change\", () => {\n      if (this.haptic) {\n        forwardHaptic(\"light\");\n      }\n    });\n  }\n\n  static override styles = [\n    styles,\n    css`\n      :host {\n        --mdc-theme-secondary: var(--switch-checked-color);\n      }\n      .mdc-switch.mdc-switch--checked .mdc-switch__thumb {\n        background-color: var(--switch-checked-button-color);\n        border-color: var(--switch-checked-button-color);\n      }\n      .mdc-switch.mdc-switch--checked .mdc-switch__track {\n        background-color: var(--switch-checked-track-color);\n        border-color: var(--switch-checked-track-color);\n      }\n      .mdc-switch:not(.mdc-switch--checked) .mdc-switch__thumb {\n        background-color: var(--switch-unchecked-button-color);\n        border-color: var(--switch-unchecked-button-color);\n      }\n      .mdc-switch:not(.mdc-switch--checked) .mdc-switch__track {\n        background-color: var(--switch-unchecked-track-color);\n        border-color: var(--switch-unchecked-track-color);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-switch\": HaSwitch;\n  }\n}\n","import { TextFieldBase } from \"@material/mwc-textfield/mwc-textfield-base\";\nimport { styles } from \"@material/mwc-textfield/mwc-textfield.css\";\nimport { TemplateResult, html, PropertyValues, css } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"ha-textfield\")\nexport class HaTextField extends TextFieldBase {\n  @property({ type: Boolean }) public invalid?: boolean;\n\n  @property({ attribute: \"error-message\" }) public errorMessage?: string;\n\n  // @ts-ignore\n  @property({ type: Boolean }) public icon?: boolean;\n\n  // @ts-ignore\n  @property({ type: Boolean }) public iconTrailing?: boolean;\n\n  override updated(changedProperties: PropertyValues) {\n    super.updated(changedProperties);\n    if (\n      (changedProperties.has(\"invalid\") &&\n        (this.invalid || changedProperties.get(\"invalid\") !== undefined)) ||\n      changedProperties.has(\"errorMessage\")\n    ) {\n      this.setCustomValidity(\n        this.invalid ? this.errorMessage || \"Invalid\" : \"\"\n      );\n      this.reportValidity();\n    }\n  }\n\n  protected override renderIcon(\n    _icon: string,\n    isTrailingIcon = false\n  ): TemplateResult {\n    const type = isTrailingIcon ? \"trailing\" : \"leading\";\n\n    return html`\n      <span\n        class=\"mdc-text-field__icon mdc-text-field__icon--${type}\"\n        tabindex=${isTrailingIcon ? 1 : -1}\n      >\n        <slot name=\"${type}Icon\"></slot>\n      </span>\n    `;\n  }\n\n  static override styles = [\n    styles,\n    css`\n      .mdc-text-field__input {\n        width: var(--ha-textfield-input-width, 100%);\n      }\n      .mdc-text-field:not(.mdc-text-field--with-leading-icon) {\n        padding: var(--text-field-padding, 0px 16px);\n      }\n      .mdc-text-field__affix--suffix {\n        padding-left: var(--text-field-suffix-padding-left, 12px);\n        padding-right: var(--text-field-suffix-padding-right, 0px);\n        padding-inline-start: var(--text-field-suffix-padding-left, 12px);\n        padding-inline-end: var(--text-field-suffix-padding-right, 0px);\n        direction: var(--direction);\n      }\n      .mdc-text-field--with-leading-icon {\n        padding-inline-start: var(--text-field-suffix-padding-left, 0px);\n        padding-inline-end: var(--text-field-suffix-padding-right, 16px);\n        direction: var(--direction);\n      }\n\n      .mdc-text-field:not(.mdc-text-field--disabled)\n        .mdc-text-field__affix--suffix {\n        color: var(--secondary-text-color);\n      }\n\n      .mdc-text-field__icon {\n        color: var(--secondary-text-color);\n      }\n\n      .mdc-text-field__icon--leading {\n        margin-inline-start: 16px;\n        margin-inline-end: 8px;\n        direction: var(--direction);\n      }\n\n      input {\n        text-align: var(--text-field-text-align);\n      }\n\n      /* Chrome, Safari, Edge, Opera */\n      :host([no-spinner]) input::-webkit-outer-spin-button,\n      :host([no-spinner]) input::-webkit-inner-spin-button {\n        -webkit-appearance: none;\n        margin: 0;\n      }\n\n      /* Firefox */\n      :host([no-spinner]) input[type=\"number\"] {\n        -moz-appearance: textfield;\n      }\n\n      .mdc-text-field__ripple {\n        overflow: hidden;\n      }\n\n      .mdc-text-field {\n        overflow: var(--text-field-overflow);\n      }\n\n      .mdc-floating-label {\n        inset-inline-start: 16px !important;\n        inset-inline-end: initial !important;\n        transform-origin: var(--float-start);\n        direction: var(--direction);\n        transform-origin: var(--float-start);\n      }\n\n      .mdc-text-field--with-leading-icon.mdc-text-field--filled\n        .mdc-floating-label {\n        max-width: calc(100% - 48px);\n        inset-inline-start: 48px !important;\n        inset-inline-end: initial !important;\n        direction: var(--direction);\n      }\n\n      .mdc-text-field__input[type=\"number\"] {\n        direction: var(--direction);\n      }\n    `,\n    // safari workaround - must be explicit\n    document.dir === \"rtl\"\n      ? css`\n          .mdc-text-field__affix--suffix,\n          .mdc-text-field--with-leading-icon,\n          .mdc-text-field__icon--leading,\n          .mdc-floating-label,\n          .mdc-text-field--with-leading-icon.mdc-text-field--filled\n            .mdc-floating-label,\n          .mdc-text-field__input[type=\"number\"] {\n            direction: rtl;\n          }\n        `\n      : css``,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-textfield\": HaTextField;\n  }\n}\n","import { css, html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\n\n@customElement(\"ha-config-section\")\nexport class HaConfigSection extends LitElement {\n  @property() public isWide = false;\n\n  @property({ type: Boolean }) public vertical = false;\n\n  @property({ type: Boolean, attribute: \"full-width\" })\n  public fullWidth = false;\n\n  protected render() {\n    return html`\n      <div\n        class=\"content ${classMap({\n          narrow: !this.isWide,\n          \"full-width\": this.fullWidth,\n        })}\"\n      >\n        <div class=\"header\"><slot name=\"header\"></slot></div>\n        <div\n          class=\"together layout ${classMap({\n            narrow: !this.isWide,\n            vertical: this.vertical || !this.isWide,\n            horizontal: !this.vertical && this.isWide,\n          })}\"\n        >\n          <div class=\"intro\"><slot name=\"introduction\"></slot></div>\n          <div class=\"panel flex-auto\"><slot></slot></div>\n        </div>\n      </div>\n    `;\n  }\n\n  static get styles() {\n    return css`\n      :host {\n        display: block;\n      }\n      .content {\n        padding: 28px 20px 0;\n        max-width: 1040px;\n        margin: 0 auto;\n      }\n\n      .layout {\n        display: flex;\n      }\n\n      .horizontal {\n        flex-direction: row;\n      }\n\n      .vertical {\n        flex-direction: column;\n      }\n\n      .flex-auto {\n        flex: 1 1 auto;\n      }\n\n      .header {\n        font-family: var(--paper-font-headline_-_font-family);\n        -webkit-font-smoothing: var(\n          --paper-font-headline_-_-webkit-font-smoothing\n        );\n        font-size: var(--paper-font-headline_-_font-size);\n        font-weight: var(--paper-font-headline_-_font-weight);\n        letter-spacing: var(--paper-font-headline_-_letter-spacing);\n        line-height: var(--paper-font-headline_-_line-height);\n        opacity: var(--dark-primary-opacity);\n      }\n\n      .together {\n        margin-top: 32px;\n      }\n\n      .intro {\n        font-family: var(--paper-font-subhead_-_font-family);\n        -webkit-font-smoothing: var(\n          --paper-font-subhead_-_-webkit-font-smoothing\n        );\n        font-weight: var(--paper-font-subhead_-_font-weight);\n        line-height: var(--paper-font-subhead_-_line-height);\n        width: 100%;\n        opacity: var(--dark-primary-opacity);\n        font-size: 14px;\n        padding-bottom: 20px;\n      }\n\n      .horizontal .intro {\n        max-width: 400px;\n        margin-right: 40px;\n      }\n\n      .panel {\n        margin-top: -24px;\n      }\n\n      .panel ::slotted(*) {\n        margin-top: 24px;\n        display: block;\n      }\n\n      .narrow.content {\n        max-width: 640px;\n      }\n      .narrow .together {\n        margin-top: 20px;\n      }\n      .narrow .intro {\n        padding-bottom: 20px;\n        margin-right: 0;\n        max-width: 500px;\n      }\n\n      .full-width {\n        padding: 0;\n      }\n\n      .full-width .layout {\n        flex-direction: column;\n      }\n    `;\n  }\n}\n","import \"@material/mwc-button/mwc-button\";\nimport \"@material/mwc-list/mwc-list-item\";\nimport {\n  mdiCheckCircle,\n  mdiCircle,\n  mdiCloseCircle,\n  mdiProgressClock,\n} from \"@mdi/js\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport { debounce } from \"../../../../../common/util/debounce\";\nimport \"../../../../../components/ha-alert\";\nimport \"../../../../../components/ha-card\";\nimport \"../../../../../components/ha-icon-next\";\nimport \"../../../../../components/ha-select\";\nimport \"../../../../../components/ha-settings-row\";\nimport \"../../../../../components/ha-svg-icon\";\nimport \"../../../../../components/ha-switch\";\nimport \"../../../../../components/ha-textfield\";\nimport {\n  computeDeviceName,\n  DeviceRegistryEntry,\n  subscribeDeviceRegistry,\n} from \"../../../../../data/device_registry\";\nimport {\n  fetchZwaveNodeConfigParameters,\n  fetchZwaveNodeMetadata,\n  setZwaveNodeConfigParameter,\n  ZWaveJSNodeConfigParams,\n  ZwaveJSNodeMetadata,\n  ZWaveJSSetConfigParamResult,\n} from \"../../../../../data/zwave_js\";\nimport \"../../../../../layouts/hass-tabs-subpage\";\nimport { SubscribeMixin } from \"../../../../../mixins/subscribe-mixin\";\nimport { haStyle } from \"../../../../../resources/styles\";\nimport type { HomeAssistant, Route } from \"../../../../../types\";\nimport \"../../../ha-config-section\";\nimport { configTabs } from \"./zwave_js-config-router\";\n\nconst icons = {\n  accepted: mdiCheckCircle,\n  queued: mdiProgressClock,\n  error: mdiCloseCircle,\n};\n\nconst getDevice = memoizeOne(\n  (\n    deviceId: string,\n    entries?: DeviceRegistryEntry[]\n  ): DeviceRegistryEntry | undefined =>\n    entries?.find((device) => device.id === deviceId)\n);\n\n@customElement(\"zwave_js-node-config\")\nclass ZWaveJSNodeConfig extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public route!: Route;\n\n  @property({ type: Boolean }) public narrow!: boolean;\n\n  @property({ type: Boolean }) public isWide!: boolean;\n\n  @property() public configEntryId?: string;\n\n  @property() public deviceId!: string;\n\n  @property({ type: Array })\n  private _deviceRegistryEntries?: DeviceRegistryEntry[];\n\n  @state() private _nodeMetadata?: ZwaveJSNodeMetadata;\n\n  @state() private _config?: ZWaveJSNodeConfigParams;\n\n  @state() private _results: Record<string, ZWaveJSSetConfigParamResult> = {};\n\n  @state() private _error?: string;\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    this.deviceId = this.route.path.substr(1);\n  }\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      subscribeDeviceRegistry(this.hass.connection, (entries) => {\n        this._deviceRegistryEntries = entries;\n      }),\n    ];\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (\n      (!this._config || changedProps.has(\"deviceId\")) &&\n      changedProps.has(\"_deviceRegistryEntries\")\n    ) {\n      this._fetchData();\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (this._error) {\n      return html`<hass-error-screen\n        .hass=${this.hass}\n        .error=${this.hass.localize(\n          `ui.panel.config.zwave_js.node_config.error_${this._error}`\n        )}\n      ></hass-error-screen>`;\n    }\n\n    if (!this._config || !this._nodeMetadata) {\n      return html`<hass-loading-screen></hass-loading-screen>`;\n    }\n\n    const device = this._device!;\n\n    return html`\n      <hass-tabs-subpage\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n        .route=${this.route}\n        .tabs=${configTabs}\n      >\n        <ha-config-section .narrow=${this.narrow} .isWide=${this.isWide}>\n          <div slot=\"header\">\n            ${this.hass.localize(\"ui.panel.config.zwave_js.node_config.header\")}\n          </div>\n\n          <div slot=\"introduction\">\n            ${device\n              ? html`\n                  <div class=\"device-info\">\n                    <h2>${computeDeviceName(device, this.hass)}</h2>\n                    <p>${device.manufacturer} ${device.model}</p>\n                  </div>\n                `\n              : ``}\n            ${this.hass.localize(\n              \"ui.panel.config.zwave_js.node_config.introduction\"\n            )}\n            <p>\n              <em>\n                ${this.hass.localize(\n                  \"ui.panel.config.zwave_js.node_config.attribution\",\n                  \"device_database\",\n                  html`<a\n                    rel=\"noreferrer noopener\"\n                    href=${this._nodeMetadata?.device_database_url ||\n                    \"https://devices.zwave-js.io\"}\n                    target=\"_blank\"\n                    >${this.hass.localize(\n                      \"ui.panel.config.zwave_js.node_config.zwave_js_device_database\"\n                    )}</a\n                  >`\n                )}\n              </em>\n            </p>\n          </div>\n          <ha-card>\n            ${Object.entries(this._config).map(\n              ([id, item]) => html` <ha-settings-row\n                class=\"config-item\"\n                .configId=${id}\n                .narrow=${this.narrow}\n              >\n                ${this._generateConfigBox(id, item)}\n              </ha-settings-row>`\n            )}\n          </ha-card>\n        </ha-config-section>\n      </hass-tabs-subpage>\n    `;\n  }\n\n  private _generateConfigBox(id, item): TemplateResult {\n    const result = this._results[id];\n    const labelAndDescription = html`\n      <span slot=\"prefix\" class=\"prefix\">\n        ${this.hass.localize(\"ui.panel.config.zwave_js.node_config.parameter\")}\n        <br />\n        <span>${item.property}</span>\n      </span>\n      <span slot=\"heading\" .title=${item.metadata.label}>\n        ${item.metadata.label}\n      </span>\n      <span slot=\"description\">\n        ${item.metadata.description}\n        ${item.metadata.description !== null && !item.metadata.writeable\n          ? html`<br />`\n          : \"\"}\n        ${!item.metadata.writeable\n          ? html`<em>\n              ${this.hass.localize(\n                \"ui.panel.config.zwave_js.node_config.parameter_is_read_only\"\n              )}\n            </em>`\n          : \"\"}\n        ${result?.status\n          ? html` <p\n              class=\"result ${classMap({\n                [result.status]: true,\n              })}\"\n            >\n              <ha-svg-icon\n                .path=${icons[result.status] ? icons[result.status] : mdiCircle}\n                class=\"result-icon\"\n                slot=\"item-icon\"\n              ></ha-svg-icon>\n              ${this.hass.localize(\n                \"ui.panel.config.zwave_js.node_config.set_param_\" +\n                  result.status\n              )}\n              ${result.status === \"error\" && result.error\n                ? html` <br /><em>${result.error}</em> `\n                : \"\"}\n            </p>`\n          : \"\"}\n      </span>\n    `;\n\n    // Numeric entries with a min value of 0 and max of 1 are considered boolean\n    if (\n      (item.configuration_value_type === \"manual_entry\" &&\n        item.metadata.min === 0 &&\n        item.metadata.max === 1) ||\n      this._isEnumeratedBool(item)\n    ) {\n      return html`\n        ${labelAndDescription}\n        <div class=\"toggle\">\n          <ha-switch\n            .property=${item.property}\n            .propertyKey=${item.property_key}\n            .checked=${item.value === 1}\n            .key=${id}\n            @change=${this._switchToggled}\n            .disabled=${!item.metadata.writeable}\n          ></ha-switch>\n        </div>\n      `;\n    }\n\n    if (item.configuration_value_type === \"manual_entry\") {\n      return html`${labelAndDescription}\n        <ha-textfield\n          type=\"number\"\n          .value=${item.value}\n          .min=${item.metadata.min}\n          .max=${item.metadata.max}\n          .property=${item.property}\n          .propertyKey=${item.property_key}\n          .key=${id}\n          .disabled=${!item.metadata.writeable}\n          @input=${this._numericInputChanged}\n        >\n          ${item.metadata.unit\n            ? html`<span slot=\"suffix\">${item.metadata.unit}</span>`\n            : \"\"}\n        </ha-textfield>`;\n    }\n\n    if (item.configuration_value_type === \"enumerated\") {\n      return html`\n        ${labelAndDescription}\n        <div class=\"flex\">\n          <ha-select\n            .disabled=${!item.metadata.writeable}\n            .value=${item.value?.toString()}\n            .key=${id}\n            .property=${item.property}\n            .propertyKey=${item.property_key}\n            @selected=${this._dropdownSelected}\n          >\n            ${Object.entries(item.metadata.states).map(\n              ([key, entityState]) => html`\n                <mwc-list-item .value=${key}>${entityState}</mwc-list-item>\n              `\n            )}\n          </ha-select>\n        </div>\n      `;\n    }\n\n    return html`${labelAndDescription}\n      <p>${item.value}</p>`;\n  }\n\n  private _isEnumeratedBool(item): boolean {\n    // Some Z-Wave config values use a states list with two options where index 0 = Disabled and 1 = Enabled\n    // We want those to be considered boolean and show a toggle switch\n    const disabledStates = [\"disable\", \"disabled\"];\n    const enabledStates = [\"enable\", \"enabled\"];\n\n    if (item.configuration_value_type !== \"enumerated\") {\n      return false;\n    }\n    if (!(\"states\" in item.metadata)) {\n      return false;\n    }\n    if (Object.keys(item.metadata.states).length !== 2) {\n      return false;\n    }\n    if (!(0 in item.metadata.states) || !(1 in item.metadata.states)) {\n      return false;\n    }\n    if (\n      disabledStates.includes(item.metadata.states[0].toLowerCase()) &&\n      enabledStates.includes(item.metadata.states[1].toLowerCase())\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  private _switchToggled(ev) {\n    this.setResult(ev.target.key, undefined);\n    this._updateConfigParameter(ev.target, ev.target.checked ? 1 : 0);\n  }\n\n  private _dropdownSelected(ev) {\n    if (ev.target === undefined || this._config![ev.target.key] === undefined) {\n      return;\n    }\n    if (this._config![ev.target.key].value?.toString() === ev.target.value) {\n      return;\n    }\n    this.setResult(ev.target.key, undefined);\n\n    this._updateConfigParameter(ev.target, Number(ev.target.value));\n  }\n\n  private debouncedUpdate = debounce((target, value) => {\n    this._config![target.key].value = value;\n\n    this._updateConfigParameter(target, value);\n  }, 1000);\n\n  private _numericInputChanged(ev) {\n    if (ev.target === undefined || this._config![ev.target.key] === undefined) {\n      return;\n    }\n    const value = Number(ev.target.value);\n    if (Number(this._config![ev.target.key].value) === value) {\n      return;\n    }\n    this.setResult(ev.target.key, undefined);\n    this.debouncedUpdate(ev.target, value);\n  }\n\n  private async _updateConfigParameter(target, value) {\n    try {\n      const result = await setZwaveNodeConfigParameter(\n        this.hass,\n        this._device!.id,\n        target.property,\n        value,\n        target.propertyKey ? target.propertyKey : undefined\n      );\n      this._config![target.key].value = value;\n\n      this.setResult(target.key, result.status);\n    } catch (err: any) {\n      this.setError(target.key, err.message);\n    }\n  }\n\n  private setResult(key: string, value: string | undefined) {\n    if (value === undefined) {\n      delete this._results[key];\n      this.requestUpdate();\n    } else {\n      this._results = { ...this._results, [key]: { status: value } };\n    }\n  }\n\n  private setError(key: string, message: string) {\n    const errorParam = { status: \"error\", error: message };\n    this._results = { ...this._results, [key]: errorParam };\n  }\n\n  private get _device(): DeviceRegistryEntry | undefined {\n    return getDevice(this.deviceId, this._deviceRegistryEntries);\n  }\n\n  private async _fetchData() {\n    if (!this.configEntryId || !this._deviceRegistryEntries) {\n      return;\n    }\n\n    const device = this._device;\n    if (!device) {\n      this._error = \"device_not_found\";\n      return;\n    }\n\n    [this._nodeMetadata, this._config] = await Promise.all([\n      fetchZwaveNodeMetadata(this.hass, device.id),\n      fetchZwaveNodeConfigParameters(this.hass, device.id),\n    ]);\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyle,\n      css`\n        .accepted {\n          color: var(--success-color);\n        }\n\n        .queued {\n          color: var(--warning-color);\n        }\n\n        .error {\n          color: var(--error-color);\n        }\n\n        .secondary {\n          color: var(--secondary-text-color);\n        }\n\n        .flex {\n          display: flex;\n        }\n\n        .flex .config-label,\n        .flex ha-select {\n          flex: 1;\n        }\n\n        .content {\n          margin-top: 24px;\n        }\n\n        .sectionHeader {\n          position: relative;\n          padding-right: 40px;\n        }\n\n        ha-card {\n          margin: 0 auto;\n          max-width: 600px;\n        }\n\n        ha-settings-row {\n          --paper-time-input-justify-content: flex-end;\n          border-top: 1px solid var(--divider-color);\n          padding: 4px 16px;\n        }\n\n        .prefix {\n          color: var(--secondary-text-color);\n          text-align: center;\n          text-transform: uppercase;\n          font-size: 0.8em;\n          padding-right: 24px;\n          line-height: 1.5em;\n        }\n\n        .prefix span {\n          font-size: 1.3em;\n        }\n\n        :host(:not([narrow])) ha-settings-row ha-textfield {\n          width: 30%;\n          text-align: right;\n        }\n\n        ha-card:last-child {\n          margin-bottom: 24px;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"zwave_js-node-config\": ZWaveJSNodeConfig;\n  }\n}\n"],"names":[],"sourceRoot":""}