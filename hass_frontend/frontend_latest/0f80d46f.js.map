{"version":3,"file":"0f80d46f.js","mappings":";;AAkGA;;AAIA;;;AAKA;AACA;;;AASA;AAEA;;;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;AAxCA","sources":["webpack://home-assistant-frontend/./src/panels/lovelace/cards/energy/hui-energy-solar-graph-card.ts"],"sourcesContent":["import {\n  ChartData,\n  ChartDataset,\n  ChartOptions,\n  ScatterDataPoint,\n} from \"chart.js\";\nimport {\n  addHours,\n  differenceInDays,\n  differenceInHours,\n  endOfToday,\n  isToday,\n  startOfToday,\n} from \"date-fns/esm\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport {\n  hex2rgb,\n  lab2rgb,\n  rgb2hex,\n  rgb2lab,\n} from \"../../../../common/color/convert-color\";\nimport { labBrighten, labDarken } from \"../../../../common/color/lab\";\nimport { formatDateShort } from \"../../../../common/datetime/format_date\";\nimport { formatTime } from \"../../../../common/datetime/format_time\";\nimport {\n  formatNumber,\n  numberFormatToLocale,\n} from \"../../../../common/number/format_number\";\nimport \"../../../../components/chart/ha-chart-base\";\nimport \"../../../../components/ha-card\";\nimport {\n  EnergyData,\n  EnergySolarForecasts,\n  getEnergyDataCollection,\n  getEnergySolarForecasts,\n  SolarSourceTypeEnergyPreference,\n} from \"../../../../data/energy\";\nimport {\n  Statistics,\n  StatisticsMetaData,\n  getStatisticLabel,\n} from \"../../../../data/recorder\";\nimport { FrontendLocaleData } from \"../../../../data/translation\";\nimport { SubscribeMixin } from \"../../../../mixins/subscribe-mixin\";\nimport { HomeAssistant } from \"../../../../types\";\nimport { LovelaceCard } from \"../../types\";\nimport { EnergySolarGraphCardConfig } from \"../types\";\n\n@customElement(\"hui-energy-solar-graph-card\")\nexport class HuiEnergySolarGraphCard\n  extends SubscribeMixin(LitElement)\n  implements LovelaceCard\n{\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @state() private _config?: EnergySolarGraphCardConfig;\n\n  @state() private _chartData: ChartData = {\n    datasets: [],\n  };\n\n  @state() private _start = startOfToday();\n\n  @state() private _end = endOfToday();\n\n  @state() private _compareStart?: Date;\n\n  @state() private _compareEnd?: Date;\n\n  protected hassSubscribeRequiredHostProps = [\"_config\"];\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      getEnergyDataCollection(this.hass, {\n        key: this._config?.collection_key,\n      }).subscribe((data) => this._getStatistics(data)),\n    ];\n  }\n\n  public getCardSize(): Promise<number> | number {\n    return 3;\n  }\n\n  public setConfig(config: EnergySolarGraphCardConfig): void {\n    this._config = config;\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass || !this._config) {\n      return html``;\n    }\n\n    return html`\n      <ha-card>\n        ${this._config.title\n          ? html`<h1 class=\"card-header\">${this._config.title}</h1>`\n          : \"\"}\n        <div\n          class=\"content ${classMap({\n            \"has-header\": !!this._config.title,\n          })}\"\n        >\n          <ha-chart-base\n            .data=${this._chartData}\n            .options=${this._createOptions(\n              this._start,\n              this._end,\n              this.hass.locale,\n              this._compareStart,\n              this._compareEnd\n            )}\n            chart-type=\"bar\"\n          ></ha-chart-base>\n          ${!this._chartData.datasets.length\n            ? html`<div class=\"no-data\">\n                ${isToday(this._start)\n                  ? this.hass.localize(\"ui.panel.lovelace.cards.energy.no_data\")\n                  : this.hass.localize(\n                      \"ui.panel.lovelace.cards.energy.no_data_period\"\n                    )}\n              </div>`\n            : \"\"}\n        </div>\n      </ha-card>\n    `;\n  }\n\n  private _createOptions = memoizeOne(\n    (\n      start: Date,\n      end: Date,\n      locale: FrontendLocaleData,\n      compareStart?: Date,\n      compareEnd?: Date\n    ): ChartOptions => {\n      const dayDifference = differenceInDays(end, start);\n      const compare = compareStart !== undefined && compareEnd !== undefined;\n      if (compare) {\n        const difference = differenceInHours(end, start);\n        const differenceCompare = differenceInHours(compareEnd!, compareStart!);\n        // If the compare period doesn't match the main period, adjust them to match\n        if (differenceCompare > difference) {\n          end = addHours(end, differenceCompare - difference);\n        } else if (difference > differenceCompare) {\n          compareEnd = addHours(compareEnd!, difference - differenceCompare);\n        }\n      }\n\n      const options: ChartOptions = {\n        parsing: false,\n        animation: false,\n        scales: {\n          x: {\n            type: \"time\",\n            suggestedMin: start.getTime(),\n            suggestedMax: end.getTime(),\n            adapters: {\n              date: {\n                locale: locale,\n              },\n            },\n            ticks: {\n              maxRotation: 0,\n              sampleSize: 5,\n              autoSkipPadding: 20,\n              major: {\n                enabled: true,\n              },\n              font: (context) =>\n                context.tick && context.tick.major\n                  ? ({ weight: \"bold\" } as any)\n                  : {},\n            },\n            time: {\n              tooltipFormat:\n                dayDifference > 35\n                  ? \"monthyear\"\n                  : dayDifference > 7\n                  ? \"date\"\n                  : dayDifference > 2\n                  ? \"weekday\"\n                  : dayDifference > 0\n                  ? \"datetime\"\n                  : \"hour\",\n              minUnit:\n                dayDifference > 35\n                  ? \"month\"\n                  : dayDifference > 2\n                  ? \"day\"\n                  : \"hour\",\n            },\n          },\n          y: {\n            stacked: true,\n            type: \"linear\",\n            title: {\n              display: true,\n              text: \"kWh\",\n            },\n            ticks: {\n              beginAtZero: true,\n            },\n          },\n        },\n        plugins: {\n          tooltip: {\n            mode: \"nearest\",\n            callbacks: {\n              title: (datasets) => {\n                if (dayDifference > 0) {\n                  return datasets[0].label;\n                }\n                const date = new Date(datasets[0].parsed.x);\n                return `${\n                  compare ? `${formatDateShort(date, locale)}: ` : \"\"\n                }${formatTime(date, locale)} â€“ ${formatTime(\n                  addHours(date, 1),\n                  locale\n                )}`;\n              },\n              label: (context) =>\n                `${context.dataset.label}: ${formatNumber(\n                  context.parsed.y,\n                  locale\n                )} kWh`,\n            },\n          },\n          filler: {\n            propagate: false,\n          },\n          legend: {\n            display: false,\n            labels: {\n              usePointStyle: true,\n            },\n          },\n        },\n        hover: {\n          mode: \"nearest\",\n        },\n        elements: {\n          line: {\n            tension: 0.3,\n            borderWidth: 1.5,\n          },\n          bar: { borderWidth: 1.5, borderRadius: 4 },\n          point: {\n            hitRadius: 5,\n          },\n        },\n        // @ts-expect-error\n        locale: numberFormatToLocale(locale),\n      };\n      if (compare) {\n        options.scales!.xAxisCompare = {\n          ...(options.scales!.x as Record<string, any>),\n          suggestedMin: compareStart!.getTime(),\n          suggestedMax: compareEnd!.getTime(),\n          display: false,\n        };\n      }\n      return options;\n    }\n  );\n\n  private async _getStatistics(energyData: EnergyData): Promise<void> {\n    const solarSources: SolarSourceTypeEnergyPreference[] =\n      energyData.prefs.energy_sources.filter(\n        (source) => source.type === \"solar\"\n      ) as SolarSourceTypeEnergyPreference[];\n\n    let forecasts: EnergySolarForecasts | undefined;\n    if (\n      solarSources.some((source) => source.config_entry_solar_forecast?.length)\n    ) {\n      try {\n        forecasts = await getEnergySolarForecasts(this.hass);\n      } catch (_e) {\n        // ignore\n      }\n    }\n\n    const datasets: ChartDataset<\"bar\" | \"line\">[] = [];\n\n    const computedStyles = getComputedStyle(this);\n    const solarColor = computedStyles\n      .getPropertyValue(\"--energy-solar-color\")\n      .trim();\n\n    datasets.push(\n      ...this._processDataSet(\n        energyData.stats,\n        energyData.statsMetadata,\n        solarSources,\n        solarColor\n      )\n    );\n\n    if (energyData.statsCompare) {\n      // Add empty dataset to align the bars\n      datasets.push({\n        order: 0,\n        data: [],\n      });\n      datasets.push({\n        order: 999,\n        data: [],\n        xAxisID: \"xAxisCompare\",\n      });\n\n      datasets.push(\n        ...this._processDataSet(\n          energyData.statsCompare,\n          energyData.statsMetadata,\n          solarSources,\n          solarColor,\n          true\n        )\n      );\n    }\n\n    if (forecasts) {\n      datasets.push(\n        ...this._processForecast(\n          energyData.statsMetadata,\n          forecasts,\n          solarSources,\n          computedStyles.getPropertyValue(\"--primary-text-color\"),\n          energyData.start,\n          energyData.end\n        )\n      );\n    }\n\n    this._start = energyData.start;\n    this._end = energyData.end || endOfToday();\n\n    this._compareStart = energyData.startCompare;\n    this._compareEnd = energyData.endCompare;\n\n    this._chartData = {\n      datasets,\n    };\n  }\n\n  private _processDataSet(\n    statistics: Statistics,\n    statisticsMetaData: Record<string, StatisticsMetaData>,\n    solarSources: SolarSourceTypeEnergyPreference[],\n    solarColor: string,\n    compare = false\n  ) {\n    const data: ChartDataset<\"bar\", ScatterDataPoint[]>[] = [];\n\n    solarSources.forEach((source, idx) => {\n      const modifiedColor =\n        idx > 0\n          ? this.hass.themes.darkMode\n            ? labBrighten(rgb2lab(hex2rgb(solarColor)), idx)\n            : labDarken(rgb2lab(hex2rgb(solarColor)), idx)\n          : undefined;\n      const borderColor = modifiedColor\n        ? rgb2hex(lab2rgb(modifiedColor))\n        : solarColor;\n\n      let prevValue: number | null = null;\n      let prevStart: string | null = null;\n\n      const solarProductionData: ScatterDataPoint[] = [];\n\n      // Process solar production data.\n      if (source.stat_energy_from in statistics) {\n        const stats = statistics[source.stat_energy_from];\n\n        for (const point of stats) {\n          if (point.sum === null) {\n            continue;\n          }\n          if (prevValue === null) {\n            prevValue = point.sum;\n            continue;\n          }\n          if (prevStart === point.start) {\n            continue;\n          }\n          const value = point.sum - prevValue;\n          const date = new Date(point.start);\n          solarProductionData.push({\n            x: date.getTime(),\n            y: value,\n          });\n          prevStart = point.start;\n          prevValue = point.sum;\n        }\n      }\n\n      data.push({\n        label: this.hass.localize(\n          \"ui.panel.lovelace.cards.energy.energy_solar_graph.production\",\n          {\n            name: getStatisticLabel(\n              this.hass,\n              source.stat_energy_from,\n              statisticsMetaData[source.stat_energy_from]\n            ),\n          }\n        ),\n        borderColor: compare ? borderColor + \"7F\" : borderColor,\n        backgroundColor: compare ? borderColor + \"32\" : borderColor + \"7F\",\n        data: solarProductionData,\n        order: 1,\n        stack: \"solar\",\n        xAxisID: compare ? \"xAxisCompare\" : undefined,\n      });\n    });\n\n    return data;\n  }\n\n  private _processForecast(\n    statisticsMetaData: Record<string, StatisticsMetaData>,\n    forecasts: EnergySolarForecasts,\n    solarSources: SolarSourceTypeEnergyPreference[],\n    borderColor: string,\n    start: Date,\n    end?: Date\n  ) {\n    const data: ChartDataset<\"line\">[] = [];\n\n    const dayDifference = differenceInDays(end || new Date(), start);\n\n    // Process solar forecast data.\n    solarSources.forEach((source) => {\n      if (source.config_entry_solar_forecast) {\n        const forecastsData: Record<string, number> | undefined = {};\n        source.config_entry_solar_forecast.forEach((configEntryId) => {\n          if (!forecasts![configEntryId]) {\n            return;\n          }\n          Object.entries(forecasts![configEntryId].wh_hours).forEach(\n            ([date, value]) => {\n              const dateObj = new Date(date);\n              if (dateObj < start || (end && dateObj > end)) {\n                return;\n              }\n              if (dayDifference > 35) {\n                dateObj.setDate(1);\n              }\n              if (dayDifference > 2) {\n                dateObj.setHours(0, 0, 0, 0);\n              } else {\n                dateObj.setMinutes(0, 0, 0);\n              }\n              const time = dateObj.getTime();\n              if (time in forecastsData) {\n                forecastsData[time] += value;\n              } else {\n                forecastsData[time] = value;\n              }\n            }\n          );\n        });\n\n        if (forecastsData) {\n          const solarForecastData: ScatterDataPoint[] = [];\n          for (const [time, value] of Object.entries(forecastsData)) {\n            solarForecastData.push({\n              x: Number(time),\n              y: value / 1000,\n            });\n          }\n\n          if (solarForecastData.length) {\n            data.push({\n              type: \"line\",\n              label: this.hass.localize(\n                \"ui.panel.lovelace.cards.energy.energy_solar_graph.forecast\",\n                {\n                  name: getStatisticLabel(\n                    this.hass,\n                    source.stat_energy_from,\n                    statisticsMetaData[source.stat_energy_from]\n                  ),\n                }\n              ),\n              fill: false,\n              stepped: false,\n              borderColor,\n              borderDash: [7, 5],\n              pointRadius: 0,\n              data: solarForecastData,\n            });\n          }\n        }\n      }\n    });\n\n    return data;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-card {\n        height: 100%;\n      }\n      .card-header {\n        padding-bottom: 0;\n      }\n      .content {\n        padding: 16px;\n      }\n      .has-header {\n        padding-top: 0;\n      }\n      .no-data {\n        position: absolute;\n        height: 100%;\n        top: 0;\n        left: 0;\n        right: 0;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        padding: 20%;\n        margin-left: 32px;\n        box-sizing: border-box;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-energy-solar-graph-card\": HuiEnergySolarGraphCard;\n  }\n}\n"],"names":[],"sourceRoot":""}