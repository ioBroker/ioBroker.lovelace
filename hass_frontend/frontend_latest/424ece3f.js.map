{"version":3,"file":"424ece3f.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsGA;AChDA;AACA;AACA;;AANA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvCA;;AC0JA;;AAUA;;AA+CA;AAKA;;AAEA;;;AAGA;AAMA;AACA;AACA;;;AAGA;;;;;AAKA;;AAIA;;AAKA;AAGA;AACA;AACA;;;;;AAMA;;;;AAQA;;;;;AAKA;AAlNA;AAyNA;AACA;;;;;;;;;;AAcA;AACA;;;;AAIA;;;AAKA;;;AAKA;;AAIA;;;AAIA;;;;AAWA;;;;;;;;;AAYA;AACA;AACA;;AAEA;;AAEA;;AAGA;AACA;AACA;AACA;;AAEA;;;;;;;AApSA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;ACgBA;;;AAIA;;AAEA;;AAGA;AACA;;;;AAIA;;;AAOA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AApEA","sources":["webpack://home-assistant-frontend/./src/layouts/ha-app-layout.js","webpack://home-assistant-frontend/./src/panels/lovelace/components/hui-marquee.ts","webpack://home-assistant-frontend/./src/panels/media-browser/ha-bar-media-player.ts","webpack://home-assistant-frontend/./src/panels/media-browser/ha-panel-media-browser.ts"],"sourcesContent":["/* eslint-plugin-disable lit */\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\nThis code is copied from app-header-layout.\n'fullbleed' support is removed as Home Assisstant doesn't use it.\ntransform: translate(0) is added.\n*/\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\nimport \"@polymer/app-layout/app-header-layout/app-header-layout\";\nimport { html } from \"@polymer/polymer/lib/utils/html-tag\";\nimport \"@polymer/polymer/polymer-element\";\n\nclass HaAppLayout extends customElements.get(\"app-header-layout\") {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: block;\n          /**\n         * Force app-header-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements (e.g. app-drawer-layout).\n         * This could be done using \\`isolation: isolate\\`, but that's not well supported\n         * across browsers.\n         */\n          position: relative;\n          z-index: 0;\n          padding: env(safe-area-inset-top) env(safe-area-inset-right)\n            env(safe-area-inset-bottom) env(safe-area-inset-left);\n        }\n\n        #wrapper ::slotted([slot=\"header\"]) {\n          @apply --layout-fixed-top;\n          z-index: 1;\n        }\n\n        #wrapper.initializing ::slotted([slot=\"header\"]) {\n          position: relative;\n        }\n\n        :host([has-scrolling-region]) {\n          height: 100%;\n        }\n\n        :host([has-scrolling-region]) #wrapper ::slotted([slot=\"header\"]) {\n          position: absolute;\n        }\n\n        :host([has-scrolling-region])\n          #wrapper.initializing\n          ::slotted([slot=\"header\"]) {\n          position: relative;\n        }\n\n        :host([has-scrolling-region]) #wrapper #contentContainer {\n          @apply --layout-fit;\n          overflow-y: auto;\n          -webkit-overflow-scrolling: touch;\n        }\n\n        :host([has-scrolling-region]) #wrapper.initializing #contentContainer {\n          position: relative;\n        }\n\n        #contentContainer {\n          /* Create a stacking context here so that all children appear below the header. */\n          position: relative;\n          z-index: 0;\n          /* Using 'transform' will cause 'position: fixed' elements to behave like\n           'position: absolute' relative to this element. */\n          transform: translate(0);\n          margin-left: env(safe-area-inset-left);\n          margin-right: env(safe-area-inset-right);\n        }\n\n        @media print {\n          :host([has-scrolling-region]) #wrapper #contentContainer {\n            overflow-y: visible;\n          }\n        }\n      </style>\n\n      <div id=\"wrapper\" class=\"initializing\">\n        <slot id=\"headerSlot\" name=\"header\"></slot>\n\n        <div id=\"contentContainer\"><slot></slot></div>\n        <slot id=\"fab\" name=\"fab\"></slot>\n      </div>\n    `;\n  }\n}\ncustomElements.define(\"ha-app-layout\", HaAppLayout);\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"hui-marquee\")\nclass HuiMarquee extends LitElement {\n  @property() public text?: string;\n\n  @property({ type: Boolean }) public active?: boolean;\n\n  @property({ reflect: true, type: Boolean, attribute: \"animating\" })\n  private _animating = false;\n\n  protected firstUpdated(changedProps) {\n    super.firstUpdated(changedProps);\n\n    // eslint-disable-next-line wc/no-self-class\n    this.addEventListener(\"mouseover\", () => this.classList.add(\"hovering\"), {\n      // Capture because we need to run before a parent sets active on us.\n      // Hovering will disable the overflow, allowing us to calc if we overflow.\n      capture: true,\n    });\n    // eslint-disable-next-line wc/no-self-class\n    this.addEventListener(\"mouseout\", () => this.classList.remove(\"hovering\"));\n  }\n\n  protected updated(changedProperties: PropertyValues): void {\n    super.updated(changedProperties);\n\n    if (changedProperties.has(\"text\") && this._animating) {\n      this._animating = false;\n    }\n\n    if (\n      changedProperties.has(\"active\") &&\n      this.active &&\n      this.offsetWidth < this.scrollWidth\n    ) {\n      this._animating = true;\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.text) {\n      return html``;\n    }\n\n    return html`\n      <div class=\"marquee-inner\" @animationiteration=${this._onIteration}>\n        <span>${this.text}</span>\n        ${this._animating ? html` <span>${this.text}</span> ` : \"\"}\n      </div>\n    `;\n  }\n\n  private _onIteration() {\n    if (!this.active) {\n      this._animating = false;\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: flex;\n        position: relative;\n        align-items: center;\n        height: 1.2em;\n        contain: strict;\n      }\n\n      .marquee-inner {\n        position: absolute;\n        left: 0;\n        right: 0;\n        text-overflow: ellipsis;\n        overflow: hidden;\n      }\n\n      :host(.hovering) .marquee-inner {\n        text-overflow: initial;\n        overflow: initial;\n      }\n\n      :host([animating]) .marquee-inner {\n        left: initial;\n        right: initial;\n        animation: marquee 10s linear infinite;\n      }\n\n      :host([animating]) .marquee-inner span {\n        padding-right: 16px;\n      }\n\n      @keyframes marquee {\n        0% {\n          transform: translateX(0%);\n        }\n        100% {\n          transform: translateX(-50%);\n        }\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-marquee\": HuiMarquee;\n  }\n}\n","import \"@material/mwc-button/mwc-button\";\nimport \"@material/mwc-linear-progress/mwc-linear-progress\";\nimport type { LinearProgress } from \"@material/mwc-linear-progress/mwc-linear-progress\";\nimport \"@material/mwc-list/mwc-list-item\";\nimport {\n  mdiChevronDown,\n  mdiMonitor,\n  mdiPause,\n  mdiPlay,\n  mdiPlayPause,\n  mdiStop,\n  mdiVolumeHigh,\n} from \"@mdi/js\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { until } from \"lit/directives/until\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { domainIcon } from \"../../common/entity/domain_icon\";\nimport { supportsFeature } from \"../../common/entity/supports-feature\";\nimport \"../../components/ha-button-menu\";\nimport \"../../components/ha-circular-progress\";\nimport \"../../components/ha-icon-button\";\nimport { UNAVAILABLE } from \"../../data/entity\";\nimport { subscribeEntityRegistry } from \"../../data/entity_registry\";\nimport {\n  BROWSER_PLAYER,\n  cleanupMediaTitle,\n  computeMediaControls,\n  computeMediaDescription,\n  ControlButton,\n  formatMediaTime,\n  getCurrentProgress,\n  handleMediaControlClick,\n  MediaPlayerEntity,\n  MediaPlayerItem,\n  setMediaPlayerVolume,\n  SUPPORT_BROWSE_MEDIA,\n  SUPPORT_PAUSE,\n  SUPPORT_PLAY,\n  SUPPORT_STOP,\n  SUPPORT_VOLUME_SET,\n} from \"../../data/media-player\";\nimport { ResolvedMediaSource } from \"../../data/media_source\";\nimport { showAlertDialog } from \"../../dialogs/generic/show-dialog-box\";\nimport { SubscribeMixin } from \"../../mixins/subscribe-mixin\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"../lovelace/components/hui-marquee\";\nimport {\n  BrowserMediaPlayer,\n  ERR_UNSUPPORTED_MEDIA,\n} from \"./browser-media-player\";\n\ndeclare global {\n  interface HASSDomEvents {\n    \"player-picked\": { entityId: string };\n  }\n}\n\n@customElement(\"ha-bar-media-player\")\nexport class BarMediaPlayer extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public entityId!: string;\n\n  @property({ type: Boolean, reflect: true })\n  public narrow!: boolean;\n\n  @query(\"mwc-linear-progress\") private _progressBar?: LinearProgress;\n\n  @query(\"#CurrentProgress\") private _currentProgress?: HTMLElement;\n\n  @state() private _marqueeActive = false;\n\n  @state() private _newMediaExpected = false;\n\n  @state() private _browserPlayer?: BrowserMediaPlayer;\n\n  @state()\n  private _hiddenEntities = new Set<string>();\n\n  private _progressInterval?: number;\n\n  private _browserPlayerVolume = 0.8;\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n\n    const stateObj = this._stateObj;\n\n    if (!stateObj) {\n      return;\n    }\n\n    if (\n      !this._progressInterval &&\n      this._showProgressBar &&\n      stateObj.state === \"playing\"\n    ) {\n      this._progressInterval = window.setInterval(\n        () => this._updateProgressBar(),\n        1000\n      );\n    }\n  }\n\n  public disconnectedCallback(): void {\n    if (this._progressInterval) {\n      clearInterval(this._progressInterval);\n      this._progressInterval = undefined;\n    }\n    this._tearDownBrowserPlayer();\n  }\n\n  public showResolvingNewMediaPicked() {\n    this._tearDownBrowserPlayer();\n    this._newMediaExpected = true;\n  }\n\n  public hideResolvingNewMediaPicked() {\n    this._newMediaExpected = false;\n  }\n\n  public playItem(item: MediaPlayerItem, resolved: ResolvedMediaSource) {\n    if (this.entityId !== BROWSER_PLAYER) {\n      throw Error(\"Only browser supported\");\n    }\n    this._tearDownBrowserPlayer();\n    try {\n      this._browserPlayer = new BrowserMediaPlayer(\n        this.hass,\n        item,\n        resolved,\n        this._browserPlayerVolume,\n        () => this.requestUpdate(\"_browserPlayer\")\n      );\n    } catch (err: any) {\n      if (err.message === ERR_UNSUPPORTED_MEDIA) {\n        showAlertDialog(this, {\n          text: this.hass.localize(\n            \"ui.components.media-browser.media_not_supported\"\n          ),\n        });\n      } else {\n        throw err;\n      }\n    }\n    this._newMediaExpected = false;\n  }\n\n  protected render(): TemplateResult {\n    if (this._newMediaExpected) {\n      return html`\n        <div class=\"controls-progress\">\n          ${until(\n            // Only show spinner after 500ms\n            new Promise((resolve) => setTimeout(resolve, 500)).then(\n              () => html`<ha-circular-progress active></ha-circular-progress>`\n            )\n          )}\n        </div>\n      `;\n    }\n\n    const isBrowser = this.entityId === BROWSER_PLAYER;\n    const stateObj = this._stateObj;\n\n    if (!stateObj) {\n      return this._renderChoosePlayer(stateObj);\n    }\n\n    const controls: ControlButton[] | undefined = !this.narrow\n      ? computeMediaControls(stateObj, true)\n      : (stateObj.state === \"playing\" &&\n          (supportsFeature(stateObj, SUPPORT_PAUSE) ||\n            supportsFeature(stateObj, SUPPORT_STOP))) ||\n        ((stateObj.state === \"paused\" || stateObj.state === \"idle\") &&\n          supportsFeature(stateObj, SUPPORT_PLAY)) ||\n        (stateObj.state === \"on\" &&\n          (supportsFeature(stateObj, SUPPORT_PLAY) ||\n            supportsFeature(stateObj, SUPPORT_PAUSE)))\n      ? [\n          {\n            icon:\n              stateObj.state === \"on\"\n                ? mdiPlayPause\n                : stateObj.state !== \"playing\"\n                ? mdiPlay\n                : supportsFeature(stateObj, SUPPORT_PAUSE)\n                ? mdiPause\n                : mdiStop,\n            action:\n              stateObj.state !== \"playing\"\n                ? \"media_play\"\n                : supportsFeature(stateObj, SUPPORT_PAUSE)\n                ? \"media_pause\"\n                : \"media_stop\",\n          },\n        ]\n      : undefined;\n    const mediaDescription = computeMediaDescription(stateObj);\n    const mediaDuration = formatMediaTime(stateObj.attributes.media_duration);\n    const mediaTitleClean = cleanupMediaTitle(\n      stateObj.attributes.media_title || \"\"\n    );\n    const mediaArt =\n      stateObj.attributes.entity_picture_local ||\n      stateObj.attributes.entity_picture;\n\n    return html`\n      <div\n        class=${classMap({\n          info: true,\n          pointer: !isBrowser,\n          app: this._browserPlayer?.item.media_class === \"app\",\n        })}\n        @click=${this._openMoreInfo}\n      >\n        ${mediaArt ? html`<img src=${this.hass.hassUrl(mediaArt)} />` : \"\"}\n        <div class=\"media-info\">\n          <hui-marquee\n            .text=${mediaTitleClean ||\n            mediaDescription ||\n            cleanupMediaTitle(stateObj.attributes.media_content_id) ||\n            (stateObj.state !== \"playing\" && stateObj.state !== \"on\"\n              ? this.hass.localize(`ui.card.media_player.nothing_playing`)\n              : \"\")}\n            .active=${this._marqueeActive}\n            @mouseover=${this._marqueeMouseOver}\n            @mouseleave=${this._marqueeMouseLeave}\n          ></hui-marquee>\n          <span class=\"secondary\">\n            ${mediaTitleClean ? mediaDescription : \"\"}\n          </span>\n        </div>\n      </div>\n      <div class=\"controls-progress\">\n        ${this._browserPlayer?.buffering\n          ? html` <ha-circular-progress active></ha-circular-progress> `\n          : html`\n              <div class=\"controls\">\n                ${controls === undefined\n                  ? \"\"\n                  : controls.map(\n                      (control) => html`\n                        <ha-icon-button\n                          .label=${this.hass.localize(\n                            `ui.card.media_player.${control.action}`\n                          )}\n                          .path=${control.icon}\n                          action=${control.action}\n                          @click=${this._handleControlClick}\n                        >\n                        </ha-icon-button>\n                      `\n                    )}\n              </div>\n              ${stateObj.attributes.media_duration === Infinity\n                ? html``\n                : this.narrow\n                ? html`<mwc-linear-progress></mwc-linear-progress>`\n                : html`\n                    <div class=\"progress\">\n                      <div id=\"CurrentProgress\"></div>\n                      <mwc-linear-progress wide></mwc-linear-progress>\n                      <div>${mediaDuration}</div>\n                    </div>\n                  `}\n            `}\n      </div>\n      ${this._renderChoosePlayer(stateObj)}\n    `;\n  }\n\n  private _renderChoosePlayer(stateObj: MediaPlayerEntity | undefined) {\n    const isBrowser = this.entityId === BROWSER_PLAYER;\n    return html`\n    <div class=\"choose-player ${isBrowser ? \"browser\" : \"\"}\">\n      ${\n        !this.narrow &&\n        stateObj &&\n        supportsFeature(stateObj, SUPPORT_VOLUME_SET)\n          ? html`\n              <ha-button-menu corner=\"BOTTOM_START\" y=\"0\" x=\"76\">\n                <ha-icon-button\n                  slot=\"trigger\"\n                  .path=${mdiVolumeHigh}\n                ></ha-icon-button>\n                <ha-slider\n                  min=\"0\"\n                  max=\"100\"\n                  step=\"1\"\n                  .value=${stateObj.attributes.volume_level! * 100}\n                  @change=${this._handleVolumeChange}\n                >\n                </ha-slider>\n              </ha-button-menu>\n            `\n          : \"\"\n      }\n\n          <ha-button-menu corner=\"BOTTOM_START\">\n            ${\n              this.narrow\n                ? html`\n                    <ha-icon-button\n                      slot=\"trigger\"\n                      .path=${isBrowser\n                        ? mdiMonitor\n                        : domainIcon(computeDomain(this.entityId), stateObj)}\n                    ></ha-icon-button>\n                  `\n                : html`\n                    <mwc-button\n                      slot=\"trigger\"\n                      .label=${this.narrow\n                        ? \"\"\n                        : `${\n                            stateObj\n                              ? computeStateName(stateObj)\n                              : this.entityId\n                          }\n                `}\n                    >\n                      <ha-svg-icon\n                        slot=\"icon\"\n                        .path=${isBrowser\n                          ? mdiMonitor\n                          : domainIcon(computeDomain(this.entityId), stateObj)}\n                      ></ha-svg-icon>\n                      <ha-svg-icon\n                        slot=\"trailingIcon\"\n                        .path=${mdiChevronDown}\n                      ></ha-svg-icon>\n                    </mwc-button>\n                  `\n            }\n            <mwc-list-item\n              .player=${BROWSER_PLAYER}\n              ?selected=${isBrowser}\n              @click=${this._selectPlayer}\n            >\n              ${this.hass.localize(\"ui.components.media-browser.web-browser\")}\n            </mwc-list-item>\n            ${this._mediaPlayerEntities.map(\n              (source) => html`\n                <mwc-list-item\n                  ?selected=${source.entity_id === this.entityId}\n                  .disabled=${source.state === UNAVAILABLE}\n                  .player=${source.entity_id}\n                  @click=${this._selectPlayer}\n                >\n                  ${computeStateName(source)}\n                </mwc-list-item>\n              `\n            )}\n          </ha-button-menu>\n        </div>\n      </div>\n\n    `;\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    super.willUpdate(changedProps);\n    if (changedProps.has(\"entityId\")) {\n      this._tearDownBrowserPlayer();\n    }\n    if (!changedProps.has(\"hass\") || this.entityId === BROWSER_PLAYER) {\n      return;\n    }\n    // Reset new media expected if media player state changes\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    if (\n      !oldHass ||\n      oldHass.states[this.entityId] !== this.hass.states[this.entityId]\n    ) {\n      this._newMediaExpected = false;\n    }\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    super.updated(changedProps);\n\n    if (this.entityId === BROWSER_PLAYER) {\n      if (!changedProps.has(\"_browserPlayer\")) {\n        return;\n      }\n    } else {\n      const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n      if (oldHass && oldHass.states[this.entityId] === this._stateObj) {\n        return;\n      }\n    }\n\n    const stateObj = this._stateObj;\n\n    this._updateProgressBar();\n\n    if (\n      !this._progressInterval &&\n      this._showProgressBar &&\n      stateObj?.state === \"playing\"\n    ) {\n      this._progressInterval = window.setInterval(\n        () => this._updateProgressBar(),\n        1000\n      );\n    } else if (\n      this._progressInterval &&\n      (!this._showProgressBar || stateObj?.state !== \"playing\")\n    ) {\n      clearInterval(this._progressInterval);\n      this._progressInterval = undefined;\n    }\n  }\n\n  private get _stateObj(): MediaPlayerEntity | undefined {\n    if (this.entityId === BROWSER_PLAYER) {\n      return this._browserPlayer\n        ? this._browserPlayer.toStateObj()\n        : BrowserMediaPlayer.idleStateObj();\n    }\n    return this.hass!.states[this.entityId] as MediaPlayerEntity | undefined;\n  }\n\n  private _tearDownBrowserPlayer() {\n    if (this._browserPlayer) {\n      this._browserPlayer.remove();\n      this._browserPlayer = undefined;\n    }\n  }\n\n  private _openMoreInfo() {\n    if (this._browserPlayer) {\n      return;\n    }\n    fireEvent(this, \"hass-more-info\", { entityId: this.entityId });\n  }\n\n  private get _showProgressBar() {\n    if (!this.hass) {\n      return false;\n    }\n\n    const stateObj = this._stateObj;\n\n    return (\n      stateObj &&\n      (stateObj.state === \"playing\" || stateObj.state === \"paused\") &&\n      \"media_duration\" in stateObj.attributes &&\n      \"media_position\" in stateObj.attributes\n    );\n  }\n\n  private get _mediaPlayerEntities() {\n    return Object.values(this.hass!.states).filter(\n      (entity) =>\n        computeStateDomain(entity) === \"media_player\" &&\n        supportsFeature(entity, SUPPORT_BROWSE_MEDIA) &&\n        !this._hiddenEntities.has(entity.entity_id)\n    );\n  }\n\n  private _updateProgressBar(): void {\n    const stateObj = this._stateObj;\n\n    if (!this._progressBar || !this._currentProgress || !stateObj) {\n      return;\n    }\n\n    if (!stateObj.attributes.media_duration) {\n      this._progressBar.progress = 0;\n      this._currentProgress.innerHTML = \"\";\n      return;\n    }\n\n    const currentProgress = getCurrentProgress(stateObj);\n    this._progressBar.progress =\n      currentProgress / stateObj.attributes.media_duration;\n\n    if (this._currentProgress) {\n      this._currentProgress.innerHTML = formatMediaTime(currentProgress);\n    }\n  }\n\n  protected override hassSubscribe(): (\n    | UnsubscribeFunc\n    | Promise<UnsubscribeFunc>\n  )[] {\n    return [\n      subscribeEntityRegistry(this.hass.connection, (entries) => {\n        const hiddenEntities = new Set<string>();\n\n        for (const entry of entries) {\n          if (\n            entry.hidden_by &&\n            computeDomain(entry.entity_id) === \"media_player\"\n          ) {\n            hiddenEntities.add(entry.entity_id);\n          }\n        }\n\n        this._hiddenEntities = hiddenEntities;\n      }),\n    ];\n  }\n\n  private _handleControlClick(e: MouseEvent): void {\n    const action = (e.currentTarget! as HTMLElement).getAttribute(\"action\")!;\n\n    if (!this._browserPlayer) {\n      handleMediaControlClick(\n        this.hass!,\n        this._stateObj!,\n        (e.currentTarget as HTMLElement).getAttribute(\"action\")!\n      );\n      return;\n    }\n    if (action === \"media_pause\") {\n      this._browserPlayer.pause();\n    } else if (action === \"media_play\") {\n      this._browserPlayer.play();\n    }\n  }\n\n  private _marqueeMouseOver(): void {\n    if (!this._marqueeActive) {\n      this._marqueeActive = true;\n    }\n  }\n\n  private _marqueeMouseLeave(): void {\n    if (this._marqueeActive) {\n      this._marqueeActive = false;\n    }\n  }\n\n  private _selectPlayer(ev: CustomEvent): void {\n    const entityId = (ev.currentTarget as any).player;\n    fireEvent(this, \"player-picked\", { entityId });\n  }\n\n  private async _handleVolumeChange(ev) {\n    ev.stopPropagation();\n    const value = Number(ev.target.value) / 100;\n    if (this._browserPlayer) {\n      this._browserPlayerVolume = value;\n      this._browserPlayer.setVolume(value);\n    } else {\n      await setMediaPlayerVolume(this.hass, this.entityId, value);\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: flex;\n        min-height: 100px;\n        background: var(\n          --ha-card-background,\n          var(--card-background-color, white)\n        );\n        border-top: 1px solid var(--divider-color);\n        padding-bottom: env(safe-area-inset-bottom);\n      }\n\n      mwc-linear-progress {\n        width: 100%;\n        padding: 0 4px;\n        --mdc-theme-primary: var(--secondary-text-color);\n      }\n\n      mwc-button[slot=\"trigger\"] {\n        --mdc-theme-primary: var(--primary-text-color);\n        --mdc-icon-size: 36px;\n      }\n\n      .info {\n        flex: 1;\n        display: flex;\n        align-items: center;\n        width: 100%;\n        margin-right: 16px;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        overflow: hidden;\n      }\n\n      .pointer {\n        cursor: pointer;\n      }\n\n      .secondary,\n      .progress {\n        color: var(--secondary-text-color);\n      }\n\n      .choose-player {\n        flex: 1;\n        display: flex;\n        justify-content: flex-end;\n        align-items: center;\n        padding: 16px;\n      }\n\n      .controls {\n        height: 48px;\n        padding-bottom: 4px;\n      }\n\n      .controls-progress {\n        flex: 2;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-direction: column;\n        direction: ltr;\n      }\n\n      .progress {\n        display: flex;\n        width: 100%;\n        align-items: center;\n      }\n\n      mwc-linear-progress[wide] {\n        margin: 0 4px;\n      }\n\n      .media-info {\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        overflow: hidden;\n        padding-left: 16px;\n        width: 100%;\n      }\n\n      hui-marquee {\n        font-size: 1.2em;\n        margin: 0px 0 4px;\n      }\n\n      img {\n        max-height: 100px;\n        max-width: 100px;\n      }\n\n      .app img {\n        max-height: 68px;\n        margin: 16px 0 16px 16px;\n      }\n\n      ha-button-menu mwc-button {\n        line-height: 1;\n      }\n\n      :host([narrow]) {\n        min-height: 56px;\n        max-height: 56px;\n      }\n\n      :host([narrow]) .controls-progress {\n        flex: unset;\n        min-width: 48px;\n      }\n\n      :host([narrow]) .media-info {\n        padding-left: 8px;\n      }\n\n      :host([narrow]) .controls {\n        display: flex;\n        padding-bottom: 0;\n        --mdc-icon-size: 30px;\n      }\n\n      :host([narrow]) .choose-player {\n        padding-left: 0;\n        padding-right: 8px;\n        min-width: 48px;\n        flex: unset;\n        justify-content: center;\n      }\n\n      :host([narrow]) .choose-player.browser {\n        justify-content: flex-end;\n      }\n\n      :host([narrow]) img {\n        max-height: 56px;\n        max-width: 56px;\n      }\n\n      :host([narrow]) .blank-image {\n        height: 56px;\n        width: 56px;\n      }\n\n      :host([narrow]) mwc-linear-progress {\n        padding: 0;\n        position: absolute;\n        top: -4px;\n        left: 0;\n      }\n\n      mwc-list-item[selected] {\n        font-weight: bold;\n      }\n\n      ha-svg-icon[slot=\"icon\"] {\n        margin-inline-start: 8px !important;\n        margin-inline-end: 8px !important;\n        direction: var(--direction);\n      }\n      ha-svg-icon[slot=\"trailingIcon\"] {\n        margin-inline-start: 8px !important;\n        margin-inline-end: 0px !important;\n        direction: var(--direction);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-bar-media-player\": BarMediaPlayer;\n  }\n}\n","import { mdiArrowLeft } from \"@mdi/js\";\nimport \"@polymer/app-layout/app-header/app-header\";\nimport \"@polymer/app-layout/app-toolbar/app-toolbar\";\nimport \"@material/mwc-button\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { LocalStorage } from \"../../common/decorators/local-storage\";\nimport { fireEvent, HASSDomEvent } from \"../../common/dom/fire_event\";\nimport { navigate } from \"../../common/navigate\";\nimport \"../../components/ha-menu-button\";\nimport \"../../components/ha-icon-button\";\nimport \"../../components/ha-icon-button-arrow-prev\";\nimport \"../../components/media-player/ha-media-player-browse\";\nimport \"../../components/media-player/ha-media-manage-button\";\nimport type {\n  HaMediaPlayerBrowse,\n  MediaPlayerItemId,\n} from \"../../components/media-player/ha-media-player-browse\";\nimport {\n  BROWSER_PLAYER,\n  MediaPickedEvent,\n  MediaPlayerItem,\n  mediaPlayerPlayMedia,\n} from \"../../data/media-player\";\nimport {\n  ResolvedMediaSource,\n  resolveMediaSource,\n} from \"../../data/media_source\";\nimport \"../../layouts/ha-app-layout\";\nimport { haStyle } from \"../../resources/styles\";\nimport type { HomeAssistant, Route } from \"../../types\";\nimport \"./ha-bar-media-player\";\nimport type { BarMediaPlayer } from \"./ha-bar-media-player\";\nimport { showWebBrowserPlayMediaDialog } from \"./show-media-player-dialog\";\nimport { showAlertDialog } from \"../../dialogs/generic/show-dialog-box\";\nimport {\n  getEntityIdFromCameraMediaSource,\n  isCameraMediaSource,\n} from \"../../data/camera\";\n\nconst createMediaPanelUrl = (entityId: string, items: MediaPlayerItemId[]) => {\n  let path = `/media-browser/${entityId}`;\n  for (const item of items.slice(1)) {\n    path +=\n      \"/\" +\n      encodeURIComponent(`${item.media_content_type},${item.media_content_id}`);\n  }\n  return path;\n};\n\n@customElement(\"ha-panel-media-browser\")\nclass PanelMediaBrowser extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean, reflect: true })\n  public narrow!: boolean;\n\n  @property() public route!: Route;\n\n  @state() _currentItem?: MediaPlayerItem;\n\n  private _navigateIds: MediaPlayerItemId[] = [\n    {\n      media_content_id: undefined,\n      media_content_type: undefined,\n    },\n  ];\n\n  @LocalStorage(\"mediaBrowseEntityId\", true, false)\n  private _entityId = BROWSER_PLAYER;\n\n  @query(\"ha-media-player-browse\") private _browser!: HaMediaPlayerBrowse;\n\n  @query(\"ha-bar-media-player\") private _player!: BarMediaPlayer;\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-app-layout>\n        <app-header fixed slot=\"header\">\n          <app-toolbar>\n            ${this._navigateIds.length > 1\n              ? html`\n                  <ha-icon-button-arrow-prev\n                    .path=${mdiArrowLeft}\n                    @click=${this._goBack}\n                  ></ha-icon-button-arrow-prev>\n                `\n              : html`\n                  <ha-menu-button\n                    .hass=${this.hass}\n                    .narrow=${this.narrow}\n                  ></ha-menu-button>\n                `}\n            <div main-title>\n              ${!this._currentItem\n                ? this.hass.localize(\n                    \"ui.components.media-browser.media-player-browser\"\n                  )\n                : this._currentItem.title}\n            </div>\n            <ha-media-manage-button\n              .hass=${this.hass}\n              .currentItem=${this._currentItem}\n              @media-refresh=${this._refreshMedia}\n            ></ha-media-manage-button>\n          </app-toolbar>\n        </app-header>\n        <ha-media-player-browse\n          .hass=${this.hass}\n          .entityId=${this._entityId}\n          .navigateIds=${this._navigateIds}\n          @media-picked=${this._mediaPicked}\n          @media-browsed=${this._mediaBrowsed}\n        ></ha-media-player-browse>\n      </ha-app-layout>\n      <ha-bar-media-player\n        .hass=${this.hass}\n        .entityId=${this._entityId}\n        .narrow=${this.narrow}\n        @player-picked=${this._playerPicked}\n      ></ha-bar-media-player>\n    `;\n  }\n\n  public willUpdate(changedProps: PropertyValues): void {\n    super.willUpdate(changedProps);\n\n    if (!changedProps.has(\"route\")) {\n      return;\n    }\n\n    if (this.route.path === \"\") {\n      navigate(`/media-browser/${this._entityId}`, { replace: true });\n      return;\n    }\n\n    const [routePlayer, ...navigateIdsEncoded] = this.route.path\n      .substring(1)\n      .split(\"/\");\n\n    if (routePlayer !== this._entityId) {\n      // Detect if picked player doesn't exist (anymore)\n      // Can happen if URL bookmarked or stored in local storage\n      if (\n        routePlayer !== BROWSER_PLAYER &&\n        this.hass.states[routePlayer] === undefined\n      ) {\n        navigate(`/media-browser/${BROWSER_PLAYER}`, { replace: true });\n        showAlertDialog(this, {\n          text: this.hass.localize(\n            \"ui.panel.media-browser.error.player_not_exist\",\n            {\n              name: routePlayer,\n            }\n          ),\n        });\n        return;\n      }\n      this._entityId = routePlayer;\n    }\n\n    this._navigateIds = [\n      {\n        media_content_type: undefined,\n        media_content_id: undefined,\n      },\n      ...navigateIdsEncoded.map((navigateId) => {\n        const decoded = decodeURIComponent(navigateId);\n        // Don't use split because media_content_id could contain commas\n        const delimiter = decoded.indexOf(\",\");\n        return {\n          media_content_type: decoded.substring(0, delimiter),\n          media_content_id: decoded.substring(delimiter + 1),\n        };\n      }),\n    ];\n    this._currentItem = undefined;\n  }\n\n  private _goBack() {\n    navigate(\n      createMediaPanelUrl(this._entityId, this._navigateIds.slice(0, -1))\n    );\n  }\n\n  private _mediaBrowsed(ev: { detail: HASSDomEvents[\"media-browsed\"] }) {\n    if (ev.detail.ids === this._navigateIds) {\n      this._currentItem = ev.detail.current;\n      return;\n    }\n\n    navigate(createMediaPanelUrl(this._entityId, ev.detail.ids), {\n      replace: ev.detail.replace,\n    });\n  }\n\n  private async _mediaPicked(\n    ev: HASSDomEvent<MediaPickedEvent>\n  ): Promise<void> {\n    const item = ev.detail.item;\n\n    if (this._entityId !== BROWSER_PLAYER) {\n      this._player.showResolvingNewMediaPicked();\n      try {\n        await mediaPlayerPlayMedia(\n          this.hass,\n          this._entityId,\n          item.media_content_id,\n          item.media_content_type\n        );\n      } catch (err) {\n        this._player.hideResolvingNewMediaPicked();\n      }\n      return;\n    }\n\n    // We won't cancel current media being played if we're going to\n    // open a camera.\n    if (isCameraMediaSource(item.media_content_id)) {\n      fireEvent(this, \"hass-more-info\", {\n        entityId: getEntityIdFromCameraMediaSource(item.media_content_id),\n      });\n      return;\n    }\n\n    this._player.showResolvingNewMediaPicked();\n    let resolvedUrl: ResolvedMediaSource;\n    try {\n      resolvedUrl = await resolveMediaSource(this.hass, item.media_content_id);\n    } catch (err: any) {\n      showAlertDialog(this, {\n        title: this.hass.localize(\n          \"ui.components.media-browser.media_browsing_error\"\n        ),\n        text: err.message,\n      });\n      this._player.hideResolvingNewMediaPicked();\n      return;\n    }\n\n    if (resolvedUrl.mime_type.startsWith(\"audio/\")) {\n      this._player.playItem(item, resolvedUrl);\n      return;\n    }\n\n    showWebBrowserPlayMediaDialog(this, {\n      sourceUrl: resolvedUrl.url,\n      sourceType: resolvedUrl.mime_type,\n      title: item.title,\n      can_play: item.can_play,\n    });\n    this._player.hideResolvingNewMediaPicked();\n  }\n\n  private _playerPicked(ev) {\n    const entityId: string = ev.detail.entityId;\n    if (entityId === this._entityId) {\n      return;\n    }\n    navigate(createMediaPanelUrl(entityId, this._navigateIds));\n  }\n\n  private _refreshMedia() {\n    this._browser.refresh();\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyle,\n      css`\n        app-toolbar {\n          --mdc-theme-primary: var(--app-header-text-color);\n        }\n\n        ha-media-player-browse {\n          height: calc(100vh - (100px + var(--header-height)));\n          direction: ltr;\n        }\n\n        :host([narrow]) ha-media-player-browse {\n          height: calc(100vh - (80px + var(--header-height)));\n        }\n\n        ha-bar-media-player {\n          position: absolute;\n          bottom: 0;\n          left: 0;\n          right: 0;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-panel-media-browser\": PanelMediaBrowser;\n  }\n}\n"],"names":[],"sourceRoot":""}