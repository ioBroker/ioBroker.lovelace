{"version":3,"file":"d02f1270.js","mappings":";;;AAwDA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAvCA;AC+DA;AAKA;AAGA;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAOA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;AA3FA;AC8CA;;AAGA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AAlEA;;AC2KA;AAaA;;AAIA;;;AAIA;AACA;;AAEA;;;AAMA;AACA;AACA;AACA;;;AAQA;;AAGA;AAKA;;AAKA;;;;;;;;;AAjNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA","sources":["webpack://home-assistant-frontend/./src/components/ha-web-rtc-player.ts","webpack://home-assistant-frontend/./src/components/ha-camera-stream.ts","webpack://home-assistant-frontend/./src/components/ha-hls-player.ts","webpack://home-assistant-frontend/./src/panels/lovelace/components/hui-image.ts"],"sourcesContent":["import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state, query } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../common/config/is_component_loaded\";\nimport { handleWebRtcOffer, WebRtcAnswer } from \"../data/camera\";\nimport { fetchWebRtcSettings } from \"../data/rtsp_to_webrtc\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-alert\";\n\n/**\n * A WebRTC stream is established by first sending an offer through a signal\n * path via an integration. An answer is returned, then the rest of the stream\n * is handled entirely client side.\n */\n@customElement(\"ha-web-rtc-player\")\nclass HaWebRtcPlayer extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public entityid!: string;\n\n  @property({ type: Boolean, attribute: \"controls\" })\n  public controls = false;\n\n  @property({ type: Boolean, attribute: \"muted\" })\n  public muted = false;\n\n  @property({ type: Boolean, attribute: \"autoplay\" })\n  public autoPlay = false;\n\n  @property({ type: Boolean, attribute: \"playsinline\" })\n  public playsInline = false;\n\n  @property() public posterUrl!: string;\n\n  @state() private _error?: string;\n\n  // don't cache this, as we remove it on disconnects\n  @query(\"#remote-stream\") private _videoEl!: HTMLVideoElement;\n\n  private _peerConnection?: RTCPeerConnection;\n\n  private _remoteStream?: MediaStream;\n\n  protected override render(): TemplateResult {\n    if (this._error) {\n      return html`<ha-alert alert-type=\"error\">${this._error}</ha-alert>`;\n    }\n    return html`\n      <video\n        id=\"remote-stream\"\n        ?autoplay=${this.autoPlay}\n        .muted=${this.muted}\n        ?playsinline=${this.playsInline}\n        ?controls=${this.controls}\n        .poster=${this.posterUrl}\n      ></video>\n    `;\n  }\n\n  public override connectedCallback() {\n    super.connectedCallback();\n    if (this.hasUpdated) {\n      this._startWebRtc();\n    }\n  }\n\n  public override disconnectedCallback() {\n    super.disconnectedCallback();\n    this._cleanUp();\n  }\n\n  protected override updated(changedProperties: PropertyValues<this>) {\n    if (!changedProperties.has(\"entityid\")) {\n      return;\n    }\n    if (!this._videoEl) {\n      return;\n    }\n    this._startWebRtc();\n  }\n\n  private async _startWebRtc(): Promise<void> {\n    this._error = undefined;\n\n    const configuration = await this._fetchPeerConfiguration();\n    const peerConnection = new RTCPeerConnection(configuration);\n    // Some cameras (such as nest) require a data channel to establish a stream\n    // however, not used by any integrations.\n    peerConnection.createDataChannel(\"dataSendChannel\");\n    peerConnection.addTransceiver(\"audio\", { direction: \"recvonly\" });\n    peerConnection.addTransceiver(\"video\", { direction: \"recvonly\" });\n\n    const offerOptions: RTCOfferOptions = {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true,\n    };\n    const offer: RTCSessionDescriptionInit = await peerConnection.createOffer(\n      offerOptions\n    );\n    await peerConnection.setLocalDescription(offer);\n\n    let candidates = \"\"; // Build an Offer SDP string with ice candidates\n    const iceResolver = new Promise<void>((resolve) => {\n      peerConnection.addEventListener(\"icecandidate\", async (event) => {\n        if (!event.candidate) {\n          resolve(); // Gathering complete\n          return;\n        }\n        candidates += `a=${event.candidate.candidate}\\r\\n`;\n      });\n    });\n    await iceResolver;\n    const offer_sdp = offer.sdp! + candidates;\n\n    let webRtcAnswer: WebRtcAnswer;\n    try {\n      webRtcAnswer = await handleWebRtcOffer(\n        this.hass,\n        this.entityid,\n        offer_sdp\n      );\n    } catch (err: any) {\n      this._error = \"Failed to start WebRTC stream: \" + err.message;\n      peerConnection.close();\n      return;\n    }\n\n    // Setup callbacks to render remote stream once media tracks are discovered.\n    const remoteStream = new MediaStream();\n    peerConnection.addEventListener(\"track\", (event) => {\n      remoteStream.addTrack(event.track);\n      this._videoEl.srcObject = remoteStream;\n    });\n    this._remoteStream = remoteStream;\n\n    // Initiate the stream with the remote device\n    const remoteDesc = new RTCSessionDescription({\n      type: \"answer\",\n      sdp: webRtcAnswer.answer,\n    });\n    try {\n      await peerConnection.setRemoteDescription(remoteDesc);\n    } catch (err: any) {\n      this._error = \"Failed to connect WebRTC stream: \" + err.message;\n      peerConnection.close();\n      return;\n    }\n    this._peerConnection = peerConnection;\n  }\n\n  private async _fetchPeerConfiguration(): Promise<RTCConfiguration> {\n    if (!isComponentLoaded(this.hass!, \"rtsp_to_webrtc\")) {\n      return {};\n    }\n    const settings = await fetchWebRtcSettings(this.hass!);\n    if (!settings || !settings.stun_server) {\n      return {};\n    }\n    return {\n      iceServers: [\n        {\n          urls: [`stun:${settings.stun_server!}`],\n        },\n      ],\n    };\n  }\n\n  private _cleanUp() {\n    if (this._remoteStream) {\n      this._remoteStream.getTracks().forEach((track) => {\n        track.stop();\n      });\n      this._remoteStream = undefined;\n    }\n    if (this._videoEl) {\n      this._videoEl.removeAttribute(\"src\");\n      this._videoEl.load();\n    }\n    if (this._peerConnection) {\n      this._peerConnection.close();\n      this._peerConnection = undefined;\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host,\n      video {\n        display: block;\n      }\n\n      video {\n        width: 100%;\n        max-height: var(--video-max-height, calc(100vh - 97px));\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-web-rtc-player\": HaWebRtcPlayer;\n  }\n}\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../common/config/is_component_loaded\";\nimport { computeStateName } from \"../common/entity/compute_state_name\";\nimport { supportsFeature } from \"../common/entity/supports-feature\";\nimport {\n  CameraEntity,\n  CAMERA_SUPPORT_STREAM,\n  computeMJPEGStreamUrl,\n  fetchStreamUrl,\n  fetchThumbnailUrlWithCache,\n  STREAM_TYPE_HLS,\n  STREAM_TYPE_WEB_RTC,\n} from \"../data/camera\";\nimport { HomeAssistant } from \"../types\";\nimport \"./ha-hls-player\";\nimport \"./ha-web-rtc-player\";\n\n@customElement(\"ha-camera-stream\")\nclass HaCameraStream extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ attribute: false }) public stateObj?: CameraEntity;\n\n  @property({ type: Boolean, attribute: \"controls\" })\n  public controls = false;\n\n  @property({ type: Boolean, attribute: \"muted\" })\n  public muted = false;\n\n  @property({ type: Boolean, attribute: \"allow-exoplayer\" })\n  public allowExoPlayer = false;\n\n  // Video background image before its loaded\n  @state() private _posterUrl?: string;\n\n  // We keep track if we should force MJPEG if there was a failure\n  // to get the HLS stream url. This is reset if we change entities.\n  @state() private _forceMJPEG?: string;\n\n  @state() private _url?: string;\n\n  @state() private _connected = false;\n\n  public willUpdate(changedProps: PropertyValues): void {\n    if (\n      changedProps.has(\"stateObj\") &&\n      !this._shouldRenderMJPEG &&\n      this.stateObj &&\n      (changedProps.get(\"stateObj\") as CameraEntity | undefined)?.entity_id !==\n        this.stateObj.entity_id\n    ) {\n      this._getPosterUrl();\n      if (this.stateObj!.attributes.frontend_stream_type === STREAM_TYPE_HLS) {\n        this._forceMJPEG = undefined;\n        this._url = undefined;\n        this._getStreamUrl();\n      }\n    }\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    this._connected = true;\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    this._connected = false;\n  }\n\n  protected render(): TemplateResult {\n    if (!this.stateObj) {\n      return html``;\n    }\n    if (__DEMO__ || this._shouldRenderMJPEG) {\n      return html` <img\n        .src=${__DEMO__\n          ? this.stateObj.attributes.entity_picture!\n          : this._connected\n          ? computeMJPEGStreamUrl(this.stateObj)\n          : \"\"}\n        .alt=${`Preview of the ${computeStateName(this.stateObj)} camera.`}\n      />`;\n    }\n    if (this.stateObj.attributes.frontend_stream_type === STREAM_TYPE_HLS) {\n      return this._url\n        ? html`<ha-hls-player\n            autoplay\n            playsinline\n            .allowExoPlayer=${this.allowExoPlayer}\n            .muted=${this.muted}\n            .controls=${this.controls}\n            .hass=${this.hass}\n            .url=${this._url}\n            .posterUrl=${this._posterUrl}\n          ></ha-hls-player>`\n        : html``;\n    }\n    if (this.stateObj.attributes.frontend_stream_type === STREAM_TYPE_WEB_RTC) {\n      return html`<ha-web-rtc-player\n        autoplay\n        playsinline\n        .muted=${this.muted}\n        .controls=${this.controls}\n        .hass=${this.hass}\n        .entityid=${this.stateObj.entity_id}\n        .posterUrl=${this._posterUrl}\n      ></ha-web-rtc-player>`;\n    }\n    return html``;\n  }\n\n  private get _shouldRenderMJPEG() {\n    if (this._forceMJPEG === this.stateObj!.entity_id) {\n      // Fallback when unable to fetch stream url\n      return true;\n    }\n    if (!supportsFeature(this.stateObj!, CAMERA_SUPPORT_STREAM)) {\n      // Steaming is not supported by the camera so fallback to MJPEG stream\n      return true;\n    }\n    if (\n      this.stateObj!.attributes.frontend_stream_type === STREAM_TYPE_WEB_RTC\n    ) {\n      // Browser support required for WebRTC\n      return typeof RTCPeerConnection === \"undefined\";\n    }\n    // Server side stream component required for HLS\n    return !isComponentLoaded(this.hass!, \"stream\");\n  }\n\n  private async _getPosterUrl(): Promise<void> {\n    try {\n      this._posterUrl = await fetchThumbnailUrlWithCache(\n        this.hass!,\n        this.stateObj!.entity_id,\n        this.clientWidth,\n        this.clientHeight\n      );\n    } catch (err: any) {\n      // poster url is optional\n      this._posterUrl = undefined;\n    }\n  }\n\n  private async _getStreamUrl(): Promise<void> {\n    try {\n      const { url } = await fetchStreamUrl(\n        this.hass!,\n        this.stateObj!.entity_id\n      );\n\n      this._url = url;\n    } catch (err: any) {\n      // Fails if we were unable to get a stream\n      // eslint-disable-next-line\n      console.error(err);\n\n      this._forceMJPEG = this.stateObj!.entity_id;\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host,\n      img {\n        display: block;\n      }\n\n      img {\n        width: 100%;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-camera-stream\": HaCameraStream;\n  }\n}\n","import type HlsType from \"hls.js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { nextRender } from \"../common/util/render-status\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-alert\";\n\ntype HlsLite = Omit<\n  HlsType,\n  \"subtitleTrackController\" | \"audioTrackController\" | \"emeController\"\n>;\n\n@customElement(\"ha-hls-player\")\nclass HaHLSPlayer extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public url!: string;\n\n  @property() public posterUrl!: string;\n\n  @property({ type: Boolean, attribute: \"controls\" })\n  public controls = false;\n\n  @property({ type: Boolean, attribute: \"muted\" })\n  public muted = false;\n\n  @property({ type: Boolean, attribute: \"autoplay\" })\n  public autoPlay = false;\n\n  @property({ type: Boolean, attribute: \"playsinline\" })\n  public playsInline = false;\n\n  @property({ type: Boolean, attribute: \"allow-exoplayer\" })\n  public allowExoPlayer = false;\n\n  // don't cache this, as we remove it on disconnects\n  @query(\"video\") private _videoEl!: HTMLVideoElement;\n\n  @state() private _error?: string;\n\n  @state() private _errorIsFatal = false;\n\n  private _hlsPolyfillInstance?: HlsLite;\n\n  private _exoPlayer = false;\n\n  private static streamCount = 0;\n\n  public connectedCallback() {\n    super.connectedCallback();\n    HaHLSPlayer.streamCount += 1;\n    if (this.hasUpdated) {\n      this._resetError();\n      this._startHls();\n    }\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    HaHLSPlayer.streamCount -= 1;\n    this._cleanUp();\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      ${this._error\n        ? html`<ha-alert\n            alert-type=\"error\"\n            class=${this._errorIsFatal ? \"fatal\" : \"retry\"}\n          >\n            ${this._error}\n          </ha-alert>`\n        : \"\"}\n      ${!this._errorIsFatal\n        ? html`<video\n            .poster=${this.posterUrl}\n            ?autoplay=${this.autoPlay}\n            .muted=${this.muted}\n            ?playsinline=${this.playsInline}\n            ?controls=${this.controls}\n          ></video>`\n        : \"\"}\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    super.updated(changedProps);\n\n    const urlChanged = changedProps.has(\"url\");\n\n    if (!urlChanged) {\n      return;\n    }\n\n    this._cleanUp();\n    this._resetError();\n    this._startHls();\n  }\n\n  private async _startHls(): Promise<void> {\n    const masterPlaylistPromise = fetch(this.url);\n\n    const Hls: typeof HlsType = (await import(\"hls.js/dist/hls.light.min\"))\n      .default;\n\n    if (!this.isConnected) {\n      return;\n    }\n\n    let hlsSupported = Hls.isSupported();\n\n    if (!hlsSupported) {\n      hlsSupported =\n        this._videoEl.canPlayType(\"application/vnd.apple.mpegurl\") !== \"\";\n    }\n\n    if (!hlsSupported) {\n      this._setFatalError(\n        this.hass.localize(\"ui.components.media-browser.video_not_supported\")\n      );\n      return;\n    }\n\n    const useExoPlayer =\n      this.allowExoPlayer && this.hass.auth.external?.config.hasExoPlayer;\n    const masterPlaylist = await (await masterPlaylistPromise).text();\n\n    if (!this.isConnected) {\n      return;\n    }\n\n    // Parse playlist assuming it is a master playlist. Match group 1 is whether hevc, match group 2 is regular playlist url\n    // See https://tools.ietf.org/html/rfc8216 for HLS spec details\n    const playlistRegexp =\n      /#EXT-X-STREAM-INF:.*?(?:CODECS=\".*?(hev1|hvc1)?\\..*?\".*?)?(?:\\n|\\r\\n)(.+)/g;\n    const match = playlistRegexp.exec(masterPlaylist);\n    const matchTwice = playlistRegexp.exec(masterPlaylist);\n\n    // Get the regular playlist url from the input (master) playlist, falling back to the input playlist if necessary\n    // This avoids the player having to load and parse the master playlist again before loading the regular playlist\n    let playlist_url: string;\n    if (match !== null && matchTwice === null) {\n      // Only send the regular playlist url if we match exactly once\n      playlist_url = new URL(match[2], this.url).href;\n    } else {\n      playlist_url = this.url;\n    }\n\n    // If codec is HEVC and ExoPlayer is supported, use ExoPlayer.\n    if (useExoPlayer && match !== null && match[1] !== undefined) {\n      this._renderHLSExoPlayer(playlist_url);\n    } else if (Hls.isSupported()) {\n      this._renderHLSPolyfill(this._videoEl, Hls, playlist_url);\n    } else {\n      this._renderHLSNative(this._videoEl, playlist_url);\n    }\n  }\n\n  private async _renderHLSExoPlayer(url: string) {\n    this._exoPlayer = true;\n    window.addEventListener(\"resize\", this._resizeExoPlayer);\n    this.updateComplete.then(() => nextRender()).then(this._resizeExoPlayer);\n    this._videoEl.style.visibility = \"hidden\";\n    await this.hass!.auth.external!.fireMessage({\n      type: \"exoplayer/play_hls\",\n      payload: {\n        url: new URL(url, window.location.href).toString(),\n        muted: this.muted,\n      },\n    });\n  }\n\n  private _resizeExoPlayer = () => {\n    if (!this._videoEl) {\n      return;\n    }\n    const rect = this._videoEl.getBoundingClientRect();\n    this.hass!.auth.external!.fireMessage({\n      type: \"exoplayer/resize\",\n      payload: {\n        left: rect.left,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n      },\n    });\n  };\n\n  private _isLLHLSSupported(): boolean {\n    // LL-HLS keeps multiple requests in flight, which can run into browser limitations without\n    // an http/2 proxy to pipeline requests. However, a small number of streams active at\n    // once should be OK.\n    // The stream count may be incremented multiple times before this function is called to check\n    // the count e.g. when loading a page with many streams on it. The race can work in our favor\n    // so we now have a better idea on if we'll use too many browser connections later.\n    if (HaHLSPlayer.streamCount <= 2) {\n      return true;\n    }\n    if (\n      !(\"performance\" in window) ||\n      performance.getEntriesByType(\"resource\").length === 0\n    ) {\n      return false;\n    }\n    const perfEntry = performance.getEntriesByType(\n      \"resource\"\n    )[0] as PerformanceResourceTiming;\n    return \"nextHopProtocol\" in perfEntry && perfEntry.nextHopProtocol === \"h2\";\n  }\n\n  private async _renderHLSPolyfill(\n    videoEl: HTMLVideoElement,\n    Hls: typeof HlsType,\n    url: string\n  ) {\n    const hls = new Hls({\n      backBufferLength: 60,\n      fragLoadingTimeOut: 30000,\n      manifestLoadingTimeOut: 30000,\n      levelLoadingTimeOut: 30000,\n      maxLiveSyncPlaybackRate: 2,\n      lowLatencyMode: this._isLLHLSSupported(),\n    });\n    this._hlsPolyfillInstance = hls;\n    hls.attachMedia(videoEl);\n    hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n      this._resetError();\n      hls.loadSource(url);\n    });\n    hls.on(Hls.Events.FRAG_LOADED, (_event, _data: any) => {\n      this._resetError();\n    });\n    hls.on(Hls.Events.ERROR, (_event, data: any) => {\n      // Some errors are recovered automatically by the hls player itself, and the others handled\n      // in this function require special actions to recover. Errors retried in this function\n      // are done with backoff to not cause unecessary failures.\n      if (!data.fatal) {\n        return;\n      }\n      if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {\n        switch (data.details) {\n          case Hls.ErrorDetails.MANIFEST_LOAD_ERROR: {\n            let error = \"Error starting stream, see logs for details\";\n            if (\n              data.response !== undefined &&\n              data.response.code !== undefined\n            ) {\n              if (data.response.code >= 500) {\n                error += \" (Server failure)\";\n              } else if (data.response.code >= 400) {\n                error += \" (Stream never started)\";\n              } else {\n                error += \" (\" + data.response.code + \")\";\n              }\n            }\n            this._setRetryableError(error);\n            break;\n          }\n          case Hls.ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n            this._setRetryableError(\"Timeout while starting stream\");\n            break;\n          default:\n            this._setRetryableError(\"Stream network error\");\n            break;\n        }\n        hls.startLoad();\n      } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {\n        this._setRetryableError(\"Error with media stream contents\");\n        hls.recoverMediaError();\n      } else {\n        this._setFatalError(\"Error playing stream\");\n      }\n    });\n  }\n\n  private async _renderHLSNative(videoEl: HTMLVideoElement, url: string) {\n    videoEl.src = url;\n    videoEl.addEventListener(\"loadedmetadata\", () => {\n      videoEl.play();\n    });\n  }\n\n  private _cleanUp() {\n    if (this._hlsPolyfillInstance) {\n      this._hlsPolyfillInstance.destroy();\n      this._hlsPolyfillInstance = undefined;\n    }\n    if (this._exoPlayer) {\n      window.removeEventListener(\"resize\", this._resizeExoPlayer);\n      this.hass!.auth.external!.fireMessage({ type: \"exoplayer/stop\" });\n      this._exoPlayer = false;\n    }\n    if (this._videoEl) {\n      this._videoEl.removeAttribute(\"src\");\n      this._videoEl.load();\n    }\n  }\n\n  private _resetError() {\n    this._error = undefined;\n    this._errorIsFatal = false;\n  }\n\n  private _setFatalError(errorMessage: string) {\n    this._error = errorMessage;\n    this._errorIsFatal = true;\n  }\n\n  private _setRetryableError(errorMessage: string) {\n    this._error = errorMessage;\n    this._errorIsFatal = false;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host,\n      video {\n        display: block;\n      }\n\n      video {\n        width: 100%;\n        max-height: var(--video-max-height, calc(100vh - 97px));\n      }\n\n      .fatal {\n        display: block;\n        padding: 100px 16px;\n      }\n\n      .retry {\n        display: block;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-hls-player\": HaHLSPlayer;\n  }\n}\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport { STATES_OFF } from \"../../../common/const\";\nimport parseAspectRatio from \"../../../common/util/parse-aspect-ratio\";\nimport \"../../../components/ha-camera-stream\";\nimport { CameraEntity, fetchThumbnailUrlWithCache } from \"../../../data/camera\";\nimport { UNAVAILABLE } from \"../../../data/entity\";\nimport { HomeAssistant } from \"../../../types\";\nimport \"../../../components/ha-circular-progress\";\n\nconst UPDATE_INTERVAL = 10000;\nconst DEFAULT_FILTER = \"grayscale(100%)\";\n\nconst MAX_IMAGE_WIDTH = 640;\nconst ASPECT_RATIO_DEFAULT = 9 / 16;\n\nconst enum LoadState {\n  Loading = 1,\n  Loaded = 2,\n  Error = 3,\n}\n\nexport interface StateSpecificConfig {\n  [state: string]: string;\n}\n\n@customElement(\"hui-image\")\nexport class HuiImage extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property() public entity?: string;\n\n  @property() public image?: string;\n\n  @property({ attribute: false }) public stateImage?: StateSpecificConfig;\n\n  @property() public cameraImage?: string;\n\n  @property() public cameraView?: \"live\" | \"auto\";\n\n  @property() public aspectRatio?: string;\n\n  @property() public filter?: string;\n\n  @property({ attribute: false }) public stateFilter?: StateSpecificConfig;\n\n  @property() public darkModeImage?: string;\n\n  @property() public darkModeFilter?: string;\n\n  @state() private _imageVisible? = false;\n\n  @state() private _loadState?: LoadState;\n\n  @state() private _cameraImageSrc?: string;\n\n  @state() private _loadedImageSrc?: string;\n\n  private _intersectionObserver?: IntersectionObserver;\n\n  private _lastImageHeight?: number;\n\n  private _cameraUpdater?: number;\n\n  private _ratio: {\n    w: number;\n    h: number;\n  } | null = null;\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    if (this._loadState === undefined) {\n      this._loadState = LoadState.Loading;\n    }\n    if (this.cameraImage && this.cameraView !== \"live\") {\n      this._startIntersectionObserverOrUpdates();\n    }\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    this._stopUpdateCameraInterval();\n    this._stopIntersectionObserver();\n    this._imageVisible = undefined;\n  }\n\n  protected handleIntersectionCallback(entries: IntersectionObserverEntry[]) {\n    this._imageVisible = entries[0].isIntersecting;\n  }\n\n  public willUpdate(changedProps: PropertyValues): void {\n    if (changedProps.has(\"hass\")) {\n      const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n\n      if (this._shouldStartCameraUpdates(oldHass)) {\n        this._startIntersectionObserverOrUpdates();\n      } else if (!this.hass!.connected) {\n        this._stopUpdateCameraInterval();\n        this._stopIntersectionObserver();\n        this._loadState = LoadState.Loading;\n        this._cameraImageSrc = undefined;\n        this._loadedImageSrc = undefined;\n      }\n    }\n    if (changedProps.has(\"_imageVisible\")) {\n      if (this._imageVisible) {\n        if (this._shouldStartCameraUpdates()) {\n          this._startUpdateCameraInterval();\n        }\n      } else {\n        this._stopUpdateCameraInterval();\n      }\n    }\n    if (changedProps.has(\"aspectRatio\")) {\n      this._ratio = this.aspectRatio\n        ? parseAspectRatio(this.aspectRatio)\n        : null;\n    }\n    if (this._loadState === LoadState.Loading && !this.cameraImage) {\n      this._loadState = LoadState.Loaded;\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass) {\n      return html``;\n    }\n    const useRatio = Boolean(\n      this._ratio && this._ratio.w > 0 && this._ratio.h > 0\n    );\n    const stateObj = this.entity ? this.hass.states[this.entity] : undefined;\n    const entityState = stateObj ? stateObj.state : UNAVAILABLE;\n\n    // Figure out image source to use\n    let imageSrc: string | undefined;\n    let cameraObj: CameraEntity | undefined;\n    // Track if we are we using a fallback image, used for filter.\n    let imageFallback = !this.stateImage;\n\n    if (this.cameraImage) {\n      if (this.cameraView === \"live\") {\n        cameraObj = this.hass.states[this.cameraImage] as CameraEntity;\n      } else {\n        imageSrc = this._cameraImageSrc;\n      }\n    } else if (this.stateImage) {\n      const stateImage = this.stateImage[entityState];\n\n      if (stateImage) {\n        imageSrc = stateImage;\n      } else {\n        imageSrc = this.image;\n        imageFallback = true;\n      }\n    } else if (this.darkModeImage && this.hass.themes.darkMode) {\n      imageSrc = this.darkModeImage;\n    } else {\n      imageSrc = this.image;\n    }\n\n    if (imageSrc) {\n      imageSrc = this.hass.hassUrl(imageSrc);\n    }\n\n    // Figure out filter to use\n    let filter = this.filter || \"\";\n\n    if (this.hass.themes.darkMode && this.darkModeFilter) {\n      filter += this.darkModeFilter;\n    }\n\n    if (this.stateFilter && this.stateFilter[entityState]) {\n      filter += this.stateFilter[entityState];\n    }\n\n    if (!filter && this.entity) {\n      const isOff = !stateObj || STATES_OFF.includes(entityState);\n      filter = isOff && imageFallback ? DEFAULT_FILTER : \"\";\n    }\n\n    return html`\n      <div\n        style=${styleMap({\n          paddingBottom: useRatio\n            ? `${((100 * this._ratio!.h) / this._ratio!.w).toFixed(2)}%`\n            : undefined,\n          backgroundImage:\n            useRatio && this._loadedImageSrc\n              ? `url(\"${this._loadedImageSrc}\")`\n              : undefined,\n          filter:\n            this._loadState === LoadState.Loaded || this.cameraView === \"live\"\n              ? filter\n              : undefined,\n        })}\n        class=\"container ${classMap({\n          ratio: useRatio,\n        })}\"\n      >\n        ${this.cameraImage && this.cameraView === \"live\"\n          ? html`\n              <ha-camera-stream\n                muted\n                .hass=${this.hass}\n                .stateObj=${cameraObj}\n              ></ha-camera-stream>\n            `\n          : imageSrc === undefined\n          ? html``\n          : html`\n              <img\n                id=\"image\"\n                src=${imageSrc}\n                @error=${this._onImageError}\n                @load=${this._onImageLoad}\n                style=${styleMap({\n                  display:\n                    useRatio || this._loadState === LoadState.Loaded\n                      ? \"block\"\n                      : \"none\",\n                })}\n              />\n            `}\n        ${this._loadState === LoadState.Error\n          ? html`<div\n              id=\"brokenImage\"\n              style=${styleMap({\n                height: !useRatio\n                  ? `${this._lastImageHeight || \"100\"}px`\n                  : undefined,\n              })}\n            ></div>`\n          : this.cameraView !== \"live\" &&\n            (imageSrc === undefined || this._loadState === LoadState.Loading)\n          ? html`<div\n              class=\"progress-container\"\n              style=${styleMap({\n                height: !useRatio\n                  ? `${this._lastImageHeight || \"100\"}px`\n                  : undefined,\n              })}\n            >\n              <ha-circular-progress\n                class=\"render-spinner\"\n                active\n                size=\"small\"\n              ></ha-circular-progress>\n            </div>`\n          : \"\"}\n      </div>\n    `;\n  }\n\n  protected _shouldStartCameraUpdates(oldHass?: HomeAssistant): boolean {\n    return !!(\n      (!oldHass || oldHass.connected !== this.hass!.connected) &&\n      this.hass!.connected &&\n      this.cameraView !== \"live\"\n    );\n  }\n\n  private _startIntersectionObserverOrUpdates(): void {\n    if (\"IntersectionObserver\" in window) {\n      if (!this._intersectionObserver) {\n        this._intersectionObserver = new IntersectionObserver(\n          this.handleIntersectionCallback.bind(this)\n        );\n      }\n      this._intersectionObserver.observe(this);\n    } else {\n      // No support for IntersectionObserver\n      // assume all images are visible\n      this._imageVisible = true;\n      this._startUpdateCameraInterval();\n    }\n  }\n\n  private _stopIntersectionObserver(): void {\n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n    }\n  }\n\n  private _startUpdateCameraInterval(): void {\n    this._stopUpdateCameraInterval();\n    this._updateCameraImageSrc();\n    if (this.cameraImage && this.isConnected) {\n      this._cameraUpdater = window.setInterval(\n        () => this._updateCameraImageSrcAtInterval(),\n        UPDATE_INTERVAL\n      );\n    }\n  }\n\n  private _stopUpdateCameraInterval(): void {\n    if (this._cameraUpdater) {\n      clearInterval(this._cameraUpdater);\n      this._cameraUpdater = undefined;\n    }\n  }\n\n  private _onImageError(): void {\n    this._loadState = LoadState.Error;\n  }\n\n  private async _onImageLoad(ev: Event): Promise<void> {\n    this._loadState = LoadState.Loaded;\n    const imgEl = ev.target as HTMLImageElement;\n    if (this._ratio && this._ratio.w > 0 && this._ratio.h > 0) {\n      this._loadedImageSrc = imgEl.src;\n    }\n    await this.updateComplete;\n    this._lastImageHeight = imgEl.offsetHeight;\n  }\n\n  private async _updateCameraImageSrcAtInterval(): Promise<void> {\n    // If we hit the interval and it was still loading\n    // it means we timed out so we should show the error.\n    if (this._loadState === LoadState.Loading) {\n      this._onImageError();\n    }\n    return this._updateCameraImageSrc();\n  }\n\n  private async _updateCameraImageSrc(): Promise<void> {\n    if (!this.hass || !this.cameraImage) {\n      return;\n    }\n\n    const cameraState = this.hass.states[this.cameraImage] as\n      | CameraEntity\n      | undefined;\n\n    if (!cameraState) {\n      this._onImageError();\n      return;\n    }\n\n    const element_width = this.clientWidth || MAX_IMAGE_WIDTH;\n    let width = Math.ceil(element_width * devicePixelRatio);\n    let height: number;\n    // If the image has not rendered yet we have no height\n    if (!this._lastImageHeight) {\n      if (this._ratio && this._ratio.w > 0 && this._ratio.h > 0) {\n        height = Math.ceil(width * (this._ratio.h / this._ratio.w));\n      } else {\n        // If we don't have a ratio and we don't have a height\n        // we ask for 200% of what we need because the aspect\n        // ratio might result in a smaller image\n        width *= 2;\n        height = Math.ceil(width * ASPECT_RATIO_DEFAULT);\n      }\n    } else {\n      height = Math.ceil(this._lastImageHeight * devicePixelRatio);\n    }\n    this._cameraImageSrc = await fetchThumbnailUrlWithCache(\n      this.hass,\n      this.cameraImage,\n      width,\n      height\n    );\n    if (this._cameraImageSrc === undefined) {\n      this._onImageError();\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n      }\n\n      .container {\n        transition: filter 0.2s linear;\n      }\n\n      img {\n        display: block;\n        height: auto;\n        width: 100%;\n      }\n\n      .progress-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n\n      .ratio {\n        position: relative;\n        width: 100%;\n        height: 0;\n        background-position: center;\n        background-size: cover;\n      }\n\n      .ratio img,\n      .ratio div {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n      }\n\n      .ratio img {\n        visibility: hidden;\n      }\n\n      #brokenImage {\n        background: grey url(\"/static/images/image-broken.svg\") center/36px\n          no-repeat;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-image\": HuiImage;\n  }\n}\n"],"names":[],"sourceRoot":""}