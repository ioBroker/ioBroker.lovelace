{"version":3,"file":"b37c5904.js","mappings":";;AAuCA;AACA;;;;;AC8DA;AACA;AACA;;;AAxBA;;;;AAAA;AC9CA;AAIA;AAEA;AAIA;AAEA;AAIA;AAKA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;AA7DA","sources":["webpack://home-assistant-frontend/./src/components/chart/state-history-chart-line.ts","webpack://home-assistant-frontend/./src/components/chart/state-history-chart-timeline.ts","webpack://home-assistant-frontend/./src/components/chart/state-history-charts.ts"],"sourcesContent":["import type { ChartData, ChartDataset, ChartOptions } from \"chart.js\";\nimport { html, LitElement, PropertyValues } from \"lit\";\nimport { property, state } from \"lit/decorators\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport {\n  formatNumber,\n  numberFormatToLocale,\n} from \"../../common/number/format_number\";\nimport { LineChartEntity, LineChartState } from \"../../data/history\";\nimport { HomeAssistant } from \"../../types\";\nimport \"./ha-chart-base\";\n\nconst safeParseFloat = (value) => {\n  const parsed = parseFloat(value);\n  return isFinite(parsed) ? parsed : null;\n};\n\nclass StateHistoryChartLine extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public data: LineChartEntity[] = [];\n\n  @property() public names: boolean | Record<string, string> = false;\n\n  @property() public unit?: string;\n\n  @property() public identifier?: string;\n\n  @property({ type: Boolean }) public isSingleDevice = false;\n\n  @property({ attribute: false }) public endTime?: Date;\n\n  @state() private _chartData?: ChartData<\"line\">;\n\n  @state() private _chartOptions?: ChartOptions<\"line\">;\n\n  protected render() {\n    return html`\n      <ha-chart-base\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        chart-type=\"line\"\n      ></ha-chart-base>\n    `;\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    if (!this.hasUpdated) {\n      this._chartOptions = {\n        parsing: false,\n        animation: false,\n        scales: {\n          x: {\n            type: \"time\",\n            adapters: {\n              date: {\n                locale: this.hass.locale,\n              },\n            },\n            ticks: {\n              maxRotation: 0,\n              sampleSize: 5,\n              autoSkipPadding: 20,\n              major: {\n                enabled: true,\n              },\n              font: (context) =>\n                context.tick && context.tick.major\n                  ? ({ weight: \"bold\" } as any)\n                  : {},\n            },\n            time: {\n              tooltipFormat: \"datetimeseconds\",\n            },\n          },\n          y: {\n            ticks: {\n              maxTicksLimit: 7,\n            },\n            title: {\n              display: true,\n              text: this.unit,\n            },\n          },\n        },\n        plugins: {\n          tooltip: {\n            mode: \"nearest\",\n            callbacks: {\n              label: (context) =>\n                `${context.dataset.label}: ${formatNumber(\n                  context.parsed.y,\n                  this.hass.locale\n                )} ${this.unit}`,\n            },\n          },\n          filler: {\n            propagate: true,\n          },\n          legend: {\n            display: !this.isSingleDevice,\n            labels: {\n              usePointStyle: true,\n            },\n          },\n        },\n        hover: {\n          mode: \"nearest\",\n        },\n        elements: {\n          line: {\n            tension: 0.1,\n            borderWidth: 1.5,\n          },\n          point: {\n            hitRadius: 5,\n          },\n        },\n        // @ts-expect-error\n        locale: numberFormatToLocale(this.hass.locale),\n      };\n    }\n    if (changedProps.has(\"data\")) {\n      this._generateData();\n    }\n  }\n\n  private _generateData() {\n    let colorIndex = 0;\n    const computedStyles = getComputedStyle(this);\n    const entityStates = this.data;\n    const datasets: ChartDataset<\"line\">[] = [];\n    let endTime: Date;\n\n    if (entityStates.length === 0) {\n      return;\n    }\n\n    endTime =\n      this.endTime ||\n      // Get the highest date from the last date of each device\n      new Date(\n        Math.max(\n          ...entityStates.map((devSts) =>\n            new Date(\n              devSts.states[devSts.states.length - 1].last_changed\n            ).getTime()\n          )\n        )\n      );\n    if (endTime > new Date()) {\n      endTime = new Date();\n    }\n\n    const names = this.names || {};\n    entityStates.forEach((states) => {\n      const domain = states.domain;\n      const name = names[states.entity_id] || states.name;\n      // array containing [value1, value2, etc]\n      let prevValues: any[] | null = null;\n\n      const data: ChartDataset<\"line\">[] = [];\n\n      const pushData = (timestamp: Date, datavalues: any[] | null) => {\n        if (!datavalues) return;\n        if (timestamp > endTime) {\n          // Drop data points that are after the requested endTime. This could happen if\n          // endTime is \"now\" and client time is not in sync with server time.\n          return;\n        }\n        data.forEach((d, i) => {\n          if (datavalues[i] === null && prevValues && prevValues[i] !== null) {\n            // null data values show up as gaps in the chart.\n            // If the current value for the dataset is null and the previous\n            // value of the data set is not null, then add an 'end' point\n            // to the chart for the previous value. Otherwise the gap will\n            // be too big. It will go from the start of the previous data\n            // value until the start of the next data value.\n            d.data.push({ x: timestamp.getTime(), y: prevValues[i] });\n          }\n          d.data.push({ x: timestamp.getTime(), y: datavalues[i] });\n        });\n        prevValues = datavalues;\n      };\n\n      const addDataSet = (\n        nameY: string,\n        step = false,\n        fill = false,\n        color?: string\n      ) => {\n        if (!color) {\n          color = getGraphColorByIndex(colorIndex, computedStyles);\n          colorIndex++;\n        }\n        data.push({\n          label: nameY,\n          fill: fill ? \"origin\" : false,\n          borderColor: color,\n          backgroundColor: color + \"7F\",\n          stepped: step ? \"before\" : false,\n          pointRadius: 0,\n          data: [],\n        });\n      };\n\n      if (\n        domain === \"thermostat\" ||\n        domain === \"climate\" ||\n        domain === \"water_heater\"\n      ) {\n        const hasHvacAction = states.states.some(\n          (entityState) => entityState.attributes?.hvac_action\n        );\n\n        const isHeating =\n          domain === \"climate\" && hasHvacAction\n            ? (entityState: LineChartState) =>\n                entityState.attributes?.hvac_action === \"heating\"\n            : (entityState: LineChartState) => entityState.state === \"heat\";\n        const isCooling =\n          domain === \"climate\" && hasHvacAction\n            ? (entityState: LineChartState) =>\n                entityState.attributes?.hvac_action === \"cooling\"\n            : (entityState: LineChartState) => entityState.state === \"cool\";\n\n        const hasHeat = states.states.some(isHeating);\n        const hasCool = states.states.some(isCooling);\n        // We differentiate between thermostats that have a target temperature\n        // range versus ones that have just a target temperature\n\n        // Using step chart by step-before so manually interpolation not needed.\n        const hasTargetRange = states.states.some(\n          (entityState) =>\n            entityState.attributes &&\n            entityState.attributes.target_temp_high !==\n              entityState.attributes.target_temp_low\n        );\n        addDataSet(\n          `${this.hass.localize(\"ui.card.climate.current_temperature\", {\n            name: name,\n          })}`,\n          true\n        );\n        if (hasHeat) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.heating\", { name: name })}`,\n            true,\n            true,\n            computedStyles.getPropertyValue(\"--state-climate-heat-color\")\n          );\n          // The \"heating\" series uses steppedArea to shade the area below the current\n          // temperature when the thermostat is calling for heat.\n        }\n        if (hasCool) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.cooling\", { name: name })}`,\n            true,\n            true,\n            computedStyles.getPropertyValue(\"--state-climate-cool-color\")\n          );\n          // The \"cooling\" series uses steppedArea to shade the area below the current\n          // temperature when the thermostat is calling for heat.\n        }\n\n        if (hasTargetRange) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n              name: name,\n              mode: this.hass.localize(\"ui.card.climate.high\"),\n            })}`,\n            true\n          );\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n              name: name,\n              mode: this.hass.localize(\"ui.card.climate.low\"),\n            })}`,\n            true\n          );\n        } else {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.target_temperature_entity\", {\n              name: name,\n            })}`,\n            true\n          );\n        }\n\n        states.states.forEach((entityState) => {\n          if (!entityState.attributes) return;\n          const curTemp = safeParseFloat(\n            entityState.attributes.current_temperature\n          );\n          const series = [curTemp];\n          if (hasHeat) {\n            series.push(isHeating(entityState) ? curTemp : null);\n          }\n          if (hasCool) {\n            series.push(isCooling(entityState) ? curTemp : null);\n          }\n          if (hasTargetRange) {\n            const targetHigh = safeParseFloat(\n              entityState.attributes.target_temp_high\n            );\n            const targetLow = safeParseFloat(\n              entityState.attributes.target_temp_low\n            );\n            series.push(targetHigh, targetLow);\n            pushData(new Date(entityState.last_changed), series);\n          } else {\n            const target = safeParseFloat(entityState.attributes.temperature);\n            series.push(target);\n            pushData(new Date(entityState.last_changed), series);\n          }\n        });\n      } else if (domain === \"humidifier\") {\n        addDataSet(\n          `${this.hass.localize(\"ui.card.humidifier.target_humidity_entity\", {\n            name: name,\n          })}`,\n          true\n        );\n        addDataSet(\n          `${this.hass.localize(\"ui.card.humidifier.on_entity\", {\n            name: name,\n          })}`,\n          true,\n          true\n        );\n\n        states.states.forEach((entityState) => {\n          if (!entityState.attributes) return;\n          const target = safeParseFloat(entityState.attributes.humidity);\n          const series = [target];\n          series.push(entityState.state === \"on\" ? target : null);\n          pushData(new Date(entityState.last_changed), series);\n        });\n      } else {\n        // Only disable interpolation for sensors\n        const isStep = domain === \"sensor\";\n        addDataSet(name, isStep);\n\n        let lastValue: number;\n        let lastDate: Date;\n        let lastNullDate: Date | null = null;\n\n        // Process chart data.\n        // When state is `unknown`, calculate the value and break the line.\n        states.states.forEach((entityState) => {\n          const value = safeParseFloat(entityState.state);\n          const date = new Date(entityState.last_changed);\n          if (value !== null && lastNullDate) {\n            const dateTime = date.getTime();\n            const lastNullDateTime = lastNullDate.getTime();\n            const lastDateTime = lastDate?.getTime();\n            const tmpValue =\n              (value - lastValue) *\n                ((lastNullDateTime - lastDateTime) /\n                  (dateTime - lastDateTime)) +\n              lastValue;\n            pushData(lastNullDate, [tmpValue]);\n            pushData(new Date(lastNullDateTime + 1), [null]);\n            pushData(date, [value]);\n            lastDate = date;\n            lastValue = value;\n            lastNullDate = null;\n          } else if (value !== null && lastNullDate === null) {\n            pushData(date, [value]);\n            lastDate = date;\n            lastValue = value;\n          } else if (\n            value === null &&\n            lastNullDate === null &&\n            lastValue !== undefined\n          ) {\n            lastNullDate = date;\n          }\n        });\n      }\n\n      // Add an entry for final values\n      pushData(endTime, prevValues);\n\n      // Concat two arrays\n      Array.prototype.push.apply(datasets, data);\n    });\n\n    this._chartData = {\n      datasets,\n    };\n  }\n}\ncustomElements.define(\"state-history-chart-line\", StateHistoryChartLine);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"state-history-chart-line\": StateHistoryChartLine;\n  }\n}\n","import type { ChartData, ChartDataset, ChartOptions } from \"chart.js\";\nimport { HassEntity } from \"home-assistant-js-websocket\";\nimport { css, CSSResultGroup, html, LitElement, PropertyValues } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport { formatDateTimeWithSeconds } from \"../../common/datetime/format_date_time\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { numberFormatToLocale } from \"../../common/number/format_number\";\nimport { computeRTL } from \"../../common/util/compute_rtl\";\nimport { TimelineEntity } from \"../../data/history\";\nimport { HomeAssistant } from \"../../types\";\nimport \"./ha-chart-base\";\nimport type { TimeLineData } from \"./timeline-chart/const\";\n\n/** Binary sensor device classes for which the static colors for on/off are NOT inverted.\n *  List the ones were \"on\" = good or normal state => should be rendered \"green\".\n *  Note: It is now a \"not inverted\" list (compared to the past) since we now have more inverted ones.\n */\nconst BINARY_SENSOR_DEVICE_CLASS_COLOR_NOT_INVERTED = new Set([\n  \"battery_charging\",\n  \"connectivity\",\n  \"light\",\n  \"moving\",\n  \"plug\",\n  \"power\",\n  \"presence\",\n  \"running\",\n]);\n\nconst STATIC_STATE_COLORS = new Set([\n  \"on\",\n  \"off\",\n  \"home\",\n  \"not_home\",\n  \"unavailable\",\n  \"unknown\",\n  \"idle\",\n]);\n\nconst stateColorMap: Map<string, string> = new Map();\n\nlet colorIndex = 0;\n\nconst invertOnOff = (entityState?: HassEntity) =>\n  entityState &&\n  computeDomain(entityState.entity_id) === \"binary_sensor\" &&\n  \"device_class\" in entityState.attributes &&\n  !BINARY_SENSOR_DEVICE_CLASS_COLOR_NOT_INVERTED.has(\n    entityState.attributes.device_class!\n  );\n\nconst getColor = (\n  stateString: string,\n  entityState: HassEntity,\n  computedStyles: CSSStyleDeclaration\n) => {\n  // Inversion is only valid for \"on\" or \"off\" state\n  if (\n    (stateString === \"on\" || stateString === \"off\") &&\n    invertOnOff(entityState)\n  ) {\n    stateString = stateString === \"on\" ? \"off\" : \"on\";\n  }\n  if (stateColorMap.has(stateString)) {\n    return stateColorMap.get(stateString);\n  }\n  if (STATIC_STATE_COLORS.has(stateString)) {\n    const color = computedStyles.getPropertyValue(\n      `--state-${stateString}-color`\n    );\n    stateColorMap.set(stateString, color);\n    return color;\n  }\n  const color = getGraphColorByIndex(colorIndex, computedStyles);\n  colorIndex++;\n  stateColorMap.set(stateString, color);\n  return color;\n};\n\n@customElement(\"state-history-chart-timeline\")\nexport class StateHistoryChartTimeline extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public data: TimelineEntity[] = [];\n\n  @property() public names: boolean | Record<string, string> = false;\n\n  @property() public unit?: string;\n\n  @property() public identifier?: string;\n\n  @property({ type: Boolean }) public isSingleDevice = false;\n\n  @property({ attribute: false }) public endTime?: Date;\n\n  @state() private _chartData?: ChartData<\"timeline\">;\n\n  @state() private _chartOptions?: ChartOptions<\"timeline\">;\n\n  protected render() {\n    return html`\n      <ha-chart-base\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .height=${this.data.length * 30 + 30}\n        chart-type=\"timeline\"\n      ></ha-chart-base>\n    `;\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    if (!this.hasUpdated) {\n      this._chartOptions = {\n        maintainAspectRatio: false,\n        parsing: false,\n        animation: false,\n        scales: {\n          x: {\n            type: \"timeline\",\n            position: \"bottom\",\n            adapters: {\n              date: {\n                locale: this.hass.locale,\n              },\n            },\n            ticks: {\n              autoSkip: true,\n              maxRotation: 0,\n              sampleSize: 5,\n              autoSkipPadding: 20,\n              major: {\n                enabled: true,\n              },\n              font: (context) =>\n                context.tick && context.tick.major\n                  ? ({ weight: \"bold\" } as any)\n                  : {},\n            },\n            grid: {\n              offset: false,\n            },\n            time: {\n              tooltipFormat: \"datetimeseconds\",\n            },\n          },\n          y: {\n            type: \"category\",\n            barThickness: 20,\n            offset: true,\n            grid: {\n              display: false,\n              drawBorder: false,\n              drawTicks: false,\n            },\n            ticks: {\n              display: this.data.length !== 1,\n            },\n            afterSetDimensions: (y) => {\n              y.maxWidth = y.chart.width * 0.18;\n            },\n            position: computeRTL(this.hass) ? \"right\" : \"left\",\n          },\n        },\n        plugins: {\n          tooltip: {\n            mode: \"nearest\",\n            callbacks: {\n              title: (context) =>\n                context![0].chart!.data!.labels![\n                  context[0].datasetIndex\n                ] as string,\n              beforeBody: (context) => context[0].dataset.label || \"\",\n              label: (item) => {\n                const d = item.dataset.data[item.dataIndex] as TimeLineData;\n                return [\n                  d.label || \"\",\n                  formatDateTimeWithSeconds(d.start, this.hass.locale),\n                  formatDateTimeWithSeconds(d.end, this.hass.locale),\n                ];\n              },\n              labelColor: (item) => ({\n                borderColor: (item.dataset.data[item.dataIndex] as TimeLineData)\n                  .color!,\n                backgroundColor: (\n                  item.dataset.data[item.dataIndex] as TimeLineData\n                ).color!,\n              }),\n            },\n          },\n          filler: {\n            propagate: true,\n          },\n        },\n        // @ts-expect-error\n        locale: numberFormatToLocale(this.hass.locale),\n      };\n    }\n    if (changedProps.has(\"data\")) {\n      this._generateData();\n    }\n  }\n\n  private _generateData() {\n    const computedStyles = getComputedStyle(this);\n    let stateHistory = this.data;\n\n    if (!stateHistory) {\n      stateHistory = [];\n    }\n\n    const startTime = new Date(\n      stateHistory.reduce(\n        (minTime, stateInfo) =>\n          Math.min(minTime, new Date(stateInfo.data[0].last_changed).getTime()),\n        new Date().getTime()\n      )\n    );\n\n    // end time is Math.max(startTime, last_event)\n    let endTime =\n      this.endTime ||\n      new Date(\n        stateHistory.reduce(\n          (maxTime, stateInfo) =>\n            Math.max(\n              maxTime,\n              new Date(\n                stateInfo.data[stateInfo.data.length - 1].last_changed\n              ).getTime()\n            ),\n          startTime.getTime()\n        )\n      );\n\n    if (endTime > new Date()) {\n      endTime = new Date();\n    }\n\n    const labels: string[] = [];\n    const datasets: ChartDataset<\"timeline\">[] = [];\n    const names = this.names || {};\n    // stateHistory is a list of lists of sorted state objects\n    stateHistory.forEach((stateInfo) => {\n      let newLastChanged: Date;\n      let prevState: string | null = null;\n      let locState: string | null = null;\n      let prevLastChanged = startTime;\n      const entityDisplay: string =\n        names[stateInfo.entity_id] || stateInfo.name;\n\n      const dataRow: TimeLineData[] = [];\n      stateInfo.data.forEach((entityState) => {\n        let newState: string | null = entityState.state;\n        const timeStamp = new Date(entityState.last_changed);\n        if (!newState) {\n          newState = null;\n        }\n        if (timeStamp > endTime) {\n          // Drop datapoints that are after the requested endTime. This could happen if\n          // endTime is 'now' and client time is not in sync with server time.\n          return;\n        }\n        if (prevState === null) {\n          prevState = newState;\n          locState = entityState.state_localize;\n          prevLastChanged = new Date(entityState.last_changed);\n        } else if (newState !== prevState) {\n          newLastChanged = new Date(entityState.last_changed);\n\n          dataRow.push({\n            start: prevLastChanged,\n            end: newLastChanged,\n            label: locState,\n            color: getColor(\n              prevState,\n              this.hass.states[stateInfo.entity_id],\n              computedStyles\n            ),\n          });\n\n          prevState = newState;\n          locState = entityState.state_localize;\n          prevLastChanged = newLastChanged;\n        }\n      });\n\n      if (prevState !== null) {\n        dataRow.push({\n          start: prevLastChanged,\n          end: endTime,\n          label: locState,\n          color: getColor(\n            prevState,\n            this.hass.states[stateInfo.entity_id],\n            computedStyles\n          ),\n        });\n      }\n      datasets.push({\n        data: dataRow,\n        label: stateInfo.entity_id,\n      });\n      labels.push(entityDisplay);\n    });\n\n    this._chartData = {\n      labels: labels,\n      datasets: datasets,\n    };\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-chart-base {\n        --chart-max-height: none;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"state-history-chart-timeline\": StateHistoryChartTimeline;\n  }\n}\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport { HistoryResult } from \"../../data/history\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"./state-history-chart-line\";\nimport \"./state-history-chart-timeline\";\n\n@customElement(\"state-history-charts\")\nclass StateHistoryCharts extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public historyData!: HistoryResult;\n\n  @property({ type: Boolean }) public names = false;\n\n  @property({ attribute: false }) public endTime?: Date;\n\n  @property({ type: Boolean, attribute: \"up-to-now\" }) public upToNow = false;\n\n  @property({ type: Boolean, attribute: \"no-single\" }) public noSingle = false;\n\n  @property({ type: Boolean }) public isLoadingData = false;\n\n  protected render(): TemplateResult {\n    if (!isComponentLoaded(this.hass, \"history\")) {\n      return html` <div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.history_disabled\")}\n      </div>`;\n    }\n\n    if (this.isLoadingData && !this.historyData) {\n      return html` <div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.loading_history\")}\n      </div>`;\n    }\n\n    if (this._isHistoryEmpty()) {\n      return html` <div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.no_history_found\")}\n      </div>`;\n    }\n\n    const computedEndTime = this.upToNow\n      ? new Date()\n      : this.endTime || new Date();\n\n    return html`\n      ${this.historyData.timeline.length\n        ? html`\n            <state-history-chart-timeline\n              .hass=${this.hass}\n              .data=${this.historyData.timeline}\n              .endTime=${computedEndTime}\n              .noSingle=${this.noSingle}\n              .names=${this.names}\n            ></state-history-chart-timeline>\n          `\n        : html``}\n      ${this.historyData.line.map(\n        (line) => html`\n          <state-history-chart-line\n            .hass=${this.hass}\n            .unit=${line.unit}\n            .data=${line.data}\n            .identifier=${line.identifier}\n            .isSingleDevice=${!this.noSingle &&\n            line.data &&\n            line.data.length === 1}\n            .endTime=${computedEndTime}\n            .names=${this.names}\n          ></state-history-chart-line>\n        `\n      )}\n    `;\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    return !(changedProps.size === 1 && changedProps.has(\"hass\"));\n  }\n\n  private _isHistoryEmpty(): boolean {\n    const historyDataEmpty =\n      !this.historyData ||\n      !this.historyData.timeline ||\n      !this.historyData.line ||\n      (this.historyData.timeline.length === 0 &&\n        this.historyData.line.length === 0);\n    return !this.isLoadingData && historyDataEmpty;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        /* height of single timeline chart = 60px */\n        min-height: 60px;\n      }\n      .info {\n        text-align: center;\n        line-height: 60px;\n        color: var(--secondary-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"state-history-charts\": StateHistoryCharts;\n  }\n}\n"],"names":[],"sourceRoot":""}