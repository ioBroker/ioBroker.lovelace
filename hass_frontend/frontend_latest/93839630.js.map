{"version":3,"file":"93839630.js","mappings":";AAyFA;AAMA;;AAUA;AACA;AACA;;AAXA;AACA;AAfA;AACA;;;;;;;;;;;AAlDA","sources":["webpack://home-assistant-frontend/./src/components/chart/statistics-chart.ts"],"sourcesContent":["import type {\n  ChartData,\n  ChartDataset,\n  ChartOptions,\n  ChartType,\n} from \"chart.js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport {\n  formatNumber,\n  numberFormatToLocale,\n} from \"../../common/number/format_number\";\nimport {\n  getStatisticIds,\n  Statistics,\n  statisticsHaveType,\n  StatisticsMetaData,\n  StatisticType,\n} from \"../../data/history\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"./ha-chart-base\";\n\n@customElement(\"statistics-chart\")\nclass StatisticsChart extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public statisticsData!: Statistics;\n\n  @property({ type: Array }) public statisticIds?: StatisticsMetaData[];\n\n  @property() public names: boolean | Record<string, string> = false;\n\n  @property() public unit?: string;\n\n  @property({ attribute: false }) public endTime?: Date;\n\n  @property({ type: Array }) public statTypes: Array<StatisticType> = [\n    \"sum\",\n    \"min\",\n    \"mean\",\n    \"max\",\n  ];\n\n  @property() public chartType: ChartType = \"line\";\n\n  @property({ type: Boolean }) public isLoadingData = false;\n\n  @state() private _chartData: ChartData = { datasets: [] };\n\n  @state() private _chartOptions?: ChartOptions;\n\n  private _computedStyle?: CSSStyleDeclaration;\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    return changedProps.size > 1 || !changedProps.has(\"hass\");\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    if (!this.hasUpdated) {\n      this._createOptions();\n    }\n    if (changedProps.has(\"statisticsData\") || changedProps.has(\"statTypes\")) {\n      this._generateData();\n    }\n  }\n\n  public firstUpdated() {\n    this._computedStyle = getComputedStyle(this);\n  }\n\n  protected render(): TemplateResult {\n    if (!isComponentLoaded(this.hass, \"history\")) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.history_disabled\")}\n      </div>`;\n    }\n\n    if (this.isLoadingData && !this.statisticsData) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\n          \"ui.components.statistics_charts.loading_statistics\"\n        )}\n      </div>`;\n    }\n\n    if (!this.statisticsData || !Object.keys(this.statisticsData).length) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\n          \"ui.components.statistics_charts.no_statistics_found\"\n        )}\n      </div>`;\n    }\n\n    return html`\n      <ha-chart-base\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .chartType=${this.chartType}\n      ></ha-chart-base>\n    `;\n  }\n\n  private _createOptions() {\n    this._chartOptions = {\n      parsing: false,\n      animation: false,\n      scales: {\n        x: {\n          type: \"time\",\n          adapters: {\n            date: {\n              locale: this.hass.locale,\n            },\n          },\n          ticks: {\n            maxRotation: 0,\n            sampleSize: 5,\n            autoSkipPadding: 20,\n            major: {\n              enabled: true,\n            },\n            font: (context) =>\n              context.tick && context.tick.major\n                ? ({ weight: \"bold\" } as any)\n                : {},\n          },\n          time: {\n            tooltipFormat: \"datetime\",\n          },\n        },\n        y: {\n          beginAtZero: false,\n          ticks: {\n            maxTicksLimit: 7,\n          },\n          title: {\n            display: this.unit,\n            text: this.unit,\n          },\n        },\n      },\n      plugins: {\n        tooltip: {\n          mode: \"nearest\",\n          callbacks: {\n            label: (context) =>\n              `${context.dataset.label}: ${formatNumber(\n                context.parsed.y,\n                this.hass.locale\n              )} ${\n                // @ts-ignore\n                context.dataset.unit || \"\"\n              }`,\n          },\n        },\n        filler: {\n          propagate: true,\n        },\n        legend: {\n          display: true,\n          labels: {\n            usePointStyle: true,\n          },\n        },\n      },\n      hover: {\n        mode: \"nearest\",\n      },\n      elements: {\n        line: {\n          tension: 0.4,\n          borderWidth: 1.5,\n        },\n        bar: { borderWidth: 1.5, borderRadius: 4 },\n        point: {\n          hitRadius: 5,\n        },\n      },\n      // @ts-expect-error\n      locale: numberFormatToLocale(this.hass.locale),\n    };\n  }\n\n  private async _getStatisticIds() {\n    this.statisticIds = await getStatisticIds(this.hass);\n  }\n\n  private async _generateData() {\n    if (!this.statisticsData) {\n      return;\n    }\n\n    if (!this.statisticIds) {\n      await this._getStatisticIds();\n    }\n\n    let colorIndex = 0;\n    const statisticsData = Object.values(this.statisticsData);\n    const totalDataSets: ChartDataset<\"line\">[] = [];\n    let endTime: Date;\n\n    if (statisticsData.length === 0) {\n      return;\n    }\n\n    endTime =\n      this.endTime ||\n      // Get the highest date from the last date of each statistic\n      new Date(\n        Math.max(\n          ...statisticsData.map((stats) =>\n            new Date(stats[stats.length - 1].start).getTime()\n          )\n        )\n      );\n\n    if (endTime > new Date()) {\n      endTime = new Date();\n    }\n\n    let unit: string | undefined | null;\n\n    const names = this.names || {};\n    statisticsData.forEach((stats) => {\n      const firstStat = stats[0];\n      let name = names[firstStat.statistic_id];\n      if (!name) {\n        const entityState = this.hass.states[firstStat.statistic_id];\n        if (entityState) {\n          name = computeStateName(entityState);\n        } else {\n          name = firstStat.statistic_id;\n        }\n      }\n\n      const meta = this.statisticIds!.find(\n        (stat) => stat.statistic_id === firstStat.statistic_id\n      );\n\n      if (!this.unit) {\n        if (unit === undefined) {\n          unit = meta?.unit_of_measurement;\n        } else if (unit !== meta?.unit_of_measurement) {\n          unit = null;\n        }\n      }\n\n      // array containing [value1, value2, etc]\n      let prevValues: Array<number | null> | null = null;\n\n      // The datasets for the current statistic\n      const statDataSets: ChartDataset<\"line\">[] = [];\n\n      const pushData = (\n        timestamp: Date,\n        dataValues: Array<number | null> | null\n      ) => {\n        if (!dataValues) return;\n        if (timestamp > endTime) {\n          // Drop data points that are after the requested endTime. This could happen if\n          // endTime is \"now\" and client time is not in sync with server time.\n          return;\n        }\n        statDataSets.forEach((d, i) => {\n          if (dataValues[i] === null && prevValues && prevValues[i] !== null) {\n            // null data values show up as gaps in the chart.\n            // If the current value for the dataset is null and the previous\n            // value of the data set is not null, then add an 'end' point\n            // to the chart for the previous value. Otherwise the gap will\n            // be too big. It will go from the start of the previous data\n            // value until the start of the next data value.\n            d.data.push({ x: timestamp.getTime(), y: prevValues[i]! });\n          }\n          d.data.push({ x: timestamp.getTime(), y: dataValues[i]! });\n        });\n        prevValues = dataValues;\n      };\n\n      const color = getGraphColorByIndex(colorIndex, this._computedStyle!);\n      colorIndex++;\n\n      const statTypes: this[\"statTypes\"] = [];\n\n      const drawBands =\n        this.statTypes.includes(\"mean\") && statisticsHaveType(stats, \"mean\");\n\n      const sortedTypes = drawBands\n        ? [...this.statTypes].sort((a, b) => {\n            if (a === \"min\" || b === \"max\") {\n              return -1;\n            }\n            if (a === \"max\" || b === \"min\") {\n              return +1;\n            }\n            return 0;\n          })\n        : this.statTypes;\n\n      sortedTypes.forEach((type) => {\n        if (statisticsHaveType(stats, type)) {\n          const band = drawBands && (type === \"min\" || type === \"max\");\n          statTypes.push(type);\n          statDataSets.push({\n            label: `${name} (${this.hass.localize(\n              `ui.components.statistics_charts.statistic_types.${type}`\n            )})\n            `,\n            fill: drawBands\n              ? type === \"min\"\n                ? \"+1\"\n                : type === \"max\"\n                ? \"-1\"\n                : false\n              : false,\n            borderColor: band ? color + \"7F\" : color,\n            backgroundColor: band ? color + \"3F\" : color + \"7F\",\n            pointRadius: 0,\n            data: [],\n            // @ts-ignore\n            unit: meta?.unit_of_measurement,\n            band,\n          });\n        }\n      });\n\n      let prevDate: Date | null = null;\n      // Process chart data.\n      let initVal: number | null = null;\n      let prevSum: number | null = null;\n      stats.forEach((stat) => {\n        const date = new Date(stat.start);\n        if (prevDate === date) {\n          return;\n        }\n        prevDate = date;\n        const dataValues: Array<number | null> = [];\n        statTypes.forEach((type) => {\n          let val: number | null;\n          if (type === \"sum\") {\n            if (!initVal) {\n              initVal = val = stat.state;\n              prevSum = stat.sum;\n            } else {\n              val = initVal + ((stat.sum || 0) - prevSum!);\n            }\n          } else {\n            val = stat[type];\n          }\n          dataValues.push(val !== null ? Math.round(val * 100) / 100 : null);\n        });\n        pushData(date, dataValues);\n      });\n\n      // Add an entry for final values\n      pushData(endTime, prevValues);\n\n      // Concat two arrays\n      Array.prototype.push.apply(totalDataSets, statDataSets);\n    });\n\n    if (unit !== null) {\n      this._chartOptions = {\n        ...this._chartOptions,\n        scales: {\n          ...this._chartOptions!.scales,\n          y: {\n            ...(this._chartOptions!.scales!.y as Record<string, unknown>),\n            title: { display: unit, text: unit },\n          },\n        },\n      };\n    }\n\n    this._chartData = {\n      datasets: totalDataSets,\n    };\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        min-height: 60px;\n      }\n      .info {\n        text-align: center;\n        line-height: 60px;\n        color: var(--secondary-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"statistics-chart\": StatisticsChart;\n  }\n}\n"],"names":[],"sourceRoot":""}