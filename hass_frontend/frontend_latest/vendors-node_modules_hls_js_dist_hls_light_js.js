/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_hls_js_dist_hls_light_js"],{

/***/ "./node_modules/hls.js/dist/hls.light.js":
/*!***********************************************!*\
  !*** ./node_modules/hls.js/dist/hls.light.js ***!
  \***********************************************/
/***/ ((module) => {

eval("(function __HLS_WORKER_BUNDLE__(__IN_WORKER__) {\n  (function (global, factory) {\n     true ? module.exports = factory() : 0;\n  })(this, function () {\n    'use strict';\n\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread2(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n      });\n      return Constructor;\n    }\n    function _defineProperty(obj, key, value) {\n      key = _toPropertyKey(key);\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function _extends() {\n      _extends = Object.assign ? Object.assign.bind() : function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function _inheritsLoose(subClass, superClass) {\n      subClass.prototype = Object.create(superClass.prototype);\n      subClass.prototype.constructor = subClass;\n      _setPrototypeOf(subClass, superClass);\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n      if (Reflect.construct.sham) return false;\n      if (typeof Proxy === \"function\") return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _construct(Parent, args, Class) {\n      if (_isNativeReflectConstruct()) {\n        _construct = Reflect.construct.bind();\n      } else {\n        _construct = function _construct(Parent, args, Class) {\n          var a = [null];\n          a.push.apply(a, args);\n          var Constructor = Function.bind.apply(Parent, a);\n          var instance = new Constructor();\n          if (Class) _setPrototypeOf(instance, Class.prototype);\n          return instance;\n        };\n      }\n      return _construct.apply(null, arguments);\n    }\n    function _isNativeFunction(fn) {\n      return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n    }\n    function _wrapNativeSuper(Class) {\n      var _cache = typeof Map === \"function\" ? new Map() : undefined;\n      _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (Class === null || !_isNativeFunction(Class)) return Class;\n        if (typeof Class !== \"function\") {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n          if (_cache.has(Class)) return _cache.get(Class);\n          _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n          return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n          constructor: {\n            value: Wrapper,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n      };\n      return _wrapNativeSuper(Class);\n    }\n    function _assertThisInitialized(self) {\n      if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self;\n    }\n    function _toPrimitive(input, hint) {\n      if (typeof input !== \"object\" || input === null) return input;\n      var prim = input[Symbol.toPrimitive];\n      if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n      }\n      return (hint === \"string\" ? String : Number)(input);\n    }\n    function _toPropertyKey(arg) {\n      var key = _toPrimitive(arg, \"string\");\n      return typeof key === \"symbol\" ? key : String(key);\n    }\n    function getDefaultExportFromCjs(x) {\n      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n    }\n    var urlToolkit = {\n      exports: {}\n    };\n    (function (module, exports) {\n      // see https://tools.ietf.org/html/rfc1808\n\n      (function (root) {\n        var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n        var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n        var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n        var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n        var URLToolkit = {\n          // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n          // E.g\n          // With opts.alwaysNormalize = false (default, spec compliant)\n          // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n          // With opts.alwaysNormalize = true (not spec compliant)\n          // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n          buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n            opts = opts || {};\n            // remove any remaining space and CRLF\n            baseURL = baseURL.trim();\n            relativeURL = relativeURL.trim();\n            if (!relativeURL) {\n              // 2a) If the embedded URL is entirely empty, it inherits the\n              // entire base URL (i.e., is set equal to the base URL)\n              // and we are done.\n              if (!opts.alwaysNormalize) {\n                return baseURL;\n              }\n              var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n              if (!basePartsForNormalise) {\n                throw new Error('Error trying to parse base URL.');\n              }\n              basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\n              return URLToolkit.buildURLFromParts(basePartsForNormalise);\n            }\n            var relativeParts = URLToolkit.parseURL(relativeURL);\n            if (!relativeParts) {\n              throw new Error('Error trying to parse relative URL.');\n            }\n            if (relativeParts.scheme) {\n              // 2b) If the embedded URL starts with a scheme name, it is\n              // interpreted as an absolute URL and we are done.\n              if (!opts.alwaysNormalize) {\n                return relativeURL;\n              }\n              relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n              return URLToolkit.buildURLFromParts(relativeParts);\n            }\n            var baseParts = URLToolkit.parseURL(baseURL);\n            if (!baseParts) {\n              throw new Error('Error trying to parse base URL.');\n            }\n            if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n              // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n              // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n              var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n              baseParts.netLoc = pathParts[1];\n              baseParts.path = pathParts[2];\n            }\n            if (baseParts.netLoc && !baseParts.path) {\n              baseParts.path = '/';\n            }\n            var builtParts = {\n              // 2c) Otherwise, the embedded URL inherits the scheme of\n              // the base URL.\n              scheme: baseParts.scheme,\n              netLoc: relativeParts.netLoc,\n              path: null,\n              params: relativeParts.params,\n              query: relativeParts.query,\n              fragment: relativeParts.fragment\n            };\n            if (!relativeParts.netLoc) {\n              // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n              // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n              // (if any) of the base URL.\n              builtParts.netLoc = baseParts.netLoc;\n              // 4) If the embedded URL path is preceded by a slash \"/\", the\n              // path is not relative and we skip to Step 7.\n              if (relativeParts.path[0] !== '/') {\n                if (!relativeParts.path) {\n                  // 5) If the embedded URL path is empty (and not preceded by a\n                  // slash), then the embedded URL inherits the base URL path\n                  builtParts.path = baseParts.path;\n                  // 5a) if the embedded URL's <params> is non-empty, we skip to\n                  // step 7; otherwise, it inherits the <params> of the base\n                  // URL (if any) and\n                  if (!relativeParts.params) {\n                    builtParts.params = baseParts.params;\n                    // 5b) if the embedded URL's <query> is non-empty, we skip to\n                    // step 7; otherwise, it inherits the <query> of the base\n                    // URL (if any) and we skip to step 7.\n                    if (!relativeParts.query) {\n                      builtParts.query = baseParts.query;\n                    }\n                  }\n                } else {\n                  // 6) The last segment of the base URL's path (anything\n                  // following the rightmost slash \"/\", or the entire path if no\n                  // slash is present) is removed and the embedded URL's path is\n                  // appended in its place.\n                  var baseURLPath = baseParts.path;\n                  var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;\n                  builtParts.path = URLToolkit.normalizePath(newPath);\n                }\n              }\n            }\n            if (builtParts.path === null) {\n              builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\n            }\n            return URLToolkit.buildURLFromParts(builtParts);\n          },\n          parseURL: function (url) {\n            var parts = URL_REGEX.exec(url);\n            if (!parts) {\n              return null;\n            }\n            return {\n              scheme: parts[1] || '',\n              netLoc: parts[2] || '',\n              path: parts[3] || '',\n              params: parts[4] || '',\n              query: parts[5] || '',\n              fragment: parts[6] || ''\n            };\n          },\n          normalizePath: function (path) {\n            // The following operations are\n            // then applied, in order, to the new path:\n            // 6a) All occurrences of \"./\", where \".\" is a complete path\n            // segment, are removed.\n            // 6b) If the path ends with \".\" as a complete path segment,\n            // that \".\" is removed.\n            path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n            // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n            // complete path segment not equal to \"..\", are removed.\n            // Removal of these path segments is performed iteratively,\n            // removing the leftmost matching pattern on each iteration,\n            // until no matching pattern remains.\n            // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n            // complete path segment not equal to \"..\", that\n            // \"<segment>/..\" is removed.\n            while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {}\n            return path.split('').reverse().join('');\n          },\n          buildURLFromParts: function (parts) {\n            return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\n          }\n        };\n        module.exports = URLToolkit;\n      })();\n    })(urlToolkit);\n    var urlToolkitExports = urlToolkit.exports;\n    var isFiniteNumber = Number.isFinite || function (value) {\n      return typeof value === 'number' && isFinite(value);\n    };\n    var Events = /*#__PURE__*/function (Events) {\n      Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n      Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n      Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n      Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n      Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n      Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n      Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n      Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n      Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n      Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n      Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n      Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n      Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n      Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n      Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n      Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n      Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n      Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n      Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n      Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n      Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n      Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n      Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n      Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n      Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n      Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n      Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n      Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n      Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n      Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n      Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n      Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n      Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n      Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n      Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n      Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n      Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n      Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n      Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n      Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n      Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n      Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n      Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n      Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n      Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n      Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n      Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n      Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n      Events[\"ERROR\"] = \"hlsError\";\n      Events[\"DESTROYING\"] = \"hlsDestroying\";\n      Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n      Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n      Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n      Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n      return Events;\n    }({});\n\n    /**\n     * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n     */\n\n    var ErrorTypes = /*#__PURE__*/function (ErrorTypes) {\n      ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n      ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n      ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n      ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n      ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n      return ErrorTypes;\n    }({});\n    var ErrorDetails = /*#__PURE__*/function (ErrorDetails) {\n      ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n      ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n      ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n      ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n      ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n      ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n      ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n      ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n      ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n      ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n      ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n      ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n      ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n      ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n      ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n      ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n      ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n      ErrorDetails[\"LEVEL_PARSING_ERROR\"] = \"levelParsingError\";\n      ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n      ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n      ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n      ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n      ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n      ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n      ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n      ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n      ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n      ErrorDetails[\"FRAG_GAP\"] = \"fragGap\";\n      ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n      ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n      ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n      ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n      ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n      ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n      ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n      ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n      ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n      ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n      ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n      ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n      ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n      ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n      return ErrorDetails;\n    }({});\n    var noop = function noop() {};\n    var fakeLogger = {\n      trace: noop,\n      debug: noop,\n      log: noop,\n      warn: noop,\n      info: noop,\n      error: noop\n    };\n    var exportedLogger = fakeLogger;\n\n    // let lastCallTime;\n    // function formatMsgWithTimeInfo(type, msg) {\n    //   const now = Date.now();\n    //   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n    //   lastCallTime = now;\n    //   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n    //   return msg;\n    // }\n\n    function consolePrintFn(type) {\n      var func = self.console[type];\n      if (func) {\n        return func.bind(self.console, \"[\" + type + \"] >\");\n      }\n      return noop;\n    }\n    function exportLoggerFunctions(debugConfig) {\n      for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        functions[_key - 1] = arguments[_key];\n      }\n      functions.forEach(function (type) {\n        exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n      });\n    }\n    function enableLogs(debugConfig, id) {\n      // check that console is available\n      if (self.console && debugConfig === true || typeof debugConfig === 'object') {\n        exportLoggerFunctions(debugConfig,\n        // Remove out from list here to hard-disable a log-level\n        // 'trace',\n        'debug', 'log', 'info', 'warn', 'error');\n        // Some browsers don't allow to use bind on console object anyway\n        // fallback to default if needed\n        try {\n          exportedLogger.log(\"Debug logs enabled for \\\"\" + id + \"\\\" in hls.js version \" + \"1.4.4\");\n        } catch (e) {\n          exportedLogger = fakeLogger;\n        }\n      } else {\n        exportedLogger = fakeLogger;\n      }\n    }\n    var logger = exportedLogger;\n    var DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\n    var ATTR_LIST_REGEX = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\n\n    // adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\n    var AttrList = /*#__PURE__*/function () {\n      function AttrList(attrs) {\n        if (typeof attrs === 'string') {\n          attrs = AttrList.parseAttrList(attrs);\n        }\n        for (var attr in attrs) {\n          if (attrs.hasOwnProperty(attr)) {\n            if (attr.substring(0, 2) === 'X-') {\n              this.clientAttrs = this.clientAttrs || [];\n              this.clientAttrs.push(attr);\n            }\n            this[attr] = attrs[attr];\n          }\n        }\n      }\n      var _proto = AttrList.prototype;\n      _proto.decimalInteger = function decimalInteger(attrName) {\n        var intValue = parseInt(this[attrName], 10);\n        if (intValue > Number.MAX_SAFE_INTEGER) {\n          return Infinity;\n        }\n        return intValue;\n      };\n      _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {\n        if (this[attrName]) {\n          var stringValue = (this[attrName] || '0x').slice(2);\n          stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n          var value = new Uint8Array(stringValue.length / 2);\n          for (var i = 0; i < stringValue.length / 2; i++) {\n            value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n          }\n          return value;\n        } else {\n          return null;\n        }\n      };\n      _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {\n        var intValue = parseInt(this[attrName], 16);\n        if (intValue > Number.MAX_SAFE_INTEGER) {\n          return Infinity;\n        }\n        return intValue;\n      };\n      _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {\n        return parseFloat(this[attrName]);\n      };\n      _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {\n        var value = this[attrName];\n        return value ? parseFloat(value) : defaultValue;\n      };\n      _proto.enumeratedString = function enumeratedString(attrName) {\n        return this[attrName];\n      };\n      _proto.bool = function bool(attrName) {\n        return this[attrName] === 'YES';\n      };\n      _proto.decimalResolution = function decimalResolution(attrName) {\n        var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n        if (res === null) {\n          return undefined;\n        }\n        return {\n          width: parseInt(res[1], 10),\n          height: parseInt(res[2], 10)\n        };\n      };\n      AttrList.parseAttrList = function parseAttrList(input) {\n        var match;\n        var attrs = {};\n        var quote = '\"';\n        ATTR_LIST_REGEX.lastIndex = 0;\n        while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n          var value = match[2];\n          if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n            value = value.slice(1, -1);\n          }\n          var name = match[1].trim();\n          attrs[name] = value;\n        }\n        return attrs;\n      };\n      return AttrList;\n    }();\n\n    // Avoid exporting const enum so that these values can be inlined\n\n    function isDateRangeCueAttribute(attrName) {\n      return attrName !== \"ID\" && attrName !== \"CLASS\" && attrName !== \"START-DATE\" && attrName !== \"DURATION\" && attrName !== \"END-DATE\" && attrName !== \"END-ON-NEXT\";\n    }\n    function isSCTE35Attribute(attrName) {\n      return attrName === \"SCTE35-OUT\" || attrName === \"SCTE35-IN\";\n    }\n    var DateRange = /*#__PURE__*/function () {\n      function DateRange(dateRangeAttr, dateRangeWithSameId) {\n        this.attr = void 0;\n        this._startDate = void 0;\n        this._endDate = void 0;\n        this._badValueForSameId = void 0;\n        if (dateRangeWithSameId) {\n          var previousAttr = dateRangeWithSameId.attr;\n          for (var key in previousAttr) {\n            if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n              logger.warn(\"DATERANGE tag attribute: \\\"\" + key + \"\\\" does not match for tags with ID: \\\"\" + dateRangeAttr.ID + \"\\\"\");\n              this._badValueForSameId = key;\n              break;\n            }\n          }\n          // Merge DateRange tags with the same ID\n          dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);\n        }\n        this.attr = dateRangeAttr;\n        this._startDate = new Date(dateRangeAttr[\"START-DATE\"]);\n        if (\"END-DATE\" in this.attr) {\n          var endDate = new Date(this.attr[\"END-DATE\"]);\n          if (isFiniteNumber(endDate.getTime())) {\n            this._endDate = endDate;\n          }\n        }\n      }\n      _createClass(DateRange, [{\n        key: \"id\",\n        get: function get() {\n          return this.attr.ID;\n        }\n      }, {\n        key: \"class\",\n        get: function get() {\n          return this.attr.CLASS;\n        }\n      }, {\n        key: \"startDate\",\n        get: function get() {\n          return this._startDate;\n        }\n      }, {\n        key: \"endDate\",\n        get: function get() {\n          if (this._endDate) {\n            return this._endDate;\n          }\n          var duration = this.duration;\n          if (duration !== null) {\n            return new Date(this._startDate.getTime() + duration * 1000);\n          }\n          return null;\n        }\n      }, {\n        key: \"duration\",\n        get: function get() {\n          if (\"DURATION\" in this.attr) {\n            var duration = this.attr.decimalFloatingPoint(\"DURATION\");\n            if (isFiniteNumber(duration)) {\n              return duration;\n            }\n          } else if (this._endDate) {\n            return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n          }\n          return null;\n        }\n      }, {\n        key: \"plannedDuration\",\n        get: function get() {\n          if (\"PLANNED-DURATION\" in this.attr) {\n            return this.attr.decimalFloatingPoint(\"PLANNED-DURATION\");\n          }\n          return null;\n        }\n      }, {\n        key: \"endOnNext\",\n        get: function get() {\n          return this.attr.bool(\"END-ON-NEXT\");\n        }\n      }, {\n        key: \"isValid\",\n        get: function get() {\n          return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);\n        }\n      }]);\n      return DateRange;\n    }();\n    var LoadStats = function LoadStats() {\n      this.aborted = false;\n      this.loaded = 0;\n      this.retry = 0;\n      this.total = 0;\n      this.chunkCount = 0;\n      this.bwEstimate = 0;\n      this.loading = {\n        start: 0,\n        first: 0,\n        end: 0\n      };\n      this.parsing = {\n        start: 0,\n        end: 0\n      };\n      this.buffering = {\n        start: 0,\n        first: 0,\n        end: 0\n      };\n    };\n    var ElementaryStreamTypes = {\n      AUDIO: \"audio\",\n      VIDEO: \"video\",\n      AUDIOVIDEO: \"audiovideo\"\n    };\n    var BaseSegment = /*#__PURE__*/function () {\n      // baseurl is the URL to the playlist\n\n      // relurl is the portion of the URL that comes from inside the playlist.\n\n      // Holds the types of data this fragment supports\n\n      function BaseSegment(baseurl) {\n        var _this$elementaryStrea;\n        this._byteRange = null;\n        this._url = null;\n        this.baseurl = void 0;\n        this.relurl = void 0;\n        this.elementaryStreams = (_this$elementaryStrea = {}, _this$elementaryStrea[ElementaryStreamTypes.AUDIO] = null, _this$elementaryStrea[ElementaryStreamTypes.VIDEO] = null, _this$elementaryStrea[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$elementaryStrea);\n        this.baseurl = baseurl;\n      }\n\n      // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n      var _proto = BaseSegment.prototype;\n      _proto.setByteRange = function setByteRange(value, previous) {\n        var params = value.split('@', 2);\n        var byteRange = [];\n        if (params.length === 1) {\n          byteRange[0] = previous ? previous.byteRangeEndOffset : 0;\n        } else {\n          byteRange[0] = parseInt(params[1]);\n        }\n        byteRange[1] = parseInt(params[0]) + byteRange[0];\n        this._byteRange = byteRange;\n      };\n      _createClass(BaseSegment, [{\n        key: \"byteRange\",\n        get: function get() {\n          if (!this._byteRange) {\n            return [];\n          }\n          return this._byteRange;\n        }\n      }, {\n        key: \"byteRangeStartOffset\",\n        get: function get() {\n          return this.byteRange[0];\n        }\n      }, {\n        key: \"byteRangeEndOffset\",\n        get: function get() {\n          return this.byteRange[1];\n        }\n      }, {\n        key: \"url\",\n        get: function get() {\n          if (!this._url && this.baseurl && this.relurl) {\n            this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {\n              alwaysNormalize: true\n            });\n          }\n          return this._url || '';\n        },\n        set: function set(value) {\n          this._url = value;\n        }\n      }]);\n      return BaseSegment;\n    }();\n\n    /**\n     * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n     */\n    var Fragment = /*#__PURE__*/function (_BaseSegment) {\n      _inheritsLoose(Fragment, _BaseSegment);\n      // EXTINF has to be present for a m3u8 to be considered valid\n\n      // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n\n      // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n      // core difference from the private field _decryptdata is the lack of the initialized IV\n      // _decryptdata will set the IV for this segment based on the segment number in the fragment\n\n      // A string representing the fragment type\n\n      // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n\n      // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n\n      // The level/track index to which the fragment belongs\n\n      // The continuity counter of the fragment\n\n      // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n\n      // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n\n      // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n\n      // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n\n      // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n\n      // Set by `updateFragPTSDTS` in level-helper\n\n      // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n\n      // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n\n      // Load/parse timing information\n\n      // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n\n      // #EXTINF  segment title\n\n      // The Media Initialization Section for this segment\n\n      // Fragment is the last fragment in the media playlist\n\n      // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n\n      function Fragment(type, baseurl) {\n        var _this;\n        _this = _BaseSegment.call(this, baseurl) || this;\n        _this._decryptdata = null;\n        _this.rawProgramDateTime = null;\n        _this.programDateTime = null;\n        _this.tagList = [];\n        _this.duration = 0;\n        _this.sn = 0;\n        _this.levelkeys = void 0;\n        _this.type = void 0;\n        _this.loader = null;\n        _this.keyLoader = null;\n        _this.level = -1;\n        _this.cc = 0;\n        _this.startPTS = void 0;\n        _this.endPTS = void 0;\n        _this.startDTS = void 0;\n        _this.endDTS = void 0;\n        _this.start = 0;\n        _this.deltaPTS = void 0;\n        _this.maxStartPTS = void 0;\n        _this.minEndPTS = void 0;\n        _this.stats = new LoadStats();\n        _this.urlId = 0;\n        _this.data = void 0;\n        _this.bitrateTest = false;\n        _this.title = null;\n        _this.initSegment = null;\n        _this.endList = void 0;\n        _this.gap = void 0;\n        _this.type = type;\n        return _this;\n      }\n      var _proto2 = Fragment.prototype;\n      _proto2.setKeyFormat = function setKeyFormat(keyFormat) {\n        if (this.levelkeys) {\n          var _key = this.levelkeys[keyFormat];\n          if (_key && !this._decryptdata) {\n            this._decryptdata = _key.getDecryptData(this.sn);\n          }\n        }\n      };\n      _proto2.abortRequests = function abortRequests() {\n        var _this$loader, _this$keyLoader;\n        (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();\n        (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();\n      };\n      _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {\n        if (partial === void 0) {\n          partial = false;\n        }\n        var elementaryStreams = this.elementaryStreams;\n        var info = elementaryStreams[type];\n        if (!info) {\n          elementaryStreams[type] = {\n            startPTS: startPTS,\n            endPTS: endPTS,\n            startDTS: startDTS,\n            endDTS: endDTS,\n            partial: partial\n          };\n          return;\n        }\n        info.startPTS = Math.min(info.startPTS, startPTS);\n        info.endPTS = Math.max(info.endPTS, endPTS);\n        info.startDTS = Math.min(info.startDTS, startDTS);\n        info.endDTS = Math.max(info.endDTS, endDTS);\n      };\n      _proto2.clearElementaryStreamInfo = function clearElementaryStreamInfo() {\n        var elementaryStreams = this.elementaryStreams;\n        elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n        elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n        elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n      };\n      _createClass(Fragment, [{\n        key: \"decryptdata\",\n        get: function get() {\n          var levelkeys = this.levelkeys;\n          if (!levelkeys && !this._decryptdata) {\n            return null;\n          }\n          if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n            var _key2 = this.levelkeys.identity;\n            if (_key2) {\n              this._decryptdata = _key2.getDecryptData(this.sn);\n            } else {\n              var keyFormats = Object.keys(this.levelkeys);\n              if (keyFormats.length === 1) {\n                return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);\n              }\n            }\n          }\n          return this._decryptdata;\n        }\n      }, {\n        key: \"end\",\n        get: function get() {\n          return this.start + this.duration;\n        }\n      }, {\n        key: \"endProgramDateTime\",\n        get: function get() {\n          if (this.programDateTime === null) {\n            return null;\n          }\n          if (!isFiniteNumber(this.programDateTime)) {\n            return null;\n          }\n          var duration = !isFiniteNumber(this.duration) ? 0 : this.duration;\n          return this.programDateTime + duration * 1000;\n        }\n      }, {\n        key: \"encrypted\",\n        get: function get() {\n          var _this$_decryptdata;\n          // At the m3u8-parser level we need to add support for manifest signalled keyformats\n          // when we want the fragment to start reporting that it is encrypted.\n          // Currently, keyFormat will only be set for identity keys\n          if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {\n            return true;\n          } else if (this.levelkeys) {\n            var keyFormats = Object.keys(this.levelkeys);\n            var len = keyFormats.length;\n            if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }]);\n      return Fragment;\n    }(BaseSegment);\n\n    /**\n     * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n     */\n    var Part = /*#__PURE__*/function (_BaseSegment2) {\n      _inheritsLoose(Part, _BaseSegment2);\n      function Part(partAttrs, frag, baseurl, index, previous) {\n        var _this2;\n        _this2 = _BaseSegment2.call(this, baseurl) || this;\n        _this2.fragOffset = 0;\n        _this2.duration = 0;\n        _this2.gap = false;\n        _this2.independent = false;\n        _this2.relurl = void 0;\n        _this2.fragment = void 0;\n        _this2.index = void 0;\n        _this2.stats = new LoadStats();\n        _this2.duration = partAttrs.decimalFloatingPoint('DURATION');\n        _this2.gap = partAttrs.bool('GAP');\n        _this2.independent = partAttrs.bool('INDEPENDENT');\n        _this2.relurl = partAttrs.enumeratedString('URI');\n        _this2.fragment = frag;\n        _this2.index = index;\n        var byteRange = partAttrs.enumeratedString('BYTERANGE');\n        if (byteRange) {\n          _this2.setByteRange(byteRange, previous);\n        }\n        if (previous) {\n          _this2.fragOffset = previous.fragOffset + previous.duration;\n        }\n        return _this2;\n      }\n      _createClass(Part, [{\n        key: \"start\",\n        get: function get() {\n          return this.fragment.start + this.fragOffset;\n        }\n      }, {\n        key: \"end\",\n        get: function get() {\n          return this.start + this.duration;\n        }\n      }, {\n        key: \"loaded\",\n        get: function get() {\n          var elementaryStreams = this.elementaryStreams;\n          return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n        }\n      }]);\n      return Part;\n    }(BaseSegment);\n    var DEFAULT_TARGET_DURATION = 10;\n\n    /**\n     * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.\n     */\n    var LevelDetails = /*#__PURE__*/function () {\n      // Manifest reload synchronization\n\n      function LevelDetails(baseUrl) {\n        this.PTSKnown = false;\n        this.alignedSliding = false;\n        this.averagetargetduration = void 0;\n        this.endCC = 0;\n        this.endSN = 0;\n        this.fragments = void 0;\n        this.fragmentHint = void 0;\n        this.partList = null;\n        this.dateRanges = void 0;\n        this.live = true;\n        this.ageHeader = 0;\n        this.advancedDateTime = void 0;\n        this.updated = true;\n        this.advanced = true;\n        this.availabilityDelay = void 0;\n        this.misses = 0;\n        this.startCC = 0;\n        this.startSN = 0;\n        this.startTimeOffset = null;\n        this.targetduration = 0;\n        this.totalduration = 0;\n        this.type = null;\n        this.url = void 0;\n        this.m3u8 = '';\n        this.version = null;\n        this.canBlockReload = false;\n        this.canSkipUntil = 0;\n        this.canSkipDateRanges = false;\n        this.skippedSegments = 0;\n        this.recentlyRemovedDateranges = void 0;\n        this.partHoldBack = 0;\n        this.holdBack = 0;\n        this.partTarget = 0;\n        this.preloadHint = void 0;\n        this.renditionReports = void 0;\n        this.tuneInGoal = 0;\n        this.deltaUpdateFailed = void 0;\n        this.driftStartTime = 0;\n        this.driftEndTime = 0;\n        this.driftStart = 0;\n        this.driftEnd = 0;\n        this.encryptedFragments = void 0;\n        this.playlistParsingError = null;\n        this.variableList = null;\n        this.hasVariableRefs = false;\n        this.fragments = [];\n        this.encryptedFragments = [];\n        this.dateRanges = {};\n        this.url = baseUrl;\n      }\n      var _proto = LevelDetails.prototype;\n      _proto.reloaded = function reloaded(previous) {\n        if (!previous) {\n          this.advanced = true;\n          this.updated = true;\n          return;\n        }\n        var partSnDiff = this.lastPartSn - previous.lastPartSn;\n        var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n        this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff;\n        this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n        if (this.updated || this.advanced) {\n          this.misses = Math.floor(previous.misses * 0.6);\n        } else {\n          this.misses = previous.misses + 1;\n        }\n        this.availabilityDelay = previous.availabilityDelay;\n      };\n      _createClass(LevelDetails, [{\n        key: \"hasProgramDateTime\",\n        get: function get() {\n          if (this.fragments.length) {\n            return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);\n          }\n          return false;\n        }\n      }, {\n        key: \"levelTargetDuration\",\n        get: function get() {\n          return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n        }\n      }, {\n        key: \"drift\",\n        get: function get() {\n          var runTime = this.driftEndTime - this.driftStartTime;\n          if (runTime > 0) {\n            var runDuration = this.driftEnd - this.driftStart;\n            return runDuration * 1000 / runTime;\n          }\n          return 1;\n        }\n      }, {\n        key: \"edge\",\n        get: function get() {\n          return this.partEnd || this.fragmentEnd;\n        }\n      }, {\n        key: \"partEnd\",\n        get: function get() {\n          var _this$partList;\n          if ((_this$partList = this.partList) != null && _this$partList.length) {\n            return this.partList[this.partList.length - 1].end;\n          }\n          return this.fragmentEnd;\n        }\n      }, {\n        key: \"fragmentEnd\",\n        get: function get() {\n          var _this$fragments;\n          if ((_this$fragments = this.fragments) != null && _this$fragments.length) {\n            return this.fragments[this.fragments.length - 1].end;\n          }\n          return 0;\n        }\n      }, {\n        key: \"age\",\n        get: function get() {\n          if (this.advancedDateTime) {\n            return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n          }\n          return 0;\n        }\n      }, {\n        key: \"lastPartIndex\",\n        get: function get() {\n          var _this$partList2;\n          if ((_this$partList2 = this.partList) != null && _this$partList2.length) {\n            return this.partList[this.partList.length - 1].index;\n          }\n          return -1;\n        }\n      }, {\n        key: \"lastPartSn\",\n        get: function get() {\n          var _this$partList3;\n          if ((_this$partList3 = this.partList) != null && _this$partList3.length) {\n            return this.partList[this.partList.length - 1].fragment.sn;\n          }\n          return this.endSN;\n        }\n      }]);\n      return LevelDetails;\n    }();\n\n    // This file is inserted as a shim for modules which we do not want to include into the distro.\n    // This replacement is done in the \"alias\" plugin of the rollup config.\n    var empty = undefined;\n    var Cues = /*@__PURE__*/getDefaultExportFromCjs(empty);\n    function sliceUint8(array, start, end) {\n      // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n      // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n      return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));\n    }\n\n    // breaking up those two types in order to clarify what is happening in the decoding path.\n\n    /**\n     * Returns true if an ID3 header can be found at offset in data\n     * @param data - The data to search\n     * @param offset - The offset at which to start searching\n     */\n    var isHeader$2 = function isHeader(data, offset) {\n      /*\n       * http://id3.org/id3v2.3.0\n       * [0]     = 'I'\n       * [1]     = 'D'\n       * [2]     = '3'\n       * [3,4]   = {Version}\n       * [5]     = {Flags}\n       * [6-9]   = {ID3 Size}\n       *\n       * An ID3v2 tag can be detected with the following pattern:\n       *  $49 44 33 yy yy xx zz zz zz zz\n       * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n       */\n      if (offset + 10 <= data.length) {\n        // look for 'ID3' identifier\n        if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n          // check version is within range\n          if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n            // check size is within range\n            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n\n    /**\n     * Returns true if an ID3 footer can be found at offset in data\n     * @param data - The data to search\n     * @param offset - The offset at which to start searching\n     */\n    var isFooter = function isFooter(data, offset) {\n      /*\n       * The footer is a copy of the header, but with a different identifier\n       */\n      if (offset + 10 <= data.length) {\n        // look for '3DI' identifier\n        if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n          // check version is within range\n          if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n            // check size is within range\n            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n\n    /**\n     * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n     * @param data - The data to search in\n     * @param offset - The offset at which to start searching\n     * @returns the block of data containing any ID3 tags found\n     * or *undefined* if no header is found at the starting offset\n     */\n    var getID3Data = function getID3Data(data, offset) {\n      var front = offset;\n      var length = 0;\n      while (isHeader$2(data, offset)) {\n        // ID3 header is 10 bytes\n        length += 10;\n        var size = readSize(data, offset + 6);\n        length += size;\n        if (isFooter(data, offset + 10)) {\n          // ID3 footer is 10 bytes\n          length += 10;\n        }\n        offset += length;\n      }\n      if (length > 0) {\n        return data.subarray(front, front + length);\n      }\n      return undefined;\n    };\n    var readSize = function readSize(data, offset) {\n      var size = 0;\n      size = (data[offset] & 0x7f) << 21;\n      size |= (data[offset + 1] & 0x7f) << 14;\n      size |= (data[offset + 2] & 0x7f) << 7;\n      size |= data[offset + 3] & 0x7f;\n      return size;\n    };\n    var canParse$2 = function canParse(data, offset) {\n      return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;\n    };\n\n    /**\n     * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n     * @param data - Block of data containing one or more ID3 tags\n     */\n    var getTimeStamp = function getTimeStamp(data) {\n      var frames = getID3Frames(data);\n      for (var i = 0; i < frames.length; i++) {\n        var frame = frames[i];\n        if (isTimeStampFrame(frame)) {\n          return readTimeStamp(frame);\n        }\n      }\n      return undefined;\n    };\n\n    /**\n     * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n     */\n    var isTimeStampFrame = function isTimeStampFrame(frame) {\n      return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n    };\n    var getFrameData = function getFrameData(data) {\n      /*\n      Frame ID       $xx xx xx xx (four characters)\n      Size           $xx xx xx xx\n      Flags          $xx xx\n      */\n      var type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n      var size = readSize(data, 4);\n\n      // skip frame id, size, and flags\n      var offset = 10;\n      return {\n        type: type,\n        size: size,\n        data: data.subarray(offset, offset + size)\n      };\n    };\n\n    /**\n     * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n     * @param id3Data - The ID3 data containing one or more ID3 tags\n     */\n    var getID3Frames = function getID3Frames(id3Data) {\n      var offset = 0;\n      var frames = [];\n      while (isHeader$2(id3Data, offset)) {\n        var size = readSize(id3Data, offset + 6);\n        // skip past ID3 header\n        offset += 10;\n        var end = offset + size;\n        // loop through frames in the ID3 tag\n        while (offset + 8 < end) {\n          var frameData = getFrameData(id3Data.subarray(offset));\n          var frame = decodeFrame(frameData);\n          if (frame) {\n            frames.push(frame);\n          }\n\n          // skip frame header and frame data\n          offset += frameData.size + 10;\n        }\n        if (isFooter(id3Data, offset)) {\n          offset += 10;\n        }\n      }\n      return frames;\n    };\n    var decodeFrame = function decodeFrame(frame) {\n      if (frame.type === 'PRIV') {\n        return decodePrivFrame(frame);\n      } else if (frame.type[0] === 'W') {\n        return decodeURLFrame(frame);\n      }\n      return decodeTextFrame(frame);\n    };\n    var decodePrivFrame = function decodePrivFrame(frame) {\n      /*\n      Format: <text string>\\0<binary data>\n      */\n      if (frame.size < 2) {\n        return undefined;\n      }\n      var owner = utf8ArrayToStr(frame.data, true);\n      var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n      return {\n        key: frame.type,\n        info: owner,\n        data: privateData.buffer\n      };\n    };\n    var decodeTextFrame = function decodeTextFrame(frame) {\n      if (frame.size < 2) {\n        return undefined;\n      }\n      if (frame.type === 'TXXX') {\n        /*\n        Format:\n        [0]   = {Text Encoding}\n        [1-?] = {Description}\\0{Value}\n        */\n        var index = 1;\n        var description = utf8ArrayToStr(frame.data.subarray(index), true);\n        index += description.length + 1;\n        var value = utf8ArrayToStr(frame.data.subarray(index));\n        return {\n          key: frame.type,\n          info: description,\n          data: value\n        };\n      }\n      /*\n      Format:\n      [0]   = {Text Encoding}\n      [1-?] = {Value}\n      */\n      var text = utf8ArrayToStr(frame.data.subarray(1));\n      return {\n        key: frame.type,\n        data: text\n      };\n    };\n    var decodeURLFrame = function decodeURLFrame(frame) {\n      if (frame.type === 'WXXX') {\n        /*\n        Format:\n        [0]   = {Text Encoding}\n        [1-?] = {Description}\\0{URL}\n        */\n        if (frame.size < 2) {\n          return undefined;\n        }\n        var index = 1;\n        var description = utf8ArrayToStr(frame.data.subarray(index), true);\n        index += description.length + 1;\n        var value = utf8ArrayToStr(frame.data.subarray(index));\n        return {\n          key: frame.type,\n          info: description,\n          data: value\n        };\n      }\n      /*\n      Format:\n      [0-?] = {URL}\n      */\n      var url = utf8ArrayToStr(frame.data);\n      return {\n        key: frame.type,\n        data: url\n      };\n    };\n    var readTimeStamp = function readTimeStamp(timeStampFrame) {\n      if (timeStampFrame.data.byteLength === 8) {\n        var data = new Uint8Array(timeStampFrame.data);\n        // timestamp is 33 bit expressed as a big-endian eight-octet number,\n        // with the upper 31 bits set to zero.\n        var pts33Bit = data[3] & 0x1;\n        var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n        timestamp /= 45;\n        if (pts33Bit) {\n          timestamp += 47721858.84;\n        } // 2^32 / 90\n\n        return Math.round(timestamp);\n      }\n      return undefined;\n    };\n\n    // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n    // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n    /* utf.js - UTF-8 <=> UTF-16 convertion\n     *\n     * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n     * Version: 1.0\n     * LastModified: Dec 25 1999\n     * This library is free.  You can redistribute it and/or modify it.\n     */\n    var utf8ArrayToStr = function utf8ArrayToStr(array, exitOnNull) {\n      if (exitOnNull === void 0) {\n        exitOnNull = false;\n      }\n      var decoder = getTextDecoder();\n      if (decoder) {\n        var decoded = decoder.decode(array);\n        if (exitOnNull) {\n          // grab up to the first null\n          var idx = decoded.indexOf('\\0');\n          return idx !== -1 ? decoded.substring(0, idx) : decoded;\n        }\n\n        // remove any null characters\n        return decoded.replace(/\\0/g, '');\n      }\n      var len = array.length;\n      var c;\n      var char2;\n      var char3;\n      var out = '';\n      var i = 0;\n      while (i < len) {\n        c = array[i++];\n        if (c === 0x00 && exitOnNull) {\n          return out;\n        } else if (c === 0x00 || c === 0x03) {\n          // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n          continue;\n        }\n        switch (c >> 4) {\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n            // 0xxxxxxx\n            out += String.fromCharCode(c);\n            break;\n          case 12:\n          case 13:\n            // 110x xxxx   10xx xxxx\n            char2 = array[i++];\n            out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n            break;\n          case 14:\n            // 1110 xxxx  10xx xxxx  10xx xxxx\n            char2 = array[i++];\n            char3 = array[i++];\n            out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n            break;\n        }\n      }\n      return out;\n    };\n    var decoder;\n    function getTextDecoder() {\n      if (!decoder && typeof self.TextDecoder !== 'undefined') {\n        decoder = new self.TextDecoder('utf-8');\n      }\n      return decoder;\n    }\n\n    /**\n     *  hex dump helper class\n     */\n\n    var Hex = {\n      hexDump: function hexDump(array) {\n        var str = '';\n        for (var i = 0; i < array.length; i++) {\n          var h = array[i].toString(16);\n          if (h.length < 2) {\n            h = '0' + h;\n          }\n          str += h;\n        }\n        return str;\n      }\n    };\n    var UINT32_MAX$1 = Math.pow(2, 32) - 1;\n    var push = [].push;\n\n    // We are using fixed track IDs for driving the MP4 remuxer\n    // instead of following the TS PIDs.\n    // There is no reason not to do this and some browsers/SourceBuffer-demuxers\n    // may not like if there are TrackID \"switches\"\n    // See https://github.com/video-dev/hls.js/issues/1331\n    // Here we are mapping our internal track types to constant MP4 track IDs\n    // With MSE currently one can only have one track of each, and we are muxing\n    // whatever video/audio rendition in them.\n    var RemuxerTrackIdConfig = {\n      video: 1,\n      audio: 2,\n      id3: 3,\n      text: 4\n    };\n    function bin2str(data) {\n      return String.fromCharCode.apply(null, data);\n    }\n    function readUint16(buffer, offset) {\n      var val = buffer[offset] << 8 | buffer[offset + 1];\n      return val < 0 ? 65536 + val : val;\n    }\n    function readUint32(buffer, offset) {\n      var val = readSint32(buffer, offset);\n      return val < 0 ? 4294967296 + val : val;\n    }\n    function readSint32(buffer, offset) {\n      return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n    }\n    function writeUint32(buffer, offset, value) {\n      buffer[offset] = value >> 24;\n      buffer[offset + 1] = value >> 16 & 0xff;\n      buffer[offset + 2] = value >> 8 & 0xff;\n      buffer[offset + 3] = value & 0xff;\n    }\n\n    // Find the data for a box specified by its path\n    function findBox(data, path) {\n      var results = [];\n      if (!path.length) {\n        // short-circuit the search for empty paths\n        return results;\n      }\n      var end = data.byteLength;\n      for (var i = 0; i < end;) {\n        var size = readUint32(data, i);\n        var type = bin2str(data.subarray(i + 4, i + 8));\n        var endbox = size > 1 ? i + size : end;\n        if (type === path[0]) {\n          if (path.length === 1) {\n            // this is the end of the path and we've found the box we were\n            // looking for\n            results.push(data.subarray(i + 8, endbox));\n          } else {\n            // recursively search for the next box along the path\n            var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n            if (subresults.length) {\n              push.apply(results, subresults);\n            }\n          }\n        }\n        i = endbox;\n      }\n\n      // we've finished searching all of data\n      return results;\n    }\n    function parseSegmentIndex(sidx) {\n      var references = [];\n      var version = sidx[0];\n\n      // set initial offset, we skip the reference ID (not needed)\n      var index = 8;\n      var timescale = readUint32(sidx, index);\n      index += 4;\n\n      // TODO: parse earliestPresentationTime and firstOffset\n      // usually zero in our case\n      var earliestPresentationTime = 0;\n      var firstOffset = 0;\n      if (version === 0) {\n        index += 8;\n      } else {\n        index += 16;\n      }\n\n      // skip reserved\n      index += 2;\n      var startByte = sidx.length + firstOffset;\n      var referencesCount = readUint16(sidx, index);\n      index += 2;\n      for (var i = 0; i < referencesCount; i++) {\n        var referenceIndex = index;\n        var referenceInfo = readUint32(sidx, referenceIndex);\n        referenceIndex += 4;\n        var referenceSize = referenceInfo & 0x7fffffff;\n        var referenceType = (referenceInfo & 0x80000000) >>> 31;\n        if (referenceType === 1) {\n          logger.warn('SIDX has hierarchical references (not supported)');\n          return null;\n        }\n        var subsegmentDuration = readUint32(sidx, referenceIndex);\n        referenceIndex += 4;\n        references.push({\n          referenceSize: referenceSize,\n          subsegmentDuration: subsegmentDuration,\n          // unscaled\n          info: {\n            duration: subsegmentDuration / timescale,\n            start: startByte,\n            end: startByte + referenceSize - 1\n          }\n        });\n        startByte += referenceSize;\n\n        // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n        // for |sapDelta|.\n        referenceIndex += 4;\n\n        // skip to next ref\n        index = referenceIndex;\n      }\n      return {\n        earliestPresentationTime: earliestPresentationTime,\n        timescale: timescale,\n        version: version,\n        referencesCount: referencesCount,\n        references: references\n      };\n    }\n\n    /**\n     * Parses an MP4 initialization segment and extracts stream type and\n     * timescale values for any declared tracks. Timescale values indicate the\n     * number of clock ticks per second to assume for time-based values\n     * elsewhere in the MP4.\n     *\n     * To determine the start time of an MP4, you need two pieces of\n     * information: the timescale unit and the earliest base media decode\n     * time. Multiple timescales can be specified within an MP4 but the\n     * base media decode time is always expressed in the timescale from\n     * the media header box for the track:\n     * ```\n     * moov > trak > mdia > mdhd.timescale\n     * moov > trak > mdia > hdlr\n     * ```\n     * @param initSegment the bytes of the init segment\n     * @returns a hash of track type to timescale values or null if\n     * the init segment is malformed.\n     */\n\n    function parseInitSegment(initSegment) {\n      var result = [];\n      var traks = findBox(initSegment, ['moov', 'trak']);\n      for (var i = 0; i < traks.length; i++) {\n        var trak = traks[i];\n        var tkhd = findBox(trak, ['tkhd'])[0];\n        if (tkhd) {\n          var version = tkhd[0];\n          var _index = version === 0 ? 12 : 20;\n          var trackId = readUint32(tkhd, _index);\n          var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n          if (mdhd) {\n            version = mdhd[0];\n            _index = version === 0 ? 12 : 20;\n            var timescale = readUint32(mdhd, _index);\n            var hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n            if (hdlr) {\n              var hdlrType = bin2str(hdlr.subarray(8, 12));\n              var type = {\n                soun: ElementaryStreamTypes.AUDIO,\n                vide: ElementaryStreamTypes.VIDEO\n              }[hdlrType];\n              if (type) {\n                // Parse codec details\n                var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n                var codec = void 0;\n                if (stsd) {\n                  codec = bin2str(stsd.subarray(12, 16));\n                  // TODO: Parse codec details to be able to build MIME type.\n                  // stsd.start += 8;\n                  // const codecBox = findBox(stsd, [codec])[0];\n                  // if (codecBox) {\n                  //   TODO: Codec parsing support for avc1, mp4a, hevc, av01...\n                  // }\n                }\n\n                result[trackId] = {\n                  timescale: timescale,\n                  type: type\n                };\n                result[type] = {\n                  timescale: timescale,\n                  id: trackId,\n                  codec: codec\n                };\n              }\n            }\n          }\n        }\n      }\n      var trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n      trex.forEach(function (trex) {\n        var trackId = readUint32(trex, 4);\n        var track = result[trackId];\n        if (track) {\n          track.default = {\n            duration: readUint32(trex, 12),\n            flags: readUint32(trex, 20)\n          };\n        }\n      });\n      return result;\n    }\n    function patchEncyptionData(initSegment, decryptdata) {\n      if (!initSegment || !decryptdata) {\n        return initSegment;\n      }\n      var keyId = decryptdata.keyId;\n      if (keyId && decryptdata.isCommonEncryption) {\n        var traks = findBox(initSegment, ['moov', 'trak']);\n        traks.forEach(function (trak) {\n          var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n          // skip the sample entry count\n          var sampleEntries = stsd.subarray(8);\n          var encBoxes = findBox(sampleEntries, ['enca']);\n          var isAudio = encBoxes.length > 0;\n          if (!isAudio) {\n            encBoxes = findBox(sampleEntries, ['encv']);\n          }\n          encBoxes.forEach(function (enc) {\n            var encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n            var sinfBoxes = findBox(encBoxChildren, ['sinf']);\n            sinfBoxes.forEach(function (sinf) {\n              var tenc = parseSinf(sinf);\n              if (tenc) {\n                // Look for default key id (keyID offset is always 8 within the tenc box):\n                var tencKeyId = tenc.subarray(8, 24);\n                if (!tencKeyId.some(function (b) {\n                  return b !== 0;\n                })) {\n                  logger.log(\"[eme] Patching keyId in 'enc\" + (isAudio ? 'a' : 'v') + \">sinf>>tenc' box: \" + Hex.hexDump(tencKeyId) + \" -> \" + Hex.hexDump(keyId));\n                  tenc.set(keyId, 8);\n                }\n              }\n            });\n          });\n        });\n      }\n      return initSegment;\n    }\n    function parseSinf(sinf) {\n      var schm = findBox(sinf, ['schm'])[0];\n      if (schm) {\n        var scheme = bin2str(schm.subarray(4, 8));\n        if (scheme === 'cbcs' || scheme === 'cenc') {\n          return findBox(sinf, ['schi', 'tenc'])[0];\n        }\n      }\n      logger.error(\"[eme] missing 'schm' box\");\n      return null;\n    }\n\n    /**\n     * Determine the base media decode start time, in seconds, for an MP4\n     * fragment. If multiple fragments are specified, the earliest time is\n     * returned.\n     *\n     * The base media decode time can be parsed from track fragment\n     * metadata:\n     * ```\n     * moof > traf > tfdt.baseMediaDecodeTime\n     * ```\n     * It requires the timescale value from the mdhd to interpret.\n     *\n     * @param initData - a hash of track type to timescale values\n     * @param fmp4 - the bytes of the mp4 fragment\n     * @returns the earliest base media decode start time for the\n     * fragment, in seconds\n     */\n    function getStartDTS(initData, fmp4) {\n      // we need info from two children of each track fragment box\n      return findBox(fmp4, ['moof', 'traf']).reduce(function (result, traf) {\n        var tfdt = findBox(traf, ['tfdt'])[0];\n        var version = tfdt[0];\n        var start = findBox(traf, ['tfhd']).reduce(function (result, tfhd) {\n          // get the track id from the tfhd\n          var id = readUint32(tfhd, 4);\n          var track = initData[id];\n          if (track) {\n            var baseTime = readUint32(tfdt, 4);\n            if (version === 1) {\n              // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n              // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n              // https://github.com/video-dev/hls.js/issues/5303\n              if (baseTime === UINT32_MAX$1) {\n                logger.warn(\"[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time\");\n                return result;\n              }\n              baseTime *= UINT32_MAX$1 + 1;\n              baseTime += readUint32(tfdt, 8);\n            }\n            // assume a 90kHz clock if no timescale was specified\n            var scale = track.timescale || 90e3;\n            // convert base time to seconds\n            var startTime = baseTime / scale;\n            if (isFinite(startTime) && (result === null || startTime < result)) {\n              return startTime;\n            }\n          }\n          return result;\n        }, null);\n        if (start !== null && isFinite(start) && (result === null || start < result)) {\n          return start;\n        }\n        return result;\n      }, null);\n    }\n\n    /*\n      For Reference:\n      aligned(8) class TrackFragmentHeaderBox\n               extends FullBox(tfhd, 0, tf_flags){\n         unsigned int(32)  track_ID;\n         // all the following are optional fields\n         unsigned int(64)  base_data_offset;\n         unsigned int(32)  sample_description_index;\n         unsigned int(32)  default_sample_duration;\n         unsigned int(32)  default_sample_size;\n         unsigned int(32)  default_sample_flags\n      }\n     */\n    function getDuration(data, initData) {\n      var rawDuration = 0;\n      var videoDuration = 0;\n      var audioDuration = 0;\n      var trafs = findBox(data, ['moof', 'traf']);\n      for (var i = 0; i < trafs.length; i++) {\n        var traf = trafs[i];\n        // There is only one tfhd & trun per traf\n        // This is true for CMAF style content, and we should perhaps check the ftyp\n        // and only look for a single trun then, but for ISOBMFF we should check\n        // for multiple track runs.\n        var tfhd = findBox(traf, ['tfhd'])[0];\n        // get the track id from the tfhd\n        var id = readUint32(tfhd, 4);\n        var track = initData[id];\n        if (!track) {\n          continue;\n        }\n        var trackDefault = track.default;\n        var tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);\n        var sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;\n        if (tfhdFlags & 0x000008) {\n          // 0x000008 indicates the presence of the default_sample_duration field\n          if (tfhdFlags & 0x000002) {\n            // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n            // If present, the default_sample_duration exists at byte offset 12\n            sampleDuration = readUint32(tfhd, 12);\n          } else {\n            // Otherwise, the duration is at byte offset 8\n            sampleDuration = readUint32(tfhd, 8);\n          }\n        }\n        // assume a 90kHz clock if no timescale was specified\n        var timescale = track.timescale || 90e3;\n        var truns = findBox(traf, ['trun']);\n        for (var j = 0; j < truns.length; j++) {\n          rawDuration = computeRawDurationFromSamples(truns[j]);\n          if (!rawDuration && sampleDuration) {\n            var sampleCount = readUint32(truns[j], 4);\n            rawDuration = sampleDuration * sampleCount;\n          }\n          if (track.type === ElementaryStreamTypes.VIDEO) {\n            videoDuration += rawDuration / timescale;\n          } else if (track.type === ElementaryStreamTypes.AUDIO) {\n            audioDuration += rawDuration / timescale;\n          }\n        }\n      }\n      if (videoDuration === 0 && audioDuration === 0) {\n        // If duration samples are not available in the traf use sidx subsegment_duration\n        var sidxDuration = 0;\n        var sidxs = findBox(data, ['sidx']);\n        for (var _i = 0; _i < sidxs.length; _i++) {\n          var sidx = parseSegmentIndex(sidxs[_i]);\n          if (sidx != null && sidx.references) {\n            sidxDuration += sidx.references.reduce(function (dur, ref) {\n              return dur + ref.info.duration || 0;\n            }, 0);\n          }\n        }\n        return sidxDuration;\n      }\n      if (videoDuration) {\n        return videoDuration;\n      }\n      return audioDuration;\n    }\n\n    /*\n      For Reference:\n      aligned(8) class TrackRunBox\n               extends FullBox(trun, version, tr_flags) {\n         unsigned int(32)  sample_count;\n         // the following are optional fields\n         signed int(32) data_offset;\n         unsigned int(32)  first_sample_flags;\n         // all fields in the following array are optional\n         {\n            unsigned int(32)  sample_duration;\n            unsigned int(32)  sample_size;\n            unsigned int(32)  sample_flags\n            if (version == 0)\n               { unsigned int(32)\n            else\n               { signed int(32)\n         }[ sample_count ]\n      }\n     */\n    function computeRawDurationFromSamples(trun) {\n      var flags = readUint32(trun, 0);\n      // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n      // Each field is an int32, which is 4 bytes\n      var offset = 8;\n      // data-offset-present flag\n      if (flags & 0x000001) {\n        offset += 4;\n      }\n      // first-sample-flags-present flag\n      if (flags & 0x000004) {\n        offset += 4;\n      }\n      var duration = 0;\n      var sampleCount = readUint32(trun, 4);\n      for (var i = 0; i < sampleCount; i++) {\n        // sample-duration-present flag\n        if (flags & 0x000100) {\n          var sampleDuration = readUint32(trun, offset);\n          duration += sampleDuration;\n          offset += 4;\n        }\n        // sample-size-present flag\n        if (flags & 0x000200) {\n          offset += 4;\n        }\n        // sample-flags-present flag\n        if (flags & 0x000400) {\n          offset += 4;\n        }\n        // sample-composition-time-offsets-present flag\n        if (flags & 0x000800) {\n          offset += 4;\n        }\n      }\n      return duration;\n    }\n    function offsetStartDTS(initData, fmp4, timeOffset) {\n      findBox(fmp4, ['moof', 'traf']).forEach(function (traf) {\n        findBox(traf, ['tfhd']).forEach(function (tfhd) {\n          // get the track id from the tfhd\n          var id = readUint32(tfhd, 4);\n          var track = initData[id];\n          if (!track) {\n            return;\n          }\n          // assume a 90kHz clock if no timescale was specified\n          var timescale = track.timescale || 90e3;\n          // get the base media decode time from the tfdt\n          findBox(traf, ['tfdt']).forEach(function (tfdt) {\n            var version = tfdt[0];\n            var baseMediaDecodeTime = readUint32(tfdt, 4);\n            if (version === 0) {\n              baseMediaDecodeTime -= timeOffset * timescale;\n              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n              writeUint32(tfdt, 4, baseMediaDecodeTime);\n            } else {\n              baseMediaDecodeTime *= Math.pow(2, 32);\n              baseMediaDecodeTime += readUint32(tfdt, 8);\n              baseMediaDecodeTime -= timeOffset * timescale;\n              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n              var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));\n              var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));\n              writeUint32(tfdt, 4, upper);\n              writeUint32(tfdt, 8, lower);\n            }\n          });\n        });\n      });\n    }\n\n    // TODO: Check if the last moof+mdat pair is part of the valid range\n    function segmentValidRange(data) {\n      var segmentedRange = {\n        valid: null,\n        remainder: null\n      };\n      var moofs = findBox(data, ['moof']);\n      if (!moofs) {\n        return segmentedRange;\n      } else if (moofs.length < 2) {\n        segmentedRange.remainder = data;\n        return segmentedRange;\n      }\n      var last = moofs[moofs.length - 1];\n      // Offset by 8 bytes; findBox offsets the start by as much\n      segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);\n      segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);\n      return segmentedRange;\n    }\n    function appendUint8Array(data1, data2) {\n      var temp = new Uint8Array(data1.length + data2.length);\n      temp.set(data1);\n      temp.set(data2, data1.length);\n      return temp;\n    }\n    function parseSamples(timeOffset, track) {\n      var seiSamples = [];\n      var videoData = track.samples;\n      var timescale = track.timescale;\n      var trackId = track.id;\n      var isHEVCFlavor = false;\n      var moofs = findBox(videoData, ['moof']);\n      moofs.map(function (moof) {\n        var moofOffset = moof.byteOffset - 8;\n        var trafs = findBox(moof, ['traf']);\n        trafs.map(function (traf) {\n          // get the base media decode time from the tfdt\n          var baseTime = findBox(traf, ['tfdt']).map(function (tfdt) {\n            var version = tfdt[0];\n            var result = readUint32(tfdt, 4);\n            if (version === 1) {\n              result *= Math.pow(2, 32);\n              result += readUint32(tfdt, 8);\n            }\n            return result / timescale;\n          })[0];\n          if (baseTime !== undefined) {\n            timeOffset = baseTime;\n          }\n          return findBox(traf, ['tfhd']).map(function (tfhd) {\n            var id = readUint32(tfhd, 4);\n            var tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n            var baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n            var sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n            var defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n            var defaultSampleDuration = 0;\n            var defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n            var defaultSampleSize = 0;\n            var defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n            var tfhdOffset = 8;\n            if (id === trackId) {\n              if (baseDataOffsetPresent) {\n                tfhdOffset += 8;\n              }\n              if (sampleDescriptionIndexPresent) {\n                tfhdOffset += 4;\n              }\n              if (defaultSampleDurationPresent) {\n                defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n                tfhdOffset += 4;\n              }\n              if (defaultSampleSizePresent) {\n                defaultSampleSize = readUint32(tfhd, tfhdOffset);\n                tfhdOffset += 4;\n              }\n              if (defaultSampleFlagsPresent) {\n                tfhdOffset += 4;\n              }\n              if (track.type === 'video') {\n                isHEVCFlavor = isHEVC(track.codec);\n              }\n              findBox(traf, ['trun']).map(function (trun) {\n                var version = trun[0];\n                var flags = readUint32(trun, 0) & 0xffffff;\n                var dataOffsetPresent = (flags & 0x000001) !== 0;\n                var dataOffset = 0;\n                var firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n                var sampleDurationPresent = (flags & 0x000100) !== 0;\n                var sampleDuration = 0;\n                var sampleSizePresent = (flags & 0x000200) !== 0;\n                var sampleSize = 0;\n                var sampleFlagsPresent = (flags & 0x000400) !== 0;\n                var sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n                var compositionOffset = 0;\n                var sampleCount = readUint32(trun, 4);\n                var trunOffset = 8; // past version, flags, and sample count\n\n                if (dataOffsetPresent) {\n                  dataOffset = readUint32(trun, trunOffset);\n                  trunOffset += 4;\n                }\n                if (firstSampleFlagsPresent) {\n                  trunOffset += 4;\n                }\n                var sampleOffset = dataOffset + moofOffset;\n                for (var ix = 0; ix < sampleCount; ix++) {\n                  if (sampleDurationPresent) {\n                    sampleDuration = readUint32(trun, trunOffset);\n                    trunOffset += 4;\n                  } else {\n                    sampleDuration = defaultSampleDuration;\n                  }\n                  if (sampleSizePresent) {\n                    sampleSize = readUint32(trun, trunOffset);\n                    trunOffset += 4;\n                  } else {\n                    sampleSize = defaultSampleSize;\n                  }\n                  if (sampleFlagsPresent) {\n                    trunOffset += 4;\n                  }\n                  if (sampleCompositionOffsetsPresent) {\n                    if (version === 0) {\n                      compositionOffset = readUint32(trun, trunOffset);\n                    } else {\n                      compositionOffset = readSint32(trun, trunOffset);\n                    }\n                    trunOffset += 4;\n                  }\n                  if (track.type === ElementaryStreamTypes.VIDEO) {\n                    var naluTotalSize = 0;\n                    while (naluTotalSize < sampleSize) {\n                      var naluSize = readUint32(videoData, sampleOffset);\n                      sampleOffset += 4;\n                      if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                        var data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                        parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                      }\n                      sampleOffset += naluSize;\n                      naluTotalSize += naluSize + 4;\n                    }\n                  }\n                  timeOffset += sampleDuration / timescale;\n                }\n              });\n            }\n          });\n        });\n      });\n      return seiSamples;\n    }\n    function isHEVC(codec) {\n      if (!codec) {\n        return false;\n      }\n      var delimit = codec.indexOf('.');\n      var baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\n      return baseCodec === 'hvc1' || baseCodec === 'hev1' ||\n      // Dolby Vision\n      baseCodec === 'dvh1' || baseCodec === 'dvhe';\n    }\n    function isSEIMessage(isHEVCFlavor, naluHeader) {\n      if (isHEVCFlavor) {\n        var naluType = naluHeader >> 1 & 0x3f;\n        return naluType === 39 || naluType === 40;\n      } else {\n        var _naluType = naluHeader & 0x1f;\n        return _naluType === 6;\n      }\n    }\n    function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n      var data = discardEPB(unescapedData);\n      var seiPtr = 0;\n      // skip nal header\n      seiPtr += headerSize;\n      var payloadType = 0;\n      var payloadSize = 0;\n      var endOfCaptions = false;\n      var b = 0;\n      while (seiPtr < data.length) {\n        payloadType = 0;\n        do {\n          if (seiPtr >= data.length) {\n            break;\n          }\n          b = data[seiPtr++];\n          payloadType += b;\n        } while (b === 0xff);\n\n        // Parse payload size.\n        payloadSize = 0;\n        do {\n          if (seiPtr >= data.length) {\n            break;\n          }\n          b = data[seiPtr++];\n          payloadSize += b;\n        } while (b === 0xff);\n        var leftOver = data.length - seiPtr;\n        if (!endOfCaptions && payloadType === 4 && seiPtr < data.length) {\n          endOfCaptions = true;\n          var countryCode = data[seiPtr++];\n          if (countryCode === 181) {\n            var providerCode = readUint16(data, seiPtr);\n            seiPtr += 2;\n            if (providerCode === 49) {\n              var userStructure = readUint32(data, seiPtr);\n              seiPtr += 4;\n              if (userStructure === 0x47413934) {\n                var userDataType = data[seiPtr++];\n\n                // Raw CEA-608 bytes wrapped in CEA-708 packet\n                if (userDataType === 3) {\n                  var firstByte = data[seiPtr++];\n                  var totalCCs = 0x1f & firstByte;\n                  var enabled = 0x40 & firstByte;\n                  var totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n                  var byteArray = new Uint8Array(totalBytes);\n                  if (enabled) {\n                    byteArray[0] = firstByte;\n                    for (var i = 1; i < totalBytes; i++) {\n                      byteArray[i] = data[seiPtr++];\n                    }\n                  }\n                  samples.push({\n                    type: userDataType,\n                    payloadType: payloadType,\n                    pts: pts,\n                    bytes: byteArray\n                  });\n                }\n              }\n            }\n          }\n        } else if (payloadType === 5 && payloadSize < leftOver) {\n          endOfCaptions = true;\n          if (payloadSize > 16) {\n            var uuidStrArray = [];\n            for (var _i2 = 0; _i2 < 16; _i2++) {\n              var _b = data[seiPtr++].toString(16);\n              uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);\n              if (_i2 === 3 || _i2 === 5 || _i2 === 7 || _i2 === 9) {\n                uuidStrArray.push('-');\n              }\n            }\n            var length = payloadSize - 16;\n            var userDataBytes = new Uint8Array(length);\n            for (var _i3 = 0; _i3 < length; _i3++) {\n              userDataBytes[_i3] = data[seiPtr++];\n            }\n            samples.push({\n              payloadType: payloadType,\n              pts: pts,\n              uuid: uuidStrArray.join(''),\n              userData: utf8ArrayToStr(userDataBytes),\n              userDataBytes: userDataBytes\n            });\n          }\n        } else if (payloadSize < leftOver) {\n          seiPtr += payloadSize;\n        } else if (payloadSize > leftOver) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * remove Emulation Prevention bytes from a RBSP\n     */\n    function discardEPB(data) {\n      var length = data.byteLength;\n      var EPBPositions = [];\n      var i = 1;\n\n      // Find all `Emulation Prevention Bytes`\n      while (i < length - 2) {\n        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n          EPBPositions.push(i + 2);\n          i += 2;\n        } else {\n          i++;\n        }\n      }\n\n      // If no Emulation Prevention Bytes were found just return the original\n      // array\n      if (EPBPositions.length === 0) {\n        return data;\n      }\n\n      // Create a new array to hold the NAL unit data\n      var newLength = length - EPBPositions.length;\n      var newData = new Uint8Array(newLength);\n      var sourceIndex = 0;\n      for (i = 0; i < newLength; sourceIndex++, i++) {\n        if (sourceIndex === EPBPositions[0]) {\n          // Skip this byte\n          sourceIndex++;\n          // Remove this position index\n          EPBPositions.shift();\n        }\n        newData[i] = data[sourceIndex];\n      }\n      return newData;\n    }\n    function parseEmsg(data) {\n      var version = data[0];\n      var schemeIdUri = '';\n      var value = '';\n      var timeScale = 0;\n      var presentationTimeDelta = 0;\n      var presentationTime = 0;\n      var eventDuration = 0;\n      var id = 0;\n      var offset = 0;\n      if (version === 0) {\n        while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n          schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n          offset += 1;\n        }\n        schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n        while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n          value += bin2str(data.subarray(offset, offset + 1));\n          offset += 1;\n        }\n        value += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n        timeScale = readUint32(data, 12);\n        presentationTimeDelta = readUint32(data, 16);\n        eventDuration = readUint32(data, 20);\n        id = readUint32(data, 24);\n        offset = 28;\n      } else if (version === 1) {\n        offset += 4;\n        timeScale = readUint32(data, offset);\n        offset += 4;\n        var leftPresentationTime = readUint32(data, offset);\n        offset += 4;\n        var rightPresentationTime = readUint32(data, offset);\n        offset += 4;\n        presentationTime = Math.pow(2, 32) * leftPresentationTime + rightPresentationTime;\n        if (!Number.isSafeInteger(presentationTime)) {\n          presentationTime = Number.MAX_SAFE_INTEGER;\n          logger.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');\n        }\n        eventDuration = readUint32(data, offset);\n        offset += 4;\n        id = readUint32(data, offset);\n        offset += 4;\n        while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n          schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n          offset += 1;\n        }\n        schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n        while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n          value += bin2str(data.subarray(offset, offset + 1));\n          offset += 1;\n        }\n        value += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n      }\n      var payload = data.subarray(offset, data.byteLength);\n      return {\n        schemeIdUri: schemeIdUri,\n        value: value,\n        timeScale: timeScale,\n        presentationTime: presentationTime,\n        presentationTimeDelta: presentationTimeDelta,\n        eventDuration: eventDuration,\n        id: id,\n        payload: payload\n      };\n    }\n    var LevelKey = /*#__PURE__*/function () {\n      LevelKey.clearKeyUriToKeyIdMap = function clearKeyUriToKeyIdMap() {};\n      function LevelKey(method, uri, format, formatversions, iv) {\n        if (formatversions === void 0) {\n          formatversions = [1];\n        }\n        if (iv === void 0) {\n          iv = null;\n        }\n        this.uri = void 0;\n        this.method = void 0;\n        this.keyFormat = void 0;\n        this.keyFormatVersions = void 0;\n        this.encrypted = void 0;\n        this.isCommonEncryption = void 0;\n        this.iv = null;\n        this.key = null;\n        this.keyId = null;\n        this.pssh = null;\n        this.method = method;\n        this.uri = uri;\n        this.keyFormat = format;\n        this.keyFormatVersions = formatversions;\n        this.iv = iv;\n        this.encrypted = method ? method !== 'NONE' : false;\n        this.isCommonEncryption = this.encrypted && method !== 'AES-128';\n      }\n      var _proto = LevelKey.prototype;\n      _proto.isSupported = function isSupported() {\n        // If it's Segment encryption or No encryption, just select that key system\n        if (this.method) {\n          if (this.method === 'AES-128' || this.method === 'NONE') {\n            return true;\n          }\n          if (this.keyFormat === 'identity') {\n            // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n            return this.method === 'SAMPLE-AES';\n          }\n        }\n        return false;\n      };\n      _proto.getDecryptData = function getDecryptData(sn) {\n        if (!this.encrypted || !this.uri) {\n          return null;\n        }\n        if (this.method === 'AES-128' && this.uri && !this.iv) {\n          if (typeof sn !== 'number') {\n            // We are fetching decryption data for a initialization segment\n            // If the segment was encrypted with AES-128\n            // It must have an IV defined. We cannot substitute the Segment Number in.\n            if (this.method === 'AES-128' && !this.iv) {\n              logger.warn(\"missing IV for initialization segment with method=\\\"\" + this.method + \"\\\" - compliance issue\");\n            }\n            // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n            sn = 0;\n          }\n          var iv = createInitializationVector(sn);\n          var decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);\n          return decryptdata;\n        }\n        {\n          return this;\n        }\n      };\n      return LevelKey;\n    }();\n    function createInitializationVector(segmentNumber) {\n      var uint8View = new Uint8Array(16);\n      for (var i = 12; i < 16; i++) {\n        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n      }\n      return uint8View;\n    }\n\n    /**\n     * MediaSource helper\n     */\n\n    function getMediaSource() {\n      if (typeof self === 'undefined') return undefined;\n      return self.MediaSource || self.WebKitMediaSource;\n    }\n\n    // from http://mp4ra.org/codecs.html\n    var sampleEntryCodesISO = {\n      audio: {\n        a3ds: true,\n        'ac-3': true,\n        'ac-4': true,\n        alac: true,\n        alaw: true,\n        dra1: true,\n        'dts+': true,\n        'dts-': true,\n        dtsc: true,\n        dtse: true,\n        dtsh: true,\n        'ec-3': true,\n        enca: true,\n        g719: true,\n        g726: true,\n        m4ae: true,\n        mha1: true,\n        mha2: true,\n        mhm1: true,\n        mhm2: true,\n        mlpa: true,\n        mp4a: true,\n        'raw ': true,\n        Opus: true,\n        opus: true,\n        // browsers expect this to be lowercase despite MP4RA says 'Opus'\n        samr: true,\n        sawb: true,\n        sawp: true,\n        sevc: true,\n        sqcp: true,\n        ssmv: true,\n        twos: true,\n        ulaw: true\n      },\n      video: {\n        avc1: true,\n        avc2: true,\n        avc3: true,\n        avc4: true,\n        avcp: true,\n        av01: true,\n        drac: true,\n        dva1: true,\n        dvav: true,\n        dvh1: true,\n        dvhe: true,\n        encv: true,\n        hev1: true,\n        hvc1: true,\n        mjp2: true,\n        mp4v: true,\n        mvc1: true,\n        mvc2: true,\n        mvc3: true,\n        mvc4: true,\n        resv: true,\n        rv60: true,\n        s263: true,\n        svc1: true,\n        svc2: true,\n        'vc-1': true,\n        vp08: true,\n        vp09: true\n      },\n      text: {\n        stpp: true,\n        wvtt: true\n      }\n    };\n    var MediaSource$2 = getMediaSource();\n    function isCodecType(codec, type) {\n      var typeCodes = sampleEntryCodesISO[type];\n      return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;\n    }\n    function isCodecSupportedInMp4(codec, type) {\n      var _MediaSource$isTypeSu;\n      return (_MediaSource$isTypeSu = MediaSource$2 == null ? void 0 : MediaSource$2.isTypeSupported((type || 'video') + \"/mp4;codecs=\\\"\" + codec + \"\\\"\")) != null ? _MediaSource$isTypeSu : false;\n    }\n    var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g;\n    var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\n    var IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)\n\n    var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n    // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n    /(?!#) *(\\S[\\S ]*)/.source,\n    // segment URI, group 3 => the URI (note newline is not eaten)\n    /#EXT-X-BYTERANGE:*(.+)/.source,\n    // next segment's byterange, group 4 => range spec (x@y)\n    /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,\n    // next segment's program date/time group 5 => the datetime spec\n    /#.*/.source // All other non-segment oriented tags will match with all groups empty\n    ].join('|'), 'g');\n    var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\n    var M3U8Parser = /*#__PURE__*/function () {\n      function M3U8Parser() {}\n      M3U8Parser.findGroup = function findGroup(groups, mediaGroupId) {\n        for (var i = 0; i < groups.length; i++) {\n          var group = groups[i];\n          if (group.id === mediaGroupId) {\n            return group;\n          }\n        }\n      };\n      M3U8Parser.convertAVC1ToAVCOTI = function convertAVC1ToAVCOTI(codec) {\n        // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n        var avcdata = codec.split('.');\n        if (avcdata.length > 2) {\n          var result = avcdata.shift() + '.';\n          result += parseInt(avcdata.shift()).toString(16);\n          result += ('000' + parseInt(avcdata.shift()).toString(16)).slice(-4);\n          return result;\n        }\n        return codec;\n      };\n      M3U8Parser.resolve = function resolve(url, baseUrl) {\n        return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {\n          alwaysNormalize: true\n        });\n      };\n      M3U8Parser.isMediaPlaylist = function isMediaPlaylist(str) {\n        return IS_MEDIA_PLAYLIST.test(str);\n      };\n      M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {\n        var hasVariableRefs = false;\n        var parsed = {\n          contentSteering: null,\n          levels: [],\n          playlistParsingError: null,\n          sessionData: null,\n          sessionKeys: null,\n          startTimeOffset: null,\n          variableList: null,\n          hasVariableRefs: hasVariableRefs\n        };\n        var levelsWithKnownCodecs = [];\n        MASTER_PLAYLIST_REGEX.lastIndex = 0;\n        var result;\n        while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n          if (result[1]) {\n            var _level$unknownCodecs;\n            // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n            var attrs = new AttrList(result[1]);\n            var uri = result[2];\n            var level = {\n              attrs: attrs,\n              bitrate: attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH'),\n              name: attrs.NAME,\n              url: M3U8Parser.resolve(uri, baseurl)\n            };\n            var resolution = attrs.decimalResolution('RESOLUTION');\n            if (resolution) {\n              level.width = resolution.width;\n              level.height = resolution.height;\n            }\n            setCodecs((attrs.CODECS || '').split(/[ ,]+/).filter(function (c) {\n              return c;\n            }), level);\n            if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {\n              level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);\n            }\n            if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {\n              levelsWithKnownCodecs.push(level);\n            }\n            parsed.levels.push(level);\n          } else if (result[3]) {\n            var tag = result[3];\n            var attributes = result[4];\n            switch (tag) {\n              case 'SESSION-DATA':\n                {\n                  // #EXT-X-SESSION-DATA\n                  var sessionAttrs = new AttrList(attributes);\n                  var dataId = sessionAttrs['DATA-ID'];\n                  if (dataId) {\n                    if (parsed.sessionData === null) {\n                      parsed.sessionData = {};\n                    }\n                    parsed.sessionData[dataId] = sessionAttrs;\n                  }\n                  break;\n                }\n              case 'SESSION-KEY':\n                {\n                  // #EXT-X-SESSION-KEY\n                  var sessionKey = parseKey(attributes, baseurl);\n                  if (sessionKey.encrypted && sessionKey.isSupported()) {\n                    if (parsed.sessionKeys === null) {\n                      parsed.sessionKeys = [];\n                    }\n                    parsed.sessionKeys.push(sessionKey);\n                  } else {\n                    logger.warn(\"[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \\\"\" + attributes + \"\\\"\");\n                  }\n                  break;\n                }\n              case 'DEFINE':\n                {\n                  break;\n                }\n              case 'CONTENT-STEERING':\n                {\n                  // #EXT-X-CONTENT-STEERING\n                  var contentSteeringAttributes = new AttrList(attributes);\n                  parsed.contentSteering = {\n                    uri: M3U8Parser.resolve(contentSteeringAttributes['SERVER-URI'], baseurl),\n                    pathwayId: contentSteeringAttributes['PATHWAY-ID'] || '.'\n                  };\n                  break;\n                }\n              case 'START':\n                {\n                  // #EXT-X-START\n                  parsed.startTimeOffset = parseStartTimeOffset(attributes);\n                  break;\n                }\n            }\n          }\n        }\n        // Filter out levels with unknown codecs if it does not remove all levels\n        var stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;\n        parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;\n        if (parsed.levels.length === 0) {\n          parsed.playlistParsingError = new Error('no levels found in manifest');\n        }\n        return parsed;\n      };\n      M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, parsed) {\n        var result;\n        var results = {};\n        var levels = parsed.levels;\n        var groupsByType = {\n          AUDIO: levels.map(function (level) {\n            return {\n              id: level.attrs.AUDIO,\n              audioCodec: level.audioCodec\n            };\n          }),\n          SUBTITLES: levels.map(function (level) {\n            return {\n              id: level.attrs.SUBTITLES,\n              textCodec: level.textCodec\n            };\n          }),\n          'CLOSED-CAPTIONS': []\n        };\n        var id = 0;\n        MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n        while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n          var attrs = new AttrList(result[1]);\n          var type = attrs.TYPE;\n          if (type) {\n            var groups = groupsByType[type];\n            var medias = results[type] || [];\n            results[type] = medias;\n            var media = {\n              attrs: attrs,\n              bitrate: 0,\n              id: id++,\n              groupId: attrs['GROUP-ID'] || '',\n              instreamId: attrs['INSTREAM-ID'],\n              name: attrs.NAME || attrs.LANGUAGE || '',\n              type: type,\n              default: attrs.bool('DEFAULT'),\n              autoselect: attrs.bool('AUTOSELECT'),\n              forced: attrs.bool('FORCED'),\n              lang: attrs.LANGUAGE,\n              url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n            };\n            if (groups != null && groups.length) {\n              // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n              // If we don't find the track signalled, lets use the first audio groups codec we have\n              // Acting as a best guess\n              var groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n              assignCodec(media, groupCodec, 'audioCodec');\n              assignCodec(media, groupCodec, 'textCodec');\n            }\n            medias.push(media);\n          }\n        }\n        return results;\n      };\n      M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {\n        var level = new LevelDetails(baseurl);\n        var fragments = level.fragments;\n        // The most recent init segment seen (applies to all subsequent segments)\n        var currentInitSegment = null;\n        var currentSN = 0;\n        var currentPart = 0;\n        var totalduration = 0;\n        var discontinuityCounter = 0;\n        var prevFrag = null;\n        var frag = new Fragment(type, baseurl);\n        var result;\n        var i;\n        var levelkeys;\n        var firstPdtIndex = -1;\n        var createNextFrag = false;\n        LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n        level.m3u8 = string;\n        level.hasVariableRefs = false;\n        while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n          if (createNextFrag) {\n            createNextFrag = false;\n            frag = new Fragment(type, baseurl);\n            // setup the next fragment for part loading\n            frag.start = totalduration;\n            frag.sn = currentSN;\n            frag.cc = discontinuityCounter;\n            frag.level = id;\n            if (currentInitSegment) {\n              frag.initSegment = currentInitSegment;\n              frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n              currentInitSegment.rawProgramDateTime = null;\n            }\n          }\n          var duration = result[1];\n          if (duration) {\n            // INF\n            frag.duration = parseFloat(duration);\n            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n            var title = (' ' + result[2]).slice(1);\n            frag.title = title || null;\n            frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n          } else if (result[3]) {\n            // url\n            if (isFiniteNumber(frag.duration)) {\n              frag.start = totalduration;\n              if (levelkeys) {\n                setFragLevelKeys(frag, levelkeys, level);\n              }\n              frag.sn = currentSN;\n              frag.level = id;\n              frag.cc = discontinuityCounter;\n              frag.urlId = levelUrlId;\n              fragments.push(frag);\n              // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n              var uri = (' ' + result[3]).slice(1);\n              frag.relurl = uri;\n              assignProgramDateTime(frag, prevFrag);\n              prevFrag = frag;\n              totalduration += frag.duration;\n              currentSN++;\n              currentPart = 0;\n              createNextFrag = true;\n            }\n          } else if (result[4]) {\n            // X-BYTERANGE\n            var data = (' ' + result[4]).slice(1);\n            if (prevFrag) {\n              frag.setByteRange(data, prevFrag);\n            } else {\n              frag.setByteRange(data);\n            }\n          } else if (result[5]) {\n            // PROGRAM-DATE-TIME\n            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n            frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n            frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n            if (firstPdtIndex === -1) {\n              firstPdtIndex = fragments.length;\n            }\n          } else {\n            result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n            if (!result) {\n              logger.warn('No matches on slow regex match for level playlist!');\n              continue;\n            }\n            for (i = 1; i < result.length; i++) {\n              if (typeof result[i] !== 'undefined') {\n                break;\n              }\n            }\n\n            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n            var tag = (' ' + result[i]).slice(1);\n            var value1 = (' ' + result[i + 1]).slice(1);\n            var value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';\n            switch (tag) {\n              case 'PLAYLIST-TYPE':\n                level.type = value1.toUpperCase();\n                break;\n              case 'MEDIA-SEQUENCE':\n                currentSN = level.startSN = parseInt(value1);\n                break;\n              case 'SKIP':\n                {\n                  var skipAttrs = new AttrList(value1);\n                  var skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n                  if (isFiniteNumber(skippedSegments)) {\n                    level.skippedSegments = skippedSegments;\n                    // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                    for (var _i = skippedSegments; _i--;) {\n                      fragments.unshift(null);\n                    }\n                    currentSN += skippedSegments;\n                  }\n                  var recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n                  if (recentlyRemovedDateranges) {\n                    level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\\t');\n                  }\n                  break;\n                }\n              case 'TARGETDURATION':\n                level.targetduration = Math.max(parseInt(value1), 1);\n                break;\n              case 'VERSION':\n                level.version = parseInt(value1);\n                break;\n              case 'EXTM3U':\n                break;\n              case 'ENDLIST':\n                level.live = false;\n                break;\n              case '#':\n                if (value1 || value2) {\n                  frag.tagList.push(value2 ? [value1, value2] : [value1]);\n                }\n                break;\n              case 'DISCONTINUITY':\n                discontinuityCounter++;\n                frag.tagList.push(['DIS']);\n                break;\n              case 'GAP':\n                frag.gap = true;\n                frag.tagList.push([tag]);\n                break;\n              case 'BITRATE':\n                frag.tagList.push([tag, value1]);\n                break;\n              case 'DATERANGE':\n                {\n                  var dateRangeAttr = new AttrList(value1);\n                  var dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);\n                  if (dateRange.isValid || level.skippedSegments) {\n                    level.dateRanges[dateRange.id] = dateRange;\n                  } else {\n                    logger.warn(\"Ignoring invalid DATERANGE tag: \\\"\" + value1 + \"\\\"\");\n                  }\n                  // Add to fragment tag list for backwards compatibility (< v1.2.0)\n                  frag.tagList.push(['EXT-X-DATERANGE', value1]);\n                  break;\n                }\n              case 'DEFINE':\n                {\n                  break;\n                }\n              case 'DISCONTINUITY-SEQUENCE':\n                discontinuityCounter = parseInt(value1);\n                break;\n              case 'KEY':\n                {\n                  var levelKey = parseKey(value1, baseurl);\n                  if (levelKey.isSupported()) {\n                    if (levelKey.method === 'NONE') {\n                      levelkeys = undefined;\n                      break;\n                    }\n                    if (!levelkeys) {\n                      levelkeys = {};\n                    }\n                    if (levelkeys[levelKey.keyFormat]) {\n                      levelkeys = _extends({}, levelkeys);\n                    }\n                    levelkeys[levelKey.keyFormat] = levelKey;\n                  } else {\n                    logger.warn(\"[Keys] Ignoring invalid EXT-X-KEY tag: \\\"\" + value1 + \"\\\"\");\n                  }\n                  break;\n                }\n              case 'START':\n                level.startTimeOffset = parseStartTimeOffset(value1);\n                break;\n              case 'MAP':\n                {\n                  var mapAttrs = new AttrList(value1);\n                  if (frag.duration) {\n                    // Initial segment tag is after segment duration tag.\n                    //   #EXTINF: 6.0\n                    //   #EXT-X-MAP:URI=\"init.mp4\n                    var init = new Fragment(type, baseurl);\n                    setInitSegment(init, mapAttrs, id, levelkeys);\n                    currentInitSegment = init;\n                    frag.initSegment = currentInitSegment;\n                    if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                      frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                    }\n                  } else {\n                    // Initial segment tag is before segment duration tag\n                    setInitSegment(frag, mapAttrs, id, levelkeys);\n                    currentInitSegment = frag;\n                    createNextFrag = true;\n                  }\n                  break;\n                }\n              case 'SERVER-CONTROL':\n                {\n                  var serverControlAttrs = new AttrList(value1);\n                  level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n                  level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n                  level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n                  level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n                  level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n                  break;\n                }\n              case 'PART-INF':\n                {\n                  var partInfAttrs = new AttrList(value1);\n                  level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n                  break;\n                }\n              case 'PART':\n                {\n                  var partList = level.partList;\n                  if (!partList) {\n                    partList = level.partList = [];\n                  }\n                  var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n                  var index = currentPart++;\n                  var partAttrs = new AttrList(value1);\n                  var part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);\n                  partList.push(part);\n                  frag.duration += part.duration;\n                  break;\n                }\n              case 'PRELOAD-HINT':\n                {\n                  var preloadHintAttrs = new AttrList(value1);\n                  level.preloadHint = preloadHintAttrs;\n                  break;\n                }\n              case 'RENDITION-REPORT':\n                {\n                  var renditionReportAttrs = new AttrList(value1);\n                  level.renditionReports = level.renditionReports || [];\n                  level.renditionReports.push(renditionReportAttrs);\n                  break;\n                }\n              default:\n                logger.warn(\"line parsed but not handled: \" + result);\n                break;\n            }\n          }\n        }\n        if (prevFrag && !prevFrag.relurl) {\n          fragments.pop();\n          totalduration -= prevFrag.duration;\n          if (level.partList) {\n            level.fragmentHint = prevFrag;\n          }\n        } else if (level.partList) {\n          assignProgramDateTime(frag, prevFrag);\n          frag.cc = discontinuityCounter;\n          level.fragmentHint = frag;\n          if (levelkeys) {\n            setFragLevelKeys(frag, levelkeys, level);\n          }\n        }\n        var fragmentLength = fragments.length;\n        var firstFragment = fragments[0];\n        var lastFragment = fragments[fragmentLength - 1];\n        totalduration += level.skippedSegments * level.targetduration;\n        if (totalduration > 0 && fragmentLength && lastFragment) {\n          level.averagetargetduration = totalduration / fragmentLength;\n          var lastSn = lastFragment.sn;\n          level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n          if (!level.live) {\n            lastFragment.endList = true;\n          }\n          if (firstFragment) {\n            level.startCC = firstFragment.cc;\n          }\n        } else {\n          level.endSN = 0;\n          level.startCC = 0;\n        }\n        if (level.fragmentHint) {\n          totalduration += level.fragmentHint.duration;\n        }\n        level.totalduration = totalduration;\n        level.endCC = discontinuityCounter;\n\n        /**\n         * Backfill any missing PDT values\n         * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n         * one or more Media Segment URIs, the client SHOULD extrapolate\n         * backward from that tag (using EXTINF durations and/or media\n         * timestamps) to associate dates with those segments.\"\n         * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n         * computed.\n         */\n        if (firstPdtIndex > 0) {\n          backfillProgramDateTimes(fragments, firstPdtIndex);\n        }\n        return level;\n      };\n      return M3U8Parser;\n    }();\n    function parseKey(keyTagAttributes, baseurl, parsed) {\n      var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;\n      // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n      var keyAttrs = new AttrList(keyTagAttributes);\n      var decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : '';\n      var decrypturi = keyAttrs.URI;\n      var decryptiv = keyAttrs.hexadecimalInteger('IV');\n      var decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;\n      // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n      var decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : 'identity';\n      if (decrypturi && keyAttrs.IV && !decryptiv) {\n        logger.error(\"Invalid IV: \" + keyAttrs.IV);\n      }\n      // If decrypturi is a URI with a scheme, then baseurl will be ignored\n      // No uri is allowed when METHOD is NONE\n      var resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';\n      var keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);\n      return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);\n    }\n    function parseStartTimeOffset(startAttributes) {\n      var startAttrs = new AttrList(startAttributes);\n      var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n      if (isFiniteNumber(startTimeOffset)) {\n        return startTimeOffset;\n      }\n      return null;\n    }\n    function setCodecs(codecs, level) {\n      ['video', 'audio', 'text'].forEach(function (type) {\n        var filtered = codecs.filter(function (codec) {\n          return isCodecType(codec, type);\n        });\n        if (filtered.length) {\n          var preferred = filtered.filter(function (codec) {\n            return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;\n          });\n          level[type + \"Codec\"] = preferred.length > 0 ? preferred[0] : filtered[0];\n\n          // remove from list\n          codecs = codecs.filter(function (codec) {\n            return filtered.indexOf(codec) === -1;\n          });\n        }\n      });\n      level.unknownCodecs = codecs;\n    }\n    function assignCodec(media, groupItem, codecProperty) {\n      var codecValue = groupItem[codecProperty];\n      if (codecValue) {\n        media[codecProperty] = codecValue;\n      }\n    }\n    function backfillProgramDateTimes(fragments, firstPdtIndex) {\n      var fragPrev = fragments[firstPdtIndex];\n      for (var i = firstPdtIndex; i--;) {\n        var frag = fragments[i];\n        // Exit on delta-playlist skipped segments\n        if (!frag) {\n          return;\n        }\n        frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n        fragPrev = frag;\n      }\n    }\n    function assignProgramDateTime(frag, prevFrag) {\n      if (frag.rawProgramDateTime) {\n        frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n      } else if (prevFrag != null && prevFrag.programDateTime) {\n        frag.programDateTime = prevFrag.endProgramDateTime;\n      }\n      if (!isFiniteNumber(frag.programDateTime)) {\n        frag.programDateTime = null;\n        frag.rawProgramDateTime = null;\n      }\n    }\n    function setInitSegment(frag, mapAttrs, id, levelkeys) {\n      frag.relurl = mapAttrs.URI;\n      if (mapAttrs.BYTERANGE) {\n        frag.setByteRange(mapAttrs.BYTERANGE);\n      }\n      frag.level = id;\n      frag.sn = 'initSegment';\n      if (levelkeys) {\n        frag.levelkeys = levelkeys;\n      }\n      frag.initSegment = null;\n    }\n    function setFragLevelKeys(frag, levelkeys, level) {\n      frag.levelkeys = levelkeys;\n      var encryptedFragments = level.encryptedFragments;\n      if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(function (format) {\n        return levelkeys[format].isCommonEncryption;\n      })) {\n        encryptedFragments.push(frag);\n      }\n    }\n    var PlaylistContextType = {\n      MANIFEST: \"manifest\",\n      LEVEL: \"level\",\n      AUDIO_TRACK: \"audioTrack\",\n      SUBTITLE_TRACK: \"subtitleTrack\"\n    };\n    var PlaylistLevelType = {\n      MAIN: \"main\",\n      AUDIO: \"audio\",\n      SUBTITLE: \"subtitle\"\n    };\n    function mapContextToLevelType(context) {\n      var type = context.type;\n      switch (type) {\n        case PlaylistContextType.AUDIO_TRACK:\n          return PlaylistLevelType.AUDIO;\n        case PlaylistContextType.SUBTITLE_TRACK:\n          return PlaylistLevelType.SUBTITLE;\n        default:\n          return PlaylistLevelType.MAIN;\n      }\n    }\n    function getResponseUrl(response, context) {\n      var url = response.url;\n      // responseURL not supported on some browsers (it is used to detect URL redirection)\n      // data-uri mode also not supported (but no need to detect redirection)\n      if (url === undefined || url.indexOf('data:') === 0) {\n        // fallback to initial URL\n        url = context.url;\n      }\n      return url;\n    }\n    var PlaylistLoader = /*#__PURE__*/function () {\n      function PlaylistLoader(hls) {\n        this.hls = void 0;\n        this.loaders = Object.create(null);\n        this.variableList = null;\n        this.hls = hls;\n        this.registerListeners();\n      }\n      var _proto = PlaylistLoader.prototype;\n      _proto.startLoad = function startLoad(startPosition) {};\n      _proto.stopLoad = function stopLoad() {\n        this.destroyInternalLoaders();\n      };\n      _proto.registerListeners = function registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n        hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n      };\n      _proto.unregisterListeners = function unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n        hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n      }\n\n      /**\n       * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n       */;\n      _proto.createInternalLoader = function createInternalLoader(context) {\n        var config = this.hls.config;\n        var PLoader = config.pLoader;\n        var Loader = config.loader;\n        var InternalLoader = PLoader || Loader;\n        var loader = new InternalLoader(config);\n        this.loaders[context.type] = loader;\n        return loader;\n      };\n      _proto.getInternalLoader = function getInternalLoader(context) {\n        return this.loaders[context.type];\n      };\n      _proto.resetInternalLoader = function resetInternalLoader(contextType) {\n        if (this.loaders[contextType]) {\n          delete this.loaders[contextType];\n        }\n      }\n\n      /**\n       * Call `destroy` on all internal loader instances mapped (one per context type)\n       */;\n      _proto.destroyInternalLoaders = function destroyInternalLoaders() {\n        for (var contextType in this.loaders) {\n          var loader = this.loaders[contextType];\n          if (loader) {\n            loader.destroy();\n          }\n          this.resetInternalLoader(contextType);\n        }\n      };\n      _proto.destroy = function destroy() {\n        this.variableList = null;\n        this.unregisterListeners();\n        this.destroyInternalLoaders();\n      };\n      _proto.onManifestLoading = function onManifestLoading(event, data) {\n        var url = data.url;\n        this.variableList = null;\n        this.load({\n          id: null,\n          level: 0,\n          responseType: 'text',\n          type: PlaylistContextType.MANIFEST,\n          url: url,\n          deliveryDirectives: null\n        });\n      };\n      _proto.onLevelLoading = function onLevelLoading(event, data) {\n        var id = data.id,\n          level = data.level,\n          url = data.url,\n          deliveryDirectives = data.deliveryDirectives;\n        this.load({\n          id: id,\n          level: level,\n          responseType: 'text',\n          type: PlaylistContextType.LEVEL,\n          url: url,\n          deliveryDirectives: deliveryDirectives\n        });\n      };\n      _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {\n        var id = data.id,\n          groupId = data.groupId,\n          url = data.url,\n          deliveryDirectives = data.deliveryDirectives;\n        this.load({\n          id: id,\n          groupId: groupId,\n          level: null,\n          responseType: 'text',\n          type: PlaylistContextType.AUDIO_TRACK,\n          url: url,\n          deliveryDirectives: deliveryDirectives\n        });\n      };\n      _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {\n        var id = data.id,\n          groupId = data.groupId,\n          url = data.url,\n          deliveryDirectives = data.deliveryDirectives;\n        this.load({\n          id: id,\n          groupId: groupId,\n          level: null,\n          responseType: 'text',\n          type: PlaylistContextType.SUBTITLE_TRACK,\n          url: url,\n          deliveryDirectives: deliveryDirectives\n        });\n      };\n      _proto.load = function load(context) {\n        var _context$deliveryDire,\n          _this = this;\n        var config = this.hls.config;\n\n        // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n\n        // Check if a loader for this context already exists\n        var loader = this.getInternalLoader(context);\n        if (loader) {\n          var loaderContext = loader.context;\n          if (loaderContext && loaderContext.url === context.url) {\n            // same URL can't overlap\n            logger.trace('[playlist-loader]: playlist request ongoing');\n            return;\n          }\n          logger.log(\"[playlist-loader]: aborting previous loader for type: \" + context.type);\n          loader.abort();\n        }\n\n        // apply different configs for retries depending on\n        // context (manifest, level, audio/subs playlist)\n        var loadPolicy;\n        if (context.type === PlaylistContextType.MANIFEST) {\n          loadPolicy = config.manifestLoadPolicy.default;\n        } else {\n          loadPolicy = _extends({}, config.playlistLoadPolicy.default, {\n            timeoutRetry: null,\n            errorRetry: null\n          });\n        }\n        loader = this.createInternalLoader(context);\n\n        // Override level/track timeout for LL-HLS requests\n        // (the default of 10000ms is counter productive to blocking playlist reload requests)\n        if ((_context$deliveryDire = context.deliveryDirectives) != null && _context$deliveryDire.part) {\n          var levelDetails;\n          if (context.type === PlaylistContextType.LEVEL && context.level !== null) {\n            levelDetails = this.hls.levels[context.level].details;\n          } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n            levelDetails = this.hls.audioTracks[context.id].details;\n          } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n            levelDetails = this.hls.subtitleTracks[context.id].details;\n          }\n          if (levelDetails) {\n            var partTarget = levelDetails.partTarget;\n            var targetDuration = levelDetails.targetduration;\n            if (partTarget && targetDuration) {\n              var maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;\n              loadPolicy = _extends({}, loadPolicy, {\n                maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),\n                maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)\n              });\n            }\n          }\n        }\n        var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n        var loaderConfig = {\n          loadPolicy: loadPolicy,\n          timeout: loadPolicy.maxLoadTimeMs,\n          maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n          retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n          maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n        };\n        var loaderCallbacks = {\n          onSuccess: function onSuccess(response, stats, context, networkDetails) {\n            var loader = _this.getInternalLoader(context);\n            _this.resetInternalLoader(context.type);\n            var string = response.data;\n\n            // Validate if it is an M3U8 at all\n            if (string.indexOf('#EXTM3U') !== 0) {\n              _this.handleManifestParsingError(response, context, new Error('no EXTM3U delimiter'), networkDetails || null, stats);\n              return;\n            }\n            stats.parsing.start = performance.now();\n            if (M3U8Parser.isMediaPlaylist(string)) {\n              _this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);\n            } else {\n              _this.handleMasterPlaylist(response, stats, context, networkDetails);\n            }\n          },\n          onError: function onError(response, context, networkDetails, stats) {\n            _this.handleNetworkError(context, networkDetails, false, response, stats);\n          },\n          onTimeout: function onTimeout(stats, context, networkDetails) {\n            _this.handleNetworkError(context, networkDetails, true, undefined, stats);\n          }\n        };\n\n        // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n        loader.load(context, loaderConfig, loaderCallbacks);\n      };\n      _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {\n        var hls = this.hls;\n        var string = response.data;\n        var url = getResponseUrl(response, context);\n        var parsedResult = M3U8Parser.parseMasterPlaylist(string, url);\n        if (parsedResult.playlistParsingError) {\n          this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);\n          return;\n        }\n        var contentSteering = parsedResult.contentSteering,\n          levels = parsedResult.levels,\n          sessionData = parsedResult.sessionData,\n          sessionKeys = parsedResult.sessionKeys,\n          startTimeOffset = parsedResult.startTimeOffset,\n          variableList = parsedResult.variableList;\n        this.variableList = variableList;\n        var _M3U8Parser$parseMast = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult),\n          _M3U8Parser$parseMast2 = _M3U8Parser$parseMast.AUDIO,\n          audioTracks = _M3U8Parser$parseMast2 === void 0 ? [] : _M3U8Parser$parseMast2,\n          subtitles = _M3U8Parser$parseMast.SUBTITLES,\n          captions = _M3U8Parser$parseMast['CLOSED-CAPTIONS'];\n        if (audioTracks.length) {\n          // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n          var embeddedAudioFound = audioTracks.some(function (audioTrack) {\n            return !audioTrack.url;\n          });\n\n          // if no embedded audio track defined, but audio codec signaled in quality level,\n          // we need to signal this main audio track this could happen with playlists with\n          // alt audio rendition in which quality levels (main)\n          // contains both audio+video. but with mixed audio track not signaled\n          if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n            logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n            audioTracks.unshift({\n              type: 'main',\n              name: 'main',\n              groupId: 'main',\n              default: false,\n              autoselect: false,\n              forced: false,\n              id: -1,\n              attrs: new AttrList({}),\n              bitrate: 0,\n              url: ''\n            });\n          }\n        }\n        hls.trigger(Events.MANIFEST_LOADED, {\n          levels: levels,\n          audioTracks: audioTracks,\n          subtitles: subtitles,\n          captions: captions,\n          contentSteering: contentSteering,\n          url: url,\n          stats: stats,\n          networkDetails: networkDetails,\n          sessionData: sessionData,\n          sessionKeys: sessionKeys,\n          startTimeOffset: startTimeOffset,\n          variableList: variableList\n        });\n      };\n      _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {\n        var hls = this.hls;\n        var id = context.id,\n          level = context.level,\n          type = context.type;\n        var url = getResponseUrl(response, context);\n        var levelUrlId = isFiniteNumber(id) ? id : 0;\n        var levelId = isFiniteNumber(level) ? level : levelUrlId;\n        var levelType = mapContextToLevelType(context);\n        var levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);\n\n        // We have done our first request (Manifest-type) and receive\n        // not a master playlist but a chunk-list (track/level)\n        // We fire the manifest-loaded event anyway with the parsed level-details\n        // by creating a single-level structure for it.\n        if (type === PlaylistContextType.MANIFEST) {\n          var singleLevel = {\n            attrs: new AttrList({}),\n            bitrate: 0,\n            details: levelDetails,\n            name: '',\n            url: url\n          };\n          hls.trigger(Events.MANIFEST_LOADED, {\n            levels: [singleLevel],\n            audioTracks: [],\n            url: url,\n            stats: stats,\n            networkDetails: networkDetails,\n            sessionData: null,\n            sessionKeys: null,\n            contentSteering: null,\n            startTimeOffset: null,\n            variableList: null\n          });\n        }\n\n        // save parsing time\n        stats.parsing.end = performance.now();\n\n        // extend the context with the new levelDetails property\n        context.levelDetails = levelDetails;\n        this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);\n      };\n      _proto.handleManifestParsingError = function handleManifestParsingError(response, context, error, networkDetails, stats) {\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.NETWORK_ERROR,\n          details: ErrorDetails.MANIFEST_PARSING_ERROR,\n          fatal: context.type === PlaylistContextType.MANIFEST,\n          url: response.url,\n          err: error,\n          error: error,\n          reason: error.message,\n          response: response,\n          context: context,\n          networkDetails: networkDetails,\n          stats: stats\n        });\n      };\n      _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response, stats) {\n        if (timeout === void 0) {\n          timeout = false;\n        }\n        var message = \"A network \" + (timeout ? 'timeout' : 'error' + (response ? ' (status ' + response.code + ')' : '')) + \" occurred while loading \" + context.type;\n        if (context.type === PlaylistContextType.LEVEL) {\n          message += \": \" + context.level + \" id: \" + context.id;\n        } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {\n          message += \" id: \" + context.id + \" group-id: \\\"\" + context.groupId + \"\\\"\";\n        }\n        var error = new Error(message);\n        logger.warn(\"[playlist-loader]: \" + message);\n        var details = ErrorDetails.UNKNOWN;\n        var fatal = false;\n        var loader = this.getInternalLoader(context);\n        switch (context.type) {\n          case PlaylistContextType.MANIFEST:\n            details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;\n            fatal = true;\n            break;\n          case PlaylistContextType.LEVEL:\n            details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;\n            fatal = false;\n            break;\n          case PlaylistContextType.AUDIO_TRACK:\n            details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n            fatal = false;\n            break;\n          case PlaylistContextType.SUBTITLE_TRACK:\n            details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;\n            fatal = false;\n            break;\n        }\n        if (loader) {\n          this.resetInternalLoader(context.type);\n        }\n        var errorData = {\n          type: ErrorTypes.NETWORK_ERROR,\n          details: details,\n          fatal: fatal,\n          url: context.url,\n          loader: loader,\n          context: context,\n          error: error,\n          networkDetails: networkDetails,\n          stats: stats\n        };\n        if (response) {\n          var url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;\n          errorData.response = _objectSpread2({\n            url: url,\n            data: undefined\n          }, response);\n        }\n        this.hls.trigger(Events.ERROR, errorData);\n      };\n      _proto.handlePlaylistLoaded = function handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {\n        var hls = this.hls;\n        var type = context.type,\n          level = context.level,\n          id = context.id,\n          groupId = context.groupId,\n          deliveryDirectives = context.deliveryDirectives;\n        var url = getResponseUrl(response, context);\n        var parent = mapContextToLevelType(context);\n        var levelIndex = typeof context.level === 'number' && parent === PlaylistLevelType.MAIN ? level : undefined;\n        if (!levelDetails.fragments.length) {\n          var _error = new Error('No Segments found in Playlist');\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.LEVEL_EMPTY_ERROR,\n            fatal: false,\n            url: url,\n            error: _error,\n            reason: _error.message,\n            response: response,\n            context: context,\n            level: levelIndex,\n            parent: parent,\n            networkDetails: networkDetails,\n            stats: stats\n          });\n          return;\n        }\n        if (!levelDetails.targetduration) {\n          levelDetails.playlistParsingError = new Error('Missing Target Duration');\n        }\n        var error = levelDetails.playlistParsingError;\n        if (error) {\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.LEVEL_PARSING_ERROR,\n            fatal: false,\n            url: url,\n            error: error,\n            reason: error.message,\n            response: response,\n            context: context,\n            level: levelIndex,\n            parent: parent,\n            networkDetails: networkDetails,\n            stats: stats\n          });\n          return;\n        }\n        if (levelDetails.live && loader) {\n          if (loader.getCacheAge) {\n            levelDetails.ageHeader = loader.getCacheAge() || 0;\n          }\n          if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n            levelDetails.ageHeader = 0;\n          }\n        }\n        switch (type) {\n          case PlaylistContextType.MANIFEST:\n          case PlaylistContextType.LEVEL:\n            hls.trigger(Events.LEVEL_LOADED, {\n              details: levelDetails,\n              level: levelIndex || 0,\n              id: id || 0,\n              stats: stats,\n              networkDetails: networkDetails,\n              deliveryDirectives: deliveryDirectives\n            });\n            break;\n          case PlaylistContextType.AUDIO_TRACK:\n            hls.trigger(Events.AUDIO_TRACK_LOADED, {\n              details: levelDetails,\n              id: id || 0,\n              groupId: groupId || '',\n              stats: stats,\n              networkDetails: networkDetails,\n              deliveryDirectives: deliveryDirectives\n            });\n            break;\n          case PlaylistContextType.SUBTITLE_TRACK:\n            hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n              details: levelDetails,\n              id: id || 0,\n              groupId: groupId || '',\n              stats: stats,\n              networkDetails: networkDetails,\n              deliveryDirectives: deliveryDirectives\n            });\n            break;\n        }\n      };\n      return PlaylistLoader;\n    }();\n    function sendAddTrackEvent(track, videoEl) {\n      var event;\n      try {\n        event = new Event('addtrack');\n      } catch (err) {\n        // for IE11\n        event = document.createEvent('Event');\n        event.initEvent('addtrack', false, false);\n      }\n      event.track = track;\n      videoEl.dispatchEvent(event);\n    }\n    function clearCurrentCues(track) {\n      // When track.mode is disabled, track.cues will be null.\n      // To guarantee the removal of cues, we need to temporarily\n      // change the mode to hidden\n      var mode = track.mode;\n      if (mode === 'disabled') {\n        track.mode = 'hidden';\n      }\n      if (track.cues) {\n        for (var i = track.cues.length; i--;) {\n          track.removeCue(track.cues[i]);\n        }\n      }\n      if (mode === 'disabled') {\n        track.mode = mode;\n      }\n    }\n    function removeCuesInRange(track, start, end, predicate) {\n      var mode = track.mode;\n      if (mode === 'disabled') {\n        track.mode = 'hidden';\n      }\n      if (track.cues && track.cues.length > 0) {\n        var cues = getCuesInRange(track.cues, start, end);\n        for (var i = 0; i < cues.length; i++) {\n          if (!predicate || predicate(cues[i])) {\n            track.removeCue(cues[i]);\n          }\n        }\n      }\n      if (mode === 'disabled') {\n        track.mode = mode;\n      }\n    }\n\n    // Find first cue starting after given time.\n    // Modified version of binary search O(log(n)).\n    function getFirstCueIndexAfterTime(cues, time) {\n      // If first cue starts after time, start there\n      if (time < cues[0].startTime) {\n        return 0;\n      }\n      // If the last cue ends before time there is no overlap\n      var len = cues.length - 1;\n      if (time > cues[len].endTime) {\n        return -1;\n      }\n      var left = 0;\n      var right = len;\n      while (left <= right) {\n        var mid = Math.floor((right + left) / 2);\n        if (time < cues[mid].startTime) {\n          right = mid - 1;\n        } else if (time > cues[mid].startTime && left < len) {\n          left = mid + 1;\n        } else {\n          // If it's not lower or higher, it must be equal.\n          return mid;\n        }\n      }\n      // At this point, left and right have swapped.\n      // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n      return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n    }\n    function getCuesInRange(cues, start, end) {\n      var cuesFound = [];\n      var firstCueInRange = getFirstCueIndexAfterTime(cues, start);\n      if (firstCueInRange > -1) {\n        for (var i = firstCueInRange, len = cues.length; i < len; i++) {\n          var _cue = cues[i];\n          if (_cue.startTime >= start && _cue.endTime <= end) {\n            cuesFound.push(_cue);\n          } else if (_cue.startTime > end) {\n            return cuesFound;\n          }\n        }\n      }\n      return cuesFound;\n    }\n    var MetadataSchema = {\n      audioId3: \"org.id3\",\n      dateRange: \"com.apple.quicktime.HLS\",\n      emsg: \"https://aomedia.org/emsg/ID3\"\n    };\n    var MIN_CUE_DURATION = 0.25;\n    function getCueClass() {\n      if (typeof self === 'undefined') return undefined;\n\n      // Attempt to recreate Safari functionality by creating\n      // WebKitDataCue objects when available and store the decoded\n      // ID3 data in the value property of the cue\n      return self.WebKitDataCue || self.VTTCue || self.TextTrackCue;\n    }\n\n    // VTTCue latest draft allows an infinite duration, fallback\n    // to MAX_VALUE if necessary\n    var MAX_CUE_ENDTIME = function () {\n      var Cue = getCueClass();\n      try {\n        new Cue(0, Number.POSITIVE_INFINITY, '');\n      } catch (e) {\n        return Number.MAX_VALUE;\n      }\n      return Number.POSITIVE_INFINITY;\n    }();\n    function dateRangeDateToTimelineSeconds(date, offset) {\n      return date.getTime() / 1000 - offset;\n    }\n    function hexToArrayBuffer(str) {\n      return Uint8Array.from(str.replace(/^0x/, '').replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;\n    }\n    var ID3TrackController = /*#__PURE__*/function () {\n      function ID3TrackController(hls) {\n        this.hls = void 0;\n        this.id3Track = null;\n        this.media = null;\n        this.dateRangeCuesAppended = {};\n        this.hls = hls;\n        this._registerListeners();\n      }\n      var _proto = ID3TrackController.prototype;\n      _proto.destroy = function destroy() {\n        this._unregisterListeners();\n        this.id3Track = null;\n        this.media = null;\n        this.dateRangeCuesAppended = {};\n        // @ts-ignore\n        this.hls = null;\n      };\n      _proto._registerListeners = function _registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      };\n      _proto._unregisterListeners = function _unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      }\n\n      // Add ID3 metatadata text track.\n      ;\n\n      _proto.onMediaAttached = function onMediaAttached(event, data) {\n        this.media = data.media;\n      };\n      _proto.onMediaDetaching = function onMediaDetaching() {\n        if (!this.id3Track) {\n          return;\n        }\n        clearCurrentCues(this.id3Track);\n        this.id3Track = null;\n        this.media = null;\n        this.dateRangeCuesAppended = {};\n      };\n      _proto.onManifestLoading = function onManifestLoading() {\n        this.dateRangeCuesAppended = {};\n      };\n      _proto.createTrack = function createTrack(media) {\n        var track = this.getID3Track(media.textTracks);\n        track.mode = 'hidden';\n        return track;\n      };\n      _proto.getID3Track = function getID3Track(textTracks) {\n        if (!this.media) {\n          return;\n        }\n        for (var i = 0; i < textTracks.length; i++) {\n          var textTrack = textTracks[i];\n          if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n            // send 'addtrack' when reusing the textTrack for metadata,\n            // same as what we do for captions\n            sendAddTrackEvent(textTrack, this.media);\n            return textTrack;\n          }\n        }\n        return this.media.addTextTrack('metadata', 'id3');\n      };\n      _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {\n        if (!this.media) {\n          return;\n        }\n        var _this$hls$config = this.hls.config,\n          enableEmsgMetadataCues = _this$hls$config.enableEmsgMetadataCues,\n          enableID3MetadataCues = _this$hls$config.enableID3MetadataCues;\n        if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n          return;\n        }\n        var samples = data.samples;\n\n        // create track dynamically\n        if (!this.id3Track) {\n          this.id3Track = this.createTrack(this.media);\n        }\n        var Cue = getCueClass();\n        for (var i = 0; i < samples.length; i++) {\n          var type = samples[i].type;\n          if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n            continue;\n          }\n          var frames = getID3Frames(samples[i].data);\n          if (frames) {\n            var startTime = samples[i].pts;\n            var endTime = startTime + samples[i].duration;\n            if (endTime > MAX_CUE_ENDTIME) {\n              endTime = MAX_CUE_ENDTIME;\n            }\n            var timeDiff = endTime - startTime;\n            if (timeDiff <= 0) {\n              endTime = startTime + MIN_CUE_DURATION;\n            }\n            for (var j = 0; j < frames.length; j++) {\n              var frame = frames[j];\n              // Safari doesn't put the timestamp frame in the TextTrack\n              if (!isTimeStampFrame(frame)) {\n                // add a bounds to any unbounded cues\n                this.updateId3CueEnds(startTime);\n                var cue = new Cue(startTime, endTime, '');\n                cue.value = frame;\n                if (type) {\n                  cue.type = type;\n                }\n                this.id3Track.addCue(cue);\n              }\n            }\n          }\n        }\n      };\n      _proto.updateId3CueEnds = function updateId3CueEnds(startTime) {\n        var _this$id3Track;\n        var cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;\n        if (cues) {\n          for (var i = cues.length; i--;) {\n            var cue = cues[i];\n            if (cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n              cue.endTime = startTime;\n            }\n          }\n        }\n      };\n      _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {\n        var startOffset = _ref.startOffset,\n          endOffset = _ref.endOffset,\n          type = _ref.type;\n        var id3Track = this.id3Track,\n          hls = this.hls;\n        if (!hls) {\n          return;\n        }\n        var _hls$config = hls.config,\n          enableEmsgMetadataCues = _hls$config.enableEmsgMetadataCues,\n          enableID3MetadataCues = _hls$config.enableID3MetadataCues;\n        if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n          var predicate;\n          if (type === 'audio') {\n            predicate = function predicate(cue) {\n              return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;\n            };\n          } else if (type === 'video') {\n            predicate = function predicate(cue) {\n              return cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n            };\n          } else {\n            predicate = function predicate(cue) {\n              return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n            };\n          }\n          removeCuesInRange(id3Track, startOffset, endOffset, predicate);\n        }\n      };\n      _proto.onLevelUpdated = function onLevelUpdated(event, _ref2) {\n        var _this = this;\n        var details = _ref2.details;\n        if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n          return;\n        }\n        var dateRangeCuesAppended = this.dateRangeCuesAppended,\n          id3Track = this.id3Track;\n        var dateRanges = details.dateRanges;\n        var ids = Object.keys(dateRanges);\n        // Remove cues from track not found in details.dateRanges\n        if (id3Track) {\n          var idsToRemove = Object.keys(dateRangeCuesAppended).filter(function (id) {\n            return !ids.includes(id);\n          });\n          var _loop = function _loop() {\n            var id = idsToRemove[i];\n            Object.keys(dateRangeCuesAppended[id].cues).forEach(function (key) {\n              id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);\n            });\n            delete dateRangeCuesAppended[id];\n          };\n          for (var i = idsToRemove.length; i--;) {\n            _loop();\n          }\n        }\n        // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n        var lastFragment = details.fragments[details.fragments.length - 1];\n        if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {\n          return;\n        }\n        if (!this.id3Track) {\n          this.id3Track = this.createTrack(this.media);\n        }\n        var dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;\n        var Cue = getCueClass();\n        var _loop2 = function _loop2() {\n          var id = ids[_i];\n          var dateRange = dateRanges[id];\n          var appendedDateRangeCues = dateRangeCuesAppended[id];\n          var cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};\n          var durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;\n          var startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);\n          var endTime = MAX_CUE_ENDTIME;\n          var endDate = dateRange.endDate;\n          if (endDate) {\n            endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);\n            durationKnown = true;\n          } else if (dateRange.endOnNext && !durationKnown) {\n            var nextDateRangeWithSameClass = ids.reduce(function (filterMapArray, id) {\n              var candidate = dateRanges[id];\n              if (candidate.class === dateRange.class && candidate.id !== id && candidate.startDate > dateRange.startDate) {\n                filterMapArray.push(candidate);\n              }\n              return filterMapArray;\n            }, []).sort(function (a, b) {\n              return a.startDate.getTime() - b.startDate.getTime();\n            })[0];\n            if (nextDateRangeWithSameClass) {\n              endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);\n              durationKnown = true;\n            }\n          }\n          var attributes = Object.keys(dateRange.attr);\n          for (var j = 0; j < attributes.length; j++) {\n            var key = attributes[j];\n            if (!isDateRangeCueAttribute(key)) {\n              continue;\n            }\n            var cue = cues[key];\n            if (cue) {\n              if (durationKnown && !appendedDateRangeCues.durationKnown) {\n                cue.endTime = endTime;\n              }\n            } else {\n              var data = dateRange.attr[key];\n              cue = new Cue(startTime, endTime, '');\n              if (isSCTE35Attribute(key)) {\n                data = hexToArrayBuffer(data);\n              }\n              cue.value = {\n                key: key,\n                data: data\n              };\n              cue.type = MetadataSchema.dateRange;\n              cue.id = id;\n              _this.id3Track.addCue(cue);\n              cues[key] = cue;\n            }\n          }\n          dateRangeCuesAppended[id] = {\n            cues: cues,\n            dateRange: dateRange,\n            durationKnown: durationKnown\n          };\n        };\n        for (var _i = 0; _i < ids.length; _i++) {\n          _loop2();\n        }\n      };\n      return ID3TrackController;\n    }();\n    var LatencyController = /*#__PURE__*/function () {\n      function LatencyController(hls) {\n        var _this = this;\n        this.hls = void 0;\n        this.config = void 0;\n        this.media = null;\n        this.levelDetails = null;\n        this.currentTime = 0;\n        this.stallCount = 0;\n        this._latency = null;\n        this.timeupdateHandler = function () {\n          return _this.timeupdate();\n        };\n        this.hls = hls;\n        this.config = hls.config;\n        this.registerListeners();\n      }\n      var _proto = LatencyController.prototype;\n      _proto.destroy = function destroy() {\n        this.unregisterListeners();\n        this.onMediaDetaching();\n        this.levelDetails = null;\n        // @ts-ignore\n        this.hls = this.timeupdateHandler = null;\n      };\n      _proto.registerListeners = function registerListeners() {\n        this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        this.hls.on(Events.ERROR, this.onError, this);\n      };\n      _proto.unregisterListeners = function unregisterListeners() {\n        this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        this.hls.off(Events.ERROR, this.onError, this);\n      };\n      _proto.onMediaAttached = function onMediaAttached(event, data) {\n        this.media = data.media;\n        this.media.addEventListener('timeupdate', this.timeupdateHandler);\n      };\n      _proto.onMediaDetaching = function onMediaDetaching() {\n        if (this.media) {\n          this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n          this.media = null;\n        }\n      };\n      _proto.onManifestLoading = function onManifestLoading() {\n        this.levelDetails = null;\n        this._latency = null;\n        this.stallCount = 0;\n      };\n      _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n        var details = _ref.details;\n        this.levelDetails = details;\n        if (details.advanced) {\n          this.timeupdate();\n        }\n        if (!details.live && this.media) {\n          this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n        }\n      };\n      _proto.onError = function onError(event, data) {\n        var _this$levelDetails;\n        if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {\n          return;\n        }\n        this.stallCount++;\n        if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {\n          logger.warn('[playback-rate-controller]: Stall detected, adjusting target latency');\n        }\n      };\n      _proto.timeupdate = function timeupdate() {\n        var media = this.media,\n          levelDetails = this.levelDetails;\n        if (!media || !levelDetails) {\n          return;\n        }\n        this.currentTime = media.currentTime;\n        var latency = this.computeLatency();\n        if (latency === null) {\n          return;\n        }\n        this._latency = latency;\n\n        // Adapt playbackRate to meet target latency in low-latency mode\n        var _this$config = this.config,\n          lowLatencyMode = _this$config.lowLatencyMode,\n          maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;\n        if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1) {\n          return;\n        }\n        var targetLatency = this.targetLatency;\n        if (targetLatency === null) {\n          return;\n        }\n        var distanceFromTarget = latency - targetLatency;\n        // Only adjust playbackRate when within one target duration of targetLatency\n        // and more than one second from under-buffering.\n        // Playback further than one target duration from target can be considered DVR playback.\n        var liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n        var inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n        if (levelDetails.live && inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n          var max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n          var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n          media.playbackRate = Math.min(max, Math.max(1, rate));\n        } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n          media.playbackRate = 1;\n        }\n      };\n      _proto.estimateLiveEdge = function estimateLiveEdge() {\n        var levelDetails = this.levelDetails;\n        if (levelDetails === null) {\n          return null;\n        }\n        return levelDetails.edge + levelDetails.age;\n      };\n      _proto.computeLatency = function computeLatency() {\n        var liveEdge = this.estimateLiveEdge();\n        if (liveEdge === null) {\n          return null;\n        }\n        return liveEdge - this.currentTime;\n      };\n      _createClass(LatencyController, [{\n        key: \"latency\",\n        get: function get() {\n          return this._latency || 0;\n        }\n      }, {\n        key: \"maxLatency\",\n        get: function get() {\n          var config = this.config,\n            levelDetails = this.levelDetails;\n          if (config.liveMaxLatencyDuration !== undefined) {\n            return config.liveMaxLatencyDuration;\n          }\n          return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n        }\n      }, {\n        key: \"targetLatency\",\n        get: function get() {\n          var levelDetails = this.levelDetails;\n          if (levelDetails === null) {\n            return null;\n          }\n          var holdBack = levelDetails.holdBack,\n            partHoldBack = levelDetails.partHoldBack,\n            targetduration = levelDetails.targetduration;\n          var _this$config2 = this.config,\n            liveSyncDuration = _this$config2.liveSyncDuration,\n            liveSyncDurationCount = _this$config2.liveSyncDurationCount,\n            lowLatencyMode = _this$config2.lowLatencyMode;\n          var userConfig = this.hls.userConfig;\n          var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n          if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n            targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n          }\n          var maxLiveSyncOnStallIncrease = targetduration;\n          var liveSyncOnStallIncrease = 1.0;\n          return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n        }\n      }, {\n        key: \"liveSyncPosition\",\n        get: function get() {\n          var liveEdge = this.estimateLiveEdge();\n          var targetLatency = this.targetLatency;\n          var levelDetails = this.levelDetails;\n          if (liveEdge === null || targetLatency === null || levelDetails === null) {\n            return null;\n          }\n          var edge = levelDetails.edge;\n          var syncPosition = liveEdge - targetLatency - this.edgeStalled;\n          var min = edge - levelDetails.totalduration;\n          var max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n          return Math.min(Math.max(min, syncPosition), max);\n        }\n      }, {\n        key: \"drift\",\n        get: function get() {\n          var levelDetails = this.levelDetails;\n          if (levelDetails === null) {\n            return 1;\n          }\n          return levelDetails.drift;\n        }\n      }, {\n        key: \"edgeStalled\",\n        get: function get() {\n          var levelDetails = this.levelDetails;\n          if (levelDetails === null) {\n            return 0;\n          }\n          var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n          return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n        }\n      }, {\n        key: \"forwardBufferLength\",\n        get: function get() {\n          var media = this.media,\n            levelDetails = this.levelDetails;\n          if (!media || !levelDetails) {\n            return 0;\n          }\n          var bufferedRanges = media.buffered.length;\n          return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n        }\n      }]);\n      return LatencyController;\n    }();\n    var HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', null];\n    var HlsSkip = {\n      No: \"\",\n      Yes: \"YES\",\n      v2: \"v2\"\n    };\n    function getSkipValue(details, msn) {\n      var canSkipUntil = details.canSkipUntil,\n        canSkipDateRanges = details.canSkipDateRanges,\n        endSN = details.endSN;\n      var snChangeGoal = msn !== undefined ? msn - endSN : 0;\n      if (canSkipUntil && snChangeGoal < canSkipUntil) {\n        if (canSkipDateRanges) {\n          return HlsSkip.v2;\n        }\n        return HlsSkip.Yes;\n      }\n      return HlsSkip.No;\n    }\n    var HlsUrlParameters = /*#__PURE__*/function () {\n      function HlsUrlParameters(msn, part, skip) {\n        this.msn = void 0;\n        this.part = void 0;\n        this.skip = void 0;\n        this.msn = msn;\n        this.part = part;\n        this.skip = skip;\n      }\n      var _proto = HlsUrlParameters.prototype;\n      _proto.addDirectives = function addDirectives(uri) {\n        var url = new self.URL(uri);\n        if (this.msn !== undefined) {\n          url.searchParams.set('_HLS_msn', this.msn.toString());\n        }\n        if (this.part !== undefined) {\n          url.searchParams.set('_HLS_part', this.part.toString());\n        }\n        if (this.skip) {\n          url.searchParams.set('_HLS_skip', this.skip);\n        }\n        return url.href;\n      };\n      return HlsUrlParameters;\n    }();\n    var Level = /*#__PURE__*/function () {\n      function Level(data) {\n        this._attrs = void 0;\n        this.audioCodec = void 0;\n        this.bitrate = void 0;\n        this.codecSet = void 0;\n        this.height = void 0;\n        this.id = void 0;\n        this.name = void 0;\n        this.videoCodec = void 0;\n        this.width = void 0;\n        this.unknownCodecs = void 0;\n        this.audioGroupIds = void 0;\n        this.details = void 0;\n        this.fragmentError = 0;\n        this.loadError = 0;\n        this.loaded = void 0;\n        this.realBitrate = 0;\n        this.textGroupIds = void 0;\n        this.url = void 0;\n        this._urlId = 0;\n        this.url = [data.url];\n        this._attrs = [data.attrs];\n        this.bitrate = data.bitrate;\n        if (data.details) {\n          this.details = data.details;\n        }\n        this.id = data.id || 0;\n        this.name = data.name;\n        this.width = data.width || 0;\n        this.height = data.height || 0;\n        this.audioCodec = data.audioCodec;\n        this.videoCodec = data.videoCodec;\n        this.unknownCodecs = data.unknownCodecs;\n        this.codecSet = [data.videoCodec, data.audioCodec].filter(function (c) {\n          return c;\n        }).join(',').replace(/\\.[^.,]+/g, '');\n      }\n      var _proto2 = Level.prototype;\n      _proto2.addFallback = function addFallback(data) {\n        this.url.push(data.url);\n        this._attrs.push(data.attrs);\n      };\n      _createClass(Level, [{\n        key: \"maxBitrate\",\n        get: function get() {\n          return Math.max(this.realBitrate, this.bitrate);\n        }\n      }, {\n        key: \"attrs\",\n        get: function get() {\n          return this._attrs[this._urlId];\n        }\n      }, {\n        key: \"pathwayId\",\n        get: function get() {\n          return this.attrs['PATHWAY-ID'] || '.';\n        }\n      }, {\n        key: \"uri\",\n        get: function get() {\n          return this.url[this._urlId] || '';\n        }\n      }, {\n        key: \"urlId\",\n        get: function get() {\n          return this._urlId;\n        },\n        set: function set(value) {\n          var newValue = value % this.url.length;\n          if (this._urlId !== newValue) {\n            this.fragmentError = 0;\n            this.loadError = 0;\n            this.details = undefined;\n            this._urlId = newValue;\n          }\n        }\n      }, {\n        key: \"audioGroupId\",\n        get: function get() {\n          var _this$audioGroupIds;\n          return (_this$audioGroupIds = this.audioGroupIds) == null ? void 0 : _this$audioGroupIds[this.urlId];\n        }\n      }, {\n        key: \"textGroupId\",\n        get: function get() {\n          var _this$textGroupIds;\n          return (_this$textGroupIds = this.textGroupIds) == null ? void 0 : _this$textGroupIds[this.urlId];\n        }\n      }]);\n      return Level;\n    }();\n    function updateFromToPTS(fragFrom, fragTo) {\n      var fragToPTS = fragTo.startPTS;\n      // if we know startPTS[toIdx]\n      if (isFiniteNumber(fragToPTS)) {\n        // update fragment duration.\n        // it helps to fix drifts between playlist reported duration and fragment real duration\n        var duration = 0;\n        var frag;\n        if (fragTo.sn > fragFrom.sn) {\n          duration = fragToPTS - fragFrom.start;\n          frag = fragFrom;\n        } else {\n          duration = fragFrom.start - fragToPTS;\n          frag = fragTo;\n        }\n        if (frag.duration !== duration) {\n          frag.duration = duration;\n        }\n        // we dont know startPTS[toIdx]\n      } else if (fragTo.sn > fragFrom.sn) {\n        var contiguous = fragFrom.cc === fragTo.cc;\n        // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n        if (contiguous && fragFrom.minEndPTS) {\n          fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);\n        } else {\n          fragTo.start = fragFrom.start + fragFrom.duration;\n        }\n      } else {\n        fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);\n      }\n    }\n    function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n      var parsedMediaDuration = endPTS - startPTS;\n      if (parsedMediaDuration <= 0) {\n        logger.warn('Fragment should have a positive duration', frag);\n        endPTS = startPTS + frag.duration;\n        endDTS = startDTS + frag.duration;\n      }\n      var maxStartPTS = startPTS;\n      var minEndPTS = endPTS;\n      var fragStartPts = frag.startPTS;\n      var fragEndPts = frag.endPTS;\n      if (isFiniteNumber(fragStartPts)) {\n        // delta PTS between audio and video\n        var deltaPTS = Math.abs(fragStartPts - startPTS);\n        if (!isFiniteNumber(frag.deltaPTS)) {\n          frag.deltaPTS = deltaPTS;\n        } else {\n          frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n        }\n        maxStartPTS = Math.max(startPTS, fragStartPts);\n        startPTS = Math.min(startPTS, fragStartPts);\n        startDTS = Math.min(startDTS, frag.startDTS);\n        minEndPTS = Math.min(endPTS, fragEndPts);\n        endPTS = Math.max(endPTS, fragEndPts);\n        endDTS = Math.max(endDTS, frag.endDTS);\n      }\n      var drift = startPTS - frag.start;\n      if (frag.start !== 0) {\n        frag.start = startPTS;\n      }\n      frag.duration = endPTS - frag.start;\n      frag.startPTS = startPTS;\n      frag.maxStartPTS = maxStartPTS;\n      frag.startDTS = startDTS;\n      frag.endPTS = endPTS;\n      frag.minEndPTS = minEndPTS;\n      frag.endDTS = endDTS;\n      var sn = frag.sn; // 'initSegment'\n      // exit if sn out of range\n      if (!details || sn < details.startSN || sn > details.endSN) {\n        return 0;\n      }\n      var i;\n      var fragIdx = sn - details.startSN;\n      var fragments = details.fragments;\n      // update frag reference in fragments array\n      // rationale is that fragments array might not contain this frag object.\n      // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n      // if we don't update frag, we won't be able to propagate PTS info on the playlist\n      // resulting in invalid sliding computation\n      fragments[fragIdx] = frag;\n      // adjust fragment PTS/duration from seqnum-1 to frag 0\n      for (i = fragIdx; i > 0; i--) {\n        updateFromToPTS(fragments[i], fragments[i - 1]);\n      }\n\n      // adjust fragment PTS/duration from seqnum to last frag\n      for (i = fragIdx; i < fragments.length - 1; i++) {\n        updateFromToPTS(fragments[i], fragments[i + 1]);\n      }\n      if (details.fragmentHint) {\n        updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n      }\n      details.PTSKnown = details.alignedSliding = true;\n      return drift;\n    }\n    function mergeDetails(oldDetails, newDetails) {\n      // Track the last initSegment processed. Initialize it to the last one on the timeline.\n      var currentInitSegment = null;\n      var oldFragments = oldDetails.fragments;\n      for (var i = oldFragments.length - 1; i >= 0; i--) {\n        var oldInit = oldFragments[i].initSegment;\n        if (oldInit) {\n          currentInitSegment = oldInit;\n          break;\n        }\n      }\n      if (oldDetails.fragmentHint) {\n        // prevent PTS and duration from being adjusted on the next hint\n        delete oldDetails.fragmentHint.endPTS;\n      }\n      // check if old/new playlists have fragments in common\n      // loop through overlapping SN and update startPTS , cc, and duration if any found\n      var ccOffset = 0;\n      var PTSFrag;\n      mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {\n        if (oldFrag.relurl) {\n          // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.\n          // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end\n          // of the playlist.\n          ccOffset = oldFrag.cc - newFrag.cc;\n        }\n        if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {\n          newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n          newFrag.startDTS = oldFrag.startDTS;\n          newFrag.maxStartPTS = oldFrag.maxStartPTS;\n          newFrag.endPTS = oldFrag.endPTS;\n          newFrag.endDTS = oldFrag.endDTS;\n          newFrag.minEndPTS = oldFrag.minEndPTS;\n          newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;\n          if (newFrag.duration) {\n            PTSFrag = newFrag;\n          }\n\n          // PTS is known when any segment has startPTS and endPTS\n          newDetails.PTSKnown = newDetails.alignedSliding = true;\n        }\n        newFrag.elementaryStreams = oldFrag.elementaryStreams;\n        newFrag.loader = oldFrag.loader;\n        newFrag.stats = oldFrag.stats;\n        newFrag.urlId = oldFrag.urlId;\n        if (oldFrag.initSegment) {\n          newFrag.initSegment = oldFrag.initSegment;\n          currentInitSegment = oldFrag.initSegment;\n        }\n      });\n      if (currentInitSegment) {\n        var fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n        fragmentsToCheck.forEach(function (frag) {\n          var _currentInitSegment;\n          if (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl)) {\n            frag.initSegment = currentInitSegment;\n          }\n        });\n      }\n      if (newDetails.skippedSegments) {\n        newDetails.deltaUpdateFailed = newDetails.fragments.some(function (frag) {\n          return !frag;\n        });\n        if (newDetails.deltaUpdateFailed) {\n          logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n          for (var _i = newDetails.skippedSegments; _i--;) {\n            newDetails.fragments.shift();\n          }\n          newDetails.startSN = newDetails.fragments[0].sn;\n          newDetails.startCC = newDetails.fragments[0].cc;\n        } else if (newDetails.canSkipDateRanges) {\n          newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);\n        }\n      }\n      var newFragments = newDetails.fragments;\n      if (ccOffset) {\n        logger.warn('discontinuity sliding from playlist, take drift into account');\n        for (var _i2 = 0; _i2 < newFragments.length; _i2++) {\n          newFragments[_i2].cc += ccOffset;\n        }\n      }\n      if (newDetails.skippedSegments) {\n        newDetails.startCC = newDetails.fragments[0].cc;\n      }\n\n      // Merge parts\n      mapPartIntersection(oldDetails.partList, newDetails.partList, function (oldPart, newPart) {\n        newPart.elementaryStreams = oldPart.elementaryStreams;\n        newPart.stats = oldPart.stats;\n      });\n\n      // if at least one fragment contains PTS info, recompute PTS information for all fragments\n      if (PTSFrag) {\n        updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n      } else {\n        // ensure that delta is within oldFragments range\n        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n        // in that case we also need to adjust start offset of all fragments\n        adjustSliding(oldDetails, newDetails);\n      }\n      if (newFragments.length) {\n        newDetails.totalduration = newDetails.edge - newFragments[0].start;\n      }\n      newDetails.driftStartTime = oldDetails.driftStartTime;\n      newDetails.driftStart = oldDetails.driftStart;\n      var advancedDateTime = newDetails.advancedDateTime;\n      if (newDetails.advanced && advancedDateTime) {\n        var edge = newDetails.edge;\n        if (!newDetails.driftStart) {\n          newDetails.driftStartTime = advancedDateTime;\n          newDetails.driftStart = edge;\n        }\n        newDetails.driftEndTime = advancedDateTime;\n        newDetails.driftEnd = edge;\n      } else {\n        newDetails.driftEndTime = oldDetails.driftEndTime;\n        newDetails.driftEnd = oldDetails.driftEnd;\n        newDetails.advancedDateTime = oldDetails.advancedDateTime;\n      }\n    }\n    function mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {\n      var dateRanges = _extends({}, oldDateRanges);\n      if (recentlyRemovedDateranges) {\n        recentlyRemovedDateranges.forEach(function (id) {\n          delete dateRanges[id];\n        });\n      }\n      Object.keys(deltaDateRanges).forEach(function (id) {\n        var dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);\n        if (dateRange.isValid) {\n          dateRanges[id] = dateRange;\n        } else {\n          logger.warn(\"Ignoring invalid Playlist Delta Update DATERANGE tag: \\\"\" + JSON.stringify(deltaDateRanges[id].attr) + \"\\\"\");\n        }\n      });\n      return dateRanges;\n    }\n    function mapPartIntersection(oldParts, newParts, intersectionFn) {\n      if (oldParts && newParts) {\n        var delta = 0;\n        for (var i = 0, len = oldParts.length; i <= len; i++) {\n          var _oldPart = oldParts[i];\n          var _newPart = newParts[i + delta];\n          if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {\n            intersectionFn(_oldPart, _newPart);\n          } else {\n            delta--;\n          }\n        }\n      }\n    }\n    function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n      var skippedSegments = newDetails.skippedSegments;\n      var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n      var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n      var delta = newDetails.startSN - oldDetails.startSN;\n      var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n      var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n      for (var i = start; i <= end; i++) {\n        var _oldFrag = oldFrags[delta + i];\n        var _newFrag = newFrags[i];\n        if (skippedSegments && !_newFrag && i < skippedSegments) {\n          // Fill in skipped segments in delta playlist\n          _newFrag = newDetails.fragments[i] = _oldFrag;\n        }\n        if (_oldFrag && _newFrag) {\n          intersectionFn(_oldFrag, _newFrag);\n        }\n      }\n    }\n    function adjustSliding(oldDetails, newDetails) {\n      var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n      var oldFragments = oldDetails.fragments;\n      if (delta < 0 || delta >= oldFragments.length) {\n        return;\n      }\n      addSliding(newDetails, oldFragments[delta].start);\n    }\n    function addSliding(details, start) {\n      if (start) {\n        var fragments = details.fragments;\n        for (var i = details.skippedSegments; i < fragments.length; i++) {\n          fragments[i].start += start;\n        }\n        if (details.fragmentHint) {\n          details.fragmentHint.start += start;\n        }\n      }\n    }\n    function computeReloadInterval(newDetails, distanceToLiveEdgeMs) {\n      if (distanceToLiveEdgeMs === void 0) {\n        distanceToLiveEdgeMs = Infinity;\n      }\n      var reloadInterval = 1000 * newDetails.targetduration;\n      if (newDetails.updated) {\n        // Use last segment duration when shorter than target duration and near live edge\n        var fragments = newDetails.fragments;\n        var liveEdgeMaxTargetDurations = 4;\n        if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n          var lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n          if (lastSegmentDuration < reloadInterval) {\n            reloadInterval = lastSegmentDuration;\n          }\n        }\n      } else {\n        // estimate = 'miss half average';\n        // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n        // changed then it MUST wait for a period of one-half the target\n        // duration before retrying.\n        reloadInterval /= 2;\n      }\n      return Math.round(reloadInterval);\n    }\n    function getFragmentWithSN(level, sn, fragCurrent) {\n      if (!(level != null && level.details)) {\n        return null;\n      }\n      var levelDetails = level.details;\n      var fragment = levelDetails.fragments[sn - levelDetails.startSN];\n      if (fragment) {\n        return fragment;\n      }\n      fragment = levelDetails.fragmentHint;\n      if (fragment && fragment.sn === sn) {\n        return fragment;\n      }\n      if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {\n        return fragCurrent;\n      }\n      return null;\n    }\n    function getPartWith(level, sn, partIndex) {\n      var _level$details;\n      if (!(level != null && level.details)) {\n        return null;\n      }\n      return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);\n    }\n    function findPart(partList, sn, partIndex) {\n      if (partList) {\n        for (var i = partList.length; i--;) {\n          var part = partList[i];\n          if (part.index === partIndex && part.fragment.sn === sn) {\n            return part;\n          }\n        }\n      }\n      return null;\n    }\n    function isTimeoutError(error) {\n      switch (error.details) {\n        case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case ErrorDetails.KEY_LOAD_TIMEOUT:\n        case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        case ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n          return true;\n      }\n      return false;\n    }\n    function getRetryConfig(loadPolicy, error) {\n      var isTimeout = isTimeoutError(error);\n      return loadPolicy.default[(isTimeout ? 'timeout' : 'error') + \"Retry\"];\n    }\n    function getRetryDelay(retryConfig, retryCount) {\n      // exponential backoff capped to max retry delay\n      var backoffFactor = retryConfig.backoff === 'linear' ? 1 : Math.pow(2, retryCount);\n      return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);\n    }\n    function getLoaderConfigWithoutReties(loderConfig) {\n      return _objectSpread2(_objectSpread2({}, loderConfig), {\n        errorRetry: null,\n        timeoutRetry: null\n      });\n    }\n    function shouldRetry(retryConfig, retryCount, isTimeout, httpStatus) {\n      return !!retryConfig && retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);\n    }\n    function retryForHttpStatus(httpStatus) {\n      // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)\n      return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);\n    }\n    var BinarySearch = {\n      /**\n       * Searches for an item in an array which matches a certain condition.\n       * This requires the condition to only match one item in the array,\n       * and for the array to be ordered.\n       *\n       * @param list The array to search.\n       * @param comparisonFn\n       *      Called and provided a candidate item as the first argument.\n       *      Should return:\n       *          > -1 if the item should be located at a lower index than the provided item.\n       *          > 1 if the item should be located at a higher index than the provided item.\n       *          > 0 if the item is the item you're looking for.\n       *\n       * @returns the object if found, otherwise returns null\n       */\n      search: function search(list, comparisonFn) {\n        var minIndex = 0;\n        var maxIndex = list.length - 1;\n        var currentIndex = null;\n        var currentElement = null;\n        while (minIndex <= maxIndex) {\n          currentIndex = (minIndex + maxIndex) / 2 | 0;\n          currentElement = list[currentIndex];\n          var comparisonResult = comparisonFn(currentElement);\n          if (comparisonResult > 0) {\n            minIndex = currentIndex + 1;\n          } else if (comparisonResult < 0) {\n            maxIndex = currentIndex - 1;\n          } else {\n            return currentElement;\n          }\n        }\n        return null;\n      }\n    };\n\n    /**\n     * Returns first fragment whose endPdt value exceeds the given PDT, or null.\n     * @param fragments - The array of candidate fragments\n     * @param PDTValue - The PDT value which must be exceeded\n     * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n     */\n    function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n      if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {\n        return null;\n      }\n\n      // if less than start\n      var startPDT = fragments[0].programDateTime;\n      if (PDTValue < (startPDT || 0)) {\n        return null;\n      }\n      var endPDT = fragments[fragments.length - 1].endProgramDateTime;\n      if (PDTValue >= (endPDT || 0)) {\n        return null;\n      }\n      maxFragLookUpTolerance = maxFragLookUpTolerance || 0;\n      for (var seg = 0; seg < fragments.length; ++seg) {\n        var frag = fragments[seg];\n        if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n          return frag;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n     * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n     * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n     * @param fragPrevious - The last frag successfully appended\n     * @param fragments - The array of candidate fragments\n     * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within\n     * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n     * @returns a matching fragment or null\n     */\n    function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {\n      if (bufferEnd === void 0) {\n        bufferEnd = 0;\n      }\n      if (maxFragLookUpTolerance === void 0) {\n        maxFragLookUpTolerance = 0;\n      }\n      var fragNext = null;\n      if (fragPrevious) {\n        fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;\n      } else if (bufferEnd === 0 && fragments[0].start === 0) {\n        fragNext = fragments[0];\n      }\n      // Prefer the next fragment if it's within tolerance\n      if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {\n        return fragNext;\n      }\n      // We might be seeking past the tolerance so find the best match\n      var foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n      if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n        return foundFragment;\n      }\n      // If no match was found return the next fragment after fragPrevious, or null\n      return fragNext;\n    }\n\n    /**\n     * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n     * @param candidate - The fragment to test\n     * @param bufferEnd - The end of the current buffered range the playhead is currently within\n     * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n     * @returns 0 if it matches, 1 if too low, -1 if too high\n     */\n    function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {\n      if (bufferEnd === void 0) {\n        bufferEnd = 0;\n      }\n      if (maxFragLookUpTolerance === void 0) {\n        maxFragLookUpTolerance = 0;\n      }\n      // eagerly accept an accurate match (no tolerance)\n      if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n        return 0;\n      }\n      // offset should be within fragment boundary - config.maxFragLookUpTolerance\n      // this is to cope with situations like\n      // bufferEnd = 9.991\n      // frag[] : [0,10]\n      // frag[1] : [10,20]\n      // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n      //              frag start               frag start+duration\n      //                  |-----------------------------|\n      //              <--->                         <--->\n      //  ...--------><-----------------------------><---------....\n      // previous frag         matching fragment         next frag\n      //  return -1             return 0                 return 1\n      // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n      // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n      var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n      if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n        return 1;\n      } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n        // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n        return -1;\n      }\n      return 0;\n    }\n\n    /**\n     * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n     * This function tests the candidate's program date time values, as represented in Unix time\n     * @param candidate - The fragment to test\n     * @param pdtBufferEnd - The Unix time representing the end of the current buffered range\n     * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n     * @returns true if contiguous, false otherwise\n     */\n    function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n      var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n\n      // endProgramDateTime can be null, default to zero\n      var endProgramDateTime = candidate.endProgramDateTime || 0;\n      return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n    }\n    function findFragWithCC(fragments, cc) {\n      return BinarySearch.search(fragments, function (candidate) {\n        if (candidate.cc < cc) {\n          return 1;\n        } else if (candidate.cc > cc) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n    }\n    var RENDITION_PENALTY_DURATION_MS = 300000;\n    var NetworkErrorAction = {\n      DoNothing: 0,\n      SendEndCallback: 1,\n      SendAlternateToPenaltyBox: 2,\n      RemoveAlternatePermanently: 3,\n      InsertDiscontinuity: 4,\n      RetryRequest: 5\n    };\n    var ErrorActionFlags = {\n      None: 0,\n      MoveAllAlternatesMatchingHost: 1,\n      MoveAllAlternatesMatchingHDCP: 2,\n      SwitchToSDR: 4\n    }; // Reserved for future use\n    var ErrorController = /*#__PURE__*/function () {\n      function ErrorController(hls) {\n        this.hls = void 0;\n        this.playlistError = 0;\n        this.penalizedRenditions = {};\n        this.log = void 0;\n        this.warn = void 0;\n        this.error = void 0;\n        this.hls = hls;\n        this.log = logger.log.bind(logger, \"[info]:\");\n        this.warn = logger.warn.bind(logger, \"[warning]:\");\n        this.error = logger.error.bind(logger, \"[error]:\");\n        this.registerListeners();\n      }\n      var _proto = ErrorController.prototype;\n      _proto.registerListeners = function registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      };\n      _proto.unregisterListeners = function unregisterListeners() {\n        var hls = this.hls;\n        if (!hls) {\n          return;\n        }\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.ERROR, this.onErrorOut, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      };\n      _proto.destroy = function destroy() {\n        this.unregisterListeners();\n        // @ts-ignore\n        this.hls = null;\n        this.penalizedRenditions = {};\n      };\n      _proto.startLoad = function startLoad(startPosition) {\n        this.playlistError = 0;\n      };\n      _proto.stopLoad = function stopLoad() {};\n      _proto.getVariantLevelIndex = function getVariantLevelIndex(frag) {\n        return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;\n      };\n      _proto.onManifestLoading = function onManifestLoading() {\n        this.playlistError = 0;\n        this.penalizedRenditions = {};\n      };\n      _proto.onLevelUpdated = function onLevelUpdated() {\n        this.playlistError = 0;\n      };\n      _proto.onError = function onError(event, data) {\n        var _data$level;\n        if (data.fatal) {\n          return;\n        }\n        var hls = this.hls;\n        var context = data.context;\n        switch (data.details) {\n          case ErrorDetails.FRAG_LOAD_ERROR:\n          case ErrorDetails.FRAG_LOAD_TIMEOUT:\n          case ErrorDetails.KEY_LOAD_ERROR:\n          case ErrorDetails.KEY_LOAD_TIMEOUT:\n            data.errorAction = this.getFragRetryOrSwitchAction(data);\n            return;\n          case ErrorDetails.FRAG_GAP:\n          case ErrorDetails.FRAG_PARSING_ERROR:\n          case ErrorDetails.FRAG_DECRYPT_ERROR:\n            {\n              // Switch level if possible, otherwise allow retry count to reach max error retries\n              data.errorAction = this.getFragRetryOrSwitchAction(data);\n              data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n              return;\n            }\n          case ErrorDetails.LEVEL_EMPTY_ERROR:\n          case ErrorDetails.LEVEL_PARSING_ERROR:\n            {\n              var _data$context, _data$context$levelDe;\n              // Only retry when empty and live\n              var levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n              if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {\n                data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);\n              } else {\n                // Escalate to fatal if not retrying or switching\n                data.levelRetry = false;\n                data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n              }\n            }\n            return;\n          case ErrorDetails.LEVEL_LOAD_ERROR:\n          case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n            if (typeof (context == null ? void 0 : context.level) === 'number') {\n              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);\n            }\n            return;\n          case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n          case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n          case ErrorDetails.SUBTITLE_LOAD_ERROR:\n          case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:\n            if (context) {\n              var level = hls.levels[hls.loadLevel];\n              if (level && (context.type === PlaylistContextType.AUDIO_TRACK && context.groupId === level.audioGroupId || context.type === PlaylistContextType.SUBTITLE_TRACK && context.groupId === level.textGroupId)) {\n                // Perform Pathway switch or Redundant failover if possible for fastest recovery\n                // otherwise allow playlist retry count to reach max error retries\n                data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);\n                data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n                data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;\n                return;\n              }\n            }\n            return;\n          case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n            {\n              var _level = hls.levels[hls.loadLevel];\n              var restrictedHdcpLevel = _level == null ? void 0 : _level.attrs['HDCP-LEVEL'];\n              if (restrictedHdcpLevel) {\n                data.errorAction = {\n                  action: NetworkErrorAction.SendAlternateToPenaltyBox,\n                  flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,\n                  hdcpLevel: restrictedHdcpLevel\n                };\n              }\n            }\n            return;\n          case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n          case ErrorDetails.REMUX_ALLOC_ERROR:\n            data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);\n            return;\n          case ErrorDetails.INTERNAL_EXCEPTION:\n          case ErrorDetails.BUFFER_APPENDING_ERROR:\n          case ErrorDetails.BUFFER_APPEND_ERROR:\n          case ErrorDetails.BUFFER_FULL_ERROR:\n          case ErrorDetails.LEVEL_SWITCH_ERROR:\n          case ErrorDetails.BUFFER_STALLED_ERROR:\n          case ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n          case ErrorDetails.BUFFER_NUDGE_ON_STALL:\n            data.errorAction = {\n              action: NetworkErrorAction.DoNothing,\n              flags: ErrorActionFlags.None\n            };\n            return;\n        }\n        if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n          var _levelIndex = this.getVariantLevelIndex(data.frag);\n          // Do not retry level. Escalate to fatal if switching levels fails.\n          data.levelRetry = false;\n          data.errorAction = this.getLevelSwitchAction(data, _levelIndex);\n          return;\n        }\n      };\n      _proto.getPlaylistRetryOrSwitchAction = function getPlaylistRetryOrSwitchAction(data, levelIndex) {\n        var _data$response;\n        var hls = this.hls;\n        var retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);\n        var retryCount = this.playlistError++;\n        var httpStatus = (_data$response = data.response) == null ? void 0 : _data$response.code;\n        var retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), httpStatus);\n        if (retry) {\n          return {\n            action: NetworkErrorAction.RetryRequest,\n            flags: ErrorActionFlags.None,\n            retryConfig: retryConfig,\n            retryCount: retryCount\n          };\n        }\n        var errorAction = this.getLevelSwitchAction(data, levelIndex);\n        if (retryConfig) {\n          errorAction.retryConfig = retryConfig;\n          errorAction.retryCount = retryCount;\n        }\n        return errorAction;\n      };\n      _proto.getFragRetryOrSwitchAction = function getFragRetryOrSwitchAction(data) {\n        var hls = this.hls;\n        // Share fragment error count accross media options (main, audio, subs)\n        // This allows for level based rendition switching when media option assets fail\n        var variantLevelIndex = this.getVariantLevelIndex(data.frag);\n        var level = hls.levels[variantLevelIndex];\n        var _hls$config = hls.config,\n          fragLoadPolicy = _hls$config.fragLoadPolicy,\n          keyLoadPolicy = _hls$config.keyLoadPolicy;\n        var retryConfig = getRetryConfig(data.details.startsWith('key') ? keyLoadPolicy : fragLoadPolicy, data);\n        var fragmentErrors = hls.levels.reduce(function (acc, level) {\n          return acc + level.fragmentError;\n        }, 0);\n        // Switch levels when out of retried or level index out of bounds\n        if (level) {\n          var _data$response2;\n          if (data.details !== ErrorDetails.FRAG_GAP) {\n            level.fragmentError++;\n          }\n          var httpStatus = (_data$response2 = data.response) == null ? void 0 : _data$response2.code;\n          var retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), httpStatus);\n          if (retry) {\n            return {\n              action: NetworkErrorAction.RetryRequest,\n              flags: ErrorActionFlags.None,\n              retryConfig: retryConfig,\n              retryCount: fragmentErrors\n            };\n          }\n        }\n        // Reach max retry count, or Missing level reference\n        // Switch to valid index\n        var errorAction = this.getLevelSwitchAction(data, variantLevelIndex);\n        // Add retry details to allow skipping of FRAG_PARSING_ERROR\n        if (retryConfig) {\n          errorAction.retryConfig = retryConfig;\n          errorAction.retryCount = fragmentErrors;\n        }\n        return errorAction;\n      };\n      _proto.getLevelSwitchAction = function getLevelSwitchAction(data, levelIndex) {\n        var hls = this.hls;\n        if (levelIndex === null || levelIndex === undefined) {\n          levelIndex = hls.loadLevel;\n        }\n        var level = this.hls.levels[levelIndex];\n        if (level) {\n          level.loadError++;\n          if (hls.autoLevelEnabled) {\n            var _data$frag, _data$context2;\n            // Search for next level to retry\n            var nextLevel = -1;\n            var levels = hls.levels;\n            var fragErrorType = (_data$frag = data.frag) == null ? void 0 : _data$frag.type;\n            var _ref = (_data$context2 = data.context) != null ? _data$context2 : {},\n              playlistErrorType = _ref.type,\n              playlistErrorGroupId = _ref.groupId;\n            for (var i = levels.length; i--;) {\n              var candidate = (i + hls.loadLevel) % levels.length;\n              if (candidate !== hls.loadLevel && levels[candidate].loadError === 0) {\n                var levelCandidate = levels[candidate];\n                // Skip level switch if GAP tag is found in next level at same position\n                if (data.details === ErrorDetails.FRAG_GAP && data.frag) {\n                  var levelDetails = levels[candidate].details;\n                  if (levelDetails) {\n                    var fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);\n                    if (fragCandidate != null && fragCandidate.gap) {\n                      continue;\n                    }\n                  }\n                } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && playlistErrorGroupId === levelCandidate.audioGroupId || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && playlistErrorGroupId === levelCandidate.textGroupId) {\n                  // For audio/subs playlist errors find another group ID or fallthrough to redundant fail-over\n                  continue;\n                } else if (fragErrorType === PlaylistLevelType.AUDIO && level.audioGroupId === levelCandidate.audioGroupId || fragErrorType === PlaylistLevelType.SUBTITLE && level.textGroupId === levelCandidate.textGroupId) {\n                  // For audio/subs frag errors find another group ID or fallthrough to redundant fail-over\n                  continue;\n                }\n                nextLevel = candidate;\n                break;\n              }\n            }\n            if (nextLevel > -1 && hls.loadLevel !== nextLevel) {\n              data.levelRetry = true;\n              this.playlistError = 0;\n              return {\n                action: NetworkErrorAction.SendAlternateToPenaltyBox,\n                flags: ErrorActionFlags.None,\n                nextAutoLevel: nextLevel\n              };\n            }\n          }\n        }\n        // No levels to switch / Manual level selection / Level not found\n        // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level\n        return {\n          action: NetworkErrorAction.SendAlternateToPenaltyBox,\n          flags: ErrorActionFlags.MoveAllAlternatesMatchingHost\n        };\n      };\n      _proto.onErrorOut = function onErrorOut(event, data) {\n        var _data$errorAction;\n        switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {\n          case NetworkErrorAction.DoNothing:\n            break;\n          case NetworkErrorAction.SendAlternateToPenaltyBox:\n            this.sendAlternateToPenaltyBox(data);\n            if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {\n              data.fatal = true;\n            }\n            break;\n        }\n        if (data.fatal) {\n          this.hls.stopLoad();\n          return;\n        }\n      };\n      _proto.sendAlternateToPenaltyBox = function sendAlternateToPenaltyBox(data) {\n        var hls = this.hls;\n        var errorAction = data.errorAction;\n        if (!errorAction) {\n          return;\n        }\n        var flags = errorAction.flags,\n          hdcpLevel = errorAction.hdcpLevel,\n          nextAutoLevel = errorAction.nextAutoLevel;\n        switch (flags) {\n          case ErrorActionFlags.None:\n            this.switchLevel(data, nextAutoLevel);\n            break;\n          case ErrorActionFlags.MoveAllAlternatesMatchingHost:\n            {\n              // Handle Redundant Levels here. Pathway switching is handled by content-steering-controller\n              if (!errorAction.resolved) {\n                errorAction.resolved = this.redundantFailover(data);\n              }\n            }\n            break;\n          case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:\n            if (hdcpLevel) {\n              hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];\n              errorAction.resolved = true;\n            }\n            this.warn(\"Restricting playback to HDCP-LEVEL of \\\"\" + hls.maxHdcpLevel + \"\\\" or lower\");\n            break;\n        }\n        // If not resolved by previous actions try to switch to next level\n        if (!errorAction.resolved) {\n          this.switchLevel(data, nextAutoLevel);\n        }\n      };\n      _proto.switchLevel = function switchLevel(data, levelIndex) {\n        if (levelIndex !== undefined && data.errorAction) {\n          this.warn(\"switching to level \" + levelIndex + \" after \" + data.details);\n          this.hls.nextAutoLevel = levelIndex;\n          data.errorAction.resolved = true;\n          // Stream controller is responsible for this but won't switch on false start\n          this.hls.nextLoadLevel = this.hls.nextAutoLevel;\n        }\n      };\n      _proto.redundantFailover = function redundantFailover(data) {\n        var _this = this;\n        var hls = this.hls,\n          penalizedRenditions = this.penalizedRenditions;\n        var levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n        var level = hls.levels[levelIndex];\n        var redundantLevels = level.url.length;\n        var errorUrlId = data.frag ? data.frag.urlId : level.urlId;\n        if (level.urlId === errorUrlId && (!data.frag || level.details)) {\n          this.penalizeRendition(level, data);\n        }\n        var _loop = function _loop() {\n          var newUrlId = (errorUrlId + i) % redundantLevels;\n          var penalizedRendition = penalizedRenditions[newUrlId];\n          // Check if rendition is penalized and skip if it is a bad fit for failover\n          if (!penalizedRendition || checkExpired(penalizedRendition, data, penalizedRenditions[errorUrlId])) {\n            // delete penalizedRenditions[newUrlId];\n            // Update the url id of all levels so that we stay on the same set of variants when level switching\n            _this.warn(\"Switching to Redundant Stream \" + (newUrlId + 1) + \"/\" + redundantLevels + \": \\\"\" + level.url[newUrlId] + \"\\\" after \" + data.details);\n            _this.playlistError = 0;\n            hls.levels.forEach(function (lv) {\n              lv.urlId = newUrlId;\n            });\n            hls.nextLoadLevel = levelIndex;\n            return {\n              v: true\n            };\n          }\n        };\n        for (var i = 1; i < redundantLevels; i++) {\n          var _ret = _loop();\n          if (typeof _ret === \"object\") return _ret.v;\n        }\n        return false;\n      };\n      _proto.penalizeRendition = function penalizeRendition(level, data) {\n        var penalizedRenditions = this.penalizedRenditions;\n        var penalizedRendition = penalizedRenditions[level.urlId] || {\n          lastErrorPerfMs: 0,\n          errors: [],\n          details: undefined\n        };\n        penalizedRendition.lastErrorPerfMs = performance.now();\n        penalizedRendition.errors.push(data);\n        penalizedRendition.details = level.details;\n        penalizedRenditions[level.urlId] = penalizedRendition;\n      };\n      return ErrorController;\n    }();\n    function checkExpired(penalizedRendition, data, currentPenaltyState) {\n      // Expire penalty for switching back to rendition after RENDITION_PENALTY_DURATION_MS\n      if (performance.now() - penalizedRendition.lastErrorPerfMs > RENDITION_PENALTY_DURATION_MS) {\n        return true;\n      }\n      // Expire penalty on GAP tag error if rendition has no GAP at position (does not cover media tracks)\n      var lastErrorDetails = penalizedRendition.details;\n      if (data.details === ErrorDetails.FRAG_GAP && lastErrorDetails && data.frag) {\n        var position = data.frag.start;\n        var candidateFrag = findFragmentByPTS(null, lastErrorDetails.fragments, position);\n        if (candidateFrag && !candidateFrag.gap) {\n          return true;\n        }\n      }\n      // Expire penalty if there are more errors in currentLevel than in penalizedRendition\n      if (currentPenaltyState && penalizedRendition.errors.length < currentPenaltyState.errors.length) {\n        var lastCandidateError = penalizedRendition.errors[penalizedRendition.errors.length - 1];\n        if (lastErrorDetails && lastCandidateError.frag && data.frag && Math.abs(lastCandidateError.frag.start - data.frag.start) > lastErrorDetails.targetduration * 3) {\n          return true;\n        }\n      }\n      return false;\n    }\n    var BasePlaylistController = /*#__PURE__*/function () {\n      function BasePlaylistController(hls, logPrefix) {\n        this.hls = void 0;\n        this.timer = -1;\n        this.requestScheduled = -1;\n        this.canLoad = false;\n        this.log = void 0;\n        this.warn = void 0;\n        this.log = logger.log.bind(logger, logPrefix + \":\");\n        this.warn = logger.warn.bind(logger, logPrefix + \":\");\n        this.hls = hls;\n      }\n      var _proto = BasePlaylistController.prototype;\n      _proto.destroy = function destroy() {\n        this.clearTimer();\n        // @ts-ignore\n        this.hls = this.log = this.warn = null;\n      };\n      _proto.clearTimer = function clearTimer() {\n        clearTimeout(this.timer);\n        this.timer = -1;\n      };\n      _proto.startLoad = function startLoad() {\n        this.canLoad = true;\n        this.requestScheduled = -1;\n        this.loadPlaylist();\n      };\n      _proto.stopLoad = function stopLoad() {\n        this.canLoad = false;\n        this.clearTimer();\n      };\n      _proto.switchParams = function switchParams(playlistUri, previous) {\n        var renditionReports = previous == null ? void 0 : previous.renditionReports;\n        if (renditionReports) {\n          var foundIndex = -1;\n          for (var i = 0; i < renditionReports.length; i++) {\n            var attr = renditionReports[i];\n            var uri = void 0;\n            try {\n              uri = new self.URL(attr.URI, previous.url).href;\n            } catch (error) {\n              logger.warn(\"Could not construct new URL for Rendition Report: \" + error);\n              uri = attr.URI || '';\n            }\n            // Use exact match. Otherwise, the last partial match, if any, will be used\n            // (Playlist URI includes a query string that the Rendition Report does not)\n            if (uri === playlistUri) {\n              foundIndex = i;\n              break;\n            } else if (uri === playlistUri.substring(0, uri.length)) {\n              foundIndex = i;\n            }\n          }\n          if (foundIndex !== -1) {\n            var _attr = renditionReports[foundIndex];\n            var msn = parseInt(_attr['LAST-MSN']) || (previous == null ? void 0 : previous.lastPartSn);\n            var part = parseInt(_attr['LAST-PART']) || (previous == null ? void 0 : previous.lastPartIndex);\n            if (this.hls.config.lowLatencyMode) {\n              var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n              if (part >= 0 && currentGoal > previous.partTarget) {\n                part += 1;\n              }\n            }\n            return new HlsUrlParameters(msn, part >= 0 ? part : undefined, HlsSkip.No);\n          }\n        }\n      };\n      _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n        if (this.requestScheduled === -1) {\n          this.requestScheduled = self.performance.now();\n        }\n        // Loading is handled by the subclasses\n      };\n\n      _proto.shouldLoadPlaylist = function shouldLoadPlaylist(playlist) {\n        return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);\n      };\n      _proto.shouldReloadPlaylist = function shouldReloadPlaylist(playlist) {\n        return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);\n      };\n      _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {\n        var _this = this;\n        var details = data.details,\n          stats = data.stats;\n\n        // Set last updated date-time\n        var now = self.performance.now();\n        var elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n        details.advancedDateTime = Date.now() - elapsed;\n\n        // if current playlist is a live playlist, arm a timer to reload it\n        if (details.live || previousDetails != null && previousDetails.live) {\n          details.reloaded(previousDetails);\n          if (previousDetails) {\n            this.log(\"live playlist \" + index + \" \" + (details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : 'MISSED'));\n          }\n          // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n          if (previousDetails && details.fragments.length > 0) {\n            mergeDetails(previousDetails, details);\n          }\n          if (!this.canLoad || !details.live) {\n            return;\n          }\n          var deliveryDirectives;\n          var msn = undefined;\n          var part = undefined;\n          if (details.canBlockReload && details.endSN && details.advanced) {\n            // Load level with LL-HLS delivery directives\n            var lowLatencyMode = this.hls.config.lowLatencyMode;\n            var lastPartSn = details.lastPartSn;\n            var endSn = details.endSN;\n            var lastPartIndex = details.lastPartIndex;\n            var hasParts = lastPartIndex !== -1;\n            var lastPart = lastPartSn === endSn;\n            // When low latency mode is disabled, we'll skip part requests once the last part index is found\n            var nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;\n            if (hasParts) {\n              msn = lastPart ? endSn + 1 : lastPartSn;\n              part = lastPart ? nextSnStartIndex : lastPartIndex + 1;\n            } else {\n              msn = endSn + 1;\n            }\n            // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n            // Update directives to obtain the Playlist that has the estimated additional duration of media\n            var lastAdvanced = details.age;\n            var cdnAge = lastAdvanced + details.ageHeader;\n            var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n            if (currentGoal > 0) {\n              if (previousDetails && currentGoal > previousDetails.tuneInGoal) {\n                // If we attempted to get the next or latest playlist update, but currentGoal increased,\n                // then we either can't catchup, or the \"age\" header cannot be trusted.\n                this.warn(\"CDN Tune-in goal increased from: \" + previousDetails.tuneInGoal + \" to: \" + currentGoal + \" with playlist age: \" + details.age);\n                currentGoal = 0;\n              } else {\n                var segments = Math.floor(currentGoal / details.targetduration);\n                msn += segments;\n                if (part !== undefined) {\n                  var parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n                  part += parts;\n                }\n                this.log(\"CDN Tune-in age: \" + details.ageHeader + \"s last advanced \" + lastAdvanced.toFixed(2) + \"s goal: \" + currentGoal + \" skip sn \" + segments + \" to part \" + part);\n              }\n              details.tuneInGoal = currentGoal;\n            }\n            deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n            if (lowLatencyMode || !lastPart) {\n              this.loadPlaylist(deliveryDirectives);\n              return;\n            }\n          } else if (details.canBlockReload) {\n            deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n          }\n          var bufferInfo = this.hls.mainForwardBufferInfo;\n          var position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n          var distanceToLiveEdgeMs = (details.edge - position) * 1000;\n          var reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);\n          if (details.updated && now > this.requestScheduled + reloadInterval) {\n            this.requestScheduled = stats.loading.start;\n          }\n          if (msn !== undefined && details.canBlockReload) {\n            this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);\n          } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now) {\n            this.requestScheduled = now;\n          } else if (this.requestScheduled - now <= 0) {\n            this.requestScheduled += reloadInterval;\n          }\n          var estimatedTimeUntilUpdate = this.requestScheduled - now;\n          estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);\n          this.log(\"reload live playlist \" + index + \" in \" + Math.round(estimatedTimeUntilUpdate) + \" ms\");\n          // this.log(\n          //   `live reload ${details.updated ? 'REFRESHED' : 'MISSED'}\n          // reload in ${estimatedTimeUntilUpdate / 1000}\n          // round trip ${(stats.loading.end - stats.loading.start) / 1000}\n          // diff ${\n          //   (reloadInterval -\n          //     (estimatedTimeUntilUpdate +\n          //       stats.loading.end -\n          //       stats.loading.start)) /\n          //   1000\n          // }\n          // reload interval ${reloadInterval / 1000}\n          // target duration ${details.targetduration}\n          // distance to edge ${distanceToLiveEdgeMs / 1000}`\n          // );\n\n          this.timer = self.setTimeout(function () {\n            return _this.loadPlaylist(deliveryDirectives);\n          }, estimatedTimeUntilUpdate);\n        } else {\n          this.clearTimer();\n        }\n      };\n      _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n        var skip = getSkipValue(details, msn);\n        if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n          msn = previousDeliveryDirectives.msn;\n          part = previousDeliveryDirectives.part;\n          skip = HlsSkip.No;\n        }\n        return new HlsUrlParameters(msn, part, skip);\n      };\n      _proto.checkRetry = function checkRetry(errorEvent) {\n        var _this2 = this;\n        var errorDetails = errorEvent.details;\n        var isTimeout = isTimeoutError(errorEvent);\n        var errorAction = errorEvent.errorAction;\n        var _ref = errorAction || {},\n          action = _ref.action,\n          _ref$retryCount = _ref.retryCount,\n          retryCount = _ref$retryCount === void 0 ? 0 : _ref$retryCount,\n          retryConfig = _ref.retryConfig;\n        var retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);\n        if (retry) {\n          var _errorEvent$context;\n          this.requestScheduled = -1;\n          if (retryCount >= retryConfig.maxNumRetry) {\n            return false;\n          }\n          if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {\n            // The LL-HLS request already timed out so retry immediately\n            this.warn(\"Retrying playlist loading \" + (retryCount + 1) + \"/\" + retryConfig.maxNumRetry + \" after \\\"\" + errorDetails + \"\\\" without delivery-directives\");\n            this.loadPlaylist();\n          } else {\n            var delay = getRetryDelay(retryConfig, retryCount);\n            // Schedule level/track reload\n            this.timer = self.setTimeout(function () {\n              return _this2.loadPlaylist();\n            }, delay);\n            this.warn(\"Retrying playlist loading \" + (retryCount + 1) + \"/\" + retryConfig.maxNumRetry + \" after \\\"\" + errorDetails + \"\\\" in \" + delay + \"ms\");\n          }\n          // `levelRetry = true` used to inform other controllers that a retry is happening\n          errorEvent.levelRetry = true;\n          errorAction.resolved = true;\n        }\n        return retry;\n      };\n      return BasePlaylistController;\n    }();\n    var chromeOrFirefox;\n    var LevelController = /*#__PURE__*/function (_BasePlaylistControll) {\n      _inheritsLoose(LevelController, _BasePlaylistControll);\n      function LevelController(hls, contentSteeringController) {\n        var _this;\n        _this = _BasePlaylistControll.call(this, hls, '[level-controller]') || this;\n        _this._levels = [];\n        _this._firstLevel = -1;\n        _this._startLevel = void 0;\n        _this.currentLevel = null;\n        _this.currentLevelIndex = -1;\n        _this.manualLevelIndex = -1;\n        _this.steering = void 0;\n        _this.onParsedComplete = void 0;\n        _this.steering = contentSteeringController;\n        _this._registerListeners();\n        return _this;\n      }\n      var _proto = LevelController.prototype;\n      _proto._registerListeners = function _registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.on(Events.ERROR, this.onError, this);\n      };\n      _proto._unregisterListeners = function _unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.off(Events.ERROR, this.onError, this);\n      };\n      _proto.destroy = function destroy() {\n        this._unregisterListeners();\n        this.steering = null;\n        this.resetLevels();\n        _BasePlaylistControll.prototype.destroy.call(this);\n      };\n      _proto.startLoad = function startLoad() {\n        var levels = this._levels;\n\n        // clean up live level details to force reload them, and reset load errors\n        levels.forEach(function (level) {\n          level.loadError = 0;\n          level.fragmentError = 0;\n        });\n        _BasePlaylistControll.prototype.startLoad.call(this);\n      };\n      _proto.resetLevels = function resetLevels() {\n        this._startLevel = undefined;\n        this.manualLevelIndex = -1;\n        this.currentLevelIndex = -1;\n        this.currentLevel = null;\n        this._levels = [];\n      };\n      _proto.onManifestLoading = function onManifestLoading(event, data) {\n        this.resetLevels();\n      };\n      _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n        var levels = [];\n        var levelSet = {};\n        var levelFromSet;\n\n        // regroup redundant levels together\n        data.levels.forEach(function (levelParsed) {\n          var _levelParsed$audioCod;\n          var attributes = levelParsed.attrs;\n\n          // erase audio codec info if browser does not support mp4a.40.34.\n          // demuxer will autodetect codec and fallback to mpeg/audio\n          if (((_levelParsed$audioCod = levelParsed.audioCodec) == null ? void 0 : _levelParsed$audioCod.indexOf('mp4a.40.34')) !== -1) {\n            chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));\n            if (chromeOrFirefox) {\n              levelParsed.audioCodec = undefined;\n            }\n          }\n          var AUDIO = attributes.AUDIO,\n            CODECS = attributes.CODECS,\n            FRAMERATE = attributes['FRAME-RATE'];\n          attributes['PATHWAY-ID'];\n          var RESOLUTION = attributes.RESOLUTION,\n            SUBTITLES = attributes.SUBTITLES;\n          var contentSteeringPrefix = '';\n          var levelKey = \"\" + contentSteeringPrefix + levelParsed.bitrate + \"-\" + RESOLUTION + \"-\" + FRAMERATE + \"-\" + CODECS;\n          levelFromSet = levelSet[levelKey];\n          if (!levelFromSet) {\n            levelFromSet = new Level(levelParsed);\n            levelSet[levelKey] = levelFromSet;\n            levels.push(levelFromSet);\n          } else {\n            levelFromSet.addFallback(levelParsed);\n          }\n          addGroupId(levelFromSet, 'audio', AUDIO);\n          addGroupId(levelFromSet, 'text', SUBTITLES);\n        });\n        this.filterAndSortMediaOptions(levels, data);\n      };\n      _proto.filterAndSortMediaOptions = function filterAndSortMediaOptions(unfilteredLevels, data) {\n        var _this2 = this;\n        var audioTracks = [];\n        var subtitleTracks = [];\n        var resolutionFound = false;\n        var videoCodecFound = false;\n        var audioCodecFound = false;\n\n        // only keep levels with supported audio/video codecs\n        var levels = unfilteredLevels.filter(function (_ref) {\n          var audioCodec = _ref.audioCodec,\n            videoCodec = _ref.videoCodec,\n            width = _ref.width,\n            height = _ref.height,\n            unknownCodecs = _ref.unknownCodecs;\n          resolutionFound || (resolutionFound = !!(width && height));\n          videoCodecFound || (videoCodecFound = !!videoCodec);\n          audioCodecFound || (audioCodecFound = !!audioCodec);\n          return !(unknownCodecs != null && unknownCodecs.length) && (!audioCodec || isCodecSupportedInMp4(audioCodec, 'audio')) && (!videoCodec || isCodecSupportedInMp4(videoCodec, 'video'));\n        });\n\n        // remove audio-only level if we also have levels with video codecs or RESOLUTION signalled\n        if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n          levels = levels.filter(function (_ref2) {\n            var videoCodec = _ref2.videoCodec,\n              width = _ref2.width,\n              height = _ref2.height;\n            return !!videoCodec || !!(width && height);\n          });\n        }\n        if (levels.length === 0) {\n          // Dispatch error after MANIFEST_LOADED is done propagating\n          Promise.resolve().then(function () {\n            if (_this2.hls) {\n              var error = new Error('no level with compatible codecs found in manifest');\n              _this2.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n                fatal: true,\n                url: data.url,\n                error: error,\n                reason: error.message\n              });\n            }\n          });\n          return;\n        }\n        if (data.audioTracks) {\n          audioTracks = data.audioTracks.filter(function (track) {\n            return !track.audioCodec || isCodecSupportedInMp4(track.audioCodec, 'audio');\n          });\n          // Assign ids after filtering as array indices by group-id\n          assignTrackIdsByGroup(audioTracks);\n        }\n        if (data.subtitles) {\n          subtitleTracks = data.subtitles;\n          assignTrackIdsByGroup(subtitleTracks);\n        }\n        // start bitrate is the first bitrate of the manifest\n        var unsortedLevels = levels.slice(0);\n        // sort levels from lowest to highest\n        levels.sort(function (a, b) {\n          if (a.attrs['HDCP-LEVEL'] !== b.attrs['HDCP-LEVEL']) {\n            return (a.attrs['HDCP-LEVEL'] || '') > (b.attrs['HDCP-LEVEL'] || '') ? 1 : -1;\n          }\n          if (a.bitrate !== b.bitrate) {\n            return a.bitrate - b.bitrate;\n          }\n          if (a.attrs['FRAME-RATE'] !== b.attrs['FRAME-RATE']) {\n            return a.attrs.decimalFloatingPoint('FRAME-RATE') - b.attrs.decimalFloatingPoint('FRAME-RATE');\n          }\n          if (a.attrs.SCORE !== b.attrs.SCORE) {\n            return a.attrs.decimalFloatingPoint('SCORE') - b.attrs.decimalFloatingPoint('SCORE');\n          }\n          if (resolutionFound && a.height !== b.height) {\n            return a.height - b.height;\n          }\n          return 0;\n        });\n        var firstLevelInPlaylist = unsortedLevels[0];\n        if (this.steering) {\n          levels = this.steering.filterParsedLevels(levels);\n          if (levels.length !== unsortedLevels.length) {\n            for (var i = 0; i < unsortedLevels.length; i++) {\n              if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {\n                firstLevelInPlaylist = unsortedLevels[i];\n                break;\n              }\n            }\n          }\n        }\n        this._levels = levels;\n\n        // find index of first level in sorted levels\n        for (var _i = 0; _i < levels.length; _i++) {\n          if (levels[_i] === firstLevelInPlaylist) {\n            this._firstLevel = _i;\n            this.log(\"manifest loaded, \" + levels.length + \" level(s) found, first bitrate: \" + firstLevelInPlaylist.bitrate);\n            break;\n          }\n        }\n\n        // Audio is only alternate if manifest include a URI along with the audio group tag,\n        // and this is not an audio-only stream where levels contain audio-only\n        var audioOnly = audioCodecFound && !videoCodecFound;\n        var edata = {\n          levels: levels,\n          audioTracks: audioTracks,\n          subtitleTracks: subtitleTracks,\n          sessionData: data.sessionData,\n          sessionKeys: data.sessionKeys,\n          firstLevel: this._firstLevel,\n          stats: data.stats,\n          audio: audioCodecFound,\n          video: videoCodecFound,\n          altAudio: !audioOnly && audioTracks.some(function (t) {\n            return !!t.url;\n          })\n        };\n        this.hls.trigger(Events.MANIFEST_PARSED, edata);\n\n        // Initiate loading after all controllers have received MANIFEST_PARSED\n        if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {\n          this.hls.startLoad(this.hls.config.startPosition);\n        }\n      };\n      _proto.onError = function onError(event, data) {\n        if (data.fatal || !data.context) {\n          return;\n        }\n        if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {\n          this.checkRetry(data);\n        }\n      }\n\n      // reset errors on the successful load of a fragment\n      ;\n\n      _proto.onFragLoaded = function onFragLoaded(event, _ref3) {\n        var frag = _ref3.frag;\n        if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {\n          var level = this._levels[frag.level];\n          if (level !== undefined) {\n            level.loadError = 0;\n          }\n        }\n      };\n      _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n        var _data$deliveryDirecti2;\n        var level = data.level,\n          details = data.details;\n        var curLevel = this._levels[level];\n        if (!curLevel) {\n          var _data$deliveryDirecti;\n          this.warn(\"Invalid level index \" + level);\n          if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {\n            details.deltaUpdateFailed = true;\n          }\n          return;\n        }\n\n        // only process level loaded events matching with expected level\n        if (level === this.currentLevelIndex) {\n          // reset level load error counter on successful level loaded only if there is no issues with fragments\n          if (curLevel.fragmentError === 0) {\n            curLevel.loadError = 0;\n          }\n          this.playlistLoaded(level, data, curLevel.details);\n        } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {\n          // received a delta playlist update that cannot be merged\n          details.deltaUpdateFailed = true;\n        }\n      };\n      _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {\n        var currentLevel = this.currentLevel;\n        if (!currentLevel) {\n          return;\n        }\n        var audioGroupId = this.hls.audioTracks[data.id].groupId;\n        if (currentLevel.audioGroupIds && currentLevel.audioGroupId !== audioGroupId) {\n          var urlId = -1;\n          for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {\n            if (currentLevel.audioGroupIds[i] === audioGroupId) {\n              urlId = i;\n              break;\n            }\n          }\n          if (urlId !== -1 && urlId !== currentLevel.urlId) {\n            currentLevel.urlId = urlId;\n            if (this.canLoad) {\n              this.startLoad();\n            }\n          }\n        }\n      };\n      _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n        _BasePlaylistControll.prototype.loadPlaylist.call(this);\n        var currentLevelIndex = this.currentLevelIndex;\n        var currentLevel = this.currentLevel;\n        if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {\n          var id = currentLevel.urlId;\n          var url = currentLevel.uri;\n          if (hlsUrlParameters) {\n            try {\n              url = hlsUrlParameters.addDirectives(url);\n            } catch (error) {\n              this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n            }\n          }\n          var pathwayId = currentLevel.attrs['PATHWAY-ID'];\n          this.log(\"Loading level index \" + currentLevelIndex + ((hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : '') + \" with\" + (pathwayId ? ' Pathway ' + pathwayId : '') + \" URI \" + (id + 1) + \"/\" + currentLevel.url.length + \" \" + url);\n\n          // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);\n          // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);\n          this.clearTimer();\n          this.hls.trigger(Events.LEVEL_LOADING, {\n            url: url,\n            level: currentLevelIndex,\n            id: id,\n            deliveryDirectives: hlsUrlParameters || null\n          });\n        }\n      };\n      _proto.removeLevel = function removeLevel(levelIndex, urlId) {\n        var _this3 = this;\n        var filterLevelAndGroupByIdIndex = function filterLevelAndGroupByIdIndex(url, id) {\n          return id !== urlId;\n        };\n        var levels = this._levels.filter(function (level, index) {\n          if (index !== levelIndex) {\n            return true;\n          }\n          if (level.url.length > 1 && urlId !== undefined) {\n            level.url = level.url.filter(filterLevelAndGroupByIdIndex);\n            if (level.audioGroupIds) {\n              level.audioGroupIds = level.audioGroupIds.filter(filterLevelAndGroupByIdIndex);\n            }\n            if (level.textGroupIds) {\n              level.textGroupIds = level.textGroupIds.filter(filterLevelAndGroupByIdIndex);\n            }\n            level.urlId = 0;\n            return true;\n          }\n          if (_this3.steering) {\n            _this3.steering.removeLevel(level);\n          }\n          return false;\n        });\n        this.hls.trigger(Events.LEVELS_UPDATED, {\n          levels: levels\n        });\n      };\n      _proto.onLevelsUpdated = function onLevelsUpdated(event, _ref4) {\n        var levels = _ref4.levels;\n        levels.forEach(function (level, index) {\n          var details = level.details;\n          if (details != null && details.fragments) {\n            details.fragments.forEach(function (fragment) {\n              fragment.level = index;\n            });\n          }\n        });\n        this._levels = levels;\n      };\n      _createClass(LevelController, [{\n        key: \"levels\",\n        get: function get() {\n          if (this._levels.length === 0) {\n            return null;\n          }\n          return this._levels;\n        }\n      }, {\n        key: \"level\",\n        get: function get() {\n          return this.currentLevelIndex;\n        },\n        set: function set(newLevel) {\n          var levels = this._levels;\n          if (levels.length === 0) {\n            return;\n          }\n          // check if level idx is valid\n          if (newLevel < 0 || newLevel >= levels.length) {\n            // invalid level id given, trigger error\n            var error = new Error('invalid level idx');\n            var fatal = newLevel < 0;\n            this.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.OTHER_ERROR,\n              details: ErrorDetails.LEVEL_SWITCH_ERROR,\n              level: newLevel,\n              fatal: fatal,\n              error: error,\n              reason: error.message\n            });\n            if (fatal) {\n              return;\n            }\n            newLevel = Math.min(newLevel, levels.length - 1);\n          }\n          var lastLevelIndex = this.currentLevelIndex;\n          var lastLevel = this.currentLevel;\n          var lastPathwayId = lastLevel ? lastLevel.attrs['PATHWAY-ID'] : undefined;\n          var level = levels[newLevel];\n          var pathwayId = level.attrs['PATHWAY-ID'];\n          this.currentLevelIndex = newLevel;\n          this.currentLevel = level;\n          if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {\n            return;\n          }\n          this.log(\"Switching to level \" + newLevel + (pathwayId ? ' with Pathway ' + pathwayId : '') + \" from level \" + lastLevelIndex + (lastPathwayId ? ' with Pathway ' + lastPathwayId : ''));\n          var levelSwitchingData = _extends({}, level, {\n            level: newLevel,\n            maxBitrate: level.maxBitrate,\n            attrs: level.attrs,\n            uri: level.uri,\n            urlId: level.urlId\n          });\n          // @ts-ignore\n          delete levelSwitchingData._attrs;\n          // @ts-ignore\n          delete levelSwitchingData._urlId;\n          this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);\n          // check if we need to load playlist for this level\n          var levelDetails = level.details;\n          if (!levelDetails || levelDetails.live) {\n            // level not retrieved yet, or live playlist we need to (re)load it\n            var hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details);\n            this.loadPlaylist(hlsUrlParameters);\n          }\n        }\n      }, {\n        key: \"manualLevel\",\n        get: function get() {\n          return this.manualLevelIndex;\n        },\n        set: function set(newLevel) {\n          this.manualLevelIndex = newLevel;\n          if (this._startLevel === undefined) {\n            this._startLevel = newLevel;\n          }\n          if (newLevel !== -1) {\n            this.level = newLevel;\n          }\n        }\n      }, {\n        key: \"firstLevel\",\n        get: function get() {\n          return this._firstLevel;\n        },\n        set: function set(newLevel) {\n          this._firstLevel = newLevel;\n        }\n      }, {\n        key: \"startLevel\",\n        get: function get() {\n          // hls.startLevel takes precedence over config.startLevel\n          // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)\n          if (this._startLevel === undefined) {\n            var configStartLevel = this.hls.config.startLevel;\n            if (configStartLevel !== undefined) {\n              return configStartLevel;\n            } else {\n              return this._firstLevel;\n            }\n          } else {\n            return this._startLevel;\n          }\n        },\n        set: function set(newLevel) {\n          this._startLevel = newLevel;\n        }\n      }, {\n        key: \"nextLoadLevel\",\n        get: function get() {\n          if (this.manualLevelIndex !== -1) {\n            return this.manualLevelIndex;\n          } else {\n            return this.hls.nextAutoLevel;\n          }\n        },\n        set: function set(nextLevel) {\n          this.level = nextLevel;\n          if (this.manualLevelIndex === -1) {\n            this.hls.nextAutoLevel = nextLevel;\n          }\n        }\n      }]);\n      return LevelController;\n    }(BasePlaylistController);\n    function addGroupId(level, type, id) {\n      if (!id) {\n        return;\n      }\n      if (type === 'audio') {\n        if (!level.audioGroupIds) {\n          level.audioGroupIds = [];\n        }\n        level.audioGroupIds[level.url.length - 1] = id;\n      } else if (type === 'text') {\n        if (!level.textGroupIds) {\n          level.textGroupIds = [];\n        }\n        level.textGroupIds[level.url.length - 1] = id;\n      }\n    }\n    function assignTrackIdsByGroup(tracks) {\n      var groups = {};\n      tracks.forEach(function (track) {\n        var groupId = track.groupId || '';\n        track.id = groups[groupId] = groups[groupId] || 0;\n        groups[groupId]++;\n      });\n    }\n    var FragmentState = {\n      NOT_LOADED: \"NOT_LOADED\",\n      APPENDING: \"APPENDING\",\n      PARTIAL: \"PARTIAL\",\n      OK: \"OK\"\n    };\n    var FragmentTracker = /*#__PURE__*/function () {\n      function FragmentTracker(hls) {\n        this.activePartLists = Object.create(null);\n        this.endListFragments = Object.create(null);\n        this.fragments = Object.create(null);\n        this.timeRanges = Object.create(null);\n        this.bufferPadding = 0.2;\n        this.hls = void 0;\n        this.hasGaps = false;\n        this.hls = hls;\n        this._registerListeners();\n      }\n      var _proto = FragmentTracker.prototype;\n      _proto._registerListeners = function _registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n      };\n      _proto._unregisterListeners = function _unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n      };\n      _proto.destroy = function destroy() {\n        this._unregisterListeners();\n        // @ts-ignore\n        this.fragments =\n        // @ts-ignore\n        this.activePartLists =\n        // @ts-ignore\n        this.endListFragments = this.timeRanges = null;\n      }\n\n      /**\n       * Return a Fragment or Part with an appended range that matches the position and levelType\n       * Otherwise, return null\n       */;\n      _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {\n        var activeParts = this.activePartLists[levelType];\n        if (activeParts) {\n          for (var i = activeParts.length; i--;) {\n            var activePart = activeParts[i];\n            if (!activePart) {\n              break;\n            }\n            var appendedPTS = activePart.end;\n            if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {\n              return activePart;\n            }\n          }\n        }\n        return this.getBufferedFrag(position, levelType);\n      }\n\n      /**\n       * Return a buffered Fragment that matches the position and levelType.\n       * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n       * If not found any Fragment, return null\n       */;\n      _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {\n        var fragments = this.fragments;\n        var keys = Object.keys(fragments);\n        for (var i = keys.length; i--;) {\n          var fragmentEntity = fragments[keys[i]];\n          if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {\n            var frag = fragmentEntity.body;\n            if (frag.start <= position && position <= frag.end) {\n              return frag;\n            }\n          }\n        }\n        return null;\n      }\n\n      /**\n       * Partial fragments effected by coded frame eviction will be removed\n       * The browser will unload parts of the buffer to free up memory for new buffer data\n       * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n       */;\n      _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {\n        var _this = this;\n        if (this.timeRanges) {\n          this.timeRanges[elementaryStream] = timeRange;\n        }\n        // Check if any flagged fragments have been unloaded\n        // excluding anything newer than appendedPartSn\n        var appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;\n        Object.keys(this.fragments).forEach(function (key) {\n          var fragmentEntity = _this.fragments[key];\n          if (!fragmentEntity) {\n            return;\n          }\n          if (appendedPartSn >= fragmentEntity.body.sn) {\n            return;\n          }\n          if (!fragmentEntity.buffered && !fragmentEntity.loaded) {\n            if (fragmentEntity.body.type === playlistType) {\n              _this.removeFragment(fragmentEntity.body);\n            }\n            return;\n          }\n          var esData = fragmentEntity.range[elementaryStream];\n          if (!esData) {\n            return;\n          }\n          esData.time.some(function (time) {\n            var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n            if (isNotBuffered) {\n              // Unregister partial fragment as it needs to load again to be reused\n              _this.removeFragment(fragmentEntity.body);\n            }\n            return isNotBuffered;\n          });\n        });\n      }\n\n      /**\n       * Checks if the fragment passed in is loaded in the buffer properly\n       * Partially loaded fragments will be registered as a partial fragment\n       */;\n      _proto.detectPartialFragments = function detectPartialFragments(data) {\n        var _this2 = this;\n        var timeRanges = this.timeRanges;\n        var frag = data.frag,\n          part = data.part;\n        if (!timeRanges || frag.sn === 'initSegment') {\n          return;\n        }\n        var fragKey = getFragmentKey(frag);\n        var fragmentEntity = this.fragments[fragKey];\n        if (!fragmentEntity) {\n          return;\n        }\n        var isFragHint = !frag.relurl;\n        Object.keys(timeRanges).forEach(function (elementaryStream) {\n          var streamInfo = frag.elementaryStreams[elementaryStream];\n          if (!streamInfo) {\n            return;\n          }\n          var timeRange = timeRanges[elementaryStream];\n          var partial = isFragHint || streamInfo.partial === true;\n          fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, part, partial, timeRange);\n        });\n        fragmentEntity.loaded = null;\n        if (Object.keys(fragmentEntity.range).length) {\n          fragmentEntity.buffered = true;\n          if (fragmentEntity.body.endList) {\n            this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n          }\n          if (!isPartial(fragmentEntity)) {\n            // Remove older fragment parts from lookup after frag is tracked as buffered\n            this.removeParts(frag.sn - 1, frag.type);\n          }\n        } else {\n          // remove fragment if nothing was appended\n          this.removeFragment(fragmentEntity.body);\n        }\n      };\n      _proto.removeParts = function removeParts(snToKeep, levelType) {\n        var activeParts = this.activePartLists[levelType];\n        if (!activeParts) {\n          return;\n        }\n        this.activePartLists[levelType] = activeParts.filter(function (part) {\n          return part.fragment.sn >= snToKeep;\n        });\n      };\n      _proto.fragBuffered = function fragBuffered(frag, force) {\n        var fragKey = getFragmentKey(frag);\n        var fragmentEntity = this.fragments[fragKey];\n        if (!fragmentEntity && force) {\n          fragmentEntity = this.fragments[fragKey] = {\n            body: frag,\n            appendedPTS: null,\n            loaded: null,\n            buffered: false,\n            range: Object.create(null)\n          };\n          if (frag.gap) {\n            this.hasGaps = true;\n          }\n        }\n        if (fragmentEntity) {\n          fragmentEntity.loaded = null;\n          fragmentEntity.buffered = true;\n        }\n      };\n      _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {\n        var buffered = {\n          time: [],\n          partial: partial\n        };\n        var startPTS = fragment.start;\n        var endPTS = fragment.end;\n        var minEndPTS = fragment.minEndPTS || endPTS;\n        var maxStartPTS = fragment.maxStartPTS || startPTS;\n        for (var i = 0; i < timeRange.length; i++) {\n          var startTime = timeRange.start(i) - this.bufferPadding;\n          var endTime = timeRange.end(i) + this.bufferPadding;\n          if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n            // Fragment is entirely contained in buffer\n            // No need to check the other timeRange times since it's completely playable\n            buffered.time.push({\n              startPTS: Math.max(startPTS, timeRange.start(i)),\n              endPTS: Math.min(endPTS, timeRange.end(i))\n            });\n            break;\n          } else if (startPTS < endTime && endPTS > startTime) {\n            buffered.partial = true;\n            // Check for intersection with buffer\n            // Get playable sections of the fragment\n            buffered.time.push({\n              startPTS: Math.max(startPTS, timeRange.start(i)),\n              endPTS: Math.min(endPTS, timeRange.end(i))\n            });\n          } else if (endPTS <= startTime) {\n            // No need to check the rest of the timeRange as it is in order\n            break;\n          }\n        }\n        return buffered;\n      }\n\n      /**\n       * Gets the partial fragment for a certain time\n       */;\n      _proto.getPartialFragment = function getPartialFragment(time) {\n        var bestFragment = null;\n        var timePadding;\n        var startTime;\n        var endTime;\n        var bestOverlap = 0;\n        var bufferPadding = this.bufferPadding,\n          fragments = this.fragments;\n        Object.keys(fragments).forEach(function (key) {\n          var fragmentEntity = fragments[key];\n          if (!fragmentEntity) {\n            return;\n          }\n          if (isPartial(fragmentEntity)) {\n            startTime = fragmentEntity.body.start - bufferPadding;\n            endTime = fragmentEntity.body.end + bufferPadding;\n            if (time >= startTime && time <= endTime) {\n              // Use the fragment that has the most padding from start and end time\n              timePadding = Math.min(time - startTime, endTime - time);\n              if (bestOverlap <= timePadding) {\n                bestFragment = fragmentEntity.body;\n                bestOverlap = timePadding;\n              }\n            }\n          }\n        });\n        return bestFragment;\n      };\n      _proto.isEndListAppended = function isEndListAppended(type) {\n        var lastFragmentEntity = this.endListFragments[type];\n        return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n      };\n      _proto.getState = function getState(fragment) {\n        var fragKey = getFragmentKey(fragment);\n        var fragmentEntity = this.fragments[fragKey];\n        if (fragmentEntity) {\n          if (!fragmentEntity.buffered) {\n            return FragmentState.APPENDING;\n          } else if (isPartial(fragmentEntity)) {\n            return FragmentState.PARTIAL;\n          } else {\n            return FragmentState.OK;\n          }\n        }\n        return FragmentState.NOT_LOADED;\n      };\n      _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {\n        var startTime;\n        var endTime;\n        for (var i = 0; i < timeRange.length; i++) {\n          startTime = timeRange.start(i) - this.bufferPadding;\n          endTime = timeRange.end(i) + this.bufferPadding;\n          if (startPTS >= startTime && endPTS <= endTime) {\n            return true;\n          }\n          if (endPTS <= startTime) {\n            // No need to check the rest of the timeRange as it is in order\n            return false;\n          }\n        }\n        return false;\n      };\n      _proto.onFragLoaded = function onFragLoaded(event, data) {\n        var frag = data.frag,\n          part = data.part;\n        // don't track initsegment (for which sn is not a number)\n        // don't track frags used for bitrateTest, they're irrelevant.\n        if (frag.sn === 'initSegment' || frag.bitrateTest) {\n          return;\n        }\n\n        // Fragment entity `loaded` FragLoadedData is null when loading parts\n        var loaded = part ? null : data;\n        var fragKey = getFragmentKey(frag);\n        this.fragments[fragKey] = {\n          body: frag,\n          appendedPTS: null,\n          loaded: loaded,\n          buffered: false,\n          range: Object.create(null)\n        };\n      };\n      _proto.onBufferAppended = function onBufferAppended(event, data) {\n        var _this3 = this;\n        var frag = data.frag,\n          part = data.part,\n          timeRanges = data.timeRanges;\n        if (frag.sn === 'initSegment') {\n          return;\n        }\n        var playlistType = frag.type;\n        if (part) {\n          var activeParts = this.activePartLists[playlistType];\n          if (!activeParts) {\n            this.activePartLists[playlistType] = activeParts = [];\n          }\n          activeParts.push(part);\n        }\n        // Store the latest timeRanges loaded in the buffer\n        this.timeRanges = timeRanges;\n        Object.keys(timeRanges).forEach(function (elementaryStream) {\n          var timeRange = timeRanges[elementaryStream];\n          _this3.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);\n        });\n      };\n      _proto.onFragBuffered = function onFragBuffered(event, data) {\n        this.detectPartialFragments(data);\n      };\n      _proto.hasFragment = function hasFragment(fragment) {\n        var fragKey = getFragmentKey(fragment);\n        return !!this.fragments[fragKey];\n      };\n      _proto.hasParts = function hasParts(type) {\n        var _this$activePartLists;\n        return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);\n      };\n      _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {\n        var _this4 = this;\n        if (withGapOnly && !this.hasGaps) {\n          return;\n        }\n        Object.keys(this.fragments).forEach(function (key) {\n          var fragmentEntity = _this4.fragments[key];\n          if (!fragmentEntity) {\n            return;\n          }\n          var frag = fragmentEntity.body;\n          if (frag.type !== playlistType || withGapOnly && !frag.gap) {\n            return;\n          }\n          if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {\n            _this4.removeFragment(frag);\n          }\n        });\n      };\n      _proto.removeFragment = function removeFragment(fragment) {\n        var fragKey = getFragmentKey(fragment);\n        fragment.stats.loaded = 0;\n        fragment.clearElementaryStreamInfo();\n        var activeParts = this.activePartLists[fragment.type];\n        if (activeParts) {\n          var snToRemove = fragment.sn;\n          this.activePartLists[fragment.type] = activeParts.filter(function (part) {\n            return part.fragment.sn !== snToRemove;\n          });\n        }\n        delete this.fragments[fragKey];\n        if (fragment.endList) {\n          delete this.endListFragments[fragment.type];\n        }\n      };\n      _proto.removeAllFragments = function removeAllFragments() {\n        this.fragments = Object.create(null);\n        this.endListFragments = Object.create(null);\n        this.activePartLists = Object.create(null);\n        this.hasGaps = false;\n      };\n      return FragmentTracker;\n    }();\n    function isPartial(fragmentEntity) {\n      var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;\n      return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));\n    }\n    function getFragmentKey(fragment) {\n      return fragment.type + \"_\" + fragment.level + \"_\" + fragment.urlId + \"_\" + fragment.sn;\n    }\n    var MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\n    var FragmentLoader = /*#__PURE__*/function () {\n      function FragmentLoader(config) {\n        this.config = void 0;\n        this.loader = null;\n        this.partLoadTimeout = -1;\n        this.config = config;\n      }\n      var _proto = FragmentLoader.prototype;\n      _proto.destroy = function destroy() {\n        if (this.loader) {\n          this.loader.destroy();\n          this.loader = null;\n        }\n      };\n      _proto.abort = function abort() {\n        if (this.loader) {\n          // Abort the loader for current fragment. Only one may load at any given time\n          this.loader.abort();\n        }\n      };\n      _proto.load = function load(frag, _onProgress) {\n        var _this = this;\n        var url = frag.url;\n        if (!url) {\n          return Promise.reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag: frag,\n            error: new Error(\"Fragment does not have a \" + (url ? 'part list' : 'url')),\n            networkDetails: null\n          }));\n        }\n        this.abort();\n        var config = this.config;\n        var FragmentILoader = config.fLoader;\n        var DefaultILoader = config.loader;\n        return new Promise(function (resolve, reject) {\n          if (_this.loader) {\n            _this.loader.destroy();\n          }\n          if (frag.gap) {\n            reject(createGapLoadError(frag));\n            return;\n          }\n          var loader = _this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n          var loaderContext = createLoaderContext(frag);\n          var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n          var loaderConfig = {\n            loadPolicy: loadPolicy,\n            timeout: loadPolicy.maxLoadTimeMs,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: 0,\n            highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE\n          };\n          // Assign frag stats to the loader's stats reference\n          frag.stats = loader.stats;\n          loader.load(loaderContext, loaderConfig, {\n            onSuccess: function onSuccess(response, stats, context, networkDetails) {\n              _this.resetLoader(frag, loader);\n              var payload = response.data;\n              if (context.resetIV && frag.decryptdata) {\n                frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n                payload = payload.slice(16);\n              }\n              resolve({\n                frag: frag,\n                part: null,\n                payload: payload,\n                networkDetails: networkDetails\n              });\n            },\n            onError: function onError(response, context, networkDetails, stats) {\n              _this.resetLoader(frag, loader);\n              reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.FRAG_LOAD_ERROR,\n                fatal: false,\n                frag: frag,\n                response: _objectSpread2({\n                  url: url,\n                  data: undefined\n                }, response),\n                error: new Error(\"HTTP Error \" + response.code + \" \" + response.text),\n                networkDetails: networkDetails,\n                stats: stats\n              }));\n            },\n            onAbort: function onAbort(stats, context, networkDetails) {\n              _this.resetLoader(frag, loader);\n              reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.INTERNAL_ABORTED,\n                fatal: false,\n                frag: frag,\n                error: new Error('Aborted'),\n                networkDetails: networkDetails,\n                stats: stats\n              }));\n            },\n            onTimeout: function onTimeout(stats, context, networkDetails) {\n              _this.resetLoader(frag, loader);\n              reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n                fatal: false,\n                frag: frag,\n                error: new Error(\"Timeout after \" + loaderConfig.timeout + \"ms\"),\n                networkDetails: networkDetails,\n                stats: stats\n              }));\n            },\n            onProgress: function onProgress(stats, context, data, networkDetails) {\n              if (_onProgress) {\n                _onProgress({\n                  frag: frag,\n                  part: null,\n                  payload: data,\n                  networkDetails: networkDetails\n                });\n              }\n            }\n          });\n        });\n      };\n      _proto.loadPart = function loadPart(frag, part, onProgress) {\n        var _this2 = this;\n        this.abort();\n        var config = this.config;\n        var FragmentILoader = config.fLoader;\n        var DefaultILoader = config.loader;\n        return new Promise(function (resolve, reject) {\n          if (_this2.loader) {\n            _this2.loader.destroy();\n          }\n          if (frag.gap || part.gap) {\n            reject(createGapLoadError(frag, part));\n            return;\n          }\n          var loader = _this2.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n          var loaderContext = createLoaderContext(frag, part);\n          // Should we define another load policy for parts?\n          var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n          var loaderConfig = {\n            loadPolicy: loadPolicy,\n            timeout: loadPolicy.maxLoadTimeMs,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: 0,\n            highWaterMark: MIN_CHUNK_SIZE\n          };\n          // Assign part stats to the loader's stats reference\n          part.stats = loader.stats;\n          loader.load(loaderContext, loaderConfig, {\n            onSuccess: function onSuccess(response, stats, context, networkDetails) {\n              _this2.resetLoader(frag, loader);\n              _this2.updateStatsFromPart(frag, part);\n              var partLoadedData = {\n                frag: frag,\n                part: part,\n                payload: response.data,\n                networkDetails: networkDetails\n              };\n              onProgress(partLoadedData);\n              resolve(partLoadedData);\n            },\n            onError: function onError(response, context, networkDetails, stats) {\n              _this2.resetLoader(frag, loader);\n              reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.FRAG_LOAD_ERROR,\n                fatal: false,\n                frag: frag,\n                part: part,\n                response: _objectSpread2({\n                  url: loaderContext.url,\n                  data: undefined\n                }, response),\n                error: new Error(\"HTTP Error \" + response.code + \" \" + response.text),\n                networkDetails: networkDetails,\n                stats: stats\n              }));\n            },\n            onAbort: function onAbort(stats, context, networkDetails) {\n              frag.stats.aborted = part.stats.aborted;\n              _this2.resetLoader(frag, loader);\n              reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.INTERNAL_ABORTED,\n                fatal: false,\n                frag: frag,\n                part: part,\n                error: new Error('Aborted'),\n                networkDetails: networkDetails,\n                stats: stats\n              }));\n            },\n            onTimeout: function onTimeout(stats, context, networkDetails) {\n              _this2.resetLoader(frag, loader);\n              reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n                fatal: false,\n                frag: frag,\n                part: part,\n                error: new Error(\"Timeout after \" + loaderConfig.timeout + \"ms\"),\n                networkDetails: networkDetails,\n                stats: stats\n              }));\n            }\n          });\n        });\n      };\n      _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {\n        var fragStats = frag.stats;\n        var partStats = part.stats;\n        var partTotal = partStats.total;\n        fragStats.loaded += partStats.loaded;\n        if (partTotal) {\n          var estTotalParts = Math.round(frag.duration / part.duration);\n          var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n          var estRemainingParts = estTotalParts - estLoadedParts;\n          var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n          fragStats.total = fragStats.loaded + estRemainingBytes;\n        } else {\n          fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n        }\n        var fragLoading = fragStats.loading;\n        var partLoading = partStats.loading;\n        if (fragLoading.start) {\n          // add to fragment loader latency\n          fragLoading.first += partLoading.first - partLoading.start;\n        } else {\n          fragLoading.start = partLoading.start;\n          fragLoading.first = partLoading.first;\n        }\n        fragLoading.end = partLoading.end;\n      };\n      _proto.resetLoader = function resetLoader(frag, loader) {\n        frag.loader = null;\n        if (this.loader === loader) {\n          self.clearTimeout(this.partLoadTimeout);\n          this.loader = null;\n        }\n        loader.destroy();\n      };\n      return FragmentLoader;\n    }();\n    function createLoaderContext(frag, part) {\n      if (part === void 0) {\n        part = null;\n      }\n      var segment = part || frag;\n      var loaderContext = {\n        frag: frag,\n        part: part,\n        responseType: 'arraybuffer',\n        url: segment.url,\n        headers: {},\n        rangeStart: 0,\n        rangeEnd: 0\n      };\n      var start = segment.byteRangeStartOffset;\n      var end = segment.byteRangeEndOffset;\n      if (isFiniteNumber(start) && isFiniteNumber(end)) {\n        var _frag$decryptdata;\n        var byteRangeStart = start;\n        var byteRangeEnd = end;\n        if (frag.sn === 'initSegment' && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === 'AES-128') {\n          // MAP segment encrypted with method 'AES-128', when served with HTTP Range,\n          // has the unencrypted size specified in the range.\n          // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n          var fragmentLen = end - start;\n          if (fragmentLen % 16) {\n            byteRangeEnd = end + (16 - fragmentLen % 16);\n          }\n          if (start !== 0) {\n            loaderContext.resetIV = true;\n            byteRangeStart = start - 16;\n          }\n        }\n        loaderContext.rangeStart = byteRangeStart;\n        loaderContext.rangeEnd = byteRangeEnd;\n      }\n      return loaderContext;\n    }\n    function createGapLoadError(frag, part) {\n      var error = new Error(\"GAP \" + (frag.gap ? 'tag' : 'attribute') + \" found\");\n      var errorData = {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_GAP,\n        fatal: false,\n        frag: frag,\n        error: error,\n        networkDetails: null\n      };\n      if (part) {\n        errorData.part = part;\n      }\n      (part ? part : frag).stats.aborted = true;\n      return new LoadError(errorData);\n    }\n    var LoadError = /*#__PURE__*/function (_Error) {\n      _inheritsLoose(LoadError, _Error);\n      function LoadError(data) {\n        var _this3;\n        _this3 = _Error.call(this, data.error.message) || this;\n        _this3.data = void 0;\n        _this3.data = data;\n        return _this3;\n      }\n      return LoadError;\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n    var KeyLoader = /*#__PURE__*/function () {\n      function KeyLoader(config) {\n        this.config = void 0;\n        this.keyUriToKeyInfo = {};\n        this.emeController = null;\n        this.config = config;\n      }\n      var _proto = KeyLoader.prototype;\n      _proto.abort = function abort(type) {\n        for (var uri in this.keyUriToKeyInfo) {\n          var loader = this.keyUriToKeyInfo[uri].loader;\n          if (loader) {\n            if (type && type !== loader.context.frag.type) {\n              return;\n            }\n            loader.abort();\n          }\n        }\n      };\n      _proto.detach = function detach() {\n        for (var uri in this.keyUriToKeyInfo) {\n          var keyInfo = this.keyUriToKeyInfo[uri];\n          // Remove cached EME keys on detach\n          if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n            delete this.keyUriToKeyInfo[uri];\n          }\n        }\n      };\n      _proto.destroy = function destroy() {\n        this.detach();\n        for (var uri in this.keyUriToKeyInfo) {\n          var loader = this.keyUriToKeyInfo[uri].loader;\n          if (loader) {\n            loader.destroy();\n          }\n        }\n        this.keyUriToKeyInfo = {};\n      };\n      _proto.createKeyLoadError = function createKeyLoadError(frag, details, error, networkDetails, response) {\n        if (details === void 0) {\n          details = ErrorDetails.KEY_LOAD_ERROR;\n        }\n        return new LoadError({\n          type: ErrorTypes.NETWORK_ERROR,\n          details: details,\n          fatal: false,\n          frag: frag,\n          response: response,\n          error: error,\n          networkDetails: networkDetails\n        });\n      };\n      _proto.loadClear = function loadClear(loadingFrag, encryptedFragments) {\n        var _this = this;\n        if (this.emeController && this.config.emeEnabled) {\n          // access key-system with nearest key on start (loaidng frag is unencrypted)\n          var sn = loadingFrag.sn,\n            cc = loadingFrag.cc;\n          var _loop = function _loop() {\n            var frag = encryptedFragments[i];\n            if (cc <= frag.cc && (sn === 'initSegment' || frag.sn === 'initSegment' || sn < frag.sn)) {\n              _this.emeController.selectKeySystemFormat(frag).then(function (keySystemFormat) {\n                frag.setKeyFormat(keySystemFormat);\n              });\n              return \"break\";\n            }\n          };\n          for (var i = 0; i < encryptedFragments.length; i++) {\n            var _ret = _loop();\n            if (_ret === \"break\") break;\n          }\n        }\n      };\n      _proto.load = function load(frag) {\n        var _this2 = this;\n        if (!frag.decryptdata && frag.encrypted && this.emeController) {\n          // Multiple keys, but none selected, resolve in eme-controller\n          return this.emeController.selectKeySystemFormat(frag).then(function (keySystemFormat) {\n            return _this2.loadInternal(frag, keySystemFormat);\n          });\n        }\n        return this.loadInternal(frag);\n      };\n      _proto.loadInternal = function loadInternal(frag, keySystemFormat) {\n        var _keyInfo, _keyInfo2;\n        if (keySystemFormat) {\n          frag.setKeyFormat(keySystemFormat);\n        }\n        var decryptdata = frag.decryptdata;\n        if (!decryptdata) {\n          var error = new Error(keySystemFormat ? \"Expected frag.decryptdata to be defined after setting format \" + keySystemFormat : 'Missing decryption data on fragment in onKeyLoading');\n          return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));\n        }\n        var uri = decryptdata.uri;\n        if (!uri) {\n          return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"Invalid key URI: \\\"\" + uri + \"\\\"\")));\n        }\n        var keyInfo = this.keyUriToKeyInfo[uri];\n        if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {\n          decryptdata.key = keyInfo.decryptdata.key;\n          return Promise.resolve({\n            frag: frag,\n            keyInfo: keyInfo\n          });\n        }\n        // Return key load promise as long as it does not have a mediakey session with an unusable key status\n        if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {\n          var _keyInfo$mediaKeySess;\n          switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {\n            case undefined:\n            case 'status-pending':\n            case 'usable':\n            case 'usable-in-future':\n              return keyInfo.keyLoadPromise.then(function (keyLoadedData) {\n                // Return the correct fragment with updated decryptdata key and loaded keyInfo\n                decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;\n                return {\n                  frag: frag,\n                  keyInfo: keyInfo\n                };\n              });\n          }\n          // If we have a key session and status and it is not pending or usable, continue\n          // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n        }\n\n        // Load the key or return the loading promise\n        keyInfo = this.keyUriToKeyInfo[uri] = {\n          decryptdata: decryptdata,\n          keyLoadPromise: null,\n          loader: null,\n          mediaKeySessionContext: null\n        };\n        switch (decryptdata.method) {\n          case 'ISO-23001-7':\n          case 'SAMPLE-AES':\n          case 'SAMPLE-AES-CENC':\n          case 'SAMPLE-AES-CTR':\n            if (decryptdata.keyFormat === 'identity') {\n              // loadKeyHTTP handles http(s) and data URLs\n              return this.loadKeyHTTP(keyInfo, frag);\n            }\n            return this.loadKeyEME(keyInfo, frag);\n          case 'AES-128':\n            return this.loadKeyHTTP(keyInfo, frag);\n          default:\n            return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"Key supplied with unsupported METHOD: \\\"\" + decryptdata.method + \"\\\"\")));\n        }\n      };\n      _proto.loadKeyEME = function loadKeyEME(keyInfo, frag) {\n        var keyLoadedData = {\n          frag: frag,\n          keyInfo: keyInfo\n        };\n        if (this.emeController && this.config.emeEnabled) {\n          var keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n          if (keySessionContextPromise) {\n            return (keyInfo.keyLoadPromise = keySessionContextPromise.then(function (keySessionContext) {\n              keyInfo.mediaKeySessionContext = keySessionContext;\n              return keyLoadedData;\n            })).catch(function (error) {\n              // Remove promise for license renewal or retry\n              keyInfo.keyLoadPromise = null;\n              throw error;\n            });\n          }\n        }\n        return Promise.resolve(keyLoadedData);\n      };\n      _proto.loadKeyHTTP = function loadKeyHTTP(keyInfo, frag) {\n        var _this3 = this;\n        var config = this.config;\n        var Loader = config.loader;\n        var keyLoader = new Loader(config);\n        frag.keyLoader = keyInfo.loader = keyLoader;\n        return keyInfo.keyLoadPromise = new Promise(function (resolve, reject) {\n          var loaderContext = {\n            keyInfo: keyInfo,\n            frag: frag,\n            responseType: 'arraybuffer',\n            url: keyInfo.decryptdata.uri\n          };\n\n          // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n          // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n          // this will also align retry logic with fragment-loader\n          var loadPolicy = config.keyLoadPolicy.default;\n          var loaderConfig = {\n            loadPolicy: loadPolicy,\n            timeout: loadPolicy.maxLoadTimeMs,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: 0\n          };\n          var loaderCallbacks = {\n            onSuccess: function onSuccess(response, stats, context, networkDetails) {\n              var frag = context.frag,\n                keyInfo = context.keyInfo,\n                uri = context.url;\n              if (!frag.decryptdata || keyInfo !== _this3.keyUriToKeyInfo[uri]) {\n                return reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('after key load, decryptdata unset or changed'), networkDetails));\n              }\n              keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n\n              // detach fragment key loader on load success\n              frag.keyLoader = null;\n              keyInfo.loader = null;\n              resolve({\n                frag: frag,\n                keyInfo: keyInfo\n              });\n            },\n            onError: function onError(response, context, networkDetails, stats) {\n              _this3.resetLoader(context);\n              reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"HTTP Error \" + response.code + \" loading key \" + response.text), networkDetails, _objectSpread2({\n                url: loaderContext.url,\n                data: undefined\n              }, response)));\n            },\n            onTimeout: function onTimeout(stats, context, networkDetails) {\n              _this3.resetLoader(context);\n              reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error('key loading timed out'), networkDetails));\n            },\n            onAbort: function onAbort(stats, context, networkDetails) {\n              _this3.resetLoader(context);\n              reject(_this3.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error('key loading aborted'), networkDetails));\n            }\n          };\n          keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n        });\n      };\n      _proto.resetLoader = function resetLoader(context) {\n        var frag = context.frag,\n          keyInfo = context.keyInfo,\n          uri = context.url;\n        var loader = keyInfo.loader;\n        if (frag.keyLoader === loader) {\n          frag.keyLoader = null;\n          keyInfo.loader = null;\n        }\n        delete this.keyUriToKeyInfo[uri];\n        if (loader) {\n          loader.destroy();\n        }\n      };\n      return KeyLoader;\n    }();\n\n    /**\n     * @ignore\n     * Sub-class specialization of EventHandler base class.\n     *\n     * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n     * scheduled asynchroneously, avoiding recursive calls in the same tick.\n     *\n     * The task itself is implemented in `doTick`. It can be requested and called for single execution\n     * using the `tick` method.\n     *\n     * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n     * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n     *\n     * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n     * and cancelled with `clearNextTick`.\n     *\n     * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n     *\n     * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n     *\n     * Further explanations:\n     *\n     * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n     * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n     *\n     * When the task execution (`tick` method) is called in re-entrant way this is detected and\n     * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n     * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n     */\n    var TaskLoop = /*#__PURE__*/function () {\n      function TaskLoop() {\n        this._boundTick = void 0;\n        this._tickTimer = null;\n        this._tickInterval = null;\n        this._tickCallCount = 0;\n        this._boundTick = this.tick.bind(this);\n      }\n      var _proto = TaskLoop.prototype;\n      _proto.destroy = function destroy() {\n        this.onHandlerDestroying();\n        this.onHandlerDestroyed();\n      };\n      _proto.onHandlerDestroying = function onHandlerDestroying() {\n        // clear all timers before unregistering from event bus\n        this.clearNextTick();\n        this.clearInterval();\n      };\n      _proto.onHandlerDestroyed = function onHandlerDestroyed() {};\n      _proto.hasInterval = function hasInterval() {\n        return !!this._tickInterval;\n      };\n      _proto.hasNextTick = function hasNextTick() {\n        return !!this._tickTimer;\n      }\n\n      /**\n       * @param millis - Interval time (ms)\n       * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n       */;\n      _proto.setInterval = function setInterval(millis) {\n        if (!this._tickInterval) {\n          this._tickCallCount = 0;\n          this._tickInterval = self.setInterval(this._boundTick, millis);\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * @returns True when interval was cleared, false when none was set (no effect)\n       */;\n      _proto.clearInterval = function clearInterval() {\n        if (this._tickInterval) {\n          self.clearInterval(this._tickInterval);\n          this._tickInterval = null;\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * @returns True when timeout was cleared, false when none was set (no effect)\n       */;\n      _proto.clearNextTick = function clearNextTick() {\n        if (this._tickTimer) {\n          self.clearTimeout(this._tickTimer);\n          this._tickTimer = null;\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * Will call the subclass doTick implementation in this main loop tick\n       * or in the next one (via setTimeout(,0)) in case it has already been called\n       * in this tick (in case this is a re-entrant call).\n       */;\n      _proto.tick = function tick() {\n        this._tickCallCount++;\n        if (this._tickCallCount === 1) {\n          this.doTick();\n          // re-entrant call to tick from previous doTick call stack\n          // -> schedule a call on the next main loop iteration to process this task processing request\n          if (this._tickCallCount > 1) {\n            // make sure only one timer exists at any time at max\n            this.tickImmediate();\n          }\n          this._tickCallCount = 0;\n        }\n      };\n      _proto.tickImmediate = function tickImmediate() {\n        this.clearNextTick();\n        this._tickTimer = self.setTimeout(this._boundTick, 0);\n      }\n\n      /**\n       * For subclass to implement task logic\n       * @abstract\n       */;\n      _proto.doTick = function doTick() {};\n      return TaskLoop;\n    }();\n\n    /**\n     * Provides methods dealing with buffer length retrieval for example.\n     *\n     * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n     *\n     * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n     */\n\n    var noopBuffered = {\n      length: 0,\n      start: function start() {\n        return 0;\n      },\n      end: function end() {\n        return 0;\n      }\n    };\n    var BufferHelper = /*#__PURE__*/function () {\n      function BufferHelper() {}\n      /**\n       * Return true if `media`'s buffered include `position`\n       */\n      BufferHelper.isBuffered = function isBuffered(media, position) {\n        try {\n          if (media) {\n            var buffered = BufferHelper.getBuffered(media);\n            for (var i = 0; i < buffered.length; i++) {\n              if (position >= buffered.start(i) && position <= buffered.end(i)) {\n                return true;\n              }\n            }\n          }\n        } catch (error) {\n          // this is to catch\n          // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n          // This SourceBuffer has been removed from the parent media source\n        }\n        return false;\n      };\n      BufferHelper.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {\n        try {\n          if (media) {\n            var vbuffered = BufferHelper.getBuffered(media);\n            var buffered = [];\n            var i;\n            for (i = 0; i < vbuffered.length; i++) {\n              buffered.push({\n                start: vbuffered.start(i),\n                end: vbuffered.end(i)\n              });\n            }\n            return this.bufferedInfo(buffered, pos, maxHoleDuration);\n          }\n        } catch (error) {\n          // this is to catch\n          // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n          // This SourceBuffer has been removed from the parent media source\n        }\n        return {\n          len: 0,\n          start: pos,\n          end: pos,\n          nextStart: undefined\n        };\n      };\n      BufferHelper.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {\n        pos = Math.max(0, pos);\n        // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n        buffered.sort(function (a, b) {\n          var diff = a.start - b.start;\n          if (diff) {\n            return diff;\n          } else {\n            return b.end - a.end;\n          }\n        });\n        var buffered2 = [];\n        if (maxHoleDuration) {\n          // there might be some small holes between buffer time range\n          // consider that holes smaller than maxHoleDuration are irrelevant and build another\n          // buffer time range representations that discards those holes\n          for (var i = 0; i < buffered.length; i++) {\n            var buf2len = buffered2.length;\n            if (buf2len) {\n              var buf2end = buffered2[buf2len - 1].end;\n              // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n              if (buffered[i].start - buf2end < maxHoleDuration) {\n                // merge overlapping time ranges\n                // update lastRange.end only if smaller than item.end\n                // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n                // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n                if (buffered[i].end > buf2end) {\n                  buffered2[buf2len - 1].end = buffered[i].end;\n                }\n              } else {\n                // big hole\n                buffered2.push(buffered[i]);\n              }\n            } else {\n              // first value\n              buffered2.push(buffered[i]);\n            }\n          }\n        } else {\n          buffered2 = buffered;\n        }\n        var bufferLen = 0;\n\n        // bufferStartNext can possibly be undefined based on the conditional logic below\n        var bufferStartNext;\n\n        // bufferStart and bufferEnd are buffer boundaries around current video position\n        var bufferStart = pos;\n        var bufferEnd = pos;\n        for (var _i = 0; _i < buffered2.length; _i++) {\n          var start = buffered2[_i].start;\n          var end = buffered2[_i].end;\n          // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n          if (pos + maxHoleDuration >= start && pos < end) {\n            // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n            bufferStart = start;\n            bufferEnd = end;\n            bufferLen = bufferEnd - pos;\n          } else if (pos + maxHoleDuration < start) {\n            bufferStartNext = start;\n            break;\n          }\n        }\n        return {\n          len: bufferLen,\n          start: bufferStart || 0,\n          end: bufferEnd || 0,\n          nextStart: bufferStartNext\n        };\n      }\n\n      /**\n       * Safe method to get buffered property.\n       * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n       */;\n      BufferHelper.getBuffered = function getBuffered(media) {\n        try {\n          return media.buffered;\n        } catch (e) {\n          logger.log('failed to get media.buffered', e);\n          return noopBuffered;\n        }\n      };\n      return BufferHelper;\n    }();\n    var ChunkMetadata = function ChunkMetadata(level, sn, id, size, part, partial) {\n      if (size === void 0) {\n        size = 0;\n      }\n      if (part === void 0) {\n        part = -1;\n      }\n      if (partial === void 0) {\n        partial = false;\n      }\n      this.level = void 0;\n      this.sn = void 0;\n      this.part = void 0;\n      this.id = void 0;\n      this.size = void 0;\n      this.partial = void 0;\n      this.transmuxing = getNewPerformanceTiming();\n      this.buffering = {\n        audio: getNewPerformanceTiming(),\n        video: getNewPerformanceTiming(),\n        audiovideo: getNewPerformanceTiming()\n      };\n      this.level = level;\n      this.sn = sn;\n      this.id = id;\n      this.size = size;\n      this.part = part;\n      this.partial = partial;\n    };\n    function getNewPerformanceTiming() {\n      return {\n        start: 0,\n        executeStart: 0,\n        executeEnd: 0,\n        end: 0\n      };\n    }\n    function findFirstFragWithCC(fragments, cc) {\n      var firstFrag = null;\n      for (var i = 0, len = fragments.length; i < len; i++) {\n        var currentFrag = fragments[i];\n        if (currentFrag && currentFrag.cc === cc) {\n          firstFrag = currentFrag;\n          break;\n        }\n      }\n      return firstFrag;\n    }\n    function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {\n      if (lastLevel.details) {\n        if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // Find the first frag in the previous level which matches the CC of the first frag of the new level\n    function findDiscontinuousReferenceFrag(prevDetails, curDetails, referenceIndex) {\n      var prevFrags = prevDetails.fragments;\n      var curFrags = curDetails.fragments;\n      if (!curFrags.length || !prevFrags.length) {\n        logger.log('No fragments to align');\n        return;\n      }\n      var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);\n      if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {\n        logger.log('No frag in previous level to align on');\n        return;\n      }\n      return prevStartFrag;\n    }\n    function adjustFragmentStart(frag, sliding) {\n      if (frag) {\n        var start = frag.start + sliding;\n        frag.start = frag.startPTS = start;\n        frag.endPTS = start + frag.duration;\n      }\n    }\n    function adjustSlidingStart(sliding, details) {\n      // Update segments\n      var fragments = details.fragments;\n      for (var i = 0, len = fragments.length; i < len; i++) {\n        adjustFragmentStart(fragments[i], sliding);\n      }\n      // Update LL-HLS parts at the end of the playlist\n      if (details.fragmentHint) {\n        adjustFragmentStart(details.fragmentHint, sliding);\n      }\n      details.alignedSliding = true;\n    }\n\n    /**\n     * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n     * contiguous stream with the last fragments.\n     * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n     * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n     * and an extra download.\n     * @param lastFrag\n     * @param lastLevel\n     * @param details\n     */\n    function alignStream(lastFrag, lastLevel, details) {\n      if (!lastLevel) {\n        return;\n      }\n      alignDiscontinuities(lastFrag, details, lastLevel);\n      if (!details.alignedSliding && lastLevel.details) {\n        // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n        // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n        // discontinuity sequence.\n        alignPDT(details, lastLevel.details);\n      }\n      if (!details.alignedSliding && lastLevel.details && !details.skippedSegments) {\n        // Try to align on sn so that we pick a better start fragment.\n        // Do not perform this on playlists with delta updates as this is only to align levels on switch\n        // and adjustSliding only adjusts fragments after skippedSegments.\n        adjustSliding(lastLevel.details, details);\n      }\n    }\n\n    /**\n     * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same\n     * discontinuity sequence.\n     * @param lastFrag - The last Fragment which shares the same discontinuity sequence\n     * @param lastLevel - The details of the last loaded level\n     * @param details - The details of the new level\n     */\n    function alignDiscontinuities(lastFrag, details, lastLevel) {\n      if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {\n        var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);\n        if (referenceFrag && isFiniteNumber(referenceFrag.start)) {\n          logger.log(\"Adjusting PTS using last level due to CC increase within current level \" + details.url);\n          adjustSlidingStart(referenceFrag.start, details);\n        }\n      }\n    }\n\n    /**\n     * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.\n     * @param details - The details of the new level\n     * @param lastDetails - The details of the last loaded level\n     */\n    function alignPDT(details, lastDetails) {\n      // This check protects the unsafe \"!\" usage below for null program date time access.\n      if (!lastDetails.fragments.length || !details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {\n        return;\n      }\n      // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM\n      // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM\n      // then we can deduce that playlist B sliding is 1000+8 = 1008s\n      var lastPDT = lastDetails.fragments[0].programDateTime; // hasProgramDateTime check above makes this safe.\n      var newPDT = details.fragments[0].programDateTime;\n      // date diff is in ms. frag.start is in seconds\n      var sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;\n      if (sliding && isFiniteNumber(sliding)) {\n        logger.log(\"Adjusting PTS using programDateTime delta \" + (newPDT - lastPDT) + \"ms, sliding:\" + sliding.toFixed(3) + \" \" + details.url + \" \");\n        adjustSlidingStart(sliding, details);\n      }\n    }\n    var AESCrypto = /*#__PURE__*/function () {\n      function AESCrypto(subtle, iv) {\n        this.subtle = void 0;\n        this.aesIV = void 0;\n        this.subtle = subtle;\n        this.aesIV = iv;\n      }\n      var _proto = AESCrypto.prototype;\n      _proto.decrypt = function decrypt(data, key) {\n        return this.subtle.decrypt({\n          name: 'AES-CBC',\n          iv: this.aesIV\n        }, key, data);\n      };\n      return AESCrypto;\n    }();\n    var FastAESKey = /*#__PURE__*/function () {\n      function FastAESKey(subtle, key) {\n        this.subtle = void 0;\n        this.key = void 0;\n        this.subtle = subtle;\n        this.key = key;\n      }\n      var _proto = FastAESKey.prototype;\n      _proto.expandKey = function expandKey() {\n        return this.subtle.importKey('raw', this.key, {\n          name: 'AES-CBC'\n        }, false, ['encrypt', 'decrypt']);\n      };\n      return FastAESKey;\n    }();\n\n    // PKCS7\n    function removePadding(array) {\n      var outputBytes = array.byteLength;\n      var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n      if (paddingBytes) {\n        return sliceUint8(array, 0, outputBytes - paddingBytes);\n      }\n      return array;\n    }\n    var AESDecryptor = /*#__PURE__*/function () {\n      function AESDecryptor() {\n        this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n        this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n        this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n        this.sBox = new Uint32Array(256);\n        this.invSBox = new Uint32Array(256);\n        this.key = new Uint32Array(0);\n        this.ksRows = 0;\n        this.keySize = 0;\n        this.keySchedule = void 0;\n        this.invKeySchedule = void 0;\n        this.initTable();\n      }\n\n      // Using view.getUint32() also swaps the byte order.\n      var _proto = AESDecryptor.prototype;\n      _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {\n        var view = new DataView(arrayBuffer);\n        var newArray = new Uint32Array(4);\n        for (var i = 0; i < 4; i++) {\n          newArray[i] = view.getUint32(i * 4);\n        }\n        return newArray;\n      };\n      _proto.initTable = function initTable() {\n        var sBox = this.sBox;\n        var invSBox = this.invSBox;\n        var subMix = this.subMix;\n        var subMix0 = subMix[0];\n        var subMix1 = subMix[1];\n        var subMix2 = subMix[2];\n        var subMix3 = subMix[3];\n        var invSubMix = this.invSubMix;\n        var invSubMix0 = invSubMix[0];\n        var invSubMix1 = invSubMix[1];\n        var invSubMix2 = invSubMix[2];\n        var invSubMix3 = invSubMix[3];\n        var d = new Uint32Array(256);\n        var x = 0;\n        var xi = 0;\n        var i = 0;\n        for (i = 0; i < 256; i++) {\n          if (i < 128) {\n            d[i] = i << 1;\n          } else {\n            d[i] = i << 1 ^ 0x11b;\n          }\n        }\n        for (i = 0; i < 256; i++) {\n          var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n          sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n          sBox[x] = sx;\n          invSBox[sx] = x;\n\n          // Compute multiplication\n          var x2 = d[x];\n          var x4 = d[x2];\n          var x8 = d[x4];\n\n          // Compute sub/invSub bytes, mix columns tables\n          var t = d[sx] * 0x101 ^ sx * 0x1010100;\n          subMix0[x] = t << 24 | t >>> 8;\n          subMix1[x] = t << 16 | t >>> 16;\n          subMix2[x] = t << 8 | t >>> 24;\n          subMix3[x] = t;\n\n          // Compute inv sub bytes, inv mix columns tables\n          t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n          invSubMix0[sx] = t << 24 | t >>> 8;\n          invSubMix1[sx] = t << 16 | t >>> 16;\n          invSubMix2[sx] = t << 8 | t >>> 24;\n          invSubMix3[sx] = t;\n\n          // Compute next counter\n          if (!x) {\n            x = xi = 1;\n          } else {\n            x = x2 ^ d[d[d[x8 ^ x2]]];\n            xi ^= d[d[xi]];\n          }\n        }\n      };\n      _proto.expandKey = function expandKey(keyBuffer) {\n        // convert keyBuffer to Uint32Array\n        var key = this.uint8ArrayToUint32Array_(keyBuffer);\n        var sameKey = true;\n        var offset = 0;\n        while (offset < key.length && sameKey) {\n          sameKey = key[offset] === this.key[offset];\n          offset++;\n        }\n        if (sameKey) {\n          return;\n        }\n        this.key = key;\n        var keySize = this.keySize = key.length;\n        if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n          throw new Error('Invalid aes key size=' + keySize);\n        }\n        var ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n        var ksRow;\n        var invKsRow;\n        var keySchedule = this.keySchedule = new Uint32Array(ksRows);\n        var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n        var sbox = this.sBox;\n        var rcon = this.rcon;\n        var invSubMix = this.invSubMix;\n        var invSubMix0 = invSubMix[0];\n        var invSubMix1 = invSubMix[1];\n        var invSubMix2 = invSubMix[2];\n        var invSubMix3 = invSubMix[3];\n        var prev;\n        var t;\n        for (ksRow = 0; ksRow < ksRows; ksRow++) {\n          if (ksRow < keySize) {\n            prev = keySchedule[ksRow] = key[ksRow];\n            continue;\n          }\n          t = prev;\n          if (ksRow % keySize === 0) {\n            // Rot word\n            t = t << 8 | t >>> 24;\n\n            // Sub word\n            t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n            // Mix Rcon\n            t ^= rcon[ksRow / keySize | 0] << 24;\n          } else if (keySize > 6 && ksRow % keySize === 4) {\n            // Sub word\n            t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n          }\n          keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n        }\n        for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n          ksRow = ksRows - invKsRow;\n          if (invKsRow & 3) {\n            t = keySchedule[ksRow];\n          } else {\n            t = keySchedule[ksRow - 4];\n          }\n          if (invKsRow < 4 || ksRow <= 4) {\n            invKeySchedule[invKsRow] = t;\n          } else {\n            invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n          }\n          invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n        }\n      }\n\n      // Adding this as a method greatly improves performance.\n      ;\n\n      _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {\n        return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n      };\n      _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {\n        var nRounds = this.keySize + 6;\n        var invKeySchedule = this.invKeySchedule;\n        var invSBOX = this.invSBox;\n        var invSubMix = this.invSubMix;\n        var invSubMix0 = invSubMix[0];\n        var invSubMix1 = invSubMix[1];\n        var invSubMix2 = invSubMix[2];\n        var invSubMix3 = invSubMix[3];\n        var initVector = this.uint8ArrayToUint32Array_(aesIV);\n        var initVector0 = initVector[0];\n        var initVector1 = initVector[1];\n        var initVector2 = initVector[2];\n        var initVector3 = initVector[3];\n        var inputInt32 = new Int32Array(inputArrayBuffer);\n        var outputInt32 = new Int32Array(inputInt32.length);\n        var t0, t1, t2, t3;\n        var s0, s1, s2, s3;\n        var inputWords0, inputWords1, inputWords2, inputWords3;\n        var ksRow, i;\n        var swapWord = this.networkToHostOrderSwap;\n        while (offset < inputInt32.length) {\n          inputWords0 = swapWord(inputInt32[offset]);\n          inputWords1 = swapWord(inputInt32[offset + 1]);\n          inputWords2 = swapWord(inputInt32[offset + 2]);\n          inputWords3 = swapWord(inputInt32[offset + 3]);\n          s0 = inputWords0 ^ invKeySchedule[0];\n          s1 = inputWords3 ^ invKeySchedule[1];\n          s2 = inputWords2 ^ invKeySchedule[2];\n          s3 = inputWords1 ^ invKeySchedule[3];\n          ksRow = 4;\n\n          // Iterate through the rounds of decryption\n          for (i = 1; i < nRounds; i++) {\n            t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n            t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n            t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n            t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n            // Update state\n            s0 = t0;\n            s1 = t1;\n            s2 = t2;\n            s3 = t3;\n            ksRow = ksRow + 4;\n          }\n\n          // Shift rows, sub bytes, add round key\n          t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n          t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n          t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n          t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n\n          // Write\n          outputInt32[offset] = swapWord(t0 ^ initVector0);\n          outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n          outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n          outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n          // reset initVector to last 4 unsigned int\n          initVector0 = inputWords0;\n          initVector1 = inputWords1;\n          initVector2 = inputWords2;\n          initVector3 = inputWords3;\n          offset = offset + 4;\n        }\n        return outputInt32.buffer;\n      };\n      return AESDecryptor;\n    }();\n    var CHUNK_SIZE = 16; // 16 bytes, 128 bits\n    var Decrypter = /*#__PURE__*/function () {\n      function Decrypter(config, _temp) {\n        var _ref = _temp === void 0 ? {} : _temp,\n          _ref$removePKCS7Paddi = _ref.removePKCS7Padding,\n          removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;\n        this.logEnabled = true;\n        this.removePKCS7Padding = void 0;\n        this.subtle = null;\n        this.softwareDecrypter = null;\n        this.key = null;\n        this.fastAesKey = null;\n        this.remainderData = null;\n        this.currentIV = null;\n        this.currentResult = null;\n        this.useSoftware = void 0;\n        this.useSoftware = config.enableSoftwareAES;\n        this.removePKCS7Padding = removePKCS7Padding;\n        // built in decryptor expects PKCS7 padding\n        if (removePKCS7Padding) {\n          try {\n            var browserCrypto = self.crypto;\n            if (browserCrypto) {\n              this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n            }\n          } catch (e) {\n            /* no-op */\n          }\n        }\n        if (this.subtle === null) {\n          this.useSoftware = true;\n        }\n      }\n      var _proto = Decrypter.prototype;\n      _proto.destroy = function destroy() {\n        this.subtle = null;\n        this.softwareDecrypter = null;\n        this.key = null;\n        this.fastAesKey = null;\n        this.remainderData = null;\n        this.currentIV = null;\n        this.currentResult = null;\n      };\n      _proto.isSync = function isSync() {\n        return this.useSoftware;\n      };\n      _proto.flush = function flush() {\n        var currentResult = this.currentResult,\n          remainderData = this.remainderData;\n        if (!currentResult || remainderData) {\n          this.reset();\n          return null;\n        }\n        var data = new Uint8Array(currentResult);\n        this.reset();\n        if (this.removePKCS7Padding) {\n          return removePadding(data);\n        }\n        return data;\n      };\n      _proto.reset = function reset() {\n        this.currentResult = null;\n        this.currentIV = null;\n        this.remainderData = null;\n        if (this.softwareDecrypter) {\n          this.softwareDecrypter = null;\n        }\n      };\n      _proto.decrypt = function decrypt(data, key, iv) {\n        var _this = this;\n        if (this.useSoftware) {\n          return new Promise(function (resolve, reject) {\n            _this.softwareDecrypt(new Uint8Array(data), key, iv);\n            var decryptResult = _this.flush();\n            if (decryptResult) {\n              resolve(decryptResult.buffer);\n            } else {\n              reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n            }\n          });\n        }\n        return this.webCryptoDecrypt(new Uint8Array(data), key, iv);\n      }\n\n      // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n      // data is handled in the flush() call\n      ;\n\n      _proto.softwareDecrypt = function softwareDecrypt(data, key, iv) {\n        var currentIV = this.currentIV,\n          currentResult = this.currentResult,\n          remainderData = this.remainderData;\n        this.logOnce('JS AES decrypt');\n        // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n        // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n        // the end on flush(), but by that time we have already received all bytes for the segment.\n        // Progressive decryption does not work with WebCrypto\n\n        if (remainderData) {\n          data = appendUint8Array(remainderData, data);\n          this.remainderData = null;\n        }\n\n        // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n        var currentChunk = this.getValidChunk(data);\n        if (!currentChunk.length) {\n          return null;\n        }\n        if (currentIV) {\n          iv = currentIV;\n        }\n        var softwareDecrypter = this.softwareDecrypter;\n        if (!softwareDecrypter) {\n          softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n        }\n        softwareDecrypter.expandKey(key);\n        var result = currentResult;\n        this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n        this.currentIV = sliceUint8(currentChunk, -16).buffer;\n        if (!result) {\n          return null;\n        }\n        return result;\n      };\n      _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv) {\n        var _this2 = this;\n        var subtle = this.subtle;\n        if (this.key !== key || !this.fastAesKey) {\n          this.key = key;\n          this.fastAesKey = new FastAESKey(subtle, key);\n        }\n        return this.fastAesKey.expandKey().then(function (aesKey) {\n          // decrypt using web crypto\n          if (!subtle) {\n            return Promise.reject(new Error('web crypto not initialized'));\n          }\n          _this2.logOnce('WebCrypto AES decrypt');\n          var crypto = new AESCrypto(subtle, new Uint8Array(iv));\n          return crypto.decrypt(data.buffer, aesKey);\n        }).catch(function (err) {\n          logger.warn(\"[decrypter]: WebCrypto Error, disable WebCrypto API, \" + err.name + \": \" + err.message);\n          return _this2.onWebCryptoError(data, key, iv);\n        });\n      };\n      _proto.onWebCryptoError = function onWebCryptoError(data, key, iv) {\n        this.useSoftware = true;\n        this.logEnabled = true;\n        this.softwareDecrypt(data, key, iv);\n        var decryptResult = this.flush();\n        if (decryptResult) {\n          return decryptResult.buffer;\n        }\n        throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data');\n      };\n      _proto.getValidChunk = function getValidChunk(data) {\n        var currentChunk = data;\n        var splitPoint = data.length - data.length % CHUNK_SIZE;\n        if (splitPoint !== data.length) {\n          currentChunk = sliceUint8(data, 0, splitPoint);\n          this.remainderData = sliceUint8(data, splitPoint);\n        }\n        return currentChunk;\n      };\n      _proto.logOnce = function logOnce(msg) {\n        if (!this.logEnabled) {\n          return;\n        }\n        logger.log(\"[decrypter]: \" + msg);\n        this.logEnabled = false;\n      };\n      return Decrypter;\n    }();\n\n    /**\n     *  TimeRanges to string helper\n     */\n\n    var TimeRanges = {\n      toString: function toString(r) {\n        var log = '';\n        var len = r.length;\n        for (var i = 0; i < len; i++) {\n          log += \"[\" + r.start(i).toFixed(3) + \"-\" + r.end(i).toFixed(3) + \"]\";\n        }\n        return log;\n      }\n    };\n    var State = {\n      STOPPED: 'STOPPED',\n      IDLE: 'IDLE',\n      KEY_LOADING: 'KEY_LOADING',\n      FRAG_LOADING: 'FRAG_LOADING',\n      FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n      WAITING_TRACK: 'WAITING_TRACK',\n      PARSING: 'PARSING',\n      PARSED: 'PARSED',\n      ENDED: 'ENDED',\n      ERROR: 'ERROR',\n      WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n      WAITING_LEVEL: 'WAITING_LEVEL'\n    };\n    var BaseStreamController = /*#__PURE__*/function (_TaskLoop) {\n      _inheritsLoose(BaseStreamController, _TaskLoop);\n      function BaseStreamController(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {\n        var _this;\n        _this = _TaskLoop.call(this) || this;\n        _this.hls = void 0;\n        _this.fragPrevious = null;\n        _this.fragCurrent = null;\n        _this.fragmentTracker = void 0;\n        _this.transmuxer = null;\n        _this._state = State.STOPPED;\n        _this.playlistType = void 0;\n        _this.media = null;\n        _this.mediaBuffer = null;\n        _this.config = void 0;\n        _this.bitrateTest = false;\n        _this.lastCurrentTime = 0;\n        _this.nextLoadPosition = 0;\n        _this.startPosition = 0;\n        _this.startTimeOffset = null;\n        _this.loadedmetadata = false;\n        _this.retryDate = 0;\n        _this.levels = null;\n        _this.fragmentLoader = void 0;\n        _this.keyLoader = void 0;\n        _this.levelLastLoaded = null;\n        _this.startFragRequested = false;\n        _this.decrypter = void 0;\n        _this.initPTS = [];\n        _this.onvseeking = null;\n        _this.onvended = null;\n        _this.logPrefix = '';\n        _this.log = void 0;\n        _this.warn = void 0;\n        _this.playlistType = playlistType;\n        _this.logPrefix = logPrefix;\n        _this.log = logger.log.bind(logger, logPrefix + \":\");\n        _this.warn = logger.warn.bind(logger, logPrefix + \":\");\n        _this.hls = hls;\n        _this.fragmentLoader = new FragmentLoader(hls.config);\n        _this.keyLoader = keyLoader;\n        _this.fragmentTracker = fragmentTracker;\n        _this.config = hls.config;\n        _this.decrypter = new Decrypter(hls.config);\n        hls.on(Events.MANIFEST_LOADED, _this.onManifestLoaded, _assertThisInitialized(_this));\n        return _this;\n      }\n      var _proto = BaseStreamController.prototype;\n      _proto.doTick = function doTick() {\n        this.onTickEnd();\n      };\n      _proto.onTickEnd = function onTickEnd() {}\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      ;\n\n      _proto.startLoad = function startLoad(startPosition) {};\n      _proto.stopLoad = function stopLoad() {\n        this.fragmentLoader.abort();\n        this.keyLoader.abort(this.playlistType);\n        var frag = this.fragCurrent;\n        if (frag != null && frag.loader) {\n          frag.abortRequests();\n          this.fragmentTracker.removeFragment(frag);\n        }\n        this.resetTransmuxer();\n        this.fragCurrent = null;\n        this.fragPrevious = null;\n        this.clearInterval();\n        this.clearNextTick();\n        this.state = State.STOPPED;\n      };\n      _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {\n        // If playlist is live, there is another buffered range after the current range, nothing buffered, media is detached,\n        // of nothing loading/loaded return false\n        if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {\n          return false;\n        }\n        var partList = levelDetails.partList;\n        // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n        // check instead if the last part is buffered.\n        if (partList != null && partList.length) {\n          var lastPart = partList[partList.length - 1];\n\n          // Checking the midpoint of the part for potential margin of error and related issues.\n          // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n          // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n          // part mismatches for independent audio and video playlists/segments.\n          var lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n          return lastPartBuffered;\n        }\n        var playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n        return this.fragmentTracker.isEndListAppended(playlistType);\n      };\n      _proto.getLevelDetails = function getLevelDetails() {\n        if (this.levels && this.levelLastLoaded !== null) {\n          var _this$levels$this$lev;\n          return (_this$levels$this$lev = this.levels[this.levelLastLoaded]) == null ? void 0 : _this$levels$this$lev.details;\n        }\n      };\n      _proto.onMediaAttached = function onMediaAttached(event, data) {\n        var media = this.media = this.mediaBuffer = data.media;\n        this.onvseeking = this.onMediaSeeking.bind(this);\n        this.onvended = this.onMediaEnded.bind(this);\n        media.addEventListener('seeking', this.onvseeking);\n        media.addEventListener('ended', this.onvended);\n        var config = this.config;\n        if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n          this.startLoad(config.startPosition);\n        }\n      };\n      _proto.onMediaDetaching = function onMediaDetaching() {\n        var media = this.media;\n        if (media != null && media.ended) {\n          this.log('MSE detaching and video ended, reset startPosition');\n          this.startPosition = this.lastCurrentTime = 0;\n        }\n\n        // remove video listeners\n        if (media && this.onvseeking && this.onvended) {\n          media.removeEventListener('seeking', this.onvseeking);\n          media.removeEventListener('ended', this.onvended);\n          this.onvseeking = this.onvended = null;\n        }\n        if (this.keyLoader) {\n          this.keyLoader.detach();\n        }\n        this.media = this.mediaBuffer = null;\n        this.loadedmetadata = false;\n        this.fragmentTracker.removeAllFragments();\n        this.stopLoad();\n      };\n      _proto.onMediaSeeking = function onMediaSeeking() {\n        var config = this.config,\n          fragCurrent = this.fragCurrent,\n          media = this.media,\n          mediaBuffer = this.mediaBuffer,\n          state = this.state;\n        var currentTime = media ? media.currentTime : 0;\n        var bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n        this.log(\"media seeking to \" + (isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime) + \", state: \" + state);\n        if (this.state === State.ENDED) {\n          this.resetLoadingState();\n        } else if (fragCurrent) {\n          // Seeking while frag load is in progress\n          var tolerance = config.maxFragLookUpTolerance;\n          var fragStartOffset = fragCurrent.start - tolerance;\n          var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n          // if seeking out of buffered range or into new one\n          if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n            var pastFragment = currentTime > fragEndOffset;\n            // if the seek position is outside the current fragment range\n            if (currentTime < fragStartOffset || pastFragment) {\n              if (pastFragment && fragCurrent.loader) {\n                this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');\n                fragCurrent.abortRequests();\n                this.resetLoadingState();\n              }\n              this.fragPrevious = null;\n            }\n          }\n        }\n        if (media) {\n          // Remove gap fragments\n          this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);\n          this.lastCurrentTime = currentTime;\n        }\n\n        // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n        if (!this.loadedmetadata && !bufferInfo.len) {\n          this.nextLoadPosition = this.startPosition = currentTime;\n        }\n\n        // Async tick to speed up processing\n        this.tickImmediate();\n      };\n      _proto.onMediaEnded = function onMediaEnded() {\n        // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n        this.startPosition = this.lastCurrentTime = 0;\n      };\n      _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n        this.startTimeOffset = data.startTimeOffset;\n        this.initPTS = [];\n      };\n      _proto.onHandlerDestroying = function onHandlerDestroying() {\n        this.stopLoad();\n        _TaskLoop.prototype.onHandlerDestroying.call(this);\n      };\n      _proto.onHandlerDestroyed = function onHandlerDestroyed() {\n        this.state = State.STOPPED;\n        if (this.fragmentLoader) {\n          this.fragmentLoader.destroy();\n        }\n        if (this.keyLoader) {\n          this.keyLoader.destroy();\n        }\n        if (this.decrypter) {\n          this.decrypter.destroy();\n        }\n        this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n        _TaskLoop.prototype.onHandlerDestroyed.call(this);\n      };\n      _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {\n        this._loadFragForPlayback(frag, level, targetBufferTime);\n      };\n      _proto._loadFragForPlayback = function _loadFragForPlayback(frag, level, targetBufferTime) {\n        var _this2 = this;\n        var progressCallback = function progressCallback(data) {\n          if (_this2.fragContextChanged(frag)) {\n            _this2.warn(\"Fragment \" + frag.sn + (data.part ? ' p: ' + data.part.index : '') + \" of level \" + frag.level + \" was dropped during download.\");\n            _this2.fragmentTracker.removeFragment(frag);\n            return;\n          }\n          frag.stats.chunkCount++;\n          _this2._handleFragmentLoadProgress(data);\n        };\n        this._doFragLoad(frag, level, targetBufferTime, progressCallback).then(function (data) {\n          if (!data) {\n            // if we're here we probably needed to backtrack or are waiting for more parts\n            return;\n          }\n          var state = _this2.state;\n          if (_this2.fragContextChanged(frag)) {\n            if (state === State.FRAG_LOADING || !_this2.fragCurrent && state === State.PARSING) {\n              _this2.fragmentTracker.removeFragment(frag);\n              _this2.state = State.IDLE;\n            }\n            return;\n          }\n          if ('payload' in data) {\n            _this2.log(\"Loaded fragment \" + frag.sn + \" of level \" + frag.level);\n            _this2.hls.trigger(Events.FRAG_LOADED, data);\n          }\n\n          // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n          _this2._handleFragmentLoadComplete(data);\n        }).catch(function (reason) {\n          if (_this2.state === State.STOPPED || _this2.state === State.ERROR) {\n            return;\n          }\n          _this2.warn(reason);\n          _this2.resetFragmentLoading(frag);\n        });\n      };\n      _proto.clearTrackerIfNeeded = function clearTrackerIfNeeded(frag) {\n        var _this$mediaBuffer;\n        var fragmentTracker = this.fragmentTracker;\n        var fragState = fragmentTracker.getState(frag);\n        if (fragState === FragmentState.APPENDING) {\n          // Lower the buffer size and try again\n          var playlistType = frag.type;\n          var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n          var minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);\n          if (this.reduceMaxBufferLength(minForwardBufferLength)) {\n            fragmentTracker.removeFragment(frag);\n          }\n        } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {\n          // Stop gap for bad tracker / buffer flush behavior\n          fragmentTracker.removeAllFragments();\n        } else if (fragmentTracker.hasParts(frag.type)) {\n          // In low latency mode, remove fragments for which only some parts were buffered\n          fragmentTracker.detectPartialFragments({\n            frag: frag,\n            part: null,\n            stats: frag.stats,\n            id: frag.type\n          });\n          if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {\n            fragmentTracker.removeFragment(frag);\n          }\n        }\n      };\n      _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {\n        if (type === void 0) {\n          type = null;\n        }\n        if (!(startOffset - endOffset)) {\n          return;\n        }\n        // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n        // passing a null type flushes both buffers\n        var flushScope = {\n          startOffset: startOffset,\n          endOffset: endOffset,\n          type: type\n        };\n        this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);\n      };\n      _proto._loadInitSegment = function _loadInitSegment(frag, level) {\n        var _this3 = this;\n        this._doFragLoad(frag, level).then(function (data) {\n          if (!data || _this3.fragContextChanged(frag) || !_this3.levels) {\n            throw new Error('init load aborted');\n          }\n          return data;\n        }).then(function (data) {\n          var hls = _this3.hls;\n          var payload = data.payload;\n          var decryptData = frag.decryptdata;\n\n          // check to see if the payload needs to be decrypted\n          if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n            var startTime = self.performance.now();\n            // decrypt init segment data\n            return _this3.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(function (err) {\n              hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.FRAG_DECRYPT_ERROR,\n                fatal: false,\n                error: err,\n                reason: err.message,\n                frag: frag\n              });\n              throw err;\n            }).then(function (decryptedData) {\n              var endTime = self.performance.now();\n              hls.trigger(Events.FRAG_DECRYPTED, {\n                frag: frag,\n                payload: decryptedData,\n                stats: {\n                  tstart: startTime,\n                  tdecrypt: endTime\n                }\n              });\n              data.payload = decryptedData;\n              return data;\n            });\n          }\n          return data;\n        }).then(function (data) {\n          var fragCurrent = _this3.fragCurrent,\n            hls = _this3.hls,\n            levels = _this3.levels;\n          if (!levels) {\n            throw new Error('init load aborted, missing levels');\n          }\n          var stats = frag.stats;\n          _this3.state = State.IDLE;\n          level.fragmentError = 0;\n          frag.data = new Uint8Array(data.payload);\n          stats.parsing.start = stats.buffering.start = self.performance.now();\n          stats.parsing.end = stats.buffering.end = self.performance.now();\n\n          // Silence FRAG_BUFFERED event if fragCurrent is null\n          if (data.frag === fragCurrent) {\n            hls.trigger(Events.FRAG_BUFFERED, {\n              stats: stats,\n              frag: fragCurrent,\n              part: null,\n              id: frag.type\n            });\n          }\n          _this3.tick();\n        }).catch(function (reason) {\n          if (_this3.state === State.STOPPED || _this3.state === State.ERROR) {\n            return;\n          }\n          _this3.warn(reason);\n          _this3.resetFragmentLoading(frag);\n        });\n      };\n      _proto.fragContextChanged = function fragContextChanged(frag) {\n        var fragCurrent = this.fragCurrent;\n        return !frag || !fragCurrent || frag.level !== fragCurrent.level || frag.sn !== fragCurrent.sn || frag.urlId !== fragCurrent.urlId;\n      };\n      _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {\n        var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;\n        var media = this.mediaBuffer ? this.mediaBuffer : this.media;\n        this.log(\"Buffered \" + frag.type + \" sn: \" + frag.sn + (part ? ' part: ' + part.index : '') + \" of \" + (this.playlistType === PlaylistLevelType.MAIN ? 'level' : 'track') + \" \" + frag.level + \" (frag:[\" + ((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3) + \"-\" + ((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3) + \"] > buffer:\" + (media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : '(detached)') + \")\");\n        this.state = State.IDLE;\n        if (!media) {\n          return;\n        }\n        if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {\n          this.loadedmetadata = true;\n          this.seekToStartPos();\n        }\n        this.tick();\n      };\n      _proto.seekToStartPos = function seekToStartPos() {};\n      _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {\n        var transmuxer = this.transmuxer;\n        if (!transmuxer) {\n          return;\n        }\n        var frag = fragLoadedEndData.frag,\n          part = fragLoadedEndData.part,\n          partsLoaded = fragLoadedEndData.partsLoaded;\n        // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n        var complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(function (fragLoaded) {\n          return !fragLoaded;\n        });\n        var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n        transmuxer.flush(chunkMeta);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      ;\n\n      _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {};\n      _proto._doFragLoad = function _doFragLoad(frag, level, targetBufferTime, progressCallback) {\n        var _frag$decryptdata,\n          _this4 = this;\n        if (targetBufferTime === void 0) {\n          targetBufferTime = null;\n        }\n        var details = level == null ? void 0 : level.details;\n        if (!this.levels || !details) {\n          throw new Error(\"frag load aborted, missing level\" + (details ? '' : ' detail') + \"s\");\n        }\n        var keyLoadingPromise = null;\n        if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {\n          this.log(\"Loading key for \" + frag.sn + \" of [\" + details.startSN + \"-\" + details.endSN + \"], \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \" \" + frag.level);\n          this.state = State.KEY_LOADING;\n          this.fragCurrent = frag;\n          keyLoadingPromise = this.keyLoader.load(frag).then(function (keyLoadedData) {\n            if (!_this4.fragContextChanged(keyLoadedData.frag)) {\n              _this4.hls.trigger(Events.KEY_LOADED, keyLoadedData);\n              if (_this4.state === State.KEY_LOADING) {\n                _this4.state = State.IDLE;\n              }\n              return keyLoadedData;\n            }\n          });\n          this.hls.trigger(Events.KEY_LOADING, {\n            frag: frag\n          });\n          if (this.fragCurrent === null) {\n            keyLoadingPromise = Promise.reject(new Error(\"frag load aborted, context changed in KEY_LOADING\"));\n          }\n        } else if (!frag.encrypted && details.encryptedFragments.length) {\n          this.keyLoader.loadClear(frag, details.encryptedFragments);\n        }\n        targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n        if (this.config.lowLatencyMode && frag.sn !== 'initSegment') {\n          var partList = details.partList;\n          if (partList && progressCallback) {\n            if (targetBufferTime > frag.end && details.fragmentHint) {\n              frag = details.fragmentHint;\n            }\n            var partIndex = this.getNextPart(partList, frag, targetBufferTime);\n            if (partIndex > -1) {\n              var part = partList[partIndex];\n              this.log(\"Loading part sn: \" + frag.sn + \" p: \" + part.index + \" cc: \" + frag.cc + \" of playlist [\" + details.startSN + \"-\" + details.endSN + \"] parts [0-\" + partIndex + \"-\" + (partList.length - 1) + \"] \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \": \" + frag.level + \", target: \" + parseFloat(targetBufferTime.toFixed(3)));\n              this.nextLoadPosition = part.start + part.duration;\n              this.state = State.FRAG_LOADING;\n              var _result;\n              if (keyLoadingPromise) {\n                _result = keyLoadingPromise.then(function (keyLoadedData) {\n                  if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData.frag)) {\n                    return null;\n                  }\n                  return _this4.doFragPartsLoad(frag, part, level, progressCallback);\n                }).catch(function (error) {\n                  return _this4.handleFragLoadError(error);\n                });\n              } else {\n                _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(function (error) {\n                  return _this4.handleFragLoadError(error);\n                });\n              }\n              this.hls.trigger(Events.FRAG_LOADING, {\n                frag: frag,\n                part: part,\n                targetBufferTime: targetBufferTime\n              });\n              if (this.fragCurrent === null) {\n                return Promise.reject(new Error(\"frag load aborted, context changed in FRAG_LOADING parts\"));\n              }\n              return _result;\n            } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n              // Fragment hint has no parts\n              return Promise.resolve(null);\n            }\n          }\n        }\n        this.log(\"Loading fragment \" + frag.sn + \" cc: \" + frag.cc + \" \" + (details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : '') + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \": \" + frag.level + \", target: \" + parseFloat(targetBufferTime.toFixed(3)));\n        // Don't update nextLoadPosition for fragments which are not buffered\n        if (isFiniteNumber(frag.sn) && !this.bitrateTest) {\n          this.nextLoadPosition = frag.start + frag.duration;\n        }\n        this.state = State.FRAG_LOADING;\n\n        // Load key before streaming fragment data\n        var dataOnProgress = this.config.progressive;\n        var result;\n        if (dataOnProgress && keyLoadingPromise) {\n          result = keyLoadingPromise.then(function (keyLoadedData) {\n            if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {\n              return null;\n            }\n            return _this4.fragmentLoader.load(frag, progressCallback);\n          }).catch(function (error) {\n            return _this4.handleFragLoadError(error);\n          });\n        } else {\n          // load unencrypted fragment data with progress event,\n          // or handle fragment result after key and fragment are finished loading\n          result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(function (_ref) {\n            var fragLoadedData = _ref[0];\n            if (!dataOnProgress && fragLoadedData && progressCallback) {\n              progressCallback(fragLoadedData);\n            }\n            return fragLoadedData;\n          }).catch(function (error) {\n            return _this4.handleFragLoadError(error);\n          });\n        }\n        this.hls.trigger(Events.FRAG_LOADING, {\n          frag: frag,\n          targetBufferTime: targetBufferTime\n        });\n        if (this.fragCurrent === null) {\n          return Promise.reject(new Error(\"frag load aborted, context changed in FRAG_LOADING\"));\n        }\n        return result;\n      };\n      _proto.doFragPartsLoad = function doFragPartsLoad(frag, fromPart, level, progressCallback) {\n        var _this5 = this;\n        return new Promise(function (resolve, reject) {\n          var _level$details;\n          var partsLoaded = [];\n          var initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;\n          var loadPart = function loadPart(part) {\n            _this5.fragmentLoader.loadPart(frag, part, progressCallback).then(function (partLoadedData) {\n              partsLoaded[part.index] = partLoadedData;\n              var loadedPart = partLoadedData.part;\n              _this5.hls.trigger(Events.FRAG_LOADED, partLoadedData);\n              var nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);\n              if (nextPart) {\n                loadPart(nextPart);\n              } else {\n                return resolve({\n                  frag: frag,\n                  part: loadedPart,\n                  partsLoaded: partsLoaded\n                });\n              }\n            }).catch(reject);\n          };\n          loadPart(fromPart);\n        });\n      };\n      _proto.handleFragLoadError = function handleFragLoadError(error) {\n        if ('data' in error) {\n          var data = error.data;\n          if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {\n            this.handleFragLoadAborted(data.frag, data.part);\n          } else {\n            this.hls.trigger(Events.ERROR, data);\n          }\n        } else {\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.OTHER_ERROR,\n            details: ErrorDetails.INTERNAL_EXCEPTION,\n            err: error,\n            error: error,\n            fatal: true\n          });\n        }\n        return null;\n      };\n      _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {\n        var context = this.getCurrentContext(chunkMeta);\n        if (!context || this.state !== State.PARSING) {\n          if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n            this.state = State.IDLE;\n          }\n          return;\n        }\n        var frag = context.frag,\n          part = context.part,\n          level = context.level;\n        var now = self.performance.now();\n        frag.stats.parsing.end = now;\n        if (part) {\n          part.stats.parsing.end = now;\n        }\n        this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n      };\n      _proto.getCurrentContext = function getCurrentContext(chunkMeta) {\n        var levels = this.levels,\n          fragCurrent = this.fragCurrent;\n        var levelIndex = chunkMeta.level,\n          sn = chunkMeta.sn,\n          partIndex = chunkMeta.part;\n        if (!(levels != null && levels[levelIndex])) {\n          this.warn(\"Levels object was unset while buffering fragment \" + sn + \" of level \" + levelIndex + \". The current chunk will not be buffered.\");\n          return null;\n        }\n        var level = levels[levelIndex];\n        var part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;\n        var frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);\n        if (!frag) {\n          return null;\n        }\n        if (fragCurrent && fragCurrent !== frag) {\n          frag.stats = fragCurrent.stats;\n        }\n        return {\n          frag: frag,\n          part: part,\n          level: level\n        };\n      };\n      _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta) {\n        var _buffer;\n        if (!data || this.state !== State.PARSING) {\n          return;\n        }\n        var data1 = data.data1,\n          data2 = data.data2;\n        var buffer = data1;\n        if (data1 && data2) {\n          // Combine the moof + mdat so that we buffer with a single append\n          buffer = appendUint8Array(data1, data2);\n        }\n        if (!((_buffer = buffer) != null && _buffer.length)) {\n          return;\n        }\n        var segment = {\n          type: data.type,\n          frag: frag,\n          part: part,\n          chunkMeta: chunkMeta,\n          parent: frag.type,\n          data: buffer\n        };\n        this.hls.trigger(Events.BUFFER_APPENDING, segment);\n        if (data.dropped && data.independent && !part) {\n          // Clear buffer so that we reload previous segments sequentially if required\n          this.flushBufferGap(frag);\n        }\n      };\n      _proto.flushBufferGap = function flushBufferGap(frag) {\n        var media = this.media;\n        if (!media) {\n          return;\n        }\n        // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n        if (!BufferHelper.isBuffered(media, media.currentTime)) {\n          this.flushMainBuffer(0, frag.start);\n          return;\n        }\n        // Remove back-buffer without interrupting playback to allow back tracking\n        var currentTime = media.currentTime;\n        var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n        var fragDuration = frag.duration;\n        var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n        var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n        if (frag.start - start > segmentFraction) {\n          this.flushMainBuffer(start, frag.start);\n        }\n      };\n      _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {\n        var pos = this.getLoadPosition();\n        if (!isFiniteNumber(pos)) {\n          return null;\n        }\n        return this.getFwdBufferInfoAtPos(bufferable, pos, type);\n      };\n      _proto.getFwdBufferInfoAtPos = function getFwdBufferInfoAtPos(bufferable, pos, type) {\n        var maxBufferHole = this.config.maxBufferHole;\n        var bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);\n        // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n        if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n          var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n          if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {\n            return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));\n          }\n        }\n        return bufferInfo;\n      };\n      _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {\n        var config = this.config;\n        var maxBufLen;\n        if (levelBitrate) {\n          maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n        } else {\n          maxBufLen = config.maxBufferLength;\n        }\n        return Math.min(maxBufLen, config.maxMaxBufferLength);\n      };\n      _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold) {\n        var config = this.config;\n        var minLength = threshold || config.maxBufferLength;\n        if (config.maxMaxBufferLength >= minLength) {\n          // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n          config.maxMaxBufferLength /= 2;\n          this.warn(\"Reduce max buffer length to \" + config.maxMaxBufferLength + \"s\");\n          return true;\n        }\n        return false;\n      };\n      _proto.getAppendedFrag = function getAppendedFrag(position, playlistType) {\n        var fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);\n        if (fragOrPart && 'fragment' in fragOrPart) {\n          return fragOrPart.fragment;\n        }\n        return fragOrPart;\n      };\n      _proto.getNextFragment = function getNextFragment(pos, levelDetails) {\n        var fragments = levelDetails.fragments;\n        var fragLen = fragments.length;\n        if (!fragLen) {\n          return null;\n        }\n\n        // find fragment index, contiguous with end of buffer position\n        var config = this.config;\n        var start = fragments[0].start;\n        var frag;\n        if (levelDetails.live) {\n          var initialLiveManifestSize = config.initialLiveManifestSize;\n          if (fragLen < initialLiveManifestSize) {\n            this.warn(\"Not enough fragments to start playback (have: \" + fragLen + \", need: \" + initialLiveManifestSize + \")\");\n            return null;\n          }\n          // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n          // In order to discover the range, we load the best matching fragment for that level and demux it.\n          // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n          // we get the fragment matching that start time\n          if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1) {\n            frag = this.getInitialLiveFragment(levelDetails, fragments);\n            this.startPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;\n          }\n        } else if (pos <= start) {\n          // VoD playlist: if loadPosition before start of playlist, load first fragment\n          frag = fragments[0];\n        }\n\n        // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n        if (!frag) {\n          var end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;\n          frag = this.getFragmentAtPosition(pos, end, levelDetails);\n        }\n        return this.mapToInitFragWhenRequired(frag);\n      };\n      _proto.isLoopLoading = function isLoopLoading(frag, targetBufferTime) {\n        var trackerState = this.fragmentTracker.getState(frag);\n        return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;\n      };\n      _proto.getNextFragmentLoopLoading = function getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {\n        var gapStart = frag.gap;\n        var nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);\n        if (nextFragment === null) {\n          return nextFragment;\n        }\n        frag = nextFragment;\n        if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {\n          // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length\n          var nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);\n          if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {\n            // Returning here might result in not finding an audio and video candiate to skip to\n            this.log(\"buffer full after gaps in \\\"\" + playlistType + \"\\\" playlist starting at sn: \" + frag.sn);\n            return null;\n          }\n        }\n        return frag;\n      };\n      _proto.mapToInitFragWhenRequired = function mapToInitFragWhenRequired(frag) {\n        // If an initSegment is present, it must be buffered first\n        if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {\n          return frag.initSegment;\n        }\n        return frag;\n      };\n      _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {\n        var nextPart = -1;\n        var contiguous = false;\n        var independentAttrOmitted = true;\n        for (var i = 0, len = partList.length; i < len; i++) {\n          var part = partList[i];\n          independentAttrOmitted = independentAttrOmitted && !part.independent;\n          if (nextPart > -1 && targetBufferTime < part.start) {\n            break;\n          }\n          var loaded = part.loaded;\n          if (loaded) {\n            nextPart = -1;\n          } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n            nextPart = i;\n          }\n          contiguous = loaded;\n        }\n        return nextPart;\n      };\n      _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {\n        var lastPart = partList[partList.length - 1];\n        return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n      }\n\n      /*\n       This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n       \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n       start and end times for each fragment in the playlist (after which this method will not need to be called).\n      */;\n      _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails, fragments) {\n        var fragPrevious = this.fragPrevious;\n        var frag = null;\n        if (fragPrevious) {\n          if (levelDetails.hasProgramDateTime) {\n            // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n            this.log(\"Live playlist, switching playlist, load frag with same PDT: \" + fragPrevious.programDateTime);\n            frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n          }\n          if (!frag) {\n            // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n            var targetSN = fragPrevious.sn + 1;\n            if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n              var fragNext = fragments[targetSN - levelDetails.startSN];\n              // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n              if (fragPrevious.cc === fragNext.cc) {\n                frag = fragNext;\n                this.log(\"Live playlist, switching playlist, load frag with next SN: \" + frag.sn);\n              }\n            }\n            // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n            // will have the wrong start times\n            if (!frag) {\n              frag = findFragWithCC(fragments, fragPrevious.cc);\n              if (frag) {\n                this.log(\"Live playlist, switching playlist, load frag with same CC: \" + frag.sn);\n              }\n            }\n          }\n        } else {\n          // Find a new start fragment when fragPrevious is null\n          var liveStart = this.hls.liveSyncPosition;\n          if (liveStart !== null) {\n            frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n          }\n        }\n        return frag;\n      }\n\n      /*\n      This method finds the best matching fragment given the provided position.\n       */;\n      _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {\n        var config = this.config;\n        var fragPrevious = this.fragPrevious;\n        var fragments = levelDetails.fragments,\n          endSN = levelDetails.endSN;\n        var fragmentHint = levelDetails.fragmentHint;\n        var tolerance = config.maxFragLookUpTolerance;\n        var partList = levelDetails.partList;\n        var loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);\n        if (loadingParts && fragmentHint && !this.bitrateTest) {\n          // Include incomplete fragment with parts at end\n          fragments = fragments.concat(fragmentHint);\n          endSN = fragmentHint.sn;\n        }\n        var frag;\n        if (bufferEnd < end) {\n          var lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;\n          // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n          // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n          frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);\n        } else {\n          // reach end of playlist\n          frag = fragments[fragments.length - 1];\n        }\n        if (frag) {\n          var curSNIdx = frag.sn - levelDetails.startSN;\n          // Move fragPrevious forward to support forcing the next fragment to load\n          // when the buffer catches up to a previously buffered range.\n          var fragState = this.fragmentTracker.getState(frag);\n          if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {\n            fragPrevious = frag;\n          }\n          if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {\n            // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n            // non-uniform fragment durations\n            var sameLevel = fragPrevious && frag.level === fragPrevious.level;\n            if (sameLevel) {\n              var nextFrag = fragments[curSNIdx + 1];\n              if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {\n                frag = nextFrag;\n              } else {\n                frag = null;\n              }\n            }\n          }\n        }\n        return frag;\n      };\n      _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {\n        var config = this.config,\n          media = this.media;\n        if (!media) {\n          return;\n        }\n        var liveSyncPosition = this.hls.liveSyncPosition;\n        var currentTime = media.currentTime;\n        var start = levelDetails.fragments[0].start;\n        var end = levelDetails.edge;\n        var withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n        // Continue if we can seek forward to sync position or if current time is outside of sliding window\n        if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n          // Continue if buffer is starving or if current time is behind max latency\n          var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n          if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n            if (!this.loadedmetadata) {\n              this.nextLoadPosition = liveSyncPosition;\n            }\n            // Only seek if ready and there is not a significant forward buffer available for playback\n            if (media.readyState) {\n              this.warn(\"Playback: \" + currentTime.toFixed(3) + \" is located too far from the end of live sliding playlist: \" + end + \", reset currentTime to : \" + liveSyncPosition.toFixed(3));\n              media.currentTime = liveSyncPosition;\n            }\n          }\n        }\n      };\n      _proto.alignPlaylists = function alignPlaylists(details, previousDetails) {\n        var levels = this.levels,\n          levelLastLoaded = this.levelLastLoaded,\n          fragPrevious = this.fragPrevious;\n        var lastLevel = levelLastLoaded !== null ? levels[levelLastLoaded] : null;\n\n        // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n        //  this could all go in level-helper mergeDetails()\n        var length = details.fragments.length;\n        if (!length) {\n          this.warn(\"No fragments in live playlist\");\n          return 0;\n        }\n        var slidingStart = details.fragments[0].start;\n        var firstLevelLoad = !previousDetails;\n        var aligned = details.alignedSliding && isFiniteNumber(slidingStart);\n        if (firstLevelLoad || !aligned && !slidingStart) {\n          alignStream(fragPrevious, lastLevel, details);\n          var alignedSlidingStart = details.fragments[0].start;\n          this.log(\"Live playlist sliding: \" + alignedSlidingStart.toFixed(2) + \" start-sn: \" + (previousDetails ? previousDetails.startSN : 'na') + \"->\" + details.startSN + \" prev-sn: \" + (fragPrevious ? fragPrevious.sn : 'na') + \" fragments: \" + length);\n          return alignedSlidingStart;\n        }\n        return slidingStart;\n      };\n      _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {\n        // Wait for Low-Latency CDN Tune-in to get an updated playlist\n        var advancePartLimit = 3;\n        return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n      };\n      _proto.setStartPosition = function setStartPosition(details, sliding) {\n        // compute start position if set to -1. use it straight away if value is defined\n        var startPosition = this.startPosition;\n        if (startPosition < sliding) {\n          startPosition = -1;\n        }\n        if (startPosition === -1 || this.lastCurrentTime === -1) {\n          // Use Playlist EXT-X-START:TIME-OFFSET when set\n          // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match\n          var offsetInMultivariantPlaylist = this.startTimeOffset !== null;\n          var startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;\n          if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {\n            startPosition = sliding + startTimeOffset;\n            if (startTimeOffset < 0) {\n              startPosition += details.totalduration;\n            }\n            startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n            this.log(\"Start time offset \" + startTimeOffset + \" found in \" + (offsetInMultivariantPlaylist ? 'multivariant' : 'media') + \" playlist, adjust startPosition to \" + startPosition);\n            this.startPosition = startPosition;\n          } else if (details.live) {\n            // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n            // not been specified via the config or an as an argument to startLoad (#3736).\n            startPosition = this.hls.liveSyncPosition || sliding;\n          } else {\n            this.startPosition = startPosition = 0;\n          }\n          this.lastCurrentTime = startPosition;\n        }\n        this.nextLoadPosition = startPosition;\n      };\n      _proto.getLoadPosition = function getLoadPosition() {\n        var media = this.media;\n        // if we have not yet loaded any fragment, start loading from start position\n        var pos = 0;\n        if (this.loadedmetadata && media) {\n          pos = media.currentTime;\n        } else if (this.nextLoadPosition) {\n          pos = this.nextLoadPosition;\n        }\n        return pos;\n      };\n      _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {\n        if (this.transmuxer && frag.sn !== 'initSegment' && frag.stats.aborted) {\n          this.warn(\"Fragment \" + frag.sn + (part ? ' part ' + part.index : '') + \" of level \" + frag.level + \" was aborted\");\n          this.resetFragmentLoading(frag);\n        }\n      };\n      _proto.resetFragmentLoading = function resetFragmentLoading(frag) {\n        if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n          this.state = State.IDLE;\n        }\n      };\n      _proto.onFragmentOrKeyLoadError = function onFragmentOrKeyLoadError(filterType, data) {\n        if (data.chunkMeta && !data.frag) {\n          var context = this.getCurrentContext(data.chunkMeta);\n          if (context) {\n            data.frag = context.frag;\n          }\n        }\n        var frag = data.frag;\n        // Handle frag error related to caller's filterType\n        if (!frag || frag.type !== filterType || !this.levels) {\n          return;\n        }\n        if (this.fragContextChanged(frag)) {\n          var _this$fragCurrent2;\n          this.warn(\"Frag load error must match current frag to retry \" + frag.url + \" > \" + ((_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url));\n          return;\n        }\n        var gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;\n        if (gapTagEncountered) {\n          this.fragmentTracker.fragBuffered(frag, true);\n        }\n        // keep retrying until the limit will be reached\n        var errorAction = data.errorAction;\n        var _ref2 = errorAction || {},\n          action = _ref2.action,\n          _ref2$retryCount = _ref2.retryCount,\n          retryCount = _ref2$retryCount === void 0 ? 0 : _ref2$retryCount,\n          retryConfig = _ref2.retryConfig;\n        if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {\n          if (!this.loadedmetadata) {\n            this.startFragRequested = false;\n            this.nextLoadPosition = this.startPosition;\n          }\n          var delay = getRetryDelay(retryConfig, retryCount);\n          this.warn(\"Fragment \" + frag.sn + \" of \" + filterType + \" \" + frag.level + \" errored with \" + data.details + \", retrying loading \" + (retryCount + 1) + \"/\" + retryConfig.maxNumRetry + \" in \" + delay + \"ms\");\n          errorAction.resolved = true;\n          this.retryDate = self.performance.now() + delay;\n          this.state = State.FRAG_LOADING_WAITING_RETRY;\n        } else if (retryConfig && errorAction) {\n          this.resetFragmentErrors(filterType);\n          if (retryCount < retryConfig.maxNumRetry) {\n            // Network retry is skipped when level switch is preferred\n            if (!gapTagEncountered) {\n              errorAction.resolved = true;\n            }\n          } else {\n            logger.warn(data.details + \" reached or exceeded max retry (\" + retryCount + \")\");\n          }\n        } else {\n          this.state = State.ERROR;\n        }\n        // Perform next async tick sooner to speed up error action resolution\n        this.tickImmediate();\n      };\n      _proto.reduceLengthAndFlushBuffer = function reduceLengthAndFlushBuffer(data) {\n        // if in appending state\n        if (this.state === State.PARSING || this.state === State.PARSED) {\n          var playlistType = data.parent;\n          var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n          // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n          // reduce max buf len if current position is buffered\n          var buffered = bufferedInfo && bufferedInfo.len > 0.5;\n          if (buffered) {\n            this.reduceMaxBufferLength(bufferedInfo.len);\n          }\n          var flushBuffer = !buffered;\n          if (flushBuffer) {\n            // current position is not buffered, but browser is still complaining about buffer full error\n            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n            // in that case flush the whole audio buffer to recover\n            this.warn(\"Buffer full error while media.currentTime is not buffered, flush \" + playlistType + \" buffer\");\n          }\n          if (data.frag) {\n            this.fragmentTracker.removeFragment(data.frag);\n            this.nextLoadPosition = data.frag.start;\n          }\n          this.resetLoadingState();\n          return flushBuffer;\n        }\n        return false;\n      };\n      _proto.resetFragmentErrors = function resetFragmentErrors(filterType) {\n        if (filterType === PlaylistLevelType.AUDIO) {\n          // Reset current fragment since audio track audio is essential and may not have a fail-over track\n          this.fragCurrent = null;\n        }\n        // Fragment errors that result in a level switch or redundant fail-over\n        // should reset the stream controller state to idle\n        if (!this.loadedmetadata) {\n          this.startFragRequested = false;\n        }\n        if (this.state !== State.STOPPED) {\n          this.state = State.IDLE;\n        }\n      };\n      _proto.afterBufferFlushed = function afterBufferFlushed(media, bufferType, playlistType) {\n        if (!media) {\n          return;\n        }\n        // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n        // (so that we will check against video.buffered ranges in case of alt audio track)\n        var bufferedTimeRanges = BufferHelper.getBuffered(media);\n        this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n        if (this.state === State.ENDED) {\n          this.resetLoadingState();\n        }\n      };\n      _proto.resetLoadingState = function resetLoadingState() {\n        this.log('Reset loading state');\n        this.fragCurrent = null;\n        this.fragPrevious = null;\n        this.state = State.IDLE;\n      };\n      _proto.resetStartWhenNotLoaded = function resetStartWhenNotLoaded(level) {\n        // if loadedmetadata is not set, it means that first frag request failed\n        // in that case, reset startFragRequested flag\n        if (!this.loadedmetadata) {\n          this.startFragRequested = false;\n          var details = this.levels ? this.levels[level].details : null;\n          if (details != null && details.live) {\n            // Update the start position and return to IDLE to recover live start\n            this.startPosition = -1;\n            this.setStartPosition(details, 0);\n            this.resetLoadingState();\n          } else {\n            this.nextLoadPosition = this.startPosition;\n          }\n        }\n      };\n      _proto.resetWhenMissingContext = function resetWhenMissingContext(chunkMeta) {\n        this.warn(\"The loading context changed while buffering fragment \" + chunkMeta.sn + \" of level \" + chunkMeta.level + \". This chunk will not be buffered.\");\n        this.removeUnbufferedFrags();\n        this.resetStartWhenNotLoaded(chunkMeta.level);\n        this.resetLoadingState();\n      };\n      _proto.removeUnbufferedFrags = function removeUnbufferedFrags(start) {\n        if (start === void 0) {\n          start = 0;\n        }\n        this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);\n      };\n      _proto.updateLevelTiming = function updateLevelTiming(frag, part, level, partial) {\n        var _this6 = this,\n          _this$transmuxer;\n        var details = level.details;\n        if (!details) {\n          this.warn('level.details undefined');\n          return;\n        }\n        var parsed = Object.keys(frag.elementaryStreams).reduce(function (result, type) {\n          var info = frag.elementaryStreams[type];\n          if (info) {\n            var parsedDuration = info.endPTS - info.startPTS;\n            if (parsedDuration <= 0) {\n              // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n              // The new transmuxer will be configured with a time offset matching the next fragment start,\n              // preventing the timeline from shifting.\n              _this6.warn(\"Could not parse fragment \" + frag.sn + \" \" + type + \" duration reliably (\" + parsedDuration + \")\");\n              return result || false;\n            }\n            var drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n            _this6.hls.trigger(Events.LEVEL_PTS_UPDATED, {\n              details: details,\n              level: level,\n              drift: drift,\n              type: type,\n              frag: frag,\n              start: info.startPTS,\n              end: info.endPTS\n            });\n            return true;\n          }\n          return result;\n        }, false);\n        if (parsed) {\n          level.fragmentError = 0;\n        } else if (((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {\n          var error = new Error(\"Found no media in fragment \" + frag.sn + \" of level \" + level.id + \" resetting transmuxer to fallback to playlist timing\");\n          this.warn(error.message);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: false,\n            error: error,\n            frag: frag,\n            reason: \"Found no media in msn \" + frag.sn + \" of level \\\"\" + level.url + \"\\\"\"\n          });\n          if (!this.hls) {\n            return;\n          }\n          this.resetTransmuxer();\n          // For this error fallthrough. Marking parsed will allow advancing to next fragment.\n        }\n\n        this.state = State.PARSED;\n        this.hls.trigger(Events.FRAG_PARSED, {\n          frag: frag,\n          part: part\n        });\n      };\n      _proto.resetTransmuxer = function resetTransmuxer() {\n        if (this.transmuxer) {\n          this.transmuxer.destroy();\n          this.transmuxer = null;\n        }\n      };\n      _proto.recoverWorkerError = function recoverWorkerError(data) {\n        if (data.event === 'demuxerWorker') {\n          this.resetTransmuxer();\n          this.resetLoadingState();\n        }\n      };\n      _createClass(BaseStreamController, [{\n        key: \"state\",\n        get: function get() {\n          return this._state;\n        },\n        set: function set(nextState) {\n          var previousState = this._state;\n          if (previousState !== nextState) {\n            this._state = nextState;\n            this.log(previousState + \"->\" + nextState);\n          }\n        }\n      }]);\n      return BaseStreamController;\n    }(TaskLoop);\n    function getSourceBuffer() {\n      return self.SourceBuffer || self.WebKitSourceBuffer;\n    }\n\n    /**\n     * @ignore\n     */\n    function isSupported() {\n      var mediaSource = getMediaSource();\n      if (!mediaSource) {\n        return false;\n      }\n      var sourceBuffer = getSourceBuffer();\n      var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n\n      // if SourceBuffer is exposed ensure its API is valid\n      // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n      var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n      return !!isTypeSupported && !!sourceBufferValidAPI;\n    }\n\n    /**\n     * @ignore\n     */\n    function changeTypeSupported() {\n      var _sourceBuffer$prototy;\n      var sourceBuffer = getSourceBuffer();\n      return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n    }\n    function dummyTrack(type, inputTimeScale) {\n      if (type === void 0) {\n        type = '';\n      }\n      if (inputTimeScale === void 0) {\n        inputTimeScale = 90000;\n      }\n      return {\n        type: type,\n        id: -1,\n        pid: -1,\n        inputTimeScale: inputTimeScale,\n        sequenceNumber: -1,\n        samples: [],\n        dropped: 0\n      };\n    }\n    var BaseAudioDemuxer = /*#__PURE__*/function () {\n      function BaseAudioDemuxer() {\n        this._audioTrack = void 0;\n        this._id3Track = void 0;\n        this.frameIndex = 0;\n        this.cachedData = null;\n        this.basePTS = null;\n        this.initPTS = null;\n        this.lastPTS = null;\n      }\n      var _proto = BaseAudioDemuxer.prototype;\n      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        this._id3Track = {\n          type: 'id3',\n          id: 3,\n          pid: -1,\n          inputTimeScale: 90000,\n          sequenceNumber: 0,\n          samples: [],\n          dropped: 0\n        };\n      };\n      _proto.resetTimeStamp = function resetTimeStamp(deaultTimestamp) {\n        this.initPTS = deaultTimestamp;\n        this.resetContiguity();\n      };\n      _proto.resetContiguity = function resetContiguity() {\n        this.basePTS = null;\n        this.lastPTS = null;\n        this.frameIndex = 0;\n      };\n      _proto.canParse = function canParse(data, offset) {\n        return false;\n      };\n      _proto.appendFrame = function appendFrame(track, data, offset) {}\n\n      // feed incoming data to the front of the parsing pipeline\n      ;\n\n      _proto.demux = function demux(data, timeOffset) {\n        if (this.cachedData) {\n          data = appendUint8Array(this.cachedData, data);\n          this.cachedData = null;\n        }\n        var id3Data = getID3Data(data, 0);\n        var offset = id3Data ? id3Data.length : 0;\n        var lastDataIndex;\n        var track = this._audioTrack;\n        var id3Track = this._id3Track;\n        var timestamp = id3Data ? getTimeStamp(id3Data) : undefined;\n        var length = data.length;\n        if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {\n          this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n          this.lastPTS = this.basePTS;\n        }\n        if (this.lastPTS === null) {\n          this.lastPTS = this.basePTS;\n        }\n\n        // more expressive than alternative: id3Data?.length\n        if (id3Data && id3Data.length > 0) {\n          id3Track.samples.push({\n            pts: this.lastPTS,\n            dts: this.lastPTS,\n            data: id3Data,\n            type: MetadataSchema.audioId3,\n            duration: Number.POSITIVE_INFINITY\n          });\n        }\n        while (offset < length) {\n          if (this.canParse(data, offset)) {\n            var frame = this.appendFrame(track, data, offset);\n            if (frame) {\n              this.frameIndex++;\n              this.lastPTS = frame.sample.pts;\n              offset += frame.length;\n              lastDataIndex = offset;\n            } else {\n              offset = length;\n            }\n          } else if (canParse$2(data, offset)) {\n            // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n            id3Data = getID3Data(data, offset);\n            id3Track.samples.push({\n              pts: this.lastPTS,\n              dts: this.lastPTS,\n              data: id3Data,\n              type: MetadataSchema.audioId3,\n              duration: Number.POSITIVE_INFINITY\n            });\n            offset += id3Data.length;\n            lastDataIndex = offset;\n          } else {\n            offset++;\n          }\n          if (offset === length && lastDataIndex !== length) {\n            var partialData = sliceUint8(data, lastDataIndex);\n            if (this.cachedData) {\n              this.cachedData = appendUint8Array(this.cachedData, partialData);\n            } else {\n              this.cachedData = partialData;\n            }\n          }\n        }\n        return {\n          audioTrack: track,\n          videoTrack: dummyTrack(),\n          id3Track: id3Track,\n          textTrack: dummyTrack()\n        };\n      };\n      _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n        return Promise.reject(new Error(\"[\" + this + \"] This demuxer does not support Sample-AES decryption\"));\n      };\n      _proto.flush = function flush(timeOffset) {\n        // Parse cache in case of remaining frames.\n        var cachedData = this.cachedData;\n        if (cachedData) {\n          this.cachedData = null;\n          this.demux(cachedData, 0);\n        }\n        return {\n          audioTrack: this._audioTrack,\n          videoTrack: dummyTrack(),\n          id3Track: this._id3Track,\n          textTrack: dummyTrack()\n        };\n      };\n      _proto.destroy = function destroy() {};\n      return BaseAudioDemuxer;\n    }();\n    /**\n     * Initialize PTS\n     * <p>\n     *    use timestamp unless it is undefined, NaN or Infinity\n     * </p>\n     */\n    var initPTSFn = function initPTSFn(timestamp, timeOffset, initPTS) {\n      if (isFiniteNumber(timestamp)) {\n        return timestamp * 90;\n      }\n      var init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;\n      return timeOffset * 90000 + init90kHz;\n    };\n\n    /**\n     * ADTS parser helper\n     * @link https://wiki.multimedia.cx/index.php?title=ADTS\n     */\n    function getAudioConfig(observer, data, offset, audioCodec) {\n      var adtsObjectType;\n      var adtsExtensionSamplingIndex;\n      var adtsChannelConfig;\n      var config;\n      var userAgent = navigator.userAgent.toLowerCase();\n      var manifestCodec = audioCodec;\n      var adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n      // byte 2\n      adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n      var adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\n      if (adtsSamplingIndex > adtsSamplingRates.length - 1) {\n        observer.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: true,\n          reason: \"invalid ADTS sampling index:\" + adtsSamplingIndex\n        });\n        return;\n      }\n      adtsChannelConfig = (data[offset + 2] & 0x01) << 2;\n      // byte 3\n      adtsChannelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n      logger.log(\"manifest codec:\" + audioCodec + \", ADTS type:\" + adtsObjectType + \", samplingIndex:\" + adtsSamplingIndex);\n      // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n      if (/firefox/i.test(userAgent)) {\n        if (adtsSamplingIndex >= 6) {\n          adtsObjectType = 5;\n          config = new Array(4);\n          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n          // there is a factor 2 between frame sample rate and output sample rate\n          // multiply frequency by 2 (see table below, equivalent to substract 3)\n          adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n        } else {\n          adtsObjectType = 2;\n          config = new Array(2);\n          adtsExtensionSamplingIndex = adtsSamplingIndex;\n        }\n        // Android : always use AAC\n      } else if (userAgent.indexOf('android') !== -1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n        adtsExtensionSamplingIndex = adtsSamplingIndex;\n      } else {\n        /*  for other browsers (Chrome/Vivaldi/Opera ...)\n            always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n        */\n        adtsObjectType = 5;\n        config = new Array(4);\n        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n        if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSamplingIndex >= 6) {\n          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n          // there is a factor 2 between frame sample rate and output sample rate\n          // multiply frequency by 2 (see table below, equivalent to substract 3)\n          adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n        } else {\n          // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n          // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n          if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {\n            adtsObjectType = 2;\n            config = new Array(2);\n          }\n          adtsExtensionSamplingIndex = adtsSamplingIndex;\n        }\n      }\n      /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n          ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()\n        Audio Profile / Audio Object Type\n        0: Null\n        1: AAC Main\n        2: AAC LC (Low Complexity)\n        3: AAC SSR (Scalable Sample Rate)\n        4: AAC LTP (Long Term Prediction)\n        5: SBR (Spectral Band Replication)\n        6: AAC Scalable\n       sampling freq\n        0: 96000 Hz\n        1: 88200 Hz\n        2: 64000 Hz\n        3: 48000 Hz\n        4: 44100 Hz\n        5: 32000 Hz\n        6: 24000 Hz\n        7: 22050 Hz\n        8: 16000 Hz\n        9: 12000 Hz\n        10: 11025 Hz\n        11: 8000 Hz\n        12: 7350 Hz\n        13: Reserved\n        14: Reserved\n        15: frequency is written explictly\n        Channel Configurations\n        These are the channel configurations:\n        0: Defined in AOT Specifc Config\n        1: 1 channel: front-center\n        2: 2 channels: front-left, front-right\n      */\n      // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n      config[0] = adtsObjectType << 3;\n      // samplingFrequencyIndex\n      config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\n      config[1] |= (adtsSamplingIndex & 0x01) << 7;\n      // channelConfiguration\n      config[1] |= adtsChannelConfig << 3;\n      if (adtsObjectType === 5) {\n        // adtsExtensionSamplingIndex\n        config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\n        config[2] = (adtsExtensionSamplingIndex & 0x01) << 7;\n        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n        config[2] |= 2 << 2;\n        config[3] = 0;\n      }\n      return {\n        config: config,\n        samplerate: adtsSamplingRates[adtsSamplingIndex],\n        channelCount: adtsChannelConfig,\n        codec: 'mp4a.40.' + adtsObjectType,\n        manifestCodec: manifestCodec\n      };\n    }\n    function isHeaderPattern$1(data, offset) {\n      return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n    }\n    function getHeaderLength(data, offset) {\n      return data[offset + 1] & 0x01 ? 7 : 9;\n    }\n    function getFullFrameLength(data, offset) {\n      return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n    }\n    function canGetFrameLength(data, offset) {\n      return offset + 5 < data.length;\n    }\n    function isHeader$1(data, offset) {\n      // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n      // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n      // More info https://wiki.multimedia.cx/index.php?title=ADTS\n      return offset + 1 < data.length && isHeaderPattern$1(data, offset);\n    }\n    function canParse$1(data, offset) {\n      return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n    }\n    function probe$1(data, offset) {\n      // same as isHeader but we also check that ADTS frame follows last ADTS frame\n      // or end of data is reached\n      if (isHeader$1(data, offset)) {\n        // ADTS header Length\n        var headerLength = getHeaderLength(data, offset);\n        if (offset + headerLength >= data.length) {\n          return false;\n        }\n        // ADTS frame Length\n        var frameLength = getFullFrameLength(data, offset);\n        if (frameLength <= headerLength) {\n          return false;\n        }\n        var newOffset = offset + frameLength;\n        return newOffset === data.length || isHeader$1(data, newOffset);\n      }\n      return false;\n    }\n    function initTrackConfig(track, observer, data, offset, audioCodec) {\n      if (!track.samplerate) {\n        var config = getAudioConfig(observer, data, offset, audioCodec);\n        if (!config) {\n          return;\n        }\n        track.config = config.config;\n        track.samplerate = config.samplerate;\n        track.channelCount = config.channelCount;\n        track.codec = config.codec;\n        track.manifestCodec = config.manifestCodec;\n        logger.log(\"parsed codec:\" + track.codec + \", rate:\" + config.samplerate + \", channels:\" + config.channelCount);\n      }\n    }\n    function getFrameDuration(samplerate) {\n      return 1024 * 90000 / samplerate;\n    }\n    function parseFrameHeader(data, offset) {\n      // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n      var headerLength = getHeaderLength(data, offset);\n      if (offset + headerLength <= data.length) {\n        // retrieve frame size\n        var frameLength = getFullFrameLength(data, offset) - headerLength;\n        if (frameLength > 0) {\n          // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n          return {\n            headerLength: headerLength,\n            frameLength: frameLength\n          };\n        }\n      }\n    }\n    function appendFrame$1(track, data, offset, pts, frameIndex) {\n      var frameDuration = getFrameDuration(track.samplerate);\n      var stamp = pts + frameIndex * frameDuration;\n      var header = parseFrameHeader(data, offset);\n      var unit;\n      if (header) {\n        var frameLength = header.frameLength,\n          headerLength = header.headerLength;\n        var _length = headerLength + frameLength;\n        var missing = Math.max(0, offset + _length - data.length);\n        // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n        if (missing) {\n          unit = new Uint8Array(_length - headerLength);\n          unit.set(data.subarray(offset + headerLength, data.length), 0);\n        } else {\n          unit = data.subarray(offset + headerLength, offset + _length);\n        }\n        var _sample = {\n          unit: unit,\n          pts: stamp\n        };\n        if (!missing) {\n          track.samples.push(_sample);\n        }\n        return {\n          sample: _sample,\n          length: _length,\n          missing: missing\n        };\n      }\n      // overflow incomplete header\n      var length = data.length - offset;\n      unit = new Uint8Array(length);\n      unit.set(data.subarray(offset, data.length), 0);\n      var sample = {\n        unit: unit,\n        pts: stamp\n      };\n      return {\n        sample: sample,\n        length: length,\n        missing: -1\n      };\n    }\n    var AACDemuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n      _inheritsLoose(AACDemuxer, _BaseAudioDemuxer);\n      function AACDemuxer(observer, config) {\n        var _this;\n        _this = _BaseAudioDemuxer.call(this) || this;\n        _this.observer = void 0;\n        _this.config = void 0;\n        _this.observer = observer;\n        _this.config = config;\n        return _this;\n      }\n      var _proto = AACDemuxer.prototype;\n      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n        this._audioTrack = {\n          container: 'audio/adts',\n          type: 'audio',\n          id: 2,\n          pid: -1,\n          sequenceNumber: 0,\n          segmentCodec: 'aac',\n          samples: [],\n          manifestCodec: audioCodec,\n          duration: trackDuration,\n          inputTimeScale: 90000,\n          dropped: 0\n        };\n      }\n\n      // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n      ;\n\n      AACDemuxer.probe = function probe(data) {\n        if (!data) {\n          return false;\n        }\n\n        // Check for the ADTS sync word\n        // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n        // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n        // More info https://wiki.multimedia.cx/index.php?title=ADTS\n        var id3Data = getID3Data(data, 0) || [];\n        var offset = id3Data.length;\n        for (var length = data.length; offset < length; offset++) {\n          if (probe$1(data, offset)) {\n            logger.log('ADTS sync word found !');\n            return true;\n          }\n        }\n        return false;\n      };\n      _proto.canParse = function canParse(data, offset) {\n        return canParse$1(data, offset);\n      };\n      _proto.appendFrame = function appendFrame(track, data, offset) {\n        initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n        var frame = appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);\n        if (frame && frame.missing === 0) {\n          return frame;\n        }\n      };\n      return AACDemuxer;\n    }(BaseAudioDemuxer);\n    var emsgSchemePattern = /\\/emsg[-/]ID3/i;\n    var MP4Demuxer = /*#__PURE__*/function () {\n      function MP4Demuxer(observer, config) {\n        this.remainderData = null;\n        this.timeOffset = 0;\n        this.config = void 0;\n        this.videoTrack = void 0;\n        this.audioTrack = void 0;\n        this.id3Track = void 0;\n        this.txtTrack = void 0;\n        this.config = config;\n      }\n      var _proto = MP4Demuxer.prototype;\n      _proto.resetTimeStamp = function resetTimeStamp() {};\n      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        var videoTrack = this.videoTrack = dummyTrack('video', 1);\n        var audioTrack = this.audioTrack = dummyTrack('audio', 1);\n        var captionTrack = this.txtTrack = dummyTrack('text', 1);\n        this.id3Track = dummyTrack('id3', 1);\n        this.timeOffset = 0;\n        if (!(initSegment != null && initSegment.byteLength)) {\n          return;\n        }\n        var initData = parseInitSegment(initSegment);\n        if (initData.video) {\n          var _initData$video = initData.video,\n            id = _initData$video.id,\n            timescale = _initData$video.timescale,\n            codec = _initData$video.codec;\n          videoTrack.id = id;\n          videoTrack.timescale = captionTrack.timescale = timescale;\n          videoTrack.codec = codec;\n        }\n        if (initData.audio) {\n          var _initData$audio = initData.audio,\n            _id = _initData$audio.id,\n            _timescale = _initData$audio.timescale,\n            _codec = _initData$audio.codec;\n          audioTrack.id = _id;\n          audioTrack.timescale = _timescale;\n          audioTrack.codec = _codec;\n        }\n        captionTrack.id = RemuxerTrackIdConfig.text;\n        videoTrack.sampleDuration = 0;\n        videoTrack.duration = audioTrack.duration = trackDuration;\n      };\n      _proto.resetContiguity = function resetContiguity() {\n        this.remainderData = null;\n      };\n      MP4Demuxer.probe = function probe(data) {\n        // ensure we find a moof box in the first 16 kB\n        data = data.length > 16384 ? data.subarray(0, 16384) : data;\n        return findBox(data, ['moof']).length > 0;\n      };\n      _proto.demux = function demux(data, timeOffset) {\n        this.timeOffset = timeOffset;\n        // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n        var videoSamples = data;\n        var videoTrack = this.videoTrack;\n        var textTrack = this.txtTrack;\n        if (this.config.progressive) {\n          // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n          // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n          // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n          if (this.remainderData) {\n            videoSamples = appendUint8Array(this.remainderData, data);\n          }\n          var segmentedData = segmentValidRange(videoSamples);\n          this.remainderData = segmentedData.remainder;\n          videoTrack.samples = segmentedData.valid || new Uint8Array();\n        } else {\n          videoTrack.samples = videoSamples;\n        }\n        var id3Track = this.extractID3Track(videoTrack, timeOffset);\n        textTrack.samples = parseSamples(timeOffset, videoTrack);\n        return {\n          videoTrack: videoTrack,\n          audioTrack: this.audioTrack,\n          id3Track: id3Track,\n          textTrack: this.txtTrack\n        };\n      };\n      _proto.flush = function flush() {\n        var timeOffset = this.timeOffset;\n        var videoTrack = this.videoTrack;\n        var textTrack = this.txtTrack;\n        videoTrack.samples = this.remainderData || new Uint8Array();\n        this.remainderData = null;\n        var id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n        textTrack.samples = parseSamples(timeOffset, videoTrack);\n        return {\n          videoTrack: videoTrack,\n          audioTrack: dummyTrack(),\n          id3Track: id3Track,\n          textTrack: dummyTrack()\n        };\n      };\n      _proto.extractID3Track = function extractID3Track(videoTrack, timeOffset) {\n        var id3Track = this.id3Track;\n        if (videoTrack.samples.length) {\n          var emsgs = findBox(videoTrack.samples, ['emsg']);\n          if (emsgs) {\n            emsgs.forEach(function (data) {\n              var emsgInfo = parseEmsg(data);\n              if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n                var pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n                var duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n                // Safari takes anything <= 0.001 seconds and maps it to Infinity\n                if (duration <= 0.001) {\n                  duration = Number.POSITIVE_INFINITY;\n                }\n                var payload = emsgInfo.payload;\n                id3Track.samples.push({\n                  data: payload,\n                  len: payload.byteLength,\n                  dts: pts,\n                  pts: pts,\n                  type: MetadataSchema.emsg,\n                  duration: duration\n                });\n              }\n            });\n          }\n        }\n        return id3Track;\n      };\n      _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n        return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n      };\n      _proto.destroy = function destroy() {};\n      return MP4Demuxer;\n    }();\n\n    /**\n     *  MPEG parser helper\n     */\n\n    var chromeVersion$1 = null;\n    var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\n    var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\n    var SamplesCoefficients = [\n    // MPEG 2.5\n    [0,\n    // Reserved\n    72,\n    // Layer3\n    144,\n    // Layer2\n    12 // Layer1\n    ],\n    // Reserved\n    [0,\n    // Reserved\n    0,\n    // Layer3\n    0,\n    // Layer2\n    0 // Layer1\n    ],\n    // MPEG 2\n    [0,\n    // Reserved\n    72,\n    // Layer3\n    144,\n    // Layer2\n    12 // Layer1\n    ],\n    // MPEG 1\n    [0,\n    // Reserved\n    144,\n    // Layer3\n    144,\n    // Layer2\n    12 // Layer1\n    ]];\n\n    var BytesInSlot = [0,\n    // Reserved\n    1,\n    // Layer3\n    1,\n    // Layer2\n    4 // Layer1\n    ];\n\n    function appendFrame(track, data, offset, pts, frameIndex) {\n      // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n      if (offset + 24 > data.length) {\n        return;\n      }\n      var header = parseHeader(data, offset);\n      if (header && offset + header.frameLength <= data.length) {\n        var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n        var stamp = pts + frameIndex * frameDuration;\n        var sample = {\n          unit: data.subarray(offset, offset + header.frameLength),\n          pts: stamp,\n          dts: stamp\n        };\n        track.config = [];\n        track.channelCount = header.channelCount;\n        track.samplerate = header.sampleRate;\n        track.samples.push(sample);\n        return {\n          sample: sample,\n          length: header.frameLength,\n          missing: 0\n        };\n      }\n    }\n    function parseHeader(data, offset) {\n      var mpegVersion = data[offset + 1] >> 3 & 3;\n      var mpegLayer = data[offset + 1] >> 1 & 3;\n      var bitRateIndex = data[offset + 2] >> 4 & 15;\n      var sampleRateIndex = data[offset + 2] >> 2 & 3;\n      if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n        var paddingBit = data[offset + 2] >> 1 & 1;\n        var channelMode = data[offset + 3] >> 6;\n        var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n        var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n        var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n        var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n        var channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n        var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n        var bytesInSlot = BytesInSlot[mpegLayer];\n        var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n        var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n        if (chromeVersion$1 === null) {\n          var userAgent = navigator.userAgent || '';\n          var result = userAgent.match(/Chrome\\/(\\d+)/i);\n          chromeVersion$1 = result ? parseInt(result[1]) : 0;\n        }\n        var needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;\n        if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n          // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n          data[offset + 3] = data[offset + 3] | 0x80;\n        }\n        return {\n          sampleRate: sampleRate,\n          channelCount: channelCount,\n          frameLength: frameLength,\n          samplesPerFrame: samplesPerFrame\n        };\n      }\n    }\n    function isHeaderPattern(data, offset) {\n      return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n    }\n    function isHeader(data, offset) {\n      // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n      // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n      // More info http://www.mp3-tech.org/programmer/frame_header.html\n      return offset + 1 < data.length && isHeaderPattern(data, offset);\n    }\n    function canParse(data, offset) {\n      var headerSize = 4;\n      return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n    }\n    function probe(data, offset) {\n      // same as isHeader but we also check that MPEG frame follows last MPEG frame\n      // or end of data is reached\n      if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n        // MPEG header Length\n        var headerLength = 4;\n        // MPEG frame Length\n        var header = parseHeader(data, offset);\n        var frameLength = headerLength;\n        if (header != null && header.frameLength) {\n          frameLength = header.frameLength;\n        }\n        var newOffset = offset + frameLength;\n        return newOffset === data.length || isHeader(data, newOffset);\n      }\n      return false;\n    }\n\n    /**\n     * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n     */\n\n    var ExpGolomb = /*#__PURE__*/function () {\n      function ExpGolomb(data) {\n        this.data = void 0;\n        this.bytesAvailable = void 0;\n        this.word = void 0;\n        this.bitsAvailable = void 0;\n        this.data = data;\n        // the number of bytes left to examine in this.data\n        this.bytesAvailable = data.byteLength;\n        // the current word being examined\n        this.word = 0; // :uint\n        // the number of bits left to examine in the current word\n        this.bitsAvailable = 0; // :uint\n      }\n\n      // ():void\n      var _proto = ExpGolomb.prototype;\n      _proto.loadWord = function loadWord() {\n        var data = this.data;\n        var bytesAvailable = this.bytesAvailable;\n        var position = data.byteLength - bytesAvailable;\n        var workingBytes = new Uint8Array(4);\n        var availableBytes = Math.min(4, bytesAvailable);\n        if (availableBytes === 0) {\n          throw new Error('no bytes available');\n        }\n        workingBytes.set(data.subarray(position, position + availableBytes));\n        this.word = new DataView(workingBytes.buffer).getUint32(0);\n        // track the amount of this.data that has been processed\n        this.bitsAvailable = availableBytes * 8;\n        this.bytesAvailable -= availableBytes;\n      }\n\n      // (count:int):void\n      ;\n\n      _proto.skipBits = function skipBits(count) {\n        var skipBytes; // :int\n        count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n        if (this.bitsAvailable > count) {\n          this.word <<= count;\n          this.bitsAvailable -= count;\n        } else {\n          count -= this.bitsAvailable;\n          skipBytes = count >> 3;\n          count -= skipBytes << 3;\n          this.bytesAvailable -= skipBytes;\n          this.loadWord();\n          this.word <<= count;\n          this.bitsAvailable -= count;\n        }\n      }\n\n      // (size:int):uint\n      ;\n\n      _proto.readBits = function readBits(size) {\n        var bits = Math.min(this.bitsAvailable, size); // :uint\n        var valu = this.word >>> 32 - bits; // :uint\n        if (size > 32) {\n          logger.error('Cannot read more than 32 bits at a time');\n        }\n        this.bitsAvailable -= bits;\n        if (this.bitsAvailable > 0) {\n          this.word <<= bits;\n        } else if (this.bytesAvailable > 0) {\n          this.loadWord();\n        } else {\n          throw new Error('no bits available');\n        }\n        bits = size - bits;\n        if (bits > 0 && this.bitsAvailable) {\n          return valu << bits | this.readBits(bits);\n        } else {\n          return valu;\n        }\n      }\n\n      // ():uint\n      ;\n\n      _proto.skipLZ = function skipLZ() {\n        var leadingZeroCount; // :uint\n        for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n          if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n            // the first bit of working word is 1\n            this.word <<= leadingZeroCount;\n            this.bitsAvailable -= leadingZeroCount;\n            return leadingZeroCount;\n          }\n        }\n        // we exhausted word and still have not found a 1\n        this.loadWord();\n        return leadingZeroCount + this.skipLZ();\n      }\n\n      // ():void\n      ;\n\n      _proto.skipUEG = function skipUEG() {\n        this.skipBits(1 + this.skipLZ());\n      }\n\n      // ():void\n      ;\n\n      _proto.skipEG = function skipEG() {\n        this.skipBits(1 + this.skipLZ());\n      }\n\n      // ():uint\n      ;\n\n      _proto.readUEG = function readUEG() {\n        var clz = this.skipLZ(); // :uint\n        return this.readBits(clz + 1) - 1;\n      }\n\n      // ():int\n      ;\n\n      _proto.readEG = function readEG() {\n        var valu = this.readUEG(); // :int\n        if (0x01 & valu) {\n          // the number is odd if the low order bit is set\n          return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n        } else {\n          return -1 * (valu >>> 1); // divide by two then make it negative\n        }\n      }\n\n      // Some convenience functions\n      // :Boolean\n      ;\n\n      _proto.readBoolean = function readBoolean() {\n        return this.readBits(1) === 1;\n      }\n\n      // ():int\n      ;\n\n      _proto.readUByte = function readUByte() {\n        return this.readBits(8);\n      }\n\n      // ():int\n      ;\n\n      _proto.readUShort = function readUShort() {\n        return this.readBits(16);\n      }\n\n      // ():int\n      ;\n\n      _proto.readUInt = function readUInt() {\n        return this.readBits(32);\n      }\n\n      /**\n       * Advance the ExpGolomb decoder past a scaling list. The scaling\n       * list is optionally transmitted as part of a sequence parameter\n       * set and is not relevant to transmuxing.\n       * @param count the number of entries in this scaling list\n       * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n       */;\n      _proto.skipScalingList = function skipScalingList(count) {\n        var lastScale = 8;\n        var nextScale = 8;\n        var deltaScale;\n        for (var j = 0; j < count; j++) {\n          if (nextScale !== 0) {\n            deltaScale = this.readEG();\n            nextScale = (lastScale + deltaScale + 256) % 256;\n          }\n          lastScale = nextScale === 0 ? lastScale : nextScale;\n        }\n      }\n\n      /**\n       * Read a sequence parameter set and return some interesting video\n       * properties. A sequence parameter set is the H264 metadata that\n       * describes the properties of upcoming video frames.\n       * @returns an object with configuration parsed from the\n       * sequence parameter set, including the dimensions of the\n       * associated video frames.\n       */;\n      _proto.readSPS = function readSPS() {\n        var frameCropLeftOffset = 0;\n        var frameCropRightOffset = 0;\n        var frameCropTopOffset = 0;\n        var frameCropBottomOffset = 0;\n        var numRefFramesInPicOrderCntCycle;\n        var scalingListCount;\n        var i;\n        var readUByte = this.readUByte.bind(this);\n        var readBits = this.readBits.bind(this);\n        var readUEG = this.readUEG.bind(this);\n        var readBoolean = this.readBoolean.bind(this);\n        var skipBits = this.skipBits.bind(this);\n        var skipEG = this.skipEG.bind(this);\n        var skipUEG = this.skipUEG.bind(this);\n        var skipScalingList = this.skipScalingList.bind(this);\n        readUByte();\n        var profileIdc = readUByte(); // profile_idc\n        readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n        skipBits(3); // reserved_zero_3bits u(3),\n        readUByte(); // level_idc u(8)\n        skipUEG(); // seq_parameter_set_id\n        // some profiles have more optional data we don't need\n        if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n          var chromaFormatIdc = readUEG();\n          if (chromaFormatIdc === 3) {\n            skipBits(1);\n          } // separate_colour_plane_flag\n\n          skipUEG(); // bit_depth_luma_minus8\n          skipUEG(); // bit_depth_chroma_minus8\n          skipBits(1); // qpprime_y_zero_transform_bypass_flag\n          if (readBoolean()) {\n            // seq_scaling_matrix_present_flag\n            scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n            for (i = 0; i < scalingListCount; i++) {\n              if (readBoolean()) {\n                // seq_scaling_list_present_flag[ i ]\n                if (i < 6) {\n                  skipScalingList(16);\n                } else {\n                  skipScalingList(64);\n                }\n              }\n            }\n          }\n        }\n        skipUEG(); // log2_max_frame_num_minus4\n        var picOrderCntType = readUEG();\n        if (picOrderCntType === 0) {\n          readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n        } else if (picOrderCntType === 1) {\n          skipBits(1); // delta_pic_order_always_zero_flag\n          skipEG(); // offset_for_non_ref_pic\n          skipEG(); // offset_for_top_to_bottom_field\n          numRefFramesInPicOrderCntCycle = readUEG();\n          for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n            skipEG();\n          } // offset_for_ref_frame[ i ]\n        }\n\n        skipUEG(); // max_num_ref_frames\n        skipBits(1); // gaps_in_frame_num_value_allowed_flag\n        var picWidthInMbsMinus1 = readUEG();\n        var picHeightInMapUnitsMinus1 = readUEG();\n        var frameMbsOnlyFlag = readBits(1);\n        if (frameMbsOnlyFlag === 0) {\n          skipBits(1);\n        } // mb_adaptive_frame_field_flag\n\n        skipBits(1); // direct_8x8_inference_flag\n        if (readBoolean()) {\n          // frame_cropping_flag\n          frameCropLeftOffset = readUEG();\n          frameCropRightOffset = readUEG();\n          frameCropTopOffset = readUEG();\n          frameCropBottomOffset = readUEG();\n        }\n        var pixelRatio = [1, 1];\n        if (readBoolean()) {\n          // vui_parameters_present_flag\n          if (readBoolean()) {\n            // aspect_ratio_info_present_flag\n            var aspectRatioIdc = readUByte();\n            switch (aspectRatioIdc) {\n              case 1:\n                pixelRatio = [1, 1];\n                break;\n              case 2:\n                pixelRatio = [12, 11];\n                break;\n              case 3:\n                pixelRatio = [10, 11];\n                break;\n              case 4:\n                pixelRatio = [16, 11];\n                break;\n              case 5:\n                pixelRatio = [40, 33];\n                break;\n              case 6:\n                pixelRatio = [24, 11];\n                break;\n              case 7:\n                pixelRatio = [20, 11];\n                break;\n              case 8:\n                pixelRatio = [32, 11];\n                break;\n              case 9:\n                pixelRatio = [80, 33];\n                break;\n              case 10:\n                pixelRatio = [18, 11];\n                break;\n              case 11:\n                pixelRatio = [15, 11];\n                break;\n              case 12:\n                pixelRatio = [64, 33];\n                break;\n              case 13:\n                pixelRatio = [160, 99];\n                break;\n              case 14:\n                pixelRatio = [4, 3];\n                break;\n              case 15:\n                pixelRatio = [3, 2];\n                break;\n              case 16:\n                pixelRatio = [2, 1];\n                break;\n              case 255:\n                {\n                  pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n                  break;\n                }\n            }\n          }\n        }\n        return {\n          width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n          height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n          pixelRatio: pixelRatio\n        };\n      };\n      _proto.readSliceType = function readSliceType() {\n        // skip NALu type\n        this.readUByte();\n        // discard first_mb_in_slice\n        this.readUEG();\n        // return slice_type\n        return this.readUEG();\n      };\n      return ExpGolomb;\n    }();\n\n    /**\n     * SAMPLE-AES decrypter\n     */\n\n    var SampleAesDecrypter = /*#__PURE__*/function () {\n      function SampleAesDecrypter(observer, config, keyData) {\n        this.keyData = void 0;\n        this.decrypter = void 0;\n        this.keyData = keyData;\n        this.decrypter = new Decrypter(config, {\n          removePKCS7Padding: false\n        });\n      }\n      var _proto = SampleAesDecrypter.prototype;\n      _proto.decryptBuffer = function decryptBuffer(encryptedData) {\n        return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);\n      }\n\n      // AAC - encrypt all full 16 bytes blocks starting from offset 16\n      ;\n\n      _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback) {\n        var _this = this;\n        var curUnit = samples[sampleIndex].unit;\n        if (curUnit.length <= 16) {\n          // No encrypted portion in this sample (first 16 bytes is not\n          // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n          return;\n        }\n        var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n        var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n        this.decryptBuffer(encryptedBuffer).then(function (decryptedBuffer) {\n          var decryptedData = new Uint8Array(decryptedBuffer);\n          curUnit.set(decryptedData, 16);\n          if (!_this.decrypter.isSync()) {\n            _this.decryptAacSamples(samples, sampleIndex + 1, callback);\n          }\n        });\n      };\n      _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {\n        for (;; sampleIndex++) {\n          if (sampleIndex >= samples.length) {\n            callback();\n            return;\n          }\n          if (samples[sampleIndex].unit.length < 32) {\n            continue;\n          }\n          this.decryptAacSample(samples, sampleIndex, callback);\n          if (!this.decrypter.isSync()) {\n            return;\n          }\n        }\n      }\n\n      // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n      ;\n\n      _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {\n        var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n        var encryptedData = new Int8Array(encryptedDataLen);\n        var outputPos = 0;\n        for (var inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n          encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n        }\n        return encryptedData;\n      };\n      _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {\n        var uint8DecryptedData = new Uint8Array(decryptedData);\n        var inputPos = 0;\n        for (var outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n          decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n        }\n        return decodedData;\n      };\n      _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n        var _this2 = this;\n        var decodedData = discardEPB(curUnit.data);\n        var encryptedData = this.getAvcEncryptedData(decodedData);\n        this.decryptBuffer(encryptedData.buffer).then(function (decryptedBuffer) {\n          curUnit.data = _this2.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n          if (!_this2.decrypter.isSync()) {\n            _this2.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n          }\n        });\n      };\n      _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n        if (samples instanceof Uint8Array) {\n          throw new Error('Cannot decrypt samples of type Uint8Array');\n        }\n        for (;; sampleIndex++, unitIndex = 0) {\n          if (sampleIndex >= samples.length) {\n            callback();\n            return;\n          }\n          var curUnits = samples[sampleIndex].units;\n          for (;; unitIndex++) {\n            if (unitIndex >= curUnits.length) {\n              break;\n            }\n            var curUnit = curUnits[unitIndex];\n            if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n              continue;\n            }\n            this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n            if (!this.decrypter.isSync()) {\n              return;\n            }\n          }\n        }\n      };\n      return SampleAesDecrypter;\n    }();\n    var PACKET_LENGTH = 188;\n    var TSDemuxer = /*#__PURE__*/function () {\n      function TSDemuxer(observer, config, typeSupported) {\n        this.observer = void 0;\n        this.config = void 0;\n        this.typeSupported = void 0;\n        this.sampleAes = null;\n        this.pmtParsed = false;\n        this.audioCodec = void 0;\n        this.videoCodec = void 0;\n        this._duration = 0;\n        this._pmtId = -1;\n        this._avcTrack = void 0;\n        this._audioTrack = void 0;\n        this._id3Track = void 0;\n        this._txtTrack = void 0;\n        this.aacOverFlow = null;\n        this.avcSample = null;\n        this.remainderData = null;\n        this.observer = observer;\n        this.config = config;\n        this.typeSupported = typeSupported;\n      }\n      TSDemuxer.probe = function probe(data) {\n        var syncOffset = TSDemuxer.syncOffset(data);\n        if (syncOffset > 0) {\n          logger.warn(\"MPEG2-TS detected but first sync word found @ offset \" + syncOffset);\n        }\n        return syncOffset !== -1;\n      };\n      TSDemuxer.syncOffset = function syncOffset(data) {\n        var length = data.length;\n        var scanwindow = Math.min(PACKET_LENGTH * 5, data.length - PACKET_LENGTH) + 1;\n        var i = 0;\n        while (i < scanwindow) {\n          // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n          var foundPat = false;\n          var packetStart = -1;\n          var tsPackets = 0;\n          for (var j = i; j < length; j += PACKET_LENGTH) {\n            if (data[j] === 0x47) {\n              tsPackets++;\n              if (packetStart === -1) {\n                packetStart = j;\n                // First sync word found at offset, increase scan length (#5251)\n                if (packetStart !== 0) {\n                  scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;\n                }\n              }\n              if (!foundPat) {\n                foundPat = parsePID(data, j) === 0;\n              }\n              // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n              if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {\n                return packetStart;\n              }\n            } else if (tsPackets) {\n              // Exit if sync word found, but does not contain contiguous packets (#5501)\n              return -1;\n            } else {\n              break;\n            }\n          }\n          i++;\n        }\n        return -1;\n      }\n\n      /**\n       * Creates a track model internal to demuxer used to drive remuxing input\n       */;\n      TSDemuxer.createTrack = function createTrack(type, duration) {\n        return {\n          container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n          type: type,\n          id: RemuxerTrackIdConfig[type],\n          pid: -1,\n          inputTimeScale: 90000,\n          sequenceNumber: 0,\n          samples: [],\n          dropped: 0,\n          duration: type === 'audio' ? duration : undefined\n        };\n      }\n\n      /**\n       * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n       * Resets all internal track instances of the demuxer.\n       */;\n      var _proto = TSDemuxer.prototype;\n      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        this.pmtParsed = false;\n        this._pmtId = -1;\n        this._avcTrack = TSDemuxer.createTrack('video');\n        this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);\n        this._id3Track = TSDemuxer.createTrack('id3');\n        this._txtTrack = TSDemuxer.createTrack('text');\n        this._audioTrack.segmentCodec = 'aac';\n\n        // flush any partial content\n        this.aacOverFlow = null;\n        this.avcSample = null;\n        this.remainderData = null;\n        this.audioCodec = audioCodec;\n        this.videoCodec = videoCodec;\n        this._duration = trackDuration;\n      };\n      _proto.resetTimeStamp = function resetTimeStamp() {};\n      _proto.resetContiguity = function resetContiguity() {\n        var _audioTrack = this._audioTrack,\n          _avcTrack = this._avcTrack,\n          _id3Track = this._id3Track;\n        if (_audioTrack) {\n          _audioTrack.pesData = null;\n        }\n        if (_avcTrack) {\n          _avcTrack.pesData = null;\n        }\n        if (_id3Track) {\n          _id3Track.pesData = null;\n        }\n        this.aacOverFlow = null;\n        this.avcSample = null;\n        this.remainderData = null;\n      };\n      _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {\n        if (isSampleAes === void 0) {\n          isSampleAes = false;\n        }\n        if (flush === void 0) {\n          flush = false;\n        }\n        if (!isSampleAes) {\n          this.sampleAes = null;\n        }\n        var pes;\n        var videoTrack = this._avcTrack;\n        var audioTrack = this._audioTrack;\n        var id3Track = this._id3Track;\n        var textTrack = this._txtTrack;\n        var avcId = videoTrack.pid;\n        var avcData = videoTrack.pesData;\n        var audioId = audioTrack.pid;\n        var id3Id = id3Track.pid;\n        var audioData = audioTrack.pesData;\n        var id3Data = id3Track.pesData;\n        var unknownPID = null;\n        var pmtParsed = this.pmtParsed;\n        var pmtId = this._pmtId;\n        var len = data.length;\n        if (this.remainderData) {\n          data = appendUint8Array(this.remainderData, data);\n          len = data.length;\n          this.remainderData = null;\n        }\n        if (len < PACKET_LENGTH && !flush) {\n          this.remainderData = data;\n          return {\n            audioTrack: audioTrack,\n            videoTrack: videoTrack,\n            id3Track: id3Track,\n            textTrack: textTrack\n          };\n        }\n        var syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n        len -= (len - syncOffset) % PACKET_LENGTH;\n        if (len < data.byteLength && !flush) {\n          this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n        }\n\n        // loop through TS packets\n        var tsPacketErrors = 0;\n        for (var start = syncOffset; start < len; start += PACKET_LENGTH) {\n          if (data[start] === 0x47) {\n            var stt = !!(data[start + 1] & 0x40);\n            var pid = parsePID(data, start);\n            var atf = (data[start + 3] & 0x30) >> 4;\n\n            // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n            var offset = void 0;\n            if (atf > 1) {\n              offset = start + 5 + data[start + 4];\n              // continue if there is only adaptation field\n              if (offset === start + PACKET_LENGTH) {\n                continue;\n              }\n            } else {\n              offset = start + 4;\n            }\n            switch (pid) {\n              case avcId:\n                if (stt) {\n                  if (avcData && (pes = parsePES(avcData))) {\n                    this.parseAVCPES(videoTrack, textTrack, pes, false);\n                  }\n                  avcData = {\n                    data: [],\n                    size: 0\n                  };\n                }\n                if (avcData) {\n                  avcData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                  avcData.size += start + PACKET_LENGTH - offset;\n                }\n                break;\n              case audioId:\n                if (stt) {\n                  if (audioData && (pes = parsePES(audioData))) {\n                    switch (audioTrack.segmentCodec) {\n                      case 'aac':\n                        this.parseAACPES(audioTrack, pes);\n                        break;\n                      case 'mp3':\n                        this.parseMPEGPES(audioTrack, pes);\n                        break;\n                    }\n                  }\n                  audioData = {\n                    data: [],\n                    size: 0\n                  };\n                }\n                if (audioData) {\n                  audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                  audioData.size += start + PACKET_LENGTH - offset;\n                }\n                break;\n              case id3Id:\n                if (stt) {\n                  if (id3Data && (pes = parsePES(id3Data))) {\n                    this.parseID3PES(id3Track, pes);\n                  }\n                  id3Data = {\n                    data: [],\n                    size: 0\n                  };\n                }\n                if (id3Data) {\n                  id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                  id3Data.size += start + PACKET_LENGTH - offset;\n                }\n                break;\n              case 0:\n                if (stt) {\n                  offset += data[offset] + 1;\n                }\n                pmtId = this._pmtId = parsePAT(data, offset);\n                // logger.log('PMT PID:'  + this._pmtId);\n                break;\n              case pmtId:\n                {\n                  if (stt) {\n                    offset += data[offset] + 1;\n                  }\n                  var parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes);\n\n                  // only update track id if track PID found while parsing PMT\n                  // this is to avoid resetting the PID to -1 in case\n                  // track PID transiently disappears from the stream\n                  // this could happen in case of transient missing audio samples for example\n                  // NOTE this is only the PID of the track as found in TS,\n                  // but we are not using this for MP4 track IDs.\n                  avcId = parsedPIDs.avc;\n                  if (avcId > 0) {\n                    videoTrack.pid = avcId;\n                  }\n                  audioId = parsedPIDs.audio;\n                  if (audioId > 0) {\n                    audioTrack.pid = audioId;\n                    audioTrack.segmentCodec = parsedPIDs.segmentCodec;\n                  }\n                  id3Id = parsedPIDs.id3;\n                  if (id3Id > 0) {\n                    id3Track.pid = id3Id;\n                  }\n                  if (unknownPID !== null && !pmtParsed) {\n                    logger.warn(\"MPEG-TS PMT found at \" + start + \" after unknown PID '\" + unknownPID + \"'. Backtracking to sync byte @\" + syncOffset + \" to parse all TS packets.\");\n                    unknownPID = null;\n                    // we set it to -188, the += 188 in the for loop will reset start to 0\n                    start = syncOffset - 188;\n                  }\n                  pmtParsed = this.pmtParsed = true;\n                  break;\n                }\n              case 0x11:\n              case 0x1fff:\n                break;\n              default:\n                unknownPID = pid;\n                break;\n            }\n          } else {\n            tsPacketErrors++;\n          }\n        }\n        if (tsPacketErrors > 0) {\n          var error = new Error(\"Found \" + tsPacketErrors + \" TS packet/s that do not start with 0x47\");\n          this.observer.emit(Events.ERROR, Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: false,\n            error: error,\n            reason: error.message\n          });\n        }\n        videoTrack.pesData = avcData;\n        audioTrack.pesData = audioData;\n        id3Track.pesData = id3Data;\n        var demuxResult = {\n          audioTrack: audioTrack,\n          videoTrack: videoTrack,\n          id3Track: id3Track,\n          textTrack: textTrack\n        };\n        if (flush) {\n          this.extractRemainingSamples(demuxResult);\n        }\n        return demuxResult;\n      };\n      _proto.flush = function flush() {\n        var remainderData = this.remainderData;\n        this.remainderData = null;\n        var result;\n        if (remainderData) {\n          result = this.demux(remainderData, -1, false, true);\n        } else {\n          result = {\n            videoTrack: this._avcTrack,\n            audioTrack: this._audioTrack,\n            id3Track: this._id3Track,\n            textTrack: this._txtTrack\n          };\n        }\n        this.extractRemainingSamples(result);\n        if (this.sampleAes) {\n          return this.decrypt(result, this.sampleAes);\n        }\n        return result;\n      };\n      _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {\n        var audioTrack = demuxResult.audioTrack,\n          videoTrack = demuxResult.videoTrack,\n          id3Track = demuxResult.id3Track,\n          textTrack = demuxResult.textTrack;\n        var avcData = videoTrack.pesData;\n        var audioData = audioTrack.pesData;\n        var id3Data = id3Track.pesData;\n        // try to parse last PES packets\n        var pes;\n        if (avcData && (pes = parsePES(avcData))) {\n          this.parseAVCPES(videoTrack, textTrack, pes, true);\n          videoTrack.pesData = null;\n        } else {\n          // either avcData null or PES truncated, keep it for next frag parsing\n          videoTrack.pesData = avcData;\n        }\n        if (audioData && (pes = parsePES(audioData))) {\n          switch (audioTrack.segmentCodec) {\n            case 'aac':\n              this.parseAACPES(audioTrack, pes);\n              break;\n            case 'mp3':\n              this.parseMPEGPES(audioTrack, pes);\n              break;\n          }\n          audioTrack.pesData = null;\n        } else {\n          if (audioData != null && audioData.size) {\n            logger.log('last AAC PES packet truncated,might overlap between fragments');\n          }\n\n          // either audioData null or PES truncated, keep it for next frag parsing\n          audioTrack.pesData = audioData;\n        }\n        if (id3Data && (pes = parsePES(id3Data))) {\n          this.parseID3PES(id3Track, pes);\n          id3Track.pesData = null;\n        } else {\n          // either id3Data null or PES truncated, keep it for next frag parsing\n          id3Track.pesData = id3Data;\n        }\n      };\n      _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n        var demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n        var sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);\n        return this.decrypt(demuxResult, sampleAes);\n      };\n      _proto.decrypt = function decrypt(demuxResult, sampleAes) {\n        return new Promise(function (resolve) {\n          var audioTrack = demuxResult.audioTrack,\n            videoTrack = demuxResult.videoTrack;\n          if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n            sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {\n              if (videoTrack.samples) {\n                sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n                  resolve(demuxResult);\n                });\n              } else {\n                resolve(demuxResult);\n              }\n            });\n          } else if (videoTrack.samples) {\n            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n              resolve(demuxResult);\n            });\n          }\n        });\n      };\n      _proto.destroy = function destroy() {\n        this._duration = 0;\n      };\n      _proto.parseAVCPES = function parseAVCPES(track, textTrack, pes, last) {\n        var _this = this;\n        var units = this.parseAVCNALu(track, pes.data);\n        var avcSample = this.avcSample;\n        var push;\n        var spsfound = false;\n        // free pes.data to save up some memory\n        pes.data = null;\n\n        // if new NAL units found and last sample still there, let's push ...\n        // this helps parsing streams with missing AUD (only do this if AUD never found)\n        if (avcSample && units.length && !track.audFound) {\n          pushAccessUnit(avcSample, track);\n          avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n        }\n        units.forEach(function (unit) {\n          switch (unit.type) {\n            // NDR\n            case 1:\n              {\n                push = true;\n                if (!avcSample) {\n                  avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n                }\n                avcSample.frame = true;\n                var data = unit.data;\n                // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n                if (spsfound && data.length > 4) {\n                  // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n                  var sliceType = new ExpGolomb(data).readSliceType();\n                  // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n                  // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n                  // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n                  // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n                  // if (sliceType === 2 || sliceType === 7) {\n                  if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                    avcSample.key = true;\n                  }\n                }\n                break;\n                // IDR\n              }\n\n            case 5:\n              push = true;\n              // handle PES not starting with AUD\n              if (!avcSample) {\n                avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n              }\n              avcSample.key = true;\n              avcSample.frame = true;\n              break;\n            // SEI\n            case 6:\n              {\n                push = true;\n                parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);\n                break;\n                // SPS\n              }\n\n            case 7:\n              push = true;\n              spsfound = true;\n              if (!track.sps) {\n                var sps = unit.data;\n                var expGolombDecoder = new ExpGolomb(sps);\n                var config = expGolombDecoder.readSPS();\n                track.width = config.width;\n                track.height = config.height;\n                track.pixelRatio = config.pixelRatio;\n                track.sps = [sps];\n                track.duration = _this._duration;\n                var codecarray = sps.subarray(1, 4);\n                var codecstring = 'avc1.';\n                for (var i = 0; i < 3; i++) {\n                  var h = codecarray[i].toString(16);\n                  if (h.length < 2) {\n                    h = '0' + h;\n                  }\n                  codecstring += h;\n                }\n                track.codec = codecstring;\n              }\n              break;\n            // PPS\n            case 8:\n              push = true;\n              if (!track.pps) {\n                track.pps = [unit.data];\n              }\n              break;\n            // AUD\n            case 9:\n              push = false;\n              track.audFound = true;\n              if (avcSample) {\n                pushAccessUnit(avcSample, track);\n              }\n              avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n              break;\n            // Filler Data\n            case 12:\n              push = true;\n              break;\n            default:\n              push = false;\n              if (avcSample) {\n                avcSample.debug += 'unknown NAL ' + unit.type + ' ';\n              }\n              break;\n          }\n          if (avcSample && push) {\n            var _units = avcSample.units;\n            _units.push(unit);\n          }\n        });\n        // if last PES packet, push samples\n        if (last && avcSample) {\n          pushAccessUnit(avcSample, track);\n          this.avcSample = null;\n        }\n      };\n      _proto.getLastNalUnit = function getLastNalUnit(samples) {\n        var _avcSample;\n        var avcSample = this.avcSample;\n        var lastUnit;\n        // try to fallback to previous sample if current one is empty\n        if (!avcSample || avcSample.units.length === 0) {\n          avcSample = samples[samples.length - 1];\n        }\n        if ((_avcSample = avcSample) != null && _avcSample.units) {\n          var units = avcSample.units;\n          lastUnit = units[units.length - 1];\n        }\n        return lastUnit;\n      };\n      _proto.parseAVCNALu = function parseAVCNALu(track, array) {\n        var len = array.byteLength;\n        var state = track.naluState || 0;\n        var lastState = state;\n        var units = [];\n        var i = 0;\n        var value;\n        var overflow;\n        var unitType;\n        var lastUnitStart = -1;\n        var lastUnitType = 0;\n        // logger.log('PES:' + Hex.hexDump(array));\n\n        if (state === -1) {\n          // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n          lastUnitStart = 0;\n          // NALu type is value read from offset 0\n          lastUnitType = array[0] & 0x1f;\n          state = 0;\n          i = 1;\n        }\n        while (i < len) {\n          value = array[i++];\n          // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n          if (!state) {\n            state = value ? 0 : 1;\n            continue;\n          }\n          if (state === 1) {\n            state = value ? 0 : 2;\n            continue;\n          }\n          // here we have state either equal to 2 or 3\n          if (!value) {\n            state = 3;\n          } else if (value === 1) {\n            if (lastUnitStart >= 0) {\n              var unit = {\n                data: array.subarray(lastUnitStart, i - state - 1),\n                type: lastUnitType\n              };\n              // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n              units.push(unit);\n            } else {\n              // lastUnitStart is undefined => this is the first start code found in this PES packet\n              // first check if start code delimiter is overlapping between 2 PES packets,\n              // ie it started in last packet (lastState not zero)\n              // and ended at the beginning of this PES packet (i <= 4 - lastState)\n              var lastUnit = this.getLastNalUnit(track.samples);\n              if (lastUnit) {\n                if (lastState && i <= 4 - lastState) {\n                  // start delimiter overlapping between PES packets\n                  // strip start delimiter bytes from the end of last NAL unit\n                  // check if lastUnit had a state different from zero\n                  if (lastUnit.state) {\n                    // strip last bytes\n                    lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n                  }\n                }\n                // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n                overflow = i - state - 1;\n                if (overflow > 0) {\n                  // logger.log('first NALU found with overflow:' + overflow);\n                  var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);\n                  tmp.set(lastUnit.data, 0);\n                  tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);\n                  lastUnit.data = tmp;\n                  lastUnit.state = 0;\n                }\n              }\n            }\n            // check if we can read unit type\n            if (i < len) {\n              unitType = array[i] & 0x1f;\n              // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n              lastUnitStart = i;\n              lastUnitType = unitType;\n              state = 0;\n            } else {\n              // not enough byte to read unit type. let's read it on next PES parsing\n              state = -1;\n            }\n          } else {\n            state = 0;\n          }\n        }\n        if (lastUnitStart >= 0 && state >= 0) {\n          var _unit = {\n            data: array.subarray(lastUnitStart, len),\n            type: lastUnitType,\n            state: state\n          };\n          units.push(_unit);\n          // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n        }\n        // no NALu found\n        if (units.length === 0) {\n          // append pes.data to previous NAL unit\n          var _lastUnit = this.getLastNalUnit(track.samples);\n          if (_lastUnit) {\n            var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);\n            _tmp.set(_lastUnit.data, 0);\n            _tmp.set(array, _lastUnit.data.byteLength);\n            _lastUnit.data = _tmp;\n          }\n        }\n        track.naluState = state;\n        return units;\n      };\n      _proto.parseAACPES = function parseAACPES(track, pes) {\n        var startOffset = 0;\n        var aacOverFlow = this.aacOverFlow;\n        var data = pes.data;\n        if (aacOverFlow) {\n          this.aacOverFlow = null;\n          var frameMissingBytes = aacOverFlow.missing;\n          var sampleLength = aacOverFlow.sample.unit.byteLength;\n          // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n          if (frameMissingBytes === -1) {\n            var tmp = new Uint8Array(sampleLength + data.byteLength);\n            tmp.set(aacOverFlow.sample.unit, 0);\n            tmp.set(data, sampleLength);\n            data = tmp;\n          } else {\n            var frameOverflowBytes = sampleLength - frameMissingBytes;\n            aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n            track.samples.push(aacOverFlow.sample);\n            startOffset = aacOverFlow.missing;\n          }\n        }\n        // look for ADTS header (0xFFFx)\n        var offset;\n        var len;\n        for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n          if (isHeader$1(data, offset)) {\n            break;\n          }\n        }\n        // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n        if (offset !== startOffset) {\n          var reason;\n          var recoverable = offset < len - 1;\n          if (recoverable) {\n            reason = \"AAC PES did not start with ADTS header,offset:\" + offset;\n          } else {\n            reason = 'No ADTS header found in AAC PES';\n          }\n          var error = new Error(reason);\n          logger.warn(\"parsing error: \" + reason);\n          this.observer.emit(Events.ERROR, Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: false,\n            levelRetry: recoverable,\n            error: error,\n            reason: reason\n          });\n          if (!recoverable) {\n            return;\n          }\n        }\n        initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n        var pts;\n        if (pes.pts !== undefined) {\n          pts = pes.pts;\n        } else if (aacOverFlow) {\n          // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n          // first sample PTS should be equal to last sample PTS + frameDuration\n          var frameDuration = getFrameDuration(track.samplerate);\n          pts = aacOverFlow.sample.pts + frameDuration;\n        } else {\n          logger.warn('[tsdemuxer]: AAC PES unknown PTS');\n          return;\n        }\n\n        // scan for aac samples\n        var frameIndex = 0;\n        var frame;\n        while (offset < len) {\n          frame = appendFrame$1(track, data, offset, pts, frameIndex);\n          offset += frame.length;\n          if (!frame.missing) {\n            frameIndex++;\n            for (; offset < len - 1; offset++) {\n              if (isHeader$1(data, offset)) {\n                break;\n              }\n            }\n          } else {\n            this.aacOverFlow = frame;\n            break;\n          }\n        }\n      };\n      _proto.parseMPEGPES = function parseMPEGPES(track, pes) {\n        var data = pes.data;\n        var length = data.length;\n        var frameIndex = 0;\n        var offset = 0;\n        var pts = pes.pts;\n        if (pts === undefined) {\n          logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\n          return;\n        }\n        while (offset < length) {\n          if (isHeader(data, offset)) {\n            var frame = appendFrame(track, data, offset, pts, frameIndex);\n            if (frame) {\n              offset += frame.length;\n              frameIndex++;\n            } else {\n              // logger.log('Unable to parse Mpeg audio frame');\n              break;\n            }\n          } else {\n            // nothing found, keep looking\n            offset++;\n          }\n        }\n      };\n      _proto.parseID3PES = function parseID3PES(id3Track, pes) {\n        if (pes.pts === undefined) {\n          logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\n          return;\n        }\n        var id3Sample = _extends({}, pes, {\n          type: this._avcTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY\n        });\n        id3Track.samples.push(id3Sample);\n      };\n      return TSDemuxer;\n    }();\n    function createAVCSample(key, pts, dts, debug) {\n      return {\n        key: key,\n        frame: false,\n        pts: pts,\n        dts: dts,\n        units: [],\n        debug: debug,\n        length: 0\n      };\n    }\n    function parsePID(data, offset) {\n      // pid is a 13-bit field starting at the last bit of TS[1]\n      return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n    }\n    function parsePAT(data, offset) {\n      // skip the PSI header and parse the first PMT entry\n      return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n    }\n    function parsePMT(data, offset, typeSupported, isSampleAes) {\n      var result = {\n        audio: -1,\n        avc: -1,\n        id3: -1,\n        segmentCodec: 'aac'\n      };\n      var sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n      var tableEnd = offset + 3 + sectionLength - 4;\n      // to determine where the table is, we have to figure out how\n      // long the program info descriptors are\n      var programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n      // advance the offset to the first entry in the mapping table\n      offset += 12 + programInfoLength;\n      while (offset < tableEnd) {\n        var pid = parsePID(data, offset);\n        switch (data[offset]) {\n          case 0xcf:\n            // SAMPLE-AES AAC\n            if (!isSampleAes) {\n              logger.log('ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream');\n              break;\n            }\n          /* falls through */\n          case 0x0f:\n            // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n            // logger.log('AAC PID:'  + pid);\n            if (result.audio === -1) {\n              result.audio = pid;\n            }\n            break;\n\n          // Packetized metadata (ID3)\n          case 0x15:\n            // logger.log('ID3 PID:'  + pid);\n            if (result.id3 === -1) {\n              result.id3 = pid;\n            }\n            break;\n          case 0xdb:\n            // SAMPLE-AES AVC\n            if (!isSampleAes) {\n              logger.log('H.264 with AES-128-CBC slice encryption found in unencrypted stream');\n              break;\n            }\n          /* falls through */\n          case 0x1b:\n            // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n            // logger.log('AVC PID:'  + pid);\n            if (result.avc === -1) {\n              result.avc = pid;\n            }\n            break;\n\n          // ISO/IEC 11172-3 (MPEG-1 audio)\n          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n          case 0x03:\n          case 0x04:\n            // logger.log('MPEG PID:'  + pid);\n            if (typeSupported.mpeg !== true && typeSupported.mp3 !== true) {\n              logger.log('MPEG audio found, not supported in this browser');\n            } else if (result.audio === -1) {\n              result.audio = pid;\n              result.segmentCodec = 'mp3';\n            }\n            break;\n          case 0x24:\n            logger.warn('Unsupported HEVC stream type found');\n            break;\n        }\n        // move to the next table entry\n        // skip past the elementary stream descriptors, if present\n        offset += ((data[offset + 3] & 0x0f) << 8 | data[offset + 4]) + 5;\n      }\n      return result;\n    }\n    function parsePES(stream) {\n      var i = 0;\n      var frag;\n      var pesLen;\n      var pesHdrLen;\n      var pesPts;\n      var pesDts;\n      var data = stream.data;\n      // safety check\n      if (!stream || stream.size === 0) {\n        return null;\n      }\n\n      // we might need up to 19 bytes to read PES header\n      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n      // usually only one merge is needed (and this is rare ...)\n      while (data[0].length < 19 && data.length > 1) {\n        var newData = new Uint8Array(data[0].length + data[1].length);\n        newData.set(data[0]);\n        newData.set(data[1], data[0].length);\n        data[0] = newData;\n        data.splice(1, 1);\n      }\n      // retrieve PTS/DTS from first fragment\n      frag = data[0];\n      var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n      if (pesPrefix === 1) {\n        pesLen = (frag[4] << 8) + frag[5];\n        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n        // minus 6 : PES header size\n        if (pesLen && pesLen > stream.size - 6) {\n          return null;\n        }\n        var pesFlags = frag[7];\n        if (pesFlags & 0xc0) {\n          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n              as Bitwise operators treat their operands as a sequence of 32 bits */\n          pesPts = (frag[9] & 0x0e) * 536870912 +\n          // 1 << 29\n          (frag[10] & 0xff) * 4194304 +\n          // 1 << 22\n          (frag[11] & 0xfe) * 16384 +\n          // 1 << 14\n          (frag[12] & 0xff) * 128 +\n          // 1 << 7\n          (frag[13] & 0xfe) / 2;\n          if (pesFlags & 0x40) {\n            pesDts = (frag[14] & 0x0e) * 536870912 +\n            // 1 << 29\n            (frag[15] & 0xff) * 4194304 +\n            // 1 << 22\n            (frag[16] & 0xfe) * 16384 +\n            // 1 << 14\n            (frag[17] & 0xff) * 128 +\n            // 1 << 7\n            (frag[18] & 0xfe) / 2;\n            if (pesPts - pesDts > 60 * 90000) {\n              logger.warn(Math.round((pesPts - pesDts) / 90000) + \"s delta between PTS and DTS, align them\");\n              pesPts = pesDts;\n            }\n          } else {\n            pesDts = pesPts;\n          }\n        }\n        pesHdrLen = frag[8];\n        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n        var payloadStartOffset = pesHdrLen + 9;\n        if (stream.size <= payloadStartOffset) {\n          return null;\n        }\n        stream.size -= payloadStartOffset;\n        // reassemble PES packet\n        var pesData = new Uint8Array(stream.size);\n        for (var j = 0, dataLen = data.length; j < dataLen; j++) {\n          frag = data[j];\n          var len = frag.byteLength;\n          if (payloadStartOffset) {\n            if (payloadStartOffset > len) {\n              // trim full frag if PES header bigger than frag\n              payloadStartOffset -= len;\n              continue;\n            } else {\n              // trim partial frag if PES header smaller than frag\n              frag = frag.subarray(payloadStartOffset);\n              len -= payloadStartOffset;\n              payloadStartOffset = 0;\n            }\n          }\n          pesData.set(frag, i);\n          i += len;\n        }\n        if (pesLen) {\n          // payload size : remove PES header + PES extension\n          pesLen -= pesHdrLen + 3;\n        }\n        return {\n          data: pesData,\n          pts: pesPts,\n          dts: pesDts,\n          len: pesLen\n        };\n      }\n      return null;\n    }\n    function pushAccessUnit(avcSample, avcTrack) {\n      if (avcSample.units.length && avcSample.frame) {\n        // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n        if (avcSample.pts === undefined) {\n          var samples = avcTrack.samples;\n          var nbSamples = samples.length;\n          if (nbSamples) {\n            var lastSample = samples[nbSamples - 1];\n            avcSample.pts = lastSample.pts;\n            avcSample.dts = lastSample.dts;\n          } else {\n            // dropping samples, no timestamp found\n            avcTrack.dropped++;\n            return;\n          }\n        }\n        avcTrack.samples.push(avcSample);\n      }\n      if (avcSample.debug.length) {\n        logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);\n      }\n    }\n    var MP3Demuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n      _inheritsLoose(MP3Demuxer, _BaseAudioDemuxer);\n      function MP3Demuxer() {\n        return _BaseAudioDemuxer.apply(this, arguments) || this;\n      }\n      var _proto = MP3Demuxer.prototype;\n      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n        this._audioTrack = {\n          container: 'audio/mpeg',\n          type: 'audio',\n          id: 2,\n          pid: -1,\n          sequenceNumber: 0,\n          segmentCodec: 'mp3',\n          samples: [],\n          manifestCodec: audioCodec,\n          duration: trackDuration,\n          inputTimeScale: 90000,\n          dropped: 0\n        };\n      };\n      MP3Demuxer.probe = function probe$1(data) {\n        if (!data) {\n          return false;\n        }\n\n        // check if data contains ID3 timestamp and MPEG sync word\n        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n        // More info http://www.mp3-tech.org/programmer/frame_header.html\n        var id3Data = getID3Data(data, 0) || [];\n        var offset = id3Data.length;\n        for (var length = data.length; offset < length; offset++) {\n          if (probe(data, offset)) {\n            logger.log('MPEG Audio sync word found !');\n            return true;\n          }\n        }\n        return false;\n      };\n      _proto.canParse = function canParse$1(data, offset) {\n        return canParse(data, offset);\n      };\n      _proto.appendFrame = function appendFrame$1(track, data, offset) {\n        if (this.basePTS === null) {\n          return;\n        }\n        return appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n      };\n      return MP3Demuxer;\n    }(BaseAudioDemuxer);\n\n    /**\n     *  AAC helper\n     */\n    var AAC = /*#__PURE__*/function () {\n      function AAC() {}\n      AAC.getSilentFrame = function getSilentFrame(codec, channelCount) {\n        switch (codec) {\n          case 'mp4a.40.2':\n            if (channelCount === 1) {\n              return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n            } else if (channelCount === 2) {\n              return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n            } else if (channelCount === 3) {\n              return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n            } else if (channelCount === 4) {\n              return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n            } else if (channelCount === 5) {\n              return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n            } else if (channelCount === 6) {\n              return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n            }\n            break;\n          // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n          default:\n            if (channelCount === 1) {\n              // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n              return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n            } else if (channelCount === 2) {\n              // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n              return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n            } else if (channelCount === 3) {\n              // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n              return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n            }\n            break;\n        }\n        return undefined;\n      };\n      return AAC;\n    }();\n\n    /**\n     * Generate MP4 Box\n     */\n\n    var UINT32_MAX = Math.pow(2, 32) - 1;\n    var MP4 = /*#__PURE__*/function () {\n      function MP4() {}\n      MP4.init = function init() {\n        MP4.types = {\n          avc1: [],\n          // codingname\n          avcC: [],\n          btrt: [],\n          dinf: [],\n          dref: [],\n          esds: [],\n          ftyp: [],\n          hdlr: [],\n          mdat: [],\n          mdhd: [],\n          mdia: [],\n          mfhd: [],\n          minf: [],\n          moof: [],\n          moov: [],\n          mp4a: [],\n          '.mp3': [],\n          mvex: [],\n          mvhd: [],\n          pasp: [],\n          sdtp: [],\n          stbl: [],\n          stco: [],\n          stsc: [],\n          stsd: [],\n          stsz: [],\n          stts: [],\n          tfdt: [],\n          tfhd: [],\n          traf: [],\n          trak: [],\n          trun: [],\n          trex: [],\n          tkhd: [],\n          vmhd: [],\n          smhd: []\n        };\n        var i;\n        for (i in MP4.types) {\n          if (MP4.types.hasOwnProperty(i)) {\n            MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n          }\n        }\n        var videoHdlr = new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x00,\n        // pre_defined\n        0x76, 0x69, 0x64, 0x65,\n        // handler_type: 'vide'\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n        ]);\n\n        var audioHdlr = new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x00,\n        // pre_defined\n        0x73, 0x6f, 0x75, 0x6e,\n        // handler_type: 'soun'\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n        ]);\n\n        MP4.HDLR_TYPES = {\n          video: videoHdlr,\n          audio: audioHdlr\n        };\n        var dref = new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x01,\n        // entry_count\n        0x00, 0x00, 0x00, 0x0c,\n        // entry_size\n        0x75, 0x72, 0x6c, 0x20,\n        // 'url' type\n        0x00,\n        // version 0\n        0x00, 0x00, 0x01 // entry_flags\n        ]);\n\n        var stco = new Uint8Array([0x00,\n        // version\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x00 // entry_count\n        ]);\n\n        MP4.STTS = MP4.STSC = MP4.STCO = stco;\n        MP4.STSZ = new Uint8Array([0x00,\n        // version\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x00,\n        // sample_size\n        0x00, 0x00, 0x00, 0x00 // sample_count\n        ]);\n\n        MP4.VMHD = new Uint8Array([0x00,\n        // version\n        0x00, 0x00, 0x01,\n        // flags\n        0x00, 0x00,\n        // graphicsmode\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n        ]);\n\n        MP4.SMHD = new Uint8Array([0x00,\n        // version\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00,\n        // balance\n        0x00, 0x00 // reserved\n        ]);\n\n        MP4.STSD = new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x01]); // entry_count\n\n        var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n        var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n        var minorVersion = new Uint8Array([0, 0, 0, 1]);\n        MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n        MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n      };\n      MP4.box = function box(type) {\n        var size = 8;\n        for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          payload[_key - 1] = arguments[_key];\n        }\n        var i = payload.length;\n        var len = i;\n        // calculate the total size we need to allocate\n        while (i--) {\n          size += payload[i].byteLength;\n        }\n        var result = new Uint8Array(size);\n        result[0] = size >> 24 & 0xff;\n        result[1] = size >> 16 & 0xff;\n        result[2] = size >> 8 & 0xff;\n        result[3] = size & 0xff;\n        result.set(type, 4);\n        // copy the payload into the result\n        for (i = 0, size = 8; i < len; i++) {\n          // copy payload[i] array @ offset size\n          result.set(payload[i], size);\n          size += payload[i].byteLength;\n        }\n        return result;\n      };\n      MP4.hdlr = function hdlr(type) {\n        return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n      };\n      MP4.mdat = function mdat(data) {\n        return MP4.box(MP4.types.mdat, data);\n      };\n      MP4.mdhd = function mdhd(timescale, duration) {\n        duration *= timescale;\n        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        return MP4.box(MP4.types.mdhd, new Uint8Array([0x01,\n        // version 1\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n        // creation_time\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n        // modification_time\n        timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n        // timescale\n        upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4,\n        // 'und' language (undetermined)\n        0x00, 0x00]));\n      };\n      MP4.mdia = function mdia(track) {\n        return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n      };\n      MP4.mfhd = function mfhd(sequenceNumber) {\n        return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n        // flags\n        sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n        ]));\n      };\n\n      MP4.minf = function minf(track) {\n        if (track.type === 'audio') {\n          return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n        } else {\n          return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n        }\n      };\n      MP4.moof = function moof(sn, baseMediaDecodeTime, track) {\n        return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n      };\n      MP4.moov = function moov(tracks) {\n        var i = tracks.length;\n        var boxes = [];\n        while (i--) {\n          boxes[i] = MP4.trak(tracks[i]);\n        }\n        return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n      };\n      MP4.mvex = function mvex(tracks) {\n        var i = tracks.length;\n        var boxes = [];\n        while (i--) {\n          boxes[i] = MP4.trex(tracks[i]);\n        }\n        return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));\n      };\n      MP4.mvhd = function mvhd(timescale, duration) {\n        duration *= timescale;\n        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        var bytes = new Uint8Array([0x01,\n        // version 1\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n        // creation_time\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n        // modification_time\n        timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n        // timescale\n        upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00,\n        // 1.0 rate\n        0x01, 0x00,\n        // 1.0 volume\n        0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n        // transformation: unity matrix\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // pre_defined\n        0xff, 0xff, 0xff, 0xff // next_track_ID\n        ]);\n\n        return MP4.box(MP4.types.mvhd, bytes);\n      };\n      MP4.sdtp = function sdtp(track) {\n        var samples = track.samples || [];\n        var bytes = new Uint8Array(4 + samples.length);\n        var i;\n        var flags;\n        // leave the full box header (4 bytes) all zero\n        // write the sample table\n        for (i = 0; i < samples.length; i++) {\n          flags = samples[i].flags;\n          bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n        }\n        return MP4.box(MP4.types.sdtp, bytes);\n      };\n      MP4.stbl = function stbl(track) {\n        return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n      };\n      MP4.avc1 = function avc1(track) {\n        var sps = [];\n        var pps = [];\n        var i;\n        var data;\n        var len;\n        // assemble the SPSs\n\n        for (i = 0; i < track.sps.length; i++) {\n          data = track.sps[i];\n          len = data.byteLength;\n          sps.push(len >>> 8 & 0xff);\n          sps.push(len & 0xff);\n\n          // SPS\n          sps = sps.concat(Array.prototype.slice.call(data));\n        }\n\n        // assemble the PPSs\n        for (i = 0; i < track.pps.length; i++) {\n          data = track.pps[i];\n          len = data.byteLength;\n          pps.push(len >>> 8 & 0xff);\n          pps.push(len & 0xff);\n          pps = pps.concat(Array.prototype.slice.call(data));\n        }\n        var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01,\n        // version\n        sps[3],\n        // profile\n        sps[4],\n        // profile compat\n        sps[5],\n        // level\n        0xfc | 3,\n        // lengthSizeMinusOne, hard-coded to 4 bytes\n        0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n        ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n        ]).concat(pps))); // \"PPS\"\n        var width = track.width;\n        var height = track.height;\n        var hSpacing = track.pixelRatio[0];\n        var vSpacing = track.pixelRatio[1];\n        return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01,\n        // data_reference_index\n        0x00, 0x00,\n        // pre_defined\n        0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // pre_defined\n        width >> 8 & 0xff, width & 0xff,\n        // width\n        height >> 8 & 0xff, height & 0xff,\n        // height\n        0x00, 0x48, 0x00, 0x00,\n        // horizresolution\n        0x00, 0x48, 0x00, 0x00,\n        // vertresolution\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01,\n        // frame_count\n        0x12, 0x64, 0x61, 0x69, 0x6c,\n        // dailymotion/hls.js\n        0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // compressorname\n        0x00, 0x18,\n        // depth = 24\n        0x11, 0x11]),\n        // pre_defined = -1\n        avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n        // bufferSizeDB\n        0x00, 0x2d, 0xc6, 0xc0,\n        // maxBitrate\n        0x00, 0x2d, 0xc6, 0xc0])),\n        // avgBitrate\n        MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n        // hSpacing\n        hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n        // vSpacing\n        vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n      };\n      MP4.esds = function esds(track) {\n        var configlen = track.config.length;\n        return new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n\n        0x03,\n        // descriptor_type\n        0x17 + configlen,\n        // length\n        0x00, 0x01,\n        // es_id\n        0x00,\n        // stream_priority\n\n        0x04,\n        // descriptor_type\n        0x0f + configlen,\n        // length\n        0x40,\n        // codec : mpeg4_audio\n        0x15,\n        // stream_type\n        0x00, 0x00, 0x00,\n        // buffer_size\n        0x00, 0x00, 0x00, 0x00,\n        // maxBitrate\n        0x00, 0x00, 0x00, 0x00,\n        // avgBitrate\n\n        0x05 // descriptor_type\n        ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n      };\n\n      MP4.mp4a = function mp4a(track) {\n        var samplerate = track.samplerate;\n        return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01,\n        // data_reference_index\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, track.channelCount,\n        // channelcount\n        0x00, 0x10,\n        // sampleSize:16bits\n        0x00, 0x00, 0x00, 0x00,\n        // reserved2\n        samplerate >> 8 & 0xff, samplerate & 0xff,\n        //\n        0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));\n      };\n      MP4.mp3 = function mp3(track) {\n        var samplerate = track.samplerate;\n        return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01,\n        // data_reference_index\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, track.channelCount,\n        // channelcount\n        0x00, 0x10,\n        // sampleSize:16bits\n        0x00, 0x00, 0x00, 0x00,\n        // reserved2\n        samplerate >> 8 & 0xff, samplerate & 0xff,\n        //\n        0x00, 0x00]));\n      };\n      MP4.stsd = function stsd(track) {\n        if (track.type === 'audio') {\n          if (track.segmentCodec === 'mp3' && track.codec === 'mp3') {\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n          }\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n        } else {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n        }\n      };\n      MP4.tkhd = function tkhd(track) {\n        var id = track.id;\n        var duration = track.duration * track.timescale;\n        var width = track.width;\n        var height = track.height;\n        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        return MP4.box(MP4.types.tkhd, new Uint8Array([0x01,\n        // version 1\n        0x00, 0x00, 0x07,\n        // flags\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n        // creation_time\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n        // modification_time\n        id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n        // track_ID\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00,\n        // layer\n        0x00, 0x00,\n        // alternate_group\n        0x00, 0x00,\n        // non-audio track volume\n        0x00, 0x00,\n        // reserved\n        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n        // transformation: unity matrix\n        width >> 8 & 0xff, width & 0xff, 0x00, 0x00,\n        // width\n        height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n        ]));\n      };\n\n      MP4.traf = function traf(track, baseMediaDecodeTime) {\n        var sampleDependencyTable = MP4.sdtp(track);\n        var id = track.id;\n        var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n        var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n        return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n        ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01,\n        // version 1\n        0x00, 0x00, 0x00,\n        // flags\n        upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 +\n        // tfhd\n        20 +\n        // tfdt\n        8 +\n        // traf header\n        16 +\n        // mfhd\n        8 +\n        // moof header\n        8),\n        // mdat header\n        sampleDependencyTable);\n      }\n\n      /**\n       * Generate a track box.\n       * @param track a track definition\n       */;\n      MP4.trak = function trak(track) {\n        track.duration = track.duration || 0xffffffff;\n        return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n      };\n      MP4.trex = function trex(track) {\n        var id = track.id;\n        return MP4.box(MP4.types.trex, new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n        // track_ID\n        0x00, 0x00, 0x00, 0x01,\n        // default_sample_description_index\n        0x00, 0x00, 0x00, 0x00,\n        // default_sample_duration\n        0x00, 0x00, 0x00, 0x00,\n        // default_sample_size\n        0x00, 0x01, 0x00, 0x01 // default_sample_flags\n        ]));\n      };\n\n      MP4.trun = function trun(track, offset) {\n        var samples = track.samples || [];\n        var len = samples.length;\n        var arraylen = 12 + 16 * len;\n        var array = new Uint8Array(arraylen);\n        var i;\n        var sample;\n        var duration;\n        var size;\n        var flags;\n        var cts;\n        offset += 8 + arraylen;\n        array.set([track.type === 'video' ? 0x01 : 0x00,\n        // version 1 for video with signed-int sample_composition_time_offset\n        0x00, 0x0f, 0x01,\n        // flags\n        len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff,\n        // sample_count\n        offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n        ], 0);\n        for (i = 0; i < len; i++) {\n          sample = samples[i];\n          duration = sample.duration;\n          size = sample.size;\n          flags = sample.flags;\n          cts = sample.cts;\n          array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff,\n          // sample_duration\n          size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff,\n          // sample_size\n          flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f,\n          // sample_flags\n          cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n          ], 12 + 16 * i);\n        }\n        return MP4.box(MP4.types.trun, array);\n      };\n      MP4.initSegment = function initSegment(tracks) {\n        if (!MP4.types) {\n          MP4.init();\n        }\n        var movie = MP4.moov(tracks);\n        var result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\n        result.set(MP4.FTYP);\n        result.set(movie, MP4.FTYP.byteLength);\n        return result;\n      };\n      return MP4;\n    }();\n    MP4.types = void 0;\n    MP4.HDLR_TYPES = void 0;\n    MP4.STTS = void 0;\n    MP4.STSC = void 0;\n    MP4.STCO = void 0;\n    MP4.STSZ = void 0;\n    MP4.VMHD = void 0;\n    MP4.SMHD = void 0;\n    MP4.STSD = void 0;\n    MP4.FTYP = void 0;\n    MP4.DINF = void 0;\n    var MPEG_TS_CLOCK_FREQ_HZ = 90000;\n    function toTimescaleFromBase(baseTime, destScale, srcBase, round) {\n      if (srcBase === void 0) {\n        srcBase = 1;\n      }\n      if (round === void 0) {\n        round = false;\n      }\n      var result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n      return round ? Math.round(result) : result;\n    }\n    function toMsFromMpegTsClock(baseTime, round) {\n      if (round === void 0) {\n        round = false;\n      }\n      return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n    }\n    var MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\n    var AAC_SAMPLES_PER_FRAME = 1024;\n    var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\n    var chromeVersion = null;\n    var safariWebkitVersion = null;\n    var MP4Remuxer = /*#__PURE__*/function () {\n      function MP4Remuxer(observer, config, typeSupported, vendor) {\n        this.observer = void 0;\n        this.config = void 0;\n        this.typeSupported = void 0;\n        this.ISGenerated = false;\n        this._initPTS = null;\n        this._initDTS = null;\n        this.nextAvcDts = null;\n        this.nextAudioPts = null;\n        this.videoSampleDuration = null;\n        this.isAudioContiguous = false;\n        this.isVideoContiguous = false;\n        this.observer = observer;\n        this.config = config;\n        this.typeSupported = typeSupported;\n        this.ISGenerated = false;\n        if (chromeVersion === null) {\n          var userAgent = navigator.userAgent || '';\n          var result = userAgent.match(/Chrome\\/(\\d+)/i);\n          chromeVersion = result ? parseInt(result[1]) : 0;\n        }\n        if (safariWebkitVersion === null) {\n          var _result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n          safariWebkitVersion = _result ? parseInt(_result[1]) : 0;\n        }\n      }\n      var _proto = MP4Remuxer.prototype;\n      _proto.destroy = function destroy() {};\n      _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {\n        logger.log('[mp4-remuxer]: initPTS & initDTS reset');\n        this._initPTS = this._initDTS = defaultTimeStamp;\n      };\n      _proto.resetNextTimestamp = function resetNextTimestamp() {\n        logger.log('[mp4-remuxer]: reset next timestamp');\n        this.isVideoContiguous = false;\n        this.isAudioContiguous = false;\n      };\n      _proto.resetInitSegment = function resetInitSegment() {\n        logger.log('[mp4-remuxer]: ISGenerated flag reset');\n        this.ISGenerated = false;\n      };\n      _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {\n        var rolloverDetected = false;\n        var startPTS = videoSamples.reduce(function (minPTS, sample) {\n          var delta = sample.pts - minPTS;\n          if (delta < -4294967296) {\n            // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n            rolloverDetected = true;\n            return normalizePts(minPTS, sample.pts);\n          } else if (delta > 0) {\n            return minPTS;\n          } else {\n            return sample.pts;\n          }\n        }, videoSamples[0].pts);\n        if (rolloverDetected) {\n          logger.debug('PTS rollover detected');\n        }\n        return startPTS;\n      };\n      _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n        var video;\n        var audio;\n        var initSegment;\n        var text;\n        var id3;\n        var independent;\n        var audioTimeOffset = timeOffset;\n        var videoTimeOffset = timeOffset;\n\n        // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n        // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n        // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n        // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n        // then we can remux one track without waiting for the other.\n        var hasAudio = audioTrack.pid > -1;\n        var hasVideo = videoTrack.pid > -1;\n        var length = videoTrack.samples.length;\n        var enoughAudioSamples = audioTrack.samples.length > 0;\n        var enoughVideoSamples = flush && length > 0 || length > 1;\n        var canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n        if (canRemuxAvc) {\n          if (!this.ISGenerated) {\n            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n          }\n          var isVideoContiguous = this.isVideoContiguous;\n          var firstKeyFrameIndex = -1;\n          var firstKeyFramePTS;\n          if (enoughVideoSamples) {\n            firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n            if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n              independent = true;\n              if (firstKeyFrameIndex > 0) {\n                logger.warn(\"[mp4-remuxer]: Dropped \" + firstKeyFrameIndex + \" out of \" + length + \" video samples due to a missing keyframe\");\n                var startPTS = this.getVideoStartPts(videoTrack.samples);\n                videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n                videoTrack.dropped += firstKeyFrameIndex;\n                videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n                firstKeyFramePTS = videoTimeOffset;\n              } else if (firstKeyFrameIndex === -1) {\n                logger.warn(\"[mp4-remuxer]: No keyframe found out of \" + length + \" video samples\");\n                independent = false;\n              }\n            }\n          }\n          if (this.ISGenerated) {\n            if (enoughAudioSamples && enoughVideoSamples) {\n              // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n              // if first audio DTS is not aligned with first video DTS then we need to take that into account\n              // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n              // drift between audio and video streams\n              var _startPTS = this.getVideoStartPts(videoTrack.samples);\n              var tsDelta = normalizePts(audioTrack.samples[0].pts, _startPTS) - _startPTS;\n              var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n              audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n              videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n            }\n\n            // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n            if (enoughAudioSamples) {\n              // if initSegment was generated without audio samples, regenerate it again\n              if (!audioTrack.samplerate) {\n                logger.warn('[mp4-remuxer]: regenerate InitSegment as audio detected');\n                initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n              }\n              audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n              if (enoughVideoSamples) {\n                var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n                // if initSegment was generated without video samples, regenerate it again\n                if (!videoTrack.inputTimeScale) {\n                  logger.warn('[mp4-remuxer]: regenerate InitSegment as video detected');\n                  initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n                }\n                video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n              }\n            } else if (enoughVideoSamples) {\n              video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n            }\n            if (video) {\n              video.firstKeyFrame = firstKeyFrameIndex;\n              video.independent = firstKeyFrameIndex !== -1;\n              video.firstKeyFramePTS = firstKeyFramePTS;\n            }\n          }\n        }\n\n        // Allow ID3 and text to remux, even if more audio/video samples are required\n        if (this.ISGenerated && this._initPTS && this._initDTS) {\n          if (id3Track.samples.length) {\n            id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n          }\n          if (textTrack.samples.length) {\n            text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n          }\n        }\n        return {\n          audio: audio,\n          video: video,\n          initSegment: initSegment,\n          independent: independent,\n          text: text,\n          id3: id3\n        };\n      };\n      _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {\n        var audioSamples = audioTrack.samples;\n        var videoSamples = videoTrack.samples;\n        var typeSupported = this.typeSupported;\n        var tracks = {};\n        var _initPTS = this._initPTS;\n        var computePTSDTS = !_initPTS || accurateTimeOffset;\n        var container = 'audio/mp4';\n        var initPTS;\n        var initDTS;\n        var timescale;\n        if (computePTSDTS) {\n          initPTS = initDTS = Infinity;\n        }\n        if (audioTrack.config && audioSamples.length) {\n          // let's use audio sampling rate as MP4 time scale.\n          // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n          // using audio sampling rate here helps having an integer MP4 frame duration\n          // this avoids potential rounding issue and AV sync issue\n          audioTrack.timescale = audioTrack.samplerate;\n          switch (audioTrack.segmentCodec) {\n            case 'mp3':\n              if (typeSupported.mpeg) {\n                // Chrome and Safari\n                container = 'audio/mpeg';\n                audioTrack.codec = '';\n              } else if (typeSupported.mp3) {\n                // Firefox\n                audioTrack.codec = 'mp3';\n              }\n              break;\n          }\n          tracks.audio = {\n            id: 'audio',\n            container: container,\n            codec: audioTrack.codec,\n            initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),\n            metadata: {\n              channelCount: audioTrack.channelCount\n            }\n          };\n          if (computePTSDTS) {\n            timescale = audioTrack.inputTimeScale;\n            if (!_initPTS || timescale !== _initPTS.timescale) {\n              // remember first PTS of this demuxing context. for audio, PTS = DTS\n              initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n            } else {\n              computePTSDTS = false;\n            }\n          }\n        }\n        if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n          // let's use input time scale as MP4 video timescale\n          // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n          videoTrack.timescale = videoTrack.inputTimeScale;\n          tracks.video = {\n            id: 'main',\n            container: 'video/mp4',\n            codec: videoTrack.codec,\n            initSegment: MP4.initSegment([videoTrack]),\n            metadata: {\n              width: videoTrack.width,\n              height: videoTrack.height\n            }\n          };\n          if (computePTSDTS) {\n            timescale = videoTrack.inputTimeScale;\n            if (!_initPTS || timescale !== _initPTS.timescale) {\n              var startPTS = this.getVideoStartPts(videoSamples);\n              var startOffset = Math.round(timescale * timeOffset);\n              initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n              initPTS = Math.min(initPTS, startPTS - startOffset);\n            } else {\n              computePTSDTS = false;\n            }\n          }\n        }\n        if (Object.keys(tracks).length) {\n          this.ISGenerated = true;\n          if (computePTSDTS) {\n            this._initPTS = {\n              baseTime: initPTS,\n              timescale: timescale\n            };\n            this._initDTS = {\n              baseTime: initDTS,\n              timescale: timescale\n            };\n          } else {\n            initPTS = timescale = undefined;\n          }\n          return {\n            tracks: tracks,\n            initPTS: initPTS,\n            timescale: timescale\n          };\n        }\n      };\n      _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n        var timeScale = track.inputTimeScale;\n        var inputSamples = track.samples;\n        var outputSamples = [];\n        var nbSamples = inputSamples.length;\n        var initPTS = this._initPTS;\n        var nextAvcDts = this.nextAvcDts;\n        var offset = 8;\n        var mp4SampleDuration = this.videoSampleDuration;\n        var firstDTS;\n        var lastDTS;\n        var minPTS = Number.POSITIVE_INFINITY;\n        var maxPTS = Number.NEGATIVE_INFINITY;\n        var sortSamples = false;\n\n        // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n        if (!contiguous || nextAvcDts === null) {\n          var pts = timeOffset * timeScale;\n          var cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n          // if not contiguous, let's use target timeOffset\n          nextAvcDts = pts - cts;\n        }\n\n        // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n        // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n        var initTime = initPTS.baseTime * timeScale / initPTS.timescale;\n        for (var i = 0; i < nbSamples; i++) {\n          var sample = inputSamples[i];\n          sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);\n          sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);\n          if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n            sortSamples = true;\n          }\n        }\n\n        // sort video samples by DTS then PTS then demux id order\n        if (sortSamples) {\n          inputSamples.sort(function (a, b) {\n            var deltadts = a.dts - b.dts;\n            var deltapts = a.pts - b.pts;\n            return deltadts || deltapts;\n          });\n        }\n\n        // Get first/last DTS\n        firstDTS = inputSamples[0].dts;\n        lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n        // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n        // set this constant duration as being the avg delta between consecutive DTS.\n        var inputDuration = lastDTS - firstDTS;\n        var averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n\n        // if fragment are contiguous, detect hole/overlapping between fragments\n        if (contiguous) {\n          // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n          var delta = firstDTS - nextAvcDts;\n          var foundHole = delta > averageSampleDuration;\n          var foundOverlap = delta < -1;\n          if (foundHole || foundOverlap) {\n            if (foundHole) {\n              logger.warn(\"AVC: \" + toMsFromMpegTsClock(delta, true) + \" ms (\" + delta + \"dts) hole between fragments detected, filling it\");\n            } else {\n              logger.warn(\"AVC: \" + toMsFromMpegTsClock(-delta, true) + \" ms (\" + delta + \"dts) overlapping between fragments detected\");\n            }\n            if (!foundOverlap || nextAvcDts >= inputSamples[0].pts) {\n              firstDTS = nextAvcDts;\n              var firstPTS = inputSamples[0].pts - delta;\n              inputSamples[0].dts = firstDTS;\n              inputSamples[0].pts = firstPTS;\n              logger.log(\"Video: First PTS/DTS adjusted: \" + toMsFromMpegTsClock(firstPTS, true) + \"/\" + toMsFromMpegTsClock(firstDTS, true) + \", delta: \" + toMsFromMpegTsClock(delta, true) + \" ms\");\n            }\n          }\n        }\n        firstDTS = Math.max(0, firstDTS);\n        var nbNalu = 0;\n        var naluLen = 0;\n        for (var _i = 0; _i < nbSamples; _i++) {\n          // compute total/avc sample length and nb of NAL units\n          var _sample = inputSamples[_i];\n          var units = _sample.units;\n          var nbUnits = units.length;\n          var sampleLen = 0;\n          for (var j = 0; j < nbUnits; j++) {\n            sampleLen += units[j].data.length;\n          }\n          naluLen += sampleLen;\n          nbNalu += nbUnits;\n          _sample.length = sampleLen;\n\n          // ensure sample monotonic DTS\n          _sample.dts = Math.max(_sample.dts, firstDTS);\n          minPTS = Math.min(_sample.pts, minPTS);\n          maxPTS = Math.max(_sample.pts, maxPTS);\n        }\n        lastDTS = inputSamples[nbSamples - 1].dts;\n\n        /* concatenate the video data and construct the mdat in place\n          (need 8 more bytes to fill length and mpdat type) */\n        var mdatSize = naluLen + 4 * nbNalu + 8;\n        var mdat;\n        try {\n          mdat = new Uint8Array(mdatSize);\n        } catch (err) {\n          this.observer.emit(Events.ERROR, Events.ERROR, {\n            type: ErrorTypes.MUX_ERROR,\n            details: ErrorDetails.REMUX_ALLOC_ERROR,\n            fatal: false,\n            error: err,\n            bytes: mdatSize,\n            reason: \"fail allocating video mdat \" + mdatSize\n          });\n          return;\n        }\n        var view = new DataView(mdat.buffer);\n        view.setUint32(0, mdatSize);\n        mdat.set(MP4.types.mdat, 4);\n        var stretchedLastFrame = false;\n        var minDtsDelta = Number.POSITIVE_INFINITY;\n        var minPtsDelta = Number.POSITIVE_INFINITY;\n        var maxDtsDelta = Number.NEGATIVE_INFINITY;\n        var maxPtsDelta = Number.NEGATIVE_INFINITY;\n        for (var _i2 = 0; _i2 < nbSamples; _i2++) {\n          var avcSample = inputSamples[_i2];\n          var avcSampleUnits = avcSample.units;\n          var mp4SampleLength = 0;\n          // convert NALU bitstream to MP4 format (prepend NALU with size field)\n          for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {\n            var unit = avcSampleUnits[_j];\n            var unitData = unit.data;\n            var unitDataLen = unit.data.byteLength;\n            view.setUint32(offset, unitDataLen);\n            offset += 4;\n            mdat.set(unitData, offset);\n            offset += unitDataLen;\n            mp4SampleLength += 4 + unitDataLen;\n          }\n\n          // expected sample duration is the Decoding Timestamp diff of consecutive samples\n          var ptsDelta = void 0;\n          if (_i2 < nbSamples - 1) {\n            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;\n            ptsDelta = inputSamples[_i2 + 1].pts - avcSample.pts;\n          } else {\n            var config = this.config;\n            var lastFrameDuration = _i2 > 0 ? avcSample.dts - inputSamples[_i2 - 1].dts : averageSampleDuration;\n            ptsDelta = _i2 > 0 ? avcSample.pts - inputSamples[_i2 - 1].pts : averageSampleDuration;\n            if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n              // In some cases, a segment's audio track duration may exceed the video track duration.\n              // Since we've already remuxed audio, and we know how long the audio track is, we look to\n              // see if the delta to the next segment is longer than maxBufferHole.\n              // If so, playback would potentially get stuck, so we artificially inflate\n              // the duration of the last frame to minimize any potential gap between segments.\n              var gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n              var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;\n              if (deltaToFrameEnd > gapTolerance) {\n                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n                // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n                if (mp4SampleDuration < 0) {\n                  mp4SampleDuration = lastFrameDuration;\n                } else {\n                  stretchedLastFrame = true;\n                }\n                logger.log(\"[mp4-remuxer]: It is approximately \" + deltaToFrameEnd / 90 + \" ms to the next segment; using duration \" + mp4SampleDuration / 90 + \" ms for the last video frame.\");\n              } else {\n                mp4SampleDuration = lastFrameDuration;\n              }\n            } else {\n              mp4SampleDuration = lastFrameDuration;\n            }\n          }\n          var compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);\n          minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n          maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n          minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n          maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n          outputSamples.push(new Mp4Sample(avcSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n        }\n        if (outputSamples.length) {\n          if (chromeVersion) {\n            if (chromeVersion < 70) {\n              // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n              // https://code.google.com/p/chromium/issues/detail?id=229412\n              var flags = outputSamples[0].flags;\n              flags.dependsOn = 2;\n              flags.isNonSync = 0;\n            }\n          } else if (safariWebkitVersion) {\n            // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n            // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n            if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n              logger.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.');\n              var dts = firstDTS;\n              for (var _i3 = 0, len = outputSamples.length; _i3 < len; _i3++) {\n                var nextDts = dts + outputSamples[_i3].duration;\n                var _pts = dts + outputSamples[_i3].cts;\n                if (_i3 < len - 1) {\n                  var nextPts = nextDts + outputSamples[_i3 + 1].cts;\n                  outputSamples[_i3].duration = nextPts - _pts;\n                } else {\n                  outputSamples[_i3].duration = _i3 ? outputSamples[_i3 - 1].duration : averageSampleDuration;\n                }\n                outputSamples[_i3].cts = 0;\n                dts = nextDts;\n              }\n            }\n          }\n        }\n        // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n        mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n        this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n        this.videoSampleDuration = mp4SampleDuration;\n        this.isVideoContiguous = true;\n        var moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {\n          samples: outputSamples\n        }));\n        var type = 'video';\n        var data = {\n          data1: moof,\n          data2: mdat,\n          startPTS: minPTS / timeScale,\n          endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n          startDTS: firstDTS / timeScale,\n          endDTS: nextAvcDts / timeScale,\n          type: type,\n          hasAudio: false,\n          hasVideo: true,\n          nb: outputSamples.length,\n          dropped: track.dropped\n        };\n        track.samples = [];\n        track.dropped = 0;\n        return data;\n      };\n      _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n        var inputTimeScale = track.inputTimeScale;\n        var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n        var scaleFactor = inputTimeScale / mp4timeScale;\n        var mp4SampleDuration = track.segmentCodec === 'aac' ? AAC_SAMPLES_PER_FRAME : MPEG_AUDIO_SAMPLE_PER_FRAME;\n        var inputSampleDuration = mp4SampleDuration * scaleFactor;\n        var initPTS = this._initPTS;\n        var rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n        var outputSamples = [];\n        var alignedWithVideo = videoTimeOffset !== undefined;\n        var inputSamples = track.samples;\n        var offset = rawMPEG ? 0 : 8;\n        var nextAudioPts = this.nextAudioPts || -1;\n\n        // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n        // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n        // for sake of clarity:\n        // consecutive fragments are frags with\n        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n        //  - less than 20 audio frames distance\n        // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n        // this helps ensuring audio continuity\n        // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n        var timeOffsetMpegTS = timeOffset * inputTimeScale;\n        var initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;\n        this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);\n\n        // compute normalized PTS\n        inputSamples.forEach(function (sample) {\n          sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);\n        });\n        if (!contiguous || nextAudioPts < 0) {\n          // filter out sample with negative PTS that are not playable anyway\n          // if we don't remove these negative samples, they will shift all audio samples forward.\n          // leading to audio overlap between current / next fragment\n          inputSamples = inputSamples.filter(function (sample) {\n            return sample.pts >= 0;\n          });\n\n          // in case all samples have negative PTS, and have been filtered out, return now\n          if (!inputSamples.length) {\n            return;\n          }\n          if (videoTimeOffset === 0) {\n            // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n            nextAudioPts = 0;\n          } else if (accurateTimeOffset && !alignedWithVideo) {\n            // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n            nextAudioPts = Math.max(0, timeOffsetMpegTS);\n          } else {\n            // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n            nextAudioPts = inputSamples[0].pts;\n          }\n        }\n\n        // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n        // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n        // In an effort to prevent this from happening, we inject frames here where there are gaps.\n        // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n        // frame.\n\n        if (track.segmentCodec === 'aac') {\n          var maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n          for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {\n            // First, let's see how far off this frame is from where we expect it to be\n            var sample = inputSamples[i];\n            var pts = sample.pts;\n            var delta = pts - nextPts;\n            var duration = Math.abs(1000 * delta / inputTimeScale);\n\n            // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n            if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n              if (i === 0) {\n                logger.warn(\"Audio frame @ \" + (pts / inputTimeScale).toFixed(3) + \"s overlaps nextAudioPts by \" + Math.round(1000 * delta / inputTimeScale) + \" ms.\");\n                this.nextAudioPts = nextAudioPts = nextPts = pts;\n              }\n            } // eslint-disable-line brace-style\n\n            // Insert missing frames if:\n            // 1: We're more than maxAudioFramesDrift frame away\n            // 2: Not more than MAX_SILENT_FRAME_DURATION away\n            // 3: currentTime (aka nextPtsNorm) is not 0\n            // 4: remuxing with video (videoTimeOffset !== undefined)\n            else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n              var missing = Math.round(delta / inputSampleDuration);\n              // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n              // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n              nextPts = pts - missing * inputSampleDuration;\n              if (nextPts < 0) {\n                missing--;\n                nextPts += inputSampleDuration;\n              }\n              if (i === 0) {\n                this.nextAudioPts = nextAudioPts = nextPts;\n              }\n              logger.warn(\"[mp4-remuxer]: Injecting \" + missing + \" audio frame @ \" + (nextPts / inputTimeScale).toFixed(3) + \"s due to \" + Math.round(1000 * delta / inputTimeScale) + \" ms gap.\");\n              for (var j = 0; j < missing; j++) {\n                var newStamp = Math.max(nextPts, 0);\n                var fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                if (!fillFrame) {\n                  logger.log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.');\n                  fillFrame = sample.unit.subarray();\n                }\n                inputSamples.splice(i, 0, {\n                  unit: fillFrame,\n                  pts: newStamp\n                });\n                nextPts += inputSampleDuration;\n                i++;\n              }\n            }\n            sample.pts = nextPts;\n            nextPts += inputSampleDuration;\n          }\n        }\n        var firstPTS = null;\n        var lastPTS = null;\n        var mdat;\n        var mdatSize = 0;\n        var sampleLength = inputSamples.length;\n        while (sampleLength--) {\n          mdatSize += inputSamples[sampleLength].unit.byteLength;\n        }\n        for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {\n          var audioSample = inputSamples[_j2];\n          var unit = audioSample.unit;\n          var _pts2 = audioSample.pts;\n          if (lastPTS !== null) {\n            // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n            // the previous sample\n            var prevSample = outputSamples[_j2 - 1];\n            prevSample.duration = Math.round((_pts2 - lastPTS) / scaleFactor);\n          } else {\n            if (contiguous && track.segmentCodec === 'aac') {\n              // set PTS/DTS to expected PTS/DTS\n              _pts2 = nextAudioPts;\n            }\n            // remember first PTS of our audioSamples\n            firstPTS = _pts2;\n            if (mdatSize > 0) {\n              /* concatenate the audio data and construct the mdat in place\n                (need 8 more bytes to fill length and mdat type) */\n              mdatSize += offset;\n              try {\n                mdat = new Uint8Array(mdatSize);\n              } catch (err) {\n                this.observer.emit(Events.ERROR, Events.ERROR, {\n                  type: ErrorTypes.MUX_ERROR,\n                  details: ErrorDetails.REMUX_ALLOC_ERROR,\n                  fatal: false,\n                  error: err,\n                  bytes: mdatSize,\n                  reason: \"fail allocating audio mdat \" + mdatSize\n                });\n                return;\n              }\n              if (!rawMPEG) {\n                var view = new DataView(mdat.buffer);\n                view.setUint32(0, mdatSize);\n                mdat.set(MP4.types.mdat, 4);\n              }\n            } else {\n              // no audio samples\n              return;\n            }\n          }\n          mdat.set(unit, offset);\n          var unitLen = unit.byteLength;\n          offset += unitLen;\n          // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n          // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n          // becomes the PTS diff with the previous sample\n          outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n          lastPTS = _pts2;\n        }\n\n        // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n        var nbSamples = outputSamples.length;\n        if (!nbSamples) {\n          return;\n        }\n\n        // The next audio sample PTS should be equal to last sample PTS + duration\n        var lastSample = outputSamples[outputSamples.length - 1];\n        this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;\n\n        // Set the track samples from inputSamples to outputSamples before remuxing\n        var moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n          samples: outputSamples\n        }));\n\n        // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n        track.samples = [];\n        var start = firstPTS / inputTimeScale;\n        var end = nextAudioPts / inputTimeScale;\n        var type = 'audio';\n        var audioData = {\n          data1: moof,\n          data2: mdat,\n          startPTS: start,\n          endPTS: end,\n          startDTS: start,\n          endDTS: end,\n          type: type,\n          hasAudio: true,\n          hasVideo: false,\n          nb: nbSamples\n        };\n        this.isAudioContiguous = true;\n        return audioData;\n      };\n      _proto.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n        var inputTimeScale = track.inputTimeScale;\n        var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n        var scaleFactor = inputTimeScale / mp4timeScale;\n        var nextAudioPts = this.nextAudioPts;\n        // sync with video's timestamp\n        var initDTS = this._initDTS;\n        var init90kHz = initDTS.baseTime * 90000 / initDTS.timescale;\n        var startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;\n        var endDTS = videoData.endDTS * inputTimeScale + init90kHz;\n        // one sample's duration value\n        var frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;\n        // samples count of this segment's duration\n        var nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);\n        // silent frame\n        var silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n        logger.warn('[mp4-remuxer]: remux empty Audio');\n        // Can't remux if we can't generate a silent frame...\n        if (!silentFrame) {\n          logger.trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec');\n          return;\n        }\n        var samples = [];\n        for (var i = 0; i < nbSamples; i++) {\n          var stamp = startDTS + i * frameDuration;\n          samples.push({\n            unit: silentFrame,\n            pts: stamp,\n            dts: stamp\n          });\n        }\n        track.samples = samples;\n        return this.remuxAudio(track, timeOffset, contiguous, false);\n      };\n      return MP4Remuxer;\n    }();\n    function normalizePts(value, reference) {\n      var offset;\n      if (reference === null) {\n        return value;\n      }\n      if (reference < value) {\n        // - 2^33\n        offset = -8589934592;\n      } else {\n        // + 2^33\n        offset = 8589934592;\n      }\n      /* PTS is 33bit (from 0 to 2^33 -1)\n        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n        PTS looping occured. fill the gap */\n      while (Math.abs(value - reference) > 4294967296) {\n        value += offset;\n      }\n      return value;\n    }\n    function findKeyframeIndex(samples) {\n      for (var i = 0; i < samples.length; i++) {\n        if (samples[i].key) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n      var length = track.samples.length;\n      if (!length) {\n        return;\n      }\n      var inputTimeScale = track.inputTimeScale;\n      for (var index = 0; index < length; index++) {\n        var sample = track.samples[index];\n        // setting id3 pts, dts to relative time\n        // using this._initPTS and this._initDTS to calculate relative time\n        sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n        sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n      }\n      var samples = track.samples;\n      track.samples = [];\n      return {\n        samples: samples\n      };\n    }\n    function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n      var length = track.samples.length;\n      if (!length) {\n        return;\n      }\n      var inputTimeScale = track.inputTimeScale;\n      for (var index = 0; index < length; index++) {\n        var sample = track.samples[index];\n        // setting text pts, dts to relative time\n        // using this._initPTS and this._initDTS to calculate relative time\n        sample.pts = normalizePts(sample.pts - initPTS.baseTime * 90000 / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n      }\n      track.samples.sort(function (a, b) {\n        return a.pts - b.pts;\n      });\n      var samples = track.samples;\n      track.samples = [];\n      return {\n        samples: samples\n      };\n    }\n    var Mp4Sample = function Mp4Sample(isKeyframe, duration, size, cts) {\n      this.size = void 0;\n      this.duration = void 0;\n      this.cts = void 0;\n      this.flags = void 0;\n      this.duration = duration;\n      this.size = size;\n      this.cts = cts;\n      this.flags = new Mp4SampleFlags(isKeyframe);\n    };\n    var Mp4SampleFlags = function Mp4SampleFlags(isKeyframe) {\n      this.isLeading = 0;\n      this.isDependedOn = 0;\n      this.hasRedundancy = 0;\n      this.degradPrio = 0;\n      this.dependsOn = 1;\n      this.isNonSync = 1;\n      this.dependsOn = isKeyframe ? 2 : 1;\n      this.isNonSync = isKeyframe ? 0 : 1;\n    };\n    var PassThroughRemuxer = /*#__PURE__*/function () {\n      function PassThroughRemuxer() {\n        this.emitInitSegment = false;\n        this.audioCodec = void 0;\n        this.videoCodec = void 0;\n        this.initData = void 0;\n        this.initPTS = null;\n        this.initTracks = void 0;\n        this.lastEndTime = null;\n      }\n      var _proto = PassThroughRemuxer.prototype;\n      _proto.destroy = function destroy() {};\n      _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {\n        this.initPTS = defaultInitPTS;\n        this.lastEndTime = null;\n      };\n      _proto.resetNextTimestamp = function resetNextTimestamp() {\n        this.lastEndTime = null;\n      };\n      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n        this.audioCodec = audioCodec;\n        this.videoCodec = videoCodec;\n        this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));\n        this.emitInitSegment = true;\n      };\n      _proto.generateInitSegment = function generateInitSegment(initSegment) {\n        var audioCodec = this.audioCodec,\n          videoCodec = this.videoCodec;\n        if (!(initSegment != null && initSegment.byteLength)) {\n          this.initTracks = undefined;\n          this.initData = undefined;\n          return;\n        }\n        var initData = this.initData = parseInitSegment(initSegment);\n\n        // Get codec from initSegment or fallback to default\n        if (!audioCodec) {\n          audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);\n        }\n        if (!videoCodec) {\n          videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);\n        }\n        var tracks = {};\n        if (initData.audio && initData.video) {\n          tracks.audiovideo = {\n            container: 'video/mp4',\n            codec: audioCodec + ',' + videoCodec,\n            initSegment: initSegment,\n            id: 'main'\n          };\n        } else if (initData.audio) {\n          tracks.audio = {\n            container: 'audio/mp4',\n            codec: audioCodec,\n            initSegment: initSegment,\n            id: 'audio'\n          };\n        } else if (initData.video) {\n          tracks.video = {\n            container: 'video/mp4',\n            codec: videoCodec,\n            initSegment: initSegment,\n            id: 'main'\n          };\n        } else {\n          logger.warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.');\n        }\n        this.initTracks = tracks;\n      };\n      _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {\n        var _initData, _initData2;\n        var initPTS = this.initPTS,\n          lastEndTime = this.lastEndTime;\n        var result = {\n          audio: undefined,\n          video: undefined,\n          text: textTrack,\n          id3: id3Track,\n          initSegment: undefined\n        };\n\n        // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n        // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n        // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n        if (!isFiniteNumber(lastEndTime)) {\n          lastEndTime = this.lastEndTime = timeOffset || 0;\n        }\n\n        // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n        // audio or video (or both); adding it to video was an arbitrary choice.\n        var data = videoTrack.samples;\n        if (!(data != null && data.length)) {\n          return result;\n        }\n        var initSegment = {\n          initPTS: undefined,\n          timescale: 1\n        };\n        var initData = this.initData;\n        if (!((_initData = initData) != null && _initData.length)) {\n          this.generateInitSegment(data);\n          initData = this.initData;\n        }\n        if (!((_initData2 = initData) != null && _initData2.length)) {\n          // We can't remux if the initSegment could not be generated\n          logger.warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');\n          return result;\n        }\n        if (this.emitInitSegment) {\n          initSegment.tracks = this.initTracks;\n          this.emitInitSegment = false;\n        }\n        var duration = getDuration(data, initData);\n        var startDTS = getStartDTS(initData, data);\n        var decodeTime = startDTS === null ? timeOffset : startDTS;\n        if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {\n          initSegment.initPTS = decodeTime - timeOffset;\n          if (initPTS && initPTS.timescale === 1) {\n            logger.warn(\"Adjusting initPTS by \" + (initSegment.initPTS - initPTS.baseTime));\n          }\n          this.initPTS = initPTS = {\n            baseTime: initSegment.initPTS,\n            timescale: 1\n          };\n        }\n        var startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;\n        var endTime = startTime + duration;\n        offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);\n        if (duration > 0) {\n          this.lastEndTime = endTime;\n        } else {\n          logger.warn('Duration parsed from mp4 should be greater than zero');\n          this.resetNextTimestamp();\n        }\n        var hasAudio = !!initData.audio;\n        var hasVideo = !!initData.video;\n        var type = '';\n        if (hasAudio) {\n          type += 'audio';\n        }\n        if (hasVideo) {\n          type += 'video';\n        }\n        var track = {\n          data1: data,\n          startPTS: startTime,\n          startDTS: startTime,\n          endPTS: endTime,\n          endDTS: endTime,\n          type: type,\n          hasAudio: hasAudio,\n          hasVideo: hasVideo,\n          nb: 1,\n          dropped: 0\n        };\n        result.audio = track.type === 'audio' ? track : undefined;\n        result.video = track.type !== 'audio' ? track : undefined;\n        result.initSegment = initSegment;\n        result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);\n        if (textTrack.samples.length) {\n          result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);\n        }\n        return result;\n      };\n      return PassThroughRemuxer;\n    }();\n    function isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {\n      if (initPTS === null) {\n        return true;\n      }\n      // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n      var minDuration = Math.max(duration, 1);\n      var startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n      return Math.abs(startTime - timeOffset) > minDuration;\n    }\n    function getParsedTrackCodec(track, type) {\n      var parsedCodec = track == null ? void 0 : track.codec;\n      if (parsedCodec && parsedCodec.length > 4) {\n        return parsedCodec;\n      }\n      // Since mp4-tools cannot parse full codec string (see 'TODO: Parse codec details'... in mp4-tools)\n      // Provide defaults based on codec type\n      // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n      if (parsedCodec === 'hvc1' || parsedCodec === 'hev1') {\n        return 'hvc1.1.6.L120.90';\n      }\n      if (parsedCodec === 'av01') {\n        return 'av01.0.04M.08';\n      }\n      if (parsedCodec === 'avc1' || type === ElementaryStreamTypes.VIDEO) {\n        return 'avc1.42e01e';\n      }\n      return 'mp4a.40.5';\n    }\n    var now;\n    // performance.now() not available on WebWorker, at least on Safari Desktop\n    try {\n      now = self.performance.now.bind(self.performance);\n    } catch (err) {\n      logger.debug('Unable to use Performance API on this environment');\n      now = typeof self !== 'undefined' && self.Date.now;\n    }\n    var muxConfig = [{\n      demux: MP4Demuxer,\n      remux: PassThroughRemuxer\n    }, {\n      demux: TSDemuxer,\n      remux: MP4Remuxer\n    }, {\n      demux: AACDemuxer,\n      remux: MP4Remuxer\n    }, {\n      demux: MP3Demuxer,\n      remux: MP4Remuxer\n    }];\n    var Transmuxer = /*#__PURE__*/function () {\n      function Transmuxer(observer, typeSupported, config, vendor, id) {\n        this.async = false;\n        this.observer = void 0;\n        this.typeSupported = void 0;\n        this.config = void 0;\n        this.vendor = void 0;\n        this.id = void 0;\n        this.demuxer = void 0;\n        this.remuxer = void 0;\n        this.decrypter = void 0;\n        this.probe = void 0;\n        this.decryptionPromise = null;\n        this.transmuxConfig = void 0;\n        this.currentTransmuxState = void 0;\n        this.observer = observer;\n        this.typeSupported = typeSupported;\n        this.config = config;\n        this.vendor = vendor;\n        this.id = id;\n      }\n      var _proto = Transmuxer.prototype;\n      _proto.configure = function configure(transmuxConfig) {\n        this.transmuxConfig = transmuxConfig;\n        if (this.decrypter) {\n          this.decrypter.reset();\n        }\n      };\n      _proto.push = function push(data, decryptdata, chunkMeta, state) {\n        var _this = this;\n        var stats = chunkMeta.transmuxing;\n        stats.executeStart = now();\n        var uintData = new Uint8Array(data);\n        var currentTransmuxState = this.currentTransmuxState,\n          transmuxConfig = this.transmuxConfig;\n        if (state) {\n          this.currentTransmuxState = state;\n        }\n        var _ref = state || currentTransmuxState,\n          contiguous = _ref.contiguous,\n          discontinuity = _ref.discontinuity,\n          trackSwitch = _ref.trackSwitch,\n          accurateTimeOffset = _ref.accurateTimeOffset,\n          timeOffset = _ref.timeOffset,\n          initSegmentChange = _ref.initSegmentChange;\n        var audioCodec = transmuxConfig.audioCodec,\n          videoCodec = transmuxConfig.videoCodec,\n          defaultInitPts = transmuxConfig.defaultInitPts,\n          duration = transmuxConfig.duration,\n          initSegmentData = transmuxConfig.initSegmentData;\n        var keyData = getEncryptionType(uintData, decryptdata);\n        if (keyData && keyData.method === 'AES-128') {\n          var decrypter = this.getDecrypter();\n          // Software decryption is synchronous; webCrypto is not\n          if (decrypter.isSync()) {\n            // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n            // data is handled in the flush() call\n            var decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);\n            // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n            var loadingParts = chunkMeta.part > -1;\n            if (loadingParts) {\n              decryptedData = decrypter.flush();\n            }\n            if (!decryptedData) {\n              stats.executeEnd = now();\n              return emptyResult(chunkMeta);\n            }\n            uintData = new Uint8Array(decryptedData);\n          } else {\n            this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(function (decryptedData) {\n              // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n              // the decrypted data has been transmuxed\n              var result = _this.push(decryptedData, null, chunkMeta);\n              _this.decryptionPromise = null;\n              return result;\n            });\n            return this.decryptionPromise;\n          }\n        }\n        var resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n        if (resetMuxers) {\n          var error = this.configureTransmuxer(uintData);\n          if (error) {\n            logger.warn(\"[transmuxer] \" + error.message);\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.FRAG_PARSING_ERROR,\n              fatal: false,\n              error: error,\n              reason: error.message\n            });\n            stats.executeEnd = now();\n            return emptyResult(chunkMeta);\n          }\n        }\n        if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n          this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n        }\n        if (discontinuity || initSegmentChange || resetMuxers) {\n          this.resetInitialTimestamp(defaultInitPts);\n        }\n        if (!contiguous) {\n          this.resetContiguity();\n        }\n        var result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n        var currentState = this.currentTransmuxState;\n        currentState.contiguous = true;\n        currentState.discontinuity = false;\n        currentState.trackSwitch = false;\n        stats.executeEnd = now();\n        return result;\n      }\n\n      // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n      ;\n\n      _proto.flush = function flush(chunkMeta) {\n        var _this2 = this;\n        var stats = chunkMeta.transmuxing;\n        stats.executeStart = now();\n        var decrypter = this.decrypter,\n          currentTransmuxState = this.currentTransmuxState,\n          decryptionPromise = this.decryptionPromise;\n        if (decryptionPromise) {\n          // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n          // only flushing is required for async decryption\n          return decryptionPromise.then(function () {\n            return _this2.flush(chunkMeta);\n          });\n        }\n        var transmuxResults = [];\n        var timeOffset = currentTransmuxState.timeOffset;\n        if (decrypter) {\n          // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n          // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n          // or for progressive downloads with small segments)\n          var decryptedData = decrypter.flush();\n          if (decryptedData) {\n            // Push always returns a TransmuxerResult if decryptdata is null\n            transmuxResults.push(this.push(decryptedData, null, chunkMeta));\n          }\n        }\n        var demuxer = this.demuxer,\n          remuxer = this.remuxer;\n        if (!demuxer || !remuxer) {\n          // If probing failed, then Hls.js has been given content its not able to handle\n          stats.executeEnd = now();\n          return [emptyResult(chunkMeta)];\n        }\n        var demuxResultOrPromise = demuxer.flush(timeOffset);\n        if (isPromise(demuxResultOrPromise)) {\n          // Decrypt final SAMPLE-AES samples\n          return demuxResultOrPromise.then(function (demuxResult) {\n            _this2.flushRemux(transmuxResults, demuxResult, chunkMeta);\n            return transmuxResults;\n          });\n        }\n        this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n        return transmuxResults;\n      };\n      _proto.flushRemux = function flushRemux(transmuxResults, demuxResult, chunkMeta) {\n        var audioTrack = demuxResult.audioTrack,\n          videoTrack = demuxResult.videoTrack,\n          id3Track = demuxResult.id3Track,\n          textTrack = demuxResult.textTrack;\n        var _this$currentTransmux = this.currentTransmuxState,\n          accurateTimeOffset = _this$currentTransmux.accurateTimeOffset,\n          timeOffset = _this$currentTransmux.timeOffset;\n        logger.log(\"[transmuxer.ts]: Flushed fragment \" + chunkMeta.sn + (chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : '') + \" of level \" + chunkMeta.level);\n        var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n        transmuxResults.push({\n          remuxResult: remuxResult,\n          chunkMeta: chunkMeta\n        });\n        chunkMeta.transmuxing.executeEnd = now();\n      };\n      _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {\n        var demuxer = this.demuxer,\n          remuxer = this.remuxer;\n        if (!demuxer || !remuxer) {\n          return;\n        }\n        demuxer.resetTimeStamp(defaultInitPts);\n        remuxer.resetTimeStamp(defaultInitPts);\n      };\n      _proto.resetContiguity = function resetContiguity() {\n        var demuxer = this.demuxer,\n          remuxer = this.remuxer;\n        if (!demuxer || !remuxer) {\n          return;\n        }\n        demuxer.resetContiguity();\n        remuxer.resetNextTimestamp();\n      };\n      _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n        var demuxer = this.demuxer,\n          remuxer = this.remuxer;\n        if (!demuxer || !remuxer) {\n          return;\n        }\n        demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n        remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n      };\n      _proto.destroy = function destroy() {\n        if (this.demuxer) {\n          this.demuxer.destroy();\n          this.demuxer = undefined;\n        }\n        if (this.remuxer) {\n          this.remuxer.destroy();\n          this.remuxer = undefined;\n        }\n      };\n      _proto.transmux = function transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n        var result;\n        if (keyData && keyData.method === 'SAMPLE-AES') {\n          result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n        } else {\n          result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n        }\n        return result;\n      };\n      _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n        var _demux = this.demuxer.demux(data, timeOffset, false, !this.config.progressive),\n          audioTrack = _demux.audioTrack,\n          videoTrack = _demux.videoTrack,\n          id3Track = _demux.id3Track,\n          textTrack = _demux.textTrack;\n        var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n        return {\n          remuxResult: remuxResult,\n          chunkMeta: chunkMeta\n        };\n      };\n      _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n        var _this3 = this;\n        return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function (demuxResult) {\n          var remuxResult = _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, _this3.id);\n          return {\n            remuxResult: remuxResult,\n            chunkMeta: chunkMeta\n          };\n        });\n      };\n      _proto.configureTransmuxer = function configureTransmuxer(data) {\n        var config = this.config,\n          observer = this.observer,\n          typeSupported = this.typeSupported,\n          vendor = this.vendor;\n        // probe for content type\n        var mux;\n        for (var i = 0, len = muxConfig.length; i < len; i++) {\n          if (muxConfig[i].demux.probe(data)) {\n            mux = muxConfig[i];\n            break;\n          }\n        }\n        if (!mux) {\n          return new Error('Failed to find demuxer by probing fragment data');\n        }\n        // so let's check that current remuxer and demuxer are still valid\n        var demuxer = this.demuxer;\n        var remuxer = this.remuxer;\n        var Remuxer = mux.remux;\n        var Demuxer = mux.demux;\n        if (!remuxer || !(remuxer instanceof Remuxer)) {\n          this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n        }\n        if (!demuxer || !(demuxer instanceof Demuxer)) {\n          this.demuxer = new Demuxer(observer, config, typeSupported);\n          this.probe = Demuxer.probe;\n        }\n      };\n      _proto.needsProbing = function needsProbing(discontinuity, trackSwitch) {\n        // in case of continuity change, or track switch\n        // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n        return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n      };\n      _proto.getDecrypter = function getDecrypter() {\n        var decrypter = this.decrypter;\n        if (!decrypter) {\n          decrypter = this.decrypter = new Decrypter(this.config);\n        }\n        return decrypter;\n      };\n      return Transmuxer;\n    }();\n    function getEncryptionType(data, decryptData) {\n      var encryptionType = null;\n      if (data.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.iv !== null && decryptData.method != null) {\n        encryptionType = decryptData;\n      }\n      return encryptionType;\n    }\n    var emptyResult = function emptyResult(chunkMeta) {\n      return {\n        remuxResult: {},\n        chunkMeta: chunkMeta\n      };\n    };\n    function isPromise(p) {\n      return 'then' in p && p.then instanceof Function;\n    }\n    var TransmuxConfig = function TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n      this.audioCodec = void 0;\n      this.videoCodec = void 0;\n      this.initSegmentData = void 0;\n      this.duration = void 0;\n      this.defaultInitPts = void 0;\n      this.audioCodec = audioCodec;\n      this.videoCodec = videoCodec;\n      this.initSegmentData = initSegmentData;\n      this.duration = duration;\n      this.defaultInitPts = defaultInitPts || null;\n    };\n    var TransmuxState = function TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n      this.discontinuity = void 0;\n      this.contiguous = void 0;\n      this.accurateTimeOffset = void 0;\n      this.trackSwitch = void 0;\n      this.timeOffset = void 0;\n      this.initSegmentChange = void 0;\n      this.discontinuity = discontinuity;\n      this.contiguous = contiguous;\n      this.accurateTimeOffset = accurateTimeOffset;\n      this.trackSwitch = trackSwitch;\n      this.timeOffset = timeOffset;\n      this.initSegmentChange = initSegmentChange;\n    };\n    var eventemitter3 = {\n      exports: {}\n    };\n    (function (module) {\n      var has = Object.prototype.hasOwnProperty,\n        prefix = '~';\n\n      /**\n       * Constructor to create a storage for our `EE` objects.\n       * An `Events` instance is a plain object whose properties are event names.\n       *\n       * @constructor\n       * @private\n       */\n      function Events() {}\n\n      //\n      // We try to not inherit from `Object.prototype`. In some engines creating an\n      // instance in this way is faster than calling `Object.create(null)` directly.\n      // If `Object.create(null)` is not supported we prefix the event names with a\n      // character to make sure that the built-in object properties are not\n      // overridden or used as an attack vector.\n      //\n      if (Object.create) {\n        Events.prototype = Object.create(null);\n\n        //\n        // This hack is needed because the `__proto__` property is still inherited in\n        // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n        //\n        if (!new Events().__proto__) prefix = false;\n      }\n\n      /**\n       * Representation of a single event listener.\n       *\n       * @param {Function} fn The listener function.\n       * @param {*} context The context to invoke the listener with.\n       * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n       * @constructor\n       * @private\n       */\n      function EE(fn, context, once) {\n        this.fn = fn;\n        this.context = context;\n        this.once = once || false;\n      }\n\n      /**\n       * Add a listener for a given event.\n       *\n       * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n       * @param {(String|Symbol)} event The event name.\n       * @param {Function} fn The listener function.\n       * @param {*} context The context to invoke the listener with.\n       * @param {Boolean} once Specify if the listener is a one-time listener.\n       * @returns {EventEmitter}\n       * @private\n       */\n      function addListener(emitter, event, fn, context, once) {\n        if (typeof fn !== 'function') {\n          throw new TypeError('The listener must be a function');\n        }\n        var listener = new EE(fn, context || emitter, once),\n          evt = prefix ? prefix + event : event;\n        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];\n        return emitter;\n      }\n\n      /**\n       * Clear event by name.\n       *\n       * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n       * @param {(String|Symbol)} evt The Event name.\n       * @private\n       */\n      function clearEvent(emitter, evt) {\n        if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];\n      }\n\n      /**\n       * Minimal `EventEmitter` interface that is molded against the Node.js\n       * `EventEmitter` interface.\n       *\n       * @constructor\n       * @public\n       */\n      function EventEmitter() {\n        this._events = new Events();\n        this._eventsCount = 0;\n      }\n\n      /**\n       * Return an array listing the events for which the emitter has registered\n       * listeners.\n       *\n       * @returns {Array}\n       * @public\n       */\n      EventEmitter.prototype.eventNames = function eventNames() {\n        var names = [],\n          events,\n          name;\n        if (this._eventsCount === 0) return names;\n        for (name in events = this._events) {\n          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n        }\n        if (Object.getOwnPropertySymbols) {\n          return names.concat(Object.getOwnPropertySymbols(events));\n        }\n        return names;\n      };\n\n      /**\n       * Return the listeners registered for a given event.\n       *\n       * @param {(String|Symbol)} event The event name.\n       * @returns {Array} The registered listeners.\n       * @public\n       */\n      EventEmitter.prototype.listeners = function listeners(event) {\n        var evt = prefix ? prefix + event : event,\n          handlers = this._events[evt];\n        if (!handlers) return [];\n        if (handlers.fn) return [handlers.fn];\n        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n          ee[i] = handlers[i].fn;\n        }\n        return ee;\n      };\n\n      /**\n       * Return the number of listeners listening to a given event.\n       *\n       * @param {(String|Symbol)} event The event name.\n       * @returns {Number} The number of listeners.\n       * @public\n       */\n      EventEmitter.prototype.listenerCount = function listenerCount(event) {\n        var evt = prefix ? prefix + event : event,\n          listeners = this._events[evt];\n        if (!listeners) return 0;\n        if (listeners.fn) return 1;\n        return listeners.length;\n      };\n\n      /**\n       * Calls each of the listeners registered for a given event.\n       *\n       * @param {(String|Symbol)} event The event name.\n       * @returns {Boolean} `true` if the event had listeners, else `false`.\n       * @public\n       */\n      EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n        var evt = prefix ? prefix + event : event;\n        if (!this._events[evt]) return false;\n        var listeners = this._events[evt],\n          len = arguments.length,\n          args,\n          i;\n        if (listeners.fn) {\n          if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n          switch (len) {\n            case 1:\n              return listeners.fn.call(listeners.context), true;\n            case 2:\n              return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n              return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n              return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n          }\n          for (i = 1, args = new Array(len - 1); i < len; i++) {\n            args[i - 1] = arguments[i];\n          }\n          listeners.fn.apply(listeners.context, args);\n        } else {\n          var length = listeners.length,\n            j;\n          for (i = 0; i < length; i++) {\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch (len) {\n              case 1:\n                listeners[i].fn.call(listeners[i].context);\n                break;\n              case 2:\n                listeners[i].fn.call(listeners[i].context, a1);\n                break;\n              case 3:\n                listeners[i].fn.call(listeners[i].context, a1, a2);\n                break;\n              case 4:\n                listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                break;\n              default:\n                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n                  args[j - 1] = arguments[j];\n                }\n                listeners[i].fn.apply(listeners[i].context, args);\n            }\n          }\n        }\n        return true;\n      };\n\n      /**\n       * Add a listener for a given event.\n       *\n       * @param {(String|Symbol)} event The event name.\n       * @param {Function} fn The listener function.\n       * @param {*} [context=this] The context to invoke the listener with.\n       * @returns {EventEmitter} `this`.\n       * @public\n       */\n      EventEmitter.prototype.on = function on(event, fn, context) {\n        return addListener(this, event, fn, context, false);\n      };\n\n      /**\n       * Add a one-time listener for a given event.\n       *\n       * @param {(String|Symbol)} event The event name.\n       * @param {Function} fn The listener function.\n       * @param {*} [context=this] The context to invoke the listener with.\n       * @returns {EventEmitter} `this`.\n       * @public\n       */\n      EventEmitter.prototype.once = function once(event, fn, context) {\n        return addListener(this, event, fn, context, true);\n      };\n\n      /**\n       * Remove the listeners of a given event.\n       *\n       * @param {(String|Symbol)} event The event name.\n       * @param {Function} fn Only remove the listeners that match this function.\n       * @param {*} context Only remove the listeners that have this context.\n       * @param {Boolean} once Only remove one-time listeners.\n       * @returns {EventEmitter} `this`.\n       * @public\n       */\n      EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n        var evt = prefix ? prefix + event : event;\n        if (!this._events[evt]) return this;\n        if (!fn) {\n          clearEvent(this, evt);\n          return this;\n        }\n        var listeners = this._events[evt];\n        if (listeners.fn) {\n          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n            clearEvent(this, evt);\n          }\n        } else {\n          for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n              events.push(listeners[i]);\n            }\n          }\n\n          //\n          // Reset the array, or remove it completely if we have no more listeners.\n          //\n          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);\n        }\n        return this;\n      };\n\n      /**\n       * Remove all listeners, or those of the specified event.\n       *\n       * @param {(String|Symbol)} [event] The event name.\n       * @returns {EventEmitter} `this`.\n       * @public\n       */\n      EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n        var evt;\n        if (event) {\n          evt = prefix ? prefix + event : event;\n          if (this._events[evt]) clearEvent(this, evt);\n        } else {\n          this._events = new Events();\n          this._eventsCount = 0;\n        }\n        return this;\n      };\n\n      //\n      // Alias methods names because people roll like that.\n      //\n      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n      EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n      //\n      // Expose the prefix.\n      //\n      EventEmitter.prefixed = prefix;\n\n      //\n      // Allow `EventEmitter` to be imported as module namespace.\n      //\n      EventEmitter.EventEmitter = EventEmitter;\n\n      //\n      // Expose the module.\n      //\n      {\n        module.exports = EventEmitter;\n      }\n    })(eventemitter3);\n    var eventemitter3Exports = eventemitter3.exports;\n    var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);\n    if (typeof __IN_WORKER__ !== 'undefined' && __IN_WORKER__) {\n      startWorker(self);\n    }\n    function startWorker(self) {\n      var observer = new EventEmitter();\n      var forwardMessage = function forwardMessage(ev, data) {\n        self.postMessage({\n          event: ev,\n          data: data\n        });\n      };\n\n      // forward events to main thread\n      observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n      observer.on(Events.ERROR, forwardMessage);\n\n      // forward logger events to main thread\n      var forwardWorkerLogs = function forwardWorkerLogs() {\n        var _loop = function _loop(logFn) {\n          var func = function func(message) {\n            forwardMessage('workerLog', {\n              logType: logFn,\n              message: message\n            });\n          };\n          logger[logFn] = func;\n        };\n        for (var logFn in logger) {\n          _loop(logFn);\n        }\n      };\n      self.addEventListener('message', function (ev) {\n        var data = ev.data;\n        switch (data.cmd) {\n          case 'init':\n            {\n              var config = JSON.parse(data.config);\n              self.transmuxer = new Transmuxer(observer, data.typeSupported, config, data.vendor, data.id);\n              enableLogs(config.debug, data.id);\n              forwardWorkerLogs();\n              forwardMessage('init', null);\n              break;\n            }\n          case 'configure':\n            {\n              self.transmuxer.configure(data.config);\n              break;\n            }\n          case 'demux':\n            {\n              var transmuxResult = self.transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);\n              if (isPromise(transmuxResult)) {\n                self.transmuxer.async = true;\n                transmuxResult.then(function (data) {\n                  emitTransmuxComplete(self, data);\n                }).catch(function (error) {\n                  forwardMessage(Events.ERROR, {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    details: ErrorDetails.FRAG_PARSING_ERROR,\n                    chunkMeta: data.chunkMeta,\n                    fatal: false,\n                    error: error,\n                    err: error,\n                    reason: \"transmuxer-worker push error\"\n                  });\n                });\n              } else {\n                self.transmuxer.async = false;\n                emitTransmuxComplete(self, transmuxResult);\n              }\n              break;\n            }\n          case 'flush':\n            {\n              var id = data.chunkMeta;\n              var _transmuxResult = self.transmuxer.flush(id);\n              var asyncFlush = isPromise(_transmuxResult);\n              if (asyncFlush || self.transmuxer.async) {\n                if (!isPromise(_transmuxResult)) {\n                  _transmuxResult = Promise.resolve(_transmuxResult);\n                }\n                _transmuxResult.then(function (results) {\n                  handleFlushResult(self, results, id);\n                }).catch(function (error) {\n                  forwardMessage(Events.ERROR, {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    details: ErrorDetails.FRAG_PARSING_ERROR,\n                    chunkMeta: data.chunkMeta,\n                    fatal: false,\n                    error: error,\n                    err: error,\n                    reason: \"transmuxer-worker flush error\"\n                  });\n                });\n              } else {\n                handleFlushResult(self, _transmuxResult, id);\n              }\n              break;\n            }\n        }\n      });\n    }\n    function emitTransmuxComplete(self, transmuxResult) {\n      if (isEmptyResult(transmuxResult.remuxResult)) {\n        return false;\n      }\n      var transferable = [];\n      var _transmuxResult$remux = transmuxResult.remuxResult,\n        audio = _transmuxResult$remux.audio,\n        video = _transmuxResult$remux.video;\n      if (audio) {\n        addToTransferable(transferable, audio);\n      }\n      if (video) {\n        addToTransferable(transferable, video);\n      }\n      self.postMessage({\n        event: 'transmuxComplete',\n        data: transmuxResult\n      }, transferable);\n      return true;\n    }\n\n    // Converts data to a transferable object https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast)\n    // in order to minimize message passing overhead\n    function addToTransferable(transferable, track) {\n      if (track.data1) {\n        transferable.push(track.data1.buffer);\n      }\n      if (track.data2) {\n        transferable.push(track.data2.buffer);\n      }\n    }\n    function handleFlushResult(self, results, chunkMeta) {\n      var parsed = results.reduce(function (parsed, result) {\n        return emitTransmuxComplete(self, result) || parsed;\n      }, false);\n      if (!parsed) {\n        // Emit at least one \"transmuxComplete\" message even if media is not found to update stream-controller state to PARSING\n        self.postMessage({\n          event: 'transmuxComplete',\n          data: results[0]\n        });\n      }\n      self.postMessage({\n        event: 'flush',\n        data: chunkMeta\n      });\n    }\n    function isEmptyResult(remuxResult) {\n      return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;\n    }\n\n    // ensure the worker ends up in the bundle\n    // If the worker should not be included this gets aliased to empty.js\n    function hasUMDWorker() {\n      return typeof __HLS_WORKER_BUNDLE__ === 'function';\n    }\n    function injectWorker() {\n      var blob = new self.Blob([\"var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(\" + __HLS_WORKER_BUNDLE__.toString() + \")(true);\"], {\n        type: 'text/javascript'\n      });\n      var objectURL = self.URL.createObjectURL(blob);\n      var worker = new self.Worker(objectURL);\n      return {\n        worker: worker,\n        objectURL: objectURL\n      };\n    }\n    function loadWorker(path) {\n      var scriptURL = new self.URL(path, self.location.href).href;\n      var worker = new self.Worker(scriptURL);\n      return {\n        worker: worker,\n        scriptURL: scriptURL\n      };\n    }\n    var MediaSource$1 = getMediaSource() || {\n      isTypeSupported: function isTypeSupported() {\n        return false;\n      }\n    };\n    var TransmuxerInterface = /*#__PURE__*/function () {\n      function TransmuxerInterface(hls, id, onTransmuxComplete, onFlush) {\n        var _this = this;\n        this.error = null;\n        this.hls = void 0;\n        this.id = void 0;\n        this.observer = void 0;\n        this.frag = null;\n        this.part = null;\n        this.useWorker = void 0;\n        this.workerContext = null;\n        this.onwmsg = void 0;\n        this.transmuxer = null;\n        this.onTransmuxComplete = void 0;\n        this.onFlush = void 0;\n        var config = hls.config;\n        this.hls = hls;\n        this.id = id;\n        this.useWorker = !!config.enableWorker;\n        this.onTransmuxComplete = onTransmuxComplete;\n        this.onFlush = onFlush;\n        var forwardMessage = function forwardMessage(ev, data) {\n          data = data || {};\n          data.frag = _this.frag;\n          data.id = _this.id;\n          if (ev === Events.ERROR) {\n            _this.error = data.error;\n          }\n          _this.hls.trigger(ev, data);\n        };\n\n        // forward events to main thread\n        this.observer = new EventEmitter();\n        this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n        this.observer.on(Events.ERROR, forwardMessage);\n        var typeSupported = {\n          mp4: MediaSource$1.isTypeSupported('video/mp4'),\n          mpeg: MediaSource$1.isTypeSupported('audio/mpeg'),\n          mp3: MediaSource$1.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n        };\n        // navigator.vendor is not always available in Web Worker\n        // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator\n        var vendor = navigator.vendor;\n        if (this.useWorker && typeof Worker !== 'undefined') {\n          var canCreateWorker = config.workerPath || hasUMDWorker();\n          if (canCreateWorker) {\n            try {\n              if (config.workerPath) {\n                logger.log(\"loading Web Worker \" + config.workerPath + \" for \\\"\" + id + \"\\\"\");\n                this.workerContext = loadWorker(config.workerPath);\n              } else {\n                logger.log(\"injecting Web Worker for \\\"\" + id + \"\\\"\");\n                this.workerContext = injectWorker();\n              }\n              this.onwmsg = function (ev) {\n                return _this.onWorkerMessage(ev);\n              };\n              var worker = this.workerContext.worker;\n              worker.addEventListener('message', this.onwmsg);\n              worker.onerror = function (event) {\n                var error = new Error(event.message + \"  (\" + event.filename + \":\" + event.lineno + \")\");\n                config.enableWorker = false;\n                logger.warn(\"Error in \\\"\" + id + \"\\\" Web Worker, fallback to inline\");\n                _this.hls.trigger(Events.ERROR, {\n                  type: ErrorTypes.OTHER_ERROR,\n                  details: ErrorDetails.INTERNAL_EXCEPTION,\n                  fatal: false,\n                  event: 'demuxerWorker',\n                  error: error\n                });\n              };\n              worker.postMessage({\n                cmd: 'init',\n                typeSupported: typeSupported,\n                vendor: vendor,\n                id: id,\n                config: JSON.stringify(config)\n              });\n            } catch (err) {\n              logger.warn(\"Error setting up \\\"\" + id + \"\\\" Web Worker, fallback to inline\", err);\n              this.resetWorker();\n              this.error = null;\n              this.transmuxer = new Transmuxer(this.observer, typeSupported, config, vendor, id);\n            }\n            return;\n          }\n        }\n        this.transmuxer = new Transmuxer(this.observer, typeSupported, config, vendor, id);\n      }\n      var _proto = TransmuxerInterface.prototype;\n      _proto.resetWorker = function resetWorker() {\n        if (this.workerContext) {\n          var _this$workerContext = this.workerContext,\n            worker = _this$workerContext.worker,\n            objectURL = _this$workerContext.objectURL;\n          if (objectURL) {\n            // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n            self.URL.revokeObjectURL(objectURL);\n          }\n          worker.removeEventListener('message', this.onwmsg);\n          worker.onerror = null;\n          worker.terminate();\n          this.workerContext = null;\n        }\n      };\n      _proto.destroy = function destroy() {\n        if (this.workerContext) {\n          this.resetWorker();\n          this.onwmsg = undefined;\n        } else {\n          var transmuxer = this.transmuxer;\n          if (transmuxer) {\n            transmuxer.destroy();\n            this.transmuxer = null;\n          }\n        }\n        var observer = this.observer;\n        if (observer) {\n          observer.removeAllListeners();\n        }\n        this.frag = null;\n        // @ts-ignore\n        this.observer = null;\n        // @ts-ignore\n        this.hls = null;\n      };\n      _proto.push = function push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n        var _frag$initSegment,\n          _lastFrag$initSegment,\n          _this2 = this;\n        chunkMeta.transmuxing.start = self.performance.now();\n        var transmuxer = this.transmuxer;\n        var timeOffset = part ? part.start : frag.start;\n        // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n        var decryptdata = frag.decryptdata;\n        var lastFrag = this.frag;\n        var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n        var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n        var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n        var partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n        var progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);\n        var contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n        var now = self.performance.now();\n        if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n          frag.stats.parsing.start = now;\n        }\n        if (part && (partDiff || !contiguous)) {\n          part.stats.parsing.start = now;\n        }\n        var initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));\n        var state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n        if (!contiguous || discontinuity || initSegmentChange) {\n          logger.log(\"[transmuxer-interface, \" + frag.type + \"]: Starting new transmux session for sn: \" + chunkMeta.sn + \" p: \" + chunkMeta.part + \" level: \" + chunkMeta.level + \" id: \" + chunkMeta.id + \"\\n        discontinuity: \" + discontinuity + \"\\n        trackSwitch: \" + trackSwitch + \"\\n        contiguous: \" + contiguous + \"\\n        accurateTimeOffset: \" + accurateTimeOffset + \"\\n        timeOffset: \" + timeOffset + \"\\n        initSegmentChange: \" + initSegmentChange);\n          var config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n          this.configureTransmuxer(config);\n        }\n        this.frag = frag;\n        this.part = part;\n\n        // Frags with sn of 'initSegment' are not transmuxed\n        if (this.workerContext) {\n          // post fragment payload as transferable objects for ArrayBuffer (no copy)\n          this.workerContext.worker.postMessage({\n            cmd: 'demux',\n            data: data,\n            decryptdata: decryptdata,\n            chunkMeta: chunkMeta,\n            state: state\n          }, data instanceof ArrayBuffer ? [data] : []);\n        } else if (transmuxer) {\n          var _transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n          if (isPromise(_transmuxResult)) {\n            transmuxer.async = true;\n            _transmuxResult.then(function (data) {\n              _this2.handleTransmuxComplete(data);\n            }).catch(function (error) {\n              _this2.transmuxerError(error, chunkMeta, 'transmuxer-interface push error');\n            });\n          } else {\n            transmuxer.async = false;\n            this.handleTransmuxComplete(_transmuxResult);\n          }\n        }\n      };\n      _proto.flush = function flush(chunkMeta) {\n        var _this3 = this;\n        chunkMeta.transmuxing.start = self.performance.now();\n        var transmuxer = this.transmuxer;\n        if (this.workerContext) {\n          this.workerContext.worker.postMessage({\n            cmd: 'flush',\n            chunkMeta: chunkMeta\n          });\n        } else if (transmuxer) {\n          var _transmuxResult2 = transmuxer.flush(chunkMeta);\n          var asyncFlush = isPromise(_transmuxResult2);\n          if (asyncFlush || transmuxer.async) {\n            if (!isPromise(_transmuxResult2)) {\n              _transmuxResult2 = Promise.resolve(_transmuxResult2);\n            }\n            _transmuxResult2.then(function (data) {\n              _this3.handleFlushResult(data, chunkMeta);\n            }).catch(function (error) {\n              _this3.transmuxerError(error, chunkMeta, 'transmuxer-interface flush error');\n            });\n          } else {\n            this.handleFlushResult(_transmuxResult2, chunkMeta);\n          }\n        }\n      };\n      _proto.transmuxerError = function transmuxerError(error, chunkMeta, reason) {\n        if (!this.hls) {\n          return;\n        }\n        this.error = error;\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          chunkMeta: chunkMeta,\n          fatal: false,\n          error: error,\n          err: error,\n          reason: reason\n        });\n      };\n      _proto.handleFlushResult = function handleFlushResult(results, chunkMeta) {\n        var _this4 = this;\n        results.forEach(function (result) {\n          _this4.handleTransmuxComplete(result);\n        });\n        this.onFlush(chunkMeta);\n      };\n      _proto.onWorkerMessage = function onWorkerMessage(ev) {\n        var data = ev.data;\n        var hls = this.hls;\n        switch (data.event) {\n          case 'init':\n            {\n              var _this$workerContext2;\n              var objectURL = (_this$workerContext2 = this.workerContext) == null ? void 0 : _this$workerContext2.objectURL;\n              if (objectURL) {\n                // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n                self.URL.revokeObjectURL(objectURL);\n              }\n              break;\n            }\n          case 'transmuxComplete':\n            {\n              this.handleTransmuxComplete(data.data);\n              break;\n            }\n          case 'flush':\n            {\n              this.onFlush(data.data);\n              break;\n            }\n\n          // pass logs from the worker thread to the main logger\n          case 'workerLog':\n            if (logger[data.data.logType]) {\n              logger[data.data.logType](data.data.message);\n            }\n            break;\n          default:\n            {\n              data.data = data.data || {};\n              data.data.frag = this.frag;\n              data.data.id = this.id;\n              hls.trigger(data.event, data.data);\n              break;\n            }\n        }\n      };\n      _proto.configureTransmuxer = function configureTransmuxer(config) {\n        var transmuxer = this.transmuxer;\n        if (this.workerContext) {\n          this.workerContext.worker.postMessage({\n            cmd: 'configure',\n            config: config\n          });\n        } else if (transmuxer) {\n          transmuxer.configure(config);\n        }\n      };\n      _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {\n        result.chunkMeta.transmuxing.end = self.performance.now();\n        this.onTransmuxComplete(result);\n      };\n      return TransmuxerInterface;\n    }();\n    var STALL_MINIMUM_DURATION_MS = 250;\n    var MAX_START_GAP_JUMP = 2.0;\n    var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\n    var SKIP_BUFFER_RANGE_START = 0.05;\n    var GapController = /*#__PURE__*/function () {\n      function GapController(config, media, fragmentTracker, hls) {\n        this.config = void 0;\n        this.media = null;\n        this.fragmentTracker = void 0;\n        this.hls = void 0;\n        this.nudgeRetry = 0;\n        this.stallReported = false;\n        this.stalled = null;\n        this.moved = false;\n        this.seeking = false;\n        this.config = config;\n        this.media = media;\n        this.fragmentTracker = fragmentTracker;\n        this.hls = hls;\n      }\n      var _proto = GapController.prototype;\n      _proto.destroy = function destroy() {\n        this.media = null;\n        // @ts-ignore\n        this.hls = this.fragmentTracker = null;\n      }\n\n      /**\n       * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n       * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n       *\n       * @param lastCurrentTime - Previously read playhead position\n       */;\n      _proto.poll = function poll(lastCurrentTime, activeFrag) {\n        var config = this.config,\n          media = this.media,\n          stalled = this.stalled;\n        if (media === null) {\n          return;\n        }\n        var currentTime = media.currentTime,\n          seeking = media.seeking;\n        var seeked = this.seeking && !seeking;\n        var beginSeek = !this.seeking && seeking;\n        this.seeking = seeking;\n\n        // The playhead is moving, no-op\n        if (currentTime !== lastCurrentTime) {\n          this.moved = true;\n          if (stalled !== null) {\n            // The playhead is now moving, but was previously stalled\n            if (this.stallReported) {\n              var _stalledDuration = self.performance.now() - stalled;\n              logger.warn(\"playback not stuck anymore @\" + currentTime + \", after \" + Math.round(_stalledDuration) + \"ms\");\n              this.stallReported = false;\n            }\n            this.stalled = null;\n            this.nudgeRetry = 0;\n          }\n          return;\n        }\n\n        // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n        if (beginSeek || seeked) {\n          this.stalled = null;\n          return;\n        }\n\n        // The playhead should not be moving\n        if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {\n          return;\n        }\n        var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n        var isBuffered = bufferInfo.len > 0;\n        var nextStart = bufferInfo.nextStart || 0;\n\n        // There is no playable buffer (seeked, waiting for buffer)\n        if (!isBuffered && !nextStart) {\n          return;\n        }\n        if (seeking) {\n          // Waiting for seeking in a buffered range to complete\n          var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n          // Next buffered range is too far ahead to jump to while still seeking\n          var noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);\n          if (hasEnoughBuffer || noBufferGap) {\n            return;\n          }\n          // Reset moved state when seeking to a point in or before a gap\n          this.moved = false;\n        }\n\n        // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n        // The addition poll gives the browser a chance to jump the gap for us\n        if (!this.moved && this.stalled !== null) {\n          var _level$details;\n          // Jump start gaps within jump threshold\n          var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n\n          // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n          // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n          // that begins over 1 target duration after the video start position.\n          var level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;\n          var isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;\n          var maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;\n          var partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);\n          if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {\n            this._trySkipBufferHole(partialOrGap);\n            return;\n          }\n        }\n\n        // Start tracking stall time\n        var tnow = self.performance.now();\n        if (stalled === null) {\n          this.stalled = tnow;\n          return;\n        }\n        var stalledDuration = tnow - stalled;\n        if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {\n          // Report stalling after trying to fix\n          this._reportStall(bufferInfo);\n          if (!this.media) {\n            return;\n          }\n        }\n        var bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n        this._tryFixBufferStall(bufferedWithHoles, stalledDuration);\n      }\n\n      /**\n       * Detects and attempts to fix known buffer stalling issues.\n       * @param bufferInfo - The properties of the current buffer.\n       * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n       * @private\n       */;\n      _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {\n        var config = this.config,\n          fragmentTracker = this.fragmentTracker,\n          media = this.media;\n        if (media === null) {\n          return;\n        }\n        var currentTime = media.currentTime;\n        var partial = fragmentTracker.getPartialFragment(currentTime);\n        if (partial) {\n          // Try to skip over the buffer hole caused by a partial fragment\n          // This method isn't limited by the size of the gap between buffered ranges\n          var targetTime = this._trySkipBufferHole(partial);\n          // we return here in this case, meaning\n          // the branch below only executes when we haven't seeked to a new position\n          if (targetTime || !this.media) {\n            return;\n          }\n        }\n\n        // if we haven't had to skip over a buffer hole of a partial fragment\n        // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n        // needs to cross some sort of threshold covering all source-buffers content\n        // to start playing properly.\n        if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {\n          logger.warn('Trying to nudge playhead over buffer-hole');\n          // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n          // We only try to jump the hole if it's under the configured size\n          // Reset stalled so to rearm watchdog timer\n          this.stalled = null;\n          this._tryNudgeBuffer();\n        }\n      }\n\n      /**\n       * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n       * @param bufferLen - The playhead distance from the end of the current buffer segment.\n       * @private\n       */;\n      _proto._reportStall = function _reportStall(bufferInfo) {\n        var hls = this.hls,\n          media = this.media,\n          stallReported = this.stallReported;\n        if (!stallReported && media) {\n          // Report stalled error once\n          this.stallReported = true;\n          var error = new Error(\"Playback stalling at @\" + media.currentTime + \" due to low buffer (\" + JSON.stringify(bufferInfo) + \")\");\n          logger.warn(error.message);\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_STALLED_ERROR,\n            fatal: false,\n            error: error,\n            buffer: bufferInfo.len\n          });\n        }\n      }\n\n      /**\n       * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n       * @param partial - The partial fragment found at the current time (where playback is stalling).\n       * @private\n       */;\n      _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {\n        var config = this.config,\n          hls = this.hls,\n          media = this.media;\n        if (media === null) {\n          return 0;\n        }\n\n        // Check if currentTime is between unbuffered regions of partial fragments\n        var currentTime = media.currentTime;\n        var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n        var startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;\n        if (startTime) {\n          var bufferStarved = bufferInfo.len <= config.maxBufferHole;\n          var waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;\n          var gapLength = startTime - currentTime;\n          if (gapLength > 0 && (bufferStarved || waiting)) {\n            // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial\n            if (gapLength > config.maxBufferHole) {\n              var fragmentTracker = this.fragmentTracker;\n              var startGap = false;\n              if (currentTime === 0) {\n                var startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);\n                if (startFrag && startTime < startFrag.end) {\n                  startGap = true;\n                }\n              }\n              if (!startGap) {\n                var startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);\n                if (startProvisioned) {\n                  var moreToLoad = false;\n                  var pos = startProvisioned.end;\n                  while (pos < startTime) {\n                    var provisioned = fragmentTracker.getPartialFragment(pos);\n                    if (provisioned) {\n                      pos += provisioned.duration;\n                    } else {\n                      moreToLoad = true;\n                      break;\n                    }\n                  }\n                  if (moreToLoad) {\n                    return 0;\n                  }\n                }\n              }\n            }\n            var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n            logger.warn(\"skipping hole, adjusting currentTime from \" + currentTime + \" to \" + targetTime);\n            this.moved = true;\n            this.stalled = null;\n            media.currentTime = targetTime;\n            if (partial && !partial.gap) {\n              var error = new Error(\"fragment loaded with buffer holes, seeking from \" + currentTime + \" to \" + targetTime);\n              hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n                fatal: false,\n                error: error,\n                reason: error.message,\n                frag: partial\n              });\n            }\n            return targetTime;\n          }\n        }\n        return 0;\n      }\n\n      /**\n       * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n       * @private\n       */;\n      _proto._tryNudgeBuffer = function _tryNudgeBuffer() {\n        var config = this.config,\n          hls = this.hls,\n          media = this.media,\n          nudgeRetry = this.nudgeRetry;\n        if (media === null) {\n          return;\n        }\n        var currentTime = media.currentTime;\n        this.nudgeRetry++;\n        if (nudgeRetry < config.nudgeMaxRetry) {\n          var targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n          // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n          var error = new Error(\"Nudging 'currentTime' from \" + currentTime + \" to \" + targetTime);\n          logger.warn(error.message);\n          media.currentTime = targetTime;\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n            error: error,\n            fatal: false\n          });\n        } else {\n          var _error = new Error(\"Playhead still not moving while enough data buffered @\" + currentTime + \" after \" + config.nudgeMaxRetry + \" nudges\");\n          logger.error(_error.message);\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_STALLED_ERROR,\n            error: _error,\n            fatal: true\n          });\n        }\n      };\n      return GapController;\n    }();\n    var TICK_INTERVAL = 100; // how often to tick in ms\n    var StreamController = /*#__PURE__*/function (_BaseStreamController) {\n      _inheritsLoose(StreamController, _BaseStreamController);\n      function StreamController(hls, fragmentTracker, keyLoader) {\n        var _this;\n        _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, '[stream-controller]', PlaylistLevelType.MAIN) || this;\n        _this.audioCodecSwap = false;\n        _this.gapController = null;\n        _this.level = -1;\n        _this._forceStartLoad = false;\n        _this.altAudio = false;\n        _this.audioOnly = false;\n        _this.fragPlaying = null;\n        _this.onvplaying = null;\n        _this.onvseeked = null;\n        _this.fragLastKbps = 0;\n        _this.couldBacktrack = false;\n        _this.backtrackFragment = null;\n        _this.audioCodecSwitch = false;\n        _this.videoBuffer = null;\n        _this._registerListeners();\n        return _this;\n      }\n      var _proto = StreamController.prototype;\n      _proto._registerListeners = function _registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n        hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n        hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      };\n      _proto._unregisterListeners = function _unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n        hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n        hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      };\n      _proto.onHandlerDestroying = function onHandlerDestroying() {\n        this._unregisterListeners();\n        this.onMediaDetaching();\n      };\n      _proto.startLoad = function startLoad(startPosition) {\n        if (this.levels) {\n          var lastCurrentTime = this.lastCurrentTime,\n            hls = this.hls;\n          this.stopLoad();\n          this.setInterval(TICK_INTERVAL);\n          this.level = -1;\n          if (!this.startFragRequested) {\n            // determine load level\n            var startLevel = hls.startLevel;\n            if (startLevel === -1) {\n              if (hls.config.testBandwidth && this.levels.length > 1) {\n                // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n                startLevel = 0;\n                this.bitrateTest = true;\n              } else {\n                startLevel = hls.nextAutoLevel;\n              }\n            }\n            // set new level to playlist loader : this will trigger start level load\n            // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n            this.level = hls.nextLoadLevel = startLevel;\n            this.loadedmetadata = false;\n          }\n          // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n          if (lastCurrentTime > 0 && startPosition === -1) {\n            this.log(\"Override startPosition with lastCurrentTime @\" + lastCurrentTime.toFixed(3));\n            startPosition = lastCurrentTime;\n          }\n          this.state = State.IDLE;\n          this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n          this.tick();\n        } else {\n          this._forceStartLoad = true;\n          this.state = State.STOPPED;\n        }\n      };\n      _proto.stopLoad = function stopLoad() {\n        this._forceStartLoad = false;\n        _BaseStreamController.prototype.stopLoad.call(this);\n      };\n      _proto.doTick = function doTick() {\n        switch (this.state) {\n          case State.WAITING_LEVEL:\n            {\n              var _levels$level;\n              var levels = this.levels,\n                level = this.level;\n              var details = levels == null ? void 0 : (_levels$level = levels[level]) == null ? void 0 : _levels$level.details;\n              if (details && (!details.live || this.levelLastLoaded === this.level)) {\n                if (this.waitForCdnTuneIn(details)) {\n                  break;\n                }\n                this.state = State.IDLE;\n                break;\n              }\n              break;\n            }\n          case State.FRAG_LOADING_WAITING_RETRY:\n            {\n              var _this$media;\n              var now = self.performance.now();\n              var retryDate = this.retryDate;\n              // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n              if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n                this.resetStartWhenNotLoaded(this.level);\n                this.state = State.IDLE;\n              }\n            }\n            break;\n        }\n        if (this.state === State.IDLE) {\n          this.doTickIdle();\n        }\n        this.onTickEnd();\n      };\n      _proto.onTickEnd = function onTickEnd() {\n        _BaseStreamController.prototype.onTickEnd.call(this);\n        this.checkBuffer();\n        this.checkFragmentChanged();\n      };\n      _proto.doTickIdle = function doTickIdle() {\n        var hls = this.hls,\n          levelLastLoaded = this.levelLastLoaded,\n          levels = this.levels,\n          media = this.media;\n        var config = hls.config,\n          level = hls.nextLoadLevel;\n\n        // if start level not parsed yet OR\n        // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n        // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n        if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {\n          return;\n        }\n\n        // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n        if (this.altAudio && this.audioOnly) {\n          return;\n        }\n        if (!(levels != null && levels[level])) {\n          return;\n        }\n        var levelInfo = levels[level];\n\n        // if buffer length is less than maxBufLen try to load a new fragment\n\n        var bufferInfo = this.getMainFwdBufferInfo();\n        if (bufferInfo === null) {\n          return;\n        }\n        var lastDetails = this.getLevelDetails();\n        if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n          var data = {};\n          if (this.altAudio) {\n            data.type = 'video';\n          }\n          this.hls.trigger(Events.BUFFER_EOS, data);\n          this.state = State.ENDED;\n          return;\n        }\n\n        // set next load level : this will trigger a playlist load if needed\n        if (hls.loadLevel !== level && hls.manualLevel === -1) {\n          this.log(\"Adapting to level \" + level + \" from level \" + this.level);\n        }\n        this.level = hls.nextLoadLevel = level;\n        var levelDetails = levelInfo.details;\n        // if level info not retrieved yet, switch state and wait for level retrieval\n        // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n        // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n        if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== level) {\n          this.level = level;\n          this.state = State.WAITING_LEVEL;\n          return;\n        }\n        var bufferLen = bufferInfo.len;\n\n        // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n        var maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n\n        // Stay idle if we are still with buffer margins\n        if (bufferLen >= maxBufLen) {\n          return;\n        }\n        if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n          this.backtrackFragment = null;\n        }\n        var targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n        var frag = this.getNextFragment(targetBufferTime, levelDetails);\n        // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n        if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== 'initSegment' && this.fragmentTracker.getState(frag) !== FragmentState.OK) {\n          var _this$backtrackFragme;\n          var backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n          var fragIdx = backtrackSn - levelDetails.startSN;\n          var backtrackFrag = levelDetails.fragments[fragIdx - 1];\n          if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n            frag = backtrackFrag;\n            this.fragmentTracker.removeFragment(backtrackFrag);\n          }\n        } else if (this.backtrackFragment && bufferInfo.len) {\n          this.backtrackFragment = null;\n        }\n        // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n        if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n          var gapStart = frag.gap;\n          if (!gapStart) {\n            // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n            var type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;\n            var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n            if (mediaBuffer) {\n              this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n            }\n          }\n          frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n        }\n        if (!frag) {\n          return;\n        }\n        if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n          frag = frag.initSegment;\n        }\n        this.loadFragment(frag, levelInfo, targetBufferTime);\n      };\n      _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {\n        // Check if fragment is not loaded\n        var fragState = this.fragmentTracker.getState(frag);\n        this.fragCurrent = frag;\n        if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n          if (frag.sn === 'initSegment') {\n            this._loadInitSegment(frag, level);\n          } else if (this.bitrateTest) {\n            this.log(\"Fragment \" + frag.sn + \" of level \" + frag.level + \" is being downloaded to test bitrate and will not be buffered\");\n            this._loadBitrateTestFrag(frag, level);\n          } else {\n            this.startFragRequested = true;\n            _BaseStreamController.prototype.loadFragment.call(this, frag, level, targetBufferTime);\n          }\n        } else {\n          this.clearTrackerIfNeeded(frag);\n        }\n      };\n      _proto.getBufferedFrag = function getBufferedFrag(position) {\n        return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);\n      };\n      _proto.followingBufferedFrag = function followingBufferedFrag(frag) {\n        if (frag) {\n          // try to get range of next fragment (500ms after this range)\n          return this.getBufferedFrag(frag.end + 0.5);\n        }\n        return null;\n      }\n\n      /*\n        on immediate level switch :\n         - pause playback if playing\n         - cancel any pending load request\n         - and trigger a buffer flush\n      */;\n      _proto.immediateLevelSwitch = function immediateLevelSwitch() {\n        this.abortCurrentFrag();\n        this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n      }\n\n      /**\n       * try to switch ASAP without breaking video playback:\n       * in order to ensure smooth but quick level switching,\n       * we need to find the next flushable buffer range\n       * we should take into account new segment fetch time\n       */;\n      _proto.nextLevelSwitch = function nextLevelSwitch() {\n        var levels = this.levels,\n          media = this.media;\n        // ensure that media is defined and that metadata are available (to retrieve currentTime)\n        if (media != null && media.readyState) {\n          var fetchdelay;\n          var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n          if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n            // flush buffer preceding current fragment (flush until current fragment start offset)\n            // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n            this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n          }\n          var levelDetails = this.getLevelDetails();\n          if (levelDetails != null && levelDetails.live) {\n            var bufferInfo = this.getMainFwdBufferInfo();\n            // Do not flush in live stream with low buffer\n            if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {\n              return;\n            }\n          }\n          if (!media.paused && levels) {\n            // add a safety delay of 1s\n            var nextLevelId = this.hls.nextLoadLevel;\n            var nextLevel = levels[nextLevelId];\n            var fragLastKbps = this.fragLastKbps;\n            if (fragLastKbps && this.fragCurrent) {\n              fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n            } else {\n              fetchdelay = 0;\n            }\n          } else {\n            fetchdelay = 0;\n          }\n          // this.log('fetchdelay:'+fetchdelay);\n          // find buffer range that will be reached once new fragment will be fetched\n          var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n          if (bufferedFrag) {\n            // we can flush buffer range following this one without stalling playback\n            var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n            if (nextBufferedFrag) {\n              // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n              this.abortCurrentFrag();\n              // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n              var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n              var fragDuration = nextBufferedFrag.duration;\n              var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * 0.5), fragDuration * 0.75));\n              this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n            }\n          }\n        }\n      };\n      _proto.abortCurrentFrag = function abortCurrentFrag() {\n        var fragCurrent = this.fragCurrent;\n        this.fragCurrent = null;\n        this.backtrackFragment = null;\n        if (fragCurrent) {\n          fragCurrent.abortRequests();\n          this.fragmentTracker.removeFragment(fragCurrent);\n        }\n        switch (this.state) {\n          case State.KEY_LOADING:\n          case State.FRAG_LOADING:\n          case State.FRAG_LOADING_WAITING_RETRY:\n          case State.PARSING:\n          case State.PARSED:\n            this.state = State.IDLE;\n            break;\n        }\n        this.nextLoadPosition = this.getLoadPosition();\n      };\n      _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {\n        _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio ? 'video' : null);\n      };\n      _proto.onMediaAttached = function onMediaAttached(event, data) {\n        _BaseStreamController.prototype.onMediaAttached.call(this, event, data);\n        var media = data.media;\n        this.onvplaying = this.onMediaPlaying.bind(this);\n        this.onvseeked = this.onMediaSeeked.bind(this);\n        media.addEventListener('playing', this.onvplaying);\n        media.addEventListener('seeked', this.onvseeked);\n        this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);\n      };\n      _proto.onMediaDetaching = function onMediaDetaching() {\n        var media = this.media;\n        if (media && this.onvplaying && this.onvseeked) {\n          media.removeEventListener('playing', this.onvplaying);\n          media.removeEventListener('seeked', this.onvseeked);\n          this.onvplaying = this.onvseeked = null;\n          this.videoBuffer = null;\n        }\n        this.fragPlaying = null;\n        if (this.gapController) {\n          this.gapController.destroy();\n          this.gapController = null;\n        }\n        _BaseStreamController.prototype.onMediaDetaching.call(this);\n      };\n      _proto.onMediaPlaying = function onMediaPlaying() {\n        // tick to speed up FRAG_CHANGED triggering\n        this.tick();\n      };\n      _proto.onMediaSeeked = function onMediaSeeked() {\n        var media = this.media;\n        var currentTime = media ? media.currentTime : null;\n        if (isFiniteNumber(currentTime)) {\n          this.log(\"Media seeked to \" + currentTime.toFixed(3));\n        }\n\n        // If seeked was issued before buffer was appended do not tick immediately\n        var bufferInfo = this.getMainFwdBufferInfo();\n        if (bufferInfo === null || bufferInfo.len === 0) {\n          this.warn(\"Main forward buffer length on \\\"seeked\\\" event \" + (bufferInfo ? bufferInfo.len : 'empty') + \")\");\n          return;\n        }\n\n        // tick to speed up FRAG_CHANGED triggering\n        this.tick();\n      };\n      _proto.onManifestLoading = function onManifestLoading() {\n        // reset buffer on manifest loading\n        this.log('Trigger BUFFER_RESET');\n        this.hls.trigger(Events.BUFFER_RESET, undefined);\n        this.fragmentTracker.removeAllFragments();\n        this.couldBacktrack = false;\n        this.startPosition = this.lastCurrentTime = 0;\n        this.levels = this.fragPlaying = this.backtrackFragment = null;\n        this.altAudio = this.audioOnly = false;\n      };\n      _proto.onManifestParsed = function onManifestParsed(event, data) {\n        var aac = false;\n        var heaac = false;\n        var codec;\n        data.levels.forEach(function (level) {\n          // detect if we have different kind of audio codecs used amongst playlists\n          codec = level.audioCodec;\n          if (codec) {\n            if (codec.indexOf('mp4a.40.2') !== -1) {\n              aac = true;\n            }\n            if (codec.indexOf('mp4a.40.5') !== -1) {\n              heaac = true;\n            }\n          }\n        });\n        this.audioCodecSwitch = aac && heaac && !changeTypeSupported();\n        if (this.audioCodecSwitch) {\n          this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n        }\n        this.levels = data.levels;\n        this.startFragRequested = false;\n      };\n      _proto.onLevelLoading = function onLevelLoading(event, data) {\n        var levels = this.levels;\n        if (!levels || this.state !== State.IDLE) {\n          return;\n        }\n        var level = levels[data.level];\n        if (!level.details || level.details.live && this.levelLastLoaded !== data.level || this.waitForCdnTuneIn(level.details)) {\n          this.state = State.WAITING_LEVEL;\n        }\n      };\n      _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n        var _curLevel$details;\n        var levels = this.levels;\n        var newLevelId = data.level;\n        var newDetails = data.details;\n        var duration = newDetails.totalduration;\n        if (!levels) {\n          this.warn(\"Levels were reset while loading level \" + newLevelId);\n          return;\n        }\n        this.log(\"Level \" + newLevelId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"]\" + (newDetails.lastPartSn ? \"[part-\" + newDetails.lastPartSn + \"-\" + newDetails.lastPartIndex + \"]\" : '') + \", cc [\" + newDetails.startCC + \", \" + newDetails.endCC + \"] duration:\" + duration);\n        var curLevel = levels[newLevelId];\n        var fragCurrent = this.fragCurrent;\n        if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {\n          if ((fragCurrent.level !== data.level || fragCurrent.urlId !== curLevel.urlId) && fragCurrent.loader) {\n            this.abortCurrentFrag();\n          }\n        }\n        var sliding = 0;\n        if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {\n          if (!newDetails.fragments[0]) {\n            newDetails.deltaUpdateFailed = true;\n          }\n          if (newDetails.deltaUpdateFailed) {\n            return;\n          }\n          sliding = this.alignPlaylists(newDetails, curLevel.details);\n        }\n        // override level info\n        curLevel.details = newDetails;\n        this.levelLastLoaded = newLevelId;\n        this.hls.trigger(Events.LEVEL_UPDATED, {\n          details: newDetails,\n          level: newLevelId\n        });\n\n        // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n        if (this.state === State.WAITING_LEVEL) {\n          if (this.waitForCdnTuneIn(newDetails)) {\n            // Wait for Low-Latency CDN Tune-in\n            return;\n          }\n          this.state = State.IDLE;\n        }\n        if (!this.startFragRequested) {\n          this.setStartPosition(newDetails, sliding);\n        } else if (newDetails.live) {\n          this.synchronizeToLiveEdge(newDetails);\n        }\n\n        // trigger handler right now\n        this.tick();\n      };\n      _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {\n        var _frag$initSegment;\n        var frag = data.frag,\n          part = data.part,\n          payload = data.payload;\n        var levels = this.levels;\n        if (!levels) {\n          this.warn(\"Levels were reset while fragment load was in progress. Fragment \" + frag.sn + \" of level \" + frag.level + \" will not be buffered\");\n          return;\n        }\n        var currentLevel = levels[frag.level];\n        var details = currentLevel.details;\n        if (!details) {\n          this.warn(\"Dropping fragment \" + frag.sn + \" of level \" + frag.level + \" after level details were reset\");\n          this.fragmentTracker.removeFragment(frag);\n          return;\n        }\n        var videoCodec = currentLevel.videoCodec;\n\n        // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n        var accurateTimeOffset = details.PTSKnown || !details.live;\n        var initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n        var audioCodec = this._getAudioCodec(currentLevel);\n\n        // transmux the MPEG-TS data to ISO-BMFF segments\n        // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n        var transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n        var partIndex = part ? part.index : -1;\n        var partial = partIndex !== -1;\n        var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n        var initPTS = this.initPTS[frag.cc];\n        transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n      };\n      _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n        // if any URL found on new audio track, it is an alternate audio track\n        var fromAltAudio = this.altAudio;\n        var altAudio = !!data.url;\n        // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n        // don't do anything if we switch to alt audio: audio stream controller is handling it.\n        // we will just have to change buffer scheduling on audioTrackSwitched\n        if (!altAudio) {\n          if (this.mediaBuffer !== this.media) {\n            this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n            this.mediaBuffer = this.media;\n            var fragCurrent = this.fragCurrent;\n            // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n            if (fragCurrent) {\n              this.log('Switching to main audio track, cancel main fragment load');\n              fragCurrent.abortRequests();\n              this.fragmentTracker.removeFragment(fragCurrent);\n            }\n            // destroy transmuxer to force init segment generation (following audio switch)\n            this.resetTransmuxer();\n            // switch to IDLE state to load new fragment\n            this.resetLoadingState();\n          } else if (this.audioOnly) {\n            // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n            this.resetTransmuxer();\n          }\n          var hls = this.hls;\n          // If switching from alt to main audio, flush all audio and trigger track switched\n          if (fromAltAudio) {\n            hls.trigger(Events.BUFFER_FLUSHING, {\n              startOffset: 0,\n              endOffset: Number.POSITIVE_INFINITY,\n              type: null\n            });\n            this.fragmentTracker.removeAllFragments();\n          }\n          hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n        }\n      };\n      _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {\n        var trackId = data.id;\n        var altAudio = !!this.hls.audioTracks[trackId].url;\n        if (altAudio) {\n          var videoBuffer = this.videoBuffer;\n          // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n          if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n            this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n            this.mediaBuffer = videoBuffer;\n          }\n        }\n        this.altAudio = altAudio;\n        this.tick();\n      };\n      _proto.onBufferCreated = function onBufferCreated(event, data) {\n        var tracks = data.tracks;\n        var mediaTrack;\n        var name;\n        var alternate = false;\n        for (var type in tracks) {\n          var track = tracks[type];\n          if (track.id === 'main') {\n            name = type;\n            mediaTrack = track;\n            // keep video source buffer reference\n            if (type === 'video') {\n              var videoTrack = tracks[type];\n              if (videoTrack) {\n                this.videoBuffer = videoTrack.buffer;\n              }\n            }\n          } else {\n            alternate = true;\n          }\n        }\n        if (alternate && mediaTrack) {\n          this.log(\"Alternate track found, use \" + name + \".buffered to schedule main fragment loading\");\n          this.mediaBuffer = mediaTrack.buffer;\n        } else {\n          this.mediaBuffer = this.media;\n        }\n      };\n      _proto.onFragBuffered = function onFragBuffered(event, data) {\n        var frag = data.frag,\n          part = data.part;\n        if (frag && frag.type !== PlaylistLevelType.MAIN) {\n          return;\n        }\n        if (this.fragContextChanged(frag)) {\n          // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n          // Avoid setting state back to IDLE, since that will interfere with a level switch\n          this.warn(\"Fragment \" + frag.sn + (part ? ' p: ' + part.index : '') + \" of level \" + frag.level + \" finished buffering, but was aborted. state: \" + this.state);\n          if (this.state === State.PARSED) {\n            this.state = State.IDLE;\n          }\n          return;\n        }\n        var stats = part ? part.stats : frag.stats;\n        this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n        if (frag.sn !== 'initSegment') {\n          this.fragPrevious = frag;\n        }\n        this.fragBufferedComplete(frag, part);\n      };\n      _proto.onError = function onError(event, data) {\n        var _data$context;\n        if (data.fatal) {\n          this.state = State.ERROR;\n          return;\n        }\n        switch (data.details) {\n          case ErrorDetails.FRAG_GAP:\n          case ErrorDetails.FRAG_PARSING_ERROR:\n          case ErrorDetails.FRAG_DECRYPT_ERROR:\n          case ErrorDetails.FRAG_LOAD_ERROR:\n          case ErrorDetails.FRAG_LOAD_TIMEOUT:\n          case ErrorDetails.KEY_LOAD_ERROR:\n          case ErrorDetails.KEY_LOAD_TIMEOUT:\n            this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);\n            break;\n          case ErrorDetails.LEVEL_LOAD_ERROR:\n          case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n          case ErrorDetails.LEVEL_PARSING_ERROR:\n            // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE\n            if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {\n              this.state = State.IDLE;\n            }\n            break;\n          case ErrorDetails.BUFFER_FULL_ERROR:\n            if (!data.parent || data.parent !== 'main') {\n              return;\n            }\n            if (this.reduceLengthAndFlushBuffer(data)) {\n              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n            }\n            break;\n          case ErrorDetails.INTERNAL_EXCEPTION:\n            this.recoverWorkerError(data);\n            break;\n        }\n      }\n\n      // Checks the health of the buffer and attempts to resolve playback stalls.\n      ;\n\n      _proto.checkBuffer = function checkBuffer() {\n        var media = this.media,\n          gapController = this.gapController;\n        if (!media || !gapController || !media.readyState) {\n          // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n          return;\n        }\n        if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {\n          // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n          var activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;\n          gapController.poll(this.lastCurrentTime, activeFrag);\n        }\n        this.lastCurrentTime = media.currentTime;\n      };\n      _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {\n        this.state = State.IDLE;\n        // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n        // in that case, reset startFragRequested flag\n        if (!this.loadedmetadata) {\n          this.startFragRequested = false;\n          this.nextLoadPosition = this.startPosition;\n        }\n        this.tickImmediate();\n      };\n      _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {\n        var type = _ref.type;\n        if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {\n          var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n        }\n      };\n      _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {\n        this.levels = data.levels;\n      };\n      _proto.swapAudioCodec = function swapAudioCodec() {\n        this.audioCodecSwap = !this.audioCodecSwap;\n      }\n\n      /**\n       * Seeks to the set startPosition if not equal to the mediaElement's current time.\n       */;\n      _proto.seekToStartPos = function seekToStartPos() {\n        var media = this.media;\n        if (!media) {\n          return;\n        }\n        var currentTime = media.currentTime;\n        var startPosition = this.startPosition;\n        // only adjust currentTime if different from startPosition or if startPosition not buffered\n        // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n        if (startPosition >= 0 && currentTime < startPosition) {\n          if (media.seeking) {\n            this.log(\"could not seek to \" + startPosition + \", already seeking at \" + currentTime);\n            return;\n          }\n          var buffered = BufferHelper.getBuffered(media);\n          var bufferStart = buffered.length ? buffered.start(0) : 0;\n          var delta = bufferStart - startPosition;\n          if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {\n            this.log(\"adjusting start position by \" + delta + \" to match buffer start\");\n            startPosition += delta;\n            this.startPosition = startPosition;\n          }\n          this.log(\"seek to target start position \" + startPosition + \" from current time \" + currentTime);\n          media.currentTime = startPosition;\n        }\n      };\n      _proto._getAudioCodec = function _getAudioCodec(currentLevel) {\n        var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n        if (this.audioCodecSwap && audioCodec) {\n          this.log('Swapping audio codec');\n          if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n          } else {\n            audioCodec = 'mp4a.40.5';\n          }\n        }\n        return audioCodec;\n      };\n      _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(frag, level) {\n        var _this2 = this;\n        frag.bitrateTest = true;\n        this._doFragLoad(frag, level).then(function (data) {\n          var hls = _this2.hls;\n          if (!data || _this2.fragContextChanged(frag)) {\n            return;\n          }\n          level.fragmentError = 0;\n          _this2.state = State.IDLE;\n          _this2.startFragRequested = false;\n          _this2.bitrateTest = false;\n          var stats = frag.stats;\n          // Bitrate tests fragments are neither parsed nor buffered\n          stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n          hls.trigger(Events.FRAG_LOADED, data);\n          frag.bitrateTest = false;\n        });\n      };\n      _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {\n        var _id3$samples;\n        var id = 'main';\n        var hls = this.hls;\n        var remuxResult = transmuxResult.remuxResult,\n          chunkMeta = transmuxResult.chunkMeta;\n        var context = this.getCurrentContext(chunkMeta);\n        if (!context) {\n          this.resetWhenMissingContext(chunkMeta);\n          return;\n        }\n        var frag = context.frag,\n          part = context.part,\n          level = context.level;\n        var video = remuxResult.video,\n          text = remuxResult.text,\n          id3 = remuxResult.id3,\n          initSegment = remuxResult.initSegment;\n        var details = level.details;\n        // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n        var audio = this.altAudio ? undefined : remuxResult.audio;\n\n        // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n        // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n        if (this.fragContextChanged(frag)) {\n          this.fragmentTracker.removeFragment(frag);\n          return;\n        }\n        this.state = State.PARSING;\n        if (initSegment) {\n          if (initSegment != null && initSegment.tracks) {\n            var mapFragment = frag.initSegment || frag;\n            this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n            hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n              frag: mapFragment,\n              id: id,\n              tracks: initSegment.tracks\n            });\n          }\n\n          // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n          var initPTS = initSegment.initPTS;\n          var timescale = initSegment.timescale;\n          if (isFiniteNumber(initPTS)) {\n            this.initPTS[frag.cc] = {\n              baseTime: initPTS,\n              timescale: timescale\n            };\n            hls.trigger(Events.INIT_PTS_FOUND, {\n              frag: frag,\n              id: id,\n              initPTS: initPTS,\n              timescale: timescale\n            });\n          }\n        }\n\n        // Avoid buffering if backtracking this fragment\n        if (video && remuxResult.independent !== false) {\n          if (details) {\n            var startPTS = video.startPTS,\n              endPTS = video.endPTS,\n              startDTS = video.startDTS,\n              endDTS = video.endDTS;\n            if (part) {\n              part.elementaryStreams[video.type] = {\n                startPTS: startPTS,\n                endPTS: endPTS,\n                startDTS: startDTS,\n                endDTS: endDTS\n              };\n            } else {\n              if (video.firstKeyFrame && video.independent && chunkMeta.id === 1) {\n                this.couldBacktrack = true;\n              }\n              if (video.dropped && video.independent) {\n                // Backtrack if dropped frames create a gap after currentTime\n\n                var bufferInfo = this.getMainFwdBufferInfo();\n                var targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n                var startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n                if (targetBufferTime < startTime - this.config.maxBufferHole) {\n                  this.backtrack(frag);\n                  return;\n                }\n                // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n                frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n              }\n            }\n            frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n            if (this.backtrackFragment) {\n              this.backtrackFragment = frag;\n            }\n            this.bufferFragmentData(video, frag, part, chunkMeta);\n          }\n        } else if (remuxResult.independent === false) {\n          this.backtrack(frag);\n          return;\n        }\n        if (audio) {\n          var _startPTS = audio.startPTS,\n            _endPTS = audio.endPTS,\n            _startDTS = audio.startDTS,\n            _endDTS = audio.endDTS;\n          if (part) {\n            part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n              startPTS: _startPTS,\n              endPTS: _endPTS,\n              startDTS: _startDTS,\n              endDTS: _endDTS\n            };\n          }\n          frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);\n          this.bufferFragmentData(audio, frag, part, chunkMeta);\n        }\n        if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n          var emittedID3 = {\n            id: id,\n            frag: frag,\n            details: details,\n            samples: id3.samples\n          };\n          hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n        }\n        if (details && text) {\n          var emittedText = {\n            id: id,\n            frag: frag,\n            details: details,\n            samples: text.samples\n          };\n          hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n        }\n      };\n      _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n        var _this3 = this;\n        if (this.state !== State.PARSING) {\n          return;\n        }\n        this.audioOnly = !!tracks.audio && !tracks.video;\n\n        // if audio track is expected to come from audio stream controller, discard any coming from main\n        if (this.altAudio && !this.audioOnly) {\n          delete tracks.audio;\n        }\n        // include levelCodec in audio and video tracks\n        var audio = tracks.audio,\n          video = tracks.video,\n          audiovideo = tracks.audiovideo;\n        if (audio) {\n          var audioCodec = currentLevel.audioCodec;\n          var ua = navigator.userAgent.toLowerCase();\n          if (this.audioCodecSwitch) {\n            if (audioCodec) {\n              if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n                audioCodec = 'mp4a.40.2';\n              } else {\n                audioCodec = 'mp4a.40.5';\n              }\n            }\n            // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n            // force HE-AAC, as it seems that most browsers prefers it.\n            // don't force HE-AAC if mono stream, or in Firefox\n            if (audio.metadata.channelCount !== 1 && ua.indexOf('firefox') === -1) {\n              audioCodec = 'mp4a.40.5';\n            }\n          }\n          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n          if (ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n            // Exclude mpeg audio\n            audioCodec = 'mp4a.40.2';\n            this.log(\"Android: force audio codec to \" + audioCodec);\n          }\n          if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {\n            this.log(\"Swapping manifest audio codec \\\"\" + currentLevel.audioCodec + \"\\\" for \\\"\" + audioCodec + \"\\\"\");\n          }\n          audio.levelCodec = audioCodec;\n          audio.id = 'main';\n          this.log(\"Init audio buffer, container:\" + audio.container + \", codecs[selected/level/parsed]=[\" + (audioCodec || '') + \"/\" + (currentLevel.audioCodec || '') + \"/\" + audio.codec + \"]\");\n        }\n        if (video) {\n          video.levelCodec = currentLevel.videoCodec;\n          video.id = 'main';\n          this.log(\"Init video buffer, container:\" + video.container + \", codecs[level/parsed]=[\" + (currentLevel.videoCodec || '') + \"/\" + video.codec + \"]\");\n        }\n        if (audiovideo) {\n          this.log(\"Init audiovideo buffer, container:\" + audiovideo.container + \", codecs[level/parsed]=[\" + (currentLevel.attrs.CODECS || '') + \"/\" + audiovideo.codec + \"]\");\n        }\n        this.hls.trigger(Events.BUFFER_CODECS, tracks);\n        // loop through tracks that are going to be provided to bufferController\n        Object.keys(tracks).forEach(function (trackName) {\n          var track = tracks[trackName];\n          var initSegment = track.initSegment;\n          if (initSegment != null && initSegment.byteLength) {\n            _this3.hls.trigger(Events.BUFFER_APPENDING, {\n              type: trackName,\n              data: initSegment,\n              frag: frag,\n              part: null,\n              chunkMeta: chunkMeta,\n              parent: frag.type\n            });\n          }\n        });\n        // trigger handler right now\n        this.tick();\n      };\n      _proto.getMainFwdBufferInfo = function getMainFwdBufferInfo() {\n        return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);\n      };\n      _proto.backtrack = function backtrack(frag) {\n        this.couldBacktrack = true;\n        // Causes findFragments to backtrack through fragments to find the keyframe\n        this.backtrackFragment = frag;\n        this.resetTransmuxer();\n        this.flushBufferGap(frag);\n        this.fragmentTracker.removeFragment(frag);\n        this.fragPrevious = null;\n        this.nextLoadPosition = frag.start;\n        this.state = State.IDLE;\n      };\n      _proto.checkFragmentChanged = function checkFragmentChanged() {\n        var video = this.media;\n        var fragPlayingCurrent = null;\n        if (video && video.readyState > 1 && video.seeking === false) {\n          var currentTime = video.currentTime;\n          /* if video element is in seeked state, currentTime can only increase.\n            (assuming that playback rate is positive ...)\n            As sometimes currentTime jumps back to zero after a\n            media decode error, check this, to avoid seeking back to\n            wrong position after a media decode error\n          */\n\n          if (BufferHelper.isBuffered(video, currentTime)) {\n            fragPlayingCurrent = this.getAppendedFrag(currentTime);\n          } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {\n            /* ensure that FRAG_CHANGED event is triggered at startup,\n              when first video frame is displayed and playback is paused.\n              add a tolerance of 100ms, in case current position is not buffered,\n              check if current pos+100ms is buffered and use that buffer range\n              for FRAG_CHANGED event reporting */\n            fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n          }\n          if (fragPlayingCurrent) {\n            this.backtrackFragment = null;\n            var fragPlaying = this.fragPlaying;\n            var fragCurrentLevel = fragPlayingCurrent.level;\n            if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel || fragPlayingCurrent.urlId !== fragPlaying.urlId) {\n              this.fragPlaying = fragPlayingCurrent;\n              this.hls.trigger(Events.FRAG_CHANGED, {\n                frag: fragPlayingCurrent\n              });\n              if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n                this.hls.trigger(Events.LEVEL_SWITCHED, {\n                  level: fragCurrentLevel\n                });\n              }\n            }\n          }\n        }\n      };\n      _createClass(StreamController, [{\n        key: \"nextLevel\",\n        get: function get() {\n          var frag = this.nextBufferedFrag;\n          if (frag) {\n            return frag.level;\n          }\n          return -1;\n        }\n      }, {\n        key: \"currentFrag\",\n        get: function get() {\n          var media = this.media;\n          if (media) {\n            return this.fragPlaying || this.getAppendedFrag(media.currentTime);\n          }\n          return null;\n        }\n      }, {\n        key: \"currentProgramDateTime\",\n        get: function get() {\n          var media = this.media;\n          if (media) {\n            var currentTime = media.currentTime;\n            var frag = this.currentFrag;\n            if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {\n              var epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;\n              return new Date(epocMs);\n            }\n          }\n          return null;\n        }\n      }, {\n        key: \"currentLevel\",\n        get: function get() {\n          var frag = this.currentFrag;\n          if (frag) {\n            return frag.level;\n          }\n          return -1;\n        }\n      }, {\n        key: \"nextBufferedFrag\",\n        get: function get() {\n          var frag = this.currentFrag;\n          if (frag) {\n            return this.followingBufferedFrag(frag);\n          }\n          return null;\n        }\n      }, {\n        key: \"forceStartLoad\",\n        get: function get() {\n          return this._forceStartLoad;\n        }\n      }]);\n      return StreamController;\n    }(BaseStreamController);\n\n    /*\n     * compute an Exponential Weighted moving average\n     * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n     *  - heavily inspired from shaka-player\n     */\n    var EWMA = /*#__PURE__*/function () {\n      //  About half of the estimated value will be from the last |halfLife| samples by weight.\n      function EWMA(halfLife, estimate, weight) {\n        if (estimate === void 0) {\n          estimate = 0;\n        }\n        if (weight === void 0) {\n          weight = 0;\n        }\n        this.halfLife = void 0;\n        this.alpha_ = void 0;\n        this.estimate_ = void 0;\n        this.totalWeight_ = void 0;\n        this.halfLife = halfLife;\n        // Larger values of alpha expire historical data more slowly.\n        this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n        this.estimate_ = estimate;\n        this.totalWeight_ = weight;\n      }\n      var _proto = EWMA.prototype;\n      _proto.sample = function sample(weight, value) {\n        var adjAlpha = Math.pow(this.alpha_, weight);\n        this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n        this.totalWeight_ += weight;\n      };\n      _proto.getTotalWeight = function getTotalWeight() {\n        return this.totalWeight_;\n      };\n      _proto.getEstimate = function getEstimate() {\n        if (this.alpha_) {\n          var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n          if (zeroFactor) {\n            return this.estimate_ / zeroFactor;\n          }\n        }\n        return this.estimate_;\n      };\n      return EWMA;\n    }();\n\n    /*\n     * EWMA Bandwidth Estimator\n     *  - heavily inspired from shaka-player\n     * Tracks bandwidth samples and estimates available bandwidth.\n     * Based on the minimum of two exponentially-weighted moving averages with\n     * different half-lives.\n     */\n\n    var EwmaBandWidthEstimator = /*#__PURE__*/function () {\n      function EwmaBandWidthEstimator(slow, fast, defaultEstimate, defaultTTFB) {\n        if (defaultTTFB === void 0) {\n          defaultTTFB = 100;\n        }\n        this.defaultEstimate_ = void 0;\n        this.minWeight_ = void 0;\n        this.minDelayMs_ = void 0;\n        this.slow_ = void 0;\n        this.fast_ = void 0;\n        this.defaultTTFB_ = void 0;\n        this.ttfb_ = void 0;\n        this.defaultEstimate_ = defaultEstimate;\n        this.minWeight_ = 0.001;\n        this.minDelayMs_ = 50;\n        this.slow_ = new EWMA(slow);\n        this.fast_ = new EWMA(fast);\n        this.defaultTTFB_ = defaultTTFB;\n        this.ttfb_ = new EWMA(slow);\n      }\n      var _proto = EwmaBandWidthEstimator.prototype;\n      _proto.update = function update(slow, fast) {\n        var slow_ = this.slow_,\n          fast_ = this.fast_,\n          ttfb_ = this.ttfb_;\n        if (slow_.halfLife !== slow) {\n          this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());\n        }\n        if (fast_.halfLife !== fast) {\n          this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());\n        }\n        if (ttfb_.halfLife !== slow) {\n          this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());\n        }\n      };\n      _proto.sample = function sample(durationMs, numBytes) {\n        durationMs = Math.max(durationMs, this.minDelayMs_);\n        var numBits = 8 * numBytes;\n        // weight is duration in seconds\n        var durationS = durationMs / 1000;\n        // value is bandwidth in bits/s\n        var bandwidthInBps = numBits / durationS;\n        this.fast_.sample(durationS, bandwidthInBps);\n        this.slow_.sample(durationS, bandwidthInBps);\n      };\n      _proto.sampleTTFB = function sampleTTFB(ttfb) {\n        // weight is frequency curve applied to TTFB in seconds\n        // (longer times have less weight with expected input under 1 second)\n        var seconds = ttfb / 1000;\n        var weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);\n        this.ttfb_.sample(weight, Math.max(ttfb, 5));\n      };\n      _proto.canEstimate = function canEstimate() {\n        return this.fast_.getTotalWeight() >= this.minWeight_;\n      };\n      _proto.getEstimate = function getEstimate() {\n        if (this.canEstimate()) {\n          // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n          // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n          // Take the minimum of these two estimates.  This should have the effect of\n          // adapting down quickly, but up more slowly.\n          return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n        } else {\n          return this.defaultEstimate_;\n        }\n      };\n      _proto.getEstimateTTFB = function getEstimateTTFB() {\n        if (this.ttfb_.getTotalWeight() >= this.minWeight_) {\n          return this.ttfb_.getEstimate();\n        } else {\n          return this.defaultTTFB_;\n        }\n      };\n      _proto.destroy = function destroy() {};\n      return EwmaBandWidthEstimator;\n    }();\n    var AbrController = /*#__PURE__*/function () {\n      function AbrController(hls) {\n        this.hls = void 0;\n        this.lastLevelLoadSec = 0;\n        this.lastLoadedFragLevel = 0;\n        this._nextAutoLevel = -1;\n        this.timer = -1;\n        this.onCheck = this._abandonRulesCheck.bind(this);\n        this.fragCurrent = null;\n        this.partCurrent = null;\n        this.bitrateTestDelay = 0;\n        this.bwEstimator = void 0;\n        this.hls = hls;\n        var config = hls.config;\n        this.bwEstimator = new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n        this.registerListeners();\n      }\n      var _proto = AbrController.prototype;\n      _proto.registerListeners = function registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      };\n      _proto.unregisterListeners = function unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      };\n      _proto.destroy = function destroy() {\n        this.unregisterListeners();\n        this.clearTimer();\n        // @ts-ignore\n        this.hls = this.onCheck = null;\n        this.fragCurrent = this.partCurrent = null;\n      };\n      _proto.onFragLoading = function onFragLoading(event, data) {\n        var _data$part;\n        var frag = data.frag;\n        if (this.ignoreFragment(frag)) {\n          return;\n        }\n        this.fragCurrent = frag;\n        this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n        this.clearTimer();\n        this.timer = self.setInterval(this.onCheck, 100);\n      };\n      _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n        this.clearTimer();\n      };\n      _proto.getTimeToLoadFrag = function getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {\n        var fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;\n        var playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;\n        return fragLoadSec + playlistLoadSec;\n      };\n      _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n        var config = this.hls.config;\n        var _data$stats = data.stats,\n          total = _data$stats.total,\n          bwEstimate = _data$stats.bwEstimate;\n        // Total is the bytelength and bwEstimate in bits/sec\n        if (isFiniteNumber(total) && isFiniteNumber(bwEstimate)) {\n          this.lastLevelLoadSec = 8 * total / bwEstimate;\n        }\n        if (data.details.live) {\n          this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n        } else {\n          this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n        }\n      }\n\n      /*\n          This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n          quickly enough to prevent underbuffering\n        */;\n      _proto._abandonRulesCheck = function _abandonRulesCheck() {\n        var frag = this.fragCurrent,\n          part = this.partCurrent,\n          hls = this.hls;\n        var autoLevelEnabled = hls.autoLevelEnabled,\n          media = hls.media;\n        if (!frag || !media) {\n          return;\n        }\n        var now = performance.now();\n        var stats = part ? part.stats : frag.stats;\n        var duration = part ? part.duration : frag.duration;\n        var timeLoading = now - stats.loading.start;\n        // If frag loading is aborted, complete, or from lowest level, stop timer and return\n        if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level === 0) {\n          this.clearTimer();\n          // reset forced auto level value so that next level will be selected\n          this._nextAutoLevel = -1;\n          return;\n        }\n\n        // This check only runs if we're in ABR mode and actually playing\n        if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {\n          return;\n        }\n        var bufferInfo = hls.mainForwardBufferInfo;\n        if (bufferInfo === null) {\n          return;\n        }\n        var ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n        var playbackRate = Math.abs(media.playbackRate);\n        // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed\n        if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {\n          return;\n        }\n\n        // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n        var bufferStarvationDelay = bufferInfo.len / playbackRate;\n        // Only downswitch if less than 2 fragment lengths are buffered\n        if (bufferStarvationDelay >= 2 * duration / playbackRate) {\n          return;\n        }\n        var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n        var loadedFirstByte = stats.loaded && ttfb > -1;\n        var bwEstimate = this.bwEstimator.getEstimate();\n        var levels = hls.levels,\n          minAutoLevel = hls.minAutoLevel;\n        var level = levels[frag.level];\n        var expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.maxBitrate / 8));\n        var timeStreaming = timeLoading - ttfb;\n        if (timeStreaming < 1 && loadedFirstByte) {\n          timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);\n        }\n        var loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;\n        // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n        var fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;\n        // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n        if (fragLoadedDelay <= bufferStarvationDelay) {\n          return;\n        }\n        var bwe = loadRate ? loadRate * 8 : bwEstimate;\n        var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n        var nextLoadLevel;\n        // Iterate through lower level and try to find the largest one that avoids rebuffering\n        for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n          // compute time to load next fragment at lower level\n          // 8 = bits per byte (bps/Bps)\n          var levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n          fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);\n          if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n            break;\n          }\n        }\n        // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n        // to load the current one\n        if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n          return;\n        }\n\n        // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down\n        if (fragLevelNextLoadedDelay > duration * 10) {\n          return;\n        }\n        hls.nextLoadLevel = nextLoadLevel;\n        if (loadedFirstByte) {\n          // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time\n          this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n        } else {\n          // If there has been no loading progress, sample TTFB\n          this.bwEstimator.sampleTTFB(timeLoading);\n        }\n        this.clearTimer();\n        logger.warn(\"[abr] Fragment \" + frag.sn + (part ? ' part ' + part.index : '') + \" of level \" + frag.level + \" is loading too slowly;\\n      Time to underbuffer: \" + bufferStarvationDelay.toFixed(3) + \" s\\n      Estimated load time for current fragment: \" + fragLoadedDelay.toFixed(3) + \" s\\n      Estimated load time for down switch fragment: \" + fragLevelNextLoadedDelay.toFixed(3) + \" s\\n      TTFB estimate: \" + ttfb + \"\\n      Current BW estimate: \" + (isFiniteNumber(bwEstimate) ? (bwEstimate / 1024).toFixed(3) : 'Unknown') + \" Kb/s\\n      New BW estimate: \" + (this.bwEstimator.getEstimate() / 1024).toFixed(3) + \" Kb/s\\n      Aborting and switching to level \" + nextLoadLevel);\n        if (frag.loader) {\n          this.fragCurrent = this.partCurrent = null;\n          frag.abortRequests();\n        }\n        hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n          frag: frag,\n          part: part,\n          stats: stats\n        });\n      };\n      _proto.onFragLoaded = function onFragLoaded(event, _ref) {\n        var frag = _ref.frag,\n          part = _ref.part;\n        var stats = part ? part.stats : frag.stats;\n        if (frag.type === PlaylistLevelType.MAIN) {\n          this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);\n        }\n        if (this.ignoreFragment(frag)) {\n          return;\n        }\n        // stop monitoring bw once frag loaded\n        this.clearTimer();\n        // store level id after successful fragment load\n        this.lastLoadedFragLevel = frag.level;\n        // reset forced auto level value so that next level will be selected\n        this._nextAutoLevel = -1;\n\n        // compute level average bitrate\n        if (this.hls.config.abrMaxWithRealBitrate) {\n          var duration = part ? part.duration : frag.duration;\n          var level = this.hls.levels[frag.level];\n          var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n          var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n          level.loaded = {\n            bytes: loadedBytes,\n            duration: loadedDuration\n          };\n          level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n        }\n        if (frag.bitrateTest) {\n          var fragBufferedData = {\n            stats: stats,\n            frag: frag,\n            part: part,\n            id: frag.type\n          };\n          this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);\n          frag.bitrateTest = false;\n        }\n      };\n      _proto.onFragBuffered = function onFragBuffered(event, data) {\n        var frag = data.frag,\n          part = data.part;\n        var stats = part != null && part.stats.loaded ? part.stats : frag.stats;\n        if (stats.aborted) {\n          return;\n        }\n        if (this.ignoreFragment(frag)) {\n          return;\n        }\n        // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n        // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n        // is used. If we used buffering in that case, our BW estimate sample will be very large.\n        var processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());\n        this.bwEstimator.sample(processingMs, stats.loaded);\n        stats.bwEstimate = this.bwEstimator.getEstimate();\n        if (frag.bitrateTest) {\n          this.bitrateTestDelay = processingMs / 1000;\n        } else {\n          this.bitrateTestDelay = 0;\n        }\n      };\n      _proto.ignoreFragment = function ignoreFragment(frag) {\n        // Only count non-alt-audio frags which were actually buffered in our BW calculations\n        return frag.type !== PlaylistLevelType.MAIN || frag.sn === 'initSegment';\n      };\n      _proto.clearTimer = function clearTimer() {\n        self.clearInterval(this.timer);\n      }\n\n      // return next auto level\n      ;\n\n      _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {\n        var fragCurrent = this.fragCurrent,\n          partCurrent = this.partCurrent,\n          hls = this.hls;\n        var maxAutoLevel = hls.maxAutoLevel,\n          config = hls.config,\n          minAutoLevel = hls.minAutoLevel,\n          media = hls.media;\n        var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n\n        // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n        // if we're playing back at the normal rate.\n        var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n        var avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate;\n        // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n        var bufferInfo = hls.mainForwardBufferInfo;\n        var bufferStarvationDelay = (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n\n        // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n        var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor);\n        if (bestLevel >= 0) {\n          return bestLevel;\n        }\n        logger.trace(\"[abr] \" + (bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty') + \", finding optimal quality level\");\n        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering\n        // if no matching level found, logic will return 0\n        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n        var bwFactor = config.abrBandWidthFactor;\n        var bwUpFactor = config.abrBandWidthUpFactor;\n        if (!bufferStarvationDelay) {\n          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n          var bitrateTestDelay = this.bitrateTestDelay;\n          if (bitrateTestDelay) {\n            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n            // max video loading delay used in  automatic start level selection :\n            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n            logger.trace(\"[abr] bitrate test took \" + Math.round(1000 * bitrateTestDelay) + \"ms, set first fragment max fetchDuration to \" + Math.round(1000 * maxStarvationDelay) + \" ms\");\n            // don't use conservative factor on bitrate test\n            bwFactor = bwUpFactor = 1;\n          }\n        }\n        bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor);\n        return Math.max(bestLevel, 0);\n      };\n      _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor) {\n        var _level$details;\n        var fragCurrent = this.fragCurrent,\n          partCurrent = this.partCurrent,\n          currentLevel = this.lastLoadedFragLevel;\n        var levels = this.hls.levels;\n        var level = levels[currentLevel];\n        var live = !!(level != null && (_level$details = level.details) != null && _level$details.live);\n        var currentCodecSet = level == null ? void 0 : level.codecSet;\n        var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n        var ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;\n        var levelSkippedMin = minAutoLevel;\n        var levelSkippedMax = -1;\n        for (var i = maxAutoLevel; i >= minAutoLevel; i--) {\n          var levelInfo = levels[i];\n          if (!levelInfo || currentCodecSet && levelInfo.codecSet !== currentCodecSet) {\n            if (levelInfo) {\n              levelSkippedMin = Math.min(i, levelSkippedMin);\n              levelSkippedMax = Math.max(i, levelSkippedMax);\n            }\n            continue;\n          }\n          if (levelSkippedMax !== -1) {\n            logger.trace(\"[abr] Skipped level(s) \" + levelSkippedMin + \"-\" + levelSkippedMax + \" with CODECS:\\\"\" + levels[levelSkippedMax].attrs.CODECS + \"\\\"; not compatible with \\\"\" + level.attrs.CODECS + \"\\\"\");\n          }\n          var levelDetails = levelInfo.details;\n          var avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n          var adjustedbw = void 0;\n          // follow algorithm captured from stagefright :\n          // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n          // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n          // consider only 80% of the available bandwidth, but if we are switching up,\n          // be even more conservative (70%) to avoid overestimating and immediately\n          // switching back.\n          if (i <= currentLevel) {\n            adjustedbw = bwFactor * currentBw;\n          } else {\n            adjustedbw = bwUpFactor * currentBw;\n          }\n          var bitrate = levels[i].maxBitrate;\n          var fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);\n          logger.trace(\"[abr] level:\" + i + \" adjustedbw-bitrate:\" + Math.round(adjustedbw - bitrate) + \" avgDuration:\" + avgDuration.toFixed(1) + \" maxFetchDuration:\" + maxFetchDuration.toFixed(1) + \" fetchDuration:\" + fetchDuration.toFixed(1));\n          // if adjusted bw is greater than level bitrate AND\n          if (adjustedbw > bitrate && (\n          // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n          // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n          // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n          fetchDuration === 0 || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {\n            // as we are looping from highest to lowest, this will return the best achievable quality level\n            return i;\n          }\n        }\n        // not enough time budget even with quality level 0 ... rebuffering might happen\n        return -1;\n      };\n      _createClass(AbrController, [{\n        key: \"nextAutoLevel\",\n        get: function get() {\n          var forcedAutoLevel = this._nextAutoLevel;\n          var bwEstimator = this.bwEstimator;\n          // in case next auto level has been forced, and bw not available or not reliable, return forced value\n          if (forcedAutoLevel !== -1 && !bwEstimator.canEstimate()) {\n            return forcedAutoLevel;\n          }\n\n          // compute next level using ABR logic\n          var nextABRAutoLevel = this.getNextABRAutoLevel();\n          // use forced auto level when ABR selected level has errored\n          if (forcedAutoLevel !== -1) {\n            var levels = this.hls.levels;\n            if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {\n              return forcedAutoLevel;\n            }\n          }\n          // if forced auto level has been defined, use it to cap ABR computed quality level\n          if (forcedAutoLevel !== -1) {\n            nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);\n          }\n          return nextABRAutoLevel;\n        },\n        set: function set(nextLevel) {\n          this._nextAutoLevel = nextLevel;\n        }\n      }]);\n      return AbrController;\n    }();\n    var BufferOperationQueue = /*#__PURE__*/function () {\n      function BufferOperationQueue(sourceBufferReference) {\n        this.buffers = void 0;\n        this.queues = {\n          video: [],\n          audio: [],\n          audiovideo: []\n        };\n        this.buffers = sourceBufferReference;\n      }\n      var _proto = BufferOperationQueue.prototype;\n      _proto.append = function append(operation, type) {\n        var queue = this.queues[type];\n        queue.push(operation);\n        if (queue.length === 1 && this.buffers[type]) {\n          this.executeNext(type);\n        }\n      };\n      _proto.insertAbort = function insertAbort(operation, type) {\n        var queue = this.queues[type];\n        queue.unshift(operation);\n        this.executeNext(type);\n      };\n      _proto.appendBlocker = function appendBlocker(type) {\n        var execute;\n        var promise = new Promise(function (resolve) {\n          execute = resolve;\n        });\n        var operation = {\n          execute: execute,\n          onStart: function onStart() {},\n          onComplete: function onComplete() {},\n          onError: function onError() {}\n        };\n        this.append(operation, type);\n        return promise;\n      };\n      _proto.executeNext = function executeNext(type) {\n        var buffers = this.buffers,\n          queues = this.queues;\n        var sb = buffers[type];\n        var queue = queues[type];\n        if (queue.length) {\n          var operation = queue[0];\n          try {\n            // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n            // which do not end with this event must call _onSBUpdateEnd manually\n            operation.execute();\n          } catch (e) {\n            logger.warn('[buffer-operation-queue]: Unhandled exception executing the current operation');\n            operation.onError(e);\n\n            // Only shift the current operation off, otherwise the updateend handler will do this for us\n            if (!(sb != null && sb.updating)) {\n              queue.shift();\n              this.executeNext(type);\n            }\n          }\n        }\n      };\n      _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {\n        this.queues[type].shift();\n        this.executeNext(type);\n      };\n      _proto.current = function current(type) {\n        return this.queues[type][0];\n      };\n      return BufferOperationQueue;\n    }();\n    var MediaSource = getMediaSource();\n    var VIDEO_CODEC_PROFILE_REPACE = /([ha]vc.)(?:\\.[^.,]+)+/;\n    var BufferController = /*#__PURE__*/function () {\n      // The level details used to determine duration, target-duration and live\n\n      // cache the self generated object url to detect hijack of video tag\n\n      // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n\n      // References to event listeners for each SourceBuffer, so that they can be referenced for event removal\n\n      // The number of BUFFER_CODEC events received before any sourceBuffers are created\n\n      // The total number of BUFFER_CODEC events received\n\n      // A reference to the attached media element\n\n      // A reference to the active media source\n\n      // Last MP3 audio chunk appended\n\n      // counters\n\n      function BufferController(hls) {\n        var _this = this;\n        this.details = null;\n        this._objectUrl = null;\n        this.operationQueue = void 0;\n        this.listeners = void 0;\n        this.hls = void 0;\n        this.bufferCodecEventsExpected = 0;\n        this._bufferCodecEventsTotal = 0;\n        this.media = null;\n        this.mediaSource = null;\n        this.lastMpegAudioChunk = null;\n        this.appendError = 0;\n        this.tracks = {};\n        this.pendingTracks = {};\n        this.sourceBuffer = void 0;\n        // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n        this._onMediaSourceOpen = function () {\n          var media = _this.media,\n            mediaSource = _this.mediaSource;\n          logger.log('[buffer-controller]: Media source opened');\n          if (media) {\n            media.removeEventListener('emptied', _this._onMediaEmptied);\n            _this.updateMediaElementDuration();\n            _this.hls.trigger(Events.MEDIA_ATTACHED, {\n              media: media\n            });\n          }\n          if (mediaSource) {\n            // once received, don't listen anymore to sourceopen event\n            mediaSource.removeEventListener('sourceopen', _this._onMediaSourceOpen);\n          }\n          _this.checkPendingTracks();\n        };\n        this._onMediaSourceClose = function () {\n          logger.log('[buffer-controller]: Media source closed');\n        };\n        this._onMediaSourceEnded = function () {\n          logger.log('[buffer-controller]: Media source ended');\n        };\n        this._onMediaEmptied = function () {\n          var media = _this.media,\n            _objectUrl = _this._objectUrl;\n          if (media && media.src !== _objectUrl) {\n            logger.error(\"Media element src was set while attaching MediaSource (\" + _objectUrl + \" > \" + media.src + \")\");\n          }\n        };\n        this.hls = hls;\n        this._initSourceBuffer();\n        this.registerListeners();\n      }\n      var _proto = BufferController.prototype;\n      _proto.hasSourceTypes = function hasSourceTypes() {\n        return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n      };\n      _proto.destroy = function destroy() {\n        this.unregisterListeners();\n        this.details = null;\n        this.lastMpegAudioChunk = null;\n      };\n      _proto.registerListeners = function registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n        hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n        hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.on(Events.BUFFER_EOS, this.onBufferEos, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        hls.on(Events.FRAG_PARSED, this.onFragParsed, this);\n        hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);\n      };\n      _proto.unregisterListeners = function unregisterListeners() {\n        var hls = this.hls;\n        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n        hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n        hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.off(Events.BUFFER_EOS, this.onBufferEos, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        hls.off(Events.FRAG_PARSED, this.onFragParsed, this);\n        hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);\n      };\n      _proto._initSourceBuffer = function _initSourceBuffer() {\n        this.sourceBuffer = {};\n        this.operationQueue = new BufferOperationQueue(this.sourceBuffer);\n        this.listeners = {\n          audio: [],\n          video: [],\n          audiovideo: []\n        };\n        this.lastMpegAudioChunk = null;\n      };\n      _proto.onManifestLoading = function onManifestLoading() {\n        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;\n        this.details = null;\n      };\n      _proto.onManifestParsed = function onManifestParsed(event, data) {\n        // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n        // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n        // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n        // it will contain the expected nb of source buffers, no need to compute it\n        var codecEvents = 2;\n        if (data.audio && !data.video || !data.altAudio || !false) {\n          codecEvents = 1;\n        }\n        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;\n        logger.log(this.bufferCodecEventsExpected + \" bufferCodec event(s) expected\");\n      };\n      _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n        var media = this.media = data.media;\n        if (media && MediaSource) {\n          var ms = this.mediaSource = new MediaSource();\n          // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n          ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n          ms.addEventListener('sourceended', this._onMediaSourceEnded);\n          ms.addEventListener('sourceclose', this._onMediaSourceClose);\n          // link video and media Source\n          media.src = self.URL.createObjectURL(ms);\n          // cache the locally generated object url\n          this._objectUrl = media.src;\n          media.addEventListener('emptied', this._onMediaEmptied);\n        }\n      };\n      _proto.onMediaDetaching = function onMediaDetaching() {\n        var media = this.media,\n          mediaSource = this.mediaSource,\n          _objectUrl = this._objectUrl;\n        if (mediaSource) {\n          logger.log('[buffer-controller]: media source detaching');\n          if (mediaSource.readyState === 'open') {\n            try {\n              // endOfStream could trigger exception if any sourcebuffer is in updating state\n              // we don't really care about checking sourcebuffer state here,\n              // as we are anyway detaching the MediaSource\n              // let's just avoid this exception to propagate\n              mediaSource.endOfStream();\n            } catch (err) {\n              logger.warn(\"[buffer-controller]: onMediaDetaching: \" + err.message + \" while calling endOfStream\");\n            }\n          }\n          // Clean up the SourceBuffers by invoking onBufferReset\n          this.onBufferReset();\n          mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n          mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n          mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose);\n\n          // Detach properly the MediaSource from the HTMLMediaElement as\n          // suggested in https://github.com/w3c/media-source/issues/53.\n          if (media) {\n            media.removeEventListener('emptied', this._onMediaEmptied);\n            if (_objectUrl) {\n              self.URL.revokeObjectURL(_objectUrl);\n            }\n\n            // clean up video tag src only if it's our own url. some external libraries might\n            // hijack the video tag and change its 'src' without destroying the Hls instance first\n            if (media.src === _objectUrl) {\n              media.removeAttribute('src');\n              media.load();\n            } else {\n              logger.warn('[buffer-controller]: media.src was changed by a third party - skip cleanup');\n            }\n          }\n          this.mediaSource = null;\n          this.media = null;\n          this._objectUrl = null;\n          this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;\n          this.pendingTracks = {};\n          this.tracks = {};\n        }\n        this.hls.trigger(Events.MEDIA_DETACHED, undefined);\n      };\n      _proto.onBufferReset = function onBufferReset() {\n        var _this2 = this;\n        this.getSourceBufferTypes().forEach(function (type) {\n          var sb = _this2.sourceBuffer[type];\n          try {\n            if (sb) {\n              _this2.removeBufferListeners(type);\n              if (_this2.mediaSource) {\n                _this2.mediaSource.removeSourceBuffer(sb);\n              }\n              // Synchronously remove the SB from the map before the next call in order to prevent an async function from\n              // accessing it\n              _this2.sourceBuffer[type] = undefined;\n            }\n          } catch (err) {\n            logger.warn(\"[buffer-controller]: Failed to reset the \" + type + \" buffer\", err);\n          }\n        });\n        this._initSourceBuffer();\n      };\n      _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n        var _this3 = this;\n        var sourceBufferCount = this.getSourceBufferTypes().length;\n        Object.keys(data).forEach(function (trackName) {\n          if (sourceBufferCount) {\n            // check if SourceBuffer codec needs to change\n            var track = _this3.tracks[trackName];\n            if (track && typeof track.buffer.changeType === 'function') {\n              var _data$trackName = data[trackName],\n                id = _data$trackName.id,\n                codec = _data$trackName.codec,\n                levelCodec = _data$trackName.levelCodec,\n                container = _data$trackName.container,\n                metadata = _data$trackName.metadata;\n              var currentCodec = (track.levelCodec || track.codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n              var nextCodec = (levelCodec || codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n              if (currentCodec !== nextCodec) {\n                var mimeType = container + \";codecs=\" + (levelCodec || codec);\n                _this3.appendChangeType(trackName, mimeType);\n                logger.log(\"[buffer-controller]: switching codec \" + currentCodec + \" to \" + nextCodec);\n                _this3.tracks[trackName] = {\n                  buffer: track.buffer,\n                  codec: codec,\n                  container: container,\n                  levelCodec: levelCodec,\n                  metadata: metadata,\n                  id: id\n                };\n              }\n            }\n          } else {\n            // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n            _this3.pendingTracks[trackName] = data[trackName];\n          }\n        });\n\n        // if sourcebuffers already created, do nothing ...\n        if (sourceBufferCount) {\n          return;\n        }\n        this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);\n        if (this.mediaSource && this.mediaSource.readyState === 'open') {\n          this.checkPendingTracks();\n        }\n      };\n      _proto.appendChangeType = function appendChangeType(type, mimeType) {\n        var _this4 = this;\n        var operationQueue = this.operationQueue;\n        var operation = {\n          execute: function execute() {\n            var sb = _this4.sourceBuffer[type];\n            if (sb) {\n              logger.log(\"[buffer-controller]: changing \" + type + \" sourceBuffer type to \" + mimeType);\n              sb.changeType(mimeType);\n            }\n            operationQueue.shiftAndExecuteNext(type);\n          },\n          onStart: function onStart() {},\n          onComplete: function onComplete() {},\n          onError: function onError(e) {\n            logger.warn(\"[buffer-controller]: Failed to change \" + type + \" SourceBuffer type\", e);\n          }\n        };\n        operationQueue.append(operation, type);\n      };\n      _proto.onBufferAppending = function onBufferAppending(event, eventData) {\n        var _this5 = this;\n        var hls = this.hls,\n          operationQueue = this.operationQueue,\n          tracks = this.tracks;\n        var data = eventData.data,\n          type = eventData.type,\n          frag = eventData.frag,\n          part = eventData.part,\n          chunkMeta = eventData.chunkMeta;\n        var chunkStats = chunkMeta.buffering[type];\n        var bufferAppendingStart = self.performance.now();\n        chunkStats.start = bufferAppendingStart;\n        var fragBuffering = frag.stats.buffering;\n        var partBuffering = part ? part.stats.buffering : null;\n        if (fragBuffering.start === 0) {\n          fragBuffering.start = bufferAppendingStart;\n        }\n        if (partBuffering && partBuffering.start === 0) {\n          partBuffering.start = bufferAppendingStart;\n        }\n\n        // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n        // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n        // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n        // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n        // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n        var audioTrack = tracks.audio;\n        var checkTimestampOffset = false;\n        if (type === 'audio' && (audioTrack == null ? void 0 : audioTrack.container) === 'audio/mpeg') {\n          checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n          this.lastMpegAudioChunk = chunkMeta;\n        }\n        var fragStart = frag.start;\n        var operation = {\n          execute: function execute() {\n            chunkStats.executeStart = self.performance.now();\n            if (checkTimestampOffset) {\n              var sb = _this5.sourceBuffer[type];\n              if (sb) {\n                var delta = fragStart - sb.timestampOffset;\n                if (Math.abs(delta) >= 0.1) {\n                  logger.log(\"[buffer-controller]: Updating audio SourceBuffer timestampOffset to \" + fragStart + \" (delta: \" + delta + \") sn: \" + frag.sn + \")\");\n                  sb.timestampOffset = fragStart;\n                }\n              }\n            }\n            _this5.appendExecutor(data, type);\n          },\n          onStart: function onStart() {\n            // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n          },\n          onComplete: function onComplete() {\n            // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n            var end = self.performance.now();\n            chunkStats.executeEnd = chunkStats.end = end;\n            if (fragBuffering.first === 0) {\n              fragBuffering.first = end;\n            }\n            if (partBuffering && partBuffering.first === 0) {\n              partBuffering.first = end;\n            }\n            var sourceBuffer = _this5.sourceBuffer;\n            var timeRanges = {};\n            for (var _type in sourceBuffer) {\n              timeRanges[_type] = BufferHelper.getBuffered(sourceBuffer[_type]);\n            }\n            _this5.appendError = 0;\n            _this5.hls.trigger(Events.BUFFER_APPENDED, {\n              type: type,\n              frag: frag,\n              part: part,\n              chunkMeta: chunkMeta,\n              parent: frag.type,\n              timeRanges: timeRanges\n            });\n          },\n          onError: function onError(err) {\n            // in case any error occured while appending, put back segment in segments table\n            logger.error(\"[buffer-controller]: Error encountered while trying to append to the \" + type + \" SourceBuffer\", err);\n            var event = {\n              type: ErrorTypes.MEDIA_ERROR,\n              parent: frag.type,\n              details: ErrorDetails.BUFFER_APPEND_ERROR,\n              frag: frag,\n              part: part,\n              chunkMeta: chunkMeta,\n              error: err,\n              err: err,\n              fatal: false\n            };\n            if (err.code === DOMException.QUOTA_EXCEEDED_ERR) {\n              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n              // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n              event.details = ErrorDetails.BUFFER_FULL_ERROR;\n            } else {\n              _this5.appendError++;\n              event.details = ErrorDetails.BUFFER_APPEND_ERROR;\n              /* with UHD content, we could get loop of quota exceeded error until\n                browser is able to evict some data from sourcebuffer. Retrying can help recover.\n              */\n              if (_this5.appendError > hls.config.appendErrorMaxRetry) {\n                logger.error(\"[buffer-controller]: Failed \" + hls.config.appendErrorMaxRetry + \" times to append segment in sourceBuffer\");\n                event.fatal = true;\n              }\n            }\n            hls.trigger(Events.ERROR, event);\n          }\n        };\n        operationQueue.append(operation, type);\n      };\n      _proto.onBufferFlushing = function onBufferFlushing(event, data) {\n        var _this6 = this;\n        var operationQueue = this.operationQueue;\n        var flushOperation = function flushOperation(type) {\n          return {\n            execute: _this6.removeExecutor.bind(_this6, type, data.startOffset, data.endOffset),\n            onStart: function onStart() {\n              // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n            },\n            onComplete: function onComplete() {\n              // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n              _this6.hls.trigger(Events.BUFFER_FLUSHED, {\n                type: type\n              });\n            },\n            onError: function onError(e) {\n              logger.warn(\"[buffer-controller]: Failed to remove from \" + type + \" SourceBuffer\", e);\n            }\n          };\n        };\n        if (data.type) {\n          operationQueue.append(flushOperation(data.type), data.type);\n        } else {\n          this.getSourceBufferTypes().forEach(function (type) {\n            operationQueue.append(flushOperation(type), type);\n          });\n        }\n      };\n      _proto.onFragParsed = function onFragParsed(event, data) {\n        var _this7 = this;\n        var frag = data.frag,\n          part = data.part;\n        var buffersAppendedTo = [];\n        var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n        if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {\n          buffersAppendedTo.push('audiovideo');\n        } else {\n          if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {\n            buffersAppendedTo.push('audio');\n          }\n          if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {\n            buffersAppendedTo.push('video');\n          }\n        }\n        var onUnblocked = function onUnblocked() {\n          var now = self.performance.now();\n          frag.stats.buffering.end = now;\n          if (part) {\n            part.stats.buffering.end = now;\n          }\n          var stats = part ? part.stats : frag.stats;\n          _this7.hls.trigger(Events.FRAG_BUFFERED, {\n            frag: frag,\n            part: part,\n            stats: stats,\n            id: frag.type\n          });\n        };\n        if (buffersAppendedTo.length === 0) {\n          logger.warn(\"Fragments must have at least one ElementaryStreamType set. type: \" + frag.type + \" level: \" + frag.level + \" sn: \" + frag.sn);\n        }\n        this.blockBuffers(onUnblocked, buffersAppendedTo);\n      };\n      _proto.onFragChanged = function onFragChanged(event, data) {\n        this.flushBackBuffer();\n      }\n\n      // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n      // an undefined data.type will mark all buffers as EOS.\n      ;\n\n      _proto.onBufferEos = function onBufferEos(event, data) {\n        var _this8 = this;\n        var ended = this.getSourceBufferTypes().reduce(function (acc, type) {\n          var sb = _this8.sourceBuffer[type];\n          if (sb && (!data.type || data.type === type)) {\n            sb.ending = true;\n            if (!sb.ended) {\n              sb.ended = true;\n              logger.log(\"[buffer-controller]: \" + type + \" sourceBuffer now EOS\");\n            }\n          }\n          return acc && !!(!sb || sb.ended);\n        }, true);\n        if (ended) {\n          logger.log(\"[buffer-controller]: Queueing mediaSource.endOfStream()\");\n          this.blockBuffers(function () {\n            _this8.getSourceBufferTypes().forEach(function (type) {\n              var sb = _this8.sourceBuffer[type];\n              if (sb) {\n                sb.ending = false;\n              }\n            });\n            var mediaSource = _this8.mediaSource;\n            if (!mediaSource || mediaSource.readyState !== 'open') {\n              if (mediaSource) {\n                logger.info(\"[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: \" + mediaSource.readyState);\n              }\n              return;\n            }\n            logger.log(\"[buffer-controller]: Calling mediaSource.endOfStream()\");\n            // Allow this to throw and be caught by the enqueueing function\n            mediaSource.endOfStream();\n          });\n        }\n      };\n      _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n        var details = _ref.details;\n        if (!details.fragments.length) {\n          return;\n        }\n        this.details = details;\n        if (this.getSourceBufferTypes().length) {\n          this.blockBuffers(this.updateMediaElementDuration.bind(this));\n        } else {\n          this.updateMediaElementDuration();\n        }\n      };\n      _proto.flushBackBuffer = function flushBackBuffer() {\n        var hls = this.hls,\n          details = this.details,\n          media = this.media,\n          sourceBuffer = this.sourceBuffer;\n        if (!media || details === null) {\n          return;\n        }\n        var sourceBufferTypes = this.getSourceBufferTypes();\n        if (!sourceBufferTypes.length) {\n          return;\n        }\n\n        // Support for deprecated liveBackBufferLength\n        var backBufferLength = details.live && hls.config.liveBackBufferLength !== null ? hls.config.liveBackBufferLength : hls.config.backBufferLength;\n        if (!isFiniteNumber(backBufferLength) || backBufferLength < 0) {\n          return;\n        }\n        var currentTime = media.currentTime;\n        var targetDuration = details.levelTargetDuration;\n        var maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n        var targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n        sourceBufferTypes.forEach(function (type) {\n          var sb = sourceBuffer[type];\n          if (sb) {\n            var buffered = BufferHelper.getBuffered(sb);\n            // when target buffer start exceeds actual buffer start\n            if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n              hls.trigger(Events.BACK_BUFFER_REACHED, {\n                bufferEnd: targetBackBufferPosition\n              });\n\n              // Support for deprecated event:\n              if (details.live) {\n                hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {\n                  bufferEnd: targetBackBufferPosition\n                });\n              } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {\n                logger.info(\"[buffer-controller]: Cannot flush \" + type + \" back buffer while SourceBuffer is in ended state\");\n                return;\n              }\n              hls.trigger(Events.BUFFER_FLUSHING, {\n                startOffset: 0,\n                endOffset: targetBackBufferPosition,\n                type: type\n              });\n            }\n          }\n        });\n      }\n\n      /**\n       * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n       * 'liveDurationInfinity` is set to `true`\n       * More details: https://github.com/video-dev/hls.js/issues/355\n       */;\n      _proto.updateMediaElementDuration = function updateMediaElementDuration() {\n        if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') {\n          return;\n        }\n        var details = this.details,\n          hls = this.hls,\n          media = this.media,\n          mediaSource = this.mediaSource;\n        var levelDuration = details.fragments[0].start + details.totalduration;\n        var mediaDuration = media.duration;\n        var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;\n        if (details.live && hls.config.liveDurationInfinity) {\n          // Override duration to Infinity\n          logger.log('[buffer-controller]: Media Source duration is set to Infinity');\n          mediaSource.duration = Infinity;\n          this.updateSeekableRange(details);\n        } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {\n          // levelDuration was the last value we set.\n          // not using mediaSource.duration as the browser may tweak this value\n          // only update Media Source duration if its value increase, this is to avoid\n          // flushing already buffered portion when switching between quality level\n          logger.log(\"[buffer-controller]: Updating Media Source duration to \" + levelDuration.toFixed(3));\n          mediaSource.duration = levelDuration;\n        }\n      };\n      _proto.updateSeekableRange = function updateSeekableRange(levelDetails) {\n        var mediaSource = this.mediaSource;\n        var fragments = levelDetails.fragments;\n        var len = fragments.length;\n        if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {\n          var start = Math.max(0, fragments[0].start);\n          var end = Math.max(start, start + levelDetails.totalduration);\n          mediaSource.setLiveSeekableRange(start, end);\n        }\n      };\n      _proto.checkPendingTracks = function checkPendingTracks() {\n        var bufferCodecEventsExpected = this.bufferCodecEventsExpected,\n          operationQueue = this.operationQueue,\n          pendingTracks = this.pendingTracks;\n\n        // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n        // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n        // data has been appended to existing ones.\n        // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n        var pendingTracksCount = Object.keys(pendingTracks).length;\n        if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {\n          // ok, let's create them now !\n          this.createSourceBuffers(pendingTracks);\n          this.pendingTracks = {};\n          // append any pending segments now !\n          var buffers = this.getSourceBufferTypes();\n          if (buffers.length) {\n            this.hls.trigger(Events.BUFFER_CREATED, {\n              tracks: this.tracks\n            });\n            buffers.forEach(function (type) {\n              operationQueue.executeNext(type);\n            });\n          } else {\n            var error = new Error('could not create source buffer for media codec(s)');\n            this.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n              fatal: true,\n              error: error,\n              reason: error.message\n            });\n          }\n        }\n      };\n      _proto.createSourceBuffers = function createSourceBuffers(tracks) {\n        var sourceBuffer = this.sourceBuffer,\n          mediaSource = this.mediaSource;\n        if (!mediaSource) {\n          throw Error('createSourceBuffers called when mediaSource was null');\n        }\n        for (var trackName in tracks) {\n          if (!sourceBuffer[trackName]) {\n            var track = tracks[trackName];\n            if (!track) {\n              throw Error(\"source buffer exists for track \" + trackName + \", however track does not\");\n            }\n            // use levelCodec as first priority\n            var codec = track.levelCodec || track.codec;\n            var mimeType = track.container + \";codecs=\" + codec;\n            logger.log(\"[buffer-controller]: creating sourceBuffer(\" + mimeType + \")\");\n            try {\n              var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n              var sbName = trackName;\n              this.addBufferListener(sbName, 'updatestart', this._onSBUpdateStart);\n              this.addBufferListener(sbName, 'updateend', this._onSBUpdateEnd);\n              this.addBufferListener(sbName, 'error', this._onSBUpdateError);\n              this.tracks[trackName] = {\n                buffer: sb,\n                codec: codec,\n                container: track.container,\n                levelCodec: track.levelCodec,\n                metadata: track.metadata,\n                id: track.id\n              };\n            } catch (err) {\n              logger.error(\"[buffer-controller]: error while trying to add sourceBuffer: \" + err.message);\n              this.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n                fatal: false,\n                error: err,\n                mimeType: mimeType\n              });\n            }\n          }\n        }\n      };\n      _proto._onSBUpdateStart = function _onSBUpdateStart(type) {\n        var operationQueue = this.operationQueue;\n        var operation = operationQueue.current(type);\n        operation.onStart();\n      };\n      _proto._onSBUpdateEnd = function _onSBUpdateEnd(type) {\n        var operationQueue = this.operationQueue;\n        var operation = operationQueue.current(type);\n        operation.onComplete();\n        operationQueue.shiftAndExecuteNext(type);\n      };\n      _proto._onSBUpdateError = function _onSBUpdateError(type, event) {\n        var error = new Error(type + \" SourceBuffer error\");\n        logger.error(\"[buffer-controller]: \" + error, event);\n        // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n        // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_APPENDING_ERROR,\n          error: error,\n          fatal: false\n        });\n        // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n        var operation = this.operationQueue.current(type);\n        if (operation) {\n          operation.onError(event);\n        }\n      }\n\n      // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually\n      ;\n\n      _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {\n        var media = this.media,\n          mediaSource = this.mediaSource,\n          operationQueue = this.operationQueue,\n          sourceBuffer = this.sourceBuffer;\n        var sb = sourceBuffer[type];\n        if (!media || !mediaSource || !sb) {\n          logger.warn(\"[buffer-controller]: Attempting to remove from the \" + type + \" SourceBuffer, but it does not exist\");\n          operationQueue.shiftAndExecuteNext(type);\n          return;\n        }\n        var mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;\n        var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;\n        var removeStart = Math.max(0, startOffset);\n        var removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n        if (removeEnd > removeStart && !sb.ending) {\n          sb.ended = false;\n          logger.log(\"[buffer-controller]: Removing [\" + removeStart + \",\" + removeEnd + \"] from the \" + type + \" SourceBuffer\");\n          sb.remove(removeStart, removeEnd);\n        } else {\n          // Cycle the queue\n          operationQueue.shiftAndExecuteNext(type);\n        }\n      }\n\n      // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually\n      ;\n\n      _proto.appendExecutor = function appendExecutor(data, type) {\n        var operationQueue = this.operationQueue,\n          sourceBuffer = this.sourceBuffer;\n        var sb = sourceBuffer[type];\n        if (!sb) {\n          logger.warn(\"[buffer-controller]: Attempting to append to the \" + type + \" SourceBuffer, but it does not exist\");\n          operationQueue.shiftAndExecuteNext(type);\n          return;\n        }\n        sb.ended = false;\n        sb.appendBuffer(data);\n      }\n\n      // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n      // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n      // upon completion, since we already do it here\n      ;\n\n      _proto.blockBuffers = function blockBuffers(onUnblocked, buffers) {\n        var _this9 = this;\n        if (buffers === void 0) {\n          buffers = this.getSourceBufferTypes();\n        }\n        if (!buffers.length) {\n          logger.log('[buffer-controller]: Blocking operation requested, but no SourceBuffers exist');\n          Promise.resolve().then(onUnblocked);\n          return;\n        }\n        var operationQueue = this.operationQueue;\n\n        // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n        var blockingOperations = buffers.map(function (type) {\n          return operationQueue.appendBlocker(type);\n        });\n        Promise.all(blockingOperations).then(function () {\n          // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n          onUnblocked();\n          buffers.forEach(function (type) {\n            var sb = _this9.sourceBuffer[type];\n            // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n            // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n            // While this is a workaround, it's probably useful to have around\n            if (!(sb != null && sb.updating)) {\n              operationQueue.shiftAndExecuteNext(type);\n            }\n          });\n        });\n      };\n      _proto.getSourceBufferTypes = function getSourceBufferTypes() {\n        return Object.keys(this.sourceBuffer);\n      };\n      _proto.addBufferListener = function addBufferListener(type, event, fn) {\n        var buffer = this.sourceBuffer[type];\n        if (!buffer) {\n          return;\n        }\n        var listener = fn.bind(this, type);\n        this.listeners[type].push({\n          event: event,\n          listener: listener\n        });\n        buffer.addEventListener(event, listener);\n      };\n      _proto.removeBufferListeners = function removeBufferListeners(type) {\n        var buffer = this.sourceBuffer[type];\n        if (!buffer) {\n          return;\n        }\n        this.listeners[type].forEach(function (l) {\n          buffer.removeEventListener(l.event, l.listener);\n        });\n      };\n      return BufferController;\n    }();\n    var CapLevelController = /*#__PURE__*/function () {\n      function CapLevelController(hls) {\n        this.hls = void 0;\n        this.autoLevelCapping = void 0;\n        this.firstLevel = void 0;\n        this.media = void 0;\n        this.restrictedLevels = void 0;\n        this.timer = void 0;\n        this.clientRect = void 0;\n        this.streamController = void 0;\n        this.hls = hls;\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        this.firstLevel = -1;\n        this.media = null;\n        this.restrictedLevels = [];\n        this.timer = undefined;\n        this.clientRect = null;\n        this.registerListeners();\n      }\n      var _proto = CapLevelController.prototype;\n      _proto.setStreamController = function setStreamController(streamController) {\n        this.streamController = streamController;\n      };\n      _proto.destroy = function destroy() {\n        this.unregisterListener();\n        if (this.hls.config.capLevelToPlayerSize) {\n          this.stopCapping();\n        }\n        this.media = null;\n        this.clientRect = null;\n        // @ts-ignore\n        this.hls = this.streamController = null;\n      };\n      _proto.registerListeners = function registerListeners() {\n        var hls = this.hls;\n        hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      };\n      _proto.unregisterListener = function unregisterListener() {\n        var hls = this.hls;\n        hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      };\n      _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {\n        // Don't add a restricted level more than once\n        var level = this.hls.levels[data.droppedLevel];\n        if (this.isLevelAllowed(level)) {\n          this.restrictedLevels.push({\n            bitrate: level.bitrate,\n            height: level.height,\n            width: level.width\n          });\n        }\n      };\n      _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n        this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n        this.clientRect = null;\n      };\n      _proto.onManifestParsed = function onManifestParsed(event, data) {\n        var hls = this.hls;\n        this.restrictedLevels = [];\n        this.firstLevel = data.firstLevel;\n        if (hls.config.capLevelToPlayerSize && data.video) {\n          // Start capping immediately if the manifest has signaled video codecs\n          this.startCapping();\n        }\n      }\n\n      // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n      // to the first level\n      ;\n\n      _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n        var hls = this.hls;\n        if (hls.config.capLevelToPlayerSize && data.video) {\n          // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n          this.startCapping();\n        }\n      };\n      _proto.onMediaDetaching = function onMediaDetaching() {\n        this.stopCapping();\n      };\n      _proto.detectPlayerSize = function detectPlayerSize() {\n        if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {\n          var levels = this.hls.levels;\n          if (levels.length) {\n            var hls = this.hls;\n            hls.autoLevelCapping = this.getMaxLevel(levels.length - 1);\n            if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n              // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n              // usually happen when the user go to the fullscreen mode.\n              this.streamController.nextLevelSwitch();\n            }\n            this.autoLevelCapping = hls.autoLevelCapping;\n          }\n        }\n      }\n\n      /*\n       * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n       */;\n      _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {\n        var _this = this;\n        var levels = this.hls.levels;\n        if (!levels.length) {\n          return -1;\n        }\n        var validLevels = levels.filter(function (level, index) {\n          return _this.isLevelAllowed(level) && index <= capLevelIndex;\n        });\n        this.clientRect = null;\n        return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n      };\n      _proto.startCapping = function startCapping() {\n        if (this.timer) {\n          // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n          return;\n        }\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        this.hls.firstLevel = this.getMaxLevel(this.firstLevel);\n        self.clearInterval(this.timer);\n        this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n        this.detectPlayerSize();\n      };\n      _proto.stopCapping = function stopCapping() {\n        this.restrictedLevels = [];\n        this.firstLevel = -1;\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        if (this.timer) {\n          self.clearInterval(this.timer);\n          this.timer = undefined;\n        }\n      };\n      _proto.getDimensions = function getDimensions() {\n        if (this.clientRect) {\n          return this.clientRect;\n        }\n        var media = this.media;\n        var boundsRect = {\n          width: 0,\n          height: 0\n        };\n        if (media) {\n          var clientRect = media.getBoundingClientRect();\n          boundsRect.width = clientRect.width;\n          boundsRect.height = clientRect.height;\n          if (!boundsRect.width && !boundsRect.height) {\n            // When the media element has no width or height (equivalent to not being in the DOM),\n            // then use its width and height attributes (media.width, media.height)\n            boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n            boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n          }\n        }\n        this.clientRect = boundsRect;\n        return boundsRect;\n      };\n      _proto.isLevelAllowed = function isLevelAllowed(level) {\n        var restrictedLevels = this.restrictedLevels;\n        return !restrictedLevels.some(function (restrictedLevel) {\n          return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;\n        });\n      };\n      CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {\n        if (!(levels != null && levels.length)) {\n          return -1;\n        }\n\n        // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n        // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n        var atGreatestBandwidth = function atGreatestBandwidth(curLevel, nextLevel) {\n          if (!nextLevel) {\n            return true;\n          }\n          return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n        };\n\n        // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n        // the max level\n        var maxLevelIndex = levels.length - 1;\n        for (var i = 0; i < levels.length; i += 1) {\n          var level = levels[i];\n          if ((level.width >= width || level.height >= height) && atGreatestBandwidth(level, levels[i + 1])) {\n            maxLevelIndex = i;\n            break;\n          }\n        }\n        return maxLevelIndex;\n      };\n      _createClass(CapLevelController, [{\n        key: \"mediaWidth\",\n        get: function get() {\n          return this.getDimensions().width * this.contentScaleFactor;\n        }\n      }, {\n        key: \"mediaHeight\",\n        get: function get() {\n          return this.getDimensions().height * this.contentScaleFactor;\n        }\n      }, {\n        key: \"contentScaleFactor\",\n        get: function get() {\n          var pixelRatio = 1;\n          if (!this.hls.config.ignoreDevicePixelRatio) {\n            try {\n              pixelRatio = self.devicePixelRatio;\n            } catch (e) {\n              /* no-op */\n            }\n          }\n          return pixelRatio;\n        }\n      }]);\n      return CapLevelController;\n    }();\n    var FPSController = /*#__PURE__*/function () {\n      // stream controller must be provided as a dependency!\n\n      function FPSController(hls) {\n        this.hls = void 0;\n        this.isVideoPlaybackQualityAvailable = false;\n        this.timer = void 0;\n        this.media = null;\n        this.lastTime = void 0;\n        this.lastDroppedFrames = 0;\n        this.lastDecodedFrames = 0;\n        this.streamController = void 0;\n        this.hls = hls;\n        this.registerListeners();\n      }\n      var _proto = FPSController.prototype;\n      _proto.setStreamController = function setStreamController(streamController) {\n        this.streamController = streamController;\n      };\n      _proto.registerListeners = function registerListeners() {\n        this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      };\n      _proto.unregisterListeners = function unregisterListeners() {\n        this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      };\n      _proto.destroy = function destroy() {\n        if (this.timer) {\n          clearInterval(this.timer);\n        }\n        this.unregisterListeners();\n        this.isVideoPlaybackQualityAvailable = false;\n        this.media = null;\n      };\n      _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n        var config = this.hls.config;\n        if (config.capLevelOnFPSDrop) {\n          var media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n          this.media = media;\n          if (media && typeof media.getVideoPlaybackQuality === 'function') {\n            this.isVideoPlaybackQualityAvailable = true;\n          }\n          self.clearInterval(this.timer);\n          this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n        }\n      };\n      _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {\n        var currentTime = performance.now();\n        if (decodedFrames) {\n          if (this.lastTime) {\n            var currentPeriod = currentTime - this.lastTime;\n            var currentDropped = droppedFrames - this.lastDroppedFrames;\n            var currentDecoded = decodedFrames - this.lastDecodedFrames;\n            var droppedFPS = 1000 * currentDropped / currentPeriod;\n            var hls = this.hls;\n            hls.trigger(Events.FPS_DROP, {\n              currentDropped: currentDropped,\n              currentDecoded: currentDecoded,\n              totalDroppedFrames: droppedFrames\n            });\n            if (droppedFPS > 0) {\n              // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n              if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n                var currentLevel = hls.currentLevel;\n                logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n                if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n                  currentLevel = currentLevel - 1;\n                  hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {\n                    level: currentLevel,\n                    droppedLevel: hls.currentLevel\n                  });\n                  hls.autoLevelCapping = currentLevel;\n                  this.streamController.nextLevelSwitch();\n                }\n              }\n            }\n          }\n          this.lastTime = currentTime;\n          this.lastDroppedFrames = droppedFrames;\n          this.lastDecodedFrames = decodedFrames;\n        }\n      };\n      _proto.checkFPSInterval = function checkFPSInterval() {\n        var video = this.media;\n        if (video) {\n          if (this.isVideoPlaybackQualityAvailable) {\n            var videoPlaybackQuality = video.getVideoPlaybackQuality();\n            this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n          } else {\n            // HTMLVideoElement doesn't include the webkit types\n            this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n          }\n        }\n      };\n      return FPSController;\n    }();\n    var AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/im;\n    var XhrLoader = /*#__PURE__*/function () {\n      function XhrLoader(config) {\n        this.xhrSetup = void 0;\n        this.requestTimeout = void 0;\n        this.retryTimeout = void 0;\n        this.retryDelay = void 0;\n        this.config = null;\n        this.callbacks = null;\n        this.context = void 0;\n        this.loader = null;\n        this.stats = void 0;\n        this.xhrSetup = config ? config.xhrSetup || null : null;\n        this.stats = new LoadStats();\n        this.retryDelay = 0;\n      }\n      var _proto = XhrLoader.prototype;\n      _proto.destroy = function destroy() {\n        this.callbacks = null;\n        this.abortInternal();\n        this.loader = null;\n        this.config = null;\n      };\n      _proto.abortInternal = function abortInternal() {\n        var loader = this.loader;\n        self.clearTimeout(this.requestTimeout);\n        self.clearTimeout(this.retryTimeout);\n        if (loader) {\n          loader.onreadystatechange = null;\n          loader.onprogress = null;\n          if (loader.readyState !== 4) {\n            this.stats.aborted = true;\n            loader.abort();\n          }\n        }\n      };\n      _proto.abort = function abort() {\n        var _this$callbacks;\n        this.abortInternal();\n        if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n          this.callbacks.onAbort(this.stats, this.context, this.loader);\n        }\n      };\n      _proto.load = function load(context, config, callbacks) {\n        if (this.stats.loading.start) {\n          throw new Error('Loader can only be used once.');\n        }\n        this.stats.loading.start = self.performance.now();\n        this.context = context;\n        this.config = config;\n        this.callbacks = callbacks;\n        this.loadInternal();\n      };\n      _proto.loadInternal = function loadInternal() {\n        var _this = this;\n        var config = this.config,\n          context = this.context;\n        if (!config) {\n          return;\n        }\n        var xhr = this.loader = new self.XMLHttpRequest();\n        var stats = this.stats;\n        stats.loading.first = 0;\n        stats.loaded = 0;\n        var xhrSetup = this.xhrSetup;\n        if (xhrSetup) {\n          Promise.resolve().then(function () {\n            if (_this.stats.aborted) return;\n            return xhrSetup(xhr, context.url);\n          }).catch(function (error) {\n            xhr.open('GET', context.url, true);\n            return xhrSetup(xhr, context.url);\n          }).then(function () {\n            if (_this.stats.aborted) return;\n            _this.openAndSendXhr(xhr, context, config);\n          }).catch(function (error) {\n            // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n            _this.callbacks.onError({\n              code: xhr.status,\n              text: error.message\n            }, context, xhr, stats);\n            return;\n          });\n        } else {\n          this.openAndSendXhr(xhr, context, config);\n        }\n      };\n      _proto.openAndSendXhr = function openAndSendXhr(xhr, context, config) {\n        if (!xhr.readyState) {\n          xhr.open('GET', context.url, true);\n        }\n        var headers = this.context.headers;\n        var _config$loadPolicy = config.loadPolicy,\n          maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs,\n          maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;\n        if (headers) {\n          for (var header in headers) {\n            xhr.setRequestHeader(header, headers[header]);\n          }\n        }\n        if (context.rangeEnd) {\n          xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n        }\n        xhr.onreadystatechange = this.readystatechange.bind(this);\n        xhr.onprogress = this.loadprogress.bind(this);\n        xhr.responseType = context.responseType;\n        // setup timeout before we perform request\n        self.clearTimeout(this.requestTimeout);\n        config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n        xhr.send();\n      };\n      _proto.readystatechange = function readystatechange() {\n        var context = this.context,\n          xhr = this.loader,\n          stats = this.stats;\n        if (!context || !xhr) {\n          return;\n        }\n        var readyState = xhr.readyState;\n        var config = this.config;\n\n        // don't proceed if xhr has been aborted\n        if (stats.aborted) {\n          return;\n        }\n\n        // >= HEADERS_RECEIVED\n        if (readyState >= 2) {\n          if (stats.loading.first === 0) {\n            stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n            // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n            if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {\n              self.clearTimeout(this.requestTimeout);\n              config.timeout = config.loadPolicy.maxLoadTimeMs;\n              this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));\n            }\n          }\n          if (readyState === 4) {\n            self.clearTimeout(this.requestTimeout);\n            xhr.onreadystatechange = null;\n            xhr.onprogress = null;\n            var _status = xhr.status;\n            // http status between 200 to 299 are all successful\n            var useResponse = xhr.responseType !== 'text';\n            if (_status >= 200 && _status < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {\n              stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n              var data = useResponse ? xhr.response : xhr.responseText;\n              var len = xhr.responseType === 'arraybuffer' ? data.byteLength : data.length;\n              stats.loaded = stats.total = len;\n              stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);\n              if (!this.callbacks) {\n                return;\n              }\n              var onProgress = this.callbacks.onProgress;\n              if (onProgress) {\n                onProgress(stats, context, data, xhr);\n              }\n              if (!this.callbacks) {\n                return;\n              }\n              var response = {\n                url: xhr.responseURL,\n                data: data,\n                code: _status\n              };\n              this.callbacks.onSuccess(response, stats, context, xhr);\n            } else {\n              var retryConfig = config.loadPolicy.errorRetry;\n              var retryCount = stats.retry;\n              // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n              if (shouldRetry(retryConfig, retryCount, false, _status)) {\n                this.retry(retryConfig);\n              } else {\n                logger.error(_status + \" while loading \" + context.url);\n                this.callbacks.onError({\n                  code: _status,\n                  text: xhr.statusText\n                }, context, xhr, stats);\n              }\n            }\n          }\n        }\n      };\n      _proto.loadtimeout = function loadtimeout() {\n        var _this$config;\n        var retryConfig = (_this$config = this.config) == null ? void 0 : _this$config.loadPolicy.timeoutRetry;\n        var retryCount = this.stats.retry;\n        if (shouldRetry(retryConfig, retryCount, true)) {\n          this.retry(retryConfig);\n        } else {\n          logger.warn(\"timeout while loading \" + this.context.url);\n          var callbacks = this.callbacks;\n          if (callbacks) {\n            this.abortInternal();\n            callbacks.onTimeout(this.stats, this.context, this.loader);\n          }\n        }\n      };\n      _proto.retry = function retry(retryConfig) {\n        var context = this.context,\n          stats = this.stats;\n        this.retryDelay = getRetryDelay(retryConfig, stats.retry);\n        stats.retry++;\n        logger.warn((status ? 'HTTP Status ' + status : 'Timeout') + \" while loading \" + context.url + \", retrying \" + stats.retry + \"/\" + retryConfig.maxNumRetry + \" in \" + this.retryDelay + \"ms\");\n        // abort and reset internal state\n        this.abortInternal();\n        this.loader = null;\n        // schedule retry\n        self.clearTimeout(this.retryTimeout);\n        this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n      };\n      _proto.loadprogress = function loadprogress(event) {\n        var stats = this.stats;\n        stats.loaded = event.loaded;\n        if (event.lengthComputable) {\n          stats.total = event.total;\n        }\n      };\n      _proto.getCacheAge = function getCacheAge() {\n        var result = null;\n        if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n          var ageHeader = this.loader.getResponseHeader('age');\n          result = ageHeader ? parseFloat(ageHeader) : null;\n        }\n        return result;\n      };\n      _proto.getResponseHeader = function getResponseHeader(name) {\n        if (this.loader && new RegExp(\"^\" + name + \":\\\\s*[\\\\d.]+\\\\s*$\", 'im').test(this.loader.getAllResponseHeaders())) {\n          return this.loader.getResponseHeader(name);\n        }\n        return null;\n      };\n      return XhrLoader;\n    }();\n    var ChunkCache = /*#__PURE__*/function () {\n      function ChunkCache() {\n        this.chunks = [];\n        this.dataLength = 0;\n      }\n      var _proto = ChunkCache.prototype;\n      _proto.push = function push(chunk) {\n        this.chunks.push(chunk);\n        this.dataLength += chunk.length;\n      };\n      _proto.flush = function flush() {\n        var chunks = this.chunks,\n          dataLength = this.dataLength;\n        var result;\n        if (!chunks.length) {\n          return new Uint8Array(0);\n        } else if (chunks.length === 1) {\n          result = chunks[0];\n        } else {\n          result = concatUint8Arrays(chunks, dataLength);\n        }\n        this.reset();\n        return result;\n      };\n      _proto.reset = function reset() {\n        this.chunks.length = 0;\n        this.dataLength = 0;\n      };\n      return ChunkCache;\n    }();\n    function concatUint8Arrays(chunks, dataLength) {\n      var result = new Uint8Array(dataLength);\n      var offset = 0;\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i];\n        result.set(chunk, offset);\n        offset += chunk.length;\n      }\n      return result;\n    }\n    function fetchSupported() {\n      if (\n      // @ts-ignore\n      self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n        try {\n          new self.ReadableStream({}); // eslint-disable-line no-new\n          return true;\n        } catch (e) {\n          /* noop */\n        }\n      }\n      return false;\n    }\n    var BYTERANGE = /(\\d+)-(\\d+)\\/(\\d+)/;\n    var FetchLoader = /*#__PURE__*/function () {\n      function FetchLoader(config /* HlsConfig */) {\n        this.fetchSetup = void 0;\n        this.requestTimeout = void 0;\n        this.request = void 0;\n        this.response = void 0;\n        this.controller = void 0;\n        this.context = void 0;\n        this.config = null;\n        this.callbacks = null;\n        this.stats = void 0;\n        this.loader = null;\n        this.fetchSetup = config.fetchSetup || getRequest;\n        this.controller = new self.AbortController();\n        this.stats = new LoadStats();\n      }\n      var _proto = FetchLoader.prototype;\n      _proto.destroy = function destroy() {\n        this.loader = this.callbacks = null;\n        this.abortInternal();\n      };\n      _proto.abortInternal = function abortInternal() {\n        var response = this.response;\n        if (!(response != null && response.ok)) {\n          this.stats.aborted = true;\n          this.controller.abort();\n        }\n      };\n      _proto.abort = function abort() {\n        var _this$callbacks;\n        this.abortInternal();\n        if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n          this.callbacks.onAbort(this.stats, this.context, this.response);\n        }\n      };\n      _proto.load = function load(context, config, callbacks) {\n        var _this = this;\n        var stats = this.stats;\n        if (stats.loading.start) {\n          throw new Error('Loader can only be used once.');\n        }\n        stats.loading.start = self.performance.now();\n        var initParams = getRequestParameters(context, this.controller.signal);\n        var onProgress = callbacks.onProgress;\n        var isArrayBuffer = context.responseType === 'arraybuffer';\n        var LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n        var _config$loadPolicy = config.loadPolicy,\n          maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs,\n          maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;\n        this.context = context;\n        this.config = config;\n        this.callbacks = callbacks;\n        this.request = this.fetchSetup(context, initParams);\n        self.clearTimeout(this.requestTimeout);\n        config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n        this.requestTimeout = self.setTimeout(function () {\n          _this.abortInternal();\n          callbacks.onTimeout(stats, context, _this.response);\n        }, config.timeout);\n        self.fetch(this.request).then(function (response) {\n          _this.response = _this.loader = response;\n          var first = Math.max(self.performance.now(), stats.loading.start);\n          self.clearTimeout(_this.requestTimeout);\n          config.timeout = maxLoadTimeMs;\n          _this.requestTimeout = self.setTimeout(function () {\n            _this.abortInternal();\n            callbacks.onTimeout(stats, context, _this.response);\n          }, maxLoadTimeMs - (first - stats.loading.start));\n          if (!response.ok) {\n            var status = response.status,\n              statusText = response.statusText;\n            throw new FetchError(statusText || 'fetch, bad network response', status, response);\n          }\n          stats.loading.first = first;\n          stats.total = getContentLength(response.headers) || stats.total;\n          if (onProgress && isFiniteNumber(config.highWaterMark)) {\n            return _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n          }\n          if (isArrayBuffer) {\n            return response.arrayBuffer();\n          }\n          if (context.responseType === 'json') {\n            return response.json();\n          }\n          return response.text();\n        }).then(function (responseData) {\n          var response = _this.response;\n          self.clearTimeout(_this.requestTimeout);\n          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n          var total = responseData[LENGTH];\n          if (total) {\n            stats.loaded = stats.total = total;\n          }\n          var loaderResponse = {\n            url: response.url,\n            data: responseData,\n            code: response.status\n          };\n          if (onProgress && !isFiniteNumber(config.highWaterMark)) {\n            onProgress(stats, context, responseData, response);\n          }\n          callbacks.onSuccess(loaderResponse, stats, context, response);\n        }).catch(function (error) {\n          self.clearTimeout(_this.requestTimeout);\n          if (stats.aborted) {\n            return;\n          }\n          // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n          // when destroying, 'error' itself can be undefined\n          var code = !error ? 0 : error.code || 0;\n          var text = !error ? null : error.message;\n          callbacks.onError({\n            code: code,\n            text: text\n          }, context, error ? error.details : null, stats);\n        });\n      };\n      _proto.getCacheAge = function getCacheAge() {\n        var result = null;\n        if (this.response) {\n          var ageHeader = this.response.headers.get('age');\n          result = ageHeader ? parseFloat(ageHeader) : null;\n        }\n        return result;\n      };\n      _proto.getResponseHeader = function getResponseHeader(name) {\n        return this.response ? this.response.headers.get(name) : null;\n      };\n      _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {\n        if (highWaterMark === void 0) {\n          highWaterMark = 0;\n        }\n        var chunkCache = new ChunkCache();\n        var reader = response.body.getReader();\n        var pump = function pump() {\n          return reader.read().then(function (data) {\n            if (data.done) {\n              if (chunkCache.dataLength) {\n                onProgress(stats, context, chunkCache.flush(), response);\n              }\n              return Promise.resolve(new ArrayBuffer(0));\n            }\n            var chunk = data.value;\n            var len = chunk.length;\n            stats.loaded += len;\n            if (len < highWaterMark || chunkCache.dataLength) {\n              // The current chunk is too small to to be emitted or the cache already has data\n              // Push it to the cache\n              chunkCache.push(chunk);\n              if (chunkCache.dataLength >= highWaterMark) {\n                // flush in order to join the typed arrays\n                onProgress(stats, context, chunkCache.flush(), response);\n              }\n            } else {\n              // If there's nothing cached already, and the chache is large enough\n              // just emit the progress event\n              onProgress(stats, context, chunk, response);\n            }\n            return pump();\n          }).catch(function () {\n            /* aborted */\n            return Promise.reject();\n          });\n        };\n        return pump();\n      };\n      return FetchLoader;\n    }();\n    function getRequestParameters(context, signal) {\n      var initParams = {\n        method: 'GET',\n        mode: 'cors',\n        credentials: 'same-origin',\n        signal: signal,\n        headers: new self.Headers(_extends({}, context.headers))\n      };\n      if (context.rangeEnd) {\n        initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n      }\n      return initParams;\n    }\n    function getByteRangeLength(byteRangeHeader) {\n      var result = BYTERANGE.exec(byteRangeHeader);\n      if (result) {\n        return parseInt(result[2]) - parseInt(result[1]) + 1;\n      }\n    }\n    function getContentLength(headers) {\n      var contentRange = headers.get('Content-Range');\n      if (contentRange) {\n        var byteRangeLength = getByteRangeLength(contentRange);\n        if (isFiniteNumber(byteRangeLength)) {\n          return byteRangeLength;\n        }\n      }\n      var contentLength = headers.get('Content-Length');\n      if (contentLength) {\n        return parseInt(contentLength);\n      }\n    }\n    function getRequest(context, initParams) {\n      return new self.Request(context.url, initParams);\n    }\n    var FetchError = /*#__PURE__*/function (_Error) {\n      _inheritsLoose(FetchError, _Error);\n      function FetchError(message, code, details) {\n        var _this2;\n        _this2 = _Error.call(this, message) || this;\n        _this2.code = void 0;\n        _this2.details = void 0;\n        _this2.code = code;\n        _this2.details = details;\n        return _this2;\n      }\n      return FetchError;\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n    /**\n     * @deprecated use fragLoadPolicy.default\n     */\n\n    /**\n     * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default\n     */\n\n    var defaultLoadPolicy = {\n      maxTimeToFirstByteMs: 8000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: null,\n      errorRetry: null\n    };\n\n    /**\n     * @ignore\n     * If possible, keep hlsDefaultConfig shallow\n     * It is cloned whenever a new Hls instance is created, by keeping the config\n     * shallow the properties are cloned, and we don't end up manipulating the default\n     */\n    var hlsDefaultConfig = _objectSpread2(_objectSpread2({\n      autoStartLoad: true,\n      // used by stream-controller\n      startPosition: -1,\n      // used by stream-controller\n      defaultAudioCodec: undefined,\n      // used by stream-controller\n      debug: false,\n      // used by logger\n      capLevelOnFPSDrop: false,\n      // used by fps-controller\n      capLevelToPlayerSize: false,\n      // used by cap-level-controller\n      ignoreDevicePixelRatio: false,\n      // used by cap-level-controller\n      initialLiveManifestSize: 1,\n      // used by stream-controller\n      maxBufferLength: 30,\n      // used by stream-controller\n      backBufferLength: Infinity,\n      // used by buffer-controller\n      maxBufferSize: 60 * 1000 * 1000,\n      // used by stream-controller\n      maxBufferHole: 0.1,\n      // used by stream-controller\n      highBufferWatchdogPeriod: 2,\n      // used by stream-controller\n      nudgeOffset: 0.1,\n      // used by stream-controller\n      nudgeMaxRetry: 3,\n      // used by stream-controller\n      maxFragLookUpTolerance: 0.25,\n      // used by stream-controller\n      liveSyncDurationCount: 3,\n      // used by latency-controller\n      liveMaxLatencyDurationCount: Infinity,\n      // used by latency-controller\n      liveSyncDuration: undefined,\n      // used by latency-controller\n      liveMaxLatencyDuration: undefined,\n      // used by latency-controller\n      maxLiveSyncPlaybackRate: 1,\n      // used by latency-controller\n      liveDurationInfinity: false,\n      // used by buffer-controller\n      /**\n       * @deprecated use backBufferLength\n       */\n      liveBackBufferLength: null,\n      // used by buffer-controller\n      maxMaxBufferLength: 600,\n      // used by stream-controller\n      enableWorker: true,\n      // used by transmuxer\n      workerPath: null,\n      // used by transmuxer\n      enableSoftwareAES: true,\n      // used by decrypter\n      startLevel: undefined,\n      // used by level-controller\n      startFragPrefetch: false,\n      // used by stream-controller\n      fpsDroppedMonitoringPeriod: 5000,\n      // used by fps-controller\n      fpsDroppedMonitoringThreshold: 0.2,\n      // used by fps-controller\n      appendErrorMaxRetry: 3,\n      // used by buffer-controller\n      loader: XhrLoader,\n      // loader: FetchLoader,\n      fLoader: undefined,\n      // used by fragment-loader\n      pLoader: undefined,\n      // used by playlist-loader\n      xhrSetup: undefined,\n      // used by xhr-loader\n      licenseXhrSetup: undefined,\n      // used by eme-controller\n      licenseResponseCallback: undefined,\n      // used by eme-controller\n      abrController: AbrController,\n      bufferController: BufferController,\n      capLevelController: CapLevelController,\n      errorController: ErrorController,\n      fpsController: FPSController,\n      stretchShortVideoTrack: false,\n      // used by mp4-remuxer\n      maxAudioFramesDrift: 1,\n      // used by mp4-remuxer\n      forceKeyFrameOnDiscontinuity: true,\n      // used by ts-demuxer\n      abrEwmaFastLive: 3,\n      // used by abr-controller\n      abrEwmaSlowLive: 9,\n      // used by abr-controller\n      abrEwmaFastVoD: 3,\n      // used by abr-controller\n      abrEwmaSlowVoD: 9,\n      // used by abr-controller\n      abrEwmaDefaultEstimate: 5e5,\n      // 500 kbps  // used by abr-controller\n      abrBandWidthFactor: 0.95,\n      // used by abr-controller\n      abrBandWidthUpFactor: 0.7,\n      // used by abr-controller\n      abrMaxWithRealBitrate: false,\n      // used by abr-controller\n      maxStarvationDelay: 4,\n      // used by abr-controller\n      maxLoadingDelay: 4,\n      // used by abr-controller\n      minAutoBitrate: 0,\n      // used by hls\n      emeEnabled: false,\n      // used by eme-controller\n      widevineLicenseUrl: undefined,\n      // used by eme-controller\n      drmSystems: {},\n      // used by eme-controller\n      drmSystemOptions: {},\n      // used by eme-controller\n      requestMediaKeySystemAccessFunc: null,\n      // used by eme-controller\n      testBandwidth: true,\n      progressive: false,\n      lowLatencyMode: true,\n      cmcd: undefined,\n      enableDateRangeMetadataCues: true,\n      enableEmsgMetadataCues: true,\n      enableID3MetadataCues: true,\n      certLoadPolicy: {\n        default: defaultLoadPolicy\n      },\n      keyLoadPolicy: {\n        default: {\n          maxTimeToFirstByteMs: 8000,\n          maxLoadTimeMs: 20000,\n          timeoutRetry: {\n            maxNumRetry: 1,\n            retryDelayMs: 1000,\n            maxRetryDelayMs: 20000,\n            backoff: 'linear'\n          },\n          errorRetry: {\n            maxNumRetry: 8,\n            retryDelayMs: 1000,\n            maxRetryDelayMs: 20000,\n            backoff: 'linear'\n          }\n        }\n      },\n      manifestLoadPolicy: {\n        default: {\n          maxTimeToFirstByteMs: Infinity,\n          maxLoadTimeMs: 20000,\n          timeoutRetry: {\n            maxNumRetry: 2,\n            retryDelayMs: 0,\n            maxRetryDelayMs: 0\n          },\n          errorRetry: {\n            maxNumRetry: 1,\n            retryDelayMs: 1000,\n            maxRetryDelayMs: 8000\n          }\n        }\n      },\n      playlistLoadPolicy: {\n        default: {\n          maxTimeToFirstByteMs: 10000,\n          maxLoadTimeMs: 20000,\n          timeoutRetry: {\n            maxNumRetry: 2,\n            retryDelayMs: 0,\n            maxRetryDelayMs: 0\n          },\n          errorRetry: {\n            maxNumRetry: 2,\n            retryDelayMs: 1000,\n            maxRetryDelayMs: 8000\n          }\n        }\n      },\n      fragLoadPolicy: {\n        default: {\n          maxTimeToFirstByteMs: 10000,\n          maxLoadTimeMs: 120000,\n          timeoutRetry: {\n            maxNumRetry: 4,\n            retryDelayMs: 0,\n            maxRetryDelayMs: 0\n          },\n          errorRetry: {\n            maxNumRetry: 6,\n            retryDelayMs: 1000,\n            maxRetryDelayMs: 8000\n          }\n        }\n      },\n      steeringManifestLoadPolicy: {\n        default: defaultLoadPolicy\n      },\n      // These default settings are deprecated in favor of the above policies\n      // and are maintained for backwards compatibility\n      manifestLoadingTimeOut: 10000,\n      manifestLoadingMaxRetry: 1,\n      manifestLoadingRetryDelay: 1000,\n      manifestLoadingMaxRetryTimeout: 64000,\n      levelLoadingTimeOut: 10000,\n      levelLoadingMaxRetry: 4,\n      levelLoadingRetryDelay: 1000,\n      levelLoadingMaxRetryTimeout: 64000,\n      fragLoadingTimeOut: 20000,\n      fragLoadingMaxRetry: 6,\n      fragLoadingRetryDelay: 1000,\n      fragLoadingMaxRetryTimeout: 64000\n    }, timelineConfig()), {}, {\n      subtitleStreamController: undefined,\n      subtitleTrackController: undefined,\n      timelineController: undefined,\n      audioStreamController: undefined,\n      audioTrackController: undefined,\n      emeController: undefined,\n      cmcdController: undefined,\n      contentSteeringController: undefined\n    });\n    function timelineConfig() {\n      return {\n        cueHandler: Cues,\n        // used by timeline-controller\n        enableWebVTT: false,\n        // used by timeline-controller\n        enableIMSC1: false,\n        // used by timeline-controller\n        enableCEA708Captions: false,\n        // used by timeline-controller\n        captionsTextTrack1Label: 'English',\n        // used by timeline-controller\n        captionsTextTrack1LanguageCode: 'en',\n        // used by timeline-controller\n        captionsTextTrack2Label: 'Spanish',\n        // used by timeline-controller\n        captionsTextTrack2LanguageCode: 'es',\n        // used by timeline-controller\n        captionsTextTrack3Label: 'Unknown CC',\n        // used by timeline-controller\n        captionsTextTrack3LanguageCode: '',\n        // used by timeline-controller\n        captionsTextTrack4Label: 'Unknown CC',\n        // used by timeline-controller\n        captionsTextTrack4LanguageCode: '',\n        // used by timeline-controller\n        renderTextTracksNatively: true\n      };\n    }\n\n    /**\n     * @ignore\n     */\n    function mergeConfig(defaultConfig, userConfig) {\n      if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n        throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n      }\n      if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n        throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n      }\n      if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n        throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n      }\n      var defaultsCopy = deepCpy(defaultConfig);\n\n      // Backwards compatibility with deprecated config values\n      var deprecatedSettingTypes = ['manifest', 'level', 'frag'];\n      var deprecatedSettings = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout'];\n      deprecatedSettingTypes.forEach(function (type) {\n        var policyName = (type === 'level' ? 'playlist' : type) + \"LoadPolicy\";\n        var policyNotSet = userConfig[policyName] === undefined;\n        var report = [];\n        deprecatedSettings.forEach(function (setting) {\n          var deprecatedSetting = type + \"Loading\" + setting;\n          var value = userConfig[deprecatedSetting];\n          if (value !== undefined && policyNotSet) {\n            report.push(deprecatedSetting);\n            var settings = defaultsCopy[policyName].default;\n            userConfig[policyName] = {\n              default: settings\n            };\n            switch (setting) {\n              case 'TimeOut':\n                settings.maxLoadTimeMs = value;\n                settings.maxTimeToFirstByteMs = value;\n                break;\n              case 'MaxRetry':\n                settings.errorRetry.maxNumRetry = value;\n                settings.timeoutRetry.maxNumRetry = value;\n                break;\n              case 'RetryDelay':\n                settings.errorRetry.retryDelayMs = value;\n                settings.timeoutRetry.retryDelayMs = value;\n                break;\n              case 'MaxRetryTimeout':\n                settings.errorRetry.maxRetryDelayMs = value;\n                settings.timeoutRetry.maxRetryDelayMs = value;\n                break;\n            }\n          }\n        });\n        if (report.length) {\n          logger.warn(\"hls.js config: \\\"\" + report.join('\", \"') + \"\\\" setting(s) are deprecated, use \\\"\" + policyName + \"\\\": \" + JSON.stringify(userConfig[policyName]));\n        }\n      });\n      return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);\n    }\n    function deepCpy(obj) {\n      if (obj && typeof obj === 'object') {\n        if (Array.isArray(obj)) {\n          return obj.map(deepCpy);\n        }\n        return Object.keys(obj).reduce(function (result, key) {\n          result[key] = deepCpy(obj[key]);\n          return result;\n        }, {});\n      }\n      return obj;\n    }\n\n    /**\n     * @ignore\n     */\n    function enableStreamingMode(config) {\n      var currentLoader = config.loader;\n      if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {\n        // If a developer has configured their own loader, respect that choice\n        logger.log('[config]: Custom loader detected, cannot enable progressive streaming');\n        config.progressive = false;\n      } else {\n        var canStreamProgressively = fetchSupported();\n        if (canStreamProgressively) {\n          config.loader = FetchLoader;\n          config.progressive = true;\n          config.enableSoftwareAES = true;\n          logger.log('[config]: Progressive streaming enabled, using FetchLoader');\n        }\n      }\n    }\n\n    /**\n     * The `Hls` class is the core of the HLS.js library used to instantiate player instances.\n     * @public\n     */\n    var Hls = /*#__PURE__*/function () {\n      /**\n       * Check if the required MediaSource Extensions are available.\n       */\n      Hls.isSupported = function isSupported$1() {\n        return isSupported();\n      };\n      /**\n       * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n       * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n       */\n      function Hls(userConfig) {\n        if (userConfig === void 0) {\n          userConfig = {};\n        }\n        /**\n         * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.\n         */\n        this.config = void 0;\n        /**\n         * The configuration object provided on player instantiation.\n         */\n        this.userConfig = void 0;\n        this.coreComponents = void 0;\n        this.networkControllers = void 0;\n        this._emitter = new EventEmitter();\n        this._autoLevelCapping = void 0;\n        this._maxHdcpLevel = null;\n        this.abrController = void 0;\n        this.bufferController = void 0;\n        this.capLevelController = void 0;\n        this.latencyController = void 0;\n        this.levelController = void 0;\n        this.streamController = void 0;\n        this.audioTrackController = void 0;\n        this.subtitleTrackController = void 0;\n        this.emeController = void 0;\n        this.cmcdController = void 0;\n        this._media = null;\n        this.url = null;\n        enableLogs(userConfig.debug || false, 'Hls instance');\n        var config = this.config = mergeConfig(Hls.DefaultConfig, userConfig);\n        this.userConfig = userConfig;\n        this._autoLevelCapping = -1;\n        if (config.progressive) {\n          enableStreamingMode(config);\n        }\n\n        // core controllers and network loaders\n        var ConfigAbrController = config.abrController,\n          ConfigBufferController = config.bufferController,\n          ConfigCapLevelController = config.capLevelController,\n          ConfigErrorController = config.errorController,\n          ConfigFpsController = config.fpsController;\n        var errorController = new ConfigErrorController(this);\n        var abrController = this.abrController = new ConfigAbrController(this);\n        var bufferController = this.bufferController = new ConfigBufferController(this);\n        var capLevelController = this.capLevelController = new ConfigCapLevelController(this);\n        var fpsController = new ConfigFpsController(this);\n        var playListLoader = new PlaylistLoader(this);\n        var id3TrackController = new ID3TrackController(this);\n        var ConfigContentSteeringController = config.contentSteeringController;\n        // ConentSteeringController is defined before LevelController to receive Multivariant Playlist events first\n        var contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;\n        var levelController = this.levelController = new LevelController(this, contentSteering);\n        // FragmentTracker must be defined before StreamController because the order of event handling is important\n        var fragmentTracker = new FragmentTracker(this);\n        var keyLoader = new KeyLoader(this.config);\n        var streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);\n\n        // Cap level controller uses streamController to flush the buffer\n        capLevelController.setStreamController(streamController);\n        // fpsController uses streamController to switch when frames are being dropped\n        fpsController.setStreamController(streamController);\n        var networkControllers = [playListLoader, levelController, streamController];\n        if (contentSteering) {\n          networkControllers.splice(1, 0, contentSteering);\n        }\n        this.networkControllers = networkControllers;\n        var coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n        this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n        var AudioStreamControllerClass = config.audioStreamController;\n        if (AudioStreamControllerClass) {\n          networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n        }\n        // subtitleTrackController must be defined before subtitleStreamController because the order of event handling is important\n        this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n        var SubtitleStreamControllerClass = config.subtitleStreamController;\n        if (SubtitleStreamControllerClass) {\n          networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n        }\n        this.createController(config.timelineController, coreComponents);\n        keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n        this.cmcdController = this.createController(config.cmcdController, coreComponents);\n        this.latencyController = this.createController(LatencyController, coreComponents);\n        this.coreComponents = coreComponents;\n\n        // Error controller handles errors before and after all other controllers\n        // This listener will be invoked after all other controllers error listeners\n        networkControllers.push(errorController);\n        var onErrorOut = errorController.onErrorOut;\n        if (typeof onErrorOut === 'function') {\n          this.on(Events.ERROR, onErrorOut, errorController);\n        }\n      }\n      var _proto = Hls.prototype;\n      _proto.createController = function createController(ControllerClass, components) {\n        if (ControllerClass) {\n          var controllerInstance = new ControllerClass(this);\n          if (components) {\n            components.push(controllerInstance);\n          }\n          return controllerInstance;\n        }\n        return null;\n      }\n\n      // Delegate the EventEmitter through the public API of Hls.js\n      ;\n\n      _proto.on = function on(event, listener, context) {\n        if (context === void 0) {\n          context = this;\n        }\n        this._emitter.on(event, listener, context);\n      };\n      _proto.once = function once(event, listener, context) {\n        if (context === void 0) {\n          context = this;\n        }\n        this._emitter.once(event, listener, context);\n      };\n      _proto.removeAllListeners = function removeAllListeners(event) {\n        this._emitter.removeAllListeners(event);\n      };\n      _proto.off = function off(event, listener, context, once) {\n        if (context === void 0) {\n          context = this;\n        }\n        this._emitter.off(event, listener, context, once);\n      };\n      _proto.listeners = function listeners(event) {\n        return this._emitter.listeners(event);\n      };\n      _proto.emit = function emit(event, name, eventObject) {\n        return this._emitter.emit(event, name, eventObject);\n      };\n      _proto.trigger = function trigger(event, eventObject) {\n        if (this.config.debug) {\n          return this.emit(event, event, eventObject);\n        } else {\n          try {\n            return this.emit(event, event, eventObject);\n          } catch (e) {\n            logger.error('An internal error happened while handling event ' + event + '. Error message: \"' + e.message + '\". Here is a stacktrace:', e);\n            this.trigger(Events.ERROR, {\n              type: ErrorTypes.OTHER_ERROR,\n              details: ErrorDetails.INTERNAL_EXCEPTION,\n              fatal: false,\n              event: event,\n              error: e\n            });\n          }\n        }\n        return false;\n      };\n      _proto.listenerCount = function listenerCount(event) {\n        return this._emitter.listenerCount(event);\n      }\n\n      /**\n       * Dispose of the instance\n       */;\n      _proto.destroy = function destroy() {\n        logger.log('destroy');\n        this.trigger(Events.DESTROYING, undefined);\n        this.detachMedia();\n        this.removeAllListeners();\n        this._autoLevelCapping = -1;\n        this.url = null;\n        this.networkControllers.forEach(function (component) {\n          return component.destroy();\n        });\n        this.networkControllers.length = 0;\n        this.coreComponents.forEach(function (component) {\n          return component.destroy();\n        });\n        this.coreComponents.length = 0;\n        // Remove any references that could be held in config options or callbacks\n        var config = this.config;\n        config.xhrSetup = config.fetchSetup = undefined;\n        // @ts-ignore\n        this.userConfig = null;\n      }\n\n      /**\n       * Attaches Hls.js to a media element\n       */;\n      _proto.attachMedia = function attachMedia(media) {\n        logger.log('attachMedia');\n        this._media = media;\n        this.trigger(Events.MEDIA_ATTACHING, {\n          media: media\n        });\n      }\n\n      /**\n       * Detach Hls.js from the media\n       */;\n      _proto.detachMedia = function detachMedia() {\n        logger.log('detachMedia');\n        this.trigger(Events.MEDIA_DETACHING, undefined);\n        this._media = null;\n      }\n\n      /**\n       * Set the source URL. Can be relative or absolute.\n       */;\n      _proto.loadSource = function loadSource(url) {\n        this.stopLoad();\n        var media = this.media;\n        var loadedSource = this.url;\n        var loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {\n          alwaysNormalize: true\n        });\n        logger.log(\"loadSource:\" + loadingSource);\n        if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {\n          this.detachMedia();\n          this.attachMedia(media);\n        }\n        // when attaching to a source URL, trigger a playlist load\n        this.trigger(Events.MANIFEST_LOADING, {\n          url: url\n        });\n      }\n\n      /**\n       * Start loading data from the stream source.\n       * Depending on default config, client starts loading automatically when a source is set.\n       *\n       * @param startPosition - Set the start position to stream from.\n       * Defaults to -1 (None: starts from earliest point)\n       */;\n      _proto.startLoad = function startLoad(startPosition) {\n        if (startPosition === void 0) {\n          startPosition = -1;\n        }\n        logger.log(\"startLoad(\" + startPosition + \")\");\n        this.networkControllers.forEach(function (controller) {\n          controller.startLoad(startPosition);\n        });\n      }\n\n      /**\n       * Stop loading of any stream data.\n       */;\n      _proto.stopLoad = function stopLoad() {\n        logger.log('stopLoad');\n        this.networkControllers.forEach(function (controller) {\n          controller.stopLoad();\n        });\n      }\n\n      /**\n       * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n       */;\n      _proto.swapAudioCodec = function swapAudioCodec() {\n        logger.log('swapAudioCodec');\n        this.streamController.swapAudioCodec();\n      }\n\n      /**\n       * When the media-element fails, this allows to detach and then re-attach it\n       * as one call (convenience method).\n       *\n       * Automatic recovery of media-errors by this process is configurable.\n       */;\n      _proto.recoverMediaError = function recoverMediaError() {\n        logger.log('recoverMediaError');\n        var media = this._media;\n        this.detachMedia();\n        if (media) {\n          this.attachMedia(media);\n        }\n      };\n      _proto.removeLevel = function removeLevel(levelIndex, urlId) {\n        if (urlId === void 0) {\n          urlId = 0;\n        }\n        this.levelController.removeLevel(levelIndex, urlId);\n      }\n\n      /**\n       * @returns an array of levels (variants) sorted by HDCP-LEVEL, BANDWIDTH, SCORE, and RESOLUTION (height)\n       */;\n      _createClass(Hls, [{\n        key: \"levels\",\n        get: function get() {\n          var levels = this.levelController.levels;\n          return levels ? levels : [];\n        }\n\n        /**\n         * Index of quality level (variant) currently played\n         */\n      }, {\n        key: \"currentLevel\",\n        get: function get() {\n          return this.streamController.currentLevel;\n        }\n\n        /**\n         * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n         */,\n        set: function set(newLevel) {\n          logger.log(\"set currentLevel:\" + newLevel);\n          this.loadLevel = newLevel;\n          this.abrController.clearTimer();\n          this.streamController.immediateLevelSwitch();\n        }\n\n        /**\n         * Index of next quality level loaded as scheduled by stream controller.\n         */\n      }, {\n        key: \"nextLevel\",\n        get: function get() {\n          return this.streamController.nextLevel;\n        }\n\n        /**\n         * Set quality level index for next loaded data.\n         * This will switch the video quality asap, without interrupting playback.\n         * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n         * @param newLevel - Pass -1 for automatic level selection\n         */,\n        set: function set(newLevel) {\n          logger.log(\"set nextLevel:\" + newLevel);\n          this.levelController.manualLevel = newLevel;\n          this.streamController.nextLevelSwitch();\n        }\n\n        /**\n         * Return the quality level of the currently or last (of none is loaded currently) segment\n         */\n      }, {\n        key: \"loadLevel\",\n        get: function get() {\n          return this.levelController.level;\n        }\n\n        /**\n         * Set quality level index for next loaded data in a conservative way.\n         * This will switch the quality without flushing, but interrupt current loading.\n         * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n         * @param newLevel - Pass -1 for automatic level selection\n         */,\n        set: function set(newLevel) {\n          logger.log(\"set loadLevel:\" + newLevel);\n          this.levelController.manualLevel = newLevel;\n        }\n\n        /**\n         * get next quality level loaded\n         */\n      }, {\n        key: \"nextLoadLevel\",\n        get: function get() {\n          return this.levelController.nextLoadLevel;\n        }\n\n        /**\n         * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n         * Same as `loadLevel` but will wait for next switch (until current loading is done).\n         */,\n        set: function set(level) {\n          this.levelController.nextLoadLevel = level;\n        }\n\n        /**\n         * Return \"first level\": like a default level, if not set,\n         * falls back to index of first level referenced in manifest\n         */\n      }, {\n        key: \"firstLevel\",\n        get: function get() {\n          return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n        }\n\n        /**\n         * Sets \"first-level\", see getter.\n         */,\n        set: function set(newLevel) {\n          logger.log(\"set firstLevel:\" + newLevel);\n          this.levelController.firstLevel = newLevel;\n        }\n\n        /**\n         * Return start level (level of first fragment that will be played back)\n         * if not overrided by user, first level appearing in manifest will be used as start level\n         * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n         * (determined from download of first segment)\n         */\n      }, {\n        key: \"startLevel\",\n        get: function get() {\n          return this.levelController.startLevel;\n        }\n\n        /**\n         * set  start level (level of first fragment that will be played back)\n         * if not overrided by user, first level appearing in manifest will be used as start level\n         * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n         * (determined from download of first segment)\n         */,\n        set: function set(newLevel) {\n          logger.log(\"set startLevel:\" + newLevel);\n          // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n          if (newLevel !== -1) {\n            newLevel = Math.max(newLevel, this.minAutoLevel);\n          }\n          this.levelController.startLevel = newLevel;\n        }\n\n        /**\n         * Whether level capping is enabled.\n         * Default value is set via `config.capLevelToPlayerSize`.\n         */\n      }, {\n        key: \"capLevelToPlayerSize\",\n        get: function get() {\n          return this.config.capLevelToPlayerSize;\n        }\n\n        /**\n         * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n         */,\n        set: function set(shouldStartCapping) {\n          var newCapLevelToPlayerSize = !!shouldStartCapping;\n          if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n            if (newCapLevelToPlayerSize) {\n              this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n            } else {\n              this.capLevelController.stopCapping();\n              this.autoLevelCapping = -1;\n              this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n            }\n\n            this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n          }\n        }\n\n        /**\n         * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n         */\n      }, {\n        key: \"autoLevelCapping\",\n        get: function get() {\n          return this._autoLevelCapping;\n        }\n\n        /**\n         * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n         */,\n        set:\n        /**\n         * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n         */\n        function set(newLevel) {\n          if (this._autoLevelCapping !== newLevel) {\n            logger.log(\"set autoLevelCapping:\" + newLevel);\n            this._autoLevelCapping = newLevel;\n          }\n        }\n      }, {\n        key: \"bandwidthEstimate\",\n        get: function get() {\n          var bwEstimator = this.abrController.bwEstimator;\n          if (!bwEstimator) {\n            return NaN;\n          }\n          return bwEstimator.getEstimate();\n        }\n\n        /**\n         * get time to first byte estimate\n         * @type {number}\n         */\n      }, {\n        key: \"ttfbEstimate\",\n        get: function get() {\n          var bwEstimator = this.abrController.bwEstimator;\n          if (!bwEstimator) {\n            return NaN;\n          }\n          return bwEstimator.getEstimateTTFB();\n        }\n      }, {\n        key: \"maxHdcpLevel\",\n        get: function get() {\n          return this._maxHdcpLevel;\n        },\n        set: function set(value) {\n          if (HdcpLevels.indexOf(value) > -1) {\n            this._maxHdcpLevel = value;\n          }\n        }\n\n        /**\n         * True when automatic level selection enabled\n         */\n      }, {\n        key: \"autoLevelEnabled\",\n        get: function get() {\n          return this.levelController.manualLevel === -1;\n        }\n\n        /**\n         * Level set manually (if any)\n         */\n      }, {\n        key: \"manualLevel\",\n        get: function get() {\n          return this.levelController.manualLevel;\n        }\n\n        /**\n         * min level selectable in auto mode according to config.minAutoBitrate\n         */\n      }, {\n        key: \"minAutoLevel\",\n        get: function get() {\n          var levels = this.levels,\n            minAutoBitrate = this.config.minAutoBitrate;\n          if (!levels) return 0;\n          var len = levels.length;\n          for (var i = 0; i < len; i++) {\n            if (levels[i].maxBitrate >= minAutoBitrate) {\n              return i;\n            }\n          }\n          return 0;\n        }\n\n        /**\n         * max level selectable in auto mode according to autoLevelCapping\n         */\n      }, {\n        key: \"maxAutoLevel\",\n        get: function get() {\n          var levels = this.levels,\n            autoLevelCapping = this.autoLevelCapping,\n            maxHdcpLevel = this.maxHdcpLevel;\n          var maxAutoLevel;\n          if (autoLevelCapping === -1 && levels && levels.length) {\n            maxAutoLevel = levels.length - 1;\n          } else {\n            maxAutoLevel = autoLevelCapping;\n          }\n          if (maxHdcpLevel) {\n            for (var i = maxAutoLevel; i--;) {\n              var hdcpLevel = levels[i].attrs['HDCP-LEVEL'];\n              if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n                return i;\n              }\n            }\n          }\n          return maxAutoLevel;\n        }\n\n        /**\n         * next automatically selected quality level\n         */\n      }, {\n        key: \"nextAutoLevel\",\n        get: function get() {\n          // ensure next auto level is between  min and max auto level\n          return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);\n        }\n\n        /**\n         * this setter is used to force next auto level.\n         * this is useful to force a switch down in auto mode:\n         * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n         * forced value is valid for one fragment. upon successful frag loading at forced level,\n         * this value will be resetted to -1 by ABR controller.\n         */,\n        set: function set(nextLevel) {\n          this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);\n        }\n\n        /**\n         * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n         */\n      }, {\n        key: \"playingDate\",\n        get: function get() {\n          return this.streamController.currentProgramDateTime;\n        }\n      }, {\n        key: \"mainForwardBufferInfo\",\n        get: function get() {\n          return this.streamController.getMainFwdBufferInfo();\n        }\n\n        /**\n         * Get the list of selectable audio tracks\n         */\n      }, {\n        key: \"audioTracks\",\n        get: function get() {\n          var audioTrackController = this.audioTrackController;\n          return audioTrackController ? audioTrackController.audioTracks : [];\n        }\n\n        /**\n         * index of the selected audio track (index in audio track lists)\n         */\n      }, {\n        key: \"audioTrack\",\n        get: function get() {\n          var audioTrackController = this.audioTrackController;\n          return audioTrackController ? audioTrackController.audioTrack : -1;\n        }\n\n        /**\n         * selects an audio track, based on its index in audio track lists\n         */,\n        set: function set(audioTrackId) {\n          var audioTrackController = this.audioTrackController;\n          if (audioTrackController) {\n            audioTrackController.audioTrack = audioTrackId;\n          }\n        }\n\n        /**\n         * get alternate subtitle tracks list from playlist\n         */\n      }, {\n        key: \"subtitleTracks\",\n        get: function get() {\n          var subtitleTrackController = this.subtitleTrackController;\n          return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n        }\n\n        /**\n         * index of the selected subtitle track (index in subtitle track lists)\n         */\n      }, {\n        key: \"subtitleTrack\",\n        get: function get() {\n          var subtitleTrackController = this.subtitleTrackController;\n          return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n        },\n        set:\n        /**\n         * select an subtitle track, based on its index in subtitle track lists\n         */\n        function set(subtitleTrackId) {\n          var subtitleTrackController = this.subtitleTrackController;\n          if (subtitleTrackController) {\n            subtitleTrackController.subtitleTrack = subtitleTrackId;\n          }\n        }\n\n        /**\n         * Whether subtitle display is enabled or not\n         */\n      }, {\n        key: \"media\",\n        get: function get() {\n          return this._media;\n        }\n      }, {\n        key: \"subtitleDisplay\",\n        get: function get() {\n          var subtitleTrackController = this.subtitleTrackController;\n          return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n        }\n\n        /**\n         * Enable/disable subtitle display rendering\n         */,\n        set: function set(value) {\n          var subtitleTrackController = this.subtitleTrackController;\n          if (subtitleTrackController) {\n            subtitleTrackController.subtitleDisplay = value;\n          }\n        }\n\n        /**\n         * get mode for Low-Latency HLS loading\n         */\n      }, {\n        key: \"lowLatencyMode\",\n        get: function get() {\n          return this.config.lowLatencyMode;\n        }\n\n        /**\n         * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n         */,\n        set: function set(mode) {\n          this.config.lowLatencyMode = mode;\n        }\n\n        /**\n         * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n         * @returns null prior to loading live Playlist\n         */\n      }, {\n        key: \"liveSyncPosition\",\n        get: function get() {\n          return this.latencyController.liveSyncPosition;\n        }\n\n        /**\n         * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n         * @returns 0 before first playlist is loaded\n         */\n      }, {\n        key: \"latency\",\n        get: function get() {\n          return this.latencyController.latency;\n        }\n\n        /**\n         * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n         * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n         * @returns 0 before first playlist is loaded\n         */\n      }, {\n        key: \"maxLatency\",\n        get: function get() {\n          return this.latencyController.maxLatency;\n        }\n\n        /**\n         * target distance from the edge as calculated by the latency controller\n         */\n      }, {\n        key: \"targetLatency\",\n        get: function get() {\n          return this.latencyController.targetLatency;\n        }\n\n        /**\n         * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n         */\n      }, {\n        key: \"drift\",\n        get: function get() {\n          return this.latencyController.drift;\n        }\n\n        /**\n         * set to true when startLoad is called before MANIFEST_PARSED event\n         */\n      }, {\n        key: \"forceStartLoad\",\n        get: function get() {\n          return this.streamController.forceStartLoad;\n        }\n      }], [{\n        key: \"version\",\n        get:\n        /**\n         * Get the video-dev/hls.js package version.\n         */\n        function get() {\n          return \"1.4.4\";\n        }\n      }, {\n        key: \"Events\",\n        get: function get() {\n          return Events;\n        }\n      }, {\n        key: \"ErrorTypes\",\n        get: function get() {\n          return ErrorTypes;\n        }\n      }, {\n        key: \"ErrorDetails\",\n        get: function get() {\n          return ErrorDetails;\n        }\n\n        /**\n         * Get the default configuration applied to new instances.\n         */\n      }, {\n        key: \"DefaultConfig\",\n        get: function get() {\n          if (!Hls.defaultConfig) {\n            return hlsDefaultConfig;\n          }\n          return Hls.defaultConfig;\n        }\n\n        /**\n         * Replace the default configuration applied to new instances.\n         */,\n        set: function set(defaultConfig) {\n          Hls.defaultConfig = defaultConfig;\n        }\n      }]);\n      return Hls;\n    }();\n    Hls.defaultConfig = void 0;\n    return Hls;\n  });\n})(false);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGxzLmpzL2Rpc3QvaGxzLmxpZ2h0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7QUFJQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBU0E7QUFHQTtBQU9BOzs7QUM3S0E7QUFHQTtBQUNBO0FDK0NBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFtSEE7Ozs7QUN0S0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQ0FBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBREE7QUFBQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUNwRkE7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FDMUdBOztBQWFBO0FBQ0E7QUFRQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBTUE7QUFBQTtBQUxBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQU9BO0FBQUE7QUFBQTtBQUFBO0FDNUhBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FDSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQW1CQTtBQUlBOztBQUVBOztBQUVBOztBQU9BO0FBQUE7QUFBQTtBQWRBO0FBQ0E7QUFHQTtBQUVBO0FBU0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUdBOzs7QUFHQTtBQUFBO0FBT0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUdBO0FBQUE7QUFDQTtBQUFBO0FBeERBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUlBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQU1BO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUErREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFTQTtBQURBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBekdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQW1EQTs7O0FBR0E7QUFBQTtBQVVBO0FBTUE7QUFDQTtBQUFBO0FBaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBS0E7QUFBQTtBQUFBO0FBQUE7QUN2VEE7O0FBRUE7OztBQUdBO0FBZUE7O0FBZ0NBO0FBQUE7QUE5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FDdEpBO0FBQ0E7QUFDQTs7QUNGQTtBQUtBO0FBQ0E7QUFDQTtBQUdBOztBQ1JBOztBQUlBOzs7OztBQUtBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUtBO0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFHQTtBQURBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQ3BaQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDVEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBYUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzMvQkE7QUFBQTtBQWdCQTtBQU1BO0FBRkE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFpQkE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFvRkE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBSUE7QUM1Q0E7QUFFQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBS0E7QUFXQTtBQUVBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFNQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQWVBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBV0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQWlCQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFtQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUtBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUNqdUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUN6SUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFTQTtBQUFBO0FBTkE7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFJQTtBQUhBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBUUE7QUFBQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVFBO0FBSEE7QUFBQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFVQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FDL3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25EQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FDOURBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFBQTtBQVVBO0FBQUE7QUFSQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUtBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQURBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUFBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkVBO0FBQUE7QUFBQTtBQW9FQTtBQUFBO0FBQUE7QUM1V0E7QUFlQTtBQUFBO0FBQUE7QUFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFpR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBTUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBbE9BO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFBQTtBQUFBO0FBQUE7QUNuRkE7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQUE7QUFKQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBcUJBO0FBQUE7QUFwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUF5Q0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBeENBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBREE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBSUE7QUFFQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQU1BO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQ2pFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQ3hDQTs7Ozs7O0FBTUE7QUFLQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFLQTtBQUZBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUlBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUtBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xLQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFTQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQTRCQTtBQUFBO0FBUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBR0E7QUFHQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBdEJBO0FBQUE7QUFBQTtBQUFBO0FBdUJBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFpQkE7QUFpQkE7QUFBQTtBQVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBS0E7QUFNQTtBQUFBO0FBS0E7QUFLQTtBQUFBO0FBTUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUM5VEE7QUFBQTtBQUVBO0FBV0E7QUFHQTtBQUNBO0FBQUE7QUFkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUlBO0FBRkE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQThIQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBaUJBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBaFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQThIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFpREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDem1CQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQWlCQTtBQUFBO0FBZkE7QUFFQTtBQUVBO0FBS0E7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBRUE7OztBQUFBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFBQTtBQUFBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFBQTtBQUFBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUlBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FDcmVBO0FBQUE7QUFPQTtBQUFBO0FBSkE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFHQTtBQURBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQzVXQTtBQXFCQTtBQUFBO0FBSkE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFKQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFiQTtBQUFBO0FBQUE7QUFXQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQVFBO0FBRUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQVFBO0FBQUE7QUFBQTtBQUdBO0FBRUE7QUFLQTtBQUNBO0FBUUE7QUFFQTtBQUtBO0FBQ0E7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FDbFdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBbUNBO0FBQUE7QUFMQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFJQTtBQUFBOztBQzdIQTs7Ozs7Ozs7QUEwQkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUNBOzs7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQ2xLQTtBQXdCQTtBQUhBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FDckNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FBT0E7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUMvS0E7QUFJQTtBQUFBO0FBSEE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUNYQTtBQUlBO0FBQUE7QUFIQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBQUE7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUEyQkE7QUFBQTtBQXRCQTtBQU1BO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBRUE7QUFNQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBTUE7QUFNQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFNQTtBQU1BO0FBTUE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FDdlVBO0FBQUE7QUFjQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBOztBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FDMU1BOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUN5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFvQ0E7QUFNQTtBQUNBO0FBQUE7QUF2Q0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7O0FBSUE7QUFBQTs7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBTUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFPQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVFBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQURBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFPQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBUUE7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBR0E7QUFPQTtBQUFBO0FBQUE7QUFGQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFLQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUtBO0FBQUE7QUFTQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFBQTtBQUFBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQUE7QUFBQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBT0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUFBO0FBT0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQVdBO0FBQ0E7QUFBQTtBQVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQy9zREE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLQTtBQUNBO0FBQ0E7QUFLQTtBQUNBOztBQUVBOzs7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FDdENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNFQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBOztBQVFBO0FBQUE7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBR0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBR0E7Ozs7OztBQU1BO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQ2pNQTs7OztBQTJCQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQ2xUQTtBQUlBO0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFKQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBT0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUM1REE7QUFBQTtBQVdBO0FBQUE7QUFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBUUE7QUFJQTtBQUlBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUdBO0FBQUE7QUFFQTtBQUFBOztBQ3JNQTs7OztBQUtBO0FBRUE7QUFRQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBOztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7O0FBR0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTs7OztBQUlBO0FBUUE7QUFBQTtBQUxBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTs7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7Ozs7OztBQUFBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FBQUE7QUFBQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUNyV0E7Ozs7QUFjQTtBQU1BO0FBQUE7QUFIQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFLQTs7QUFFQTtBQUFBOztBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUlBO0FBRUE7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBS0E7QUFJQTtBQUVBO0FBQ0E7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FDdklBO0FBQUE7QUFzQkE7QUFJQTtBQXZCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBVUE7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBT0E7QUFGQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBT0E7QUFNQTtBQUtBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBTUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeHRDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFBQTtBQUFBOztBQ25FQTs7O0FBQUE7QUFJQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FDN0VBOzs7O0FBU0E7QUFBQTtBQUVBO0FBQUE7QUFjQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFZQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFZQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFEQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQVNBO0FBQ0E7QUFJQTtBQUFBO0FBR0E7QUFNQTtBQUFBO0FBR0E7QUFNQTtBQUNBO0FBR0E7QUFHQTs7QUFBQTtBQUdBO0FBQ0E7QUFNQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBR0E7QUFLQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFBQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQU9BO0FBQ0E7QUFHQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFtQ0E7QUFDQTtBQXVCQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQVFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFNQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7O0FBRUE7QUFBQTtBQU1BOztBQUFBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFBQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUNBO0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFtQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUdBOztBQUFBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQWFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBOzs7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFHQTs7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQU1BO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQTFtQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQ1hBO0FBT0E7QUFLQTtBQUZBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFXQTtBQUdBO0FBREE7QUFBQTtBQUVBO0FBQ0E7QUNDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFlQTtBQUlBO0FBaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBTUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQU1BO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFTQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBS0E7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFRQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQWFBO0FBVkE7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBV0E7QUFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FDbG5DQTtBQWlCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQWlCQTtBQU1BO0FBcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFTQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQU1BO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVFBO0FBQ0E7QUFHQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFJQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQWFBO0FBWkE7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQWVBO0FBZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdnQkE7QUFDQTs7QUFFQTs7Ozs7OztBQU9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBRUE7QUFJQTs7O0FBR0E7Ozs7Ozs7QUFPQTtBQUNBOzs7QUFJQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFHQTtBQUNBOztBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOzs7O0FBS0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUNBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBS0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUNBOztBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdlVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFUQTtBQUFBO0FBQUE7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7O0FDMUxBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFnQkE7QUFLQTtBQUFBO0FBbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBYUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBUUE7QUFDQTtBQU9BO0FBT0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FDNVlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFhQTtBQUFBO0FBVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBQUE7QUFBQTtBQU9BO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTs7QUFFQTs7Ozs7QUFBQTtBQUFBO0FBVUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBQUE7QUFBQTtBQU1BO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFBQTtBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FDeFVBO0FBQUE7QUFFQTtBQW1CQTtBQUlBO0FBQ0E7QUFNQTtBQTFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUlBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFBQTtBQUFBO0FBT0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUtBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUtBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBUUE7QUFFQTtBQVlBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQUE7QUFHQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFJQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FDcDRDQTs7Ozs7QUFBQTtBQVlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU5BO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FDdkNBOzs7Ozs7OztBQVFBO0FBV0E7QUFLQTtBQURBO0FBQUE7QUFBQTtBQVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FDdkZBO0FBMkJBO0FBQUE7QUFaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFLQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFLQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQThCQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUFBO0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQXlMQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FDaGpCQTtBQWdCQTtBQUFBO0FBUEE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUNwREE7QUFDQTtBQUFBO0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBS0E7O0FBR0E7O0FBR0E7O0FBR0E7O0FBR0E7O0FBR0E7O0FBT0E7QUFBQTtBQUFBO0FBaENBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFFQTtBQUNBO0FBNHRCQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQXh2QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFJQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBQUE7QUFBQTtBQU1BO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQU1BO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7O0FBQUE7QUFJQTtBQUFBO0FBREE7QUFBQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FDejhCQTtBQXVCQTtBQUFBO0FBVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBOztBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUtBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQXdCQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFyRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQ3hPQTtBQWNBOztBQUdBO0FBQUE7QUFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUM1SEE7QUFBQTtBQWdCQTtBQUFBO0FBYkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQzlUQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFjQTtBQUFBO0FBWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBUUE7QUFGQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUhBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBOztBQ3BMQTs7OztBQTZCQTs7OztBQWdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFnQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUlBO0FBS0E7QUFHQTtBQUVBO0FBTUE7QUFHQTtBQUVBO0FBS0E7QUFHQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDem1CQTs7OztBQUFBO0FBMENBOzs7QUFBQTtBQUlBO0FBQ0E7QUFnQ0E7Ozs7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQTVFQTs7O0FBQUE7QUFLQTs7O0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb0RBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVNBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFLQTtBQURBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFNQTtBQURBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFPQTtBQUZBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBOzs7Ozs7QUFBQTtBQUFBO0FBT0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBOztBQUVBOzs7OztBQUFBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFFQTs7Ozs7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7O0FBRUE7Ozs7O0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUtBO0FBQ0E7O0FBRUE7Ozs7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBOztBQUVBOztBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7O0FBRUE7Ozs7O0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBOzs7O0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBdUJBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUEzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBYUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBSUE7O0FBRUE7Ozs7OztBQUFBO0FBQUE7QUFRQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFHQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFNQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFiQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBZ0JBO0FBQ0E7QUFHQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFFQTs7OztBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7O0FBRUE7Ozs7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBOztBQUVBOzs7OztBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUE1eEJBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFVQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7O0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7O0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUF6RUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9ub2RlX21vZHVsZXMvdXJsLXRvb2xraXQvc3JjL3VybC10b29sa2l0LmpzPzAxYjQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3BvbHlmaWxscy9udW1iZXIudHM/NzJjZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZXZlbnRzLnRzPzMxNTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2Vycm9ycy50cz9iNmIxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy9sb2dnZXIudHM/OWRkMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvYXR0ci1saXN0LnRzPzM2ZjgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2xvYWRlci9kYXRlLXJhbmdlLnRzPzQxOWUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2xvYWRlci9sb2FkLXN0YXRzLnRzPzg0NmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2xvYWRlci9mcmFnbWVudC50cz9mZmIzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9sb2FkZXIvbGV2ZWwtZGV0YWlscy50cz9jYmRkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9lbXB0eS5qcz8yMDM0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy90eXBlZC1hcnJheS50cz9kZmUyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9pZDMudHM/YjE4NCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvaGV4LnRzPzkyYzYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL21wNC10b29scy50cz8xMzE5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9sb2FkZXIvbGV2ZWwta2V5LnRzPzgzMmYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL21lZGlhc291cmNlLWhlbHBlci50cz8wYWY3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy9jb2RlY3MudHM/ZmZjMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvbG9hZGVyL20zdTgtcGFyc2VyLnRzPzViMzciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3R5cGVzL2xvYWRlci50cz8zYWVhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLnRzPzY4NTkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy50cz9jOGEzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy90eXBlcy9kZW11eGVyLnRzPzgwMGMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXIudHM/OWUyNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9sYXRlbmN5LWNvbnRyb2xsZXIudHM/Y2FlNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdHlwZXMvbGV2ZWwudHM/NDc3NSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9sZXZlbC1oZWxwZXIudHM/YzRkYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvZXJyb3ItaGVscGVyLnRzP2U2NDUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2gudHM/ZWJiYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9mcmFnbWVudC1maW5kZXJzLnRzP2FjNjkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvZXJyb3ItY29udHJvbGxlci50cz9kYjc0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlci50cz80N2RkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXIudHM/NDE4ZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLnRzPzA3MGQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2xvYWRlci9mcmFnbWVudC1sb2FkZXIudHM/NTRjNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvbG9hZGVyL2tleS1sb2FkZXIudHM/NDY1ZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdGFzay1sb29wLnRzPzc4NDIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHM/NDY1OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdHlwZXMvdHJhbnNtdXhlci50cz83YWQwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy9kaXNjb250aW51aXRpZXMudHM/ZGE1MiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY3J5cHQvYWVzLWNyeXB0by50cz80MGQyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jcnlwdC9mYXN0LWFlcy1rZXkudHM/MzFhNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY3J5cHQvYWVzLWRlY3J5cHRvci50cz9kMWMwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jcnlwdC9kZWNyeXB0ZXIudHM/ZDExOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvdGltZS1yYW5nZXMudHM/OTEzMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLnRzPzdkNzkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2lzLXN1cHBvcnRlZC50cz9iOTk5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9kdW1teS1kZW11eGVkLXRyYWNrLnRzP2IwNTAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L2Jhc2UtYXVkaW8tZGVtdXhlci50cz8wNjE2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9hZHRzLnRzPzkxZmIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L2FhY2RlbXV4ZXIudHM/MjU2ZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvbXA0ZGVtdXhlci50cz80ZTJkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9tcGVnYXVkaW8udHM/ZTQzYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvZXhwLWdvbG9tYi50cz9kZjJjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9zYW1wbGUtYWVzLnRzP2UwYjkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L3RzZGVtdXhlci50cz9kZDNmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9tcDNkZW11eGVyLnRzPzFiZjMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3JlbXV4L2FhYy1oZWxwZXIudHM/N2YyNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcmVtdXgvbXA0LWdlbmVyYXRvci50cz8yZTY5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbi50cz9jNjI3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZW11eC9tcDQtcmVtdXhlci50cz8yM2U4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyLnRzPzMxNDIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L3RyYW5zbXV4ZXIudHM/MjE5YyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcz80YmFjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC90cmFuc211eGVyLXdvcmtlci50cz83ZGYyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9pbmplY3Qtd29ya2VyLnRzP2I5NjIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlLnRzPzcwYjciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvZ2FwLWNvbnRyb2xsZXIudHM/ODBlYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlci50cz8xNjZjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy9ld21hLnRzP2ZiYzgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvci50cz82YTBmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2Fici1jb250cm9sbGVyLnRzPzIyZDkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZS50cz9hMzkwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyLnRzPzIwNWEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXIudHM/NWM3MyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9mcHMtY29udHJvbGxlci50cz9lNDBjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy94aHItbG9hZGVyLnRzPzIzOTQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzPzFjYzgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL2ZldGNoLWxvYWRlci50cz84Y2YyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb25maWcudHM/ZWE3NiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaGxzLnRzPzIwZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxODA4XG5cbihmdW5jdGlvbiAocm9vdCkge1xuICB2YXIgVVJMX1JFR0VYID1cbiAgICAvXig/PSgoPzpbYS16QS1aMC05K1xcLS5dKzopPykpXFwxKD89KCg/OlxcL1xcL1teXFwvPyNdKik/KSlcXDIoPz0oKD86KD86W14/I1xcL10qXFwvKSpbXjs/I1xcL10qKT8pKVxcMygoPzo7W14/I10qKT8pKFxcP1teI10qKT8oI1teXSopPyQvO1xuICB2YXIgRklSU1RfU0VHTUVOVF9SRUdFWCA9IC9eKD89KFteXFwvPyNdKikpXFwxKFteXSopJC87XG4gIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuICB2YXIgU0xBU0hfRE9UX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC5cXC5cXC8oPyFcXC5cXC5cXC8pW15cXC9dKig/PVxcLykvZztcblxuICB2YXIgVVJMVG9vbGtpdCA9IHtcbiAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuICAgIC8vIEUuZ1xuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSBmYWxzZSAoZGVmYXVsdCwgc3BlYyBjb21wbGlhbnQpXG4gICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IHRydWUgKG5vdCBzcGVjIGNvbXBsaWFudClcbiAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9nXG4gICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24gKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XG4gICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgIC8vIHJlbW92ZSBhbnkgcmVtYWluaW5nIHNwYWNlIGFuZCBDUkxGXG4gICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XG4gICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMLnRyaW0oKTtcbiAgICAgIGlmICghcmVsYXRpdmVVUkwpIHtcbiAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxuICAgICAgICAvLyBlbnRpcmUgYmFzZSBVUkwgKGkuZS4sIGlzIHNldCBlcXVhbCB0byB0aGUgYmFzZSBVUkwpXG4gICAgICAgIC8vIGFuZCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlVVJMO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuICAgICAgICBpZiAoIWJhc2VQYXJ0c0Zvck5vcm1hbGlzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICAgICAgICB9XG4gICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKFxuICAgICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVsYXRpdmVQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwocmVsYXRpdmVVUkwpO1xuICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIHJlbGF0aXZlIFVSTC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnNjaGVtZSkge1xuICAgICAgICAvLyAyYikgSWYgdGhlIGVtYmVkZGVkIFVSTCBzdGFydHMgd2l0aCBhIHNjaGVtZSBuYW1lLCBpdCBpc1xuICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBhbiBhYnNvbHV0ZSBVUkwgYW5kIHdlIGFyZSBkb25lLlxuICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbGF0aXZlVVJMO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF0aXZlUGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpO1xuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhyZWxhdGl2ZVBhcnRzKTtcbiAgICAgIH1cbiAgICAgIHZhciBiYXNlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuICAgICAgaWYgKCFiYXNlUGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJhc2VQYXJ0cy5uZXRMb2MgJiYgYmFzZVBhcnRzLnBhdGggJiYgYmFzZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICAvLyBJZiBuZXRMb2MgbWlzc2luZyBhbmQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggJy8nLCBhc3N1bWUgZXZlcnRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgJy8nIGlzIHRoZSBuZXRMb2NcbiAgICAgICAgLy8gVGhpcyBjYXVzZXMgJ2V4YW1wbGUuY29tL2EnIHRvIGJlIGhhbmRsZWQgYXMgJy8vZXhhbXBsZS5jb20vYScgaW5zdGVhZCBvZiAnL2V4YW1wbGUuY29tL2EnXG4gICAgICAgIHZhciBwYXRoUGFydHMgPSBGSVJTVF9TRUdNRU5UX1JFR0VYLmV4ZWMoYmFzZVBhcnRzLnBhdGgpO1xuICAgICAgICBiYXNlUGFydHMubmV0TG9jID0gcGF0aFBhcnRzWzFdO1xuICAgICAgICBiYXNlUGFydHMucGF0aCA9IHBhdGhQYXJ0c1syXTtcbiAgICAgIH1cbiAgICAgIGlmIChiYXNlUGFydHMubmV0TG9jICYmICFiYXNlUGFydHMucGF0aCkge1xuICAgICAgICBiYXNlUGFydHMucGF0aCA9ICcvJztcbiAgICAgIH1cbiAgICAgIHZhciBidWlsdFBhcnRzID0ge1xuICAgICAgICAvLyAyYykgT3RoZXJ3aXNlLCB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSBzY2hlbWUgb2ZcbiAgICAgICAgLy8gdGhlIGJhc2UgVVJMLlxuICAgICAgICBzY2hlbWU6IGJhc2VQYXJ0cy5zY2hlbWUsXG4gICAgICAgIG5ldExvYzogcmVsYXRpdmVQYXJ0cy5uZXRMb2MsXG4gICAgICAgIHBhdGg6IG51bGwsXG4gICAgICAgIHBhcmFtczogcmVsYXRpdmVQYXJ0cy5wYXJhbXMsXG4gICAgICAgIHF1ZXJ5OiByZWxhdGl2ZVBhcnRzLnF1ZXJ5LFxuICAgICAgICBmcmFnbWVudDogcmVsYXRpdmVQYXJ0cy5mcmFnbWVudCxcbiAgICAgIH07XG4gICAgICBpZiAoIXJlbGF0aXZlUGFydHMubmV0TG9jKSB7XG4gICAgICAgIC8vIDMpIElmIHRoZSBlbWJlZGRlZCBVUkwncyA8bmV0X2xvYz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG4gICAgICAgIC8vIChpZiBhbnkpIG9mIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgYnVpbHRQYXJ0cy5uZXRMb2MgPSBiYXNlUGFydHMubmV0TG9jO1xuICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG4gICAgICAgIC8vIHBhdGggaXMgbm90IHJlbGF0aXZlIGFuZCB3ZSBza2lwIHRvIFN0ZXAgNy5cbiAgICAgICAgaWYgKHJlbGF0aXZlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgICAgIC8vIDUpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBlbXB0eSAoYW5kIG5vdCBwcmVjZWRlZCBieSBhXG4gICAgICAgICAgICAvLyBzbGFzaCksIHRoZW4gdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgYmFzZSBVUkwgcGF0aFxuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG4gICAgICAgICAgICAvLyA1YSkgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxwYXJhbXM+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cGFyYW1zPiBvZiB0aGUgYmFzZVxuICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhcmFtcykge1xuICAgICAgICAgICAgICBidWlsdFBhcnRzLnBhcmFtcyA9IGJhc2VQYXJ0cy5wYXJhbXM7XG4gICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cXVlcnk+IG9mIHRoZSBiYXNlXG4gICAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmQgd2Ugc2tpcCB0byBzdGVwIDcuXG4gICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuICAgICAgICAgICAgICAgIGJ1aWx0UGFydHMucXVlcnkgPSBiYXNlUGFydHMucXVlcnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gNikgVGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgYmFzZSBVUkwncyBwYXRoIChhbnl0aGluZ1xuICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuICAgICAgICAgICAgLy8gc2xhc2ggaXMgcHJlc2VudCkgaXMgcmVtb3ZlZCBhbmQgdGhlIGVtYmVkZGVkIFVSTCdzIHBhdGggaXNcbiAgICAgICAgICAgIC8vIGFwcGVuZGVkIGluIGl0cyBwbGFjZS5cbiAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgdmFyIG5ld1BhdGggPVxuICAgICAgICAgICAgICBiYXNlVVJMUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVVSTFBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICtcbiAgICAgICAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJ1aWx0UGFydHMucGF0aCA9PT0gbnVsbCkge1xuICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZVxuICAgICAgICAgID8gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aClcbiAgICAgICAgICA6IHJlbGF0aXZlUGFydHMucGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJ1aWx0UGFydHMpO1xuICAgIH0sXG4gICAgcGFyc2VVUkw6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFVSTF9SRUdFWC5leGVjKHVybCk7XG4gICAgICBpZiAoIXBhcnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1lOiBwYXJ0c1sxXSB8fCAnJyxcbiAgICAgICAgbmV0TG9jOiBwYXJ0c1syXSB8fCAnJyxcbiAgICAgICAgcGF0aDogcGFydHNbM10gfHwgJycsXG4gICAgICAgIHBhcmFtczogcGFydHNbNF0gfHwgJycsXG4gICAgICAgIHF1ZXJ5OiBwYXJ0c1s1XSB8fCAnJyxcbiAgICAgICAgZnJhZ21lbnQ6IHBhcnRzWzZdIHx8ICcnLFxuICAgICAgfTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZVBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXG4gICAgICAvLyB0aGVuIGFwcGxpZWQsIGluIG9yZGVyLCB0byB0aGUgbmV3IHBhdGg6XG4gICAgICAvLyA2YSkgQWxsIG9jY3VycmVuY2VzIG9mIFwiLi9cIiwgd2hlcmUgXCIuXCIgaXMgYSBjb21wbGV0ZSBwYXRoXG4gICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cbiAgICAgIC8vIDZiKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCIuXCIgYXMgYSBjb21wbGV0ZSBwYXRoIHNlZ21lbnQsXG4gICAgICAvLyB0aGF0IFwiLlwiIGlzIHJlbW92ZWQuXG4gICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XG4gICAgICAvLyA2YykgQWxsIG9jY3VycmVuY2VzIG9mIFwiPHNlZ21lbnQ+Ly4uL1wiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIGFyZSByZW1vdmVkLlxuICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcbiAgICAgIC8vIHJlbW92aW5nIHRoZSBsZWZ0bW9zdCBtYXRjaGluZyBwYXR0ZXJuIG9uIGVhY2ggaXRlcmF0aW9uLFxuICAgICAgLy8gdW50aWwgbm8gbWF0Y2hpbmcgcGF0dGVybiByZW1haW5zLlxuICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIHRoYXRcbiAgICAgIC8vIFwiPHNlZ21lbnQ+Ly4uXCIgaXMgcmVtb3ZlZC5cbiAgICAgIHdoaWxlIChcbiAgICAgICAgcGF0aC5sZW5ndGggIT09IChwYXRoID0gcGF0aC5yZXBsYWNlKFNMQVNIX0RPVF9ET1RfUkVHRVgsICcnKSkubGVuZ3RoXG4gICAgICApIHt9XG4gICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgYnVpbGRVUkxGcm9tUGFydHM6IGZ1bmN0aW9uIChwYXJ0cykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcGFydHMuc2NoZW1lICtcbiAgICAgICAgcGFydHMubmV0TG9jICtcbiAgICAgICAgcGFydHMucGF0aCArXG4gICAgICAgIHBhcnRzLnBhcmFtcyArXG4gICAgICAgIHBhcnRzLnF1ZXJ5ICtcbiAgICAgICAgcGFydHMuZnJhZ21lbnRcbiAgICAgICk7XG4gICAgfSxcbiAgfTtcblxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuICAgIG1vZHVsZS5leHBvcnRzID0gVVJMVG9vbGtpdDtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFVSTFRvb2xraXQ7XG4gICAgfSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JykgZXhwb3J0c1snVVJMVG9vbGtpdCddID0gVVJMVG9vbGtpdDtcbiAgZWxzZSByb290WydVUkxUb29sa2l0J10gPSBVUkxUb29sa2l0O1xufSkodGhpcyk7XG4iLCJleHBvcnQgY29uc3QgaXNGaW5pdGVOdW1iZXIgPVxuICBOdW1iZXIuaXNGaW5pdGUgfHxcbiAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpO1xuICB9O1xuXG5leHBvcnQgY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG4iLCJpbXBvcnQge1xuICBNYW5pZmVzdExvYWRlZERhdGEsXG4gIE1hbmlmZXN0TG9hZGluZ0RhdGEsXG4gIE1lZGlhQXR0YWNoZWREYXRhLFxuICBNZWRpYUF0dGFjaGluZ0RhdGEsXG4gIExldmVsTG9hZGluZ0RhdGEsXG4gIExldmVsTG9hZGVkRGF0YSxcbiAgTWFuaWZlc3RQYXJzZWREYXRhLFxuICBMZXZlbFVwZGF0ZWREYXRhLFxuICBMZXZlbHNVcGRhdGVkRGF0YSxcbiAgRnJhZ1BhcnNpbmdVc2VyZGF0YURhdGEsXG4gIEZyYWdEZWNyeXB0ZWREYXRhLFxuICBGcmFnTG9hZGVkRGF0YSxcbiAgSW5pdFBUU0ZvdW5kRGF0YSxcbiAgQ3Vlc1BhcnNlZERhdGEsXG4gIFN1YnRpdGxlRnJhZ1Byb2Nlc3NlZERhdGEsXG4gIE5vbk5hdGl2ZVRleHRUcmFja3NEYXRhLFxuICBGcmFnTG9hZGluZ0RhdGEsXG4gIEF1ZGlvVHJhY2tMb2FkZWREYXRhLFxuICBTdWJ0aXRsZVRyYWNrTG9hZGVkRGF0YSxcbiAgRXJyb3JEYXRhLFxuICBBdWRpb1RyYWNrU3dpdGNoaW5nRGF0YSxcbiAgQXVkaW9UcmFja1N3aXRjaGVkRGF0YSxcbiAgS2V5TG9hZGVkRGF0YSxcbiAgS2V5TG9hZGluZ0RhdGEsXG4gIFN1YnRpdGxlVHJhY2tTd2l0Y2hEYXRhLFxuICBTdWJ0aXRsZVRyYWNrc1VwZGF0ZWREYXRhLFxuICBMZXZlbFN3aXRjaGVkRGF0YSxcbiAgRnJhZ0NoYW5nZWREYXRhLFxuICBCdWZmZXJBcHBlbmRpbmdEYXRhLFxuICBCdWZmZXJDb2RlY3NEYXRhLFxuICBGcmFnUGFyc2luZ01ldGFkYXRhRGF0YSxcbiAgRnJhZ1BhcnNpbmdJbml0U2VnbWVudERhdGEsXG4gIEZyYWdCdWZmZXJlZERhdGEsXG4gIEJ1ZmZlckZsdXNoaW5nRGF0YSxcbiAgQnVmZmVyRU9TRGF0YSxcbiAgTGV2ZWxTd2l0Y2hpbmdEYXRhLFxuICBGUFNEcm9wTGV2ZWxDYXBwaW5nRGF0YSxcbiAgRlBTRHJvcERhdGEsXG4gIEJ1ZmZlckNyZWF0ZWREYXRhLFxuICBCdWZmZXJBcHBlbmRlZERhdGEsXG4gIExldmVsUFRTVXBkYXRlZERhdGEsXG4gIEZyYWdQYXJzZWREYXRhLFxuICBBdWRpb1RyYWNrc1VwZGF0ZWREYXRhLFxuICBGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWREYXRhLFxuICBCYWNrQnVmZmVyRGF0YSxcbiAgTGl2ZUJhY2tCdWZmZXJEYXRhLFxuICBUcmFja0xvYWRpbmdEYXRhLFxuICBCdWZmZXJGbHVzaGVkRGF0YSxcbn0gZnJvbSAnLi90eXBlcy9ldmVudHMnO1xuXG5leHBvcnQgZW51bSBFdmVudHMge1xuICAvLyBGaXJlZCBiZWZvcmUgTWVkaWFTb3VyY2UgaXMgYXR0YWNoaW5nIHRvIG1lZGlhIGVsZW1lbnRcbiAgTUVESUFfQVRUQUNISU5HID0gJ2hsc01lZGlhQXR0YWNoaW5nJyxcbiAgLy8gRmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgYXR0YWNoZWQgdG8gbWVkaWEgZWxlbWVudFxuICBNRURJQV9BVFRBQ0hFRCA9ICdobHNNZWRpYUF0dGFjaGVkJyxcbiAgLy8gRmlyZWQgYmVmb3JlIGRldGFjaGluZyBNZWRpYVNvdXJjZSBmcm9tIG1lZGlhIGVsZW1lbnRcbiAgTUVESUFfREVUQUNISU5HID0gJ2hsc01lZGlhRGV0YWNoaW5nJyxcbiAgLy8gRmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIG1lZGlhIGVsZW1lbnRcbiAgTUVESUFfREVUQUNIRUQgPSAnaGxzTWVkaWFEZXRhY2hlZCcsXG4gIC8vIEZpcmVkIHdoZW4gdGhlIGJ1ZmZlciBpcyBnb2luZyB0byBiZSByZXNldFxuICBCVUZGRVJfUkVTRVQgPSAnaGxzQnVmZmVyUmVzZXQnLFxuICAvLyBGaXJlZCB3aGVuIHdlIGtub3cgYWJvdXQgdGhlIGNvZGVjcyB0aGF0IHdlIG5lZWQgYnVmZmVycyBmb3IgdG8gcHVzaCBpbnRvIC0gZGF0YToge3RyYWNrcyA6IHsgY29udGFpbmVyLCBjb2RlYywgbGV2ZWxDb2RlYywgaW5pdFNlZ21lbnQsIG1ldGFkYXRhIH19XG4gIEJVRkZFUl9DT0RFQ1MgPSAnaGxzQnVmZmVyQ29kZWNzJyxcbiAgLy8gZmlyZWQgd2hlbiBzb3VyY2VidWZmZXJzIGhhdmUgYmVlbiBjcmVhdGVkIC0gZGF0YTogeyB0cmFja3MgOiB0cmFja3MgfVxuICBCVUZGRVJfQ1JFQVRFRCA9ICdobHNCdWZmZXJDcmVhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBhcHBlbmQgYSBzZWdtZW50IHRvIHRoZSBidWZmZXIgLSBkYXRhOiB7IHNlZ21lbnQ6IHNlZ21lbnQgb2JqZWN0IH1cbiAgQlVGRkVSX0FQUEVORElORyA9ICdobHNCdWZmZXJBcHBlbmRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGFyZSBkb25lIHdpdGggYXBwZW5kaW5nIGEgbWVkaWEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YSA6IHsgcGFyZW50IDogc2VnbWVudCBwYXJlbnQgdGhhdCB0cmlnZ2VyZWQgQlVGRkVSX0FQUEVORElORywgcGVuZGluZyA6IG5iIG9mIHNlZ21lbnRzIHdhaXRpbmcgZm9yIGFwcGVuZGluZyBmb3IgdGhpcyBzZWdtZW50IHBhcmVudH1cbiAgQlVGRkVSX0FQUEVOREVEID0gJ2hsc0J1ZmZlckFwcGVuZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIGFuZCB3ZSB3YW50IHRvIG5vdGlmeSB0aGUgbWVkaWEgYnVmZmVyIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBtb3JlIGRhdGEgLSBkYXRhOiB7IH1cbiAgQlVGRkVSX0VPUyA9ICdobHNCdWZmZXJFb3MnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgc2hvdWxkIGJlIGZsdXNoZWQgLSBkYXRhIHsgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCB9XG4gIEJVRkZFUl9GTFVTSElORyA9ICdobHNCdWZmZXJGbHVzaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGJ1ZmZlciBoYXMgYmVlbiBmbHVzaGVkIC0gZGF0YTogeyB9XG4gIEJVRkZFUl9GTFVTSEVEID0gJ2hsc0J1ZmZlckZsdXNoZWQnLFxuICAvLyBmaXJlZCB0byBzaWduYWwgdGhhdCBhIG1hbmlmZXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBtYW5pZmVzdFVSTH1cbiAgTUFOSUZFU1RfTE9BRElORyA9ICdobHNNYW5pZmVzdExvYWRpbmcnLFxuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdLCBhdWRpb1RyYWNrcyA6IFsgYXZhaWxhYmxlIGF1ZGlvIHRyYWNrcyBdLCB1cmwgOiBtYW5pZmVzdFVSTCwgc3RhdHMgOiBMb2FkZXJTdGF0cyB9XG4gIE1BTklGRVNUX0xPQURFRCA9ICdobHNNYW5pZmVzdExvYWRlZCcsXG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIHBhcnNlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGZpcnN0TGV2ZWwgOiBpbmRleCBvZiBmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiBNYW5pZmVzdH1cbiAgTUFOSUZFU1RfUEFSU0VEID0gJ2hsc01hbmlmZXN0UGFyc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgTEVWRUxfU1dJVENISU5HID0gJ2hsc0xldmVsU3dpdGNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyBlZmZlY3RpdmUgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgTEVWRUxfU1dJVENIRUQgPSAnaGxzTGV2ZWxTd2l0Y2hlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbGV2ZWwgVVJMLCBsZXZlbCA6IGlkIG9mIGxldmVsIGJlaW5nIGxvYWRlZH1cbiAgTEVWRUxfTE9BRElORyA9ICdobHNMZXZlbExvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgbG9hZGVkIGxldmVsLCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgTEVWRUxfTE9BREVEID0gJ2hsc0xldmVsTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsJ3MgZGV0YWlscyBoYXZlIGJlZW4gdXBkYXRlZCBiYXNlZCBvbiBwcmV2aW91cyBkZXRhaWxzLCBhZnRlciBpdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwgfVxuICBMRVZFTF9VUERBVEVEID0gJ2hsc0xldmVsVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIFBUUyBpbmZvcm1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFmdGVyIHBhcnNpbmcgYSBmcmFnbWVudCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCwgZHJpZnQ6IFBUUyBkcmlmdCBvYnNlcnZlZCB3aGVuIHBhcnNpbmcgbGFzdCBmcmFnbWVudCB9XG4gIExFVkVMX1BUU19VUERBVEVEID0gJ2hsc0xldmVsUHRzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IGxldmVscyBoYXZlIGNoYW5nZWQgYWZ0ZXIgcmVtb3ZpbmcgYSBsZXZlbCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10gfVxuICBMRVZFTFNfVVBEQVRFRCA9ICdobHNMZXZlbHNVcGRhdGVkJyxcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgYXVkaW8gdHJhY2sgbGlzdHMgaGFzIGJlZW4gdXBkYXRlZCAtIGRhdGE6IHsgYXVkaW9UcmFja3MgOiBhdWRpb1RyYWNrcyB9XG4gIEFVRElPX1RSQUNLU19VUERBVEVEID0gJ2hsc0F1ZGlvVHJhY2tzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoaW5nIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgaWQgOiBhdWRpbyB0cmFjayBpZCB9XG4gIEFVRElPX1RSQUNLX1NXSVRDSElORyA9ICdobHNBdWRpb1RyYWNrU3dpdGNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2ggYWN0dWFsbHkgb2NjdXJzIC0gZGF0YTogeyBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cbiAgQVVESU9fVFJBQ0tfU1dJVENIRUQgPSAnaGxzQXVkaW9UcmFja1N3aXRjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogYXVkaW8gdHJhY2sgVVJMLCBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cbiAgQVVESU9fVFJBQ0tfTE9BRElORyA9ICdobHNBdWRpb1RyYWNrTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogYXVkaW8gdHJhY2sgaWQsIHN0YXRzIDogTG9hZGVyU3RhdHMgfVxuICBBVURJT19UUkFDS19MT0FERUQgPSAnaGxzQXVkaW9UcmFja0xvYWRlZCcsXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IHN1YnRpdGxlIHRyYWNrIGxpc3RzIGhhcyBiZWVuIHVwZGF0ZWQgLSBkYXRhOiB7IHN1YnRpdGxlVHJhY2tzIDogc3VidGl0bGVUcmFja3MgfVxuICBTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCA9ICdobHNTdWJ0aXRsZVRyYWNrc1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBzdWJ0aXRsZSB0cmFja3Mgd2VyZSBjbGVhcmVkIGFzIGEgcmVzdWx0IG9mIHN0b3BwaW5nIHRoZSBtZWRpYVxuICBTVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRCA9ICdobHNTdWJ0aXRsZVRyYWNrc0NsZWFyZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIHN1YnRpdGxlIHRyYWNrIHN3aXRjaCBvY2N1cnMgLSBkYXRhOiB7IGlkIDogc3VidGl0bGUgdHJhY2sgaWQgfVxuICBTVUJUSVRMRV9UUkFDS19TV0lUQ0ggPSAnaGxzU3VidGl0bGVUcmFja1N3aXRjaCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSB0cmFjayBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogc3VidGl0bGUgdHJhY2sgVVJMLCBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkIH1cbiAgU1VCVElUTEVfVFJBQ0tfTE9BRElORyA9ICdobHNTdWJ0aXRsZVRyYWNrTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSB0cmFjayBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCwgc3RhdHMgOiBMb2FkZXJTdGF0cyB9XG4gIFNVQlRJVExFX1RSQUNLX0xPQURFRCA9ICdobHNTdWJ0aXRsZVRyYWNrTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIGZyYWdtZW50IGhhcyBiZWVuIHByb2Nlc3NlZCAtIGRhdGE6IHsgc3VjY2VzcyA6IGJvb2xlYW4sIGZyYWcgOiB0aGUgcHJvY2Vzc2VkIGZyYWcgfVxuICBTVUJUSVRMRV9GUkFHX1BST0NFU1NFRCA9ICdobHNTdWJ0aXRsZUZyYWdQcm9jZXNzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgc2V0IG9mIFZUVEN1ZXMgdG8gYmUgbWFuYWdlZCBleHRlcm5hbGx5IGhhcyBiZWVuIHBhcnNlZCAtIGRhdGE6IHsgdHlwZTogc3RyaW5nLCB0cmFjazogc3RyaW5nLCBjdWVzOiBbIFZUVEN1ZSBdIH1cbiAgQ1VFU19QQVJTRUQgPSAnaGxzQ3Vlc1BhcnNlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSB0ZXh0IHRyYWNrIHRvIGJlIG1hbmFnZWQgZXh0ZXJuYWxseSBpcyBmb3VuZCAtIGRhdGE6IHsgdHJhY2tzOiBbIHsgbGFiZWw6IHN0cmluZywga2luZDogc3RyaW5nLCBkZWZhdWx0OiBib29sZWFuIH0gXSB9XG4gIE5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQgPSAnaGxzTm9uTmF0aXZlVGV4dFRyYWNrc0ZvdW5kJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgZmlyc3QgdGltZXN0YW1wIGlzIGZvdW5kIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGluaXRQVFM6IGluaXRQVFMsIHRpbWVzY2FsZTogdGltZXNjYWxlLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgSU5JVF9QVFNfRk9VTkQgPSAnaGxzSW5pdFB0c0ZvdW5kJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRlJBR19MT0FESU5HID0gJ2hsc0ZyYWdMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgcHJvZ3Jlc3NpbmcgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHsgdHJlcXVlc3QsIHRmaXJzdCwgbG9hZGVkIH0gfVxuICAvLyBGUkFHX0xPQURfUFJPR1JFU1MgPSAnaGxzRnJhZ0xvYWRQcm9ncmVzcycsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgYWJvcnRpbmcgZm9yIGVtZXJnZW5jeSBzd2l0Y2ggZG93biAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCA9ICdobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBmcmFnbWVudCBwYXlsb2FkLCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgRlJBR19MT0FERUQgPSAnaGxzRnJhZ0xvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBoYXMgZmluaXNoZWQgZGVjcnlwdGluZyAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBmcmFnbWVudCBwYXlsb2FkLCBzdGF0cyA6IHsgdHN0YXJ0LCB0ZGVjcnlwdCB9IH1cbiAgRlJBR19ERUNSWVBURUQgPSAnaGxzRnJhZ0RlY3J5cHRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gSW5pdCBTZWdtZW50IGhhcyBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgbW9vdiA6IG1vb3YgTVA0IGJveCwgY29kZWNzIDogY29kZWNzIGZvdW5kIHdoaWxlIHBhcnNpbmcgZnJhZ21lbnQgfVxuICBGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UID0gJ2hsc0ZyYWdQYXJzaW5nSW5pdFNlZ21lbnQnLFxuICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgc2VpIHRleHQgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgc2FtcGxlcyA6IFsgc2VpIHNhbXBsZXMgcGVzIF0gfVxuICBGUkFHX1BBUlNJTkdfVVNFUkRBVEEgPSAnaGxzRnJhZ1BhcnNpbmdVc2VyZGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBpZDMgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgc2FtcGxlcyA6IFsgaWQzIHNhbXBsZXMgcGVzIF0gfVxuICBGUkFHX1BBUlNJTkdfTUVUQURBVEEgPSAnaGxzRnJhZ1BhcnNpbmdNZXRhZGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gZGF0YSBoYXZlIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBkYXRhMSA6IG1vb2YgTVA0IGJveCBvciBUUyBmcmFnbWVudHMsIGRhdGEyIDogbWRhdCBNUDQgYm94IG9yIG51bGx9XG4gIC8vIEZSQUdfUEFSU0lOR19EQVRBID0gJ2hsc0ZyYWdQYXJzaW5nRGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgcGFyc2luZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRlJBR19QQVJTRUQgPSAnaGxzRnJhZ1BhcnNlZCcsXG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgcmVtdXhlZCBNUDQgYm94ZXMgaGF2ZSBhbGwgYmVlbiBhcHBlbmRlZCBpbnRvIFNvdXJjZUJ1ZmZlciAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgRlJBR19CVUZGRVJFRCA9ICdobHNGcmFnQnVmZmVyZWQnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IG1hdGNoaW5nIHdpdGggY3VycmVudCBtZWRpYSBwb3NpdGlvbiBpcyBjaGFuZ2luZyAtIGRhdGEgOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfQ0hBTkdFRCA9ICdobHNGcmFnQ2hhbmdlZCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgRlBTIGRyb3AgZXZlbnQgLSBkYXRhOiB7IGN1cnJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZCwgdG90YWxEcm9wcGVkRnJhbWVzIH1cbiAgRlBTX0RST1AgPSAnaGxzRnBzRHJvcCcsXG4gIC8vIHRyaWdnZXJlZCB3aGVuIEZQUyBkcm9wIHRyaWdnZXJzIGF1dG8gbGV2ZWwgY2FwcGluZyAtIGRhdGE6IHsgbGV2ZWwsIGRyb3BwZWRMZXZlbCB9XG4gIEZQU19EUk9QX0xFVkVMX0NBUFBJTkcgPSAnaGxzRnBzRHJvcExldmVsQ2FwcGluZycsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGVycm9yIGV2ZW50IC0gZGF0YTogeyB0eXBlIDogZXJyb3IgdHlwZSwgZGV0YWlscyA6IGVycm9yIGRldGFpbHMsIGZhdGFsIDogaWYgdHJ1ZSwgaGxzLmpzIGNhbm5vdC93aWxsIG5vdCB0cnkgdG8gcmVjb3ZlciwgaWYgZmFsc2UsIGhscy5qcyB3aWxsIHRyeSB0byByZWNvdmVyLG90aGVyIGVycm9yIHNwZWNpZmljIGRhdGEgfVxuICBFUlJPUiA9ICdobHNFcnJvcicsXG4gIC8vIGZpcmVkIHdoZW4gaGxzLmpzIGluc3RhbmNlIHN0YXJ0cyBkZXN0cm95aW5nLiBEaWZmZXJlbnQgZnJvbSBNRURJQV9ERVRBQ0hFRCBhcyBvbmUgY291bGQgd2FudCB0byBkZXRhY2ggYW5kIHJlYXR0YWNoIGEgbWVkaWEgdG8gdGhlIGluc3RhbmNlIG9mIGhscy5qcyB0byBoYW5kbGUgbWlkLXJvbGxzIGZvciBleGFtcGxlIC0gZGF0YTogeyB9XG4gIERFU1RST1lJTkcgPSAnaGxzRGVzdHJveWluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEtFWV9MT0FESU5HID0gJ2hsc0tleUxvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIGtleUluZm8gOiBLZXlMb2FkZXJJbmZvIH1cbiAgS0VZX0xPQURFRCA9ICdobHNLZXlMb2FkZWQnLFxuICAvLyBkZXByZWNhdGVkOyBwbGVhc2UgdXNlIEJBQ0tfQlVGRkVSX1JFQUNIRUQgLSBkYXRhIDogeyBidWZmZXJFbmQ6IG51bWJlciB9XG4gIExJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRCA9ICdobHNMaXZlQmFja0J1ZmZlclJlYWNoZWQnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBiYWNrIGJ1ZmZlciBpcyByZWFjaGVkIGFzIGRlZmluZWQgYnkgdGhlIGJhY2tCdWZmZXJMZW5ndGggY29uZmlnIG9wdGlvbiAtIGRhdGEgOiB7IGJ1ZmZlckVuZDogbnVtYmVyIH1cbiAgQkFDS19CVUZGRVJfUkVBQ0hFRCA9ICdobHNCYWNrQnVmZmVyUmVhY2hlZCcsXG59XG5cbi8qKlxuICogRGVmaW5lcyBlYWNoIEV2ZW50IHR5cGUgYW5kIHBheWxvYWQgYnkgRXZlbnQgbmFtZS4gVXNlZCBpbiB7QGxpbmsgaGxzLmpzI0hsc0V2ZW50RW1pdHRlcn0gdG8gc3Ryb25nbHkgdHlwZSB0aGUgZXZlbnQgbGlzdGVuZXIgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhsc0xpc3RlbmVycyB7XG4gIFtFdmVudHMuTUVESUFfQVRUQUNISU5HXTogKFxuICAgIGV2ZW50OiBFdmVudHMuTUVESUFfQVRUQUNISU5HLFxuICAgIGRhdGE6IE1lZGlhQXR0YWNoaW5nRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTUVESUFfQVRUQUNIRURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5NRURJQV9BVFRBQ0hFRCxcbiAgICBkYXRhOiBNZWRpYUF0dGFjaGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTUVESUFfREVUQUNISU5HXTogKGV2ZW50OiBFdmVudHMuTUVESUFfREVUQUNISU5HKSA9PiB2b2lkO1xuICBbRXZlbnRzLk1FRElBX0RFVEFDSEVEXTogKGV2ZW50OiBFdmVudHMuTUVESUFfREVUQUNIRUQpID0+IHZvaWQ7XG4gIFtFdmVudHMuQlVGRkVSX1JFU0VUXTogKGV2ZW50OiBFdmVudHMuQlVGRkVSX1JFU0VUKSA9PiB2b2lkO1xuICBbRXZlbnRzLkJVRkZFUl9DT0RFQ1NdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfQ09ERUNTLFxuICAgIGRhdGE6IEJ1ZmZlckNvZGVjc0RhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkJVRkZFUl9DUkVBVEVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0NSRUFURUQsXG4gICAgZGF0YTogQnVmZmVyQ3JlYXRlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLFxuICAgIGRhdGE6IEJ1ZmZlckFwcGVuZGluZ0RhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkJVRkZFUl9BUFBFTkRFRF06IChcbiAgICBldmVudDogRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCxcbiAgICBkYXRhOiBCdWZmZXJBcHBlbmRlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkJVRkZFUl9FT1NdOiAoZXZlbnQ6IEV2ZW50cy5CVUZGRVJfRU9TLCBkYXRhOiBCdWZmZXJFT1NEYXRhKSA9PiB2b2lkO1xuICBbRXZlbnRzLkJVRkZFUl9GTFVTSElOR106IChcbiAgICBldmVudDogRXZlbnRzLkJVRkZFUl9GTFVTSElORyxcbiAgICBkYXRhOiBCdWZmZXJGbHVzaGluZ0RhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkJVRkZFUl9GTFVTSEVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0ZMVVNIRUQsXG4gICAgZGF0YTogQnVmZmVyRmx1c2hlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLk1BTklGRVNUX0xPQURJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLFxuICAgIGRhdGE6IE1hbmlmZXN0TG9hZGluZ0RhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLk1BTklGRVNUX0xPQURFRF06IChcbiAgICBldmVudDogRXZlbnRzLk1BTklGRVNUX0xPQURFRCxcbiAgICBkYXRhOiBNYW5pZmVzdExvYWRlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLk1BTklGRVNUX1BBUlNFRF06IChcbiAgICBldmVudDogRXZlbnRzLk1BTklGRVNUX1BBUlNFRCxcbiAgICBkYXRhOiBNYW5pZmVzdFBhcnNlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkxFVkVMX1NXSVRDSElOR106IChcbiAgICBldmVudDogRXZlbnRzLkxFVkVMX1NXSVRDSElORyxcbiAgICBkYXRhOiBMZXZlbFN3aXRjaGluZ0RhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkxFVkVMX1NXSVRDSEVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuTEVWRUxfU1dJVENIRUQsXG4gICAgZGF0YTogTGV2ZWxTd2l0Y2hlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkxFVkVMX0xPQURJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTF9MT0FESU5HLFxuICAgIGRhdGE6IExldmVsTG9hZGluZ0RhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkxFVkVMX0xPQURFRF06IChcbiAgICBldmVudDogRXZlbnRzLkxFVkVMX0xPQURFRCxcbiAgICBkYXRhOiBMZXZlbExvYWRlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkxFVkVMX1VQREFURURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTF9VUERBVEVELFxuICAgIGRhdGE6IExldmVsVXBkYXRlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkxFVkVMX1BUU19VUERBVEVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuTEVWRUxfUFRTX1VQREFURUQsXG4gICAgZGF0YTogTGV2ZWxQVFNVcGRhdGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTEVWRUxTX1VQREFURURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTFNfVVBEQVRFRCxcbiAgICBkYXRhOiBMZXZlbHNVcGRhdGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQVVESU9fVFJBQ0tTX1VQREFURURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5BVURJT19UUkFDS1NfVVBEQVRFRCxcbiAgICBkYXRhOiBBdWRpb1RyYWNrc1VwZGF0ZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsXG4gICAgZGF0YTogQXVkaW9UcmFja1N3aXRjaGluZ0RhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsXG4gICAgZGF0YTogQXVkaW9UcmFja1N3aXRjaGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElOR106IChcbiAgICBldmVudDogRXZlbnRzLkFVRElPX1RSQUNLX0xPQURJTkcsXG4gICAgZGF0YTogVHJhY2tMb2FkaW5nRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELFxuICAgIGRhdGE6IEF1ZGlvVHJhY2tMb2FkZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRF06IChcbiAgICBldmVudDogRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELFxuICAgIGRhdGE6IFN1YnRpdGxlVHJhY2tzVXBkYXRlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLlNVQlRJVExFX1RSQUNLU19DTEVBUkVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuU1VCVElUTEVfVFJBQ0tTX0NMRUFSRURcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSF06IChcbiAgICBldmVudDogRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCxcbiAgICBkYXRhOiBTdWJ0aXRsZVRyYWNrU3dpdGNoRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElOR106IChcbiAgICBldmVudDogRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsXG4gICAgZGF0YTogVHJhY2tMb2FkaW5nRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELFxuICAgIGRhdGE6IFN1YnRpdGxlVHJhY2tMb2FkZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRF06IChcbiAgICBldmVudDogRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELFxuICAgIGRhdGE6IFN1YnRpdGxlRnJhZ1Byb2Nlc3NlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkNVRVNfUEFSU0VEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQ1VFU19QQVJTRUQsXG4gICAgZGF0YTogQ3Vlc1BhcnNlZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkRdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5OT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5ELFxuICAgIGRhdGE6IE5vbk5hdGl2ZVRleHRUcmFja3NEYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5JTklUX1BUU19GT1VORF06IChcbiAgICBldmVudDogRXZlbnRzLklOSVRfUFRTX0ZPVU5ELFxuICAgIGRhdGE6IEluaXRQVFNGb3VuZERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkZSQUdfTE9BRElOR106IChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfTE9BRElORyxcbiAgICBkYXRhOiBGcmFnTG9hZGluZ0RhdGFcbiAgKSA9PiB2b2lkO1xuICAvLyBbRXZlbnRzLkZSQUdfTE9BRF9QUk9HUkVTU106IFRvZG9FdmVudFR5cGVcbiAgW0V2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsXG4gICAgZGF0YTogRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuRlJBR19MT0FERURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX0xPQURFRCxcbiAgICBkYXRhOiBGcmFnTG9hZGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuRlJBR19ERUNSWVBURURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCxcbiAgICBkYXRhOiBGcmFnRGVjcnlwdGVkRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVF06IChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsXG4gICAgZGF0YTogRnJhZ1BhcnNpbmdJbml0U2VnbWVudERhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQV06IChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSxcbiAgICBkYXRhOiBGcmFnUGFyc2luZ1VzZXJkYXRhRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuRlJBR19QQVJTSU5HX01FVEFEQVRBXTogKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19QQVJTSU5HX01FVEFEQVRBLFxuICAgIGRhdGE6IEZyYWdQYXJzaW5nTWV0YWRhdGFEYXRhXG4gICkgPT4gdm9pZDtcbiAgLy8gW0V2ZW50cy5GUkFHX1BBUlNJTkdfREFUQV06IFRvZG9FdmVudFR5cGVcbiAgW0V2ZW50cy5GUkFHX1BBUlNFRF06IChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfUEFSU0VELFxuICAgIGRhdGE6IEZyYWdQYXJzZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5GUkFHX0JVRkZFUkVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19CVUZGRVJFRCxcbiAgICBkYXRhOiBGcmFnQnVmZmVyZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5GUkFHX0NIQU5HRURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX0NIQU5HRUQsXG4gICAgZGF0YTogRnJhZ0NoYW5nZWREYXRhXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5GUFNfRFJPUF06IChldmVudDogRXZlbnRzLkZQU19EUk9QLCBkYXRhOiBGUFNEcm9wRGF0YSkgPT4gdm9pZDtcbiAgW0V2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HXTogKFxuICAgIGV2ZW50OiBFdmVudHMuRlBTX0RST1BfTEVWRUxfQ0FQUElORyxcbiAgICBkYXRhOiBGUFNEcm9wTGV2ZWxDYXBwaW5nRGF0YVxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuRVJST1JdOiAoZXZlbnQ6IEV2ZW50cy5FUlJPUiwgZGF0YTogRXJyb3JEYXRhKSA9PiB2b2lkO1xuICBbRXZlbnRzLkRFU1RST1lJTkddOiAoZXZlbnQ6IEV2ZW50cy5ERVNUUk9ZSU5HKSA9PiB2b2lkO1xuICBbRXZlbnRzLktFWV9MT0FESU5HXTogKFxuICAgIGV2ZW50OiBFdmVudHMuS0VZX0xPQURJTkcsXG4gICAgZGF0YTogS2V5TG9hZGluZ0RhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLktFWV9MT0FERURdOiAoZXZlbnQ6IEV2ZW50cy5LRVlfTE9BREVELCBkYXRhOiBLZXlMb2FkZWREYXRhKSA9PiB2b2lkO1xuICBbRXZlbnRzLkxJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRF06IChcbiAgICBldmVudDogRXZlbnRzLkxJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRCxcbiAgICBkYXRhOiBMaXZlQmFja0J1ZmZlckRhdGFcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkJBQ0tfQlVGRkVSX1JFQUNIRURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5CQUNLX0JVRkZFUl9SRUFDSEVELFxuICAgIGRhdGE6IEJhY2tCdWZmZXJEYXRhXG4gICkgPT4gdm9pZDtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSGxzRXZlbnRFbWl0dGVyIHtcbiAgb248RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycywgQ29udGV4dCA9IHVuZGVmaW5lZD4oXG4gICAgZXZlbnQ6IEUsXG4gICAgbGlzdGVuZXI6IEhsc0xpc3RlbmVyc1tFXSxcbiAgICBjb250ZXh0PzogQ29udGV4dFxuICApOiB2b2lkO1xuICBvbmNlPEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnMsIENvbnRleHQgPSB1bmRlZmluZWQ+KFxuICAgIGV2ZW50OiBFLFxuICAgIGxpc3RlbmVyOiBIbHNMaXN0ZW5lcnNbRV0sXG4gICAgY29udGV4dD86IENvbnRleHRcbiAgKTogdm9pZDtcblxuICByZW1vdmVBbGxMaXN0ZW5lcnM8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oZXZlbnQ/OiBFKTogdm9pZDtcbiAgb2ZmPEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnMsIENvbnRleHQgPSB1bmRlZmluZWQ+KFxuICAgIGV2ZW50OiBFLFxuICAgIGxpc3RlbmVyPzogSGxzTGlzdGVuZXJzW0VdLFxuICAgIGNvbnRleHQ/OiBDb250ZXh0LFxuICAgIG9uY2U/OiBib29sZWFuXG4gICk6IHZvaWQ7XG5cbiAgbGlzdGVuZXJzPEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnM+KGV2ZW50OiBFKTogSGxzTGlzdGVuZXJzW0VdW107XG4gIGVtaXQ8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oXG4gICAgZXZlbnQ6IEUsXG4gICAgbmFtZTogRSxcbiAgICBldmVudE9iamVjdDogUGFyYW1ldGVyczxIbHNMaXN0ZW5lcnNbRV0+WzFdXG4gICk6IGJvb2xlYW47XG4gIGxpc3RlbmVyQ291bnQ8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oZXZlbnQ6IEUpOiBudW1iZXI7XG59XG4iLCJleHBvcnQgZW51bSBFcnJvclR5cGVzIHtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBuZXR3b3JrIGVycm9yIChsb2FkaW5nIGVycm9yIC8gdGltZW91dCAuLi4pXG4gIE5FVFdPUktfRVJST1IgPSAnbmV0d29ya0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtZWRpYSBFcnJvciAodmlkZW8vcGFyc2luZy9tZWRpYXNvdXJjZSBlcnJvcilcbiAgTUVESUFfRVJST1IgPSAnbWVkaWFFcnJvcicsXG4gIC8vIEVNRSAoZW5jcnlwdGVkIG1lZGlhIGV4dGVuc2lvbnMpIGVycm9yc1xuICBLRVlfU1lTVEVNX0VSUk9SID0gJ2tleVN5c3RlbUVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtdXggRXJyb3IgKGRlbXV4aW5nL3JlbXV4aW5nKVxuICBNVVhfRVJST1IgPSAnbXV4RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbGwgb3RoZXIgZXJyb3JzXG4gIE9USEVSX0VSUk9SID0gJ290aGVyRXJyb3InLFxufVxuXG5leHBvcnQgZW51bSBFcnJvckRldGFpbHMge1xuICBLRVlfU1lTVEVNX05PX0tFWVMgPSAna2V5U3lzdGVtTm9LZXlzJyxcbiAgS0VZX1NZU1RFTV9OT19BQ0NFU1MgPSAna2V5U3lzdGVtTm9BY2Nlc3MnLFxuICBLRVlfU1lTVEVNX05PX1NFU1NJT04gPSAna2V5U3lzdGVtTm9TZXNzaW9uJyxcbiAgS0VZX1NZU1RFTV9OT19DT05GSUdVUkVEX0xJQ0VOU0UgPSAna2V5U3lzdGVtTm9Db25maWd1cmVkTGljZW5zZScsXG4gIEtFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCA9ICdrZXlTeXN0ZW1MaWNlbnNlUmVxdWVzdEZhaWxlZCcsXG4gIEtFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVEID0gJ2tleVN5c3RlbVNlcnZlckNlcnRpZmljYXRlUmVxdWVzdEZhaWxlZCcsXG4gIEtFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1VQREFURV9GQUlMRUQgPSAna2V5U3lzdGVtU2VydmVyQ2VydGlmaWNhdGVVcGRhdGVGYWlsZWQnLFxuICBLRVlfU1lTVEVNX1NFU1NJT05fVVBEQVRFX0ZBSUxFRCA9ICdrZXlTeXN0ZW1TZXNzaW9uVXBkYXRlRmFpbGVkJyxcbiAgS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURUQgPSAna2V5U3lzdGVtU3RhdHVzT3V0cHV0UmVzdHJpY3RlZCcsXG4gIEtFWV9TWVNURU1fU1RBVFVTX0lOVEVSTkFMX0VSUk9SID0gJ2tleVN5c3RlbVN0YXR1c0ludGVybmFsRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIE1BTklGRVNUX0xPQURfRVJST1IgPSAnbWFuaWZlc3RMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTUFOSUZFU1RfTE9BRF9USU1FT1VUID0gJ21hbmlmZXN0TG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IHBhcnNpbmcgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgTUFOSUZFU1RfUEFSU0lOR19FUlJPUiA9ICdtYW5pZmVzdFBhcnNpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3Qgd2l0aCBvbmx5IGluY29tcGF0aWJsZSBjb2RlY3MgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUiA9ICdtYW5pZmVzdEluY29tcGF0aWJsZUNvZGVjc0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCB3aGljaCBjb250YWlucyBubyBmcmFnbWVudHMgLSBkYXRhOiB7IHVybDogZmF1bHR5IFVSTCwgcmVhc29uOiBcIm5vIGZyYWdtZW50cyBmb3VuZCBpbiBsZXZlbFwiLCBsZXZlbDogaW5kZXggb2YgdGhlIGJhZCBsZXZlbCB9XG4gIExFVkVMX0VNUFRZX0VSUk9SID0gJ2xldmVsRW1wdHlFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTEVWRUxfTE9BRF9FUlJPUiA9ICdsZXZlbExvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBMRVZFTF9MT0FEX1RJTUVPVVQgPSAnbGV2ZWxMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgcGFyc2UgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIGVycm9yOiBFcnJvciwgcmVhc29uOiBlcnJvciBtZXNzYWdlIH1cbiAgTEVWRUxfUEFSU0lOR19FUlJPUiA9ICdsZXZlbFBhcnNpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgc3dpdGNoIGVycm9yIC0gZGF0YTogeyBsZXZlbCA6IGZhdWx0eSBsZXZlbCBJZCwgZXZlbnQgOiBlcnJvciBkZXNjcmlwdGlvbn1cbiAgTEVWRUxfU1dJVENIX0VSUk9SID0gJ2xldmVsU3dpdGNoRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBBVURJT19UUkFDS19MT0FEX0VSUk9SID0gJ2F1ZGlvVHJhY2tMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEFVRElPX1RSQUNLX0xPQURfVElNRU9VVCA9ICdhdWRpb1RyYWNrTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIHN1YnRpdGxlIHRyYWNrIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIFNVQlRJVExFX0xPQURfRVJST1IgPSAnc3VidGl0bGVUcmFja0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgc3VidGl0bGUgdHJhY2sgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBTVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQgPSAnc3VidGl0bGVUcmFja0xvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgRlJBR19MT0FEX0VSUk9SID0gJ2ZyYWdMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9BRF9USU1FT1VUID0gJ2ZyYWdMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgZGVjcnlwdGlvbiBlcnJvciBldmVudCAtIGRhdGE6IHtpZCA6IGRlbXV4ZXIgSWQsZnJhZzogZnJhZ21lbnQgb2JqZWN0LCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cbiAgRlJBR19ERUNSWVBUX0VSUk9SID0gJ2ZyYWdEZWNyeXB0RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IHBhcnNpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XG4gIC8vIHdpbGwgYmUgcmVuYW1lZCBERU1VWF9QQVJTSU5HX0VSUk9SIGFuZCBzd2l0Y2hlZCB0byBNVVhfRVJST1IgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxuICBGUkFHX1BBUlNJTkdfRVJST1IgPSAnZnJhZ1BhcnNpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgb3IgcGFydCBsb2FkIHNraXBwZWQgYmVjYXVzZSBvZiBhIEdBUCB0YWcgb3IgYXR0cmlidXRlXG4gIEZSQUdfR0FQID0gJ2ZyYWdHYXAnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIHJlbXV4IGFsbG9jIGVycm9yIGV2ZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgSWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIGJ5dGVzIDogbmIgb2YgYnl0ZXMgb24gd2hpY2ggYWxsb2NhdGlvbiBmYWlsZWQgLCByZWFzb24gOiBlcnJvciB0ZXh0IH1cbiAgUkVNVVhfQUxMT0NfRVJST1IgPSAncmVtdXhBbGxvY0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgS0VZX0xPQURfRVJST1IgPSAna2V5TG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCB0aW1lb3V0IGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBLRVlfTE9BRF9USU1FT1VUID0gJ2tleUxvYWRUaW1lT3V0JyxcbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gZXhjZXB0aW9uIG9jY3VycyB3aGlsZSBhZGRpbmcgYSBzb3VyY2VCdWZmZXIgdG8gTWVkaWFTb3VyY2UgLSBkYXRhIDogeyBlcnJvciA6IGV4Y2VwdGlvbiAsIG1pbWVUeXBlIDogbWltZVR5cGUgfVxuICBCVUZGRVJfQUREX0NPREVDX0VSUk9SID0gJ2J1ZmZlckFkZENvZGVjRXJyb3InLFxuICAvLyBUcmlnZ2VyZWQgd2hlbiBzb3VyY2UgYnVmZmVyKHMpIGNvdWxkIG5vdCBiZSBjcmVhdGVkIHVzaW5nIGxldmVsIChtYW5pZmVzdCBDT0RFQ1MgYXR0cmlidXRlKSwgcGFyc2VkIG1lZGlhLCBvciBiZXN0IGd1ZXNzIGNvZGVjKHMpIC0gZGF0YTogeyByZWFzb24gOiBlcnJvciByZWFzb24gfVxuICBCVUZGRVJfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUiA9ICdidWZmZXJJbmNvbXBhdGlibGVDb2RlY3NFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZCBlcnJvciAtIGRhdGE6IGFwcGVuZCBlcnJvciBkZXNjcmlwdGlvblxuICBCVUZGRVJfQVBQRU5EX0VSUk9SID0gJ2J1ZmZlckFwcGVuZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgYXBwZW5kaW5nIGVycm9yIGV2ZW50IC0gZGF0YTogYXBwZW5kaW5nIGVycm9yIGRlc2NyaXB0aW9uXG4gIEJVRkZFUl9BUFBFTkRJTkdfRVJST1IgPSAnYnVmZmVyQXBwZW5kaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzdGFsbGVkIGVycm9yIGV2ZW50XG4gIEJVRkZFUl9TVEFMTEVEX0VSUk9SID0gJ2J1ZmZlclN0YWxsZWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGZ1bGwgZXZlbnRcbiAgQlVGRkVSX0ZVTExfRVJST1IgPSAnYnVmZmVyRnVsbEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc2VlayBvdmVyIGhvbGUgZXZlbnRcbiAgQlVGRkVSX1NFRUtfT1ZFUl9IT0xFID0gJ2J1ZmZlclNlZWtPdmVySG9sZScsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIG51ZGdlIG9uIHN0YWxsIChwbGF5YmFjayBpcyBzdHVjayBhbHRob3VnaCBjdXJyZW50VGltZSBpcyBpbiBhIGJ1ZmZlcmVkIGFyZWEpXG4gIEJVRkZFUl9OVURHRV9PTl9TVEFMTCA9ICdidWZmZXJOdWRnZU9uU3RhbGwnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBleGNlcHRpb24gaGFwcGVuaW5nIGluc2lkZSBobHMuanMgd2hpbGUgaGFuZGxpbmcgYW4gZXZlbnRcbiAgSU5URVJOQUxfRVhDRVBUSU9OID0gJ2ludGVybmFsRXhjZXB0aW9uJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gaW50ZXJuYWwgY2FsbCB0byBhYm9ydCBhIGxvYWRlclxuICBJTlRFUk5BTF9BQk9SVEVEID0gJ2Fib3J0ZWQnLFxuICAvLyBVbmNhdGVnb3JpemVkIGVycm9yXG4gIFVOS05PV04gPSAndW5rbm93bicsXG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIElMb2dGdW5jdGlvbiB7XG4gIChtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElMb2dnZXIge1xuICB0cmFjZTogSUxvZ0Z1bmN0aW9uO1xuICBkZWJ1ZzogSUxvZ0Z1bmN0aW9uO1xuICBsb2c6IElMb2dGdW5jdGlvbjtcbiAgd2FybjogSUxvZ0Z1bmN0aW9uO1xuICBpbmZvOiBJTG9nRnVuY3Rpb247XG4gIGVycm9yOiBJTG9nRnVuY3Rpb247XG59XG5cbmNvbnN0IG5vb3A6IElMb2dGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHt9O1xuXG5jb25zdCBmYWtlTG9nZ2VyOiBJTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3AsXG59O1xuXG5sZXQgZXhwb3J0ZWRMb2dnZXI6IElMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuXG4vLyBsZXQgbGFzdENhbGxUaW1lO1xuLy8gZnVuY3Rpb24gZm9ybWF0TXNnV2l0aFRpbWVJbmZvKHR5cGUsIG1zZykge1xuLy8gICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XG4vLyAgIGxhc3RDYWxsVGltZSA9IG5vdztcbi8vICAgbXNnID0gKG5ldyBEYXRlKG5vdykpLnRvSVNPU3RyaW5nKCkgKyAnIHwgWycgKyAgdHlwZSArICddID4gJyArIG1zZyArICcgKCAnICsgZGlmZiArICcgbXMgKSc7XG4vLyAgIHJldHVybiBtc2c7XG4vLyB9XG5cbmZ1bmN0aW9uIGNvbnNvbGVQcmludEZuKHR5cGU6IHN0cmluZyk6IElMb2dGdW5jdGlvbiB7XG4gIGNvbnN0IGZ1bmM6IElMb2dGdW5jdGlvbiA9IHNlbGYuY29uc29sZVt0eXBlXTtcbiAgaWYgKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuYy5iaW5kKHNlbGYuY29uc29sZSwgYFske3R5cGV9XSA+YCk7XG4gIH1cbiAgcmV0dXJuIG5vb3A7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhcbiAgZGVidWdDb25maWc6IGJvb2xlYW4gfCBJTG9nZ2VyLFxuICAuLi5mdW5jdGlvbnM6IHN0cmluZ1tdXG4pOiB2b2lkIHtcbiAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBleHBvcnRlZExvZ2dlclt0eXBlXSA9IGRlYnVnQ29uZmlnW3R5cGVdXG4gICAgICA/IGRlYnVnQ29uZmlnW3R5cGVdLmJpbmQoZGVidWdDb25maWcpXG4gICAgICA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ3MoZGVidWdDb25maWc6IGJvb2xlYW4gfCBJTG9nZ2VyLCBpZDogc3RyaW5nKTogdm9pZCB7XG4gIC8vIGNoZWNrIHRoYXQgY29uc29sZSBpcyBhdmFpbGFibGVcbiAgaWYgKFxuICAgIChzZWxmLmNvbnNvbGUgJiYgZGVidWdDb25maWcgPT09IHRydWUpIHx8XG4gICAgdHlwZW9mIGRlYnVnQ29uZmlnID09PSAnb2JqZWN0J1xuICApIHtcbiAgICBleHBvcnRMb2dnZXJGdW5jdGlvbnMoXG4gICAgICBkZWJ1Z0NvbmZpZyxcbiAgICAgIC8vIFJlbW92ZSBvdXQgZnJvbSBsaXN0IGhlcmUgdG8gaGFyZC1kaXNhYmxlIGEgbG9nLWxldmVsXG4gICAgICAvLyAndHJhY2UnLFxuICAgICAgJ2RlYnVnJyxcbiAgICAgICdsb2cnLFxuICAgICAgJ2luZm8nLFxuICAgICAgJ3dhcm4nLFxuICAgICAgJ2Vycm9yJ1xuICAgICk7XG4gICAgLy8gU29tZSBicm93c2VycyBkb24ndCBhbGxvdyB0byB1c2UgYmluZCBvbiBjb25zb2xlIG9iamVjdCBhbnl3YXlcbiAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0IGlmIG5lZWRlZFxuICAgIHRyeSB7XG4gICAgICBleHBvcnRlZExvZ2dlci5sb2coXG4gICAgICAgIGBEZWJ1ZyBsb2dzIGVuYWJsZWQgZm9yIFwiJHtpZH1cIiBpbiBobHMuanMgdmVyc2lvbiAke19fVkVSU0lPTl9ffWBcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxvZ2dlcjogSUxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuIiwiY29uc3QgREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYID0gL14oXFxkKyl4KFxcZCspJC87XG5jb25zdCBBVFRSX0xJU1RfUkVHRVggPSAvKC4rPyk9KFwiLio/XCJ8Lio/KSg/Oix8JCkvZztcblxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5vbmdpbC9ub2RlLW0zdThwYXJzZS9ibG9iL21hc3Rlci9hdHRybGlzdC5qc1xuZXhwb3J0IGNsYXNzIEF0dHJMaXN0IHtcbiAgW2tleTogc3RyaW5nXTogYW55O1xuXG4gIGNvbnN0cnVjdG9yKGF0dHJzOiBzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF0dHJzID0gQXR0ckxpc3QucGFyc2VBdHRyTGlzdChhdHRycyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJzKSB7XG4gICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgaWYgKGF0dHIuc3Vic3RyaW5nKDAsIDIpID09PSAnWC0nKSB7XG4gICAgICAgICAgdGhpcy5jbGllbnRBdHRycyA9IHRoaXMuY2xpZW50QXR0cnMgfHwgW107XG4gICAgICAgICAgdGhpcy5jbGllbnRBdHRycy5wdXNoKGF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbYXR0cl0gPSBhdHRyc1thdHRyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWNpbWFsSW50ZWdlcihhdHRyTmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxMCk7XG4gICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cblxuICBoZXhhZGVjaW1hbEludGVnZXIoYXR0ck5hbWU6IHN0cmluZykge1xuICAgIGlmICh0aGlzW2F0dHJOYW1lXSkge1xuICAgICAgbGV0IHN0cmluZ1ZhbHVlID0gKHRoaXNbYXR0ck5hbWVdIHx8ICcweCcpLnNsaWNlKDIpO1xuICAgICAgc3RyaW5nVmFsdWUgPSAoc3RyaW5nVmFsdWUubGVuZ3RoICYgMSA/ICcwJyA6ICcnKSArIHN0cmluZ1ZhbHVlO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyKGF0dHJOYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfVxuXG4gIGRlY2ltYWxGbG9hdGluZ1BvaW50KGF0dHJOYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXNbYXR0ck5hbWVdKTtcbiAgfVxuXG4gIG9wdGlvbmFsRmxvYXQoYXR0ck5hbWU6IHN0cmluZywgZGVmYXVsdFZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpc1thdHRyTmFtZV07XG4gICAgcmV0dXJuIHZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBlbnVtZXJhdGVkU3RyaW5nKGF0dHJOYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXTtcbiAgfVxuXG4gIGJvb2woYXR0ck5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXSA9PT0gJ1lFUyc7XG4gIH1cblxuICBkZWNpbWFsUmVzb2x1dGlvbihhdHRyTmFtZTogc3RyaW5nKTpcbiAgICB8IHtcbiAgICAgICAgd2lkdGg6IG51bWJlcjtcbiAgICAgICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgICB9XG4gICAgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJlcyA9IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWC5leGVjKHRoaXNbYXR0ck5hbWVdKTtcbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogcGFyc2VJbnQocmVzWzFdLCAxMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KHJlc1syXSwgMTApLFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgcGFyc2VBdHRyTGlzdChpbnB1dDogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgbGV0IG1hdGNoO1xuICAgIGNvbnN0IGF0dHJzID0ge307XG4gICAgY29uc3QgcXVvdGUgPSAnXCInO1xuICAgIEFUVFJfTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgobWF0Y2ggPSBBVFRSX0xJU1RfUkVHRVguZXhlYyhpbnB1dCkpICE9PSBudWxsKSB7XG4gICAgICBsZXQgdmFsdWUgPSBtYXRjaFsyXTtcblxuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJlxuICAgICAgICB2YWx1ZS5sYXN0SW5kZXhPZihxdW90ZSkgPT09IHZhbHVlLmxlbmd0aCAtIDFcbiAgICAgICkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG4gIH1cbn1cbiIsImltcG9ydCB7IEF0dHJMaXN0IH0gZnJvbSAnLi4vdXRpbHMvYXR0ci1saXN0JztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbi8vIEF2b2lkIGV4cG9ydGluZyBjb25zdCBlbnVtIHNvIHRoYXQgdGhlc2UgdmFsdWVzIGNhbiBiZSBpbmxpbmVkXG5jb25zdCBlbnVtIERhdGVSYW5nZUF0dHJpYnV0ZSB7XG4gIElEID0gJ0lEJyxcbiAgQ0xBU1MgPSAnQ0xBU1MnLFxuICBTVEFSVF9EQVRFID0gJ1NUQVJULURBVEUnLFxuICBEVVJBVElPTiA9ICdEVVJBVElPTicsXG4gIEVORF9EQVRFID0gJ0VORC1EQVRFJyxcbiAgRU5EX09OX05FWFQgPSAnRU5ELU9OLU5FWFQnLFxuICBQTEFOTkVEX0RVUkFUSU9OID0gJ1BMQU5ORUQtRFVSQVRJT04nLFxuICBTQ1RFMzVfT1VUID0gJ1NDVEUzNS1PVVQnLFxuICBTQ1RFMzVfSU4gPSAnU0NURTM1LUlOJyxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZVJhbmdlQ3VlQXR0cmlidXRlKGF0dHJOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBhdHRyTmFtZSAhPT0gRGF0ZVJhbmdlQXR0cmlidXRlLklEICYmXG4gICAgYXR0ck5hbWUgIT09IERhdGVSYW5nZUF0dHJpYnV0ZS5DTEFTUyAmJlxuICAgIGF0dHJOYW1lICE9PSBEYXRlUmFuZ2VBdHRyaWJ1dGUuU1RBUlRfREFURSAmJlxuICAgIGF0dHJOYW1lICE9PSBEYXRlUmFuZ2VBdHRyaWJ1dGUuRFVSQVRJT04gJiZcbiAgICBhdHRyTmFtZSAhPT0gRGF0ZVJhbmdlQXR0cmlidXRlLkVORF9EQVRFICYmXG4gICAgYXR0ck5hbWUgIT09IERhdGVSYW5nZUF0dHJpYnV0ZS5FTkRfT05fTkVYVFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTQ1RFMzVBdHRyaWJ1dGUoYXR0ck5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGF0dHJOYW1lID09PSBEYXRlUmFuZ2VBdHRyaWJ1dGUuU0NURTM1X09VVCB8fFxuICAgIGF0dHJOYW1lID09PSBEYXRlUmFuZ2VBdHRyaWJ1dGUuU0NURTM1X0lOXG4gICk7XG59XG5cbmV4cG9ydCBjbGFzcyBEYXRlUmFuZ2Uge1xuICBwdWJsaWMgYXR0cjogQXR0ckxpc3Q7XG4gIHByaXZhdGUgX3N0YXJ0RGF0ZTogRGF0ZTtcbiAgcHJpdmF0ZSBfZW5kRGF0ZT86IERhdGU7XG4gIHByaXZhdGUgX2JhZFZhbHVlRm9yU2FtZUlkPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGVSYW5nZUF0dHI6IEF0dHJMaXN0LCBkYXRlUmFuZ2VXaXRoU2FtZUlkPzogRGF0ZVJhbmdlKSB7XG4gICAgaWYgKGRhdGVSYW5nZVdpdGhTYW1lSWQpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQXR0ciA9IGRhdGVSYW5nZVdpdGhTYW1lSWQuYXR0cjtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXZpb3VzQXR0cikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGVSYW5nZUF0dHIsIGtleSkgJiZcbiAgICAgICAgICBkYXRlUmFuZ2VBdHRyW2tleV0gIT09IHByZXZpb3VzQXR0cltrZXldXG4gICAgICAgICkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYERBVEVSQU5HRSB0YWcgYXR0cmlidXRlOiBcIiR7a2V5fVwiIGRvZXMgbm90IG1hdGNoIGZvciB0YWdzIHdpdGggSUQ6IFwiJHtkYXRlUmFuZ2VBdHRyLklEfVwiYFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgPSBrZXk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIERhdGVSYW5nZSB0YWdzIHdpdGggdGhlIHNhbWUgSURcbiAgICAgIGRhdGVSYW5nZUF0dHIgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICBuZXcgQXR0ckxpc3Qoe30pLFxuICAgICAgICBwcmV2aW91c0F0dHIsXG4gICAgICAgIGRhdGVSYW5nZUF0dHJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuYXR0ciA9IGRhdGVSYW5nZUF0dHI7XG4gICAgdGhpcy5fc3RhcnREYXRlID0gbmV3IERhdGUoZGF0ZVJhbmdlQXR0cltEYXRlUmFuZ2VBdHRyaWJ1dGUuU1RBUlRfREFURV0pO1xuICAgIGlmIChEYXRlUmFuZ2VBdHRyaWJ1dGUuRU5EX0RBVEUgaW4gdGhpcy5hdHRyKSB7XG4gICAgICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUodGhpcy5hdHRyW0RhdGVSYW5nZUF0dHJpYnV0ZS5FTkRfREFURV0pO1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShlbmREYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgdGhpcy5fZW5kRGF0ZSA9IGVuZERhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYXR0ci5JRDtcbiAgfVxuXG4gIGdldCBjbGFzcygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmF0dHIuQ0xBU1M7XG4gIH1cblxuICBnZXQgc3RhcnREYXRlKCk6IERhdGUge1xuICAgIHJldHVybiB0aGlzLl9zdGFydERhdGU7XG4gIH1cblxuICBnZXQgZW5kRGF0ZSgpOiBEYXRlIHwgbnVsbCB7XG4gICAgaWYgKHRoaXMuX2VuZERhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmREYXRlO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG4gICAgaWYgKGR1cmF0aW9uICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fc3RhcnREYXRlLmdldFRpbWUoKSArIGR1cmF0aW9uICogMTAwMCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IGR1cmF0aW9uKCk6IG51bWJlciB8IG51bGwge1xuICAgIGlmIChEYXRlUmFuZ2VBdHRyaWJ1dGUuRFVSQVRJT04gaW4gdGhpcy5hdHRyKSB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuYXR0ci5kZWNpbWFsRmxvYXRpbmdQb2ludChcbiAgICAgICAgRGF0ZVJhbmdlQXR0cmlidXRlLkRVUkFUSU9OXG4gICAgICApO1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShkdXJhdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fZW5kRGF0ZSkge1xuICAgICAgcmV0dXJuICh0aGlzLl9lbmREYXRlLmdldFRpbWUoKSAtIHRoaXMuX3N0YXJ0RGF0ZS5nZXRUaW1lKCkpIC8gMTAwMDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgcGxhbm5lZER1cmF0aW9uKCk6IG51bWJlciB8IG51bGwge1xuICAgIGlmIChEYXRlUmFuZ2VBdHRyaWJ1dGUuUExBTk5FRF9EVVJBVElPTiBpbiB0aGlzLmF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIuZGVjaW1hbEZsb2F0aW5nUG9pbnQoXG4gICAgICAgIERhdGVSYW5nZUF0dHJpYnV0ZS5QTEFOTkVEX0RVUkFUSU9OXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBlbmRPbk5leHQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXR0ci5ib29sKERhdGVSYW5nZUF0dHJpYnV0ZS5FTkRfT05fTkVYVCk7XG4gIH1cblxuICBnZXQgaXNWYWxpZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgISF0aGlzLmlkICYmXG4gICAgICAhdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgJiZcbiAgICAgIE51bWJlci5pc0Zpbml0ZSh0aGlzLnN0YXJ0RGF0ZS5nZXRUaW1lKCkpICYmXG4gICAgICAodGhpcy5kdXJhdGlvbiA9PT0gbnVsbCB8fCB0aGlzLmR1cmF0aW9uID49IDApICYmXG4gICAgICAoIXRoaXMuZW5kT25OZXh0IHx8ICEhdGhpcy5jbGFzcylcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7XG4gIEhsc1BlcmZvcm1hbmNlVGltaW5nLFxuICBIbHNQcm9ncmVzc2l2ZVBlcmZvcm1hbmNlVGltaW5nLFxuICBMb2FkZXJTdGF0cyxcbn0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcblxuZXhwb3J0IGNsYXNzIExvYWRTdGF0cyBpbXBsZW1lbnRzIExvYWRlclN0YXRzIHtcbiAgYWJvcnRlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBsb2FkZWQ6IG51bWJlciA9IDA7XG4gIHJldHJ5OiBudW1iZXIgPSAwO1xuICB0b3RhbDogbnVtYmVyID0gMDtcbiAgY2h1bmtDb3VudDogbnVtYmVyID0gMDtcbiAgYndFc3RpbWF0ZTogbnVtYmVyID0gMDtcbiAgbG9hZGluZzogSGxzUHJvZ3Jlc3NpdmVQZXJmb3JtYW5jZVRpbWluZyA9IHsgc3RhcnQ6IDAsIGZpcnN0OiAwLCBlbmQ6IDAgfTtcbiAgcGFyc2luZzogSGxzUGVyZm9ybWFuY2VUaW1pbmcgPSB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgYnVmZmVyaW5nOiBIbHNQcm9ncmVzc2l2ZVBlcmZvcm1hbmNlVGltaW5nID0geyBzdGFydDogMCwgZmlyc3Q6IDAsIGVuZDogMCB9O1xufVxuIiwiaW1wb3J0IHsgYnVpbGRBYnNvbHV0ZVVSTCB9IGZyb20gJ3VybC10b29sa2l0JztcbmltcG9ydCB7IExldmVsS2V5IH0gZnJvbSAnLi9sZXZlbC1rZXknO1xuaW1wb3J0IHsgTG9hZFN0YXRzIH0gZnJvbSAnLi9sb2FkLXN0YXRzJztcbmltcG9ydCB7IEF0dHJMaXN0IH0gZnJvbSAnLi4vdXRpbHMvYXR0ci1saXN0JztcbmltcG9ydCB0eXBlIHtcbiAgRnJhZ21lbnRMb2FkZXJDb250ZXh0LFxuICBLZXlMb2FkZXJDb250ZXh0LFxuICBMb2FkZXIsXG4gIFBsYXlsaXN0TGV2ZWxUeXBlLFxufSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHR5cGUgeyBLZXlTeXN0ZW1Gb3JtYXRzIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFrZXlzLWhlbHBlcic7XG5cbmV4cG9ydCBjb25zdCBlbnVtIEVsZW1lbnRhcnlTdHJlYW1UeXBlcyB7XG4gIEFVRElPID0gJ2F1ZGlvJyxcbiAgVklERU8gPSAndmlkZW8nLFxuICBBVURJT1ZJREVPID0gJ2F1ZGlvdmlkZW8nLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVsZW1lbnRhcnlTdHJlYW1JbmZvIHtcbiAgc3RhcnRQVFM6IG51bWJlcjtcbiAgZW5kUFRTOiBudW1iZXI7XG4gIHN0YXJ0RFRTOiBudW1iZXI7XG4gIGVuZERUUzogbnVtYmVyO1xuICBwYXJ0aWFsPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IHR5cGUgRWxlbWVudGFyeVN0cmVhbXMgPSBSZWNvcmQ8XG4gIEVsZW1lbnRhcnlTdHJlYW1UeXBlcyxcbiAgRWxlbWVudGFyeVN0cmVhbUluZm8gfCBudWxsXG4+O1xuXG5leHBvcnQgY2xhc3MgQmFzZVNlZ21lbnQge1xuICBwcml2YXRlIF9ieXRlUmFuZ2U6IG51bWJlcltdIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX3VybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gYmFzZXVybCBpcyB0aGUgVVJMIHRvIHRoZSBwbGF5bGlzdFxuICBwdWJsaWMgcmVhZG9ubHkgYmFzZXVybDogc3RyaW5nO1xuICAvLyByZWx1cmwgaXMgdGhlIHBvcnRpb24gb2YgdGhlIFVSTCB0aGF0IGNvbWVzIGZyb20gaW5zaWRlIHRoZSBwbGF5bGlzdC5cbiAgcHVibGljIHJlbHVybD86IHN0cmluZztcbiAgLy8gSG9sZHMgdGhlIHR5cGVzIG9mIGRhdGEgdGhpcyBmcmFnbWVudCBzdXBwb3J0c1xuICBwdWJsaWMgZWxlbWVudGFyeVN0cmVhbXM6IEVsZW1lbnRhcnlTdHJlYW1zID0ge1xuICAgIFtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dOiBudWxsLFxuICAgIFtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dOiBudWxsLFxuICAgIFtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT106IG51bGwsXG4gIH07XG5cbiAgY29uc3RydWN0b3IoYmFzZXVybDogc3RyaW5nKSB7XG4gICAgdGhpcy5iYXNldXJsID0gYmFzZXVybDtcbiAgfVxuXG4gIC8vIHNldEJ5dGVSYW5nZSBjb252ZXJ0cyBhIEVYVC1YLUJZVEVSQU5HRSBhdHRyaWJ1dGUgaW50byBhIHR3byBlbGVtZW50IGFycmF5XG4gIHNldEJ5dGVSYW5nZSh2YWx1ZTogc3RyaW5nLCBwcmV2aW91cz86IEJhc2VTZWdtZW50KSB7XG4gICAgY29uc3QgcGFyYW1zID0gdmFsdWUuc3BsaXQoJ0AnLCAyKTtcbiAgICBjb25zdCBieXRlUmFuZ2U6IG51bWJlcltdID0gW107XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGJ5dGVSYW5nZVswXSA9IHByZXZpb3VzID8gcHJldmlvdXMuYnl0ZVJhbmdlRW5kT2Zmc2V0IDogMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZVJhbmdlWzBdID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICB9XG4gICAgYnl0ZVJhbmdlWzFdID0gcGFyc2VJbnQocGFyYW1zWzBdKSArIGJ5dGVSYW5nZVswXTtcbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBieXRlUmFuZ2U7XG4gIH1cblxuICBnZXQgYnl0ZVJhbmdlKCk6IG51bWJlcltdIHtcbiAgICBpZiAoIXRoaXMuX2J5dGVSYW5nZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9ieXRlUmFuZ2U7XG4gIH1cblxuICBnZXQgYnl0ZVJhbmdlU3RhcnRPZmZzZXQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMF07XG4gIH1cblxuICBnZXQgYnl0ZVJhbmdlRW5kT2Zmc2V0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzFdO1xuICB9XG5cbiAgZ2V0IHVybCgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5fdXJsICYmIHRoaXMuYmFzZXVybCAmJiB0aGlzLnJlbHVybCkge1xuICAgICAgdGhpcy5fdXJsID0gYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmwsIHRoaXMucmVsdXJsLCB7XG4gICAgICAgIGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdXJsIHx8ICcnO1xuICB9XG5cbiAgc2V0IHVybCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIFNlZ21lbnQuIEZvdW5kIGluIHtAbGluayBobHMuanMjTGV2ZWxEZXRhaWxzLmZyYWdtZW50c30uXG4gKi9cbmV4cG9ydCBjbGFzcyBGcmFnbWVudCBleHRlbmRzIEJhc2VTZWdtZW50IHtcbiAgcHJpdmF0ZSBfZGVjcnlwdGRhdGE6IExldmVsS2V5IHwgbnVsbCA9IG51bGw7XG5cbiAgcHVibGljIHJhd1Byb2dyYW1EYXRlVGltZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBwcm9ncmFtRGF0ZVRpbWU6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgdGFnTGlzdDogQXJyYXk8c3RyaW5nW10+ID0gW107XG5cbiAgLy8gRVhUSU5GIGhhcyB0byBiZSBwcmVzZW50IGZvciBhIG0zdTggdG8gYmUgY29uc2lkZXJlZCB2YWxpZFxuICBwdWJsaWMgZHVyYXRpb246IG51bWJlciA9IDA7XG4gIC8vIHNuIG5vdGF0ZXMgdGhlIHNlcXVlbmNlIG51bWJlciBmb3IgYSBzZWdtZW50LCBhbmQgaWYgc2V0IHRvIGEgc3RyaW5nIGNhbiBiZSAnaW5pdFNlZ21lbnQnXG4gIHB1YmxpYyBzbjogbnVtYmVyIHwgJ2luaXRTZWdtZW50JyA9IDA7XG4gIC8vIGxldmVsa2V5cyBhcmUgdGhlIEVYVC1YLUtFWSB0YWdzIHRoYXQgYXBwbHkgdG8gdGhpcyBzZWdtZW50IGZvciBkZWNyeXB0aW9uXG4gIC8vIGNvcmUgZGlmZmVyZW5jZSBmcm9tIHRoZSBwcml2YXRlIGZpZWxkIF9kZWNyeXB0ZGF0YSBpcyB0aGUgbGFjayBvZiB0aGUgaW5pdGlhbGl6ZWQgSVZcbiAgLy8gX2RlY3J5cHRkYXRhIHdpbGwgc2V0IHRoZSBJViBmb3IgdGhpcyBzZWdtZW50IGJhc2VkIG9uIHRoZSBzZWdtZW50IG51bWJlciBpbiB0aGUgZnJhZ21lbnRcbiAgcHVibGljIGxldmVsa2V5cz86IHsgW2tleTogc3RyaW5nXTogTGV2ZWxLZXkgfTtcbiAgLy8gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBmcmFnbWVudCB0eXBlXG4gIHB1YmxpYyByZWFkb25seSB0eXBlOiBQbGF5bGlzdExldmVsVHlwZTtcbiAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGxvYWRlci4gU2V0IHdoaWxlIHRoZSBmcmFnbWVudCBpcyBsb2FkaW5nLCBhbmQgcmVtb3ZlZCBhZnRlcndhcmRzLiBVc2VkIHRvIGFib3J0IGZyYWdtZW50IGxvYWRpbmdcbiAgcHVibGljIGxvYWRlcjogTG9hZGVyPEZyYWdtZW50TG9hZGVyQ29udGV4dD4gfCBudWxsID0gbnVsbDtcbiAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGtleSBsb2FkZXIuIFNldCB3aGlsZSB0aGUga2V5IGlzIGxvYWRpbmcsIGFuZCByZW1vdmVkIGFmdGVyd2FyZHMuIFVzZWQgdG8gYWJvcnQga2V5IGxvYWRpbmdcbiAgcHVibGljIGtleUxvYWRlcjogTG9hZGVyPEtleUxvYWRlckNvbnRleHQ+IHwgbnVsbCA9IG51bGw7XG4gIC8vIFRoZSBsZXZlbC90cmFjayBpbmRleCB0byB3aGljaCB0aGUgZnJhZ21lbnQgYmVsb25nc1xuICBwdWJsaWMgbGV2ZWw6IG51bWJlciA9IC0xO1xuICAvLyBUaGUgY29udGludWl0eSBjb3VudGVyIG9mIHRoZSBmcmFnbWVudFxuICBwdWJsaWMgY2M6IG51bWJlciA9IDA7XG4gIC8vIFRoZSBzdGFydGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgcHVibGljIHN0YXJ0UFRTPzogbnVtYmVyO1xuICAvLyBUaGUgZW5kaW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICBwdWJsaWMgZW5kUFRTPzogbnVtYmVyO1xuICAvLyBUaGUgc3RhcnRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIHB1YmxpYyBzdGFydERUUyE6IG51bWJlcjtcbiAgLy8gVGhlIGVuZGluZyBEZWNvZGUgVGltZSBTdGFtcCAoRFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgcHVibGljIGVuZERUUyE6IG51bWJlcjtcbiAgLy8gVGhlIHN0YXJ0IHRpbWUgb2YgdGhlIGZyYWdtZW50LCBhcyBsaXN0ZWQgaW4gdGhlIG1hbmlmZXN0LiBVcGRhdGVkIGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICBwdWJsaWMgc3RhcnQ6IG51bWJlciA9IDA7XG4gIC8vIFNldCBieSBgdXBkYXRlRnJhZ1BUU0RUU2AgaW4gbGV2ZWwtaGVscGVyXG4gIHB1YmxpYyBkZWx0YVBUUz86IG51bWJlcjtcbiAgLy8gVGhlIG1heGltdW0gc3RhcnRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIHB1YmxpYyBtYXhTdGFydFBUUz86IG51bWJlcjtcbiAgLy8gVGhlIG1pbmltdW0gZW5kaW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChhdWRpby92aWRlbyBQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICBwdWJsaWMgbWluRW5kUFRTPzogbnVtYmVyO1xuICAvLyBMb2FkL3BhcnNlIHRpbWluZyBpbmZvcm1hdGlvblxuICBwdWJsaWMgc3RhdHM6IExvYWRTdGF0cyA9IG5ldyBMb2FkU3RhdHMoKTtcbiAgcHVibGljIHVybElkOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgZGF0YT86IFVpbnQ4QXJyYXk7XG4gIC8vIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNlZ21lbnQgd2FzIGRvd25sb2FkZWQgaW4gb3JkZXIgdG8gdGVzdCBiaXRyYXRlLCBhbmQgd2FzIG5vdCBidWZmZXJlZFxuICBwdWJsaWMgYml0cmF0ZVRlc3Q6IGJvb2xlYW4gPSBmYWxzZTtcbiAgLy8gI0VYVElORiAgc2VnbWVudCB0aXRsZVxuICBwdWJsaWMgdGl0bGU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAvLyBUaGUgTWVkaWEgSW5pdGlhbGl6YXRpb24gU2VjdGlvbiBmb3IgdGhpcyBzZWdtZW50XG4gIHB1YmxpYyBpbml0U2VnbWVudDogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgLy8gRnJhZ21lbnQgaXMgdGhlIGxhc3QgZnJhZ21lbnQgaW4gdGhlIG1lZGlhIHBsYXlsaXN0XG4gIHB1YmxpYyBlbmRMaXN0PzogYm9vbGVhbjtcbiAgLy8gRnJhZ21lbnQgaXMgbWFya2VkIGJ5IGFuIEVYVC1YLUdBUCB0YWcgaW5kaWNhdGluZyB0aGF0IGl0IGRvZXMgbm90IGNvbnRhaW4gbWVkaWEgZGF0YSBhbmQgc2hvdWxkIG5vdCBiZSBsb2FkZWRcbiAgcHVibGljIGdhcD86IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IodHlwZTogUGxheWxpc3RMZXZlbFR5cGUsIGJhc2V1cmw6IHN0cmluZykge1xuICAgIHN1cGVyKGJhc2V1cmwpO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cblxuICBnZXQgZGVjcnlwdGRhdGEoKTogTGV2ZWxLZXkgfCBudWxsIHtcbiAgICBjb25zdCB7IGxldmVsa2V5cyB9ID0gdGhpcztcbiAgICBpZiAoIWxldmVsa2V5cyAmJiAhdGhpcy5fZGVjcnlwdGRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZGVjcnlwdGRhdGEgJiYgdGhpcy5sZXZlbGtleXMgJiYgIXRoaXMubGV2ZWxrZXlzLk5PTkUpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMubGV2ZWxrZXlzLmlkZW50aXR5O1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IGtleS5nZXREZWNyeXB0RGF0YSh0aGlzLnNuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGtleUZvcm1hdHMgPSBPYmplY3Qua2V5cyh0aGlzLmxldmVsa2V5cyk7XG4gICAgICAgIGlmIChrZXlGb3JtYXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiAodGhpcy5fZGVjcnlwdGRhdGEgPSB0aGlzLmxldmVsa2V5c1tcbiAgICAgICAgICAgIGtleUZvcm1hdHNbMF1cbiAgICAgICAgICBdLmdldERlY3J5cHREYXRhKHRoaXMuc24pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNdWx0aXBsZSBrZXlzLiBrZXktbG9hZGVyIHRvIGNhbGwgRnJhZ21lbnQuc2V0S2V5Rm9ybWF0IGJhc2VkIG9uIHNlbGVjdGVkIGtleS1zeXN0ZW0uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVjcnlwdGRhdGE7XG4gIH1cblxuICBnZXQgZW5kKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICB9XG5cbiAgZ2V0IGVuZFByb2dyYW1EYXRlVGltZSgpIHtcbiAgICBpZiAodGhpcy5wcm9ncmFtRGF0ZVRpbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRoaXMucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZHVyYXRpb24gPSAhTnVtYmVyLmlzRmluaXRlKHRoaXMuZHVyYXRpb24pID8gMCA6IHRoaXMuZHVyYXRpb247XG5cbiAgICByZXR1cm4gdGhpcy5wcm9ncmFtRGF0ZVRpbWUgKyBkdXJhdGlvbiAqIDEwMDA7XG4gIH1cblxuICBnZXQgZW5jcnlwdGVkKCkge1xuICAgIC8vIEF0IHRoZSBtM3U4LXBhcnNlciBsZXZlbCB3ZSBuZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtYW5pZmVzdCBzaWduYWxsZWQga2V5Zm9ybWF0c1xuICAgIC8vIHdoZW4gd2Ugd2FudCB0aGUgZnJhZ21lbnQgdG8gc3RhcnQgcmVwb3J0aW5nIHRoYXQgaXQgaXMgZW5jcnlwdGVkLlxuICAgIC8vIEN1cnJlbnRseSwga2V5Rm9ybWF0IHdpbGwgb25seSBiZSBzZXQgZm9yIGlkZW50aXR5IGtleXNcbiAgICBpZiAodGhpcy5fZGVjcnlwdGRhdGE/LmVuY3J5cHRlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxldmVsa2V5cykge1xuICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgIGNvbnN0IGxlbiA9IGtleUZvcm1hdHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA+IDEgfHwgKGxlbiA9PT0gMSAmJiB0aGlzLmxldmVsa2V5c1trZXlGb3JtYXRzWzBdXS5lbmNyeXB0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHNldEtleUZvcm1hdChrZXlGb3JtYXQ6IEtleVN5c3RlbUZvcm1hdHMpIHtcbiAgICBpZiAodGhpcy5sZXZlbGtleXMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMubGV2ZWxrZXlzW2tleUZvcm1hdF07XG4gICAgICBpZiAoa2V5ICYmICF0aGlzLl9kZWNyeXB0ZGF0YSkge1xuICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IGtleS5nZXREZWNyeXB0RGF0YSh0aGlzLnNuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhYm9ydFJlcXVlc3RzKCk6IHZvaWQge1xuICAgIHRoaXMubG9hZGVyPy5hYm9ydCgpO1xuICAgIHRoaXMua2V5TG9hZGVyPy5hYm9ydCgpO1xuICB9XG5cbiAgc2V0RWxlbWVudGFyeVN0cmVhbUluZm8oXG4gICAgdHlwZTogRWxlbWVudGFyeVN0cmVhbVR5cGVzLFxuICAgIHN0YXJ0UFRTOiBudW1iZXIsXG4gICAgZW5kUFRTOiBudW1iZXIsXG4gICAgc3RhcnREVFM6IG51bWJlcixcbiAgICBlbmREVFM6IG51bWJlcixcbiAgICBwYXJ0aWFsOiBib29sZWFuID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3QgeyBlbGVtZW50YXJ5U3RyZWFtcyB9ID0gdGhpcztcbiAgICBjb25zdCBpbmZvID0gZWxlbWVudGFyeVN0cmVhbXNbdHlwZV07XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9IHtcbiAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUyxcbiAgICAgICAgc3RhcnREVFMsXG4gICAgICAgIGVuZERUUyxcbiAgICAgICAgcGFydGlhbCxcbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5mby5zdGFydFBUUyA9IE1hdGgubWluKGluZm8uc3RhcnRQVFMsIHN0YXJ0UFRTKTtcbiAgICBpbmZvLmVuZFBUUyA9IE1hdGgubWF4KGluZm8uZW5kUFRTLCBlbmRQVFMpO1xuICAgIGluZm8uc3RhcnREVFMgPSBNYXRoLm1pbihpbmZvLnN0YXJ0RFRTLCBzdGFydERUUyk7XG4gICAgaW5mby5lbmREVFMgPSBNYXRoLm1heChpbmZvLmVuZERUUywgZW5kRFRTKTtcbiAgfVxuXG4gIGNsZWFyRWxlbWVudGFyeVN0cmVhbUluZm8oKSB7XG4gICAgY29uc3QgeyBlbGVtZW50YXJ5U3RyZWFtcyB9ID0gdGhpcztcbiAgICBlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0gbnVsbDtcbiAgICBlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dID0gbnVsbDtcbiAgICBlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT10gPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogT2JqZWN0IHJlcHJlc2VudGluZyBwYXJzZWQgZGF0YSBmcm9tIGFuIEhMUyBQYXJ0aWFsIFNlZ21lbnQuIEZvdW5kIGluIHtAbGluayBobHMuanMjTGV2ZWxEZXRhaWxzLnBhcnRMaXN0fS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnQgZXh0ZW5kcyBCYXNlU2VnbWVudCB7XG4gIHB1YmxpYyByZWFkb25seSBmcmFnT2Zmc2V0OiBudW1iZXIgPSAwO1xuICBwdWJsaWMgcmVhZG9ubHkgZHVyYXRpb246IG51bWJlciA9IDA7XG4gIHB1YmxpYyByZWFkb25seSBnYXA6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIHJlYWRvbmx5IGluZGVwZW5kZW50OiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyByZWFkb25seSByZWx1cmw6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGZyYWdtZW50OiBGcmFnbWVudDtcbiAgcHVibGljIHJlYWRvbmx5IGluZGV4OiBudW1iZXI7XG4gIHB1YmxpYyBzdGF0czogTG9hZFN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhcnRBdHRyczogQXR0ckxpc3QsXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAgYmFzZXVybDogc3RyaW5nLFxuICAgIGluZGV4OiBudW1iZXIsXG4gICAgcHJldmlvdXM/OiBQYXJ0XG4gICkge1xuICAgIHN1cGVyKGJhc2V1cmwpO1xuICAgIHRoaXMuZHVyYXRpb24gPSBwYXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ0RVUkFUSU9OJyk7XG4gICAgdGhpcy5nYXAgPSBwYXJ0QXR0cnMuYm9vbCgnR0FQJyk7XG4gICAgdGhpcy5pbmRlcGVuZGVudCA9IHBhcnRBdHRycy5ib29sKCdJTkRFUEVOREVOVCcpO1xuICAgIHRoaXMucmVsdXJsID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ1VSSScpIGFzIHN0cmluZztcbiAgICB0aGlzLmZyYWdtZW50ID0gZnJhZztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgY29uc3QgYnl0ZVJhbmdlID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0JZVEVSQU5HRScpO1xuICAgIGlmIChieXRlUmFuZ2UpIHtcbiAgICAgIHRoaXMuc2V0Qnl0ZVJhbmdlKGJ5dGVSYW5nZSwgcHJldmlvdXMpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgIHRoaXMuZnJhZ09mZnNldCA9IHByZXZpb3VzLmZyYWdPZmZzZXQgKyBwcmV2aW91cy5kdXJhdGlvbjtcbiAgICB9XG4gIH1cblxuICBnZXQgc3RhcnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5zdGFydCArIHRoaXMuZnJhZ09mZnNldDtcbiAgfVxuXG4gIGdldCBlbmQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gIH1cblxuICBnZXQgbG9hZGVkKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHsgZWxlbWVudGFyeVN0cmVhbXMgfSA9IHRoaXM7XG4gICAgcmV0dXJuICEhKFxuICAgICAgZWxlbWVudGFyeVN0cmVhbXMuYXVkaW8gfHxcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zLnZpZGVvIHx8XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtcy5hdWRpb3ZpZGVvXG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgUGFydCB9IGZyb20gJy4vZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudCB9IGZyb20gJy4vZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBBdHRyTGlzdCB9IGZyb20gJy4uL3V0aWxzL2F0dHItbGlzdCc7XG5pbXBvcnQgdHlwZSB7IERhdGVSYW5nZSB9IGZyb20gJy4vZGF0ZS1yYW5nZSc7XG5pbXBvcnQgdHlwZSB7IFZhcmlhYmxlTWFwIH0gZnJvbSAnLi4vdHlwZXMvbGV2ZWwnO1xuXG5jb25zdCBERUZBVUxUX1RBUkdFVF9EVVJBVElPTiA9IDEwO1xuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIGRhdGEgZnJvbSBhbiBITFMgTWVkaWEgUGxheWxpc3QuIEZvdW5kIGluIHtAbGluayBobHMuanMjTGV2ZWwuZGV0YWlsc30uXG4gKi9cbmV4cG9ydCBjbGFzcyBMZXZlbERldGFpbHMge1xuICBwdWJsaWMgUFRTS25vd246IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIGFsaWduZWRTbGlkaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBhdmVyYWdldGFyZ2V0ZHVyYXRpb24/OiBudW1iZXI7XG4gIHB1YmxpYyBlbmRDQzogbnVtYmVyID0gMDtcbiAgcHVibGljIGVuZFNOOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgZnJhZ21lbnRzOiBGcmFnbWVudFtdO1xuICBwdWJsaWMgZnJhZ21lbnRIaW50PzogRnJhZ21lbnQ7XG4gIHB1YmxpYyBwYXJ0TGlzdDogUGFydFtdIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBkYXRlUmFuZ2VzOiBSZWNvcmQ8c3RyaW5nLCBEYXRlUmFuZ2U+O1xuICBwdWJsaWMgbGl2ZTogYm9vbGVhbiA9IHRydWU7XG4gIHB1YmxpYyBhZ2VIZWFkZXI6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBhZHZhbmNlZERhdGVUaW1lPzogbnVtYmVyO1xuICBwdWJsaWMgdXBkYXRlZDogYm9vbGVhbiA9IHRydWU7XG4gIHB1YmxpYyBhZHZhbmNlZDogYm9vbGVhbiA9IHRydWU7XG4gIHB1YmxpYyBhdmFpbGFiaWxpdHlEZWxheT86IG51bWJlcjsgLy8gTWFuaWZlc3QgcmVsb2FkIHN5bmNocm9uaXphdGlvblxuICBwdWJsaWMgbWlzc2VzOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgc3RhcnRDQzogbnVtYmVyID0gMDtcbiAgcHVibGljIHN0YXJ0U046IG51bWJlciA9IDA7XG4gIHB1YmxpYyBzdGFydFRpbWVPZmZzZXQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgdGFyZ2V0ZHVyYXRpb246IG51bWJlciA9IDA7XG4gIHB1YmxpYyB0b3RhbGR1cmF0aW9uOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgdHlwZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyB1cmw6IHN0cmluZztcbiAgcHVibGljIG0zdTg6IHN0cmluZyA9ICcnO1xuICBwdWJsaWMgdmVyc2lvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBjYW5CbG9ja1JlbG9hZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgY2FuU2tpcFVudGlsOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgY2FuU2tpcERhdGVSYW5nZXM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIHNraXBwZWRTZWdtZW50czogbnVtYmVyID0gMDtcbiAgcHVibGljIHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXM/OiBzdHJpbmdbXTtcbiAgcHVibGljIHBhcnRIb2xkQmFjazogbnVtYmVyID0gMDtcbiAgcHVibGljIGhvbGRCYWNrOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgcGFydFRhcmdldDogbnVtYmVyID0gMDtcbiAgcHVibGljIHByZWxvYWRIaW50PzogQXR0ckxpc3Q7XG4gIHB1YmxpYyByZW5kaXRpb25SZXBvcnRzPzogQXR0ckxpc3RbXTtcbiAgcHVibGljIHR1bmVJbkdvYWw6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBkZWx0YVVwZGF0ZUZhaWxlZD86IGJvb2xlYW47XG4gIHB1YmxpYyBkcmlmdFN0YXJ0VGltZTogbnVtYmVyID0gMDtcbiAgcHVibGljIGRyaWZ0RW5kVGltZTogbnVtYmVyID0gMDtcbiAgcHVibGljIGRyaWZ0U3RhcnQ6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBkcmlmdEVuZDogbnVtYmVyID0gMDtcbiAgcHVibGljIGVuY3J5cHRlZEZyYWdtZW50czogRnJhZ21lbnRbXTtcbiAgcHVibGljIHBsYXlsaXN0UGFyc2luZ0Vycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgdmFyaWFibGVMaXN0OiBWYXJpYWJsZU1hcCB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgaGFzVmFyaWFibGVSZWZzID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoYmFzZVVybCkge1xuICAgIHRoaXMuZnJhZ21lbnRzID0gW107XG4gICAgdGhpcy5lbmNyeXB0ZWRGcmFnbWVudHMgPSBbXTtcbiAgICB0aGlzLmRhdGVSYW5nZXMgPSB7fTtcbiAgICB0aGlzLnVybCA9IGJhc2VVcmw7XG4gIH1cblxuICByZWxvYWRlZChwcmV2aW91czogTGV2ZWxEZXRhaWxzIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFwcmV2aW91cykge1xuICAgICAgdGhpcy5hZHZhbmNlZCA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0U25EaWZmID0gdGhpcy5sYXN0UGFydFNuIC0gcHJldmlvdXMubGFzdFBhcnRTbjtcbiAgICBjb25zdCBwYXJ0SW5kZXhEaWZmID0gdGhpcy5sYXN0UGFydEluZGV4IC0gcHJldmlvdXMubGFzdFBhcnRJbmRleDtcbiAgICB0aGlzLnVwZGF0ZWQgPVxuICAgICAgdGhpcy5lbmRTTiAhPT0gcHJldmlvdXMuZW5kU04gfHwgISFwYXJ0SW5kZXhEaWZmIHx8ICEhcGFydFNuRGlmZjtcbiAgICB0aGlzLmFkdmFuY2VkID1cbiAgICAgIHRoaXMuZW5kU04gPiBwcmV2aW91cy5lbmRTTiB8fFxuICAgICAgcGFydFNuRGlmZiA+IDAgfHxcbiAgICAgIChwYXJ0U25EaWZmID09PSAwICYmIHBhcnRJbmRleERpZmYgPiAwKTtcbiAgICBpZiAodGhpcy51cGRhdGVkIHx8IHRoaXMuYWR2YW5jZWQpIHtcbiAgICAgIHRoaXMubWlzc2VzID0gTWF0aC5mbG9vcihwcmV2aW91cy5taXNzZXMgKiAwLjYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1pc3NlcyA9IHByZXZpb3VzLm1pc3NlcyArIDE7XG4gICAgfVxuICAgIHRoaXMuYXZhaWxhYmlsaXR5RGVsYXkgPSBwcmV2aW91cy5hdmFpbGFiaWxpdHlEZWxheTtcbiAgfVxuXG4gIGdldCBoYXNQcm9ncmFtRGF0ZVRpbWUoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShcbiAgICAgICAgdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoIC0gMV0ucHJvZ3JhbURhdGVUaW1lIGFzIG51bWJlclxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0IGxldmVsVGFyZ2V0RHVyYXRpb24oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gfHxcbiAgICAgIHRoaXMudGFyZ2V0ZHVyYXRpb24gfHxcbiAgICAgIERFRkFVTFRfVEFSR0VUX0RVUkFUSU9OXG4gICAgKTtcbiAgfVxuXG4gIGdldCBkcmlmdCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHJ1blRpbWUgPSB0aGlzLmRyaWZ0RW5kVGltZSAtIHRoaXMuZHJpZnRTdGFydFRpbWU7XG4gICAgaWYgKHJ1blRpbWUgPiAwKSB7XG4gICAgICBjb25zdCBydW5EdXJhdGlvbiA9IHRoaXMuZHJpZnRFbmQgLSB0aGlzLmRyaWZ0U3RhcnQ7XG4gICAgICByZXR1cm4gKHJ1bkR1cmF0aW9uICogMTAwMCkgLyBydW5UaW1lO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGdldCBlZGdlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFydEVuZCB8fCB0aGlzLmZyYWdtZW50RW5kO1xuICB9XG5cbiAgZ2V0IHBhcnRFbmQoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5wYXJ0TGlzdD8ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmVuZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRFbmQ7XG4gIH1cblxuICBnZXQgZnJhZ21lbnRFbmQoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5mcmFnbWVudHM/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdLmVuZDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXQgYWdlKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuYWR2YW5jZWREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KERhdGUubm93KCkgLSB0aGlzLmFkdmFuY2VkRGF0ZVRpbWUsIDApIC8gMTAwMDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXQgbGFzdFBhcnRJbmRleCgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLnBhcnRMaXN0Py5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uaW5kZXg7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGdldCBsYXN0UGFydFNuKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMucGFydExpc3Q/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5mcmFnbWVudC5zbiBhcyBudW1iZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVuZFNOO1xuICB9XG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgaW5zZXJ0ZWQgYXMgYSBzaGltIGZvciBtb2R1bGVzIHdoaWNoIHdlIGRvIG5vdCB3YW50IHRvIGluY2x1ZGUgaW50byB0aGUgZGlzdHJvLlxuLy8gVGhpcyByZXBsYWNlbWVudCBpcyBkb25lIGluIHRoZSBcImFsaWFzXCIgcGx1Z2luIG9mIHRoZSByb2xsdXAgY29uZmlnLlxubW9kdWxlLmV4cG9ydHMgPSB1bmRlZmluZWQ7XG4iLCJleHBvcnQgZnVuY3Rpb24gc2xpY2VVaW50OChcbiAgYXJyYXk6IFVpbnQ4QXJyYXksXG4gIHN0YXJ0PzogbnVtYmVyLFxuICBlbmQ/OiBudW1iZXJcbik6IFVpbnQ4QXJyYXkge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIFRoaXMgcG9seWZpbGxzIElFMTEgdXNhZ2Ugb2YgVWludDhBcnJheSBzbGljZS5cbiAgLy8gSXQgYWx3YXlzIGV4aXN0cyBpbiB0aGUgVHlwZVNjcmlwdCBkZWZpbml0aW9uIHNvIGZhaWxzLCBidXQgaXQgZmFpbHMgYXQgcnVudGltZSBvbiBJRTExLlxuICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICA/IGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgOiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheSwgc3RhcnQsIGVuZCkpO1xufVxuIiwidHlwZSBSYXdGcmFtZSA9IHsgdHlwZTogc3RyaW5nOyBzaXplOiBudW1iZXI7IGRhdGE6IFVpbnQ4QXJyYXkgfTtcblxuLy8gYnJlYWtpbmcgdXAgdGhvc2UgdHdvIHR5cGVzIGluIG9yZGVyIHRvIGNsYXJpZnkgd2hhdCBpcyBoYXBwZW5pbmcgaW4gdGhlIGRlY29kaW5nIHBhdGguXG50eXBlIERlY29kZWRGcmFtZTxUPiA9IHsga2V5OiBzdHJpbmc7IGRhdGE6IFQ7IGluZm8/OiBhbnkgfTtcbmV4cG9ydCB0eXBlIEZyYW1lID0gRGVjb2RlZEZyYW1lPEFycmF5QnVmZmVyIHwgc3RyaW5nPjtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gSUQzIGhlYWRlciBjYW4gYmUgZm91bmQgYXQgb2Zmc2V0IGluIGRhdGFcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGlzSGVhZGVyID0gKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gIC8qXG4gICAqIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgKiBbMF0gICAgID0gJ0knXG4gICAqIFsxXSAgICAgPSAnRCdcbiAgICogWzJdICAgICA9ICczJ1xuICAgKiBbMyw0XSAgID0ge1ZlcnNpb259XG4gICAqIFs1XSAgICAgPSB7RmxhZ3N9XG4gICAqIFs2LTldICAgPSB7SUQzIFNpemV9XG4gICAqXG4gICAqIEFuIElEM3YyIHRhZyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gICAqICAkNDkgNDQgMzMgeXkgeXkgeHggenogenogenogenpcbiAgICogV2hlcmUgeXkgaXMgbGVzcyB0aGFuICRGRiwgeHggaXMgdGhlICdmbGFncycgYnl0ZSBhbmQgenogaXMgbGVzcyB0aGFuICQ4MFxuICAgKi9cbiAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gbG9vayBmb3IgJ0lEMycgaWRlbnRpZmllclxuICAgIGlmIChcbiAgICAgIGRhdGFbb2Zmc2V0XSA9PT0gMHg0OSAmJlxuICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJlxuICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHgzM1xuICAgICkge1xuICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiZcbiAgICAgICAgICBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJlxuICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmXG4gICAgICAgICAgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODBcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2hcbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICovXG5leHBvcnQgY29uc3QgaXNGb290ZXIgPSAoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgLypcbiAgICogVGhlIGZvb3RlciBpcyBhIGNvcHkgb2YgdGhlIGhlYWRlciwgYnV0IHdpdGggYSBkaWZmZXJlbnQgaWRlbnRpZmllclxuICAgKi9cbiAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gbG9vayBmb3IgJzNESScgaWRlbnRpZmllclxuICAgIGlmIChcbiAgICAgIGRhdGFbb2Zmc2V0XSA9PT0gMHgzMyAmJlxuICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJlxuICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHg0OVxuICAgICkge1xuICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiZcbiAgICAgICAgICBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJlxuICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmXG4gICAgICAgICAgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODBcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW55IGFkamFjZW50IElEMyB0YWdzIGZvdW5kIGluIGRhdGEgc3RhcnRpbmcgYXQgb2Zmc2V0LCBhcyBvbmUgYmxvY2sgb2YgZGF0YVxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICogQHJldHVybnMgdGhlIGJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBhbnkgSUQzIHRhZ3MgZm91bmRcbiAqIG9yICp1bmRlZmluZWQqIGlmIG5vIGhlYWRlciBpcyBmb3VuZCBhdCB0aGUgc3RhcnRpbmcgb2Zmc2V0XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJRDNEYXRhID0gKFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBvZmZzZXQ6IG51bWJlclxuKTogVWludDhBcnJheSB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGZyb250ID0gb2Zmc2V0O1xuICBsZXQgbGVuZ3RoID0gMDtcblxuICB3aGlsZSAoaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIElEMyBoZWFkZXIgaXMgMTAgYnl0ZXNcbiAgICBsZW5ndGggKz0gMTA7XG5cbiAgICBjb25zdCBzaXplID0gcmVhZFNpemUoZGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgbGVuZ3RoICs9IHNpemU7XG5cbiAgICBpZiAoaXNGb290ZXIoZGF0YSwgb2Zmc2V0ICsgMTApKSB7XG4gICAgICAvLyBJRDMgZm9vdGVyIGlzIDEwIGJ5dGVzXG4gICAgICBsZW5ndGggKz0gMTA7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgfVxuXG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGRhdGEuc3ViYXJyYXkoZnJvbnQsIGZyb250ICsgbGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCByZWFkU2l6ZSA9IChkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciA9PiB7XG4gIGxldCBzaXplID0gMDtcbiAgc2l6ZSA9IChkYXRhW29mZnNldF0gJiAweDdmKSA8PCAyMTtcbiAgc2l6ZSB8PSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4N2YpIDw8IDE0O1xuICBzaXplIHw9IChkYXRhW29mZnNldCArIDJdICYgMHg3ZikgPDwgNztcbiAgc2l6ZSB8PSBkYXRhW29mZnNldCArIDNdICYgMHg3ZjtcbiAgcmV0dXJuIHNpemU7XG59O1xuXG5leHBvcnQgY29uc3QgY2FuUGFyc2UgPSAoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIChcbiAgICBpc0hlYWRlcihkYXRhLCBvZmZzZXQpICYmXG4gICAgcmVhZFNpemUoZGF0YSwgb2Zmc2V0ICsgNikgKyAxMCA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldFxuICApO1xufTtcblxuLyoqXG4gKiBTZWFyY2hlcyBmb3IgdGhlIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmb3VuZCBpbiB0aGUgSUQzIGRhdGEgY2h1bmtcbiAqIEBwYXJhbSBkYXRhIC0gQmxvY2sgb2YgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUaW1lU3RhbXAgPSAoZGF0YTogVWludDhBcnJheSk6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGZyYW1lczogRnJhbWVbXSA9IGdldElEM0ZyYW1lcyhkYXRhKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzW2ldO1xuXG4gICAgaWYgKGlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICByZXR1cm4gcmVhZFRpbWVTdGFtcChmcmFtZSBhcyBEZWNvZGVkRnJhbWU8QXJyYXlCdWZmZXI+KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIElEMyBmcmFtZSBpcyBhbiBFbGVtZW50YXJ5IFN0cmVhbSB0aW1lc3RhbXAgZnJhbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGlzVGltZVN0YW1wRnJhbWUgPSAoZnJhbWU6IEZyYW1lKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiAoXG4gICAgZnJhbWUgJiZcbiAgICBmcmFtZS5rZXkgPT09ICdQUklWJyAmJlxuICAgIGZyYW1lLmluZm8gPT09ICdjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcCdcbiAgKTtcbn07XG5cbmNvbnN0IGdldEZyYW1lRGF0YSA9IChkYXRhOiBVaW50OEFycmF5KTogUmF3RnJhbWUgPT4ge1xuICAvKlxuICBGcmFtZSBJRCAgICAgICAkeHggeHggeHggeHggKGZvdXIgY2hhcmFjdGVycylcbiAgU2l6ZSAgICAgICAgICAgJHh4IHh4IHh4IHh4XG4gIEZsYWdzICAgICAgICAgICR4eCB4eFxuICAqL1xuICBjb25zdCB0eXBlOiBzdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10pO1xuICBjb25zdCBzaXplOiBudW1iZXIgPSByZWFkU2l6ZShkYXRhLCA0KTtcblxuICAvLyBza2lwIGZyYW1lIGlkLCBzaXplLCBhbmQgZmxhZ3NcbiAgY29uc3Qgb2Zmc2V0ID0gMTA7XG5cbiAgcmV0dXJuIHsgdHlwZSwgc2l6ZSwgZGF0YTogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgSUQzIGZyYW1lcyBmb3VuZCBpbiBhbGwgdGhlIElEMyB0YWdzIGluIHRoZSBpZDNEYXRhXG4gKiBAcGFyYW0gaWQzRGF0YSAtIFRoZSBJRDMgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJRDNGcmFtZXMgPSAoaWQzRGF0YTogVWludDhBcnJheSk6IEZyYW1lW10gPT4ge1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgZnJhbWVzOiBGcmFtZVtdID0gW107XG5cbiAgd2hpbGUgKGlzSGVhZGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICBjb25zdCBzaXplID0gcmVhZFNpemUoaWQzRGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgLy8gc2tpcCBwYXN0IElEMyBoZWFkZXJcbiAgICBvZmZzZXQgKz0gMTA7XG4gICAgY29uc3QgZW5kID0gb2Zmc2V0ICsgc2l6ZTtcbiAgICAvLyBsb29wIHRocm91Z2ggZnJhbWVzIGluIHRoZSBJRDMgdGFnXG4gICAgd2hpbGUgKG9mZnNldCArIDggPCBlbmQpIHtcbiAgICAgIGNvbnN0IGZyYW1lRGF0YTogUmF3RnJhbWUgPSBnZXRGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgIGNvbnN0IGZyYW1lOiBGcmFtZSB8IHVuZGVmaW5lZCA9IGRlY29kZUZyYW1lKGZyYW1lRGF0YSk7XG4gICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBza2lwIGZyYW1lIGhlYWRlciBhbmQgZnJhbWUgZGF0YVxuICAgICAgb2Zmc2V0ICs9IGZyYW1lRGF0YS5zaXplICsgMTA7XG4gICAgfVxuXG4gICAgaWYgKGlzRm9vdGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgIG9mZnNldCArPSAxMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnJhbWVzO1xufTtcblxuZXhwb3J0IGNvbnN0IGRlY29kZUZyYW1lID0gKGZyYW1lOiBSYXdGcmFtZSk6IEZyYW1lIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgIHJldHVybiBkZWNvZGVQcml2RnJhbWUoZnJhbWUpO1xuICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdXJykge1xuICAgIHJldHVybiBkZWNvZGVVUkxGcmFtZShmcmFtZSk7XG4gIH1cblxuICByZXR1cm4gZGVjb2RlVGV4dEZyYW1lKGZyYW1lKTtcbn07XG5cbmNvbnN0IGRlY29kZVByaXZGcmFtZSA9IChcbiAgZnJhbWU6IFJhd0ZyYW1lXG4pOiBEZWNvZGVkRnJhbWU8QXJyYXlCdWZmZXI+IHwgdW5kZWZpbmVkID0+IHtcbiAgLypcbiAgRm9ybWF0OiA8dGV4dCBzdHJpbmc+XFwwPGJpbmFyeSBkYXRhPlxuICAqL1xuICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3Qgb3duZXIgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLCB0cnVlKTtcbiAgY29uc3QgcHJpdmF0ZURhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZS5kYXRhLnN1YmFycmF5KG93bmVyLmxlbmd0aCArIDEpKTtcblxuICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGluZm86IG93bmVyLCBkYXRhOiBwcml2YXRlRGF0YS5idWZmZXIgfTtcbn07XG5cbmNvbnN0IGRlY29kZVRleHRGcmFtZSA9IChmcmFtZTogUmF3RnJhbWUpOiBEZWNvZGVkRnJhbWU8c3RyaW5nPiB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoZnJhbWUudHlwZSA9PT0gJ1RYWFgnKSB7XG4gICAgLypcbiAgICBGb3JtYXQ6XG4gICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VmFsdWV9XG4gICAgKi9cbiAgICBsZXQgaW5kZXggPSAxO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCksIHRydWUpO1xuXG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICBjb25zdCB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcblxuICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgaW5mbzogZGVzY3JpcHRpb24sIGRhdGE6IHZhbHVlIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICBbMS0/XSA9IHtWYWx1ZX1cbiAgKi9cbiAgY29uc3QgdGV4dCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkpO1xuICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGRhdGE6IHRleHQgfTtcbn07XG5cbmNvbnN0IGRlY29kZVVSTEZyYW1lID0gKGZyYW1lOiBSYXdGcmFtZSk6IERlY29kZWRGcmFtZTxzdHJpbmc+IHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKGZyYW1lLnR5cGUgPT09ICdXWFhYJykge1xuICAgIC8qXG4gICAgRm9ybWF0OlxuICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgWzEtP10gPSB7RGVzY3JpcHRpb259XFwwe1VSTH1cbiAgICAqL1xuICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBsZXQgaW5kZXggPSAxO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uOiBzdHJpbmcgPSB1dGY4QXJyYXlUb1N0cihcbiAgICAgIGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpLFxuICAgICAgdHJ1ZVxuICAgICk7XG5cbiAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHZhbHVlOiBzdHJpbmcgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG5cbiAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGluZm86IGRlc2NyaXB0aW9uLCBkYXRhOiB2YWx1ZSB9O1xuICB9XG4gIC8qXG4gIEZvcm1hdDpcbiAgWzAtP10gPSB7VVJMfVxuICAqL1xuICBjb25zdCB1cmw6IHN0cmluZyA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xuICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGRhdGE6IHVybCB9O1xufTtcblxuY29uc3QgcmVhZFRpbWVTdGFtcCA9IChcbiAgdGltZVN0YW1wRnJhbWU6IERlY29kZWRGcmFtZTxBcnJheUJ1ZmZlcj5cbik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh0aW1lU3RhbXBGcmFtZS5kYXRhLmJ5dGVMZW5ndGggPT09IDgpIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGltZVN0YW1wRnJhbWUuZGF0YSk7XG4gICAgLy8gdGltZXN0YW1wIGlzIDMzIGJpdCBleHByZXNzZWQgYXMgYSBiaWctZW5kaWFuIGVpZ2h0LW9jdGV0IG51bWJlcixcbiAgICAvLyB3aXRoIHRoZSB1cHBlciAzMSBiaXRzIHNldCB0byB6ZXJvLlxuICAgIGNvbnN0IHB0czMzQml0ID0gZGF0YVszXSAmIDB4MTtcbiAgICBsZXQgdGltZXN0YW1wID1cbiAgICAgIChkYXRhWzRdIDw8IDIzKSArIChkYXRhWzVdIDw8IDE1KSArIChkYXRhWzZdIDw8IDcpICsgZGF0YVs3XTtcbiAgICB0aW1lc3RhbXAgLz0gNDU7XG5cbiAgICBpZiAocHRzMzNCaXQpIHtcbiAgICAgIHRpbWVzdGFtcCArPSA0NzcyMTg1OC44NDtcbiAgICB9IC8vIDJeMzIgLyA5MFxuXG4gICAgcmV0dXJuIE1hdGgucm91bmQodGltZXN0YW1wKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg5MzY5ODQvdWludDhhcnJheS10by1zdHJpbmctaW4tamF2YXNjcmlwdC8yMjM3MzE5N1xuLy8gaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L3V0Zi50eHRcbi8qIHV0Zi5qcyAtIFVURi04IDw9PiBVVEYtMTYgY29udmVydGlvblxuICpcbiAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gKiBWZXJzaW9uOiAxLjBcbiAqIExhc3RNb2RpZmllZDogRGVjIDI1IDE5OTlcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAqL1xuZXhwb3J0IGNvbnN0IHV0ZjhBcnJheVRvU3RyID0gKFxuICBhcnJheTogVWludDhBcnJheSxcbiAgZXhpdE9uTnVsbDogYm9vbGVhbiA9IGZhbHNlXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZ2V0VGV4dERlY29kZXIoKTtcbiAgaWYgKGRlY29kZXIpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoYXJyYXkpO1xuXG4gICAgaWYgKGV4aXRPbk51bGwpIHtcbiAgICAgIC8vIGdyYWIgdXAgdG8gdGhlIGZpcnN0IG51bGxcbiAgICAgIGNvbnN0IGlkeCA9IGRlY29kZWQuaW5kZXhPZignXFwwJyk7XG4gICAgICByZXR1cm4gaWR4ICE9PSAtMSA/IGRlY29kZWQuc3Vic3RyaW5nKDAsIGlkeCkgOiBkZWNvZGVkO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbnkgbnVsbCBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIGRlY29kZWQucmVwbGFjZSgvXFwwL2csICcnKTtcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgbGV0IGM7XG4gIGxldCBjaGFyMjtcbiAgbGV0IGNoYXIzO1xuICBsZXQgb3V0ID0gJyc7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBjID0gYXJyYXlbaSsrXTtcbiAgICBpZiAoYyA9PT0gMHgwMCAmJiBleGl0T25OdWxsKSB7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gMHgwMCB8fCBjID09PSAweDAzKSB7XG4gICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIDMgKEVORF9PRl9URVhUKSBvciAwIChOVUxMKSB0aGVuIHNraXAgaXRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGMgPj4gNCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxOlxuICAgICAgY2FzZSAyOlxuICAgICAgY2FzZSAzOlxuICAgICAgY2FzZSA0OlxuICAgICAgY2FzZSA1OlxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA3OlxuICAgICAgICAvLyAweHh4eHh4eFxuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyOlxuICAgICAgY2FzZSAxMzpcbiAgICAgICAgLy8gMTEweCB4eHh4ICAgMTB4eCB4eHh4XG4gICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMHgxZikgPDwgNikgfCAoY2hhcjIgJiAweDNmKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxNDpcbiAgICAgICAgLy8gMTExMCB4eHh4ICAxMHh4IHh4eHggIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIGNoYXIzID0gYXJyYXlbaSsrXTtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgICAgKChjICYgMHgwZikgPDwgMTIpIHwgKChjaGFyMiAmIDB4M2YpIDw8IDYpIHwgKChjaGFyMyAmIDB4M2YpIDw8IDApXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbmV4cG9ydCBjb25zdCB0ZXN0YWJsZXMgPSB7XG4gIGRlY29kZVRleHRGcmFtZTogZGVjb2RlVGV4dEZyYW1lLFxufTtcblxubGV0IGRlY29kZXI6IFRleHREZWNvZGVyO1xuXG5mdW5jdGlvbiBnZXRUZXh0RGVjb2RlcigpIHtcbiAgaWYgKCFkZWNvZGVyICYmIHR5cGVvZiBzZWxmLlRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRlY29kZXIgPSBuZXcgc2VsZi5UZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVyO1xufVxuIiwiLyoqXG4gKiAgaGV4IGR1bXAgaGVscGVyIGNsYXNzXG4gKi9cblxuY29uc3QgSGV4ID0ge1xuICBoZXhEdW1wOiBmdW5jdGlvbiAoYXJyYXk6IFVpbnQ4QXJyYXkpIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGggPSBhcnJheVtpXS50b1N0cmluZygxNik7XG4gICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgfVxuXG4gICAgICBzdHIgKz0gaDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhleDtcbiIsImltcG9ydCB7IEVsZW1lbnRhcnlTdHJlYW1UeXBlcyB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgeyBzbGljZVVpbnQ4IH0gZnJvbSAnLi90eXBlZC1hcnJheSc7XG5pbXBvcnQgeyB1dGY4QXJyYXlUb1N0ciB9IGZyb20gJy4uL2RlbXV4L2lkMyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IEhleCBmcm9tICcuL2hleCc7XG5pbXBvcnQgdHlwZSB7IFBhc3N0aHJvdWdoVHJhY2ssIFVzZXJkYXRhU2FtcGxlIH0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5pbXBvcnQgdHlwZSB7IERlY3J5cHREYXRhIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWtleSc7XG5cbmNvbnN0IFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuY29uc3QgcHVzaCA9IFtdLnB1c2g7XG5cbi8vIFdlIGFyZSB1c2luZyBmaXhlZCB0cmFjayBJRHMgZm9yIGRyaXZpbmcgdGhlIE1QNCByZW11eGVyXG4vLyBpbnN0ZWFkIG9mIGZvbGxvd2luZyB0aGUgVFMgUElEcy5cbi8vIFRoZXJlIGlzIG5vIHJlYXNvbiBub3QgdG8gZG8gdGhpcyBhbmQgc29tZSBicm93c2Vycy9Tb3VyY2VCdWZmZXItZGVtdXhlcnNcbi8vIG1heSBub3QgbGlrZSBpZiB0aGVyZSBhcmUgVHJhY2tJRCBcInN3aXRjaGVzXCJcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMTMzMVxuLy8gSGVyZSB3ZSBhcmUgbWFwcGluZyBvdXIgaW50ZXJuYWwgdHJhY2sgdHlwZXMgdG8gY29uc3RhbnQgTVA0IHRyYWNrIElEc1xuLy8gV2l0aCBNU0UgY3VycmVudGx5IG9uZSBjYW4gb25seSBoYXZlIG9uZSB0cmFjayBvZiBlYWNoLCBhbmQgd2UgYXJlIG11eGluZ1xuLy8gd2hhdGV2ZXIgdmlkZW8vYXVkaW8gcmVuZGl0aW9uIGluIHRoZW0uXG5leHBvcnQgY29uc3QgUmVtdXhlclRyYWNrSWRDb25maWcgPSB7XG4gIHZpZGVvOiAxLFxuICBhdWRpbzogMixcbiAgaWQzOiAzLFxuICB0ZXh0OiA0LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJpbjJzdHIoZGF0YTogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFVpbnQxNihidWZmZXI6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgdmFsID0gKGJ1ZmZlcltvZmZzZXRdIDw8IDgpIHwgYnVmZmVyW29mZnNldCArIDFdO1xuICByZXR1cm4gdmFsIDwgMCA/IDY1NTM2ICsgdmFsIDogdmFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFVpbnQzMihidWZmZXI6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgdmFsID0gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCk7XG4gIHJldHVybiB2YWwgPCAwID8gNDI5NDk2NzI5NiArIHZhbCA6IHZhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRTaW50MzIoYnVmZmVyOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiAoXG4gICAgKGJ1ZmZlcltvZmZzZXRdIDw8IDI0KSB8XG4gICAgKGJ1ZmZlcltvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgIChidWZmZXJbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIGJ1ZmZlcltvZmZzZXQgKyAzXVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVVaW50MzIoYnVmZmVyOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlciwgdmFsdWU6IG51bWJlcikge1xuICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlID4+IDI0O1xuICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4gMTYpICYgMHhmZjtcbiAgYnVmZmVyW29mZnNldCArIDJdID0gKHZhbHVlID4+IDgpICYgMHhmZjtcbiAgYnVmZmVyW29mZnNldCArIDNdID0gdmFsdWUgJiAweGZmO1xufVxuXG4vLyBGaW5kIHRoZSBkYXRhIGZvciBhIGJveCBzcGVjaWZpZWQgYnkgaXRzIHBhdGhcbmV4cG9ydCBmdW5jdGlvbiBmaW5kQm94KGRhdGE6IFVpbnQ4QXJyYXksIHBhdGg6IHN0cmluZ1tdKTogVWludDhBcnJheVtdIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdIGFzIFVpbnQ4QXJyYXlbXTtcbiAgaWYgKCFwYXRoLmxlbmd0aCkge1xuICAgIC8vIHNob3J0LWNpcmN1aXQgdGhlIHNlYXJjaCBmb3IgZW1wdHkgcGF0aHNcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBjb25zdCBlbmQgPSBkYXRhLmJ5dGVMZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICkge1xuICAgIGNvbnN0IHNpemUgPSByZWFkVWludDMyKGRhdGEsIGkpO1xuICAgIGNvbnN0IHR5cGUgPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkoaSArIDQsIGkgKyA4KSk7XG4gICAgY29uc3QgZW5kYm94ID0gc2l6ZSA+IDEgPyBpICsgc2l6ZSA6IGVuZDtcblxuICAgIGlmICh0eXBlID09PSBwYXRoWzBdKSB7XG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZW5kIG9mIHRoZSBwYXRoIGFuZCB3ZSd2ZSBmb3VuZCB0aGUgYm94IHdlIHdlcmVcbiAgICAgICAgLy8gbG9va2luZyBmb3JcbiAgICAgICAgcmVzdWx0cy5wdXNoKGRhdGEuc3ViYXJyYXkoaSArIDgsIGVuZGJveCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgY29uc3Qgc3VicmVzdWx0cyA9IGZpbmRCb3goZGF0YS5zdWJhcnJheShpICsgOCwgZW5kYm94KSwgcGF0aC5zbGljZSgxKSk7XG4gICAgICAgIGlmIChzdWJyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc3VicmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaSA9IGVuZGJveDtcbiAgfVxuXG4gIC8vIHdlJ3ZlIGZpbmlzaGVkIHNlYXJjaGluZyBhbGwgb2YgZGF0YVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxudHlwZSBTaWR4SW5mbyA9IHtcbiAgZWFybGllc3RQcmVzZW50YXRpb25UaW1lOiBudW1iZXI7XG4gIHRpbWVzY2FsZTogbnVtYmVyO1xuICB2ZXJzaW9uOiBudW1iZXI7XG4gIHJlZmVyZW5jZXNDb3VudDogbnVtYmVyO1xuICByZWZlcmVuY2VzOiBhbnlbXTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNlZ21lbnRJbmRleChzaWR4OiBVaW50OEFycmF5KTogU2lkeEluZm8gfCBudWxsIHtcbiAgY29uc3QgcmVmZXJlbmNlczogYW55W10gPSBbXTtcblxuICBjb25zdCB2ZXJzaW9uID0gc2lkeFswXTtcblxuICAvLyBzZXQgaW5pdGlhbCBvZmZzZXQsIHdlIHNraXAgdGhlIHJlZmVyZW5jZSBJRCAobm90IG5lZWRlZClcbiAgbGV0IGluZGV4ID0gODtcblxuICBjb25zdCB0aW1lc2NhbGUgPSByZWFkVWludDMyKHNpZHgsIGluZGV4KTtcbiAgaW5kZXggKz0gNDtcblxuICAvLyBUT0RPOiBwYXJzZSBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgYW5kIGZpcnN0T2Zmc2V0XG4gIC8vIHVzdWFsbHkgemVybyBpbiBvdXIgY2FzZVxuICBjb25zdCBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgPSAwO1xuICBjb25zdCBmaXJzdE9mZnNldCA9IDA7XG5cbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICBpbmRleCArPSA4O1xuICB9IGVsc2Uge1xuICAgIGluZGV4ICs9IDE2O1xuICB9XG5cbiAgLy8gc2tpcCByZXNlcnZlZFxuICBpbmRleCArPSAyO1xuXG4gIGxldCBzdGFydEJ5dGUgPSBzaWR4Lmxlbmd0aCArIGZpcnN0T2Zmc2V0O1xuXG4gIGNvbnN0IHJlZmVyZW5jZXNDb3VudCA9IHJlYWRVaW50MTYoc2lkeCwgaW5kZXgpO1xuICBpbmRleCArPSAyO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmZXJlbmNlc0NvdW50OyBpKyspIHtcbiAgICBsZXQgcmVmZXJlbmNlSW5kZXggPSBpbmRleDtcblxuICAgIGNvbnN0IHJlZmVyZW5jZUluZm8gPSByZWFkVWludDMyKHNpZHgsIHJlZmVyZW5jZUluZGV4KTtcbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgY29uc3QgcmVmZXJlbmNlU2l6ZSA9IHJlZmVyZW5jZUluZm8gJiAweDdmZmZmZmZmO1xuICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSAocmVmZXJlbmNlSW5mbyAmIDB4ODAwMDAwMDApID4+PiAzMTtcblxuICAgIGlmIChyZWZlcmVuY2VUeXBlID09PSAxKSB7XG4gICAgICBsb2dnZXIud2FybignU0lEWCBoYXMgaGllcmFyY2hpY2FsIHJlZmVyZW5jZXMgKG5vdCBzdXBwb3J0ZWQpJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJzZWdtZW50RHVyYXRpb24gPSByZWFkVWludDMyKHNpZHgsIHJlZmVyZW5jZUluZGV4KTtcbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgIHJlZmVyZW5jZVNpemUsXG4gICAgICBzdWJzZWdtZW50RHVyYXRpb24sIC8vIHVuc2NhbGVkXG4gICAgICBpbmZvOiB7XG4gICAgICAgIGR1cmF0aW9uOiBzdWJzZWdtZW50RHVyYXRpb24gLyB0aW1lc2NhbGUsXG4gICAgICAgIHN0YXJ0OiBzdGFydEJ5dGUsXG4gICAgICAgIGVuZDogc3RhcnRCeXRlICsgcmVmZXJlbmNlU2l6ZSAtIDEsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgc3RhcnRCeXRlICs9IHJlZmVyZW5jZVNpemU7XG5cbiAgICAvLyBTa2lwcGluZyAxIGJpdCBmb3IgfHN0YXJ0c1dpdGhTYXB8LCAzIGJpdHMgZm9yIHxzYXBUeXBlfCwgYW5kIDI4IGJpdHNcbiAgICAvLyBmb3IgfHNhcERlbHRhfC5cbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgLy8gc2tpcCB0byBuZXh0IHJlZlxuICAgIGluZGV4ID0gcmVmZXJlbmNlSW5kZXg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSxcbiAgICB0aW1lc2NhbGUsXG4gICAgdmVyc2lvbixcbiAgICByZWZlcmVuY2VzQ291bnQsXG4gICAgcmVmZXJlbmNlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gTVA0IGluaXRpYWxpemF0aW9uIHNlZ21lbnQgYW5kIGV4dHJhY3RzIHN0cmVhbSB0eXBlIGFuZFxuICogdGltZXNjYWxlIHZhbHVlcyBmb3IgYW55IGRlY2xhcmVkIHRyYWNrcy4gVGltZXNjYWxlIHZhbHVlcyBpbmRpY2F0ZSB0aGVcbiAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAqIGVsc2V3aGVyZSBpbiB0aGUgTVA0LlxuICpcbiAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAqIGluZm9ybWF0aW9uOiB0aGUgdGltZXNjYWxlIHVuaXQgYW5kIHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZVxuICogdGltZS4gTXVsdGlwbGUgdGltZXNjYWxlcyBjYW4gYmUgc3BlY2lmaWVkIHdpdGhpbiBhbiBNUDQgYnV0IHRoZVxuICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICogdGhlIG1lZGlhIGhlYWRlciBib3ggZm9yIHRoZSB0cmFjazpcbiAqIGBgYFxuICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IGhkbHJcbiAqIGBgYFxuICogQHBhcmFtIGluaXRTZWdtZW50IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gKiBAcmV0dXJucyBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcbiAqIHRoZSBpbml0IHNlZ21lbnQgaXMgbWFsZm9ybWVkLlxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdERhdGFUcmFjayB7XG4gIHRpbWVzY2FsZTogbnVtYmVyO1xuICBpZDogbnVtYmVyO1xuICBjb2RlYzogc3RyaW5nO1xufVxuXG50eXBlIEhkbHJUeXBlID0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPIHwgRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPO1xuXG5leHBvcnQgaW50ZXJmYWNlIEluaXREYXRhIGV4dGVuZHMgQXJyYXk8YW55PiB7XG4gIFtpbmRleDogbnVtYmVyXTpcbiAgICB8IHtcbiAgICAgICAgdGltZXNjYWxlOiBudW1iZXI7XG4gICAgICAgIHR5cGU6IEhkbHJUeXBlO1xuICAgICAgICBkZWZhdWx0Pzoge1xuICAgICAgICAgIGR1cmF0aW9uOiBudW1iZXI7XG4gICAgICAgICAgZmxhZ3M6IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB8IHVuZGVmaW5lZDtcbiAgYXVkaW8/OiBJbml0RGF0YVRyYWNrO1xuICB2aWRlbz86IEluaXREYXRhVHJhY2s7XG4gIGNhcHRpb24/OiBJbml0RGF0YVRyYWNrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudDogVWludDhBcnJheSk6IEluaXREYXRhIHtcbiAgY29uc3QgcmVzdWx0OiBJbml0RGF0YSA9IFtdO1xuICBjb25zdCB0cmFrcyA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWtzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdHJhayA9IHRyYWtzW2ldO1xuICAgIGNvbnN0IHRraGQgPSBmaW5kQm94KHRyYWssIFsndGtoZCddKVswXTtcbiAgICBpZiAodGtoZCkge1xuICAgICAgbGV0IHZlcnNpb24gPSB0a2hkWzBdO1xuICAgICAgbGV0IGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XG4gICAgICBjb25zdCB0cmFja0lkID0gcmVhZFVpbnQzMih0a2hkLCBpbmRleCk7XG4gICAgICBjb25zdCBtZGhkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWRoZCddKVswXTtcbiAgICAgIGlmIChtZGhkKSB7XG4gICAgICAgIHZlcnNpb24gPSBtZGhkWzBdO1xuICAgICAgICBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgICBjb25zdCB0aW1lc2NhbGUgPSByZWFkVWludDMyKG1kaGQsIGluZGV4KTtcbiAgICAgICAgY29uc3QgaGRsciA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ2hkbHInXSlbMF07XG4gICAgICAgIGlmIChoZGxyKSB7XG4gICAgICAgICAgY29uc3QgaGRsclR5cGUgPSBiaW4yc3RyKGhkbHIuc3ViYXJyYXkoOCwgMTIpKTtcbiAgICAgICAgICBjb25zdCB0eXBlOiBIZGxyVHlwZSB8IHVuZGVmaW5lZCA9IHtcbiAgICAgICAgICAgIHNvdW46IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyBhcyBjb25zdCxcbiAgICAgICAgICAgIHZpZGU6IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTyBhcyBjb25zdCxcbiAgICAgICAgICB9W2hkbHJUeXBlXTtcbiAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgLy8gUGFyc2UgY29kZWMgZGV0YWlsc1xuICAgICAgICAgICAgY29uc3Qgc3RzZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21pbmYnLCAnc3RibCcsICdzdHNkJ10pWzBdO1xuICAgICAgICAgICAgbGV0IGNvZGVjO1xuICAgICAgICAgICAgaWYgKHN0c2QpIHtcbiAgICAgICAgICAgICAgY29kZWMgPSBiaW4yc3RyKHN0c2Quc3ViYXJyYXkoMTIsIDE2KSk7XG4gICAgICAgICAgICAgIC8vIFRPRE86IFBhcnNlIGNvZGVjIGRldGFpbHMgdG8gYmUgYWJsZSB0byBidWlsZCBNSU1FIHR5cGUuXG4gICAgICAgICAgICAgIC8vIHN0c2Quc3RhcnQgKz0gODtcbiAgICAgICAgICAgICAgLy8gY29uc3QgY29kZWNCb3ggPSBmaW5kQm94KHN0c2QsIFtjb2RlY10pWzBdO1xuICAgICAgICAgICAgICAvLyBpZiAoY29kZWNCb3gpIHtcbiAgICAgICAgICAgICAgLy8gICBUT0RPOiBDb2RlYyBwYXJzaW5nIHN1cHBvcnQgZm9yIGF2YzEsIG1wNGEsIGhldmMsIGF2MDEuLi5cbiAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W3RyYWNrSWRdID0geyB0aW1lc2NhbGUsIHR5cGUgfTtcbiAgICAgICAgICAgIHJlc3VsdFt0eXBlXSA9IHsgdGltZXNjYWxlLCBpZDogdHJhY2tJZCwgY29kZWMgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB0cmV4ID0gZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ212ZXgnLCAndHJleCddKTtcbiAgdHJleC5mb3JFYWNoKCh0cmV4KSA9PiB7XG4gICAgY29uc3QgdHJhY2tJZCA9IHJlYWRVaW50MzIodHJleCwgNCk7XG4gICAgY29uc3QgdHJhY2sgPSByZXN1bHRbdHJhY2tJZF07XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5kZWZhdWx0ID0ge1xuICAgICAgICBkdXJhdGlvbjogcmVhZFVpbnQzMih0cmV4LCAxMiksXG4gICAgICAgIGZsYWdzOiByZWFkVWludDMyKHRyZXgsIDIwKSxcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hFbmN5cHRpb25EYXRhKFxuICBpbml0U2VnbWVudDogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgZGVjcnlwdGRhdGE6IERlY3J5cHREYXRhIHwgbnVsbFxuKTogVWludDhBcnJheSB8IHVuZGVmaW5lZCB7XG4gIGlmICghaW5pdFNlZ21lbnQgfHwgIWRlY3J5cHRkYXRhKSB7XG4gICAgcmV0dXJuIGluaXRTZWdtZW50O1xuICB9XG4gIGNvbnN0IGtleUlkID0gZGVjcnlwdGRhdGEua2V5SWQ7XG4gIGlmIChrZXlJZCAmJiBkZWNyeXB0ZGF0YS5pc0NvbW1vbkVuY3J5cHRpb24pIHtcbiAgICBjb25zdCB0cmFrcyA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuICAgIHRyYWtzLmZvckVhY2goKHRyYWspID0+IHtcbiAgICAgIGNvbnN0IHN0c2QgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtaW5mJywgJ3N0YmwnLCAnc3RzZCddKVswXTtcblxuICAgICAgLy8gc2tpcCB0aGUgc2FtcGxlIGVudHJ5IGNvdW50XG4gICAgICBjb25zdCBzYW1wbGVFbnRyaWVzID0gc3RzZC5zdWJhcnJheSg4KTtcbiAgICAgIGxldCBlbmNCb3hlcyA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgWydlbmNhJ10pO1xuICAgICAgY29uc3QgaXNBdWRpbyA9IGVuY0JveGVzLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoIWlzQXVkaW8pIHtcbiAgICAgICAgZW5jQm94ZXMgPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFsnZW5jdiddKTtcbiAgICAgIH1cbiAgICAgIGVuY0JveGVzLmZvckVhY2goKGVuYykgPT4ge1xuICAgICAgICBjb25zdCBlbmNCb3hDaGlsZHJlbiA9IGlzQXVkaW8gPyBlbmMuc3ViYXJyYXkoMjgpIDogZW5jLnN1YmFycmF5KDc4KTtcbiAgICAgICAgY29uc3Qgc2luZkJveGVzID0gZmluZEJveChlbmNCb3hDaGlsZHJlbiwgWydzaW5mJ10pO1xuICAgICAgICBzaW5mQm94ZXMuZm9yRWFjaCgoc2luZikgPT4ge1xuICAgICAgICAgIGNvbnN0IHRlbmMgPSBwYXJzZVNpbmYoc2luZik7XG4gICAgICAgICAgaWYgKHRlbmMpIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGRlZmF1bHQga2V5IGlkIChrZXlJRCBvZmZzZXQgaXMgYWx3YXlzIDggd2l0aGluIHRoZSB0ZW5jIGJveCk6XG4gICAgICAgICAgICBjb25zdCB0ZW5jS2V5SWQgPSB0ZW5jLnN1YmFycmF5KDgsIDI0KTtcbiAgICAgICAgICAgIGlmICghdGVuY0tleUlkLnNvbWUoKGIpID0+IGIgIT09IDApKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICAgICAgICAgYFtlbWVdIFBhdGNoaW5nIGtleUlkIGluICdlbmMke1xuICAgICAgICAgICAgICAgICAgaXNBdWRpbyA/ICdhJyA6ICd2J1xuICAgICAgICAgICAgICAgIH0+c2luZj4+dGVuYycgYm94OiAke0hleC5oZXhEdW1wKHRlbmNLZXlJZCl9IC0+ICR7SGV4LmhleER1bXAoXG4gICAgICAgICAgICAgICAgICBrZXlJZFxuICAgICAgICAgICAgICAgICl9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0ZW5jLnNldChrZXlJZCwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGluaXRTZWdtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTaW5mKHNpbmY6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHwgbnVsbCB7XG4gIGNvbnN0IHNjaG0gPSBmaW5kQm94KHNpbmYsIFsnc2NobSddKVswXTtcbiAgaWYgKHNjaG0pIHtcbiAgICBjb25zdCBzY2hlbWUgPSBiaW4yc3RyKHNjaG0uc3ViYXJyYXkoNCwgOCkpO1xuICAgIGlmIChzY2hlbWUgPT09ICdjYmNzJyB8fCBzY2hlbWUgPT09ICdjZW5jJykge1xuICAgICAgcmV0dXJuIGZpbmRCb3goc2luZiwgWydzY2hpJywgJ3RlbmMnXSlbMF07XG4gICAgfVxuICB9XG4gIGxvZ2dlci5lcnJvcihgW2VtZV0gbWlzc2luZyAnc2NobScgYm94YCk7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERldGVybWluZSB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSwgaW4gc2Vjb25kcywgZm9yIGFuIE1QNFxuICogZnJhZ21lbnQuIElmIG11bHRpcGxlIGZyYWdtZW50cyBhcmUgc3BlY2lmaWVkLCB0aGUgZWFybGllc3QgdGltZSBpc1xuICogcmV0dXJuZWQuXG4gKlxuICogVGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgY2FuIGJlIHBhcnNlZCBmcm9tIHRyYWNrIGZyYWdtZW50XG4gKiBtZXRhZGF0YTpcbiAqIGBgYFxuICogbW9vZiA+IHRyYWYgPiB0ZmR0LmJhc2VNZWRpYURlY29kZVRpbWVcbiAqIGBgYFxuICogSXQgcmVxdWlyZXMgdGhlIHRpbWVzY2FsZSB2YWx1ZSBmcm9tIHRoZSBtZGhkIHRvIGludGVycHJldC5cbiAqXG4gKiBAcGFyYW0gaW5pdERhdGEgLSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzXG4gKiBAcGFyYW0gZm1wNCAtIHRoZSBieXRlcyBvZiB0aGUgbXA0IGZyYWdtZW50XG4gKiBAcmV0dXJucyB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSBmb3IgdGhlXG4gKiBmcmFnbWVudCwgaW4gc2Vjb25kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhcnREVFMoXG4gIGluaXREYXRhOiBJbml0RGF0YSxcbiAgZm1wNDogVWludDhBcnJheVxuKTogbnVtYmVyIHwgbnVsbCB7XG4gIC8vIHdlIG5lZWQgaW5mbyBmcm9tIHR3byBjaGlsZHJlbiBvZiBlYWNoIHRyYWNrIGZyYWdtZW50IGJveFxuICByZXR1cm4gZmluZEJveChmbXA0LCBbJ21vb2YnLCAndHJhZiddKS5yZWR1Y2UoXG4gICAgKHJlc3VsdDogbnVtYmVyIHwgbnVsbCwgdHJhZikgPT4ge1xuICAgICAgY29uc3QgdGZkdCA9IGZpbmRCb3godHJhZiwgWyd0ZmR0J10pWzBdO1xuICAgICAgY29uc3QgdmVyc2lvbiA9IHRmZHRbMF07XG4gICAgICBjb25zdCBzdGFydCA9IGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLnJlZHVjZShcbiAgICAgICAgKHJlc3VsdDogbnVtYmVyIHwgbnVsbCwgdGZoZCkgPT4ge1xuICAgICAgICAgIC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuICAgICAgICAgIGNvbnN0IGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgICAgICBjb25zdCB0cmFjayA9IGluaXREYXRhW2lkXTtcbiAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxldCBiYXNlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyB0b28gbGFyZ2UsIGFzc3VtZSBzaWduZWQgNjQtYml0LiBOZWdhdGl2ZSB0cmFjayBmcmFnbWVudCBkZWNvZGUgdGltZXMgYXJlIGludmFsaWQsIGJ1dCB0aGV5IGV4aXN0IGluIHRoZSB3aWxkLlxuICAgICAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGxhcmdlIHZhbHVlcyBmcm9tIGJlaW5nIHVzZWQgZm9yIGluaXRQVFMsIHdoaWNoIGNhbiBjYXVzZSBwbGF5bGlzdCBzeW5jIGlzc3Vlcy5cbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzUzMDNcbiAgICAgICAgICAgICAgaWYgKGJhc2VUaW1lID09PSBVSU5UMzJfTUFYKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgICBgW21wNC1kZW11eGVyXTogSWdub3JpbmcgYXNzdW1lZCBpbnZhbGlkIHNpZ25lZCA2NC1iaXQgdHJhY2sgZnJhZ21lbnQgZGVjb2RlIHRpbWVgXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJhc2VUaW1lICo9IFVJTlQzMl9NQVggKyAxO1xuICAgICAgICAgICAgICBiYXNlVGltZSArPSByZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGJhc2UgdGltZSB0byBzZWNvbmRzXG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBiYXNlVGltZSAvIHNjYWxlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBpc0Zpbml0ZShzdGFydFRpbWUpICYmXG4gICAgICAgICAgICAgIChyZXN1bHQgPT09IG51bGwgfHwgc3RhcnRUaW1lIDwgcmVzdWx0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdGFydFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXJ0ICE9PSBudWxsICYmXG4gICAgICAgIGlzRmluaXRlKHN0YXJ0KSAmJlxuICAgICAgICAocmVzdWx0ID09PSBudWxsIHx8IHN0YXJ0IDwgcmVzdWx0KVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBudWxsXG4gICk7XG59XG5cbi8qXG4gIEZvciBSZWZlcmVuY2U6XG4gIGFsaWduZWQoOCkgY2xhc3MgVHJhY2tGcmFnbWVudEhlYWRlckJveFxuICAgICAgICAgICBleHRlbmRzIEZ1bGxCb3go4oCYdGZoZOKAmSwgMCwgdGZfZmxhZ3Mpe1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICB0cmFja19JRDtcbiAgICAgLy8gYWxsIHRoZSBmb2xsb3dpbmcgYXJlIG9wdGlvbmFsIGZpZWxkc1xuICAgICB1bnNpZ25lZCBpbnQoNjQpICBiYXNlX2RhdGFfb2Zmc2V0O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZGVzY3JpcHRpb25faW5kZXg7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uO1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9zaXplO1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREdXJhdGlvbihkYXRhOiBVaW50OEFycmF5LCBpbml0RGF0YTogSW5pdERhdGEpIHtcbiAgbGV0IHJhd0R1cmF0aW9uID0gMDtcbiAgbGV0IHZpZGVvRHVyYXRpb24gPSAwO1xuICBsZXQgYXVkaW9EdXJhdGlvbiA9IDA7XG4gIGNvbnN0IHRyYWZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnLCAndHJhZiddKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWYgPSB0cmFmc1tpXTtcbiAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSB0ZmhkICYgdHJ1biBwZXIgdHJhZlxuICAgIC8vIFRoaXMgaXMgdHJ1ZSBmb3IgQ01BRiBzdHlsZSBjb250ZW50LCBhbmQgd2Ugc2hvdWxkIHBlcmhhcHMgY2hlY2sgdGhlIGZ0eXBcbiAgICAvLyBhbmQgb25seSBsb29rIGZvciBhIHNpbmdsZSB0cnVuIHRoZW4sIGJ1dCBmb3IgSVNPQk1GRiB3ZSBzaG91bGQgY2hlY2tcbiAgICAvLyBmb3IgbXVsdGlwbGUgdHJhY2sgcnVucy5cbiAgICBjb25zdCB0ZmhkID0gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSlbMF07XG4gICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgY29uc3QgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgIGNvbnN0IHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgIGlmICghdHJhY2spIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0cmFja0RlZmF1bHQgPSB0cmFjay5kZWZhdWx0O1xuICAgIGNvbnN0IHRmaGRGbGFncyA9IHJlYWRVaW50MzIodGZoZCwgMCkgfCB0cmFja0RlZmF1bHQ/LmZsYWdzITtcbiAgICBsZXQgc2FtcGxlRHVyYXRpb246IG51bWJlciB8IHVuZGVmaW5lZCA9IHRyYWNrRGVmYXVsdD8uZHVyYXRpb247XG4gICAgaWYgKHRmaGRGbGFncyAmIDB4MDAwMDA4KSB7XG4gICAgICAvLyAweDAwMDAwOCBpbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIHRoZSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiBmaWVsZFxuICAgICAgaWYgKHRmaGRGbGFncyAmIDB4MDAwMDAyKSB7XG4gICAgICAgIC8vIDB4MDAwMDAyIGluZGljYXRlcyB0aGUgcHJlc2VuY2Ugb2YgdGhlIHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCBmaWVsZCwgd2hpY2ggcHJlY2VkZXMgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cbiAgICAgICAgLy8gSWYgcHJlc2VudCwgdGhlIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uIGV4aXN0cyBhdCBieXRlIG9mZnNldCAxMlxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgMTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgZHVyYXRpb24gaXMgYXQgYnl0ZSBvZmZzZXQgOFxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgOCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgY29uc3QgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgY29uc3QgdHJ1bnMgPSBmaW5kQm94KHRyYWYsIFsndHJ1biddKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRydW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICByYXdEdXJhdGlvbiA9IGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzKHRydW5zW2pdKTtcbiAgICAgIGlmICghcmF3RHVyYXRpb24gJiYgc2FtcGxlRHVyYXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW5zW2pdLCA0KTtcbiAgICAgICAgcmF3RHVyYXRpb24gPSBzYW1wbGVEdXJhdGlvbiAqIHNhbXBsZUNvdW50O1xuICAgICAgfVxuICAgICAgaWYgKHRyYWNrLnR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTykge1xuICAgICAgICB2aWRlb0R1cmF0aW9uICs9IHJhd0R1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay50eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pIHtcbiAgICAgICAgYXVkaW9EdXJhdGlvbiArPSByYXdEdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZpZGVvRHVyYXRpb24gPT09IDAgJiYgYXVkaW9EdXJhdGlvbiA9PT0gMCkge1xuICAgIC8vIElmIGR1cmF0aW9uIHNhbXBsZXMgYXJlIG5vdCBhdmFpbGFibGUgaW4gdGhlIHRyYWYgdXNlIHNpZHggc3Vic2VnbWVudF9kdXJhdGlvblxuICAgIGxldCBzaWR4RHVyYXRpb24gPSAwO1xuICAgIGNvbnN0IHNpZHhzID0gZmluZEJveChkYXRhLCBbJ3NpZHgnXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWR4cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2lkeCA9IHBhcnNlU2VnbWVudEluZGV4KHNpZHhzW2ldKTtcbiAgICAgIGlmIChzaWR4Py5yZWZlcmVuY2VzKSB7XG4gICAgICAgIHNpZHhEdXJhdGlvbiArPSBzaWR4LnJlZmVyZW5jZXMucmVkdWNlKFxuICAgICAgICAgIChkdXIsIHJlZikgPT4gZHVyICsgcmVmLmluZm8uZHVyYXRpb24gfHwgMCxcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZHhEdXJhdGlvbjtcbiAgfVxuICBpZiAodmlkZW9EdXJhdGlvbikge1xuICAgIHJldHVybiB2aWRlb0R1cmF0aW9uO1xuICB9XG4gIHJldHVybiBhdWRpb0R1cmF0aW9uO1xufVxuXG4vKlxuICBGb3IgUmVmZXJlbmNlOlxuICBhbGlnbmVkKDgpIGNsYXNzIFRyYWNrUnVuQm94XG4gICAgICAgICAgIGV4dGVuZHMgRnVsbEJveCjigJh0cnVu4oCZLCB2ZXJzaW9uLCB0cl9mbGFncykge1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfY291bnQ7XG4gICAgIC8vIHRoZSBmb2xsb3dpbmcgYXJlIG9wdGlvbmFsIGZpZWxkc1xuICAgICBzaWduZWQgaW50KDMyKSBkYXRhX29mZnNldDtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZmlyc3Rfc2FtcGxlX2ZsYWdzO1xuICAgICAvLyBhbGwgZmllbGRzIGluIHRoZSBmb2xsb3dpbmcgYXJyYXkgYXJlIG9wdGlvbmFsXG4gICAgIHtcbiAgICAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2R1cmF0aW9uO1xuICAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfc2l6ZTtcbiAgICAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2ZsYWdzXG4gICAgICAgIGlmICh2ZXJzaW9uID09IDApXG4gICAgICAgICAgIHsgdW5zaWduZWQgaW50KDMyKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgIHsgc2lnbmVkIGludCgzMilcbiAgICAgfVsgc2FtcGxlX2NvdW50IF1cbiAgfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVJhd0R1cmF0aW9uRnJvbVNhbXBsZXModHJ1bik6IG51bWJlciB7XG4gIGNvbnN0IGZsYWdzID0gcmVhZFVpbnQzMih0cnVuLCAwKTtcbiAgLy8gRmxhZ3MgYXJlIGF0IG9mZnNldCAwLCBub24tb3B0aW9uYWwgc2FtcGxlX2NvdW50IGlzIGF0IG9mZnNldCA0LiBUaGVyZWZvcmUgd2Ugc3RhcnQgOCBieXRlcyBpbi5cbiAgLy8gRWFjaCBmaWVsZCBpcyBhbiBpbnQzMiwgd2hpY2ggaXMgNCBieXRlc1xuICBsZXQgb2Zmc2V0ID0gODtcbiAgLy8gZGF0YS1vZmZzZXQtcHJlc2VudCBmbGFnXG4gIGlmIChmbGFncyAmIDB4MDAwMDAxKSB7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gIH1cbiAgLy8gZmlyc3Qtc2FtcGxlLWZsYWdzLXByZXNlbnQgZmxhZ1xuICBpZiAoZmxhZ3MgJiAweDAwMDAwNCkge1xuICAgIG9mZnNldCArPSA0O1xuICB9XG5cbiAgbGV0IGR1cmF0aW9uID0gMDtcbiAgY29uc3Qgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW4sIDQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZUNvdW50OyBpKyspIHtcbiAgICAvLyBzYW1wbGUtZHVyYXRpb24tcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDAxMDApIHtcbiAgICAgIGNvbnN0IHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0cnVuLCBvZmZzZXQpO1xuICAgICAgZHVyYXRpb24gKz0gc2FtcGxlRHVyYXRpb247XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG4gICAgLy8gc2FtcGxlLXNpemUtcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDAyMDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgICAvLyBzYW1wbGUtZmxhZ3MtcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDA0MDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgICAvLyBzYW1wbGUtY29tcG9zaXRpb24tdGltZS1vZmZzZXRzLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwODAwKSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR1cmF0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2Zmc2V0U3RhcnREVFMoXG4gIGluaXREYXRhOiBJbml0RGF0YSxcbiAgZm1wNDogVWludDhBcnJheSxcbiAgdGltZU9mZnNldDogbnVtYmVyXG4pIHtcbiAgZmluZEJveChmbXA0LCBbJ21vb2YnLCAndHJhZiddKS5mb3JFYWNoKCh0cmFmKSA9PiB7XG4gICAgZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkuZm9yRWFjaCgodGZoZCkgPT4ge1xuICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICBjb25zdCBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICBjb25zdCB0cmFjayA9IGluaXREYXRhW2lkXTtcbiAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcbiAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzO1xuICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcbiAgICAgIGZpbmRCb3godHJhZiwgWyd0ZmR0J10pLmZvckVhY2goKHRmZHQpID0+IHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRmZHRbMF07XG4gICAgICAgIGxldCBiYXNlTWVkaWFEZWNvZGVUaW1lID0gcmVhZFVpbnQzMih0ZmR0LCA0KTtcblxuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgLT0gdGltZU9mZnNldCAqIHRpbWVzY2FsZTtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5tYXgoYmFzZU1lZGlhRGVjb2RlVGltZSwgMCk7XG4gICAgICAgICAgd3JpdGVVaW50MzIodGZkdCwgNCwgYmFzZU1lZGlhRGVjb2RlVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSArPSByZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgLT0gdGltZU9mZnNldCAqIHRpbWVzY2FsZTtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5tYXgoYmFzZU1lZGlhRGVjb2RlVGltZSwgMCk7XG4gICAgICAgICAgY29uc3QgdXBwZXIgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgICAgICBjb25zdCBsb3dlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDQsIHVwcGVyKTtcbiAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA4LCBsb3dlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gVE9ETzogQ2hlY2sgaWYgdGhlIGxhc3QgbW9vZittZGF0IHBhaXIgaXMgcGFydCBvZiB0aGUgdmFsaWQgcmFuZ2VcbmV4cG9ydCBmdW5jdGlvbiBzZWdtZW50VmFsaWRSYW5nZShkYXRhOiBVaW50OEFycmF5KTogU2VnbWVudGVkUmFuZ2Uge1xuICBjb25zdCBzZWdtZW50ZWRSYW5nZTogU2VnbWVudGVkUmFuZ2UgPSB7XG4gICAgdmFsaWQ6IG51bGwsXG4gICAgcmVtYWluZGVyOiBudWxsLFxuICB9O1xuXG4gIGNvbnN0IG1vb2ZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnXSk7XG4gIGlmICghbW9vZnMpIHtcbiAgICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG4gIH0gZWxzZSBpZiAobW9vZnMubGVuZ3RoIDwgMikge1xuICAgIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IGRhdGE7XG4gICAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBtb29mc1ttb29mcy5sZW5ndGggLSAxXTtcbiAgLy8gT2Zmc2V0IGJ5IDggYnl0ZXM7IGZpbmRCb3ggb2Zmc2V0cyB0aGUgc3RhcnQgYnkgYXMgbXVjaFxuICBzZWdtZW50ZWRSYW5nZS52YWxpZCA9IHNsaWNlVWludDgoZGF0YSwgMCwgbGFzdC5ieXRlT2Zmc2V0IC0gOCk7XG4gIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IHNsaWNlVWludDgoZGF0YSwgbGFzdC5ieXRlT2Zmc2V0IC0gOCk7XG4gIHJldHVybiBzZWdtZW50ZWRSYW5nZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWdtZW50ZWRSYW5nZSB7XG4gIHZhbGlkOiBVaW50OEFycmF5IHwgbnVsbDtcbiAgcmVtYWluZGVyOiBVaW50OEFycmF5IHwgbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZFVpbnQ4QXJyYXkoXG4gIGRhdGExOiBVaW50OEFycmF5LFxuICBkYXRhMjogVWludDhBcnJheVxuKTogVWludDhBcnJheSB7XG4gIGNvbnN0IHRlbXAgPSBuZXcgVWludDhBcnJheShkYXRhMS5sZW5ndGggKyBkYXRhMi5sZW5ndGgpO1xuICB0ZW1wLnNldChkYXRhMSk7XG4gIHRlbXAuc2V0KGRhdGEyLCBkYXRhMS5sZW5ndGgpO1xuXG4gIHJldHVybiB0ZW1wO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElFbXNnUGFyc2luZ0RhdGEge1xuICBzY2hlbWVJZFVyaTogc3RyaW5nO1xuICB2YWx1ZTogc3RyaW5nO1xuICB0aW1lU2NhbGU6IG51bWJlcjtcbiAgcHJlc2VudGF0aW9uVGltZURlbHRhPzogbnVtYmVyO1xuICBwcmVzZW50YXRpb25UaW1lPzogbnVtYmVyO1xuICBldmVudER1cmF0aW9uOiBudW1iZXI7XG4gIGlkOiBudW1iZXI7XG4gIHBheWxvYWQ6IFVpbnQ4QXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNhbXBsZXMoXG4gIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgdHJhY2s6IFBhc3N0aHJvdWdoVHJhY2tcbik6IFVzZXJkYXRhU2FtcGxlW10ge1xuICBjb25zdCBzZWlTYW1wbGVzID0gW10gYXMgVXNlcmRhdGFTYW1wbGVbXTtcbiAgY29uc3QgdmlkZW9EYXRhID0gdHJhY2suc2FtcGxlcztcbiAgY29uc3QgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlO1xuICBjb25zdCB0cmFja0lkID0gdHJhY2suaWQ7XG4gIGxldCBpc0hFVkNGbGF2b3IgPSBmYWxzZTtcblxuICBjb25zdCBtb29mcyA9IGZpbmRCb3godmlkZW9EYXRhLCBbJ21vb2YnXSk7XG4gIG1vb2ZzLm1hcCgobW9vZikgPT4ge1xuICAgIGNvbnN0IG1vb2ZPZmZzZXQgPSBtb29mLmJ5dGVPZmZzZXQgLSA4O1xuICAgIGNvbnN0IHRyYWZzID0gZmluZEJveChtb29mLCBbJ3RyYWYnXSk7XG4gICAgdHJhZnMubWFwKCh0cmFmKSA9PiB7XG4gICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgY29uc3QgYmFzZVRpbWUgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKS5tYXAoKHRmZHQpID0+IHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRmZHRbMF07XG4gICAgICAgIGxldCByZXN1bHQgPSByZWFkVWludDMyKHRmZHQsIDQpO1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgIHJlc3VsdCAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgcmVzdWx0ICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCAvIHRpbWVzY2FsZTtcbiAgICAgIH0pWzBdO1xuXG4gICAgICBpZiAoYmFzZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aW1lT2Zmc2V0ID0gYmFzZVRpbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAoKHRmaGQpID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgICBjb25zdCB0ZmhkRmxhZ3MgPSByZWFkVWludDMyKHRmaGQsIDApICYgMHhmZmZmZmY7XG4gICAgICAgIGNvbnN0IGJhc2VEYXRhT2Zmc2V0UHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAwMSkgIT09IDA7XG4gICAgICAgIGNvbnN0IHNhbXBsZURlc2NyaXB0aW9uSW5kZXhQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDAyKSAhPT0gMDtcbiAgICAgICAgY29uc3QgZGVmYXVsdFNhbXBsZUR1cmF0aW9uUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAwOCkgIT09IDA7XG4gICAgICAgIGxldCBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSAwO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2FtcGxlU2l6ZVByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMTApICE9PSAwO1xuICAgICAgICBsZXQgZGVmYXVsdFNhbXBsZVNpemUgPSAwO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2FtcGxlRmxhZ3NQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDIwKSAhPT0gMDtcbiAgICAgICAgbGV0IHRmaGRPZmZzZXQgPSA4O1xuXG4gICAgICAgIGlmIChpZCA9PT0gdHJhY2tJZCkge1xuICAgICAgICAgIGlmIChiYXNlRGF0YU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbXBsZURlc2NyaXB0aW9uSW5kZXhQcmVzZW50KSB7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIHRmaGRPZmZzZXQpO1xuICAgICAgICAgICAgdGZoZE9mZnNldCArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVmYXVsdFNhbXBsZVNpemVQcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlU2l6ZSA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBpc0hFVkNGbGF2b3IgPSBpc0hFVkModHJhY2suY29kZWMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpbmRCb3godHJhZiwgWyd0cnVuJ10pLm1hcCgodHJ1bikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRydW5bMF07XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IHJlYWRVaW50MzIodHJ1biwgMCkgJiAweGZmZmZmZjtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFPZmZzZXRQcmVzZW50ID0gKGZsYWdzICYgMHgwMDAwMDEpICE9PSAwO1xuICAgICAgICAgICAgbGV0IGRhdGFPZmZzZXQgPSAwO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RTYW1wbGVGbGFnc1ByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDAwNCkgIT09IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVEdXJhdGlvblByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDEwMCkgIT09IDA7XG4gICAgICAgICAgICBsZXQgc2FtcGxlRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlU2l6ZVByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDIwMCkgIT09IDA7XG4gICAgICAgICAgICBsZXQgc2FtcGxlU2l6ZSA9IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVGbGFnc1ByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDQwMCkgIT09IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVDb21wb3NpdGlvbk9mZnNldHNQcmVzZW50ID0gKGZsYWdzICYgMHgwMDA4MDApICE9PSAwO1xuICAgICAgICAgICAgbGV0IGNvbXBvc2l0aW9uT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUNvdW50ID0gcmVhZFVpbnQzMih0cnVuLCA0KTtcbiAgICAgICAgICAgIGxldCB0cnVuT2Zmc2V0ID0gODsgLy8gcGFzdCB2ZXJzaW9uLCBmbGFncywgYW5kIHNhbXBsZSBjb3VudFxuXG4gICAgICAgICAgICBpZiAoZGF0YU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgZGF0YU9mZnNldCA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBzYW1wbGVPZmZzZXQgPSBkYXRhT2Zmc2V0ICsgbW9vZk9mZnNldDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IHNhbXBsZUNvdW50OyBpeCsrKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gZGVmYXVsdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVTaXplUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHNhbXBsZVNpemUgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVTaXplID0gZGVmYXVsdFNhbXBsZVNpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2FtcGxlQ29tcG9zaXRpb25PZmZzZXRzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb3NpdGlvbk9mZnNldCA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uT2Zmc2V0ID0gcmVhZFNpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFsdVRvdGFsU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5hbHVUb3RhbFNpemUgPCBzYW1wbGVTaXplKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuYWx1U2l6ZSA9IHJlYWRVaW50MzIodmlkZW9EYXRhLCBzYW1wbGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgdmlkZW9EYXRhW3NhbXBsZU9mZnNldF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB2aWRlb0RhdGEuc3ViYXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArIG5hbHVTaXplXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgaXNIRVZDRmxhdm9yID8gMiA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgdGltZU9mZnNldCArIGNvbXBvc2l0aW9uT2Zmc2V0IC8gdGltZXNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgIHNlaVNhbXBsZXNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArPSBuYWx1U2l6ZTtcbiAgICAgICAgICAgICAgICAgIG5hbHVUb3RhbFNpemUgKz0gbmFsdVNpemUgKyA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRpbWVPZmZzZXQgKz0gc2FtcGxlRHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHNlaVNhbXBsZXM7XG59XG5cbmZ1bmN0aW9uIGlzSEVWQyhjb2RlYzogc3RyaW5nKSB7XG4gIGlmICghY29kZWMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZGVsaW1pdCA9IGNvZGVjLmluZGV4T2YoJy4nKTtcbiAgY29uc3QgYmFzZUNvZGVjID0gZGVsaW1pdCA8IDAgPyBjb2RlYyA6IGNvZGVjLnN1YnN0cmluZygwLCBkZWxpbWl0KTtcbiAgcmV0dXJuIChcbiAgICBiYXNlQ29kZWMgPT09ICdodmMxJyB8fFxuICAgIGJhc2VDb2RlYyA9PT0gJ2hldjEnIHx8XG4gICAgLy8gRG9sYnkgVmlzaW9uXG4gICAgYmFzZUNvZGVjID09PSAnZHZoMScgfHxcbiAgICBiYXNlQ29kZWMgPT09ICdkdmhlJ1xuICApO1xufVxuXG5mdW5jdGlvbiBpc1NFSU1lc3NhZ2UoaXNIRVZDRmxhdm9yOiBib29sZWFuLCBuYWx1SGVhZGVyOiBudW1iZXIpIHtcbiAgaWYgKGlzSEVWQ0ZsYXZvcikge1xuICAgIGNvbnN0IG5hbHVUeXBlID0gKG5hbHVIZWFkZXIgPj4gMSkgJiAweDNmO1xuICAgIHJldHVybiBuYWx1VHlwZSA9PT0gMzkgfHwgbmFsdVR5cGUgPT09IDQwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5hbHVUeXBlID0gbmFsdUhlYWRlciAmIDB4MWY7XG4gICAgcmV0dXJuIG5hbHVUeXBlID09PSA2O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdShcbiAgdW5lc2NhcGVkRGF0YTogVWludDhBcnJheSxcbiAgaGVhZGVyU2l6ZTogbnVtYmVyLFxuICBwdHM6IG51bWJlcixcbiAgc2FtcGxlczogVXNlcmRhdGFTYW1wbGVbXVxuKSB7XG4gIGNvbnN0IGRhdGEgPSBkaXNjYXJkRVBCKHVuZXNjYXBlZERhdGEpO1xuICBsZXQgc2VpUHRyID0gMDtcbiAgLy8gc2tpcCBuYWwgaGVhZGVyXG4gIHNlaVB0ciArPSBoZWFkZXJTaXplO1xuICBsZXQgcGF5bG9hZFR5cGUgPSAwO1xuICBsZXQgcGF5bG9hZFNpemUgPSAwO1xuICBsZXQgZW5kT2ZDYXB0aW9ucyA9IGZhbHNlO1xuICBsZXQgYiA9IDA7XG5cbiAgd2hpbGUgKHNlaVB0ciA8IGRhdGEubGVuZ3RoKSB7XG4gICAgcGF5bG9hZFR5cGUgPSAwO1xuICAgIGRvIHtcbiAgICAgIGlmIChzZWlQdHIgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBiID0gZGF0YVtzZWlQdHIrK107XG4gICAgICBwYXlsb2FkVHlwZSArPSBiO1xuICAgIH0gd2hpbGUgKGIgPT09IDB4ZmYpO1xuXG4gICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplLlxuICAgIHBheWxvYWRTaXplID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAoc2VpUHRyID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYiA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgcGF5bG9hZFNpemUgKz0gYjtcbiAgICB9IHdoaWxlIChiID09PSAweGZmKTtcblxuICAgIGNvbnN0IGxlZnRPdmVyID0gZGF0YS5sZW5ndGggLSBzZWlQdHI7XG5cbiAgICBpZiAoIWVuZE9mQ2FwdGlvbnMgJiYgcGF5bG9hZFR5cGUgPT09IDQgJiYgc2VpUHRyIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgIGVuZE9mQ2FwdGlvbnMgPSB0cnVlO1xuXG4gICAgICBjb25zdCBjb3VudHJ5Q29kZSA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgaWYgKGNvdW50cnlDb2RlID09PSAxODEpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJDb2RlID0gcmVhZFVpbnQxNihkYXRhLCBzZWlQdHIpO1xuICAgICAgICBzZWlQdHIgKz0gMjtcblxuICAgICAgICBpZiAocHJvdmlkZXJDb2RlID09PSA0OSkge1xuICAgICAgICAgIGNvbnN0IHVzZXJTdHJ1Y3R1cmUgPSByZWFkVWludDMyKGRhdGEsIHNlaVB0cik7XG4gICAgICAgICAgc2VpUHRyICs9IDQ7XG5cbiAgICAgICAgICBpZiAodXNlclN0cnVjdHVyZSA9PT0gMHg0NzQxMzkzNCkge1xuICAgICAgICAgICAgY29uc3QgdXNlckRhdGFUeXBlID0gZGF0YVtzZWlQdHIrK107XG5cbiAgICAgICAgICAgIC8vIFJhdyBDRUEtNjA4IGJ5dGVzIHdyYXBwZWQgaW4gQ0VBLTcwOCBwYWNrZXRcbiAgICAgICAgICAgIGlmICh1c2VyRGF0YVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gZGF0YVtzZWlQdHIrK107XG4gICAgICAgICAgICAgIGNvbnN0IHRvdGFsQ0NzID0gMHgxZiAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgY29uc3QgZW5hYmxlZCA9IDB4NDAgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgIGNvbnN0IHRvdGFsQnl0ZXMgPSBlbmFibGVkID8gMiArIHRvdGFsQ0NzICogMyA6IDA7XG4gICAgICAgICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsQnl0ZXMpO1xuICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGJ5dGVBcnJheVswXSA9IGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRvdGFsQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5W2ldID0gZGF0YVtzZWlQdHIrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB1c2VyRGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgcHRzLFxuICAgICAgICAgICAgICAgIGJ5dGVzOiBieXRlQXJyYXksXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZFR5cGUgPT09IDUgJiYgcGF5bG9hZFNpemUgPCBsZWZ0T3Zlcikge1xuICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XG5cbiAgICAgIGlmIChwYXlsb2FkU2l6ZSA+IDE2KSB7XG4gICAgICAgIGNvbnN0IHV1aWRTdHJBcnJheTogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBiID0gZGF0YVtzZWlQdHIrK10udG9TdHJpbmcoMTYpO1xuICAgICAgICAgIHV1aWRTdHJBcnJheS5wdXNoKGIubGVuZ3RoID09IDEgPyAnMCcgKyBiIDogYik7XG5cbiAgICAgICAgICBpZiAoaSA9PT0gMyB8fCBpID09PSA1IHx8IGkgPT09IDcgfHwgaSA9PT0gOSkge1xuICAgICAgICAgICAgdXVpZFN0ckFycmF5LnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGF5bG9hZFNpemUgLSAxNjtcbiAgICAgICAgY29uc3QgdXNlckRhdGFCeXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB1c2VyRGF0YUJ5dGVzW2ldID0gZGF0YVtzZWlQdHIrK107XG4gICAgICAgIH1cblxuICAgICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgIHB0cyxcbiAgICAgICAgICB1dWlkOiB1dWlkU3RyQXJyYXkuam9pbignJyksXG4gICAgICAgICAgdXNlckRhdGE6IHV0ZjhBcnJheVRvU3RyKHVzZXJEYXRhQnl0ZXMpLFxuICAgICAgICAgIHVzZXJEYXRhQnl0ZXMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPCBsZWZ0T3Zlcikge1xuICAgICAgc2VpUHRyICs9IHBheWxvYWRTaXplO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPiBsZWZ0T3Zlcikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNjYXJkRVBCKGRhdGE6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICBjb25zdCBFUEJQb3NpdGlvbnMgPSBbXSBhcyBBcnJheTxudW1iZXI+O1xuICBsZXQgaSA9IDE7XG5cbiAgLy8gRmluZCBhbGwgYEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzYFxuICB3aGlsZSAoaSA8IGxlbmd0aCAtIDIpIHtcbiAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJiBkYXRhW2kgKyAxXSA9PT0gMCAmJiBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xuICAgICAgRVBCUG9zaXRpb25zLnB1c2goaSArIDIpO1xuICAgICAgaSArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgbm8gRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXMgd2VyZSBmb3VuZCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWxcbiAgLy8gYXJyYXlcbiAgaWYgKEVQQlBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBob2xkIHRoZSBOQUwgdW5pdCBkYXRhXG4gIGNvbnN0IG5ld0xlbmd0aCA9IGxlbmd0aCAtIEVQQlBvc2l0aW9ucy5sZW5ndGg7XG4gIGNvbnN0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICBsZXQgc291cmNlSW5kZXggPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuZXdMZW5ndGg7IHNvdXJjZUluZGV4KyssIGkrKykge1xuICAgIGlmIChzb3VyY2VJbmRleCA9PT0gRVBCUG9zaXRpb25zWzBdKSB7XG4gICAgICAvLyBTa2lwIHRoaXMgYnl0ZVxuICAgICAgc291cmNlSW5kZXgrKztcbiAgICAgIC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XG4gICAgICBFUEJQb3NpdGlvbnMuc2hpZnQoKTtcbiAgICB9XG4gICAgbmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xuICB9XG4gIHJldHVybiBuZXdEYXRhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFbXNnKGRhdGE6IFVpbnQ4QXJyYXkpOiBJRW1zZ1BhcnNpbmdEYXRhIHtcbiAgY29uc3QgdmVyc2lvbiA9IGRhdGFbMF07XG4gIGxldCBzY2hlbWVJZFVyaTogc3RyaW5nID0gJyc7XG4gIGxldCB2YWx1ZTogc3RyaW5nID0gJyc7XG4gIGxldCB0aW1lU2NhbGU6IG51bWJlciA9IDA7XG4gIGxldCBwcmVzZW50YXRpb25UaW1lRGVsdGE6IG51bWJlciA9IDA7XG4gIGxldCBwcmVzZW50YXRpb25UaW1lOiBudW1iZXIgPSAwO1xuICBsZXQgZXZlbnREdXJhdGlvbjogbnVtYmVyID0gMDtcbiAgbGV0IGlkOiBudW1iZXIgPSAwO1xuICBsZXQgb2Zmc2V0OiBudW1iZXIgPSAwO1xuXG4gIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cblxuICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcblxuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG5cbiAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG5cbiAgICB0aW1lU2NhbGUgPSByZWFkVWludDMyKGRhdGEsIDEyKTtcbiAgICBwcmVzZW50YXRpb25UaW1lRGVsdGEgPSByZWFkVWludDMyKGRhdGEsIDE2KTtcbiAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCAyMCk7XG4gICAgaWQgPSByZWFkVWludDMyKGRhdGEsIDI0KTtcbiAgICBvZmZzZXQgPSAyODtcbiAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgdGltZVNjYWxlID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGNvbnN0IGxlZnRQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGNvbnN0IHJpZ2h0UHJlc2VudGF0aW9uVGltZSA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBwcmVzZW50YXRpb25UaW1lID0gMiAqKiAzMiAqIGxlZnRQcmVzZW50YXRpb25UaW1lICsgcmlnaHRQcmVzZW50YXRpb25UaW1lO1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocHJlc2VudGF0aW9uVGltZSkpIHtcbiAgICAgIHByZXNlbnRhdGlvblRpbWUgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAnUHJlc2VudGF0aW9uIHRpbWUgZXhjZWVkcyBzYWZlIGludGVnZXIgbGltaXQgYW5kIHdyYXBwZWQgdG8gbWF4IHNhZmUgaW50ZWdlciBpbiBwYXJzaW5nIGVtc2cgYm94J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGlkID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuXG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cblxuICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcblxuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG5cbiAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG4gIH1cbiAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiB7XG4gICAgc2NoZW1lSWRVcmksXG4gICAgdmFsdWUsXG4gICAgdGltZVNjYWxlLFxuICAgIHByZXNlbnRhdGlvblRpbWUsXG4gICAgcHJlc2VudGF0aW9uVGltZURlbHRhLFxuICAgIGV2ZW50RHVyYXRpb24sXG4gICAgaWQsXG4gICAgcGF5bG9hZCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1wNEJveCh0eXBlOiBBcnJheUxpa2U8bnVtYmVyPiwgLi4ucGF5bG9hZDogVWludDhBcnJheVtdKSB7XG4gIGNvbnN0IGxlbiA9IHBheWxvYWQubGVuZ3RoO1xuICBsZXQgc2l6ZSA9IDg7XG4gIGxldCBpID0gbGVuO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIHJlc3VsdFswXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gIHJlc3VsdFsxXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gIHJlc3VsdFsyXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgcmVzdWx0WzNdID0gc2l6ZSAmIDB4ZmY7XG4gIHJlc3VsdC5zZXQodHlwZSwgNCk7XG4gIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQuc2V0KHBheWxvYWRbaV0sIHNpemUpO1xuICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtcDRwc3NoKFxuICBzeXN0ZW1JZDogVWludDhBcnJheSxcbiAga2V5aWRzOiBBcnJheTxVaW50OEFycmF5PiB8IG51bGwsXG4gIGRhdGE6IFVpbnQ4QXJyYXlcbikge1xuICBpZiAoc3lzdGVtSWQuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzeXN0ZW0gaWQnKTtcbiAgfVxuICBsZXQgdmVyc2lvbjtcbiAgbGV0IGtpZHM7XG4gIGlmIChrZXlpZHMpIHtcbiAgICB2ZXJzaW9uID0gMTtcbiAgICBraWRzID0gbmV3IFVpbnQ4QXJyYXkoa2V5aWRzLmxlbmd0aCAqIDE2KTtcbiAgICBmb3IgKGxldCBpeCA9IDA7IGl4IDwga2V5aWRzLmxlbmd0aDsgaXgrKykge1xuICAgICAgY29uc3QgayA9IGtleWlkc1tpeF07IC8vIHVpbnQ4YXJyYXlcbiAgICAgIGlmIChrLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgfVxuICAgICAga2lkcy5zZXQoaywgaXggKiAxNik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZlcnNpb24gPSAwO1xuICAgIGtpZHMgPSBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIGxldCBraWRDb3VudDtcbiAgaWYgKHZlcnNpb24gPiAwKSB7XG4gICAga2lkQ291bnQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBpZiAoa2V5aWRzIS5sZW5ndGggPiAwKSB7XG4gICAgICBuZXcgRGF0YVZpZXcoa2lkQ291bnQuYnVmZmVyKS5zZXRVaW50MzIoMCwga2V5aWRzIS5sZW5ndGgsIGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAga2lkQ291bnQgPSBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIGNvbnN0IGRhdGFTaXplID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGlmIChkYXRhICYmIGRhdGEuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICBuZXcgRGF0YVZpZXcoZGF0YVNpemUuYnVmZmVyKS5zZXRVaW50MzIoMCwgZGF0YS5ieXRlTGVuZ3RoLCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG1wNEJveChcbiAgICBbMTEyLCAxMTUsIDExNSwgMTA0XSxcbiAgICBuZXcgVWludDhBcnJheShbXG4gICAgICB2ZXJzaW9uLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBGbGFnc1xuICAgIF0pLFxuICAgIHN5c3RlbUlkLCAvLyAxNiBieXRlc1xuICAgIGtpZENvdW50LFxuICAgIGtpZHMsXG4gICAgZGF0YVNpemUsXG4gICAgZGF0YSB8fCBuZXcgVWludDhBcnJheSgpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBzc2goaW5pdERhdGE6IEFycmF5QnVmZmVyKSB7XG4gIGlmICghKGluaXREYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8IGluaXREYXRhLmJ5dGVMZW5ndGggPCAzMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB2ZXJzaW9uOiAwLFxuICAgIHN5c3RlbUlkOiAnJyxcbiAgICBraWRzOiBudWxsIGFzIG51bGwgfCBVaW50OEFycmF5W10sXG4gICAgZGF0YTogbnVsbCBhcyBudWxsIHwgVWludDhBcnJheSxcbiAgfTtcbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhpbml0RGF0YSk7XG4gIGNvbnN0IGJveFNpemUgPSB2aWV3LmdldFVpbnQzMigwKTtcbiAgaWYgKGluaXREYXRhLmJ5dGVMZW5ndGggIT09IGJveFNpemUgJiYgYm94U2l6ZSA+IDQ0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgdHlwZSA9IHZpZXcuZ2V0VWludDMyKDQpO1xuICBpZiAodHlwZSAhPT0gMHg3MDczNzM2OCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlc3VsdC52ZXJzaW9uID0gdmlldy5nZXRVaW50MzIoOCkgPj4+IDI0O1xuICBpZiAocmVzdWx0LnZlcnNpb24gPiAxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVzdWx0LnN5c3RlbUlkID0gSGV4LmhleER1bXAobmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEsIDEyLCAxNikpO1xuICBjb25zdCBkYXRhU2l6ZU9yS2lkQ291bnQgPSB2aWV3LmdldFVpbnQzMigyOCk7XG4gIGlmIChyZXN1bHQudmVyc2lvbiA9PT0gMCkge1xuICAgIGlmIChib3hTaXplIC0gMzIgPCBkYXRhU2l6ZU9yS2lkQ291bnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuZGF0YSA9IG5ldyBVaW50OEFycmF5KGluaXREYXRhLCAzMiwgZGF0YVNpemVPcktpZENvdW50KTtcbiAgfSBlbHNlIGlmIChyZXN1bHQudmVyc2lvbiA9PT0gMSkge1xuICAgIHJlc3VsdC5raWRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhU2l6ZU9yS2lkQ291bnQ7IGkrKykge1xuICAgICAgcmVzdWx0LmtpZHMucHVzaChuZXcgVWludDhBcnJheShpbml0RGF0YSwgMzIgKyBpICogMTYsIDE2KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQge1xuICBjaGFuZ2VFbmRpYW5uZXNzLFxuICBjb252ZXJ0RGF0YVVyaVRvQXJyYXlCeXRlcyxcbn0gZnJvbSAnLi4vdXRpbHMva2V5c3lzdGVtLXV0aWwnO1xuaW1wb3J0IHsgS2V5U3lzdGVtRm9ybWF0cyB9IGZyb20gJy4uL3V0aWxzL21lZGlha2V5cy1oZWxwZXInO1xuaW1wb3J0IHsgbXA0cHNzaCB9IGZyb20gJy4uL3V0aWxzL21wNC10b29scyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgYmFzZTY0RGVjb2RlIH0gZnJvbSAnLi4vdXRpbHMvbnVtZXJpYy1lbmNvZGluZy11dGlscyc7XG5cbmxldCBrZXlVcmlUb0tleUlkTWFwOiB7IFt1cmk6IHN0cmluZ106IFVpbnQ4QXJyYXkgfSA9IHt9O1xuXG5leHBvcnQgaW50ZXJmYWNlIERlY3J5cHREYXRhIHtcbiAgdXJpOiBzdHJpbmc7XG4gIG1ldGhvZDogc3RyaW5nO1xuICBrZXlGb3JtYXQ6IHN0cmluZztcbiAga2V5Rm9ybWF0VmVyc2lvbnM6IG51bWJlcltdO1xuICBpdjogVWludDhBcnJheSB8IG51bGw7XG4gIGtleTogVWludDhBcnJheSB8IG51bGw7XG4gIGtleUlkOiBVaW50OEFycmF5IHwgbnVsbDtcbiAgcHNzaDogVWludDhBcnJheSB8IG51bGw7XG4gIGVuY3J5cHRlZDogYm9vbGVhbjtcbiAgaXNDb21tb25FbmNyeXB0aW9uOiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgTGV2ZWxLZXkgaW1wbGVtZW50cyBEZWNyeXB0RGF0YSB7XG4gIHB1YmxpYyByZWFkb25seSB1cmk6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IG1ldGhvZDogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkga2V5Rm9ybWF0OiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBrZXlGb3JtYXRWZXJzaW9uczogbnVtYmVyW107XG4gIHB1YmxpYyByZWFkb25seSBlbmNyeXB0ZWQ6IGJvb2xlYW47XG4gIHB1YmxpYyByZWFkb25seSBpc0NvbW1vbkVuY3J5cHRpb246IGJvb2xlYW47XG4gIHB1YmxpYyBpdjogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMga2V5OiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBrZXlJZDogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgcHNzaDogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuXG4gIHN0YXRpYyBjbGVhcktleVVyaVRvS2V5SWRNYXAoKSB7XG4gICAga2V5VXJpVG9LZXlJZE1hcCA9IHt9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbWV0aG9kOiBzdHJpbmcsXG4gICAgdXJpOiBzdHJpbmcsXG4gICAgZm9ybWF0OiBzdHJpbmcsXG4gICAgZm9ybWF0dmVyc2lvbnM6IG51bWJlcltdID0gWzFdLFxuICAgIGl2OiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGxcbiAgKSB7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy51cmkgPSB1cmk7XG4gICAgdGhpcy5rZXlGb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucyA9IGZvcm1hdHZlcnNpb25zO1xuICAgIHRoaXMuaXYgPSBpdjtcbiAgICB0aGlzLmVuY3J5cHRlZCA9IG1ldGhvZCA/IG1ldGhvZCAhPT0gJ05PTkUnIDogZmFsc2U7XG4gICAgdGhpcy5pc0NvbW1vbkVuY3J5cHRpb24gPSB0aGlzLmVuY3J5cHRlZCAmJiBtZXRob2QgIT09ICdBRVMtMTI4JztcbiAgfVxuXG4gIHB1YmxpYyBpc1N1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgICAvLyBJZiBpdCdzIFNlZ21lbnQgZW5jcnlwdGlvbiBvciBObyBlbmNyeXB0aW9uLCBqdXN0IHNlbGVjdCB0aGF0IGtleSBzeXN0ZW1cbiAgICBpZiAodGhpcy5tZXRob2QpIHtcbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0FFUy0xMjgnIHx8IHRoaXMubWV0aG9kID09PSAnTk9ORScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5rZXlGb3JtYXQgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgLy8gTWFpbnRhaW4gc3VwcG9ydCBmb3IgY2xlYXIgU0FNUExFLUFFUyB3aXRoIE1QRUctMyBUU1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2QgPT09ICdTQU1QTEUtQUVTJztcbiAgICAgIH0gZWxzZSBpZiAoX19VU0VfRU1FX0RSTV9fKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5rZXlGb3JtYXQpIHtcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuRkFJUlBMQVk6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdJU08tMjMwMDEtNycsXG4gICAgICAgICAgICAgICAgJ1NBTVBMRS1BRVMnLFxuICAgICAgICAgICAgICAgICdTQU1QTEUtQUVTLUNFTkMnLFxuICAgICAgICAgICAgICAgICdTQU1QTEUtQUVTLUNUUicsXG4gICAgICAgICAgICAgIF0uaW5kZXhPZih0aGlzLm1ldGhvZCkgIT09IC0xXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXREZWNyeXB0RGF0YShzbjogbnVtYmVyIHwgJ2luaXRTZWdtZW50Jyk6IExldmVsS2V5IHwgbnVsbCB7XG4gICAgaWYgKCF0aGlzLmVuY3J5cHRlZCB8fCAhdGhpcy51cmkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0FFUy0xMjgnICYmIHRoaXMudXJpICYmICF0aGlzLml2KSB7XG4gICAgICBpZiAodHlwZW9mIHNuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBXZSBhcmUgZmV0Y2hpbmcgZGVjcnlwdGlvbiBkYXRhIGZvciBhIGluaXRpYWxpemF0aW9uIHNlZ21lbnRcbiAgICAgICAgLy8gSWYgdGhlIHNlZ21lbnQgd2FzIGVuY3J5cHRlZCB3aXRoIEFFUy0xMjhcbiAgICAgICAgLy8gSXQgbXVzdCBoYXZlIGFuIElWIGRlZmluZWQuIFdlIGNhbm5vdCBzdWJzdGl0dXRlIHRoZSBTZWdtZW50IE51bWJlciBpbi5cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnQUVTLTEyOCcgJiYgIXRoaXMuaXYpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgIGBtaXNzaW5nIElWIGZvciBpbml0aWFsaXphdGlvbiBzZWdtZW50IHdpdGggbWV0aG9kPVwiJHt0aGlzLm1ldGhvZH1cIiAtIGNvbXBsaWFuY2UgaXNzdWVgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHBsaWNpdGx5IHNldCBzbiB0byByZXN1bHRpbmcgdmFsdWUgZnJvbSBpbXBsaWNpdCBjb252ZXJzaW9ucyAnaW5pdFNlZ21lbnQnIHZhbHVlcyBmb3IgSVYgZ2VuZXJhdGlvbi5cbiAgICAgICAgc24gPSAwO1xuICAgICAgfVxuICAgICAgY29uc3QgaXYgPSBjcmVhdGVJbml0aWFsaXphdGlvblZlY3Rvcihzbik7XG4gICAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IG5ldyBMZXZlbEtleShcbiAgICAgICAgdGhpcy5tZXRob2QsXG4gICAgICAgIHRoaXMudXJpLFxuICAgICAgICAnaWRlbnRpdHknLFxuICAgICAgICB0aGlzLmtleUZvcm1hdFZlcnNpb25zLFxuICAgICAgICBpdlxuICAgICAgKTtcbiAgICAgIHJldHVybiBkZWNyeXB0ZGF0YTtcbiAgICB9XG5cbiAgICBpZiAoIV9fVVNFX0VNRV9EUk1fXykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBrZXlJZCBpZiBwb3NzaWJsZVxuICAgIGNvbnN0IGtleUJ5dGVzID0gY29udmVydERhdGFVcmlUb0FycmF5Qnl0ZXModGhpcy51cmkpO1xuICAgIGlmIChrZXlCeXRlcykge1xuICAgICAgc3dpdGNoICh0aGlzLmtleUZvcm1hdCkge1xuICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuV0lERVZJTkU6XG4gICAgICAgICAgdGhpcy5wc3NoID0ga2V5Qnl0ZXM7XG4gICAgICAgICAgLy8gSW4gY2FzZSBvZiB3aWRldmluZSBrZXlJRCBpcyBlbWJlZGRlZCBpbiBQU1NIIGJveC4gUmVhZCBLZXkgSUQuXG4gICAgICAgICAgaWYgKGtleUJ5dGVzLmxlbmd0aCA+PSAyMikge1xuICAgICAgICAgICAgdGhpcy5rZXlJZCA9IGtleUJ5dGVzLnN1YmFycmF5KFxuICAgICAgICAgICAgICBrZXlCeXRlcy5sZW5ndGggLSAyMixcbiAgICAgICAgICAgICAga2V5Qnl0ZXMubGVuZ3RoIC0gNlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6IHtcbiAgICAgICAgICBjb25zdCBQbGF5UmVhZHlLZXlTeXN0ZW1VVUlEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHg5YSwgMHgwNCwgMHhmMCwgMHg3OSwgMHg5OCwgMHg0MCwgMHg0MiwgMHg4NiwgMHhhYiwgMHg5MiwgMHhlNixcbiAgICAgICAgICAgIDB4NWIsIDB4ZTAsIDB4ODgsIDB4NWYsIDB4OTUsXG4gICAgICAgICAgXSk7XG5cbiAgICAgICAgICB0aGlzLnBzc2ggPSBtcDRwc3NoKFBsYXlSZWFkeUtleVN5c3RlbVVVSUQsIG51bGwsIGtleUJ5dGVzKTtcblxuICAgICAgICAgIGNvbnN0IGtleUJ5dGVzVXRmMTYgPSBuZXcgVWludDE2QXJyYXkoXG4gICAgICAgICAgICBrZXlCeXRlcy5idWZmZXIsXG4gICAgICAgICAgICBrZXlCeXRlcy5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAga2V5Qnl0ZXMuYnl0ZUxlbmd0aCAvIDJcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGtleUJ5dGVTdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIEFycmF5LmZyb20oa2V5Qnl0ZXNVdGYxNilcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gUGFyc2UgUGxheXJlYWR5IFdSTUhlYWRlciBYTUxcbiAgICAgICAgICBjb25zdCB4bWxLZXlCeXRlcyA9IGtleUJ5dGVTdHIuc3Vic3RyaW5nKFxuICAgICAgICAgICAga2V5Qnl0ZVN0ci5pbmRleE9mKCc8JyksXG4gICAgICAgICAgICBrZXlCeXRlU3RyLmxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgIGNvbnN0IHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sS2V5Qnl0ZXMsICd0ZXh0L3htbCcpO1xuICAgICAgICAgIGNvbnN0IGtleURhdGEgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0tJRCcpWzBdO1xuICAgICAgICAgIGlmIChrZXlEYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlJZCA9IGtleURhdGEuY2hpbGROb2Rlc1swXVxuICAgICAgICAgICAgICA/IGtleURhdGEuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWVcbiAgICAgICAgICAgICAgOiBrZXlEYXRhLmdldEF0dHJpYnV0ZSgnVkFMVUUnKTtcbiAgICAgICAgICAgIGlmIChrZXlJZCkge1xuICAgICAgICAgICAgICBjb25zdCBrZXlJZEFycmF5ID0gYmFzZTY0RGVjb2RlKGtleUlkKS5zdWJhcnJheSgwLCAxNik7XG4gICAgICAgICAgICAgIC8vIEtJRCB2YWx1ZSBpbiBQUk8gaXMgYSBiYXNlNjQtZW5jb2RlZCBsaXR0bGUgZW5kaWFuIEdVSUQgaW50ZXJwcmV0YXRpb24gb2YgVVVJRFxuICAgICAgICAgICAgICAvLyBLSUQgdmFsdWUgaW4g4oCYdGVuY+KAmSBpcyBhIGJpZyBlbmRpYW4gVVVJRCBHVUlEIGludGVycHJldGF0aW9uIG9mIFVVSURcbiAgICAgICAgICAgICAgY2hhbmdlRW5kaWFubmVzcyhrZXlJZEFycmF5KTtcbiAgICAgICAgICAgICAgdGhpcy5rZXlJZCA9IGtleUlkQXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBsZXQga2V5ZGF0YSA9IGtleUJ5dGVzLnN1YmFycmF5KDAsIDE2KTtcbiAgICAgICAgICBpZiAoa2V5ZGF0YS5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgICAgICBwYWRkZWQuc2V0KGtleWRhdGEsIDE2IC0ga2V5ZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAga2V5ZGF0YSA9IHBhZGRlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5rZXlJZCA9IGtleWRhdGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGJlaGF2aW9yOiBhc3NpZ24gYSBuZXcga2V5SWQgZm9yIGVhY2ggdXJpXG4gICAgaWYgKCF0aGlzLmtleUlkIHx8IHRoaXMua2V5SWQuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIGxldCBrZXlJZCA9IGtleVVyaVRvS2V5SWRNYXBbdGhpcy51cmldO1xuICAgICAgaWYgKCFrZXlJZCkge1xuICAgICAgICBjb25zdCB2YWwgPVxuICAgICAgICAgIE9iamVjdC5rZXlzKGtleVVyaVRvS2V5SWRNYXApLmxlbmd0aCAlIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICBrZXlJZCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcoa2V5SWQuYnVmZmVyLCAxMiwgNCk7IC8vIEp1c3Qgc2V0IHRoZSBsYXN0IDQgYnl0ZXNcbiAgICAgICAgZHYuc2V0VWludDMyKDAsIHZhbCk7XG4gICAgICAgIGtleVVyaVRvS2V5SWRNYXBbdGhpcy51cmldID0ga2V5SWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmtleUlkID0ga2V5SWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc2VnbWVudE51bWJlcjogbnVtYmVyKTogVWludDhBcnJheSB7XG4gIGNvbnN0IHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgZm9yIChsZXQgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgIHVpbnQ4Vmlld1tpXSA9IChzZWdtZW50TnVtYmVyID4+ICg4ICogKDE1IC0gaSkpKSAmIDB4ZmY7XG4gIH1cbiAgcmV0dXJuIHVpbnQ4Vmlldztcbn1cbiIsIi8qKlxuICogTWVkaWFTb3VyY2UgaGVscGVyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lZGlhU291cmNlKCk6IHR5cGVvZiBNZWRpYVNvdXJjZSB8IHVuZGVmaW5lZCB7XG4gIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiBzZWxmLk1lZGlhU291cmNlIHx8ICgoc2VsZiBhcyBhbnkpLldlYktpdE1lZGlhU291cmNlIGFzIE1lZGlhU291cmNlKTtcbn1cbiIsImltcG9ydCB7IGdldE1lZGlhU291cmNlIH0gZnJvbSAnLi9tZWRpYXNvdXJjZS1oZWxwZXInO1xuXG4vLyBmcm9tIGh0dHA6Ly9tcDRyYS5vcmcvY29kZWNzLmh0bWxcbmNvbnN0IHNhbXBsZUVudHJ5Q29kZXNJU08gPSB7XG4gIGF1ZGlvOiB7XG4gICAgYTNkczogdHJ1ZSxcbiAgICAnYWMtMyc6IHRydWUsXG4gICAgJ2FjLTQnOiB0cnVlLFxuICAgIGFsYWM6IHRydWUsXG4gICAgYWxhdzogdHJ1ZSxcbiAgICBkcmExOiB0cnVlLFxuICAgICdkdHMrJzogdHJ1ZSxcbiAgICAnZHRzLSc6IHRydWUsXG4gICAgZHRzYzogdHJ1ZSxcbiAgICBkdHNlOiB0cnVlLFxuICAgIGR0c2g6IHRydWUsXG4gICAgJ2VjLTMnOiB0cnVlLFxuICAgIGVuY2E6IHRydWUsXG4gICAgZzcxOTogdHJ1ZSxcbiAgICBnNzI2OiB0cnVlLFxuICAgIG00YWU6IHRydWUsXG4gICAgbWhhMTogdHJ1ZSxcbiAgICBtaGEyOiB0cnVlLFxuICAgIG1obTE6IHRydWUsXG4gICAgbWhtMjogdHJ1ZSxcbiAgICBtbHBhOiB0cnVlLFxuICAgIG1wNGE6IHRydWUsXG4gICAgJ3JhdyAnOiB0cnVlLFxuICAgIE9wdXM6IHRydWUsXG4gICAgb3B1czogdHJ1ZSwgLy8gYnJvd3NlcnMgZXhwZWN0IHRoaXMgdG8gYmUgbG93ZXJjYXNlIGRlc3BpdGUgTVA0UkEgc2F5cyAnT3B1cydcbiAgICBzYW1yOiB0cnVlLFxuICAgIHNhd2I6IHRydWUsXG4gICAgc2F3cDogdHJ1ZSxcbiAgICBzZXZjOiB0cnVlLFxuICAgIHNxY3A6IHRydWUsXG4gICAgc3NtdjogdHJ1ZSxcbiAgICB0d29zOiB0cnVlLFxuICAgIHVsYXc6IHRydWUsXG4gIH0sXG4gIHZpZGVvOiB7XG4gICAgYXZjMTogdHJ1ZSxcbiAgICBhdmMyOiB0cnVlLFxuICAgIGF2YzM6IHRydWUsXG4gICAgYXZjNDogdHJ1ZSxcbiAgICBhdmNwOiB0cnVlLFxuICAgIGF2MDE6IHRydWUsXG4gICAgZHJhYzogdHJ1ZSxcbiAgICBkdmExOiB0cnVlLFxuICAgIGR2YXY6IHRydWUsXG4gICAgZHZoMTogdHJ1ZSxcbiAgICBkdmhlOiB0cnVlLFxuICAgIGVuY3Y6IHRydWUsXG4gICAgaGV2MTogdHJ1ZSxcbiAgICBodmMxOiB0cnVlLFxuICAgIG1qcDI6IHRydWUsXG4gICAgbXA0djogdHJ1ZSxcbiAgICBtdmMxOiB0cnVlLFxuICAgIG12YzI6IHRydWUsXG4gICAgbXZjMzogdHJ1ZSxcbiAgICBtdmM0OiB0cnVlLFxuICAgIHJlc3Y6IHRydWUsXG4gICAgcnY2MDogdHJ1ZSxcbiAgICBzMjYzOiB0cnVlLFxuICAgIHN2YzE6IHRydWUsXG4gICAgc3ZjMjogdHJ1ZSxcbiAgICAndmMtMSc6IHRydWUsXG4gICAgdnAwODogdHJ1ZSxcbiAgICB2cDA5OiB0cnVlLFxuICB9LFxuICB0ZXh0OiB7XG4gICAgc3RwcDogdHJ1ZSxcbiAgICB3dnR0OiB0cnVlLFxuICB9LFxufTtcblxuY29uc3QgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuXG5leHBvcnQgdHlwZSBDb2RlY1R5cGUgPSAnYXVkaW8nIHwgJ3ZpZGVvJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29kZWNUeXBlKGNvZGVjOiBzdHJpbmcsIHR5cGU6IENvZGVjVHlwZSk6IGJvb2xlYW4ge1xuICBjb25zdCB0eXBlQ29kZXMgPSBzYW1wbGVFbnRyeUNvZGVzSVNPW3R5cGVdO1xuICByZXR1cm4gISF0eXBlQ29kZXMgJiYgdHlwZUNvZGVzW2NvZGVjLnNsaWNlKDAsIDQpXSA9PT0gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNChjb2RlYzogc3RyaW5nLCB0eXBlOiBDb2RlY1R5cGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBNZWRpYVNvdXJjZT8uaXNUeXBlU3VwcG9ydGVkKGAke3R5cGUgfHwgJ3ZpZGVvJ30vbXA0O2NvZGVjcz1cIiR7Y29kZWN9XCJgKSA/P1xuICAgIGZhbHNlXG4gICk7XG59XG4iLCJpbXBvcnQgeyBidWlsZEFic29sdXRlVVJMIH0gZnJvbSAndXJsLXRvb2xraXQnO1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi9kYXRlLXJhbmdlJztcbmltcG9ydCB7IEZyYWdtZW50LCBQYXJ0IH0gZnJvbSAnLi9mcmFnbWVudCc7XG5pbXBvcnQgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuL2xldmVsLWRldGFpbHMnO1xuaW1wb3J0IHsgTGV2ZWxLZXkgfSBmcm9tICcuL2xldmVsLWtleSc7XG5pbXBvcnQgeyBBdHRyTGlzdCB9IGZyb20gJy4uL3V0aWxzL2F0dHItbGlzdCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHtcbiAgYWRkVmFyaWFibGVEZWZpbml0aW9uLFxuICBoYXNWYXJpYWJsZVJlZmVyZW5jZXMsXG4gIGltcG9ydFZhcmlhYmxlRGVmaW5pdGlvbixcbiAgc3Vic3RpdHV0ZVZhcmlhYmxlcyxcbiAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyxcbn0gZnJvbSAnLi4vdXRpbHMvdmFyaWFibGUtc3Vic3RpdHV0aW9uJztcbmltcG9ydCB7IGlzQ29kZWNUeXBlIH0gZnJvbSAnLi4vdXRpbHMvY29kZWNzJztcbmltcG9ydCB0eXBlIHsgQ29kZWNUeXBlIH0gZnJvbSAnLi4vdXRpbHMvY29kZWNzJztcbmltcG9ydCB0eXBlIHtcbiAgTWVkaWFQbGF5bGlzdCxcbiAgQXVkaW9Hcm91cCxcbiAgTWVkaWFQbGF5bGlzdFR5cGUsXG4gIE1lZGlhQXR0cmlidXRlcyxcbn0gZnJvbSAnLi4vdHlwZXMvbWVkaWEtcGxheWxpc3QnO1xuaW1wb3J0IHR5cGUgeyBQbGF5bGlzdExldmVsVHlwZSB9IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgdHlwZSB7IExldmVsQXR0cmlidXRlcywgTGV2ZWxQYXJzZWQsIFZhcmlhYmxlTWFwIH0gZnJvbSAnLi4vdHlwZXMvbGV2ZWwnO1xuaW1wb3J0IHR5cGUgeyBDb250ZW50U3RlZXJpbmdPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcblxudHlwZSBNM1U4UGFyc2VyRnJhZ21lbnRzID0gQXJyYXk8RnJhZ21lbnQgfCBudWxsPjtcblxuZXhwb3J0IHR5cGUgUGFyc2VkTXVsdGl2YXJpYW50UGxheWxpc3QgPSB7XG4gIGNvbnRlbnRTdGVlcmluZzogQ29udGVudFN0ZWVyaW5nT3B0aW9ucyB8IG51bGw7XG4gIGxldmVsczogTGV2ZWxQYXJzZWRbXTtcbiAgcGxheWxpc3RQYXJzaW5nRXJyb3I6IEVycm9yIHwgbnVsbDtcbiAgc2Vzc2lvbkRhdGE6IFJlY29yZDxzdHJpbmcsIEF0dHJMaXN0PiB8IG51bGw7XG4gIHNlc3Npb25LZXlzOiBMZXZlbEtleVtdIHwgbnVsbDtcbiAgc3RhcnRUaW1lT2Zmc2V0OiBudW1iZXIgfCBudWxsO1xuICB2YXJpYWJsZUxpc3Q6IFZhcmlhYmxlTWFwIHwgbnVsbDtcbiAgaGFzVmFyaWFibGVSZWZzOiBib29sZWFuO1xufTtcblxudHlwZSBQYXJzZWRNdWx0aXZhcmlhbnRNZWRpYU9wdGlvbnMgPSB7XG4gIEFVRElPPzogTWVkaWFQbGF5bGlzdFtdO1xuICBTVUJUSVRMRVM/OiBNZWRpYVBsYXlsaXN0W107XG4gICdDTE9TRUQtQ0FQVElPTlMnPzogTWVkaWFQbGF5bGlzdFtdO1xufTtcblxuY29uc3QgTUFTVEVSX1BMQVlMSVNUX1JFR0VYID1cbiAgLyNFWFQtWC1TVFJFQU0tSU5GOihbXlxcclxcbl0qKSg/OltcXHJcXG5dKD86I1teXFxyXFxuXSopPykqKFteXFxyXFxuXSspfCNFWFQtWC0oU0VTU0lPTi1EQVRBfFNFU1NJT04tS0VZfERFRklORXxDT05URU5ULVNURUVSSU5HfFNUQVJUKTooW15cXHJcXG5dKilbXFxyXFxuXSsvZztcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xuXG5jb25zdCBJU19NRURJQV9QTEFZTElTVCA9IC9eI0VYVCg/OklORnwtWC1UQVJHRVREVVJBVElPTik6L207IC8vIEhhbmRsZSBlbXB0eSBNZWRpYSBQbGF5bGlzdCAoZmlyc3QgRVhUSU5GIG5vdCBzaWduYWxlZCwgYnV0IFRBUkdFVERVUkFUSU9OIHByZXNlbnQpXG5cbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFxuICBbXG4gICAgLyNFWFRJTkY6XFxzKihcXGQqKD86XFwuXFxkKyk/KSg/OiwoLiopXFxzKyk/Ly5zb3VyY2UsIC8vIGR1cmF0aW9uICgjRVhUSU5GOjxkdXJhdGlvbj4sPHRpdGxlPiksIGdyb3VwIDEgPT4gZHVyYXRpb24sIGdyb3VwIDIgPT4gdGl0bGVcbiAgICAvKD8hIykgKihcXFNbXFxTIF0qKS8uc291cmNlLCAvLyBzZWdtZW50IFVSSSwgZ3JvdXAgMyA9PiB0aGUgVVJJIChub3RlIG5ld2xpbmUgaXMgbm90IGVhdGVuKVxuICAgIC8jRVhULVgtQllURVJBTkdFOiooLispLy5zb3VyY2UsIC8vIG5leHQgc2VnbWVudCdzIGJ5dGVyYW5nZSwgZ3JvdXAgNCA9PiByYW5nZSBzcGVjICh4QHkpXG4gICAgLyNFWFQtWC1QUk9HUkFNLURBVEUtVElNRTooLispLy5zb3VyY2UsIC8vIG5leHQgc2VnbWVudCdzIHByb2dyYW0gZGF0ZS90aW1lIGdyb3VwIDUgPT4gdGhlIGRhdGV0aW1lIHNwZWNcbiAgICAvIy4qLy5zb3VyY2UsIC8vIEFsbCBvdGhlciBub24tc2VnbWVudCBvcmllbnRlZCB0YWdzIHdpbGwgbWF0Y2ggd2l0aCBhbGwgZ3JvdXBzIGVtcHR5XG4gIF0uam9pbignfCcpLFxuICAnZydcbik7XG5cbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cgPSBuZXcgUmVnRXhwKFxuICBbXG4gICAgLyMoRVhUTTNVKS8uc291cmNlLFxuICAgIC8jRVhULVgtKERBVEVSQU5HRXxERUZJTkV8S0VZfE1BUHxQQVJUfFBBUlQtSU5GfFBMQVlMSVNULVRZUEV8UFJFTE9BRC1ISU5UfFJFTkRJVElPTi1SRVBPUlR8U0VSVkVSLUNPTlRST0x8U0tJUHxTVEFSVCk6KC4rKS9cbiAgICAgIC5zb3VyY2UsXG4gICAgLyNFWFQtWC0oQklUUkFURXxESVNDT05USU5VSVRZLVNFUVVFTkNFfE1FRElBLVNFUVVFTkNFfFRBUkdFVERVUkFUSU9OfFZFUlNJT04pOiAqKFxcZCspL1xuICAgICAgLnNvdXJjZSxcbiAgICAvI0VYVC1YLShESVNDT05USU5VSVRZfEVORExJU1R8R0FQKS8uc291cmNlLFxuICAgIC8oIykoW146XSopOiguKikvLnNvdXJjZSxcbiAgICAvKCMpKC4qKSg/Oi4qKVxccj9cXG4/Ly5zb3VyY2UsXG4gIF0uam9pbignfCcpXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNM1U4UGFyc2VyIHtcbiAgc3RhdGljIGZpbmRHcm91cChcbiAgICBncm91cHM6IEFycmF5PEF1ZGlvR3JvdXA+LFxuICAgIG1lZGlhR3JvdXBJZDogc3RyaW5nXG4gICk6IEF1ZGlvR3JvdXAgfCB1bmRlZmluZWQge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgIGlmIChncm91cC5pZCA9PT0gbWVkaWFHcm91cElkKSB7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgY29udmVydEFWQzFUb0FWQ09USShjb2RlYykge1xuICAgIC8vIENvbnZlcnQgYXZjMSBjb2RlYyBzdHJpbmcgZnJvbSBSRkMtNDI4MSB0byBSRkMtNjM4MSBmb3IgTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkXG4gICAgY29uc3QgYXZjZGF0YSA9IGNvZGVjLnNwbGl0KCcuJyk7XG4gICAgaWYgKGF2Y2RhdGEubGVuZ3RoID4gMikge1xuICAgICAgbGV0IHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcbiAgICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJlc3VsdCArPSAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjO1xuICB9XG5cbiAgc3RhdGljIHJlc29sdmUodXJsLCBiYXNlVXJsKSB7XG4gICAgcmV0dXJuIGJ1aWxkQWJzb2x1dGVVUkwoYmFzZVVybCwgdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHN0YXRpYyBpc01lZGlhUGxheWxpc3Qoc3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gSVNfTUVESUFfUExBWUxJU1QudGVzdChzdHIpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlTWFzdGVyUGxheWxpc3QoXG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgYmFzZXVybDogc3RyaW5nXG4gICk6IFBhcnNlZE11bHRpdmFyaWFudFBsYXlsaXN0IHtcbiAgICBjb25zdCBoYXNWYXJpYWJsZVJlZnMgPSBfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fX1xuICAgICAgPyBoYXNWYXJpYWJsZVJlZmVyZW5jZXMoc3RyaW5nKVxuICAgICAgOiBmYWxzZTtcbiAgICBjb25zdCBwYXJzZWQ6IFBhcnNlZE11bHRpdmFyaWFudFBsYXlsaXN0ID0ge1xuICAgICAgY29udGVudFN0ZWVyaW5nOiBudWxsLFxuICAgICAgbGV2ZWxzOiBbXSxcbiAgICAgIHBsYXlsaXN0UGFyc2luZ0Vycm9yOiBudWxsLFxuICAgICAgc2Vzc2lvbkRhdGE6IG51bGwsXG4gICAgICBzZXNzaW9uS2V5czogbnVsbCxcbiAgICAgIHN0YXJ0VGltZU9mZnNldDogbnVsbCxcbiAgICAgIHZhcmlhYmxlTGlzdDogbnVsbCxcbiAgICAgIGhhc1ZhcmlhYmxlUmVmcyxcbiAgICB9O1xuICAgIGNvbnN0IGxldmVsc1dpdGhLbm93bkNvZGVjczogTGV2ZWxQYXJzZWRbXSA9IFtdO1xuXG4gICAgTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG5cbiAgICBsZXQgcmVzdWx0OiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsO1xuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlc3VsdFsxXSkge1xuICAgICAgICAvLyAnI0VYVC1YLVNUUkVBTS1JTkYnIGlzIGZvdW5kLCBwYXJzZSBsZXZlbCB0YWcgIGluIGdyb3VwIDFcbiAgICAgICAgY29uc3QgYXR0cnMgPSBuZXcgQXR0ckxpc3QocmVzdWx0WzFdKSBhcyBMZXZlbEF0dHJpYnV0ZXM7XG4gICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBhdHRycywgW1xuICAgICAgICAgICAgJ0NPREVDUycsXG4gICAgICAgICAgICAnU1VQUExFTUVOVEFMLUNPREVDUycsXG4gICAgICAgICAgICAnQUxMT1dFRC1DUEMnLFxuICAgICAgICAgICAgJ1BBVEhXQVktSUQnLFxuICAgICAgICAgICAgJ1NUQUJMRS1WQVJJQU5ULUlEJyxcbiAgICAgICAgICAgICdBVURJTycsXG4gICAgICAgICAgICAnVklERU8nLFxuICAgICAgICAgICAgJ1NVQlRJVExFUycsXG4gICAgICAgICAgICAnQ0xPU0VELUNBUFRJT05TJyxcbiAgICAgICAgICAgICdOQU1FJyxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fX1xuICAgICAgICAgID8gc3Vic3RpdHV0ZVZhcmlhYmxlcyhwYXJzZWQsIHJlc3VsdFsyXSlcbiAgICAgICAgICA6IHJlc3VsdFsyXTtcbiAgICAgICAgY29uc3QgbGV2ZWw6IExldmVsUGFyc2VkID0ge1xuICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgIGJpdHJhdGU6XG4gICAgICAgICAgICBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fFxuICAgICAgICAgICAgYXR0cnMuZGVjaW1hbEludGVnZXIoJ0JBTkRXSURUSCcpLFxuICAgICAgICAgIG5hbWU6IGF0dHJzLk5BTUUsXG4gICAgICAgICAgdXJsOiBNM1U4UGFyc2VyLnJlc29sdmUodXJpLCBiYXNldXJsKSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcbiAgICAgICAgaWYgKHJlc29sdXRpb24pIHtcbiAgICAgICAgICBsZXZlbC53aWR0aCA9IHJlc29sdXRpb24ud2lkdGg7XG4gICAgICAgICAgbGV2ZWwuaGVpZ2h0ID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRDb2RlY3MoXG4gICAgICAgICAgKChhdHRycy5DT0RFQ1MgYXMgc3RyaW5nKSB8fCAnJykuc3BsaXQoL1sgLF0rLykuZmlsdGVyKChjKSA9PiBjKSxcbiAgICAgICAgICBsZXZlbFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChsZXZlbC52aWRlb0NvZGVjICYmIGxldmVsLnZpZGVvQ29kZWMuaW5kZXhPZignYXZjMScpICE9PSAtMSkge1xuICAgICAgICAgIGxldmVsLnZpZGVvQ29kZWMgPSBNM1U4UGFyc2VyLmNvbnZlcnRBVkMxVG9BVkNPVEkobGV2ZWwudmlkZW9Db2RlYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxldmVsLnVua25vd25Db2RlY3M/Lmxlbmd0aCkge1xuICAgICAgICAgIGxldmVsc1dpdGhLbm93bkNvZGVjcy5wdXNoKGxldmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5sZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkge1xuICAgICAgICBjb25zdCB0YWcgPSByZXN1bHRbM107XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSByZXN1bHRbNF07XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgY2FzZSAnU0VTU0lPTi1EQVRBJzoge1xuICAgICAgICAgICAgLy8gI0VYVC1YLVNFU1NJT04tREFUQVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkF0dHJzID0gbmV3IEF0dHJMaXN0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBzZXNzaW9uQXR0cnMsIFtcbiAgICAgICAgICAgICAgICAnREFUQS1JRCcsXG4gICAgICAgICAgICAgICAgJ0xBTkdVQUdFJyxcbiAgICAgICAgICAgICAgICAnVkFMVUUnLFxuICAgICAgICAgICAgICAgICdVUkknLFxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGFJZCA9IHNlc3Npb25BdHRyc1snREFUQS1JRCddO1xuICAgICAgICAgICAgaWYgKGRhdGFJZCkge1xuICAgICAgICAgICAgICBpZiAocGFyc2VkLnNlc3Npb25EYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25EYXRhID0ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25EYXRhW2RhdGFJZF0gPSBzZXNzaW9uQXR0cnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU0VTU0lPTi1LRVknOiB7XG4gICAgICAgICAgICAvLyAjRVhULVgtU0VTU0lPTi1LRVlcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25LZXkgPSBwYXJzZUtleShhdHRyaWJ1dGVzLCBiYXNldXJsLCBwYXJzZWQpO1xuICAgICAgICAgICAgaWYgKHNlc3Npb25LZXkuZW5jcnlwdGVkICYmIHNlc3Npb25LZXkuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgICBpZiAocGFyc2VkLnNlc3Npb25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25LZXlzID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25LZXlzLnB1c2goc2Vzc2lvbktleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICBgW0tleXNdIElnbm9yaW5nIGludmFsaWQgRVhULVgtU0VTU0lPTi1LRVkgdGFnOiBcIiR7YXR0cmlidXRlc31cImBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdERUZJTkUnOiB7XG4gICAgICAgICAgICAvLyAjRVhULVgtREVGSU5FXG4gICAgICAgICAgICBpZiAoX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX18pIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGVBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBbXG4gICAgICAgICAgICAgICAgJ05BTUUnLFxuICAgICAgICAgICAgICAgICdWQUxVRScsXG4gICAgICAgICAgICAgICAgJ1FVRVJZUEFSQU0nLFxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgYWRkVmFyaWFibGVEZWZpbml0aW9uKHBhcnNlZCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBiYXNldXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdDT05URU5ULVNURUVSSU5HJzoge1xuICAgICAgICAgICAgLy8gI0VYVC1YLUNPTlRFTlQtU1RFRVJJTkdcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICBpZiAoX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX18pIHtcbiAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBwYXJzZWQsXG4gICAgICAgICAgICAgICAgY29udGVudFN0ZWVyaW5nQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBbJ1NFUlZFUi1VUkknLCAnUEFUSFdBWS1JRCddXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZWQuY29udGVudFN0ZWVyaW5nID0ge1xuICAgICAgICAgICAgICB1cmk6IE0zVThQYXJzZXIucmVzb2x2ZShcbiAgICAgICAgICAgICAgICBjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzWydTRVJWRVItVVJJJ10sXG4gICAgICAgICAgICAgICAgYmFzZXVybFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBwYXRod2F5SWQ6IGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXNbJ1BBVEhXQVktSUQnXSB8fCAnLicsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1NUQVJUJzoge1xuICAgICAgICAgICAgLy8gI0VYVC1YLVNUQVJUXG4gICAgICAgICAgICBwYXJzZWQuc3RhcnRUaW1lT2Zmc2V0ID0gcGFyc2VTdGFydFRpbWVPZmZzZXQoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpbHRlciBvdXQgbGV2ZWxzIHdpdGggdW5rbm93biBjb2RlY3MgaWYgaXQgZG9lcyBub3QgcmVtb3ZlIGFsbCBsZXZlbHNcbiAgICBjb25zdCBzdHJpcFVua25vd25Db2RlY0xldmVscyA9XG4gICAgICBsZXZlbHNXaXRoS25vd25Db2RlY3MubGVuZ3RoID4gMCAmJlxuICAgICAgbGV2ZWxzV2l0aEtub3duQ29kZWNzLmxlbmd0aCA8IHBhcnNlZC5sZXZlbHMubGVuZ3RoO1xuXG4gICAgcGFyc2VkLmxldmVscyA9IHN0cmlwVW5rbm93bkNvZGVjTGV2ZWxzXG4gICAgICA/IGxldmVsc1dpdGhLbm93bkNvZGVjc1xuICAgICAgOiBwYXJzZWQubGV2ZWxzO1xuICAgIGlmIChwYXJzZWQubGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdubyBsZXZlbHMgZm91bmQgaW4gbWFuaWZlc3QnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICBiYXNldXJsOiBzdHJpbmcsXG4gICAgcGFyc2VkOiBQYXJzZWRNdWx0aXZhcmlhbnRQbGF5bGlzdFxuICApOiBQYXJzZWRNdWx0aXZhcmlhbnRNZWRpYU9wdGlvbnMge1xuICAgIGxldCByZXN1bHQ6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGw7XG4gICAgY29uc3QgcmVzdWx0czogUGFyc2VkTXVsdGl2YXJpYW50TWVkaWFPcHRpb25zID0ge307XG4gICAgY29uc3QgbGV2ZWxzID0gcGFyc2VkLmxldmVscztcbiAgICBjb25zdCBncm91cHNCeVR5cGUgPSB7XG4gICAgICBBVURJTzogbGV2ZWxzLm1hcCgobGV2ZWw6IExldmVsUGFyc2VkKSA9PiAoe1xuICAgICAgICBpZDogbGV2ZWwuYXR0cnMuQVVESU8sXG4gICAgICAgIGF1ZGlvQ29kZWM6IGxldmVsLmF1ZGlvQ29kZWMsXG4gICAgICB9KSksXG4gICAgICBTVUJUSVRMRVM6IGxldmVscy5tYXAoKGxldmVsOiBMZXZlbFBhcnNlZCkgPT4gKHtcbiAgICAgICAgaWQ6IGxldmVsLmF0dHJzLlNVQlRJVExFUyxcbiAgICAgICAgdGV4dENvZGVjOiBsZXZlbC50ZXh0Q29kZWMsXG4gICAgICB9KSksXG4gICAgICAnQ0xPU0VELUNBUFRJT05TJzogW10sXG4gICAgfTtcbiAgICBsZXQgaWQgPSAwO1xuICAgIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSkgYXMgTWVkaWFBdHRyaWJ1dGVzO1xuICAgICAgY29uc3QgdHlwZTogTWVkaWFQbGF5bGlzdFR5cGUgfCB1bmRlZmluZWQgPSBhdHRycy5UWVBFIGFzXG4gICAgICAgIHwgTWVkaWFQbGF5bGlzdFR5cGVcbiAgICAgICAgfCB1bmRlZmluZWQ7XG4gICAgICBpZiAodHlwZSkge1xuICAgICAgICBjb25zdCBncm91cHMgPSBncm91cHNCeVR5cGVbdHlwZV07XG4gICAgICAgIGNvbnN0IG1lZGlhczogTWVkaWFQbGF5bGlzdFtdID0gcmVzdWx0c1t0eXBlXSB8fCBbXTtcbiAgICAgICAgcmVzdWx0c1t0eXBlXSA9IG1lZGlhcztcbiAgICAgICAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIGF0dHJzLCBbXG4gICAgICAgICAgICAnVVJJJyxcbiAgICAgICAgICAgICdHUk9VUC1JRCcsXG4gICAgICAgICAgICAnTEFOR1VBR0UnLFxuICAgICAgICAgICAgJ0FTU09DLUxBTkdVQUdFJyxcbiAgICAgICAgICAgICdTVEFCTEUtUkVORElUSU9OLUlEJyxcbiAgICAgICAgICAgICdOQU1FJyxcbiAgICAgICAgICAgICdJTlNUUkVBTS1JRCcsXG4gICAgICAgICAgICAnQ0hBUkFDVEVSSVNUSUNTJyxcbiAgICAgICAgICAgICdDSEFOTkVMUycsXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVkaWE6IE1lZGlhUGxheWxpc3QgPSB7XG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICBpZDogaWQrKyxcbiAgICAgICAgICBncm91cElkOiBhdHRyc1snR1JPVVAtSUQnXSB8fCAnJyxcbiAgICAgICAgICBpbnN0cmVhbUlkOiBhdHRyc1snSU5TVFJFQU0tSUQnXSxcbiAgICAgICAgICBuYW1lOiBhdHRycy5OQU1FIHx8IGF0dHJzLkxBTkdVQUdFIHx8ICcnLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZGVmYXVsdDogYXR0cnMuYm9vbCgnREVGQVVMVCcpLFxuICAgICAgICAgIGF1dG9zZWxlY3Q6IGF0dHJzLmJvb2woJ0FVVE9TRUxFQ1QnKSxcbiAgICAgICAgICBmb3JjZWQ6IGF0dHJzLmJvb2woJ0ZPUkNFRCcpLFxuICAgICAgICAgIGxhbmc6IGF0dHJzLkxBTkdVQUdFLFxuICAgICAgICAgIHVybDogYXR0cnMuVVJJID8gTTNVOFBhcnNlci5yZXNvbHZlKGF0dHJzLlVSSSwgYmFzZXVybCkgOiAnJyxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ3JvdXBzPy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYXVkaW8gb3IgdGV4dCBncm91cHMgc2lnbmFsbGVkIGluIHRoZSBtYW5pZmVzdCwgbGV0J3MgbG9vayBmb3IgYSBtYXRjaGluZyBjb2RlYyBzdHJpbmcgZm9yIHRoaXMgdHJhY2tcbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIHRoZSB0cmFjayBzaWduYWxsZWQsIGxldHMgdXNlIHRoZSBmaXJzdCBhdWRpbyBncm91cHMgY29kZWMgd2UgaGF2ZVxuICAgICAgICAgIC8vIEFjdGluZyBhcyBhIGJlc3QgZ3Vlc3NcbiAgICAgICAgICBjb25zdCBncm91cENvZGVjID1cbiAgICAgICAgICAgIE0zVThQYXJzZXIuZmluZEdyb3VwKGdyb3VwcywgbWVkaWEuZ3JvdXBJZCBhcyBzdHJpbmcpIHx8IGdyb3Vwc1swXTtcbiAgICAgICAgICBhc3NpZ25Db2RlYyhtZWRpYSwgZ3JvdXBDb2RlYywgJ2F1ZGlvQ29kZWMnKTtcbiAgICAgICAgICBhc3NpZ25Db2RlYyhtZWRpYSwgZ3JvdXBDb2RlYywgJ3RleHRDb2RlYycpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVkaWFzLnB1c2gobWVkaWEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUxldmVsUGxheWxpc3QoXG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgYmFzZXVybDogc3RyaW5nLFxuICAgIGlkOiBudW1iZXIsXG4gICAgdHlwZTogUGxheWxpc3RMZXZlbFR5cGUsXG4gICAgbGV2ZWxVcmxJZDogbnVtYmVyLFxuICAgIG11bHRpdmFyaWFudFZhcmlhYmxlTGlzdDogVmFyaWFibGVNYXAgfCBudWxsXG4gICk6IExldmVsRGV0YWlscyB7XG4gICAgY29uc3QgbGV2ZWwgPSBuZXcgTGV2ZWxEZXRhaWxzKGJhc2V1cmwpO1xuICAgIGNvbnN0IGZyYWdtZW50czogTTNVOFBhcnNlckZyYWdtZW50cyA9IGxldmVsLmZyYWdtZW50cztcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgaW5pdCBzZWdtZW50IHNlZW4gKGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgc2VnbWVudHMpXG4gICAgbGV0IGN1cnJlbnRJbml0U2VnbWVudDogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgY3VycmVudFNOID0gMDtcbiAgICBsZXQgY3VycmVudFBhcnQgPSAwO1xuICAgIGxldCB0b3RhbGR1cmF0aW9uID0gMDtcbiAgICBsZXQgZGlzY29udGludWl0eUNvdW50ZXIgPSAwO1xuICAgIGxldCBwcmV2RnJhZzogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgZnJhZzogRnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQodHlwZSwgYmFzZXVybCk7XG4gICAgbGV0IHJlc3VsdDogUmVnRXhwRXhlY0FycmF5IHwgUmVnRXhwTWF0Y2hBcnJheSB8IG51bGw7XG4gICAgbGV0IGk6IG51bWJlcjtcbiAgICBsZXQgbGV2ZWxrZXlzOiB7IFtrZXk6IHN0cmluZ106IExldmVsS2V5IH0gfCB1bmRlZmluZWQ7XG4gICAgbGV0IGZpcnN0UGR0SW5kZXggPSAtMTtcbiAgICBsZXQgY3JlYXRlTmV4dEZyYWcgPSBmYWxzZTtcblxuICAgIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QubGFzdEluZGV4ID0gMDtcbiAgICBsZXZlbC5tM3U4ID0gc3RyaW5nO1xuICAgIGxldmVsLmhhc1ZhcmlhYmxlUmVmcyA9IF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fXG4gICAgICA/IGhhc1ZhcmlhYmxlUmVmZXJlbmNlcyhzdHJpbmcpXG4gICAgICA6IGZhbHNlO1xuXG4gICAgd2hpbGUgKChyZXN1bHQgPSBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIGlmIChjcmVhdGVOZXh0RnJhZykge1xuICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IGZhbHNlO1xuICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2V1cmwpO1xuICAgICAgICAvLyBzZXR1cCB0aGUgbmV4dCBmcmFnbWVudCBmb3IgcGFydCBsb2FkaW5nXG4gICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICBmcmFnLnNuID0gY3VycmVudFNOO1xuICAgICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgaWYgKGN1cnJlbnRJbml0U2VnbWVudCkge1xuICAgICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcmVzdWx0WzFdO1xuICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgIC8vIElORlxuICAgICAgICBmcmFnLmR1cmF0aW9uID0gcGFyc2VGbG9hdChkdXJhdGlvbik7XG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgY29uc3QgdGl0bGUgPSAoJyAnICsgcmVzdWx0WzJdKS5zbGljZSgxKTtcbiAgICAgICAgZnJhZy50aXRsZSA9IHRpdGxlIHx8IG51bGw7XG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHRpdGxlID8gWydJTkYnLCBkdXJhdGlvbiwgdGl0bGVdIDogWydJTkYnLCBkdXJhdGlvbl0pO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHtcbiAgICAgICAgLy8gdXJsXG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgICBmcmFnLnN0YXJ0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgICBpZiAobGV2ZWxrZXlzKSB7XG4gICAgICAgICAgICBzZXRGcmFnTGV2ZWxLZXlzKGZyYWcsIGxldmVsa2V5cywgbGV2ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFnLnNuID0gY3VycmVudFNOO1xuICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICAgICAgZnJhZy51cmxJZCA9IGxldmVsVXJsSWQ7XG4gICAgICAgICAgZnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgIGNvbnN0IHVyaSA9ICgnICcgKyByZXN1bHRbM10pLnNsaWNlKDEpO1xuICAgICAgICAgIGZyYWcucmVsdXJsID0gX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX19cbiAgICAgICAgICAgID8gc3Vic3RpdHV0ZVZhcmlhYmxlcyhsZXZlbCwgdXJpKVxuICAgICAgICAgICAgOiB1cmk7XG4gICAgICAgICAgYXNzaWduUHJvZ3JhbURhdGVUaW1lKGZyYWcsIHByZXZGcmFnKTtcbiAgICAgICAgICBwcmV2RnJhZyA9IGZyYWc7XG4gICAgICAgICAgdG90YWxkdXJhdGlvbiArPSBmcmFnLmR1cmF0aW9uO1xuICAgICAgICAgIGN1cnJlbnRTTisrO1xuICAgICAgICAgIGN1cnJlbnRQYXJ0ID0gMDtcbiAgICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzRdKSB7XG4gICAgICAgIC8vIFgtQllURVJBTkdFXG4gICAgICAgIGNvbnN0IGRhdGEgPSAoJyAnICsgcmVzdWx0WzRdKS5zbGljZSgxKTtcbiAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UoZGF0YSwgcHJldkZyYWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs1XSkge1xuICAgICAgICAvLyBQUk9HUkFNLURBVEUtVElNRVxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gKCcgJyArIHJlc3VsdFs1XSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnUFJPR1JBTS1EQVRFLVRJTUUnLCBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZV0pO1xuICAgICAgICBpZiAoZmlyc3RQZHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBmaXJzdFBkdEluZGV4ID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdLm1hdGNoKExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdObyBtYXRjaGVzIG9uIHNsb3cgcmVnZXggbWF0Y2ggZm9yIGxldmVsIHBsYXlsaXN0IScpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgY29uc3QgdGFnID0gKCcgJyArIHJlc3VsdFtpXSkuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IHZhbHVlMSA9ICgnICcgKyByZXN1bHRbaSArIDFdKS5zbGljZSgxKTtcbiAgICAgICAgY29uc3QgdmFsdWUyID0gcmVzdWx0W2kgKyAyXSA/ICgnICcgKyByZXN1bHRbaSArIDJdKS5zbGljZSgxKSA6ICcnO1xuXG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XG4gICAgICAgICAgICBsZXZlbC50eXBlID0gdmFsdWUxLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNRURJQS1TRVFVRU5DRSc6XG4gICAgICAgICAgICBjdXJyZW50U04gPSBsZXZlbC5zdGFydFNOID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1NLSVAnOiB7XG4gICAgICAgICAgICBjb25zdCBza2lwQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBza2lwQXR0cnMsIFtcbiAgICAgICAgICAgICAgICAnUkVDRU5UTFktUkVNT1ZFRC1EQVRFUkFOR0VTJyxcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBza2lwcGVkU2VnbWVudHMgPVxuICAgICAgICAgICAgICBza2lwQXR0cnMuZGVjaW1hbEludGVnZXIoJ1NLSVBQRUQtU0VHTUVOVFMnKTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc2tpcHBlZFNlZ21lbnRzKSkge1xuICAgICAgICAgICAgICBsZXZlbC5za2lwcGVkU2VnbWVudHMgPSBza2lwcGVkU2VnbWVudHM7XG4gICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCByZXN1bHQgaW4gZnJhZ21lbnRzW10gY29udGFpbmluZyB1bmRlZmluZWQgdmFsdWVzLCB3aGljaCB3ZSB3aWxsIGZpbGwgaW4gd2l0aCBgbWVyZ2VEZXRhaWxzYFxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gc2tpcHBlZFNlZ21lbnRzOyBpLS07ICkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50cy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnRTTiArPSBza2lwcGVkU2VnbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzID0gc2tpcEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoXG4gICAgICAgICAgICAgICdSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMpIHtcbiAgICAgICAgICAgICAgbGV2ZWwucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9XG4gICAgICAgICAgICAgICAgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcy5zcGxpdCgnXFx0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBNYXRoLm1heChwYXJzZUludCh2YWx1ZTEpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1ZFUlNJT04nOlxuICAgICAgICAgICAgbGV2ZWwudmVyc2lvbiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdFWFRNM1UnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRU5ETElTVCc6XG4gICAgICAgICAgICBsZXZlbC5saXZlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIGlmICh2YWx1ZTEgfHwgdmFsdWUyKSB7XG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFt2YWx1ZTEsIHZhbHVlMl0gOiBbdmFsdWUxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZJzpcbiAgICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyKys7XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0dBUCc6XG4gICAgICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbdGFnXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdCSVRSQVRFJzpcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFt0YWcsIHZhbHVlMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnREFURVJBTkdFJzoge1xuICAgICAgICAgICAgY29uc3QgZGF0ZVJhbmdlQXR0ciA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIGRhdGVSYW5nZUF0dHIsIFtcbiAgICAgICAgICAgICAgICAnSUQnLFxuICAgICAgICAgICAgICAgICdDTEFTUycsXG4gICAgICAgICAgICAgICAgJ1NUQVJULURBVEUnLFxuICAgICAgICAgICAgICAgICdFTkQtREFURScsXG4gICAgICAgICAgICAgICAgJ1NDVEUzNS1DTUQnLFxuICAgICAgICAgICAgICAgICdTQ1RFMzUtT1VUJyxcbiAgICAgICAgICAgICAgICAnU0NURTM1LUlOJyxcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgZGF0ZVJhbmdlQXR0cixcbiAgICAgICAgICAgICAgICBkYXRlUmFuZ2VBdHRyLmNsaWVudEF0dHJzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRlUmFuZ2UgPSBuZXcgRGF0ZVJhbmdlKFxuICAgICAgICAgICAgICBkYXRlUmFuZ2VBdHRyLFxuICAgICAgICAgICAgICBsZXZlbC5kYXRlUmFuZ2VzW2RhdGVSYW5nZUF0dHIuSURdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5pc1ZhbGlkIHx8IGxldmVsLnNraXBwZWRTZWdtZW50cykge1xuICAgICAgICAgICAgICBsZXZlbC5kYXRlUmFuZ2VzW2RhdGVSYW5nZS5pZF0gPSBkYXRlUmFuZ2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybihgSWdub3JpbmcgaW52YWxpZCBEQVRFUkFOR0UgdGFnOiBcIiR7dmFsdWUxfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdG8gZnJhZ21lbnQgdGFnIGxpc3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICg8IHYxLjIuMClcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnRVhULVgtREFURVJBTkdFJywgdmFsdWUxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnREVGSU5FJzoge1xuICAgICAgICAgICAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlQXR0cmlidXRlcyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIFtcbiAgICAgICAgICAgICAgICAnTkFNRScsXG4gICAgICAgICAgICAgICAgJ1ZBTFVFJyxcbiAgICAgICAgICAgICAgICAnSU1QT1JUJyxcbiAgICAgICAgICAgICAgICAnUVVFUllQQVJBTScsXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICBpZiAoJ0lNUE9SVCcgaW4gdmFyaWFibGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0VmFyaWFibGVEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgICB2YXJpYWJsZUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICBtdWx0aXZhcmlhbnRWYXJpYWJsZUxpc3RcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFZhcmlhYmxlRGVmaW5pdGlvbihsZXZlbCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBiYXNldXJsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnRElTQ09OVElOVUlUWS1TRVFVRU5DRSc6XG4gICAgICAgICAgICBkaXNjb250aW51aXR5Q291bnRlciA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdLRVknOiB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbEtleSA9IHBhcnNlS2V5KHZhbHVlMSwgYmFzZXVybCwgbGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGxldmVsS2V5LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsS2V5Lm1ldGhvZCA9PT0gJ05PTkUnKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghbGV2ZWxrZXlzKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxldmVsa2V5c1tsZXZlbEtleS5rZXlGb3JtYXRdKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0gT2JqZWN0LmFzc2lnbih7fSwgbGV2ZWxrZXlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXZlbGtleXNbbGV2ZWxLZXkua2V5Rm9ybWF0XSA9IGxldmVsS2V5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFtLZXlzXSBJZ25vcmluZyBpbnZhbGlkIEVYVC1YLUtFWSB0YWc6IFwiJHt2YWx1ZTF9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICBsZXZlbC5zdGFydFRpbWVPZmZzZXQgPSBwYXJzZVN0YXJ0VGltZU9mZnNldCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTUFQJzoge1xuICAgICAgICAgICAgY29uc3QgbWFwQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBtYXBBdHRycywgW1xuICAgICAgICAgICAgICAgICdCWVRFUkFOR0UnLFxuICAgICAgICAgICAgICAgICdVUkknLFxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFnLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIEluaXRpYWwgc2VnbWVudCB0YWcgaXMgYWZ0ZXIgc2VnbWVudCBkdXJhdGlvbiB0YWcuXG4gICAgICAgICAgICAgIC8vICAgI0VYVElORjogNi4wXG4gICAgICAgICAgICAgIC8vICAgI0VYVC1YLU1BUDpVUkk9XCJpbml0Lm1wNFxuICAgICAgICAgICAgICBjb25zdCBpbml0ID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICBzZXRJbml0U2VnbWVudChpbml0LCBtYXBBdHRycywgaWQsIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGluaXQ7XG4gICAgICAgICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lICYmXG4gICAgICAgICAgICAgICAgIWZyYWcucmF3UHJvZ3JhbURhdGVUaW1lXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzZWdtZW50IHRhZyBpcyBiZWZvcmUgc2VnbWVudCBkdXJhdGlvbiB0YWdcbiAgICAgICAgICAgICAgc2V0SW5pdFNlZ21lbnQoZnJhZywgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBmcmFnO1xuICAgICAgICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU0VSVkVSLUNPTlRST0wnOiB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJDb250cm9sQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgIGxldmVsLmNhbkJsb2NrUmVsb2FkID0gc2VydmVyQ29udHJvbEF0dHJzLmJvb2woJ0NBTi1CTE9DSy1SRUxPQUQnKTtcbiAgICAgICAgICAgIGxldmVsLmNhblNraXBVbnRpbCA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KFxuICAgICAgICAgICAgICAnQ0FOLVNLSVAtVU5USUwnLFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV2ZWwuY2FuU2tpcERhdGVSYW5nZXMgPVxuICAgICAgICAgICAgICBsZXZlbC5jYW5Ta2lwVW50aWwgPiAwICYmXG4gICAgICAgICAgICAgIHNlcnZlckNvbnRyb2xBdHRycy5ib29sKCdDQU4tU0tJUC1EQVRFUkFOR0VTJyk7XG4gICAgICAgICAgICBsZXZlbC5wYXJ0SG9sZEJhY2sgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdChcbiAgICAgICAgICAgICAgJ1BBUlQtSE9MRC1CQUNLJyxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldmVsLmhvbGRCYWNrID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ0hPTEQtQkFDSycsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1BBUlQtSU5GJzoge1xuICAgICAgICAgICAgY29uc3QgcGFydEluZkF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICBsZXZlbC5wYXJ0VGFyZ2V0ID0gcGFydEluZkF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdQQVJULVRBUkdFVCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1BBUlQnOiB7XG4gICAgICAgICAgICBsZXQgcGFydExpc3QgPSBsZXZlbC5wYXJ0TGlzdDtcbiAgICAgICAgICAgIGlmICghcGFydExpc3QpIHtcbiAgICAgICAgICAgICAgcGFydExpc3QgPSBsZXZlbC5wYXJ0TGlzdCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGcmFnbWVudFBhcnQgPVxuICAgICAgICAgICAgICBjdXJyZW50UGFydCA+IDAgPyBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY3VycmVudFBhcnQrKztcbiAgICAgICAgICAgIGNvbnN0IHBhcnRBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHBhcnRBdHRycywgW1xuICAgICAgICAgICAgICAgICdCWVRFUkFOR0UnLFxuICAgICAgICAgICAgICAgICdVUkknLFxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBuZXcgUGFydChcbiAgICAgICAgICAgICAgcGFydEF0dHJzLFxuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBiYXNldXJsLFxuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgcHJldmlvdXNGcmFnbWVudFBhcnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwYXJ0TGlzdC5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgZnJhZy5kdXJhdGlvbiArPSBwYXJ0LmR1cmF0aW9uO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1BSRUxPQUQtSElOVCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHByZWxvYWRIaW50QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBwcmVsb2FkSGludEF0dHJzLCBbJ1VSSSddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsLnByZWxvYWRIaW50ID0gcHJlbG9hZEhpbnRBdHRycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdSRU5ESVRJT04tUkVQT1JUJzoge1xuICAgICAgICAgICAgY29uc3QgcmVuZGl0aW9uUmVwb3J0QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCByZW5kaXRpb25SZXBvcnRBdHRycywgW1xuICAgICAgICAgICAgICAgICdVUkknLFxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsLnJlbmRpdGlvblJlcG9ydHMgPSBsZXZlbC5yZW5kaXRpb25SZXBvcnRzIHx8IFtdO1xuICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cy5wdXNoKHJlbmRpdGlvblJlcG9ydEF0dHJzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGxpbmUgcGFyc2VkIGJ1dCBub3QgaGFuZGxlZDogJHtyZXN1bHR9YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldkZyYWcgJiYgIXByZXZGcmFnLnJlbHVybCkge1xuICAgICAgZnJhZ21lbnRzLnBvcCgpO1xuICAgICAgdG90YWxkdXJhdGlvbiAtPSBwcmV2RnJhZy5kdXJhdGlvbjtcbiAgICAgIGlmIChsZXZlbC5wYXJ0TGlzdCkge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEhpbnQgPSBwcmV2RnJhZztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxldmVsLnBhcnRMaXN0KSB7XG4gICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpO1xuICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRIaW50ID0gZnJhZztcbiAgICAgIGlmIChsZXZlbGtleXMpIHtcbiAgICAgICAgc2V0RnJhZ0xldmVsS2V5cyhmcmFnLCBsZXZlbGtleXMsIGxldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJhZ21lbnRMZW5ndGggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IGZpcnN0RnJhZ21lbnQgPSBmcmFnbWVudHNbMF07XG4gICAgY29uc3QgbGFzdEZyYWdtZW50ID0gZnJhZ21lbnRzW2ZyYWdtZW50TGVuZ3RoIC0gMV07XG4gICAgdG90YWxkdXJhdGlvbiArPSBsZXZlbC5za2lwcGVkU2VnbWVudHMgKiBsZXZlbC50YXJnZXRkdXJhdGlvbjtcbiAgICBpZiAodG90YWxkdXJhdGlvbiA+IDAgJiYgZnJhZ21lbnRMZW5ndGggJiYgbGFzdEZyYWdtZW50KSB7XG4gICAgICBsZXZlbC5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uIC8gZnJhZ21lbnRMZW5ndGg7XG4gICAgICBjb25zdCBsYXN0U24gPSBsYXN0RnJhZ21lbnQuc247XG4gICAgICBsZXZlbC5lbmRTTiA9IGxhc3RTbiAhPT0gJ2luaXRTZWdtZW50JyA/IGxhc3RTbiA6IDA7XG4gICAgICBpZiAoIWxldmVsLmxpdmUpIHtcbiAgICAgICAgbGFzdEZyYWdtZW50LmVuZExpc3QgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0RnJhZ21lbnQpIHtcbiAgICAgICAgbGV2ZWwuc3RhcnRDQyA9IGZpcnN0RnJhZ21lbnQuY2M7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVsLmVuZFNOID0gMDtcbiAgICAgIGxldmVsLnN0YXJ0Q0MgPSAwO1xuICAgIH1cbiAgICBpZiAobGV2ZWwuZnJhZ21lbnRIaW50KSB7XG4gICAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLmZyYWdtZW50SGludC5kdXJhdGlvbjtcbiAgICB9XG4gICAgbGV2ZWwudG90YWxkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb247XG4gICAgbGV2ZWwuZW5kQ0MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcblxuICAgIC8qKlxuICAgICAqIEJhY2tmaWxsIGFueSBtaXNzaW5nIFBEVCB2YWx1ZXNcbiAgICAgKiBcIklmIHRoZSBmaXJzdCBFWFQtWC1QUk9HUkFNLURBVEUtVElNRSB0YWcgaW4gYSBQbGF5bGlzdCBhcHBlYXJzIGFmdGVyXG4gICAgICogb25lIG9yIG1vcmUgTWVkaWEgU2VnbWVudCBVUklzLCB0aGUgY2xpZW50IFNIT1VMRCBleHRyYXBvbGF0ZVxuICAgICAqIGJhY2t3YXJkIGZyb20gdGhhdCB0YWcgKHVzaW5nIEVYVElORiBkdXJhdGlvbnMgYW5kL29yIG1lZGlhXG4gICAgICogdGltZXN0YW1wcykgdG8gYXNzb2NpYXRlIGRhdGVzIHdpdGggdGhvc2Ugc2VnbWVudHMuXCJcbiAgICAgKiBXZSBoYXZlIGFscmVhZHkgZXh0cmFwb2xhdGVkIGZvcndhcmQsIGJ1dCBhbGwgZnJhZ21lbnRzIHVwIHRvIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBQRFQgZG8gbm90IGhhdmUgdGhlaXIgUERUc1xuICAgICAqIGNvbXB1dGVkLlxuICAgICAqL1xuICAgIGlmIChmaXJzdFBkdEluZGV4ID4gMCkge1xuICAgICAgYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGZyYWdtZW50cywgZmlyc3RQZHRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlS2V5KFxuICBrZXlUYWdBdHRyaWJ1dGVzOiBzdHJpbmcsXG4gIGJhc2V1cmw6IHN0cmluZyxcbiAgcGFyc2VkOiBQYXJzZWRNdWx0aXZhcmlhbnRQbGF5bGlzdCB8IExldmVsRGV0YWlsc1xuKTogTGV2ZWxLZXkge1xuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjODIxNiNzZWN0aW9uLTQuMy4yLjRcbiAgY29uc3Qga2V5QXR0cnMgPSBuZXcgQXR0ckxpc3Qoa2V5VGFnQXR0cmlidXRlcyk7XG4gIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBrZXlBdHRycywgW1xuICAgICAgJ0tFWUZPUk1BVCcsXG4gICAgICAnS0VZRk9STUFUVkVSU0lPTlMnLFxuICAgICAgJ1VSSScsXG4gICAgICAnSVYnLFxuICAgICAgJ1VSSScsXG4gICAgXSk7XG4gIH1cbiAgY29uc3QgZGVjcnlwdG1ldGhvZCA9IGtleUF0dHJzLk1FVEhPRCA/PyAnJztcbiAgY29uc3QgZGVjcnlwdHVyaSA9IGtleUF0dHJzLlVSSTtcbiAgY29uc3QgZGVjcnlwdGl2ID0ga2V5QXR0cnMuaGV4YWRlY2ltYWxJbnRlZ2VyKCdJVicpO1xuICBjb25zdCBkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnMgPSBrZXlBdHRycy5LRVlGT1JNQVRWRVJTSU9OUztcbiAgLy8gRnJvbSBSRkM6IFRoaXMgYXR0cmlidXRlIGlzIE9QVElPTkFMOyBpdHMgYWJzZW5jZSBpbmRpY2F0ZXMgYW4gaW1wbGljaXQgdmFsdWUgb2YgXCJpZGVudGl0eVwiLlxuICBjb25zdCBkZWNyeXB0a2V5Zm9ybWF0ID0ga2V5QXR0cnMuS0VZRk9STUFUID8/ICdpZGVudGl0eSc7XG5cbiAgaWYgKGRlY3J5cHR1cmkgJiYga2V5QXR0cnMuSVYgJiYgIWRlY3J5cHRpdikge1xuICAgIGxvZ2dlci5lcnJvcihgSW52YWxpZCBJVjogJHtrZXlBdHRycy5JVn1gKTtcbiAgfVxuICAvLyBJZiBkZWNyeXB0dXJpIGlzIGEgVVJJIHdpdGggYSBzY2hlbWUsIHRoZW4gYmFzZXVybCB3aWxsIGJlIGlnbm9yZWRcbiAgLy8gTm8gdXJpIGlzIGFsbG93ZWQgd2hlbiBNRVRIT0QgaXMgTk9ORVxuICBjb25zdCByZXNvbHZlZFVyaSA9IGRlY3J5cHR1cmkgPyBNM1U4UGFyc2VyLnJlc29sdmUoZGVjcnlwdHVyaSwgYmFzZXVybCkgOiAnJztcbiAgY29uc3Qga2V5Rm9ybWF0VmVyc2lvbnMgPSAoXG4gICAgZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zID8gZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zIDogJzEnXG4gIClcbiAgICAuc3BsaXQoJy8nKVxuICAgIC5tYXAoTnVtYmVyKVxuICAgIC5maWx0ZXIoTnVtYmVyLmlzRmluaXRlKTtcblxuICByZXR1cm4gbmV3IExldmVsS2V5KFxuICAgIGRlY3J5cHRtZXRob2QsXG4gICAgcmVzb2x2ZWRVcmksXG4gICAgZGVjcnlwdGtleWZvcm1hdCxcbiAgICBrZXlGb3JtYXRWZXJzaW9ucyxcbiAgICBkZWNyeXB0aXZcbiAgKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTdGFydFRpbWVPZmZzZXQoc3RhcnRBdHRyaWJ1dGVzOiBzdHJpbmcpOiBudW1iZXIgfCBudWxsIHtcbiAgY29uc3Qgc3RhcnRBdHRycyA9IG5ldyBBdHRyTGlzdChzdGFydEF0dHJpYnV0ZXMpO1xuICBjb25zdCBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpO1xuICBpZiAoTnVtYmVyLmlzRmluaXRlKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICByZXR1cm4gc3RhcnRUaW1lT2Zmc2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDb2RlY3MoY29kZWNzOiBBcnJheTxzdHJpbmc+LCBsZXZlbDogTGV2ZWxQYXJzZWQpIHtcbiAgWyd2aWRlbycsICdhdWRpbycsICd0ZXh0J10uZm9yRWFjaCgodHlwZTogQ29kZWNUeXBlKSA9PiB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBjb2RlY3MuZmlsdGVyKChjb2RlYykgPT4gaXNDb2RlY1R5cGUoY29kZWMsIHR5cGUpKTtcbiAgICBpZiAoZmlsdGVyZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwcmVmZXJyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKGNvZGVjKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29kZWMubGFzdEluZGV4T2YoJ2F2YzEnLCAwKSA9PT0gMCB8fFxuICAgICAgICAgIGNvZGVjLmxhc3RJbmRleE9mKCdtcDRhJywgMCkgPT09IDBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgbGV2ZWxbYCR7dHlwZX1Db2RlY2BdID0gcHJlZmVycmVkLmxlbmd0aCA+IDAgPyBwcmVmZXJyZWRbMF0gOiBmaWx0ZXJlZFswXTtcblxuICAgICAgLy8gcmVtb3ZlIGZyb20gbGlzdFxuICAgICAgY29kZWNzID0gY29kZWNzLmZpbHRlcigoY29kZWMpID0+IGZpbHRlcmVkLmluZGV4T2YoY29kZWMpID09PSAtMSk7XG4gICAgfVxuICB9KTtcblxuICBsZXZlbC51bmtub3duQ29kZWNzID0gY29kZWNzO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25Db2RlYyhtZWRpYSwgZ3JvdXBJdGVtLCBjb2RlY1Byb3BlcnR5KSB7XG4gIGNvbnN0IGNvZGVjVmFsdWUgPSBncm91cEl0ZW1bY29kZWNQcm9wZXJ0eV07XG4gIGlmIChjb2RlY1ZhbHVlKSB7XG4gICAgbWVkaWFbY29kZWNQcm9wZXJ0eV0gPSBjb2RlY1ZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhY2tmaWxsUHJvZ3JhbURhdGVUaW1lcyhcbiAgZnJhZ21lbnRzOiBNM1U4UGFyc2VyRnJhZ21lbnRzLFxuICBmaXJzdFBkdEluZGV4OiBudW1iZXJcbikge1xuICBsZXQgZnJhZ1ByZXYgPSBmcmFnbWVudHNbZmlyc3RQZHRJbmRleF0gYXMgRnJhZ21lbnQ7XG4gIGZvciAobGV0IGkgPSBmaXJzdFBkdEluZGV4OyBpLS07ICkge1xuICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudHNbaV07XG4gICAgLy8gRXhpdCBvbiBkZWx0YS1wbGF5bGlzdCBza2lwcGVkIHNlZ21lbnRzXG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID1cbiAgICAgIChmcmFnUHJldi5wcm9ncmFtRGF0ZVRpbWUgYXMgbnVtYmVyKSAtIGZyYWcuZHVyYXRpb24gKiAxMDAwO1xuICAgIGZyYWdQcmV2ID0gZnJhZztcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpIHtcbiAgaWYgKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBEYXRlLnBhcnNlKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKTtcbiAgfSBlbHNlIGlmIChwcmV2RnJhZz8ucHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBwcmV2RnJhZy5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIH1cblxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFnLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEluaXRTZWdtZW50KFxuICBmcmFnOiBGcmFnbWVudCxcbiAgbWFwQXR0cnM6IEF0dHJMaXN0LFxuICBpZDogbnVtYmVyLFxuICBsZXZlbGtleXM6IHsgW2tleTogc3RyaW5nXTogTGV2ZWxLZXkgfSB8IHVuZGVmaW5lZFxuKSB7XG4gIGZyYWcucmVsdXJsID0gbWFwQXR0cnMuVVJJO1xuICBpZiAobWFwQXR0cnMuQllURVJBTkdFKSB7XG4gICAgZnJhZy5zZXRCeXRlUmFuZ2UobWFwQXR0cnMuQllURVJBTkdFKTtcbiAgfVxuICBmcmFnLmxldmVsID0gaWQ7XG4gIGZyYWcuc24gPSAnaW5pdFNlZ21lbnQnO1xuICBpZiAobGV2ZWxrZXlzKSB7XG4gICAgZnJhZy5sZXZlbGtleXMgPSBsZXZlbGtleXM7XG4gIH1cbiAgZnJhZy5pbml0U2VnbWVudCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEZyYWdMZXZlbEtleXMoXG4gIGZyYWc6IEZyYWdtZW50LFxuICBsZXZlbGtleXM6IHsgW2tleTogc3RyaW5nXTogTGV2ZWxLZXkgfSxcbiAgbGV2ZWw6IExldmVsRGV0YWlsc1xuKSB7XG4gIGZyYWcubGV2ZWxrZXlzID0gbGV2ZWxrZXlzO1xuICBjb25zdCB7IGVuY3J5cHRlZEZyYWdtZW50cyB9ID0gbGV2ZWw7XG4gIGlmIChcbiAgICAoIWVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGggfHxcbiAgICAgIGVuY3J5cHRlZEZyYWdtZW50c1tlbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoIC0gMV0ubGV2ZWxrZXlzICE9PVxuICAgICAgICBsZXZlbGtleXMpICYmXG4gICAgT2JqZWN0LmtleXMobGV2ZWxrZXlzKS5zb21lKFxuICAgICAgKGZvcm1hdCkgPT4gbGV2ZWxrZXlzIVtmb3JtYXRdLmlzQ29tbW9uRW5jcnlwdGlvblxuICAgIClcbiAgKSB7XG4gICAgZW5jcnlwdGVkRnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgTG9hZGVyQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB0eXBlIHsgRnJhZ21lbnQgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBQYXJ0IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB0eXBlIHsgS2V5TG9hZGVySW5mbyB9IGZyb20gJy4uL2xvYWRlci9rZXktbG9hZGVyJztcbmltcG9ydCB0eXBlIHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWRldGFpbHMnO1xuaW1wb3J0IHR5cGUgeyBIbHNVcmxQYXJhbWV0ZXJzIH0gZnJvbSAnLi9sZXZlbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyQ29udGV4dCB7XG4gIC8vIHRhcmdldCBVUkxcbiAgdXJsOiBzdHJpbmc7XG4gIC8vIGxvYWRlciByZXNwb25zZSB0eXBlIChhcnJheWJ1ZmZlciBvciBkZWZhdWx0IHJlc3BvbnNlIHR5cGUgZm9yIHBsYXlsaXN0KVxuICByZXNwb25zZVR5cGU6IHN0cmluZztcbiAgLy8gaGVhZGVyc1xuICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgLy8gc3RhcnQgYnl0ZSByYW5nZSBvZmZzZXRcbiAgcmFuZ2VTdGFydD86IG51bWJlcjtcbiAgLy8gZW5kIGJ5dGUgcmFuZ2Ugb2Zmc2V0XG4gIHJhbmdlRW5kPzogbnVtYmVyO1xuICAvLyB0cnVlIGlmIG9uUHJvZ3Jlc3Mgc2hvdWxkIHJlcG9ydCBwYXJ0aWFsIGNodW5rIG9mIGxvYWRlZCBjb250ZW50XG4gIHByb2dyZXNzRGF0YT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJhZ21lbnRMb2FkZXJDb250ZXh0IGV4dGVuZHMgTG9hZGVyQ29udGV4dCB7XG4gIGZyYWc6IEZyYWdtZW50O1xuICBwYXJ0OiBQYXJ0IHwgbnVsbDtcbiAgcmVzZXRJVj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgS2V5TG9hZGVyQ29udGV4dCBleHRlbmRzIExvYWRlckNvbnRleHQge1xuICBrZXlJbmZvOiBLZXlMb2FkZXJJbmZvO1xuICBmcmFnOiBGcmFnbWVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZXJDb25maWd1cmF0aW9uIHtcbiAgLy8gTG9hZGVyQ29uZmlnIHBvbGljeSB0aGF0IG92ZXJyaWRlcyByZXF1aXJlZCBzZXR0aW5nc1xuICBsb2FkUG9saWN5OiBMb2FkZXJDb25maWc7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgTG9hZGVyQ29uZmlnIHRpbWVvdXRSZXRyeSBhbmQgZXJyb3JSZXRyeSBtYXhOdW1SZXRyeVxuICAgKi9cbiAgLy8gTWF4IG51bWJlciBvZiBsb2FkIHJldHJpZXNcbiAgbWF4UmV0cnk6IG51bWJlcjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBMb2FkZXJDb25maWcgbWF4VGltZVRvRmlyc3RCeXRlTXMgYW5kIG1heExvYWRUaW1lTXNcbiAgICovXG4gIC8vIFRpbWVvdXQgYWZ0ZXIgd2hpY2ggYG9uVGltZU91dGAgY2FsbGJhY2sgd2lsbCBiZSB0cmlnZ2VyZWRcbiAgLy8gIHdoZW4gbG9hZGluZyBoYXMgbm90IGZpbmlzaGVkIGFmdGVyIHRoYXQgZGVsYXlcbiAgdGltZW91dDogbnVtYmVyO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIExvYWRlckNvbmZpZyB0aW1lb3V0UmV0cnkgYW5kIGVycm9yUmV0cnkgcmV0cnlEZWxheU1zXG4gICAqL1xuICAvLyBEZWxheSBiZXR3ZWVuIGFuIEkvTyBlcnJvciBhbmQgZm9sbG93aW5nIGNvbm5lY3Rpb24gcmV0cnkgKG1zKS5cbiAgLy8gVGhpcyB0byBhdm9pZCBzcGFtbWluZyB0aGUgc2VydmVyXG4gIHJldHJ5RGVsYXk6IG51bWJlcjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBMb2FkZXJDb25maWcgdGltZW91dFJldHJ5IGFuZCBlcnJvclJldHJ5IG1heFJldHJ5RGVsYXlNc1xuICAgKi9cbiAgLy8gbWF4IGNvbm5lY3Rpb24gcmV0cnkgZGVsYXkgKG1zKVxuICBtYXhSZXRyeURlbGF5OiBudW1iZXI7XG4gIC8vIFdoZW4gc3RyZWFtaW5nIHByb2dyZXNzaXZlbHksIHRoaXMgaXMgdGhlIG1pbmltdW0gY2h1bmsgc2l6ZSByZXF1aXJlZCB0byBlbWl0IGEgUFJPR1JFU1MgZXZlbnRcbiAgaGlnaFdhdGVyTWFyaz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZXJSZXNwb25zZSB7XG4gIHVybDogc3RyaW5nO1xuICBkYXRhPzogc3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBPYmplY3Q7XG4gIC8vIEVycm9ycyBjYW4gaW5jbHVkZSBIVFRQIHN0YXR1cyBjb2RlIGFuZCBlcnJvciBtZXNzYWdlXG4gIC8vIFN1Y2Nlc3NmdWwgcmVzcG9uc2VzIHNob3VsZCBpbmNsdWRlIHN0YXR1cyBjb2RlIDIwMFxuICBjb2RlPzogbnVtYmVyO1xuICB0ZXh0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlclN0YXRzIHtcbiAgYWJvcnRlZDogYm9vbGVhbjtcbiAgbG9hZGVkOiBudW1iZXI7XG4gIHJldHJ5OiBudW1iZXI7XG4gIHRvdGFsOiBudW1iZXI7XG4gIGNodW5rQ291bnQ6IG51bWJlcjtcbiAgYndFc3RpbWF0ZTogbnVtYmVyO1xuICBsb2FkaW5nOiBIbHNQcm9ncmVzc2l2ZVBlcmZvcm1hbmNlVGltaW5nO1xuICBwYXJzaW5nOiBIbHNQZXJmb3JtYW5jZVRpbWluZztcbiAgYnVmZmVyaW5nOiBIbHNQcm9ncmVzc2l2ZVBlcmZvcm1hbmNlVGltaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhsc1BlcmZvcm1hbmNlVGltaW5nIHtcbiAgc3RhcnQ6IG51bWJlcjtcbiAgZW5kOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGxzQ2h1bmtQZXJmb3JtYW5jZVRpbWluZyBleHRlbmRzIEhsc1BlcmZvcm1hbmNlVGltaW5nIHtcbiAgZXhlY3V0ZVN0YXJ0OiBudW1iZXI7XG4gIGV4ZWN1dGVFbmQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIbHNQcm9ncmVzc2l2ZVBlcmZvcm1hbmNlVGltaW5nIGV4dGVuZHMgSGxzUGVyZm9ybWFuY2VUaW1pbmcge1xuICBmaXJzdDogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBMb2FkZXJPblN1Y2Nlc3M8VCBleHRlbmRzIExvYWRlckNvbnRleHQ+ID0gKFxuICByZXNwb25zZTogTG9hZGVyUmVzcG9uc2UsXG4gIHN0YXRzOiBMb2FkZXJTdGF0cyxcbiAgY29udGV4dDogVCxcbiAgbmV0d29ya0RldGFpbHM6IGFueVxuKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBMb2FkZXJPblByb2dyZXNzPFQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0PiA9IChcbiAgc3RhdHM6IExvYWRlclN0YXRzLFxuICBjb250ZXh0OiBULFxuICBkYXRhOiBzdHJpbmcgfCBBcnJheUJ1ZmZlcixcbiAgbmV0d29ya0RldGFpbHM6IGFueVxuKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBMb2FkZXJPbkVycm9yPFQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0PiA9IChcbiAgZXJyb3I6IHtcbiAgICAvLyBlcnJvciBzdGF0dXMgY29kZVxuICAgIGNvZGU6IG51bWJlcjtcbiAgICAvLyBlcnJvciBkZXNjcmlwdGlvblxuICAgIHRleHQ6IHN0cmluZztcbiAgfSxcbiAgY29udGV4dDogVCxcbiAgbmV0d29ya0RldGFpbHM6IGFueSxcbiAgc3RhdHM6IExvYWRlclN0YXRzXG4pID0+IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIExvYWRlck9uVGltZW91dDxUIGV4dGVuZHMgTG9hZGVyQ29udGV4dD4gPSAoXG4gIHN0YXRzOiBMb2FkZXJTdGF0cyxcbiAgY29udGV4dDogVCxcbiAgbmV0d29ya0RldGFpbHM6IGFueVxuKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBMb2FkZXJPbkFib3J0PFQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0PiA9IChcbiAgc3RhdHM6IExvYWRlclN0YXRzLFxuICBjb250ZXh0OiBULFxuICBuZXR3b3JrRGV0YWlsczogYW55XG4pID0+IHZvaWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyQ2FsbGJhY2tzPFQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0PiB7XG4gIG9uU3VjY2VzczogTG9hZGVyT25TdWNjZXNzPFQ+O1xuICBvbkVycm9yOiBMb2FkZXJPbkVycm9yPFQ+O1xuICBvblRpbWVvdXQ6IExvYWRlck9uVGltZW91dDxUPjtcbiAgb25BYm9ydD86IExvYWRlck9uQWJvcnQ8VD47XG4gIG9uUHJvZ3Jlc3M/OiBMb2FkZXJPblByb2dyZXNzPFQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlcjxUIGV4dGVuZHMgTG9hZGVyQ29udGV4dD4ge1xuICBkZXN0cm95KCk6IHZvaWQ7XG4gIGFib3J0KCk6IHZvaWQ7XG4gIGxvYWQoXG4gICAgY29udGV4dDogTG9hZGVyQ29udGV4dCxcbiAgICBjb25maWc6IExvYWRlckNvbmZpZ3VyYXRpb24sXG4gICAgY2FsbGJhY2tzOiBMb2FkZXJDYWxsYmFja3M8VD5cbiAgKTogdm9pZDtcbiAgLyoqXG4gICAqIGBnZXRDYWNoZUFnZSgpYCBpcyBjYWxsZWQgYnkgaGxzLmpzIHRvIGdldCB0aGUgZHVyYXRpb24gdGhhdCBhIGdpdmVuIG9iamVjdFxuICAgKiBoYXMgYmVlbiBzaXR0aW5nIGluIGEgY2FjaGUgcHJveHkgd2hlbiBwbGF5aW5nIGxpdmUuICBJZiBpbXBsZW1lbnRlZCxcbiAgICogdGhpcyBzaG91bGQgcmV0dXJuIGEgdmFsdWUgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogRm9yIEhUVFAgYmFzZWQgbG9hZGVycywgdGhpcyBzaG91bGQgcmV0dXJuIHRoZSBjb250ZW50cyBvZiB0aGUgXCJhZ2VcIiBoZWFkZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHRpbWUgb2JqZWN0IGJlaW5nIGxvZGFkZWRcbiAgICovXG4gIGdldENhY2hlQWdlPzogKCkgPT4gbnVtYmVyIHwgbnVsbDtcbiAgZ2V0UmVzcG9uc2VIZWFkZXI/OiAobmFtZTogc3RyaW5nKSA9PiBzdHJpbmcgfCBudWxsO1xuICBjb250ZXh0OiBUO1xuICBzdGF0czogTG9hZGVyU3RhdHM7XG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIFBsYXlsaXN0Q29udGV4dFR5cGUge1xuICBNQU5JRkVTVCA9ICdtYW5pZmVzdCcsXG4gIExFVkVMID0gJ2xldmVsJyxcbiAgQVVESU9fVFJBQ0sgPSAnYXVkaW9UcmFjaycsXG4gIFNVQlRJVExFX1RSQUNLID0gJ3N1YnRpdGxlVHJhY2snLFxufVxuXG5leHBvcnQgY29uc3QgZW51bSBQbGF5bGlzdExldmVsVHlwZSB7XG4gIE1BSU4gPSAnbWFpbicsXG4gIEFVRElPID0gJ2F1ZGlvJyxcbiAgU1VCVElUTEUgPSAnc3VidGl0bGUnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBsYXlsaXN0TG9hZGVyQ29udGV4dCBleHRlbmRzIExvYWRlckNvbnRleHQge1xuICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlO1xuICAvLyB0aGUgbGV2ZWwgaW5kZXggdG8gbG9hZFxuICBsZXZlbDogbnVtYmVyIHwgbnVsbDtcbiAgLy8gbGV2ZWwgb3IgdHJhY2sgaWQgZnJvbSBMZXZlbExvYWRpbmdEYXRhIC8gVHJhY2tMb2FkaW5nRGF0YVxuICBpZDogbnVtYmVyIHwgbnVsbDtcbiAgLy8gdHJhY2sgZ3JvdXAgaWRcbiAgZ3JvdXBJZD86IHN0cmluZztcbiAgLy8gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBwYXJzZWQgbTN1OCBsZXZlbCBwbGF5bGlzdFxuICBsZXZlbERldGFpbHM/OiBMZXZlbERldGFpbHM7XG4gIC8vIEJsb2NraW5nIHBsYXlsaXN0IHJlcXVlc3QgZGVsaXZlcnkgZGlyZWN0aXZlcyAob3IgbnVsbCBpZCBub25lIHdlcmUgYWRkZWQgdG8gcGxheWxpc3QgdXJsXG4gIGRlbGl2ZXJ5RGlyZWN0aXZlczogSGxzVXJsUGFyYW1ldGVycyB8IG51bGw7XG59XG4iLCIvKipcbiAqIFBsYXlsaXN0TG9hZGVyIC0gZGVsZWdhdGUgZm9yIG1lZGlhIG1hbmlmZXN0L3BsYXlsaXN0IGxvYWRpbmcgdGFza3MuIFRha2VzIGNhcmUgb2YgcGFyc2luZyBtZWRpYSB0byBpbnRlcm5hbCBkYXRhLW1vZGVscy5cbiAqXG4gKiBPbmNlIGxvYWRlZCwgZGlzcGF0Y2hlcyBldmVudHMgd2l0aCBwYXJzZWQgZGF0YS1tb2RlbHMgb2YgbWFuaWZlc3QvbGV2ZWxzL2F1ZGlvL3N1YnRpdGxlIHRyYWNrcy5cbiAqXG4gKiBVc2VzIGxvYWRlcihzKSBzZXQgaW4gY29uZmlnIHRvIGRvIGFjdHVhbCBpbnRlcm5hbCBsb2FkaW5nIG9mIHJlc291cmNlIHRhc2tzLlxuICovXG5cbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMsIEVycm9yVHlwZXMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBNM1U4UGFyc2VyIGZyb20gJy4vbTN1OC1wYXJzZXInO1xuaW1wb3J0IHR5cGUgeyBMZXZlbFBhcnNlZCwgVmFyaWFibGVNYXAgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgdHlwZSB7XG4gIExvYWRlcixcbiAgTG9hZGVyQ2FsbGJhY2tzLFxuICBMb2FkZXJDb25maWd1cmF0aW9uLFxuICBMb2FkZXJDb250ZXh0LFxuICBMb2FkZXJSZXNwb25zZSxcbiAgTG9hZGVyU3RhdHMsXG4gIFBsYXlsaXN0TG9hZGVyQ29udGV4dCxcbn0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7IFBsYXlsaXN0Q29udGV4dFR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7IExldmVsRGV0YWlscyB9IGZyb20gJy4vbGV2ZWwtZGV0YWlscyc7XG5pbXBvcnQgeyBBdHRyTGlzdCB9IGZyb20gJy4uL3V0aWxzL2F0dHItbGlzdCc7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHtcbiAgRXJyb3JEYXRhLFxuICBMZXZlbExvYWRpbmdEYXRhLFxuICBNYW5pZmVzdExvYWRpbmdEYXRhLFxuICBUcmFja0xvYWRpbmdEYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBOZXR3b3JrQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSB7IE1lZGlhQXR0cmlidXRlcyB9IGZyb20gJy4uL3R5cGVzL21lZGlhLXBsYXlsaXN0JztcbmltcG9ydCB0eXBlIHsgTG9hZGVyQ29uZmlnLCBSZXRyeUNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5cbmZ1bmN0aW9uIG1hcENvbnRleHRUb0xldmVsVHlwZShcbiAgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0XG4pOiBQbGF5bGlzdExldmVsVHlwZSB7XG4gIGNvbnN0IHsgdHlwZSB9ID0gY29udGV4dDtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuQVVESU87XG4gICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgcmV0dXJuIFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuTUFJTjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZVVybChcbiAgcmVzcG9uc2U6IExvYWRlclJlc3BvbnNlLFxuICBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHRcbik6IHN0cmluZyB7XG4gIGxldCB1cmwgPSByZXNwb25zZS51cmw7XG4gIC8vIHJlc3BvbnNlVVJMIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2VycyAoaXQgaXMgdXNlZCB0byBkZXRlY3QgVVJMIHJlZGlyZWN0aW9uKVxuICAvLyBkYXRhLXVyaSBtb2RlIGFsc28gbm90IHN1cHBvcnRlZCAoYnV0IG5vIG5lZWQgdG8gZGV0ZWN0IHJlZGlyZWN0aW9uKVxuICBpZiAodXJsID09PSB1bmRlZmluZWQgfHwgdXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAvLyBmYWxsYmFjayB0byBpbml0aWFsIFVSTFxuICAgIHVybCA9IGNvbnRleHQudXJsO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmNsYXNzIFBsYXlsaXN0TG9hZGVyIGltcGxlbWVudHMgTmV0d29ya0NvbXBvbmVudEFQSSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgaGxzOiBIbHM7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9hZGVyczoge1xuICAgIFtrZXk6IHN0cmluZ106IExvYWRlcjxMb2FkZXJDb250ZXh0PjtcbiAgfSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHByaXZhdGUgdmFyaWFibGVMaXN0OiBWYXJpYWJsZU1hcCB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKGhsczogSGxzKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgcHVibGljIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uOiBudW1iZXIpOiB2b2lkIHt9XG5cbiAgcHVibGljIHN0b3BMb2FkKCk6IHZvaWQge1xuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGluZywgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBkZWZhdWx0cyBvciBjb25maWd1cmVkIGxvYWRlci10eXBlIG92ZXJsb2FkcyAocExvYWRlciBhbmQgbG9hZGVyIGNvbmZpZyBwYXJhbXMpXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZUludGVybmFsTG9hZGVyKFxuICAgIGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dFxuICApOiBMb2FkZXI8TG9hZGVyQ29udGV4dD4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCBQTG9hZGVyID0gY29uZmlnLnBMb2FkZXI7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBJbnRlcm5hbExvYWRlciA9IFBMb2FkZXIgfHwgTG9hZGVyO1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBJbnRlcm5hbExvYWRlcihjb25maWcpIGFzIExvYWRlcjxQbGF5bGlzdExvYWRlckNvbnRleHQ+O1xuXG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSBsb2FkZXI7XG4gICAgcmV0dXJuIGxvYWRlcjtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0SW50ZXJuYWxMb2FkZXIoXG4gICAgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0XG4gICk6IExvYWRlcjxMb2FkZXJDb250ZXh0PiB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGBkZXN0cm95YCBvbiBhbGwgaW50ZXJuYWwgbG9hZGVyIGluc3RhbmNlcyBtYXBwZWQgKG9uZSBwZXIgY29udGV4dCB0eXBlKVxuICAgKi9cbiAgcHJpdmF0ZSBkZXN0cm95SW50ZXJuYWxMb2FkZXJzKCk6IHZvaWQge1xuICAgIGZvciAoY29uc3QgY29udGV4dFR5cGUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gbnVsbDtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgb25NYW5pZmVzdExvYWRpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLFxuICAgIGRhdGE6IE1hbmlmZXN0TG9hZGluZ0RhdGFcbiAgKSB7XG4gICAgY29uc3QgeyB1cmwgfSA9IGRhdGE7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZDogbnVsbCxcbiAgICAgIGxldmVsOiAwLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNULFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBudWxsLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkxldmVsTG9hZGluZyhldmVudDogRXZlbnRzLkxFVkVMX0xPQURJTkcsIGRhdGE6IExldmVsTG9hZGluZ0RhdGEpIHtcbiAgICBjb25zdCB7IGlkLCBsZXZlbCwgdXJsLCBkZWxpdmVyeURpcmVjdGl2ZXMgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgbGV2ZWwsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uQXVkaW9UcmFja0xvYWRpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLFxuICAgIGRhdGE6IFRyYWNrTG9hZGluZ0RhdGFcbiAgKSB7XG4gICAgY29uc3QgeyBpZCwgZ3JvdXBJZCwgdXJsLCBkZWxpdmVyeURpcmVjdGl2ZXMgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGxldmVsOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBvblN1YnRpdGxlVHJhY2tMb2FkaW5nKFxuICAgIGV2ZW50OiBFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORyxcbiAgICBkYXRhOiBUcmFja0xvYWRpbmdEYXRhXG4gICkge1xuICAgIGNvbnN0IHsgaWQsIGdyb3VwSWQsIHVybCwgZGVsaXZlcnlEaXJlY3RpdmVzIH0gPSBkYXRhO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBsZXZlbDogbnVsbCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbG9hZChjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQpOiB2b2lkIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAvLyBsb2dnZXIuZGVidWcoYFtwbGF5bGlzdC1sb2FkZXJdOiBMb2FkaW5nIHBsYXlsaXN0IG9mIHR5cGUgJHtjb250ZXh0LnR5cGV9LCBsZXZlbDogJHtjb250ZXh0LmxldmVsfSwgaWQ6ICR7Y29udGV4dC5pZH1gKTtcblxuICAgIC8vIENoZWNrIGlmIGEgbG9hZGVyIGZvciB0aGlzIGNvbnRleHQgYWxyZWFkeSBleGlzdHNcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBjb25zdCBsb2FkZXJDb250ZXh0ID0gbG9hZGVyLmNvbnRleHQ7XG4gICAgICBpZiAobG9hZGVyQ29udGV4dCAmJiBsb2FkZXJDb250ZXh0LnVybCA9PT0gY29udGV4dC51cmwpIHtcbiAgICAgICAgLy8gc2FtZSBVUkwgY2FuJ3Qgb3ZlcmxhcFxuICAgICAgICBsb2dnZXIudHJhY2UoJ1twbGF5bGlzdC1sb2FkZXJdOiBwbGF5bGlzdCByZXF1ZXN0IG9uZ29pbmcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgYFtwbGF5bGlzdC1sb2FkZXJdOiBhYm9ydGluZyBwcmV2aW91cyBsb2FkZXIgZm9yIHR5cGU6ICR7Y29udGV4dC50eXBlfWBcbiAgICAgICk7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBkaWZmZXJlbnQgY29uZmlncyBmb3IgcmV0cmllcyBkZXBlbmRpbmcgb25cbiAgICAvLyBjb250ZXh0IChtYW5pZmVzdCwgbGV2ZWwsIGF1ZGlvL3N1YnMgcGxheWxpc3QpXG4gICAgbGV0IGxvYWRQb2xpY3k6IExvYWRlckNvbmZpZztcbiAgICBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUKSB7XG4gICAgICBsb2FkUG9saWN5ID0gY29uZmlnLm1hbmlmZXN0TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkUG9saWN5ID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLnBsYXlsaXN0TG9hZFBvbGljeS5kZWZhdWx0LCB7XG4gICAgICAgIHRpbWVvdXRSZXRyeTogbnVsbCxcbiAgICAgICAgZXJyb3JSZXRyeTogbnVsbCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkZXIgPSB0aGlzLmNyZWF0ZUludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuXG4gICAgLy8gT3ZlcnJpZGUgbGV2ZWwvdHJhY2sgdGltZW91dCBmb3IgTEwtSExTIHJlcXVlc3RzXG4gICAgLy8gKHRoZSBkZWZhdWx0IG9mIDEwMDAwbXMgaXMgY291bnRlciBwcm9kdWN0aXZlIHRvIGJsb2NraW5nIHBsYXlsaXN0IHJlbG9hZCByZXF1ZXN0cylcbiAgICBpZiAoY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXM/LnBhcnQpIHtcbiAgICAgIGxldCBsZXZlbERldGFpbHM6IExldmVsRGV0YWlscyB8IHVuZGVmaW5lZDtcbiAgICAgIGlmIChcbiAgICAgICAgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMICYmXG4gICAgICAgIGNvbnRleHQubGV2ZWwgIT09IG51bGxcbiAgICAgICkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5sZXZlbHNbY29udGV4dC5sZXZlbF0uZGV0YWlscztcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJlxuICAgICAgICBjb250ZXh0LmlkICE9PSBudWxsXG4gICAgICApIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMuYXVkaW9UcmFja3NbY29udGV4dC5pZF0uZGV0YWlscztcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJlxuICAgICAgICBjb250ZXh0LmlkICE9PSBudWxsXG4gICAgICApIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMuc3VidGl0bGVUcmFja3NbY29udGV4dC5pZF0uZGV0YWlscztcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbERldGFpbHMpIHtcbiAgICAgICAgY29uc3QgcGFydFRhcmdldCA9IGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0O1xuICAgICAgICBjb25zdCB0YXJnZXREdXJhdGlvbiA9IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICAgICAgaWYgKHBhcnRUYXJnZXQgJiYgdGFyZ2V0RHVyYXRpb24pIHtcbiAgICAgICAgICBjb25zdCBtYXhMb3dMYXRlbmN5UGxheWxpc3RSZWZyZXNoID1cbiAgICAgICAgICAgIE1hdGgubWF4KHBhcnRUYXJnZXQgKiAzLCB0YXJnZXREdXJhdGlvbiAqIDAuOCkgKiAxMDAwO1xuICAgICAgICAgIGxvYWRQb2xpY3kgPSBPYmplY3QuYXNzaWduKHt9LCBsb2FkUG9saWN5LCB7XG4gICAgICAgICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogTWF0aC5taW4oXG4gICAgICAgICAgICAgIG1heExvd0xhdGVuY3lQbGF5bGlzdFJlZnJlc2gsXG4gICAgICAgICAgICAgIGxvYWRQb2xpY3kubWF4VGltZVRvRmlyc3RCeXRlTXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBtYXhMb2FkVGltZU1zOiBNYXRoLm1pbihcbiAgICAgICAgICAgICAgbWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCxcbiAgICAgICAgICAgICAgbG9hZFBvbGljeS5tYXhUaW1lVG9GaXJzdEJ5dGVNc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eTogUmV0cnlDb25maWcgfCBSZWNvcmQ8c3RyaW5nLCB2b2lkPiA9XG4gICAgICBsb2FkUG9saWN5LmVycm9yUmV0cnkgfHwgbG9hZFBvbGljeS50aW1lb3V0UmV0cnkgfHwge307XG4gICAgY29uc3QgbG9hZGVyQ29uZmlnOiBMb2FkZXJDb25maWd1cmF0aW9uID0ge1xuICAgICAgbG9hZFBvbGljeSxcbiAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgIG1heFJldHJ5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkubWF4TnVtUmV0cnkgfHwgMCxcbiAgICAgIHJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5yZXRyeURlbGF5TXMgfHwgMCxcbiAgICAgIG1heFJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhSZXRyeURlbGF5TXMgfHwgMCxcbiAgICB9O1xuXG4gICAgY29uc3QgbG9hZGVyQ2FsbGJhY2tzOiBMb2FkZXJDYWxsYmFja3M8UGxheWxpc3RMb2FkZXJDb250ZXh0PiA9IHtcbiAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KSBhc1xuICAgICAgICAgIHwgTG9hZGVyPFBsYXlsaXN0TG9hZGVyQ29udGV4dD5cbiAgICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHQudHlwZSk7XG5cbiAgICAgICAgY29uc3Qgc3RyaW5nID0gcmVzcG9uc2UuZGF0YSBhcyBzdHJpbmc7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgaWYgaXQgaXMgYW4gTTNVOCBhdCBhbGxcbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUTTNVJykgIT09IDApIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgbmV3IEVycm9yKCdubyBFWFRNM1UgZGVsaW1pdGVyJyksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyB8fCBudWxsLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRzLnBhcnNpbmcuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaWYgKE0zVThQYXJzZXIuaXNNZWRpYVBsYXlsaXN0KHN0cmluZykpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyB8fCBudWxsLFxuICAgICAgICAgICAgbG9hZGVyXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZU1hc3RlclBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICBzdGF0c1xuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZU5ldHdvcmtFcnJvcihcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHN0YXRzXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgIH07XG5cbiAgICAvLyBsb2dnZXIuZGVidWcoYFtwbGF5bGlzdC1sb2FkZXJdOiBDYWxsaW5nIGludGVybmFsIGxvYWRlciBkZWxlZ2F0ZSBmb3IgVVJMOiAke2NvbnRleHQudXJsfWApO1xuXG4gICAgbG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVNYXN0ZXJQbGF5bGlzdChcbiAgICByZXNwb25zZTogTG9hZGVyUmVzcG9uc2UsXG4gICAgc3RhdHM6IExvYWRlclN0YXRzLFxuICAgIGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dCxcbiAgICBuZXR3b3JrRGV0YWlsczogYW55XG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHN0cmluZyA9IHJlc3BvbnNlLmRhdGEgYXMgc3RyaW5nO1xuXG4gICAgY29uc3QgdXJsID0gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuXG4gICAgY29uc3QgcGFyc2VkUmVzdWx0ID0gTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgdXJsKTtcblxuICAgIGlmIChwYXJzZWRSZXN1bHQucGxheWxpc3RQYXJzaW5nRXJyb3IpIHtcbiAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IoXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBwYXJzZWRSZXN1bHQucGxheWxpc3RQYXJzaW5nRXJyb3IsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzdGF0c1xuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBjb250ZW50U3RlZXJpbmcsXG4gICAgICBsZXZlbHMsXG4gICAgICBzZXNzaW9uRGF0YSxcbiAgICAgIHNlc3Npb25LZXlzLFxuICAgICAgc3RhcnRUaW1lT2Zmc2V0LFxuICAgICAgdmFyaWFibGVMaXN0LFxuICAgIH0gPSBwYXJzZWRSZXN1bHQ7XG5cbiAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IHZhcmlhYmxlTGlzdDtcblxuICAgIGNvbnN0IHtcbiAgICAgIEFVRElPOiBhdWRpb1RyYWNrcyA9IFtdLFxuICAgICAgU1VCVElUTEVTOiBzdWJ0aXRsZXMsXG4gICAgICAnQ0xPU0VELUNBUFRJT05TJzogY2FwdGlvbnMsXG4gICAgfSA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCBwYXJzZWRSZXN1bHQpO1xuXG4gICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBmb3VuZCBhbiBhdWRpbyB0cmFjayBlbWJlZGRlZCBpbiBtYWluIHBsYXlsaXN0IChhdWRpbyB0cmFjayB3aXRob3V0IFVSSSBhdHRyaWJ1dGUpXG4gICAgICBjb25zdCBlbWJlZGRlZEF1ZGlvRm91bmQ6IGJvb2xlYW4gPSBhdWRpb1RyYWNrcy5zb21lKFxuICAgICAgICAoYXVkaW9UcmFjaykgPT4gIWF1ZGlvVHJhY2sudXJsXG4gICAgICApO1xuXG4gICAgICAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCxcbiAgICAgIC8vIHdlIG5lZWQgdG8gc2lnbmFsIHRoaXMgbWFpbiBhdWRpbyB0cmFjayB0aGlzIGNvdWxkIGhhcHBlbiB3aXRoIHBsYXlsaXN0cyB3aXRoXG4gICAgICAvLyBhbHQgYXVkaW8gcmVuZGl0aW9uIGluIHdoaWNoIHF1YWxpdHkgbGV2ZWxzIChtYWluKVxuICAgICAgLy8gY29udGFpbnMgYm90aCBhdWRpbyt2aWRlby4gYnV0IHdpdGggbWl4ZWQgYXVkaW8gdHJhY2sgbm90IHNpZ25hbGVkXG4gICAgICBpZiAoXG4gICAgICAgICFlbWJlZGRlZEF1ZGlvRm91bmQgJiZcbiAgICAgICAgbGV2ZWxzWzBdLmF1ZGlvQ29kZWMgJiZcbiAgICAgICAgIWxldmVsc1swXS5hdHRycy5BVURJT1xuICAgICAgKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICAgJ1twbGF5bGlzdC1sb2FkZXJdOiBhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCBidXQgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgc2lnbmFsZWQsIGNyZWF0ZSBvbmUnXG4gICAgICAgICk7XG4gICAgICAgIGF1ZGlvVHJhY2tzLnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6ICdtYWluJyxcbiAgICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgICAgZ3JvdXBJZDogJ21haW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgIGF1dG9zZWxlY3Q6IGZhbHNlLFxuICAgICAgICAgIGZvcmNlZDogZmFsc2UsXG4gICAgICAgICAgaWQ6IC0xLFxuICAgICAgICAgIGF0dHJzOiBuZXcgQXR0ckxpc3Qoe30pIGFzIE1lZGlhQXR0cmlidXRlcyxcbiAgICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICAgIHVybDogJycsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhscy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgIGxldmVscyxcbiAgICAgIGF1ZGlvVHJhY2tzLFxuICAgICAgc3VidGl0bGVzLFxuICAgICAgY2FwdGlvbnMsXG4gICAgICBjb250ZW50U3RlZXJpbmcsXG4gICAgICB1cmwsXG4gICAgICBzdGF0cyxcbiAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgc2Vzc2lvbkRhdGEsXG4gICAgICBzZXNzaW9uS2V5cyxcbiAgICAgIHN0YXJ0VGltZU9mZnNldCxcbiAgICAgIHZhcmlhYmxlTGlzdCxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QoXG4gICAgcmVzcG9uc2U6IExvYWRlclJlc3BvbnNlLFxuICAgIHN0YXRzOiBMb2FkZXJTdGF0cyxcbiAgICBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQsXG4gICAgbmV0d29ya0RldGFpbHM6IGFueSxcbiAgICBsb2FkZXI6IExvYWRlcjxQbGF5bGlzdExvYWRlckNvbnRleHQ+IHwgdW5kZWZpbmVkXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHsgaWQsIGxldmVsLCB0eXBlIH0gPSBjb250ZXh0O1xuXG4gICAgY29uc3QgdXJsID0gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgIGNvbnN0IGxldmVsVXJsSWQgPSBOdW1iZXIuaXNGaW5pdGUoaWQgYXMgbnVtYmVyKSA/IChpZCBhcyBudW1iZXIpIDogMDtcbiAgICBjb25zdCBsZXZlbElkID0gTnVtYmVyLmlzRmluaXRlKGxldmVsIGFzIG51bWJlcilcbiAgICAgID8gKGxldmVsIGFzIG51bWJlcilcbiAgICAgIDogbGV2ZWxVcmxJZDtcbiAgICBjb25zdCBsZXZlbFR5cGUgPSBtYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCk7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzOiBMZXZlbERldGFpbHMgPSBNM1U4UGFyc2VyLnBhcnNlTGV2ZWxQbGF5bGlzdChcbiAgICAgIHJlc3BvbnNlLmRhdGEgYXMgc3RyaW5nLFxuICAgICAgdXJsLFxuICAgICAgbGV2ZWxJZCxcbiAgICAgIGxldmVsVHlwZSxcbiAgICAgIGxldmVsVXJsSWQsXG4gICAgICB0aGlzLnZhcmlhYmxlTGlzdFxuICAgICk7XG5cbiAgICAvLyBXZSBoYXZlIGRvbmUgb3VyIGZpcnN0IHJlcXVlc3QgKE1hbmlmZXN0LXR5cGUpIGFuZCByZWNlaXZlXG4gICAgLy8gbm90IGEgbWFzdGVyIHBsYXlsaXN0IGJ1dCBhIGNodW5rLWxpc3QgKHRyYWNrL2xldmVsKVxuICAgIC8vIFdlIGZpcmUgdGhlIG1hbmlmZXN0LWxvYWRlZCBldmVudCBhbnl3YXkgd2l0aCB0aGUgcGFyc2VkIGxldmVsLWRldGFpbHNcbiAgICAvLyBieSBjcmVhdGluZyBhIHNpbmdsZS1sZXZlbCBzdHJ1Y3R1cmUgZm9yIGl0LlxuICAgIGlmICh0eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUKSB7XG4gICAgICBjb25zdCBzaW5nbGVMZXZlbDogTGV2ZWxQYXJzZWQgPSB7XG4gICAgICAgIGF0dHJzOiBuZXcgQXR0ckxpc3Qoe30pLFxuICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgIG5hbWU6ICcnLFxuICAgICAgICB1cmwsXG4gICAgICB9O1xuXG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB7XG4gICAgICAgIGxldmVsczogW3NpbmdsZUxldmVsXSxcbiAgICAgICAgYXVkaW9UcmFja3M6IFtdLFxuICAgICAgICB1cmwsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgc2Vzc2lvbkRhdGE6IG51bGwsXG4gICAgICAgIHNlc3Npb25LZXlzOiBudWxsLFxuICAgICAgICBjb250ZW50U3RlZXJpbmc6IG51bGwsXG4gICAgICAgIHN0YXJ0VGltZU9mZnNldDogbnVsbCxcbiAgICAgICAgdmFyaWFibGVMaXN0OiBudWxsLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2F2ZSBwYXJzaW5nIHRpbWVcbiAgICBzdGF0cy5wYXJzaW5nLmVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgLy8gZXh0ZW5kIHRoZSBjb250ZXh0IHdpdGggdGhlIG5ldyBsZXZlbERldGFpbHMgcHJvcGVydHlcbiAgICBjb250ZXh0LmxldmVsRGV0YWlscyA9IGxldmVsRGV0YWlscztcblxuICAgIHRoaXMuaGFuZGxlUGxheWxpc3RMb2FkZWQoXG4gICAgICBsZXZlbERldGFpbHMsXG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0YXRzLFxuICAgICAgY29udGV4dCxcbiAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgbG9hZGVyXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IoXG4gICAgcmVzcG9uc2U6IExvYWRlclJlc3BvbnNlLFxuICAgIGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dCxcbiAgICBlcnJvcjogRXJyb3IsXG4gICAgbmV0d29ya0RldGFpbHM6IGFueSxcbiAgICBzdGF0czogTG9hZGVyU3RhdHNcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6IGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCxcbiAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgZXJyOiBlcnJvcixcbiAgICAgIGVycm9yLFxuICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgcmVzcG9uc2UsXG4gICAgICBjb250ZXh0LFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBzdGF0cyxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlTmV0d29ya0Vycm9yKFxuICAgIGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dCxcbiAgICBuZXR3b3JrRGV0YWlsczogYW55LFxuICAgIHRpbWVvdXQgPSBmYWxzZSxcbiAgICByZXNwb25zZTogeyBjb2RlOiBudW1iZXI7IHRleHQ6IHN0cmluZyB9IHwgdW5kZWZpbmVkLFxuICAgIHN0YXRzOiBMb2FkZXJTdGF0c1xuICApOiB2b2lkIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBBIG5ldHdvcmsgJHtcbiAgICAgIHRpbWVvdXRcbiAgICAgICAgPyAndGltZW91dCdcbiAgICAgICAgOiAnZXJyb3InICsgKHJlc3BvbnNlID8gJyAoc3RhdHVzICcgKyByZXNwb25zZS5jb2RlICsgJyknIDogJycpXG4gICAgfSBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nICR7Y29udGV4dC50eXBlfWA7XG4gICAgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCkge1xuICAgICAgbWVzc2FnZSArPSBgOiAke2NvbnRleHQubGV2ZWx9IGlkOiAke2NvbnRleHQuaWR9YDtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLIHx8XG4gICAgICBjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0tcbiAgICApIHtcbiAgICAgIG1lc3NhZ2UgKz0gYCBpZDogJHtjb250ZXh0LmlkfSBncm91cC1pZDogXCIke2NvbnRleHQuZ3JvdXBJZH1cImA7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGxvZ2dlci53YXJuKGBbcGxheWxpc3QtbG9hZGVyXTogJHttZXNzYWdlfWApO1xuICAgIGxldCBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLlVOS05PV047XG4gICAgbGV0IGZhdGFsID0gZmFsc2U7XG5cbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuXG4gICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXRcbiAgICAgICAgICA/IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVRcbiAgICAgICAgICA6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dFxuICAgICAgICAgID8gRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVFxuICAgICAgICAgIDogRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dFxuICAgICAgICAgID8gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVFxuICAgICAgICAgIDogRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dFxuICAgICAgICAgID8gRXJyb3JEZXRhaWxzLlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVFxuICAgICAgICAgIDogRXJyb3JEZXRhaWxzLlNVQlRJVExFX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yRGF0YTogRXJyb3JEYXRhID0ge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlscyxcbiAgICAgIGZhdGFsLFxuICAgICAgdXJsOiBjb250ZXh0LnVybCxcbiAgICAgIGxvYWRlcixcbiAgICAgIGNvbnRleHQsXG4gICAgICBlcnJvcixcbiAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgc3RhdHMsXG4gICAgfTtcblxuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgY29uc3QgdXJsID0gbmV0d29ya0RldGFpbHM/LnVybCB8fCBjb250ZXh0LnVybDtcbiAgICAgIGVycm9yRGF0YS5yZXNwb25zZSA9IHsgdXJsLCBkYXRhOiB1bmRlZmluZWQgYXMgYW55LCAuLi5yZXNwb25zZSB9O1xuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvckRhdGEpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVQbGF5bGlzdExvYWRlZChcbiAgICBsZXZlbERldGFpbHM6IExldmVsRGV0YWlscyxcbiAgICByZXNwb25zZTogTG9hZGVyUmVzcG9uc2UsXG4gICAgc3RhdHM6IExvYWRlclN0YXRzLFxuICAgIGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dCxcbiAgICBuZXR3b3JrRGV0YWlsczogYW55LFxuICAgIGxvYWRlcjogTG9hZGVyPFBsYXlsaXN0TG9hZGVyQ29udGV4dD4gfCB1bmRlZmluZWRcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgeyB0eXBlLCBsZXZlbCwgaWQsIGdyb3VwSWQsIGRlbGl2ZXJ5RGlyZWN0aXZlcyB9ID0gY29udGV4dDtcbiAgICBjb25zdCB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgY29uc3QgcGFyZW50ID0gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpO1xuICAgIGNvbnN0IGxldmVsSW5kZXggPVxuICAgICAgdHlwZW9mIGNvbnRleHQubGV2ZWwgPT09ICdudW1iZXInICYmIHBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTlxuICAgICAgICA/IChsZXZlbCBhcyBudW1iZXIpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmICghbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdObyBTZWdtZW50cyBmb3VuZCBpbiBQbGF5bGlzdCcpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxldmVsOiBsZXZlbEluZGV4LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzdGF0cyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikge1xuICAgICAgbGV2ZWxEZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdNaXNzaW5nIFRhcmdldCBEdXJhdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IGxldmVsRGV0YWlscy5wbGF5bGlzdFBhcnNpbmdFcnJvcjtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxldmVsOiBsZXZlbEluZGV4LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzdGF0cyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSAmJiBsb2FkZXIpIHtcbiAgICAgIGlmIChsb2FkZXIuZ2V0Q2FjaGVBZ2UpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzLmFnZUhlYWRlciA9IGxvYWRlci5nZXRDYWNoZUFnZSgpIHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoIWxvYWRlci5nZXRDYWNoZUFnZSB8fCBpc05hTihsZXZlbERldGFpbHMuYWdlSGVhZGVyKSkge1xuICAgICAgICBsZXZlbERldGFpbHMuYWdlSGVhZGVyID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTDpcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBsZXZlbDogbGV2ZWxJbmRleCB8fCAwLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQgfHwgJycsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxheWxpc3RMb2FkZXI7XG4iLCJpbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZW5kQWRkVHJhY2tFdmVudCh0cmFjazogVGV4dFRyYWNrLCB2aWRlb0VsOiBIVE1MTWVkaWFFbGVtZW50KSB7XG4gIGxldCBldmVudDogRXZlbnQ7XG4gIHRyeSB7XG4gICAgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHRyYWNrJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGZvciBJRTExXG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2FkZHRyYWNrJywgZmFsc2UsIGZhbHNlKTtcbiAgfVxuICAoZXZlbnQgYXMgYW55KS50cmFjayA9IHRyYWNrO1xuICB2aWRlb0VsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ3VlVG9UcmFjayh0cmFjazogVGV4dFRyYWNrLCBjdWU6IFZUVEN1ZSkge1xuICAvLyBTb21ldGltZXMgdGhlcmUgYXJlIGN1ZSBvdmVybGFwcyBvbiBzZWdtZW50ZWQgdnR0cyBzbyB0aGUgc2FtZVxuICAvLyBjdWUgY2FuIGFwcGVhciBtb3JlIHRoYW4gb25jZSBpbiBkaWZmZXJlbnQgdnR0IGZpbGVzLlxuICAvLyBUaGlzIGF2b2lkIHNob3dpbmcgZHVwbGljYXRlZCBjdWVzIHdpdGggc2FtZSB0aW1lY29kZSBhbmQgdGV4dC5cbiAgY29uc3QgbW9kZSA9IHRyYWNrLm1vZGU7XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICB9XG4gIGlmICh0cmFjay5jdWVzICYmICF0cmFjay5jdWVzLmdldEN1ZUJ5SWQoY3VlLmlkKSkge1xuICAgIHRyeSB7XG4gICAgICB0cmFjay5hZGRDdWUoY3VlKTtcbiAgICAgIGlmICghdHJhY2suY3Vlcy5nZXRDdWVCeUlkKGN1ZS5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhZGRDdWUgaXMgZmFpbGVkIGZvcjogJHtjdWV9YCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZGVidWcoYFt0ZXh0dHJhY2stdXRpbHNdOiAke2Vycn1gKTtcbiAgICAgIGNvbnN0IHRleHRUcmFja0N1ZSA9IG5ldyAoc2VsZi5UZXh0VHJhY2tDdWUgYXMgYW55KShcbiAgICAgICAgY3VlLnN0YXJ0VGltZSxcbiAgICAgICAgY3VlLmVuZFRpbWUsXG4gICAgICAgIGN1ZS50ZXh0XG4gICAgICApO1xuICAgICAgdGV4dFRyYWNrQ3VlLmlkID0gY3VlLmlkO1xuICAgICAgdHJhY2suYWRkQ3VlKHRleHRUcmFja0N1ZSk7XG4gICAgfVxuICB9XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9IG1vZGU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQ3VycmVudEN1ZXModHJhY2s6IFRleHRUcmFjaykge1xuICAvLyBXaGVuIHRyYWNrLm1vZGUgaXMgZGlzYWJsZWQsIHRyYWNrLmN1ZXMgd2lsbCBiZSBudWxsLlxuICAvLyBUbyBndWFyYW50ZWUgdGhlIHJlbW92YWwgb2YgY3Vlcywgd2UgbmVlZCB0byB0ZW1wb3JhcmlseVxuICAvLyBjaGFuZ2UgdGhlIG1vZGUgdG8gaGlkZGVuXG4gIGNvbnN0IG1vZGUgPSB0cmFjay5tb2RlO1xuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuICBpZiAodHJhY2suY3Vlcykge1xuICAgIGZvciAobGV0IGkgPSB0cmFjay5jdWVzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgIHRyYWNrLnJlbW92ZUN1ZSh0cmFjay5jdWVzW2ldKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3Vlc0luUmFuZ2UoXG4gIHRyYWNrOiBUZXh0VHJhY2ssXG4gIHN0YXJ0OiBudW1iZXIsXG4gIGVuZDogbnVtYmVyLFxuICBwcmVkaWNhdGU/OiAoY3VlOiBUZXh0VHJhY2tDdWUpID0+IGJvb2xlYW5cbikge1xuICBjb25zdCBtb2RlID0gdHJhY2subW9kZTtcbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gIH1cblxuICBpZiAodHJhY2suY3VlcyAmJiB0cmFjay5jdWVzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjdWVzID0gZ2V0Q3Vlc0luUmFuZ2UodHJhY2suY3Vlcywgc3RhcnQsIGVuZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoY3Vlc1tpXSkpIHtcbiAgICAgICAgdHJhY2sucmVtb3ZlQ3VlKGN1ZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICB9XG59XG5cbi8vIEZpbmQgZmlyc3QgY3VlIHN0YXJ0aW5nIGFmdGVyIGdpdmVuIHRpbWUuXG4vLyBNb2RpZmllZCB2ZXJzaW9uIG9mIGJpbmFyeSBzZWFyY2ggTyhsb2cobikpLlxuZnVuY3Rpb24gZ2V0Rmlyc3RDdWVJbmRleEFmdGVyVGltZShcbiAgY3VlczogVGV4dFRyYWNrQ3VlTGlzdCB8IFRleHRUcmFja0N1ZVtdLFxuICB0aW1lOiBudW1iZXJcbik6IG51bWJlciB7XG4gIC8vIElmIGZpcnN0IGN1ZSBzdGFydHMgYWZ0ZXIgdGltZSwgc3RhcnQgdGhlcmVcbiAgaWYgKHRpbWUgPCBjdWVzWzBdLnN0YXJ0VGltZSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIElmIHRoZSBsYXN0IGN1ZSBlbmRzIGJlZm9yZSB0aW1lIHRoZXJlIGlzIG5vIG92ZXJsYXBcbiAgY29uc3QgbGVuID0gY3Vlcy5sZW5ndGggLSAxO1xuICBpZiAodGltZSA+IGN1ZXNbbGVuXS5lbmRUaW1lKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgbGV0IGxlZnQgPSAwO1xuICBsZXQgcmlnaHQgPSBsZW47XG5cbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChyaWdodCArIGxlZnQpIC8gMik7XG5cbiAgICBpZiAodGltZSA8IGN1ZXNbbWlkXS5zdGFydFRpbWUpIHtcbiAgICAgIHJpZ2h0ID0gbWlkIC0gMTtcbiAgICB9IGVsc2UgaWYgKHRpbWUgPiBjdWVzW21pZF0uc3RhcnRUaW1lICYmIGxlZnQgPCBsZW4pIHtcbiAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIG5vdCBsb3dlciBvciBoaWdoZXIsIGl0IG11c3QgYmUgZXF1YWwuXG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICAvLyBBdCB0aGlzIHBvaW50LCBsZWZ0IGFuZCByaWdodCBoYXZlIHN3YXBwZWQuXG4gIC8vIE5vIGRpcmVjdCBtYXRjaCB3YXMgZm91bmQsIGxlZnQgb3IgcmlnaHQgZWxlbWVudCBtdXN0IGJlIHRoZSBjbG9zZXN0LiBDaGVjayB3aGljaCBvbmUgaGFzIHRoZSBzbWFsbGVzdCBkaWZmLlxuICByZXR1cm4gY3Vlc1tsZWZ0XS5zdGFydFRpbWUgLSB0aW1lIDwgdGltZSAtIGN1ZXNbcmlnaHRdLnN0YXJ0VGltZVxuICAgID8gbGVmdFxuICAgIDogcmlnaHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdWVzSW5SYW5nZShcbiAgY3VlczogVGV4dFRyYWNrQ3VlTGlzdCB8IFRleHRUcmFja0N1ZVtdLFxuICBzdGFydDogbnVtYmVyLFxuICBlbmQ6IG51bWJlclxuKTogVGV4dFRyYWNrQ3VlW10ge1xuICBjb25zdCBjdWVzRm91bmQ6IFRleHRUcmFja0N1ZVtdID0gW107XG4gIGNvbnN0IGZpcnN0Q3VlSW5SYW5nZSA9IGdldEZpcnN0Q3VlSW5kZXhBZnRlclRpbWUoY3Vlcywgc3RhcnQpO1xuICBpZiAoZmlyc3RDdWVJblJhbmdlID4gLTEpIHtcbiAgICBmb3IgKGxldCBpID0gZmlyc3RDdWVJblJhbmdlLCBsZW4gPSBjdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjdWUgPSBjdWVzW2ldO1xuICAgICAgaWYgKGN1ZS5zdGFydFRpbWUgPj0gc3RhcnQgJiYgY3VlLmVuZFRpbWUgPD0gZW5kKSB7XG4gICAgICAgIGN1ZXNGb3VuZC5wdXNoKGN1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGN1ZS5zdGFydFRpbWUgPiBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGN1ZXNGb3VuZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1ZXNGb3VuZDtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF0aW9uYWxUaW1lc3RhbXAgfSBmcm9tICcuLi91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVtdXhlciB7XG4gIGRlbXV4KFxuICAgIGRhdGE6IFVpbnQ4QXJyYXksXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGlzU2FtcGxlQWVzPzogYm9vbGVhbixcbiAgICBmbHVzaD86IGJvb2xlYW5cbiAgKTogRGVtdXhlclJlc3VsdDtcbiAgZGVtdXhTYW1wbGVBZXMoXG4gICAgZGF0YTogVWludDhBcnJheSxcbiAgICBrZXlEYXRhOiBLZXlEYXRhLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlclxuICApOiBQcm9taXNlPERlbXV4ZXJSZXN1bHQ+O1xuICBmbHVzaCh0aW1lT2Zmc2V0PzogbnVtYmVyKTogRGVtdXhlclJlc3VsdCB8IFByb21pc2U8RGVtdXhlclJlc3VsdD47XG4gIGRlc3Ryb3koKTogdm9pZDtcbiAgcmVzZXRJbml0U2VnbWVudChcbiAgICBpbml0U2VnbWVudDogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgICBhdWRpb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdmlkZW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHRyYWNrRHVyYXRpb246IG51bWJlclxuICApO1xuICByZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFBUUz86IFJhdGlvbmFsVGltZXN0YW1wIHwgbnVsbCk6IHZvaWQ7XG4gIHJlc2V0Q29udGlndWl0eSgpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlbXV4ZXJSZXN1bHQge1xuICBhdWRpb1RyYWNrOiBEZW11eGVkQXVkaW9UcmFjaztcbiAgdmlkZW9UcmFjazogRGVtdXhlZFZpZGVvVHJhY2s7XG4gIGlkM1RyYWNrOiBEZW11eGVkTWV0YWRhdGFUcmFjaztcbiAgdGV4dFRyYWNrOiBEZW11eGVkVXNlcmRhdGFUcmFjaztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZW11eGVkVHJhY2sge1xuICB0eXBlOiBzdHJpbmc7XG4gIGlkOiBudW1iZXI7XG4gIHBpZDogbnVtYmVyO1xuICBpbnB1dFRpbWVTY2FsZTogbnVtYmVyO1xuICBzZXF1ZW5jZU51bWJlcjogbnVtYmVyO1xuICBzYW1wbGVzOlxuICAgIHwgQXVkaW9TYW1wbGVbXVxuICAgIHwgQXZjU2FtcGxlW11cbiAgICB8IE1ldGFkYXRhU2FtcGxlW11cbiAgICB8IFVzZXJkYXRhU2FtcGxlW11cbiAgICB8IFVpbnQ4QXJyYXk7XG4gIHRpbWVzY2FsZT86IG51bWJlcjtcbiAgY29udGFpbmVyPzogc3RyaW5nO1xuICBkcm9wcGVkOiBudW1iZXI7XG4gIGR1cmF0aW9uPzogbnVtYmVyO1xuICBwZXNEYXRhPzogRWxlbWVudGFyeVN0cmVhbURhdGEgfCBudWxsO1xuICBjb2RlYz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXNzdGhyb3VnaFRyYWNrIGV4dGVuZHMgRGVtdXhlZFRyYWNrIHtcbiAgc2FtcGxlRHVyYXRpb246IG51bWJlcjtcbiAgc2FtcGxlczogVWludDhBcnJheTtcbiAgdGltZXNjYWxlOiBudW1iZXI7XG4gIGR1cmF0aW9uOiBudW1iZXI7XG4gIGNvZGVjOiBzdHJpbmc7XG59XG5leHBvcnQgaW50ZXJmYWNlIERlbXV4ZWRBdWRpb1RyYWNrIGV4dGVuZHMgRGVtdXhlZFRyYWNrIHtcbiAgY29uZmlnPzogbnVtYmVyW107XG4gIHNhbXBsZXJhdGU/OiBudW1iZXI7XG4gIHNlZ21lbnRDb2RlYz86IHN0cmluZztcbiAgY2hhbm5lbENvdW50PzogbnVtYmVyO1xuICBtYW5pZmVzdENvZGVjPzogc3RyaW5nO1xuICBzYW1wbGVzOiBBdWRpb1NhbXBsZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlbXV4ZWRWaWRlb1RyYWNrIGV4dGVuZHMgRGVtdXhlZFRyYWNrIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgcGl4ZWxSYXRpbz86IFtudW1iZXIsIG51bWJlcl07XG4gIGF1ZEZvdW5kPzogYm9vbGVhbjtcbiAgcHBzPzogVWludDhBcnJheVtdO1xuICBzcHM/OiBVaW50OEFycmF5W107XG4gIG5hbHVTdGF0ZT86IG51bWJlcjtcbiAgc2FtcGxlczogQXZjU2FtcGxlW10gfCBVaW50OEFycmF5O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlbXV4ZWRBdmNUcmFjayBleHRlbmRzIERlbXV4ZWRWaWRlb1RyYWNrIHtcbiAgc2FtcGxlczogQXZjU2FtcGxlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVtdXhlZE1ldGFkYXRhVHJhY2sgZXh0ZW5kcyBEZW11eGVkVHJhY2sge1xuICBzYW1wbGVzOiBNZXRhZGF0YVNhbXBsZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlbXV4ZWRVc2VyZGF0YVRyYWNrIGV4dGVuZHMgRGVtdXhlZFRyYWNrIHtcbiAgc2FtcGxlczogVXNlcmRhdGFTYW1wbGVbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gTWV0YWRhdGFTY2hlbWEge1xuICBhdWRpb0lkMyA9ICdvcmcuaWQzJyxcbiAgZGF0ZVJhbmdlID0gJ2NvbS5hcHBsZS5xdWlja3RpbWUuSExTJyxcbiAgZW1zZyA9ICdodHRwczovL2FvbWVkaWEub3JnL2Vtc2cvSUQzJyxcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTWV0YWRhdGFTYW1wbGUge1xuICBwdHM6IG51bWJlcjtcbiAgZHRzOiBudW1iZXI7XG4gIGR1cmF0aW9uOiBudW1iZXI7XG4gIGxlbj86IG51bWJlcjtcbiAgZGF0YTogVWludDhBcnJheTtcbiAgdHlwZTogTWV0YWRhdGFTY2hlbWE7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlcmRhdGFTYW1wbGUge1xuICBwdHM6IG51bWJlcjtcbiAgYnl0ZXM/OiBVaW50OEFycmF5O1xuICB0eXBlPzogbnVtYmVyO1xuICBwYXlsb2FkVHlwZT86IG51bWJlcjtcbiAgdXVpZD86IHN0cmluZztcbiAgdXNlckRhdGE/OiBzdHJpbmc7XG4gIHVzZXJEYXRhQnl0ZXM/OiBVaW50OEFycmF5O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF2Y1NhbXBsZSB7XG4gIGR0czogbnVtYmVyO1xuICBwdHM6IG51bWJlcjtcbiAga2V5OiBib29sZWFuO1xuICBmcmFtZTogYm9vbGVhbjtcbiAgdW5pdHM6IEF2Y1NhbXBsZVVuaXRbXTtcbiAgZGVidWc6IHN0cmluZztcbiAgbGVuZ3RoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXZjU2FtcGxlVW5pdCB7XG4gIGRhdGE6IFVpbnQ4QXJyYXk7XG4gIHR5cGU6IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgQXVkaW9TYW1wbGUgPSB7XG4gIHVuaXQ6IFVpbnQ4QXJyYXk7XG4gIHB0czogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgQXVkaW9GcmFtZSA9IHtcbiAgc2FtcGxlOiBBdWRpb1NhbXBsZTtcbiAgbGVuZ3RoOiBudW1iZXI7XG4gIG1pc3Npbmc6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWxlbWVudGFyeVN0cmVhbURhdGEge1xuICBkYXRhOiBVaW50OEFycmF5W107XG4gIHNpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBLZXlEYXRhIHtcbiAgbWV0aG9kOiBzdHJpbmc7XG4gIGtleTogVWludDhBcnJheTtcbiAgaXY6IFVpbnQ4QXJyYXk7XG59XG4iLCJpbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHtcbiAgc2VuZEFkZFRyYWNrRXZlbnQsXG4gIGNsZWFyQ3VycmVudEN1ZXMsXG4gIHJlbW92ZUN1ZXNJblJhbmdlLFxufSBmcm9tICcuLi91dGlscy90ZXh0dHJhY2stdXRpbHMnO1xuaW1wb3J0ICogYXMgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XG5pbXBvcnQge1xuICBEYXRlUmFuZ2UsXG4gIGlzRGF0ZVJhbmdlQ3VlQXR0cmlidXRlLFxuICBpc1NDVEUzNUF0dHJpYnV0ZSxcbn0gZnJvbSAnLi4vbG9hZGVyL2RhdGUtcmFuZ2UnO1xuaW1wb3J0IHsgTWV0YWRhdGFTY2hlbWEgfSBmcm9tICcuLi90eXBlcy9kZW11eGVyJztcbmltcG9ydCB0eXBlIHtcbiAgQnVmZmVyRmx1c2hpbmdEYXRhLFxuICBGcmFnUGFyc2luZ01ldGFkYXRhRGF0YSxcbiAgTGV2ZWxVcGRhdGVkRGF0YSxcbiAgTWVkaWFBdHRhY2hlZERhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgV2ViS2l0RGF0YUN1ZTogVlRUQ3VlIHwgdm9pZDtcbiAgfVxufVxuXG50eXBlIEN1ZSA9IFZUVEN1ZSB8IFRleHRUcmFja0N1ZTtcblxuY29uc3QgTUlOX0NVRV9EVVJBVElPTiA9IDAuMjU7XG5cbmZ1bmN0aW9uIGdldEN1ZUNsYXNzKCkge1xuICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIC8vIEF0dGVtcHQgdG8gcmVjcmVhdGUgU2FmYXJpIGZ1bmN0aW9uYWxpdHkgYnkgY3JlYXRpbmdcbiAgLy8gV2ViS2l0RGF0YUN1ZSBvYmplY3RzIHdoZW4gYXZhaWxhYmxlIGFuZCBzdG9yZSB0aGUgZGVjb2RlZFxuICAvLyBJRDMgZGF0YSBpbiB0aGUgdmFsdWUgcHJvcGVydHkgb2YgdGhlIGN1ZVxuICByZXR1cm4gKHNlbGYuV2ViS2l0RGF0YUN1ZSB8fCBzZWxmLlZUVEN1ZSB8fCBzZWxmLlRleHRUcmFja0N1ZSkgYXMgYW55O1xufVxuXG4vLyBWVFRDdWUgbGF0ZXN0IGRyYWZ0IGFsbG93cyBhbiBpbmZpbml0ZSBkdXJhdGlvbiwgZmFsbGJhY2tcbi8vIHRvIE1BWF9WQUxVRSBpZiBuZWNlc3NhcnlcbmNvbnN0IE1BWF9DVUVfRU5EVElNRSA9ICgoKSA9PiB7XG4gIGNvbnN0IEN1ZSA9IGdldEN1ZUNsYXNzKCk7XG4gIHRyeSB7XG4gICAgbmV3IEN1ZSgwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICB9XG4gIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG59KSgpO1xuXG5mdW5jdGlvbiBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMoZGF0ZTogRGF0ZSwgb2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgLyAxMDAwIC0gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBoZXhUb0FycmF5QnVmZmVyKHN0cik6IEFycmF5QnVmZmVyIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShcbiAgICBzdHJcbiAgICAgIC5yZXBsYWNlKC9eMHgvLCAnJylcbiAgICAgIC5yZXBsYWNlKC8oW1xcZGEtZkEtRl17Mn0pID8vZywgJzB4JDEgJylcbiAgICAgIC5yZXBsYWNlKC8gKyQvLCAnJylcbiAgICAgIC5zcGxpdCgnICcpXG4gICkuYnVmZmVyO1xufVxuY2xhc3MgSUQzVHJhY2tDb250cm9sbGVyIGltcGxlbWVudHMgQ29tcG9uZW50QVBJIHtcbiAgcHJpdmF0ZSBobHM6IEhscztcbiAgcHJpdmF0ZSBpZDNUcmFjazogVGV4dFRyYWNrIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBkYXRlUmFuZ2VDdWVzQXBwZW5kZWQ6IFJlY29yZDxcbiAgICBzdHJpbmcsXG4gICAgeyBjdWVzOiBSZWNvcmQ8c3RyaW5nLCBDdWU+OyBkYXRlUmFuZ2U6IERhdGVSYW5nZTsgZHVyYXRpb25Lbm93bjogYm9vbGVhbiB9XG4gID4gPSB7fTtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHRoaXMub25GcmFnUGFyc2luZ01ldGFkYXRhLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHRoaXMub25GcmFnUGFyc2luZ01ldGFkYXRhLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gIH1cblxuICAvLyBBZGQgSUQzIG1ldGF0YWRhdGEgdGV4dCB0cmFjay5cbiAgcHJvdGVjdGVkIG9uTWVkaWFBdHRhY2hlZChcbiAgICBldmVudDogRXZlbnRzLk1FRElBX0FUVEFDSEVELFxuICAgIGRhdGE6IE1lZGlhQXR0YWNoZWREYXRhXG4gICk6IHZvaWQge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFEZXRhY2hpbmcoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyQ3VycmVudEN1ZXModGhpcy5pZDNUcmFjayk7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgfVxuXG4gIHByaXZhdGUgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgfVxuXG4gIGNyZWF0ZVRyYWNrKG1lZGlhOiBIVE1MTWVkaWFFbGVtZW50KTogVGV4dFRyYWNrIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0SUQzVHJhY2sobWVkaWEudGV4dFRyYWNrcykgYXMgVGV4dFRyYWNrO1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgICByZXR1cm4gdHJhY2s7XG4gIH1cblxuICBnZXRJRDNUcmFjayh0ZXh0VHJhY2tzOiBUZXh0VHJhY2tMaXN0KTogVGV4dFRyYWNrIHwgdm9pZCB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dFRyYWNrOiBUZXh0VHJhY2sgPSB0ZXh0VHJhY2tzW2ldO1xuICAgICAgaWYgKHRleHRUcmFjay5raW5kID09PSAnbWV0YWRhdGEnICYmIHRleHRUcmFjay5sYWJlbCA9PT0gJ2lkMycpIHtcbiAgICAgICAgLy8gc2VuZCAnYWRkdHJhY2snIHdoZW4gcmV1c2luZyB0aGUgdGV4dFRyYWNrIGZvciBtZXRhZGF0YSxcbiAgICAgICAgLy8gc2FtZSBhcyB3aGF0IHdlIGRvIGZvciBjYXB0aW9uc1xuICAgICAgICBzZW5kQWRkVHJhY2tFdmVudCh0ZXh0VHJhY2ssIHRoaXMubWVkaWEpO1xuXG4gICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnLCAnaWQzJyk7XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nTWV0YWRhdGEoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsXG4gICAgZGF0YTogRnJhZ1BhcnNpbmdNZXRhZGF0YURhdGFcbiAgKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgaGxzOiB7XG4gICAgICAgIGNvbmZpZzogeyBlbmFibGVFbXNnTWV0YWRhdGFDdWVzLCBlbmFibGVJRDNNZXRhZGF0YUN1ZXMgfSxcbiAgICAgIH0sXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFlbmFibGVFbXNnTWV0YWRhdGFDdWVzICYmICFlbmFibGVJRDNNZXRhZGF0YUN1ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IHNhbXBsZXMgfSA9IGRhdGE7XG5cbiAgICAvLyBjcmVhdGUgdHJhY2sgZHluYW1pY2FsbHlcbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmNyZWF0ZVRyYWNrKHRoaXMubWVkaWEpO1xuICAgIH1cblxuICAgIGNvbnN0IEN1ZSA9IGdldEN1ZUNsYXNzKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBzYW1wbGVzW2ldLnR5cGU7XG4gICAgICBpZiAoXG4gICAgICAgICh0eXBlID09PSBNZXRhZGF0YVNjaGVtYS5lbXNnICYmICFlbmFibGVFbXNnTWV0YWRhdGFDdWVzKSB8fFxuICAgICAgICAhZW5hYmxlSUQzTWV0YWRhdGFDdWVzXG4gICAgICApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZyYW1lcyA9IElEMy5nZXRJRDNGcmFtZXMoc2FtcGxlc1tpXS5kYXRhKTtcbiAgICAgIGlmIChmcmFtZXMpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc2FtcGxlc1tpXS5wdHM7XG4gICAgICAgIGxldCBlbmRUaW1lOiBudW1iZXIgPSBzdGFydFRpbWUgKyBzYW1wbGVzW2ldLmR1cmF0aW9uO1xuXG4gICAgICAgIGlmIChlbmRUaW1lID4gTUFYX0NVRV9FTkRUSU1FKSB7XG4gICAgICAgICAgZW5kVGltZSA9IE1BWF9DVUVfRU5EVElNRTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWVEaWZmID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgaWYgKHRpbWVEaWZmIDw9IDApIHtcbiAgICAgICAgICBlbmRUaW1lID0gc3RhcnRUaW1lICsgTUlOX0NVRV9EVVJBVElPTjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZnJhbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbal07XG4gICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgcHV0IHRoZSB0aW1lc3RhbXAgZnJhbWUgaW4gdGhlIFRleHRUcmFja1xuICAgICAgICAgIGlmICghSUQzLmlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICAgICAgICAvLyBhZGQgYSBib3VuZHMgdG8gYW55IHVuYm91bmRlZCBjdWVzXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlkM0N1ZUVuZHMoc3RhcnRUaW1lKTtcblxuICAgICAgICAgICAgY29uc3QgY3VlID0gbmV3IEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsICcnKTtcbiAgICAgICAgICAgIGN1ZS52YWx1ZSA9IGZyYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgY3VlLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pZDNUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGVJZDNDdWVFbmRzKHN0YXJ0VGltZTogbnVtYmVyKSB7XG4gICAgY29uc3QgY3VlcyA9IHRoaXMuaWQzVHJhY2s/LmN1ZXM7XG4gICAgaWYgKGN1ZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSBjdWVzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY29uc3QgY3VlID0gY3Vlc1tpXSBhcyBhbnk7XG4gICAgICAgIGlmIChjdWUuc3RhcnRUaW1lIDwgc3RhcnRUaW1lICYmIGN1ZS5lbmRUaW1lID09PSBNQVhfQ1VFX0VORFRJTUUpIHtcbiAgICAgICAgICBjdWUuZW5kVGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyRmx1c2hpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsXG4gICAgeyBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB0eXBlIH06IEJ1ZmZlckZsdXNoaW5nRGF0YVxuICApIHtcbiAgICBjb25zdCB7IGlkM1RyYWNrLCBobHMgfSA9IHRoaXM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBjb25maWc6IHsgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcywgZW5hYmxlSUQzTWV0YWRhdGFDdWVzIH0sXG4gICAgfSA9IGhscztcbiAgICBpZiAoaWQzVHJhY2sgJiYgKGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgfHwgZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSkge1xuICAgICAgbGV0IHByZWRpY2F0ZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcHJlZGljYXRlID0gKGN1ZSkgPT5cbiAgICAgICAgICAoY3VlIGFzIGFueSkudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMgJiZcbiAgICAgICAgICBlbmFibGVJRDNNZXRhZGF0YUN1ZXM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgcHJlZGljYXRlID0gKGN1ZSkgPT5cbiAgICAgICAgICAoY3VlIGFzIGFueSkudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiBlbmFibGVFbXNnTWV0YWRhdGFDdWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZGljYXRlID0gKGN1ZSkgPT5cbiAgICAgICAgICAoKGN1ZSBhcyBhbnkpLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzICYmXG4gICAgICAgICAgICBlbmFibGVJRDNNZXRhZGF0YUN1ZXMpIHx8XG4gICAgICAgICAgKChjdWUgYXMgYW55KS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5lbXNnICYmIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMpO1xuICAgICAgfVxuICAgICAgcmVtb3ZlQ3Vlc0luUmFuZ2UoaWQzVHJhY2ssIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHByZWRpY2F0ZSk7XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbFVwZGF0ZWQoZXZlbnQ6IEV2ZW50cy5MRVZFTF9VUERBVEVELCB7IGRldGFpbHMgfTogTGV2ZWxVcGRhdGVkRGF0YSkge1xuICAgIGlmIChcbiAgICAgICF0aGlzLm1lZGlhIHx8XG4gICAgICAhZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgfHxcbiAgICAgICF0aGlzLmhscy5jb25maWcuZW5hYmxlRGF0ZVJhbmdlTWV0YWRhdGFDdWVzXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkLCBpZDNUcmFjayB9ID0gdGhpcztcbiAgICBjb25zdCB7IGRhdGVSYW5nZXMgfSA9IGRldGFpbHM7XG4gICAgY29uc3QgaWRzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlcyk7XG4gICAgLy8gUmVtb3ZlIGN1ZXMgZnJvbSB0cmFjayBub3QgZm91bmQgaW4gZGV0YWlscy5kYXRlUmFuZ2VzXG4gICAgaWYgKGlkM1RyYWNrKSB7XG4gICAgICBjb25zdCBpZHNUb1JlbW92ZSA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZUN1ZXNBcHBlbmRlZCkuZmlsdGVyKFxuICAgICAgICAoaWQpID0+ICFpZHMuaW5jbHVkZXMoaWQpXG4gICAgICApO1xuICAgICAgZm9yIChsZXQgaSA9IGlkc1RvUmVtb3ZlLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY29uc3QgaWQgPSBpZHNUb1JlbW92ZVtpXTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXS5jdWVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICBpZDNUcmFjay5yZW1vdmVDdWUoZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXS5jdWVzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEV4aXQgaWYgdGhlIHBsYXlsaXN0IGRvZXMgbm90IGhhdmUgRGF0ZSBSYW5nZXMgb3IgZG9lcyBub3QgaGF2ZSBQcm9ncmFtIERhdGUgVGltZVxuICAgIGNvbnN0IGxhc3RGcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRzW2RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpZHMubGVuZ3RoID09PSAwIHx8ICFOdW1iZXIuaXNGaW5pdGUobGFzdEZyYWdtZW50Py5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5jcmVhdGVUcmFjayh0aGlzLm1lZGlhKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRlVGltZU9mZnNldCA9XG4gICAgICAobGFzdEZyYWdtZW50LnByb2dyYW1EYXRlVGltZSBhcyBudW1iZXIpIC8gMTAwMCAtIGxhc3RGcmFnbWVudC5zdGFydDtcbiAgICBjb25zdCBDdWUgPSBnZXRDdWVDbGFzcygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGlkID0gaWRzW2ldO1xuICAgICAgY29uc3QgZGF0ZVJhbmdlID0gZGF0ZVJhbmdlc1tpZF07XG4gICAgICBjb25zdCBhcHBlbmRlZERhdGVSYW5nZUN1ZXMgPSBkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdO1xuICAgICAgY29uc3QgY3VlcyA9IGFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcz8uY3VlcyB8fCB7fTtcbiAgICAgIGxldCBkdXJhdGlvbktub3duID0gYXBwZW5kZWREYXRlUmFuZ2VDdWVzPy5kdXJhdGlvbktub3duIHx8IGZhbHNlO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzKFxuICAgICAgICBkYXRlUmFuZ2Uuc3RhcnREYXRlLFxuICAgICAgICBkYXRlVGltZU9mZnNldFxuICAgICAgKTtcbiAgICAgIGxldCBlbmRUaW1lID0gTUFYX0NVRV9FTkRUSU1FO1xuICAgICAgY29uc3QgZW5kRGF0ZSA9IGRhdGVSYW5nZS5lbmREYXRlO1xuICAgICAgaWYgKGVuZERhdGUpIHtcbiAgICAgICAgZW5kVGltZSA9IGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhlbmREYXRlLCBkYXRlVGltZU9mZnNldCk7XG4gICAgICAgIGR1cmF0aW9uS25vd24gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkYXRlUmFuZ2UuZW5kT25OZXh0ICYmICFkdXJhdGlvbktub3duKSB7XG4gICAgICAgIGNvbnN0IG5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzID0gaWRzXG4gICAgICAgICAgLnJlZHVjZSgoZmlsdGVyTWFwQXJyYXksIGlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgY2FuZGlkYXRlLmNsYXNzID09PSBkYXRlUmFuZ2UuY2xhc3MgJiZcbiAgICAgICAgICAgICAgY2FuZGlkYXRlLmlkICE9PSBpZCAmJlxuICAgICAgICAgICAgICBjYW5kaWRhdGUuc3RhcnREYXRlID4gZGF0ZVJhbmdlLnN0YXJ0RGF0ZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGZpbHRlck1hcEFycmF5LnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJNYXBBcnJheTtcbiAgICAgICAgICB9LCBbXSBhcyBEYXRlUmFuZ2VbXSlcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5zdGFydERhdGUuZ2V0VGltZSgpIC0gYi5zdGFydERhdGUuZ2V0VGltZSgpKVswXTtcbiAgICAgICAgaWYgKG5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzKSB7XG4gICAgICAgICAgZW5kVGltZSA9IGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhcbiAgICAgICAgICAgIG5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzLnN0YXJ0RGF0ZSxcbiAgICAgICAgICAgIGRhdGVUaW1lT2Zmc2V0XG4gICAgICAgICAgKTtcbiAgICAgICAgICBkdXJhdGlvbktub3duID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlLmF0dHIpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF0dHJpYnV0ZXNbal07XG4gICAgICAgIGlmICghaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdWUgPSBjdWVzW2tleV0gYXMgYW55O1xuICAgICAgICBpZiAoY3VlKSB7XG4gICAgICAgICAgaWYgKGR1cmF0aW9uS25vd24gJiYgIWFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcy5kdXJhdGlvbktub3duKSB7XG4gICAgICAgICAgICBjdWUuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBkYXRhID0gZGF0ZVJhbmdlLmF0dHJba2V5XTtcbiAgICAgICAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgJycpO1xuICAgICAgICAgIGlmIChpc1NDVEUzNUF0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgICAgICBkYXRhID0gaGV4VG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VlLnZhbHVlID0geyBrZXksIGRhdGEgfTtcbiAgICAgICAgICBjdWUudHlwZSA9IE1ldGFkYXRhU2NoZW1hLmRhdGVSYW5nZTtcbiAgICAgICAgICBjdWUuaWQgPSBpZDtcbiAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICAgIGN1ZXNba2V5XSA9IGN1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXSA9IHtcbiAgICAgICAgY3VlcyxcbiAgICAgICAgZGF0ZVJhbmdlLFxuICAgICAgICBkdXJhdGlvbktub3duLFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSUQzVHJhY2tDb250cm9sbGVyO1xuIiwiaW1wb3J0IHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWRldGFpbHMnO1xuaW1wb3J0IHsgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7XG4gIEVycm9yRGF0YSxcbiAgTGV2ZWxVcGRhdGVkRGF0YSxcbiAgTWVkaWFBdHRhY2hpbmdEYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgSGxzQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF0ZW5jeUNvbnRyb2xsZXIgaW1wbGVtZW50cyBDb21wb25lbnRBUEkge1xuICBwcml2YXRlIGhsczogSGxzO1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogSGxzQ29uZmlnO1xuICBwcml2YXRlIG1lZGlhOiBIVE1MTWVkaWFFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbGV2ZWxEZXRhaWxzOiBMZXZlbERldGFpbHMgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjdXJyZW50VGltZTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBzdGFsbENvdW50OiBudW1iZXIgPSAwO1xuICBwcml2YXRlIF9sYXRlbmN5OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB0aW1ldXBkYXRlSGFuZGxlciA9ICgpID0+IHRoaXMudGltZXVwZGF0ZSgpO1xuXG4gIGNvbnN0cnVjdG9yKGhsczogSGxzKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGdldCBsYXRlbmN5KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2xhdGVuY3kgfHwgMDtcbiAgfVxuXG4gIGdldCBtYXhMYXRlbmN5KCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBjb25maWcsIGxldmVsRGV0YWlscyB9ID0gdGhpcztcbiAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxEZXRhaWxzXG4gICAgICA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb25cbiAgICAgIDogMDtcbiAgfVxuXG4gIGdldCB0YXJnZXRMYXRlbmN5KCk6IG51bWJlciB8IG51bGwge1xuICAgIGNvbnN0IHsgbGV2ZWxEZXRhaWxzIH0gPSB0aGlzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IGhvbGRCYWNrLCBwYXJ0SG9sZEJhY2ssIHRhcmdldGR1cmF0aW9uIH0gPSBsZXZlbERldGFpbHM7XG4gICAgY29uc3QgeyBsaXZlU3luY0R1cmF0aW9uLCBsaXZlU3luY0R1cmF0aW9uQ291bnQsIGxvd0xhdGVuY3lNb2RlIH0gPVxuICAgICAgdGhpcy5jb25maWc7XG4gICAgY29uc3QgdXNlckNvbmZpZyA9IHRoaXMuaGxzLnVzZXJDb25maWc7XG4gICAgbGV0IHRhcmdldExhdGVuY3kgPSBsb3dMYXRlbmN5TW9kZSA/IHBhcnRIb2xkQmFjayB8fCBob2xkQmFjayA6IGhvbGRCYWNrO1xuICAgIGlmIChcbiAgICAgIHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fFxuICAgICAgdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHxcbiAgICAgIHRhcmdldExhdGVuY3kgPT09IDBcbiAgICApIHtcbiAgICAgIHRhcmdldExhdGVuY3kgPVxuICAgICAgICBsaXZlU3luY0R1cmF0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IGxpdmVTeW5jRHVyYXRpb25cbiAgICAgICAgICA6IGxpdmVTeW5jRHVyYXRpb25Db3VudCAqIHRhcmdldGR1cmF0aW9uO1xuICAgIH1cbiAgICBjb25zdCBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZSA9IHRhcmdldGR1cmF0aW9uO1xuICAgIGNvbnN0IGxpdmVTeW5jT25TdGFsbEluY3JlYXNlID0gMS4wO1xuICAgIHJldHVybiAoXG4gICAgICB0YXJnZXRMYXRlbmN5ICtcbiAgICAgIE1hdGgubWluKFxuICAgICAgICB0aGlzLnN0YWxsQ291bnQgKiBsaXZlU3luY09uU3RhbGxJbmNyZWFzZSxcbiAgICAgICAgbWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2VcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24oKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgY29uc3QgbGl2ZUVkZ2UgPSB0aGlzLmVzdGltYXRlTGl2ZUVkZ2UoKTtcbiAgICBjb25zdCB0YXJnZXRMYXRlbmN5ID0gdGhpcy50YXJnZXRMYXRlbmN5O1xuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgIGlmIChsaXZlRWRnZSA9PT0gbnVsbCB8fCB0YXJnZXRMYXRlbmN5ID09PSBudWxsIHx8IGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2UgPSBsZXZlbERldGFpbHMuZWRnZTtcbiAgICBjb25zdCBzeW5jUG9zaXRpb24gPSBsaXZlRWRnZSAtIHRhcmdldExhdGVuY3kgLSB0aGlzLmVkZ2VTdGFsbGVkO1xuICAgIGNvbnN0IG1pbiA9IGVkZ2UgLSBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICBjb25zdCBtYXggPVxuICAgICAgZWRnZSAtXG4gICAgICAoKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0KSB8fFxuICAgICAgICBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIHN5bmNQb3NpdGlvbiksIG1heCk7XG4gIH1cblxuICBnZXQgZHJpZnQoKTogbnVtYmVyIHtcbiAgICBjb25zdCB7IGxldmVsRGV0YWlscyB9ID0gdGhpcztcbiAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVsRGV0YWlscy5kcmlmdDtcbiAgfVxuXG4gIGdldCBlZGdlU3RhbGxlZCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgbGV2ZWxEZXRhaWxzIH0gPSB0aGlzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBtYXhMZXZlbFVwZGF0ZUFnZSA9XG4gICAgICAoKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0KSB8fFxuICAgICAgICBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pICogMztcbiAgICByZXR1cm4gTWF0aC5tYXgobGV2ZWxEZXRhaWxzLmFnZSAtIG1heExldmVsVXBkYXRlQWdlLCAwKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGZvcndhcmRCdWZmZXJMZW5ndGgoKTogbnVtYmVyIHtcbiAgICBjb25zdCB7IG1lZGlhLCBsZXZlbERldGFpbHMgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSB8fCAhbGV2ZWxEZXRhaWxzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyZWRSYW5nZXMgPSBtZWRpYS5idWZmZXJlZC5sZW5ndGg7XG4gICAgcmV0dXJuIChcbiAgICAgIChidWZmZXJlZFJhbmdlc1xuICAgICAgICA/IG1lZGlhLmJ1ZmZlcmVkLmVuZChidWZmZXJlZFJhbmdlcyAtIDEpXG4gICAgICAgIDogbGV2ZWxEZXRhaWxzLmVkZ2UpIC0gdGhpcy5jdXJyZW50VGltZVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy50aW1ldXBkYXRlSGFuZGxlciA9IG51bGw7XG4gIH1cblxuICBwcml2YXRlIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cblxuICBwcml2YXRlIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1lZGlhQXR0YWNoZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5NRURJQV9BVFRBQ0hFRCxcbiAgICBkYXRhOiBNZWRpYUF0dGFjaGluZ0RhdGFcbiAgKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5tZWRpYS5hZGRFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy50aW1ldXBkYXRlSGFuZGxlcik7XG4gIH1cblxuICBwcml2YXRlIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5fbGF0ZW5jeSA9IG51bGw7XG4gICAgdGhpcy5zdGFsbENvdW50ID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgb25MZXZlbFVwZGF0ZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTF9VUERBVEVELFxuICAgIHsgZGV0YWlscyB9OiBMZXZlbFVwZGF0ZWREYXRhXG4gICkge1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gZGV0YWlscztcbiAgICBpZiAoZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgdGhpcy50aW1ldXBkYXRlKCk7XG4gICAgfVxuICAgIGlmICghZGV0YWlscy5saXZlICYmIHRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25FcnJvcihldmVudDogRXZlbnRzLkVSUk9SLCBkYXRhOiBFcnJvckRhdGEpIHtcbiAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGFsbENvdW50Kys7XG4gICAgaWYgKHRoaXMubGV2ZWxEZXRhaWxzPy5saXZlKSB7XG4gICAgICBsb2dnZXIud2FybihcbiAgICAgICAgJ1twbGF5YmFjay1yYXRlLWNvbnRyb2xsZXJdOiBTdGFsbCBkZXRlY3RlZCwgYWRqdXN0aW5nIHRhcmdldCBsYXRlbmN5J1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRpbWV1cGRhdGUoKSB7XG4gICAgY29uc3QgeyBtZWRpYSwgbGV2ZWxEZXRhaWxzIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG5cbiAgICBjb25zdCBsYXRlbmN5ID0gdGhpcy5jb21wdXRlTGF0ZW5jeSgpO1xuICAgIGlmIChsYXRlbmN5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2xhdGVuY3kgPSBsYXRlbmN5O1xuXG4gICAgLy8gQWRhcHQgcGxheWJhY2tSYXRlIHRvIG1lZXQgdGFyZ2V0IGxhdGVuY3kgaW4gbG93LWxhdGVuY3kgbW9kZVxuICAgIGNvbnN0IHsgbG93TGF0ZW5jeU1vZGUsIG1heExpdmVTeW5jUGxheWJhY2tSYXRlIH0gPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIWxvd0xhdGVuY3lNb2RlIHx8IG1heExpdmVTeW5jUGxheWJhY2tSYXRlID09PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG4gICAgaWYgKHRhcmdldExhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlzdGFuY2VGcm9tVGFyZ2V0ID0gbGF0ZW5jeSAtIHRhcmdldExhdGVuY3k7XG4gICAgLy8gT25seSBhZGp1c3QgcGxheWJhY2tSYXRlIHdoZW4gd2l0aGluIG9uZSB0YXJnZXQgZHVyYXRpb24gb2YgdGFyZ2V0TGF0ZW5jeVxuICAgIC8vIGFuZCBtb3JlIHRoYW4gb25lIHNlY29uZCBmcm9tIHVuZGVyLWJ1ZmZlcmluZy5cbiAgICAvLyBQbGF5YmFjayBmdXJ0aGVyIHRoYW4gb25lIHRhcmdldCBkdXJhdGlvbiBmcm9tIHRhcmdldCBjYW4gYmUgY29uc2lkZXJlZCBEVlIgcGxheWJhY2suXG4gICAgY29uc3QgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbiA9IE1hdGgubWluKFxuICAgICAgdGhpcy5tYXhMYXRlbmN5LFxuICAgICAgdGFyZ2V0TGF0ZW5jeSArIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvblxuICAgICk7XG4gICAgY29uc3QgaW5MaXZlUmFuZ2UgPSBkaXN0YW5jZUZyb21UYXJnZXQgPCBsaXZlTWluTGF0ZW5jeUR1cmF0aW9uO1xuICAgIGlmIChcbiAgICAgIGxldmVsRGV0YWlscy5saXZlICYmXG4gICAgICBpbkxpdmVSYW5nZSAmJlxuICAgICAgZGlzdGFuY2VGcm9tVGFyZ2V0ID4gMC4wNSAmJlxuICAgICAgdGhpcy5mb3J3YXJkQnVmZmVyTGVuZ3RoID4gMVxuICAgICkge1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5taW4oMiwgTWF0aC5tYXgoMS4wLCBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZSkpO1xuICAgICAgY29uc3QgcmF0ZSA9XG4gICAgICAgIE1hdGgucm91bmQoXG4gICAgICAgICAgKDIgLyAoMSArIE1hdGguZXhwKC0wLjc1ICogZGlzdGFuY2VGcm9tVGFyZ2V0IC0gdGhpcy5lZGdlU3RhbGxlZCkpKSAqXG4gICAgICAgICAgICAyMFxuICAgICAgICApIC8gMjA7XG4gICAgICBtZWRpYS5wbGF5YmFja1JhdGUgPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KDEsIHJhdGUpKTtcbiAgICB9IGVsc2UgaWYgKG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMSAmJiBtZWRpYS5wbGF5YmFja1JhdGUgIT09IDApIHtcbiAgICAgIG1lZGlhLnBsYXliYWNrUmF0ZSA9IDE7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlc3RpbWF0ZUxpdmVFZGdlKCk6IG51bWJlciB8IG51bGwge1xuICAgIGNvbnN0IHsgbGV2ZWxEZXRhaWxzIH0gPSB0aGlzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxEZXRhaWxzLmVkZ2UgKyBsZXZlbERldGFpbHMuYWdlO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21wdXRlTGF0ZW5jeSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICBjb25zdCBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgIGlmIChsaXZlRWRnZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsaXZlRWRnZSAtIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cbn1cbiIsImltcG9ydCB7IExldmVsRGV0YWlscyB9IGZyb20gJy4uL2xvYWRlci9sZXZlbC1kZXRhaWxzJztcbmltcG9ydCB7IEF0dHJMaXN0IH0gZnJvbSAnLi4vdXRpbHMvYXR0ci1saXN0JztcblxuZXhwb3J0IGludGVyZmFjZSBMZXZlbFBhcnNlZCB7XG4gIGF0dHJzOiBMZXZlbEF0dHJpYnV0ZXM7XG4gIGF1ZGlvQ29kZWM/OiBzdHJpbmc7XG4gIGJpdHJhdGU6IG51bWJlcjtcbiAgZGV0YWlscz86IExldmVsRGV0YWlscztcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICBpZD86IG51bWJlcjtcbiAgbGV2ZWw/OiBudW1iZXI7XG4gIG5hbWU6IHN0cmluZztcbiAgdGV4dENvZGVjPzogc3RyaW5nO1xuICB1bmtub3duQ29kZWNzPzogc3RyaW5nW107XG4gIHVybDogc3RyaW5nO1xuICB2aWRlb0NvZGVjPzogc3RyaW5nO1xuICB3aWR0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMZXZlbEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyTGlzdCB7XG4gICdBTExPV0VELUNQQyc/OiBzdHJpbmc7XG4gIEFVRElPPzogc3RyaW5nO1xuICAnQVZFUkFHRS1CQU5EV0lEVEgnPzogc3RyaW5nO1xuICBCQU5EV0lEVEg/OiBzdHJpbmc7XG4gICdDTE9TRUQtQ0FQVElPTlMnPzogc3RyaW5nO1xuICBDT0RFQ1M/OiBzdHJpbmc7XG4gICdGUkFNRS1SQVRFJz86IHN0cmluZztcbiAgJ0hEQ1AtTEVWRUwnPzogJ1RZUEUtMCcgfCAnVFlQRS0xJyB8ICdOT05FJztcbiAgJ1BBVEhXQVktSUQnPzogc3RyaW5nO1xuICBSRVNPTFVUSU9OPzogc3RyaW5nO1xuICBTQ09SRT86IHN0cmluZztcbiAgJ1NUQUJMRS1WQVJJQU5ULUlEJz86IHN0cmluZztcbiAgU1VCVElUTEVTPzogc3RyaW5nO1xuICAnU1VQUExFTUVOVEFMLUNPREVDUyc/OiBzdHJpbmc7XG4gIFZJREVPPzogc3RyaW5nO1xuICAnVklERU8tUkFOR0UnPzogJ1NEUicgfCAnSExHJyB8ICdQUSc7XG59XG5cbmV4cG9ydCBjb25zdCBIZGNwTGV2ZWxzID0gWydOT05FJywgJ1RZUEUtMCcsICdUWVBFLTEnLCBudWxsXSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIEhkY3BMZXZlbCA9ICh0eXBlb2YgSGRjcExldmVscylbbnVtYmVyXTtcblxuZXhwb3J0IHR5cGUgVmFyaWFibGVNYXAgPSBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG5leHBvcnQgY29uc3QgZW51bSBIbHNTa2lwIHtcbiAgTm8gPSAnJyxcbiAgWWVzID0gJ1lFUycsXG4gIHYyID0gJ3YyJyxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNraXBWYWx1ZShkZXRhaWxzOiBMZXZlbERldGFpbHMsIG1zbj86IG51bWJlcik6IEhsc1NraXAge1xuICBjb25zdCB7IGNhblNraXBVbnRpbCwgY2FuU2tpcERhdGVSYW5nZXMsIGVuZFNOIH0gPSBkZXRhaWxzO1xuICBjb25zdCBzbkNoYW5nZUdvYWwgPSBtc24gIT09IHVuZGVmaW5lZCA/IG1zbiAtIGVuZFNOIDogMDtcbiAgaWYgKGNhblNraXBVbnRpbCAmJiBzbkNoYW5nZUdvYWwgPCBjYW5Ta2lwVW50aWwpIHtcbiAgICBpZiAoY2FuU2tpcERhdGVSYW5nZXMpIHtcbiAgICAgIHJldHVybiBIbHNTa2lwLnYyO1xuICAgIH1cbiAgICByZXR1cm4gSGxzU2tpcC5ZZXM7XG4gIH1cbiAgcmV0dXJuIEhsc1NraXAuTm87XG59XG5cbmV4cG9ydCBjbGFzcyBIbHNVcmxQYXJhbWV0ZXJzIHtcbiAgbXNuPzogbnVtYmVyO1xuICBwYXJ0PzogbnVtYmVyO1xuICBza2lwPzogSGxzU2tpcDtcblxuICBjb25zdHJ1Y3Rvcihtc24/OiBudW1iZXIsIHBhcnQ/OiBudW1iZXIsIHNraXA/OiBIbHNTa2lwKSB7XG4gICAgdGhpcy5tc24gPSBtc247XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICB0aGlzLnNraXAgPSBza2lwO1xuICB9XG5cbiAgYWRkRGlyZWN0aXZlcyh1cmk6IHN0cmluZyk6IHN0cmluZyB8IG5ldmVyIHtcbiAgICBjb25zdCB1cmw6IFVSTCA9IG5ldyBzZWxmLlVSTCh1cmkpO1xuICAgIGlmICh0aGlzLm1zbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19tc24nLCB0aGlzLm1zbi50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wYXJ0JywgdGhpcy5wYXJ0LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19za2lwJywgdGhpcy5za2lwKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybC5ocmVmO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMZXZlbCB7XG4gIHB1YmxpYyByZWFkb25seSBfYXR0cnM6IExldmVsQXR0cmlidXRlc1tdO1xuICBwdWJsaWMgcmVhZG9ubHkgYXVkaW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBwdWJsaWMgcmVhZG9ubHkgYml0cmF0ZTogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgY29kZWNTZXQ6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGhlaWdodDogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgaWQ6IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IG5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgcHVibGljIHJlYWRvbmx5IHZpZGVvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgcHVibGljIHJlYWRvbmx5IHdpZHRoOiBudW1iZXI7XG4gIHB1YmxpYyByZWFkb25seSB1bmtub3duQ29kZWNzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcbiAgcHVibGljIGF1ZGlvR3JvdXBJZHM/OiAoc3RyaW5nIHwgdW5kZWZpbmVkKVtdO1xuICBwdWJsaWMgZGV0YWlscz86IExldmVsRGV0YWlscztcbiAgcHVibGljIGZyYWdtZW50RXJyb3I6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBsb2FkRXJyb3I6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBsb2FkZWQ/OiB7IGJ5dGVzOiBudW1iZXI7IGR1cmF0aW9uOiBudW1iZXIgfTtcbiAgcHVibGljIHJlYWxCaXRyYXRlOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgdGV4dEdyb3VwSWRzPzogKHN0cmluZyB8IHVuZGVmaW5lZClbXTtcbiAgcHVibGljIHVybDogc3RyaW5nW107XG4gIHByaXZhdGUgX3VybElkOiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE6IExldmVsUGFyc2VkKSB7XG4gICAgdGhpcy51cmwgPSBbZGF0YS51cmxdO1xuICAgIHRoaXMuX2F0dHJzID0gW2RhdGEuYXR0cnNdO1xuICAgIHRoaXMuYml0cmF0ZSA9IGRhdGEuYml0cmF0ZTtcbiAgICBpZiAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICB0aGlzLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgfVxuICAgIHRoaXMuaWQgPSBkYXRhLmlkIHx8IDA7XG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgIHRoaXMud2lkdGggPSBkYXRhLndpZHRoIHx8IDA7XG4gICAgdGhpcy5oZWlnaHQgPSBkYXRhLmhlaWdodCB8fCAwO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGRhdGEuYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSBkYXRhLnZpZGVvQ29kZWM7XG4gICAgdGhpcy51bmtub3duQ29kZWNzID0gZGF0YS51bmtub3duQ29kZWNzO1xuICAgIHRoaXMuY29kZWNTZXQgPSBbZGF0YS52aWRlb0NvZGVjLCBkYXRhLmF1ZGlvQ29kZWNdXG4gICAgICAuZmlsdGVyKChjKSA9PiBjKVxuICAgICAgLmpvaW4oJywnKVxuICAgICAgLnJlcGxhY2UoL1xcLlteLixdKy9nLCAnJyk7XG4gIH1cblxuICBnZXQgbWF4Qml0cmF0ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnJlYWxCaXRyYXRlLCB0aGlzLmJpdHJhdGUpO1xuICB9XG5cbiAgZ2V0IGF0dHJzKCk6IExldmVsQXR0cmlidXRlcyB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJzW3RoaXMuX3VybElkXTtcbiAgfVxuXG4gIGdldCBwYXRod2F5SWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyc1snUEFUSFdBWS1JRCddIHx8ICcuJztcbiAgfVxuXG4gIGdldCB1cmkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy51cmxbdGhpcy5fdXJsSWRdIHx8ICcnO1xuICB9XG5cbiAgZ2V0IHVybElkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3VybElkO1xuICB9XG5cbiAgc2V0IHVybElkKHZhbHVlOiBudW1iZXIpIHtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlICUgdGhpcy51cmwubGVuZ3RoO1xuICAgIGlmICh0aGlzLl91cmxJZCAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICB0aGlzLmxvYWRFcnJvciA9IDA7XG4gICAgICB0aGlzLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl91cmxJZCA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhdWRpb0dyb3VwSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5hdWRpb0dyb3VwSWRzPy5bdGhpcy51cmxJZF07XG4gIH1cblxuICBnZXQgdGV4dEdyb3VwSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0R3JvdXBJZHM/Llt0aGlzLnVybElkXTtcbiAgfVxuXG4gIGFkZEZhbGxiYWNrKGRhdGE6IExldmVsUGFyc2VkKSB7XG4gICAgdGhpcy51cmwucHVzaChkYXRhLnVybCk7XG4gICAgdGhpcy5fYXR0cnMucHVzaChkYXRhLmF0dHJzKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBQcm92aWRlcyBtZXRob2RzIGRlYWxpbmcgd2l0aCBwbGF5bGlzdCBzbGlkaW5nIGFuZCBkcmlmdFxuICovXG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBGcmFnbWVudCwgUGFydCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwtZGV0YWlscyc7XG5pbXBvcnQgdHlwZSB7IExldmVsIH0gZnJvbSAnLi4vdHlwZXMvbGV2ZWwnO1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vbG9hZGVyL2RhdGUtcmFuZ2UnO1xuXG50eXBlIEZyYWdtZW50SW50ZXJzZWN0aW9uID0gKG9sZEZyYWc6IEZyYWdtZW50LCBuZXdGcmFnOiBGcmFnbWVudCkgPT4gdm9pZDtcbnR5cGUgUGFydEludGVyc2VjdGlvbiA9IChvbGRQYXJ0OiBQYXJ0LCBuZXdQYXJ0OiBQYXJ0KSA9PiB2b2lkO1xuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUFRTKFxuICBmcmFnbWVudHM6IEZyYWdtZW50W10sXG4gIGZyb21JZHg6IG51bWJlcixcbiAgdG9JZHg6IG51bWJlclxuKTogdm9pZCB7XG4gIGNvbnN0IGZyYWdGcm9tID0gZnJhZ21lbnRzW2Zyb21JZHhdO1xuICBjb25zdCBmcmFnVG8gPSBmcmFnbWVudHNbdG9JZHhdO1xuICB1cGRhdGVGcm9tVG9QVFMoZnJhZ0Zyb20sIGZyYWdUbyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZyb21Ub1BUUyhmcmFnRnJvbTogRnJhZ21lbnQsIGZyYWdUbzogRnJhZ21lbnQpIHtcbiAgY29uc3QgZnJhZ1RvUFRTID0gZnJhZ1RvLnN0YXJ0UFRTIGFzIG51bWJlcjtcbiAgLy8gaWYgd2Uga25vdyBzdGFydFBUU1t0b0lkeF1cbiAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnVG9QVFMpKSB7XG4gICAgLy8gdXBkYXRlIGZyYWdtZW50IGR1cmF0aW9uLlxuICAgIC8vIGl0IGhlbHBzIHRvIGZpeCBkcmlmdHMgYmV0d2VlbiBwbGF5bGlzdCByZXBvcnRlZCBkdXJhdGlvbiBhbmQgZnJhZ21lbnQgcmVhbCBkdXJhdGlvblxuICAgIGxldCBkdXJhdGlvbjogbnVtYmVyID0gMDtcbiAgICBsZXQgZnJhZzogRnJhZ21lbnQ7XG4gICAgaWYgKGZyYWdUby5zbiA+IGZyYWdGcm9tLnNuKSB7XG4gICAgICBkdXJhdGlvbiA9IGZyYWdUb1BUUyAtIGZyYWdGcm9tLnN0YXJ0O1xuICAgICAgZnJhZyA9IGZyYWdGcm9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdXJhdGlvbiA9IGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvUFRTO1xuICAgICAgZnJhZyA9IGZyYWdUbztcbiAgICB9XG4gICAgaWYgKGZyYWcuZHVyYXRpb24gIT09IGR1cmF0aW9uKSB7XG4gICAgICBmcmFnLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgfVxuICAgIC8vIHdlIGRvbnQga25vdyBzdGFydFBUU1t0b0lkeF1cbiAgfSBlbHNlIGlmIChmcmFnVG8uc24gPiBmcmFnRnJvbS5zbikge1xuICAgIGNvbnN0IGNvbnRpZ3VvdXMgPSBmcmFnRnJvbS5jYyA9PT0gZnJhZ1RvLmNjO1xuICAgIC8vIFRPRE86IFdpdGggcGFydC1sb2FkaW5nIGVuZC9kdXJhdGlvbnMgd2UgbmVlZCB0byBjb25maXJtIHRoZSB3aG9sZSBmcmFnbWVudCBpcyBsb2FkZWQgYmVmb3JlIHVzaW5nIChvciBzZXR0aW5nKSBtaW5FbmRQVFNcbiAgICBpZiAoY29udGlndW91cyAmJiBmcmFnRnJvbS5taW5FbmRQVFMpIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgKGZyYWdGcm9tLm1pbkVuZFBUUyAtIGZyYWdGcm9tLnN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgKyBmcmFnRnJvbS5kdXJhdGlvbjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZnJhZ1RvLnN0YXJ0ID0gTWF0aC5tYXgoZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG8uZHVyYXRpb24sIDApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVGcmFnUFRTRFRTKFxuICBkZXRhaWxzOiBMZXZlbERldGFpbHMgfCB1bmRlZmluZWQsXG4gIGZyYWc6IEZyYWdtZW50LFxuICBzdGFydFBUUzogbnVtYmVyLFxuICBlbmRQVFM6IG51bWJlcixcbiAgc3RhcnREVFM6IG51bWJlcixcbiAgZW5kRFRTOiBudW1iZXJcbik6IG51bWJlciB7XG4gIGNvbnN0IHBhcnNlZE1lZGlhRHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcbiAgaWYgKHBhcnNlZE1lZGlhRHVyYXRpb24gPD0gMCkge1xuICAgIGxvZ2dlci53YXJuKCdGcmFnbWVudCBzaG91bGQgaGF2ZSBhIHBvc2l0aXZlIGR1cmF0aW9uJywgZnJhZyk7XG4gICAgZW5kUFRTID0gc3RhcnRQVFMgKyBmcmFnLmR1cmF0aW9uO1xuICAgIGVuZERUUyA9IHN0YXJ0RFRTICsgZnJhZy5kdXJhdGlvbjtcbiAgfVxuICBsZXQgbWF4U3RhcnRQVFMgPSBzdGFydFBUUztcbiAgbGV0IG1pbkVuZFBUUyA9IGVuZFBUUztcbiAgY29uc3QgZnJhZ1N0YXJ0UHRzID0gZnJhZy5zdGFydFBUUyBhcyBudW1iZXI7XG4gIGNvbnN0IGZyYWdFbmRQdHMgPSBmcmFnLmVuZFBUUyBhcyBudW1iZXI7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZ1N0YXJ0UHRzKSkge1xuICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xuICAgIGNvbnN0IGRlbHRhUFRTID0gTWF0aC5hYnMoZnJhZ1N0YXJ0UHRzIC0gc3RhcnRQVFMpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYWcuZGVsdGFQVFMgYXMgbnVtYmVyKSkge1xuICAgICAgZnJhZy5kZWx0YVBUUyA9IGRlbHRhUFRTO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnLmRlbHRhUFRTID0gTWF0aC5tYXgoZGVsdGFQVFMsIGZyYWcuZGVsdGFQVFMgYXMgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBtYXhTdGFydFBUUyA9IE1hdGgubWF4KHN0YXJ0UFRTLCBmcmFnU3RhcnRQdHMpO1xuICAgIHN0YXJ0UFRTID0gTWF0aC5taW4oc3RhcnRQVFMsIGZyYWdTdGFydFB0cyk7XG4gICAgc3RhcnREVFMgPSBNYXRoLm1pbihzdGFydERUUywgZnJhZy5zdGFydERUUyk7XG5cbiAgICBtaW5FbmRQVFMgPSBNYXRoLm1pbihlbmRQVFMsIGZyYWdFbmRQdHMpO1xuICAgIGVuZFBUUyA9IE1hdGgubWF4KGVuZFBUUywgZnJhZ0VuZFB0cyk7XG4gICAgZW5kRFRTID0gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUyk7XG4gIH1cblxuICBjb25zdCBkcmlmdCA9IHN0YXJ0UFRTIC0gZnJhZy5zdGFydDtcbiAgaWYgKGZyYWcuc3RhcnQgIT09IDApIHtcbiAgICBmcmFnLnN0YXJ0ID0gc3RhcnRQVFM7XG4gIH1cbiAgZnJhZy5kdXJhdGlvbiA9IGVuZFBUUyAtIGZyYWcuc3RhcnQ7XG4gIGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcbiAgZnJhZy5tYXhTdGFydFBUUyA9IG1heFN0YXJ0UFRTO1xuICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XG4gIGZyYWcuZW5kUFRTID0gZW5kUFRTO1xuICBmcmFnLm1pbkVuZFBUUyA9IG1pbkVuZFBUUztcbiAgZnJhZy5lbmREVFMgPSBlbmREVFM7XG5cbiAgY29uc3Qgc24gPSBmcmFnLnNuIGFzIG51bWJlcjsgLy8gJ2luaXRTZWdtZW50J1xuICAvLyBleGl0IGlmIHNuIG91dCBvZiByYW5nZVxuICBpZiAoIWRldGFpbHMgfHwgc24gPCBkZXRhaWxzLnN0YXJ0U04gfHwgc24gPiBkZXRhaWxzLmVuZFNOKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IGk7XG4gIGNvbnN0IGZyYWdJZHggPSBzbiAtIGRldGFpbHMuc3RhcnRTTjtcbiAgY29uc3QgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gIC8vIHVwZGF0ZSBmcmFnIHJlZmVyZW5jZSBpbiBmcmFnbWVudHMgYXJyYXlcbiAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgZnJhZ21lbnRzIGFycmF5IG1pZ2h0IG5vdCBjb250YWluIHRoaXMgZnJhZyBvYmplY3QuXG4gIC8vIHRoaXMgd2lsbCBoYXBwZW4gaWYgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIGJldHdlZW4gZnJhZyBsb2FkaW5nIGFuZCBjYWxsIHRvIHVwZGF0ZUZyYWdQVFNEVFMoKVxuICAvLyBpZiB3ZSBkb24ndCB1cGRhdGUgZnJhZywgd2Ugd29uJ3QgYmUgYWJsZSB0byBwcm9wYWdhdGUgUFRTIGluZm8gb24gdGhlIHBsYXlsaXN0XG4gIC8vIHJlc3VsdGluZyBpbiBpbnZhbGlkIHNsaWRpbmcgY29tcHV0YXRpb25cbiAgZnJhZ21lbnRzW2ZyYWdJZHhdID0gZnJhZztcbiAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bS0xIHRvIGZyYWcgMFxuICBmb3IgKGkgPSBmcmFnSWR4OyBpID4gMDsgaS0tKSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tpXSwgZnJhZ21lbnRzW2kgLSAxXSk7XG4gIH1cblxuICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtIHRvIGxhc3QgZnJhZ1xuICBmb3IgKGkgPSBmcmFnSWR4OyBpIDwgZnJhZ21lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHVwZGF0ZUZyb21Ub1BUUyhmcmFnbWVudHNbaV0sIGZyYWdtZW50c1tpICsgMV0pO1xuICB9XG4gIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIHVwZGF0ZUZyb21Ub1BUUyhmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLCBkZXRhaWxzLmZyYWdtZW50SGludCk7XG4gIH1cblxuICBkZXRhaWxzLlBUU0tub3duID0gZGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG4gIHJldHVybiBkcmlmdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGV0YWlscyhcbiAgb2xkRGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICBuZXdEZXRhaWxzOiBMZXZlbERldGFpbHNcbik6IHZvaWQge1xuICAvLyBUcmFjayB0aGUgbGFzdCBpbml0U2VnbWVudCBwcm9jZXNzZWQuIEluaXRpYWxpemUgaXQgdG8gdGhlIGxhc3Qgb25lIG9uIHRoZSB0aW1lbGluZS5cbiAgbGV0IGN1cnJlbnRJbml0U2VnbWVudDogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgY29uc3Qgb2xkRnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHM7XG4gIGZvciAobGV0IGkgPSBvbGRGcmFnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBvbGRJbml0ID0gb2xkRnJhZ21lbnRzW2ldLmluaXRTZWdtZW50O1xuICAgIGlmIChvbGRJbml0KSB7XG4gICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBvbGRJbml0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9sZERldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgLy8gcHJldmVudCBQVFMgYW5kIGR1cmF0aW9uIGZyb20gYmVpbmcgYWRqdXN0ZWQgb24gdGhlIG5leHQgaGludFxuICAgIGRlbGV0ZSBvbGREZXRhaWxzLmZyYWdtZW50SGludC5lbmRQVFM7XG4gIH1cbiAgLy8gY2hlY2sgaWYgb2xkL25ldyBwbGF5bGlzdHMgaGF2ZSBmcmFnbWVudHMgaW4gY29tbW9uXG4gIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcbiAgbGV0IGNjT2Zmc2V0ID0gMDtcbiAgbGV0IFBUU0ZyYWc7XG4gIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKFxuICAgIG9sZERldGFpbHMsXG4gICAgbmV3RGV0YWlscyxcbiAgICAob2xkRnJhZzogRnJhZ21lbnQsIG5ld0ZyYWc6IEZyYWdtZW50KSA9PiB7XG4gICAgICBpZiAob2xkRnJhZy5yZWx1cmwpIHtcbiAgICAgICAgLy8gRG8gbm90IGNvbXBhcmUgQ0MgaWYgdGhlIG9sZCBmcmFnbWVudCBoYXMgbm8gdXJsLiBUaGlzIGlzIGEgbGV2ZWwuZnJhZ21lbnRIaW50IHVzZWQgYnkgTEwtSExTIHBhcnRzLlxuICAgICAgICAvLyBJdCBtYXliZSBiZSBvZmYgYnkgMSBpZiBpdCB3YXMgY3JlYXRlZCBiZWZvcmUgYW55IHBhcnRzIG9yIGRpc2NvbnRpbnVpdHkgdGFncyB3ZXJlIGFwcGVuZGVkIHRvIHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIHBsYXlsaXN0LlxuICAgICAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBOdW1iZXIuaXNGaW5pdGUob2xkRnJhZy5zdGFydFBUUykgJiZcbiAgICAgICAgTnVtYmVyLmlzRmluaXRlKG9sZEZyYWcuZW5kUFRTKVxuICAgICAgKSB7XG4gICAgICAgIG5ld0ZyYWcuc3RhcnQgPSBuZXdGcmFnLnN0YXJ0UFRTID0gb2xkRnJhZy5zdGFydFBUUyBhcyBudW1iZXI7XG4gICAgICAgIG5ld0ZyYWcuc3RhcnREVFMgPSBvbGRGcmFnLnN0YXJ0RFRTO1xuICAgICAgICBuZXdGcmFnLm1heFN0YXJ0UFRTID0gb2xkRnJhZy5tYXhTdGFydFBUUztcblxuICAgICAgICBuZXdGcmFnLmVuZFBUUyA9IG9sZEZyYWcuZW5kUFRTO1xuICAgICAgICBuZXdGcmFnLmVuZERUUyA9IG9sZEZyYWcuZW5kRFRTO1xuICAgICAgICBuZXdGcmFnLm1pbkVuZFBUUyA9IG9sZEZyYWcubWluRW5kUFRTO1xuICAgICAgICBuZXdGcmFnLmR1cmF0aW9uID1cbiAgICAgICAgICAob2xkRnJhZy5lbmRQVFMgYXMgbnVtYmVyKSAtIChvbGRGcmFnLnN0YXJ0UFRTIGFzIG51bWJlcik7XG5cbiAgICAgICAgaWYgKG5ld0ZyYWcuZHVyYXRpb24pIHtcbiAgICAgICAgICBQVFNGcmFnID0gbmV3RnJhZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBUUyBpcyBrbm93biB3aGVuIGFueSBzZWdtZW50IGhhcyBzdGFydFBUUyBhbmQgZW5kUFRTXG4gICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBuZXdEZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5ld0ZyYWcuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRGcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgbmV3RnJhZy5sb2FkZXIgPSBvbGRGcmFnLmxvYWRlcjtcbiAgICAgIG5ld0ZyYWcuc3RhdHMgPSBvbGRGcmFnLnN0YXRzO1xuICAgICAgbmV3RnJhZy51cmxJZCA9IG9sZEZyYWcudXJsSWQ7XG4gICAgICBpZiAob2xkRnJhZy5pbml0U2VnbWVudCkge1xuICAgICAgICBuZXdGcmFnLmluaXRTZWdtZW50ID0gb2xkRnJhZy5pbml0U2VnbWVudDtcbiAgICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gb2xkRnJhZy5pbml0U2VnbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICk7XG5cbiAgaWYgKGN1cnJlbnRJbml0U2VnbWVudCkge1xuICAgIGNvbnN0IGZyYWdtZW50c1RvQ2hlY2sgPSBuZXdEZXRhaWxzLmZyYWdtZW50SGludFxuICAgICAgPyBuZXdEZXRhaWxzLmZyYWdtZW50cy5jb25jYXQobmV3RGV0YWlscy5mcmFnbWVudEhpbnQpXG4gICAgICA6IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICAgIGZyYWdtZW50c1RvQ2hlY2suZm9yRWFjaCgoZnJhZykgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAhZnJhZy5pbml0U2VnbWVudCB8fFxuICAgICAgICBmcmFnLmluaXRTZWdtZW50LnJlbHVybCA9PT0gY3VycmVudEluaXRTZWdtZW50Py5yZWx1cmxcbiAgICAgICkge1xuICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgbmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IG5ld0RldGFpbHMuZnJhZ21lbnRzLnNvbWUoKGZyYWcpID0+ICFmcmFnKTtcbiAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICdbbGV2ZWwtaGVscGVyXSBQcmV2aW91cyBwbGF5bGlzdCBtaXNzaW5nIHNlZ21lbnRzIHNraXBwZWQgaW4gZGVsdGEgcGxheWxpc3QnXG4gICAgICApO1xuICAgICAgZm9yIChsZXQgaSA9IG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzOyBpLS07ICkge1xuICAgICAgICBuZXdEZXRhaWxzLmZyYWdtZW50cy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgbmV3RGV0YWlscy5zdGFydFNOID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc24gYXMgbnVtYmVyO1xuICAgICAgbmV3RGV0YWlscy5zdGFydENDID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uY2M7XG4gICAgfSBlbHNlIGlmIChuZXdEZXRhaWxzLmNhblNraXBEYXRlUmFuZ2VzKSB7XG4gICAgICBuZXdEZXRhaWxzLmRhdGVSYW5nZXMgPSBtZXJnZURhdGVSYW5nZXMoXG4gICAgICAgIG9sZERldGFpbHMuZGF0ZVJhbmdlcyxcbiAgICAgICAgbmV3RGV0YWlscy5kYXRlUmFuZ2VzLFxuICAgICAgICBuZXdEZXRhaWxzLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmV3RnJhZ21lbnRzID0gbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gIGlmIChjY09mZnNldCkge1xuICAgIGxvZ2dlci53YXJuKCdkaXNjb250aW51aXR5IHNsaWRpbmcgZnJvbSBwbGF5bGlzdCwgdGFrZSBkcmlmdCBpbnRvIGFjY291bnQnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0ZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3RnJhZ21lbnRzW2ldLmNjICs9IGNjT2Zmc2V0O1xuICAgIH1cbiAgfVxuICBpZiAobmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICBuZXdEZXRhaWxzLnN0YXJ0Q0MgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5jYztcbiAgfVxuXG4gIC8vIE1lcmdlIHBhcnRzXG4gIG1hcFBhcnRJbnRlcnNlY3Rpb24oXG4gICAgb2xkRGV0YWlscy5wYXJ0TGlzdCxcbiAgICBuZXdEZXRhaWxzLnBhcnRMaXN0LFxuICAgIChvbGRQYXJ0OiBQYXJ0LCBuZXdQYXJ0OiBQYXJ0KSA9PiB7XG4gICAgICBuZXdQYXJ0LmVsZW1lbnRhcnlTdHJlYW1zID0gb2xkUGFydC5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICAgIG5ld1BhcnQuc3RhdHMgPSBvbGRQYXJ0LnN0YXRzO1xuICAgIH1cbiAgKTtcblxuICAvLyBpZiBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgY29udGFpbnMgUFRTIGluZm8sIHJlY29tcHV0ZSBQVFMgaW5mb3JtYXRpb24gZm9yIGFsbCBmcmFnbWVudHNcbiAgaWYgKFBUU0ZyYWcpIHtcbiAgICB1cGRhdGVGcmFnUFRTRFRTKFxuICAgICAgbmV3RGV0YWlscyxcbiAgICAgIFBUU0ZyYWcsXG4gICAgICBQVFNGcmFnLnN0YXJ0UFRTLFxuICAgICAgUFRTRnJhZy5lbmRQVFMsXG4gICAgICBQVFNGcmFnLnN0YXJ0RFRTLFxuICAgICAgUFRTRnJhZy5lbmREVFNcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGVuc3VyZSB0aGF0IGRlbHRhIGlzIHdpdGhpbiBvbGRGcmFnbWVudHMgcmFuZ2VcbiAgICAvLyBhbHNvIGFkanVzdCBzbGlkaW5nIGluIGNhc2UgZGVsdGEgaXMgMCAod2UgY291bGQgaGF2ZSBvbGQ9WzUwLTYwXSBhbmQgbmV3PW9sZD1bNTAtNjFdKVxuICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBhbHNvIG5lZWQgdG8gYWRqdXN0IHN0YXJ0IG9mZnNldCBvZiBhbGwgZnJhZ21lbnRzXG4gICAgYWRqdXN0U2xpZGluZyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzKTtcbiAgfVxuXG4gIGlmIChuZXdGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uID0gbmV3RGV0YWlscy5lZGdlIC0gbmV3RnJhZ21lbnRzWzBdLnN0YXJ0O1xuICB9XG5cbiAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0VGltZSA9IG9sZERldGFpbHMuZHJpZnRTdGFydFRpbWU7XG4gIG5ld0RldGFpbHMuZHJpZnRTdGFydCA9IG9sZERldGFpbHMuZHJpZnRTdGFydDtcbiAgY29uc3QgYWR2YW5jZWREYXRlVGltZSA9IG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgaWYgKG5ld0RldGFpbHMuYWR2YW5jZWQgJiYgYWR2YW5jZWREYXRlVGltZSkge1xuICAgIGNvbnN0IGVkZ2UgPSBuZXdEZXRhaWxzLmVkZ2U7XG4gICAgaWYgKCFuZXdEZXRhaWxzLmRyaWZ0U3RhcnQpIHtcbiAgICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgICAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0ID0gZWRnZTtcbiAgICB9XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmQgPSBlZGdlO1xuICB9IGVsc2Uge1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmRUaW1lID0gb2xkRGV0YWlscy5kcmlmdEVuZFRpbWU7XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZCA9IG9sZERldGFpbHMuZHJpZnRFbmQ7XG4gICAgbmV3RGV0YWlscy5hZHZhbmNlZERhdGVUaW1lID0gb2xkRGV0YWlscy5hZHZhbmNlZERhdGVUaW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGF0ZVJhbmdlcyhcbiAgb2xkRGF0ZVJhbmdlczogUmVjb3JkPHN0cmluZywgRGF0ZVJhbmdlPixcbiAgZGVsdGFEYXRlUmFuZ2VzOiBSZWNvcmQ8c3RyaW5nLCBEYXRlUmFuZ2U+LFxuICByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZFxuKTogUmVjb3JkPHN0cmluZywgRGF0ZVJhbmdlPiB7XG4gIGNvbnN0IGRhdGVSYW5nZXMgPSBPYmplY3QuYXNzaWduKHt9LCBvbGREYXRlUmFuZ2VzKTtcbiAgaWYgKHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMpIHtcbiAgICByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICBkZWxldGUgZGF0ZVJhbmdlc1tpZF07XG4gICAgfSk7XG4gIH1cbiAgT2JqZWN0LmtleXMoZGVsdGFEYXRlUmFuZ2VzKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgIGNvbnN0IGRhdGVSYW5nZSA9IG5ldyBEYXRlUmFuZ2UoZGVsdGFEYXRlUmFuZ2VzW2lkXS5hdHRyLCBkYXRlUmFuZ2VzW2lkXSk7XG4gICAgaWYgKGRhdGVSYW5nZS5pc1ZhbGlkKSB7XG4gICAgICBkYXRlUmFuZ2VzW2lkXSA9IGRhdGVSYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgIGBJZ25vcmluZyBpbnZhbGlkIFBsYXlsaXN0IERlbHRhIFVwZGF0ZSBEQVRFUkFOR0UgdGFnOiBcIiR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgZGVsdGFEYXRlUmFuZ2VzW2lkXS5hdHRyXG4gICAgICAgICl9XCJgXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRlUmFuZ2VzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwUGFydEludGVyc2VjdGlvbihcbiAgb2xkUGFydHM6IFBhcnRbXSB8IG51bGwsXG4gIG5ld1BhcnRzOiBQYXJ0W10gfCBudWxsLFxuICBpbnRlcnNlY3Rpb25GbjogUGFydEludGVyc2VjdGlvblxuKSB7XG4gIGlmIChvbGRQYXJ0cyAmJiBuZXdQYXJ0cykge1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9sZFBhcnRzLmxlbmd0aDsgaSA8PSBsZW47IGkrKykge1xuICAgICAgY29uc3Qgb2xkUGFydCA9IG9sZFBhcnRzW2ldO1xuICAgICAgY29uc3QgbmV3UGFydCA9IG5ld1BhcnRzW2kgKyBkZWx0YV07XG4gICAgICBpZiAoXG4gICAgICAgIG9sZFBhcnQgJiZcbiAgICAgICAgbmV3UGFydCAmJlxuICAgICAgICBvbGRQYXJ0LmluZGV4ID09PSBuZXdQYXJ0LmluZGV4ICYmXG4gICAgICAgIG9sZFBhcnQuZnJhZ21lbnQuc24gPT09IG5ld1BhcnQuZnJhZ21lbnQuc25cbiAgICAgICkge1xuICAgICAgICBpbnRlcnNlY3Rpb25GbihvbGRQYXJ0LCBuZXdQYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhLS07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBGcmFnbWVudEludGVyc2VjdGlvbihcbiAgb2xkRGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICBuZXdEZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIGludGVyc2VjdGlvbkZuOiBGcmFnbWVudEludGVyc2VjdGlvblxuKTogdm9pZCB7XG4gIGNvbnN0IHNraXBwZWRTZWdtZW50cyA9IG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzO1xuICBjb25zdCBzdGFydCA9XG4gICAgTWF0aC5tYXgob2xkRGV0YWlscy5zdGFydFNOLCBuZXdEZXRhaWxzLnN0YXJ0U04pIC0gbmV3RGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBlbmQgPVxuICAgIChvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IDEgOiAwKSArXG4gICAgKHNraXBwZWRTZWdtZW50c1xuICAgICAgPyBuZXdEZXRhaWxzLmVuZFNOXG4gICAgICA6IE1hdGgubWluKG9sZERldGFpbHMuZW5kU04sIG5ld0RldGFpbHMuZW5kU04pKSAtXG4gICAgbmV3RGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiAtIG9sZERldGFpbHMuc3RhcnRTTjtcbiAgY29uc3QgbmV3RnJhZ3MgPSBuZXdEZXRhaWxzLmZyYWdtZW50SGludFxuICAgID8gbmV3RGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG5ld0RldGFpbHMuZnJhZ21lbnRIaW50KVxuICAgIDogbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gIGNvbnN0IG9sZEZyYWdzID0gb2xkRGV0YWlscy5mcmFnbWVudEhpbnRcbiAgICA/IG9sZERldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChvbGREZXRhaWxzLmZyYWdtZW50SGludClcbiAgICA6IG9sZERldGFpbHMuZnJhZ21lbnRzO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgIGNvbnN0IG9sZEZyYWcgPSBvbGRGcmFnc1tkZWx0YSArIGldO1xuICAgIGxldCBuZXdGcmFnID0gbmV3RnJhZ3NbaV07XG4gICAgaWYgKHNraXBwZWRTZWdtZW50cyAmJiAhbmV3RnJhZyAmJiBpIDwgc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgICAvLyBGaWxsIGluIHNraXBwZWQgc2VnbWVudHMgaW4gZGVsdGEgcGxheWxpc3RcbiAgICAgIG5ld0ZyYWcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1tpXSA9IG9sZEZyYWc7XG4gICAgfVxuICAgIGlmIChvbGRGcmFnICYmIG5ld0ZyYWcpIHtcbiAgICAgIGludGVyc2VjdGlvbkZuKG9sZEZyYWcsIG5ld0ZyYWcpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0U2xpZGluZyhcbiAgb2xkRGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICBuZXdEZXRhaWxzOiBMZXZlbERldGFpbHNcbik6IHZvaWQge1xuICBjb25zdCBkZWx0YSA9XG4gICAgbmV3RGV0YWlscy5zdGFydFNOICsgbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMgLSBvbGREZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IG9sZEZyYWdtZW50cyA9IG9sZERldGFpbHMuZnJhZ21lbnRzO1xuICBpZiAoZGVsdGEgPCAwIHx8IGRlbHRhID49IG9sZEZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWRkU2xpZGluZyhuZXdEZXRhaWxzLCBvbGRGcmFnbWVudHNbZGVsdGFdLnN0YXJ0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFNsaWRpbmcoZGV0YWlsczogTGV2ZWxEZXRhaWxzLCBzdGFydDogbnVtYmVyKSB7XG4gIGlmIChzdGFydCkge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgIGZvciAobGV0IGkgPSBkZXRhaWxzLnNraXBwZWRTZWdtZW50czsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZnJhZ21lbnRzW2ldLnN0YXJ0ICs9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgIGRldGFpbHMuZnJhZ21lbnRIaW50LnN0YXJ0ICs9IHN0YXJ0O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVJlbG9hZEludGVydmFsKFxuICBuZXdEZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIGRpc3RhbmNlVG9MaXZlRWRnZU1zOiBudW1iZXIgPSBJbmZpbml0eVxuKTogbnVtYmVyIHtcbiAgbGV0IHJlbG9hZEludGVydmFsID0gMTAwMCAqIG5ld0RldGFpbHMudGFyZ2V0ZHVyYXRpb247XG5cbiAgaWYgKG5ld0RldGFpbHMudXBkYXRlZCkge1xuICAgIC8vIFVzZSBsYXN0IHNlZ21lbnQgZHVyYXRpb24gd2hlbiBzaG9ydGVyIHRoYW4gdGFyZ2V0IGR1cmF0aW9uIGFuZCBuZWFyIGxpdmUgZWRnZVxuICAgIGNvbnN0IGZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICAgIGNvbnN0IGxpdmVFZGdlTWF4VGFyZ2V0RHVyYXRpb25zID0gNDtcbiAgICBpZiAoXG4gICAgICBmcmFnbWVudHMubGVuZ3RoICYmXG4gICAgICByZWxvYWRJbnRlcnZhbCAqIGxpdmVFZGdlTWF4VGFyZ2V0RHVyYXRpb25zID4gZGlzdGFuY2VUb0xpdmVFZGdlTXNcbiAgICApIHtcbiAgICAgIGNvbnN0IGxhc3RTZWdtZW50RHVyYXRpb24gPVxuICAgICAgICBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLmR1cmF0aW9uICogMTAwMDtcbiAgICAgIGlmIChsYXN0U2VnbWVudER1cmF0aW9uIDwgcmVsb2FkSW50ZXJ2YWwpIHtcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgPSBsYXN0U2VnbWVudER1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBlc3RpbWF0ZSA9ICdtaXNzIGhhbGYgYXZlcmFnZSc7XG4gICAgLy8gZm9sbG93IEhMUyBTcGVjLCBJZiB0aGUgY2xpZW50IHJlbG9hZHMgYSBQbGF5bGlzdCBmaWxlIGFuZCBmaW5kcyB0aGF0IGl0IGhhcyBub3RcbiAgICAvLyBjaGFuZ2VkIHRoZW4gaXQgTVVTVCB3YWl0IGZvciBhIHBlcmlvZCBvZiBvbmUtaGFsZiB0aGUgdGFyZ2V0XG4gICAgLy8gZHVyYXRpb24gYmVmb3JlIHJldHJ5aW5nLlxuICAgIHJlbG9hZEludGVydmFsIC89IDI7XG4gIH1cblxuICByZXR1cm4gTWF0aC5yb3VuZChyZWxvYWRJbnRlcnZhbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFdpdGhTTihcbiAgbGV2ZWw6IExldmVsLFxuICBzbjogbnVtYmVyLFxuICBmcmFnQ3VycmVudDogRnJhZ21lbnQgfCBudWxsXG4pOiBGcmFnbWVudCB8IG51bGwge1xuICBpZiAoIWxldmVsPy5kZXRhaWxzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgbGV0IGZyYWdtZW50OiBGcmFnbWVudCB8IHVuZGVmaW5lZCA9XG4gICAgbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tzbiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTtcbiAgaWYgKGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG4gIGZyYWdtZW50ID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50SGludDtcbiAgaWYgKGZyYWdtZW50ICYmIGZyYWdtZW50LnNuID09PSBzbikge1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBpZiAoc24gPCBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiBmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5zbiA9PT0gc24pIHtcbiAgICByZXR1cm4gZnJhZ0N1cnJlbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJ0V2l0aChcbiAgbGV2ZWw6IExldmVsLFxuICBzbjogbnVtYmVyLFxuICBwYXJ0SW5kZXg6IG51bWJlclxuKTogUGFydCB8IG51bGwge1xuICBpZiAoIWxldmVsPy5kZXRhaWxzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGZpbmRQYXJ0KGxldmVsLmRldGFpbHM/LnBhcnRMaXN0LCBzbiwgcGFydEluZGV4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQYXJ0KFxuICBwYXJ0TGlzdDogUGFydFtdIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgc246IG51bWJlcixcbiAgcGFydEluZGV4OiBudW1iZXJcbik6IFBhcnQgfCBudWxsIHtcbiAgaWYgKHBhcnRMaXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IHBhcnRMaXN0Lmxlbmd0aDsgaS0tOyApIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0TGlzdFtpXTtcbiAgICAgIGlmIChwYXJ0LmluZGV4ID09PSBwYXJ0SW5kZXggJiYgcGFydC5mcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IHsgTG9hZFBvbGljeSwgTG9hZGVyQ29uZmlnLCBSZXRyeUNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgRXJyb3JEYXRhIH0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVGltZW91dEVycm9yKGVycm9yOiBFcnJvckRhdGEpOiBib29sZWFuIHtcbiAgc3dpdGNoIChlcnJvci5kZXRhaWxzKSB7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmV0cnlDb25maWcoXG4gIGxvYWRQb2xpY3k6IExvYWRQb2xpY3ksXG4gIGVycm9yOiBFcnJvckRhdGFcbik6IFJldHJ5Q29uZmlnIHwgbnVsbCB7XG4gIGNvbnN0IGlzVGltZW91dCA9IGlzVGltZW91dEVycm9yKGVycm9yKTtcbiAgcmV0dXJuIGxvYWRQb2xpY3kuZGVmYXVsdFtgJHtpc1RpbWVvdXQgPyAndGltZW91dCcgOiAnZXJyb3InfVJldHJ5YF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXRyeURlbGF5KFxuICByZXRyeUNvbmZpZzogUmV0cnlDb25maWcsXG4gIHJldHJ5Q291bnQ6IG51bWJlclxuKTogbnVtYmVyIHtcbiAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gbWF4IHJldHJ5IGRlbGF5XG4gIGNvbnN0IGJhY2tvZmZGYWN0b3IgPVxuICAgIHJldHJ5Q29uZmlnLmJhY2tvZmYgPT09ICdsaW5lYXInID8gMSA6IE1hdGgucG93KDIsIHJldHJ5Q291bnQpO1xuICByZXR1cm4gTWF0aC5taW4oXG4gICAgYmFja29mZkZhY3RvciAqIHJldHJ5Q29uZmlnLnJldHJ5RGVsYXlNcyxcbiAgICByZXRyeUNvbmZpZy5tYXhSZXRyeURlbGF5TXNcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMoXG4gIGxvZGVyQ29uZmlnOiBMb2FkZXJDb25maWdcbik6IExvYWRlckNvbmZpZyB7XG4gIHJldHVybiB7XG4gICAgLi4ubG9kZXJDb25maWcsXG4gICAgLi4ue1xuICAgICAgZXJyb3JSZXRyeTogbnVsbCxcbiAgICAgIHRpbWVvdXRSZXRyeTogbnVsbCxcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkUmV0cnkoXG4gIHJldHJ5Q29uZmlnOiBSZXRyeUNvbmZpZyB8IG51bGwgfCB1bmRlZmluZWQsXG4gIHJldHJ5Q291bnQ6IG51bWJlcixcbiAgaXNUaW1lb3V0OiBib29sZWFuLFxuICBodHRwU3RhdHVzPzogbnVtYmVyIHwgdW5kZWZpbmVkXG4pOiByZXRyeUNvbmZpZyBpcyBSZXRyeUNvbmZpZyAmIGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgICEhcmV0cnlDb25maWcgJiZcbiAgICByZXRyeUNvdW50IDwgcmV0cnlDb25maWcubWF4TnVtUmV0cnkgJiZcbiAgICAocmV0cnlGb3JIdHRwU3RhdHVzKGh0dHBTdGF0dXMpIHx8ICEhaXNUaW1lb3V0KVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV0cnlGb3JIdHRwU3RhdHVzKGh0dHBTdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCkge1xuICAvLyBEbyBub3QgcmV0cnkgb24gc3RhdHVzIDR4eCwgc3RhdHVzIDAgKENPUlMgZXJyb3IpLCBvciB1bmRlZmluZWQgKGRlY3J5cHQvZ2FwL3BhcnNlIGVycm9yKVxuICByZXR1cm4gKFxuICAgIChodHRwU3RhdHVzID09PSAwICYmIG5hdmlnYXRvci5vbkxpbmUgPT09IGZhbHNlKSB8fFxuICAgICghIWh0dHBTdGF0dXMgJiYgKGh0dHBTdGF0dXMgPCA0MDAgfHwgaHR0cFN0YXR1cyA+IDQ5OSkpXG4gICk7XG59XG4iLCJ0eXBlIEJpbmFyeVNlYXJjaENvbXBhcmlzb248VD4gPSAoY2FuZGlkYXRlOiBUKSA9PiAtMSB8IDAgfCAxO1xuXG5jb25zdCBCaW5hcnlTZWFyY2ggPSB7XG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXG4gICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcbiAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIGxpc3QgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIGNvbXBhcmlzb25GblxuICAgKiAgICAgIENhbGxlZCBhbmQgcHJvdmlkZWQgYSBjYW5kaWRhdGUgaXRlbSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAqICAgICAgU2hvdWxkIHJldHVybjpcbiAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAqICAgICAgICAgID4gMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGhpZ2hlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgKiAgICAgICAgICA+IDAgaWYgdGhlIGl0ZW0gaXMgdGhlIGl0ZW0geW91J3JlIGxvb2tpbmcgZm9yLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgb2JqZWN0IGlmIGZvdW5kLCBvdGhlcndpc2UgcmV0dXJucyBudWxsXG4gICAqL1xuICBzZWFyY2g6IGZ1bmN0aW9uIDxUPihcbiAgICBsaXN0OiBUW10sXG4gICAgY29tcGFyaXNvbkZuOiBCaW5hcnlTZWFyY2hDb21wYXJpc29uPFQ+XG4gICk6IFQgfCBudWxsIHtcbiAgICBsZXQgbWluSW5kZXg6IG51bWJlciA9IDA7XG4gICAgbGV0IG1heEluZGV4OiBudW1iZXIgPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgbGV0IGN1cnJlbnRJbmRleDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRFbGVtZW50OiBUIHwgbnVsbCA9IG51bGw7XG5cbiAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgIGN1cnJlbnRJbmRleCA9ICgobWluSW5kZXggKyBtYXhJbmRleCkgLyAyKSB8IDA7XG4gICAgICBjdXJyZW50RWxlbWVudCA9IGxpc3RbY3VycmVudEluZGV4XTtcblxuICAgICAgY29uc3QgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GbihjdXJyZW50RWxlbWVudCk7XG4gICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcbiAgICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgfSBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCaW5hcnlTZWFyY2g7XG4iLCJpbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4uL3V0aWxzL2JpbmFyeS1zZWFyY2gnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuXG4vKipcbiAqIFJldHVybnMgZmlyc3QgZnJhZ21lbnQgd2hvc2UgZW5kUGR0IHZhbHVlIGV4Y2VlZHMgdGhlIGdpdmVuIFBEVCwgb3IgbnVsbC5cbiAqIEBwYXJhbSBmcmFnbWVudHMgLSBUaGUgYXJyYXkgb2YgY2FuZGlkYXRlIGZyYWdtZW50c1xuICogQHBhcmFtIFBEVFZhbHVlIC0gVGhlIFBEVCB2YWx1ZSB3aGljaCBtdXN0IGJlIGV4Y2VlZGVkXG4gKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydC9lbmQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGcmFnbWVudEJ5UERUKFxuICBmcmFnbWVudHM6IEFycmF5PEZyYWdtZW50PixcbiAgUERUVmFsdWU6IG51bWJlciB8IG51bGwsXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IG51bWJlclxuKTogRnJhZ21lbnQgfCBudWxsIHtcbiAgaWYgKFxuICAgIFBEVFZhbHVlID09PSBudWxsIHx8XG4gICAgIUFycmF5LmlzQXJyYXkoZnJhZ21lbnRzKSB8fFxuICAgICFmcmFnbWVudHMubGVuZ3RoIHx8XG4gICAgIU51bWJlci5pc0Zpbml0ZShQRFRWYWx1ZSlcbiAgKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBpZiBsZXNzIHRoYW4gc3RhcnRcbiAgY29uc3Qgc3RhcnRQRFQgPSBmcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lO1xuICBpZiAoUERUVmFsdWUgPCAoc3RhcnRQRFQgfHwgMCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGVuZFBEVCA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kUHJvZ3JhbURhdGVUaW1lO1xuICBpZiAoUERUVmFsdWUgPj0gKGVuZFBEVCB8fCAwKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgfHwgMDtcbiAgZm9yIChsZXQgc2VnID0gMDsgc2VnIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytzZWcpIHtcbiAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRzW3NlZ107XG4gICAgaWYgKHBkdFdpdGhpblRvbGVyYW5jZVRlc3QoUERUVmFsdWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWcpKSB7XG4gICAgICByZXR1cm4gZnJhZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kcyBhIGZyYWdtZW50IGJhc2VkIG9uIHRoZSBTTiBvZiB0aGUgcHJldmlvdXMgZnJhZ21lbnQ7IG9yIGJhc2VkIG9uIHRoZSBuZWVkcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gKiBUaGlzIG1ldGhvZCBjb21wZW5zYXRlcyBmb3Igc21hbGwgYnVmZmVyIGdhcHMgYnkgYXBwbHlpbmcgYSB0b2xlcmFuY2UgdG8gdGhlIHN0YXJ0IG9mIGFueSBjYW5kaWRhdGUgZnJhZ21lbnQsIHRodXNcbiAqIGJyZWFraW5nIGFueSB0cmFwcyB3aGljaCB3b3VsZCBjYXVzZSB0aGUgc2FtZSBmcmFnbWVudCB0byBiZSBjb250aW51b3VzbHkgc2VsZWN0ZWQgd2l0aGluIGEgc21hbGwgcmFuZ2UuXG4gKiBAcGFyYW0gZnJhZ1ByZXZpb3VzIC0gVGhlIGxhc3QgZnJhZyBzdWNjZXNzZnVsbHkgYXBwZW5kZWRcbiAqIEBwYXJhbSBmcmFnbWVudHMgLSBUaGUgYXJyYXkgb2YgY2FuZGlkYXRlIGZyYWdtZW50c1xuICogQHBhcmFtIGJ1ZmZlckVuZCAtIFRoZSBlbmQgb2YgdGhlIGNvbnRpZ3VvdXMgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgYSBtYXRjaGluZyBmcmFnbWVudCBvciBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBUUyhcbiAgZnJhZ1ByZXZpb3VzOiBGcmFnbWVudCB8IG51bGwsXG4gIGZyYWdtZW50czogQXJyYXk8RnJhZ21lbnQ+LFxuICBidWZmZXJFbmQ6IG51bWJlciA9IDAsXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IG51bWJlciA9IDBcbik6IEZyYWdtZW50IHwgbnVsbCB7XG4gIGxldCBmcmFnTmV4dDogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgIGZyYWdOZXh0ID1cbiAgICAgIGZyYWdtZW50c1tcbiAgICAgICAgKGZyYWdQcmV2aW91cy5zbiBhcyBudW1iZXIpIC0gKGZyYWdtZW50c1swXS5zbiBhcyBudW1iZXIpICsgMVxuICAgICAgXSB8fCBudWxsO1xuICB9IGVsc2UgaWYgKGJ1ZmZlckVuZCA9PT0gMCAmJiBmcmFnbWVudHNbMF0uc3RhcnQgPT09IDApIHtcbiAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1swXTtcbiAgfVxuICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gIGlmIChcbiAgICBmcmFnTmV4dCAmJlxuICAgIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdOZXh0KSA9PT1cbiAgICAgIDBcbiAgKSB7XG4gICAgcmV0dXJuIGZyYWdOZXh0O1xuICB9XG4gIC8vIFdlIG1pZ2h0IGJlIHNlZWtpbmcgcGFzdCB0aGUgdG9sZXJhbmNlIHNvIGZpbmQgdGhlIGJlc3QgbWF0Y2hcbiAgY29uc3QgZm91bmRGcmFnbWVudCA9IEJpbmFyeVNlYXJjaC5zZWFyY2goXG4gICAgZnJhZ21lbnRzLFxuICAgIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdC5iaW5kKG51bGwsIGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSlcbiAgKTtcbiAgaWYgKGZvdW5kRnJhZ21lbnQgJiYgKGZvdW5kRnJhZ21lbnQgIT09IGZyYWdQcmV2aW91cyB8fCAhZnJhZ05leHQpKSB7XG4gICAgcmV0dXJuIGZvdW5kRnJhZ21lbnQ7XG4gIH1cbiAgLy8gSWYgbm8gbWF0Y2ggd2FzIGZvdW5kIHJldHVybiB0aGUgbmV4dCBmcmFnbWVudCBhZnRlciBmcmFnUHJldmlvdXMsIG9yIG51bGxcbiAgcmV0dXJuIGZyYWdOZXh0O1xufVxuXG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5U24ncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBAcGFyYW0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSBidWZmZXJFbmQgLSBUaGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXG4gKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgMCBpZiBpdCBtYXRjaGVzLCAxIGlmIHRvbyBsb3csIC0xIGlmIHRvbyBoaWdoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoXG4gIGJ1ZmZlckVuZCA9IDAsXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwLFxuICBjYW5kaWRhdGU6IEZyYWdtZW50XG4pIHtcbiAgLy8gZWFnZXJseSBhY2NlcHQgYW4gYWNjdXJhdGUgbWF0Y2ggKG5vIHRvbGVyYW5jZSlcbiAgaWYgKFxuICAgIGNhbmRpZGF0ZS5zdGFydCA8PSBidWZmZXJFbmQgJiZcbiAgICBjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gPiBidWZmZXJFbmRcbiAgKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAvLyBsb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICBjb25zdCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihcbiAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLFxuICAgIGNhbmRpZGF0ZS5kdXJhdGlvbiArIChjYW5kaWRhdGUuZGVsdGFQVFMgPyBjYW5kaWRhdGUuZGVsdGFQVFMgOiAwKVxuICApO1xuICBpZiAoXG4gICAgY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIDw9XG4gICAgYnVmZmVyRW5kXG4gICkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKFxuICAgIGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJlxuICAgIGNhbmRpZGF0ZS5zdGFydFxuICApIHtcbiAgICAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5UGR0J3MgQmluYXJ5U2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBiZXN0IG1hdGNoIHRvIHRoZSBjdXJyZW50IGJ1ZmZlciBjb25kaXRpb25zLlxuICogVGhpcyBmdW5jdGlvbiB0ZXN0cyB0aGUgY2FuZGlkYXRlJ3MgcHJvZ3JhbSBkYXRlIHRpbWUgdmFsdWVzLCBhcyByZXByZXNlbnRlZCBpbiBVbml4IHRpbWVcbiAqIEBwYXJhbSBjYW5kaWRhdGUgLSBUaGUgZnJhZ21lbnQgdG8gdGVzdFxuICogQHBhcmFtIHBkdEJ1ZmZlckVuZCAtIFRoZSBVbml4IHRpbWUgcmVwcmVzZW50aW5nIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2VcbiAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0IGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyB0cnVlIGlmIGNvbnRpZ3VvdXMsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGR0V2l0aGluVG9sZXJhbmNlVGVzdChcbiAgcGR0QnVmZmVyRW5kOiBudW1iZXIsXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IG51bWJlcixcbiAgY2FuZGlkYXRlOiBGcmFnbWVudFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9XG4gICAgTWF0aC5taW4oXG4gICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLFxuICAgICAgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApXG4gICAgKSAqIDEwMDA7XG5cbiAgLy8gZW5kUHJvZ3JhbURhdGVUaW1lIGNhbiBiZSBudWxsLCBkZWZhdWx0IHRvIHplcm9cbiAgY29uc3QgZW5kUHJvZ3JhbURhdGVUaW1lID0gY2FuZGlkYXRlLmVuZFByb2dyYW1EYXRlVGltZSB8fCAwO1xuICByZXR1cm4gZW5kUHJvZ3JhbURhdGVUaW1lIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gcGR0QnVmZmVyRW5kO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEZyYWdXaXRoQ0MoXG4gIGZyYWdtZW50czogRnJhZ21lbnRbXSxcbiAgY2M6IG51bWJlclxuKTogRnJhZ21lbnQgfCBudWxsIHtcbiAgcmV0dXJuIEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCAoY2FuZGlkYXRlKSA9PiB7XG4gICAgaWYgKGNhbmRpZGF0ZS5jYyA8IGNjKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5jYyA+IGNjKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXJyb3JEZXRhaWxzLCBFcnJvclR5cGVzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IFBsYXlsaXN0Q29udGV4dFR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7XG4gIGdldFJldHJ5Q29uZmlnLFxuICBpc1RpbWVvdXRFcnJvcixcbiAgc2hvdWxkUmV0cnksXG59IGZyb20gJy4uL3V0aWxzL2Vycm9yLWhlbHBlcic7XG5pbXBvcnQgeyBmaW5kRnJhZ21lbnRCeVBUUyB9IGZyb20gJy4vZnJhZ21lbnQtZmluZGVycyc7XG5pbXBvcnQgeyBIZGNwTGV2ZWwsIEhkY3BMZXZlbHMsIHR5cGUgTGV2ZWwgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5pbXBvcnQgdHlwZSB7IFJldHJ5Q29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB0eXBlIHsgTmV0d29ya0NvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUgeyBFcnJvckRhdGEgfSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IExldmVsRGV0YWlscyB9IGZyb20gJy4uL2hscyc7XG5cbmNvbnN0IFJFTkRJVElPTl9QRU5BTFRZX0RVUkFUSU9OX01TID0gMzAwMDAwO1xuXG5leHBvcnQgY29uc3QgZW51bSBOZXR3b3JrRXJyb3JBY3Rpb24ge1xuICBEb05vdGhpbmcgPSAwLFxuICBTZW5kRW5kQ2FsbGJhY2sgPSAxLCAvLyBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZVxuICBTZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94ID0gMixcbiAgUmVtb3ZlQWx0ZXJuYXRlUGVybWFuZW50bHkgPSAzLCAvLyBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZVxuICBJbnNlcnREaXNjb250aW51aXR5ID0gNCwgLy8gUmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2VcbiAgUmV0cnlSZXF1ZXN0ID0gNSxcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gRXJyb3JBY3Rpb25GbGFncyB7XG4gIE5vbmUgPSAwLFxuICBNb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdCA9IDEsXG4gIE1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIRENQID0gMSA8PCAxLFxuICBTd2l0Y2hUb1NEUiA9IDEgPDwgMiwgLy8gUmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2Vcbn1cblxuZXhwb3J0IHR5cGUgSUVycm9yQWN0aW9uID0ge1xuICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbjtcbiAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3M7XG4gIHJldHJ5Q291bnQ/OiBudW1iZXI7XG4gIHJldHJ5Q29uZmlnPzogUmV0cnlDb25maWc7XG4gIGhkY3BMZXZlbD86IEhkY3BMZXZlbDtcbiAgbmV4dEF1dG9MZXZlbD86IG51bWJlcjtcbiAgcmVzb2x2ZWQ/OiBib29sZWFuO1xufTtcblxudHlwZSBQZW5hbGl6ZWRSZW5kaXRpb24gPSB7XG4gIGxhc3RFcnJvclBlcmZNczogbnVtYmVyO1xuICBlcnJvcnM6IEVycm9yRGF0YVtdO1xuICBkZXRhaWxzPzogTGV2ZWxEZXRhaWxzO1xufTtcblxudHlwZSBQZW5hbGl6ZWRSZW5kaXRpb25zID0geyBba2V5OiBudW1iZXJdOiBQZW5hbGl6ZWRSZW5kaXRpb24gfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JDb250cm9sbGVyIGltcGxlbWVudHMgTmV0d29ya0NvbXBvbmVudEFQSSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgaGxzOiBIbHM7XG4gIHByaXZhdGUgcGxheWxpc3RFcnJvcjogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBwZW5hbGl6ZWRSZW5kaXRpb25zOiBQZW5hbGl6ZWRSZW5kaXRpb25zID0ge307XG4gIHByaXZhdGUgbG9nOiAobXNnOiBhbnkpID0+IHZvaWQ7XG4gIHByaXZhdGUgd2FybjogKG1zZzogYW55KSA9PiB2b2lkO1xuICBwcml2YXRlIGVycm9yOiAobXNnOiBhbnkpID0+IHZvaWQ7XG5cbiAgY29uc3RydWN0b3IoaGxzOiBIbHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIGBbaW5mb106YCk7XG4gICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChsb2dnZXIsIGBbd2FybmluZ106YCk7XG4gICAgdGhpcy5lcnJvciA9IGxvZ2dlci5lcnJvci5iaW5kKGxvZ2dlciwgYFtlcnJvcl06YCk7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yT3V0LCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICB0aGlzLnBlbmFsaXplZFJlbmRpdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICB9XG5cbiAgc3RvcExvYWQoKTogdm9pZCB7fVxuXG4gIHByaXZhdGUgZ2V0VmFyaWFudExldmVsSW5kZXgoZnJhZzogRnJhZ21lbnQgfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICAgIHJldHVybiBmcmFnPy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOXG4gICAgICA/IGZyYWcubGV2ZWxcbiAgICAgIDogdGhpcy5obHMubG9hZExldmVsO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgIHRoaXMucGVuYWxpemVkUmVuZGl0aW9ucyA9IHt9O1xuICB9XG5cbiAgcHJpdmF0ZSBvbkxldmVsVXBkYXRlZCgpIHtcbiAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkVycm9yKGV2ZW50OiBFdmVudHMuRVJST1IsIGRhdGE6IEVycm9yRGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IGNvbnRleHQgPSBkYXRhLmNvbnRleHQ7XG5cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0dBUDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjoge1xuICAgICAgICAvLyBTd2l0Y2ggbGV2ZWwgaWYgcG9zc2libGUsIG90aGVyd2lzZSBhbGxvdyByZXRyeSBjb3VudCB0byByZWFjaCBtYXggZXJyb3IgcmV0cmllc1xuICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRGcmFnUmV0cnlPclN3aXRjaEFjdGlvbihkYXRhKTtcbiAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5hY3Rpb24gPSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfRU1QVFlfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gT25seSByZXRyeSB3aGVuIGVtcHR5IGFuZCBsaXZlXG4gICAgICAgICAgY29uc3QgbGV2ZWxJbmRleCA9XG4gICAgICAgICAgICBkYXRhLnBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTlxuICAgICAgICAgICAgICA/IChkYXRhLmxldmVsIGFzIG51bWJlcilcbiAgICAgICAgICAgICAgOiBobHMubG9hZExldmVsO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SICYmXG4gICAgICAgICAgICAhIWRhdGEuY29udGV4dD8ubGV2ZWxEZXRhaWxzPy5saXZlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oXG4gICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgIGxldmVsSW5kZXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVzY2FsYXRlIHRvIGZhdGFsIGlmIG5vdCByZXRyeWluZyBvciBzd2l0Y2hpbmdcbiAgICAgICAgICAgIGRhdGEubGV2ZWxSZXRyeSA9IGZhbHNlO1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dD8ubGV2ZWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uKFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGNvbnRleHQubGV2ZWxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5TVUJUSVRMRV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGNvbnN0IGxldmVsID0gaGxzLmxldmVsc1tobHMubG9hZExldmVsXTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBsZXZlbCAmJlxuICAgICAgICAgICAgKChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiZcbiAgICAgICAgICAgICAgY29udGV4dC5ncm91cElkID09PSBsZXZlbC5hdWRpb0dyb3VwSWQpIHx8XG4gICAgICAgICAgICAgIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiZcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdyb3VwSWQgPT09IGxldmVsLnRleHRHcm91cElkKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gUGF0aHdheSBzd2l0Y2ggb3IgUmVkdW5kYW50IGZhaWxvdmVyIGlmIHBvc3NpYmxlIGZvciBmYXN0ZXN0IHJlY292ZXJ5XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYWxsb3cgcGxheWxpc3QgcmV0cnkgY291bnQgdG8gcmVhY2ggbWF4IGVycm9yIHJldHJpZXNcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgaGxzLmxvYWRMZXZlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24uYWN0aW9uID1cbiAgICAgICAgICAgICAgTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uLmZsYWdzID1cbiAgICAgICAgICAgICAgRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURUQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IGhscy5sZXZlbHNbaGxzLmxvYWRMZXZlbF07XG4gICAgICAgICAgY29uc3QgcmVzdHJpY3RlZEhkY3BMZXZlbCA9IGxldmVsPy5hdHRyc1snSERDUC1MRVZFTCddO1xuICAgICAgICAgIGlmIChyZXN0cmljdGVkSGRjcExldmVsKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUCxcbiAgICAgICAgICAgICAgaGRjcExldmVsOiByZXN0cmljdGVkSGRjcExldmVsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SOlxuICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGRhdGEubGV2ZWwgPz8gaGxzLmxvYWRMZXZlbFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT046XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfU1dJVENIX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEU6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEw6XG4gICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB7XG4gICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uRG9Ob3RoaW5nLFxuICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS50eXBlID09PSBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IpIHtcbiAgICAgIGNvbnN0IGxldmVsSW5kZXggPSB0aGlzLmdldFZhcmlhbnRMZXZlbEluZGV4KGRhdGEuZnJhZyk7XG4gICAgICAvLyBEbyBub3QgcmV0cnkgbGV2ZWwuIEVzY2FsYXRlIHRvIGZhdGFsIGlmIHN3aXRjaGluZyBsZXZlbHMgZmFpbHMuXG4gICAgICBkYXRhLmxldmVsUmV0cnkgPSBmYWxzZTtcbiAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uKFxuICAgIGRhdGE6IEVycm9yRGF0YSxcbiAgICBsZXZlbEluZGV4OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkXG4gICk6IElFcnJvckFjdGlvbiB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgcmV0cnlDb25maWcgPSBnZXRSZXRyeUNvbmZpZyhobHMuY29uZmlnLnBsYXlsaXN0TG9hZFBvbGljeSwgZGF0YSk7XG4gICAgY29uc3QgcmV0cnlDb3VudCA9IHRoaXMucGxheWxpc3RFcnJvcisrO1xuICAgIGNvbnN0IGh0dHBTdGF0dXMgPSBkYXRhLnJlc3BvbnNlPy5jb2RlO1xuICAgIGNvbnN0IHJldHJ5ID0gc2hvdWxkUmV0cnkoXG4gICAgICByZXRyeUNvbmZpZyxcbiAgICAgIHJldHJ5Q291bnQsXG4gICAgICBpc1RpbWVvdXRFcnJvcihkYXRhKSxcbiAgICAgIGh0dHBTdGF0dXNcbiAgICApO1xuICAgIGlmIChyZXRyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0LFxuICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICByZXRyeUNvbmZpZyxcbiAgICAgICAgcmV0cnlDb3VudCxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICBpZiAocmV0cnlDb25maWcpIHtcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q29uZmlnID0gcmV0cnlDb25maWc7XG4gICAgICBlcnJvckFjdGlvbi5yZXRyeUNvdW50ID0gcmV0cnlDb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yQWN0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRGcmFnUmV0cnlPclN3aXRjaEFjdGlvbihkYXRhOiBFcnJvckRhdGEpOiBJRXJyb3JBY3Rpb24ge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIC8vIFNoYXJlIGZyYWdtZW50IGVycm9yIGNvdW50IGFjY3Jvc3MgbWVkaWEgb3B0aW9ucyAobWFpbiwgYXVkaW8sIHN1YnMpXG4gICAgLy8gVGhpcyBhbGxvd3MgZm9yIGxldmVsIGJhc2VkIHJlbmRpdGlvbiBzd2l0Y2hpbmcgd2hlbiBtZWRpYSBvcHRpb24gYXNzZXRzIGZhaWxcbiAgICBjb25zdCB2YXJpYW50TGV2ZWxJbmRleCA9IHRoaXMuZ2V0VmFyaWFudExldmVsSW5kZXgoZGF0YS5mcmFnKTtcbiAgICBjb25zdCBsZXZlbCA9IGhscy5sZXZlbHNbdmFyaWFudExldmVsSW5kZXhdO1xuICAgIGNvbnN0IHsgZnJhZ0xvYWRQb2xpY3ksIGtleUxvYWRQb2xpY3kgfSA9IGhscy5jb25maWc7XG4gICAgY29uc3QgcmV0cnlDb25maWcgPSBnZXRSZXRyeUNvbmZpZyhcbiAgICAgIGRhdGEuZGV0YWlscy5zdGFydHNXaXRoKCdrZXknKSA/IGtleUxvYWRQb2xpY3kgOiBmcmFnTG9hZFBvbGljeSxcbiAgICAgIGRhdGFcbiAgICApO1xuICAgIGNvbnN0IGZyYWdtZW50RXJyb3JzID0gaGxzLmxldmVscy5yZWR1Y2UoXG4gICAgICAoYWNjLCBsZXZlbCkgPT4gYWNjICsgbGV2ZWwuZnJhZ21lbnRFcnJvcixcbiAgICAgIDBcbiAgICApO1xuICAgIC8vIFN3aXRjaCBsZXZlbHMgd2hlbiBvdXQgb2YgcmV0cmllZCBvciBsZXZlbCBpbmRleCBvdXQgb2YgYm91bmRzXG4gICAgaWYgKGxldmVsKSB7XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuRlJBR19HQVApIHtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvcisrO1xuICAgICAgfVxuICAgICAgY29uc3QgaHR0cFN0YXR1cyA9IGRhdGEucmVzcG9uc2U/LmNvZGU7XG4gICAgICBjb25zdCByZXRyeSA9IHNob3VsZFJldHJ5KFxuICAgICAgICByZXRyeUNvbmZpZyxcbiAgICAgICAgZnJhZ21lbnRFcnJvcnMsXG4gICAgICAgIGlzVGltZW91dEVycm9yKGRhdGEpLFxuICAgICAgICBodHRwU3RhdHVzXG4gICAgICApO1xuICAgICAgaWYgKHJldHJ5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0LFxuICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmUsXG4gICAgICAgICAgcmV0cnlDb25maWcsXG4gICAgICAgICAgcmV0cnlDb3VudDogZnJhZ21lbnRFcnJvcnMsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlYWNoIG1heCByZXRyeSBjb3VudCwgb3IgTWlzc2luZyBsZXZlbCByZWZlcmVuY2VcbiAgICAvLyBTd2l0Y2ggdG8gdmFsaWQgaW5kZXhcbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgdmFyaWFudExldmVsSW5kZXgpO1xuICAgIC8vIEFkZCByZXRyeSBkZXRhaWxzIHRvIGFsbG93IHNraXBwaW5nIG9mIEZSQUdfUEFSU0lOR19FUlJPUlxuICAgIGlmIChyZXRyeUNvbmZpZykge1xuICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb25maWcgPSByZXRyeUNvbmZpZztcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q291bnQgPSBmcmFnbWVudEVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yQWN0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRMZXZlbFN3aXRjaEFjdGlvbihcbiAgICBkYXRhOiBFcnJvckRhdGEsXG4gICAgbGV2ZWxJbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZFxuICApOiBJRXJyb3JBY3Rpb24ge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmIChsZXZlbEluZGV4ID09PSBudWxsIHx8IGxldmVsSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV2ZWxJbmRleCA9IGhscy5sb2FkTGV2ZWw7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGlmIChsZXZlbCkge1xuICAgICAgbGV2ZWwubG9hZEVycm9yKys7XG4gICAgICBpZiAoaGxzLmF1dG9MZXZlbEVuYWJsZWQpIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBuZXh0IGxldmVsIHRvIHJldHJ5XG4gICAgICAgIGxldCBuZXh0TGV2ZWwgPSAtMTtcbiAgICAgICAgY29uc3QgbGV2ZWxzID0gaGxzLmxldmVscztcbiAgICAgICAgY29uc3QgZnJhZ0Vycm9yVHlwZSA9IGRhdGEuZnJhZz8udHlwZTtcbiAgICAgICAgY29uc3QgeyB0eXBlOiBwbGF5bGlzdEVycm9yVHlwZSwgZ3JvdXBJZDogcGxheWxpc3RFcnJvckdyb3VwSWQgfSA9XG4gICAgICAgICAgZGF0YS5jb250ZXh0ID8/IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWxzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSAoaSArIGhscy5sb2FkTGV2ZWwpICUgbGV2ZWxzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjYW5kaWRhdGUgIT09IGhscy5sb2FkTGV2ZWwgJiZcbiAgICAgICAgICAgIGxldmVsc1tjYW5kaWRhdGVdLmxvYWRFcnJvciA9PT0gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxDYW5kaWRhdGUgPSBsZXZlbHNbY2FuZGlkYXRlXTtcbiAgICAgICAgICAgIC8vIFNraXAgbGV2ZWwgc3dpdGNoIGlmIEdBUCB0YWcgaXMgZm91bmQgaW4gbmV4dCBsZXZlbCBhdCBzYW1lIHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAoZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuRlJBR19HQVAgJiYgZGF0YS5mcmFnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsc1tjYW5kaWRhdGVdLmRldGFpbHM7XG4gICAgICAgICAgICAgIGlmIChsZXZlbERldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmFnQ2FuZGlkYXRlID0gZmluZEZyYWdtZW50QnlQVFMoXG4gICAgICAgICAgICAgICAgICBkYXRhLmZyYWcsXG4gICAgICAgICAgICAgICAgICBsZXZlbERldGFpbHMuZnJhZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgZGF0YS5mcmFnLnN0YXJ0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ0NhbmRpZGF0ZT8uZ2FwKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIChwbGF5bGlzdEVycm9yVHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJlxuICAgICAgICAgICAgICAgIHBsYXlsaXN0RXJyb3JHcm91cElkID09PSBsZXZlbENhbmRpZGF0ZS5hdWRpb0dyb3VwSWQpIHx8XG4gICAgICAgICAgICAgIChwbGF5bGlzdEVycm9yVHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJlxuICAgICAgICAgICAgICAgIHBsYXlsaXN0RXJyb3JHcm91cElkID09PSBsZXZlbENhbmRpZGF0ZS50ZXh0R3JvdXBJZClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyBGb3IgYXVkaW8vc3VicyBwbGF5bGlzdCBlcnJvcnMgZmluZCBhbm90aGVyIGdyb3VwIElEIG9yIGZhbGx0aHJvdWdoIHRvIHJlZHVuZGFudCBmYWlsLW92ZXJcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAoZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8gJiZcbiAgICAgICAgICAgICAgICBsZXZlbC5hdWRpb0dyb3VwSWQgPT09IGxldmVsQ2FuZGlkYXRlLmF1ZGlvR3JvdXBJZCkgfHxcbiAgICAgICAgICAgICAgKGZyYWdFcnJvclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFICYmXG4gICAgICAgICAgICAgICAgbGV2ZWwudGV4dEdyb3VwSWQgPT09IGxldmVsQ2FuZGlkYXRlLnRleHRHcm91cElkKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIEZvciBhdWRpby9zdWJzIGZyYWcgZXJyb3JzIGZpbmQgYW5vdGhlciBncm91cCBJRCBvciBmYWxsdGhyb3VnaCB0byByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dExldmVsID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0TGV2ZWwgPiAtMSAmJiBobHMubG9hZExldmVsICE9PSBuZXh0TGV2ZWwpIHtcbiAgICAgICAgICBkYXRhLmxldmVsUmV0cnkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gsXG4gICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICAgICAgbmV4dEF1dG9MZXZlbDogbmV4dExldmVsLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gbGV2ZWxzIHRvIHN3aXRjaCAvIE1hbnVhbCBsZXZlbCBzZWxlY3Rpb24gLyBMZXZlbCBub3QgZm91bmRcbiAgICAvLyBSZXNvbHZlIHdpdGggUGF0aHdheSBzd2l0Y2gsIFJlZHVuZGFudCBmYWlsLW92ZXIsIG9yIHN0YXkgb24gbG93ZXN0IExldmVsXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gsXG4gICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdCxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIG9uRXJyb3JPdXQoZXZlbnQ6IEV2ZW50cy5FUlJPUiwgZGF0YTogRXJyb3JEYXRhKSB7XG4gICAgc3dpdGNoIChkYXRhLmVycm9yQWN0aW9uPy5hY3Rpb24pIHtcbiAgICAgIGNhc2UgTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94OlxuICAgICAgICB0aGlzLnNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhZGF0YS5lcnJvckFjdGlvbi5yZXNvbHZlZCAmJlxuICAgICAgICAgIGRhdGEuZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQXG4gICAgICAgICkge1xuICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0OlxuICAgICAgICAvLyBoYW5kbGVkIGJ5IHN0cmVhbSBhbmQgcGxheWxpc3QvbGV2ZWwgY29udHJvbGxlcnNcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHRoaXMuaGxzLnN0b3BMb2FkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94KGRhdGE6IEVycm9yRGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICBpZiAoIWVycm9yQWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZmxhZ3MsIGhkY3BMZXZlbCwgbmV4dEF1dG9MZXZlbCB9ID0gZXJyb3JBY3Rpb247XG5cbiAgICBzd2l0Y2ggKGZsYWdzKSB7XG4gICAgICBjYXNlIEVycm9yQWN0aW9uRmxhZ3MuTm9uZTpcbiAgICAgICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLCBuZXh0QXV0b0xldmVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3Q6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBIYW5kbGUgUmVkdW5kYW50IExldmVscyBoZXJlLiBQYXRod2F5IHN3aXRjaGluZyBpcyBoYW5kbGVkIGJ5IGNvbnRlbnQtc3RlZXJpbmctY29udHJvbGxlclxuICAgICAgICAgIGlmICghZXJyb3JBY3Rpb24ucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdGhpcy5yZWR1bmRhbnRGYWlsb3ZlcihkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1A6XG4gICAgICAgIGlmIChoZGNwTGV2ZWwpIHtcbiAgICAgICAgICBobHMubWF4SGRjcExldmVsID0gSGRjcExldmVsc1tIZGNwTGV2ZWxzLmluZGV4T2YoaGRjcExldmVsKSAtIDFdO1xuICAgICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgYFJlc3RyaWN0aW5nIHBsYXliYWNrIHRvIEhEQ1AtTEVWRUwgb2YgXCIke2hscy5tYXhIZGNwTGV2ZWx9XCIgb3IgbG93ZXJgXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBJZiBub3QgcmVzb2x2ZWQgYnkgcHJldmlvdXMgYWN0aW9ucyB0cnkgdG8gc3dpdGNoIHRvIG5leHQgbGV2ZWxcbiAgICBpZiAoIWVycm9yQWN0aW9uLnJlc29sdmVkKSB7XG4gICAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEsIG5leHRBdXRvTGV2ZWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3dpdGNoTGV2ZWwoZGF0YTogRXJyb3JEYXRhLCBsZXZlbEluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAobGV2ZWxJbmRleCAhPT0gdW5kZWZpbmVkICYmIGRhdGEuZXJyb3JBY3Rpb24pIHtcbiAgICAgIHRoaXMud2Fybihgc3dpdGNoaW5nIHRvIGxldmVsICR7bGV2ZWxJbmRleH0gYWZ0ZXIgJHtkYXRhLmRldGFpbHN9YCk7XG4gICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbGV2ZWxJbmRleDtcbiAgICAgIGRhdGEuZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgLy8gU3RyZWFtIGNvbnRyb2xsZXIgaXMgcmVzcG9uc2libGUgZm9yIHRoaXMgYnV0IHdvbid0IHN3aXRjaCBvbiBmYWxzZSBzdGFydFxuICAgICAgdGhpcy5obHMubmV4dExvYWRMZXZlbCA9IHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZWR1bmRhbnRGYWlsb3ZlcihkYXRhOiBFcnJvckRhdGEpOiBib29sZWFuIHtcbiAgICBjb25zdCB7IGhscywgcGVuYWxpemVkUmVuZGl0aW9ucyB9ID0gdGhpcztcbiAgICBjb25zdCBsZXZlbEluZGV4OiBudW1iZXIgPVxuICAgICAgZGF0YS5wYXJlbnQgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU5cbiAgICAgICAgPyAoZGF0YS5sZXZlbCBhcyBudW1iZXIpXG4gICAgICAgIDogaGxzLmxvYWRMZXZlbDtcbiAgICBjb25zdCBsZXZlbCA9IGhscy5sZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgY29uc3QgcmVkdW5kYW50TGV2ZWxzID0gbGV2ZWwudXJsLmxlbmd0aDtcbiAgICBjb25zdCBlcnJvclVybElkID0gZGF0YS5mcmFnID8gZGF0YS5mcmFnLnVybElkIDogbGV2ZWwudXJsSWQ7XG4gICAgaWYgKGxldmVsLnVybElkID09PSBlcnJvclVybElkICYmICghZGF0YS5mcmFnIHx8IGxldmVsLmRldGFpbHMpKSB7XG4gICAgICB0aGlzLnBlbmFsaXplUmVuZGl0aW9uKGxldmVsLCBkYXRhKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZWR1bmRhbnRMZXZlbHM7IGkrKykge1xuICAgICAgY29uc3QgbmV3VXJsSWQgPSAoZXJyb3JVcmxJZCArIGkpICUgcmVkdW5kYW50TGV2ZWxzO1xuICAgICAgY29uc3QgcGVuYWxpemVkUmVuZGl0aW9uID0gcGVuYWxpemVkUmVuZGl0aW9uc1tuZXdVcmxJZF07XG4gICAgICAvLyBDaGVjayBpZiByZW5kaXRpb24gaXMgcGVuYWxpemVkIGFuZCBza2lwIGlmIGl0IGlzIGEgYmFkIGZpdCBmb3IgZmFpbG92ZXJcbiAgICAgIGlmIChcbiAgICAgICAgIXBlbmFsaXplZFJlbmRpdGlvbiB8fFxuICAgICAgICBjaGVja0V4cGlyZWQocGVuYWxpemVkUmVuZGl0aW9uLCBkYXRhLCBwZW5hbGl6ZWRSZW5kaXRpb25zW2Vycm9yVXJsSWRdKVxuICAgICAgKSB7XG4gICAgICAgIC8vIGRlbGV0ZSBwZW5hbGl6ZWRSZW5kaXRpb25zW25ld1VybElkXTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB1cmwgaWQgb2YgYWxsIGxldmVscyBzbyB0aGF0IHdlIHN0YXkgb24gdGhlIHNhbWUgc2V0IG9mIHZhcmlhbnRzIHdoZW4gbGV2ZWwgc3dpdGNoaW5nXG4gICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICBgU3dpdGNoaW5nIHRvIFJlZHVuZGFudCBTdHJlYW0gJHtuZXdVcmxJZCArIDF9LyR7cmVkdW5kYW50TGV2ZWxzfTogXCIke1xuICAgICAgICAgICAgbGV2ZWwudXJsW25ld1VybElkXVxuICAgICAgICAgIH1cIiBhZnRlciAke2RhdGEuZGV0YWlsc31gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgICAgIGhscy5sZXZlbHMuZm9yRWFjaCgobHYpID0+IHtcbiAgICAgICAgICBsdi51cmxJZCA9IG5ld1VybElkO1xuICAgICAgICB9KTtcbiAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbEluZGV4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBwZW5hbGl6ZVJlbmRpdGlvbihsZXZlbDogTGV2ZWwsIGRhdGE6IEVycm9yRGF0YSkge1xuICAgIGNvbnN0IHsgcGVuYWxpemVkUmVuZGl0aW9ucyB9ID0gdGhpcztcbiAgICBjb25zdCBwZW5hbGl6ZWRSZW5kaXRpb24gPSBwZW5hbGl6ZWRSZW5kaXRpb25zW2xldmVsLnVybElkXSB8fCB7XG4gICAgICBsYXN0RXJyb3JQZXJmTXM6IDAsXG4gICAgICBlcnJvcnM6IFtdLFxuICAgICAgZGV0YWlsczogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgcGVuYWxpemVkUmVuZGl0aW9uLmxhc3RFcnJvclBlcmZNcyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHBlbmFsaXplZFJlbmRpdGlvbi5lcnJvcnMucHVzaChkYXRhKTtcbiAgICBwZW5hbGl6ZWRSZW5kaXRpb24uZGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgcGVuYWxpemVkUmVuZGl0aW9uc1tsZXZlbC51cmxJZF0gPSBwZW5hbGl6ZWRSZW5kaXRpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHBpcmVkKFxuICBwZW5hbGl6ZWRSZW5kaXRpb246IFBlbmFsaXplZFJlbmRpdGlvbixcbiAgZGF0YTogRXJyb3JEYXRhLFxuICBjdXJyZW50UGVuYWx0eVN0YXRlOiBQZW5hbGl6ZWRSZW5kaXRpb24gfCB1bmRlZmluZWRcbik6IGJvb2xlYW4ge1xuICAvLyBFeHBpcmUgcGVuYWx0eSBmb3Igc3dpdGNoaW5nIGJhY2sgdG8gcmVuZGl0aW9uIGFmdGVyIFJFTkRJVElPTl9QRU5BTFRZX0RVUkFUSU9OX01TXG4gIGlmIChcbiAgICBwZXJmb3JtYW5jZS5ub3coKSAtIHBlbmFsaXplZFJlbmRpdGlvbi5sYXN0RXJyb3JQZXJmTXMgPlxuICAgIFJFTkRJVElPTl9QRU5BTFRZX0RVUkFUSU9OX01TXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIEV4cGlyZSBwZW5hbHR5IG9uIEdBUCB0YWcgZXJyb3IgaWYgcmVuZGl0aW9uIGhhcyBubyBHQVAgYXQgcG9zaXRpb24gKGRvZXMgbm90IGNvdmVyIG1lZGlhIHRyYWNrcylcbiAgY29uc3QgbGFzdEVycm9yRGV0YWlscyA9IHBlbmFsaXplZFJlbmRpdGlvbi5kZXRhaWxzO1xuICBpZiAoZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuRlJBR19HQVAgJiYgbGFzdEVycm9yRGV0YWlscyAmJiBkYXRhLmZyYWcpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGRhdGEuZnJhZy5zdGFydDtcbiAgICBjb25zdCBjYW5kaWRhdGVGcmFnID0gZmluZEZyYWdtZW50QnlQVFMoXG4gICAgICBudWxsLFxuICAgICAgbGFzdEVycm9yRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICBwb3NpdGlvblxuICAgICk7XG4gICAgaWYgKGNhbmRpZGF0ZUZyYWcgJiYgIWNhbmRpZGF0ZUZyYWcuZ2FwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gRXhwaXJlIHBlbmFsdHkgaWYgdGhlcmUgYXJlIG1vcmUgZXJyb3JzIGluIGN1cnJlbnRMZXZlbCB0aGFuIGluIHBlbmFsaXplZFJlbmRpdGlvblxuICBpZiAoXG4gICAgY3VycmVudFBlbmFsdHlTdGF0ZSAmJlxuICAgIHBlbmFsaXplZFJlbmRpdGlvbi5lcnJvcnMubGVuZ3RoIDwgY3VycmVudFBlbmFsdHlTdGF0ZS5lcnJvcnMubGVuZ3RoXG4gICkge1xuICAgIGNvbnN0IGxhc3RDYW5kaWRhdGVFcnJvciA9XG4gICAgICBwZW5hbGl6ZWRSZW5kaXRpb24uZXJyb3JzW3BlbmFsaXplZFJlbmRpdGlvbi5lcnJvcnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKFxuICAgICAgbGFzdEVycm9yRGV0YWlscyAmJlxuICAgICAgbGFzdENhbmRpZGF0ZUVycm9yLmZyYWcgJiZcbiAgICAgIGRhdGEuZnJhZyAmJlxuICAgICAgTWF0aC5hYnMobGFzdENhbmRpZGF0ZUVycm9yLmZyYWcuc3RhcnQgLSBkYXRhLmZyYWcuc3RhcnQpID5cbiAgICAgICAgbGFzdEVycm9yRGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDNcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgTmV0d29ya0NvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHsgZ2V0U2tpcFZhbHVlLCBIbHNTa2lwLCBIbHNVcmxQYXJhbWV0ZXJzLCBMZXZlbCB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB7IGNvbXB1dGVSZWxvYWRJbnRlcnZhbCwgbWVyZ2VEZXRhaWxzIH0gZnJvbSAnLi9sZXZlbC1oZWxwZXInO1xuaW1wb3J0IHsgRXJyb3JEYXRhIH0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcbmltcG9ydCB7IGdldFJldHJ5RGVsYXksIGlzVGltZW91dEVycm9yIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3ItaGVscGVyJztcbmltcG9ydCB7IE5ldHdvcmtFcnJvckFjdGlvbiB9IGZyb20gJy4vZXJyb3ItY29udHJvbGxlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHR5cGUgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwtZGV0YWlscyc7XG5pbXBvcnQgdHlwZSB7IE1lZGlhUGxheWxpc3QgfSBmcm9tICcuLi90eXBlcy9tZWRpYS1wbGF5bGlzdCc7XG5pbXBvcnQgdHlwZSB7XG4gIEF1ZGlvVHJhY2tMb2FkZWREYXRhLFxuICBMZXZlbExvYWRlZERhdGEsXG4gIFRyYWNrTG9hZGVkRGF0YSxcbn0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVBsYXlsaXN0Q29udHJvbGxlciBpbXBsZW1lbnRzIE5ldHdvcmtDb21wb25lbnRBUEkge1xuICBwcm90ZWN0ZWQgaGxzOiBIbHM7XG4gIHByb3RlY3RlZCB0aW1lcjogbnVtYmVyID0gLTE7XG4gIHByb3RlY3RlZCByZXF1ZXN0U2NoZWR1bGVkOiBudW1iZXIgPSAtMTtcbiAgcHJvdGVjdGVkIGNhbkxvYWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJvdGVjdGVkIGxvZzogKG1zZzogYW55KSA9PiB2b2lkO1xuICBwcm90ZWN0ZWQgd2FybjogKG1zZzogYW55KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKGhsczogSGxzLCBsb2dQcmVmaXg6IHN0cmluZykge1xuICAgIHRoaXMubG9nID0gbG9nZ2VyLmxvZy5iaW5kKGxvZ2dlciwgYCR7bG9nUHJlZml4fTpgKTtcbiAgICB0aGlzLndhcm4gPSBsb2dnZXIud2Fybi5iaW5kKGxvZ2dlciwgYCR7bG9nUHJlZml4fTpgKTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMubG9nID0gdGhpcy53YXJuID0gbnVsbDtcbiAgfVxuXG4gIHByb3RlY3RlZCBjbGVhclRpbWVyKCk6IHZvaWQge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gLTE7XG4gIH1cblxuICBwdWJsaWMgc3RhcnRMb2FkKCk6IHZvaWQge1xuICAgIHRoaXMuY2FuTG9hZCA9IHRydWU7XG4gICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTE7XG4gICAgdGhpcy5sb2FkUGxheWxpc3QoKTtcbiAgfVxuXG4gIHB1YmxpYyBzdG9wTG9hZCgpOiB2b2lkIHtcbiAgICB0aGlzLmNhbkxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzd2l0Y2hQYXJhbXMoXG4gICAgcGxheWxpc3RVcmk6IHN0cmluZyxcbiAgICBwcmV2aW91czogTGV2ZWxEZXRhaWxzIHwgdW5kZWZpbmVkXG4gICk6IEhsc1VybFBhcmFtZXRlcnMgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJlbmRpdGlvblJlcG9ydHMgPSBwcmV2aW91cz8ucmVuZGl0aW9uUmVwb3J0cztcbiAgICBpZiAocmVuZGl0aW9uUmVwb3J0cykge1xuICAgICAgbGV0IGZvdW5kSW5kZXggPSAtMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGl0aW9uUmVwb3J0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhdHRyID0gcmVuZGl0aW9uUmVwb3J0c1tpXTtcbiAgICAgICAgbGV0IHVyaTogc3RyaW5nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVyaSA9IG5ldyBzZWxmLlVSTChhdHRyLlVSSSwgcHJldmlvdXMudXJsKS5ocmVmO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYENvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCBmb3IgUmVuZGl0aW9uIFJlcG9ydDogJHtlcnJvcn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICB1cmkgPSBhdHRyLlVSSSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgZXhhY3QgbWF0Y2guIE90aGVyd2lzZSwgdGhlIGxhc3QgcGFydGlhbCBtYXRjaCwgaWYgYW55LCB3aWxsIGJlIHVzZWRcbiAgICAgICAgLy8gKFBsYXlsaXN0IFVSSSBpbmNsdWRlcyBhIHF1ZXJ5IHN0cmluZyB0aGF0IHRoZSBSZW5kaXRpb24gUmVwb3J0IGRvZXMgbm90KVxuICAgICAgICBpZiAodXJpID09PSBwbGF5bGlzdFVyaSkge1xuICAgICAgICAgIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHVyaSA9PT0gcGxheWxpc3RVcmkuc3Vic3RyaW5nKDAsIHVyaS5sZW5ndGgpKSB7XG4gICAgICAgICAgZm91bmRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkge1xuICAgICAgICBjb25zdCBhdHRyID0gcmVuZGl0aW9uUmVwb3J0c1tmb3VuZEluZGV4XTtcbiAgICAgICAgY29uc3QgbXNuID0gcGFyc2VJbnQoYXR0clsnTEFTVC1NU04nXSkgfHwgcHJldmlvdXM/Lmxhc3RQYXJ0U247XG4gICAgICAgIGxldCBwYXJ0ID0gcGFyc2VJbnQoYXR0clsnTEFTVC1QQVJUJ10pIHx8IHByZXZpb3VzPy5sYXN0UGFydEluZGV4O1xuICAgICAgICBpZiAodGhpcy5obHMuY29uZmlnLmxvd0xhdGVuY3lNb2RlKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudEdvYWwgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIHByZXZpb3VzLmFnZSAtIHByZXZpb3VzLnBhcnRUYXJnZXQsXG4gICAgICAgICAgICBwcmV2aW91cy50YXJnZXRkdXJhdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHBhcnQgPj0gMCAmJiBjdXJyZW50R29hbCA+IHByZXZpb3VzLnBhcnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHBhcnQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIbHNVcmxQYXJhbWV0ZXJzKFxuICAgICAgICAgIG1zbixcbiAgICAgICAgICBwYXJ0ID49IDAgPyBwYXJ0IDogdW5kZWZpbmVkLFxuICAgICAgICAgIEhsc1NraXAuTm9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnM/OiBIbHNVcmxQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9PT0gLTEpIHtcbiAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICAgIC8vIExvYWRpbmcgaXMgaGFuZGxlZCBieSB0aGUgc3ViY2xhc3Nlc1xuICB9XG5cbiAgcHJvdGVjdGVkIHNob3VsZExvYWRQbGF5bGlzdChcbiAgICBwbGF5bGlzdDogTGV2ZWwgfCBNZWRpYVBsYXlsaXN0IHwgbnVsbCB8IHVuZGVmaW5lZFxuICApOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5jYW5Mb2FkICYmXG4gICAgICAhIXBsYXlsaXN0ICYmXG4gICAgICAhIXBsYXlsaXN0LnVybCAmJlxuICAgICAgKCFwbGF5bGlzdC5kZXRhaWxzIHx8IHBsYXlsaXN0LmRldGFpbHMubGl2ZSlcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNob3VsZFJlbG9hZFBsYXlsaXN0KFxuICAgIHBsYXlsaXN0OiBMZXZlbCB8IE1lZGlhUGxheWxpc3QgfCBudWxsIHwgdW5kZWZpbmVkXG4gICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnRpbWVyID09PSAtMSAmJlxuICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSAmJlxuICAgICAgdGhpcy5zaG91bGRMb2FkUGxheWxpc3QocGxheWxpc3QpXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBwbGF5bGlzdExvYWRlZChcbiAgICBpbmRleDogbnVtYmVyLFxuICAgIGRhdGE6IExldmVsTG9hZGVkRGF0YSB8IEF1ZGlvVHJhY2tMb2FkZWREYXRhIHwgVHJhY2tMb2FkZWREYXRhLFxuICAgIHByZXZpb3VzRGV0YWlscz86IExldmVsRGV0YWlsc1xuICApIHtcbiAgICBjb25zdCB7IGRldGFpbHMsIHN0YXRzIH0gPSBkYXRhO1xuXG4gICAgLy8gU2V0IGxhc3QgdXBkYXRlZCBkYXRlLXRpbWVcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBzdGF0cy5sb2FkaW5nLmZpcnN0XG4gICAgICA/IE1hdGgubWF4KDAsIG5vdyAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpXG4gICAgICA6IDA7XG4gICAgZGV0YWlscy5hZHZhbmNlZERhdGVUaW1lID0gRGF0ZS5ub3coKSAtIGVsYXBzZWQ7XG5cbiAgICAvLyBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdCwgYXJtIGEgdGltZXIgdG8gcmVsb2FkIGl0XG4gICAgaWYgKGRldGFpbHMubGl2ZSB8fCBwcmV2aW91c0RldGFpbHM/LmxpdmUpIHtcbiAgICAgIGRldGFpbHMucmVsb2FkZWQocHJldmlvdXNEZXRhaWxzKTtcbiAgICAgIGlmIChwcmV2aW91c0RldGFpbHMpIHtcbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgYGxpdmUgcGxheWxpc3QgJHtpbmRleH0gJHtcbiAgICAgICAgICAgIGRldGFpbHMuYWR2YW5jZWRcbiAgICAgICAgICAgICAgPyAnUkVGUkVTSEVEICcgKyBkZXRhaWxzLmxhc3RQYXJ0U24gKyAnLScgKyBkZXRhaWxzLmxhc3RQYXJ0SW5kZXhcbiAgICAgICAgICAgICAgOiAnTUlTU0VEJ1xuICAgICAgICAgIH1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBNZXJnZSBsaXZlIHBsYXlsaXN0cyB0byBhZGp1c3QgZnJhZ21lbnQgc3RhcnRzIGFuZCBmaWxsIGluIGRlbHRhIHBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcbiAgICAgIGlmIChwcmV2aW91c0RldGFpbHMgJiYgZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBtZXJnZURldGFpbHMocHJldmlvdXNEZXRhaWxzLCBkZXRhaWxzKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jYW5Mb2FkIHx8ICFkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGRlbGl2ZXJ5RGlyZWN0aXZlczogSGxzVXJsUGFyYW1ldGVycyB8IHVuZGVmaW5lZDtcbiAgICAgIGxldCBtc246IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgIGxldCBwYXJ0OiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoZGV0YWlscy5jYW5CbG9ja1JlbG9hZCAmJiBkZXRhaWxzLmVuZFNOICYmIGRldGFpbHMuYWR2YW5jZWQpIHtcbiAgICAgICAgLy8gTG9hZCBsZXZlbCB3aXRoIExMLUhMUyBkZWxpdmVyeSBkaXJlY3RpdmVzXG4gICAgICAgIGNvbnN0IGxvd0xhdGVuY3lNb2RlID0gdGhpcy5obHMuY29uZmlnLmxvd0xhdGVuY3lNb2RlO1xuICAgICAgICBjb25zdCBsYXN0UGFydFNuID0gZGV0YWlscy5sYXN0UGFydFNuO1xuICAgICAgICBjb25zdCBlbmRTbiA9IGRldGFpbHMuZW5kU047XG4gICAgICAgIGNvbnN0IGxhc3RQYXJ0SW5kZXggPSBkZXRhaWxzLmxhc3RQYXJ0SW5kZXg7XG4gICAgICAgIGNvbnN0IGhhc1BhcnRzID0gbGFzdFBhcnRJbmRleCAhPT0gLTE7XG4gICAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gbGFzdFBhcnRTbiA9PT0gZW5kU247XG4gICAgICAgIC8vIFdoZW4gbG93IGxhdGVuY3kgbW9kZSBpcyBkaXNhYmxlZCwgd2UnbGwgc2tpcCBwYXJ0IHJlcXVlc3RzIG9uY2UgdGhlIGxhc3QgcGFydCBpbmRleCBpcyBmb3VuZFxuICAgICAgICBjb25zdCBuZXh0U25TdGFydEluZGV4ID0gbG93TGF0ZW5jeU1vZGUgPyAwIDogbGFzdFBhcnRJbmRleDtcbiAgICAgICAgaWYgKGhhc1BhcnRzKSB7XG4gICAgICAgICAgbXNuID0gbGFzdFBhcnQgPyBlbmRTbiArIDEgOiBsYXN0UGFydFNuO1xuICAgICAgICAgIHBhcnQgPSBsYXN0UGFydCA/IG5leHRTblN0YXJ0SW5kZXggOiBsYXN0UGFydEluZGV4ICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtc24gPSBlbmRTbiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW46IFwiYWdlXCIgaGVhZGVyIGFuZCB0aW1lIHNpbmNlIGxvYWQgaW5kaWNhdGVzIHdlJ3JlIGJlaGluZCBieSBtb3JlIHRoYW4gb25lIHBhcnRcbiAgICAgICAgLy8gVXBkYXRlIGRpcmVjdGl2ZXMgdG8gb2J0YWluIHRoZSBQbGF5bGlzdCB0aGF0IGhhcyB0aGUgZXN0aW1hdGVkIGFkZGl0aW9uYWwgZHVyYXRpb24gb2YgbWVkaWFcbiAgICAgICAgY29uc3QgbGFzdEFkdmFuY2VkID0gZGV0YWlscy5hZ2U7XG4gICAgICAgIGNvbnN0IGNkbkFnZSA9IGxhc3RBZHZhbmNlZCArIGRldGFpbHMuYWdlSGVhZGVyO1xuICAgICAgICBsZXQgY3VycmVudEdvYWwgPSBNYXRoLm1pbihcbiAgICAgICAgICBjZG5BZ2UgLSBkZXRhaWxzLnBhcnRUYXJnZXQsXG4gICAgICAgICAgZGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDEuNVxuICAgICAgICApO1xuICAgICAgICBpZiAoY3VycmVudEdvYWwgPiAwKSB7XG4gICAgICAgICAgaWYgKHByZXZpb3VzRGV0YWlscyAmJiBjdXJyZW50R29hbCA+IHByZXZpb3VzRGV0YWlscy50dW5lSW5Hb2FsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhdHRlbXB0ZWQgdG8gZ2V0IHRoZSBuZXh0IG9yIGxhdGVzdCBwbGF5bGlzdCB1cGRhdGUsIGJ1dCBjdXJyZW50R29hbCBpbmNyZWFzZWQsXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGVpdGhlciBjYW4ndCBjYXRjaHVwLCBvciB0aGUgXCJhZ2VcIiBoZWFkZXIgY2Fubm90IGJlIHRydXN0ZWQuXG4gICAgICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgICAgIGBDRE4gVHVuZS1pbiBnb2FsIGluY3JlYXNlZCBmcm9tOiAke3ByZXZpb3VzRGV0YWlscy50dW5lSW5Hb2FsfSB0bzogJHtjdXJyZW50R29hbH0gd2l0aCBwbGF5bGlzdCBhZ2U6ICR7ZGV0YWlscy5hZ2V9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN1cnJlbnRHb2FsID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBNYXRoLmZsb29yKGN1cnJlbnRHb2FsIC8gZGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgICAgICAgICBtc24gKz0gc2VnbWVudHM7XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gTWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICAoY3VycmVudEdvYWwgJSBkZXRhaWxzLnRhcmdldGR1cmF0aW9uKSAvIGRldGFpbHMucGFydFRhcmdldFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwYXJ0ICs9IHBhcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgICAgIGBDRE4gVHVuZS1pbiBhZ2U6ICR7XG4gICAgICAgICAgICAgICAgZGV0YWlscy5hZ2VIZWFkZXJcbiAgICAgICAgICAgICAgfXMgbGFzdCBhZHZhbmNlZCAke2xhc3RBZHZhbmNlZC50b0ZpeGVkKFxuICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgKX1zIGdvYWw6ICR7Y3VycmVudEdvYWx9IHNraXAgc24gJHtzZWdtZW50c30gdG8gcGFydCAke3BhcnR9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGV0YWlscy50dW5lSW5Hb2FsID0gY3VycmVudEdvYWw7XG4gICAgICAgIH1cbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gdGhpcy5nZXREZWxpdmVyeURpcmVjdGl2ZXMoXG4gICAgICAgICAgZGV0YWlscyxcbiAgICAgICAgICBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICAgICAgICBtc24sXG4gICAgICAgICAgcGFydFxuICAgICAgICApO1xuICAgICAgICBpZiAobG93TGF0ZW5jeU1vZGUgfHwgIWxhc3RQYXJ0KSB7XG4gICAgICAgICAgdGhpcy5sb2FkUGxheWxpc3QoZGVsaXZlcnlEaXJlY3RpdmVzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGV0YWlscy5jYW5CbG9ja1JlbG9hZCkge1xuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSB0aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhcbiAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICAgIGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgICAgIG1zbixcbiAgICAgICAgICBwYXJ0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5obHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBidWZmZXJJbmZvID8gYnVmZmVySW5mby5lbmQgLSBidWZmZXJJbmZvLmxlbiA6IDA7XG4gICAgICBjb25zdCBkaXN0YW5jZVRvTGl2ZUVkZ2VNcyA9IChkZXRhaWxzLmVkZ2UgLSBwb3NpdGlvbikgKiAxMDAwO1xuICAgICAgY29uc3QgcmVsb2FkSW50ZXJ2YWwgPSBjb21wdXRlUmVsb2FkSW50ZXJ2YWwoXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIGRpc3RhbmNlVG9MaXZlRWRnZU1zXG4gICAgICApO1xuICAgICAgaWYgKGRldGFpbHMudXBkYXRlZCAmJiBub3cgPiB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgKyByZWxvYWRJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSBzdGF0cy5sb2FkaW5nLnN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAobXNuICE9PSB1bmRlZmluZWQgJiYgZGV0YWlscy5jYW5CbG9ja1JlbG9hZCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPVxuICAgICAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgK1xuICAgICAgICAgIHJlbG9hZEludGVydmFsIC1cbiAgICAgICAgICAoZGV0YWlscy5wYXJ0VGFyZ2V0ICogMTAwMCB8fCAxMDAwKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9PT0gLTEgfHxcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkICsgcmVsb2FkSW50ZXJ2YWwgPCBub3dcbiAgICAgICkge1xuICAgICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSBub3c7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVxdWVzdFNjaGVkdWxlZCAtIG5vdyA8PSAwKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCArPSByZWxvYWRJbnRlcnZhbDtcbiAgICAgIH1cbiAgICAgIGxldCBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgPSB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgLSBub3c7XG4gICAgICBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgPSBNYXRoLm1heCgwLCBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpO1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgIGByZWxvYWQgbGl2ZSBwbGF5bGlzdCAke2luZGV4fSBpbiAke01hdGgucm91bmQoXG4gICAgICAgICAgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlXG4gICAgICAgICl9IG1zYFxuICAgICAgKTtcbiAgICAgIC8vIHRoaXMubG9nKFxuICAgICAgLy8gICBgbGl2ZSByZWxvYWQgJHtkZXRhaWxzLnVwZGF0ZWQgPyAnUkVGUkVTSEVEJyA6ICdNSVNTRUQnfVxuICAgICAgLy8gcmVsb2FkIGluICR7ZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlIC8gMTAwMH1cbiAgICAgIC8vIHJvdW5kIHRyaXAgJHsoc3RhdHMubG9hZGluZy5lbmQgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KSAvIDEwMDB9XG4gICAgICAvLyBkaWZmICR7XG4gICAgICAvLyAgIChyZWxvYWRJbnRlcnZhbCAtXG4gICAgICAvLyAgICAgKGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSArXG4gICAgICAvLyAgICAgICBzdGF0cy5sb2FkaW5nLmVuZCAtXG4gICAgICAvLyAgICAgICBzdGF0cy5sb2FkaW5nLnN0YXJ0KSkgL1xuICAgICAgLy8gICAxMDAwXG4gICAgICAvLyB9XG4gICAgICAvLyByZWxvYWQgaW50ZXJ2YWwgJHtyZWxvYWRJbnRlcnZhbCAvIDEwMDB9XG4gICAgICAvLyB0YXJnZXQgZHVyYXRpb24gJHtkZXRhaWxzLnRhcmdldGR1cmF0aW9ufVxuICAgICAgLy8gZGlzdGFuY2UgdG8gZWRnZSAke2Rpc3RhbmNlVG9MaXZlRWRnZU1zIC8gMTAwMH1gXG4gICAgICAvLyApO1xuXG4gICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PiB0aGlzLmxvYWRQbGF5bGlzdChkZWxpdmVyeURpcmVjdGl2ZXMpLFxuICAgICAgICBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKFxuICAgIGRldGFpbHM6IExldmVsRGV0YWlscyxcbiAgICBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlczogSGxzVXJsUGFyYW1ldGVycyB8IG51bGwsXG4gICAgbXNuPzogbnVtYmVyLFxuICAgIHBhcnQ/OiBudW1iZXJcbiAgKTogSGxzVXJsUGFyYW1ldGVycyB7XG4gICAgbGV0IHNraXAgPSBnZXRTa2lwVmFsdWUoZGV0YWlscywgbXNuKTtcbiAgICBpZiAocHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXM/LnNraXAgJiYgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgbXNuID0gcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMubXNuO1xuICAgICAgcGFydCA9IHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnBhcnQ7XG4gICAgICBza2lwID0gSGxzU2tpcC5ObztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIbHNVcmxQYXJhbWV0ZXJzKG1zbiwgcGFydCwgc2tpcCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tSZXRyeShlcnJvckV2ZW50OiBFcnJvckRhdGEpOiBib29sZWFuIHtcbiAgICBjb25zdCBlcnJvckRldGFpbHMgPSBlcnJvckV2ZW50LmRldGFpbHM7XG4gICAgY29uc3QgaXNUaW1lb3V0ID0gaXNUaW1lb3V0RXJyb3IoZXJyb3JFdmVudCk7XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSBlcnJvckV2ZW50LmVycm9yQWN0aW9uO1xuICAgIGNvbnN0IHsgYWN0aW9uLCByZXRyeUNvdW50ID0gMCwgcmV0cnlDb25maWcgfSA9IGVycm9yQWN0aW9uIHx8IHt9O1xuICAgIGNvbnN0IHJldHJ5ID1cbiAgICAgICEhZXJyb3JBY3Rpb24gJiZcbiAgICAgICEhcmV0cnlDb25maWcgJiZcbiAgICAgIChhY3Rpb24gPT09IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QgfHxcbiAgICAgICAgKCFlcnJvckFjdGlvbi5yZXNvbHZlZCAmJlxuICAgICAgICAgIGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gpKTtcbiAgICBpZiAocmV0cnkpIHtcbiAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IC0xO1xuICAgICAgaWYgKHJldHJ5Q291bnQgPj0gcmV0cnlDb25maWcubWF4TnVtUmV0cnkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGltZW91dCAmJiBlcnJvckV2ZW50LmNvbnRleHQ/LmRlbGl2ZXJ5RGlyZWN0aXZlcykge1xuICAgICAgICAvLyBUaGUgTEwtSExTIHJlcXVlc3QgYWxyZWFkeSB0aW1lZCBvdXQgc28gcmV0cnkgaW1tZWRpYXRlbHlcbiAgICAgICAgdGhpcy53YXJuKFxuICAgICAgICAgIGBSZXRyeWluZyBwbGF5bGlzdCBsb2FkaW5nICR7cmV0cnlDb3VudCArIDF9LyR7XG4gICAgICAgICAgICByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeVxuICAgICAgICAgIH0gYWZ0ZXIgXCIke2Vycm9yRGV0YWlsc31cIiB3aXRob3V0IGRlbGl2ZXJ5LWRpcmVjdGl2ZXNgXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubG9hZFBsYXlsaXN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZWxheSA9IGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHJldHJ5Q291bnQpO1xuICAgICAgICAvLyBTY2hlZHVsZSBsZXZlbC90cmFjayByZWxvYWRcbiAgICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB0aGlzLmxvYWRQbGF5bGlzdCgpLCBkZWxheSk7XG4gICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICBgUmV0cnlpbmcgcGxheWxpc3QgbG9hZGluZyAke3JldHJ5Q291bnQgKyAxfS8ke1xuICAgICAgICAgICAgcmV0cnlDb25maWcubWF4TnVtUmV0cnlcbiAgICAgICAgICB9IGFmdGVyIFwiJHtlcnJvckRldGFpbHN9XCIgaW4gJHtkZWxheX1tc2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIGBsZXZlbFJldHJ5ID0gdHJ1ZWAgdXNlZCB0byBpbmZvcm0gb3RoZXIgY29udHJvbGxlcnMgdGhhdCBhIHJldHJ5IGlzIGhhcHBlbmluZ1xuICAgICAgZXJyb3JFdmVudC5sZXZlbFJldHJ5ID0gdHJ1ZTtcbiAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHJ5O1xuICB9XG59XG4iLCIvKlxuICogTGV2ZWwgQ29udHJvbGxlclxuICovXG5cbmltcG9ydCB7XG4gIE1hbmlmZXN0TG9hZGVkRGF0YSxcbiAgTWFuaWZlc3RQYXJzZWREYXRhLFxuICBMZXZlbExvYWRlZERhdGEsXG4gIFRyYWNrU3dpdGNoZWREYXRhLFxuICBGcmFnTG9hZGVkRGF0YSxcbiAgRXJyb3JEYXRhLFxuICBMZXZlbFN3aXRjaGluZ0RhdGEsXG4gIExldmVsc1VwZGF0ZWREYXRhLFxuICBNYW5pZmVzdExvYWRpbmdEYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHsgTGV2ZWwgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCB9IGZyb20gJy4uL3V0aWxzL2NvZGVjcyc7XG5pbXBvcnQgQmFzZVBsYXlsaXN0Q29udHJvbGxlciBmcm9tICcuL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlcic7XG5pbXBvcnQgeyBQbGF5bGlzdENvbnRleHRUeXBlLCBQbGF5bGlzdExldmVsVHlwZSB9IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgSGxzVXJsUGFyYW1ldGVycywgTGV2ZWxQYXJzZWQgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgdHlwZSB7IE1lZGlhUGxheWxpc3QgfSBmcm9tICcuLi90eXBlcy9tZWRpYS1wbGF5bGlzdCc7XG5pbXBvcnQgQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciBmcm9tICcuL2NvbnRlbnQtc3RlZXJpbmctY29udHJvbGxlcic7XG5cbmxldCBjaHJvbWVPckZpcmVmb3g6IGJvb2xlYW47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsQ29udHJvbGxlciBleHRlbmRzIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIge1xuICBwcml2YXRlIF9sZXZlbHM6IExldmVsW10gPSBbXTtcbiAgcHJpdmF0ZSBfZmlyc3RMZXZlbDogbnVtYmVyID0gLTE7XG4gIHByaXZhdGUgX3N0YXJ0TGV2ZWw/OiBudW1iZXI7XG4gIHByaXZhdGUgY3VycmVudExldmVsOiBMZXZlbCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGN1cnJlbnRMZXZlbEluZGV4OiBudW1iZXIgPSAtMTtcbiAgcHJpdmF0ZSBtYW51YWxMZXZlbEluZGV4OiBudW1iZXIgPSAtMTtcbiAgcHJpdmF0ZSBzdGVlcmluZzogQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciB8IG51bGw7XG5cbiAgcHVibGljIG9uUGFyc2VkQ29tcGxldGUhOiBGdW5jdGlvbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBobHM6IEhscyxcbiAgICBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyOiBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyIHwgbnVsbFxuICApIHtcbiAgICBzdXBlcihobHMsICdbbGV2ZWwtY29udHJvbGxlcl0nKTtcbiAgICB0aGlzLnN0ZWVyaW5nID0gY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cblxuICBwcml2YXRlIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnN0ZWVyaW5nID0gbnVsbDtcbiAgICB0aGlzLnJlc2V0TGV2ZWxzKCk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgcHVibGljIHN0YXJ0TG9hZCgpOiB2b2lkIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG5cbiAgICAvLyBjbGVhbiB1cCBsaXZlIGxldmVsIGRldGFpbHMgdG8gZm9yY2UgcmVsb2FkIHRoZW0sIGFuZCByZXNldCBsb2FkIGVycm9yc1xuICAgIGxldmVscy5mb3JFYWNoKChsZXZlbCkgPT4ge1xuICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgIH0pO1xuXG4gICAgc3VwZXIuc3RhcnRMb2FkKCk7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0TGV2ZWxzKCkge1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IC0xO1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbnVsbDtcbiAgICB0aGlzLl9sZXZlbHMgPSBbXTtcbiAgfVxuXG4gIHByaXZhdGUgb25NYW5pZmVzdExvYWRpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLFxuICAgIGRhdGE6IE1hbmlmZXN0TG9hZGluZ0RhdGFcbiAgKSB7XG4gICAgdGhpcy5yZXNldExldmVscygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWFuaWZlc3RMb2FkZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsXG4gICAgZGF0YTogTWFuaWZlc3RMb2FkZWREYXRhXG4gICkge1xuICAgIGNvbnN0IGxldmVsczogTGV2ZWxbXSA9IFtdO1xuICAgIGNvbnN0IGxldmVsU2V0OiB7IFtrZXk6IHN0cmluZ106IExldmVsIH0gPSB7fTtcbiAgICBsZXQgbGV2ZWxGcm9tU2V0OiBMZXZlbDtcblxuICAgIC8vIHJlZ3JvdXAgcmVkdW5kYW50IGxldmVscyB0b2dldGhlclxuICAgIGRhdGEubGV2ZWxzLmZvckVhY2goKGxldmVsUGFyc2VkOiBMZXZlbFBhcnNlZCkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGxldmVsUGFyc2VkLmF0dHJzO1xuXG4gICAgICAvLyBlcmFzZSBhdWRpbyBjb2RlYyBpbmZvIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtcDRhLjQwLjM0LlxuICAgICAgLy8gZGVtdXhlciB3aWxsIGF1dG9kZXRlY3QgY29kZWMgYW5kIGZhbGxiYWNrIHRvIG1wZWcvYXVkaW9cbiAgICAgIGlmIChsZXZlbFBhcnNlZC5hdWRpb0NvZGVjPy5pbmRleE9mKCdtcDRhLjQwLjM0JykgIT09IC0xKSB7XG4gICAgICAgIGNocm9tZU9yRmlyZWZveCB8fD0gL2Nocm9tZXxmaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgaWYgKGNocm9tZU9yRmlyZWZveCkge1xuICAgICAgICAgIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBBVURJTyxcbiAgICAgICAgQ09ERUNTLFxuICAgICAgICAnRlJBTUUtUkFURSc6IEZSQU1FUkFURSxcbiAgICAgICAgJ1BBVEhXQVktSUQnOiBQQVRIV0FZLFxuICAgICAgICBSRVNPTFVUSU9OLFxuICAgICAgICBTVUJUSVRMRVMsXG4gICAgICB9ID0gYXR0cmlidXRlcztcbiAgICAgIGNvbnN0IGNvbnRlbnRTdGVlcmluZ1ByZWZpeCA9IF9fVVNFX0NPTlRFTlRfU1RFRVJJTkdfX1xuICAgICAgICA/IGAke1BBVEhXQVkgfHwgJy4nfS1gXG4gICAgICAgIDogJyc7XG4gICAgICBjb25zdCBsZXZlbEtleSA9IGAke2NvbnRlbnRTdGVlcmluZ1ByZWZpeH0ke2xldmVsUGFyc2VkLmJpdHJhdGV9LSR7UkVTT0xVVElPTn0tJHtGUkFNRVJBVEV9LSR7Q09ERUNTfWA7XG4gICAgICBsZXZlbEZyb21TZXQgPSBsZXZlbFNldFtsZXZlbEtleV07XG5cbiAgICAgIGlmICghbGV2ZWxGcm9tU2V0KSB7XG4gICAgICAgIGxldmVsRnJvbVNldCA9IG5ldyBMZXZlbChsZXZlbFBhcnNlZCk7XG4gICAgICAgIGxldmVsU2V0W2xldmVsS2V5XSA9IGxldmVsRnJvbVNldDtcbiAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWxGcm9tU2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsRnJvbVNldC5hZGRGYWxsYmFjayhsZXZlbFBhcnNlZCk7XG4gICAgICB9XG5cbiAgICAgIGFkZEdyb3VwSWQobGV2ZWxGcm9tU2V0LCAnYXVkaW8nLCBBVURJTyk7XG4gICAgICBhZGRHcm91cElkKGxldmVsRnJvbVNldCwgJ3RleHQnLCBTVUJUSVRMRVMpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5maWx0ZXJBbmRTb3J0TWVkaWFPcHRpb25zKGxldmVscywgZGF0YSk7XG4gIH1cblxuICBwcml2YXRlIGZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMoXG4gICAgdW5maWx0ZXJlZExldmVsczogTGV2ZWxbXSxcbiAgICBkYXRhOiBNYW5pZmVzdExvYWRlZERhdGFcbiAgKSB7XG4gICAgbGV0IGF1ZGlvVHJhY2tzOiBNZWRpYVBsYXlsaXN0W10gPSBbXTtcbiAgICBsZXQgc3VidGl0bGVUcmFja3M6IE1lZGlhUGxheWxpc3RbXSA9IFtdO1xuXG4gICAgbGV0IHJlc29sdXRpb25Gb3VuZCA9IGZhbHNlO1xuICAgIGxldCB2aWRlb0NvZGVjRm91bmQgPSBmYWxzZTtcbiAgICBsZXQgYXVkaW9Db2RlY0ZvdW5kID0gZmFsc2U7XG5cbiAgICAvLyBvbmx5IGtlZXAgbGV2ZWxzIHdpdGggc3VwcG9ydGVkIGF1ZGlvL3ZpZGVvIGNvZGVjc1xuICAgIGxldCBsZXZlbHMgPSB1bmZpbHRlcmVkTGV2ZWxzLmZpbHRlcihcbiAgICAgICh7IGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHdpZHRoLCBoZWlnaHQsIHVua25vd25Db2RlY3MgfSkgPT4ge1xuICAgICAgICByZXNvbHV0aW9uRm91bmQgfHw9ICEhKHdpZHRoICYmIGhlaWdodCk7XG4gICAgICAgIHZpZGVvQ29kZWNGb3VuZCB8fD0gISF2aWRlb0NvZGVjO1xuICAgICAgICBhdWRpb0NvZGVjRm91bmQgfHw9ICEhYXVkaW9Db2RlYztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAhdW5rbm93bkNvZGVjcz8ubGVuZ3RoICYmXG4gICAgICAgICAgKCFhdWRpb0NvZGVjIHx8IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNChhdWRpb0NvZGVjLCAnYXVkaW8nKSkgJiZcbiAgICAgICAgICAoIXZpZGVvQ29kZWMgfHwgaXNDb2RlY1N1cHBvcnRlZEluTXA0KHZpZGVvQ29kZWMsICd2aWRlbycpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyByZW1vdmUgYXVkaW8tb25seSBsZXZlbCBpZiB3ZSBhbHNvIGhhdmUgbGV2ZWxzIHdpdGggdmlkZW8gY29kZWNzIG9yIFJFU09MVVRJT04gc2lnbmFsbGVkXG4gICAgaWYgKChyZXNvbHV0aW9uRm91bmQgfHwgdmlkZW9Db2RlY0ZvdW5kKSAmJiBhdWRpb0NvZGVjRm91bmQpIHtcbiAgICAgIGxldmVscyA9IGxldmVscy5maWx0ZXIoXG4gICAgICAgICh7IHZpZGVvQ29kZWMsIHdpZHRoLCBoZWlnaHQgfSkgPT4gISF2aWRlb0NvZGVjIHx8ICEhKHdpZHRoICYmIGhlaWdodClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIERpc3BhdGNoIGVycm9yIGFmdGVyIE1BTklGRVNUX0xPQURFRCBpcyBkb25lIHByb3BhZ2F0aW5nXG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaGxzKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnbm8gbGV2ZWwgd2l0aCBjb21wYXRpYmxlIGNvZGVjcyBmb3VuZCBpbiBtYW5pZmVzdCdcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIHVybDogZGF0YS51cmwsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuYXVkaW9UcmFja3MpIHtcbiAgICAgIGF1ZGlvVHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcy5maWx0ZXIoXG4gICAgICAgICh0cmFjaykgPT5cbiAgICAgICAgICAhdHJhY2suYXVkaW9Db2RlYyB8fCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQodHJhY2suYXVkaW9Db2RlYywgJ2F1ZGlvJylcbiAgICAgICk7XG4gICAgICAvLyBBc3NpZ24gaWRzIGFmdGVyIGZpbHRlcmluZyBhcyBhcnJheSBpbmRpY2VzIGJ5IGdyb3VwLWlkXG4gICAgICBhc3NpZ25UcmFja0lkc0J5R3JvdXAoYXVkaW9UcmFja3MpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnN1YnRpdGxlcykge1xuICAgICAgc3VidGl0bGVUcmFja3MgPSBkYXRhLnN1YnRpdGxlcztcbiAgICAgIGFzc2lnblRyYWNrSWRzQnlHcm91cChzdWJ0aXRsZVRyYWNrcyk7XG4gICAgfVxuICAgIC8vIHN0YXJ0IGJpdHJhdGUgaXMgdGhlIGZpcnN0IGJpdHJhdGUgb2YgdGhlIG1hbmlmZXN0XG4gICAgY29uc3QgdW5zb3J0ZWRMZXZlbHMgPSBsZXZlbHMuc2xpY2UoMCk7XG4gICAgLy8gc29ydCBsZXZlbHMgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdFxuICAgIGxldmVscy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5hdHRyc1snSERDUC1MRVZFTCddICE9PSBiLmF0dHJzWydIRENQLUxFVkVMJ10pIHtcbiAgICAgICAgcmV0dXJuIChhLmF0dHJzWydIRENQLUxFVkVMJ10gfHwgJycpID4gKGIuYXR0cnNbJ0hEQ1AtTEVWRUwnXSB8fCAnJylcbiAgICAgICAgICA/IDFcbiAgICAgICAgICA6IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGEuYml0cmF0ZSAhPT0gYi5iaXRyYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmJpdHJhdGUgLSBiLmJpdHJhdGU7XG4gICAgICB9XG4gICAgICBpZiAoYS5hdHRyc1snRlJBTUUtUkFURSddICE9PSBiLmF0dHJzWydGUkFNRS1SQVRFJ10pIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBhLmF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdGUkFNRS1SQVRFJykgLVxuICAgICAgICAgIGIuYXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ0ZSQU1FLVJBVEUnKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGEuYXR0cnMuU0NPUkUgIT09IGIuYXR0cnMuU0NPUkUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBhLmF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdTQ09SRScpIC1cbiAgICAgICAgICBiLmF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdTQ09SRScpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocmVzb2x1dGlvbkZvdW5kICYmIGEuaGVpZ2h0ICE9PSBiLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gYS5oZWlnaHQgLSBiLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgbGV0IGZpcnN0TGV2ZWxJblBsYXlsaXN0ID0gdW5zb3J0ZWRMZXZlbHNbMF07XG4gICAgaWYgKHRoaXMuc3RlZXJpbmcpIHtcbiAgICAgIGxldmVscyA9IHRoaXMuc3RlZXJpbmcuZmlsdGVyUGFyc2VkTGV2ZWxzKGxldmVscyk7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCAhPT0gdW5zb3J0ZWRMZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5zb3J0ZWRMZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodW5zb3J0ZWRMZXZlbHNbaV0ucGF0aHdheUlkID09PSBsZXZlbHNbMF0ucGF0aHdheUlkKSB7XG4gICAgICAgICAgICBmaXJzdExldmVsSW5QbGF5bGlzdCA9IHVuc29ydGVkTGV2ZWxzW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuXG4gICAgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbHNbaV0gPT09IGZpcnN0TGV2ZWxJblBsYXlsaXN0KSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBpO1xuICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICBgbWFuaWZlc3QgbG9hZGVkLCAke2xldmVscy5sZW5ndGh9IGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiAke2ZpcnN0TGV2ZWxJblBsYXlsaXN0LmJpdHJhdGV9YFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBdWRpbyBpcyBvbmx5IGFsdGVybmF0ZSBpZiBtYW5pZmVzdCBpbmNsdWRlIGEgVVJJIGFsb25nIHdpdGggdGhlIGF1ZGlvIGdyb3VwIHRhZyxcbiAgICAvLyBhbmQgdGhpcyBpcyBub3QgYW4gYXVkaW8tb25seSBzdHJlYW0gd2hlcmUgbGV2ZWxzIGNvbnRhaW4gYXVkaW8tb25seVxuICAgIGNvbnN0IGF1ZGlvT25seSA9IGF1ZGlvQ29kZWNGb3VuZCAmJiAhdmlkZW9Db2RlY0ZvdW5kO1xuICAgIGNvbnN0IGVkYXRhOiBNYW5pZmVzdFBhcnNlZERhdGEgPSB7XG4gICAgICBsZXZlbHMsXG4gICAgICBhdWRpb1RyYWNrcyxcbiAgICAgIHN1YnRpdGxlVHJhY2tzLFxuICAgICAgc2Vzc2lvbkRhdGE6IGRhdGEuc2Vzc2lvbkRhdGEsXG4gICAgICBzZXNzaW9uS2V5czogZGF0YS5zZXNzaW9uS2V5cyxcbiAgICAgIGZpcnN0TGV2ZWw6IHRoaXMuX2ZpcnN0TGV2ZWwsXG4gICAgICBzdGF0czogZGF0YS5zdGF0cyxcbiAgICAgIGF1ZGlvOiBhdWRpb0NvZGVjRm91bmQsXG4gICAgICB2aWRlbzogdmlkZW9Db2RlY0ZvdW5kLFxuICAgICAgYWx0QXVkaW86ICFhdWRpb09ubHkgJiYgYXVkaW9UcmFja3Muc29tZSgodCkgPT4gISF0LnVybCksXG4gICAgfTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIGVkYXRhKTtcblxuICAgIC8vIEluaXRpYXRlIGxvYWRpbmcgYWZ0ZXIgYWxsIGNvbnRyb2xsZXJzIGhhdmUgcmVjZWl2ZWQgTUFOSUZFU1RfUEFSU0VEXG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5hdXRvU3RhcnRMb2FkIHx8IHRoaXMuaGxzLmZvcmNlU3RhcnRMb2FkKSB7XG4gICAgICB0aGlzLmhscy5zdGFydExvYWQodGhpcy5obHMuY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBsZXZlbHMoKTogTGV2ZWxbXSB8IG51bGwge1xuICAgIGlmICh0aGlzLl9sZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xldmVscztcbiAgfVxuXG4gIGdldCBsZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICB9XG5cbiAgc2V0IGxldmVsKG5ld0xldmVsOiBudW1iZXIpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgaWYgKGxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0xldmVsIDwgMCB8fCBuZXdMZXZlbCA+PSBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAvLyBpbnZhbGlkIGxldmVsIGlkIGdpdmVuLCB0cmlnZ2VyIGVycm9yXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignaW52YWxpZCBsZXZlbCBpZHgnKTtcbiAgICAgIGNvbnN0IGZhdGFsID0gbmV3TGV2ZWwgPCAwO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUixcbiAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICBmYXRhbCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgIH0pO1xuICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5ld0xldmVsID0gTWF0aC5taW4obmV3TGV2ZWwsIGxldmVscy5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgY29uc3QgbGFzdExldmVsID0gdGhpcy5jdXJyZW50TGV2ZWw7XG4gICAgY29uc3QgbGFzdFBhdGh3YXlJZCA9IGxhc3RMZXZlbCA/IGxhc3RMZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW25ld0xldmVsXTtcbiAgICBjb25zdCBwYXRod2F5SWQgPSBsZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddO1xuICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBuZXdMZXZlbDtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IGxldmVsO1xuXG4gICAgaWYgKFxuICAgICAgbGFzdExldmVsSW5kZXggPT09IG5ld0xldmVsICYmXG4gICAgICBsZXZlbC5kZXRhaWxzICYmXG4gICAgICBsYXN0TGV2ZWwgJiZcbiAgICAgIGxhc3RQYXRod2F5SWQgPT09IHBhdGh3YXlJZFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubG9nKFxuICAgICAgYFN3aXRjaGluZyB0byBsZXZlbCAke25ld0xldmVsfSR7XG4gICAgICAgIHBhdGh3YXlJZCA/ICcgd2l0aCBQYXRod2F5ICcgKyBwYXRod2F5SWQgOiAnJ1xuICAgICAgfSBmcm9tIGxldmVsICR7bGFzdExldmVsSW5kZXh9JHtcbiAgICAgICAgbGFzdFBhdGh3YXlJZCA/ICcgd2l0aCBQYXRod2F5ICcgKyBsYXN0UGF0aHdheUlkIDogJydcbiAgICAgIH1gXG4gICAgKTtcblxuICAgIGNvbnN0IGxldmVsU3dpdGNoaW5nRGF0YTogTGV2ZWxTd2l0Y2hpbmdEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgbGV2ZWwsIHtcbiAgICAgIGxldmVsOiBuZXdMZXZlbCxcbiAgICAgIG1heEJpdHJhdGU6IGxldmVsLm1heEJpdHJhdGUsXG4gICAgICBhdHRyczogbGV2ZWwuYXR0cnMsXG4gICAgICB1cmk6IGxldmVsLnVyaSxcbiAgICAgIHVybElkOiBsZXZlbC51cmxJZCxcbiAgICB9KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZGVsZXRlIGxldmVsU3dpdGNoaW5nRGF0YS5fYXR0cnM7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGRlbGV0ZSBsZXZlbFN3aXRjaGluZ0RhdGEuX3VybElkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgbGV2ZWxTd2l0Y2hpbmdEYXRhKTtcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgbGV2ZWxcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAvLyBsZXZlbCBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICBjb25zdCBobHNVcmxQYXJhbWV0ZXJzID0gdGhpcy5zd2l0Y2hQYXJhbXMobGV2ZWwudXJpLCBsYXN0TGV2ZWw/LmRldGFpbHMpO1xuICAgICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG1hbnVhbExldmVsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcbiAgfVxuXG4gIHNldCBtYW51YWxMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG5cbiAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGZpcnN0TGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgfVxuXG4gIHNldCBmaXJzdExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgZ2V0IHN0YXJ0TGV2ZWwoKSB7XG4gICAgLy8gaGxzLnN0YXJ0TGV2ZWwgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGNvbmZpZy5zdGFydExldmVsXG4gICAgLy8gaWYgbm9uZSBvZiB0aGVzZSB2YWx1ZXMgYXJlIGRlZmluZWQsIGZhbGxiYWNrIG9uIHRoaXMuX2ZpcnN0TGV2ZWwgKGZpcnN0IHF1YWxpdHkgbGV2ZWwgYXBwZWFyaW5nIGluIHZhcmlhbnQgbWFuaWZlc3QpXG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY29uZmlnU3RhcnRMZXZlbCA9IHRoaXMuaGxzLmNvbmZpZy5zdGFydExldmVsO1xuICAgICAgaWYgKGNvbmZpZ1N0YXJ0TGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY29uZmlnU3RhcnRMZXZlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnRMZXZlbDtcbiAgICB9XG4gIH1cblxuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkVycm9yKGV2ZW50OiBFdmVudHMuRVJST1IsIGRhdGE6IEVycm9yRGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsIHx8ICFkYXRhLmNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBkYXRhLmNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCAmJlxuICAgICAgZGF0YS5jb250ZXh0LmxldmVsID09PSB0aGlzLmxldmVsXG4gICAgKSB7XG4gICAgICB0aGlzLmNoZWNrUmV0cnkoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzZXQgZXJyb3JzIG9uIHRoZSBzdWNjZXNzZnVsIGxvYWQgb2YgYSBmcmFnbWVudFxuICBwcm90ZWN0ZWQgb25GcmFnTG9hZGVkKGV2ZW50OiBFdmVudHMuRlJBR19MT0FERUQsIHsgZnJhZyB9OiBGcmFnTG9hZGVkRGF0YSkge1xuICAgIGlmIChmcmFnICE9PSB1bmRlZmluZWQgJiYgZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuX2xldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uTGV2ZWxMb2FkZWQoZXZlbnQ6IEV2ZW50cy5MRVZFTF9MT0FERUQsIGRhdGE6IExldmVsTG9hZGVkRGF0YSkge1xuICAgIGNvbnN0IHsgbGV2ZWwsIGRldGFpbHMgfSA9IGRhdGE7XG4gICAgY29uc3QgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxdO1xuXG4gICAgaWYgKCFjdXJMZXZlbCkge1xuICAgICAgdGhpcy53YXJuKGBJbnZhbGlkIGxldmVsIGluZGV4ICR7bGV2ZWx9YCk7XG4gICAgICBpZiAoZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXM/LnNraXApIHtcbiAgICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb25seSBwcm9jZXNzIGxldmVsIGxvYWRlZCBldmVudHMgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBsZXZlbFxuICAgIGlmIChsZXZlbCA9PT0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleCkge1xuICAgICAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgbGV2ZWwgbG9hZGVkIG9ubHkgaWYgdGhlcmUgaXMgbm8gaXNzdWVzIHdpdGggZnJhZ21lbnRzXG4gICAgICBpZiAoY3VyTGV2ZWwuZnJhZ21lbnRFcnJvciA9PT0gMCkge1xuICAgICAgICBjdXJMZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5wbGF5bGlzdExvYWRlZChsZXZlbCwgZGF0YSwgY3VyTGV2ZWwuZGV0YWlscyk7XG4gICAgfSBlbHNlIGlmIChkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcz8uc2tpcCkge1xuICAgICAgLy8gcmVjZWl2ZWQgYSBkZWx0YSBwbGF5bGlzdCB1cGRhdGUgdGhhdCBjYW5ub3QgYmUgbWVyZ2VkXG4gICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25BdWRpb1RyYWNrU3dpdGNoZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCxcbiAgICBkYXRhOiBUcmFja1N3aXRjaGVkRGF0YVxuICApIHtcbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbDtcbiAgICBpZiAoIWN1cnJlbnRMZXZlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF1ZGlvR3JvdXBJZCA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2RhdGEuaWRdLmdyb3VwSWQ7XG4gICAgaWYgKFxuICAgICAgY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHMgJiZcbiAgICAgIGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWQgIT09IGF1ZGlvR3JvdXBJZFxuICAgICkge1xuICAgICAgbGV0IHVybElkID0gLTE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkc1tpXSA9PT0gYXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgdXJsSWQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh1cmxJZCAhPT0gLTEgJiYgdXJsSWQgIT09IGN1cnJlbnRMZXZlbC51cmxJZCkge1xuICAgICAgICBjdXJyZW50TGV2ZWwudXJsSWQgPSB1cmxJZDtcbiAgICAgICAgaWYgKHRoaXMuY2FuTG9hZCkge1xuICAgICAgICAgIHRoaXMuc3RhcnRMb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnM/OiBIbHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIubG9hZFBsYXlsaXN0KCk7XG4gICAgY29uc3QgY3VycmVudExldmVsSW5kZXggPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IHRoaXMuY3VycmVudExldmVsO1xuXG4gICAgaWYgKGN1cnJlbnRMZXZlbCAmJiB0aGlzLnNob3VsZExvYWRQbGF5bGlzdChjdXJyZW50TGV2ZWwpKSB7XG4gICAgICBjb25zdCBpZCA9IGN1cnJlbnRMZXZlbC51cmxJZDtcbiAgICAgIGxldCB1cmwgPSBjdXJyZW50TGV2ZWwudXJpO1xuICAgICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgICBgQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6ICR7ZXJyb3J9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcGF0aHdheUlkID0gY3VycmVudExldmVsLmF0dHJzWydQQVRIV0FZLUlEJ107XG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgYExvYWRpbmcgbGV2ZWwgaW5kZXggJHtjdXJyZW50TGV2ZWxJbmRleH0ke1xuICAgICAgICAgIGhsc1VybFBhcmFtZXRlcnM/Lm1zbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/ICcgYXQgc24gJyArXG4gICAgICAgICAgICAgIGhsc1VybFBhcmFtZXRlcnMubXNuICtcbiAgICAgICAgICAgICAgJyBwYXJ0ICcgK1xuICAgICAgICAgICAgICBobHNVcmxQYXJhbWV0ZXJzLnBhcnRcbiAgICAgICAgICAgIDogJydcbiAgICAgICAgfSB3aXRoJHtwYXRod2F5SWQgPyAnIFBhdGh3YXkgJyArIHBhdGh3YXlJZCA6ICcnfSBVUkkgJHtpZCArIDF9LyR7XG4gICAgICAgICAgY3VycmVudExldmVsLnVybC5sZW5ndGhcbiAgICAgICAgfSAke3VybH1gXG4gICAgICApO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZygnQ3VycmVudCBhdWRpbyB0cmFjayBncm91cCBJRDonLCB0aGlzLmhscy5hdWRpb1RyYWNrc1t0aGlzLmhscy5hdWRpb1RyYWNrXS5ncm91cElkKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdOZXcgdmlkZW8gcXVhbGl0eSBsZXZlbCBhdWRpbyBncm91cCBpZDonLCBsZXZlbE9iamVjdC5hdHRycy5BVURJTywgbGV2ZWwpO1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB7XG4gICAgICAgIHVybCxcbiAgICAgICAgbGV2ZWw6IGN1cnJlbnRMZXZlbEluZGV4LFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBobHNVcmxQYXJhbWV0ZXJzIHx8IG51bGwsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgc2V0IG5leHRMb2FkTGV2ZWwobmV4dExldmVsKSB7XG4gICAgdGhpcy5sZXZlbCA9IG5leHRMZXZlbDtcbiAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICB9XG4gIH1cblxuICByZW1vdmVMZXZlbChsZXZlbEluZGV4LCB1cmxJZCkge1xuICAgIGNvbnN0IGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXggPSAodXJsLCBpZCkgPT4gaWQgIT09IHVybElkO1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscy5maWx0ZXIoKGxldmVsLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ICE9PSBsZXZlbEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobGV2ZWwudXJsLmxlbmd0aCA+IDEgJiYgdXJsSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXZlbC51cmwgPSBsZXZlbC51cmwuZmlsdGVyKGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXgpO1xuICAgICAgICBpZiAobGV2ZWwuYXVkaW9Hcm91cElkcykge1xuICAgICAgICAgIGxldmVsLmF1ZGlvR3JvdXBJZHMgPSBsZXZlbC5hdWRpb0dyb3VwSWRzLmZpbHRlcihcbiAgICAgICAgICAgIGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbC50ZXh0R3JvdXBJZHMpIHtcbiAgICAgICAgICBsZXZlbC50ZXh0R3JvdXBJZHMgPSBsZXZlbC50ZXh0R3JvdXBJZHMuZmlsdGVyKFxuICAgICAgICAgICAgZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV2ZWwudXJsSWQgPSAwO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0ZWVyaW5nKSB7XG4gICAgICAgIHRoaXMuc3RlZXJpbmcucmVtb3ZlTGV2ZWwobGV2ZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxTX1VQREFURUQsIHsgbGV2ZWxzIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkxldmVsc1VwZGF0ZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTFNfVVBEQVRFRCxcbiAgICB7IGxldmVscyB9OiBMZXZlbHNVcGRhdGVkRGF0YVxuICApIHtcbiAgICBsZXZlbHMuZm9yRWFjaCgobGV2ZWwsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7IGRldGFpbHMgfSA9IGxldmVsO1xuICAgICAgaWYgKGRldGFpbHM/LmZyYWdtZW50cykge1xuICAgICAgICBkZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKChmcmFnbWVudCkgPT4ge1xuICAgICAgICAgIGZyYWdtZW50LmxldmVsID0gaW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkR3JvdXBJZChcbiAgbGV2ZWw6IExldmVsLFxuICB0eXBlOiBzdHJpbmcsXG4gIGlkOiBzdHJpbmcgfCB1bmRlZmluZWRcbik6IHZvaWQge1xuICBpZiAoIWlkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgaWYgKCFsZXZlbC5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICBsZXZlbC5hdWRpb0dyb3VwSWRzID0gW107XG4gICAgfVxuICAgIGxldmVsLmF1ZGlvR3JvdXBJZHNbbGV2ZWwudXJsLmxlbmd0aCAtIDFdID0gaWQ7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgaWYgKCFsZXZlbC50ZXh0R3JvdXBJZHMpIHtcbiAgICAgIGxldmVsLnRleHRHcm91cElkcyA9IFtdO1xuICAgIH1cbiAgICBsZXZlbC50ZXh0R3JvdXBJZHNbbGV2ZWwudXJsLmxlbmd0aCAtIDFdID0gaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduVHJhY2tJZHNCeUdyb3VwKHRyYWNrczogTWVkaWFQbGF5bGlzdFtdKTogdm9pZCB7XG4gIGNvbnN0IGdyb3VwcyA9IHt9O1xuICB0cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICBjb25zdCBncm91cElkID0gdHJhY2suZ3JvdXBJZCB8fCAnJztcbiAgICB0cmFjay5pZCA9IGdyb3Vwc1tncm91cElkXSA9IGdyb3Vwc1tncm91cElkXSB8fCAwO1xuICAgIGdyb3Vwc1tncm91cElkXSsrO1xuICB9KTtcbn1cbiIsImltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBGcmFnbWVudCwgUGFydCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgeyBQbGF5bGlzdExldmVsVHlwZSB9IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgdHlwZSB7IFNvdXJjZUJ1ZmZlck5hbWUgfSBmcm9tICcuLi90eXBlcy9idWZmZXInO1xuaW1wb3J0IHR5cGUge1xuICBGcmFnbWVudEJ1ZmZlcmVkUmFuZ2UsXG4gIEZyYWdtZW50RW50aXR5LFxuICBGcmFnbWVudFRpbWVSYW5nZSxcbn0gZnJvbSAnLi4vdHlwZXMvZnJhZ21lbnQtdHJhY2tlcic7XG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUge1xuICBCdWZmZXJBcHBlbmRlZERhdGEsXG4gIEZyYWdCdWZmZXJlZERhdGEsXG4gIEZyYWdMb2FkZWREYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5cbmV4cG9ydCBjb25zdCBlbnVtIEZyYWdtZW50U3RhdGUge1xuICBOT1RfTE9BREVEID0gJ05PVF9MT0FERUQnLFxuICBBUFBFTkRJTkcgPSAnQVBQRU5ESU5HJyxcbiAgUEFSVElBTCA9ICdQQVJUSUFMJyxcbiAgT0sgPSAnT0snLFxufVxuXG5leHBvcnQgY2xhc3MgRnJhZ21lbnRUcmFja2VyIGltcGxlbWVudHMgQ29tcG9uZW50QVBJIHtcbiAgcHJpdmF0ZSBhY3RpdmVQYXJ0TGlzdHM6IHsgW2tleSBpbiBQbGF5bGlzdExldmVsVHlwZV0/OiBQYXJ0W10gfSA9XG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcHJpdmF0ZSBlbmRMaXN0RnJhZ21lbnRzOiB7IFtrZXkgaW4gUGxheWxpc3RMZXZlbFR5cGVdPzogRnJhZ21lbnRFbnRpdHkgfSA9XG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcHJpdmF0ZSBmcmFnbWVudHM6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgRnJhZ21lbnRFbnRpdHk+PiA9XG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcHJpdmF0ZSB0aW1lUmFuZ2VzOlxuICAgIHwge1xuICAgICAgICBba2V5IGluIFNvdXJjZUJ1ZmZlck5hbWVdPzogVGltZVJhbmdlcztcbiAgICAgIH1cbiAgICB8IG51bGwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHByaXZhdGUgYnVmZmVyUGFkZGluZzogbnVtYmVyID0gMC4yO1xuICBwcml2YXRlIGhsczogSGxzO1xuICBwcml2YXRlIGhhc0dhcHM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihobHM6IEhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuXG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5mcmFnbWVudHMgPVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHMgPVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzID1cbiAgICAgIHRoaXMudGltZVJhbmdlcyA9XG4gICAgICAgIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgRnJhZ21lbnQgb3IgUGFydCB3aXRoIGFuIGFwcGVuZGVkIHJhbmdlIHRoYXQgbWF0Y2hlcyB0aGUgcG9zaXRpb24gYW5kIGxldmVsVHlwZVxuICAgKiBPdGhlcndpc2UsIHJldHVybiBudWxsXG4gICAqL1xuICBwdWJsaWMgZ2V0QXBwZW5kZWRGcmFnKFxuICAgIHBvc2l0aW9uOiBudW1iZXIsXG4gICAgbGV2ZWxUeXBlOiBQbGF5bGlzdExldmVsVHlwZVxuICApOiBGcmFnbWVudCB8IFBhcnQgfCBudWxsIHtcbiAgICBjb25zdCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW2xldmVsVHlwZV07XG4gICAgaWYgKGFjdGl2ZVBhcnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gYWN0aXZlUGFydHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICBjb25zdCBhY3RpdmVQYXJ0ID0gYWN0aXZlUGFydHNbaV07XG4gICAgICAgIGlmICghYWN0aXZlUGFydCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGVuZGVkUFRTID0gYWN0aXZlUGFydC5lbmQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBhY3RpdmVQYXJ0LnN0YXJ0IDw9IHBvc2l0aW9uICYmXG4gICAgICAgICAgYXBwZW5kZWRQVFMgIT09IG51bGwgJiZcbiAgICAgICAgICBwb3NpdGlvbiA8PSBhcHBlbmRlZFBUU1xuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlUGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgYnVmZmVyZWQgRnJhZ21lbnQgdGhhdCBtYXRjaGVzIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlLlxuICAgKiBBIGJ1ZmZlcmVkIEZyYWdtZW50IGlzIG9uZSB3aG9zZSBsb2FkaW5nLCBwYXJzaW5nIGFuZCBhcHBlbmRpbmcgaXMgZG9uZSAoY29tcGxldGVkIG9yIFwicGFydGlhbFwiIG1lYW5pbmcgYWJvcnRlZCkuXG4gICAqIElmIG5vdCBmb3VuZCBhbnkgRnJhZ21lbnQsIHJldHVybiBudWxsXG4gICAqL1xuICBwdWJsaWMgZ2V0QnVmZmVyZWRGcmFnKFxuICAgIHBvc2l0aW9uOiBudW1iZXIsXG4gICAgbGV2ZWxUeXBlOiBQbGF5bGlzdExldmVsVHlwZVxuICApOiBGcmFnbWVudCB8IG51bGwge1xuICAgIGNvbnN0IHsgZnJhZ21lbnRzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudHMpO1xuICAgIGZvciAobGV0IGkgPSBrZXlzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleXNbaV1dO1xuICAgICAgaWYgKGZyYWdtZW50RW50aXR5Py5ib2R5LnR5cGUgPT09IGxldmVsVHlwZSAmJiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgaWYgKGZyYWcuc3RhcnQgPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPD0gZnJhZy5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsIGZyYWdtZW50cyBlZmZlY3RlZCBieSBjb2RlZCBmcmFtZSBldmljdGlvbiB3aWxsIGJlIHJlbW92ZWRcbiAgICogVGhlIGJyb3dzZXIgd2lsbCB1bmxvYWQgcGFydHMgb2YgdGhlIGJ1ZmZlciB0byBmcmVlIHVwIG1lbW9yeSBmb3IgbmV3IGJ1ZmZlciBkYXRhXG4gICAqIEZyYWdtZW50cyB3aWxsIG5lZWQgdG8gYmUgcmVsb2FkZWQgd2hlbiB0aGUgYnVmZmVyIGlzIGZyZWVkIHVwLCByZW1vdmluZyBwYXJ0aWFsIGZyYWdtZW50cyB3aWxsIGFsbG93IHRoZW0gdG8gcmVsb2FkKHNpbmNlIHRoZXJlIG1pZ2h0IGJlIHBhcnRzIHRoYXQgYXJlIHN0aWxsIHBsYXlhYmxlKVxuICAgKi9cbiAgcHVibGljIGRldGVjdEV2aWN0ZWRGcmFnbWVudHMoXG4gICAgZWxlbWVudGFyeVN0cmVhbTogU291cmNlQnVmZmVyTmFtZSxcbiAgICB0aW1lUmFuZ2U6IFRpbWVSYW5nZXMsXG4gICAgcGxheWxpc3RUeXBlOiBQbGF5bGlzdExldmVsVHlwZSxcbiAgICBhcHBlbmRlZFBhcnQ/OiBQYXJ0IHwgbnVsbFxuICApIHtcbiAgICBpZiAodGhpcy50aW1lUmFuZ2VzKSB7XG4gICAgICB0aGlzLnRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV0gPSB0aW1lUmFuZ2U7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGFueSBmbGFnZ2VkIGZyYWdtZW50cyBoYXZlIGJlZW4gdW5sb2FkZWRcbiAgICAvLyBleGNsdWRpbmcgYW55dGhpbmcgbmV3ZXIgdGhhbiBhcHBlbmRlZFBhcnRTblxuICAgIGNvbnN0IGFwcGVuZGVkUGFydFNuID0gKGFwcGVuZGVkUGFydD8uZnJhZ21lbnQuc24gfHwgLTEpIGFzIG51bWJlcjtcbiAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhcHBlbmRlZFBhcnRTbiA+PSAoZnJhZ21lbnRFbnRpdHkuYm9keS5zbiBhcyBudW1iZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiYgIWZyYWdtZW50RW50aXR5LmxvYWRlZCkge1xuICAgICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlID09PSBwbGF5bGlzdFR5cGUpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVzRGF0YSA9IGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgaWYgKCFlc0RhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXNEYXRhLnRpbWUuc29tZSgodGltZTogRnJhZ21lbnRUaW1lUmFuZ2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNOb3RCdWZmZXJlZCA9ICF0aGlzLmlzVGltZUJ1ZmZlcmVkKFxuICAgICAgICAgIHRpbWUuc3RhcnRQVFMsXG4gICAgICAgICAgdGltZS5lbmRQVFMsXG4gICAgICAgICAgdGltZVJhbmdlXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpc05vdEJ1ZmZlcmVkKSB7XG4gICAgICAgICAgLy8gVW5yZWdpc3RlciBwYXJ0aWFsIGZyYWdtZW50IGFzIGl0IG5lZWRzIHRvIGxvYWQgYWdhaW4gdG8gYmUgcmV1c2VkXG4gICAgICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOb3RCdWZmZXJlZDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZnJhZ21lbnQgcGFzc2VkIGluIGlzIGxvYWRlZCBpbiB0aGUgYnVmZmVyIHByb3Blcmx5XG4gICAqIFBhcnRpYWxseSBsb2FkZWQgZnJhZ21lbnRzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICovXG4gIHB1YmxpYyBkZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKGRhdGE6IEZyYWdCdWZmZXJlZERhdGEpIHtcbiAgICBjb25zdCB0aW1lUmFuZ2VzID0gdGhpcy50aW1lUmFuZ2VzO1xuICAgIGNvbnN0IHsgZnJhZywgcGFydCB9ID0gZGF0YTtcbiAgICBpZiAoIXRpbWVSYW5nZXMgfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNGcmFnSGludCA9ICFmcmFnLnJlbHVybDtcbiAgICBPYmplY3Qua2V5cyh0aW1lUmFuZ2VzKS5mb3JFYWNoKChlbGVtZW50YXJ5U3RyZWFtOiBTb3VyY2VCdWZmZXJOYW1lKSA9PiB7XG4gICAgICBjb25zdCBzdHJlYW1JbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgIGlmICghc3RyZWFtSW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0aW1lUmFuZ2UgPSB0aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dIGFzIFRpbWVSYW5nZXM7XG4gICAgICBjb25zdCBwYXJ0aWFsID0gaXNGcmFnSGludCB8fCBzdHJlYW1JbmZvLnBhcnRpYWwgPT09IHRydWU7XG4gICAgICBmcmFnbWVudEVudGl0eS5yYW5nZVtlbGVtZW50YXJ5U3RyZWFtXSA9IHRoaXMuZ2V0QnVmZmVyZWRUaW1lcyhcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgcGFydGlhbCxcbiAgICAgICAgdGltZVJhbmdlXG4gICAgICApO1xuICAgIH0pO1xuICAgIGZyYWdtZW50RW50aXR5LmxvYWRlZCA9IG51bGw7XG4gICAgaWYgKE9iamVjdC5rZXlzKGZyYWdtZW50RW50aXR5LnJhbmdlKS5sZW5ndGgpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID0gdHJ1ZTtcbiAgICAgIGlmIChmcmFnbWVudEVudGl0eS5ib2R5LmVuZExpc3QpIHtcbiAgICAgICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2ZyYWdtZW50RW50aXR5LmJvZHkudHlwZV0gPSBmcmFnbWVudEVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICAvLyBSZW1vdmUgb2xkZXIgZnJhZ21lbnQgcGFydHMgZnJvbSBsb29rdXAgYWZ0ZXIgZnJhZyBpcyB0cmFja2VkIGFzIGJ1ZmZlcmVkXG4gICAgICAgIHRoaXMucmVtb3ZlUGFydHMoKGZyYWcuc24gYXMgbnVtYmVyKSAtIDEsIGZyYWcudHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBmcmFnbWVudCBpZiBub3RoaW5nIHdhcyBhcHBlbmRlZFxuICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZVBhcnRzKHNuVG9LZWVwOiBudW1iZXIsIGxldmVsVHlwZTogUGxheWxpc3RMZXZlbFR5cGUpIHtcbiAgICBjb25zdCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW2xldmVsVHlwZV07XG4gICAgaWYgKCFhY3RpdmVQYXJ0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tsZXZlbFR5cGVdID0gYWN0aXZlUGFydHMuZmlsdGVyKFxuICAgICAgKHBhcnQpID0+IChwYXJ0LmZyYWdtZW50LnNuIGFzIG51bWJlcikgPj0gc25Ub0tlZXBcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGZyYWdCdWZmZXJlZChmcmFnOiBGcmFnbWVudCwgZm9yY2U/OiB0cnVlKSB7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIGxldCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIGlmICghZnJhZ21lbnRFbnRpdHkgJiYgZm9yY2UpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV0gPSB7XG4gICAgICAgIGJvZHk6IGZyYWcsXG4gICAgICAgIGFwcGVuZGVkUFRTOiBudWxsLFxuICAgICAgICBsb2FkZWQ6IG51bGwsXG4gICAgICAgIGJ1ZmZlcmVkOiBmYWxzZSxcbiAgICAgICAgcmFuZ2U6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICB9O1xuICAgICAgaWYgKGZyYWcuZ2FwKSB7XG4gICAgICAgIHRoaXMuaGFzR2FwcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmcmFnbWVudEVudGl0eSkge1xuICAgICAgZnJhZ21lbnRFbnRpdHkubG9hZGVkID0gbnVsbDtcbiAgICAgIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldEJ1ZmZlcmVkVGltZXMoXG4gICAgZnJhZ21lbnQ6IEZyYWdtZW50LFxuICAgIHBhcnQ6IFBhcnQgfCBudWxsLFxuICAgIHBhcnRpYWw6IGJvb2xlYW4sXG4gICAgdGltZVJhbmdlOiBUaW1lUmFuZ2VzXG4gICk6IEZyYWdtZW50QnVmZmVyZWRSYW5nZSB7XG4gICAgY29uc3QgYnVmZmVyZWQ6IEZyYWdtZW50QnVmZmVyZWRSYW5nZSA9IHtcbiAgICAgIHRpbWU6IFtdLFxuICAgICAgcGFydGlhbCxcbiAgICB9O1xuICAgIGNvbnN0IHN0YXJ0UFRTID0gZnJhZ21lbnQuc3RhcnQ7XG4gICAgY29uc3QgZW5kUFRTID0gZnJhZ21lbnQuZW5kO1xuICAgIGNvbnN0IG1pbkVuZFBUUyA9IGZyYWdtZW50Lm1pbkVuZFBUUyB8fCBlbmRQVFM7XG4gICAgY29uc3QgbWF4U3RhcnRQVFMgPSBmcmFnbWVudC5tYXhTdGFydFBUUyB8fCBzdGFydFBUUztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgY29uc3QgZW5kVGltZSA9IHRpbWVSYW5nZS5lbmQoaSkgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBpZiAobWF4U3RhcnRQVFMgPj0gc3RhcnRUaW1lICYmIG1pbkVuZFBUUyA8PSBlbmRUaW1lKSB7XG4gICAgICAgIC8vIEZyYWdtZW50IGlzIGVudGlyZWx5IGNvbnRhaW5lZCBpbiBidWZmZXJcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgb3RoZXIgdGltZVJhbmdlIHRpbWVzIHNpbmNlIGl0J3MgY29tcGxldGVseSBwbGF5YWJsZVxuICAgICAgICBidWZmZXJlZC50aW1lLnB1c2goe1xuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcbiAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSksXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRQVFMgPCBlbmRUaW1lICYmIGVuZFBUUyA+IHN0YXJ0VGltZSkge1xuICAgICAgICBidWZmZXJlZC5wYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludGVyc2VjdGlvbiB3aXRoIGJ1ZmZlclxuICAgICAgICAvLyBHZXQgcGxheWFibGUgc2VjdGlvbnMgb2YgdGhlIGZyYWdtZW50XG4gICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgc3RhcnRQVFM6IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpLFxuICAgICAgICAgIGVuZFBUUzogTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGFydGlhbCBmcmFnbWVudCBmb3IgYSBjZXJ0YWluIHRpbWVcbiAgICovXG4gIHB1YmxpYyBnZXRQYXJ0aWFsRnJhZ21lbnQodGltZTogbnVtYmVyKTogRnJhZ21lbnQgfCBudWxsIHtcbiAgICBsZXQgYmVzdEZyYWdtZW50OiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICAgIGxldCB0aW1lUGFkZGluZzogbnVtYmVyO1xuICAgIGxldCBzdGFydFRpbWU6IG51bWJlcjtcbiAgICBsZXQgZW5kVGltZTogbnVtYmVyO1xuICAgIGxldCBiZXN0T3ZlcmxhcDogbnVtYmVyID0gMDtcbiAgICBjb25zdCB7IGJ1ZmZlclBhZGRpbmcsIGZyYWdtZW50cyB9ID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyhmcmFnbWVudHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSBmcmFnbWVudHNba2V5XTtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFydGlhbChmcmFnbWVudEVudGl0eSkpIHtcbiAgICAgICAgc3RhcnRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5zdGFydCAtIGJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIGVuZFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LmVuZCArIGJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIGlmICh0aW1lID49IHN0YXJ0VGltZSAmJiB0aW1lIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGZyYWdtZW50IHRoYXQgaGFzIHRoZSBtb3N0IHBhZGRpbmcgZnJvbSBzdGFydCBhbmQgZW5kIHRpbWVcbiAgICAgICAgICB0aW1lUGFkZGluZyA9IE1hdGgubWluKHRpbWUgLSBzdGFydFRpbWUsIGVuZFRpbWUgLSB0aW1lKTtcbiAgICAgICAgICBpZiAoYmVzdE92ZXJsYXAgPD0gdGltZVBhZGRpbmcpIHtcbiAgICAgICAgICAgIGJlc3RGcmFnbWVudCA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICAgICAgICBiZXN0T3ZlcmxhcCA9IHRpbWVQYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBiZXN0RnJhZ21lbnQ7XG4gIH1cblxuICBwdWJsaWMgaXNFbmRMaXN0QXBwZW5kZWQodHlwZTogUGxheWxpc3RMZXZlbFR5cGUpOiBib29sZWFuIHtcbiAgICBjb25zdCBsYXN0RnJhZ21lbnRFbnRpdHkgPSB0aGlzLmVuZExpc3RGcmFnbWVudHNbdHlwZV07XG4gICAgcmV0dXJuIChcbiAgICAgIGxhc3RGcmFnbWVudEVudGl0eSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAobGFzdEZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkIHx8IGlzUGFydGlhbChsYXN0RnJhZ21lbnRFbnRpdHkpKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0U3RhdGUoZnJhZ21lbnQ6IEZyYWdtZW50KTogRnJhZ21lbnRTdGF0ZSB7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuXG4gICAgaWYgKGZyYWdtZW50RW50aXR5KSB7XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLkFQUEVORElORztcbiAgICAgIH0gZWxzZSBpZiAoaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuT0s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRDtcbiAgfVxuXG4gIHByaXZhdGUgaXNUaW1lQnVmZmVyZWQoXG4gICAgc3RhcnRQVFM6IG51bWJlcixcbiAgICBlbmRQVFM6IG51bWJlcixcbiAgICB0aW1lUmFuZ2U6IFRpbWVSYW5nZXNcbiAgKTogYm9vbGVhbiB7XG4gICAgbGV0IHN0YXJ0VGltZTtcbiAgICBsZXQgZW5kVGltZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgZW5kVGltZSA9IHRpbWVSYW5nZS5lbmQoaSkgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBpZiAoc3RhcnRQVFMgPj0gc3RhcnRUaW1lICYmIGVuZFBUUyA8PSBlbmRUaW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXN0IG9mIHRoZSB0aW1lUmFuZ2UgYXMgaXQgaXMgaW4gb3JkZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgb25GcmFnTG9hZGVkKGV2ZW50OiBFdmVudHMuRlJBR19MT0FERUQsIGRhdGE6IEZyYWdMb2FkZWREYXRhKSB7XG4gICAgY29uc3QgeyBmcmFnLCBwYXJ0IH0gPSBkYXRhO1xuICAgIC8vIGRvbid0IHRyYWNrIGluaXRzZWdtZW50IChmb3Igd2hpY2ggc24gaXMgbm90IGEgbnVtYmVyKVxuICAgIC8vIGRvbid0IHRyYWNrIGZyYWdzIHVzZWQgZm9yIGJpdHJhdGVUZXN0LCB0aGV5J3JlIGlycmVsZXZhbnQuXG4gICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgfHwgZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZyYWdtZW50IGVudGl0eSBgbG9hZGVkYCBGcmFnTG9hZGVkRGF0YSBpcyBudWxsIHdoZW4gbG9hZGluZyBwYXJ0c1xuICAgIGNvbnN0IGxvYWRlZCA9IHBhcnQgPyBudWxsIDogZGF0YTtcblxuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XSA9IHtcbiAgICAgIGJvZHk6IGZyYWcsXG4gICAgICBhcHBlbmRlZFBUUzogbnVsbCxcbiAgICAgIGxvYWRlZCxcbiAgICAgIGJ1ZmZlcmVkOiBmYWxzZSxcbiAgICAgIHJhbmdlOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIG9uQnVmZmVyQXBwZW5kZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsXG4gICAgZGF0YTogQnVmZmVyQXBwZW5kZWREYXRhXG4gICkge1xuICAgIGNvbnN0IHsgZnJhZywgcGFydCwgdGltZVJhbmdlcyB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBmcmFnLnR5cGU7XG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIGxldCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW3BsYXlsaXN0VHlwZV07XG4gICAgICBpZiAoIWFjdGl2ZVBhcnRzKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUGFydExpc3RzW3BsYXlsaXN0VHlwZV0gPSBhY3RpdmVQYXJ0cyA9IFtdO1xuICAgICAgfVxuICAgICAgYWN0aXZlUGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgLy8gU3RvcmUgdGhlIGxhdGVzdCB0aW1lUmFuZ2VzIGxvYWRlZCBpbiB0aGUgYnVmZmVyXG4gICAgdGhpcy50aW1lUmFuZ2VzID0gdGltZVJhbmdlcztcbiAgICBPYmplY3Qua2V5cyh0aW1lUmFuZ2VzKS5mb3JFYWNoKChlbGVtZW50YXJ5U3RyZWFtOiBTb3VyY2VCdWZmZXJOYW1lKSA9PiB7XG4gICAgICBjb25zdCB0aW1lUmFuZ2UgPSB0aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dIGFzIFRpbWVSYW5nZXM7XG4gICAgICB0aGlzLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoXG4gICAgICAgIGVsZW1lbnRhcnlTdHJlYW0sXG4gICAgICAgIHRpbWVSYW5nZSxcbiAgICAgICAgcGxheWxpc3RUeXBlLFxuICAgICAgICBwYXJ0XG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkZyYWdCdWZmZXJlZChldmVudDogRXZlbnRzLkZSQUdfQlVGRkVSRUQsIGRhdGE6IEZyYWdCdWZmZXJlZERhdGEpIHtcbiAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZGF0YSk7XG4gIH1cblxuICBwcml2YXRlIGhhc0ZyYWdtZW50KGZyYWdtZW50OiBGcmFnbWVudCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgcmV0dXJuICEhdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gIH1cblxuICBwdWJsaWMgaGFzUGFydHModHlwZTogUGxheWxpc3RMZXZlbFR5cGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmFjdGl2ZVBhcnRMaXN0c1t0eXBlXT8ubGVuZ3RoO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUZyYWdtZW50c0luUmFuZ2UoXG4gICAgc3RhcnQ6IG51bWJlcixcbiAgICBlbmQ6IG51bWJlcixcbiAgICBwbGF5bGlzdFR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlLFxuICAgIHdpdGhHYXBPbmx5PzogYm9vbGVhbixcbiAgICB1bmJ1ZmZlcmVkT25seT86IGJvb2xlYW5cbiAgKSB7XG4gICAgaWYgKHdpdGhHYXBPbmx5ICYmICF0aGlzLmhhc0dhcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1trZXldO1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgIGlmIChmcmFnLnR5cGUgIT09IHBsYXlsaXN0VHlwZSB8fCAod2l0aEdhcE9ubHkgJiYgIWZyYWcuZ2FwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGZyYWcuc3RhcnQgPCBlbmQgJiZcbiAgICAgICAgZnJhZy5lbmQgPiBzdGFydCAmJlxuICAgICAgICAoZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgfHwgdW5idWZmZXJlZE9ubHkpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVGcmFnbWVudChmcmFnbWVudDogRnJhZ21lbnQpIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIGZyYWdtZW50LnN0YXRzLmxvYWRlZCA9IDA7XG4gICAgZnJhZ21lbnQuY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpO1xuICAgIGNvbnN0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbZnJhZ21lbnQudHlwZV07XG4gICAgaWYgKGFjdGl2ZVBhcnRzKSB7XG4gICAgICBjb25zdCBzblRvUmVtb3ZlID0gZnJhZ21lbnQuc247XG4gICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tmcmFnbWVudC50eXBlXSA9IGFjdGl2ZVBhcnRzLmZpbHRlcihcbiAgICAgICAgKHBhcnQpID0+IHBhcnQuZnJhZ21lbnQuc24gIT09IHNuVG9SZW1vdmVcbiAgICAgICk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoZnJhZ21lbnQuZW5kTGlzdCkge1xuICAgICAgZGVsZXRlIHRoaXMuZW5kTGlzdEZyYWdtZW50c1tmcmFnbWVudC50eXBlXTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlQWxsRnJhZ21lbnRzKCkge1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmhhc0dhcHMgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHk6IEZyYWdtZW50RW50aXR5KTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiZcbiAgICAoZnJhZ21lbnRFbnRpdHkuYm9keS5nYXAgfHxcbiAgICAgIGZyYWdtZW50RW50aXR5LnJhbmdlLnZpZGVvPy5wYXJ0aWFsIHx8XG4gICAgICBmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpbz8ucGFydGlhbCB8fFxuICAgICAgZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW92aWRlbz8ucGFydGlhbClcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQ6IEZyYWdtZW50KTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke2ZyYWdtZW50LnR5cGV9XyR7ZnJhZ21lbnQubGV2ZWx9XyR7ZnJhZ21lbnQudXJsSWR9XyR7ZnJhZ21lbnQuc259YDtcbn1cbiIsImltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4vZnJhZ21lbnQnO1xuaW1wb3J0IHtcbiAgTG9hZGVyLFxuICBMb2FkZXJDb25maWd1cmF0aW9uLFxuICBGcmFnbWVudExvYWRlckNvbnRleHQsXG59IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgeyBnZXRMb2FkZXJDb25maWdXaXRob3V0UmV0aWVzIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3ItaGVscGVyJztcbmltcG9ydCB0eXBlIHsgSGxzQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB0eXBlIHsgQmFzZVNlZ21lbnQsIFBhcnQgfSBmcm9tICcuL2ZyYWdtZW50JztcbmltcG9ydCB0eXBlIHtcbiAgRXJyb3JEYXRhLFxuICBGcmFnTG9hZGVkRGF0YSxcbiAgUGFydHNMb2FkZWREYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuXG5jb25zdCBNSU5fQ0hVTktfU0laRSA9IE1hdGgucG93KDIsIDE3KTsgLy8gMTI4a2JcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnJhZ21lbnRMb2FkZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogSGxzQ29uZmlnO1xuICBwcml2YXRlIGxvYWRlcjogTG9hZGVyPEZyYWdtZW50TG9hZGVyQ29udGV4dD4gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBwYXJ0TG9hZFRpbWVvdXQ6IG51bWJlciA9IC0xO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogSGxzQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGFib3J0KCkge1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgLy8gQWJvcnQgdGhlIGxvYWRlciBmb3IgY3VycmVudCBmcmFnbWVudC4gT25seSBvbmUgbWF5IGxvYWQgYXQgYW55IGdpdmVuIHRpbWVcbiAgICAgIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICB9XG5cbiAgbG9hZChcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBvblByb2dyZXNzPzogRnJhZ21lbnRMb2FkUHJvZ3Jlc3NDYWxsYmFja1xuICApOiBQcm9taXNlPEZyYWdMb2FkZWREYXRhPiB7XG4gICAgY29uc3QgdXJsID0gZnJhZy51cmw7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGcmFnbWVudCBkb2VzIG5vdCBoYXZlIGEgJHt1cmwgPyAncGFydCBsaXN0JyA6ICd1cmwnfWBcbiAgICAgICAgICApLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBudWxsLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5hYm9ydCgpO1xuXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgRnJhZ21lbnRJTG9hZGVyID0gY29uZmlnLmZMb2FkZXI7XG4gICAgY29uc3QgRGVmYXVsdElMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5nYXApIHtcbiAgICAgICAgcmVqZWN0KGNyZWF0ZUdhcExvYWRFcnJvcihmcmFnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlciA9XG4gICAgICAgICh0aGlzLmxvYWRlciA9XG4gICAgICAgIGZyYWcubG9hZGVyID1cbiAgICAgICAgICBGcmFnbWVudElMb2FkZXJcbiAgICAgICAgICAgID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpXG4gICAgICAgICAgICA6IChuZXcgRGVmYXVsdElMb2FkZXIoY29uZmlnKSBhcyBMb2FkZXI8RnJhZ21lbnRMb2FkZXJDb250ZXh0PikpO1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZyk7XG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhcbiAgICAgICAgY29uZmlnLmZyYWdMb2FkUG9saWN5LmRlZmF1bHRcbiAgICAgICk7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWc6IExvYWRlckNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDAsXG4gICAgICAgIGhpZ2hXYXRlck1hcms6IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgPyBJbmZpbml0eSA6IE1JTl9DSFVOS19TSVpFLFxuICAgICAgfTtcbiAgICAgIC8vIEFzc2lnbiBmcmFnIHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgIGZyYWcuc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIHtcbiAgICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICBsZXQgcGF5bG9hZCA9IHJlc3BvbnNlLmRhdGEgYXMgQXJyYXlCdWZmZXI7XG4gICAgICAgICAgaWYgKGNvbnRleHQucmVzZXRJViAmJiBmcmFnLmRlY3J5cHRkYXRhKSB7XG4gICAgICAgICAgICBmcmFnLmRlY3J5cHRkYXRhLml2ID0gbmV3IFVpbnQ4QXJyYXkocGF5bG9hZC5zbGljZSgwLCAxNikpO1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuc2xpY2UoMTYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiB7IHVybCwgZGF0YTogdW5kZWZpbmVkLCAuLi5yZXNwb25zZSB9LFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBIVFRQIEVycm9yICR7cmVzcG9uc2UuY29kZX0gJHtyZXNwb25zZS50ZXh0fWApLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignQWJvcnRlZCcpLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgVGltZW91dCBhZnRlciAke2xvYWRlckNvbmZpZy50aW1lb3V0fW1zYCksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qcm9ncmVzczogKHN0YXRzLCBjb250ZXh0LCBkYXRhLCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgICBvblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICAgICAgcGF5bG9hZDogZGF0YSBhcyBBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBsb2FkUGFydChcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBwYXJ0OiBQYXJ0LFxuICAgIG9uUHJvZ3Jlc3M6IEZyYWdtZW50TG9hZFByb2dyZXNzQ2FsbGJhY2tcbiAgKTogUHJvbWlzZTxGcmFnTG9hZGVkRGF0YT4ge1xuICAgIHRoaXMuYWJvcnQoKTtcblxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgIGNvbnN0IERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWcuZ2FwIHx8IHBhcnQuZ2FwKSB7XG4gICAgICAgIHJlamVjdChjcmVhdGVHYXBMb2FkRXJyb3IoZnJhZywgcGFydCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZXIgPVxuICAgICAgICAodGhpcy5sb2FkZXIgPVxuICAgICAgICBmcmFnLmxvYWRlciA9XG4gICAgICAgICAgRnJhZ21lbnRJTG9hZGVyXG4gICAgICAgICAgICA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKVxuICAgICAgICAgICAgOiAobmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZykgYXMgTG9hZGVyPEZyYWdtZW50TG9hZGVyQ29udGV4dD4pKTtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcsIHBhcnQpO1xuICAgICAgLy8gU2hvdWxkIHdlIGRlZmluZSBhbm90aGVyIGxvYWQgcG9saWN5IGZvciBwYXJ0cz9cbiAgICAgIGNvbnN0IGxvYWRQb2xpY3kgPSBnZXRMb2FkZXJDb25maWdXaXRob3V0UmV0aWVzKFxuICAgICAgICBjb25maWcuZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGxvYWRlckNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogMCxcbiAgICAgICAgaGlnaFdhdGVyTWFyazogTUlOX0NIVU5LX1NJWkUsXG4gICAgICB9O1xuICAgICAgLy8gQXNzaWduIHBhcnQgc3RhdHMgdG8gdGhlIGxvYWRlcidzIHN0YXRzIHJlZmVyZW5jZVxuICAgICAgcGFydC5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywge1xuICAgICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHRoaXMudXBkYXRlU3RhdHNGcm9tUGFydChmcmFnLCBwYXJ0KTtcbiAgICAgICAgICBjb25zdCBwYXJ0TG9hZGVkRGF0YTogRnJhZ0xvYWRlZERhdGEgPSB7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHJlc3BvbnNlLmRhdGEgYXMgQXJyYXlCdWZmZXIsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIG9uUHJvZ3Jlc3MocGFydExvYWRlZERhdGEpO1xuICAgICAgICAgIHJlc29sdmUocGFydExvYWRlZERhdGEpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYEhUVFAgRXJyb3IgJHtyZXNwb25zZS5jb2RlfSAke3Jlc3BvbnNlLnRleHR9YCksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIGZyYWcuc3RhdHMuYWJvcnRlZCA9IHBhcnQuc3RhdHMuYWJvcnRlZDtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignQWJvcnRlZCcpLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgVGltZW91dCBhZnRlciAke2xvYWRlckNvbmZpZy50aW1lb3V0fW1zYCksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVTdGF0c0Zyb21QYXJ0KGZyYWc6IEZyYWdtZW50LCBwYXJ0OiBQYXJ0KSB7XG4gICAgY29uc3QgZnJhZ1N0YXRzID0gZnJhZy5zdGF0cztcbiAgICBjb25zdCBwYXJ0U3RhdHMgPSBwYXJ0LnN0YXRzO1xuICAgIGNvbnN0IHBhcnRUb3RhbCA9IHBhcnRTdGF0cy50b3RhbDtcbiAgICBmcmFnU3RhdHMubG9hZGVkICs9IHBhcnRTdGF0cy5sb2FkZWQ7XG4gICAgaWYgKHBhcnRUb3RhbCkge1xuICAgICAgY29uc3QgZXN0VG90YWxQYXJ0cyA9IE1hdGgucm91bmQoZnJhZy5kdXJhdGlvbiAvIHBhcnQuZHVyYXRpb24pO1xuICAgICAgY29uc3QgZXN0TG9hZGVkUGFydHMgPSBNYXRoLm1pbihcbiAgICAgICAgTWF0aC5yb3VuZChmcmFnU3RhdHMubG9hZGVkIC8gcGFydFRvdGFsKSxcbiAgICAgICAgZXN0VG90YWxQYXJ0c1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGVzdFJlbWFpbmluZ1BhcnRzID0gZXN0VG90YWxQYXJ0cyAtIGVzdExvYWRlZFBhcnRzO1xuICAgICAgY29uc3QgZXN0UmVtYWluaW5nQnl0ZXMgPVxuICAgICAgICBlc3RSZW1haW5pbmdQYXJ0cyAqIE1hdGgucm91bmQoZnJhZ1N0YXRzLmxvYWRlZCAvIGVzdExvYWRlZFBhcnRzKTtcbiAgICAgIGZyYWdTdGF0cy50b3RhbCA9IGZyYWdTdGF0cy5sb2FkZWQgKyBlc3RSZW1haW5pbmdCeXRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1N0YXRzLnRvdGFsID0gTWF0aC5tYXgoZnJhZ1N0YXRzLmxvYWRlZCwgZnJhZ1N0YXRzLnRvdGFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJhZ0xvYWRpbmcgPSBmcmFnU3RhdHMubG9hZGluZztcbiAgICBjb25zdCBwYXJ0TG9hZGluZyA9IHBhcnRTdGF0cy5sb2FkaW5nO1xuICAgIGlmIChmcmFnTG9hZGluZy5zdGFydCkge1xuICAgICAgLy8gYWRkIHRvIGZyYWdtZW50IGxvYWRlciBsYXRlbmN5XG4gICAgICBmcmFnTG9hZGluZy5maXJzdCArPSBwYXJ0TG9hZGluZy5maXJzdCAtIHBhcnRMb2FkaW5nLnN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnTG9hZGluZy5zdGFydCA9IHBhcnRMb2FkaW5nLnN0YXJ0O1xuICAgICAgZnJhZ0xvYWRpbmcuZmlyc3QgPSBwYXJ0TG9hZGluZy5maXJzdDtcbiAgICB9XG4gICAgZnJhZ0xvYWRpbmcuZW5kID0gcGFydExvYWRpbmcuZW5kO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNldExvYWRlcihmcmFnOiBGcmFnbWVudCwgbG9hZGVyOiBMb2FkZXI8RnJhZ21lbnRMb2FkZXJDb250ZXh0Pikge1xuICAgIGZyYWcubG9hZGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5sb2FkZXIgPT09IGxvYWRlcikge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5wYXJ0TG9hZFRpbWVvdXQpO1xuICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgICBsb2FkZXIuZGVzdHJveSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvYWRlckNvbnRleHQoXG4gIGZyYWc6IEZyYWdtZW50LFxuICBwYXJ0OiBQYXJ0IHwgbnVsbCA9IG51bGxcbik6IEZyYWdtZW50TG9hZGVyQ29udGV4dCB7XG4gIGNvbnN0IHNlZ21lbnQ6IEJhc2VTZWdtZW50ID0gcGFydCB8fCBmcmFnO1xuICBjb25zdCBsb2FkZXJDb250ZXh0OiBGcmFnbWVudExvYWRlckNvbnRleHQgPSB7XG4gICAgZnJhZyxcbiAgICBwYXJ0LFxuICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICB1cmw6IHNlZ21lbnQudXJsLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgcmFuZ2VFbmQ6IDAsXG4gIH07XG4gIGNvbnN0IHN0YXJ0ID0gc2VnbWVudC5ieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgY29uc3QgZW5kID0gc2VnbWVudC5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoc3RhcnQpICYmIE51bWJlci5pc0Zpbml0ZShlbmQpKSB7XG4gICAgbGV0IGJ5dGVSYW5nZVN0YXJ0ID0gc3RhcnQ7XG4gICAgbGV0IGJ5dGVSYW5nZUVuZCA9IGVuZDtcbiAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyAmJiBmcmFnLmRlY3J5cHRkYXRhPy5tZXRob2QgPT09ICdBRVMtMTI4Jykge1xuICAgICAgLy8gTUFQIHNlZ21lbnQgZW5jcnlwdGVkIHdpdGggbWV0aG9kICdBRVMtMTI4Jywgd2hlbiBzZXJ2ZWQgd2l0aCBIVFRQIFJhbmdlLFxuICAgICAgLy8gaGFzIHRoZSB1bmVuY3J5cHRlZCBzaXplIHNwZWNpZmllZCBpbiB0aGUgcmFuZ2UuXG4gICAgICAvLyBSZWY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYW50b3MtaGxzLXJmYzgyMTZiaXMtMDgjc2VjdGlvbi02LjMuNlxuICAgICAgY29uc3QgZnJhZ21lbnRMZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgIGlmIChmcmFnbWVudExlbiAlIDE2KSB7XG4gICAgICAgIGJ5dGVSYW5nZUVuZCA9IGVuZCArICgxNiAtIChmcmFnbWVudExlbiAlIDE2KSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgIT09IDApIHtcbiAgICAgICAgbG9hZGVyQ29udGV4dC5yZXNldElWID0gdHJ1ZTtcbiAgICAgICAgYnl0ZVJhbmdlU3RhcnQgPSBzdGFydCAtIDE2O1xuICAgICAgfVxuICAgIH1cbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBieXRlUmFuZ2VTdGFydDtcbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlRW5kID0gYnl0ZVJhbmdlRW5kO1xuICB9XG4gIHJldHVybiBsb2FkZXJDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVHYXBMb2FkRXJyb3IoZnJhZzogRnJhZ21lbnQsIHBhcnQ/OiBQYXJ0KTogTG9hZEVycm9yIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEdBUCAke2ZyYWcuZ2FwID8gJ3RhZycgOiAnYXR0cmlidXRlJ30gZm91bmRgKTtcbiAgY29uc3QgZXJyb3JEYXRhOiBGcmFnTG9hZEZhaWxSZXN1bHQgPSB7XG4gICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19HQVAsXG4gICAgZmF0YWw6IGZhbHNlLFxuICAgIGZyYWcsXG4gICAgZXJyb3IsXG4gICAgbmV0d29ya0RldGFpbHM6IG51bGwsXG4gIH07XG4gIGlmIChwYXJ0KSB7XG4gICAgZXJyb3JEYXRhLnBhcnQgPSBwYXJ0O1xuICB9XG4gIChwYXJ0ID8gcGFydCA6IGZyYWcpLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICByZXR1cm4gbmV3IExvYWRFcnJvcihlcnJvckRhdGEpO1xufVxuXG5leHBvcnQgY2xhc3MgTG9hZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgZGF0YTogRnJhZ0xvYWRGYWlsUmVzdWx0O1xuICBjb25zdHJ1Y3RvcihkYXRhOiBGcmFnTG9hZEZhaWxSZXN1bHQpIHtcbiAgICBzdXBlcihkYXRhLmVycm9yLm1lc3NhZ2UpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGcmFnTG9hZEZhaWxSZXN1bHQgZXh0ZW5kcyBFcnJvckRhdGEge1xuICBmcmFnOiBGcmFnbWVudDtcbiAgcGFydD86IFBhcnQ7XG4gIHJlc3BvbnNlPzoge1xuICAgIGRhdGE6IGFueTtcbiAgICAvLyBlcnJvciBzdGF0dXMgY29kZVxuICAgIGNvZGU6IG51bWJlcjtcbiAgICAvLyBlcnJvciBkZXNjcmlwdGlvblxuICAgIHRleHQ6IHN0cmluZztcbiAgICB1cmw6IHN0cmluZztcbiAgfTtcbiAgbmV0d29ya0RldGFpbHM6IGFueTtcbn1cblxuZXhwb3J0IHR5cGUgRnJhZ21lbnRMb2FkUHJvZ3Jlc3NDYWxsYmFjayA9IChcbiAgcmVzdWx0OiBGcmFnTG9hZGVkRGF0YSB8IFBhcnRzTG9hZGVkRGF0YVxuKSA9PiB2b2lkO1xuIiwiaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7XG4gIExvYWRlclN0YXRzLFxuICBMb2FkZXJSZXNwb25zZSxcbiAgTG9hZGVyQ29uZmlndXJhdGlvbixcbiAgTG9hZGVyQ2FsbGJhY2tzLFxuICBMb2FkZXIsXG4gIEtleUxvYWRlckNvbnRleHQsXG4gIFBsYXlsaXN0TGV2ZWxUeXBlLFxufSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHsgTG9hZEVycm9yIH0gZnJvbSAnLi9mcmFnbWVudC1sb2FkZXInO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUgeyBLZXlMb2FkZWREYXRhIH0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgTGV2ZWxLZXkgfSBmcm9tICcuL2xldmVsLWtleSc7XG5pbXBvcnQgdHlwZSBFTUVDb250cm9sbGVyIGZyb20gJy4uL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgeyBNZWRpYUtleVNlc3Npb25Db250ZXh0IH0gZnJvbSAnLi4vY29udHJvbGxlci9lbWUtY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSB7IEtleVN5c3RlbUZvcm1hdHMgfSBmcm9tICcuLi91dGlscy9tZWRpYWtleXMtaGVscGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBLZXlMb2FkZXJJbmZvIHtcbiAgZGVjcnlwdGRhdGE6IExldmVsS2V5O1xuICBrZXlMb2FkUHJvbWlzZTogUHJvbWlzZTxLZXlMb2FkZWREYXRhPiB8IG51bGw7XG4gIGxvYWRlcjogTG9hZGVyPEtleUxvYWRlckNvbnRleHQ+IHwgbnVsbDtcbiAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dDogTWVkaWFLZXlTZXNzaW9uQ29udGV4dCB8IG51bGw7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlMb2FkZXIgaW1wbGVtZW50cyBDb21wb25lbnRBUEkge1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogSGxzQ29uZmlnO1xuICBwdWJsaWMga2V5VXJpVG9LZXlJbmZvOiB7IFtrZXl1cmk6IHN0cmluZ106IEtleUxvYWRlckluZm8gfSA9IHt9O1xuICBwdWJsaWMgZW1lQ29udHJvbGxlcjogRU1FQ29udHJvbGxlciB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogSGxzQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cblxuICBhYm9ydCh0eXBlPzogUGxheWxpc3RMZXZlbFR5cGUpIHtcbiAgICBmb3IgKGNvbnN0IHVyaSBpbiB0aGlzLmtleVVyaVRvS2V5SW5mbykge1xuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXS5sb2FkZXI7XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGlmICh0eXBlICYmIHR5cGUgIT09IGxvYWRlci5jb250ZXh0LmZyYWcudHlwZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgZm9yIChjb25zdCB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgIGNvbnN0IGtleUluZm8gPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgICAgLy8gUmVtb3ZlIGNhY2hlZCBFTUUga2V5cyBvbiBkZXRhY2hcbiAgICAgIGlmIChcbiAgICAgICAga2V5SW5mby5tZWRpYUtleVNlc3Npb25Db250ZXh0IHx8XG4gICAgICAgIGtleUluZm8uZGVjcnlwdGRhdGEuaXNDb21tb25FbmNyeXB0aW9uXG4gICAgICApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRldGFjaCgpO1xuICAgIGZvciAoY29uc3QgdXJpIGluIHRoaXMua2V5VXJpVG9LZXlJbmZvKSB7XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldLmxvYWRlcjtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5rZXlVcmlUb0tleUluZm8gPSB7fTtcbiAgfVxuXG4gIGNyZWF0ZUtleUxvYWRFcnJvcihcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMgPSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsXG4gICAgZXJyb3I6IEVycm9yLFxuICAgIG5ldHdvcmtEZXRhaWxzPzogYW55LFxuICAgIHJlc3BvbnNlPzogeyB1cmw6IHN0cmluZzsgZGF0YTogdW5kZWZpbmVkOyBjb2RlOiBudW1iZXI7IHRleHQ6IHN0cmluZyB9XG4gICk6IExvYWRFcnJvciB7XG4gICAgcmV0dXJuIG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlscyxcbiAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgIGZyYWcsXG4gICAgICByZXNwb25zZSxcbiAgICAgIGVycm9yLFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgfSk7XG4gIH1cblxuICBsb2FkQ2xlYXIoXG4gICAgbG9hZGluZ0ZyYWc6IEZyYWdtZW50LFxuICAgIGVuY3J5cHRlZEZyYWdtZW50czogRnJhZ21lbnRbXVxuICApOiB2b2lkIHwgUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICAvLyBhY2Nlc3Mga2V5LXN5c3RlbSB3aXRoIG5lYXJlc3Qga2V5IG9uIHN0YXJ0IChsb2FpZG5nIGZyYWcgaXMgdW5lbmNyeXB0ZWQpXG4gICAgICBjb25zdCB7IHNuLCBjYyB9ID0gbG9hZGluZ0ZyYWc7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmcmFnID0gZW5jcnlwdGVkRnJhZ21lbnRzW2ldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY2MgPD0gZnJhZy5jYyAmJlxuICAgICAgICAgIChzbiA9PT0gJ2luaXRTZWdtZW50JyB8fCBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnIHx8IHNuIDwgZnJhZy5zbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5lbWVDb250cm9sbGVyXG4gICAgICAgICAgICAuc2VsZWN0S2V5U3lzdGVtRm9ybWF0KGZyYWcpXG4gICAgICAgICAgICAudGhlbigoa2V5U3lzdGVtRm9ybWF0KSA9PiB7XG4gICAgICAgICAgICAgIGZyYWcuc2V0S2V5Rm9ybWF0KGtleVN5c3RlbUZvcm1hdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvYWQoZnJhZzogRnJhZ21lbnQpOiBQcm9taXNlPEtleUxvYWRlZERhdGE+IHtcbiAgICBpZiAoIWZyYWcuZGVjcnlwdGRhdGEgJiYgZnJhZy5lbmNyeXB0ZWQgJiYgdGhpcy5lbWVDb250cm9sbGVyKSB7XG4gICAgICAvLyBNdWx0aXBsZSBrZXlzLCBidXQgbm9uZSBzZWxlY3RlZCwgcmVzb2x2ZSBpbiBlbWUtY29udHJvbGxlclxuICAgICAgcmV0dXJuIHRoaXMuZW1lQ29udHJvbGxlclxuICAgICAgICAuc2VsZWN0S2V5U3lzdGVtRm9ybWF0KGZyYWcpXG4gICAgICAgIC50aGVuKChrZXlTeXN0ZW1Gb3JtYXQpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkSW50ZXJuYWwoZnJhZywga2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubG9hZEludGVybmFsKGZyYWcpO1xuICB9XG5cbiAgbG9hZEludGVybmFsKFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIGtleVN5c3RlbUZvcm1hdD86IEtleVN5c3RlbUZvcm1hdHNcbiAgKTogUHJvbWlzZTxLZXlMb2FkZWREYXRhPiB7XG4gICAgaWYgKGtleVN5c3RlbUZvcm1hdCkge1xuICAgICAgZnJhZy5zZXRLZXlGb3JtYXQoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgIGlmICghZGVjcnlwdGRhdGEpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBrZXlTeXN0ZW1Gb3JtYXRcbiAgICAgICAgICA/IGBFeHBlY3RlZCBmcmFnLmRlY3J5cHRkYXRhIHRvIGJlIGRlZmluZWQgYWZ0ZXIgc2V0dGluZyBmb3JtYXQgJHtrZXlTeXN0ZW1Gb3JtYXR9YFxuICAgICAgICAgIDogJ01pc3NpbmcgZGVjcnlwdGlvbiBkYXRhIG9uIGZyYWdtZW50IGluIG9uS2V5TG9hZGluZydcbiAgICAgICk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgZXJyb3IpXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgaWYgKCF1cmkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgdGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsXG4gICAgICAgICAgbmV3IEVycm9yKGBJbnZhbGlkIGtleSBVUkk6IFwiJHt1cml9XCJgKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQga2V5SW5mbyA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG5cbiAgICBpZiAoa2V5SW5mbz8uZGVjcnlwdGRhdGEua2V5KSB7XG4gICAgICBkZWNyeXB0ZGF0YS5rZXkgPSBrZXlJbmZvLmRlY3J5cHRkYXRhLmtleTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBmcmFnLCBrZXlJbmZvIH0pO1xuICAgIH1cbiAgICAvLyBSZXR1cm4ga2V5IGxvYWQgcHJvbWlzZSBhcyBsb25nIGFzIGl0IGRvZXMgbm90IGhhdmUgYSBtZWRpYWtleSBzZXNzaW9uIHdpdGggYW4gdW51c2FibGUga2V5IHN0YXR1c1xuICAgIGlmIChrZXlJbmZvPy5rZXlMb2FkUHJvbWlzZSkge1xuICAgICAgc3dpdGNoIChrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQ/LmtleVN0YXR1cykge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnc3RhdHVzLXBlbmRpbmcnOlxuICAgICAgICBjYXNlICd1c2FibGUnOlxuICAgICAgICBjYXNlICd1c2FibGUtaW4tZnV0dXJlJzpcbiAgICAgICAgICByZXR1cm4ga2V5SW5mby5rZXlMb2FkUHJvbWlzZS50aGVuKChrZXlMb2FkZWREYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGNvcnJlY3QgZnJhZ21lbnQgd2l0aCB1cGRhdGVkIGRlY3J5cHRkYXRhIGtleSBhbmQgbG9hZGVkIGtleUluZm9cbiAgICAgICAgICAgIGRlY3J5cHRkYXRhLmtleSA9IGtleUxvYWRlZERhdGEua2V5SW5mby5kZWNyeXB0ZGF0YS5rZXk7XG4gICAgICAgICAgICByZXR1cm4geyBmcmFnLCBrZXlJbmZvIH07XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEga2V5IHNlc3Npb24gYW5kIHN0YXR1cyBhbmQgaXQgaXMgbm90IHBlbmRpbmcgb3IgdXNhYmxlLCBjb250aW51ZVxuICAgICAgLy8gVGhpcyB3aWxsIGdvIGJhY2sgdG8gdGhlIGVtZS1jb250cm9sbGVyIGZvciBleHBpcmVkIGtleXMgdG8gZ2V0IGEgbmV3IGtleUxvYWRQcm9taXNlXG4gICAgfVxuXG4gICAgLy8gTG9hZCB0aGUga2V5IG9yIHJldHVybiB0aGUgbG9hZGluZyBwcm9taXNlXG4gICAga2V5SW5mbyA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0gPSB7XG4gICAgICBkZWNyeXB0ZGF0YSxcbiAgICAgIGtleUxvYWRQcm9taXNlOiBudWxsLFxuICAgICAgbG9hZGVyOiBudWxsLFxuICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dDogbnVsbCxcbiAgICB9O1xuXG4gICAgc3dpdGNoIChkZWNyeXB0ZGF0YS5tZXRob2QpIHtcbiAgICAgIGNhc2UgJ0lTTy0yMzAwMS03JzpcbiAgICAgIGNhc2UgJ1NBTVBMRS1BRVMnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUy1DRU5DJzpcbiAgICAgIGNhc2UgJ1NBTVBMRS1BRVMtQ1RSJzpcbiAgICAgICAgaWYgKGRlY3J5cHRkYXRhLmtleUZvcm1hdCA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgIC8vIGxvYWRLZXlIVFRQIGhhbmRsZXMgaHR0cChzKSBhbmQgZGF0YSBVUkxzXG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEtleUhUVFAoa2V5SW5mbywgZnJhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZEtleUVNRShrZXlJbmZvLCBmcmFnKTtcbiAgICAgIGNhc2UgJ0FFUy0xMjgnOlxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICB0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBLZXkgc3VwcGxpZWQgd2l0aCB1bnN1cHBvcnRlZCBNRVRIT0Q6IFwiJHtkZWNyeXB0ZGF0YS5tZXRob2R9XCJgXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGxvYWRLZXlFTUUoa2V5SW5mbzogS2V5TG9hZGVySW5mbywgZnJhZzogRnJhZ21lbnQpOiBQcm9taXNlPEtleUxvYWRlZERhdGE+IHtcbiAgICBjb25zdCBrZXlMb2FkZWREYXRhOiBLZXlMb2FkZWREYXRhID0geyBmcmFnLCBrZXlJbmZvIH07XG4gICAgaWYgKHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICBjb25zdCBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UgPVxuICAgICAgICB0aGlzLmVtZUNvbnRyb2xsZXIubG9hZEtleShrZXlMb2FkZWREYXRhKTtcbiAgICAgIGlmIChrZXlTZXNzaW9uQ29udGV4dFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIChrZXlJbmZvLmtleUxvYWRQcm9taXNlID0ga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlLnRoZW4oXG4gICAgICAgICAgKGtleVNlc3Npb25Db250ZXh0KSA9PiB7XG4gICAgICAgICAgICBrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPSBrZXlTZXNzaW9uQ29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiBrZXlMb2FkZWREYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgKSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHByb21pc2UgZm9yIGxpY2Vuc2UgcmVuZXdhbCBvciByZXRyeVxuICAgICAgICAgIGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXlMb2FkZWREYXRhKTtcbiAgfVxuXG4gIGxvYWRLZXlIVFRQKGtleUluZm86IEtleUxvYWRlckluZm8sIGZyYWc6IEZyYWdtZW50KTogUHJvbWlzZTxLZXlMb2FkZWREYXRhPiB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBrZXlMb2FkZXIgPSBuZXcgTG9hZGVyKGNvbmZpZykgYXMgTG9hZGVyPEtleUxvYWRlckNvbnRleHQ+O1xuICAgIGZyYWcua2V5TG9hZGVyID0ga2V5SW5mby5sb2FkZXIgPSBrZXlMb2FkZXI7XG5cbiAgICByZXR1cm4gKGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBsb2FkZXJDb250ZXh0OiBLZXlMb2FkZXJDb250ZXh0ID0ge1xuICAgICAgICBrZXlJbmZvLFxuICAgICAgICBmcmFnLFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgICAgIHVybDoga2V5SW5mby5kZWNyeXB0ZGF0YS51cmksXG4gICAgICB9O1xuXG4gICAgICAvLyBtYXhSZXRyeSBpcyAwIHNvIHRoYXQgaW5zdGVhZCBvZiByZXRyeWluZyB0aGUgc2FtZSBrZXkgb24gdGhlIHNhbWUgdmFyaWFudCBtdWx0aXBsZSB0aW1lcyxcbiAgICAgIC8vIGtleS1sb2FkZXIgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGFuZCByZWx5IG9uIHN0cmVhbS1jb250cm9sbGVyIHRvIGhhbmRsZSByZXRyeSBsb2dpYy5cbiAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIGFsaWduIHJldHJ5IGxvZ2ljIHdpdGggZnJhZ21lbnQtbG9hZGVyXG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gY29uZmlnLmtleUxvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICAgIGNvbnN0IGxvYWRlckNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogMCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGxvYWRlckNhbGxiYWNrczogTG9hZGVyQ2FsbGJhY2tzPEtleUxvYWRlckNvbnRleHQ+ID0ge1xuICAgICAgICBvblN1Y2Nlc3M6IChcbiAgICAgICAgICByZXNwb25zZTogTG9hZGVyUmVzcG9uc2UsXG4gICAgICAgICAgc3RhdHM6IExvYWRlclN0YXRzLFxuICAgICAgICAgIGNvbnRleHQ6IEtleUxvYWRlckNvbnRleHQsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHM6IGFueVxuICAgICAgICApID0+IHtcbiAgICAgICAgICBjb25zdCB7IGZyYWcsIGtleUluZm8sIHVybDogdXJpIH0gPSBjb250ZXh0O1xuICAgICAgICAgIGlmICghZnJhZy5kZWNyeXB0ZGF0YSB8fCBrZXlJbmZvICE9PSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihcbiAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUixcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoJ2FmdGVyIGtleSBsb2FkLCBkZWNyeXB0ZGF0YSB1bnNldCBvciBjaGFuZ2VkJyksXG4gICAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBrZXlJbmZvLmRlY3J5cHRkYXRhLmtleSA9IGZyYWcuZGVjcnlwdGRhdGEua2V5ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICByZXNwb25zZS5kYXRhIGFzIEFycmF5QnVmZmVyXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIGRldGFjaCBmcmFnbWVudCBrZXkgbG9hZGVyIG9uIGxvYWQgc3VjY2Vzc1xuICAgICAgICAgIGZyYWcua2V5TG9hZGVyID0gbnVsbDtcbiAgICAgICAgICBrZXlJbmZvLmxvYWRlciA9IG51bGw7XG4gICAgICAgICAgcmVzb2x2ZSh7IGZyYWcsIGtleUluZm8gfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FcnJvcjogKFxuICAgICAgICAgIHJlc3BvbnNlOiB7IGNvZGU6IG51bWJlcjsgdGV4dDogc3RyaW5nIH0sXG4gICAgICAgICAgY29udGV4dDogS2V5TG9hZGVyQ29udGV4dCxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogYW55LFxuICAgICAgICAgIHN0YXRzOiBMb2FkZXJTdGF0c1xuICAgICAgICApID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGNvbnRleHQpO1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKFxuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgSFRUUCBFcnJvciAke3Jlc3BvbnNlLmNvZGV9IGxvYWRpbmcga2V5ICR7cmVzcG9uc2UudGV4dH1gXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICB7IHVybDogbG9hZGVyQ29udGV4dC51cmwsIGRhdGE6IHVuZGVmaW5lZCwgLi4ucmVzcG9uc2UgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25UaW1lb3V0OiAoXG4gICAgICAgICAgc3RhdHM6IExvYWRlclN0YXRzLFxuICAgICAgICAgIGNvbnRleHQ6IEtleUxvYWRlckNvbnRleHQsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHM6IGFueVxuICAgICAgICApID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGNvbnRleHQpO1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKFxuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdrZXkgbG9hZGluZyB0aW1lZCBvdXQnKSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQWJvcnQ6IChcbiAgICAgICAgICBzdGF0czogTG9hZGVyU3RhdHMsXG4gICAgICAgICAgY29udGV4dDogS2V5TG9hZGVyQ29udGV4dCxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogYW55XG4gICAgICAgICkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgdGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoXG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIGFib3J0ZWQnKSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAga2V5TG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgIH0pKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXRMb2FkZXIoY29udGV4dDogS2V5TG9hZGVyQ29udGV4dCkge1xuICAgIGNvbnN0IHsgZnJhZywga2V5SW5mbywgdXJsOiB1cmkgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgbG9hZGVyID0ga2V5SW5mby5sb2FkZXI7XG4gICAgaWYgKGZyYWcua2V5TG9hZGVyID09PSBsb2FkZXIpIHtcbiAgICAgIGZyYWcua2V5TG9hZGVyID0gbnVsbDtcbiAgICAgIGtleUluZm8ubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGlnbm9yZVxuICogU3ViLWNsYXNzIHNwZWNpYWxpemF0aW9uIG9mIEV2ZW50SGFuZGxlciBiYXNlIGNsYXNzLlxuICpcbiAqIFRhc2tMb29wIGFsbG93cyB0byBzY2hlZHVsZSBhIHRhc2sgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIChvcHRpb25uYWx5IHJlcGVhdGVkbHkpIG9uIHRoZSBtYWluIGxvb3AsXG4gKiBzY2hlZHVsZWQgYXN5bmNocm9uZW91c2x5LCBhdm9pZGluZyByZWN1cnNpdmUgY2FsbHMgaW4gdGhlIHNhbWUgdGljay5cbiAqXG4gKiBUaGUgdGFzayBpdHNlbGYgaXMgaW1wbGVtZW50ZWQgaW4gYGRvVGlja2AuIEl0IGNhbiBiZSByZXF1ZXN0ZWQgYW5kIGNhbGxlZCBmb3Igc2luZ2xlIGV4ZWN1dGlvblxuICogdXNpbmcgdGhlIGB0aWNrYCBtZXRob2QuXG4gKlxuICogSXQgd2lsbCBiZSBhc3N1cmVkIHRoYXQgdGhlIHRhc2sgZXhlY3V0aW9uIG1ldGhvZCAoYHRpY2tgKSBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIG1haW4gbG9vcCBcInRpY2tcIixcbiAqIG5vIG1hdHRlciBob3cgb2Z0ZW4gaXQgZ2V0cyByZXF1ZXN0ZWQgZm9yIGV4ZWN1dGlvbi4gRXhlY3V0aW9uIGluIGZ1cnRoZXIgdGlja3Mgd2lsbCBiZSBzY2hlZHVsZWQgYWNjb3JkaW5nbHkuXG4gKlxuICogSWYgZnVydGhlciBleGVjdXRpb24gcmVxdWVzdHMgaGF2ZSBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkIG9uIHRoZSBuZXh0IHRpY2ssIGl0IGNhbiBiZSBjaGVja2VkIHdpdGggYGhhc05leHRUaWNrYCxcbiAqIGFuZCBjYW5jZWxsZWQgd2l0aCBgY2xlYXJOZXh0VGlja2AuXG4gKlxuICogVGhlIHRhc2sgY2FuIGJlIHNjaGVkdWxlZCBhcyBhbiBpbnRlcnZhbCByZXBlYXRlZGx5IHdpdGggYSBwZXJpb2QgYXMgcGFyYW1ldGVyIChzZWUgYHNldEludGVydmFsYCwgYGNsZWFySW50ZXJ2YWxgKS5cbiAqXG4gKiBTdWItY2xhc3NlcyBuZWVkIHRvIGltcGxlbWVudCB0aGUgYGRvVGlja2AgbWV0aG9kIHdoaWNoIHdpbGwgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgdGFzayBleGVjdXRpb24gcm91dGluZS5cbiAqXG4gKiBGdXJ0aGVyIGV4cGxhbmF0aW9uczpcbiAqXG4gKiBUaGUgYmFzZWNsYXNzIGhhcyBhIGB0aWNrYCBtZXRob2QgdGhhdCB3aWxsIHNjaGVkdWxlIHRoZSBkb1RpY2sgY2FsbC4gSXQgbWF5IGJlIGNhbGxlZCBzeW5jaHJvbmVvdXNseVxuICogb25seSBmb3IgYSBzdGFjay1kZXB0aCBvZiBvbmUuIE9uIHJlLWVudHJhbnQgY2FsbHMsIHN1Yi1zZXF1ZW50IGNhbGxzIGFyZSBzY2hlZHVsZWQgZm9yIG5leHQgbWFpbiBsb29wIHRpY2tzLlxuICpcbiAqIFdoZW4gdGhlIHRhc2sgZXhlY3V0aW9uIChgdGlja2AgbWV0aG9kKSBpcyBjYWxsZWQgaW4gcmUtZW50cmFudCB3YXkgdGhpcyBpcyBkZXRlY3RlZCBhbmRcbiAqIHdlIGFyZSBsaW1pdGluZyB0aGUgdGFzayBleGVjdXRpb24gcGVyIGNhbGwgc3RhY2sgdG8gZXhhY3RseSBvbmUsIGJ1dCBzY2hlZHVsaW5nL3Bvc3QtcG9uaW5nIGZ1cnRoZXJcbiAqIHRhc2sgcHJvY2Vzc2luZyBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIChhbHNvIGtub3duIGFzIFwibmV4dCB0aWNrXCIgaW4gdGhlIE5vZGUvSlMgcnVudGltZSBsaW5nbykuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhc2tMb29wIHtcbiAgcHJpdmF0ZSByZWFkb25seSBfYm91bmRUaWNrOiAoKSA9PiB2b2lkO1xuICBwcml2YXRlIF90aWNrVGltZXI6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF90aWNrSW50ZXJ2YWw6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF90aWNrQ2FsbENvdW50ID0gMDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9ib3VuZFRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWluZygpO1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICAvLyBjbGVhciBhbGwgdGltZXJzIGJlZm9yZSB1bnJlZ2lzdGVyaW5nIGZyb20gZXZlbnQgYnVzXG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25IYW5kbGVyRGVzdHJveWVkKCkge31cblxuICBwdWJsaWMgaGFzSW50ZXJ2YWwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja0ludGVydmFsO1xuICB9XG5cbiAgcHVibGljIGhhc05leHRUaWNrKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuX3RpY2tUaW1lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gbWlsbGlzIC0gSW50ZXJ2YWwgdGltZSAobXMpXG4gICAqIEBldHVybnMgVHJ1ZSB3aGVuIGludGVydmFsIGhhcyBiZWVuIHNjaGVkdWxlZCwgZmFsc2Ugd2hlbiBhbHJlYWR5IHNjaGVkdWxlZCAobm8gZWZmZWN0KVxuICAgKi9cbiAgcHVibGljIHNldEludGVydmFsKG1pbGxpczogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLl9ib3VuZFRpY2ssIG1pbGxpcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFRydWUgd2hlbiBpbnRlcnZhbCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIHB1YmxpYyBjbGVhckludGVydmFsKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLl90aWNrSW50ZXJ2YWwpO1xuICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgVHJ1ZSB3aGVuIHRpbWVvdXQgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAqL1xuICBwdWJsaWMgY2xlYXJOZXh0VGljaygpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5fdGlja1RpbWVyKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLl90aWNrVGltZXIpO1xuICAgICAgdGhpcy5fdGlja1RpbWVyID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBjYWxsIHRoZSBzdWJjbGFzcyBkb1RpY2sgaW1wbGVtZW50YXRpb24gaW4gdGhpcyBtYWluIGxvb3AgdGlja1xuICAgKiBvciBpbiB0aGUgbmV4dCBvbmUgKHZpYSBzZXRUaW1lb3V0KCwwKSkgaW4gY2FzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFxuICAgKiBpbiB0aGlzIHRpY2sgKGluIGNhc2UgdGhpcyBpcyBhIHJlLWVudHJhbnQgY2FsbCkuXG4gICAqL1xuICBwdWJsaWMgdGljaygpOiB2b2lkIHtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50Kys7XG4gICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPT09IDEpIHtcbiAgICAgIHRoaXMuZG9UaWNrKCk7XG4gICAgICAvLyByZS1lbnRyYW50IGNhbGwgdG8gdGljayBmcm9tIHByZXZpb3VzIGRvVGljayBjYWxsIHN0YWNrXG4gICAgICAvLyAtPiBzY2hlZHVsZSBhIGNhbGwgb24gdGhlIG5leHQgbWFpbiBsb29wIGl0ZXJhdGlvbiB0byBwcm9jZXNzIHRoaXMgdGFzayBwcm9jZXNzaW5nIHJlcXVlc3RcbiAgICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID4gMSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgb25seSBvbmUgdGltZXIgZXhpc3RzIGF0IGFueSB0aW1lIGF0IG1heFxuICAgICAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB0aWNrSW1tZWRpYXRlKCk6IHZvaWQge1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuX3RpY2tUaW1lciA9IHNlbGYuc2V0VGltZW91dCh0aGlzLl9ib3VuZFRpY2ssIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBzdWJjbGFzcyB0byBpbXBsZW1lbnQgdGFzayBsb2dpY1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIHByb3RlY3RlZCBkb1RpY2soKTogdm9pZCB7fVxufVxuIiwiLyoqXG4gKiBQcm92aWRlcyBtZXRob2RzIGRlYWxpbmcgd2l0aCBidWZmZXIgbGVuZ3RoIHJldHJpZXZhbCBmb3IgZXhhbXBsZS5cbiAqXG4gKiBJbiBnZW5lcmFsLCBhIGhlbHBlciBhcm91bmQgSFRNTDUgTWVkaWFFbGVtZW50IFRpbWVSYW5nZXMgZ2F0aGVyZWQgZnJvbSBgYnVmZmVyZWRgIHByb3BlcnR5LlxuICpcbiAqIEFsc28gQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9idWZmZXJlZFxuICovXG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyJztcblxudHlwZSBCdWZmZXJUaW1lUmFuZ2UgPSB7XG4gIHN0YXJ0OiBudW1iZXI7XG4gIGVuZDogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgQnVmZmVyYWJsZSA9IHtcbiAgYnVmZmVyZWQ6IFRpbWVSYW5nZXM7XG59O1xuXG5leHBvcnQgdHlwZSBCdWZmZXJJbmZvID0ge1xuICBsZW46IG51bWJlcjtcbiAgc3RhcnQ6IG51bWJlcjtcbiAgZW5kOiBudW1iZXI7XG4gIG5leHRTdGFydD86IG51bWJlcjtcbn07XG5cbmNvbnN0IG5vb3BCdWZmZXJlZDogVGltZVJhbmdlcyA9IHtcbiAgbGVuZ3RoOiAwLFxuICBzdGFydDogKCkgPT4gMCxcbiAgZW5kOiAoKSA9PiAwLFxufTtcblxuZXhwb3J0IGNsYXNzIEJ1ZmZlckhlbHBlciB7XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBgbWVkaWFgJ3MgYnVmZmVyZWQgaW5jbHVkZSBgcG9zaXRpb25gXG4gICAqL1xuICBzdGF0aWMgaXNCdWZmZXJlZChtZWRpYTogQnVmZmVyYWJsZSwgcG9zaXRpb246IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1ZmZlcmVkLnN0YXJ0KGkpICYmIHBvc2l0aW9uIDw9IGJ1ZmZlcmVkLmVuZChpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBidWZmZXJJbmZvKFxuICAgIG1lZGlhOiBCdWZmZXJhYmxlIHwgbnVsbCxcbiAgICBwb3M6IG51bWJlcixcbiAgICBtYXhIb2xlRHVyYXRpb246IG51bWJlclxuICApOiBCdWZmZXJJbmZvIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGNvbnN0IHZidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkOiBCdWZmZXJUaW1lUmFuZ2VbXSA9IFtdO1xuICAgICAgICBsZXQgaTogbnVtYmVyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyZWQucHVzaCh7IHN0YXJ0OiB2YnVmZmVyZWQuc3RhcnQoaSksIGVuZDogdmJ1ZmZlcmVkLmVuZChpKSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyB0aGlzIGlzIHRvIGNhdGNoXG4gICAgICAvLyBJbnZhbGlkU3RhdGVFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdidWZmZXJlZCcgcHJvcGVydHkgZnJvbSAnU291cmNlQnVmZmVyJzpcbiAgICAgIC8vIFRoaXMgU291cmNlQnVmZmVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IG1lZGlhIHNvdXJjZVxuICAgIH1cbiAgICByZXR1cm4geyBsZW46IDAsIHN0YXJ0OiBwb3MsIGVuZDogcG9zLCBuZXh0U3RhcnQ6IHVuZGVmaW5lZCB9O1xuICB9XG5cbiAgc3RhdGljIGJ1ZmZlcmVkSW5mbyhcbiAgICBidWZmZXJlZDogQnVmZmVyVGltZVJhbmdlW10sXG4gICAgcG9zOiBudW1iZXIsXG4gICAgbWF4SG9sZUR1cmF0aW9uOiBudW1iZXJcbiAgKToge1xuICAgIGxlbjogbnVtYmVyO1xuICAgIHN0YXJ0OiBudW1iZXI7XG4gICAgZW5kOiBudW1iZXI7XG4gICAgbmV4dFN0YXJ0PzogbnVtYmVyO1xuICB9IHtcbiAgICBwb3MgPSBNYXRoLm1heCgwLCBwb3MpO1xuICAgIC8vIHNvcnQgb24gYnVmZmVyLnN0YXJ0L3NtYWxsZXIgZW5kIChJRSBkb2VzIG5vdCBhbHdheXMgcmV0dXJuIHNvcnRlZCBidWZmZXJlZCByYW5nZSlcbiAgICBidWZmZXJlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBjb25zdCBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLmVuZCAtIGEuZW5kO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IGJ1ZmZlcmVkMjogQnVmZmVyVGltZVJhbmdlW10gPSBbXTtcbiAgICBpZiAobWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAvLyB0aGVyZSBtaWdodCBiZSBzb21lIHNtYWxsIGhvbGVzIGJldHdlZW4gYnVmZmVyIHRpbWUgcmFuZ2VcbiAgICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnVmMmxlbiA9IGJ1ZmZlcmVkMi5sZW5ndGg7XG4gICAgICAgIGlmIChidWYybGVuKSB7XG4gICAgICAgICAgY29uc3QgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xuICAgICAgICAgIC8vIGlmIHNtYWxsIGhvbGUgKHZhbHVlIGJldHdlZW4gMCBvciBtYXhIb2xlRHVyYXRpb24gKSBvciBvdmVybGFwcGluZyAobmVnYXRpdmUpXG4gICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLnN0YXJ0IC0gYnVmMmVuZCA8IG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gbWVyZ2Ugb3ZlcmxhcHBpbmcgdGltZSByYW5nZXNcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0UmFuZ2UuZW5kIG9ubHkgaWYgc21hbGxlciB0aGFuIGl0ZW0uZW5kXG4gICAgICAgICAgICAvLyBlLmcuICBbIDEsIDE1XSB3aXRoICBbIDIsOF0gPT4gWyAxLDE1XSAobm8gbmVlZCB0byBtb2RpZnkgbGFzdFJhbmdlLmVuZClcbiAgICAgICAgICAgIC8vIHdoZXJlYXMgWyAxLCA4XSB3aXRoICBbIDIsMTVdID0+IFsgMSwxNV0gKCBsYXN0UmFuZ2Ugc2hvdWxkIHN3aXRjaCBmcm9tIFsxLDhdIHRvIFsxLDE1XSlcbiAgICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5lbmQgPiBidWYyZW5kKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kID0gYnVmZmVyZWRbaV0uZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBiaWcgaG9sZVxuICAgICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaXJzdCB2YWx1ZVxuICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJlZDIgPSBidWZmZXJlZDtcbiAgICB9XG5cbiAgICBsZXQgYnVmZmVyTGVuID0gMDtcblxuICAgIC8vIGJ1ZmZlclN0YXJ0TmV4dCBjYW4gcG9zc2libHkgYmUgdW5kZWZpbmVkIGJhc2VkIG9uIHRoZSBjb25kaXRpb25hbCBsb2dpYyBiZWxvd1xuICAgIGxldCBidWZmZXJTdGFydE5leHQ6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAgIC8vIGJ1ZmZlclN0YXJ0IGFuZCBidWZmZXJFbmQgYXJlIGJ1ZmZlciBib3VuZGFyaWVzIGFyb3VuZCBjdXJyZW50IHZpZGVvIHBvc2l0aW9uXG4gICAgbGV0IGJ1ZmZlclN0YXJ0OiBudW1iZXIgPSBwb3M7XG4gICAgbGV0IGJ1ZmZlckVuZDogbnVtYmVyID0gcG9zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGJ1ZmZlcmVkMltpXS5zdGFydDtcbiAgICAgIGNvbnN0IGVuZCA9IGJ1ZmZlcmVkMltpXS5lbmQ7XG4gICAgICAvLyBsb2dnZXIubG9nKCdidWYgc3RhcnQvZW5kOicgKyBidWZmZXJlZC5zdGFydChpKSArICcvJyArIGJ1ZmZlcmVkLmVuZChpKSk7XG4gICAgICBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uID49IHN0YXJ0ICYmIHBvcyA8IGVuZCkge1xuICAgICAgICAvLyBwbGF5IHBvc2l0aW9uIGlzIGluc2lkZSB0aGlzIGJ1ZmZlciBUaW1lUmFuZ2UsIHJldHJpZXZlIGVuZCBvZiBidWZmZXIgcG9zaXRpb24gYW5kIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgYnVmZmVyU3RhcnQgPSBzdGFydDtcbiAgICAgICAgYnVmZmVyRW5kID0gZW5kO1xuICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJFbmQgLSBwb3M7XG4gICAgICB9IGVsc2UgaWYgKHBvcyArIG1heEhvbGVEdXJhdGlvbiA8IHN0YXJ0KSB7XG4gICAgICAgIGJ1ZmZlclN0YXJ0TmV4dCA9IHN0YXJ0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbjogYnVmZmVyTGVuLFxuICAgICAgc3RhcnQ6IGJ1ZmZlclN0YXJ0IHx8IDAsXG4gICAgICBlbmQ6IGJ1ZmZlckVuZCB8fCAwLFxuICAgICAgbmV4dFN0YXJ0OiBidWZmZXJTdGFydE5leHQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYWZlIG1ldGhvZCB0byBnZXQgYnVmZmVyZWQgcHJvcGVydHkuXG4gICAqIFNvdXJjZUJ1ZmZlci5idWZmZXJlZCBtYXkgdGhyb3cgaWYgU291cmNlQnVmZmVyIGlzIHJlbW92ZWQgZnJvbSBpdCdzIE1lZGlhU291cmNlXG4gICAqL1xuICBzdGF0aWMgZ2V0QnVmZmVyZWQobWVkaWE6IEJ1ZmZlcmFibGUpOiBUaW1lUmFuZ2VzIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1lZGlhLmJ1ZmZlcmVkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2ZhaWxlZCB0byBnZXQgbWVkaWEuYnVmZmVyZWQnLCBlKTtcbiAgICAgIHJldHVybiBub29wQnVmZmVyZWQ7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJlbXV4ZXJSZXN1bHQgfSBmcm9tICcuL3JlbXV4ZXInO1xuaW1wb3J0IHR5cGUgeyBIbHNDaHVua1BlcmZvcm1hbmNlVGltaW5nIH0gZnJvbSAnLi9sb2FkZXInO1xuaW1wb3J0IHR5cGUgeyBTb3VyY2VCdWZmZXJOYW1lIH0gZnJvbSAnLi9idWZmZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbXV4ZXJSZXN1bHQge1xuICByZW11eFJlc3VsdDogUmVtdXhlclJlc3VsdDtcbiAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhO1xufVxuXG5leHBvcnQgY2xhc3MgQ2h1bmtNZXRhZGF0YSB7XG4gIHB1YmxpYyByZWFkb25seSBsZXZlbDogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgc246IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IHBhcnQ6IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IGlkOiBudW1iZXI7XG4gIHB1YmxpYyByZWFkb25seSBzaXplOiBudW1iZXI7XG4gIHB1YmxpYyByZWFkb25seSBwYXJ0aWFsOiBib29sZWFuO1xuICBwdWJsaWMgcmVhZG9ubHkgdHJhbnNtdXhpbmc6IEhsc0NodW5rUGVyZm9ybWFuY2VUaW1pbmcgPVxuICAgIGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCk7XG4gIHB1YmxpYyByZWFkb25seSBidWZmZXJpbmc6IHtcbiAgICBba2V5IGluIFNvdXJjZUJ1ZmZlck5hbWVdOiBIbHNDaHVua1BlcmZvcm1hbmNlVGltaW5nO1xuICB9ID0ge1xuICAgIGF1ZGlvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgIHZpZGVvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgIGF1ZGlvdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCksXG4gIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbGV2ZWw6IG51bWJlcixcbiAgICBzbjogbnVtYmVyLFxuICAgIGlkOiBudW1iZXIsXG4gICAgc2l6ZSA9IDAsXG4gICAgcGFydCA9IC0xLFxuICAgIHBhcnRpYWwgPSBmYWxzZVxuICApIHtcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgdGhpcy5zbiA9IHNuO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgdGhpcy5wYXJ0aWFsID0gcGFydGlhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpOiBIbHNDaHVua1BlcmZvcm1hbmNlVGltaW5nIHtcbiAgcmV0dXJuIHsgc3RhcnQ6IDAsIGV4ZWN1dGVTdGFydDogMCwgZXhlY3V0ZUVuZDogMCwgZW5kOiAwIH07XG59XG4iLCJpbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBhZGp1c3RTbGlkaW5nIH0gZnJvbSAnLi4vY29udHJvbGxlci9sZXZlbC1oZWxwZXInO1xuXG5pbXBvcnQgdHlwZSB7IEZyYWdtZW50IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB0eXBlIHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWRldGFpbHMnO1xuaW1wb3J0IHR5cGUgeyBMZXZlbCB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB0eXBlIHsgUmVxdWlyZWRQcm9wZXJ0aWVzIH0gZnJvbSAnLi4vdHlwZXMvZ2VuZXJhbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50czogRnJhZ21lbnRbXSwgY2M6IG51bWJlcikge1xuICBsZXQgZmlyc3RGcmFnOiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50RnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICBpZiAoY3VycmVudEZyYWcgJiYgY3VycmVudEZyYWcuY2MgPT09IGNjKSB7XG4gICAgICBmaXJzdEZyYWcgPSBjdXJyZW50RnJhZztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaXJzdEZyYWc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzKFxuICBsYXN0RnJhZzogRnJhZ21lbnQgfCBudWxsLFxuICBsYXN0TGV2ZWw6IExldmVsLFxuICBkZXRhaWxzOiBMZXZlbERldGFpbHNcbik6IGxhc3RMZXZlbCBpcyBSZXF1aXJlZFByb3BlcnRpZXM8TGV2ZWwsICdkZXRhaWxzJz4ge1xuICBpZiAobGFzdExldmVsLmRldGFpbHMpIHtcbiAgICBpZiAoXG4gICAgICBkZXRhaWxzLmVuZENDID4gZGV0YWlscy5zdGFydENDIHx8XG4gICAgICAobGFzdEZyYWcgJiYgbGFzdEZyYWcuY2MgPCBkZXRhaWxzLnN0YXJ0Q0MpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBGaW5kIHRoZSBmaXJzdCBmcmFnIGluIHRoZSBwcmV2aW91cyBsZXZlbCB3aGljaCBtYXRjaGVzIHRoZSBDQyBvZiB0aGUgZmlyc3QgZnJhZyBvZiB0aGUgbmV3IGxldmVsXG5leHBvcnQgZnVuY3Rpb24gZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnKFxuICBwcmV2RGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICBjdXJEZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIHJlZmVyZW5jZUluZGV4OiBudW1iZXIgPSAwXG4pIHtcbiAgY29uc3QgcHJldkZyYWdzID0gcHJldkRldGFpbHMuZnJhZ21lbnRzO1xuICBjb25zdCBjdXJGcmFncyA9IGN1ckRldGFpbHMuZnJhZ21lbnRzO1xuXG4gIGlmICghY3VyRnJhZ3MubGVuZ3RoIHx8ICFwcmV2RnJhZ3MubGVuZ3RoKSB7XG4gICAgbG9nZ2VyLmxvZygnTm8gZnJhZ21lbnRzIHRvIGFsaWduJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcHJldlN0YXJ0RnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MocHJldkZyYWdzLCBjdXJGcmFnc1swXS5jYyk7XG5cbiAgaWYgKCFwcmV2U3RhcnRGcmFnIHx8IChwcmV2U3RhcnRGcmFnICYmICFwcmV2U3RhcnRGcmFnLnN0YXJ0UFRTKSkge1xuICAgIGxvZ2dlci5sb2coJ05vIGZyYWcgaW4gcHJldmlvdXMgbGV2ZWwgdG8gYWxpZ24gb24nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gcHJldlN0YXJ0RnJhZztcbn1cblxuZnVuY3Rpb24gYWRqdXN0RnJhZ21lbnRTdGFydChmcmFnOiBGcmFnbWVudCwgc2xpZGluZzogbnVtYmVyKSB7XG4gIGlmIChmcmFnKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBmcmFnLnN0YXJ0ICsgc2xpZGluZztcbiAgICBmcmFnLnN0YXJ0ID0gZnJhZy5zdGFydFBUUyA9IHN0YXJ0O1xuICAgIGZyYWcuZW5kUFRTID0gc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RTbGlkaW5nU3RhcnQoc2xpZGluZzogbnVtYmVyLCBkZXRhaWxzOiBMZXZlbERldGFpbHMpIHtcbiAgLy8gVXBkYXRlIHNlZ21lbnRzXG4gIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYWRqdXN0RnJhZ21lbnRTdGFydChmcmFnbWVudHNbaV0sIHNsaWRpbmcpO1xuICB9XG4gIC8vIFVwZGF0ZSBMTC1ITFMgcGFydHMgYXQgdGhlIGVuZCBvZiB0aGUgcGxheWxpc3RcbiAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgYWRqdXN0RnJhZ21lbnRTdGFydChkZXRhaWxzLmZyYWdtZW50SGludCwgc2xpZGluZyk7XG4gIH1cbiAgZGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG59XG5cbi8qKlxuICogVXNpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGxhc3QgbGV2ZWwsIHRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgUFRTJyBvZiB0aGUgbmV3IGZyYWdtZW50cyBzbyB0aGF0IHRoZXkgZm9ybSBhXG4gKiBjb250aWd1b3VzIHN0cmVhbSB3aXRoIHRoZSBsYXN0IGZyYWdtZW50cy5cbiAqIFRoZSBQVFMgb2YgYSBmcmFnbWVudCBsZXRzIEhscy5qcyBrbm93IHdoZXJlIGl0IGZpdHMgaW50byBhIHN0cmVhbSAtIGJ5IGtub3dpbmcgZXZlcnkgUFRTLCB3ZSBrbm93IHdoaWNoIGZyYWdtZW50IHRvXG4gKiBkb3dubG9hZCBhdCBhbnkgZ2l2ZW4gdGltZS4gUFRTIGlzIG5vcm1hbGx5IGNvbXB1dGVkIHdoZW4gdGhlIGZyYWdtZW50IGlzIGRlbXV4ZWQsIHNvIHRha2luZyB0aGlzIHN0ZXAgc2F2ZXMgdXMgdGltZVxuICogYW5kIGFuIGV4dHJhIGRvd25sb2FkLlxuICogQHBhcmFtIGxhc3RGcmFnXG4gKiBAcGFyYW0gbGFzdExldmVsXG4gKiBAcGFyYW0gZGV0YWlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWxpZ25TdHJlYW0oXG4gIGxhc3RGcmFnOiBGcmFnbWVudCB8IG51bGwsXG4gIGxhc3RMZXZlbDogTGV2ZWwgfCBudWxsLFxuICBkZXRhaWxzOiBMZXZlbERldGFpbHNcbikge1xuICBpZiAoIWxhc3RMZXZlbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKTtcbiAgaWYgKCFkZXRhaWxzLmFsaWduZWRTbGlkaW5nICYmIGxhc3RMZXZlbC5kZXRhaWxzKSB7XG4gICAgLy8gSWYgdGhlIFBUUyB3YXNuJ3QgZmlndXJlZCBvdXQgdmlhIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgdGhhdCBtZWFucyB0aGVyZSB3YXMgbm8gQ0MgaW5jcmVhc2Ugd2l0aGluIHRoZSBsZXZlbC5cbiAgICAvLyBBbGlnbmluZyB2aWEgUHJvZ3JhbSBEYXRlIFRpbWUgc2hvdWxkIHRoZXJlZm9yZSBiZSByZWxpYWJsZSwgc2luY2UgUERUIHNob3VsZCBiZSB0aGUgc2FtZSB3aXRoaW4gdGhlIHNhbWVcbiAgICAvLyBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICAgIGFsaWduUERUKGRldGFpbHMsIGxhc3RMZXZlbC5kZXRhaWxzKTtcbiAgfVxuICBpZiAoXG4gICAgIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiZcbiAgICBsYXN0TGV2ZWwuZGV0YWlscyAmJlxuICAgICFkZXRhaWxzLnNraXBwZWRTZWdtZW50c1xuICApIHtcbiAgICAvLyBUcnkgdG8gYWxpZ24gb24gc24gc28gdGhhdCB3ZSBwaWNrIGEgYmV0dGVyIHN0YXJ0IGZyYWdtZW50LlxuICAgIC8vIERvIG5vdCBwZXJmb3JtIHRoaXMgb24gcGxheWxpc3RzIHdpdGggZGVsdGEgdXBkYXRlcyBhcyB0aGlzIGlzIG9ubHkgdG8gYWxpZ24gbGV2ZWxzIG9uIHN3aXRjaFxuICAgIC8vIGFuZCBhZGp1c3RTbGlkaW5nIG9ubHkgYWRqdXN0cyBmcmFnbWVudHMgYWZ0ZXIgc2tpcHBlZFNlZ21lbnRzLlxuICAgIGFkanVzdFNsaWRpbmcobGFzdExldmVsLmRldGFpbHMsIGRldGFpbHMpO1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBUUyBpZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgUFRTIG9mIGEgZnJhZ21lbnQgaW4gdGhlIGxhc3QgbGV2ZWwgd2hpY2ggc2hhcmVzIHRoZSBzYW1lXG4gKiBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICogQHBhcmFtIGxhc3RGcmFnIC0gVGhlIGxhc3QgRnJhZ21lbnQgd2hpY2ggc2hhcmVzIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2VcbiAqIEBwYXJhbSBsYXN0TGV2ZWwgLSBUaGUgZGV0YWlscyBvZiB0aGUgbGFzdCBsb2FkZWQgbGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICovXG5mdW5jdGlvbiBhbGlnbkRpc2NvbnRpbnVpdGllcyhcbiAgbGFzdEZyYWc6IEZyYWdtZW50IHwgbnVsbCxcbiAgZGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICBsYXN0TGV2ZWw6IExldmVsXG4pIHtcbiAgaWYgKHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykpIHtcbiAgICBjb25zdCByZWZlcmVuY2VGcmFnID0gZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnKFxuICAgICAgbGFzdExldmVsLmRldGFpbHMsXG4gICAgICBkZXRhaWxzXG4gICAgKTtcbiAgICBpZiAocmVmZXJlbmNlRnJhZyAmJiBOdW1iZXIuaXNGaW5pdGUocmVmZXJlbmNlRnJhZy5zdGFydCkpIHtcbiAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgIGBBZGp1c3RpbmcgUFRTIHVzaW5nIGxhc3QgbGV2ZWwgZHVlIHRvIENDIGluY3JlYXNlIHdpdGhpbiBjdXJyZW50IGxldmVsICR7ZGV0YWlscy51cmx9YFxuICAgICAgKTtcbiAgICAgIGFkanVzdFNsaWRpbmdTdGFydChyZWZlcmVuY2VGcmFnLnN0YXJ0LCBkZXRhaWxzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUFRTIG9mIGEgbmV3IGxldmVsJ3MgZnJhZ21lbnRzIHVzaW5nIHRoZSBkaWZmZXJlbmNlIGluIFByb2dyYW0gRGF0ZSBUaW1lIGZyb20gdGhlIGxhc3QgbGV2ZWwuXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqIEBwYXJhbSBsYXN0RGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBsYXN0IGxvYWRlZCBsZXZlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxpZ25QRFQoZGV0YWlsczogTGV2ZWxEZXRhaWxzLCBsYXN0RGV0YWlsczogTGV2ZWxEZXRhaWxzKSB7XG4gIC8vIFRoaXMgY2hlY2sgcHJvdGVjdHMgdGhlIHVuc2FmZSBcIiFcIiB1c2FnZSBiZWxvdyBmb3IgbnVsbCBwcm9ncmFtIGRhdGUgdGltZSBhY2Nlc3MuXG4gIGlmIChcbiAgICAhbGFzdERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCB8fFxuICAgICFkZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSB8fFxuICAgICFsYXN0RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWVcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGlmIGxhc3QgbGV2ZWwgc2xpZGluZyBpcyAxMDAwIGFuZCBpdHMgZmlyc3QgZnJhZyBQUk9HUkFNLURBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDAgQU1cbiAgLy8gYW5kIGlmIG5ldyBkZXRhaWxzIGZpcnN0IGZyYWcgUFJPR1JBTSBEQVRFLVRJTUUgaXMgMjAxNy0wOC0yMCAxOjEwOjA4IEFNXG4gIC8vIHRoZW4gd2UgY2FuIGRlZHVjZSB0aGF0IHBsYXlsaXN0IEIgc2xpZGluZyBpcyAxMDAwKzggPSAxMDA4c1xuICBjb25zdCBsYXN0UERUID0gbGFzdERldGFpbHMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZSE7IC8vIGhhc1Byb2dyYW1EYXRlVGltZSBjaGVjayBhYm92ZSBtYWtlcyB0aGlzIHNhZmUuXG4gIGNvbnN0IG5ld1BEVCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZSE7XG4gIC8vIGRhdGUgZGlmZiBpcyBpbiBtcy4gZnJhZy5zdGFydCBpcyBpbiBzZWNvbmRzXG4gIGNvbnN0IHNsaWRpbmcgPSAobmV3UERUIC0gbGFzdFBEVCkgLyAxMDAwICsgbGFzdERldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICBpZiAoc2xpZGluZyAmJiBOdW1iZXIuaXNGaW5pdGUoc2xpZGluZykpIHtcbiAgICBsb2dnZXIubG9nKFxuICAgICAgYEFkanVzdGluZyBQVFMgdXNpbmcgcHJvZ3JhbURhdGVUaW1lIGRlbHRhICR7XG4gICAgICAgIG5ld1BEVCAtIGxhc3RQRFRcbiAgICAgIH1tcywgc2xpZGluZzoke3NsaWRpbmcudG9GaXhlZCgzKX0gJHtkZXRhaWxzLnVybH0gYFxuICAgICk7XG4gICAgYWRqdXN0U2xpZGluZ1N0YXJ0KHNsaWRpbmcsIGRldGFpbHMpO1xuICB9XG59XG5cbi8qKlxuICogRW5zdXJlcyBhcHByb3ByaWF0ZSB0aW1lLWFsaWdubWVudCBiZXR3ZWVuIHJlbmRpdGlvbnMgYmFzZWQgb24gUERULiBVbmxpa2UgYGFsaWduUERUYCwgd2hpY2ggYWRqdXN0c1xuICogdGhlIHRpbWVsaW5lIGJhc2VkIG9uIHRoZSBkZWx0YSBiZXR3ZWVuIFBEVHMgb2YgdGhlIDB0aCBmcmFnbWVudCBvZiB0d28gcGxheWxpc3RzL2BMZXZlbERldGFpbHNgLFxuICogdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoZSB0aW1lbGluZXMgcmVwcmVzZW50ZWQgaW4gYHJlZkRldGFpbHNgIGFyZSBhY2N1cmF0ZSwgaW5jbHVkaW5nIHRoZSBQRFRzLFxuICogYW5kIHVzZXMgdGhlIFwid2FsbGNsb2NrXCIvUERUIHRpbWVsaW5lIGFzIGEgY3Jvc3MtcmVmZXJlbmNlIHRvIGBkZXRhaWxzYCwgYWRqdXN0aW5nIHRoZSBwcmVzZW50YXRpb25cbiAqIHRpbWVzL3RpbWVsaW5lcyBvZiBgZGV0YWlsc2AgYWNjb3JkaW5nbHkuXG4gKiBHaXZlbiB0aGUgYXN5bmNocm9ub3VzIG5hdHVyZSBvZiBmZXRjaGVzIGFuZCBpbml0aWFsIGxvYWRzIG9mIGxpdmUgYG1haW5gIGFuZCBhdWRpby9zdWJ0aXRsZSB0cmFja3MsXG4gKiB0aGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gZW5zdXJlIHRoZSBcImxvY2FsIHRpbWVsaW5lc1wiIG9mIGF1ZGlvL3N1YnRpdGxlIHRyYWNrc1xuICogYXJlIGFsaWduZWQgdG8gdGhlIG1haW4vdmlkZW8gdGltZWxpbmUsIHVzaW5nIFBEVCBhcyB0aGUgY3Jvc3MtcmVmZXJlbmNlL1wiYW5jaG9yXCIgdGhhdCBzaG91bGRcbiAqIGJlIGNvbnNpc3RlbnQgYWNyb3NzIHBsYXlsaXN0cywgcGVyIHRoZSBITFMgc3BlYy5cbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIHJlbmRpdGlvbiB5b3UnZCBsaWtlIHRvIHRpbWUtYWxpZ24gKGUuZy4gYW4gYXVkaW8gcmVuZGl0aW9uKS5cbiAqIEBwYXJhbSByZWZEZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIHJlZmVyZW5jZSByZW5kaXRpb24gd2l0aCBzdGFydCBhbmQgUERUIHRpbWVzIGZvciBhbGlnbm1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVChcbiAgZGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICByZWZEZXRhaWxzOiBMZXZlbERldGFpbHNcbikge1xuICBpZiAoIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFyZWZEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICBjb25zdCByZWZGcmFnbWVudHMgPSByZWZEZXRhaWxzLmZyYWdtZW50cztcbiAgaWYgKCFmcmFnbWVudHMubGVuZ3RoIHx8ICFyZWZGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgZGVsdGEgdG8gYXBwbHkgdG8gYWxsIGZyYWdtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGRlbHRhIGluIFBEVCB0aW1lcyBhbmQgc3RhcnQgdGltZXNcbiAgLy8gb2YgYSBmcmFnbWVudCBpbiB0aGUgcmVmZXJlbmNlIGRldGFpbHMsIGFuZCBhIGZyYWdtZW50IGluIHRoZSB0YXJnZXQgZGV0YWlscyBvZiB0aGUgc2FtZSBkaXNjb250aW51aXR5LlxuICAvLyBJZiBhIGZyYWdtZW50IG9mIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkgd2FzIG5vdCBmb3VuZCB1c2UgdGhlIG1pZGRsZSBmcmFnbWVudCBvZiBib3RoLlxuICBjb25zdCBtaWRkbGVGcmFnID0gTWF0aC5yb3VuZChyZWZGcmFnbWVudHMubGVuZ3RoIC8gMikgLSAxO1xuICBjb25zdCByZWZGcmFnID0gcmVmRnJhZ21lbnRzW21pZGRsZUZyYWddO1xuICBjb25zdCBmcmFnID1cbiAgICBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgcmVmRnJhZy5jYykgfHxcbiAgICBmcmFnbWVudHNbTWF0aC5yb3VuZChmcmFnbWVudHMubGVuZ3RoIC8gMikgLSAxXTtcblxuICBjb25zdCByZWZQRFQgPSByZWZGcmFnLnByb2dyYW1EYXRlVGltZTtcbiAgY29uc3QgdGFyZ2V0UERUID0gZnJhZy5wcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChyZWZQRFQgPT09IG51bGwgfHwgdGFyZ2V0UERUID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZGVsdGEgPSAodGFyZ2V0UERUIC0gcmVmUERUKSAvIDEwMDAgLSAoZnJhZy5zdGFydCAtIHJlZkZyYWcuc3RhcnQpO1xuICBhZGp1c3RTbGlkaW5nU3RhcnQoZGVsdGEsIGRldGFpbHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUVTQ3J5cHRvIHtcbiAgcHJpdmF0ZSBzdWJ0bGU6IFN1YnRsZUNyeXB0bztcbiAgcHJpdmF0ZSBhZXNJVjogVWludDhBcnJheTtcblxuICBjb25zdHJ1Y3RvcihzdWJ0bGU6IFN1YnRsZUNyeXB0bywgaXY6IFVpbnQ4QXJyYXkpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmFlc0lWID0gaXY7XG4gIH1cblxuICBkZWNyeXB0KGRhdGE6IEFycmF5QnVmZmVyLCBrZXk6IENyeXB0b0tleSkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHsgbmFtZTogJ0FFUy1DQkMnLCBpdjogdGhpcy5hZXNJViB9LCBrZXksIGRhdGEpO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBGYXN0QUVTS2V5IHtcbiAgcHJpdmF0ZSBzdWJ0bGU6IGFueTtcbiAgcHJpdmF0ZSBrZXk6IEFycmF5QnVmZmVyO1xuXG4gIGNvbnN0cnVjdG9yKHN1YnRsZSwga2V5KSB7XG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gIH1cblxuICBleHBhbmRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGxlLmltcG9ydEtleSgncmF3JywgdGhpcy5rZXksIHsgbmFtZTogJ0FFUy1DQkMnIH0sIGZhbHNlLCBbXG4gICAgICAnZW5jcnlwdCcsXG4gICAgICAnZGVjcnlwdCcsXG4gICAgXSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHNsaWNlVWludDggfSBmcm9tICcuLi91dGlscy90eXBlZC1hcnJheSc7XG5cbi8vIFBLQ1M3XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUGFkZGluZyhhcnJheTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBvdXRwdXRCeXRlcyA9IGFycmF5LmJ5dGVMZW5ndGg7XG4gIGNvbnN0IHBhZGRpbmdCeXRlcyA9XG4gICAgb3V0cHV0Qnl0ZXMgJiYgbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlcikuZ2V0VWludDgob3V0cHV0Qnl0ZXMgLSAxKTtcbiAgaWYgKHBhZGRpbmdCeXRlcykge1xuICAgIHJldHVybiBzbGljZVVpbnQ4KGFycmF5LCAwLCBvdXRwdXRCeXRlcyAtIHBhZGRpbmdCeXRlcyk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBRVNEZWNyeXB0b3Ige1xuICBwcml2YXRlIHJjb246IEFycmF5PG51bWJlcj4gPSBbXG4gICAgMHgwLCAweDEsIDB4MiwgMHg0LCAweDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzYsXG4gIF07XG4gIHByaXZhdGUgc3ViTWl4OiBBcnJheTxVaW50MzJBcnJheT4gPSBbXG4gICAgbmV3IFVpbnQzMkFycmF5KDI1NiksXG4gICAgbmV3IFVpbnQzMkFycmF5KDI1NiksXG4gICAgbmV3IFVpbnQzMkFycmF5KDI1NiksXG4gICAgbmV3IFVpbnQzMkFycmF5KDI1NiksXG4gIF07XG4gIHByaXZhdGUgaW52U3ViTWl4OiBBcnJheTxVaW50MzJBcnJheT4gPSBbXG4gICAgbmV3IFVpbnQzMkFycmF5KDI1NiksXG4gICAgbmV3IFVpbnQzMkFycmF5KDI1NiksXG4gICAgbmV3IFVpbnQzMkFycmF5KDI1NiksXG4gICAgbmV3IFVpbnQzMkFycmF5KDI1NiksXG4gIF07XG4gIHByaXZhdGUgc0JveDogVWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgcHJpdmF0ZSBpbnZTQm94OiBVaW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICBwcml2YXRlIGtleTogVWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoMCk7XG5cbiAgcHJpdmF0ZSBrc1Jvd3M6IG51bWJlciA9IDA7XG4gIHByaXZhdGUga2V5U2l6ZTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBrZXlTY2hlZHVsZSE6IFVpbnQzMkFycmF5O1xuICBwcml2YXRlIGludktleVNjaGVkdWxlITogVWludDMyQXJyYXk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbml0VGFibGUoKTtcbiAgfVxuXG4gIC8vIFVzaW5nIHZpZXcuZ2V0VWludDMyKCkgYWxzbyBzd2FwcyB0aGUgYnl0ZSBvcmRlci5cbiAgdWludDhBcnJheVRvVWludDMyQXJyYXlfKGFycmF5QnVmZmVyKSB7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgY29uc3QgbmV3QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIG5ld0FycmF5W2ldID0gdmlldy5nZXRVaW50MzIoaSAqIDQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfVxuXG4gIGluaXRUYWJsZSgpIHtcbiAgICBjb25zdCBzQm94ID0gdGhpcy5zQm94O1xuICAgIGNvbnN0IGludlNCb3ggPSB0aGlzLmludlNCb3g7XG4gICAgY29uc3Qgc3ViTWl4ID0gdGhpcy5zdWJNaXg7XG4gICAgY29uc3Qgc3ViTWl4MCA9IHN1Yk1peFswXTtcbiAgICBjb25zdCBzdWJNaXgxID0gc3ViTWl4WzFdO1xuICAgIGNvbnN0IHN1Yk1peDIgPSBzdWJNaXhbMl07XG4gICAgY29uc3Qgc3ViTWl4MyA9IHN1Yk1peFszXTtcbiAgICBjb25zdCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBjb25zdCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGNvbnN0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgY29uc3QgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBjb25zdCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuXG4gICAgY29uc3QgZCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeGkgPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGxldCBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuICAgICAgc0JveFt4XSA9IHN4O1xuICAgICAgaW52U0JveFtzeF0gPSB4O1xuXG4gICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG4gICAgICBjb25zdCB4MiA9IGRbeF07XG4gICAgICBjb25zdCB4NCA9IGRbeDJdO1xuICAgICAgY29uc3QgeDggPSBkW3g0XTtcblxuICAgICAgLy8gQ29tcHV0ZSBzdWIvaW52U3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgIGxldCB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcbiAgICAgIHN1Yk1peDBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gICAgICBzdWJNaXgxW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcbiAgICAgIHN1Yk1peDJbeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG4gICAgICBzdWJNaXgzW3hdID0gdDtcblxuICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xuICAgICAgaW52U3ViTWl4MFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gICAgICBpbnZTdWJNaXgxW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICBpbnZTdWJNaXgyW3N4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgICAgIGludlN1Yk1peDNbc3hdID0gdDtcblxuICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcbiAgICAgIGlmICgheCkge1xuICAgICAgICB4ID0geGkgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcbiAgICAgICAgeGkgXj0gZFtkW3hpXV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXhwYW5kS2V5KGtleUJ1ZmZlcjogQXJyYXlCdWZmZXIpIHtcbiAgICAvLyBjb252ZXJ0IGtleUJ1ZmZlciB0byBVaW50MzJBcnJheVxuICAgIGNvbnN0IGtleSA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGtleUJ1ZmZlcik7XG4gICAgbGV0IHNhbWVLZXkgPSB0cnVlO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IGtleS5sZW5ndGggJiYgc2FtZUtleSkge1xuICAgICAgc2FtZUtleSA9IGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuXG4gICAgaWYgKHNhbWVLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICBjb25zdCBrZXlTaXplID0gKHRoaXMua2V5U2l6ZSA9IGtleS5sZW5ndGgpO1xuXG4gICAgaWYgKGtleVNpemUgIT09IDQgJiYga2V5U2l6ZSAhPT0gNiAmJiBrZXlTaXplICE9PSA4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWVzIGtleSBzaXplPScgKyBrZXlTaXplKTtcbiAgICB9XG5cbiAgICBjb25zdCBrc1Jvd3MgPSAodGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQpO1xuICAgIGxldCBrc1JvdztcbiAgICBsZXQgaW52S3NSb3c7XG5cbiAgICBjb25zdCBrZXlTY2hlZHVsZSA9ICh0aGlzLmtleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cykpO1xuICAgIGNvbnN0IGludktleVNjaGVkdWxlID0gKHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKSk7XG4gICAgY29uc3Qgc2JveCA9IHRoaXMuc0JveDtcbiAgICBjb25zdCByY29uID0gdGhpcy5yY29uO1xuXG4gICAgY29uc3QgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgY29uc3QgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICBjb25zdCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGNvbnN0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgY29uc3QgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcblxuICAgIGxldCBwcmV2O1xuICAgIGxldCB0O1xuXG4gICAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgIHByZXYgPSBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlba3NSb3ddO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHQgPSBwcmV2O1xuXG4gICAgICBpZiAoa3NSb3cgJSBrZXlTaXplID09PSAwKSB7XG4gICAgICAgIC8vIFJvdCB3b3JkXG4gICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cbiAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgdCA9XG4gICAgICAgICAgKHNib3hbdCA+Pj4gMjRdIDw8IDI0KSB8XG4gICAgICAgICAgKHNib3hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgICAgKHNib3hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfFxuICAgICAgICAgIHNib3hbdCAmIDB4ZmZdO1xuXG4gICAgICAgIC8vIE1peCBSY29uXG4gICAgICAgIHQgXj0gcmNvblsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xuICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT09IDQpIHtcbiAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgdCA9XG4gICAgICAgICAgKHNib3hbdCA+Pj4gMjRdIDw8IDI0KSB8XG4gICAgICAgICAgKHNib3hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgICAgKHNib3hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfFxuICAgICAgICAgIHNib3hbdCAmIDB4ZmZdO1xuICAgICAgfVxuXG4gICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBwcmV2ID0gKGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KSA+Pj4gMDtcbiAgICB9XG5cbiAgICBmb3IgKGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcbiAgICAgIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG4gICAgICBpZiAoaW52S3NSb3cgJiAzKSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPVxuICAgICAgICAgIGludlN1Yk1peDBbc2JveFt0ID4+PiAyNF1dIF5cbiAgICAgICAgICBpbnZTdWJNaXgxW3Nib3hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeXG4gICAgICAgICAgaW52U3ViTWl4MltzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdXSBeXG4gICAgICAgICAgaW52U3ViTWl4M1tzYm94W3QgJiAweGZmXV07XG4gICAgICB9XG5cbiAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktleVNjaGVkdWxlW2ludktzUm93XSA+Pj4gMDtcbiAgICB9XG4gIH1cblxuICAvLyBBZGRpbmcgdGhpcyBhcyBhIG1ldGhvZCBncmVhdGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlLlxuICBuZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKHdvcmQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKHdvcmQgPDwgMjQpIHxcbiAgICAgICgod29yZCAmIDB4ZmYwMCkgPDwgOCkgfFxuICAgICAgKCh3b3JkICYgMHhmZjAwMDApID4+IDgpIHxcbiAgICAgICh3b3JkID4+PiAyNClcbiAgICApO1xuICB9XG5cbiAgZGVjcnlwdChpbnB1dEFycmF5QnVmZmVyOiBBcnJheUJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIsIGFlc0lWOiBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IG5Sb3VuZHMgPSB0aGlzLmtleVNpemUgKyA2O1xuICAgIGNvbnN0IGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZTtcbiAgICBjb25zdCBpbnZTQk9YID0gdGhpcy5pbnZTQm94O1xuXG4gICAgY29uc3QgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgY29uc3QgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICBjb25zdCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGNvbnN0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgY29uc3QgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcblxuICAgIGNvbnN0IGluaXRWZWN0b3IgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhZXNJVik7XG4gICAgbGV0IGluaXRWZWN0b3IwID0gaW5pdFZlY3RvclswXTtcbiAgICBsZXQgaW5pdFZlY3RvcjEgPSBpbml0VmVjdG9yWzFdO1xuICAgIGxldCBpbml0VmVjdG9yMiA9IGluaXRWZWN0b3JbMl07XG4gICAgbGV0IGluaXRWZWN0b3IzID0gaW5pdFZlY3RvclszXTtcblxuICAgIGNvbnN0IGlucHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEFycmF5QnVmZmVyKTtcbiAgICBjb25zdCBvdXRwdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0SW50MzIubGVuZ3RoKTtcblxuICAgIGxldCB0MCwgdDEsIHQyLCB0MztcbiAgICBsZXQgczAsIHMxLCBzMiwgczM7XG4gICAgbGV0IGlucHV0V29yZHMwLCBpbnB1dFdvcmRzMSwgaW5wdXRXb3JkczIsIGlucHV0V29yZHMzO1xuXG4gICAgbGV0IGtzUm93LCBpO1xuICAgIGNvbnN0IHN3YXBXb3JkID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IGlucHV0SW50MzIubGVuZ3RoKSB7XG4gICAgICBpbnB1dFdvcmRzMCA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0XSk7XG4gICAgICBpbnB1dFdvcmRzMSA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMV0pO1xuICAgICAgaW5wdXRXb3JkczIgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDJdKTtcbiAgICAgIGlucHV0V29yZHMzID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAzXSk7XG5cbiAgICAgIHMwID0gaW5wdXRXb3JkczAgXiBpbnZLZXlTY2hlZHVsZVswXTtcbiAgICAgIHMxID0gaW5wdXRXb3JkczMgXiBpbnZLZXlTY2hlZHVsZVsxXTtcbiAgICAgIHMyID0gaW5wdXRXb3JkczIgXiBpbnZLZXlTY2hlZHVsZVsyXTtcbiAgICAgIHMzID0gaW5wdXRXb3JkczEgXiBpbnZLZXlTY2hlZHVsZVszXTtcblxuICAgICAga3NSb3cgPSA0O1xuXG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvdW5kcyBvZiBkZWNyeXB0aW9uXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgblJvdW5kczsgaSsrKSB7XG4gICAgICAgIHQwID1cbiAgICAgICAgICBpbnZTdWJNaXgwW3MwID4+PiAyNF0gXlxuICAgICAgICAgIGludlN1Yk1peDFbKHMxID4+IDE2KSAmIDB4ZmZdIF5cbiAgICAgICAgICBpbnZTdWJNaXgyWyhzMiA+PiA4KSAmIDB4ZmZdIF5cbiAgICAgICAgICBpbnZTdWJNaXgzW3MzICYgMHhmZl0gXlxuICAgICAgICAgIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgdDEgPVxuICAgICAgICAgIGludlN1Yk1peDBbczEgPj4+IDI0XSBeXG4gICAgICAgICAgaW52U3ViTWl4MVsoczIgPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgIGludlN1Yk1peDJbKHMzID4+IDgpICYgMHhmZl0gXlxuICAgICAgICAgIGludlN1Yk1peDNbczAgJiAweGZmXSBeXG4gICAgICAgICAgaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgdDIgPVxuICAgICAgICAgIGludlN1Yk1peDBbczIgPj4+IDI0XSBeXG4gICAgICAgICAgaW52U3ViTWl4MVsoczMgPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgIGludlN1Yk1peDJbKHMwID4+IDgpICYgMHhmZl0gXlxuICAgICAgICAgIGludlN1Yk1peDNbczEgJiAweGZmXSBeXG4gICAgICAgICAgaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgdDMgPVxuICAgICAgICAgIGludlN1Yk1peDBbczMgPj4+IDI0XSBeXG4gICAgICAgICAgaW52U3ViTWl4MVsoczAgPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgIGludlN1Yk1peDJbKHMxID4+IDgpICYgMHhmZl0gXlxuICAgICAgICAgIGludlN1Yk1peDNbczIgJiAweGZmXSBeXG4gICAgICAgICAgaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgICAgIHMwID0gdDA7XG4gICAgICAgIHMxID0gdDE7XG4gICAgICAgIHMyID0gdDI7XG4gICAgICAgIHMzID0gdDM7XG5cbiAgICAgICAga3NSb3cgPSBrc1JvdyArIDQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuICAgICAgdDAgPVxuICAgICAgICAoaW52U0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgICAgIChpbnZTQk9YWyhzMSA+PiAxNikgJiAweGZmXSA8PCAxNikgXlxuICAgICAgICAoaW52U0JPWFsoczIgPj4gOCkgJiAweGZmXSA8PCA4KSBeXG4gICAgICAgIGludlNCT1hbczMgJiAweGZmXSBeXG4gICAgICAgIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIHQxID1cbiAgICAgICAgKGludlNCT1hbczEgPj4+IDI0XSA8PCAyNCkgXlxuICAgICAgICAoaW52U0JPWFsoczIgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF5cbiAgICAgICAgKGludlNCT1hbKHMzID4+IDgpICYgMHhmZl0gPDwgOCkgXlxuICAgICAgICBpbnZTQk9YW3MwICYgMHhmZl0gXlxuICAgICAgICBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgdDIgPVxuICAgICAgICAoaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgICAgIChpbnZTQk9YWyhzMyA+PiAxNikgJiAweGZmXSA8PCAxNikgXlxuICAgICAgICAoaW52U0JPWFsoczAgPj4gOCkgJiAweGZmXSA8PCA4KSBeXG4gICAgICAgIGludlNCT1hbczEgJiAweGZmXSBeXG4gICAgICAgIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICB0MyA9XG4gICAgICAgIChpbnZTQk9YW3MzID4+PiAyNF0gPDwgMjQpIF5cbiAgICAgICAgKGludlNCT1hbKHMwID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeXG4gICAgICAgIChpbnZTQk9YWyhzMSA+PiA4KSAmIDB4ZmZdIDw8IDgpIF5cbiAgICAgICAgaW52U0JPWFtzMiAmIDB4ZmZdIF5cbiAgICAgICAgaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcblxuICAgICAgLy8gV3JpdGVcbiAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSBzd2FwV29yZCh0MCBeIGluaXRWZWN0b3IwKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHN3YXBXb3JkKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSBzd2FwV29yZCh0MSBeIGluaXRWZWN0b3IzKTtcblxuICAgICAgLy8gcmVzZXQgaW5pdFZlY3RvciB0byBsYXN0IDQgdW5zaWduZWQgaW50XG4gICAgICBpbml0VmVjdG9yMCA9IGlucHV0V29yZHMwO1xuICAgICAgaW5pdFZlY3RvcjEgPSBpbnB1dFdvcmRzMTtcbiAgICAgIGluaXRWZWN0b3IyID0gaW5wdXRXb3JkczI7XG4gICAgICBpbml0VmVjdG9yMyA9IGlucHV0V29yZHMzO1xuXG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyA0O1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRJbnQzMi5idWZmZXI7XG4gIH1cbn1cbiIsImltcG9ydCBBRVNDcnlwdG8gZnJvbSAnLi9hZXMtY3J5cHRvJztcbmltcG9ydCBGYXN0QUVTS2V5IGZyb20gJy4vZmFzdC1hZXMta2V5JztcbmltcG9ydCBBRVNEZWNyeXB0b3IsIHsgcmVtb3ZlUGFkZGluZyB9IGZyb20gJy4vYWVzLWRlY3J5cHRvcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgYXBwZW5kVWludDhBcnJheSB9IGZyb20gJy4uL3V0aWxzL21wNC10b29scyc7XG5pbXBvcnQgeyBzbGljZVVpbnQ4IH0gZnJvbSAnLi4vdXRpbHMvdHlwZWQtYXJyYXknO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuXG5jb25zdCBDSFVOS19TSVpFID0gMTY7IC8vIDE2IGJ5dGVzLCAxMjggYml0c1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWNyeXB0ZXIge1xuICBwcml2YXRlIGxvZ0VuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICBwcml2YXRlIHJlbW92ZVBLQ1M3UGFkZGluZzogYm9vbGVhbjtcbiAgcHJpdmF0ZSBzdWJ0bGU6IFN1YnRsZUNyeXB0byB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHNvZnR3YXJlRGVjcnlwdGVyOiBBRVNEZWNyeXB0b3IgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBrZXk6IEFycmF5QnVmZmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZmFzdEFlc0tleTogRmFzdEFFU0tleSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHJlbWFpbmRlckRhdGE6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjdXJyZW50SVY6IEFycmF5QnVmZmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY3VycmVudFJlc3VsdDogQXJyYXlCdWZmZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB1c2VTb2Z0d2FyZTogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEhsc0NvbmZpZywgeyByZW1vdmVQS0NTN1BhZGRpbmcgPSB0cnVlIH0gPSB7fSkge1xuICAgIHRoaXMudXNlU29mdHdhcmUgPSBjb25maWcuZW5hYmxlU29mdHdhcmVBRVM7XG4gICAgdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcgPSByZW1vdmVQS0NTN1BhZGRpbmc7XG4gICAgLy8gYnVpbHQgaW4gZGVjcnlwdG9yIGV4cGVjdHMgUEtDUzcgcGFkZGluZ1xuICAgIGlmIChyZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJDcnlwdG8gPSBzZWxmLmNyeXB0bztcbiAgICAgICAgaWYgKGJyb3dzZXJDcnlwdG8pIHtcbiAgICAgICAgICB0aGlzLnN1YnRsZSA9XG4gICAgICAgICAgICBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fFxuICAgICAgICAgICAgKChicm93c2VyQ3J5cHRvIGFzIGFueSkud2Via2l0U3VidGxlIGFzIFN1YnRsZUNyeXB0byk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3VidGxlID09PSBudWxsKSB7XG4gICAgICB0aGlzLnVzZVNvZnR3YXJlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3VidGxlID0gbnVsbDtcbiAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5mYXN0QWVzS2V5ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICB9XG5cbiAgcHVibGljIGlzU3luYygpIHtcbiAgICByZXR1cm4gdGhpcy51c2VTb2Z0d2FyZTtcbiAgfVxuXG4gIHB1YmxpYyBmbHVzaCgpOiBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgY29uc3QgeyBjdXJyZW50UmVzdWx0LCByZW1haW5kZXJEYXRhIH0gPSB0aGlzO1xuICAgIGlmICghY3VycmVudFJlc3VsdCB8fCByZW1haW5kZXJEYXRhKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGN1cnJlbnRSZXN1bHQpO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICBpZiAodGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgIHJldHVybiByZW1vdmVQYWRkaW5nKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpIHtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIGlmICh0aGlzLnNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGVjcnlwdChcbiAgICBkYXRhOiBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIsXG4gICAga2V5OiBBcnJheUJ1ZmZlcixcbiAgICBpdjogQXJyYXlCdWZmZXJcbiAgKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4ge1xuICAgIGlmICh0aGlzLnVzZVNvZnR3YXJlKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdChuZXcgVWludDhBcnJheShkYXRhKSwga2V5LCBpdik7XG4gICAgICAgIGNvbnN0IGRlY3J5cHRSZXN1bHQgPSB0aGlzLmZsdXNoKCk7XG4gICAgICAgIGlmIChkZWNyeXB0UmVzdWx0KSB7XG4gICAgICAgICAgcmVzb2x2ZShkZWNyeXB0UmVzdWx0LmJ1ZmZlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignW3NvZnR3YXJlRGVjcnlwdF0gRmFpbGVkIHRvIGRlY3J5cHQgZGF0YScpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndlYkNyeXB0b0RlY3J5cHQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGtleSwgaXYpO1xuICB9XG5cbiAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBwcm9ncmVzc2l2ZS4gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBtYXkgbm90IHJldHVybiBhIHJlc3VsdCBvbiBlYWNoIGNhbGwuIEFueSBjYWNoZWRcbiAgLy8gZGF0YSBpcyBoYW5kbGVkIGluIHRoZSBmbHVzaCgpIGNhbGxcbiAgcHVibGljIHNvZnR3YXJlRGVjcnlwdChcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtleTogQXJyYXlCdWZmZXIsXG4gICAgaXY6IEFycmF5QnVmZmVyXG4gICk6IEFycmF5QnVmZmVyIHwgbnVsbCB7XG4gICAgY29uc3QgeyBjdXJyZW50SVYsIGN1cnJlbnRSZXN1bHQsIHJlbWFpbmRlckRhdGEgfSA9IHRoaXM7XG4gICAgdGhpcy5sb2dPbmNlKCdKUyBBRVMgZGVjcnlwdCcpO1xuICAgIC8vIFRoZSBvdXRwdXQgaXMgc3RhZ2dlcmVkIGR1cmluZyBwcm9ncmVzc2l2ZSBwYXJzaW5nIC0gdGhlIGN1cnJlbnQgcmVzdWx0IGlzIGNhY2hlZCwgYW5kIGVtaXR0ZWQgb24gdGhlIG5leHQgY2FsbFxuICAgIC8vIFRoaXMgaXMgZG9uZSBpbiBvcmRlciB0byBzdHJpcCBQS0NTNyBwYWRkaW5nLCB3aGljaCBpcyBmb3VuZCBhdCB0aGUgZW5kIG9mIGVhY2ggc2VnbWVudC4gV2Ugb25seSBrbm93IHdlJ3ZlIHJlYWNoZWRcbiAgICAvLyB0aGUgZW5kIG9uIGZsdXNoKCksIGJ1dCBieSB0aGF0IHRpbWUgd2UgaGF2ZSBhbHJlYWR5IHJlY2VpdmVkIGFsbCBieXRlcyBmb3IgdGhlIHNlZ21lbnQuXG4gICAgLy8gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBkb2VzIG5vdCB3b3JrIHdpdGggV2ViQ3J5cHRvXG5cbiAgICBpZiAocmVtYWluZGVyRGF0YSkge1xuICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkocmVtYWluZGVyRGF0YSwgZGF0YSk7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEJ5dGUgbGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNiAoQUVTLTEyOCA9IDEyOCBiaXQgYmxvY2tzID0gMTYgYnl0ZXMpXG4gICAgY29uc3QgY3VycmVudENodW5rID0gdGhpcy5nZXRWYWxpZENodW5rKGRhdGEpO1xuICAgIGlmICghY3VycmVudENodW5rLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRJVikge1xuICAgICAgaXYgPSBjdXJyZW50SVY7XG4gICAgfVxuXG4gICAgbGV0IHNvZnR3YXJlRGVjcnlwdGVyID0gdGhpcy5zb2Z0d2FyZURlY3J5cHRlcjtcbiAgICBpZiAoIXNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBuZXcgQUVTRGVjcnlwdG9yKCk7XG4gICAgfVxuICAgIHNvZnR3YXJlRGVjcnlwdGVyLmV4cGFuZEtleShrZXkpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gY3VycmVudFJlc3VsdDtcblxuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IHNvZnR3YXJlRGVjcnlwdGVyLmRlY3J5cHQoY3VycmVudENodW5rLmJ1ZmZlciwgMCwgaXYpO1xuICAgIHRoaXMuY3VycmVudElWID0gc2xpY2VVaW50OChjdXJyZW50Q2h1bmssIC0xNikuYnVmZmVyO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHVibGljIHdlYkNyeXB0b0RlY3J5cHQoXG4gICAgZGF0YTogVWludDhBcnJheSxcbiAgICBrZXk6IEFycmF5QnVmZmVyLFxuICAgIGl2OiBBcnJheUJ1ZmZlclxuICApOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gICAgY29uc3Qgc3VidGxlID0gdGhpcy5zdWJ0bGU7XG4gICAgaWYgKHRoaXMua2V5ICE9PSBrZXkgfHwgIXRoaXMuZmFzdEFlc0tleSkge1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLmZhc3RBZXNLZXkgPSBuZXcgRmFzdEFFU0tleShzdWJ0bGUsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZhc3RBZXNLZXlcbiAgICAgIC5leHBhbmRLZXkoKVxuICAgICAgLnRoZW4oKGFlc0tleSkgPT4ge1xuICAgICAgICAvLyBkZWNyeXB0IHVzaW5nIHdlYiBjcnlwdG9cbiAgICAgICAgaWYgKCFzdWJ0bGUpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd3ZWIgY3J5cHRvIG5vdCBpbml0aWFsaXplZCcpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ09uY2UoJ1dlYkNyeXB0byBBRVMgZGVjcnlwdCcpO1xuICAgICAgICBjb25zdCBjcnlwdG8gPSBuZXcgQUVTQ3J5cHRvKHN1YnRsZSwgbmV3IFVpbnQ4QXJyYXkoaXYpKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5kZWNyeXB0KGRhdGEuYnVmZmVyLCBhZXNLZXkpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgIGBbZGVjcnlwdGVyXTogV2ViQ3J5cHRvIEVycm9yLCBkaXNhYmxlIFdlYkNyeXB0byBBUEksICR7ZXJyLm5hbWV9OiAke2Vyci5tZXNzYWdlfWBcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5vbldlYkNyeXB0b0Vycm9yKGRhdGEsIGtleSwgaXYpO1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uV2ViQ3J5cHRvRXJyb3IoZGF0YSwga2V5LCBpdik6IEFycmF5QnVmZmVyIHwgbmV2ZXIge1xuICAgIHRoaXMudXNlU29mdHdhcmUgPSB0cnVlO1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5zb2Z0d2FyZURlY3J5cHQoZGF0YSwga2V5LCBpdik7XG4gICAgY29uc3QgZGVjcnlwdFJlc3VsdCA9IHRoaXMuZmx1c2goKTtcbiAgICBpZiAoZGVjcnlwdFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGRlY3J5cHRSZXN1bHQuYnVmZmVyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkNyeXB0byBhbmQgc29mdHdhcmVEZWNyeXB0OiBmYWlsZWQgdG8gZGVjcnlwdCBkYXRhJyk7XG4gIH1cblxuICBwcml2YXRlIGdldFZhbGlkQ2h1bmsoZGF0YTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICAgIGxldCBjdXJyZW50Q2h1bmsgPSBkYXRhO1xuICAgIGNvbnN0IHNwbGl0UG9pbnQgPSBkYXRhLmxlbmd0aCAtIChkYXRhLmxlbmd0aCAlIENIVU5LX1NJWkUpO1xuICAgIGlmIChzcGxpdFBvaW50ICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgY3VycmVudENodW5rID0gc2xpY2VVaW50OChkYXRhLCAwLCBzcGxpdFBvaW50KTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IHNsaWNlVWludDgoZGF0YSwgc3BsaXRQb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q2h1bms7XG4gIH1cblxuICBwcml2YXRlIGxvZ09uY2UobXNnOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIubG9nKGBbZGVjcnlwdGVyXTogJHttc2d9YCk7XG4gICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gIH1cbn1cbiIsIi8qKlxuICogIFRpbWVSYW5nZXMgdG8gc3RyaW5nIGhlbHBlclxuICovXG5cbmNvbnN0IFRpbWVSYW5nZXMgPSB7XG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAocjogVGltZVJhbmdlcykge1xuICAgIGxldCBsb2cgPSAnJztcbiAgICBjb25zdCBsZW4gPSByLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsb2cgKz0gYFske3Iuc3RhcnQoaSkudG9GaXhlZCgzKX0tJHtyLmVuZChpKS50b0ZpeGVkKDMpfV1gO1xuICAgIH1cblxuICAgIHJldHVybiBsb2c7XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBUaW1lUmFuZ2VzO1xuIiwiaW1wb3J0IFRhc2tMb29wIGZyb20gJy4uL3Rhc2stbG9vcCc7XG5pbXBvcnQgeyBGcmFnbWVudFN0YXRlIH0gZnJvbSAnLi9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCB7IEJ1ZmZlcmFibGUsIEJ1ZmZlckhlbHBlciwgQnVmZmVySW5mbyB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMsIEVycm9yVHlwZXMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgQ2h1bmtNZXRhZGF0YSB9IGZyb20gJy4uL3R5cGVzL3RyYW5zbXV4ZXInO1xuaW1wb3J0IHsgYXBwZW5kVWludDhBcnJheSB9IGZyb20gJy4uL3V0aWxzL21wNC10b29scyc7XG5pbXBvcnQgeyBhbGlnblN0cmVhbSB9IGZyb20gJy4uL3V0aWxzL2Rpc2NvbnRpbnVpdGllcyc7XG5pbXBvcnQge1xuICBmaW5kRnJhZ21lbnRCeVBEVCxcbiAgZmluZEZyYWdtZW50QnlQVFMsXG4gIGZpbmRGcmFnV2l0aENDLFxufSBmcm9tICcuL2ZyYWdtZW50LWZpbmRlcnMnO1xuaW1wb3J0IHtcbiAgZmluZFBhcnQsXG4gIGdldEZyYWdtZW50V2l0aFNOLFxuICBnZXRQYXJ0V2l0aCxcbiAgdXBkYXRlRnJhZ1BUU0RUUyxcbn0gZnJvbSAnLi9sZXZlbC1oZWxwZXInO1xuaW1wb3J0IFRyYW5zbXV4ZXJJbnRlcmZhY2UgZnJvbSAnLi4vZGVtdXgvdHJhbnNtdXhlci1pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFBhcnQgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IEZyYWdtZW50TG9hZGVyLCB7XG4gIEZyYWdtZW50TG9hZFByb2dyZXNzQ2FsbGJhY2ssXG4gIExvYWRFcnJvcixcbn0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50LWxvYWRlcic7XG5pbXBvcnQgS2V5TG9hZGVyIGZyb20gJy4uL2xvYWRlci9rZXktbG9hZGVyJztcbmltcG9ydCB7IExldmVsRGV0YWlscyB9IGZyb20gJy4uL2xvYWRlci9sZXZlbC1kZXRhaWxzJztcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcbmltcG9ydCBUaW1lUmFuZ2VzIGZyb20gJy4uL3V0aWxzL3RpbWUtcmFuZ2VzJztcbmltcG9ydCB7IFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7IGdldFJldHJ5RGVsYXkgfSBmcm9tICcuLi91dGlscy9lcnJvci1oZWxwZXInO1xuaW1wb3J0IHsgTmV0d29ya0Vycm9yQWN0aW9uIH0gZnJvbSAnLi9lcnJvci1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIHtcbiAgQnVmZmVyQXBwZW5kaW5nRGF0YSxcbiAgRXJyb3JEYXRhLFxuICBGcmFnTG9hZGVkRGF0YSxcbiAgUGFydHNMb2FkZWREYXRhLFxuICBLZXlMb2FkZWREYXRhLFxuICBNZWRpYUF0dGFjaGVkRGF0YSxcbiAgQnVmZmVyRmx1c2hpbmdEYXRhLFxuICBNYW5pZmVzdExvYWRlZERhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IEZyYWdtZW50VHJhY2tlciB9IGZyb20gJy4vZnJhZ21lbnQtdHJhY2tlcic7XG5pbXBvcnQgdHlwZSB7IExldmVsIH0gZnJvbSAnLi4vdHlwZXMvbGV2ZWwnO1xuaW1wb3J0IHR5cGUgeyBSZW11eGVkVHJhY2sgfSBmcm9tICcuLi90eXBlcy9yZW11eGVyJztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBOZXR3b3JrQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSB7IFNvdXJjZUJ1ZmZlck5hbWUgfSBmcm9tICcuLi90eXBlcy9idWZmZXInO1xuaW1wb3J0IHR5cGUgeyBSYXRpb25hbFRpbWVzdGFtcCB9IGZyb20gJy4uL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uJztcblxudHlwZSBSZXNvbHZlRnJhZ0xvYWRlZCA9IChGcmFnTG9hZGVkRW5kRGF0YSkgPT4gdm9pZDtcbnR5cGUgUmVqZWN0RnJhZ0xvYWRlZCA9IChMb2FkRXJyb3IpID0+IHZvaWQ7XG5cbmV4cG9ydCBjb25zdCBTdGF0ZSA9IHtcbiAgU1RPUFBFRDogJ1NUT1BQRUQnLFxuICBJRExFOiAnSURMRScsXG4gIEtFWV9MT0FESU5HOiAnS0VZX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkc6ICdGUkFHX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTogJ0ZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZJyxcbiAgV0FJVElOR19UUkFDSzogJ1dBSVRJTkdfVFJBQ0snLFxuICBQQVJTSU5HOiAnUEFSU0lORycsXG4gIFBBUlNFRDogJ1BBUlNFRCcsXG4gIEVOREVEOiAnRU5ERUQnLFxuICBFUlJPUjogJ0VSUk9SJyxcbiAgV0FJVElOR19JTklUX1BUUzogJ1dBSVRJTkdfSU5JVF9QVFMnLFxuICBXQUlUSU5HX0xFVkVMOiAnV0FJVElOR19MRVZFTCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlU3RyZWFtQ29udHJvbGxlclxuICBleHRlbmRzIFRhc2tMb29wXG4gIGltcGxlbWVudHMgTmV0d29ya0NvbXBvbmVudEFQSVxue1xuICBwcm90ZWN0ZWQgaGxzOiBIbHM7XG5cbiAgcHJvdGVjdGVkIGZyYWdQcmV2aW91czogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIGZyYWdDdXJyZW50OiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgZnJhZ21lbnRUcmFja2VyOiBGcmFnbWVudFRyYWNrZXI7XG4gIHByb3RlY3RlZCB0cmFuc211eGVyOiBUcmFuc211eGVySW50ZXJmYWNlIHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBfc3RhdGU6IHN0cmluZyA9IFN0YXRlLlNUT1BQRUQ7XG4gIHByb3RlY3RlZCBwbGF5bGlzdFR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlO1xuICBwcm90ZWN0ZWQgbWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIG1lZGlhQnVmZmVyOiBCdWZmZXJhYmxlIHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBjb25maWc6IEhsc0NvbmZpZztcbiAgcHJvdGVjdGVkIGJpdHJhdGVUZXN0OiBib29sZWFuID0gZmFsc2U7XG4gIHByb3RlY3RlZCBsYXN0Q3VycmVudFRpbWU6IG51bWJlciA9IDA7XG4gIHByb3RlY3RlZCBuZXh0TG9hZFBvc2l0aW9uOiBudW1iZXIgPSAwO1xuICBwcm90ZWN0ZWQgc3RhcnRQb3NpdGlvbjogbnVtYmVyID0gMDtcbiAgcHJvdGVjdGVkIHN0YXJ0VGltZU9mZnNldDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBsb2FkZWRtZXRhZGF0YTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgcmV0cnlEYXRlOiBudW1iZXIgPSAwO1xuICBwcm90ZWN0ZWQgbGV2ZWxzOiBBcnJheTxMZXZlbD4gfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIGZyYWdtZW50TG9hZGVyOiBGcmFnbWVudExvYWRlcjtcbiAgcHJvdGVjdGVkIGtleUxvYWRlcjogS2V5TG9hZGVyO1xuICBwcm90ZWN0ZWQgbGV2ZWxMYXN0TG9hZGVkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIHN0YXJ0RnJhZ1JlcXVlc3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgZGVjcnlwdGVyOiBEZWNyeXB0ZXI7XG4gIHByb3RlY3RlZCBpbml0UFRTOiBSYXRpb25hbFRpbWVzdGFtcFtdID0gW107XG4gIHByb3RlY3RlZCBvbnZzZWVraW5nOiBFdmVudExpc3RlbmVyIHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBvbnZlbmRlZDogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nUHJlZml4OiBzdHJpbmcgPSAnJztcbiAgcHJvdGVjdGVkIGxvZzogKG1zZzogYW55KSA9PiB2b2lkO1xuICBwcm90ZWN0ZWQgd2FybjogKG1zZzogYW55KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGhsczogSGxzLFxuICAgIGZyYWdtZW50VHJhY2tlcjogRnJhZ21lbnRUcmFja2VyLFxuICAgIGtleUxvYWRlcjogS2V5TG9hZGVyLFxuICAgIGxvZ1ByZWZpeDogc3RyaW5nLFxuICAgIHBsYXlsaXN0VHlwZTogUGxheWxpc3RMZXZlbFR5cGVcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBsYXlsaXN0VHlwZSA9IHBsYXlsaXN0VHlwZTtcbiAgICB0aGlzLmxvZ1ByZWZpeCA9IGxvZ1ByZWZpeDtcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIGAke2xvZ1ByZWZpeH06YCk7XG4gICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChsb2dnZXIsIGAke2xvZ1ByZWZpeH06YCk7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5mcmFnbWVudExvYWRlciA9IG5ldyBGcmFnbWVudExvYWRlcihobHMuY29uZmlnKTtcbiAgICB0aGlzLmtleUxvYWRlciA9IGtleUxvYWRlcjtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKGhscy5jb25maWcpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRvVGljaygpIHtcbiAgICB0aGlzLm9uVGlja0VuZCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uVGlja0VuZCgpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBwdWJsaWMgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb246IG51bWJlcik6IHZvaWQge31cblxuICBwdWJsaWMgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5mcmFnbWVudExvYWRlci5hYm9ydCgpO1xuICAgIHRoaXMua2V5TG9hZGVyLmFib3J0KHRoaXMucGxheWxpc3RUeXBlKTtcbiAgICBjb25zdCBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZz8ubG9hZGVyKSB7XG4gICAgICBmcmFnLmFib3J0UmVxdWVzdHMoKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3RyZWFtRW5kZWQoXG4gICAgYnVmZmVySW5mbzogQnVmZmVySW5mbyxcbiAgICBsZXZlbERldGFpbHM6IExldmVsRGV0YWlsc1xuICApOiBib29sZWFuIHtcbiAgICAvLyBJZiBwbGF5bGlzdCBpcyBsaXZlLCB0aGVyZSBpcyBhbm90aGVyIGJ1ZmZlcmVkIHJhbmdlIGFmdGVyIHRoZSBjdXJyZW50IHJhbmdlLCBub3RoaW5nIGJ1ZmZlcmVkLCBtZWRpYSBpcyBkZXRhY2hlZCxcbiAgICAvLyBvZiBub3RoaW5nIGxvYWRpbmcvbG9hZGVkIHJldHVybiBmYWxzZVxuICAgIGlmIChcbiAgICAgIGxldmVsRGV0YWlscy5saXZlIHx8XG4gICAgICBidWZmZXJJbmZvLm5leHRTdGFydCB8fFxuICAgICAgIWJ1ZmZlckluZm8uZW5kIHx8XG4gICAgICAhdGhpcy5tZWRpYVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0TGlzdCA9IGxldmVsRGV0YWlscy5wYXJ0TGlzdDtcbiAgICAvLyBTaW5jZSB0aGUgbGFzdCBwYXJ0IGlzbid0IGd1YXJhbnRlZWQgdG8gY29ycmVzcG9uZCB0byB0aGUgbGFzdCBwbGF5bGlzdCBzZWdtZW50IGZvciBMb3ctTGF0ZW5jeSBITFMsXG4gICAgLy8gY2hlY2sgaW5zdGVhZCBpZiB0aGUgbGFzdCBwYXJ0IGlzIGJ1ZmZlcmVkLlxuICAgIGlmIChwYXJ0TGlzdD8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYXN0UGFydCA9IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAvLyBDaGVja2luZyB0aGUgbWlkcG9pbnQgb2YgdGhlIHBhcnQgZm9yIHBvdGVudGlhbCBtYXJnaW4gb2YgZXJyb3IgYW5kIHJlbGF0ZWQgaXNzdWVzLlxuICAgICAgLy8gTk9URTogVGVjaG5pY2FsbHkgSSBiZWxpZXZlIHBhcnRzIGNvdWxkIHlpZWxkIGNvbnRlbnQgdGhhdCBpcyA8IHRoZSBjb21wdXRlZCBkdXJhdGlvbiAoaW5jbHVkaW5nIHBvdGVudGlhbCBhIGR1cmF0aW9uIG9mIDApXG4gICAgICAvLyBhbmQgc3RpbGwgYmUgc3BlYy1jb21wbGlhbnQsIHNvIHRoZXJlIG1heSBzdGlsbCBiZSBlZGdlIGNhc2VzIGhlcmUuIExpa2V3aXNlLCB0aGVyZSBjb3VsZCBiZSBpc3N1ZXMgaW4gZW5kIG9mIHN0cmVhbVxuICAgICAgLy8gcGFydCBtaXNtYXRjaGVzIGZvciBpbmRlcGVuZGVudCBhdWRpbyBhbmQgdmlkZW8gcGxheWxpc3RzL3NlZ21lbnRzLlxuICAgICAgY29uc3QgbGFzdFBhcnRCdWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKFxuICAgICAgICB0aGlzLm1lZGlhLFxuICAgICAgICBsYXN0UGFydC5zdGFydCArIGxhc3RQYXJ0LmR1cmF0aW9uIC8gMlxuICAgICAgKTtcbiAgICAgIHJldHVybiBsYXN0UGFydEJ1ZmZlcmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9XG4gICAgICBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2xldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV0udHlwZTtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuaXNFbmRMaXN0QXBwZW5kZWQocGxheWxpc3RUeXBlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRMZXZlbERldGFpbHMoKTogTGV2ZWxEZXRhaWxzIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsc1t0aGlzLmxldmVsTGFzdExvYWRlZF0/LmRldGFpbHM7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFBdHRhY2hlZChcbiAgICBldmVudDogRXZlbnRzLk1FRElBX0FUVEFDSEVELFxuICAgIGRhdGE6IE1lZGlhQXR0YWNoZWREYXRhXG4gICkge1xuICAgIGNvbnN0IG1lZGlhID0gKHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYSk7XG4gICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpIGFzIEV2ZW50TGlzdGVuZXI7XG4gICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcykgYXMgRXZlbnRMaXN0ZW5lcjtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICh0aGlzLmxldmVscyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICB0aGlzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYT8uZW5kZWQpIHtcbiAgICAgIHRoaXMubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBpZiAobWVkaWEgJiYgdGhpcy5vbnZzZWVraW5nICYmIHRoaXMub252ZW5kZWQpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5rZXlMb2FkZXIpIHtcbiAgICAgIHRoaXMua2V5TG9hZGVyLmRldGFjaCgpO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhU2Vla2luZygpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgZnJhZ0N1cnJlbnQsIG1lZGlhLCBtZWRpYUJ1ZmZlciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWU6IG51bWJlciA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiAwO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhcbiAgICAgIG1lZGlhQnVmZmVyID8gbWVkaWFCdWZmZXIgOiBtZWRpYSxcbiAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgY29uZmlnLm1heEJ1ZmZlckhvbGVcbiAgICApO1xuXG4gICAgdGhpcy5sb2coXG4gICAgICBgbWVkaWEgc2Vla2luZyB0byAke1xuICAgICAgICBOdW1iZXIuaXNGaW5pdGUoY3VycmVudFRpbWUpID8gY3VycmVudFRpbWUudG9GaXhlZCgzKSA6IGN1cnJlbnRUaW1lXG4gICAgICB9LCBzdGF0ZTogJHtzdGF0ZX1gXG4gICAgKTtcblxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgIC8vIFNlZWtpbmcgd2hpbGUgZnJhZyBsb2FkIGlzIGluIHByb2dyZXNzXG4gICAgICBjb25zdCB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgIGNvbnN0IGZyYWdTdGFydE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0IC0gdG9sZXJhbmNlO1xuICAgICAgY29uc3QgZnJhZ0VuZE9mZnNldCA9XG4gICAgICAgIGZyYWdDdXJyZW50LnN0YXJ0ICsgZnJhZ0N1cnJlbnQuZHVyYXRpb24gKyB0b2xlcmFuY2U7XG4gICAgICAvLyBpZiBzZWVraW5nIG91dCBvZiBidWZmZXJlZCByYW5nZSBvciBpbnRvIG5ldyBvbmVcbiAgICAgIGlmIChcbiAgICAgICAgIWJ1ZmZlckluZm8ubGVuIHx8XG4gICAgICAgIGZyYWdFbmRPZmZzZXQgPCBidWZmZXJJbmZvLnN0YXJ0IHx8XG4gICAgICAgIGZyYWdTdGFydE9mZnNldCA+IGJ1ZmZlckluZm8uZW5kXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgcGFzdEZyYWdtZW50ID0gY3VycmVudFRpbWUgPiBmcmFnRW5kT2Zmc2V0O1xuICAgICAgICAvLyBpZiB0aGUgc2VlayBwb3NpdGlvbiBpcyBvdXRzaWRlIHRoZSBjdXJyZW50IGZyYWdtZW50IHJhbmdlXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA8IGZyYWdTdGFydE9mZnNldCB8fCBwYXN0RnJhZ21lbnQpIHtcbiAgICAgICAgICBpZiAocGFzdEZyYWdtZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgICAgICdzZWVraW5nIG91dHNpZGUgb2YgYnVmZmVyIHdoaWxlIGZyYWdtZW50IGxvYWQgaW4gcHJvZ3Jlc3MsIGNhbmNlbCBmcmFnbWVudCBsb2FkJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAvLyBSZW1vdmUgZ2FwIGZyYWdtZW50c1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShcbiAgICAgICAgY3VycmVudFRpbWUsXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICB0aGlzLnBsYXlsaXN0VHlwZSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcblxuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG5cbiAgICAvLyBpbiBjYXNlIHNlZWtpbmcgb2NjdXJzIGFsdGhvdWdoIG5vIG1lZGlhIGJ1ZmZlcmVkLCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiBhbmQgbmV4dExvYWRQb3NpdGlvbiB0byBzZWVrIHRhcmdldFxuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiAhYnVmZmVySW5mby5sZW4pIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IGN1cnJlbnRUaW1lO1xuICAgIH1cblxuICAgIC8vIEFzeW5jIHRpY2sgdG8gc3BlZWQgdXAgcHJvY2Vzc2luZ1xuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFFbmRlZCgpIHtcbiAgICAvLyByZXNldCBzdGFydFBvc2l0aW9uIGFuZCBsYXN0Q3VycmVudFRpbWUgdG8gcmVzdGFydCBwbGF5YmFjayBAIHN0cmVhbSBiZWdpbm5pbmdcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NYW5pZmVzdExvYWRlZChcbiAgICBldmVudDogRXZlbnRzLk1BTklGRVNUX0xPQURFRCxcbiAgICBkYXRhOiBNYW5pZmVzdExvYWRlZERhdGFcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5zdGFydFRpbWVPZmZzZXQgPSBkYXRhLnN0YXJ0VGltZU9mZnNldDtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICBzdXBlci5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25IYW5kbGVyRGVzdHJveWVkKCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIGlmICh0aGlzLmZyYWdtZW50TG9hZGVyKSB7XG4gICAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaWYgKHRoaXMua2V5TG9hZGVyKSB7XG4gICAgICB0aGlzLmtleUxvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlY3J5cHRlcikge1xuICAgICAgdGhpcy5kZWNyeXB0ZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuaGxzID1cbiAgICAgIHRoaXMubG9nID1cbiAgICAgIHRoaXMud2FybiA9XG4gICAgICB0aGlzLmRlY3J5cHRlciA9XG4gICAgICB0aGlzLmtleUxvYWRlciA9XG4gICAgICB0aGlzLmZyYWdtZW50TG9hZGVyID1cbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID1cbiAgICAgICAgbnVsbCBhcyBhbnk7XG4gICAgc3VwZXIub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbG9hZEZyYWdtZW50KFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIGxldmVsOiBMZXZlbCxcbiAgICB0YXJnZXRCdWZmZXJUaW1lOiBudW1iZXJcbiAgKSB7XG4gICAgdGhpcy5fbG9hZEZyYWdGb3JQbGF5YmFjayhmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSk7XG4gIH1cblxuICBwcml2YXRlIF9sb2FkRnJhZ0ZvclBsYXliYWNrKFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIGxldmVsOiBMZXZlbCxcbiAgICB0YXJnZXRCdWZmZXJUaW1lOiBudW1iZXJcbiAgKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NDYWxsYmFjazogRnJhZ21lbnRMb2FkUHJvZ3Jlc3NDYWxsYmFjayA9IChcbiAgICAgIGRhdGE6IEZyYWdMb2FkZWREYXRhXG4gICAgKSA9PiB7XG4gICAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgdGhpcy53YXJuKFxuICAgICAgICAgIGBGcmFnbWVudCAke2ZyYWcuc259JHtcbiAgICAgICAgICAgIGRhdGEucGFydCA/ICcgcDogJyArIGRhdGEucGFydC5pbmRleCA6ICcnXG4gICAgICAgICAgfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IHdhcyBkcm9wcGVkIGR1cmluZyBkb3dubG9hZC5gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmcmFnLnN0YXRzLmNodW5rQ291bnQrKztcbiAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuICAgIH07XG5cbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lLCBwcm9ncmVzc0NhbGxiYWNrKVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgLy8gaWYgd2UncmUgaGVyZSB3ZSBwcm9iYWJseSBuZWVkZWQgdG8gYmFja3RyYWNrIG9yIGFyZSB3YWl0aW5nIGZvciBtb3JlIHBhcnRzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyB8fFxuICAgICAgICAgICAgKCF0aGlzLmZyYWdDdXJyZW50ICYmIHN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdwYXlsb2FkJyBpbiBkYXRhKSB7XG4gICAgICAgICAgdGhpcy5sb2coYExvYWRlZCBmcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH1gKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXNzIHRocm91Z2ggdGhlIHdob2xlIHBheWxvYWQ7IGNvbnRyb2xsZXJzIG5vdCBpbXBsZW1lbnRpbmcgcHJvZ3Jlc3NpdmUgbG9hZGluZyByZWNlaXZlIGRhdGEgZnJvbSB0aGlzIGNhbGxiYWNrXG4gICAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGRhdGEpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FybihyZWFzb24pO1xuICAgICAgICB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpO1xuICAgICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2xlYXJUcmFja2VySWZOZWVkZWQoZnJhZzogRnJhZ21lbnQpIHtcbiAgICBjb25zdCB7IGZyYWdtZW50VHJhY2tlciB9ID0gdGhpcztcbiAgICBjb25zdCBmcmFnU3RhdGUgPSBmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgaWYgKGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5BUFBFTkRJTkcpIHtcbiAgICAgIC8vIExvd2VyIHRoZSBidWZmZXIgc2l6ZSBhbmQgdHJ5IGFnYWluXG4gICAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBmcmFnLnR5cGUgYXMgUGxheWxpc3RMZXZlbFR5cGU7XG4gICAgICBjb25zdCBidWZmZXJlZEluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8oXG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIsXG4gICAgICAgIHBsYXlsaXN0VHlwZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1pbkZvcndhcmRCdWZmZXJMZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgZnJhZy5kdXJhdGlvbixcbiAgICAgICAgYnVmZmVyZWRJbmZvID8gYnVmZmVyZWRJbmZvLmxlbiA6IHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aFxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLnJlZHVjZU1heEJ1ZmZlckxlbmd0aChtaW5Gb3J3YXJkQnVmZmVyTGVuZ3RoKSkge1xuICAgICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm1lZGlhQnVmZmVyPy5idWZmZXJlZC5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFN0b3AgZ2FwIGZvciBiYWQgdHJhY2tlciAvIGJ1ZmZlciBmbHVzaCBiZWhhdmlvclxuICAgICAgZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIH0gZWxzZSBpZiAoZnJhZ21lbnRUcmFja2VyLmhhc1BhcnRzKGZyYWcudHlwZSkpIHtcbiAgICAgIC8vIEluIGxvdyBsYXRlbmN5IG1vZGUsIHJlbW92ZSBmcmFnbWVudHMgZm9yIHdoaWNoIG9ubHkgc29tZSBwYXJ0cyB3ZXJlIGJ1ZmZlcmVkXG4gICAgICBmcmFnbWVudFRyYWNrZXIuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyh7XG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgIHN0YXRzOiBmcmFnLnN0YXRzLFxuICAgICAgICBpZDogZnJhZy50eXBlLFxuICAgICAgfSk7XG4gICAgICBpZiAoZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwpIHtcbiAgICAgICAgZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBmbHVzaE1haW5CdWZmZXIoXG4gICAgc3RhcnRPZmZzZXQ6IG51bWJlcixcbiAgICBlbmRPZmZzZXQ6IG51bWJlcixcbiAgICB0eXBlOiBTb3VyY2VCdWZmZXJOYW1lIHwgbnVsbCA9IG51bGxcbiAgKSB7XG4gICAgaWYgKCEoc3RhcnRPZmZzZXQgLSBlbmRPZmZzZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdoZW4gYWx0ZXJuYXRlIGF1ZGlvIGlzIHBsYXlpbmcsIHRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBpcyByZXNwb25zaWJsZSBmb3IgdGhlIGF1ZGlvIGJ1ZmZlci4gT3RoZXJ3aXNlLFxuICAgIC8vIHBhc3NpbmcgYSBudWxsIHR5cGUgZmx1c2hlcyBib3RoIGJ1ZmZlcnNcbiAgICBjb25zdCBmbHVzaFNjb3BlOiBCdWZmZXJGbHVzaGluZ0RhdGEgPSB7IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHR5cGUgfTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIGZsdXNoU2NvcGUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9sb2FkSW5pdFNlZ21lbnQoZnJhZzogRnJhZ21lbnQsIGxldmVsOiBMZXZlbCkge1xuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwpXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoIWRhdGEgfHwgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgfHwgIXRoaXMubGV2ZWxzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IGxvYWQgYWJvcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGRhdGE6IEZyYWdMb2FkZWREYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGRhdGE7XG4gICAgICAgIGNvbnN0IGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYXlsb2FkICYmXG4gICAgICAgICAgcGF5bG9hZC5ieXRlTGVuZ3RoID4gMCAmJlxuICAgICAgICAgIGRlY3J5cHREYXRhICYmXG4gICAgICAgICAgZGVjcnlwdERhdGEua2V5ICYmXG4gICAgICAgICAgZGVjcnlwdERhdGEuaXYgJiZcbiAgICAgICAgICBkZWNyeXB0RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4J1xuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIC8vIGRlY3J5cHQgaW5pdCBzZWdtZW50IGRhdGFcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0ZXJcbiAgICAgICAgICAgIC5kZWNyeXB0KFxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShwYXlsb2FkKSxcbiAgICAgICAgICAgICAgZGVjcnlwdERhdGEua2V5LmJ1ZmZlcixcbiAgICAgICAgICAgICAgZGVjcnlwdERhdGEuaXYuYnVmZmVyXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1IsXG4gICAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkZWNyeXB0ZWREYXRhKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19ERUNSWVBURUQsIHtcbiAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAgICAgICAgIHRzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgdGRlY3J5cHQ6IGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGRhdGEucGF5bG9hZCA9IGRlY3J5cHRlZERhdGE7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSlcbiAgICAgIC50aGVuKChkYXRhOiBGcmFnTG9hZGVkRGF0YSkgPT4ge1xuICAgICAgICBjb25zdCB7IGZyYWdDdXJyZW50LCBobHMsIGxldmVscyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVscycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhdHMgPSBmcmFnLnN0YXRzO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICAgIGZyYWcuZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEucGF5bG9hZCk7XG4gICAgICAgIHN0YXRzLnBhcnNpbmcuc3RhcnQgPSBzdGF0cy5idWZmZXJpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBzdGF0cy5wYXJzaW5nLmVuZCA9IHN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIC8vIFNpbGVuY2UgRlJBR19CVUZGRVJFRCBldmVudCBpZiBmcmFnQ3VycmVudCBpcyBudWxsXG4gICAgICAgIGlmIChkYXRhLmZyYWcgPT09IGZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgICAgZnJhZzogZnJhZ0N1cnJlbnQsXG4gICAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgICAgaWQ6IGZyYWcudHlwZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhcm4ocmVhc29uKTtcbiAgICAgICAgdGhpcy5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGZyYWdDb250ZXh0Q2hhbmdlZChmcmFnOiBGcmFnbWVudCB8IG51bGwpIHtcbiAgICBjb25zdCB7IGZyYWdDdXJyZW50IH0gPSB0aGlzO1xuICAgIHJldHVybiAoXG4gICAgICAhZnJhZyB8fFxuICAgICAgIWZyYWdDdXJyZW50IHx8XG4gICAgICBmcmFnLmxldmVsICE9PSBmcmFnQ3VycmVudC5sZXZlbCB8fFxuICAgICAgZnJhZy5zbiAhPT0gZnJhZ0N1cnJlbnQuc24gfHxcbiAgICAgIGZyYWcudXJsSWQgIT09IGZyYWdDdXJyZW50LnVybElkXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBmcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnOiBGcmFnbWVudCwgcGFydDogUGFydCB8IG51bGwpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICB0aGlzLmxvZyhcbiAgICAgIGBCdWZmZXJlZCAke2ZyYWcudHlwZX0gc246ICR7ZnJhZy5zbn0ke1xuICAgICAgICBwYXJ0ID8gJyBwYXJ0OiAnICsgcGFydC5pbmRleCA6ICcnXG4gICAgICB9IG9mICR7XG4gICAgICAgIHRoaXMucGxheWxpc3RUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gJ2xldmVsJyA6ICd0cmFjaydcbiAgICAgIH0gJHtmcmFnLmxldmVsfSAoZnJhZzpbJHsoZnJhZy5zdGFydFBUUyA/PyBOYU4pLnRvRml4ZWQoMyl9LSR7KFxuICAgICAgICBmcmFnLmVuZFBUUyA/PyBOYU5cbiAgICAgICkudG9GaXhlZCgzKX1dID4gYnVmZmVyOiR7XG4gICAgICAgIG1lZGlhXG4gICAgICAgICAgPyBUaW1lUmFuZ2VzLnRvU3RyaW5nKEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSkpXG4gICAgICAgICAgOiAnKGRldGFjaGVkKSdcbiAgICAgIH0pYFxuICAgICk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhdGhpcy5sb2FkZWRtZXRhZGF0YSAmJlxuICAgICAgZnJhZy50eXBlID09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gJiZcbiAgICAgIG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCAmJlxuICAgICAgdGhpcy5mcmFnQ3VycmVudD8uc24gPT09IHRoaXMuZnJhZ1ByZXZpb3VzPy5zblxuICAgICkge1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICB0aGlzLnNlZWtUb1N0YXJ0UG9zKCk7XG4gICAgfVxuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNlZWtUb1N0YXJ0UG9zKCkge31cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGZyYWdMb2FkZWRFbmREYXRhOiBQYXJ0c0xvYWRlZERhdGEpIHtcbiAgICBjb25zdCB7IHRyYW5zbXV4ZXIgfSA9IHRoaXM7XG4gICAgaWYgKCF0cmFuc211eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZnJhZywgcGFydCwgcGFydHNMb2FkZWQgfSA9IGZyYWdMb2FkZWRFbmREYXRhO1xuICAgIC8vIElmIHdlIGRpZCBub3QgbG9hZCBwYXJ0cywgb3IgbG9hZGVkIGFsbCBwYXJ0cywgd2UgaGF2ZSBjb21wbGV0ZSAobm90IHBhcnRpYWwpIGZyYWdtZW50IGRhdGFcbiAgICBjb25zdCBjb21wbGV0ZSA9XG4gICAgICAhcGFydHNMb2FkZWQgfHxcbiAgICAgIHBhcnRzTG9hZGVkLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgcGFydHNMb2FkZWQuc29tZSgoZnJhZ0xvYWRlZCkgPT4gIWZyYWdMb2FkZWQpO1xuICAgIGNvbnN0IGNodW5rTWV0YSA9IG5ldyBDaHVua01ldGFkYXRhKFxuICAgICAgZnJhZy5sZXZlbCxcbiAgICAgIGZyYWcuc24gYXMgbnVtYmVyLFxuICAgICAgZnJhZy5zdGF0cy5jaHVua0NvdW50ICsgMSxcbiAgICAgIDAsXG4gICAgICBwYXJ0ID8gcGFydC5pbmRleCA6IC0xLFxuICAgICAgIWNvbXBsZXRlXG4gICAgKTtcbiAgICB0cmFuc211eGVyLmZsdXNoKGNodW5rTWV0YSk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHByb3RlY3RlZCBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoXG4gICAgZnJhZzogUGFydHNMb2FkZWREYXRhIHwgRnJhZ0xvYWRlZERhdGFcbiAgKSB7fVxuXG4gIHByb3RlY3RlZCBfZG9GcmFnTG9hZChcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBsZXZlbDogTGV2ZWwsXG4gICAgdGFyZ2V0QnVmZmVyVGltZTogbnVtYmVyIHwgbnVsbCA9IG51bGwsXG4gICAgcHJvZ3Jlc3NDYWxsYmFjaz86IEZyYWdtZW50TG9hZFByb2dyZXNzQ2FsbGJhY2tcbiAgKTogUHJvbWlzZTxQYXJ0c0xvYWRlZERhdGEgfCBGcmFnTG9hZGVkRGF0YSB8IG51bGw+IHtcbiAgICBjb25zdCBkZXRhaWxzID0gbGV2ZWw/LmRldGFpbHM7XG4gICAgaWYgKCF0aGlzLmxldmVscyB8fCAhZGV0YWlscykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgZnJhZyBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWwke2RldGFpbHMgPyAnJyA6ICcgZGV0YWlsJ31zYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQga2V5TG9hZGluZ1Byb21pc2U6IFByb21pc2U8S2V5TG9hZGVkRGF0YSB8IHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKGZyYWcuZW5jcnlwdGVkICYmICFmcmFnLmRlY3J5cHRkYXRhPy5rZXkpIHtcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgTG9hZGluZyBrZXkgZm9yICR7ZnJhZy5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfS0ke2RldGFpbHMuZW5kU059XSwgJHtcbiAgICAgICAgICB0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjaydcbiAgICAgICAgfSAke2ZyYWcubGV2ZWx9YFxuICAgICAgKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSB0aGlzLmtleUxvYWRlci5sb2FkKGZyYWcpLnRoZW4oKGtleUxvYWRlZERhdGEpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChrZXlMb2FkZWREYXRhLmZyYWcpKSB7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuS0VZX0xPQURFRCwga2V5TG9hZGVkRGF0YSk7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGtleUxvYWRlZERhdGE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuS0VZX0xPQURJTkcsIHsgZnJhZyB9KTtcbiAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGtleUxvYWRpbmdQcm9taXNlID0gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgbmV3IEVycm9yKGBmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEtFWV9MT0FESU5HYClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFmcmFnLmVuY3J5cHRlZCAmJiBkZXRhaWxzLmVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMua2V5TG9hZGVyLmxvYWRDbGVhcihmcmFnLCBkZXRhaWxzLmVuY3J5cHRlZEZyYWdtZW50cyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0QnVmZmVyVGltZSA9IE1hdGgubWF4KGZyYWcuc3RhcnQsIHRhcmdldEJ1ZmZlclRpbWUgfHwgMCk7XG4gICAgaWYgKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIGNvbnN0IHBhcnRMaXN0ID0gZGV0YWlscy5wYXJ0TGlzdDtcbiAgICAgIGlmIChwYXJ0TGlzdCAmJiBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lID4gZnJhZy5lbmQgJiYgZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgICAgICBmcmFnID0gZGV0YWlscy5mcmFnbWVudEhpbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydEluZGV4ID0gdGhpcy5nZXROZXh0UGFydChwYXJ0TGlzdCwgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICAgIGlmIChwYXJ0SW5kZXggPiAtMSkge1xuICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0TGlzdFtwYXJ0SW5kZXhdO1xuICAgICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICAgYExvYWRpbmcgcGFydCBzbjogJHtmcmFnLnNufSBwOiAke3BhcnQuaW5kZXh9IGNjOiAke1xuICAgICAgICAgICAgICBmcmFnLmNjXG4gICAgICAgICAgICB9IG9mIHBsYXlsaXN0IFske2RldGFpbHMuc3RhcnRTTn0tJHtcbiAgICAgICAgICAgICAgZGV0YWlscy5lbmRTTlxuICAgICAgICAgICAgfV0gcGFydHMgWzAtJHtwYXJ0SW5kZXh9LSR7cGFydExpc3QubGVuZ3RoIC0gMX1dICR7XG4gICAgICAgICAgICAgIHRoaXMubG9nUHJlZml4ID09PSAnW3N0cmVhbS1jb250cm9sbGVyXScgPyAnbGV2ZWwnIDogJ3RyYWNrJ1xuICAgICAgICAgICAgfTogJHtmcmFnLmxldmVsfSwgdGFyZ2V0OiAke3BhcnNlRmxvYXQoXG4gICAgICAgICAgICAgIHRhcmdldEJ1ZmZlclRpbWUudG9GaXhlZCgzKVxuICAgICAgICAgICAgKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBwYXJ0LnN0YXJ0ICsgcGFydC5kdXJhdGlvbjtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgIGxldCByZXN1bHQ6IFByb21pc2U8UGFydHNMb2FkZWREYXRhIHwgRnJhZ0xvYWRlZERhdGEgfCBudWxsPjtcbiAgICAgICAgICBpZiAoa2V5TG9hZGluZ1Byb21pc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGtleUxvYWRpbmdQcm9taXNlXG4gICAgICAgICAgICAgIC50aGVuKChrZXlMb2FkZWREYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgIWtleUxvYWRlZERhdGEgfHxcbiAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEuZnJhZylcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb0ZyYWdQYXJ0c0xvYWQoXG4gICAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFja1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmRvRnJhZ1BhcnRzTG9hZChcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2tcbiAgICAgICAgICAgICkuY2F0Y2goKGVycm9yOiBMb2FkRXJyb3IpID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURJTkcsIHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgdGFyZ2V0QnVmZmVyVGltZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGhpcy5mcmFnQ3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYGZyYWcgbG9hZCBhYm9ydGVkLCBjb250ZXh0IGNoYW5nZWQgaW4gRlJBR19MT0FESU5HIHBhcnRzYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICFmcmFnLnVybCB8fFxuICAgICAgICAgIHRoaXMubG9hZGVkRW5kT2ZQYXJ0cyhwYXJ0TGlzdCwgdGFyZ2V0QnVmZmVyVGltZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gRnJhZ21lbnQgaGludCBoYXMgbm8gcGFydHNcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sb2coXG4gICAgICBgTG9hZGluZyBmcmFnbWVudCAke2ZyYWcuc259IGNjOiAke2ZyYWcuY2N9ICR7XG4gICAgICAgIGRldGFpbHMgPyAnb2YgWycgKyBkZXRhaWxzLnN0YXJ0U04gKyAnLScgKyBkZXRhaWxzLmVuZFNOICsgJ10gJyA6ICcnXG4gICAgICB9JHt0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjayd9OiAke1xuICAgICAgICBmcmFnLmxldmVsXG4gICAgICB9LCB0YXJnZXQ6ICR7cGFyc2VGbG9hdCh0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMykpfWBcbiAgICApO1xuICAgIC8vIERvbid0IHVwZGF0ZSBuZXh0TG9hZFBvc2l0aW9uIGZvciBmcmFnbWVudHMgd2hpY2ggYXJlIG5vdCBidWZmZXJlZFxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbiBhcyBudW1iZXIpICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcblxuICAgIC8vIExvYWQga2V5IGJlZm9yZSBzdHJlYW1pbmcgZnJhZ21lbnQgZGF0YVxuICAgIGNvbnN0IGRhdGFPblByb2dyZXNzID0gdGhpcy5jb25maWcucHJvZ3Jlc3NpdmU7XG4gICAgbGV0IHJlc3VsdDogUHJvbWlzZTxQYXJ0c0xvYWRlZERhdGEgfCBGcmFnTG9hZGVkRGF0YSB8IG51bGw+O1xuICAgIGlmIChkYXRhT25Qcm9ncmVzcyAmJiBrZXlMb2FkaW5nUHJvbWlzZSkge1xuICAgICAgcmVzdWx0ID0ga2V5TG9hZGluZ1Byb21pc2VcbiAgICAgICAgLnRoZW4oKGtleUxvYWRlZERhdGEpID0+IHtcbiAgICAgICAgICBpZiAoIWtleUxvYWRlZERhdGEgfHwgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoa2V5TG9hZGVkRGF0YT8uZnJhZykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKGZyYWcsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB0aGlzLmhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9hZCB1bmVuY3J5cHRlZCBmcmFnbWVudCBkYXRhIHdpdGggcHJvZ3Jlc3MgZXZlbnQsXG4gICAgICAvLyBvciBoYW5kbGUgZnJhZ21lbnQgcmVzdWx0IGFmdGVyIGtleSBhbmQgZnJhZ21lbnQgYXJlIGZpbmlzaGVkIGxvYWRpbmdcbiAgICAgIHJlc3VsdCA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgZGF0YU9uUHJvZ3Jlc3MgPyBwcm9ncmVzc0NhbGxiYWNrIDogdW5kZWZpbmVkXG4gICAgICAgICksXG4gICAgICAgIGtleUxvYWRpbmdQcm9taXNlLFxuICAgICAgXSlcbiAgICAgICAgLnRoZW4oKFtmcmFnTG9hZGVkRGF0YV0pID0+IHtcbiAgICAgICAgICBpZiAoIWRhdGFPblByb2dyZXNzICYmIGZyYWdMb2FkZWREYXRhICYmIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soZnJhZ0xvYWRlZERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnJhZ0xvYWRlZERhdGE7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURJTkcsIHsgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSB9KTtcbiAgICBpZiAodGhpcy5mcmFnQ3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgRXJyb3IoYGZyYWcgbG9hZCBhYm9ydGVkLCBjb250ZXh0IGNoYW5nZWQgaW4gRlJBR19MT0FESU5HYClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGRvRnJhZ1BhcnRzTG9hZChcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBmcm9tUGFydDogUGFydCxcbiAgICBsZXZlbDogTGV2ZWwsXG4gICAgcHJvZ3Jlc3NDYWxsYmFjazogRnJhZ21lbnRMb2FkUHJvZ3Jlc3NDYWxsYmFja1xuICApOiBQcm9taXNlPFBhcnRzTG9hZGVkRGF0YSB8IG51bGw+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoXG4gICAgICAocmVzb2x2ZTogUmVzb2x2ZUZyYWdMb2FkZWQsIHJlamVjdDogUmVqZWN0RnJhZ0xvYWRlZCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJ0c0xvYWRlZDogRnJhZ0xvYWRlZERhdGFbXSA9IFtdO1xuICAgICAgICBjb25zdCBpbml0aWFsUGFydExpc3QgPSBsZXZlbC5kZXRhaWxzPy5wYXJ0TGlzdDtcbiAgICAgICAgY29uc3QgbG9hZFBhcnQgPSAocGFydDogUGFydCkgPT4ge1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnRMb2FkZXJcbiAgICAgICAgICAgIC5sb2FkUGFydChmcmFnLCBwYXJ0LCBwcm9ncmVzc0NhbGxiYWNrKVxuICAgICAgICAgICAgLnRoZW4oKHBhcnRMb2FkZWREYXRhOiBGcmFnTG9hZGVkRGF0YSkgPT4ge1xuICAgICAgICAgICAgICBwYXJ0c0xvYWRlZFtwYXJ0LmluZGV4XSA9IHBhcnRMb2FkZWREYXRhO1xuICAgICAgICAgICAgICBjb25zdCBsb2FkZWRQYXJ0ID0gcGFydExvYWRlZERhdGEucGFydCBhcyBQYXJ0O1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgcGFydExvYWRlZERhdGEpO1xuICAgICAgICAgICAgICBjb25zdCBuZXh0UGFydCA9XG4gICAgICAgICAgICAgICAgZ2V0UGFydFdpdGgobGV2ZWwsIGZyYWcuc24gYXMgbnVtYmVyLCBwYXJ0LmluZGV4ICsgMSkgfHxcbiAgICAgICAgICAgICAgICBmaW5kUGFydChpbml0aWFsUGFydExpc3QsIGZyYWcuc24gYXMgbnVtYmVyLCBwYXJ0LmluZGV4ICsgMSk7XG4gICAgICAgICAgICAgIGlmIChuZXh0UGFydCkge1xuICAgICAgICAgICAgICAgIGxvYWRQYXJ0KG5leHRQYXJ0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgICAgcGFydDogbG9hZGVkUGFydCxcbiAgICAgICAgICAgICAgICAgIHBhcnRzTG9hZGVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGxvYWRQYXJ0KGZyb21QYXJ0KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yOiBMb2FkRXJyb3IgfCBFcnJvcikge1xuICAgIGlmICgnZGF0YScgaW4gZXJyb3IpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBlcnJvci5kYXRhO1xuICAgICAgaWYgKGVycm9yLmRhdGEgJiYgZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCkge1xuICAgICAgICB0aGlzLmhhbmRsZUZyYWdMb2FkQWJvcnRlZChkYXRhLmZyYWcsIGRhdGEucGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZGF0YSBhcyBFcnJvckRhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICBlcnI6IGVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaChjaHVua01ldGE6IENodW5rTWV0YWRhdGEpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuICAgIGlmICghY29udGV4dCB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICBpZiAoXG4gICAgICAgICF0aGlzLmZyYWdDdXJyZW50ICYmXG4gICAgICAgIHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1JcbiAgICAgICkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBmcmFnLCBwYXJ0LCBsZXZlbCB9ID0gY29udGV4dDtcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGZyYWcuc3RhdHMucGFyc2luZy5lbmQgPSBub3c7XG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5lbmQgPSBub3c7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTGV2ZWxUaW1pbmcoZnJhZywgcGFydCwgbGV2ZWwsIGNodW5rTWV0YS5wYXJ0aWFsKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRDdXJyZW50Q29udGV4dChcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGFcbiAgKTogeyBmcmFnOiBGcmFnbWVudDsgcGFydDogUGFydCB8IG51bGw7IGxldmVsOiBMZXZlbCB9IHwgbnVsbCB7XG4gICAgY29uc3QgeyBsZXZlbHMsIGZyYWdDdXJyZW50IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGV2ZWw6IGxldmVsSW5kZXgsIHNuLCBwYXJ0OiBwYXJ0SW5kZXggfSA9IGNodW5rTWV0YTtcbiAgICBpZiAoIWxldmVscz8uW2xldmVsSW5kZXhdKSB7XG4gICAgICB0aGlzLndhcm4oXG4gICAgICAgIGBMZXZlbHMgb2JqZWN0IHdhcyB1bnNldCB3aGlsZSBidWZmZXJpbmcgZnJhZ21lbnQgJHtzbn0gb2YgbGV2ZWwgJHtsZXZlbEluZGV4fS4gVGhlIGN1cnJlbnQgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tsZXZlbEluZGV4XTtcbiAgICBjb25zdCBwYXJ0ID0gcGFydEluZGV4ID4gLTEgPyBnZXRQYXJ0V2l0aChsZXZlbCwgc24sIHBhcnRJbmRleCkgOiBudWxsO1xuICAgIGNvbnN0IGZyYWcgPSBwYXJ0XG4gICAgICA/IHBhcnQuZnJhZ21lbnRcbiAgICAgIDogZ2V0RnJhZ21lbnRXaXRoU04obGV2ZWwsIHNuLCBmcmFnQ3VycmVudCk7XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50ICE9PSBmcmFnKSB7XG4gICAgICBmcmFnLnN0YXRzID0gZnJhZ0N1cnJlbnQuc3RhdHM7XG4gICAgfVxuICAgIHJldHVybiB7IGZyYWcsIHBhcnQsIGxldmVsIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgYnVmZmVyRnJhZ21lbnREYXRhKFxuICAgIGRhdGE6IFJlbXV4ZWRUcmFjayxcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBwYXJ0OiBQYXJ0IHwgbnVsbCxcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGFcbiAgKSB7XG4gICAgaWYgKCFkYXRhIHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGRhdGExLCBkYXRhMiB9ID0gZGF0YTtcbiAgICBsZXQgYnVmZmVyID0gZGF0YTE7XG4gICAgaWYgKGRhdGExICYmIGRhdGEyKSB7XG4gICAgICAvLyBDb21iaW5lIHRoZSBtb29mICsgbWRhdCBzbyB0aGF0IHdlIGJ1ZmZlciB3aXRoIGEgc2luZ2xlIGFwcGVuZFxuICAgICAgYnVmZmVyID0gYXBwZW5kVWludDhBcnJheShkYXRhMSwgZGF0YTIpO1xuICAgIH1cblxuICAgIGlmICghYnVmZmVyPy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzZWdtZW50OiBCdWZmZXJBcHBlbmRpbmdEYXRhID0ge1xuICAgICAgdHlwZTogZGF0YS50eXBlLFxuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBjaHVua01ldGEsXG4gICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgIGRhdGE6IGJ1ZmZlcixcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHNlZ21lbnQpO1xuXG4gICAgaWYgKGRhdGEuZHJvcHBlZCAmJiBkYXRhLmluZGVwZW5kZW50ICYmICFwYXJ0KSB7XG4gICAgICAvLyBDbGVhciBidWZmZXIgc28gdGhhdCB3ZSByZWxvYWQgcHJldmlvdXMgc2VnbWVudHMgc2VxdWVudGlhbGx5IGlmIHJlcXVpcmVkXG4gICAgICB0aGlzLmZsdXNoQnVmZmVyR2FwKGZyYWcpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBmbHVzaEJ1ZmZlckdhcChmcmFnOiBGcmFnbWVudCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIGN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgY2xlYXIgdGhlIGJhY2sgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIGJhY2t0cmFjayBhcyBtdWNoIGFzIG5lZWRlZFxuICAgIGlmICghQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIG1lZGlhLmN1cnJlbnRUaW1lKSkge1xuICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZy5zdGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbW92ZSBiYWNrLWJ1ZmZlciB3aXRob3V0IGludGVycnVwdGluZyBwbGF5YmFjayB0byBhbGxvdyBiYWNrIHRyYWNraW5nXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICBjb25zdCBmcmFnRHVyYXRpb24gPSBmcmFnLmR1cmF0aW9uO1xuICAgIGNvbnN0IHNlZ21lbnRGcmFjdGlvbiA9IE1hdGgubWluKFxuICAgICAgdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAqIDIsXG4gICAgICBmcmFnRHVyYXRpb24gKiAwLjI1XG4gICAgKTtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KFxuICAgICAgTWF0aC5taW4oZnJhZy5zdGFydCAtIHNlZ21lbnRGcmFjdGlvbiwgYnVmZmVySW5mby5lbmQgLSBzZWdtZW50RnJhY3Rpb24pLFxuICAgICAgY3VycmVudFRpbWUgKyBzZWdtZW50RnJhY3Rpb25cbiAgICApO1xuICAgIGlmIChmcmFnLnN0YXJ0IC0gc3RhcnQgPiBzZWdtZW50RnJhY3Rpb24pIHtcbiAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKHN0YXJ0LCBmcmFnLnN0YXJ0KTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0RndkQnVmZmVySW5mbyhcbiAgICBidWZmZXJhYmxlOiBCdWZmZXJhYmxlIHwgbnVsbCxcbiAgICB0eXBlOiBQbGF5bGlzdExldmVsVHlwZVxuICApOiBCdWZmZXJJbmZvIHwgbnVsbCB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShwb3MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mb0F0UG9zKGJ1ZmZlcmFibGUsIHBvcywgdHlwZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0RndkQnVmZmVySW5mb0F0UG9zKFxuICAgIGJ1ZmZlcmFibGU6IEJ1ZmZlcmFibGUgfCBudWxsLFxuICAgIHBvczogbnVtYmVyLFxuICAgIHR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlXG4gICk6IEJ1ZmZlckluZm8gfCBudWxsIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWc6IHsgbWF4QnVmZmVySG9sZSB9LFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhidWZmZXJhYmxlLCBwb3MsIG1heEJ1ZmZlckhvbGUpO1xuICAgIC8vIFdvcmthcm91bmQgZmxhdyBpbiBnZXR0aW5nIGZvcndhcmQgYnVmZmVyIHdoZW4gbWF4QnVmZmVySG9sZSBpcyBzbWFsbGVyIHRoYW4gZ2FwIGF0IGN1cnJlbnQgcG9zXG4gICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkRnJhZ0F0UG9zID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHBvcywgdHlwZSk7XG4gICAgICBpZiAoYnVmZmVyZWRGcmFnQXRQb3MgJiYgYnVmZmVySW5mby5uZXh0U3RhcnQgPCBidWZmZXJlZEZyYWdBdFBvcy5lbmQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKFxuICAgICAgICAgIGJ1ZmZlcmFibGUsXG4gICAgICAgICAgcG9zLFxuICAgICAgICAgIE1hdGgubWF4KGJ1ZmZlckluZm8ubmV4dFN0YXJ0LCBtYXhCdWZmZXJIb2xlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVySW5mbztcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRNYXhCdWZmZXJMZW5ndGgobGV2ZWxCaXRyYXRlPzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCB7IGNvbmZpZyB9ID0gdGhpcztcbiAgICBsZXQgbWF4QnVmTGVuO1xuICAgIGlmIChsZXZlbEJpdHJhdGUpIHtcbiAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KFxuICAgICAgICAoOCAqIGNvbmZpZy5tYXhCdWZmZXJTaXplKSAvIGxldmVsQml0cmF0ZSxcbiAgICAgICAgY29uZmlnLm1heEJ1ZmZlckxlbmd0aFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QnVmTGVuID0gY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKG1heEJ1ZkxlbiwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKHRocmVzaG9sZDogbnVtYmVyKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgbWluTGVuZ3RoID0gdGhyZXNob2xkIHx8IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gbWluTGVuZ3RoKSB7XG4gICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cbiAgICAgIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggLz0gMjtcbiAgICAgIHRoaXMud2FybihgUmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvICR7Y29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aH1zYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldEFwcGVuZGVkRnJhZyhcbiAgICBwb3NpdGlvbjogbnVtYmVyLFxuICAgIHBsYXlsaXN0VHlwZTogUGxheWxpc3RMZXZlbFR5cGUgPSBQbGF5bGlzdExldmVsVHlwZS5NQUlOXG4gICk6IEZyYWdtZW50IHwgbnVsbCB7XG4gICAgY29uc3QgZnJhZ09yUGFydCA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEFwcGVuZGVkRnJhZyhcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgUGxheWxpc3RMZXZlbFR5cGUuTUFJTlxuICAgICk7XG4gICAgaWYgKGZyYWdPclBhcnQgJiYgJ2ZyYWdtZW50JyBpbiBmcmFnT3JQYXJ0KSB7XG4gICAgICByZXR1cm4gZnJhZ09yUGFydC5mcmFnbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdPclBhcnQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0TmV4dEZyYWdtZW50KFxuICAgIHBvczogbnVtYmVyLFxuICAgIGxldmVsRGV0YWlsczogTGV2ZWxEZXRhaWxzXG4gICk6IEZyYWdtZW50IHwgbnVsbCB7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cztcbiAgICBjb25zdCBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcblxuICAgIGlmICghZnJhZ0xlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICBjb25zdCB7IGNvbmZpZyB9ID0gdGhpcztcbiAgICBjb25zdCBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydDtcbiAgICBsZXQgZnJhZztcblxuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgY29uc3QgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUgPSBjb25maWcuaW5pdGlhbExpdmVNYW5pZmVzdFNpemU7XG4gICAgICBpZiAoZnJhZ0xlbiA8IGluaXRpYWxMaXZlTWFuaWZlc3RTaXplKSB7XG4gICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICBgTm90IGVub3VnaCBmcmFnbWVudHMgdG8gc3RhcnQgcGxheWJhY2sgKGhhdmU6ICR7ZnJhZ0xlbn0sIG5lZWQ6ICR7aW5pdGlhbExpdmVNYW5pZmVzdFNpemV9KWBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGUgcmVhbCBmcmFnbWVudCBzdGFydCB0aW1lcyBmb3IgYSBsaXZlIHN0cmVhbSBhcmUgb25seSBrbm93biBhZnRlciB0aGUgUFRTIHJhbmdlIGZvciB0aGF0IGxldmVsIGlzIGtub3duLlxuICAgICAgLy8gSW4gb3JkZXIgdG8gZGlzY292ZXIgdGhlIHJhbmdlLCB3ZSBsb2FkIHRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50IGZvciB0aGF0IGxldmVsIGFuZCBkZW11eCBpdC5cbiAgICAgIC8vIERvIG5vdCBsb2FkIHVzaW5nIGxpdmUgbG9naWMgaWYgdGhlIHN0YXJ0aW5nIGZyYWcgaXMgcmVxdWVzdGVkIC0gd2Ugd2FudCB0byB1c2UgZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKCkgc28gdGhhdFxuICAgICAgLy8gd2UgZ2V0IHRoZSBmcmFnbWVudCBtYXRjaGluZyB0aGF0IHN0YXJ0IHRpbWVcbiAgICAgIGlmIChcbiAgICAgICAgIWxldmVsRGV0YWlscy5QVFNLbm93biAmJlxuICAgICAgICAhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiZcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID09PSAtMVxuICAgICAgKSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLmdldEluaXRpYWxMaXZlRnJhZ21lbnQobGV2ZWxEZXRhaWxzLCBmcmFnbWVudHMpO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBmcmFnXG4gICAgICAgICAgPyB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uIHx8IGZyYWcuc3RhcnRcbiAgICAgICAgICA6IHBvcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvcyA8PSBzdGFydCkge1xuICAgICAgLy8gVm9EIHBsYXlsaXN0OiBpZiBsb2FkUG9zaXRpb24gYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XG4gICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmVuJ3QgcnVuIGludG8gYW55IHNwZWNpYWwgY2FzZXMgYWxyZWFkeSwganVzdCBsb2FkIHRoZSBmcmFnbWVudCBtb3N0IGNsb3NlbHkgbWF0Y2hpbmcgdGhlIHJlcXVlc3RlZCBwb3NpdGlvblxuICAgIGlmICghZnJhZykge1xuICAgICAgY29uc3QgZW5kID0gY29uZmlnLmxvd0xhdGVuY3lNb2RlXG4gICAgICAgID8gbGV2ZWxEZXRhaWxzLnBhcnRFbmRcbiAgICAgICAgOiBsZXZlbERldGFpbHMuZnJhZ21lbnRFbmQ7XG4gICAgICBmcmFnID0gdGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24ocG9zLCBlbmQsIGxldmVsRGV0YWlscyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZChmcmFnKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpc0xvb3BMb2FkaW5nKGZyYWc6IEZyYWdtZW50LCB0YXJnZXRCdWZmZXJUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCB0cmFja2VyU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICByZXR1cm4gKFxuICAgICAgKHRyYWNrZXJTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5PSyB8fFxuICAgICAgICAodHJhY2tlclN0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwgJiYgISFmcmFnLmdhcCkpICYmXG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPiB0YXJnZXRCdWZmZXJUaW1lXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXROZXh0RnJhZ21lbnRMb29wTG9hZGluZyhcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBsZXZlbERldGFpbHM6IExldmVsRGV0YWlscyxcbiAgICBidWZmZXJJbmZvOiBCdWZmZXJJbmZvLFxuICAgIHBsYXlsaXN0VHlwZTogUGxheWxpc3RMZXZlbFR5cGUsXG4gICAgbWF4QnVmTGVuOiBudW1iZXJcbiAgKTogRnJhZ21lbnQgfCBudWxsIHtcbiAgICBjb25zdCBnYXBTdGFydCA9IGZyYWcuZ2FwO1xuICAgIGNvbnN0IG5leHRGcmFnbWVudCA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50KFxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uLFxuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgKTtcbiAgICBpZiAobmV4dEZyYWdtZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV4dEZyYWdtZW50O1xuICAgIH1cbiAgICBmcmFnID0gbmV4dEZyYWdtZW50O1xuICAgIGlmIChnYXBTdGFydCAmJiBmcmFnICYmICFmcmFnLmdhcCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCkge1xuICAgICAgLy8gTWVkaWEgYnVmZmVyZWQgYWZ0ZXIgR0FQIHRhZ3Mgc2hvdWxkIG5vdCBtYWtlIHRoZSBuZXh0IGJ1ZmZlciB0aW1lcmFuZ2UgZXhjZWVkIGZvcndhcmQgYnVmZmVyIGxlbmd0aFxuICAgICAgY29uc3QgbmV4dGJ1ZmZlckluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm9BdFBvcyhcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhLFxuICAgICAgICBidWZmZXJJbmZvLm5leHRTdGFydCxcbiAgICAgICAgcGxheWxpc3RUeXBlXG4gICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBuZXh0YnVmZmVySW5mbyAhPT0gbnVsbCAmJlxuICAgICAgICBidWZmZXJJbmZvLmxlbiArIG5leHRidWZmZXJJbmZvLmxlbiA+PSBtYXhCdWZMZW5cbiAgICAgICkge1xuICAgICAgICAvLyBSZXR1cm5pbmcgaGVyZSBtaWdodCByZXN1bHQgaW4gbm90IGZpbmRpbmcgYW4gYXVkaW8gYW5kIHZpZGVvIGNhbmRpYXRlIHRvIHNraXAgdG9cbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgYGJ1ZmZlciBmdWxsIGFmdGVyIGdhcHMgaW4gXCIke3BsYXlsaXN0VHlwZX1cIiBwbGF5bGlzdCBzdGFydGluZyBhdCBzbjogJHtmcmFnLnNufWBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgbWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZChmcmFnOiBGcmFnbWVudCB8IG51bGwpOiB0eXBlb2YgZnJhZyB7XG4gICAgLy8gSWYgYW4gaW5pdFNlZ21lbnQgaXMgcHJlc2VudCwgaXQgbXVzdCBiZSBidWZmZXJlZCBmaXJzdFxuICAgIGlmIChmcmFnPy5pbml0U2VnbWVudCAmJiAhZnJhZz8uaW5pdFNlZ21lbnQuZGF0YSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgcmV0dXJuIGZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICBnZXROZXh0UGFydChcbiAgICBwYXJ0TGlzdDogUGFydFtdLFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIHRhcmdldEJ1ZmZlclRpbWU6IG51bWJlclxuICApOiBudW1iZXIge1xuICAgIGxldCBuZXh0UGFydCA9IC0xO1xuICAgIGxldCBjb250aWd1b3VzID0gZmFsc2U7XG4gICAgbGV0IGluZGVwZW5kZW50QXR0ck9taXR0ZWQgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXJ0TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRMaXN0W2ldO1xuICAgICAgaW5kZXBlbmRlbnRBdHRyT21pdHRlZCA9IGluZGVwZW5kZW50QXR0ck9taXR0ZWQgJiYgIXBhcnQuaW5kZXBlbmRlbnQ7XG4gICAgICBpZiAobmV4dFBhcnQgPiAtMSAmJiB0YXJnZXRCdWZmZXJUaW1lIDwgcGFydC5zdGFydCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlZCA9IHBhcnQubG9hZGVkO1xuICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICBuZXh0UGFydCA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKGNvbnRpZ3VvdXMgfHwgcGFydC5pbmRlcGVuZGVudCB8fCBpbmRlcGVuZGVudEF0dHJPbWl0dGVkKSAmJlxuICAgICAgICBwYXJ0LmZyYWdtZW50ID09PSBmcmFnXG4gICAgICApIHtcbiAgICAgICAgbmV4dFBhcnQgPSBpO1xuICAgICAgfVxuICAgICAgY29udGlndW91cyA9IGxvYWRlZDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRQYXJ0O1xuICB9XG5cbiAgcHJpdmF0ZSBsb2FkZWRFbmRPZlBhcnRzKFxuICAgIHBhcnRMaXN0OiBQYXJ0W10sXG4gICAgdGFyZ2V0QnVmZmVyVGltZTogbnVtYmVyXG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGxhc3RQYXJ0ID0gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGxhc3RQYXJ0ICYmIHRhcmdldEJ1ZmZlclRpbWUgPiBsYXN0UGFydC5zdGFydCAmJiBsYXN0UGFydC5sb2FkZWQ7XG4gIH1cblxuICAvKlxuICAgVGhpcyBtZXRob2QgaXMgdXNlZCBmaW5kIHRoZSBiZXN0IG1hdGNoaW5nIGZpcnN0IGZyYWdtZW50IGZvciBhIGxpdmUgcGxheWxpc3QuIFRoaXMgZnJhZ21lbnQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlXG4gICBcInNsaWRpbmdcIiBvZiB0aGUgcGxheWxpc3QsIHdoaWNoIGlzIGl0cyBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgcGxheWJhY2suIEFmdGVyIHNsaWRpbmcgd2UgY2FuIGNvbXB1dGUgdGhlIHJlYWxcbiAgIHN0YXJ0IGFuZCBlbmQgdGltZXMgZm9yIGVhY2ggZnJhZ21lbnQgaW4gdGhlIHBsYXlsaXN0IChhZnRlciB3aGljaCB0aGlzIG1ldGhvZCB3aWxsIG5vdCBuZWVkIHRvIGJlIGNhbGxlZCkuXG4gICovXG4gIHByb3RlY3RlZCBnZXRJbml0aWFsTGl2ZUZyYWdtZW50KFxuICAgIGxldmVsRGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICAgIGZyYWdtZW50czogQXJyYXk8RnJhZ21lbnQ+XG4gICk6IEZyYWdtZW50IHwgbnVsbCB7XG4gICAgY29uc3QgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgbGV0IGZyYWc6IEZyYWdtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgICAgaWYgKGxldmVsRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgLy8gUHJlZmVyIHVzaW5nIFBEVCwgYmVjYXVzZSBpdCBjYW4gYmUgYWNjdXJhdGUgZW5vdWdoIHRvIGNob29zZSB0aGUgY29ycmVjdCBmcmFnbWVudCB3aXRob3V0IGtub3dpbmcgdGhlIGxldmVsIHNsaWRpbmdcbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgYExpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBQRFQ6ICR7ZnJhZ1ByZXZpb3VzLnByb2dyYW1EYXRlVGltZX1gXG4gICAgICAgICk7XG4gICAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBEVChcbiAgICAgICAgICBmcmFnbWVudHMsXG4gICAgICAgICAgZnJhZ1ByZXZpb3VzLmVuZFByb2dyYW1EYXRlVGltZSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgLy8gU04gZG9lcyBub3QgbmVlZCB0byBiZSBhY2N1cmF0ZSBiZXR3ZWVuIHJlbmRpdGlvbnMsIGJ1dCBkZXBlbmRpbmcgb24gdGhlIHBhY2thZ2luZyBpdCBtYXkgYmUgc28uXG4gICAgICAgIGNvbnN0IHRhcmdldFNOID0gKGZyYWdQcmV2aW91cy5zbiBhcyBudW1iZXIpICsgMTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRhcmdldFNOID49IGxldmVsRGV0YWlscy5zdGFydFNOICYmXG4gICAgICAgICAgdGFyZ2V0U04gPD0gbGV2ZWxEZXRhaWxzLmVuZFNOXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGZyYWdOZXh0ID0gZnJhZ21lbnRzW3RhcmdldFNOIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlJ3JlIHN0YXlpbmcgd2l0aGluIHRoZSBjb250aW51aXR5IHJhbmdlLCBzaW5jZSBQVFMgcmVzZXRzIHVwb24gYSBuZXcgcmFuZ2VcbiAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzLmNjID09PSBmcmFnTmV4dC5jYykge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdOZXh0O1xuICAgICAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgICAgIGBMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046ICR7XG4gICAgICAgICAgICAgICAgZnJhZyEuc25cbiAgICAgICAgICAgICAgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHN0YXkgd2l0aGluIHRoZSBjb250aW51aXR5IHJhbmdlIGlmIGF2YWlsYWJsZTsgb3RoZXJ3aXNlIHRoZSBmcmFnbWVudHMgaW4gdGhlIHBsYXlsaXN0XG4gICAgICAgIC8vIHdpbGwgaGF2ZSB0aGUgd3Jvbmcgc3RhcnQgdGltZXNcbiAgICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgICAgZnJhZyA9IGZpbmRGcmFnV2l0aENDKGZyYWdtZW50cywgZnJhZ1ByZXZpb3VzLmNjKTtcbiAgICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgICAgIGBMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgQ0M6ICR7ZnJhZy5zbn1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaW5kIGEgbmV3IHN0YXJ0IGZyYWdtZW50IHdoZW4gZnJhZ1ByZXZpb3VzIGlzIG51bGxcbiAgICAgIGNvbnN0IGxpdmVTdGFydCA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb247XG4gICAgICBpZiAobGl2ZVN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLmdldEZyYWdtZW50QXRQb3NpdGlvbihcbiAgICAgICAgICBsaXZlU3RhcnQsXG4gICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdCA/IGxldmVsRGV0YWlscy5mcmFnbWVudEVuZCA6IGxldmVsRGV0YWlscy5lZGdlLFxuICAgICAgICAgIGxldmVsRGV0YWlsc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgLypcbiAgVGhpcyBtZXRob2QgZmluZHMgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZ2l2ZW4gdGhlIHByb3ZpZGVkIHBvc2l0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldEZyYWdtZW50QXRQb3NpdGlvbihcbiAgICBidWZmZXJFbmQ6IG51bWJlcixcbiAgICBlbmQ6IG51bWJlcixcbiAgICBsZXZlbERldGFpbHM6IExldmVsRGV0YWlsc1xuICApOiBGcmFnbWVudCB8IG51bGwge1xuICAgIGNvbnN0IHsgY29uZmlnIH0gPSB0aGlzO1xuICAgIGxldCB7IGZyYWdQcmV2aW91cyB9ID0gdGhpcztcbiAgICBsZXQgeyBmcmFnbWVudHMsIGVuZFNOIH0gPSBsZXZlbERldGFpbHM7XG4gICAgY29uc3QgeyBmcmFnbWVudEhpbnQgfSA9IGxldmVsRGV0YWlscztcbiAgICBjb25zdCB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICBjb25zdCBwYXJ0TGlzdCA9IGxldmVsRGV0YWlscy5wYXJ0TGlzdDtcblxuICAgIGNvbnN0IGxvYWRpbmdQYXJ0cyA9ICEhKFxuICAgICAgY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmXG4gICAgICBwYXJ0TGlzdD8ubGVuZ3RoICYmXG4gICAgICBmcmFnbWVudEhpbnRcbiAgICApO1xuICAgIGlmIChsb2FkaW5nUGFydHMgJiYgZnJhZ21lbnRIaW50ICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAvLyBJbmNsdWRlIGluY29tcGxldGUgZnJhZ21lbnQgd2l0aCBwYXJ0cyBhdCBlbmRcbiAgICAgIGZyYWdtZW50cyA9IGZyYWdtZW50cy5jb25jYXQoZnJhZ21lbnRIaW50KTtcbiAgICAgIGVuZFNOID0gZnJhZ21lbnRIaW50LnNuIGFzIG51bWJlcjtcbiAgICB9XG5cbiAgICBsZXQgZnJhZztcbiAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICBjb25zdCBsb29rdXBUb2xlcmFuY2UgPSBidWZmZXJFbmQgPiBlbmQgLSB0b2xlcmFuY2UgPyAwIDogdG9sZXJhbmNlO1xuICAgICAgLy8gUmVtb3ZlIHRoZSB0b2xlcmFuY2UgaWYgaXQgd291bGQgcHV0IHRoZSBidWZmZXJFbmQgcGFzdCB0aGUgYWN0dWFsIGVuZCBvZiBzdHJlYW1cbiAgICAgIC8vIFVzZXMgYnVmZmVyIGFuZCBzZXF1ZW5jZSBudW1iZXIgdG8gY2FsY3VsYXRlIHN3aXRjaCBzZWdtZW50IChyZXF1aXJlZCBpZiB1c2luZyBFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFKVxuICAgICAgZnJhZyA9IGZpbmRGcmFnbWVudEJ5UFRTKFxuICAgICAgICBmcmFnUHJldmlvdXMsXG4gICAgICAgIGZyYWdtZW50cyxcbiAgICAgICAgYnVmZmVyRW5kLFxuICAgICAgICBsb29rdXBUb2xlcmFuY2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGNvbnN0IGN1clNOSWR4ID0gZnJhZy5zbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xuICAgICAgLy8gTW92ZSBmcmFnUHJldmlvdXMgZm9yd2FyZCB0byBzdXBwb3J0IGZvcmNpbmcgdGhlIG5leHQgZnJhZ21lbnQgdG8gbG9hZFxuICAgICAgLy8gd2hlbiB0aGUgYnVmZmVyIGNhdGNoZXMgdXAgdG8gYSBwcmV2aW91c2x5IGJ1ZmZlcmVkIHJhbmdlLlxuICAgICAgY29uc3QgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgICBpZiAoXG4gICAgICAgIGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5PSyB8fFxuICAgICAgICAoZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwgJiYgZnJhZy5nYXApXG4gICAgICApIHtcbiAgICAgICAgZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgZnJhZ1ByZXZpb3VzICYmXG4gICAgICAgIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbiAmJlxuICAgICAgICAoIWxvYWRpbmdQYXJ0cyB8fCBwYXJ0TGlzdFswXS5mcmFnbWVudC5zbiA+IGZyYWcuc24pXG4gICAgICApIHtcbiAgICAgICAgLy8gRm9yY2UgdGhlIG5leHQgZnJhZ21lbnQgdG8gbG9hZCBpZiB0aGUgcHJldmlvdXMgb25lIHdhcyBhbHJlYWR5IHNlbGVjdGVkLiBUaGlzIGNhbiBvY2Nhc2lvbmFsbHkgaGFwcGVuIHdpdGhcbiAgICAgICAgLy8gbm9uLXVuaWZvcm0gZnJhZ21lbnQgZHVyYXRpb25zXG4gICAgICAgIGNvbnN0IHNhbWVMZXZlbCA9IGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVsID09PSBmcmFnUHJldmlvdXMubGV2ZWw7XG4gICAgICAgIGlmIChzYW1lTGV2ZWwpIHtcbiAgICAgICAgICBjb25zdCBuZXh0RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCArIDFdO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZyYWcuc24gPCBlbmRTTiAmJlxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUobmV4dEZyYWcpICE9PSBGcmFnbWVudFN0YXRlLk9LXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBmcmFnID0gbmV4dEZyYWc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIHByb3RlY3RlZCBzeW5jaHJvbml6ZVRvTGl2ZUVkZ2UobGV2ZWxEZXRhaWxzOiBMZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgbWVkaWEgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IHN0YXJ0ID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICBjb25zdCBlbmQgPSBsZXZlbERldGFpbHMuZWRnZTtcbiAgICBjb25zdCB3aXRoaW5TbGlkaW5nV2luZG93ID1cbiAgICAgIGN1cnJlbnRUaW1lID49IHN0YXJ0IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UgJiZcbiAgICAgIGN1cnJlbnRUaW1lIDw9IGVuZDtcbiAgICAvLyBDb250aW51ZSBpZiB3ZSBjYW4gc2VlayBmb3J3YXJkIHRvIHN5bmMgcG9zaXRpb24gb3IgaWYgY3VycmVudCB0aW1lIGlzIG91dHNpZGUgb2Ygc2xpZGluZyB3aW5kb3dcbiAgICBpZiAoXG4gICAgICBsaXZlU3luY1Bvc2l0aW9uICE9PSBudWxsICYmXG4gICAgICBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24gJiZcbiAgICAgIChjdXJyZW50VGltZSA8IGxpdmVTeW5jUG9zaXRpb24gfHwgIXdpdGhpblNsaWRpbmdXaW5kb3cpXG4gICAgKSB7XG4gICAgICAvLyBDb250aW51ZSBpZiBidWZmZXIgaXMgc3RhcnZpbmcgb3IgaWYgY3VycmVudCB0aW1lIGlzIGJlaGluZCBtYXggbGF0ZW5jeVxuICAgICAgY29uc3QgbWF4TGF0ZW5jeSA9XG4gICAgICAgIGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uXG4gICAgICAgICAgOiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgaWYgKFxuICAgICAgICAoIXdpdGhpblNsaWRpbmdXaW5kb3cgJiYgbWVkaWEucmVhZHlTdGF0ZSA8IDQpIHx8XG4gICAgICAgIGN1cnJlbnRUaW1lIDwgZW5kIC0gbWF4TGF0ZW5jeVxuICAgICAgKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBzZWVrIGlmIHJlYWR5IGFuZCB0aGVyZSBpcyBub3QgYSBzaWduaWZpY2FudCBmb3J3YXJkIGJ1ZmZlciBhdmFpbGFibGUgZm9yIHBsYXliYWNrXG4gICAgICAgIGlmIChtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFxuICAgICAgICAgICAgYFBsYXliYWNrOiAke2N1cnJlbnRUaW1lLnRvRml4ZWQoXG4gICAgICAgICAgICAgIDNcbiAgICAgICAgICAgICl9IGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0OiAke2VuZH0sIHJlc2V0IGN1cnJlbnRUaW1lIHRvIDogJHtsaXZlU3luY1Bvc2l0aW9uLnRvRml4ZWQoXG4gICAgICAgICAgICAgIDNcbiAgICAgICAgICAgICl9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFsaWduUGxheWxpc3RzKFxuICAgIGRldGFpbHM6IExldmVsRGV0YWlscyxcbiAgICBwcmV2aW91c0RldGFpbHM/OiBMZXZlbERldGFpbHNcbiAgKTogbnVtYmVyIHtcbiAgICBjb25zdCB7IGxldmVscywgbGV2ZWxMYXN0TG9hZGVkLCBmcmFnUHJldmlvdXMgfSA9IHRoaXM7XG4gICAgY29uc3QgbGFzdExldmVsOiBMZXZlbCB8IG51bGwgPVxuICAgICAgbGV2ZWxMYXN0TG9hZGVkICE9PSBudWxsID8gbGV2ZWxzIVtsZXZlbExhc3RMb2FkZWRdIDogbnVsbDtcblxuICAgIC8vIEZJWE1FOiBJZiBub3QgZm9yIGBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzYCByZXF1aXJpbmcgZnJhZ1ByZXZpb3VzLmNjLFxuICAgIC8vICB0aGlzIGNvdWxkIGFsbCBnbyBpbiBsZXZlbC1oZWxwZXIgbWVyZ2VEZXRhaWxzKClcbiAgICBjb25zdCBsZW5ndGggPSBkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHRoaXMud2FybihgTm8gZnJhZ21lbnRzIGluIGxpdmUgcGxheWxpc3RgKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBzbGlkaW5nU3RhcnQgPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICBjb25zdCBmaXJzdExldmVsTG9hZCA9ICFwcmV2aW91c0RldGFpbHM7XG4gICAgY29uc3QgYWxpZ25lZCA9IGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgTnVtYmVyLmlzRmluaXRlKHNsaWRpbmdTdGFydCk7XG4gICAgaWYgKGZpcnN0TGV2ZWxMb2FkIHx8ICghYWxpZ25lZCAmJiAhc2xpZGluZ1N0YXJ0KSkge1xuICAgICAgYWxpZ25TdHJlYW0oZnJhZ1ByZXZpb3VzLCBsYXN0TGV2ZWwsIGRldGFpbHMpO1xuICAgICAgY29uc3QgYWxpZ25lZFNsaWRpbmdTdGFydCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgIGBMaXZlIHBsYXlsaXN0IHNsaWRpbmc6ICR7YWxpZ25lZFNsaWRpbmdTdGFydC50b0ZpeGVkKDIpfSBzdGFydC1zbjogJHtcbiAgICAgICAgICBwcmV2aW91c0RldGFpbHMgPyBwcmV2aW91c0RldGFpbHMuc3RhcnRTTiA6ICduYSdcbiAgICAgICAgfS0+JHtkZXRhaWxzLnN0YXJ0U059IHByZXYtc246ICR7XG4gICAgICAgICAgZnJhZ1ByZXZpb3VzID8gZnJhZ1ByZXZpb3VzLnNuIDogJ25hJ1xuICAgICAgICB9IGZyYWdtZW50czogJHtsZW5ndGh9YFxuICAgICAgKTtcbiAgICAgIHJldHVybiBhbGlnbmVkU2xpZGluZ1N0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gc2xpZGluZ1N0YXJ0O1xuICB9XG5cbiAgcHJvdGVjdGVkIHdhaXRGb3JDZG5UdW5lSW4oZGV0YWlsczogTGV2ZWxEZXRhaWxzKSB7XG4gICAgLy8gV2FpdCBmb3IgTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW4gdG8gZ2V0IGFuIHVwZGF0ZWQgcGxheWxpc3RcbiAgICBjb25zdCBhZHZhbmNlUGFydExpbWl0ID0gMztcbiAgICByZXR1cm4gKFxuICAgICAgZGV0YWlscy5saXZlICYmXG4gICAgICBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkICYmXG4gICAgICBkZXRhaWxzLnBhcnRUYXJnZXQgJiZcbiAgICAgIGRldGFpbHMudHVuZUluR29hbCA+XG4gICAgICAgIE1hdGgubWF4KGRldGFpbHMucGFydEhvbGRCYWNrLCBkZXRhaWxzLnBhcnRUYXJnZXQgKiBhZHZhbmNlUGFydExpbWl0KVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0U3RhcnRQb3NpdGlvbihkZXRhaWxzOiBMZXZlbERldGFpbHMsIHNsaWRpbmc6IG51bWJlcikge1xuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXG4gICAgbGV0IHN0YXJ0UG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgaWYgKHN0YXJ0UG9zaXRpb24gPCBzbGlkaW5nKSB7XG4gICAgICBzdGFydFBvc2l0aW9uID0gLTE7XG4gICAgfVxuICAgIGlmIChzdGFydFBvc2l0aW9uID09PSAtMSB8fCB0aGlzLmxhc3RDdXJyZW50VGltZSA9PT0gLTEpIHtcbiAgICAgIC8vIFVzZSBQbGF5bGlzdCBFWFQtWC1TVEFSVDpUSU1FLU9GRlNFVCB3aGVuIHNldFxuICAgICAgLy8gUHJpb3JpdGl6ZSBNdWx0aXZhcmlhbnQgUGxheWxpc3Qgb2Zmc2V0IHNvIHRoYXQgbWFpbiwgYXVkaW8sIGFuZCBzdWJ0aXRsZSBzdHJlYW0tY29udHJvbGxlciBzdGFydCB0aW1lcyBtYXRjaFxuICAgICAgY29uc3Qgb2Zmc2V0SW5NdWx0aXZhcmlhbnRQbGF5bGlzdCA9IHRoaXMuc3RhcnRUaW1lT2Zmc2V0ICE9PSBudWxsO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lT2Zmc2V0ID0gb2Zmc2V0SW5NdWx0aXZhcmlhbnRQbGF5bGlzdFxuICAgICAgICA/IHRoaXMuc3RhcnRUaW1lT2Zmc2V0XG4gICAgICAgIDogZGV0YWlscy5zdGFydFRpbWVPZmZzZXQ7XG4gICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0ICE9PSBudWxsICYmIE51bWJlci5pc0Zpbml0ZShzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBzbGlkaW5nICsgc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xuICAgICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gZGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBNYXRoLm1pbihcbiAgICAgICAgICBNYXRoLm1heChzbGlkaW5nLCBzdGFydFBvc2l0aW9uKSxcbiAgICAgICAgICBzbGlkaW5nICsgZGV0YWlscy50b3RhbGR1cmF0aW9uXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgIGBTdGFydCB0aW1lIG9mZnNldCAke3N0YXJ0VGltZU9mZnNldH0gZm91bmQgaW4gJHtcbiAgICAgICAgICAgIG9mZnNldEluTXVsdGl2YXJpYW50UGxheWxpc3QgPyAnbXVsdGl2YXJpYW50JyA6ICdtZWRpYSdcbiAgICAgICAgICB9IHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0UG9zaXRpb259YFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgLy8gTGVhdmUgdGhpcy5zdGFydFBvc2l0aW9uIGF0IC0xLCBzbyB0aGF0IHdlIGNhbiB1c2UgYGdldEluaXRpYWxMaXZlRnJhZ21lbnRgIGxvZ2ljIHdoZW4gc3RhcnRQb3NpdGlvbiBoYXNcbiAgICAgICAgLy8gbm90IGJlZW4gc3BlY2lmaWVkIHZpYSB0aGUgY29uZmlnIG9yIGFuIGFzIGFuIGFyZ3VtZW50IHRvIHN0YXJ0TG9hZCAoIzM3MzYpLlxuICAgICAgICBzdGFydFBvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbiB8fCBzbGlkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0TG9hZFBvc2l0aW9uKCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBtZWRpYSB9ID0gdGhpcztcbiAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZGVkIGFueSBmcmFnbWVudCwgc3RhcnQgbG9hZGluZyBmcm9tIHN0YXJ0IHBvc2l0aW9uXG4gICAgbGV0IHBvcyA9IDA7XG4gICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEgJiYgbWVkaWEpIHtcbiAgICAgIHBvcyA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0TG9hZFBvc2l0aW9uKSB7XG4gICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcztcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRnJhZ0xvYWRBYm9ydGVkKGZyYWc6IEZyYWdtZW50LCBwYXJ0OiBQYXJ0IHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXMudHJhbnNtdXhlciAmJiBmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnICYmIGZyYWcuc3RhdHMuYWJvcnRlZCkge1xuICAgICAgdGhpcy53YXJuKFxuICAgICAgICBgRnJhZ21lbnQgJHtmcmFnLnNufSR7cGFydCA/ICcgcGFydCAnICsgcGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke1xuICAgICAgICAgIGZyYWcubGV2ZWxcbiAgICAgICAgfSB3YXMgYWJvcnRlZGBcbiAgICAgICk7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCByZXNldEZyYWdtZW50TG9hZGluZyhmcmFnOiBGcmFnbWVudCkge1xuICAgIGlmIChcbiAgICAgICF0aGlzLmZyYWdDdXJyZW50IHx8XG4gICAgICAoIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpICYmXG4gICAgICAgIHRoaXMuc3RhdGUgIT09IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZKVxuICAgICkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihcbiAgICBmaWx0ZXJUeXBlOiBQbGF5bGlzdExldmVsVHlwZSxcbiAgICBkYXRhOiBFcnJvckRhdGFcbiAgKSB7XG4gICAgaWYgKGRhdGEuY2h1bmtNZXRhICYmICFkYXRhLmZyYWcpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGRhdGEuY2h1bmtNZXRhKTtcbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGRhdGEuZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBIYW5kbGUgZnJhZyBlcnJvciByZWxhdGVkIHRvIGNhbGxlcidzIGZpbHRlclR5cGVcbiAgICBpZiAoIWZyYWcgfHwgZnJhZy50eXBlICE9PSBmaWx0ZXJUeXBlIHx8ICF0aGlzLmxldmVscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYEZyYWcgbG9hZCBlcnJvciBtdXN0IG1hdGNoIGN1cnJlbnQgZnJhZyB0byByZXRyeSAke2ZyYWcudXJsfSA+ICR7dGhpcy5mcmFnQ3VycmVudD8udXJsfWBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGdhcFRhZ0VuY291bnRlcmVkID0gZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuRlJBR19HQVA7XG4gICAgaWYgKGdhcFRhZ0VuY291bnRlcmVkKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQoZnJhZywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIGtlZXAgcmV0cnlpbmcgdW50aWwgdGhlIGxpbWl0IHdpbGwgYmUgcmVhY2hlZFxuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICBjb25zdCB7IGFjdGlvbiwgcmV0cnlDb3VudCA9IDAsIHJldHJ5Q29uZmlnIH0gPSBlcnJvckFjdGlvbiB8fCB7fTtcbiAgICBpZiAoXG4gICAgICBlcnJvckFjdGlvbiAmJlxuICAgICAgYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0ICYmXG4gICAgICByZXRyeUNvbmZpZ1xuICAgICkge1xuICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCk7XG4gICAgICB0aGlzLndhcm4oXG4gICAgICAgIGBGcmFnbWVudCAke2ZyYWcuc259IG9mICR7ZmlsdGVyVHlwZX0gJHtmcmFnLmxldmVsfSBlcnJvcmVkIHdpdGggJHtcbiAgICAgICAgICBkYXRhLmRldGFpbHNcbiAgICAgICAgfSwgcmV0cnlpbmcgbG9hZGluZyAke3JldHJ5Q291bnQgKyAxfS8ke1xuICAgICAgICAgIHJldHJ5Q29uZmlnLm1heE51bVJldHJ5XG4gICAgICAgIH0gaW4gJHtkZWxheX1tc2BcbiAgICAgICk7XG4gICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICB0aGlzLnJldHJ5RGF0ZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICB9IGVsc2UgaWYgKHJldHJ5Q29uZmlnICYmIGVycm9yQWN0aW9uKSB7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRFcnJvcnMoZmlsdGVyVHlwZSk7XG4gICAgICBpZiAocmV0cnlDb3VudCA8IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5KSB7XG4gICAgICAgIC8vIE5ldHdvcmsgcmV0cnkgaXMgc2tpcHBlZCB3aGVuIGxldmVsIHN3aXRjaCBpcyBwcmVmZXJyZWRcbiAgICAgICAgaWYgKCFnYXBUYWdFbmNvdW50ZXJlZCkge1xuICAgICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYCR7ZGF0YS5kZXRhaWxzfSByZWFjaGVkIG9yIGV4Y2VlZGVkIG1heCByZXRyeSAoJHtyZXRyeUNvdW50fSlgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICB9XG4gICAgLy8gUGVyZm9ybSBuZXh0IGFzeW5jIHRpY2sgc29vbmVyIHRvIHNwZWVkIHVwIGVycm9yIGFjdGlvbiByZXNvbHV0aW9uXG4gICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YTogRXJyb3JEYXRhKTogYm9vbGVhbiB7XG4gICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBkYXRhLnBhcmVudCBhcyBQbGF5bGlzdExldmVsVHlwZTtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkSW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyhcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlcixcbiAgICAgICAgcGxheWxpc3RUeXBlXG4gICAgICApO1xuICAgICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXG4gICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgY29uc3QgYnVmZmVyZWQgPSBidWZmZXJlZEluZm8gJiYgYnVmZmVyZWRJbmZvLmxlbiA+IDAuNTtcbiAgICAgIGlmIChidWZmZXJlZCkge1xuICAgICAgICB0aGlzLnJlZHVjZU1heEJ1ZmZlckxlbmd0aChidWZmZXJlZEluZm8ubGVuKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZsdXNoQnVmZmVyID0gIWJ1ZmZlcmVkO1xuICAgICAgaWYgKGZsdXNoQnVmZmVyKSB7XG4gICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC83MDhcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBhdWRpbyBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgYEJ1ZmZlciBmdWxsIGVycm9yIHdoaWxlIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggJHtwbGF5bGlzdFR5cGV9IGJ1ZmZlcmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmZyYWcpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZGF0YS5mcmFnKTtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZGF0YS5mcmFnLnN0YXJ0O1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGZsdXNoQnVmZmVyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVzZXRGcmFnbWVudEVycm9ycyhmaWx0ZXJUeXBlOiBQbGF5bGlzdExldmVsVHlwZSkge1xuICAgIGlmIChmaWx0ZXJUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTykge1xuICAgICAgLy8gUmVzZXQgY3VycmVudCBmcmFnbWVudCBzaW5jZSBhdWRpbyB0cmFjayBhdWRpbyBpcyBlc3NlbnRpYWwgYW5kIG1heSBub3QgaGF2ZSBhIGZhaWwtb3ZlciB0cmFja1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIC8vIEZyYWdtZW50IGVycm9ycyB0aGF0IHJlc3VsdCBpbiBhIGxldmVsIHN3aXRjaCBvciByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgLy8gc2hvdWxkIHJlc2V0IHRoZSBzdHJlYW0gY29udHJvbGxlciBzdGF0ZSB0byBpZGxlXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFmdGVyQnVmZmVyRmx1c2hlZChcbiAgICBtZWRpYTogQnVmZmVyYWJsZSxcbiAgICBidWZmZXJUeXBlOiBTb3VyY2VCdWZmZXJOYW1lLFxuICAgIHBsYXlsaXN0VHlwZTogUGxheWxpc3RMZXZlbFR5cGVcbiAgKSB7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBBZnRlciBzdWNjZXNzZnVsIGJ1ZmZlciBmbHVzaGluZywgZmlsdGVyIGZsdXNoZWQgZnJhZ21lbnRzIGZyb20gYnVmZmVyZWRGcmFncyB1c2UgbWVkaWFCdWZmZXJlZCBpbnN0ZWFkIG9mIG1lZGlhXG4gICAgLy8gKHNvIHRoYXQgd2Ugd2lsbCBjaGVjayBhZ2FpbnN0IHZpZGVvLmJ1ZmZlcmVkIHJhbmdlcyBpbiBjYXNlIG9mIGFsdCBhdWRpbyB0cmFjaylcbiAgICBjb25zdCBidWZmZXJlZFRpbWVSYW5nZXMgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoXG4gICAgICBidWZmZXJUeXBlLFxuICAgICAgYnVmZmVyZWRUaW1lUmFuZ2VzLFxuICAgICAgcGxheWxpc3RUeXBlXG4gICAgKTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVzZXRMb2FkaW5nU3RhdGUoKSB7XG4gICAgdGhpcy5sb2coJ1Jlc2V0IGxvYWRpbmcgc3RhdGUnKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQobGV2ZWw6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgZmlyc3QgZnJhZyByZXF1ZXN0IGZhaWxlZFxuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkZXRhaWxzID0gdGhpcy5sZXZlbHMgPyB0aGlzLmxldmVsc1tsZXZlbF0uZGV0YWlscyA6IG51bGw7XG4gICAgICBpZiAoZGV0YWlscz8ubGl2ZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHN0YXJ0IHBvc2l0aW9uIGFuZCByZXR1cm4gdG8gSURMRSB0byByZWNvdmVyIGxpdmUgc3RhcnRcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gLTE7XG4gICAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbihkZXRhaWxzLCAwKTtcbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCByZXNldFdoZW5NaXNzaW5nQ29udGV4dChjaHVua01ldGE6IENodW5rTWV0YWRhdGEpIHtcbiAgICB0aGlzLndhcm4oXG4gICAgICBgVGhlIGxvYWRpbmcgY29udGV4dCBjaGFuZ2VkIHdoaWxlIGJ1ZmZlcmluZyBmcmFnbWVudCAke2NodW5rTWV0YS5zbn0gb2YgbGV2ZWwgJHtjaHVua01ldGEubGV2ZWx9LiBUaGlzIGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLmBcbiAgICApO1xuICAgIHRoaXMucmVtb3ZlVW5idWZmZXJlZEZyYWdzKCk7XG4gICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZChjaHVua01ldGEubGV2ZWwpO1xuICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW1vdmVVbmJ1ZmZlcmVkRnJhZ3Moc3RhcnQ6IG51bWJlciA9IDApIHtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKFxuICAgICAgc3RhcnQsXG4gICAgICBJbmZpbml0eSxcbiAgICAgIHRoaXMucGxheWxpc3RUeXBlLFxuICAgICAgZmFsc2UsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlTGV2ZWxUaW1pbmcoXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAgcGFydDogUGFydCB8IG51bGwsXG4gICAgbGV2ZWw6IExldmVsLFxuICAgIHBhcnRpYWw6IGJvb2xlYW5cbiAgKSB7XG4gICAgY29uc3QgZGV0YWlscyA9IGxldmVsLmRldGFpbHMgYXMgTGV2ZWxEZXRhaWxzO1xuICAgIGlmICghZGV0YWlscykge1xuICAgICAgdGhpcy53YXJuKCdsZXZlbC5kZXRhaWxzIHVuZGVmaW5lZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSBPYmplY3Qua2V5cyhmcmFnLmVsZW1lbnRhcnlTdHJlYW1zKS5yZWR1Y2UoXG4gICAgICAocmVzdWx0LCB0eXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zW3R5cGVdO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZER1cmF0aW9uID0gaW5mby5lbmRQVFMgLSBpbmZvLnN0YXJ0UFRTO1xuICAgICAgICAgIGlmIChwYXJzZWREdXJhdGlvbiA8PSAwKSB7XG4gICAgICAgICAgICAvLyBEZXN0cm95IHRoZSB0cmFuc211eGVyIGFmdGVyIGl0J3MgbmV4dCB0aW1lIG9mZnNldCBmYWlsZWQgdG8gYWR2YW5jZSBiZWNhdXNlIGR1cmF0aW9uIHdhcyA8PSAwLlxuICAgICAgICAgICAgLy8gVGhlIG5ldyB0cmFuc211eGVyIHdpbGwgYmUgY29uZmlndXJlZCB3aXRoIGEgdGltZSBvZmZzZXQgbWF0Y2hpbmcgdGhlIG5leHQgZnJhZ21lbnQgc3RhcnQsXG4gICAgICAgICAgICAvLyBwcmV2ZW50aW5nIHRoZSB0aW1lbGluZSBmcm9tIHNoaWZ0aW5nLlxuICAgICAgICAgICAgdGhpcy53YXJuKFxuICAgICAgICAgICAgICBgQ291bGQgbm90IHBhcnNlIGZyYWdtZW50ICR7ZnJhZy5zbn0gJHt0eXBlfSBkdXJhdGlvbiByZWxpYWJseSAoJHtwYXJzZWREdXJhdGlvbn0pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRyaWZ0ID0gcGFydGlhbFxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IHVwZGF0ZUZyYWdQVFNEVFMoXG4gICAgICAgICAgICAgICAgZGV0YWlscyxcbiAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgIGluZm8uc3RhcnRQVFMsXG4gICAgICAgICAgICAgICAgaW5mby5lbmRQVFMsXG4gICAgICAgICAgICAgICAgaW5mby5zdGFydERUUyxcbiAgICAgICAgICAgICAgICBpbmZvLmVuZERUU1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1BUU19VUERBVEVELCB7XG4gICAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICBkcmlmdCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgc3RhcnQ6IGluZm8uc3RhcnRQVFMsXG4gICAgICAgICAgICBlbmQ6IGluZm8uZW5kUFRTLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc211eGVyPy5lcnJvciA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBGb3VuZCBubyBtZWRpYSBpbiBmcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7bGV2ZWwuaWR9IHJlc2V0dGluZyB0cmFuc211eGVyIHRvIGZhbGxiYWNrIHRvIHBsYXlsaXN0IHRpbWluZ2BcbiAgICAgICk7XG4gICAgICB0aGlzLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmcmFnLFxuICAgICAgICByZWFzb246IGBGb3VuZCBubyBtZWRpYSBpbiBtc24gJHtmcmFnLnNufSBvZiBsZXZlbCBcIiR7bGV2ZWwudXJsfVwiYCxcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgLy8gRm9yIHRoaXMgZXJyb3IgZmFsbHRocm91Z2guIE1hcmtpbmcgcGFyc2VkIHdpbGwgYWxsb3cgYWR2YW5jaW5nIHRvIG5leHQgZnJhZ21lbnQuXG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTRUQsIHsgZnJhZywgcGFydCB9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZXNldFRyYW5zbXV4ZXIoKSB7XG4gICAgaWYgKHRoaXMudHJhbnNtdXhlcikge1xuICAgICAgdGhpcy50cmFuc211eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHJlY292ZXJXb3JrZXJFcnJvcihkYXRhOiBFcnJvckRhdGEpIHtcbiAgICBpZiAoZGF0YS5ldmVudCA9PT0gJ2RlbXV4ZXJXb3JrZXInKSB7XG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHNldCBzdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICB0aGlzLmxvZyhgJHtwcmV2aW91c1N0YXRlfS0+JHtuZXh0U3RhdGV9YCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0TWVkaWFTb3VyY2UgfSBmcm9tICcuL3V0aWxzL21lZGlhc291cmNlLWhlbHBlcic7XG5pbXBvcnQgdHlwZSB7IEV4dGVuZGVkU291cmNlQnVmZmVyIH0gZnJvbSAnLi90eXBlcy9idWZmZXInO1xuXG5mdW5jdGlvbiBnZXRTb3VyY2VCdWZmZXIoKTogdHlwZW9mIHNlbGYuU291cmNlQnVmZmVyIHtcbiAgcmV0dXJuIHNlbGYuU291cmNlQnVmZmVyIHx8IChzZWxmIGFzIGFueSkuV2ViS2l0U291cmNlQnVmZmVyO1xufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xuICBjb25zdCBtZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKCk7XG4gIGlmICghbWVkaWFTb3VyY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc291cmNlQnVmZmVyID0gZ2V0U291cmNlQnVmZmVyKCk7XG4gIGNvbnN0IGlzVHlwZVN1cHBvcnRlZCA9XG4gICAgbWVkaWFTb3VyY2UgJiZcbiAgICB0eXBlb2YgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkID09PSAnZnVuY3Rpb24nICYmXG4gICAgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFLG1wNGEuNDAuMlwiJyk7XG5cbiAgLy8gaWYgU291cmNlQnVmZmVyIGlzIGV4cG9zZWQgZW5zdXJlIGl0cyBBUEkgaXMgdmFsaWRcbiAgLy8gT2xkZXIgYnJvd3NlcnMgZG8gbm90IGV4cG9zZSBTb3VyY2VCdWZmZXIgZ2xvYmFsbHkgc28gY2hlY2tpbmcgU291cmNlQnVmZmVyLnByb3RvdHlwZSBpcyBpbXBvc3NpYmxlXG4gIGNvbnN0IHNvdXJjZUJ1ZmZlclZhbGlkQVBJID1cbiAgICAhc291cmNlQnVmZmVyIHx8XG4gICAgKHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUgJiZcbiAgICAgIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLmFwcGVuZEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUucmVtb3ZlID09PSAnZnVuY3Rpb24nKTtcbiAgcmV0dXJuICEhaXNUeXBlU3VwcG9ydGVkICYmICEhc291cmNlQnVmZmVyVmFsaWRBUEk7XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlVHlwZVN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgY29uc3Qgc291cmNlQnVmZmVyID0gZ2V0U291cmNlQnVmZmVyKCk7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIChzb3VyY2VCdWZmZXI/LnByb3RvdHlwZSBhcyBFeHRlbmRlZFNvdXJjZUJ1ZmZlcik/LmNoYW5nZVR5cGUgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuICApO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBEZW11eGVkVHJhY2sgfSBmcm9tICcuLi90eXBlcy9kZW11eGVyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGR1bW15VHJhY2sodHlwZSA9ICcnLCBpbnB1dFRpbWVTY2FsZSA9IDkwMDAwKTogRGVtdXhlZFRyYWNrIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGlkOiAtMSxcbiAgICBwaWQ6IC0xLFxuICAgIGlucHV0VGltZVNjYWxlLFxuICAgIHNlcXVlbmNlTnVtYmVyOiAtMSxcbiAgICBzYW1wbGVzOiBbXSxcbiAgICBkcm9wcGVkOiAwLFxuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XG5pbXBvcnQge1xuICBEZW11eGVyUmVzdWx0LFxuICBEZW11eGVyLFxuICBEZW11eGVkQXVkaW9UcmFjayxcbiAgQXVkaW9GcmFtZSxcbiAgRGVtdXhlZE1ldGFkYXRhVHJhY2ssXG4gIERlbXV4ZWRWaWRlb1RyYWNrLFxuICBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgS2V5RGF0YSxcbiAgTWV0YWRhdGFTY2hlbWEsXG59IGZyb20gJy4uL3R5cGVzL2RlbXV4ZXInO1xuaW1wb3J0IHsgZHVtbXlUcmFjayB9IGZyb20gJy4vZHVtbXktZGVtdXhlZC10cmFjayc7XG5pbXBvcnQgeyBhcHBlbmRVaW50OEFycmF5IH0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcbmltcG9ydCB7IHNsaWNlVWludDggfSBmcm9tICcuLi91dGlscy90eXBlZC1hcnJheSc7XG5pbXBvcnQgeyBSYXRpb25hbFRpbWVzdGFtcCB9IGZyb20gJy4uL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uJztcblxuY2xhc3MgQmFzZUF1ZGlvRGVtdXhlciBpbXBsZW1lbnRzIERlbXV4ZXIge1xuICBwcm90ZWN0ZWQgX2F1ZGlvVHJhY2shOiBEZW11eGVkQXVkaW9UcmFjaztcbiAgcHJvdGVjdGVkIF9pZDNUcmFjayE6IERlbXV4ZWRNZXRhZGF0YVRyYWNrO1xuICBwcm90ZWN0ZWQgZnJhbWVJbmRleDogbnVtYmVyID0gMDtcbiAgcHJvdGVjdGVkIGNhY2hlZERhdGE6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIGJhc2VQVFM6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgaW5pdFBUUzogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIGxhc3RQVFM6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIHJlc2V0SW5pdFNlZ21lbnQoXG4gICAgaW5pdFNlZ21lbnQ6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQsXG4gICAgYXVkaW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHZpZGVvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB0cmFja0R1cmF0aW9uOiBudW1iZXJcbiAgKSB7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB7XG4gICAgICB0eXBlOiAnaWQzJyxcbiAgICAgIGlkOiAzLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBkcm9wcGVkOiAwLFxuICAgIH07XG4gIH1cblxuICByZXNldFRpbWVTdGFtcChkZWF1bHRUaW1lc3RhbXA6IFJhdGlvbmFsVGltZXN0YW1wIHwgbnVsbCkge1xuICAgIHRoaXMuaW5pdFBUUyA9IGRlYXVsdFRpbWVzdGFtcDtcbiAgICB0aGlzLnJlc2V0Q29udGlndWl0eSgpO1xuICB9XG5cbiAgcmVzZXRDb250aWd1aXR5KCk6IHZvaWQge1xuICAgIHRoaXMuYmFzZVBUUyA9IG51bGw7XG4gICAgdGhpcy5sYXN0UFRTID0gbnVsbDtcbiAgICB0aGlzLmZyYW1lSW5kZXggPSAwO1xuICB9XG5cbiAgY2FuUGFyc2UoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBhcHBlbmRGcmFtZShcbiAgICB0cmFjazogRGVtdXhlZEF1ZGlvVHJhY2ssXG4gICAgZGF0YTogVWludDhBcnJheSxcbiAgICBvZmZzZXQ6IG51bWJlclxuICApOiBBdWRpb0ZyYW1lIHwgdm9pZCB7fVxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgZGVtdXgoZGF0YTogVWludDhBcnJheSwgdGltZU9mZnNldDogbnVtYmVyKTogRGVtdXhlclJlc3VsdCB7XG4gICAgaWYgKHRoaXMuY2FjaGVkRGF0YSkge1xuICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5jYWNoZWREYXRhLCBkYXRhKTtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGlkM0RhdGE6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCAwKTtcbiAgICBsZXQgb2Zmc2V0ID0gaWQzRGF0YSA/IGlkM0RhdGEubGVuZ3RoIDogMDtcbiAgICBsZXQgbGFzdERhdGFJbmRleDtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjaztcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBpZDNEYXRhID8gSUQzLmdldFRpbWVTdGFtcChpZDNEYXRhKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuYmFzZVBUUyA9PT0gbnVsbCB8fFxuICAgICAgKHRoaXMuZnJhbWVJbmRleCA9PT0gMCAmJiBOdW1iZXIuaXNGaW5pdGUodGltZXN0YW1wKSlcbiAgICApIHtcbiAgICAgIHRoaXMuYmFzZVBUUyA9IGluaXRQVFNGbih0aW1lc3RhbXAsIHRpbWVPZmZzZXQsIHRoaXMuaW5pdFBUUyk7XG4gICAgICB0aGlzLmxhc3RQVFMgPSB0aGlzLmJhc2VQVFM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGFzdFBUUyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sYXN0UFRTID0gdGhpcy5iYXNlUFRTO1xuICAgIH1cblxuICAgIC8vIG1vcmUgZXhwcmVzc2l2ZSB0aGFuIGFsdGVybmF0aXZlOiBpZDNEYXRhPy5sZW5ndGhcbiAgICBpZiAoaWQzRGF0YSAmJiBpZDNEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgIHB0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICBkdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgZGF0YTogaWQzRGF0YSxcbiAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5jYW5QYXJzZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZUluZGV4Kys7XG4gICAgICAgICAgdGhpcy5sYXN0UFRTID0gZnJhbWUuc2FtcGxlLnB0cztcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKElEMy5jYW5QYXJzZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIC8vIGFmdGVyIGEgSUQzLmNhblBhcnNlLCBhIGNhbGwgdG8gSUQzLmdldElEM0RhdGEgKnNob3VsZCogYWx3YXlzIHJldHVybnMgc29tZSBkYXRhXG4gICAgICAgIGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCBvZmZzZXQpITtcbiAgICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICBwdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgICBkdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgICBkYXRhOiBpZDNEYXRhLFxuICAgICAgICAgIHR5cGU6IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzLFxuICAgICAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZzZXQgKz0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCAmJiBsYXN0RGF0YUluZGV4ICE9PSBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcGFydGlhbERhdGEgPSBzbGljZVVpbnQ4KGRhdGEsIGxhc3REYXRhSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICAgICAgdGhpcy5jYWNoZWREYXRhID0gYXBwZW5kVWludDhBcnJheSh0aGlzLmNhY2hlZERhdGEsIHBhcnRpYWxEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBwYXJ0aWFsRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhdWRpb1RyYWNrOiB0cmFjayxcbiAgICAgIHZpZGVvVHJhY2s6IGR1bW15VHJhY2soKSBhcyBEZW11eGVkVmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiBkdW1teVRyYWNrKCkgYXMgRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gICAgfTtcbiAgfVxuXG4gIGRlbXV4U2FtcGxlQWVzKFxuICAgIGRhdGE6IFVpbnQ4QXJyYXksXG4gICAga2V5RGF0YTogS2V5RGF0YSxcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXJcbiAgKTogUHJvbWlzZTxEZW11eGVyUmVzdWx0PiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgbmV3IEVycm9yKGBbJHt0aGlzfV0gVGhpcyBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU2FtcGxlLUFFUyBkZWNyeXB0aW9uYClcbiAgICApO1xuICB9XG5cbiAgZmx1c2godGltZU9mZnNldDogbnVtYmVyKTogRGVtdXhlclJlc3VsdCB7XG4gICAgLy8gUGFyc2UgY2FjaGUgaW4gY2FzZSBvZiByZW1haW5pbmcgZnJhbWVzLlxuICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLmNhY2hlZERhdGE7XG4gICAgaWYgKGNhY2hlZERhdGEpIHtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLmRlbXV4KGNhY2hlZERhdGEsIDApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhdWRpb1RyYWNrOiB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjazogZHVtbXlUcmFjaygpIGFzIERlbXV4ZWRWaWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2s6IHRoaXMuX2lkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiBkdW1teVRyYWNrKCkgYXMgRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gICAgfTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7fVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgUFRTXG4gKiA8cD5cbiAqICAgIHVzZSB0aW1lc3RhbXAgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgTmFOIG9yIEluZmluaXR5XG4gKiA8L3A+XG4gKi9cbmV4cG9ydCBjb25zdCBpbml0UFRTRm4gPSAoXG4gIHRpbWVzdGFtcDogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gIGluaXRQVFM6IFJhdGlvbmFsVGltZXN0YW1wIHwgbnVsbFxuKTogbnVtYmVyID0+IHtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZSh0aW1lc3RhbXAgYXMgbnVtYmVyKSkge1xuICAgIHJldHVybiB0aW1lc3RhbXAhICogOTA7XG4gIH1cbiAgY29uc3QgaW5pdDkwa0h6ID0gaW5pdFBUU1xuICAgID8gKGluaXRQVFMuYmFzZVRpbWUgKiA5MDAwMCkgLyBpbml0UFRTLnRpbWVzY2FsZVxuICAgIDogMDtcbiAgcmV0dXJuIHRpbWVPZmZzZXQgKiA5MDAwMCArIGluaXQ5MGtIejtcbn07XG5leHBvcnQgZGVmYXVsdCBCYXNlQXVkaW9EZW11eGVyO1xuIiwiLyoqXG4gKiBBRFRTIHBhcnNlciBoZWxwZXJcbiAqIEBsaW5rIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gKi9cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHR5cGUgeyBIbHNFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHtcbiAgRGVtdXhlZEF1ZGlvVHJhY2ssXG4gIEF1ZGlvRnJhbWUsXG4gIEF1ZGlvU2FtcGxlLFxufSBmcm9tICcuLi90eXBlcy9kZW11eGVyJztcblxudHlwZSBBdWRpb0NvbmZpZyA9IHtcbiAgY29uZmlnOiBudW1iZXJbXTtcbiAgc2FtcGxlcmF0ZTogbnVtYmVyO1xuICBjaGFubmVsQ291bnQ6IG51bWJlcjtcbiAgY29kZWM6IHN0cmluZztcbiAgbWFuaWZlc3RDb2RlYzogc3RyaW5nO1xufTtcblxudHlwZSBGcmFtZUhlYWRlciA9IHtcbiAgaGVhZGVyTGVuZ3RoOiBudW1iZXI7XG4gIGZyYW1lTGVuZ3RoOiBudW1iZXI7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXVkaW9Db25maWcoXG4gIG9ic2VydmVyLFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgYXVkaW9Db2RlYzogc3RyaW5nXG4pOiBBdWRpb0NvbmZpZyB8IHZvaWQge1xuICBsZXQgYWR0c09iamVjdFR5cGU6IG51bWJlcjtcbiAgbGV0IGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4OiBudW1iZXI7XG4gIGxldCBhZHRzQ2hhbm5lbENvbmZpZzogbnVtYmVyO1xuICBsZXQgY29uZmlnOiBudW1iZXJbXTtcbiAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBtYW5pZmVzdENvZGVjID0gYXVkaW9Db2RlYztcbiAgY29uc3QgYWR0c1NhbXBsaW5nUmF0ZXMgPSBbXG4gICAgOTYwMDAsIDg4MjAwLCA2NDAwMCwgNDgwMDAsIDQ0MTAwLCAzMjAwMCwgMjQwMDAsIDIyMDUwLCAxNjAwMCwgMTIwMDAsIDExMDI1LFxuICAgIDgwMDAsIDczNTAsXG4gIF07XG4gIC8vIGJ5dGUgMlxuICBhZHRzT2JqZWN0VHlwZSA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4YzApID4+PiA2KSArIDE7XG4gIGNvbnN0IGFkdHNTYW1wbGluZ0luZGV4ID0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDNjKSA+Pj4gMjtcbiAgaWYgKGFkdHNTYW1wbGluZ0luZGV4ID4gYWR0c1NhbXBsaW5nUmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgcmVhc29uOiBgaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OiR7YWR0c1NhbXBsaW5nSW5kZXh9YCxcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgYWR0c0NoYW5uZWxDb25maWcgPSAoZGF0YVtvZmZzZXQgKyAyXSAmIDB4MDEpIDw8IDI7XG4gIC8vIGJ5dGUgM1xuICBhZHRzQ2hhbm5lbENvbmZpZyB8PSAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4YzApID4+PiA2O1xuICBsb2dnZXIubG9nKFxuICAgIGBtYW5pZmVzdCBjb2RlYzoke2F1ZGlvQ29kZWN9LCBBRFRTIHR5cGU6JHthZHRzT2JqZWN0VHlwZX0sIHNhbXBsaW5nSW5kZXg6JHthZHRzU2FtcGxpbmdJbmRleH1gXG4gICk7XG4gIC8vIGZpcmVmb3g6IGZyZXEgbGVzcyB0aGFuIDI0a0h6ID0gQUFDIFNCUiAoSEUtQUFDKVxuICBpZiAoL2ZpcmVmb3gvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICBpZiAoYWR0c1NhbXBsaW5nSW5kZXggPj0gNikge1xuICAgICAgYWR0c09iamVjdFR5cGUgPSA1O1xuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXggLSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICAgIH1cbiAgICAvLyBBbmRyb2lkIDogYWx3YXlzIHVzZSBBQUNcbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xuICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleDtcbiAgfSBlbHNlIHtcbiAgICAvKiAgZm9yIG90aGVyIGJyb3dzZXJzIChDaHJvbWUvVml2YWxkaS9PcGVyYSAuLi4pXG4gICAgICAgIGFsd2F5cyBmb3JjZSBhdWRpbyB0eXBlIHRvIGJlIEhFLUFBQyBTQlIsIGFzIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYXVkaW8gY29kZWMgc3dpdGNoIHByb3Blcmx5IChsaWtlIENocm9tZSAuLi4pXG4gICAgKi9cbiAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBIRS1BQUMgb3IgSEUtQUFDdjIpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIEFORCBmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6KVxuICAgIGlmIChcbiAgICAgIChhdWRpb0NvZGVjICYmXG4gICAgICAgIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMjknKSAhPT0gLTEgfHxcbiAgICAgICAgICBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkpIHx8XG4gICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsaW5nSW5kZXggPj0gNilcbiAgICApIHtcbiAgICAgIC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xuICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4IC0gMztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEFBQykgQU5EIChmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6IEFORCBuYiBjaGFubmVsIGlzIDEpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIGFuZCBtb25vIGF1ZGlvKVxuICAgICAgLy8gQ2hyb21lIGZhaWxzIHRvIHBsYXkgYmFjayB3aXRoIGxvdyBmcmVxdWVuY3kgQUFDIExDIG1vbm8gd2hlbiBpbml0aWFsaXplZCB3aXRoIEhFLUFBQy4gIFRoaXMgaXMgbm90IGEgcHJvYmxlbSB3aXRoIHN0ZXJlby5cbiAgICAgIGlmIChcbiAgICAgICAgKGF1ZGlvQ29kZWMgJiZcbiAgICAgICAgICBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSAmJlxuICAgICAgICAgICgoYWR0c1NhbXBsaW5nSW5kZXggPj0gNiAmJiBhZHRzQ2hhbm5lbENvbmZpZyA9PT0gMSkgfHxcbiAgICAgICAgICAgIC92aXZhbGRpL2kudGVzdCh1c2VyQWdlbnQpKSkgfHxcbiAgICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNDaGFubmVsQ29uZmlnID09PSAxKVxuICAgICAgKSB7XG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgfVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleDtcbiAgICB9XG4gIH1cbiAgLyogcmVmZXIgdG8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0F1ZGlvX1NwZWNpZmljX0NvbmZpZ1xuICAgICAgSVNPIDE0NDk2LTMgKEFBQykucGRmIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxuICAgIEF1ZGlvIFByb2ZpbGUgLyBBdWRpbyBPYmplY3QgVHlwZVxuICAgIDA6IE51bGxcbiAgICAxOiBBQUMgTWFpblxuICAgIDI6IEFBQyBMQyAoTG93IENvbXBsZXhpdHkpXG4gICAgMzogQUFDIFNTUiAoU2NhbGFibGUgU2FtcGxlIFJhdGUpXG4gICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXG4gICAgNTogU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKVxuICAgIDY6IEFBQyBTY2FsYWJsZVxuICAgc2FtcGxpbmcgZnJlcVxuICAgIDA6IDk2MDAwIEh6XG4gICAgMTogODgyMDAgSHpcbiAgICAyOiA2NDAwMCBIelxuICAgIDM6IDQ4MDAwIEh6XG4gICAgNDogNDQxMDAgSHpcbiAgICA1OiAzMjAwMCBIelxuICAgIDY6IDI0MDAwIEh6XG4gICAgNzogMjIwNTAgSHpcbiAgICA4OiAxNjAwMCBIelxuICAgIDk6IDEyMDAwIEh6XG4gICAgMTA6IDExMDI1IEh6XG4gICAgMTE6IDgwMDAgSHpcbiAgICAxMjogNzM1MCBIelxuICAgIDEzOiBSZXNlcnZlZFxuICAgIDE0OiBSZXNlcnZlZFxuICAgIDE1OiBmcmVxdWVuY3kgaXMgd3JpdHRlbiBleHBsaWN0bHlcbiAgICBDaGFubmVsIENvbmZpZ3VyYXRpb25zXG4gICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxuICAgIDA6IERlZmluZWQgaW4gQU9UIFNwZWNpZmMgQ29uZmlnXG4gICAgMTogMSBjaGFubmVsOiBmcm9udC1jZW50ZXJcbiAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxuICAqL1xuICAvLyBhdWRpb09iamVjdFR5cGUgPSBwcm9maWxlID0+IHByb2ZpbGUsIHRoZSBNUEVHLTQgQXVkaW8gT2JqZWN0IFR5cGUgbWludXMgMVxuICBjb25maWdbMF0gPSBhZHRzT2JqZWN0VHlwZSA8PCAzO1xuICAvLyBzYW1wbGluZ0ZyZXF1ZW5jeUluZGV4XG4gIGNvbmZpZ1swXSB8PSAoYWR0c1NhbXBsaW5nSW5kZXggJiAweDBlKSA+PiAxO1xuICBjb25maWdbMV0gfD0gKGFkdHNTYW1wbGluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgLy8gY2hhbm5lbENvbmZpZ3VyYXRpb25cbiAgY29uZmlnWzFdIHw9IGFkdHNDaGFubmVsQ29uZmlnIDw8IDM7XG4gIGlmIChhZHRzT2JqZWN0VHlwZSA9PT0gNSkge1xuICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4XG4gICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCAmIDB4MGUpID4+IDE7XG4gICAgY29uZmlnWzJdID0gKGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXG4gICAgY29uZmlnWzJdIHw9IDIgPDwgMjtcbiAgICBjb25maWdbM10gPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29uZmlnLFxuICAgIHNhbXBsZXJhdGU6IGFkdHNTYW1wbGluZ1JhdGVzW2FkdHNTYW1wbGluZ0luZGV4XSxcbiAgICBjaGFubmVsQ291bnQ6IGFkdHNDaGFubmVsQ29uZmlnLFxuICAgIGNvZGVjOiAnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGUsXG4gICAgbWFuaWZlc3RDb2RlYyxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSGVhZGVyUGF0dGVybihkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhmNikgPT09IDB4ZjA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIZWFkZXJMZW5ndGgoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDEgPyA3IDogOTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiAoXG4gICAgKChkYXRhW29mZnNldCArIDNdICYgMHgwMykgPDwgMTEpIHxcbiAgICAoZGF0YVtvZmZzZXQgKyA0XSA8PCAzKSB8XG4gICAgKChkYXRhW29mZnNldCArIDVdICYgMHhlMCkgPj4+IDUpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW5HZXRGcmFtZUxlbmd0aChkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICByZXR1cm4gb2Zmc2V0ICsgNSA8IGRhdGEubGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIZWFkZXIoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgMCBmb3IgQURUU1xuICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgcmV0dXJuIG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhblBhcnNlKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgY2FuR2V0RnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSAmJlxuICAgIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpICYmXG4gICAgZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgPD0gZGF0YS5sZW5ndGggLSBvZmZzZXRcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2JlKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBBRFRTIGZyYW1lIGZvbGxvd3MgbGFzdCBBRFRTIGZyYW1lXG4gIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgaWYgKGlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBBRFRTIGhlYWRlciBMZW5ndGhcbiAgICBjb25zdCBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFEVFMgZnJhbWUgTGVuZ3RoXG4gICAgY29uc3QgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICBpZiAoZnJhbWVMZW5ndGggPD0gaGVhZGVyTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0VHJhY2tDb25maWcoXG4gIHRyYWNrOiBEZW11eGVkQXVkaW9UcmFjayxcbiAgb2JzZXJ2ZXI6IEhsc0V2ZW50RW1pdHRlcixcbiAgZGF0YTogVWludDhBcnJheSxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIGF1ZGlvQ29kZWM6IHN0cmluZ1xuKSB7XG4gIGlmICghdHJhY2suc2FtcGxlcmF0ZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgdHJhY2suc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgdHJhY2subWFuaWZlc3RDb2RlYyA9IGNvbmZpZy5tYW5pZmVzdENvZGVjO1xuICAgIGxvZ2dlci5sb2coXG4gICAgICBgcGFyc2VkIGNvZGVjOiR7dHJhY2suY29kZWN9LCByYXRlOiR7Y29uZmlnLnNhbXBsZXJhdGV9LCBjaGFubmVsczoke2NvbmZpZy5jaGFubmVsQ291bnR9YFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYW1lRHVyYXRpb24oc2FtcGxlcmF0ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuICgxMDI0ICogOTAwMDApIC8gc2FtcGxlcmF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRnJhbWVIZWFkZXIoXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4gIG9mZnNldDogbnVtYmVyXG4pOiBGcmFtZUhlYWRlciB8IHZvaWQge1xuICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgY29uc3QgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gIGlmIChvZmZzZXQgKyBoZWFkZXJMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgY29uc3QgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSAtIGhlYWRlckxlbmd0aDtcbiAgICBpZiAoZnJhbWVMZW5ndGggPiAwKSB7XG4gICAgICAvLyBsb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9YCk7XG4gICAgICByZXR1cm4geyBoZWFkZXJMZW5ndGgsIGZyYW1lTGVuZ3RoIH07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRGcmFtZShcbiAgdHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgcHRzOiBudW1iZXIsXG4gIGZyYW1lSW5kZXg6IG51bWJlclxuKTogQXVkaW9GcmFtZSB7XG4gIGNvbnN0IGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUgYXMgbnVtYmVyKTtcbiAgY29uc3Qgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgY29uc3QgaGVhZGVyID0gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICBsZXQgdW5pdDogVWludDhBcnJheTtcbiAgaWYgKGhlYWRlcikge1xuICAgIGNvbnN0IHsgZnJhbWVMZW5ndGgsIGhlYWRlckxlbmd0aCB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoO1xuICAgIGNvbnN0IG1pc3NpbmcgPSBNYXRoLm1heCgwLCBvZmZzZXQgKyBsZW5ndGggLSBkYXRhLmxlbmd0aCk7XG4gICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lICR7ZnJhbWVJbmRleH0sIHB0czoke3N0YW1wfSBsZW5ndGhAb2Zmc2V0L3RvdGFsOiAke2ZyYW1lTGVuZ3RofUAke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofSBtaXNzaW5nOiAke21pc3Npbmd9YCk7XG4gICAgaWYgKG1pc3NpbmcpIHtcbiAgICAgIHVuaXQgPSBuZXcgVWludDhBcnJheShsZW5ndGggLSBoZWFkZXJMZW5ndGgpO1xuICAgICAgdW5pdC5zZXQoZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIGRhdGEubGVuZ3RoKSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXQgPSBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzYW1wbGU6IEF1ZGlvU2FtcGxlID0ge1xuICAgICAgdW5pdCxcbiAgICAgIHB0czogc3RhbXAsXG4gICAgfTtcbiAgICBpZiAoIW1pc3NpbmcpIHtcbiAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChzYW1wbGUgYXMgQXVkaW9TYW1wbGUpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHNhbXBsZSwgbGVuZ3RoLCBtaXNzaW5nIH07XG4gIH1cbiAgLy8gb3ZlcmZsb3cgaW5jb21wbGV0ZSBoZWFkZXJcbiAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG4gIHVuaXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICB1bml0LnNldChkYXRhLnN1YmFycmF5KG9mZnNldCwgZGF0YS5sZW5ndGgpLCAwKTtcbiAgY29uc3Qgc2FtcGxlOiBBdWRpb1NhbXBsZSA9IHtcbiAgICB1bml0LFxuICAgIHB0czogc3RhbXAsXG4gIH07XG4gIHJldHVybiB7IHNhbXBsZSwgbGVuZ3RoLCBtaXNzaW5nOiAtMSB9O1xufVxuIiwiLyoqXG4gKiBBQUMgZGVtdXhlclxuICovXG5pbXBvcnQgQmFzZUF1ZGlvRGVtdXhlciBmcm9tICcuL2Jhc2UtYXVkaW8tZGVtdXhlcic7XG5pbXBvcnQgKiBhcyBBRFRTIGZyb20gJy4vYWR0cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0ICogYXMgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XG5pbXBvcnQgdHlwZSB7IEhsc0V2ZW50RW1pdHRlciB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IEhsc0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5cbmNsYXNzIEFBQ0RlbXV4ZXIgZXh0ZW5kcyBCYXNlQXVkaW9EZW11eGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBvYnNlcnZlcjogSGxzRXZlbnRFbWl0dGVyO1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogSGxzQ29uZmlnO1xuXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQoXG4gICAgaW5pdFNlZ21lbnQ6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQsXG4gICAgYXVkaW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHZpZGVvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB0cmFja0R1cmF0aW9uOiBudW1iZXJcbiAgKSB7XG4gICAgc3VwZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL2FkdHMnLFxuICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2VnbWVudENvZGVjOiAnYWFjJyxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgZHJvcHBlZDogMCxcbiAgICB9O1xuICB9XG5cbiAgLy8gU291cmNlIGZvciBwcm9iZSBpbmZvIC0gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgc3RhdGljIHByb2JlKGRhdGEpOiBib29sZWFuIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgdGhlIEFEVFMgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gICAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgY29uc3QgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApIHx8IFtdO1xuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoQURUUy5wcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBBRFRTLmNhblBhcnNlKGRhdGEsIG9mZnNldCk7XG4gIH1cblxuICBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KSB7XG4gICAgQURUUy5pbml0VHJhY2tDb25maWcoXG4gICAgICB0cmFjayxcbiAgICAgIHRoaXMub2JzZXJ2ZXIsXG4gICAgICBkYXRhLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdHJhY2subWFuaWZlc3RDb2RlY1xuICAgICk7XG4gICAgY29uc3QgZnJhbWUgPSBBRFRTLmFwcGVuZEZyYW1lKFxuICAgICAgdHJhY2ssXG4gICAgICBkYXRhLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdGhpcy5iYXNlUFRTIGFzIG51bWJlcixcbiAgICAgIHRoaXMuZnJhbWVJbmRleFxuICAgICk7XG4gICAgaWYgKGZyYW1lICYmIGZyYW1lLm1pc3NpbmcgPT09IDApIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQUFDRGVtdXhlcjtcbiIsIi8qKlxuICogTVA0IGRlbXV4ZXJcbiAqL1xuaW1wb3J0IHtcbiAgRGVtdXhlcixcbiAgRGVtdXhlclJlc3VsdCxcbiAgUGFzc3Rocm91Z2hUcmFjayxcbiAgRGVtdXhlZEF1ZGlvVHJhY2ssXG4gIERlbXV4ZWRVc2VyZGF0YVRyYWNrLFxuICBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgS2V5RGF0YSxcbiAgTWV0YWRhdGFTY2hlbWEsXG59IGZyb20gJy4uL3R5cGVzL2RlbXV4ZXInO1xuaW1wb3J0IHtcbiAgZmluZEJveCxcbiAgc2VnbWVudFZhbGlkUmFuZ2UsXG4gIGFwcGVuZFVpbnQ4QXJyYXksXG4gIHBhcnNlRW1zZyxcbiAgcGFyc2VTYW1wbGVzLFxuICBwYXJzZUluaXRTZWdtZW50LFxuICBSZW11eGVyVHJhY2tJZENvbmZpZyxcbn0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcbmltcG9ydCB7IGR1bW15VHJhY2sgfSBmcm9tICcuL2R1bW15LWRlbXV4ZWQtdHJhY2snO1xuaW1wb3J0IHR5cGUgeyBIbHNFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuXG5jb25zdCBlbXNnU2NoZW1lUGF0dGVybiA9IC9cXC9lbXNnWy0vXUlEMy9pO1xuXG5jbGFzcyBNUDREZW11eGVyIGltcGxlbWVudHMgRGVtdXhlciB7XG4gIHByaXZhdGUgcmVtYWluZGVyRGF0YTogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHRpbWVPZmZzZXQ6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgY29uZmlnOiBIbHNDb25maWc7XG4gIHByaXZhdGUgdmlkZW9UcmFjaz86IFBhc3N0aHJvdWdoVHJhY2s7XG4gIHByaXZhdGUgYXVkaW9UcmFjaz86IERlbXV4ZWRBdWRpb1RyYWNrO1xuICBwcml2YXRlIGlkM1RyYWNrPzogRGVtdXhlZE1ldGFkYXRhVHJhY2s7XG4gIHByaXZhdGUgdHh0VHJhY2s/OiBEZW11eGVkVXNlcmRhdGFUcmFjaztcblxuICBjb25zdHJ1Y3RvcihvYnNlcnZlcjogSGxzRXZlbnRFbWl0dGVyLCBjb25maWc6IEhsc0NvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgcHVibGljIHJlc2V0VGltZVN0YW1wKCkge31cblxuICBwdWJsaWMgcmVzZXRJbml0U2VnbWVudChcbiAgICBpbml0U2VnbWVudDogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgICBhdWRpb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdmlkZW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHRyYWNrRHVyYXRpb246IG51bWJlclxuICApIHtcbiAgICBjb25zdCB2aWRlb1RyYWNrID0gKHRoaXMudmlkZW9UcmFjayA9IGR1bW15VHJhY2soXG4gICAgICAndmlkZW8nLFxuICAgICAgMVxuICAgICkgYXMgUGFzc3Rocm91Z2hUcmFjayk7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9ICh0aGlzLmF1ZGlvVHJhY2sgPSBkdW1teVRyYWNrKFxuICAgICAgJ2F1ZGlvJyxcbiAgICAgIDFcbiAgICApIGFzIERlbXV4ZWRBdWRpb1RyYWNrKTtcbiAgICBjb25zdCBjYXB0aW9uVHJhY2sgPSAodGhpcy50eHRUcmFjayA9IGR1bW15VHJhY2soXG4gICAgICAndGV4dCcsXG4gICAgICAxXG4gICAgKSBhcyBEZW11eGVkVXNlcmRhdGFUcmFjayk7XG5cbiAgICB0aGlzLmlkM1RyYWNrID0gZHVtbXlUcmFjaygnaWQzJywgMSkgYXMgRGVtdXhlZE1ldGFkYXRhVHJhY2s7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gMDtcblxuICAgIGlmICghaW5pdFNlZ21lbnQ/LmJ5dGVMZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5pdERhdGEgPSBwYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KTtcblxuICAgIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgY29uc3QgeyBpZCwgdGltZXNjYWxlLCBjb2RlYyB9ID0gaW5pdERhdGEudmlkZW87XG4gICAgICB2aWRlb1RyYWNrLmlkID0gaWQ7XG4gICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IGNhcHRpb25UcmFjay50aW1lc2NhbGUgPSB0aW1lc2NhbGU7XG4gICAgICB2aWRlb1RyYWNrLmNvZGVjID0gY29kZWM7XG4gICAgfVxuXG4gICAgaWYgKGluaXREYXRhLmF1ZGlvKSB7XG4gICAgICBjb25zdCB7IGlkLCB0aW1lc2NhbGUsIGNvZGVjIH0gPSBpbml0RGF0YS5hdWRpbztcbiAgICAgIGF1ZGlvVHJhY2suaWQgPSBpZDtcbiAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gdGltZXNjYWxlO1xuICAgICAgYXVkaW9UcmFjay5jb2RlYyA9IGNvZGVjO1xuICAgIH1cblxuICAgIGNhcHRpb25UcmFjay5pZCA9IFJlbXV4ZXJUcmFja0lkQ29uZmlnLnRleHQ7XG4gICAgdmlkZW9UcmFjay5zYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgdmlkZW9UcmFjay5kdXJhdGlvbiA9IGF1ZGlvVHJhY2suZHVyYXRpb24gPSB0cmFja0R1cmF0aW9uO1xuICB9XG5cbiAgcHVibGljIHJlc2V0Q29udGlndWl0eSgpOiB2b2lkIHtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIHByb2JlKGRhdGE6IFVpbnQ4QXJyYXkpIHtcbiAgICAvLyBlbnN1cmUgd2UgZmluZCBhIG1vb2YgYm94IGluIHRoZSBmaXJzdCAxNiBrQlxuICAgIGRhdGEgPSBkYXRhLmxlbmd0aCA+IDE2Mzg0ID8gZGF0YS5zdWJhcnJheSgwLCAxNjM4NCkgOiBkYXRhO1xuICAgIHJldHVybiBmaW5kQm94KGRhdGEsIFsnbW9vZiddKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgcHVibGljIGRlbXV4KGRhdGE6IFVpbnQ4QXJyYXksIHRpbWVPZmZzZXQ6IG51bWJlcik6IERlbXV4ZXJSZXN1bHQge1xuICAgIHRoaXMudGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgLy8gTG9hZCBhbGwgZGF0YSBpbnRvIHRoZSBhdmMgdHJhY2suIFRoZSBDTUFGIHJlbXV4ZXIgd2lsbCBsb29rIGZvciB0aGUgZGF0YSBpbiB0aGUgc2FtcGxlcyBvYmplY3Q7IHRoZSByZXN0IG9mIHRoZSBmaWVsZHMgZG8gbm90IG1hdHRlclxuICAgIGxldCB2aWRlb1NhbXBsZXMgPSBkYXRhO1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLnZpZGVvVHJhY2sgYXMgUGFzc3Rocm91Z2hUcmFjaztcbiAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLnR4dFRyYWNrIGFzIERlbXV4ZWRVc2VyZGF0YVRyYWNrO1xuICAgIGlmICh0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSkge1xuICAgICAgLy8gU3BsaXQgdGhlIGJ5dGVzdHJlYW0gaW50byB0d28gcmFuZ2VzOiBvbmUgZW5jb21wYXNzaW5nIGFsbCBkYXRhIHVwIHVudGlsIHRoZSBzdGFydCBvZiB0aGUgbGFzdCBtb29mLCBhbmQgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIGd1YXJhbnRlZSB0aGF0IHdlJ3JlIHNlbmRpbmcgdmFsaWQgZGF0YSB0byBNU0UgLSB3aGVuIGRlbXV4aW5nIHByb2dyZXNzaXZlbHksIHdlIGhhdmUgbm8gZ3VhcmFudGVlXG4gICAgICAvLyB0aGF0IHRoZSBmZXRjaCBsb2FkZXIgZ2l2ZXMgdXMgZmx1c2ggbW9vZittZGF0IHBhaXJzLiBJZiB3ZSBwdXNoIGphZ2dlZCBkYXRhIHRvIE1TRSwgaXQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gICAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICAgIHZpZGVvU2FtcGxlcyA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlZ21lbnRlZERhdGEgPSBzZWdtZW50VmFsaWRSYW5nZSh2aWRlb1NhbXBsZXMpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gc2VnbWVudGVkRGF0YS5yZW1haW5kZXI7XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSBzZWdtZW50ZWREYXRhLnZhbGlkIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvU2FtcGxlcztcbiAgICB9XG5cbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgIHRleHRUcmFjay5zYW1wbGVzID0gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHZpZGVvVHJhY2spO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBhdWRpb1RyYWNrOiB0aGlzLmF1ZGlvVHJhY2sgYXMgRGVtdXhlZEF1ZGlvVHJhY2ssXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogdGhpcy50eHRUcmFjayBhcyBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGZsdXNoKCkge1xuICAgIGNvbnN0IHRpbWVPZmZzZXQgPSB0aGlzLnRpbWVPZmZzZXQ7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjayBhcyBQYXNzdGhyb3VnaFRyYWNrO1xuICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMudHh0VHJhY2sgYXMgRGVtdXhlZFVzZXJkYXRhVHJhY2s7XG4gICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdGhpcy5yZW1haW5kZXJEYXRhIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcblxuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5leHRyYWN0SUQzVHJhY2sodmlkZW9UcmFjaywgdGhpcy50aW1lT2Zmc2V0KTtcbiAgICB0ZXh0VHJhY2suc2FtcGxlcyA9IHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB2aWRlb1RyYWNrKTtcblxuICAgIHJldHVybiB7XG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgYXVkaW9UcmFjazogZHVtbXlUcmFjaygpIGFzIERlbXV4ZWRBdWRpb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKSBhcyBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0SUQzVHJhY2soXG4gICAgdmlkZW9UcmFjazogUGFzc3Rocm91Z2hUcmFjayxcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXJcbiAgKTogRGVtdXhlZE1ldGFkYXRhVHJhY2sge1xuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5pZDNUcmFjayBhcyBEZW11eGVkTWV0YWRhdGFUcmFjaztcbiAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZW1zZ3MgPSBmaW5kQm94KHZpZGVvVHJhY2suc2FtcGxlcywgWydlbXNnJ10pO1xuICAgICAgaWYgKGVtc2dzKSB7XG4gICAgICAgIGVtc2dzLmZvckVhY2goKGRhdGE6IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgICBjb25zdCBlbXNnSW5mbyA9IHBhcnNlRW1zZyhkYXRhKTtcbiAgICAgICAgICBpZiAoZW1zZ1NjaGVtZVBhdHRlcm4udGVzdChlbXNnSW5mby5zY2hlbWVJZFVyaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHB0cyA9IE51bWJlci5pc0Zpbml0ZShlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lKVxuICAgICAgICAgICAgICA/IGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWUhIC8gZW1zZ0luZm8udGltZVNjYWxlXG4gICAgICAgICAgICAgIDogdGltZU9mZnNldCArXG4gICAgICAgICAgICAgICAgZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZURlbHRhISAvIGVtc2dJbmZvLnRpbWVTY2FsZTtcbiAgICAgICAgICAgIGxldCBkdXJhdGlvbiA9XG4gICAgICAgICAgICAgIGVtc2dJbmZvLmV2ZW50RHVyYXRpb24gPT09IDB4ZmZmZmZmZmZcbiAgICAgICAgICAgICAgICA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgICAgICAgICAgIDogZW1zZ0luZm8uZXZlbnREdXJhdGlvbiAvIGVtc2dJbmZvLnRpbWVTY2FsZTtcbiAgICAgICAgICAgIC8vIFNhZmFyaSB0YWtlcyBhbnl0aGluZyA8PSAwLjAwMSBzZWNvbmRzIGFuZCBtYXBzIGl0IHRvIEluZmluaXR5XG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPD0gMC4wMDEpIHtcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZW1zZ0luZm8ucGF5bG9hZDtcbiAgICAgICAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICAgIGRhdGE6IHBheWxvYWQsXG4gICAgICAgICAgICAgIGxlbjogcGF5bG9hZC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICBkdHM6IHB0cyxcbiAgICAgICAgICAgICAgcHRzOiBwdHMsXG4gICAgICAgICAgICAgIHR5cGU6IE1ldGFkYXRhU2NoZW1hLmVtc2csXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZDNUcmFjaztcbiAgfVxuXG4gIGRlbXV4U2FtcGxlQWVzKFxuICAgIGRhdGE6IFVpbnQ4QXJyYXksXG4gICAga2V5RGF0YTogS2V5RGF0YSxcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXJcbiAgKTogUHJvbWlzZTxEZW11eGVyUmVzdWx0PiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgbmV3IEVycm9yKCdUaGUgTVA0IGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTQU1QTEUtQUVTIGRlY3J5cHRpb24nKVxuICAgICk7XG4gIH1cblxuICBkZXN0cm95KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTVA0RGVtdXhlcjtcbiIsIi8qKlxuICogIE1QRUcgcGFyc2VyIGhlbHBlclxuICovXG5pbXBvcnQgeyBEZW11eGVkQXVkaW9UcmFjayB9IGZyb20gJy4uL3R5cGVzL2RlbXV4ZXInO1xuXG5sZXQgY2hyb21lVmVyc2lvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbmNvbnN0IEJpdHJhdGVzTWFwID0gW1xuICAzMiwgNjQsIDk2LCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMjg4LCAzMjAsIDM1MiwgMzg0LCA0MTYsIDQ0OCwgMzIsIDQ4LCA1NixcbiAgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzODQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsXG4gIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsXG4gIDE2MCwgMTc2LCAxOTIsIDIyNCwgMjU2LCA4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LFxuICAxNjAsXG5dO1xuXG5jb25zdCBTYW1wbGluZ1JhdGVNYXAgPSBbXG4gIDQ0MTAwLCA0ODAwMCwgMzIwMDAsIDIyMDUwLCAyNDAwMCwgMTYwMDAsIDExMDI1LCAxMjAwMCwgODAwMCxcbl07XG5cbmNvbnN0IFNhbXBsZXNDb2VmZmljaWVudHMgPSBbXG4gIC8vIE1QRUcgMi41XG4gIFtcbiAgICAwLCAvLyBSZXNlcnZlZFxuICAgIDcyLCAvLyBMYXllcjNcbiAgICAxNDQsIC8vIExheWVyMlxuICAgIDEyLCAvLyBMYXllcjFcbiAgXSxcbiAgLy8gUmVzZXJ2ZWRcbiAgW1xuICAgIDAsIC8vIFJlc2VydmVkXG4gICAgMCwgLy8gTGF5ZXIzXG4gICAgMCwgLy8gTGF5ZXIyXG4gICAgMCwgLy8gTGF5ZXIxXG4gIF0sXG4gIC8vIE1QRUcgMlxuICBbXG4gICAgMCwgLy8gUmVzZXJ2ZWRcbiAgICA3MiwgLy8gTGF5ZXIzXG4gICAgMTQ0LCAvLyBMYXllcjJcbiAgICAxMiwgLy8gTGF5ZXIxXG4gIF0sXG4gIC8vIE1QRUcgMVxuICBbXG4gICAgMCwgLy8gUmVzZXJ2ZWRcbiAgICAxNDQsIC8vIExheWVyM1xuICAgIDE0NCwgLy8gTGF5ZXIyXG4gICAgMTIsIC8vIExheWVyMVxuICBdLFxuXTtcblxuY29uc3QgQnl0ZXNJblNsb3QgPSBbXG4gIDAsIC8vIFJlc2VydmVkXG4gIDEsIC8vIExheWVyM1xuICAxLCAvLyBMYXllcjJcbiAgNCwgLy8gTGF5ZXIxXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kRnJhbWUoXG4gIHRyYWNrOiBEZW11eGVkQXVkaW9UcmFjayxcbiAgZGF0YTogVWludDhBcnJheSxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHB0czogbnVtYmVyLFxuICBmcmFtZUluZGV4OiBudW1iZXJcbikge1xuICAvLyBVc2luZyBodHRwOi8vd3d3LmRhdGF2b3lhZ2UuY29tL21wZ3NjcmlwdC9tcGVnaGRyLmh0bSBhcyBhIHJlZmVyZW5jZVxuICBpZiAob2Zmc2V0ICsgMjQgPiBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGhlYWRlciA9IHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gIGlmIChoZWFkZXIgJiYgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IChoZWFkZXIuc2FtcGxlc1BlckZyYW1lICogOTAwMDApIC8gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgY29uc3Qgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICBjb25zdCBzYW1wbGUgPSB7XG4gICAgICB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoKSxcbiAgICAgIHB0czogc3RhbXAsXG4gICAgICBkdHM6IHN0YW1wLFxuICAgIH07XG5cbiAgICB0cmFjay5jb25maWcgPSBbXTtcbiAgICB0cmFjay5jaGFubmVsQ291bnQgPSBoZWFkZXIuY2hhbm5lbENvdW50O1xuICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICB0cmFjay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcblxuICAgIHJldHVybiB7IHNhbXBsZSwgbGVuZ3RoOiBoZWFkZXIuZnJhbWVMZW5ndGgsIG1pc3Npbmc6IDAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIZWFkZXIoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpIHtcbiAgY29uc3QgbXBlZ1ZlcnNpb24gPSAoZGF0YVtvZmZzZXQgKyAxXSA+PiAzKSAmIDM7XG4gIGNvbnN0IG1wZWdMYXllciA9IChkYXRhW29mZnNldCArIDFdID4+IDEpICYgMztcbiAgY29uc3QgYml0UmF0ZUluZGV4ID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gNCkgJiAxNTtcbiAgY29uc3Qgc2FtcGxlUmF0ZUluZGV4ID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gMikgJiAzO1xuICBpZiAoXG4gICAgbXBlZ1ZlcnNpb24gIT09IDEgJiZcbiAgICBiaXRSYXRlSW5kZXggIT09IDAgJiZcbiAgICBiaXRSYXRlSW5kZXggIT09IDE1ICYmXG4gICAgc2FtcGxlUmF0ZUluZGV4ICE9PSAzXG4gICkge1xuICAgIGNvbnN0IHBhZGRpbmdCaXQgPSAoZGF0YVtvZmZzZXQgKyAyXSA+PiAxKSAmIDE7XG4gICAgY29uc3QgY2hhbm5lbE1vZGUgPSBkYXRhW29mZnNldCArIDNdID4+IDY7XG4gICAgY29uc3QgY29sdW1uSW5CaXRyYXRlcyA9XG4gICAgICBtcGVnVmVyc2lvbiA9PT0gMyA/IDMgLSBtcGVnTGF5ZXIgOiBtcGVnTGF5ZXIgPT09IDMgPyAzIDogNDtcbiAgICBjb25zdCBiaXRSYXRlID1cbiAgICAgIEJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGJpdFJhdGVJbmRleCAtIDFdICogMTAwMDtcbiAgICBjb25zdCBjb2x1bW5JblNhbXBsZVJhdGVzID1cbiAgICAgIG1wZWdWZXJzaW9uID09PSAzID8gMCA6IG1wZWdWZXJzaW9uID09PSAyID8gMSA6IDI7XG4gICAgY29uc3Qgc2FtcGxlUmF0ZSA9XG4gICAgICBTYW1wbGluZ1JhdGVNYXBbY29sdW1uSW5TYW1wbGVSYXRlcyAqIDMgKyBzYW1wbGVSYXRlSW5kZXhdO1xuICAgIGNvbnN0IGNoYW5uZWxDb3VudCA9IGNoYW5uZWxNb2RlID09PSAzID8gMSA6IDI7IC8vIElmIGJpdHMgb2YgY2hhbm5lbCBtb2RlIGFyZSBgMTFgIHRoZW4gaXQgaXMgYSBzaW5nbGUgY2hhbm5lbCAoTW9ubylcbiAgICBjb25zdCBzYW1wbGVDb2VmZmljaWVudCA9IFNhbXBsZXNDb2VmZmljaWVudHNbbXBlZ1ZlcnNpb25dW21wZWdMYXllcl07XG4gICAgY29uc3QgYnl0ZXNJblNsb3QgPSBCeXRlc0luU2xvdFttcGVnTGF5ZXJdO1xuICAgIGNvbnN0IHNhbXBsZXNQZXJGcmFtZSA9IHNhbXBsZUNvZWZmaWNpZW50ICogOCAqIGJ5dGVzSW5TbG90O1xuICAgIGNvbnN0IGZyYW1lTGVuZ3RoID1cbiAgICAgIE1hdGguZmxvb3IoKHNhbXBsZUNvZWZmaWNpZW50ICogYml0UmF0ZSkgLyBzYW1wbGVSYXRlICsgcGFkZGluZ0JpdCkgKlxuICAgICAgYnl0ZXNJblNsb3Q7XG5cbiAgICBpZiAoY2hyb21lVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgICBjb25zdCBuZWVkQ2hyb21lRml4ID0gISFjaHJvbWVWZXJzaW9uICYmIGNocm9tZVZlcnNpb24gPD0gODc7XG5cbiAgICBpZiAoXG4gICAgICBuZWVkQ2hyb21lRml4ICYmXG4gICAgICBtcGVnTGF5ZXIgPT09IDIgJiZcbiAgICAgIGJpdFJhdGUgPj0gMjI0MDAwICYmXG4gICAgICBjaGFubmVsTW9kZSA9PT0gMFxuICAgICkge1xuICAgICAgLy8gV29yayBhcm91bmQgYnVnIGluIENocm9taXVtIGJ5IHNldHRpbmcgY2hhbm5lbE1vZGUgdG8gZHVhbC1jaGFubmVsICgwMSkgaW5zdGVhZCBvZiBzdGVyZW8gKDAwKVxuICAgICAgZGF0YVtvZmZzZXQgKyAzXSA9IGRhdGFbb2Zmc2V0ICsgM10gfCAweDgwO1xuICAgIH1cblxuICAgIHJldHVybiB7IHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCwgZnJhbWVMZW5ndGgsIHNhbXBsZXNQZXJGcmFtZSB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4oZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiZcbiAgICAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZTApID09PSAweGUwICYmXG4gICAgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDA2KSAhPT0gMHgwMFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIZWFkZXIoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgcmV0dXJuIG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhblBhcnNlKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IGhlYWRlclNpemUgPSA0O1xuXG4gIHJldHVybiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSAmJiBoZWFkZXJTaXplIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvYmUoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IE1QRUcgZnJhbWUgZm9sbG93cyBsYXN0IE1QRUcgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gTVBFRyBoZWFkZXIgTGVuZ3RoXG4gICAgY29uc3QgaGVhZGVyTGVuZ3RoID0gNDtcbiAgICAvLyBNUEVHIGZyYW1lIExlbmd0aFxuICAgIGNvbnN0IGhlYWRlciA9IHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gICAgbGV0IGZyYW1lTGVuZ3RoID0gaGVhZGVyTGVuZ3RoO1xuICAgIGlmIChoZWFkZXI/LmZyYW1lTGVuZ3RoKSB7XG4gICAgICBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICByZXR1cm4gbmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCBpc0hlYWRlcihkYXRhLCBuZXdPZmZzZXQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsIi8qKlxuICogUGFyc2VyIGZvciBleHBvbmVudGlhbCBHb2xvbWIgY29kZXMsIGEgdmFyaWFibGUtYml0d2lkdGggbnVtYmVyIGVuY29kaW5nIHNjaGVtZSB1c2VkIGJ5IGgyNjQuXG4gKi9cblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRXhwR29sb21iIHtcbiAgcHJpdmF0ZSBkYXRhOiBVaW50OEFycmF5O1xuICBwdWJsaWMgYnl0ZXNBdmFpbGFibGU6IG51bWJlcjtcbiAgcHJpdmF0ZSB3b3JkOiBudW1iZXI7XG4gIHByaXZhdGUgYml0c0F2YWlsYWJsZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE6IFVpbnQ4QXJyYXkpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIC8vIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCB0byBleGFtaW5lIGluIHRoaXMuZGF0YVxuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgLy8gdGhlIGN1cnJlbnQgd29yZCBiZWluZyBleGFtaW5lZFxuICAgIHRoaXMud29yZCA9IDA7IC8vIDp1aW50XG4gICAgLy8gdGhlIG51bWJlciBvZiBiaXRzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGUgY3VycmVudCB3b3JkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gMDsgLy8gOnVpbnRcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgbG9hZFdvcmQoKTogdm9pZCB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBieXRlc0F2YWlsYWJsZSA9IHRoaXMuYnl0ZXNBdmFpbGFibGU7XG4gICAgY29uc3QgcG9zaXRpb24gPSBkYXRhLmJ5dGVMZW5ndGggLSBieXRlc0F2YWlsYWJsZTtcbiAgICBjb25zdCB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCBhdmFpbGFibGVCeXRlcyA9IE1hdGgubWluKDQsIGJ5dGVzQXZhaWxhYmxlKTtcbiAgICBpZiAoYXZhaWxhYmxlQnl0ZXMgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYnl0ZXMgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgd29ya2luZ0J5dGVzLnNldChkYXRhLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGF2YWlsYWJsZUJ5dGVzKSk7XG4gICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTtcbiAgICAvLyB0cmFjayB0aGUgYW1vdW50IG9mIHRoaXMuZGF0YSB0aGF0IGhhcyBiZWVuIHByb2Nlc3NlZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IGF2YWlsYWJsZUJ5dGVzICogODtcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xuICB9XG5cbiAgLy8gKGNvdW50OmludCk6dm9pZFxuICBza2lwQml0cyhjb3VudDogbnVtYmVyKTogdm9pZCB7XG4gICAgbGV0IHNraXBCeXRlczsgLy8gOmludFxuICAgIGNvdW50ID0gTWF0aC5taW4oY291bnQsIHRoaXMuYnl0ZXNBdmFpbGFibGUgKiA4ICsgdGhpcy5iaXRzQXZhaWxhYmxlKTtcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gY291bnQpIHtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50IC09IHRoaXMuYml0c0F2YWlsYWJsZTtcbiAgICAgIHNraXBCeXRlcyA9IGNvdW50ID4+IDM7XG4gICAgICBjb3VudCAtPSBza2lwQnl0ZXMgPDwgMztcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9XG4gIH1cblxuICAvLyAoc2l6ZTppbnQpOnVpbnRcbiAgcmVhZEJpdHMoc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBsZXQgYml0cyA9IE1hdGgubWluKHRoaXMuYml0c0F2YWlsYWJsZSwgc2l6ZSk7IC8vIDp1aW50XG4gICAgY29uc3QgdmFsdSA9IHRoaXMud29yZCA+Pj4gKDMyIC0gYml0cyk7IC8vIDp1aW50XG4gICAgaWYgKHNpemUgPiAzMikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3QgcmVhZCBtb3JlIHRoYW4gMzIgYml0cyBhdCBhIHRpbWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gYml0cztcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBiaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBiaXRzIGF2YWlsYWJsZScpO1xuICAgIH1cblxuICAgIGJpdHMgPSBzaXplIC0gYml0cztcbiAgICBpZiAoYml0cyA+IDAgJiYgdGhpcy5iaXRzQXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gKHZhbHUgPDwgYml0cykgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdTtcbiAgICB9XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHNraXBMWigpOiBudW1iZXIge1xuICAgIGxldCBsZWFkaW5nWmVyb0NvdW50OyAvLyA6dWludFxuICAgIGZvciAoXG4gICAgICBsZWFkaW5nWmVyb0NvdW50ID0gMDtcbiAgICAgIGxlYWRpbmdaZXJvQ291bnQgPCB0aGlzLmJpdHNBdmFpbGFibGU7XG4gICAgICArK2xlYWRpbmdaZXJvQ291bnRcbiAgICApIHtcbiAgICAgIGlmICgodGhpcy53b3JkICYgKDB4ODAwMDAwMDAgPj4+IGxlYWRpbmdaZXJvQ291bnQpKSAhPT0gMCkge1xuICAgICAgICAvLyB0aGUgZmlyc3QgYml0IG9mIHdvcmtpbmcgd29yZCBpcyAxXG4gICAgICAgIHRoaXMud29yZCA8PD0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXG4gICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50ICsgdGhpcy5za2lwTFooKTtcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgc2tpcFVFRygpOiB2b2lkIHtcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgc2tpcEVHKCk6IHZvaWQge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dWludFxuICByZWFkVUVHKCk6IG51bWJlciB7XG4gICAgY29uc3QgY2x6ID0gdGhpcy5za2lwTFooKTsgLy8gOnVpbnRcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyhjbHogKyAxKSAtIDE7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZEVHKCk6IG51bWJlciB7XG4gICAgY29uc3QgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgaWYgKDB4MDEgJiB2YWx1KSB7XG4gICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcbiAgICAgIHJldHVybiAoMSArIHZhbHUpID4+PiAxOyAvLyBhZGQgMSB0byBtYWtlIGl0IGV2ZW4sIGFuZCBkaXZpZGUgYnkgMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTEgKiAodmFsdSA+Pj4gMSk7IC8vIGRpdmlkZSBieSB0d28gdGhlbiBtYWtlIGl0IG5lZ2F0aXZlXG4gICAgfVxuICB9XG5cbiAgLy8gU29tZSBjb252ZW5pZW5jZSBmdW5jdGlvbnNcbiAgLy8gOkJvb2xlYW5cbiAgcmVhZEJvb2xlYW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMSkgPT09IDE7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVCeXRlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoOCk7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVTaG9ydCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDE2KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVUludCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgKiBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgKiBAc2VlIFJlY29tbWVuZGF0aW9uIElUVS1UIEguMjY0LCBTZWN0aW9uIDcuMy4yLjEuMS4xXG4gICAqL1xuICBza2lwU2NhbGluZ0xpc3QoY291bnQ6IG51bWJlcik6IHZvaWQge1xuICAgIGxldCBsYXN0U2NhbGUgPSA4O1xuICAgIGxldCBuZXh0U2NhbGUgPSA4O1xuICAgIGxldCBkZWx0YVNjYWxlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgaWYgKG5leHRTY2FsZSAhPT0gMCkge1xuICAgICAgICBkZWx0YVNjYWxlID0gdGhpcy5yZWFkRUcoKTtcbiAgICAgICAgbmV4dFNjYWxlID0gKGxhc3RTY2FsZSArIGRlbHRhU2NhbGUgKyAyNTYpICUgMjU2O1xuICAgICAgfVxuICAgICAgbGFzdFNjYWxlID0gbmV4dFNjYWxlID09PSAwID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBhbmQgcmV0dXJuIHNvbWUgaW50ZXJlc3RpbmcgdmlkZW9cbiAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcbiAgICogZGVzY3JpYmVzIHRoZSBwcm9wZXJ0aWVzIG9mIHVwY29taW5nIHZpZGVvIGZyYW1lcy5cbiAgICogQHJldHVybnMgYW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBwYXJzZWQgZnJvbSB0aGVcbiAgICogc2VxdWVuY2UgcGFyYW1ldGVyIHNldCwgaW5jbHVkaW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZVxuICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cbiAgICovXG4gIHJlYWRTUFMoKToge1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgcGl4ZWxSYXRpbzogW251bWJlciwgbnVtYmVyXTtcbiAgfSB7XG4gICAgbGV0IGZyYW1lQ3JvcExlZnRPZmZzZXQgPSAwO1xuICAgIGxldCBmcmFtZUNyb3BSaWdodE9mZnNldCA9IDA7XG4gICAgbGV0IGZyYW1lQ3JvcFRvcE9mZnNldCA9IDA7XG4gICAgbGV0IGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IDA7XG4gICAgbGV0IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTtcbiAgICBsZXQgc2NhbGluZ0xpc3RDb3VudDtcbiAgICBsZXQgaTtcbiAgICBjb25zdCByZWFkVUJ5dGUgPSB0aGlzLnJlYWRVQnl0ZS5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHJlYWRCaXRzID0gdGhpcy5yZWFkQml0cy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHJlYWRVRUcgPSB0aGlzLnJlYWRVRUcuYmluZCh0aGlzKTtcbiAgICBjb25zdCByZWFkQm9vbGVhbiA9IHRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKTtcbiAgICBjb25zdCBza2lwQml0cyA9IHRoaXMuc2tpcEJpdHMuYmluZCh0aGlzKTtcbiAgICBjb25zdCBza2lwRUcgPSB0aGlzLnNraXBFRy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBVRUcgPSB0aGlzLnNraXBVRUcuYmluZCh0aGlzKTtcbiAgICBjb25zdCBza2lwU2NhbGluZ0xpc3QgPSB0aGlzLnNraXBTY2FsaW5nTGlzdC5iaW5kKHRoaXMpO1xuXG4gICAgcmVhZFVCeXRlKCk7XG4gICAgY29uc3QgcHJvZmlsZUlkYyA9IHJlYWRVQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgIHJlYWRCaXRzKDUpOyAvLyBwcm9maWxlQ29tcGF0IGNvbnN0cmFpbnRfc2V0WzAtNF1fZmxhZywgdSg1KVxuICAgIHNraXBCaXRzKDMpOyAvLyByZXNlcnZlZF96ZXJvXzNiaXRzIHUoMyksXG4gICAgcmVhZFVCeXRlKCk7IC8vIGxldmVsX2lkYyB1KDgpXG4gICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgIC8vIHNvbWUgcHJvZmlsZXMgaGF2ZSBtb3JlIG9wdGlvbmFsIGRhdGEgd2UgZG9uJ3QgbmVlZFxuICAgIGlmIChcbiAgICAgIHByb2ZpbGVJZGMgPT09IDEwMCB8fFxuICAgICAgcHJvZmlsZUlkYyA9PT0gMTEwIHx8XG4gICAgICBwcm9maWxlSWRjID09PSAxMjIgfHxcbiAgICAgIHByb2ZpbGVJZGMgPT09IDI0NCB8fFxuICAgICAgcHJvZmlsZUlkYyA9PT0gNDQgfHxcbiAgICAgIHByb2ZpbGVJZGMgPT09IDgzIHx8XG4gICAgICBwcm9maWxlSWRjID09PSA4NiB8fFxuICAgICAgcHJvZmlsZUlkYyA9PT0gMTE4IHx8XG4gICAgICBwcm9maWxlSWRjID09PSAxMjhcbiAgICApIHtcbiAgICAgIGNvbnN0IGNocm9tYUZvcm1hdElkYyA9IHJlYWRVRUcoKTtcbiAgICAgIGlmIChjaHJvbWFGb3JtYXRJZGMgPT09IDMpIHtcbiAgICAgICAgc2tpcEJpdHMoMSk7XG4gICAgICB9IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG5cbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XG4gICAgICBza2lwQml0cygxKTsgLy8gcXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXG4gICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSBjaHJvbWFGb3JtYXRJZGMgIT09IDMgPyA4IDogMTI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FsaW5nTGlzdENvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgLy8gc2VxX3NjYWxpbmdfbGlzdF9wcmVzZW50X2ZsYWdbIGkgXVxuICAgICAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoNjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBza2lwVUVHKCk7IC8vIGxvZzJfbWF4X2ZyYW1lX251bV9taW51czRcbiAgICBjb25zdCBwaWNPcmRlckNudFR5cGUgPSByZWFkVUVHKCk7XG4gICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xuICAgICAgcmVhZFVFRygpOyAvLyBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czRcbiAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xuICAgICAgc2tpcEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9ub25fcmVmX3BpY1xuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlID0gcmVhZFVFRygpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgIHNraXBFRygpO1xuICAgICAgfSAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgc2tpcEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuICAgIGNvbnN0IHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgY29uc3QgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICBjb25zdCBmcmFtZU1ic09ubHlGbGFnID0gcmVhZEJpdHMoMSk7XG4gICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcbiAgICAgIHNraXBCaXRzKDEpO1xuICAgIH0gLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuXG4gICAgc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgIH1cbiAgICBsZXQgcGl4ZWxSYXRpbzogW251bWJlciwgbnVtYmVyXSA9IFsxLCAxXTtcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW9JZGMgPSByZWFkVUJ5dGUoKTtcbiAgICAgICAgc3dpdGNoIChhc3BlY3RSYXRpb0lkYykge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMSwgMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEyLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEwLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQwLCAzM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzI0LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIwLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMyLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzgwLCAzM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxOCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTUsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzY0LCAzM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNjAsIDk5XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQsIDNdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMywgMl07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyLCAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjU1OiB7XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gW1xuICAgICAgICAgICAgICAocmVhZFVCeXRlKCkgPDwgOCkgfCByZWFkVUJ5dGUoKSxcbiAgICAgICAgICAgICAgKHJlYWRVQnl0ZSgpIDw8IDgpIHwgcmVhZFVCeXRlKCksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5jZWlsKFxuICAgICAgICAocGljV2lkdGhJbk1ic01pbnVzMSArIDEpICogMTYgLVxuICAgICAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC1cbiAgICAgICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCAqIDJcbiAgICAgICksXG4gICAgICBoZWlnaHQ6XG4gICAgICAgICgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYgLVxuICAgICAgICAoZnJhbWVNYnNPbmx5RmxhZyA/IDIgOiA0KSAqXG4gICAgICAgICAgKGZyYW1lQ3JvcFRvcE9mZnNldCArIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCksXG4gICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuICAgIH07XG4gIH1cblxuICByZWFkU2xpY2VUeXBlKCkge1xuICAgIC8vIHNraXAgTkFMdSB0eXBlXG4gICAgdGhpcy5yZWFkVUJ5dGUoKTtcbiAgICAvLyBkaXNjYXJkIGZpcnN0X21iX2luX3NsaWNlXG4gICAgdGhpcy5yZWFkVUVHKCk7XG4gICAgLy8gcmV0dXJuIHNsaWNlX3R5cGVcbiAgICByZXR1cm4gdGhpcy5yZWFkVUVHKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXhwR29sb21iO1xuIiwiLyoqXG4gKiBTQU1QTEUtQUVTIGRlY3J5cHRlclxuICovXG5cbmltcG9ydCB7IEhsc0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgRGVjcnlwdGVyIGZyb20gJy4uL2NyeXB0L2RlY3J5cHRlcic7XG5pbXBvcnQgeyBIbHNFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUge1xuICBBdWRpb1NhbXBsZSxcbiAgQXZjU2FtcGxlLFxuICBBdmNTYW1wbGVVbml0LFxuICBEZW11eGVkVmlkZW9UcmFjayxcbiAgS2V5RGF0YSxcbn0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5pbXBvcnQgeyBkaXNjYXJkRVBCIH0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcblxuY2xhc3MgU2FtcGxlQWVzRGVjcnlwdGVyIHtcbiAgcHJpdmF0ZSBrZXlEYXRhOiBLZXlEYXRhO1xuICBwcml2YXRlIGRlY3J5cHRlcjogRGVjcnlwdGVyO1xuXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXIsIGNvbmZpZzogSGxzQ29uZmlnLCBrZXlEYXRhOiBLZXlEYXRhKSB7XG4gICAgdGhpcy5rZXlEYXRhID0ga2V5RGF0YTtcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIoY29uZmlnLCB7XG4gICAgICByZW1vdmVQS0NTN1BhZGRpbmc6IGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhOiBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoXG4gICAgICBlbmNyeXB0ZWREYXRhLFxuICAgICAgdGhpcy5rZXlEYXRhLmtleS5idWZmZXIsXG4gICAgICB0aGlzLmtleURhdGEuaXYuYnVmZmVyXG4gICAgKTtcbiAgfVxuXG4gIC8vIEFBQyAtIGVuY3J5cHQgYWxsIGZ1bGwgMTYgYnl0ZXMgYmxvY2tzIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDE2XG4gIHByaXZhdGUgZGVjcnlwdEFhY1NhbXBsZShcbiAgICBzYW1wbGVzOiBBdWRpb1NhbXBsZVtdLFxuICAgIHNhbXBsZUluZGV4OiBudW1iZXIsXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWRcbiAgKSB7XG4gICAgY29uc3QgY3VyVW5pdCA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQ7XG4gICAgaWYgKGN1clVuaXQubGVuZ3RoIDw9IDE2KSB7XG4gICAgICAvLyBObyBlbmNyeXB0ZWQgcG9ydGlvbiBpbiB0aGlzIHNhbXBsZSAoZmlyc3QgMTYgYnl0ZXMgaXMgbm90XG4gICAgICAvLyBlbmNyeXB0ZWQsIHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9hcmNoaXZlL2RvY3VtZW50YXRpb24vQXVkaW9WaWRlby9Db25jZXB0dWFsL0hMU19TYW1wbGVfRW5jcnlwdGlvbi9FbmNyeXB0aW9uL0VuY3J5cHRpb24uaHRtbCksXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBjdXJVbml0LnN1YmFycmF5KFxuICAgICAgMTYsXG4gICAgICBjdXJVbml0Lmxlbmd0aCAtIChjdXJVbml0Lmxlbmd0aCAlIDE2KVxuICAgICk7XG4gICAgY29uc3QgZW5jcnlwdGVkQnVmZmVyID0gZW5jcnlwdGVkRGF0YS5idWZmZXIuc2xpY2UoXG4gICAgICBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQsXG4gICAgICBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQgKyBlbmNyeXB0ZWREYXRhLmxlbmd0aFxuICAgICk7XG5cbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkQnVmZmVyKS50aGVuKChkZWNyeXB0ZWRCdWZmZXI6IEFycmF5QnVmZmVyKSA9PiB7XG4gICAgICBjb25zdCBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkQnVmZmVyKTtcbiAgICAgIGN1clVuaXQuc2V0KGRlY3J5cHRlZERhdGEsIDE2KTtcblxuICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICB0aGlzLmRlY3J5cHRBYWNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4ICsgMSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGVjcnlwdEFhY1NhbXBsZXMoXG4gICAgc2FtcGxlczogQXVkaW9TYW1wbGVbXSxcbiAgICBzYW1wbGVJbmRleDogbnVtYmVyLFxuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkXG4gICkge1xuICAgIGZvciAoOyA7IHNhbXBsZUluZGV4KyspIHtcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0Lmxlbmd0aCA8IDMyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQVZDIC0gZW5jcnlwdCBvbmUgMTYgYnl0ZXMgYmxvY2sgb3V0IG9mIHRlbiwgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMzJcbiAgZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YTogVWludDhBcnJheSkge1xuICAgIGNvbnN0IGVuY3J5cHRlZERhdGFMZW4gPVxuICAgICAgTWF0aC5mbG9vcigoZGVjb2RlZERhdGEubGVuZ3RoIC0gNDgpIC8gMTYwKSAqIDE2ICsgMTY7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUxlbik7XG4gICAgbGV0IG91dHB1dFBvcyA9IDA7XG4gICAgZm9yIChcbiAgICAgIGxldCBpbnB1dFBvcyA9IDMyO1xuICAgICAgaW5wdXRQb3MgPCBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjtcbiAgICAgIGlucHV0UG9zICs9IDE2MCwgb3V0cHV0UG9zICs9IDE2XG4gICAgKSB7XG4gICAgICBlbmNyeXB0ZWREYXRhLnNldChcbiAgICAgICAgZGVjb2RlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLFxuICAgICAgICBvdXRwdXRQb3NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY3J5cHRlZERhdGE7XG4gIH1cblxuICBnZXRBdmNEZWNyeXB0ZWRVbml0KFxuICAgIGRlY29kZWREYXRhOiBVaW50OEFycmF5LFxuICAgIGRlY3J5cHRlZERhdGE6IEFycmF5TGlrZTxudW1iZXI+IHwgQXJyYXlCdWZmZXIgfCBTaGFyZWRBcnJheUJ1ZmZlclxuICApIHtcbiAgICBjb25zdCB1aW50OERlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICBsZXQgaW5wdXRQb3MgPSAwO1xuICAgIGZvciAoXG4gICAgICBsZXQgb3V0cHV0UG9zID0gMzI7XG4gICAgICBvdXRwdXRQb3MgPCBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjtcbiAgICAgIG91dHB1dFBvcyArPSAxNjAsIGlucHV0UG9zICs9IDE2XG4gICAgKSB7XG4gICAgICBkZWNvZGVkRGF0YS5zZXQoXG4gICAgICAgIHVpbnQ4RGVjcnlwdGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksXG4gICAgICAgIG91dHB1dFBvc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjb2RlZERhdGE7XG4gIH1cblxuICBkZWNyeXB0QXZjU2FtcGxlKFxuICAgIHNhbXBsZXM6IEF2Y1NhbXBsZVtdLFxuICAgIHNhbXBsZUluZGV4OiBudW1iZXIsXG4gICAgdW5pdEluZGV4OiBudW1iZXIsXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWQsXG4gICAgY3VyVW5pdDogQXZjU2FtcGxlVW5pdFxuICApIHtcbiAgICBjb25zdCBkZWNvZGVkRGF0YSA9IGRpc2NhcmRFUEIoY3VyVW5pdC5kYXRhKTtcbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gdGhpcy5nZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKTtcblxuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhLmJ1ZmZlcikudGhlbihcbiAgICAgIChkZWNyeXB0ZWRCdWZmZXI6IEFycmF5QnVmZmVyKSA9PiB7XG4gICAgICAgIGN1clVuaXQuZGF0YSA9IHRoaXMuZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkQnVmZmVyKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgICAgdGhpcy5kZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4ICsgMSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGRlY3J5cHRBdmNTYW1wbGVzKFxuICAgIHNhbXBsZXM6IERlbXV4ZWRWaWRlb1RyYWNrWydzYW1wbGVzJ10sXG4gICAgc2FtcGxlSW5kZXg6IG51bWJlcixcbiAgICB1bml0SW5kZXg6IG51bWJlcixcbiAgICBjYWxsYmFjazogKCkgPT4gdm9pZFxuICApIHtcbiAgICBpZiAoc2FtcGxlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY3J5cHQgc2FtcGxlcyBvZiB0eXBlIFVpbnQ4QXJyYXknKTtcbiAgICB9XG5cbiAgICBmb3IgKDsgOyBzYW1wbGVJbmRleCsrLCB1bml0SW5kZXggPSAwKSB7XG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJVbml0cyA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXRzO1xuICAgICAgZm9yICg7IDsgdW5pdEluZGV4KyspIHtcbiAgICAgICAgaWYgKHVuaXRJbmRleCA+PSBjdXJVbml0cy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1clVuaXQgPSBjdXJVbml0c1t1bml0SW5kZXhdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY3VyVW5pdC5kYXRhLmxlbmd0aCA8PSA0OCB8fFxuICAgICAgICAgIChjdXJVbml0LnR5cGUgIT09IDEgJiYgY3VyVW5pdC50eXBlICE9PSA1KVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVjcnlwdEF2Y1NhbXBsZShcbiAgICAgICAgICBzYW1wbGVzLFxuICAgICAgICAgIHNhbXBsZUluZGV4LFxuICAgICAgICAgIHVuaXRJbmRleCxcbiAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICBjdXJVbml0XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTYW1wbGVBZXNEZWNyeXB0ZXI7XG4iLCIvKipcbiAqIGhpZ2hseSBvcHRpbWl6ZWQgVFMgZGVtdXhlcjpcbiAqIHBhcnNlIFBBVCwgUE1UXG4gKiBleHRyYWN0IFBFUyBwYWNrZXQgZnJvbSBhdWRpbyBhbmQgdmlkZW8gUElEc1xuICogZXh0cmFjdCBBVkMvSDI2NCBOQUwgdW5pdHMgYW5kIEFBQy9BRFRTIHNhbXBsZXMgZnJvbSBQRVMgcGFja2V0XG4gKiB0cmlnZ2VyIHRoZSByZW11eGVyIHVwb24gcGFyc2luZyBjb21wbGV0aW9uXG4gKiBpdCBhbHNvIHRyaWVzIHRvIHdvcmthcm91bmQgYXMgYmVzdCBhcyBpdCBjYW4gYXVkaW8gY29kZWMgc3dpdGNoIChIRS1BQUMgdG8gQUFDIGFuZCB2aWNlIHZlcnNhKSwgd2l0aG91dCBoYXZpbmcgdG8gcmVzdGFydCB0aGUgTWVkaWFTb3VyY2UuXG4gKiBpdCBhbHNvIGNvbnRyb2xzIHRoZSByZW11eGluZyBwcm9jZXNzIDpcbiAqIHVwb24gZGlzY29udGludWl0eSBvciBsZXZlbCBzd2l0Y2ggZGV0ZWN0aW9uLCBpdCB3aWxsIGFsc28gbm90aWZpZXMgdGhlIHJlbXV4ZXIgc28gdGhhdCBpdCBjYW4gcmVzZXQgaXRzIHN0YXRlLlxuICovXG5cbmltcG9ydCAqIGFzIEFEVFMgZnJvbSAnLi9hZHRzJztcbmltcG9ydCAqIGFzIE1wZWdBdWRpbyBmcm9tICcuL21wZWdhdWRpbyc7XG5pbXBvcnQgRXhwR29sb21iIGZyb20gJy4vZXhwLWdvbG9tYic7XG5pbXBvcnQgU2FtcGxlQWVzRGVjcnlwdGVyIGZyb20gJy4vc2FtcGxlLWFlcyc7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHtcbiAgYXBwZW5kVWludDhBcnJheSxcbiAgcGFyc2VTRUlNZXNzYWdlRnJvbU5BTHUsXG4gIFJlbXV4ZXJUcmFja0lkQ29uZmlnLFxufSBmcm9tICcuLi91dGlscy9tcDQtdG9vbHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgdHlwZSB7IEhsc0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IEhsc0V2ZW50RW1pdHRlciB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQge1xuICBEZW11eGVkQXZjVHJhY2ssXG4gIERlbXV4ZWRBdWRpb1RyYWNrLFxuICBEZW11eGVkVHJhY2ssXG4gIERlbXV4ZXIsXG4gIERlbXV4ZXJSZXN1bHQsXG4gIEF2Y1NhbXBsZSxcbiAgRGVtdXhlZE1ldGFkYXRhVHJhY2ssXG4gIERlbXV4ZWRVc2VyZGF0YVRyYWNrLFxuICBFbGVtZW50YXJ5U3RyZWFtRGF0YSxcbiAgS2V5RGF0YSxcbiAgTWV0YWRhdGFTY2hlbWEsXG59IGZyb20gJy4uL3R5cGVzL2RlbXV4ZXInO1xuaW1wb3J0IHsgQXVkaW9GcmFtZSB9IGZyb20gJy4uL3R5cGVzL2RlbXV4ZXInO1xuXG50eXBlIFBhcnNlZFRpbWVzdGFtcCA9IHtcbiAgcHRzPzogbnVtYmVyO1xuICBkdHM/OiBudW1iZXI7XG59O1xuXG50eXBlIFBFUyA9IFBhcnNlZFRpbWVzdGFtcCAmIHtcbiAgZGF0YTogVWludDhBcnJheTtcbiAgbGVuOiBudW1iZXI7XG59O1xuXG50eXBlIFBhcnNlZEF2Y1NhbXBsZSA9IFBhcnNlZFRpbWVzdGFtcCAmIE9taXQ8QXZjU2FtcGxlLCAncHRzJyB8ICdkdHMnPjtcblxuZXhwb3J0IGludGVyZmFjZSBUeXBlU3VwcG9ydGVkIHtcbiAgbXBlZzogYm9vbGVhbjtcbiAgbXAzOiBib29sZWFuO1xuICBtcDQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IFBBQ0tFVF9MRU5HVEggPSAxODg7XG5cbmNsYXNzIFRTRGVtdXhlciBpbXBsZW1lbnRzIERlbXV4ZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBIbHNDb25maWc7XG4gIHByaXZhdGUgdHlwZVN1cHBvcnRlZDogVHlwZVN1cHBvcnRlZDtcblxuICBwcml2YXRlIHNhbXBsZUFlczogU2FtcGxlQWVzRGVjcnlwdGVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcG10UGFyc2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgYXVkaW9Db2RlYz86IHN0cmluZztcbiAgcHJpdmF0ZSB2aWRlb0NvZGVjPzogc3RyaW5nO1xuICBwcml2YXRlIF9kdXJhdGlvbjogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBfcG10SWQ6IG51bWJlciA9IC0xO1xuXG4gIHByaXZhdGUgX2F2Y1RyYWNrPzogRGVtdXhlZEF2Y1RyYWNrO1xuICBwcml2YXRlIF9hdWRpb1RyYWNrPzogRGVtdXhlZEF1ZGlvVHJhY2s7XG4gIHByaXZhdGUgX2lkM1RyYWNrPzogRGVtdXhlZE1ldGFkYXRhVHJhY2s7XG4gIHByaXZhdGUgX3R4dFRyYWNrPzogRGVtdXhlZFVzZXJkYXRhVHJhY2s7XG4gIHByaXZhdGUgYWFjT3ZlckZsb3c6IEF1ZGlvRnJhbWUgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBhdmNTYW1wbGU6IFBhcnNlZEF2Y1NhbXBsZSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHJlbWFpbmRlckRhdGE6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBvYnNlcnZlcjogSGxzRXZlbnRFbWl0dGVyLFxuICAgIGNvbmZpZzogSGxzQ29uZmlnLFxuICAgIHR5cGVTdXBwb3J0ZWQ6IFR5cGVTdXBwb3J0ZWRcbiAgKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgcHJvYmUoZGF0YTogVWludDhBcnJheSkge1xuICAgIGNvbnN0IHN5bmNPZmZzZXQgPSBUU0RlbXV4ZXIuc3luY09mZnNldChkYXRhKTtcbiAgICBpZiAoc3luY09mZnNldCA+IDApIHtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICBgTVBFRzItVFMgZGV0ZWN0ZWQgYnV0IGZpcnN0IHN5bmMgd29yZCBmb3VuZCBAIG9mZnNldCAke3N5bmNPZmZzZXR9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN5bmNPZmZzZXQgIT09IC0xO1xuICB9XG5cbiAgc3RhdGljIHN5bmNPZmZzZXQoZGF0YTogVWludDhBcnJheSk6IG51bWJlciB7XG4gICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IHNjYW53aW5kb3cgPVxuICAgICAgTWF0aC5taW4oUEFDS0VUX0xFTkdUSCAqIDUsIGRhdGEubGVuZ3RoIC0gUEFDS0VUX0xFTkdUSCkgKyAxO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHNjYW53aW5kb3cpIHtcbiAgICAgIC8vIGEgVFMgaW5pdCBzZWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDIgVFMgcGFja2V0czogUEFUIGFuZCBQTVQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XG4gICAgICBsZXQgZm91bmRQYXQgPSBmYWxzZTtcbiAgICAgIGxldCBwYWNrZXRTdGFydCA9IC0xO1xuICAgICAgbGV0IHRzUGFja2V0cyA9IDA7XG4gICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGxlbmd0aDsgaiArPSBQQUNLRVRfTEVOR1RIKSB7XG4gICAgICAgIGlmIChkYXRhW2pdID09PSAweDQ3KSB7XG4gICAgICAgICAgdHNQYWNrZXRzKys7XG4gICAgICAgICAgaWYgKHBhY2tldFN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgICAgcGFja2V0U3RhcnQgPSBqO1xuICAgICAgICAgICAgLy8gRmlyc3Qgc3luYyB3b3JkIGZvdW5kIGF0IG9mZnNldCwgaW5jcmVhc2Ugc2NhbiBsZW5ndGggKCM1MjUxKVxuICAgICAgICAgICAgaWYgKHBhY2tldFN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAgIHNjYW53aW5kb3cgPVxuICAgICAgICAgICAgICAgIE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgcGFja2V0U3RhcnQgKyBQQUNLRVRfTEVOR1RIICogOTksXG4gICAgICAgICAgICAgICAgICBkYXRhLmxlbmd0aCAtIFBBQ0tFVF9MRU5HVEhcbiAgICAgICAgICAgICAgICApICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZFBhdCkge1xuICAgICAgICAgICAgZm91bmRQYXQgPSBwYXJzZVBJRChkYXRhLCBqKSA9PT0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU3luYyB3b3JkIGZvdW5kIGF0IDAgd2l0aCAzIHBhY2tldHMsIG9yIGZvdW5kIGF0IG9mZnNldCBsZWFzdCAyIHBhY2tldHMgdXAgdG8gc2NhbndpbmRvdyAoIzU1MDEpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZm91bmRQYXQgJiZcbiAgICAgICAgICAgIHRzUGFja2V0cyA+IDEgJiZcbiAgICAgICAgICAgICgocGFja2V0U3RhcnQgPT09IDAgJiYgdHNQYWNrZXRzID4gMikgfHxcbiAgICAgICAgICAgICAgaiArIFBBQ0tFVF9MRU5HVEggPiBzY2Fud2luZG93KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHBhY2tldFN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0c1BhY2tldHMpIHtcbiAgICAgICAgICAvLyBFeGl0IGlmIHN5bmMgd29yZCBmb3VuZCwgYnV0IGRvZXMgbm90IGNvbnRhaW4gY29udGlndW91cyBwYWNrZXRzICgjNTUwMSlcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0cmFjayBtb2RlbCBpbnRlcm5hbCB0byBkZW11eGVyIHVzZWQgdG8gZHJpdmUgcmVtdXhpbmcgaW5wdXRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVUcmFjayhcbiAgICB0eXBlOiAnYXVkaW8nIHwgJ3ZpZGVvJyB8ICdpZDMnIHwgJ3RleHQnLFxuICAgIGR1cmF0aW9uPzogbnVtYmVyXG4gICk6IERlbXV4ZWRUcmFjayB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRhaW5lcjpcbiAgICAgICAgdHlwZSA9PT0gJ3ZpZGVvJyB8fCB0eXBlID09PSAnYXVkaW8nID8gJ3ZpZGVvL21wMnQnIDogdW5kZWZpbmVkLFxuICAgICAgdHlwZSxcbiAgICAgIGlkOiBSZW11eGVyVHJhY2tJZENvbmZpZ1t0eXBlXSxcbiAgICAgIHBpZDogLTEsXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgZHJvcHBlZDogMCxcbiAgICAgIGR1cmF0aW9uOiB0eXBlID09PSAnYXVkaW8nID8gZHVyYXRpb24gOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbml0IHNlZ21lbnQgb24gdGhlIGRlbXV4ZXIvcmVtdXhlciBpbnRlcmZhY2UuIE5lZWRlZCBmb3IgZGlzY29udGludWl0aWVzL3RyYWNrLXN3aXRjaGVzIChvciBhdCBzdHJlYW0gc3RhcnQpXG4gICAqIFJlc2V0cyBhbGwgaW50ZXJuYWwgdHJhY2sgaW5zdGFuY2VzIG9mIHRoZSBkZW11eGVyLlxuICAgKi9cbiAgcHVibGljIHJlc2V0SW5pdFNlZ21lbnQoXG4gICAgaW5pdFNlZ21lbnQ6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQsXG4gICAgYXVkaW9Db2RlYzogc3RyaW5nLFxuICAgIHZpZGVvQ29kZWM6IHN0cmluZyxcbiAgICB0cmFja0R1cmF0aW9uOiBudW1iZXJcbiAgKSB7XG4gICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wbXRJZCA9IC0xO1xuXG4gICAgdGhpcy5fYXZjVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ3ZpZGVvJykgYXMgRGVtdXhlZEF2Y1RyYWNrO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soXG4gICAgICAnYXVkaW8nLFxuICAgICAgdHJhY2tEdXJhdGlvblxuICAgICkgYXMgRGVtdXhlZEF1ZGlvVHJhY2s7XG4gICAgdGhpcy5faWQzVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2lkMycpIGFzIERlbXV4ZWRNZXRhZGF0YVRyYWNrO1xuICAgIHRoaXMuX3R4dFRyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd0ZXh0JykgYXMgRGVtdXhlZFVzZXJkYXRhVHJhY2s7XG4gICAgdGhpcy5fYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPSAnYWFjJztcblxuICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0cmFja0R1cmF0aW9uO1xuICB9XG5cbiAgcHVibGljIHJlc2V0VGltZVN0YW1wKCkge31cblxuICBwdWJsaWMgcmVzZXRDb250aWd1aXR5KCk6IHZvaWQge1xuICAgIGNvbnN0IHsgX2F1ZGlvVHJhY2ssIF9hdmNUcmFjaywgX2lkM1RyYWNrIH0gPSB0aGlzO1xuICAgIGlmIChfYXVkaW9UcmFjaykge1xuICAgICAgX2F1ZGlvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChfYXZjVHJhY2spIHtcbiAgICAgIF9hdmNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKF9pZDNUcmFjaykge1xuICAgICAgX2lkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBkZW11eChcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBpc1NhbXBsZUFlcyA9IGZhbHNlLFxuICAgIGZsdXNoID0gZmFsc2VcbiAgKTogRGVtdXhlclJlc3VsdCB7XG4gICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgIH1cblxuICAgIGxldCBwZXM6IFBFUyB8IG51bGw7XG5cbiAgICBjb25zdCB2aWRlb1RyYWNrID0gdGhpcy5fYXZjVHJhY2sgYXMgRGVtdXhlZEF2Y1RyYWNrO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrIGFzIERlbXV4ZWRBdWRpb1RyYWNrO1xuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2sgYXMgRGVtdXhlZE1ldGFkYXRhVHJhY2s7XG4gICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy5fdHh0VHJhY2sgYXMgRGVtdXhlZFVzZXJkYXRhVHJhY2s7XG5cbiAgICBsZXQgYXZjSWQgPSB2aWRlb1RyYWNrLnBpZDtcbiAgICBsZXQgYXZjRGF0YSA9IHZpZGVvVHJhY2sucGVzRGF0YTtcbiAgICBsZXQgYXVkaW9JZCA9IGF1ZGlvVHJhY2sucGlkO1xuICAgIGxldCBpZDNJZCA9IGlkM1RyYWNrLnBpZDtcbiAgICBsZXQgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhO1xuICAgIGxldCBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YTtcbiAgICBsZXQgdW5rbm93blBJRDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkO1xuICAgIGxldCBwbXRJZCA9IHRoaXMuX3BtdElkO1xuXG4gICAgbGV0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGlmICh0aGlzLnJlbWFpbmRlckRhdGEpIHtcbiAgICAgIGRhdGEgPSBhcHBlbmRVaW50OEFycmF5KHRoaXMucmVtYWluZGVyRGF0YSwgZGF0YSk7XG4gICAgICBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGxlbiA8IFBBQ0tFVF9MRU5HVEggJiYgIWZsdXNoKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBkYXRhO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW9UcmFjayxcbiAgICAgICAgdmlkZW9UcmFjayxcbiAgICAgICAgaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjayxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc3luY09mZnNldCA9IE1hdGgubWF4KDAsIFRTRGVtdXhlci5zeW5jT2Zmc2V0KGRhdGEpKTtcbiAgICBsZW4gLT0gKGxlbiAtIHN5bmNPZmZzZXQpICUgUEFDS0VUX0xFTkdUSDtcbiAgICBpZiAobGVuIDwgZGF0YS5ieXRlTGVuZ3RoICYmICFmbHVzaCkge1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIGRhdGEuYnVmZmVyLFxuICAgICAgICBsZW4sXG4gICAgICAgIGRhdGEuYnVmZmVyLmJ5dGVMZW5ndGggLSBsZW5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcbiAgICBsZXQgdHNQYWNrZXRFcnJvcnMgPSAwO1xuICAgIGZvciAobGV0IHN0YXJ0ID0gc3luY09mZnNldDsgc3RhcnQgPCBsZW47IHN0YXJ0ICs9IFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICBjb25zdCBzdHQgPSAhIShkYXRhW3N0YXJ0ICsgMV0gJiAweDQwKTtcbiAgICAgICAgY29uc3QgcGlkID0gcGFyc2VQSUQoZGF0YSwgc3RhcnQpO1xuICAgICAgICBjb25zdCBhdGYgPSAoZGF0YVtzdGFydCArIDNdICYgMHgzMCkgPj4gNDtcblxuICAgICAgICAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGUgZmlmdGggYnl0ZSBvZiB0aGUgVFMgcGFja2V0IGhlYWRlci5cbiAgICAgICAgbGV0IG9mZnNldDogbnVtYmVyO1xuICAgICAgICBpZiAoYXRmID4gMSkge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNSArIGRhdGFbc3RhcnQgKyA0XTtcbiAgICAgICAgICAvLyBjb250aW51ZSBpZiB0aGVyZSBpcyBvbmx5IGFkYXB0YXRpb24gZmllbGRcbiAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydCArIFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwaWQpIHtcbiAgICAgICAgICBjYXNlIGF2Y0lkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFWQ1BFUyh2aWRlb1RyYWNrLCB0ZXh0VHJhY2ssIHBlcywgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYXZjRGF0YSA9IHsgZGF0YTogW10sIHNpemU6IDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdmNEYXRhKSB7XG4gICAgICAgICAgICAgIGF2Y0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgYXZjRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYXVkaW9JZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQUFDUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZU1QRUdQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YSA9IHsgZGF0YTogW10sIHNpemU6IDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyBQQUNLRVRfTEVOR1RIKSk7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQzSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWQzRGF0YSA9IHsgZGF0YTogW10sIHNpemU6IDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZDNEYXRhKSB7XG4gICAgICAgICAgICAgIGlkM0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgaWQzRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQgPSBwYXJzZVBBVChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnUE1UIFBJRDonICArIHRoaXMuX3BtdElkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcG10SWQ6IHtcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFBJRHMgPSBwYXJzZVBNVChcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgICB0aGlzLnR5cGVTdXBwb3J0ZWQsXG4gICAgICAgICAgICAgIGlzU2FtcGxlQWVzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0cmFjayBpZCBpZiB0cmFjayBQSUQgZm91bmQgd2hpbGUgcGFyc2luZyBQTVRcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgcmVzZXR0aW5nIHRoZSBQSUQgdG8gLTEgaW4gY2FzZVxuICAgICAgICAgICAgLy8gdHJhY2sgUElEIHRyYW5zaWVudGx5IGRpc2FwcGVhcnMgZnJvbSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpbiBjYXNlIG9mIHRyYW5zaWVudCBtaXNzaW5nIGF1ZGlvIHNhbXBsZXMgZm9yIGV4YW1wbGVcbiAgICAgICAgICAgIC8vIE5PVEUgdGhpcyBpcyBvbmx5IHRoZSBQSUQgb2YgdGhlIHRyYWNrIGFzIGZvdW5kIGluIFRTLFxuICAgICAgICAgICAgLy8gYnV0IHdlIGFyZSBub3QgdXNpbmcgdGhpcyBmb3IgTVA0IHRyYWNrIElEcy5cbiAgICAgICAgICAgIGF2Y0lkID0gcGFyc2VkUElEcy5hdmM7XG4gICAgICAgICAgICBpZiAoYXZjSWQgPiAwKSB7XG4gICAgICAgICAgICAgIHZpZGVvVHJhY2sucGlkID0gYXZjSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF1ZGlvSWQgPSBwYXJzZWRQSURzLmF1ZGlvO1xuICAgICAgICAgICAgaWYgKGF1ZGlvSWQgPiAwKSB7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2sucGlkID0gYXVkaW9JZDtcbiAgICAgICAgICAgICAgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPSBwYXJzZWRQSURzLnNlZ21lbnRDb2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkM0lkID0gcGFyc2VkUElEcy5pZDM7XG4gICAgICAgICAgICBpZiAoaWQzSWQgPiAwKSB7XG4gICAgICAgICAgICAgIGlkM1RyYWNrLnBpZCA9IGlkM0lkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodW5rbm93blBJRCAhPT0gbnVsbCAmJiAhcG10UGFyc2VkKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgIGBNUEVHLVRTIFBNVCBmb3VuZCBhdCAke3N0YXJ0fSBhZnRlciB1bmtub3duIFBJRCAnJHt1bmtub3duUElEfScuIEJhY2t0cmFja2luZyB0byBzeW5jIGJ5dGUgQCR7c3luY09mZnNldH0gdG8gcGFyc2UgYWxsIFRTIHBhY2tldHMuYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB1bmtub3duUElEID0gbnVsbDtcbiAgICAgICAgICAgICAgLy8gd2Ugc2V0IGl0IHRvIC0xODgsIHRoZSArPSAxODggaW4gdGhlIGZvciBsb29wIHdpbGwgcmVzZXQgc3RhcnQgdG8gMFxuICAgICAgICAgICAgICBzdGFydCA9IHN5bmNPZmZzZXQgLSAxODg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAweDExOlxuICAgICAgICAgIGNhc2UgMHgxZmZmOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHVua25vd25QSUQgPSBwaWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHNQYWNrZXRFcnJvcnMrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHNQYWNrZXRFcnJvcnMgPiAwKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgYEZvdW5kICR7dHNQYWNrZXRFcnJvcnN9IFRTIHBhY2tldC9zIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggMHg0N2BcbiAgICAgICk7XG4gICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmlkZW9UcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XG4gICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG5cbiAgICBjb25zdCBkZW11eFJlc3VsdDogRGVtdXhlclJlc3VsdCA9IHtcbiAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2ssXG4gICAgfTtcblxuICAgIGlmIChmbHVzaCkge1xuICAgICAgdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbXV4UmVzdWx0O1xuICB9XG5cbiAgcHVibGljIGZsdXNoKCk6IERlbXV4ZXJSZXN1bHQgfCBQcm9taXNlPERlbXV4ZXJSZXN1bHQ+IHtcbiAgICBjb25zdCB7IHJlbWFpbmRlckRhdGEgfSA9IHRoaXM7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICBsZXQgcmVzdWx0OiBEZW11eGVyUmVzdWx0O1xuICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmRlbXV4KHJlbWFpbmRlckRhdGEsIC0xLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdmlkZW9UcmFjazogdGhpcy5fYXZjVHJhY2sgYXMgRGVtdXhlZEF2Y1RyYWNrLFxuICAgICAgICBhdWRpb1RyYWNrOiB0aGlzLl9hdWRpb1RyYWNrIGFzIERlbXV4ZWRBdWRpb1RyYWNrLFxuICAgICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2sgYXMgRGVtdXhlZE1ldGFkYXRhVHJhY2ssXG4gICAgICAgIHRleHRUcmFjazogdGhpcy5fdHh0VHJhY2sgYXMgRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKHJlc3VsdCk7XG4gICAgaWYgKHRoaXMuc2FtcGxlQWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNyeXB0KHJlc3VsdCwgdGhpcy5zYW1wbGVBZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdDogRGVtdXhlclJlc3VsdCkge1xuICAgIGNvbnN0IHsgYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjayB9ID0gZGVtdXhSZXN1bHQ7XG4gICAgY29uc3QgYXZjRGF0YSA9IHZpZGVvVHJhY2sucGVzRGF0YTtcbiAgICBjb25zdCBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGE7XG4gICAgY29uc3QgaWQzRGF0YSA9IGlkM1RyYWNrLnBlc0RhdGE7XG4gICAgLy8gdHJ5IHRvIHBhcnNlIGxhc3QgUEVTIHBhY2tldHNcbiAgICBsZXQgcGVzOiBQRVMgfCBudWxsO1xuICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkpIHtcbiAgICAgIHRoaXMucGFyc2VBVkNQRVMoXG4gICAgICAgIHZpZGVvVHJhY2sgYXMgRGVtdXhlZEF2Y1RyYWNrLFxuICAgICAgICB0ZXh0VHJhY2sgYXMgRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gICAgICAgIHBlcyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBhdmNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IGF2Y0RhdGE7XG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgY2FzZSAnYWFjJzpcbiAgICAgICAgICB0aGlzLnBhcnNlQUFDUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgdGhpcy5wYXJzZU1QRUdQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhdWRpb0RhdGE/LnNpemUpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAnbGFzdCBBQUMgUEVTIHBhY2tldCB0cnVuY2F0ZWQsbWlnaHQgb3ZlcmxhcCBiZXR3ZWVuIGZyYWdtZW50cydcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gZWl0aGVyIGF1ZGlvRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XG4gICAgfVxuXG4gICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xuICAgICAgdGhpcy5wYXJzZUlEM1BFUyhpZDNUcmFjaywgcGVzKTtcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgaWQzRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGVtdXhTYW1wbGVBZXMoXG4gICAgZGF0YTogVWludDhBcnJheSxcbiAgICBrZXlEYXRhOiBLZXlEYXRhLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlclxuICApOiBQcm9taXNlPERlbXV4ZXJSZXN1bHQ+IHtcbiAgICBjb25zdCBkZW11eFJlc3VsdCA9IHRoaXMuZGVtdXgoXG4gICAgICBkYXRhLFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIHRydWUsXG4gICAgICAhdGhpcy5jb25maWcucHJvZ3Jlc3NpdmVcbiAgICApO1xuICAgIGNvbnN0IHNhbXBsZUFlcyA9ICh0aGlzLnNhbXBsZUFlcyA9IG5ldyBTYW1wbGVBZXNEZWNyeXB0ZXIoXG4gICAgICB0aGlzLm9ic2VydmVyLFxuICAgICAgdGhpcy5jb25maWcsXG4gICAgICBrZXlEYXRhXG4gICAgKSk7XG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdChkZW11eFJlc3VsdCwgc2FtcGxlQWVzKTtcbiAgfVxuXG4gIHByaXZhdGUgZGVjcnlwdChcbiAgICBkZW11eFJlc3VsdDogRGVtdXhlclJlc3VsdCxcbiAgICBzYW1wbGVBZXM6IFNhbXBsZUFlc0RlY3J5cHRlclxuICApOiBQcm9taXNlPERlbXV4ZXJSZXN1bHQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHsgYXVkaW9UcmFjaywgdmlkZW9UcmFjayB9ID0gZGVtdXhSZXN1bHQ7XG4gICAgICBpZiAoYXVkaW9UcmFjay5zYW1wbGVzICYmIGF1ZGlvVHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEFhY1NhbXBsZXMoYXVkaW9UcmFjay5zYW1wbGVzLCAwLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICAgICAgc2FtcGxlQWVzLmRlY3J5cHRBdmNTYW1wbGVzKHZpZGVvVHJhY2suc2FtcGxlcywgMCwgMCwgKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKGRlbXV4UmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGRlbXV4UmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMpIHtcbiAgICAgICAgc2FtcGxlQWVzLmRlY3J5cHRBdmNTYW1wbGVzKHZpZGVvVHJhY2suc2FtcGxlcywgMCwgMCwgKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VBVkNQRVMoXG4gICAgdHJhY2s6IERlbXV4ZWRBdmNUcmFjayxcbiAgICB0ZXh0VHJhY2s6IERlbXV4ZWRVc2VyZGF0YVRyYWNrLFxuICAgIHBlczogUEVTLFxuICAgIGxhc3Q6IGJvb2xlYW5cbiAgKSB7XG4gICAgY29uc3QgdW5pdHMgPSB0aGlzLnBhcnNlQVZDTkFMdSh0cmFjaywgcGVzLmRhdGEpO1xuICAgIGNvbnN0IGRlYnVnID0gZmFsc2U7XG4gICAgbGV0IGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlO1xuICAgIGxldCBwdXNoOiBib29sZWFuO1xuICAgIGxldCBzcHNmb3VuZCA9IGZhbHNlO1xuICAgIC8vIGZyZWUgcGVzLmRhdGEgdG8gc2F2ZSB1cCBzb21lIG1lbW9yeVxuICAgIChwZXMgYXMgYW55KS5kYXRhID0gbnVsbDtcblxuICAgIC8vIGlmIG5ldyBOQUwgdW5pdHMgZm91bmQgYW5kIGxhc3Qgc2FtcGxlIHN0aWxsIHRoZXJlLCBsZXQncyBwdXNoIC4uLlxuICAgIC8vIHRoaXMgaGVscHMgcGFyc2luZyBzdHJlYW1zIHdpdGggbWlzc2luZyBBVUQgKG9ubHkgZG8gdGhpcyBpZiBBVUQgbmV2ZXIgZm91bmQpXG4gICAgaWYgKGF2Y1NhbXBsZSAmJiB1bml0cy5sZW5ndGggJiYgIXRyYWNrLmF1ZEZvdW5kKSB7XG4gICAgICBwdXNoQWNjZXNzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgfVxuXG4gICAgdW5pdHMuZm9yRWFjaCgodW5pdCkgPT4ge1xuICAgICAgc3dpdGNoICh1bml0LnR5cGUpIHtcbiAgICAgICAgLy8gTkRSXG4gICAgICAgIGNhc2UgMToge1xuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmICghYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZShcbiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgcGVzLnB0cyxcbiAgICAgICAgICAgICAgcGVzLmR0cyxcbiAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ05EUiAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgICAvLyBvbmx5IGNoZWNrIHNsaWNlIHR5cGUgdG8gZGV0ZWN0IEtGIGluIGNhc2UgU1BTIGZvdW5kIGluIHNhbWUgcGFja2V0IChhbnkga2V5ZnJhbWUgaXMgcHJlY2VkZWQgYnkgU1BTIC4uLilcbiAgICAgICAgICBpZiAoc3BzZm91bmQgJiYgZGF0YS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAvLyByZXRyaWV2ZSBzbGljZSB0eXBlIGJ5IHBhcnNpbmcgYmVnaW5uaW5nIG9mIE5BTCB1bml0IChmb2xsb3cgSDI2NCBzcGVjLCBzbGljZV9oZWFkZXIgZGVmaW5pdGlvbikgdG8gZGV0ZWN0IGtleWZyYW1lIGVtYmVkZGVkIGluIE5EUlxuICAgICAgICAgICAgY29uc3Qgc2xpY2VUeXBlID0gbmV3IEV4cEdvbG9tYihkYXRhKS5yZWFkU2xpY2VUeXBlKCk7XG4gICAgICAgICAgICAvLyAyIDogSSBzbGljZSwgNCA6IFNJIHNsaWNlLCA3IDogSSBzbGljZSwgOTogU0kgc2xpY2VcbiAgICAgICAgICAgIC8vIFNJIHNsaWNlIDogQSBzbGljZSB0aGF0IGlzIGNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seSBhbmQgdXNpbmcgcXVhbnRpc2F0aW9uIG9mIHRoZSBwcmVkaWN0aW9uIHNhbXBsZXMuXG4gICAgICAgICAgICAvLyBBbiBTSSBzbGljZSBjYW4gYmUgY29kZWQgc3VjaCB0aGF0IGl0cyBkZWNvZGVkIHNhbXBsZXMgY2FuIGJlIGNvbnN0cnVjdGVkIGlkZW50aWNhbGx5IHRvIGFuIFNQIHNsaWNlLlxuICAgICAgICAgICAgLy8gSSBzbGljZTogQSBzbGljZSB0aGF0IGlzIG5vdCBhbiBTSSBzbGljZSB0aGF0IGlzIGRlY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5LlxuICAgICAgICAgICAgLy8gaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc2xpY2VUeXBlID09PSAyIHx8XG4gICAgICAgICAgICAgIHNsaWNlVHlwZSA9PT0gNCB8fFxuICAgICAgICAgICAgICBzbGljZVR5cGUgPT09IDcgfHxcbiAgICAgICAgICAgICAgc2xpY2VUeXBlID09PSA5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIElEUlxuICAgICAgICB9XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAvLyBoYW5kbGUgUEVTIG5vdCBzdGFydGluZyB3aXRoIEFVRFxuICAgICAgICAgIGlmICghYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZShcbiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgcGVzLnB0cyxcbiAgICAgICAgICAgICAgcGVzLmR0cyxcbiAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ0lEUiAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF2Y1NhbXBsZS5rZXkgPSB0cnVlO1xuICAgICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFNFSVxuICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1NFSSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdShcbiAgICAgICAgICAgIHVuaXQuZGF0YSxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBwZXMucHRzIGFzIG51bWJlcixcbiAgICAgICAgICAgIHRleHRUcmFjay5zYW1wbGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBTUFNcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgc3BzZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU1BTICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0cmFjay5zcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwcyA9IHVuaXQuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgRXhwR29sb21iKHNwcyk7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcbiAgICAgICAgICAgIHRyYWNrLndpZHRoID0gY29uZmlnLndpZHRoO1xuICAgICAgICAgICAgdHJhY2suaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICAgICAgICAgIHRyYWNrLnBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbztcbiAgICAgICAgICAgIHRyYWNrLnNwcyA9IFtzcHNdO1xuICAgICAgICAgICAgdHJhY2suZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjYXJyYXkgPSBzcHMuc3ViYXJyYXkoMSwgNCk7XG4gICAgICAgICAgICBsZXQgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV0IGggPSBjb2RlY2FycmF5W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29kZWNzdHJpbmcgKz0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBQUFNcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnUFBTICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcbiAgICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBBVURcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICB0cmFjay5hdWRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIHBlcy5wdHMsXG4gICAgICAgICAgICBwZXMuZHRzLFxuICAgICAgICAgICAgZGVidWcgPyAnQVVEICcgOiAnJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEZpbGxlciBEYXRhXG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAndW5rbm93biBOQUwgJyArIHVuaXQudHlwZSArICcgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChhdmNTYW1wbGUgJiYgcHVzaCkge1xuICAgICAgICBjb25zdCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBpZiBsYXN0IFBFUyBwYWNrZXQsIHB1c2ggc2FtcGxlc1xuICAgIGlmIChsYXN0ICYmIGF2Y1NhbXBsZSkge1xuICAgICAgcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRMYXN0TmFsVW5pdChzYW1wbGVzOiBBdmNTYW1wbGVbXSkge1xuICAgIGxldCBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZTtcbiAgICBsZXQgbGFzdFVuaXQ7XG4gICAgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxuICAgIGlmICghYXZjU2FtcGxlIHx8IGF2Y1NhbXBsZS51bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgaWYgKGF2Y1NhbXBsZT8udW5pdHMpIHtcbiAgICAgIGNvbnN0IHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xuICAgICAgbGFzdFVuaXQgPSB1bml0c1t1bml0cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RVbml0O1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZUFWQ05BTHUoXG4gICAgdHJhY2s6IERlbXV4ZWRBdmNUcmFjayxcbiAgICBhcnJheTogVWludDhBcnJheVxuICApOiBBcnJheTx7XG4gICAgZGF0YTogVWludDhBcnJheTtcbiAgICB0eXBlOiBudW1iZXI7XG4gICAgc3RhdGU/OiBudW1iZXI7XG4gIH0+IHtcbiAgICBjb25zdCBsZW4gPSBhcnJheS5ieXRlTGVuZ3RoO1xuICAgIGxldCBzdGF0ZSA9IHRyYWNrLm5hbHVTdGF0ZSB8fCAwO1xuICAgIGNvbnN0IGxhc3RTdGF0ZSA9IHN0YXRlO1xuICAgIGNvbnN0IHVuaXRzID0gW10gYXMgQXJyYXk8e1xuICAgICAgZGF0YTogVWludDhBcnJheTtcbiAgICAgIHR5cGU6IG51bWJlcjtcbiAgICAgIHN0YXRlPzogbnVtYmVyO1xuICAgIH0+O1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IG92ZXJmbG93O1xuICAgIGxldCB1bml0VHlwZTtcbiAgICBsZXQgbGFzdFVuaXRTdGFydCA9IC0xO1xuICAgIGxldCBsYXN0VW5pdFR5cGU6IG51bWJlciA9IDA7XG4gICAgLy8gbG9nZ2VyLmxvZygnUEVTOicgKyBIZXguaGV4RHVtcChhcnJheSkpO1xuXG4gICAgaWYgKHN0YXRlID09PSAtMSkge1xuICAgICAgLy8gc3BlY2lhbCB1c2UgY2FzZSB3aGVyZSB3ZSBmb3VuZCAzIG9yIDQtYnl0ZSBzdGFydCBjb2RlcyBleGFjdGx5IGF0IHRoZSBlbmQgb2YgcHJldmlvdXMgUEVTIHBhY2tldFxuICAgICAgbGFzdFVuaXRTdGFydCA9IDA7XG4gICAgICAvLyBOQUx1IHR5cGUgaXMgdmFsdWUgcmVhZCBmcm9tIG9mZnNldCAwXG4gICAgICBsYXN0VW5pdFR5cGUgPSBhcnJheVswXSAmIDB4MWY7XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBpID0gMTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdmFsdWUgPSBhcnJheVtpKytdO1xuICAgICAgLy8gb3B0aW1pemF0aW9uLiBzdGF0ZSAwIGFuZCAxIGFyZSB0aGUgcHJlZG9taW5hbnQgY2FzZS4gbGV0J3MgaGFuZGxlIHRoZW0gb3V0c2lkZSBvZiB0aGUgc3dpdGNoL2Nhc2VcbiAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gaGVyZSB3ZSBoYXZlIHN0YXRlIGVpdGhlciBlcXVhbCB0byAyIG9yIDNcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgc3RhdGUgPSAzO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwKSB7XG4gICAgICAgICAgY29uc3QgdW5pdCA9IHtcbiAgICAgICAgICAgIGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGkgLSBzdGF0ZSAtIDEpLFxuICAgICAgICAgICAgdHlwZTogbGFzdFVuaXRUeXBlLFxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxhc3RVbml0U3RhcnQgaXMgdW5kZWZpbmVkID0+IHRoaXMgaXMgdGhlIGZpcnN0IHN0YXJ0IGNvZGUgZm91bmQgaW4gdGhpcyBQRVMgcGFja2V0XG4gICAgICAgICAgLy8gZmlyc3QgY2hlY2sgaWYgc3RhcnQgY29kZSBkZWxpbWl0ZXIgaXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiAyIFBFUyBwYWNrZXRzLFxuICAgICAgICAgIC8vIGllIGl0IHN0YXJ0ZWQgaW4gbGFzdCBwYWNrZXQgKGxhc3RTdGF0ZSBub3QgemVybylcbiAgICAgICAgICAvLyBhbmQgZW5kZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIFBFUyBwYWNrZXQgKGkgPD0gNCAtIGxhc3RTdGF0ZSlcbiAgICAgICAgICBjb25zdCBsYXN0VW5pdCA9IHRoaXMuZ2V0TGFzdE5hbFVuaXQodHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgaWYgKGxhc3RVbml0KSB7XG4gICAgICAgICAgICBpZiAobGFzdFN0YXRlICYmIGkgPD0gNCAtIGxhc3RTdGF0ZSkge1xuICAgICAgICAgICAgICAvLyBzdGFydCBkZWxpbWl0ZXIgb3ZlcmxhcHBpbmcgYmV0d2VlbiBQRVMgcGFja2V0c1xuICAgICAgICAgICAgICAvLyBzdHJpcCBzdGFydCBkZWxpbWl0ZXIgYnl0ZXMgZnJvbSB0aGUgZW5kIG9mIGxhc3QgTkFMIHVuaXRcbiAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbGFzdFVuaXQgaGFkIGEgc3RhdGUgZGlmZmVyZW50IGZyb20gemVyb1xuICAgICAgICAgICAgICBpZiAobGFzdFVuaXQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsYXN0IGJ5dGVzXG4gICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGxhc3RVbml0LmRhdGEuc3ViYXJyYXkoXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoIC0gbGFzdFN0YXRlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgTkFMIHVuaXRzIGFyZSBub3Qgc3RhcnRpbmcgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBhY2tldCwgcHVzaCBwcmVjZWRpbmcgZGF0YSBpbnRvIHByZXZpb3VzIE5BTCB1bml0LlxuICAgICAgICAgICAgb3ZlcmZsb3cgPSBpIC0gc3RhdGUgLSAxO1xuICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaXJzdCBOQUxVIGZvdW5kIHdpdGggb3ZlcmZsb3c6JyArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICAgICAgICB0bXAuc2V0KGFycmF5LnN1YmFycmF5KDAsIG92ZXJmbG93KSwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgICAgICAgICAgbGFzdFVuaXQuc3RhdGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVhZCB1bml0IHR5cGVcbiAgICAgICAgaWYgKGkgPCBsZW4pIHtcbiAgICAgICAgICB1bml0VHlwZSA9IGFycmF5W2ldICYgMHgxZjtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaW5kIE5BTFUgQCBvZmZzZXQ6JyArIGkgKyAnLHR5cGU6JyArIHVuaXRUeXBlKTtcbiAgICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gaTtcbiAgICAgICAgICBsYXN0VW5pdFR5cGUgPSB1bml0VHlwZTtcbiAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm90IGVub3VnaCBieXRlIHRvIHJlYWQgdW5pdCB0eXBlLiBsZXQncyByZWFkIGl0IG9uIG5leHQgUEVTIHBhcnNpbmdcbiAgICAgICAgICBzdGF0ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDAgJiYgc3RhdGUgPj0gMCkge1xuICAgICAgY29uc3QgdW5pdCA9IHtcbiAgICAgICAgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgbGVuKSxcbiAgICAgICAgdHlwZTogbGFzdFVuaXRUeXBlLFxuICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICB9O1xuICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcbiAgICB9XG4gICAgLy8gbm8gTkFMdSBmb3VuZFxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgY29uc3QgbGFzdFVuaXQgPSB0aGlzLmdldExhc3ROYWxVbml0KHRyYWNrLnNhbXBsZXMpO1xuICAgICAgaWYgKGxhc3RVbml0KSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIGFycmF5LmJ5dGVMZW5ndGgpO1xuICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICB0bXAuc2V0KGFycmF5LCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmFjay5uYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICByZXR1cm4gdW5pdHM7XG4gIH1cblxuICBwcml2YXRlIHBhcnNlQUFDUEVTKHRyYWNrOiBEZW11eGVkQXVkaW9UcmFjaywgcGVzOiBQRVMpIHtcbiAgICBsZXQgc3RhcnRPZmZzZXQgPSAwO1xuICAgIGNvbnN0IGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdztcbiAgICBsZXQgZGF0YSA9IHBlcy5kYXRhO1xuICAgIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgICBjb25zdCBmcmFtZU1pc3NpbmdCeXRlcyA9IGFhY092ZXJGbG93Lm1pc3Npbmc7XG4gICAgICBjb25zdCBzYW1wbGVMZW5ndGggPSBhYWNPdmVyRmxvdy5zYW1wbGUudW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDOiBhcHBlbmQgb3ZlcmZsb3dpbmcgJHtzYW1wbGVMZW5ndGh9IGJ5dGVzIHRvIGJlZ2lubmluZyBvZiBuZXcgUEVTYCk7XG4gICAgICBpZiAoZnJhbWVNaXNzaW5nQnl0ZXMgPT09IC0xKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KHNhbXBsZUxlbmd0aCArIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRtcC5zZXQoYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQsIDApO1xuICAgICAgICB0bXAuc2V0KGRhdGEsIHNhbXBsZUxlbmd0aCk7XG4gICAgICAgIGRhdGEgPSB0bXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmcmFtZU92ZXJmbG93Qnl0ZXMgPSBzYW1wbGVMZW5ndGggLSBmcmFtZU1pc3NpbmdCeXRlcztcbiAgICAgICAgYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQuc2V0KFxuICAgICAgICAgIGRhdGEuc3ViYXJyYXkoMCwgZnJhbWVNaXNzaW5nQnl0ZXMpLFxuICAgICAgICAgIGZyYW1lT3ZlcmZsb3dCeXRlc1xuICAgICAgICApO1xuICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjT3ZlckZsb3cuc2FtcGxlKTtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBhYWNPdmVyRmxvdy5taXNzaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgIGxldCBvZmZzZXQ6IG51bWJlcjtcbiAgICBsZXQgbGVuOiBudW1iZXI7XG4gICAgZm9yIChvZmZzZXQgPSBzdGFydE9mZnNldCwgbGVuID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoQURUUy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBBRFRTIGhlYWRlciBkb2VzIG5vdCBzdGFydCBzdHJhaWdodCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYXlsb2FkLCByYWlzZSBhbiBlcnJvclxuICAgIGlmIChvZmZzZXQgIT09IHN0YXJ0T2Zmc2V0KSB7XG4gICAgICBsZXQgcmVhc29uOiBzdHJpbmc7XG4gICAgICBjb25zdCByZWNvdmVyYWJsZSA9IG9mZnNldCA8IGxlbiAtIDE7XG4gICAgICBpZiAocmVjb3ZlcmFibGUpIHtcbiAgICAgICAgcmVhc29uID0gYEFBQyBQRVMgZGlkIG5vdCBzdGFydCB3aXRoIEFEVFMgaGVhZGVyLG9mZnNldDoke29mZnNldH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29uID0gJ05vIEFEVFMgaGVhZGVyIGZvdW5kIGluIEFBQyBQRVMnO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgIGxvZ2dlci53YXJuKGBwYXJzaW5nIGVycm9yOiAke3JlYXNvbn1gKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGxldmVsUmV0cnk6IHJlY292ZXJhYmxlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlY292ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBBRFRTLmluaXRUcmFja0NvbmZpZyhcbiAgICAgIHRyYWNrLFxuICAgICAgdGhpcy5vYnNlcnZlcixcbiAgICAgIGRhdGEsXG4gICAgICBvZmZzZXQsXG4gICAgICB0aGlzLmF1ZGlvQ29kZWMgYXMgc3RyaW5nXG4gICAgKTtcblxuICAgIGxldCBwdHM6IG51bWJlcjtcbiAgICBpZiAocGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdHMgPSBwZXMucHRzO1xuICAgIH0gZWxzZSBpZiAoYWFjT3ZlckZsb3cpIHtcbiAgICAgIC8vIGlmIGxhc3QgQUFDIGZyYW1lIGlzIG92ZXJmbG93aW5nLCB3ZSBzaG91bGQgZW5zdXJlIHRpbWVzdGFtcHMgYXJlIGNvbnRpZ3VvdXM6XG4gICAgICAvLyBmaXJzdCBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBmcmFtZUR1cmF0aW9uXG4gICAgICBjb25zdCBmcmFtZUR1cmF0aW9uID0gQURUUy5nZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUgYXMgbnVtYmVyKTtcbiAgICAgIHB0cyA9IGFhY092ZXJGbG93LnNhbXBsZS5wdHMgKyBmcmFtZUR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybignW3RzZGVtdXhlcl06IEFBQyBQRVMgdW5rbm93biBQVFMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzY2FuIGZvciBhYWMgc2FtcGxlc1xuICAgIGxldCBmcmFtZUluZGV4ID0gMDtcbiAgICBsZXQgZnJhbWU7XG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbikge1xuICAgICAgZnJhbWUgPSBBRFRTLmFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgaWYgKCFmcmFtZS5taXNzaW5nKSB7XG4gICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgZm9yICg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICAgICAgaWYgKEFEVFMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFhY092ZXJGbG93ID0gZnJhbWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VNUEVHUEVTKHRyYWNrOiBEZW11eGVkQXVkaW9UcmFjaywgcGVzOiBQRVMpIHtcbiAgICBjb25zdCBkYXRhID0gcGVzLmRhdGE7XG4gICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IHB0cyA9IHBlcy5wdHM7XG4gICAgaWYgKHB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dnZXIud2FybignW3RzZGVtdXhlcl06IE1QRUcgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgaWYgKE1wZWdBdWRpby5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gTXBlZ0F1ZGlvLmFwcGVuZEZyYW1lKFxuICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIHB0cyxcbiAgICAgICAgICBmcmFtZUluZGV4XG4gICAgICAgICk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBhcnNlSUQzUEVTKGlkM1RyYWNrOiBEZW11eGVkTWV0YWRhdGFUcmFjaywgcGVzOiBQRVMpIHtcbiAgICBpZiAocGVzLnB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dnZXIud2FybignW3RzZGVtdXhlcl06IElEMyBQRVMgdW5rbm93biBQVFMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaWQzU2FtcGxlID0gT2JqZWN0LmFzc2lnbih7fSwgcGVzIGFzIFJlcXVpcmVkPFBFUz4sIHtcbiAgICAgIHR5cGU6IHRoaXMuX2F2Y1RyYWNrID8gTWV0YWRhdGFTY2hlbWEuZW1zZyA6IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzLFxuICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICB9KTtcbiAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goaWQzU2FtcGxlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBVkNTYW1wbGUoXG4gIGtleTogYm9vbGVhbixcbiAgcHRzOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gIGR0czogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICBkZWJ1Zzogc3RyaW5nXG4pOiBQYXJzZWRBdmNTYW1wbGUge1xuICByZXR1cm4ge1xuICAgIGtleSxcbiAgICBmcmFtZTogZmFsc2UsXG4gICAgcHRzLFxuICAgIGR0cyxcbiAgICB1bml0czogW10sXG4gICAgZGVidWcsXG4gICAgbGVuZ3RoOiAwLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVBJRChkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIC8vIHBpZCBpcyBhIDEzLWJpdCBmaWVsZCBzdGFydGluZyBhdCB0aGUgbGFzdCBiaXQgb2YgVFNbMV1cbiAgcmV0dXJuICgoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MWYpIDw8IDgpICsgZGF0YVtvZmZzZXQgKyAyXTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQQVQoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICAvLyBza2lwIHRoZSBQU0kgaGVhZGVyIGFuZCBwYXJzZSB0aGUgZmlyc3QgUE1UIGVudHJ5XG4gIHJldHVybiAoKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgxZikgPDwgOCkgfCBkYXRhW29mZnNldCArIDExXTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQTVQoXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4gIG9mZnNldDogbnVtYmVyLFxuICB0eXBlU3VwcG9ydGVkOiBUeXBlU3VwcG9ydGVkLFxuICBpc1NhbXBsZUFlczogYm9vbGVhblxuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHsgYXVkaW86IC0xLCBhdmM6IC0xLCBpZDM6IC0xLCBzZWdtZW50Q29kZWM6ICdhYWMnIH07XG4gIGNvbnN0IHNlY3Rpb25MZW5ndGggPSAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDBmKSA8PCA4KSB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gIGNvbnN0IHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuICAvLyB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIHRhYmxlIGlzLCB3ZSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93XG4gIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcbiAgY29uc3QgcHJvZ3JhbUluZm9MZW5ndGggPVxuICAgICgoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4KSB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAvLyBhZHZhbmNlIHRoZSBvZmZzZXQgdG8gdGhlIGZpcnN0IGVudHJ5IGluIHRoZSBtYXBwaW5nIHRhYmxlXG4gIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcbiAgICBjb25zdCBwaWQgPSBwYXJzZVBJRChkYXRhLCBvZmZzZXQpO1xuICAgIHN3aXRjaCAoZGF0YVtvZmZzZXRdKSB7XG4gICAgICBjYXNlIDB4Y2Y6IC8vIFNBTVBMRS1BRVMgQUFDXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgJ0FEVFMgQUFDIHdpdGggQUVTLTEyOC1DQkMgZnJhbWUgZW5jcnlwdGlvbiBmb3VuZCBpbiB1bmVuY3J5cHRlZCBzdHJlYW0nXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAweDBmOiAvLyBJU08vSUVDIDEzODE4LTcgQURUUyBBQUMgKE1QRUctMiBsb3dlciBiaXQtcmF0ZSBhdWRpbylcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnQUFDIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQuYXVkaW8gPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF1ZGlvID0gcGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIFBhY2tldGl6ZWQgbWV0YWRhdGEgKElEMylcbiAgICAgIGNhc2UgMHgxNTpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnSUQzIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQuaWQzID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5pZDMgPSBwaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweGRiOiAvLyBTQU1QTEUtQUVTIEFWQ1xuICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgICdILjI2NCB3aXRoIEFFUy0xMjgtQ0JDIHNsaWNlIGVuY3J5cHRpb24gZm91bmQgaW4gdW5lbmNyeXB0ZWQgc3RyZWFtJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHgxYjogLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmF2YyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXZjID0gcGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIElTTy9JRUMgMTExNzItMyAoTVBFRy0xIGF1ZGlvKVxuICAgICAgLy8gb3IgSVNPL0lFQyAxMzgxOC0zIChNUEVHLTIgaGFsdmVkIHNhbXBsZSByYXRlIGF1ZGlvKVxuICAgICAgY2FzZSAweDAzOlxuICAgICAgY2FzZSAweDA0OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdNUEVHIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcgIT09IHRydWUgJiYgdHlwZVN1cHBvcnRlZC5tcDMgIT09IHRydWUpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdNUEVHIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XG4gICAgICAgICAgcmVzdWx0LnNlZ21lbnRDb2RlYyA9ICdtcDMnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MjQ6XG4gICAgICAgIGxvZ2dlci53YXJuKCdVbnN1cHBvcnRlZCBIRVZDIHN0cmVhbSB0eXBlIGZvdW5kJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCd1bmtub3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICBvZmZzZXQgKz0gKCgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MGYpIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyA0XSkgKyA1O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUEVTKHN0cmVhbTogRWxlbWVudGFyeVN0cmVhbURhdGEpOiBQRVMgfCBudWxsIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgZnJhZzogVWludDhBcnJheTtcbiAgbGV0IHBlc0xlbjogbnVtYmVyO1xuICBsZXQgcGVzSGRyTGVuOiBudW1iZXI7XG4gIGxldCBwZXNQdHM6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgbGV0IHBlc0R0czogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBjb25zdCBkYXRhID0gc3RyZWFtLmRhdGE7XG4gIC8vIHNhZmV0eSBjaGVja1xuICBpZiAoIXN0cmVhbSB8fCBzdHJlYW0uc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gd2UgbWlnaHQgbmVlZCB1cCB0byAxOSBieXRlcyB0byByZWFkIFBFUyBoZWFkZXJcbiAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXG4gIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcbiAgd2hpbGUgKGRhdGFbMF0ubGVuZ3RoIDwgMTkgJiYgZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFbMF0ubGVuZ3RoICsgZGF0YVsxXS5sZW5ndGgpO1xuICAgIG5ld0RhdGEuc2V0KGRhdGFbMF0pO1xuICAgIG5ld0RhdGEuc2V0KGRhdGFbMV0sIGRhdGFbMF0ubGVuZ3RoKTtcbiAgICBkYXRhWzBdID0gbmV3RGF0YTtcbiAgICBkYXRhLnNwbGljZSgxLCAxKTtcbiAgfVxuICAvLyByZXRyaWV2ZSBQVFMvRFRTIGZyb20gZmlyc3QgZnJhZ21lbnRcbiAgZnJhZyA9IGRhdGFbMF07XG4gIGNvbnN0IHBlc1ByZWZpeCA9IChmcmFnWzBdIDw8IDE2KSArIChmcmFnWzFdIDw8IDgpICsgZnJhZ1syXTtcbiAgaWYgKHBlc1ByZWZpeCA9PT0gMSkge1xuICAgIHBlc0xlbiA9IChmcmFnWzRdIDw8IDgpICsgZnJhZ1s1XTtcbiAgICAvLyBpZiBQRVMgcGFyc2VkIGxlbmd0aCBpcyBub3QgemVybyBhbmQgZ3JlYXRlciB0aGFuIHRvdGFsIHJlY2VpdmVkIGxlbmd0aCwgc3RvcCBwYXJzaW5nLiBQRVMgbWlnaHQgYmUgdHJ1bmNhdGVkXG4gICAgLy8gbWludXMgNiA6IFBFUyBoZWFkZXIgc2l6ZVxuICAgIGlmIChwZXNMZW4gJiYgcGVzTGVuID4gc3RyZWFtLnNpemUgLSA2KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBwZXNGbGFncyA9IGZyYWdbN107XG4gICAgaWYgKHBlc0ZsYWdzICYgMHhjMCkge1xuICAgICAgLyogUEVTIGhlYWRlciBkZXNjcmliZWQgaGVyZSA6IGh0dHA6Ly9kdmQuc291cmNlZm9yZ2UubmV0L2R2ZGluZm8vcGVzLWhkci5odG1sXG4gICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXG4gICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXG4gICAgICBwZXNQdHMgPVxuICAgICAgICAoZnJhZ1s5XSAmIDB4MGUpICogNTM2ODcwOTEyICsgLy8gMSA8PCAyOVxuICAgICAgICAoZnJhZ1sxMF0gJiAweGZmKSAqIDQxOTQzMDQgKyAvLyAxIDw8IDIyXG4gICAgICAgIChmcmFnWzExXSAmIDB4ZmUpICogMTYzODQgKyAvLyAxIDw8IDE0XG4gICAgICAgIChmcmFnWzEyXSAmIDB4ZmYpICogMTI4ICsgLy8gMSA8PCA3XG4gICAgICAgIChmcmFnWzEzXSAmIDB4ZmUpIC8gMjtcblxuICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICBwZXNEdHMgPVxuICAgICAgICAgIChmcmFnWzE0XSAmIDB4MGUpICogNTM2ODcwOTEyICsgLy8gMSA8PCAyOVxuICAgICAgICAgIChmcmFnWzE1XSAmIDB4ZmYpICogNDE5NDMwNCArIC8vIDEgPDwgMjJcbiAgICAgICAgICAoZnJhZ1sxNl0gJiAweGZlKSAqIDE2Mzg0ICsgLy8gMSA8PCAxNFxuICAgICAgICAgIChmcmFnWzE3XSAmIDB4ZmYpICogMTI4ICsgLy8gMSA8PCA3XG4gICAgICAgICAgKGZyYWdbMThdICYgMHhmZSkgLyAyO1xuXG4gICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCAqIDkwMDAwKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgJHtNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAocGVzUHRzIC0gcGVzRHRzKSAvIDkwMDAwXG4gICAgICAgICAgICApfXMgZGVsdGEgYmV0d2VlbiBQVFMgYW5kIERUUywgYWxpZ24gdGhlbWBcbiAgICAgICAgICApO1xuICAgICAgICAgIHBlc1B0cyA9IHBlc0R0cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVzRHRzID0gcGVzUHRzO1xuICAgICAgfVxuICAgIH1cbiAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xuICAgIC8vIDkgYnl0ZXMgOiA2IGJ5dGVzIGZvciBQRVMgaGVhZGVyICsgMyBieXRlcyBmb3IgUEVTIGV4dGVuc2lvblxuICAgIGxldCBwYXlsb2FkU3RhcnRPZmZzZXQgPSBwZXNIZHJMZW4gKyA5O1xuICAgIGlmIChzdHJlYW0uc2l6ZSA8PSBwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdHJlYW0uc2l6ZSAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgLy8gcmVhc3NlbWJsZSBQRVMgcGFja2V0XG4gICAgY29uc3QgcGVzRGF0YSA9IG5ldyBVaW50OEFycmF5KHN0cmVhbS5zaXplKTtcbiAgICBmb3IgKGxldCBqID0gMCwgZGF0YUxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgZGF0YUxlbjsgaisrKSB7XG4gICAgICBmcmFnID0gZGF0YVtqXTtcbiAgICAgIGxldCBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQgPiBsZW4pIHtcbiAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgLT0gbGVuO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcbiAgICAgICAgICBmcmFnID0gZnJhZy5zdWJhcnJheShwYXlsb2FkU3RhcnRPZmZzZXQpO1xuICAgICAgICAgIGxlbiAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVzRGF0YS5zZXQoZnJhZywgaSk7XG4gICAgICBpICs9IGxlbjtcbiAgICB9XG4gICAgaWYgKHBlc0xlbikge1xuICAgICAgLy8gcGF5bG9hZCBzaXplIDogcmVtb3ZlIFBFUyBoZWFkZXIgKyBQRVMgZXh0ZW5zaW9uXG4gICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuICsgMztcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0YTogcGVzRGF0YSwgcHRzOiBwZXNQdHMsIGR0czogcGVzRHRzLCBsZW46IHBlc0xlbiB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoQWNjZXNzVW5pdChhdmNTYW1wbGU6IFBhcnNlZEF2Y1NhbXBsZSwgYXZjVHJhY2s6IERlbXV4ZWRBdmNUcmFjaykge1xuICBpZiAoYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCAmJiBhdmNTYW1wbGUuZnJhbWUpIHtcbiAgICAvLyBpZiBzYW1wbGUgZG9lcyBub3QgaGF2ZSBQVFMvRFRTLCBwYXRjaCB3aXRoIGxhc3Qgc2FtcGxlIFBUUy9EVFNcbiAgICBpZiAoYXZjU2FtcGxlLnB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBzYW1wbGVzID0gYXZjVHJhY2suc2FtcGxlcztcbiAgICAgIGNvbnN0IG5iU2FtcGxlcyA9IHNhbXBsZXMubGVuZ3RoO1xuICAgICAgaWYgKG5iU2FtcGxlcykge1xuICAgICAgICBjb25zdCBsYXN0U2FtcGxlID0gc2FtcGxlc1tuYlNhbXBsZXMgLSAxXTtcbiAgICAgICAgYXZjU2FtcGxlLnB0cyA9IGxhc3RTYW1wbGUucHRzO1xuICAgICAgICBhdmNTYW1wbGUuZHRzID0gbGFzdFNhbXBsZS5kdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkcm9wcGluZyBzYW1wbGVzLCBubyB0aW1lc3RhbXAgZm91bmRcbiAgICAgICAgYXZjVHJhY2suZHJvcHBlZCsrO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGF2Y1RyYWNrLnNhbXBsZXMucHVzaChhdmNTYW1wbGUgYXMgQXZjU2FtcGxlKTtcbiAgfVxuICBpZiAoYXZjU2FtcGxlLmRlYnVnLmxlbmd0aCkge1xuICAgIGxvZ2dlci5sb2coYXZjU2FtcGxlLnB0cyArICcvJyArIGF2Y1NhbXBsZS5kdHMgKyAnOicgKyBhdmNTYW1wbGUuZGVidWcpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRTRGVtdXhlcjtcbiIsIi8qKlxuICogTVAzIGRlbXV4ZXJcbiAqL1xuaW1wb3J0IEJhc2VBdWRpb0RlbXV4ZXIgZnJvbSAnLi9iYXNlLWF1ZGlvLWRlbXV4ZXInO1xuaW1wb3J0ICogYXMgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0ICogYXMgTXBlZ0F1ZGlvIGZyb20gJy4vbXBlZ2F1ZGlvJztcblxuY2xhc3MgTVAzRGVtdXhlciBleHRlbmRzIEJhc2VBdWRpb0RlbXV4ZXIge1xuICByZXNldEluaXRTZWdtZW50KFxuICAgIGluaXRTZWdtZW50OiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICAgIGF1ZGlvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2aWRlb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdHJhY2tEdXJhdGlvbjogbnVtYmVyXG4gICkge1xuICAgIHN1cGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6ICdhdWRpby9tcGVnJyxcbiAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICBpZDogMixcbiAgICAgIHBpZDogLTEsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNlZ21lbnRDb2RlYzogJ21wMycsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICBkdXJhdGlvbjogdHJhY2tEdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDAsXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBwcm9iZShkYXRhKTogYm9vbGVhbiB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgZGF0YSBjb250YWlucyBJRDMgdGltZXN0YW1wIGFuZCBNUEVHIHN5bmMgd29yZFxuICAgIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICAgIGNvbnN0IGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCAwKSB8fCBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgaWYgKE1wZWdBdWRpby5wcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ01QRUcgQXVkaW8gc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBNcGVnQXVkaW8uY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgfVxuXG4gIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5iYXNlUFRTID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBNcGVnQXVkaW8uYXBwZW5kRnJhbWUoXG4gICAgICB0cmFjayxcbiAgICAgIGRhdGEsXG4gICAgICBvZmZzZXQsXG4gICAgICB0aGlzLmJhc2VQVFMsXG4gICAgICB0aGlzLmZyYW1lSW5kZXhcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QM0RlbXV4ZXI7XG4iLCIvKipcbiAqICBBQUMgaGVscGVyXG4gKi9cblxuY2xhc3MgQUFDIHtcbiAgc3RhdGljIGdldFNpbGVudEZyYW1lKFxuICAgIGNvZGVjPzogc3RyaW5nLFxuICAgIGNoYW5uZWxDb3VudD86IG51bWJlclxuICApOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkIHtcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICBjYXNlICdtcDRhLjQwLjInOlxuICAgICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODAsXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsXG4gICAgICAgICAgICAweDAwLCAweDhlLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LFxuICAgICAgICAgICAgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOCxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCxcbiAgICAgICAgICAgIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzgsXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA2KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsXG4gICAgICAgICAgICAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLFxuICAgICAgICAgICAgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMCxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gaGFuZGxlIEhFLUFBQyBiZWxvdyAobXA0YS40MC41IC8gbXA0YS40MC4yOSlcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZSAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NGUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsXG4gICAgICAgICAgICAweDAsIDB4MWMsIDB4NiwgMHhmMSwgMHhjMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLFxuICAgICAgICAgICAgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSxcbiAgICAgICAgICAgIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLFxuICAgICAgICAgICAgMHg1YSwgMHg1ZSxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCxcbiAgICAgICAgICAgIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLFxuICAgICAgICAgICAgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSxcbiAgICAgICAgICAgIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLFxuICAgICAgICAgICAgMHg1YSwgMHg1ZSxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLFxuICAgICAgICAgICAgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLFxuICAgICAgICAgICAgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSxcbiAgICAgICAgICAgIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVlLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFBQztcbiIsIi8qKlxuICogR2VuZXJhdGUgTVA0IEJveFxuICovXG5cbnR5cGUgSGRsclR5cGVzID0ge1xuICB2aWRlbzogVWludDhBcnJheTtcbiAgYXVkaW86IFVpbnQ4QXJyYXk7XG59O1xuXG5jb25zdCBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcblxuY2xhc3MgTVA0IHtcbiAgcHVibGljIHN0YXRpYyB0eXBlczogUmVjb3JkPHN0cmluZywgbnVtYmVyW10+O1xuICBwcml2YXRlIHN0YXRpYyBIRExSX1RZUEVTOiBIZGxyVHlwZXM7XG4gIHByaXZhdGUgc3RhdGljIFNUVFM6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIFNUU0M6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIFNUQ086IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIFNUU1o6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIFZNSEQ6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIFNNSEQ6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIFNUU0Q6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIEZUWVA6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIERJTkY6IFVpbnQ4QXJyYXk7XG5cbiAgc3RhdGljIGluaXQoKSB7XG4gICAgTVA0LnR5cGVzID0ge1xuICAgICAgYXZjMTogW10sIC8vIGNvZGluZ25hbWVcbiAgICAgIGF2Y0M6IFtdLFxuICAgICAgYnRydDogW10sXG4gICAgICBkaW5mOiBbXSxcbiAgICAgIGRyZWY6IFtdLFxuICAgICAgZXNkczogW10sXG4gICAgICBmdHlwOiBbXSxcbiAgICAgIGhkbHI6IFtdLFxuICAgICAgbWRhdDogW10sXG4gICAgICBtZGhkOiBbXSxcbiAgICAgIG1kaWE6IFtdLFxuICAgICAgbWZoZDogW10sXG4gICAgICBtaW5mOiBbXSxcbiAgICAgIG1vb2Y6IFtdLFxuICAgICAgbW9vdjogW10sXG4gICAgICBtcDRhOiBbXSxcbiAgICAgICcubXAzJzogW10sXG4gICAgICBtdmV4OiBbXSxcbiAgICAgIG12aGQ6IFtdLFxuICAgICAgcGFzcDogW10sXG4gICAgICBzZHRwOiBbXSxcbiAgICAgIHN0Ymw6IFtdLFxuICAgICAgc3RjbzogW10sXG4gICAgICBzdHNjOiBbXSxcbiAgICAgIHN0c2Q6IFtdLFxuICAgICAgc3RzejogW10sXG4gICAgICBzdHRzOiBbXSxcbiAgICAgIHRmZHQ6IFtdLFxuICAgICAgdGZoZDogW10sXG4gICAgICB0cmFmOiBbXSxcbiAgICAgIHRyYWs6IFtdLFxuICAgICAgdHJ1bjogW10sXG4gICAgICB0cmV4OiBbXSxcbiAgICAgIHRraGQ6IFtdLFxuICAgICAgdm1oZDogW10sXG4gICAgICBzbWhkOiBbXSxcbiAgICB9O1xuXG4gICAgbGV0IGk6IHN0cmluZztcbiAgICBmb3IgKGkgaW4gTVA0LnR5cGVzKSB7XG4gICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIE1QNC50eXBlc1tpXSA9IFtcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDEpLFxuICAgICAgICAgIGkuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMyksXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdmlkZW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHg3NixcbiAgICAgIDB4NjksXG4gICAgICAweDY0LFxuICAgICAgMHg2NSwgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTYsXG4gICAgICAweDY5LFxuICAgICAgMHg2NCxcbiAgICAgIDB4NjUsXG4gICAgICAweDZmLFxuICAgICAgMHg0OCxcbiAgICAgIDB4NjEsXG4gICAgICAweDZlLFxuICAgICAgMHg2NCxcbiAgICAgIDB4NmMsXG4gICAgICAweDY1LFxuICAgICAgMHg3MixcbiAgICAgIDB4MDAsIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXG4gICAgXSk7XG5cbiAgICBjb25zdCBhdWRpb0hkbHIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDczLFxuICAgICAgMHg2ZixcbiAgICAgIDB4NzUsXG4gICAgICAweDZlLCAvLyBoYW5kbGVyX3R5cGU6ICdzb3VuJ1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHg1MyxcbiAgICAgIDB4NmYsXG4gICAgICAweDc1LFxuICAgICAgMHg2ZSxcbiAgICAgIDB4NjQsXG4gICAgICAweDQ4LFxuICAgICAgMHg2MSxcbiAgICAgIDB4NmUsXG4gICAgICAweDY0LFxuICAgICAgMHg2YyxcbiAgICAgIDB4NjUsXG4gICAgICAweDcyLFxuICAgICAgMHgwMCwgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgICBdKTtcblxuICAgIE1QNC5IRExSX1RZUEVTID0ge1xuICAgICAgdmlkZW86IHZpZGVvSGRscixcbiAgICAgIGF1ZGlvOiBhdWRpb0hkbHIsXG4gICAgfTtcblxuICAgIGNvbnN0IGRyZWYgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDEsIC8vIGVudHJ5X2NvdW50XG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDBjLCAvLyBlbnRyeV9zaXplXG4gICAgICAweDc1LFxuICAgICAgMHg3MixcbiAgICAgIDB4NmMsXG4gICAgICAweDIwLCAvLyAndXJsJyB0eXBlXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMSwgLy8gZW50cnlfZmxhZ3NcbiAgICBdKTtcblxuICAgIGNvbnN0IHN0Y28gPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBlbnRyeV9jb3VudFxuICAgIF0pO1xuXG4gICAgTVA0LlNUVFMgPSBNUDQuU1RTQyA9IE1QNC5TVENPID0gc3RjbztcblxuICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gc2FtcGxlX3NpemVcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHNhbXBsZV9jb3VudFxuICAgIF0pO1xuICAgIE1QNC5WTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAxLCAvLyBmbGFnc1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIGdyYXBoaWNzbW9kZVxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBvcGNvbG9yXG4gICAgXSk7XG4gICAgTVA0LlNNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gYmFsYW5jZVxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgXSk7XG5cbiAgICBNUDQuU1RTRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMSxcbiAgICBdKTsgLy8gZW50cnlfY291bnRcblxuICAgIGNvbnN0IG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LCAxMTUsIDExMSwgMTA5XSk7IC8vIGlzb21cbiAgICBjb25zdCBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsIDExOCwgOTksIDQ5XSk7IC8vIGF2YzFcbiAgICBjb25zdCBtaW5vclZlcnNpb24gPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xuXG4gICAgTVA0LkZUWVAgPSBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLmZ0eXAsXG4gICAgICBtYWpvckJyYW5kLFxuICAgICAgbWlub3JWZXJzaW9uLFxuICAgICAgbWFqb3JCcmFuZCxcbiAgICAgIGF2YzFCcmFuZFxuICAgICk7XG4gICAgTVA0LkRJTkYgPSBNUDQuYm94KE1QNC50eXBlcy5kaW5mLCBNUDQuYm94KE1QNC50eXBlcy5kcmVmLCBkcmVmKSk7XG4gIH1cblxuICBzdGF0aWMgYm94KHR5cGUsIC4uLnBheWxvYWQ6IFVpbnQ4QXJyYXlbXSkge1xuICAgIGxldCBzaXplID0gODtcbiAgICBsZXQgaSA9IHBheWxvYWQubGVuZ3RoO1xuICAgIGNvbnN0IGxlbiA9IGk7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICByZXN1bHRbMF0gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIHJlc3VsdFsxXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICAgIHJlc3VsdC5zZXQodHlwZSwgNCk7XG4gICAgLy8gY29weSB0aGUgcGF5bG9hZCBpbnRvIHRoZSByZXN1bHRcbiAgICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBjb3B5IHBheWxvYWRbaV0gYXJyYXkgQCBvZmZzZXQgc2l6ZVxuICAgICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc3RhdGljIGhkbHIodHlwZSkge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5oZGxyLCBNUDQuSERMUl9UWVBFU1t0eXBlXSk7XG4gIH1cblxuICBzdGF0aWMgbWRhdChkYXRhKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kYXQsIGRhdGEpO1xuICB9XG5cbiAgc3RhdGljIG1kaGQodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChcbiAgICAgIE1QNC50eXBlcy5tZGhkLFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgICAodGltZXNjYWxlID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgICh0aW1lc2NhbGUgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKHRpbWVzY2FsZSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIHRpbWVzY2FsZSAmIDB4ZmYsIC8vIHRpbWVzY2FsZVxuICAgICAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCxcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZixcbiAgICAgICAgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsXG4gICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweGZmLFxuICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweGZmLFxuICAgICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsXG4gICAgICAgIDB4NTUsXG4gICAgICAgIDB4YzQsIC8vICd1bmQnIGxhbmd1YWdlICh1bmRldGVybWluZWQpXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgbWRpYSh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLm1kaWEsXG4gICAgICBNUDQubWRoZCh0cmFjay50aW1lc2NhbGUsIHRyYWNrLmR1cmF0aW9uKSxcbiAgICAgIE1QNC5oZGxyKHRyYWNrLnR5cGUpLFxuICAgICAgTVA0Lm1pbmYodHJhY2spXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBtZmhkKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICBNUDQudHlwZXMubWZoZCxcbiAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgc2VxdWVuY2VOdW1iZXIgPj4gMjQsXG4gICAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAxNikgJiAweGZmLFxuICAgICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gOCkgJiAweGZmLFxuICAgICAgICBzZXF1ZW5jZU51bWJlciAmIDB4ZmYsIC8vIHNlcXVlbmNlX251bWJlclxuICAgICAgXSlcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIG1pbmYodHJhY2spIHtcbiAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICAgIE1QNC50eXBlcy5taW5mLFxuICAgICAgICBNUDQuYm94KE1QNC50eXBlcy5zbWhkLCBNUDQuU01IRCksXG4gICAgICAgIE1QNC5ESU5GLFxuICAgICAgICBNUDQuc3RibCh0cmFjaylcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgICBNUDQudHlwZXMubWluZixcbiAgICAgICAgTVA0LmJveChNUDQudHlwZXMudm1oZCwgTVA0LlZNSEQpLFxuICAgICAgICBNUDQuRElORixcbiAgICAgICAgTVA0LnN0YmwodHJhY2spXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBtb29mKHNuLCBiYXNlTWVkaWFEZWNvZGVUaW1lLCB0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLm1vb2YsXG4gICAgICBNUDQubWZoZChzbiksXG4gICAgICBNUDQudHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSlcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIG1vb3YodHJhY2tzKSB7XG4gICAgbGV0IGkgPSB0cmFja3MubGVuZ3RoO1xuICAgIGNvbnN0IGJveGVzOiBVaW50OEFycmF5W10gPSBbXTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyYWsodHJhY2tzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShcbiAgICAgIG51bGwsXG4gICAgICBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildXG4gICAgICAgIC5jb25jYXQoYm94ZXMpXG4gICAgICAgIC5jb25jYXQoTVA0Lm12ZXgodHJhY2tzKSlcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIG12ZXgodHJhY2tzKSB7XG4gICAgbGV0IGkgPSB0cmFja3MubGVuZ3RoO1xuICAgIGNvbnN0IGJveGVzOiBVaW50OEFycmF5W10gPSBbXTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyZXgodHJhY2tzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm12ZXgsIC4uLmJveGVzXSk7XG4gIH1cblxuICBzdGF0aWMgbXZoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAodGltZXNjYWxlID4+IDI0KSAmIDB4ZmYsXG4gICAgICAodGltZXNjYWxlID4+IDE2KSAmIDB4ZmYsXG4gICAgICAodGltZXNjYWxlID4+IDgpICYgMHhmZixcbiAgICAgIHRpbWVzY2FsZSAmIDB4ZmYsIC8vIHRpbWVzY2FsZVxuICAgICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhmZixcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4ZmYsXG4gICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsXG4gICAgICBsb3dlcldvcmREdXJhdGlvbiA+PiAyNCxcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweGZmLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDgpICYgMHhmZixcbiAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZixcbiAgICAgIDB4MDAsXG4gICAgICAweDAxLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIDEuMCByYXRlXG4gICAgICAweDAxLFxuICAgICAgMHgwMCwgLy8gMS4wIHZvbHVtZVxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsXG4gICAgICAweDAxLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMSxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHg0MCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHhmZixcbiAgICAgIDB4ZmYsXG4gICAgICAweGZmLFxuICAgICAgMHhmZiwgLy8gbmV4dF90cmFja19JRFxuICAgIF0pO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XG4gIH1cblxuICBzdGF0aWMgc2R0cCh0cmFjaykge1xuICAgIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCArIHNhbXBsZXMubGVuZ3RoKTtcbiAgICBsZXQgaTtcbiAgICBsZXQgZmxhZ3M7XG4gICAgLy8gbGVhdmUgdGhlIGZ1bGwgYm94IGhlYWRlciAoNCBieXRlcykgYWxsIHplcm9cbiAgICAvLyB3cml0ZSB0aGUgc2FtcGxlIHRhYmxlXG4gICAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZsYWdzID0gc2FtcGxlc1tpXS5mbGFncztcbiAgICAgIGJ5dGVzW2kgKyA0XSA9XG4gICAgICAgIChmbGFncy5kZXBlbmRzT24gPDwgNCkgfFxuICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIpIHxcbiAgICAgICAgZmxhZ3MuaGFzUmVkdW5kYW5jeTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc2R0cCwgYnl0ZXMpO1xuICB9XG5cbiAgc3RhdGljIHN0YmwodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChcbiAgICAgIE1QNC50eXBlcy5zdGJsLFxuICAgICAgTVA0LnN0c2QodHJhY2spLFxuICAgICAgTVA0LmJveChNUDQudHlwZXMuc3R0cywgTVA0LlNUVFMpLFxuICAgICAgTVA0LmJveChNUDQudHlwZXMuc3RzYywgTVA0LlNUU0MpLFxuICAgICAgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLFxuICAgICAgTVA0LmJveChNUDQudHlwZXMuc3RjbywgTVA0LlNUQ08pXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBhdmMxKHRyYWNrKSB7XG4gICAgbGV0IHNwczogbnVtYmVyW10gPSBbXTtcbiAgICBsZXQgcHBzOiBudW1iZXJbXSA9IFtdO1xuICAgIGxldCBpO1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBsZW47XG4gICAgLy8gYXNzZW1ibGUgdGhlIFNQU3NcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5zcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5zcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBzcHMucHVzaCgobGVuID4+PiA4KSAmIDB4ZmYpO1xuICAgICAgc3BzLnB1c2gobGVuICYgMHhmZik7XG5cbiAgICAgIC8vIFNQU1xuICAgICAgc3BzID0gc3BzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gYXNzZW1ibGUgdGhlIFBQU3NcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2sucHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhID0gdHJhY2sucHBzW2ldO1xuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcHBzLnB1c2goKGxlbiA+Pj4gOCkgJiAweGZmKTtcbiAgICAgIHBwcy5wdXNoKGxlbiAmIDB4ZmYpO1xuXG4gICAgICBwcHMgPSBwcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9XG5cbiAgICBjb25zdCBhdmNjID0gTVA0LmJveChcbiAgICAgIE1QNC50eXBlcy5hdmNDLFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIFtcbiAgICAgICAgICAweDAxLCAvLyB2ZXJzaW9uXG4gICAgICAgICAgc3BzWzNdLCAvLyBwcm9maWxlXG4gICAgICAgICAgc3BzWzRdLCAvLyBwcm9maWxlIGNvbXBhdFxuICAgICAgICAgIHNwc1s1XSwgLy8gbGV2ZWxcbiAgICAgICAgICAweGZjIHwgMywgLy8gbGVuZ3RoU2l6ZU1pbnVzT25lLCBoYXJkLWNvZGVkIHRvIDQgYnl0ZXNcbiAgICAgICAgICAweGUwIHwgdHJhY2suc3BzLmxlbmd0aCwgLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgICAgIF1cbiAgICAgICAgICAuY29uY2F0KHNwcylcbiAgICAgICAgICAuY29uY2F0KFtcbiAgICAgICAgICAgIHRyYWNrLnBwcy5sZW5ndGgsIC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICAgICAgICBdKVxuICAgICAgICAgIC5jb25jYXQocHBzKVxuICAgICAgKVxuICAgICk7IC8vIFwiUFBTXCJcbiAgICBjb25zdCB3aWR0aCA9IHRyYWNrLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICBjb25zdCBoU3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMF07XG4gICAgY29uc3QgdlNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzFdO1xuXG4gICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICBNUDQudHlwZXMuYXZjMSxcbiAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgICAgKHdpZHRoID4+IDgpICYgMHhmZixcbiAgICAgICAgd2lkdGggJiAweGZmLCAvLyB3aWR0aFxuICAgICAgICAoaGVpZ2h0ID4+IDgpICYgMHhmZixcbiAgICAgICAgaGVpZ2h0ICYgMHhmZiwgLy8gaGVpZ2h0XG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4NDgsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIGhvcml6cmVzb2x1dGlvblxuICAgICAgICAweDAwLFxuICAgICAgICAweDQ4LFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyB2ZXJ0cmVzb2x1dGlvblxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAxLCAvLyBmcmFtZV9jb3VudFxuICAgICAgICAweDEyLFxuICAgICAgICAweDY0LFxuICAgICAgICAweDYxLFxuICAgICAgICAweDY5LFxuICAgICAgICAweDZjLCAvLyBkYWlseW1vdGlvbi9obHMuanNcbiAgICAgICAgMHg3OSxcbiAgICAgICAgMHg2ZCxcbiAgICAgICAgMHg2ZixcbiAgICAgICAgMHg3NCxcbiAgICAgICAgMHg2OSxcbiAgICAgICAgMHg2ZixcbiAgICAgICAgMHg2ZSxcbiAgICAgICAgMHgyZixcbiAgICAgICAgMHg2OCxcbiAgICAgICAgMHg2YyxcbiAgICAgICAgMHg3MyxcbiAgICAgICAgMHgyZSxcbiAgICAgICAgMHg2YSxcbiAgICAgICAgMHg3MyxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gY29tcHJlc3Nvcm5hbWVcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgxOCwgLy8gZGVwdGggPSAyNFxuICAgICAgICAweDExLFxuICAgICAgICAweDExLFxuICAgICAgXSksIC8vIHByZV9kZWZpbmVkID0gLTFcbiAgICAgIGF2Y2MsXG4gICAgICBNUDQuYm94KFxuICAgICAgICBNUDQudHlwZXMuYnRydCxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgMHgxYyxcbiAgICAgICAgICAweDljLFxuICAgICAgICAgIDB4ODAsIC8vIGJ1ZmZlclNpemVEQlxuICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgMHgyZCxcbiAgICAgICAgICAweGM2LFxuICAgICAgICAgIDB4YzAsIC8vIG1heEJpdHJhdGVcbiAgICAgICAgICAweDAwLFxuICAgICAgICAgIDB4MmQsXG4gICAgICAgICAgMHhjNixcbiAgICAgICAgICAweGMwLFxuICAgICAgICBdKVxuICAgICAgKSwgLy8gYXZnQml0cmF0ZVxuICAgICAgTVA0LmJveChcbiAgICAgICAgTVA0LnR5cGVzLnBhc3AsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICBoU3BhY2luZyA+PiAyNCwgLy8gaFNwYWNpbmdcbiAgICAgICAgICAoaFNwYWNpbmcgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAoaFNwYWNpbmcgPj4gOCkgJiAweGZmLFxuICAgICAgICAgIGhTcGFjaW5nICYgMHhmZixcbiAgICAgICAgICB2U3BhY2luZyA+PiAyNCwgLy8gdlNwYWNpbmdcbiAgICAgICAgICAodlNwYWNpbmcgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAodlNwYWNpbmcgPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHZTcGFjaW5nICYgMHhmZixcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIGVzZHModHJhY2spIHtcbiAgICBjb25zdCBjb25maWdsZW4gPSB0cmFjay5jb25maWcubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShcbiAgICAgIFtcbiAgICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIGZsYWdzXG5cbiAgICAgICAgMHgwMywgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICAgIDB4MTcgKyBjb25maWdsZW4sIC8vIGxlbmd0aFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAxLCAvLyBlc19pZFxuICAgICAgICAweDAwLCAvLyBzdHJlYW1fcHJpb3JpdHlcblxuICAgICAgICAweDA0LCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgICAgMHgwZiArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgICAgIDB4NDAsIC8vIGNvZGVjIDogbXBlZzRfYXVkaW9cbiAgICAgICAgMHgxNSwgLy8gc3RyZWFtX3R5cGVcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gYnVmZmVyX3NpemVcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gbWF4Qml0cmF0ZVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBhdmdCaXRyYXRlXG5cbiAgICAgICAgMHgwNSwgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICBdXG4gICAgICAgIC5jb25jYXQoW2NvbmZpZ2xlbl0pXG4gICAgICAgIC5jb25jYXQodHJhY2suY29uZmlnKVxuICAgICAgICAuY29uY2F0KFsweDA2LCAweDAxLCAweDAyXSlcbiAgICApOyAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXG4gIH1cblxuICBzdGF0aWMgbXA0YSh0cmFjaykge1xuICAgIGNvbnN0IHNhbXBsZXJhdGUgPSB0cmFjay5zYW1wbGVyYXRlO1xuICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLm1wNGEsXG4gICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsXG4gICAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkMlxuICAgICAgICAoc2FtcGxlcmF0ZSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgXSksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy5lc2RzLCBNUDQuZXNkcyh0cmFjaykpXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBtcDModHJhY2spIHtcbiAgICBjb25zdCBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICByZXR1cm4gTVA0LmJveChcbiAgICAgIE1QNC50eXBlc1snLm1wMyddLFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLFxuICAgICAgICB0cmFjay5jaGFubmVsQ291bnQsIC8vIGNoYW5uZWxjb3VudFxuICAgICAgICAweDAwLFxuICAgICAgICAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZDJcbiAgICAgICAgKHNhbXBsZXJhdGUgPj4gOCkgJiAweGZmLFxuICAgICAgICBzYW1wbGVyYXRlICYgMHhmZiwgLy9cbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBzdHNkKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIGlmICh0cmFjay5zZWdtZW50Q29kZWMgPT09ICdtcDMnICYmIHRyYWNrLmNvZGVjID09PSAnbXAzJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXA0YSh0cmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5hdmMxKHRyYWNrKSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHRraGQodHJhY2spIHtcbiAgICBjb25zdCBpZCA9IHRyYWNrLmlkO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gKiB0cmFjay50aW1lc2NhbGU7XG4gICAgY29uc3Qgd2lkdGggPSB0cmFjay53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICBNUDQudHlwZXMudGtoZCxcbiAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDcsIC8vIGZsYWdzXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgICAgKGlkID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChpZCA+PiAxNikgJiAweGZmLFxuICAgICAgICAoaWQgPj4gOCkgJiAweGZmLFxuICAgICAgICBpZCAmIDB4ZmYsIC8vIHRyYWNrX0lEXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LFxuICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhmZixcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDgpICYgMHhmZixcbiAgICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweGZmLFxuICAgICAgICBsb3dlcldvcmREdXJhdGlvbiA+PiAyNCxcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZixcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gbGF5ZXJcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gYWx0ZXJuYXRlX2dyb3VwXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMSxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMSxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHg0MCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgICAod2lkdGggPj4gOCkgJiAweGZmLFxuICAgICAgICB3aWR0aCAmIDB4ZmYsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHdpZHRoXG4gICAgICAgIChoZWlnaHQgPj4gOCkgJiAweGZmLFxuICAgICAgICBoZWlnaHQgJiAweGZmLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBoZWlnaHRcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyB0cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgY29uc3Qgc2FtcGxlRGVwZW5kZW5jeVRhYmxlID0gTVA0LnNkdHAodHJhY2spO1xuICAgIGNvbnN0IGlkID0gdHJhY2suaWQ7XG4gICAgY29uc3QgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoXG4gICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKVxuICAgICk7XG4gICAgY29uc3QgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoXG4gICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKVxuICAgICk7XG4gICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICBNUDQudHlwZXMudHJhZixcbiAgICAgIE1QNC5ib3goXG4gICAgICAgIE1QNC50eXBlcy50ZmhkLFxuICAgICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAgICAgMHgwMCxcbiAgICAgICAgICAweDAwLFxuICAgICAgICAgIDB4MDAsIC8vIGZsYWdzXG4gICAgICAgICAgaWQgPj4gMjQsXG4gICAgICAgICAgKGlkID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgKGlkID4+IDgpICYgMHhmZixcbiAgICAgICAgICBpZCAmIDB4ZmYsIC8vIHRyYWNrX0lEXG4gICAgICAgIF0pXG4gICAgICApLFxuICAgICAgTVA0LmJveChcbiAgICAgICAgTVA0LnR5cGVzLnRmZHQsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAgICAgICAweDAwLFxuICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgICB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0LFxuICAgICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweGZmLFxuICAgICAgICAgIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsXG4gICAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4ZmYsXG4gICAgICAgIF0pXG4gICAgICApLFxuICAgICAgTVA0LnRydW4oXG4gICAgICAgIHRyYWNrLFxuICAgICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUubGVuZ3RoICtcbiAgICAgICAgICAxNiArIC8vIHRmaGRcbiAgICAgICAgICAyMCArIC8vIHRmZHRcbiAgICAgICAgICA4ICsgLy8gdHJhZiBoZWFkZXJcbiAgICAgICAgICAxNiArIC8vIG1maGRcbiAgICAgICAgICA4ICsgLy8gbW9vZiBoZWFkZXJcbiAgICAgICAgICA4XG4gICAgICApLCAvLyBtZGF0IGhlYWRlclxuICAgICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYWNrIGJveC5cbiAgICogQHBhcmFtIHRyYWNrIGEgdHJhY2sgZGVmaW5pdGlvblxuICAgKi9cbiAgc3RhdGljIHRyYWsodHJhY2spIHtcbiAgICB0cmFjay5kdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uIHx8IDB4ZmZmZmZmZmY7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWssIE1QNC50a2hkKHRyYWNrKSwgTVA0Lm1kaWEodHJhY2spKTtcbiAgfVxuXG4gIHN0YXRpYyB0cmV4KHRyYWNrKSB7XG4gICAgY29uc3QgaWQgPSB0cmFjay5pZDtcbiAgICByZXR1cm4gTVA0LmJveChcbiAgICAgIE1QNC50eXBlcy50cmV4LFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgaWQgPj4gMjQsXG4gICAgICAgIChpZCA+PiAxNikgJiAweGZmLFxuICAgICAgICAoaWQgPj4gOCkgJiAweGZmLFxuICAgICAgICBpZCAmIDB4ZmYsIC8vIHRyYWNrX0lEXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDEsIC8vIGRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX3NpemVcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMSxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyB0cnVuKHRyYWNrLCBvZmZzZXQpIHtcbiAgICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICBjb25zdCBsZW4gPSBzYW1wbGVzLmxlbmd0aDtcbiAgICBjb25zdCBhcnJheWxlbiA9IDEyICsgMTYgKiBsZW47XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheWxlbik7XG4gICAgbGV0IGk7XG4gICAgbGV0IHNhbXBsZTtcbiAgICBsZXQgZHVyYXRpb247XG4gICAgbGV0IHNpemU7XG4gICAgbGV0IGZsYWdzO1xuICAgIGxldCBjdHM7XG4gICAgb2Zmc2V0ICs9IDggKyBhcnJheWxlbjtcbiAgICBhcnJheS5zZXQoXG4gICAgICBbXG4gICAgICAgIHRyYWNrLnR5cGUgPT09ICd2aWRlbycgPyAweDAxIDogMHgwMCwgLy8gdmVyc2lvbiAxIGZvciB2aWRlbyB3aXRoIHNpZ25lZC1pbnQgc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MGYsXG4gICAgICAgIDB4MDEsIC8vIGZsYWdzXG4gICAgICAgIChsZW4gPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChsZW4gPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChsZW4gPj4+IDgpICYgMHhmZixcbiAgICAgICAgbGVuICYgMHhmZiwgLy8gc2FtcGxlX2NvdW50XG4gICAgICAgIChvZmZzZXQgPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChvZmZzZXQgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChvZmZzZXQgPj4+IDgpICYgMHhmZixcbiAgICAgICAgb2Zmc2V0ICYgMHhmZiwgLy8gZGF0YV9vZmZzZXRcbiAgICAgIF0sXG4gICAgICAwXG4gICAgKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICBkdXJhdGlvbiA9IHNhbXBsZS5kdXJhdGlvbjtcbiAgICAgIHNpemUgPSBzYW1wbGUuc2l6ZTtcbiAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xuICAgICAgY3RzID0gc2FtcGxlLmN0cztcbiAgICAgIGFycmF5LnNldChcbiAgICAgICAgW1xuICAgICAgICAgIChkdXJhdGlvbiA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgICAoZHVyYXRpb24gPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgKGR1cmF0aW9uID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgZHVyYXRpb24gJiAweGZmLCAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgICAgICAoc2l6ZSA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgICAoc2l6ZSA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAoc2l6ZSA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgIHNpemUgJiAweGZmLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgICAgIChmbGFncy5pc0xlYWRpbmcgPDwgMikgfCBmbGFncy5kZXBlbmRzT24sXG4gICAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCA2KSB8XG4gICAgICAgICAgICAoZmxhZ3MuaGFzUmVkdW5kYW5jeSA8PCA0KSB8XG4gICAgICAgICAgICAoZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEpIHxcbiAgICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyxcbiAgICAgICAgICBmbGFncy5kZWdyYWRQcmlvICYgKDB4ZjAgPDwgOCksXG4gICAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmIDB4MGYsIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgICAgIChjdHMgPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgICAgKGN0cyA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAoY3RzID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgY3RzICYgMHhmZiwgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICAgIF0sXG4gICAgICAgIDEyICsgMTYgKiBpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJ1biwgYXJyYXkpO1xuICB9XG5cbiAgc3RhdGljIGluaXRTZWdtZW50KHRyYWNrcykge1xuICAgIGlmICghTVA0LnR5cGVzKSB7XG4gICAgICBNUDQuaW5pdCgpO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShNUDQuRlRZUC5ieXRlTGVuZ3RoICsgbW92aWUuYnl0ZUxlbmd0aCk7XG4gICAgcmVzdWx0LnNldChNUDQuRlRZUCk7XG4gICAgcmVzdWx0LnNldChtb3ZpZSwgTVA0LkZUWVAuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNUDQ7XG4iLCJjb25zdCBNUEVHX1RTX0NMT0NLX0ZSRVFfSFogPSA5MDAwMDtcblxuZXhwb3J0IHR5cGUgUmF0aW9uYWxUaW1lc3RhbXAgPSB7XG4gIGJhc2VUaW1lOiBudW1iZXI7IC8vIHRpY2tzXG4gIHRpbWVzY2FsZTogbnVtYmVyOyAvLyB0aWNrcyBwZXIgc2Vjb25kXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdG9UaW1lc2NhbGVGcm9tQmFzZShcbiAgYmFzZVRpbWU6IG51bWJlcixcbiAgZGVzdFNjYWxlOiBudW1iZXIsXG4gIHNyY0Jhc2U6IG51bWJlciA9IDEsXG4gIHJvdW5kOiBib29sZWFuID0gZmFsc2Vcbik6IG51bWJlciB7XG4gIGNvbnN0IHJlc3VsdCA9IGJhc2VUaW1lICogZGVzdFNjYWxlICogc3JjQmFzZTsgLy8gZXF1aXZhbGVudCB0byBgKHZhbHVlICogc2NhbGUpIC8gKDEgLyBiYXNlKWBcbiAgcmV0dXJuIHJvdW5kID8gTWF0aC5yb3VuZChyZXN1bHQpIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9UaW1lc2NhbGVGcm9tU2NhbGUoXG4gIGJhc2VUaW1lOiBudW1iZXIsXG4gIGRlc3RTY2FsZTogbnVtYmVyLFxuICBzcmNTY2FsZTogbnVtYmVyID0gMSxcbiAgcm91bmQ6IGJvb2xlYW4gPSBmYWxzZVxuKTogbnVtYmVyIHtcbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UoYmFzZVRpbWUsIGRlc3RTY2FsZSwgMSAvIHNyY1NjYWxlLCByb3VuZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b01zRnJvbU1wZWdUc0Nsb2NrKFxuICBiYXNlVGltZTogbnVtYmVyLFxuICByb3VuZDogYm9vbGVhbiA9IGZhbHNlXG4pOiBudW1iZXIge1xuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgMTAwMCwgMSAvIE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiwgcm91bmQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGUoXG4gIGJhc2VUaW1lOiBudW1iZXIsXG4gIHNyY1NjYWxlOiBudW1iZXIgPSAxXG4pOiBudW1iZXIge1xuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgTVBFR19UU19DTE9DS19GUkVRX0haLCAxIC8gc3JjU2NhbGUpO1xufVxuIiwiaW1wb3J0IEFBQyBmcm9tICcuL2FhYy1oZWxwZXInO1xuaW1wb3J0IE1QNCBmcm9tICcuL21wNC1nZW5lcmF0b3InO1xuaW1wb3J0IHR5cGUgeyBIbHNFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHtcbiAgSW5pdFNlZ21lbnREYXRhLFxuICBSZW11eGVyLFxuICBSZW11eGVyUmVzdWx0LFxuICBSZW11eGVkTWV0YWRhdGEsXG4gIFJlbXV4ZWRUcmFjayxcbiAgUmVtdXhlZFVzZXJkYXRhLFxufSBmcm9tICcuLi90eXBlcy9yZW11eGVyJztcbmltcG9ydCB7IFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7XG4gIFJhdGlvbmFsVGltZXN0YW1wLFxuICB0b01zRnJvbU1wZWdUc0Nsb2NrLFxufSBmcm9tICcuLi91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbic7XG5pbXBvcnQgdHlwZSB7XG4gIEF1ZGlvU2FtcGxlLFxuICBBdmNTYW1wbGUsXG4gIERlbXV4ZWRBdWRpb1RyYWNrLFxuICBEZW11eGVkQXZjVHJhY2ssXG4gIERlbXV4ZWRNZXRhZGF0YVRyYWNrLFxuICBEZW11eGVkVXNlcmRhdGFUcmFjayxcbn0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5pbXBvcnQgdHlwZSB7IFRyYWNrU2V0IH0gZnJvbSAnLi4vdHlwZXMvdHJhY2snO1xuaW1wb3J0IHR5cGUgeyBTb3VyY2VCdWZmZXJOYW1lIH0gZnJvbSAnLi4vdHlwZXMvYnVmZmVyJztcbmltcG9ydCB0eXBlIHsgRnJhZ21lbnQgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuXG5jb25zdCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OID0gMTAgKiAxMDAwOyAvLyAxMCBzZWNvbmRzXG5jb25zdCBBQUNfU0FNUExFU19QRVJfRlJBTUUgPSAxMDI0O1xuY29uc3QgTVBFR19BVURJT19TQU1QTEVfUEVSX0ZSQU1FID0gMTE1MjtcblxubGV0IGNocm9tZVZlcnNpb246IG51bWJlciB8IG51bGwgPSBudWxsO1xubGV0IHNhZmFyaVdlYmtpdFZlcnNpb246IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNUDRSZW11eGVyIGltcGxlbWVudHMgUmVtdXhlciB7XG4gIHByaXZhdGUgb2JzZXJ2ZXI6IEhsc0V2ZW50RW1pdHRlcjtcbiAgcHJpdmF0ZSBjb25maWc6IEhsc0NvbmZpZztcbiAgcHJpdmF0ZSB0eXBlU3VwcG9ydGVkOiBhbnk7XG4gIHByaXZhdGUgSVNHZW5lcmF0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfaW5pdFBUUzogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfaW5pdERUUzogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBuZXh0QXZjRHRzOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBuZXh0QXVkaW9QdHM6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHZpZGVvU2FtcGxlRHVyYXRpb246IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzQXVkaW9Db250aWd1b3VzOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgaXNWaWRlb0NvbnRpZ3VvdXM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBvYnNlcnZlcjogSGxzRXZlbnRFbWl0dGVyLFxuICAgIGNvbmZpZzogSGxzQ29uZmlnLFxuICAgIHR5cGVTdXBwb3J0ZWQsXG4gICAgdmVuZG9yID0gJydcbiAgKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGNocm9tZVZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4gICAgICBjb25zdCByZXN1bHQgPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS9pKTtcbiAgICAgIGNocm9tZVZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gICAgaWYgKHNhZmFyaVdlYmtpdFZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQrKS9pKTtcbiAgICAgIHNhZmFyaVdlYmtpdFZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge31cblxuICByZXNldFRpbWVTdGFtcChkZWZhdWx0VGltZVN0YW1wOiBSYXRpb25hbFRpbWVzdGFtcCB8IG51bGwpIHtcbiAgICBsb2dnZXIubG9nKCdbbXA0LXJlbXV4ZXJdOiBpbml0UFRTICYgaW5pdERUUyByZXNldCcpO1xuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gZGVmYXVsdFRpbWVTdGFtcDtcbiAgfVxuXG4gIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICBsb2dnZXIubG9nKCdbbXA0LXJlbXV4ZXJdOiByZXNldCBuZXh0IHRpbWVzdGFtcCcpO1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gZmFsc2U7XG4gIH1cblxuICByZXNldEluaXRTZWdtZW50KCkge1xuICAgIGxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IElTR2VuZXJhdGVkIGZsYWcgcmVzZXQnKTtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gIH1cblxuICBnZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcykge1xuICAgIGxldCByb2xsb3ZlckRldGVjdGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3RhcnRQVFMgPSB2aWRlb1NhbXBsZXMucmVkdWNlKChtaW5QVFMsIHNhbXBsZSkgPT4ge1xuICAgICAgY29uc3QgZGVsdGEgPSBzYW1wbGUucHRzIC0gbWluUFRTO1xuICAgICAgaWYgKGRlbHRhIDwgLTQyOTQ5NjcyOTYpIHtcbiAgICAgICAgLy8gMl4zMiwgc2VlIFBUU05vcm1hbGl6ZSBmb3IgcmVhc29uaW5nLCBidXQgd2UncmUgaGl0dGluZyBhIHJvbGxvdmVyIGhlcmUsIGFuZCB3ZSBkb24ndCB3YW50IHRoYXQgdG8gaW1wYWN0IHRoZSB0aW1lT2Zmc2V0IGNhbGN1bGF0aW9uXG4gICAgICAgIHJvbGxvdmVyRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUHRzKG1pblBUUywgc2FtcGxlLnB0cyk7XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICByZXR1cm4gbWluUFRTO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZS5wdHM7XG4gICAgICB9XG4gICAgfSwgdmlkZW9TYW1wbGVzWzBdLnB0cyk7XG4gICAgaWYgKHJvbGxvdmVyRGV0ZWN0ZWQpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnUFRTIHJvbGxvdmVyIGRldGVjdGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBzdGFydFBUUztcbiAgfVxuXG4gIHJlbXV4KFxuICAgIGF1ZGlvVHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLFxuICAgIHZpZGVvVHJhY2s6IERlbXV4ZWRBdmNUcmFjayxcbiAgICBpZDNUcmFjazogRGVtdXhlZE1ldGFkYXRhVHJhY2ssXG4gICAgdGV4dFRyYWNrOiBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiBib29sZWFuLFxuICAgIGZsdXNoOiBib29sZWFuLFxuICAgIHBsYXlsaXN0VHlwZTogUGxheWxpc3RMZXZlbFR5cGVcbiAgKTogUmVtdXhlclJlc3VsdCB7XG4gICAgbGV0IHZpZGVvOiBSZW11eGVkVHJhY2sgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGF1ZGlvOiBSZW11eGVkVHJhY2sgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGluaXRTZWdtZW50OiBJbml0U2VnbWVudERhdGEgfCB1bmRlZmluZWQ7XG4gICAgbGV0IHRleHQ6IFJlbXV4ZWRVc2VyZGF0YSB8IHVuZGVmaW5lZDtcbiAgICBsZXQgaWQzOiBSZW11eGVkTWV0YWRhdGEgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGluZGVwZW5kZW50OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIGxldCBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIGxldCB2aWRlb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuXG4gICAgLy8gSWYgd2UncmUgcmVtdXhpbmcgYXVkaW8gYW5kIHZpZGVvIHByb2dyZXNzaXZlbHksIHdhaXQgdW50aWwgd2UndmUgcmVjZWl2ZWQgZW5vdWdoIHNhbXBsZXMgZm9yIGVhY2ggdHJhY2sgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHN5bmNocm9uaXplIHRoZSBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtcy4gV2Uga25vdyBpZiB0aGUgY3VycmVudCBzZWdtZW50IHdpbGwgaGF2ZSBzYW1wbGVzIGlmIHRoZSBcInBpZFwiXG4gICAgLy8gcGFyYW1ldGVyIGlzIGdyZWF0ZXIgdGhhbiAtMS4gVGhlIHBpZCBpcyBzZXQgd2hlbiB0aGUgUE1UIGlzIHBhcnNlZCwgd2hpY2ggY29udGFpbnMgdGhlIHRyYWNrcyBsaXN0LlxuICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSBpbml0U2VnbWVudCBoYXMgYWxyZWFkeSBiZWVuIGdlbmVyYXRlZCwgb3Igd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIGEgc2VnbWVudCAoZmx1c2gpLFxuICAgIC8vIHRoZW4gd2UgY2FuIHJlbXV4IG9uZSB0cmFjayB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBvdGhlci5cbiAgICBjb25zdCBoYXNBdWRpbyA9IGF1ZGlvVHJhY2sucGlkID4gLTE7XG4gICAgY29uc3QgaGFzVmlkZW8gPSB2aWRlb1RyYWNrLnBpZCA+IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgY29uc3QgZW5vdWdoQXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgZW5vdWdoVmlkZW9TYW1wbGVzID0gKGZsdXNoICYmIGxlbmd0aCA+IDApIHx8IGxlbmd0aCA+IDE7XG4gICAgY29uc3QgY2FuUmVtdXhBdmMgPVxuICAgICAgKCghaGFzQXVkaW8gfHwgZW5vdWdoQXVkaW9TYW1wbGVzKSAmJlxuICAgICAgICAoIWhhc1ZpZGVvIHx8IGVub3VnaFZpZGVvU2FtcGxlcykpIHx8XG4gICAgICB0aGlzLklTR2VuZXJhdGVkIHx8XG4gICAgICBmbHVzaDtcblxuICAgIGlmIChjYW5SZW11eEF2Yykge1xuICAgICAgaWYgKCF0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKFxuICAgICAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICAgICAgdmlkZW9UcmFjayxcbiAgICAgICAgICB0aW1lT2Zmc2V0LFxuICAgICAgICAgIGFjY3VyYXRlVGltZU9mZnNldFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc1ZpZGVvQ29udGlndW91cyA9IHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXM7XG4gICAgICBsZXQgZmlyc3RLZXlGcmFtZUluZGV4ID0gLTE7XG4gICAgICBsZXQgZmlyc3RLZXlGcmFtZVBUUztcblxuICAgICAgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICBmaXJzdEtleUZyYW1lSW5kZXggPSBmaW5kS2V5ZnJhbWVJbmRleCh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICBpZiAoIWlzVmlkZW9Db250aWd1b3VzICYmIHRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICBpbmRlcGVuZGVudCA9IHRydWU7XG4gICAgICAgICAgaWYgKGZpcnN0S2V5RnJhbWVJbmRleCA+IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICBgW21wNC1yZW11eGVyXTogRHJvcHBlZCAke2ZpcnN0S2V5RnJhbWVJbmRleH0gb3V0IG9mICR7bGVuZ3RofSB2aWRlbyBzYW1wbGVzIGR1ZSB0byBhIG1pc3Npbmcga2V5ZnJhbWVgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9UcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcy5zbGljZShmaXJzdEtleUZyYW1lSW5kZXgpO1xuICAgICAgICAgICAgdmlkZW9UcmFjay5kcm9wcGVkICs9IGZpcnN0S2V5RnJhbWVJbmRleDtcbiAgICAgICAgICAgIHZpZGVvVGltZU9mZnNldCArPVxuICAgICAgICAgICAgICAodmlkZW9UcmFjay5zYW1wbGVzWzBdLnB0cyAtIHN0YXJ0UFRTKSAvXG4gICAgICAgICAgICAgIHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgICBmaXJzdEtleUZyYW1lUFRTID0gdmlkZW9UaW1lT2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3RLZXlGcmFtZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgIGBbbXA0LXJlbXV4ZXJdOiBObyBrZXlmcmFtZSBmb3VuZCBvdXQgb2YgJHtsZW5ndGh9IHZpZGVvIHNhbXBsZXNgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgaWYgKGVub3VnaEF1ZGlvU2FtcGxlcyAmJiBlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAvLyB0aW1lT2Zmc2V0IGlzIGV4cGVjdGVkIHRvIGJlIHRoZSBvZmZzZXQgb2YgdGhlIGZpcnN0IHRpbWVzdGFtcCBvZiB0aGlzIGZyYWdtZW50IChmaXJzdCBEVFMpXG4gICAgICAgICAgLy8gaWYgZmlyc3QgYXVkaW8gRFRTIGlzIG5vdCBhbGlnbmVkIHdpdGggZmlyc3QgdmlkZW8gRFRTIHRoZW4gd2UgbmVlZCB0byB0YWtlIHRoYXQgaW50byBhY2NvdW50XG4gICAgICAgICAgLy8gd2hlbiBwcm92aWRpbmcgdGltZU9mZnNldCB0byByZW11eEF1ZGlvIC8gcmVtdXhWaWRlby4gaWYgd2UgZG9uJ3QgZG8gdGhhdCwgdGhlcmUgbWlnaHQgYmUgYSBwZXJtYW5lbnQgLyBzbWFsbFxuICAgICAgICAgIC8vIGRyaWZ0IGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvIHN0cmVhbXNcbiAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgIGNvbnN0IHRzRGVsdGEgPVxuICAgICAgICAgICAgbm9ybWFsaXplUHRzKGF1ZGlvVHJhY2suc2FtcGxlc1swXS5wdHMsIHN0YXJ0UFRTKSAtIHN0YXJ0UFRTO1xuICAgICAgICAgIGNvbnN0IGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSA9IHRzRGVsdGEgLyB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICAgIGF1ZGlvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCBhdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEpO1xuICAgICAgICAgIHZpZGVvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCAtYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1cnBvc2VmdWxseSByZW11eGluZyBhdWRpbyBiZWZvcmUgdmlkZW8sIHNvIHRoYXQgcmVtdXhWaWRlbyBjYW4gdXNlIG5leHRBdWRpb1B0cywgd2hpY2ggaXMgY2FsY3VsYXRlZCBpbiByZW11eEF1ZGlvLlxuICAgICAgICBpZiAoZW5vdWdoQXVkaW9TYW1wbGVzKSB7XG4gICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IGF1ZGlvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICBpZiAoIWF1ZGlvVHJhY2suc2FtcGxlcmF0ZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICdbbXA0LXJlbXV4ZXJdOiByZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKFxuICAgICAgICAgICAgICBhdWRpb1RyYWNrLFxuICAgICAgICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICAgICAgICB0aW1lT2Zmc2V0LFxuICAgICAgICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF1ZGlvID0gdGhpcy5yZW11eEF1ZGlvKFxuICAgICAgICAgICAgYXVkaW9UcmFjayxcbiAgICAgICAgICAgIGF1ZGlvVGltZU9mZnNldCxcbiAgICAgICAgICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMsXG4gICAgICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICAgICAgICBoYXNWaWRlbyB8fFxuICAgICAgICAgICAgICBlbm91Z2hWaWRlb1NhbXBsZXMgfHxcbiAgICAgICAgICAgICAgcGxheWxpc3RUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5BVURJT1xuICAgICAgICAgICAgICA/IHZpZGVvVGltZU9mZnNldFxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9UcmFja0xlbmd0aCA9IGF1ZGlvID8gYXVkaW8uZW5kUFRTIC0gYXVkaW8uc3RhcnRQVFMgOiAwO1xuICAgICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IHZpZGVvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICAgIGlmICghdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZSkge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICAnW21wNC1yZW11eGVyXTogcmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZCdcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoXG4gICAgICAgICAgICAgICAgYXVkaW9UcmFjayxcbiAgICAgICAgICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICAgICAgICAgIHRpbWVPZmZzZXQsXG4gICAgICAgICAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWRlbyA9IHRoaXMucmVtdXhWaWRlbyhcbiAgICAgICAgICAgICAgdmlkZW9UcmFjayxcbiAgICAgICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0LFxuICAgICAgICAgICAgICBpc1ZpZGVvQ29udGlndW91cyxcbiAgICAgICAgICAgICAgYXVkaW9UcmFja0xlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgdmlkZW8gPSB0aGlzLnJlbXV4VmlkZW8oXG4gICAgICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0LFxuICAgICAgICAgICAgaXNWaWRlb0NvbnRpZ3VvdXMsXG4gICAgICAgICAgICAwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICB2aWRlby5maXJzdEtleUZyYW1lID0gZmlyc3RLZXlGcmFtZUluZGV4O1xuICAgICAgICAgIHZpZGVvLmluZGVwZW5kZW50ID0gZmlyc3RLZXlGcmFtZUluZGV4ICE9PSAtMTtcbiAgICAgICAgICB2aWRlby5maXJzdEtleUZyYW1lUFRTID0gZmlyc3RLZXlGcmFtZVBUUztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG93IElEMyBhbmQgdGV4dCB0byByZW11eCwgZXZlbiBpZiBtb3JlIGF1ZGlvL3ZpZGVvIHNhbXBsZXMgYXJlIHJlcXVpcmVkXG4gICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQgJiYgdGhpcy5faW5pdFBUUyAmJiB0aGlzLl9pbml0RFRTKSB7XG4gICAgICBpZiAoaWQzVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgaWQzID0gZmx1c2hUZXh0VHJhY2tNZXRhZGF0YUN1ZVNhbXBsZXMoXG4gICAgICAgICAgaWQzVHJhY2ssXG4gICAgICAgICAgdGltZU9mZnNldCxcbiAgICAgICAgICB0aGlzLl9pbml0UFRTLFxuICAgICAgICAgIHRoaXMuX2luaXREVFNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICB0ZXh0ID0gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXMoXG4gICAgICAgICAgdGV4dFRyYWNrLFxuICAgICAgICAgIHRpbWVPZmZzZXQsXG4gICAgICAgICAgdGhpcy5faW5pdFBUU1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhdWRpbyxcbiAgICAgIHZpZGVvLFxuICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICBpbmRlcGVuZGVudCxcbiAgICAgIHRleHQsXG4gICAgICBpZDMsXG4gICAgfTtcbiAgfVxuXG4gIGdlbmVyYXRlSVMoXG4gICAgYXVkaW9UcmFjazogRGVtdXhlZEF1ZGlvVHJhY2ssXG4gICAgdmlkZW9UcmFjazogRGVtdXhlZEF2Y1RyYWNrLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGJvb2xlYW5cbiAgKTogSW5pdFNlZ21lbnREYXRhIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXM7XG4gICAgY29uc3QgdmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzO1xuICAgIGNvbnN0IHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQ7XG4gICAgY29uc3QgdHJhY2tzOiBUcmFja1NldCA9IHt9O1xuICAgIGNvbnN0IF9pbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICBsZXQgY29tcHV0ZVBUU0RUUyA9ICFfaW5pdFBUUyB8fCBhY2N1cmF0ZVRpbWVPZmZzZXQ7XG4gICAgbGV0IGNvbnRhaW5lciA9ICdhdWRpby9tcDQnO1xuICAgIGxldCBpbml0UFRTOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGluaXREVFM6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBsZXQgdGltZXNjYWxlOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBJbmZpbml0eTtcbiAgICB9XG5cbiAgICBpZiAoYXVkaW9UcmFjay5jb25maWcgJiYgYXVkaW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgLy8gbGV0J3MgdXNlIGF1ZGlvIHNhbXBsaW5nIHJhdGUgYXMgTVA0IHRpbWUgc2NhbGUuXG4gICAgICAvLyByYXRpb25hbGUgaXMgdGhhdCB0aGVyZSBpcyBhIGludGVnZXIgbmIgb2YgYXVkaW8gZnJhbWVzIHBlciBhdWRpbyBzYW1wbGUgKDEwMjQgZm9yIEFBQylcbiAgICAgIC8vIHVzaW5nIGF1ZGlvIHNhbXBsaW5nIHJhdGUgaGVyZSBoZWxwcyBoYXZpbmcgYW4gaW50ZWdlciBNUDQgZnJhbWUgZHVyYXRpb25cbiAgICAgIC8vIHRoaXMgYXZvaWRzIHBvdGVudGlhbCByb3VuZGluZyBpc3N1ZSBhbmQgQVYgc3luYyBpc3N1ZVxuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSBhdWRpb1RyYWNrLnNhbXBsZXJhdGU7XG4gICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgaWYgKHR5cGVTdXBwb3J0ZWQubXBlZykge1xuICAgICAgICAgICAgLy8gQ2hyb21lIGFuZCBTYWZhcmlcbiAgICAgICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcGVnJztcbiAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVTdXBwb3J0ZWQubXAzKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJ21wMyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICBpZDogJ2F1ZGlvJyxcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIGNvZGVjOiBhdWRpb1RyYWNrLmNvZGVjLFxuICAgICAgICBpbml0U2VnbWVudDpcbiAgICAgICAgICBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ21wMycgJiYgdHlwZVN1cHBvcnRlZC5tcGVnXG4gICAgICAgICAgICA/IG5ldyBVaW50OEFycmF5KDApXG4gICAgICAgICAgICA6IE1QNC5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogYXVkaW9UcmFjay5jaGFubmVsQ291bnQsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGltZXNjYWxlID0gYXVkaW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgaWYgKCFfaW5pdFBUUyB8fCB0aW1lc2NhbGUgIT09IF9pbml0UFRTLnRpbWVzY2FsZSkge1xuICAgICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiB0aGlzIGRlbXV4aW5nIGNvbnRleHQuIGZvciBhdWRpbywgUFRTID0gRFRTXG4gICAgICAgICAgaW5pdFBUUyA9IGluaXREVFMgPVxuICAgICAgICAgICAgYXVkaW9TYW1wbGVzWzBdLnB0cyAtIE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcHV0ZVBUU0RUUyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZpZGVvVHJhY2suc3BzICYmIHZpZGVvVHJhY2sucHBzICYmIHZpZGVvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIC8vIGxldCdzIHVzZSBpbnB1dCB0aW1lIHNjYWxlIGFzIE1QNCB2aWRlbyB0aW1lc2NhbGVcbiAgICAgIC8vIHdlIHVzZSBpbnB1dCB0aW1lIHNjYWxlIHN0cmFpZ2h0IGF3YXkgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzIG9uIGZyYW1lIGR1cmF0aW9uIC8gY3RzIGNvbXB1dGF0aW9uXG4gICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICB0cmFja3MudmlkZW8gPSB7XG4gICAgICAgIGlkOiAnbWFpbicsXG4gICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjOiB2aWRlb1RyYWNrLmNvZGVjLFxuICAgICAgICBpbml0U2VnbWVudDogTVA0LmluaXRTZWdtZW50KFt2aWRlb1RyYWNrXSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgd2lkdGg6IHZpZGVvVHJhY2sud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB2aWRlb1RyYWNrLmhlaWdodCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aW1lc2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICBpZiAoIV9pbml0UFRTIHx8IHRpbWVzY2FsZSAhPT0gX2luaXRQVFMudGltZXNjYWxlKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9TYW1wbGVzKTtcbiAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKFxuICAgICAgICAgICAgaW5pdERUUyBhcyBudW1iZXIsXG4gICAgICAgICAgICBub3JtYWxpemVQdHModmlkZW9TYW1wbGVzWzBdLmR0cywgc3RhcnRQVFMpIC0gc3RhcnRPZmZzZXRcbiAgICAgICAgICApO1xuICAgICAgICAgIGluaXRQVFMgPSBNYXRoLm1pbihpbml0UFRTIGFzIG51bWJlciwgc3RhcnRQVFMgLSBzdGFydE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcHV0ZVBUU0RUUyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRyYWNrcykubGVuZ3RoKSB7XG4gICAgICB0aGlzLklTR2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRoaXMuX2luaXRQVFMgPSB7XG4gICAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMgYXMgbnVtYmVyLFxuICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlIGFzIG51bWJlcixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW5pdERUUyA9IHtcbiAgICAgICAgICBiYXNlVGltZTogaW5pdERUUyBhcyBudW1iZXIsXG4gICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUgYXMgbnVtYmVyLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdFBUUyA9IHRpbWVzY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhY2tzLFxuICAgICAgICBpbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGUsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJlbXV4VmlkZW8oXG4gICAgdHJhY2s6IERlbXV4ZWRBdmNUcmFjayxcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gICAgY29udGlndW91czogYm9vbGVhbixcbiAgICBhdWRpb1RyYWNrTGVuZ3RoOiBudW1iZXJcbiAgKTogUmVtdXhlZFRyYWNrIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB0aW1lU2NhbGU6IG51bWJlciA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGlucHV0U2FtcGxlczogQXJyYXk8QXZjU2FtcGxlPiA9IHRyYWNrLnNhbXBsZXM7XG4gICAgY29uc3Qgb3V0cHV0U2FtcGxlczogQXJyYXk8TXA0U2FtcGxlPiA9IFtdO1xuICAgIGNvbnN0IG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFMgYXMgUmF0aW9uYWxUaW1lc3RhbXA7XG4gICAgbGV0IG5leHRBdmNEdHMgPSB0aGlzLm5leHRBdmNEdHM7XG4gICAgbGV0IG9mZnNldCA9IDg7XG4gICAgbGV0IG1wNFNhbXBsZUR1cmF0aW9uID0gdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uO1xuICAgIGxldCBmaXJzdERUUztcbiAgICBsZXQgbGFzdERUUztcbiAgICBsZXQgbWluUFRTOiBudW1iZXIgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heFBUUzogbnVtYmVyID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGxldCBzb3J0U2FtcGxlcyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgcGFyc2VkIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXMgd2l0aCBsYXN0IG9uZSwgbGV0J3MgdXNlIGxhc3QgRFRTIHZhbHVlIGFzIHJlZmVyZW5jZVxuICAgIGlmICghY29udGlndW91cyB8fCBuZXh0QXZjRHRzID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwdHMgPSB0aW1lT2Zmc2V0ICogdGltZVNjYWxlO1xuICAgICAgY29uc3QgY3RzID1cbiAgICAgICAgaW5wdXRTYW1wbGVzWzBdLnB0cyAtXG4gICAgICAgIG5vcm1hbGl6ZVB0cyhpbnB1dFNhbXBsZXNbMF0uZHRzLCBpbnB1dFNhbXBsZXNbMF0ucHRzKTtcbiAgICAgIC8vIGlmIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGFyZ2V0IHRpbWVPZmZzZXRcbiAgICAgIG5leHRBdmNEdHMgPSBwdHMgLSBjdHM7XG4gICAgfVxuXG4gICAgLy8gUFRTIGlzIGNvZGVkIG9uIDMzYml0cywgYW5kIGNhbiBsb29wIGZyb20gLTJeMzIgdG8gMl4zMlxuICAgIC8vIFBUU05vcm1hbGl6ZSB3aWxsIG1ha2UgUFRTL0RUUyB2YWx1ZSBtb25vdG9uaWMsIHdlIHVzZSBsYXN0IGtub3duIERUUyB2YWx1ZSBhcyByZWZlcmVuY2UgdmFsdWVcbiAgICBjb25zdCBpbml0VGltZSA9IChpbml0UFRTLmJhc2VUaW1lICogdGltZVNjYWxlKSAvIGluaXRQVFMudGltZXNjYWxlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRUaW1lLCBuZXh0QXZjRHRzKTtcbiAgICAgIHNhbXBsZS5kdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLmR0cyAtIGluaXRUaW1lLCBuZXh0QXZjRHRzKTtcbiAgICAgIGlmIChzYW1wbGUuZHRzIDwgaW5wdXRTYW1wbGVzW2kgPiAwID8gaSAtIDEgOiBpXS5kdHMpIHtcbiAgICAgICAgc29ydFNhbXBsZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNvcnQgdmlkZW8gc2FtcGxlcyBieSBEVFMgdGhlbiBQVFMgdGhlbiBkZW11eCBpZCBvcmRlclxuICAgIGlmIChzb3J0U2FtcGxlcykge1xuICAgICAgaW5wdXRTYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgY29uc3QgZGVsdGFkdHMgPSBhLmR0cyAtIGIuZHRzO1xuICAgICAgICBjb25zdCBkZWx0YXB0cyA9IGEucHRzIC0gYi5wdHM7XG4gICAgICAgIHJldHVybiBkZWx0YWR0cyB8fCBkZWx0YXB0cztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEdldCBmaXJzdC9sYXN0IERUU1xuICAgIGZpcnN0RFRTID0gaW5wdXRTYW1wbGVzWzBdLmR0cztcbiAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW2lucHV0U2FtcGxlcy5sZW5ndGggLSAxXS5kdHM7XG5cbiAgICAvLyBTYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAvLyBzZXQgdGhpcyBjb25zdGFudCBkdXJhdGlvbiBhcyBiZWluZyB0aGUgYXZnIGRlbHRhIGJldHdlZW4gY29uc2VjdXRpdmUgRFRTLlxuICAgIGNvbnN0IGlucHV0RHVyYXRpb24gPSBsYXN0RFRTIC0gZmlyc3REVFM7XG4gICAgY29uc3QgYXZlcmFnZVNhbXBsZUR1cmF0aW9uID0gaW5wdXREdXJhdGlvblxuICAgICAgPyBNYXRoLnJvdW5kKGlucHV0RHVyYXRpb24gLyAobmJTYW1wbGVzIC0gMSkpXG4gICAgICA6IG1wNFNhbXBsZUR1cmF0aW9uIHx8IHRyYWNrLmlucHV0VGltZVNjYWxlIC8gMzA7XG5cbiAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICBpZiAoY29udGlndW91cykge1xuICAgICAgLy8gY2hlY2sgdGltZXN0YW1wIGNvbnRpbnVpdHkgYWNyb3NzIGNvbnNlY3V0aXZlIGZyYWdtZW50cyAodGhpcyBpcyB0byByZW1vdmUgaW50ZXItZnJhZ21lbnQgZ2FwL2hvbGUpXG4gICAgICBjb25zdCBkZWx0YSA9IGZpcnN0RFRTIC0gbmV4dEF2Y0R0cztcbiAgICAgIGNvbnN0IGZvdW5kSG9sZSA9IGRlbHRhID4gYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgY29uc3QgZm91bmRPdmVybGFwID0gZGVsdGEgPCAtMTtcbiAgICAgIGlmIChmb3VuZEhvbGUgfHwgZm91bmRPdmVybGFwKSB7XG4gICAgICAgIGlmIChmb3VuZEhvbGUpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgIGBBVkM6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhcbiAgICAgICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICl9IG1zICgke2RlbHRhfWR0cykgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCwgZmlsbGluZyBpdGBcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYEFWQzogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKFxuICAgICAgICAgICAgICAtZGVsdGEsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICl9IG1zICgke2RlbHRhfWR0cykgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWRgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvdW5kT3ZlcmxhcCB8fCBuZXh0QXZjRHRzID49IGlucHV0U2FtcGxlc1swXS5wdHMpIHtcbiAgICAgICAgICBmaXJzdERUUyA9IG5leHRBdmNEdHM7XG4gICAgICAgICAgY29uc3QgZmlyc3RQVFMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzIC0gZGVsdGE7XG4gICAgICAgICAgaW5wdXRTYW1wbGVzWzBdLmR0cyA9IGZpcnN0RFRTO1xuICAgICAgICAgIGlucHV0U2FtcGxlc1swXS5wdHMgPSBmaXJzdFBUUztcbiAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgYFZpZGVvOiBGaXJzdCBQVFMvRFRTIGFkanVzdGVkOiAke3RvTXNGcm9tTXBlZ1RzQ2xvY2soXG4gICAgICAgICAgICAgIGZpcnN0UFRTLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApfS8ke3RvTXNGcm9tTXBlZ1RzQ2xvY2soXG4gICAgICAgICAgICAgIGZpcnN0RFRTLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApfSwgZGVsdGE6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhkZWx0YSwgdHJ1ZSl9IG1zYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaXJzdERUUyA9IE1hdGgubWF4KDAsIGZpcnN0RFRTKTtcblxuICAgIGxldCBuYk5hbHUgPSAwO1xuICAgIGxldCBuYWx1TGVuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICAvLyBjb21wdXRlIHRvdGFsL2F2YyBzYW1wbGUgbGVuZ3RoIGFuZCBuYiBvZiBOQUwgdW5pdHNcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIGNvbnN0IHVuaXRzID0gc2FtcGxlLnVuaXRzO1xuICAgICAgY29uc3QgbmJVbml0cyA9IHVuaXRzLmxlbmd0aDtcbiAgICAgIGxldCBzYW1wbGVMZW4gPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgc2FtcGxlTGVuICs9IHVuaXRzW2pdLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBuYWx1TGVuICs9IHNhbXBsZUxlbjtcbiAgICAgIG5iTmFsdSArPSBuYlVuaXRzO1xuICAgICAgc2FtcGxlLmxlbmd0aCA9IHNhbXBsZUxlbjtcblxuICAgICAgLy8gZW5zdXJlIHNhbXBsZSBtb25vdG9uaWMgRFRTXG4gICAgICBzYW1wbGUuZHRzID0gTWF0aC5tYXgoc2FtcGxlLmR0cywgZmlyc3REVFMpO1xuXG4gICAgICBtaW5QVFMgPSBNYXRoLm1pbihzYW1wbGUucHRzLCBtaW5QVFMpO1xuICAgICAgbWF4UFRTID0gTWF0aC5tYXgoc2FtcGxlLnB0cywgbWF4UFRTKTtcbiAgICB9XG4gICAgbGFzdERUUyA9IGlucHV0U2FtcGxlc1tuYlNhbXBsZXMgLSAxXS5kdHM7XG5cbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXG4gICAgY29uc3QgbWRhdFNpemUgPSBuYWx1TGVuICsgNCAqIG5iTmFsdSArIDg7XG4gICAgbGV0IG1kYXQ7XG4gICAgdHJ5IHtcbiAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NVVhfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICBieXRlczogbWRhdFNpemUsXG4gICAgICAgIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0ICR7bWRhdFNpemV9YCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xuXG4gICAgbGV0IHN0cmV0Y2hlZExhc3RGcmFtZSA9IGZhbHNlO1xuICAgIGxldCBtaW5EdHNEZWx0YSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWluUHRzRGVsdGEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heER0c0RlbHRhID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXhQdHNEZWx0YSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICBjb25zdCBhdmNTYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV07XG4gICAgICBjb25zdCBhdmNTYW1wbGVVbml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgIGxldCBtcDRTYW1wbGVMZW5ndGggPSAwO1xuICAgICAgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxuICAgICAgZm9yIChsZXQgaiA9IDAsIG5iVW5pdHMgPSBhdmNTYW1wbGVVbml0cy5sZW5ndGg7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgY29uc3QgdW5pdCA9IGF2Y1NhbXBsZVVuaXRzW2pdO1xuICAgICAgICBjb25zdCB1bml0RGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgY29uc3QgdW5pdERhdGFMZW4gPSB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCB1bml0RGF0YUxlbik7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBtZGF0LnNldCh1bml0RGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHVuaXREYXRhTGVuO1xuICAgICAgICBtcDRTYW1wbGVMZW5ndGggKz0gNCArIHVuaXREYXRhTGVuO1xuICAgICAgfVxuXG4gICAgICAvLyBleHBlY3RlZCBzYW1wbGUgZHVyYXRpb24gaXMgdGhlIERlY29kaW5nIFRpbWVzdGFtcCBkaWZmIG9mIGNvbnNlY3V0aXZlIHNhbXBsZXNcbiAgICAgIGxldCBwdHNEZWx0YTtcbiAgICAgIGlmIChpIDwgbmJTYW1wbGVzIC0gMSkge1xuICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGlucHV0U2FtcGxlc1tpICsgMV0uZHRzIC0gYXZjU2FtcGxlLmR0cztcbiAgICAgICAgcHRzRGVsdGEgPSBpbnB1dFNhbXBsZXNbaSArIDFdLnB0cyAtIGF2Y1NhbXBsZS5wdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgbGFzdEZyYW1lRHVyYXRpb24gPVxuICAgICAgICAgIGkgPiAwXG4gICAgICAgICAgICA/IGF2Y1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbaSAtIDFdLmR0c1xuICAgICAgICAgICAgOiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICAgIHB0c0RlbHRhID1cbiAgICAgICAgICBpID4gMFxuICAgICAgICAgICAgPyBhdmNTYW1wbGUucHRzIC0gaW5wdXRTYW1wbGVzW2kgLSAxXS5wdHNcbiAgICAgICAgICAgIDogYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2sgJiYgdGhpcy5uZXh0QXVkaW9QdHMgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cbiAgICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBhbHJlYWR5IHJlbXV4ZWQgYXVkaW8sIGFuZCB3ZSBrbm93IGhvdyBsb25nIHRoZSBhdWRpbyB0cmFjayBpcywgd2UgbG9vayB0b1xuICAgICAgICAgIC8vIHNlZSBpZiB0aGUgZGVsdGEgdG8gdGhlIG5leHQgc2VnbWVudCBpcyBsb25nZXIgdGhhbiBtYXhCdWZmZXJIb2xlLlxuICAgICAgICAgIC8vIElmIHNvLCBwbGF5YmFjayB3b3VsZCBwb3RlbnRpYWxseSBnZXQgc3R1Y2ssIHNvIHdlIGFydGlmaWNpYWxseSBpbmZsYXRlXG4gICAgICAgICAgLy8gdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IGZyYW1lIHRvIG1pbmltaXplIGFueSBwb3RlbnRpYWwgZ2FwIGJldHdlZW4gc2VnbWVudHMuXG4gICAgICAgICAgY29uc3QgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihjb25maWcubWF4QnVmZmVySG9sZSAqIHRpbWVTY2FsZSk7XG4gICAgICAgICAgY29uc3QgZGVsdGFUb0ZyYW1lRW5kID1cbiAgICAgICAgICAgIChhdWRpb1RyYWNrTGVuZ3RoXG4gICAgICAgICAgICAgID8gbWluUFRTICsgYXVkaW9UcmFja0xlbmd0aCAqIHRpbWVTY2FsZVxuICAgICAgICAgICAgICA6IHRoaXMubmV4dEF1ZGlvUHRzKSAtIGF2Y1NhbXBsZS5wdHM7XG4gICAgICAgICAgaWYgKGRlbHRhVG9GcmFtZUVuZCA+IGdhcFRvbGVyYW5jZSkge1xuICAgICAgICAgICAgLy8gV2Ugc3VidHJhY3QgbGFzdEZyYW1lRHVyYXRpb24gZnJvbSBkZWx0YVRvRnJhbWVFbmQgdG8gdHJ5IHRvIHByZXZlbnQgYW55IHZpZGVvXG4gICAgICAgICAgICAvLyBmcmFtZSBvdmVybGFwLiBtYXhCdWZmZXJIb2xlIHNob3VsZCBiZSA+PiBsYXN0RnJhbWVEdXJhdGlvbiBhbnl3YXkuXG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGRlbHRhVG9GcmFtZUVuZCAtIGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKG1wNFNhbXBsZUR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyZXRjaGVkTGFzdEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICAgICAgIGBbbXA0LXJlbXV4ZXJdOiBJdCBpcyBhcHByb3hpbWF0ZWx5ICR7XG4gICAgICAgICAgICAgICAgZGVsdGFUb0ZyYW1lRW5kIC8gOTBcbiAgICAgICAgICAgICAgfSBtcyB0byB0aGUgbmV4dCBzZWdtZW50OyB1c2luZyBkdXJhdGlvbiAke1xuICAgICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uIC8gOTBcbiAgICAgICAgICAgICAgfSBtcyBmb3IgdGhlIGxhc3QgdmlkZW8gZnJhbWUuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5yb3VuZChhdmNTYW1wbGUucHRzIC0gYXZjU2FtcGxlLmR0cyk7XG4gICAgICBtaW5EdHNEZWx0YSA9IE1hdGgubWluKG1pbkR0c0RlbHRhLCBtcDRTYW1wbGVEdXJhdGlvbik7XG4gICAgICBtYXhEdHNEZWx0YSA9IE1hdGgubWF4KG1heER0c0RlbHRhLCBtcDRTYW1wbGVEdXJhdGlvbik7XG4gICAgICBtaW5QdHNEZWx0YSA9IE1hdGgubWluKG1pblB0c0RlbHRhLCBwdHNEZWx0YSk7XG4gICAgICBtYXhQdHNEZWx0YSA9IE1hdGgubWF4KG1heFB0c0RlbHRhLCBwdHNEZWx0YSk7XG5cbiAgICAgIG91dHB1dFNhbXBsZXMucHVzaChcbiAgICAgICAgbmV3IE1wNFNhbXBsZShcbiAgICAgICAgICBhdmNTYW1wbGUua2V5LFxuICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uLFxuICAgICAgICAgIG1wNFNhbXBsZUxlbmd0aCxcbiAgICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3V0cHV0U2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGlmIChjaHJvbWVWZXJzaW9uKSB7XG4gICAgICAgIGlmIChjaHJvbWVWZXJzaW9uIDwgNzApIHtcbiAgICAgICAgICAvLyBDaHJvbWUgd29ya2Fyb3VuZCwgbWFyayBmaXJzdCBzYW1wbGUgYXMgYmVpbmcgYSBSYW5kb20gQWNjZXNzIFBvaW50IChrZXlmcmFtZSkgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxuICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjk0MTJcbiAgICAgICAgICBjb25zdCBmbGFncyA9IG91dHB1dFNhbXBsZXNbMF0uZmxhZ3M7XG4gICAgICAgICAgZmxhZ3MuZGVwZW5kc09uID0gMjtcbiAgICAgICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNhZmFyaVdlYmtpdFZlcnNpb24pIHtcbiAgICAgICAgLy8gRml4IGZvciBcIkNOTiBzcGVjaWFsIHJlcG9ydCwgd2l0aCBDQ1wiIGluIHRlc3Qtc3RyZWFtcyAoU2FmYXJpIGJyb3dzZXIgb25seSlcbiAgICAgICAgLy8gSWdub3JlIERUUyB3aGVuIGZyYW1lIGR1cmF0aW9ucyBhcmUgaXJyZWd1bGFyLiBTYWZhcmkgTVNFIGRvZXMgbm90IGhhbmRsZSB0aGlzIGxlYWRpbmcgdG8gZ2Fwcy5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1heFB0c0RlbHRhIC0gbWluUHRzRGVsdGEgPCBtYXhEdHNEZWx0YSAtIG1pbkR0c0RlbHRhICYmXG4gICAgICAgICAgYXZlcmFnZVNhbXBsZUR1cmF0aW9uIC8gbWF4RHRzRGVsdGEgPCAwLjAyNSAmJlxuICAgICAgICAgIG91dHB1dFNhbXBsZXNbMF0uY3RzID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgJ0ZvdW5kIGlycmVndWxhciBnYXBzIGluIHNhbXBsZSBkdXJhdGlvbi4gVXNpbmcgUFRTIGluc3RlYWQgb2YgRFRTIHRvIGRldGVybWluZSBNUDQgc2FtcGxlIGR1cmF0aW9uLidcbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkdHMgPSBmaXJzdERUUztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dER0cyA9IGR0cyArIG91dHB1dFNhbXBsZXNbaV0uZHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBwdHMgPSBkdHMgKyBvdXRwdXRTYW1wbGVzW2ldLmN0cztcbiAgICAgICAgICAgIGlmIChpIDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgICBjb25zdCBuZXh0UHRzID0gbmV4dER0cyArIG91dHB1dFNhbXBsZXNbaSArIDFdLmN0cztcbiAgICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tpXS5kdXJhdGlvbiA9IG5leHRQdHMgLSBwdHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRwdXRTYW1wbGVzW2ldLmR1cmF0aW9uID0gaVxuICAgICAgICAgICAgICAgID8gb3V0cHV0U2FtcGxlc1tpIC0gMV0uZHVyYXRpb25cbiAgICAgICAgICAgICAgICA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbaV0uY3RzID0gMDtcbiAgICAgICAgICAgIGR0cyA9IG5leHREdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5leHQgQVZDIHNhbXBsZSBEVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIERUUyArIGxhc3Qgc2FtcGxlIGR1cmF0aW9uIChpbiBQRVMgdGltZXNjYWxlKVxuICAgIG1wNFNhbXBsZUR1cmF0aW9uID1cbiAgICAgIHN0cmV0Y2hlZExhc3RGcmFtZSB8fCAhbXA0U2FtcGxlRHVyYXRpb25cbiAgICAgICAgPyBhdmVyYWdlU2FtcGxlRHVyYXRpb25cbiAgICAgICAgOiBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICB0aGlzLm5leHRBdmNEdHMgPSBuZXh0QXZjRHRzID0gbGFzdERUUyArIG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSB0cnVlO1xuICAgIGNvbnN0IG1vb2YgPSBNUDQubW9vZihcbiAgICAgIHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssXG4gICAgICBmaXJzdERUUyxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRyYWNrLCB7XG4gICAgICAgIHNhbXBsZXM6IG91dHB1dFNhbXBsZXMsXG4gICAgICB9KVxuICAgICk7XG4gICAgY29uc3QgdHlwZTogU291cmNlQnVmZmVyTmFtZSA9ICd2aWRlbyc7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGRhdGExOiBtb29mLFxuICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICBzdGFydFBUUzogbWluUFRTIC8gdGltZVNjYWxlLFxuICAgICAgZW5kUFRTOiAobWF4UFRTICsgbXA0U2FtcGxlRHVyYXRpb24pIC8gdGltZVNjYWxlLFxuICAgICAgc3RhcnREVFM6IGZpcnN0RFRTIC8gdGltZVNjYWxlLFxuICAgICAgZW5kRFRTOiAobmV4dEF2Y0R0cyBhcyBudW1iZXIpIC8gdGltZVNjYWxlLFxuICAgICAgdHlwZSxcbiAgICAgIGhhc0F1ZGlvOiBmYWxzZSxcbiAgICAgIGhhc1ZpZGVvOiB0cnVlLFxuICAgICAgbmI6IG91dHB1dFNhbXBsZXMubGVuZ3RoLFxuICAgICAgZHJvcHBlZDogdHJhY2suZHJvcHBlZCxcbiAgICB9O1xuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICB0cmFjay5kcm9wcGVkID0gMDtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJlbXV4QXVkaW8oXG4gICAgdHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBjb250aWd1b3VzOiBib29sZWFuLFxuICAgIGFjY3VyYXRlVGltZU9mZnNldDogYm9vbGVhbixcbiAgICB2aWRlb1RpbWVPZmZzZXQ/OiBudW1iZXJcbiAgKTogUmVtdXhlZFRyYWNrIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZTogbnVtYmVyID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgbXA0dGltZVNjYWxlOiBudW1iZXIgPSB0cmFjay5zYW1wbGVyYXRlXG4gICAgICA/IHRyYWNrLnNhbXBsZXJhdGVcbiAgICAgIDogaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3I6IG51bWJlciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlO1xuICAgIGNvbnN0IG1wNFNhbXBsZUR1cmF0aW9uOiBudW1iZXIgPVxuICAgICAgdHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJ1xuICAgICAgICA/IEFBQ19TQU1QTEVTX1BFUl9GUkFNRVxuICAgICAgICA6IE1QRUdfQVVESU9fU0FNUExFX1BFUl9GUkFNRTtcbiAgICBjb25zdCBpbnB1dFNhbXBsZUR1cmF0aW9uOiBudW1iZXIgPSBtcDRTYW1wbGVEdXJhdGlvbiAqIHNjYWxlRmFjdG9yO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTIGFzIFJhdGlvbmFsVGltZXN0YW1wO1xuICAgIGNvbnN0IHJhd01QRUc6IGJvb2xlYW4gPVxuICAgICAgdHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0aGlzLnR5cGVTdXBwb3J0ZWQubXBlZztcbiAgICBjb25zdCBvdXRwdXRTYW1wbGVzOiBBcnJheTxNcDRTYW1wbGU+ID0gW107XG4gICAgY29uc3QgYWxpZ25lZFdpdGhWaWRlbyA9IHZpZGVvVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgbGV0IGlucHV0U2FtcGxlczogQXJyYXk8QXVkaW9TYW1wbGU+ID0gdHJhY2suc2FtcGxlcztcbiAgICBsZXQgb2Zmc2V0OiBudW1iZXIgPSByYXdNUEVHID8gMCA6IDg7XG4gICAgbGV0IG5leHRBdWRpb1B0czogbnVtYmVyID0gdGhpcy5uZXh0QXVkaW9QdHMgfHwgLTE7XG5cbiAgICAvLyB3aW5kb3cuYXVkaW9TYW1wbGVzID8gd2luZG93LmF1ZGlvU2FtcGxlcy5wdXNoKGlucHV0U2FtcGxlcy5tYXAocyA9PiBzLnB0cykpIDogKHdpbmRvdy5hdWRpb1NhbXBsZXMgPSBbaW5wdXRTYW1wbGVzLm1hcChzID0+IHMucHRzKV0pO1xuXG4gICAgLy8gZm9yIGF1ZGlvIHNhbXBsZXMsIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAvLyBmb3Igc2FrZSBvZiBjbGFyaXR5OlxuICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxuICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IChpZiBhY2N1cmF0ZSkgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgLy8gIC0gbGVzcyB0aGFuIDIwIGF1ZGlvIGZyYW1lcyBkaXN0YW5jZVxuICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXG4gICAgLy8gdGhpcyBoZWxwcyBlbnN1cmluZyBhdWRpbyBjb250aW51aXR5XG4gICAgLy8gYW5kIHRoaXMgYWxzbyBhdm9pZHMgYXVkaW8gZ2xpdGNoZXMvY3V0IHdoZW4gc3dpdGNoaW5nIHF1YWxpdHksIG9yIHJlcG9ydGluZyB3cm9uZyBkdXJhdGlvbiBvbiBmaXJzdCBhdWRpbyBmcmFtZVxuICAgIGNvbnN0IHRpbWVPZmZzZXRNcGVnVFMgPSB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgaW5pdFRpbWUgPSAoaW5pdFBUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlKSAvIGluaXRQVFMudGltZXNjYWxlO1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSBjb250aWd1b3VzID1cbiAgICAgIGNvbnRpZ3VvdXMgfHxcbiAgICAgICgoaW5wdXRTYW1wbGVzLmxlbmd0aCAmJlxuICAgICAgICBuZXh0QXVkaW9QdHMgPiAwICYmXG4gICAgICAgICgoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmXG4gICAgICAgICAgTWF0aC5hYnModGltZU9mZnNldE1wZWdUUyAtIG5leHRBdWRpb1B0cykgPCA5MDAwKSB8fFxuICAgICAgICAgIE1hdGguYWJzKFxuICAgICAgICAgICAgbm9ybWFsaXplUHRzKGlucHV0U2FtcGxlc1swXS5wdHMgLSBpbml0VGltZSwgdGltZU9mZnNldE1wZWdUUykgLVxuICAgICAgICAgICAgICBuZXh0QXVkaW9QdHNcbiAgICAgICAgICApIDxcbiAgICAgICAgICAgIDIwICogaW5wdXRTYW1wbGVEdXJhdGlvbikpIGFzIGJvb2xlYW4pO1xuXG4gICAgLy8gY29tcHV0ZSBub3JtYWxpemVkIFBUU1xuICAgIGlucHV0U2FtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRUaW1lLCB0aW1lT2Zmc2V0TXBlZ1RTKTtcbiAgICB9KTtcblxuICAgIGlmICghY29udGlndW91cyB8fCBuZXh0QXVkaW9QdHMgPCAwKSB7XG4gICAgICAvLyBmaWx0ZXIgb3V0IHNhbXBsZSB3aXRoIG5lZ2F0aXZlIFBUUyB0aGF0IGFyZSBub3QgcGxheWFibGUgYW55d2F5XG4gICAgICAvLyBpZiB3ZSBkb24ndCByZW1vdmUgdGhlc2UgbmVnYXRpdmUgc2FtcGxlcywgdGhleSB3aWxsIHNoaWZ0IGFsbCBhdWRpbyBzYW1wbGVzIGZvcndhcmQuXG4gICAgICAvLyBsZWFkaW5nIHRvIGF1ZGlvIG92ZXJsYXAgYmV0d2VlbiBjdXJyZW50IC8gbmV4dCBmcmFnbWVudFxuICAgICAgaW5wdXRTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmZpbHRlcigoc2FtcGxlKSA9PiBzYW1wbGUucHRzID49IDApO1xuXG4gICAgICAvLyBpbiBjYXNlIGFsbCBzYW1wbGVzIGhhdmUgbmVnYXRpdmUgUFRTLCBhbmQgaGF2ZSBiZWVuIGZpbHRlcmVkIG91dCwgcmV0dXJuIG5vd1xuICAgICAgaWYgKCFpbnB1dFNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHZpZGVvVGltZU9mZnNldCA9PT0gMCkge1xuICAgICAgICAvLyBTZXQgdGhlIHN0YXJ0IHRvIDAgdG8gbWF0Y2ggdmlkZW8gc28gdGhhdCBzdGFydCBnYXBzIGxhcmdlciB0aGFuIGlucHV0U2FtcGxlRHVyYXRpb24gYXJlIGZpbGxlZCB3aXRoIHNpbGVuY2VcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmICFhbGlnbmVkV2l0aFZpZGVvKSB7XG4gICAgICAgIC8vIFdoZW4gbm90IHNlZWtpbmcsIG5vdCBsaXZlLCBhbmQgTGV2ZWxEZXRhaWxzLlBUU0tub3duLCB1c2UgZnJhZ21lbnQgc3RhcnQgYXMgcHJlZGljdGVkIG5leHQgYXVkaW8gUFRTXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IE1hdGgubWF4KDAsIHRpbWVPZmZzZXRNcGVnVFMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgZnJhZ3MgYXJlIG5vdCBjb250aWd1b3VzIGFuZCBpZiB3ZSBjYW50IHRydXN0IHRpbWUgb2Zmc2V0LCBsZXQncyB1c2UgZmlyc3Qgc2FtcGxlIFBUUyBhcyBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICBuZXh0QXVkaW9QdHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBhdWRpbyB0cmFjayBpcyBtaXNzaW5nIHNhbXBsZXMsIHRoZSBmcmFtZXMgc2VlbSB0byBnZXQgXCJsZWZ0LXNoaWZ0ZWRcIiB3aXRoaW4gdGhlXG4gICAgLy8gcmVzdWx0aW5nIG1wNCBzZWdtZW50LCBjYXVzaW5nIHN5bmMgaXNzdWVzIGFuZCBsZWF2aW5nIGdhcHMgYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gc2VnbWVudC5cbiAgICAvLyBJbiBhbiBlZmZvcnQgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nLCB3ZSBpbmplY3QgZnJhbWVzIGhlcmUgd2hlcmUgdGhlcmUgYXJlIGdhcHMuXG4gICAgLy8gV2hlbiBwb3NzaWJsZSwgd2UgaW5qZWN0IGEgc2lsZW50IGZyYW1lOyB3aGVuIHRoYXQncyBub3QgcG9zc2libGUsIHdlIGR1cGxpY2F0ZSB0aGUgbGFzdFxuICAgIC8vIGZyYW1lLlxuXG4gICAgaWYgKHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ2FhYycpIHtcbiAgICAgIGNvbnN0IG1heEF1ZGlvRnJhbWVzRHJpZnQgPSB0aGlzLmNvbmZpZy5tYXhBdWRpb0ZyYW1lc0RyaWZ0O1xuICAgICAgZm9yIChsZXQgaSA9IDAsIG5leHRQdHMgPSBuZXh0QXVkaW9QdHM7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmlyc3QsIGxldCdzIHNlZSBob3cgZmFyIG9mZiB0aGlzIGZyYW1lIGlzIGZyb20gd2hlcmUgd2UgZXhwZWN0IGl0IHRvIGJlXG4gICAgICAgIGNvbnN0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgICAgY29uc3QgcHRzID0gc2FtcGxlLnB0cztcbiAgICAgICAgY29uc3QgZGVsdGEgPSBwdHMgLSBuZXh0UHRzO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IE1hdGguYWJzKCgxMDAwICogZGVsdGEpIC8gaW5wdXRUaW1lU2NhbGUpO1xuXG4gICAgICAgIC8vIFdoZW4gcmVtdXhpbmcgd2l0aCB2aWRlbywgaWYgd2UncmUgb3ZlcmxhcHBpbmcgYnkgbW9yZSB0aGFuIGEgZHVyYXRpb24sIGRyb3AgdGhpcyBzYW1wbGUgdG8gc3RheSBpbiBzeW5jXG4gICAgICAgIGlmIChcbiAgICAgICAgICBkZWx0YSA8PSAtbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiZcbiAgICAgICAgICBhbGlnbmVkV2l0aFZpZGVvXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgYEF1ZGlvIGZyYW1lIEAgJHsocHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoXG4gICAgICAgICAgICAgICAgM1xuICAgICAgICAgICAgICApfXMgb3ZlcmxhcHMgbmV4dEF1ZGlvUHRzIGJ5ICR7TWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICAoMTAwMCAqIGRlbHRhKSAvIGlucHV0VGltZVNjYWxlXG4gICAgICAgICAgICAgICl9IG1zLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IG5leHRQdHMgPSBwdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcblxuICAgICAgICAvLyBJbnNlcnQgbWlzc2luZyBmcmFtZXMgaWY6XG4gICAgICAgIC8vIDE6IFdlJ3JlIG1vcmUgdGhhbiBtYXhBdWRpb0ZyYW1lc0RyaWZ0IGZyYW1lIGF3YXlcbiAgICAgICAgLy8gMjogTm90IG1vcmUgdGhhbiBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OIGF3YXlcbiAgICAgICAgLy8gMzogY3VycmVudFRpbWUgKGFrYSBuZXh0UHRzTm9ybSkgaXMgbm90IDBcbiAgICAgICAgLy8gNDogcmVtdXhpbmcgd2l0aCB2aWRlbyAodmlkZW9UaW1lT2Zmc2V0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIGRlbHRhID49IG1heEF1ZGlvRnJhbWVzRHJpZnQgKiBpbnB1dFNhbXBsZUR1cmF0aW9uICYmXG4gICAgICAgICAgZHVyYXRpb24gPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OICYmXG4gICAgICAgICAgYWxpZ25lZFdpdGhWaWRlb1xuICAgICAgICApIHtcbiAgICAgICAgICBsZXQgbWlzc2luZyA9IE1hdGgucm91bmQoZGVsdGEgLyBpbnB1dFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgICAvLyBBZGp1c3QgbmV4dFB0cyBzbyB0aGF0IHNpbGVudCBzYW1wbGVzIGFyZSBhbGlnbmVkIHdpdGggbWVkaWEgcHRzLiBUaGlzIHdpbGwgcHJldmVudCBtZWRpYSBzYW1wbGVzIGZyb21cbiAgICAgICAgICAvLyBsYXRlciBiZWluZyBzaGlmdGVkIGlmIG5leHRQdHMgaXMgYmFzZWQgb24gdGltZU9mZnNldCBhbmQgZGVsdGEgaXMgbm90IGEgbXVsdGlwbGUgb2YgaW5wdXRTYW1wbGVEdXJhdGlvbi5cbiAgICAgICAgICBuZXh0UHRzID0gcHRzIC0gbWlzc2luZyAqIGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgaWYgKG5leHRQdHMgPCAwKSB7XG4gICAgICAgICAgICBtaXNzaW5nLS07XG4gICAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IG5leHRQdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYFttcDQtcmVtdXhlcl06IEluamVjdGluZyAke21pc3Npbmd9IGF1ZGlvIGZyYW1lIEAgJHsoXG4gICAgICAgICAgICAgIG5leHRQdHMgLyBpbnB1dFRpbWVTY2FsZVxuICAgICAgICAgICAgKS50b0ZpeGVkKDMpfXMgZHVlIHRvICR7TWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgKDEwMDAgKiBkZWx0YSkgLyBpbnB1dFRpbWVTY2FsZVxuICAgICAgICAgICAgKX0gbXMgZ2FwLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWlzc2luZzsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGFtcCA9IE1hdGgubWF4KG5leHRQdHMgYXMgbnVtYmVyLCAwKTtcbiAgICAgICAgICAgIGxldCBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUoXG4gICAgICAgICAgICAgIHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsXG4gICAgICAgICAgICAgIHRyYWNrLmNoYW5uZWxDb3VudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICAgICAgICAgJ1ttcDQtcmVtdXhlcl06IFVuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgbGFzdCBmcmFtZSBpbnN0ZWFkLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZmlsbEZyYW1lID0gc2FtcGxlLnVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMCwge1xuICAgICAgICAgICAgICB1bml0OiBmaWxsRnJhbWUsXG4gICAgICAgICAgICAgIHB0czogbmV3U3RhbXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2FtcGxlLnB0cyA9IG5leHRQdHM7XG4gICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZpcnN0UFRTOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgbGFzdFBUUzogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IG1kYXQ6IGFueTtcbiAgICBsZXQgbWRhdFNpemU6IG51bWJlciA9IDA7XG4gICAgbGV0IHNhbXBsZUxlbmd0aDogbnVtYmVyID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoc2FtcGxlTGVuZ3RoLS0pIHtcbiAgICAgIG1kYXRTaXplICs9IGlucHV0U2FtcGxlc1tzYW1wbGVMZW5ndGhdLnVuaXQuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDAsIG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7IGogPCBuYlNhbXBsZXM7IGorKykge1xuICAgICAgY29uc3QgYXVkaW9TYW1wbGUgPSBpbnB1dFNhbXBsZXNbal07XG4gICAgICBjb25zdCB1bml0ID0gYXVkaW9TYW1wbGUudW5pdDtcbiAgICAgIGxldCBwdHMgPSBhdWRpb1NhbXBsZS5wdHM7XG4gICAgICBpZiAobGFzdFBUUyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCBzZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBzYW1wbGUgdG8gdGhlIFwicmVhbFwiIGR1cmF0aW9uOyB0aGUgUFRTIGRpZmYgd2l0aFxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgc2FtcGxlXG4gICAgICAgIGNvbnN0IHByZXZTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW2ogLSAxXTtcbiAgICAgICAgcHJldlNhbXBsZS5kdXJhdGlvbiA9IE1hdGgucm91bmQoKHB0cyAtIGxhc3RQVFMpIC8gc2NhbGVGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgdHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgICAgIC8vIHNldCBQVFMvRFRTIHRvIGV4cGVjdGVkIFBUUy9EVFNcbiAgICAgICAgICBwdHMgPSBuZXh0QXVkaW9QdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIG91ciBhdWRpb1NhbXBsZXNcbiAgICAgICAgZmlyc3RQVFMgPSBwdHM7XG4gICAgICAgIGlmIChtZGF0U2l6ZSA+IDApIHtcbiAgICAgICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgYXVkaW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1kYXQgdHlwZSkgKi9cbiAgICAgICAgICBtZGF0U2l6ZSArPSBvZmZzZXQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NVVhfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICBieXRlczogbWRhdFNpemUsXG4gICAgICAgICAgICAgIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyBhdWRpbyBtZGF0ICR7bWRhdFNpemV9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJhd01QRUcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgICAgICAgICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBhdWRpbyBzYW1wbGVzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZGF0LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgY29uc3QgdW5pdExlbiA9IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgIG9mZnNldCArPSB1bml0TGVuO1xuICAgICAgLy8gRGVmYXVsdCB0aGUgc2FtcGxlJ3MgZHVyYXRpb24gdG8gdGhlIGNvbXB1dGVkIG1wNFNhbXBsZUR1cmF0aW9uLCB3aGljaCB3aWxsIGVpdGhlciBiZSAxMDI0IGZvciBBQUMgb3IgMTE1MiBmb3IgTVBFR1xuICAgICAgLy8gSW4gdGhlIGNhc2UgdGhhdCB3ZSBoYXZlIDEgc2FtcGxlLCB0aGlzIHdpbGwgYmUgdGhlIGR1cmF0aW9uLiBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCB0aGUgZHVyYXRpb25cbiAgICAgIC8vIGJlY29tZXMgdGhlIFBUUyBkaWZmIHdpdGggdGhlIHByZXZpb3VzIHNhbXBsZVxuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG5ldyBNcDRTYW1wbGUodHJ1ZSwgbXA0U2FtcGxlRHVyYXRpb24sIHVuaXRMZW4sIDApKTtcbiAgICAgIGxhc3RQVFMgPSBwdHM7XG4gICAgfVxuXG4gICAgLy8gV2UgY291bGQgZW5kIHVwIHdpdGggbm8gYXVkaW8gc2FtcGxlcyBpZiBhbGwgaW5wdXQgc2FtcGxlcyB3ZXJlIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByZXZpb3VzbHkgcmVtdXhlZCBvbmVzXG4gICAgY29uc3QgbmJTYW1wbGVzID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgaWYgKCFuYlNhbXBsZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgbmV4dCBhdWRpbyBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBkdXJhdGlvblxuICAgIGNvbnN0IGxhc3RTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW291dHB1dFNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBuZXh0QXVkaW9QdHMgPVxuICAgICAgbGFzdFBUUyEgKyBzY2FsZUZhY3RvciAqIGxhc3RTYW1wbGUuZHVyYXRpb247XG5cbiAgICAvLyBTZXQgdGhlIHRyYWNrIHNhbXBsZXMgZnJvbSBpbnB1dFNhbXBsZXMgdG8gb3V0cHV0U2FtcGxlcyBiZWZvcmUgcmVtdXhpbmdcbiAgICBjb25zdCBtb29mID0gcmF3TVBFR1xuICAgICAgPyBuZXcgVWludDhBcnJheSgwKVxuICAgICAgOiBNUDQubW9vZihcbiAgICAgICAgICB0cmFjay5zZXF1ZW5jZU51bWJlcisrLFxuICAgICAgICAgIGZpcnN0UFRTISAvIHNjYWxlRmFjdG9yLFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRyYWNrLCB7IHNhbXBsZXM6IG91dHB1dFNhbXBsZXMgfSlcbiAgICAgICAgKTtcblxuICAgIC8vIENsZWFyIHRoZSB0cmFjayBzYW1wbGVzLiBUaGlzIGFsc28gY2xlYXJzIHRoZSBzYW1wbGVzIGFycmF5IGluIHRoZSBkZW11eGVyLCBzaW5jZSB0aGUgcmVmZXJlbmNlIGlzIHNoYXJlZFxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IGZpcnN0UFRTISAvIGlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGVuZCA9IG5leHRBdWRpb1B0cyAvIGlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUgPSAnYXVkaW8nO1xuICAgIGNvbnN0IGF1ZGlvRGF0YSA9IHtcbiAgICAgIGRhdGExOiBtb29mLFxuICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICBzdGFydFBUUzogc3RhcnQsXG4gICAgICBlbmRQVFM6IGVuZCxcbiAgICAgIHN0YXJ0RFRTOiBzdGFydCxcbiAgICAgIGVuZERUUzogZW5kLFxuICAgICAgdHlwZSxcbiAgICAgIGhhc0F1ZGlvOiB0cnVlLFxuICAgICAgaGFzVmlkZW86IGZhbHNlLFxuICAgICAgbmI6IG5iU2FtcGxlcyxcbiAgICB9O1xuXG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IHRydWU7XG4gICAgcmV0dXJuIGF1ZGlvRGF0YTtcbiAgfVxuXG4gIHJlbXV4RW1wdHlBdWRpbyhcbiAgICB0cmFjazogRGVtdXhlZEF1ZGlvVHJhY2ssXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGNvbnRpZ3VvdXM6IGJvb2xlYW4sXG4gICAgdmlkZW9EYXRhOiBGcmFnbWVudFxuICApOiBSZW11eGVkVHJhY2sgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGlucHV0VGltZVNjYWxlOiBudW1iZXIgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBtcDR0aW1lU2NhbGU6IG51bWJlciA9IHRyYWNrLnNhbXBsZXJhdGVcbiAgICAgID8gdHJhY2suc2FtcGxlcmF0ZVxuICAgICAgOiBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBzY2FsZUZhY3RvcjogbnVtYmVyID0gaW5wdXRUaW1lU2NhbGUgLyBtcDR0aW1lU2NhbGU7XG4gICAgY29uc3QgbmV4dEF1ZGlvUHRzOiBudW1iZXIgfCBudWxsID0gdGhpcy5uZXh0QXVkaW9QdHM7XG4gICAgLy8gc3luYyB3aXRoIHZpZGVvJ3MgdGltZXN0YW1wXG4gICAgY29uc3QgaW5pdERUUyA9IHRoaXMuX2luaXREVFMgYXMgUmF0aW9uYWxUaW1lc3RhbXA7XG4gICAgY29uc3QgaW5pdDkwa0h6ID0gKGluaXREVFMuYmFzZVRpbWUgKiA5MDAwMCkgLyBpbml0RFRTLnRpbWVzY2FsZTtcbiAgICBjb25zdCBzdGFydERUUzogbnVtYmVyID1cbiAgICAgIChuZXh0QXVkaW9QdHMgIT09IG51bGxcbiAgICAgICAgPyBuZXh0QXVkaW9QdHNcbiAgICAgICAgOiB2aWRlb0RhdGEuc3RhcnREVFMgKiBpbnB1dFRpbWVTY2FsZSkgKyBpbml0OTBrSHo7XG4gICAgY29uc3QgZW5kRFRTOiBudW1iZXIgPSB2aWRlb0RhdGEuZW5kRFRTICogaW5wdXRUaW1lU2NhbGUgKyBpbml0OTBrSHo7XG4gICAgLy8gb25lIHNhbXBsZSdzIGR1cmF0aW9uIHZhbHVlXG4gICAgY29uc3QgZnJhbWVEdXJhdGlvbjogbnVtYmVyID0gc2NhbGVGYWN0b3IgKiBBQUNfU0FNUExFU19QRVJfRlJBTUU7XG4gICAgLy8gc2FtcGxlcyBjb3VudCBvZiB0aGlzIHNlZ21lbnQncyBkdXJhdGlvblxuICAgIGNvbnN0IG5iU2FtcGxlczogbnVtYmVyID0gTWF0aC5jZWlsKChlbmREVFMgLSBzdGFydERUUykgLyBmcmFtZUR1cmF0aW9uKTtcbiAgICAvLyBzaWxlbnQgZnJhbWVcbiAgICBjb25zdCBzaWxlbnRGcmFtZTogVWludDhBcnJheSB8IHVuZGVmaW5lZCA9IEFBQy5nZXRTaWxlbnRGcmFtZShcbiAgICAgIHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsXG4gICAgICB0cmFjay5jaGFubmVsQ291bnRcbiAgICApO1xuXG4gICAgbG9nZ2VyLndhcm4oJ1ttcDQtcmVtdXhlcl06IHJlbXV4IGVtcHR5IEF1ZGlvJyk7XG4gICAgLy8gQ2FuJ3QgcmVtdXggaWYgd2UgY2FuJ3QgZ2VuZXJhdGUgYSBzaWxlbnQgZnJhbWUuLi5cbiAgICBpZiAoIXNpbGVudEZyYW1lKSB7XG4gICAgICBsb2dnZXIudHJhY2UoXG4gICAgICAgICdbbXA0LXJlbXV4ZXJdOiBVbmFibGUgdG8gcmVtdXhFbXB0eUF1ZGlvIHNpbmNlIHdlIHdlcmUgdW5hYmxlIHRvIGdldCBhIHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWMnXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNhbXBsZXM6IEFycmF5PGFueT4gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFtcCA9IHN0YXJ0RFRTICsgaSAqIGZyYW1lRHVyYXRpb247XG4gICAgICBzYW1wbGVzLnB1c2goeyB1bml0OiBzaWxlbnRGcmFtZSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcCB9KTtcbiAgICB9XG4gICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XG5cbiAgICByZXR1cm4gdGhpcy5yZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBmYWxzZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVB0cyh2YWx1ZTogbnVtYmVyLCByZWZlcmVuY2U6IG51bWJlciB8IG51bGwpOiBudW1iZXIge1xuICBsZXQgb2Zmc2V0O1xuICBpZiAocmVmZXJlbmNlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHJlZmVyZW5jZSA8IHZhbHVlKSB7XG4gICAgLy8gLSAyXjMzXG4gICAgb2Zmc2V0ID0gLTg1ODk5MzQ1OTI7XG4gIH0gZWxzZSB7XG4gICAgLy8gKyAyXjMzXG4gICAgb2Zmc2V0ID0gODU4OTkzNDU5MjtcbiAgfVxuICAvKiBQVFMgaXMgMzNiaXQgKGZyb20gMCB0byAyXjMzIC0xKVxuICAgIGlmIGRpZmYgYmV0d2VlbiB2YWx1ZSBhbmQgcmVmZXJlbmNlIGlzIGJpZ2dlciB0aGFuIGhhbGYgb2YgdGhlIGFtcGxpdHVkZSAoMl4zMikgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgUFRTIGxvb3Bpbmcgb2NjdXJlZC4gZmlsbCB0aGUgZ2FwICovXG4gIHdoaWxlIChNYXRoLmFicyh2YWx1ZSAtIHJlZmVyZW5jZSkgPiA0Mjk0OTY3Mjk2KSB7XG4gICAgdmFsdWUgKz0gb2Zmc2V0O1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBmaW5kS2V5ZnJhbWVJbmRleChzYW1wbGVzOiBBcnJheTxBdmNTYW1wbGU+KTogbnVtYmVyIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNhbXBsZXNbaV0ua2V5KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hUZXh0VHJhY2tNZXRhZGF0YUN1ZVNhbXBsZXMoXG4gIHRyYWNrOiBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgdGltZU9mZnNldDogbnVtYmVyLFxuICBpbml0UFRTOiBSYXRpb25hbFRpbWVzdGFtcCxcbiAgaW5pdERUUzogUmF0aW9uYWxUaW1lc3RhbXBcbik6IFJlbXV4ZWRNZXRhZGF0YSB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3Qgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgLy8gc2V0dGluZyBpZDMgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICBzYW1wbGUucHRzID1cbiAgICAgIG5vcm1hbGl6ZVB0cyhcbiAgICAgICAgc2FtcGxlLnB0cyAtIChpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUpIC8gaW5pdFBUUy50aW1lc2NhbGUsXG4gICAgICAgIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZVxuICAgICAgKSAvIGlucHV0VGltZVNjYWxlO1xuICAgIHNhbXBsZS5kdHMgPVxuICAgICAgbm9ybWFsaXplUHRzKFxuICAgICAgICBzYW1wbGUuZHRzIC0gKGluaXREVFMuYmFzZVRpbWUgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbml0RFRTLnRpbWVzY2FsZSxcbiAgICAgICAgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlXG4gICAgICApIC8gaW5wdXRUaW1lU2NhbGU7XG4gIH1cbiAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBzYW1wbGVzLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXMoXG4gIHRyYWNrOiBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgdGltZU9mZnNldDogbnVtYmVyLFxuICBpbml0UFRTOiBSYXRpb25hbFRpbWVzdGFtcFxuKTogUmVtdXhlZFVzZXJkYXRhIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgIC8vIHNldHRpbmcgdGV4dCBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgIHNhbXBsZS5wdHMgPVxuICAgICAgbm9ybWFsaXplUHRzKFxuICAgICAgICBzYW1wbGUucHRzIC0gKGluaXRQVFMuYmFzZVRpbWUgKiA5MDAwMCkgLyBpbml0UFRTLnRpbWVzY2FsZSxcbiAgICAgICAgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlXG4gICAgICApIC8gaW5wdXRUaW1lU2NhbGU7XG4gIH1cbiAgdHJhY2suc2FtcGxlcy5zb3J0KChhLCBiKSA9PiBhLnB0cyAtIGIucHRzKTtcbiAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBzYW1wbGVzLFxuICB9O1xufVxuXG5jbGFzcyBNcDRTYW1wbGUge1xuICBwdWJsaWMgc2l6ZTogbnVtYmVyO1xuICBwdWJsaWMgZHVyYXRpb246IG51bWJlcjtcbiAgcHVibGljIGN0czogbnVtYmVyO1xuICBwdWJsaWMgZmxhZ3M6IE1wNFNhbXBsZUZsYWdzO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGlzS2V5ZnJhbWU6IGJvb2xlYW4sXG4gICAgZHVyYXRpb246IG51bWJlcixcbiAgICBzaXplOiBudW1iZXIsXG4gICAgY3RzOiBudW1iZXJcbiAgKSB7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5jdHMgPSBjdHM7XG4gICAgdGhpcy5mbGFncyA9IG5ldyBNcDRTYW1wbGVGbGFncyhpc0tleWZyYW1lKTtcbiAgfVxufVxuXG5jbGFzcyBNcDRTYW1wbGVGbGFncyB7XG4gIHB1YmxpYyBpc0xlYWRpbmc6IDAgPSAwO1xuICBwdWJsaWMgaXNEZXBlbmRlZE9uOiAwID0gMDtcbiAgcHVibGljIGhhc1JlZHVuZGFuY3k6IDAgPSAwO1xuICBwdWJsaWMgZGVncmFkUHJpbzogMCA9IDA7XG4gIHB1YmxpYyBkZXBlbmRzT246IDEgfCAyID0gMTtcbiAgcHVibGljIGlzTm9uU3luYzogMCB8IDEgPSAxO1xuXG4gIGNvbnN0cnVjdG9yKGlzS2V5ZnJhbWUpIHtcbiAgICB0aGlzLmRlcGVuZHNPbiA9IGlzS2V5ZnJhbWUgPyAyIDogMTtcbiAgICB0aGlzLmlzTm9uU3luYyA9IGlzS2V5ZnJhbWUgPyAwIDogMTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgZmx1c2hUZXh0VHJhY2tNZXRhZGF0YUN1ZVNhbXBsZXMsXG4gIGZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzLFxufSBmcm9tICcuL21wNC1yZW11eGVyJztcbmltcG9ydCB7XG4gIEluaXREYXRhLFxuICBJbml0RGF0YVRyYWNrLFxuICBwYXRjaEVuY3lwdGlvbkRhdGEsXG59IGZyb20gJy4uL3V0aWxzL21wNC10b29scyc7XG5pbXBvcnQge1xuICBnZXREdXJhdGlvbixcbiAgZ2V0U3RhcnREVFMsXG4gIG9mZnNldFN0YXJ0RFRTLFxuICBwYXJzZUluaXRTZWdtZW50LFxufSBmcm9tICcuLi91dGlscy9tcDQtdG9vbHMnO1xuaW1wb3J0IHsgRWxlbWVudGFyeVN0cmVhbVR5cGVzIH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSB7IFRyYWNrU2V0IH0gZnJvbSAnLi4vdHlwZXMvdHJhY2snO1xuaW1wb3J0IHR5cGUge1xuICBJbml0U2VnbWVudERhdGEsXG4gIFJlbXV4ZWRUcmFjayxcbiAgUmVtdXhlcixcbiAgUmVtdXhlclJlc3VsdCxcbn0gZnJvbSAnLi4vdHlwZXMvcmVtdXhlcic7XG5pbXBvcnQgdHlwZSB7XG4gIERlbXV4ZWRBdWRpb1RyYWNrLFxuICBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gIFBhc3N0aHJvdWdoVHJhY2ssXG59IGZyb20gJy4uL3R5cGVzL2RlbXV4ZXInO1xuaW1wb3J0IHR5cGUgeyBEZWNyeXB0RGF0YSB9IGZyb20gJy4uL2xvYWRlci9sZXZlbC1rZXknO1xuaW1wb3J0IHR5cGUgeyBSYXRpb25hbFRpbWVzdGFtcCB9IGZyb20gJy4uL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uJztcblxuY2xhc3MgUGFzc1Rocm91Z2hSZW11eGVyIGltcGxlbWVudHMgUmVtdXhlciB7XG4gIHByaXZhdGUgZW1pdEluaXRTZWdtZW50OiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgYXVkaW9Db2RlYz86IHN0cmluZztcbiAgcHJpdmF0ZSB2aWRlb0NvZGVjPzogc3RyaW5nO1xuICBwcml2YXRlIGluaXREYXRhPzogSW5pdERhdGE7XG4gIHByaXZhdGUgaW5pdFBUUzogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpbml0VHJhY2tzPzogVHJhY2tTZXQ7XG4gIHByaXZhdGUgbGFzdEVuZFRpbWU6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIHB1YmxpYyBkZXN0cm95KCkge31cblxuICBwdWJsaWMgcmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFM6IFJhdGlvbmFsVGltZXN0YW1wIHwgbnVsbCkge1xuICAgIHRoaXMuaW5pdFBUUyA9IGRlZmF1bHRJbml0UFRTO1xuICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICB9XG5cbiAgcHVibGljIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICB0aGlzLmxhc3RFbmRUaW1lID0gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyByZXNldEluaXRTZWdtZW50KFxuICAgIGluaXRTZWdtZW50OiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICAgIGF1ZGlvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2aWRlb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgZGVjcnlwdGRhdGE6IERlY3J5cHREYXRhIHwgbnVsbFxuICApIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5nZW5lcmF0ZUluaXRTZWdtZW50KHBhdGNoRW5jeXB0aW9uRGF0YShpbml0U2VnbWVudCwgZGVjcnlwdGRhdGEpKTtcbiAgICB0aGlzLmVtaXRJbml0U2VnbWVudCA9IHRydWU7XG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQ6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBsZXQgeyBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjIH0gPSB0aGlzO1xuICAgIGlmICghaW5pdFNlZ21lbnQ/LmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRoaXMuaW5pdFRyYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuaW5pdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluaXREYXRhID0gKHRoaXMuaW5pdERhdGEgPSBwYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KSk7XG5cbiAgICAvLyBHZXQgY29kZWMgZnJvbSBpbml0U2VnbWVudCBvciBmYWxsYmFjayB0byBkZWZhdWx0XG4gICAgaWYgKCFhdWRpb0NvZGVjKSB7XG4gICAgICBhdWRpb0NvZGVjID0gZ2V0UGFyc2VkVHJhY2tDb2RlYyhcbiAgICAgICAgaW5pdERhdGEuYXVkaW8sXG4gICAgICAgIEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXZpZGVvQ29kZWMpIHtcbiAgICAgIHZpZGVvQ29kZWMgPSBnZXRQYXJzZWRUcmFja0NvZGVjKFxuICAgICAgICBpbml0RGF0YS52aWRlbyxcbiAgICAgICAgRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYWNrczogVHJhY2tTZXQgPSB7fTtcbiAgICBpZiAoaW5pdERhdGEuYXVkaW8gJiYgaW5pdERhdGEudmlkZW8pIHtcbiAgICAgIHRyYWNrcy5hdWRpb3ZpZGVvID0ge1xuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogYXVkaW9Db2RlYyArICcsJyArIHZpZGVvQ29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ21haW4nLFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGluaXREYXRhLmF1ZGlvKSB7XG4gICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL21wNCcsXG4gICAgICAgIGNvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgICBpbml0U2VnbWVudCxcbiAgICAgICAgaWQ6ICdhdWRpbycsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IHZpZGVvQ29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ21haW4nLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICdbcGFzc3Rocm91Z2gtcmVtdXhlci50c106IGluaXRTZWdtZW50IGRvZXMgbm90IGNvbnRhaW4gbW9vdiBvciB0cmFrIGJveGVzLidcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuaW5pdFRyYWNrcyA9IHRyYWNrcztcbiAgfVxuXG4gIHB1YmxpYyByZW11eChcbiAgICBhdWRpb1RyYWNrOiBEZW11eGVkQXVkaW9UcmFjayxcbiAgICB2aWRlb1RyYWNrOiBQYXNzdGhyb3VnaFRyYWNrLFxuICAgIGlkM1RyYWNrOiBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgICB0ZXh0VHJhY2s6IERlbXV4ZWRVc2VyZGF0YVRyYWNrLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGJvb2xlYW5cbiAgKTogUmVtdXhlclJlc3VsdCB7XG4gICAgbGV0IHsgaW5pdFBUUywgbGFzdEVuZFRpbWUgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVzdWx0OiBSZW11eGVyUmVzdWx0ID0ge1xuICAgICAgYXVkaW86IHVuZGVmaW5lZCxcbiAgICAgIHZpZGVvOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0OiB0ZXh0VHJhY2ssXG4gICAgICBpZDM6IGlkM1RyYWNrLFxuICAgICAgaW5pdFNlZ21lbnQ6IHVuZGVmaW5lZCxcbiAgICB9O1xuXG4gICAgLy8gSWYgd2UgaGF2ZW4ndCB5ZXQgc2V0IGEgbGFzdEVuZERUUywgb3IgaXQgd2FzIHJlc2V0LCBzZXQgaXQgdG8gdGhlIHByb3ZpZGVkIHRpbWVPZmZzZXQuIFdlIHdhbnQgdG8gdXNlIHRoZVxuICAgIC8vIGxhc3RFbmREVFMgb3ZlciB0aW1lT2Zmc2V0IHdoZW5ldmVyIHBvc3NpYmxlOyBkdXJpbmcgcHJvZ3Jlc3NpdmUgcGxheWJhY2ssIHRoZSBtZWRpYSBzb3VyY2Ugd2lsbCBub3QgdXBkYXRlXG4gICAgLy8gdGhlIG1lZGlhIGR1cmF0aW9uICh3aGljaCBpcyB3aGF0IHRpbWVPZmZzZXQgaXMgcHJvdmlkZWQgYXMpIGJlZm9yZSB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIG5leHQgY2h1bmsuXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobGFzdEVuZFRpbWUhKSkge1xuICAgICAgbGFzdEVuZFRpbWUgPSB0aGlzLmxhc3RFbmRUaW1lID0gdGltZU9mZnNldCB8fCAwO1xuICAgIH1cblxuICAgIC8vIFRoZSBiaW5hcnkgc2VnbWVudCBkYXRhIGlzIGFkZGVkIHRvIHRoZSB2aWRlb1RyYWNrIGluIHRoZSBtcDRkZW11eGVyLiBXZSBkb24ndCBjaGVjayB0byBzZWUgaWYgdGhlIGRhdGEgaXMgb25seVxuICAgIC8vIGF1ZGlvIG9yIHZpZGVvIChvciBib3RoKTsgYWRkaW5nIGl0IHRvIHZpZGVvIHdhcyBhbiBhcmJpdHJhcnkgY2hvaWNlLlxuICAgIGNvbnN0IGRhdGEgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgaWYgKCFkYXRhPy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdFNlZ21lbnQ6IEluaXRTZWdtZW50RGF0YSA9IHtcbiAgICAgIGluaXRQVFM6IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVzY2FsZTogMSxcbiAgICB9O1xuICAgIGxldCBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgaWYgKCFpbml0RGF0YT8ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQoZGF0YSk7XG4gICAgICBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgfVxuICAgIGlmICghaW5pdERhdGE/Lmxlbmd0aCkge1xuICAgICAgLy8gV2UgY2FuJ3QgcmVtdXggaWYgdGhlIGluaXRTZWdtZW50IGNvdWxkIG5vdCBiZSBnZW5lcmF0ZWRcbiAgICAgIGxvZ2dlci53YXJuKCdbcGFzc3Rocm91Z2gtcmVtdXhlci50c106IEZhaWxlZCB0byBnZW5lcmF0ZSBpbml0U2VnbWVudC4nKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmVtaXRJbml0U2VnbWVudCkge1xuICAgICAgaW5pdFNlZ21lbnQudHJhY2tzID0gdGhpcy5pbml0VHJhY2tzIGFzIFRyYWNrU2V0O1xuICAgICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBkdXJhdGlvbiA9IGdldER1cmF0aW9uKGRhdGEsIGluaXREYXRhKTtcbiAgICBjb25zdCBzdGFydERUUyA9IGdldFN0YXJ0RFRTKGluaXREYXRhLCBkYXRhKTtcbiAgICBjb25zdCBkZWNvZGVUaW1lID0gc3RhcnREVFMgPT09IG51bGwgPyB0aW1lT2Zmc2V0IDogc3RhcnREVFM7XG4gICAgaWYgKFxuICAgICAgaXNJbnZhbGlkSW5pdFB0cyhpbml0UFRTLCBkZWNvZGVUaW1lLCB0aW1lT2Zmc2V0LCBkdXJhdGlvbikgfHxcbiAgICAgIChpbml0U2VnbWVudC50aW1lc2NhbGUgIT09IGluaXRQVFMudGltZXNjYWxlICYmIGFjY3VyYXRlVGltZU9mZnNldClcbiAgICApIHtcbiAgICAgIGluaXRTZWdtZW50LmluaXRQVFMgPSBkZWNvZGVUaW1lIC0gdGltZU9mZnNldDtcbiAgICAgIGlmIChpbml0UFRTICYmIGluaXRQVFMudGltZXNjYWxlID09PSAxKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgIGBBZGp1c3RpbmcgaW5pdFBUUyBieSAke2luaXRTZWdtZW50LmluaXRQVFMgLSBpbml0UFRTLmJhc2VUaW1lfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFMgPSB7XG4gICAgICAgIGJhc2VUaW1lOiBpbml0U2VnbWVudC5pbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGU6IDEsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGF1ZGlvVHJhY2tcbiAgICAgID8gZGVjb2RlVGltZSAtIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZVxuICAgICAgOiAobGFzdEVuZFRpbWUgYXMgbnVtYmVyKTtcbiAgICBjb25zdCBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgb2Zmc2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEsIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZSk7XG5cbiAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICB0aGlzLmxhc3RFbmRUaW1lID0gZW5kVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oJ0R1cmF0aW9uIHBhcnNlZCBmcm9tIG1wNCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgIHRoaXMucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzQXVkaW8gPSAhIWluaXREYXRhLmF1ZGlvO1xuICAgIGNvbnN0IGhhc1ZpZGVvID0gISFpbml0RGF0YS52aWRlbztcblxuICAgIGxldCB0eXBlOiBhbnkgPSAnJztcbiAgICBpZiAoaGFzQXVkaW8pIHtcbiAgICAgIHR5cGUgKz0gJ2F1ZGlvJztcbiAgICB9XG5cbiAgICBpZiAoaGFzVmlkZW8pIHtcbiAgICAgIHR5cGUgKz0gJ3ZpZGVvJztcbiAgICB9XG5cbiAgICBjb25zdCB0cmFjazogUmVtdXhlZFRyYWNrID0ge1xuICAgICAgZGF0YTE6IGRhdGEsXG4gICAgICBzdGFydFBUUzogc3RhcnRUaW1lLFxuICAgICAgc3RhcnREVFM6IHN0YXJ0VGltZSxcbiAgICAgIGVuZFBUUzogZW5kVGltZSxcbiAgICAgIGVuZERUUzogZW5kVGltZSxcbiAgICAgIHR5cGUsXG4gICAgICBoYXNBdWRpbyxcbiAgICAgIGhhc1ZpZGVvLFxuICAgICAgbmI6IDEsXG4gICAgICBkcm9wcGVkOiAwLFxuICAgIH07XG5cbiAgICByZXN1bHQuYXVkaW8gPSB0cmFjay50eXBlID09PSAnYXVkaW8nID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgcmVzdWx0LnZpZGVvID0gdHJhY2sudHlwZSAhPT0gJ2F1ZGlvJyA/IHRyYWNrIDogdW5kZWZpbmVkO1xuICAgIHJlc3VsdC5pbml0U2VnbWVudCA9IGluaXRTZWdtZW50O1xuICAgIHJlc3VsdC5pZDMgPSBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyhcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGluaXRQVFMsXG4gICAgICBpbml0UFRTXG4gICAgKTtcblxuICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC50ZXh0ID0gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXMoXG4gICAgICAgIHRleHRUcmFjayxcbiAgICAgICAgdGltZU9mZnNldCxcbiAgICAgICAgaW5pdFBUU1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW52YWxpZEluaXRQdHMoXG4gIGluaXRQVFM6IFJhdGlvbmFsVGltZXN0YW1wIHwgbnVsbCxcbiAgc3RhcnREVFM6IG51bWJlcixcbiAgdGltZU9mZnNldDogbnVtYmVyLFxuICBkdXJhdGlvbjogbnVtYmVyXG4pOiBpbml0UFRTIGlzIG51bGwge1xuICBpZiAoaW5pdFBUUyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIEluaXRQVFMgaXMgaW52YWxpZCB3aGVuIGRpc3RhbmNlIGZyb20gcHJvZ3JhbSB3b3VsZCBiZSBtb3JlIHRoYW4gc2VnbWVudCBkdXJhdGlvbiBvciBhIG1pbmltdW0gb2Ygb25lIHNlY29uZFxuICBjb25zdCBtaW5EdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCAxKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gc3RhcnREVFMgLSBpbml0UFRTLmJhc2VUaW1lIC8gaW5pdFBUUy50aW1lc2NhbGU7XG4gIHJldHVybiBNYXRoLmFicyhzdGFydFRpbWUgLSB0aW1lT2Zmc2V0KSA+IG1pbkR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJzZWRUcmFja0NvZGVjKFxuICB0cmFjazogSW5pdERhdGFUcmFjayB8IHVuZGVmaW5lZCxcbiAgdHlwZTogRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPIHwgRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXG4pOiBzdHJpbmcge1xuICBjb25zdCBwYXJzZWRDb2RlYyA9IHRyYWNrPy5jb2RlYztcbiAgaWYgKHBhcnNlZENvZGVjICYmIHBhcnNlZENvZGVjLmxlbmd0aCA+IDQpIHtcbiAgICByZXR1cm4gcGFyc2VkQ29kZWM7XG4gIH1cbiAgLy8gU2luY2UgbXA0LXRvb2xzIGNhbm5vdCBwYXJzZSBmdWxsIGNvZGVjIHN0cmluZyAoc2VlICdUT0RPOiBQYXJzZSBjb2RlYyBkZXRhaWxzJy4uLiBpbiBtcDQtdG9vbHMpXG4gIC8vIFByb3ZpZGUgZGVmYXVsdHMgYmFzZWQgb24gY29kZWMgdHlwZVxuICAvLyBUaGlzIGFsbG93cyBmb3Igc29tZSBwbGF5YmFjayBvZiBzb21lIGZtcDQgcGxheWxpc3RzIHdpdGhvdXQgQ09ERUNTIGRlZmluZWQgaW4gbWFuaWZlc3RcbiAgaWYgKHBhcnNlZENvZGVjID09PSAnaHZjMScgfHwgcGFyc2VkQ29kZWMgPT09ICdoZXYxJykge1xuICAgIHJldHVybiAnaHZjMS4xLjYuTDEyMC45MCc7XG4gIH1cbiAgaWYgKHBhcnNlZENvZGVjID09PSAnYXYwMScpIHtcbiAgICByZXR1cm4gJ2F2MDEuMC4wNE0uMDgnO1xuICB9XG4gIGlmIChwYXJzZWRDb2RlYyA9PT0gJ2F2YzEnIHx8IHR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTykge1xuICAgIHJldHVybiAnYXZjMS40MmUwMWUnO1xuICB9XG4gIHJldHVybiAnbXA0YS40MC41Jztcbn1cbmV4cG9ydCBkZWZhdWx0IFBhc3NUaHJvdWdoUmVtdXhlcjtcbiIsImltcG9ydCB0eXBlIHsgSGxzRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xuaW1wb3J0IEFBQ0RlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvYWFjZGVtdXhlcic7XG5pbXBvcnQgTVA0RGVtdXhlciBmcm9tICcuLi9kZW11eC9tcDRkZW11eGVyJztcbmltcG9ydCBUU0RlbXV4ZXIsIHsgVHlwZVN1cHBvcnRlZCB9IGZyb20gJy4uL2RlbXV4L3RzZGVtdXhlcic7XG5pbXBvcnQgTVAzRGVtdXhlciBmcm9tICcuLi9kZW11eC9tcDNkZW11eGVyJztcbmltcG9ydCBNUDRSZW11eGVyIGZyb20gJy4uL3JlbXV4L21wNC1yZW11eGVyJztcbmltcG9ydCBQYXNzVGhyb3VnaFJlbXV4ZXIgZnJvbSAnLi4vcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHR5cGUgeyBEZW11eGVyLCBEZW11eGVyUmVzdWx0LCBLZXlEYXRhIH0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5pbXBvcnQgdHlwZSB7IFJlbXV4ZXIgfSBmcm9tICcuLi90eXBlcy9yZW11eGVyJztcbmltcG9ydCB0eXBlIHsgVHJhbnNtdXhlclJlc3VsdCwgQ2h1bmtNZXRhZGF0YSB9IGZyb20gJy4uL3R5cGVzL3RyYW5zbXV4ZXInO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBEZWNyeXB0RGF0YSB9IGZyb20gJy4uL2xvYWRlci9sZXZlbC1rZXknO1xuaW1wb3J0IHR5cGUgeyBQbGF5bGlzdExldmVsVHlwZSB9IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgdHlwZSB7IFJhdGlvbmFsVGltZXN0YW1wIH0gZnJvbSAnLi4vdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24nO1xuXG5sZXQgbm93O1xuLy8gcGVyZm9ybWFuY2Uubm93KCkgbm90IGF2YWlsYWJsZSBvbiBXZWJXb3JrZXIsIGF0IGxlYXN0IG9uIFNhZmFyaSBEZXNrdG9wXG50cnkge1xuICBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHNlbGYucGVyZm9ybWFuY2UpO1xufSBjYXRjaCAoZXJyKSB7XG4gIGxvZ2dlci5kZWJ1ZygnVW5hYmxlIHRvIHVzZSBQZXJmb3JtYW5jZSBBUEkgb24gdGhpcyBlbnZpcm9ubWVudCcpO1xuICBub3cgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5EYXRlLm5vdztcbn1cblxudHlwZSBNdXhDb25maWcgPVxuICB8IHsgZGVtdXg6IHR5cGVvZiBNUDREZW11eGVyOyByZW11eDogdHlwZW9mIFBhc3NUaHJvdWdoUmVtdXhlciB9XG4gIHwgeyBkZW11eDogdHlwZW9mIFRTRGVtdXhlcjsgcmVtdXg6IHR5cGVvZiBNUDRSZW11eGVyIH1cbiAgfCB7IGRlbXV4OiB0eXBlb2YgQUFDRGVtdXhlcjsgcmVtdXg6IHR5cGVvZiBNUDRSZW11eGVyIH1cbiAgfCB7IGRlbXV4OiB0eXBlb2YgTVAzRGVtdXhlcjsgcmVtdXg6IHR5cGVvZiBNUDRSZW11eGVyIH07XG5cbmNvbnN0IG11eENvbmZpZzogTXV4Q29uZmlnW10gPSBbXG4gIHsgZGVtdXg6IE1QNERlbXV4ZXIsIHJlbXV4OiBQYXNzVGhyb3VnaFJlbXV4ZXIgfSxcbiAgeyBkZW11eDogVFNEZW11eGVyLCByZW11eDogTVA0UmVtdXhlciB9LFxuICB7IGRlbXV4OiBBQUNEZW11eGVyLCByZW11eDogTVA0UmVtdXhlciB9LFxuICB7IGRlbXV4OiBNUDNEZW11eGVyLCByZW11eDogTVA0UmVtdXhlciB9LFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNtdXhlciB7XG4gIHB1YmxpYyBhc3luYzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXI7XG4gIHByaXZhdGUgdHlwZVN1cHBvcnRlZDogVHlwZVN1cHBvcnRlZDtcbiAgcHJpdmF0ZSBjb25maWc6IEhsc0NvbmZpZztcbiAgcHJpdmF0ZSB2ZW5kb3I6IHN0cmluZztcbiAgcHJpdmF0ZSBpZDogUGxheWxpc3RMZXZlbFR5cGU7XG4gIHByaXZhdGUgZGVtdXhlcj86IERlbXV4ZXI7XG4gIHByaXZhdGUgcmVtdXhlcj86IFJlbXV4ZXI7XG4gIHByaXZhdGUgZGVjcnlwdGVyPzogRGVjcnlwdGVyO1xuICBwcml2YXRlIHByb2JlITogRnVuY3Rpb247XG4gIHByaXZhdGUgZGVjcnlwdGlvblByb21pc2U6IFByb21pc2U8VHJhbnNtdXhlclJlc3VsdD4gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB0cmFuc211eENvbmZpZyE6IFRyYW5zbXV4Q29uZmlnO1xuICBwcml2YXRlIGN1cnJlbnRUcmFuc211eFN0YXRlITogVHJhbnNtdXhTdGF0ZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBvYnNlcnZlcjogSGxzRXZlbnRFbWl0dGVyLFxuICAgIHR5cGVTdXBwb3J0ZWQ6IFR5cGVTdXBwb3J0ZWQsXG4gICAgY29uZmlnOiBIbHNDb25maWcsXG4gICAgdmVuZG9yOiBzdHJpbmcsXG4gICAgaWQ6IFBsYXlsaXN0TGV2ZWxUeXBlXG4gICkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudmVuZG9yID0gdmVuZG9yO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgfVxuXG4gIGNvbmZpZ3VyZSh0cmFuc211eENvbmZpZzogVHJhbnNtdXhDb25maWcpIHtcbiAgICB0aGlzLnRyYW5zbXV4Q29uZmlnID0gdHJhbnNtdXhDb25maWc7XG4gICAgaWYgKHRoaXMuZGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLmRlY3J5cHRlci5yZXNldCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2goXG4gICAgZGF0YTogQXJyYXlCdWZmZXIsXG4gICAgZGVjcnlwdGRhdGE6IERlY3J5cHREYXRhIHwgbnVsbCxcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGEsXG4gICAgc3RhdGU/OiBUcmFuc211eFN0YXRlXG4gICk6IFRyYW5zbXV4ZXJSZXN1bHQgfCBQcm9taXNlPFRyYW5zbXV4ZXJSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGF0cyA9IGNodW5rTWV0YS50cmFuc211eGluZztcbiAgICBzdGF0cy5leGVjdXRlU3RhcnQgPSBub3coKTtcblxuICAgIGxldCB1aW50RGF0YTogVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIGNvbnN0IHsgY3VycmVudFRyYW5zbXV4U3RhdGUsIHRyYW5zbXV4Q29uZmlnIH0gPSB0aGlzO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSA9IHN0YXRlO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRpZ3VvdXMsXG4gICAgICBkaXNjb250aW51aXR5LFxuICAgICAgdHJhY2tTd2l0Y2gsXG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICB0aW1lT2Zmc2V0LFxuICAgICAgaW5pdFNlZ21lbnRDaGFuZ2UsXG4gICAgfSA9IHN0YXRlIHx8IGN1cnJlbnRUcmFuc211eFN0YXRlO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICB2aWRlb0NvZGVjLFxuICAgICAgZGVmYXVsdEluaXRQdHMsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGluaXRTZWdtZW50RGF0YSxcbiAgICB9ID0gdHJhbnNtdXhDb25maWc7XG5cbiAgICBjb25zdCBrZXlEYXRhID0gZ2V0RW5jcnlwdGlvblR5cGUodWludERhdGEsIGRlY3J5cHRkYXRhKTtcbiAgICBpZiAoa2V5RGF0YSAmJiBrZXlEYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICBjb25zdCBkZWNyeXB0ZXIgPSB0aGlzLmdldERlY3J5cHRlcigpO1xuICAgICAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBzeW5jaHJvbm91czsgd2ViQ3J5cHRvIGlzIG5vdFxuICAgICAgaWYgKGRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICAvLyBTb2Z0d2FyZSBkZWNyeXB0aW9uIGlzIHByb2dyZXNzaXZlLiBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIG1heSBub3QgcmV0dXJuIGEgcmVzdWx0IG9uIGVhY2ggY2FsbC4gQW55IGNhY2hlZFxuICAgICAgICAvLyBkYXRhIGlzIGhhbmRsZWQgaW4gdGhlIGZsdXNoKCkgY2FsbFxuICAgICAgICBsZXQgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5zb2Z0d2FyZURlY3J5cHQoXG4gICAgICAgICAgdWludERhdGEsXG4gICAgICAgICAga2V5RGF0YS5rZXkuYnVmZmVyLFxuICAgICAgICAgIGtleURhdGEuaXYuYnVmZmVyXG4gICAgICAgICk7XG4gICAgICAgIC8vIEZvciBMb3ctTGF0ZW5jeSBITFMgUGFydHMsIGRlY3J5cHQgaW4gcGxhY2UsIHNpbmNlIHBhcnQgcGFyc2luZyBpcyBleHBlY3RlZCBvbiBwdXNoIHByb2dyZXNzXG4gICAgICAgIGNvbnN0IGxvYWRpbmdQYXJ0cyA9IGNodW5rTWV0YS5wYXJ0ID4gLTE7XG4gICAgICAgIGlmIChsb2FkaW5nUGFydHMpIHtcbiAgICAgICAgICBkZWNyeXB0ZWREYXRhID0gZGVjcnlwdGVyLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgICAgIHJldHVybiBlbXB0eVJlc3VsdChjaHVua01ldGEpO1xuICAgICAgICB9XG4gICAgICAgIHVpbnREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlY3J5cHRpb25Qcm9taXNlID0gZGVjcnlwdGVyXG4gICAgICAgICAgLndlYkNyeXB0b0RlY3J5cHQodWludERhdGEsIGtleURhdGEua2V5LmJ1ZmZlciwga2V5RGF0YS5pdi5idWZmZXIpXG4gICAgICAgICAgLnRoZW4oKGRlY3J5cHRlZERhdGEpOiBUcmFuc211eGVyUmVzdWx0ID0+IHtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgcHVzaCBoZXJlIGlzIGltcG9ydGFudDsgaWYgZmx1c2goKSBpcyBjYWxsZWQgd2hpbGUgdGhpcyBpcyBzdGlsbCByZXNvbHZpbmcsIHRoaXMgZW5zdXJlcyB0aGF0XG4gICAgICAgICAgICAvLyB0aGUgZGVjcnlwdGVkIGRhdGEgaGFzIGJlZW4gdHJhbnNtdXhlZFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wdXNoKFxuICAgICAgICAgICAgICBkZWNyeXB0ZWREYXRhLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBjaHVua01ldGFcbiAgICAgICAgICAgICkgYXMgVHJhbnNtdXhlclJlc3VsdDtcbiAgICAgICAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGlvblByb21pc2UhO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc2V0TXV4ZXJzID0gdGhpcy5uZWVkc1Byb2JpbmcoZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gpO1xuICAgIGlmIChyZXNldE11eGVycykge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNvbmZpZ3VyZVRyYW5zbXV4ZXIodWludERhdGEpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBbdHJhbnNtdXhlcl0gJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KGNodW5rTWV0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2ggfHwgaW5pdFNlZ21lbnRDaGFuZ2UgfHwgcmVzZXRNdXhlcnMpIHtcbiAgICAgIHRoaXMucmVzZXRJbml0U2VnbWVudChcbiAgICAgICAgaW5pdFNlZ21lbnREYXRhLFxuICAgICAgICBhdWRpb0NvZGVjLFxuICAgICAgICB2aWRlb0NvZGVjLFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZGVjcnlwdGRhdGFcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGRpc2NvbnRpbnVpdHkgfHwgaW5pdFNlZ21lbnRDaGFuZ2UgfHwgcmVzZXRNdXhlcnMpIHtcbiAgICAgIHRoaXMucmVzZXRJbml0aWFsVGltZXN0YW1wKGRlZmF1bHRJbml0UHRzKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbnRpZ3VvdXMpIHtcbiAgICAgIHRoaXMucmVzZXRDb250aWd1aXR5KCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cmFuc211eChcbiAgICAgIHVpbnREYXRhLFxuICAgICAga2V5RGF0YSxcbiAgICAgIHRpbWVPZmZzZXQsXG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICBjaHVua01ldGFcbiAgICApO1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGU7XG5cbiAgICBjdXJyZW50U3RhdGUuY29udGlndW91cyA9IHRydWU7XG4gICAgY3VycmVudFN0YXRlLmRpc2NvbnRpbnVpdHkgPSBmYWxzZTtcbiAgICBjdXJyZW50U3RhdGUudHJhY2tTd2l0Y2ggPSBmYWxzZTtcblxuICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gRHVlIHRvIGRhdGEgY2FjaGluZywgZmx1c2ggY2FsbHMgY2FuIHByb2R1Y2UgbW9yZSB0aGFuIG9uZSBUcmFuc211eGVyUmVzdWx0IChoZW5jZSB0aGUgQXJyYXkgdHlwZSlcbiAgZmx1c2goXG4gICAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhXG4gICk6IFRyYW5zbXV4ZXJSZXN1bHRbXSB8IFByb21pc2U8VHJhbnNtdXhlclJlc3VsdFtdPiB7XG4gICAgY29uc3Qgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG5cbiAgICBjb25zdCB7IGRlY3J5cHRlciwgY3VycmVudFRyYW5zbXV4U3RhdGUsIGRlY3J5cHRpb25Qcm9taXNlIH0gPSB0aGlzO1xuXG4gICAgaWYgKGRlY3J5cHRpb25Qcm9taXNlKSB7XG4gICAgICAvLyBVcG9uIHJlc29sdXRpb24sIHRoZSBkZWNyeXB0aW9uIHByb21pc2UgY2FsbHMgcHVzaCgpIGFuZCByZXR1cm5zIGl0cyBUcmFuc211eGVyUmVzdWx0IHVwIHRoZSBzdGFjay4gVGhlcmVmb3JlXG4gICAgICAvLyBvbmx5IGZsdXNoaW5nIGlzIHJlcXVpcmVkIGZvciBhc3luYyBkZWNyeXB0aW9uXG4gICAgICByZXR1cm4gZGVjcnlwdGlvblByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsdXNoKGNodW5rTWV0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc211eFJlc3VsdHM6IFRyYW5zbXV4ZXJSZXN1bHRbXSA9IFtdO1xuICAgIGNvbnN0IHsgdGltZU9mZnNldCB9ID0gY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgaWYgKGRlY3J5cHRlcikge1xuICAgICAgLy8gVGhlIGRlY3J5cHRlciBtYXkgaGF2ZSBkYXRhIGNhY2hlZCwgd2hpY2ggbmVlZHMgdG8gYmUgZGVtdXhlZC4gSW4gdGhpcyBjYXNlIHdlJ2xsIGhhdmUgdHdvIFRyYW5zbXV4UmVzdWx0c1xuICAgICAgLy8gVGhpcyBoYXBwZW5zIGluIHRoZSBjYXNlIHRoYXQgd2UgcmVjZWl2ZSBvbmx5IDEgcHVzaCBjYWxsIGZvciBhIHNlZ21lbnQgKGVpdGhlciBmb3Igbm9uLXByb2dyZXNzaXZlIGRvd25sb2FkcyxcbiAgICAgIC8vIG9yIGZvciBwcm9ncmVzc2l2ZSBkb3dubG9hZHMgd2l0aCBzbWFsbCBzZWdtZW50cylcbiAgICAgIGNvbnN0IGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcbiAgICAgIGlmIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgIC8vIFB1c2ggYWx3YXlzIHJldHVybnMgYSBUcmFuc211eGVyUmVzdWx0IGlmIGRlY3J5cHRkYXRhIGlzIG51bGxcbiAgICAgICAgdHJhbnNtdXhSZXN1bHRzLnB1c2goXG4gICAgICAgICAgdGhpcy5wdXNoKGRlY3J5cHRlZERhdGEsIG51bGwsIGNodW5rTWV0YSkgYXMgVHJhbnNtdXhlclJlc3VsdFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgZGVtdXhlciwgcmVtdXhlciB9ID0gdGhpcztcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIC8vIElmIHByb2JpbmcgZmFpbGVkLCB0aGVuIEhscy5qcyBoYXMgYmVlbiBnaXZlbiBjb250ZW50IGl0cyBub3QgYWJsZSB0byBoYW5kbGVcbiAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgIHJldHVybiBbZW1wdHlSZXN1bHQoY2h1bmtNZXRhKV07XG4gICAgfVxuXG4gICAgY29uc3QgZGVtdXhSZXN1bHRPclByb21pc2UgPSBkZW11eGVyLmZsdXNoKHRpbWVPZmZzZXQpO1xuICAgIGlmIChpc1Byb21pc2UoZGVtdXhSZXN1bHRPclByb21pc2UpKSB7XG4gICAgICAvLyBEZWNyeXB0IGZpbmFsIFNBTVBMRS1BRVMgc2FtcGxlc1xuICAgICAgcmV0dXJuIGRlbXV4UmVzdWx0T3JQcm9taXNlLnRoZW4oKGRlbXV4UmVzdWx0KSA9PiB7XG4gICAgICAgIHRoaXMuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpO1xuICAgICAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5mbHVzaFJlbXV4KHRyYW5zbXV4UmVzdWx0cywgZGVtdXhSZXN1bHRPclByb21pc2UsIGNodW5rTWV0YSk7XG4gICAgcmV0dXJuIHRyYW5zbXV4UmVzdWx0cztcbiAgfVxuXG4gIHByaXZhdGUgZmx1c2hSZW11eChcbiAgICB0cmFuc211eFJlc3VsdHM6IFRyYW5zbXV4ZXJSZXN1bHRbXSxcbiAgICBkZW11eFJlc3VsdDogRGVtdXhlclJlc3VsdCxcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGFcbiAgKSB7XG4gICAgY29uc3QgeyBhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrIH0gPSBkZW11eFJlc3VsdDtcbiAgICBjb25zdCB7IGFjY3VyYXRlVGltZU9mZnNldCwgdGltZU9mZnNldCB9ID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBsb2dnZXIubG9nKFxuICAgICAgYFt0cmFuc211eGVyLnRzXTogRmx1c2hlZCBmcmFnbWVudCAke2NodW5rTWV0YS5zbn0ke1xuICAgICAgICBjaHVua01ldGEucGFydCA+IC0xID8gJyBwOiAnICsgY2h1bmtNZXRhLnBhcnQgOiAnJ1xuICAgICAgfSBvZiBsZXZlbCAke2NodW5rTWV0YS5sZXZlbH1gXG4gICAgKTtcbiAgICBjb25zdCByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlciEucmVtdXgoXG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrLFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIHRydWUsXG4gICAgICB0aGlzLmlkXG4gICAgKTtcbiAgICB0cmFuc211eFJlc3VsdHMucHVzaCh7XG4gICAgICByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YSxcbiAgICB9KTtcblxuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5leGVjdXRlRW5kID0gbm93KCk7XG4gIH1cblxuICByZXNldEluaXRpYWxUaW1lc3RhbXAoZGVmYXVsdEluaXRQdHM6IFJhdGlvbmFsVGltZXN0YW1wIHwgbnVsbCkge1xuICAgIGNvbnN0IHsgZGVtdXhlciwgcmVtdXhlciB9ID0gdGhpcztcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gICAgcmVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gIH1cblxuICByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgY29uc3QgeyBkZW11eGVyLCByZW11eGVyIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZW11eGVyLnJlc2V0Q29udGlndWl0eSgpO1xuICAgIHJlbXV4ZXIucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gIH1cblxuICByZXNldEluaXRTZWdtZW50KFxuICAgIGluaXRTZWdtZW50RGF0YTogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgICBhdWRpb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdmlkZW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHRyYWNrRHVyYXRpb246IG51bWJlcixcbiAgICBkZWNyeXB0ZGF0YTogRGVjcnlwdERhdGEgfCBudWxsXG4gICkge1xuICAgIGNvbnN0IHsgZGVtdXhlciwgcmVtdXhlciB9ID0gdGhpcztcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVtdXhlci5yZXNldEluaXRTZWdtZW50KFxuICAgICAgaW5pdFNlZ21lbnREYXRhLFxuICAgICAgYXVkaW9Db2RlYyxcbiAgICAgIHZpZGVvQ29kZWMsXG4gICAgICB0cmFja0R1cmF0aW9uXG4gICAgKTtcbiAgICByZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoXG4gICAgICBpbml0U2VnbWVudERhdGEsXG4gICAgICBhdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYyxcbiAgICAgIGRlY3J5cHRkYXRhXG4gICAgKTtcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVtdXhlcikge1xuICAgICAgdGhpcy5yZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucmVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyYW5zbXV4KFxuICAgIGRhdGE6IFVpbnQ4QXJyYXksXG4gICAga2V5RGF0YTogS2V5RGF0YSB8IG51bGwsXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGFjY3VyYXRlVGltZU9mZnNldDogYm9vbGVhbixcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGFcbiAgKTogVHJhbnNtdXhlclJlc3VsdCB8IFByb21pc2U8VHJhbnNtdXhlclJlc3VsdD4ge1xuICAgIGxldCByZXN1bHQ6IFRyYW5zbXV4ZXJSZXN1bHQgfCBQcm9taXNlPFRyYW5zbXV4ZXJSZXN1bHQ+O1xuICAgIGlmIChrZXlEYXRhICYmIGtleURhdGEubWV0aG9kID09PSAnU0FNUExFLUFFUycpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhTYW1wbGVBZXMoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGtleURhdGEsXG4gICAgICAgIHRpbWVPZmZzZXQsXG4gICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgICAgY2h1bmtNZXRhXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbXV4VW5lbmNyeXB0ZWQoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHRpbWVPZmZzZXQsXG4gICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgICAgY2h1bmtNZXRhXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc211eFVuZW5jcnlwdGVkKFxuICAgIGRhdGE6IFVpbnQ4QXJyYXksXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGFjY3VyYXRlVGltZU9mZnNldDogYm9vbGVhbixcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGFcbiAgKTogVHJhbnNtdXhlclJlc3VsdCB7XG4gICAgY29uc3QgeyBhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrIH0gPSAoXG4gICAgICB0aGlzLmRlbXV4ZXIgYXMgRGVtdXhlclxuICAgICkuZGVtdXgoZGF0YSwgdGltZU9mZnNldCwgZmFsc2UsICF0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSk7XG4gICAgY29uc3QgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIhLnJlbXV4KFxuICAgICAgYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjayxcbiAgICAgIHRpbWVPZmZzZXQsXG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMuaWRcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc211eFNhbXBsZUFlcyhcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGRlY3J5cHREYXRhOiBLZXlEYXRhLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGJvb2xlYW4sXG4gICAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhXG4gICk6IFByb21pc2U8VHJhbnNtdXhlclJlc3VsdD4ge1xuICAgIHJldHVybiAodGhpcy5kZW11eGVyIGFzIERlbXV4ZXIpXG4gICAgICAuZGVtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQpXG4gICAgICAudGhlbigoZGVtdXhSZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIhLnJlbXV4KFxuICAgICAgICAgIGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssXG4gICAgICAgICAgZGVtdXhSZXN1bHQudmlkZW9UcmFjayxcbiAgICAgICAgICBkZW11eFJlc3VsdC5pZDNUcmFjayxcbiAgICAgICAgICBkZW11eFJlc3VsdC50ZXh0VHJhY2ssXG4gICAgICAgICAgdGltZU9mZnNldCxcbiAgICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgdGhpcy5pZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbXV4UmVzdWx0LFxuICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25maWd1cmVUcmFuc211eGVyKGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHwgRXJyb3Ige1xuICAgIGNvbnN0IHsgY29uZmlnLCBvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgdmVuZG9yIH0gPSB0aGlzO1xuICAgIC8vIHByb2JlIGZvciBjb250ZW50IHR5cGVcbiAgICBsZXQgbXV4O1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtdXhDb25maWcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChtdXhDb25maWdbaV0uZGVtdXgucHJvYmUoZGF0YSkpIHtcbiAgICAgICAgbXV4ID0gbXV4Q29uZmlnW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtdXgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGRlbXV4ZXIgYnkgcHJvYmluZyBmcmFnbWVudCBkYXRhJyk7XG4gICAgfVxuICAgIC8vIHNvIGxldCdzIGNoZWNrIHRoYXQgY3VycmVudCByZW11eGVyIGFuZCBkZW11eGVyIGFyZSBzdGlsbCB2YWxpZFxuICAgIGNvbnN0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgY29uc3QgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcbiAgICBjb25zdCBSZW11eGVyOiBNdXhDb25maWdbJ3JlbXV4J10gPSBtdXgucmVtdXg7XG4gICAgY29uc3QgRGVtdXhlcjogTXV4Q29uZmlnWydkZW11eCddID0gbXV4LmRlbXV4O1xuICAgIGlmICghcmVtdXhlciB8fCAhKHJlbXV4ZXIgaW5zdGFuY2VvZiBSZW11eGVyKSkge1xuICAgICAgdGhpcy5yZW11eGVyID0gbmV3IFJlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdmVuZG9yKTtcbiAgICB9XG4gICAgaWYgKCFkZW11eGVyIHx8ICEoZGVtdXhlciBpbnN0YW5jZW9mIERlbXV4ZXIpKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKTtcbiAgICAgIHRoaXMucHJvYmUgPSBEZW11eGVyLnByb2JlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbmVlZHNQcm9iaW5nKGRpc2NvbnRpbnVpdHk6IGJvb2xlYW4sIHRyYWNrU3dpdGNoOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb250aW51aXR5IGNoYW5nZSwgb3IgdHJhY2sgc3dpdGNoXG4gICAgLy8gd2UgbWlnaHQgc3dpdGNoIGZyb20gY29udGVudCB0eXBlIChBQUMgY29udGFpbmVyIHRvIFRTIGNvbnRhaW5lciwgb3IgVFMgdG8gZm1wNCBmb3IgZXhhbXBsZSlcbiAgICByZXR1cm4gIXRoaXMuZGVtdXhlciB8fCAhdGhpcy5yZW11eGVyIHx8IGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2g7XG4gIH1cblxuICBwcml2YXRlIGdldERlY3J5cHRlcigpOiBEZWNyeXB0ZXIge1xuICAgIGxldCBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcjtcbiAgICBpZiAoIWRlY3J5cHRlcikge1xuICAgICAgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKHRoaXMuY29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY3J5cHRlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uVHlwZShcbiAgZGF0YTogVWludDhBcnJheSxcbiAgZGVjcnlwdERhdGE6IERlY3J5cHREYXRhIHwgbnVsbFxuKTogS2V5RGF0YSB8IG51bGwge1xuICBsZXQgZW5jcnlwdGlvblR5cGU6IEtleURhdGEgfCBudWxsID0gbnVsbDtcbiAgaWYgKFxuICAgIGRhdGEuYnl0ZUxlbmd0aCA+IDAgJiZcbiAgICBkZWNyeXB0RGF0YSAhPSBudWxsICYmXG4gICAgZGVjcnlwdERhdGEua2V5ICE9IG51bGwgJiZcbiAgICBkZWNyeXB0RGF0YS5pdiAhPT0gbnVsbCAmJlxuICAgIGRlY3J5cHREYXRhLm1ldGhvZCAhPSBudWxsXG4gICkge1xuICAgIGVuY3J5cHRpb25UeXBlID0gZGVjcnlwdERhdGEgYXMgS2V5RGF0YTtcbiAgfVxuICByZXR1cm4gZW5jcnlwdGlvblR5cGU7XG59XG5cbmNvbnN0IGVtcHR5UmVzdWx0ID0gKGNodW5rTWV0YSk6IFRyYW5zbXV4ZXJSZXN1bHQgPT4gKHtcbiAgcmVtdXhSZXN1bHQ6IHt9LFxuICBjaHVua01ldGEsXG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZTxUPihwOiBQcm9taXNlPFQ+IHwgYW55KTogcCBpcyBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuICd0aGVuJyBpbiBwICYmIHAudGhlbiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuXG5leHBvcnQgY2xhc3MgVHJhbnNtdXhDb25maWcge1xuICBwdWJsaWMgYXVkaW9Db2RlYz86IHN0cmluZztcbiAgcHVibGljIHZpZGVvQ29kZWM/OiBzdHJpbmc7XG4gIHB1YmxpYyBpbml0U2VnbWVudERhdGE/OiBVaW50OEFycmF5O1xuICBwdWJsaWMgZHVyYXRpb246IG51bWJlcjtcbiAgcHVibGljIGRlZmF1bHRJbml0UHRzOiBSYXRpb25hbFRpbWVzdGFtcCB8IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgYXVkaW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHZpZGVvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBpbml0U2VnbWVudERhdGE6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQsXG4gICAgZHVyYXRpb246IG51bWJlcixcbiAgICBkZWZhdWx0SW5pdFB0cz86IFJhdGlvbmFsVGltZXN0YW1wXG4gICkge1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLmluaXRTZWdtZW50RGF0YSA9IGluaXRTZWdtZW50RGF0YTtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgdGhpcy5kZWZhdWx0SW5pdFB0cyA9IGRlZmF1bHRJbml0UHRzIHx8IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRyYW5zbXV4U3RhdGUge1xuICBwdWJsaWMgZGlzY29udGludWl0eTogYm9vbGVhbjtcbiAgcHVibGljIGNvbnRpZ3VvdXM6IGJvb2xlYW47XG4gIHB1YmxpYyBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGJvb2xlYW47XG4gIHB1YmxpYyB0cmFja1N3aXRjaDogYm9vbGVhbjtcbiAgcHVibGljIHRpbWVPZmZzZXQ6IG51bWJlcjtcbiAgcHVibGljIGluaXRTZWdtZW50Q2hhbmdlOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGRpc2NvbnRpbnVpdHk6IGJvb2xlYW4sXG4gICAgY29udGlndW91czogYm9vbGVhbixcbiAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGJvb2xlYW4sXG4gICAgdHJhY2tTd2l0Y2g6IGJvb2xlYW4sXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGluaXRTZWdtZW50Q2hhbmdlOiBib29sZWFuXG4gICkge1xuICAgIHRoaXMuZGlzY29udGludWl0eSA9IGRpc2NvbnRpbnVpdHk7XG4gICAgdGhpcy5jb250aWd1b3VzID0gY29udGlndW91cztcbiAgICB0aGlzLmFjY3VyYXRlVGltZU9mZnNldCA9IGFjY3VyYXRlVGltZU9mZnNldDtcbiAgICB0aGlzLnRyYWNrU3dpdGNoID0gdHJhY2tTd2l0Y2g7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICB0aGlzLmluaXRTZWdtZW50Q2hhbmdlID0gaW5pdFNlZ21lbnRDaGFuZ2U7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiIsImltcG9ydCBUcmFuc211eGVyLCB7IGlzUHJvbWlzZSB9IGZyb20gJy4uL2RlbXV4L3RyYW5zbXV4ZXInO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IElMb2dGdW5jdGlvbiwgZW5hYmxlTG9ncywgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgRXJyb3JEZXRhaWxzLCBFcnJvclR5cGVzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB0eXBlIHsgUmVtdXhlZFRyYWNrLCBSZW11eGVyUmVzdWx0IH0gZnJvbSAnLi4vdHlwZXMvcmVtdXhlcic7XG5pbXBvcnQgdHlwZSB7IFRyYW5zbXV4ZXJSZXN1bHQsIENodW5rTWV0YWRhdGEgfSBmcm9tICcuLi90eXBlcy90cmFuc211eGVyJztcblxuaWYgKHR5cGVvZiBfX0lOX1dPUktFUl9fICE9PSAndW5kZWZpbmVkJyAmJiBfX0lOX1dPUktFUl9fKSB7XG4gIHN0YXJ0V29ya2VyKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtlcihzZWxmKSB7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBjb25zdCBmb3J3YXJkTWVzc2FnZSA9IChldiwgZGF0YSkgPT4ge1xuICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBldmVudDogZXYsIGRhdGE6IGRhdGEgfSk7XG4gIH07XG5cbiAgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcbiAgb2JzZXJ2ZXIub24oRXZlbnRzLkZSQUdfREVDUllQVEVELCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50cy5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xuXG4gIC8vIGZvcndhcmQgbG9nZ2VyIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICBjb25zdCBmb3J3YXJkV29ya2VyTG9ncyA9ICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGxvZ0ZuIGluIGxvZ2dlcikge1xuICAgICAgY29uc3QgZnVuYzogSUxvZ0Z1bmN0aW9uID0gKG1lc3NhZ2U/KSA9PiB7XG4gICAgICAgIGZvcndhcmRNZXNzYWdlKCd3b3JrZXJMb2cnLCB7XG4gICAgICAgICAgbG9nVHlwZTogbG9nRm4sXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBsb2dnZXJbbG9nRm5dID0gZnVuYztcbiAgICB9XG4gIH07XG5cbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGV2LmRhdGE7XG4gICAgc3dpdGNoIChkYXRhLmNtZCkge1xuICAgICAgY2FzZSAnaW5pdCc6IHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gSlNPTi5wYXJzZShkYXRhLmNvbmZpZyk7XG4gICAgICAgIHNlbGYudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVyKFxuICAgICAgICAgIG9ic2VydmVyLFxuICAgICAgICAgIGRhdGEudHlwZVN1cHBvcnRlZCxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgZGF0YS52ZW5kb3IsXG4gICAgICAgICAgZGF0YS5pZFxuICAgICAgICApO1xuICAgICAgICBlbmFibGVMb2dzKGNvbmZpZy5kZWJ1ZywgZGF0YS5pZCk7XG4gICAgICAgIGZvcndhcmRXb3JrZXJMb2dzKCk7XG4gICAgICAgIGZvcndhcmRNZXNzYWdlKCdpbml0JywgbnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnY29uZmlndXJlJzoge1xuICAgICAgICBzZWxmLnRyYW5zbXV4ZXIuY29uZmlndXJlKGRhdGEuY29uZmlnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdkZW11eCc6IHtcbiAgICAgICAgY29uc3QgdHJhbnNtdXhSZXN1bHQ6IFRyYW5zbXV4ZXJSZXN1bHQgfCBQcm9taXNlPFRyYW5zbXV4ZXJSZXN1bHQ+ID1cbiAgICAgICAgICBzZWxmLnRyYW5zbXV4ZXIucHVzaChcbiAgICAgICAgICAgIGRhdGEuZGF0YSxcbiAgICAgICAgICAgIGRhdGEuZGVjcnlwdGRhdGEsXG4gICAgICAgICAgICBkYXRhLmNodW5rTWV0YSxcbiAgICAgICAgICAgIGRhdGEuc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoaXNQcm9taXNlKHRyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICAgIHNlbGYudHJhbnNtdXhlci5hc3luYyA9IHRydWU7XG4gICAgICAgICAgdHJhbnNtdXhSZXN1bHRcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIGVtaXRUcmFuc211eENvbXBsZXRlKHNlbGYsIGRhdGEpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgZm9yd2FyZE1lc3NhZ2UoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgICAgICAgIGNodW5rTWV0YTogZGF0YS5jaHVua01ldGEsXG4gICAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGVycjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBgdHJhbnNtdXhlci13b3JrZXIgcHVzaCBlcnJvcmAsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi50cmFuc211eGVyLmFzeW5jID0gZmFsc2U7XG4gICAgICAgICAgZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgdHJhbnNtdXhSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZmx1c2gnOiB7XG4gICAgICAgIGNvbnN0IGlkID0gZGF0YS5jaHVua01ldGE7XG4gICAgICAgIGxldCB0cmFuc211eFJlc3VsdCA9IHNlbGYudHJhbnNtdXhlci5mbHVzaChpZCk7XG4gICAgICAgIGNvbnN0IGFzeW5jRmx1c2ggPSBpc1Byb21pc2UodHJhbnNtdXhSZXN1bHQpO1xuICAgICAgICBpZiAoYXN5bmNGbHVzaCB8fCBzZWxmLnRyYW5zbXV4ZXIuYXN5bmMpIHtcbiAgICAgICAgICBpZiAoIWlzUHJvbWlzZSh0cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRyYW5zbXV4UmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKHRyYW5zbXV4UmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhbnNtdXhSZXN1bHRcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHRzOiBBcnJheTxUcmFuc211eGVyUmVzdWx0PikgPT4ge1xuICAgICAgICAgICAgICBoYW5kbGVGbHVzaFJlc3VsdChzZWxmLCByZXN1bHRzIGFzIEFycmF5PFRyYW5zbXV4ZXJSZXN1bHQ+LCBpZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBmb3J3YXJkTWVzc2FnZShFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgICAgICAgY2h1bmtNZXRhOiBkYXRhLmNodW5rTWV0YSxcbiAgICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgZXJyOiBlcnJvcixcbiAgICAgICAgICAgICAgICByZWFzb246IGB0cmFuc211eGVyLXdvcmtlciBmbHVzaCBlcnJvcmAsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlRmx1c2hSZXN1bHQoXG4gICAgICAgICAgICBzZWxmLFxuICAgICAgICAgICAgdHJhbnNtdXhSZXN1bHQgYXMgQXJyYXk8VHJhbnNtdXhlclJlc3VsdD4sXG4gICAgICAgICAgICBpZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbWl0VHJhbnNtdXhDb21wbGV0ZShcbiAgc2VsZjogYW55LFxuICB0cmFuc211eFJlc3VsdDogVHJhbnNtdXhlclJlc3VsdFxuKTogYm9vbGVhbiB7XG4gIGlmIChpc0VtcHR5UmVzdWx0KHRyYW5zbXV4UmVzdWx0LnJlbXV4UmVzdWx0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0cmFuc2ZlcmFibGU6IEFycmF5PEFycmF5QnVmZmVyPiA9IFtdO1xuICBjb25zdCB7IGF1ZGlvLCB2aWRlbyB9ID0gdHJhbnNtdXhSZXN1bHQucmVtdXhSZXN1bHQ7XG4gIGlmIChhdWRpbykge1xuICAgIGFkZFRvVHJhbnNmZXJhYmxlKHRyYW5zZmVyYWJsZSwgYXVkaW8pO1xuICB9XG4gIGlmICh2aWRlbykge1xuICAgIGFkZFRvVHJhbnNmZXJhYmxlKHRyYW5zZmVyYWJsZSwgdmlkZW8pO1xuICB9XG4gIHNlbGYucG9zdE1lc3NhZ2UoXG4gICAgeyBldmVudDogJ3RyYW5zbXV4Q29tcGxldGUnLCBkYXRhOiB0cmFuc211eFJlc3VsdCB9LFxuICAgIHRyYW5zZmVyYWJsZVxuICApO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gQ29udmVydHMgZGF0YSB0byBhIHRyYW5zZmVyYWJsZSBvYmplY3QgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxMS8xMi9UcmFuc2ZlcmFibGUtT2JqZWN0cy1MaWdodG5pbmctRmFzdClcbi8vIGluIG9yZGVyIHRvIG1pbmltaXplIG1lc3NhZ2UgcGFzc2luZyBvdmVyaGVhZFxuZnVuY3Rpb24gYWRkVG9UcmFuc2ZlcmFibGUoXG4gIHRyYW5zZmVyYWJsZTogQXJyYXk8QXJyYXlCdWZmZXI+LFxuICB0cmFjazogUmVtdXhlZFRyYWNrXG4pIHtcbiAgaWYgKHRyYWNrLmRhdGExKSB7XG4gICAgdHJhbnNmZXJhYmxlLnB1c2godHJhY2suZGF0YTEuYnVmZmVyKTtcbiAgfVxuICBpZiAodHJhY2suZGF0YTIpIHtcbiAgICB0cmFuc2ZlcmFibGUucHVzaCh0cmFjay5kYXRhMi5idWZmZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZsdXNoUmVzdWx0KFxuICBzZWxmOiBhbnksXG4gIHJlc3VsdHM6IEFycmF5PFRyYW5zbXV4ZXJSZXN1bHQ+LFxuICBjaHVua01ldGE6IENodW5rTWV0YWRhdGFcbikge1xuICBjb25zdCBwYXJzZWQgPSByZXN1bHRzLnJlZHVjZShcbiAgICAocGFyc2VkLCByZXN1bHQpID0+IGVtaXRUcmFuc211eENvbXBsZXRlKHNlbGYsIHJlc3VsdCkgfHwgcGFyc2VkLFxuICAgIGZhbHNlXG4gICk7XG4gIGlmICghcGFyc2VkKSB7XG4gICAgLy8gRW1pdCBhdCBsZWFzdCBvbmUgXCJ0cmFuc211eENvbXBsZXRlXCIgbWVzc2FnZSBldmVuIGlmIG1lZGlhIGlzIG5vdCBmb3VuZCB0byB1cGRhdGUgc3RyZWFtLWNvbnRyb2xsZXIgc3RhdGUgdG8gUEFSU0lOR1xuICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBldmVudDogJ3RyYW5zbXV4Q29tcGxldGUnLCBkYXRhOiByZXN1bHRzWzBdIH0pO1xuICB9XG4gIHNlbGYucG9zdE1lc3NhZ2UoeyBldmVudDogJ2ZsdXNoJywgZGF0YTogY2h1bmtNZXRhIH0pO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5UmVzdWx0KHJlbXV4UmVzdWx0OiBSZW11eGVyUmVzdWx0KSB7XG4gIHJldHVybiAoXG4gICAgIXJlbXV4UmVzdWx0LmF1ZGlvICYmXG4gICAgIXJlbXV4UmVzdWx0LnZpZGVvICYmXG4gICAgIXJlbXV4UmVzdWx0LnRleHQgJiZcbiAgICAhcmVtdXhSZXN1bHQuaWQzICYmXG4gICAgIXJlbXV4UmVzdWx0LmluaXRTZWdtZW50XG4gICk7XG59XG4iLCIvLyBlbnN1cmUgdGhlIHdvcmtlciBlbmRzIHVwIGluIHRoZSBidW5kbGVcbi8vIElmIHRoZSB3b3JrZXIgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCB0aGlzIGdldHMgYWxpYXNlZCB0byBlbXB0eS5qc1xuaW1wb3J0ICcuL3RyYW5zbXV4ZXItd29ya2VyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1VNRFdvcmtlcigpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiBfX0hMU19XT1JLRVJfQlVORExFX18gPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCB0eXBlIFdvcmtlckNvbnRleHQgPSB7XG4gIHdvcmtlcjogV29ya2VyO1xuICBvYmplY3RVUkw/OiBzdHJpbmc7XG4gIHNjcmlwdFVSTD86IHN0cmluZztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RXb3JrZXIoKTogV29ya2VyQ29udGV4dCB7XG4gIGNvbnN0IGJsb2IgPSBuZXcgc2VsZi5CbG9iKFxuICAgIFtcbiAgICAgIGB2YXIgZXhwb3J0cz17fTt2YXIgbW9kdWxlPXtleHBvcnRzOmV4cG9ydHN9O2Z1bmN0aW9uIGRlZmluZShmKXtmKCl9O2RlZmluZS5hbWQ9dHJ1ZTsoJHtfX0hMU19XT1JLRVJfQlVORExFX18udG9TdHJpbmcoKX0pKHRydWUpO2AsXG4gICAgXSxcbiAgICB7XG4gICAgICB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyxcbiAgICB9XG4gICk7XG4gIGNvbnN0IG9iamVjdFVSTCA9IHNlbGYuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgY29uc3Qgd29ya2VyID0gbmV3IHNlbGYuV29ya2VyKG9iamVjdFVSTCk7XG5cbiAgcmV0dXJuIHtcbiAgICB3b3JrZXIsXG4gICAgb2JqZWN0VVJMLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZFdvcmtlcihwYXRoOiBzdHJpbmcpOiBXb3JrZXJDb250ZXh0IHtcbiAgY29uc3Qgc2NyaXB0VVJMID0gbmV3IHNlbGYuVVJMKHBhdGgsIHNlbGYubG9jYXRpb24uaHJlZikuaHJlZjtcbiAgY29uc3Qgd29ya2VyID0gbmV3IHNlbGYuV29ya2VyKHNjcmlwdFVSTCk7XG5cbiAgcmV0dXJuIHtcbiAgICB3b3JrZXIsXG4gICAgc2NyaXB0VVJMLFxuICB9O1xufVxuIiwiaW1wb3J0IHtcbiAgV29ya2VyQ29udGV4dCxcbiAgaGFzVU1EV29ya2VyLFxuICBpbmplY3RXb3JrZXIsXG4gIGxvYWRXb3JrZXIsXG59IGZyb20gJy4vaW5qZWN0LXdvcmtlcic7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IFRyYW5zbXV4ZXIsIHtcbiAgVHJhbnNtdXhDb25maWcsXG4gIFRyYW5zbXV4U3RhdGUsXG4gIGlzUHJvbWlzZSxcbn0gZnJvbSAnLi4vZGVtdXgvdHJhbnNtdXhlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGdldE1lZGlhU291cmNlIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFBhcnQgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBDaHVua01ldGFkYXRhLCBUcmFuc211eGVyUmVzdWx0IH0gZnJvbSAnLi4vdHlwZXMvdHJhbnNtdXhlcic7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgSGxzRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgUGxheWxpc3RMZXZlbFR5cGUgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHR5cGUgeyBUeXBlU3VwcG9ydGVkIH0gZnJvbSAnLi90c2RlbXV4ZXInO1xuaW1wb3J0IHR5cGUgeyBSYXRpb25hbFRpbWVzdGFtcCB9IGZyb20gJy4uL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uJztcblxuY29uc3QgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpIHx8IHsgaXNUeXBlU3VwcG9ydGVkOiAoKSA9PiBmYWxzZSB9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc211eGVySW50ZXJmYWNlIHtcbiAgcHVibGljIGVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGhsczogSGxzO1xuICBwcml2YXRlIGlkOiBQbGF5bGlzdExldmVsVHlwZTtcbiAgcHJpdmF0ZSBvYnNlcnZlcjogSGxzRXZlbnRFbWl0dGVyO1xuICBwcml2YXRlIGZyYWc6IEZyYWdtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcGFydDogUGFydCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHVzZVdvcmtlcjogYm9vbGVhbjtcbiAgcHJpdmF0ZSB3b3JrZXJDb250ZXh0OiBXb3JrZXJDb250ZXh0IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgb253bXNnPzogRnVuY3Rpb247XG4gIHByaXZhdGUgdHJhbnNtdXhlcjogVHJhbnNtdXhlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG9uVHJhbnNtdXhDb21wbGV0ZTogKHRyYW5zbXV4UmVzdWx0OiBUcmFuc211eGVyUmVzdWx0KSA9PiB2b2lkO1xuICBwcml2YXRlIG9uRmx1c2g6IChjaHVua01ldGE6IENodW5rTWV0YWRhdGEpID0+IHZvaWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgaGxzOiBIbHMsXG4gICAgaWQ6IFBsYXlsaXN0TGV2ZWxUeXBlLFxuICAgIG9uVHJhbnNtdXhDb21wbGV0ZTogKHRyYW5zbXV4UmVzdWx0OiBUcmFuc211eGVyUmVzdWx0KSA9PiB2b2lkLFxuICAgIG9uRmx1c2g6IChjaHVua01ldGE6IENodW5rTWV0YWRhdGEpID0+IHZvaWRcbiAgKSB7XG4gICAgY29uc3QgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy51c2VXb3JrZXIgPSAhIWNvbmZpZy5lbmFibGVXb3JrZXI7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUgPSBvblRyYW5zbXV4Q29tcGxldGU7XG4gICAgdGhpcy5vbkZsdXNoID0gb25GbHVzaDtcblxuICAgIGNvbnN0IGZvcndhcmRNZXNzYWdlID0gKGV2LCBkYXRhKSA9PiB7XG4gICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgIGRhdGEuZnJhZyA9IHRoaXMuZnJhZztcbiAgICAgIGRhdGEuaWQgPSB0aGlzLmlkO1xuICAgICAgaWYgKGV2ID09PSBFdmVudHMuRVJST1IpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IGRhdGEuZXJyb3I7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKGV2LCBkYXRhKTtcbiAgICB9O1xuXG4gICAgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcbiAgICB0aGlzLm9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpIGFzIEhsc0V2ZW50RW1pdHRlcjtcbiAgICB0aGlzLm9ic2VydmVyLm9uKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIHRoaXMub2JzZXJ2ZXIub24oRXZlbnRzLkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG5cbiAgICBjb25zdCB0eXBlU3VwcG9ydGVkOiBUeXBlU3VwcG9ydGVkID0ge1xuICAgICAgbXA0OiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNCcpLFxuICAgICAgbXBlZzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXG4gICAgICBtcDM6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXA0OyBjb2RlY3M9XCJtcDNcIicpLFxuICAgIH07XG4gICAgLy8gbmF2aWdhdG9yLnZlbmRvciBpcyBub3QgYWx3YXlzIGF2YWlsYWJsZSBpbiBXZWIgV29ya2VyXG4gICAgLy8gcmVmZXIgdG8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dvcmtlckdsb2JhbFNjb3BlL25hdmlnYXRvclxuICAgIGNvbnN0IHZlbmRvciA9IG5hdmlnYXRvci52ZW5kb3I7XG4gICAgaWYgKHRoaXMudXNlV29ya2VyICYmIHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBjYW5DcmVhdGVXb3JrZXIgPSBjb25maWcud29ya2VyUGF0aCB8fCBoYXNVTURXb3JrZXIoKTtcbiAgICAgIGlmIChjYW5DcmVhdGVXb3JrZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoY29uZmlnLndvcmtlclBhdGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYGxvYWRpbmcgV2ViIFdvcmtlciAke2NvbmZpZy53b3JrZXJQYXRofSBmb3IgXCIke2lkfVwiYCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlckNvbnRleHQgPSBsb2FkV29ya2VyKGNvbmZpZy53b3JrZXJQYXRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgaW5qZWN0aW5nIFdlYiBXb3JrZXIgZm9yIFwiJHtpZH1cImApO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gaW5qZWN0V29ya2VyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub253bXNnID0gKGV2OiBhbnkpID0+IHRoaXMub25Xb3JrZXJNZXNzYWdlKGV2KTtcbiAgICAgICAgICBjb25zdCB7IHdvcmtlciB9ID0gdGhpcy53b3JrZXJDb250ZXh0O1xuICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cgYXMgYW55KTtcbiAgICAgICAgICB3b3JrZXIub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGAke2V2ZW50Lm1lc3NhZ2V9ICAoJHtldmVudC5maWxlbmFtZX06JHtldmVudC5saW5lbm99KWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25maWcuZW5hYmxlV29ya2VyID0gZmFsc2U7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgRXJyb3IgaW4gXCIke2lkfVwiIFdlYiBXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZWApO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBldmVudDogJ2RlbXV4ZXJXb3JrZXInLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGNtZDogJ2luaXQnLFxuICAgICAgICAgICAgdHlwZVN1cHBvcnRlZDogdHlwZVN1cHBvcnRlZCxcbiAgICAgICAgICAgIHZlbmRvcjogdmVuZG9yLFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgY29uZmlnOiBKU09OLnN0cmluZ2lmeShjb25maWcpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgIGBFcnJvciBzZXR0aW5nIHVwIFwiJHtpZH1cIiBXZWIgV29ya2VyLCBmYWxsYmFjayB0byBpbmxpbmVgLFxuICAgICAgICAgICAgZXJyXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnJlc2V0V29ya2VyKCk7XG4gICAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgICAgdGhpcy50cmFuc211eGVyID0gbmV3IFRyYW5zbXV4ZXIoXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLFxuICAgICAgICAgICAgdHlwZVN1cHBvcnRlZCxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHZlbmRvcixcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50cmFuc211eGVyID0gbmV3IFRyYW5zbXV4ZXIoXG4gICAgICB0aGlzLm9ic2VydmVyLFxuICAgICAgdHlwZVN1cHBvcnRlZCxcbiAgICAgIGNvbmZpZyxcbiAgICAgIHZlbmRvcixcbiAgICAgIGlkXG4gICAgKTtcbiAgfVxuXG4gIHJlc2V0V29ya2VyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHsgd29ya2VyLCBvYmplY3RVUkwgfSA9IHRoaXMud29ya2VyQ29udGV4dDtcbiAgICAgIGlmIChvYmplY3RVUkwpIHtcbiAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VVJMKTtcbiAgICAgIH1cbiAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cgYXMgYW55KTtcbiAgICAgIHdvcmtlci5vbmVycm9yID0gbnVsbDtcbiAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICB0aGlzLnJlc2V0V29ya2VyKCk7XG4gICAgICB0aGlzLm9ud21zZyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICAgIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgfVxuXG4gIHB1c2goXG4gICAgZGF0YTogQXJyYXlCdWZmZXIsXG4gICAgaW5pdFNlZ21lbnREYXRhOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICAgIGF1ZGlvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2aWRlb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAgcGFydDogUGFydCB8IG51bGwsXG4gICAgZHVyYXRpb246IG51bWJlcixcbiAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGJvb2xlYW4sXG4gICAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhLFxuICAgIGRlZmF1bHRJbml0UFRTPzogUmF0aW9uYWxUaW1lc3RhbXBcbiAgKTogdm9pZCB7XG4gICAgY2h1bmtNZXRhLnRyYW5zbXV4aW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCB7IHRyYW5zbXV4ZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgdGltZU9mZnNldCA9IHBhcnQgPyBwYXJ0LnN0YXJ0IDogZnJhZy5zdGFydDtcbiAgICAvLyBUT0RPOiBwdXNoIFwiY2xlYXItbGVhZFwiIGRlY3J5cHQgZGF0YSBmb3IgdW5lbmNyeXB0ZWQgZnJhZ21lbnRzIGluIHN0cmVhbXMgd2l0aCBlbmNyeXB0ZWQgb25lc1xuICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICBjb25zdCBsYXN0RnJhZyA9IHRoaXMuZnJhZztcblxuICAgIGNvbnN0IGRpc2NvbnRpbnVpdHkgPSAhKGxhc3RGcmFnICYmIGZyYWcuY2MgPT09IGxhc3RGcmFnLmNjKTtcbiAgICBjb25zdCB0cmFja1N3aXRjaCA9ICEobGFzdEZyYWcgJiYgY2h1bmtNZXRhLmxldmVsID09PSBsYXN0RnJhZy5sZXZlbCk7XG4gICAgY29uc3Qgc25EaWZmID0gbGFzdEZyYWcgPyBjaHVua01ldGEuc24gLSAobGFzdEZyYWcuc24gYXMgbnVtYmVyKSA6IC0xO1xuICAgIGNvbnN0IHBhcnREaWZmID0gdGhpcy5wYXJ0ID8gY2h1bmtNZXRhLnBhcnQgLSB0aGlzLnBhcnQuaW5kZXggOiAtMTtcbiAgICBjb25zdCBwcm9ncmVzc2l2ZSA9XG4gICAgICBzbkRpZmYgPT09IDAgJiZcbiAgICAgIGNodW5rTWV0YS5pZCA+IDEgJiZcbiAgICAgIGNodW5rTWV0YS5pZCA9PT0gbGFzdEZyYWc/LnN0YXRzLmNodW5rQ291bnQ7XG4gICAgY29uc3QgY29udGlndW91cyA9XG4gICAgICAhdHJhY2tTd2l0Y2ggJiZcbiAgICAgIChzbkRpZmYgPT09IDEgfHxcbiAgICAgICAgKHNuRGlmZiA9PT0gMCAmJiAocGFydERpZmYgPT09IDEgfHwgKHByb2dyZXNzaXZlICYmIHBhcnREaWZmIDw9IDApKSkpO1xuICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBpZiAodHJhY2tTd2l0Y2ggfHwgc25EaWZmIHx8IGZyYWcuc3RhdHMucGFyc2luZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZy5zdGF0cy5wYXJzaW5nLnN0YXJ0ID0gbm93O1xuICAgIH1cbiAgICBpZiAocGFydCAmJiAocGFydERpZmYgfHwgIWNvbnRpZ3VvdXMpKSB7XG4gICAgICBwYXJ0LnN0YXRzLnBhcnNpbmcuc3RhcnQgPSBub3c7XG4gICAgfVxuICAgIGNvbnN0IGluaXRTZWdtZW50Q2hhbmdlID0gIShcbiAgICAgIGxhc3RGcmFnICYmIGZyYWcuaW5pdFNlZ21lbnQ/LnVybCA9PT0gbGFzdEZyYWcuaW5pdFNlZ21lbnQ/LnVybFxuICAgICk7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgVHJhbnNtdXhTdGF0ZShcbiAgICAgIGRpc2NvbnRpbnVpdHksXG4gICAgICBjb250aWd1b3VzLFxuICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgdHJhY2tTd2l0Y2gsXG4gICAgICB0aW1lT2Zmc2V0LFxuICAgICAgaW5pdFNlZ21lbnRDaGFuZ2VcbiAgICApO1xuICAgIGlmICghY29udGlndW91cyB8fCBkaXNjb250aW51aXR5IHx8IGluaXRTZWdtZW50Q2hhbmdlKSB7XG4gICAgICBsb2dnZXIubG9nKGBbdHJhbnNtdXhlci1pbnRlcmZhY2UsICR7ZnJhZy50eXBlfV06IFN0YXJ0aW5nIG5ldyB0cmFuc211eCBzZXNzaW9uIGZvciBzbjogJHtjaHVua01ldGEuc259IHA6ICR7Y2h1bmtNZXRhLnBhcnR9IGxldmVsOiAke2NodW5rTWV0YS5sZXZlbH0gaWQ6ICR7Y2h1bmtNZXRhLmlkfVxuICAgICAgICBkaXNjb250aW51aXR5OiAke2Rpc2NvbnRpbnVpdHl9XG4gICAgICAgIHRyYWNrU3dpdGNoOiAke3RyYWNrU3dpdGNofVxuICAgICAgICBjb250aWd1b3VzOiAke2NvbnRpZ3VvdXN9XG4gICAgICAgIGFjY3VyYXRlVGltZU9mZnNldDogJHthY2N1cmF0ZVRpbWVPZmZzZXR9XG4gICAgICAgIHRpbWVPZmZzZXQ6ICR7dGltZU9mZnNldH1cbiAgICAgICAgaW5pdFNlZ21lbnRDaGFuZ2U6ICR7aW5pdFNlZ21lbnRDaGFuZ2V9YCk7XG4gICAgICBjb25zdCBjb25maWcgPSBuZXcgVHJhbnNtdXhDb25maWcoXG4gICAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICAgIHZpZGVvQ29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50RGF0YSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGRlZmF1bHRJbml0UFRTXG4gICAgICApO1xuICAgICAgdGhpcy5jb25maWd1cmVUcmFuc211eGVyKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnID0gZnJhZztcbiAgICB0aGlzLnBhcnQgPSBwYXJ0O1xuXG4gICAgLy8gRnJhZ3Mgd2l0aCBzbiBvZiAnaW5pdFNlZ21lbnQnIGFyZSBub3QgdHJhbnNtdXhlZFxuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIC8vIHBvc3QgZnJhZ21lbnQgcGF5bG9hZCBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0cyBmb3IgQXJyYXlCdWZmZXIgKG5vIGNvcHkpXG4gICAgICB0aGlzLndvcmtlckNvbnRleHQud29ya2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICB7XG4gICAgICAgICAgY21kOiAnZGVtdXgnLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgZGVjcnlwdGRhdGEsXG4gICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICB9LFxuICAgICAgICBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBbZGF0YV0gOiBbXVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgIGNvbnN0IHRyYW5zbXV4UmVzdWx0ID0gdHJhbnNtdXhlci5wdXNoKFxuICAgICAgICBkYXRhLFxuICAgICAgICBkZWNyeXB0ZGF0YSxcbiAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICBzdGF0ZVxuICAgICAgKTtcbiAgICAgIGlmIChpc1Byb21pc2UodHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuYXN5bmMgPSB0cnVlO1xuICAgICAgICB0cmFuc211eFJlc3VsdFxuICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUoZGF0YSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXJFcnJvcihcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICAgICAgJ3RyYW5zbXV4ZXItaW50ZXJmYWNlIHB1c2ggZXJyb3InXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNtdXhlci5hc3luYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQgYXMgVHJhbnNtdXhlclJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZmx1c2goY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhKSB7XG4gICAgY2h1bmtNZXRhLnRyYW5zbXV4aW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCB7IHRyYW5zbXV4ZXIgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgMTtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdmbHVzaCcsXG4gICAgICAgIGNodW5rTWV0YSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgbGV0IHRyYW5zbXV4UmVzdWx0ID0gdHJhbnNtdXhlci5mbHVzaChjaHVua01ldGEpO1xuICAgICAgY29uc3QgYXN5bmNGbHVzaCA9IGlzUHJvbWlzZSh0cmFuc211eFJlc3VsdCk7XG4gICAgICBpZiAoYXN5bmNGbHVzaCB8fCB0cmFuc211eGVyLmFzeW5jKSB7XG4gICAgICAgIGlmICghaXNQcm9taXNlKHRyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICAgIHRyYW5zbXV4UmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKHRyYW5zbXV4UmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc211eFJlc3VsdFxuICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZsdXNoUmVzdWx0KGRhdGEsIGNodW5rTWV0YSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXJFcnJvcihcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICAgICAgJ3RyYW5zbXV4ZXItaW50ZXJmYWNlIGZsdXNoIGVycm9yJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRmx1c2hSZXN1bHQoXG4gICAgICAgICAgdHJhbnNtdXhSZXN1bHQgYXMgQXJyYXk8VHJhbnNtdXhlclJlc3VsdD4sXG4gICAgICAgICAgY2h1bmtNZXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc211eGVyRXJyb3IoXG4gICAgZXJyb3I6IEVycm9yLFxuICAgIGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YSxcbiAgICByZWFzb246IHN0cmluZ1xuICApIHtcbiAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICBjaHVua01ldGEsXG4gICAgICBmYXRhbDogZmFsc2UsXG4gICAgICBlcnJvcixcbiAgICAgIGVycjogZXJyb3IsXG4gICAgICByZWFzb24sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUZsdXNoUmVzdWx0KFxuICAgIHJlc3VsdHM6IEFycmF5PFRyYW5zbXV4ZXJSZXN1bHQ+LFxuICAgIGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YVxuICApIHtcbiAgICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgdGhpcy5vbkZsdXNoKGNodW5rTWV0YSk7XG4gIH1cblxuICBwcml2YXRlIG9uV29ya2VyTWVzc2FnZShldjogYW55KTogdm9pZCB7XG4gICAgY29uc3QgZGF0YSA9IGV2LmRhdGE7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7XG4gICAgICBjYXNlICdpbml0Jzoge1xuICAgICAgICBjb25zdCBvYmplY3RVUkwgPSB0aGlzLndvcmtlckNvbnRleHQ/Lm9iamVjdFVSTDtcbiAgICAgICAgaWYgKG9iamVjdFVSTCkge1xuICAgICAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSB0cmFuc211eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcbiAgICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VVJMKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSAndHJhbnNtdXhDb21wbGV0ZSc6IHtcbiAgICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdmbHVzaCc6IHtcbiAgICAgICAgdGhpcy5vbkZsdXNoKGRhdGEuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXNzIGxvZ3MgZnJvbSB0aGUgd29ya2VyIHRocmVhZCB0byB0aGUgbWFpbiBsb2dnZXJcbiAgICAgIGNhc2UgJ3dvcmtlckxvZyc6XG4gICAgICAgIGlmIChsb2dnZXJbZGF0YS5kYXRhLmxvZ1R5cGVdKSB7XG4gICAgICAgICAgbG9nZ2VyW2RhdGEuZGF0YS5sb2dUeXBlXShkYXRhLmRhdGEubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgZGF0YS5kYXRhID0gZGF0YS5kYXRhIHx8IHt9O1xuICAgICAgICBkYXRhLmRhdGEuZnJhZyA9IHRoaXMuZnJhZztcbiAgICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgICAgaGxzLnRyaWdnZXIoZGF0YS5ldmVudCwgZGF0YS5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb25maWd1cmVUcmFuc211eGVyKGNvbmZpZzogVHJhbnNtdXhDb25maWcpIHtcbiAgICBjb25zdCB7IHRyYW5zbXV4ZXIgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ2NvbmZpZ3VyZScsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgdHJhbnNtdXhlci5jb25maWd1cmUoY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVRyYW5zbXV4Q29tcGxldGUocmVzdWx0OiBUcmFuc211eGVyUmVzdWx0KSB7XG4gICAgcmVzdWx0LmNodW5rTWV0YS50cmFuc211eGluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlKHJlc3VsdCk7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgQnVmZmVySW5mbyB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHsgQnVmZmVySGVscGVyIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgUGxheWxpc3RMZXZlbFR5cGUgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgSGxzQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB0eXBlIHsgRnJhZ21lbnQgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudFRyYWNrZXIgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xuXG5leHBvcnQgY29uc3QgU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUyA9IDI1MDtcbmV4cG9ydCBjb25zdCBNQVhfU1RBUlRfR0FQX0pVTVAgPSAyLjA7XG5leHBvcnQgY29uc3QgU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFMgPSAwLjE7XG5leHBvcnQgY29uc3QgU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQgPSAwLjA1O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYXBDb250cm9sbGVyIHtcbiAgcHJpdmF0ZSBjb25maWc6IEhsc0NvbmZpZztcbiAgcHJpdmF0ZSBtZWRpYTogSFRNTE1lZGlhRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGZyYWdtZW50VHJhY2tlcjogRnJhZ21lbnRUcmFja2VyO1xuICBwcml2YXRlIGhsczogSGxzO1xuICBwcml2YXRlIG51ZGdlUmV0cnk6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgc3RhbGxSZXBvcnRlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIHN0YWxsZWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG1vdmVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgc2Vla2luZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgbWVkaWEsIGZyYWdtZW50VHJhY2tlciwgaGxzKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGxheWhlYWQgaXMgc3R1Y2sgd2l0aGluIGEgZ2FwLCBhbmQgaWYgc28sIGF0dGVtcHRzIHRvIGZyZWUgaXQuXG4gICAqIEEgZ2FwIGlzIGFuIHVuYnVmZmVyZWQgcmFuZ2UgYmV0d2VlbiB0d28gYnVmZmVyZWQgcmFuZ2VzIChvciB0aGUgc3RhcnQgYW5kIHRoZSBmaXJzdCBidWZmZXJlZCByYW5nZSkuXG4gICAqXG4gICAqIEBwYXJhbSBsYXN0Q3VycmVudFRpbWUgLSBQcmV2aW91c2x5IHJlYWQgcGxheWhlYWQgcG9zaXRpb25cbiAgICovXG4gIHB1YmxpYyBwb2xsKGxhc3RDdXJyZW50VGltZTogbnVtYmVyLCBhY3RpdmVGcmFnOiBGcmFnbWVudCB8IG51bGwpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgbWVkaWEsIHN0YWxsZWQgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY3VycmVudFRpbWUsIHNlZWtpbmcgfSA9IG1lZGlhO1xuICAgIGNvbnN0IHNlZWtlZCA9IHRoaXMuc2Vla2luZyAmJiAhc2Vla2luZztcbiAgICBjb25zdCBiZWdpblNlZWsgPSAhdGhpcy5zZWVraW5nICYmIHNlZWtpbmc7XG5cbiAgICB0aGlzLnNlZWtpbmcgPSBzZWVraW5nO1xuXG4gICAgLy8gVGhlIHBsYXloZWFkIGlzIG1vdmluZywgbm8tb3BcbiAgICBpZiAoY3VycmVudFRpbWUgIT09IGxhc3RDdXJyZW50VGltZSkge1xuICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICBpZiAoc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgcGxheWhlYWQgaXMgbm93IG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICAgIGNvbnN0IHN0YWxsZWREdXJhdGlvbiA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFsbGVkO1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYHBsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEAke2N1cnJlbnRUaW1lfSwgYWZ0ZXIgJHtNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICBzdGFsbGVkRHVyYXRpb25cbiAgICAgICAgICAgICl9bXNgXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFyIHN0YWxsZWQgc3RhdGUgd2hlbiBiZWdpbm5pbmcgb3IgZmluaXNoaW5nIHNlZWtpbmcgc28gdGhhdCB3ZSBkb24ndCByZXBvcnQgc3RhbGxzIGNvbWluZyBvdXQgb2YgYSBzZWVrXG4gICAgaWYgKGJlZ2luU2VlayB8fCBzZWVrZWQpIHtcbiAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlIHBsYXloZWFkIHNob3VsZCBub3QgYmUgbW92aW5nXG4gICAgaWYgKFxuICAgICAgKG1lZGlhLnBhdXNlZCAmJiAhc2Vla2luZykgfHxcbiAgICAgIG1lZGlhLmVuZGVkIHx8XG4gICAgICBtZWRpYS5wbGF5YmFja1JhdGUgPT09IDAgfHxcbiAgICAgICFCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpLmxlbmd0aFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IGlzQnVmZmVyZWQgPSBidWZmZXJJbmZvLmxlbiA+IDA7XG4gICAgY29uc3QgbmV4dFN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQgfHwgMDtcblxuICAgIC8vIFRoZXJlIGlzIG5vIHBsYXlhYmxlIGJ1ZmZlciAoc2Vla2VkLCB3YWl0aW5nIGZvciBidWZmZXIpXG4gICAgaWYgKCFpc0J1ZmZlcmVkICYmICFuZXh0U3RhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2Vla2luZykge1xuICAgICAgLy8gV2FpdGluZyBmb3Igc2Vla2luZyBpbiBhIGJ1ZmZlcmVkIHJhbmdlIHRvIGNvbXBsZXRlXG4gICAgICBjb25zdCBoYXNFbm91Z2hCdWZmZXIgPSBidWZmZXJJbmZvLmxlbiA+IE1BWF9TVEFSVF9HQVBfSlVNUDtcbiAgICAgIC8vIE5leHQgYnVmZmVyZWQgcmFuZ2UgaXMgdG9vIGZhciBhaGVhZCB0byBqdW1wIHRvIHdoaWxlIHN0aWxsIHNlZWtpbmdcbiAgICAgIGNvbnN0IG5vQnVmZmVyR2FwID1cbiAgICAgICAgIW5leHRTdGFydCB8fFxuICAgICAgICAoYWN0aXZlRnJhZyAmJiBhY3RpdmVGcmFnLnN0YXJ0IDw9IGN1cnJlbnRUaW1lKSB8fFxuICAgICAgICAobmV4dFN0YXJ0IC0gY3VycmVudFRpbWUgPiBNQVhfU1RBUlRfR0FQX0pVTVAgJiZcbiAgICAgICAgICAhdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKSk7XG4gICAgICBpZiAoaGFzRW5vdWdoQnVmZmVyIHx8IG5vQnVmZmVyR2FwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlc2V0IG1vdmVkIHN0YXRlIHdoZW4gc2Vla2luZyB0byBhIHBvaW50IGluIG9yIGJlZm9yZSBhIGdhcFxuICAgICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNraXAgc3RhcnQgZ2FwcyBpZiB3ZSBoYXZlbid0IHBsYXllZCwgYnV0IHRoZSBsYXN0IHBvbGwgZGV0ZWN0ZWQgdGhlIHN0YXJ0IG9mIGEgc3RhbGxcbiAgICAvLyBUaGUgYWRkaXRpb24gcG9sbCBnaXZlcyB0aGUgYnJvd3NlciBhIGNoYW5jZSB0byBqdW1wIHRoZSBnYXAgZm9yIHVzXG4gICAgaWYgKCF0aGlzLm1vdmVkICYmIHRoaXMuc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgICAgLy8gSnVtcCBzdGFydCBnYXBzIHdpdGhpbiBqdW1wIHRocmVzaG9sZFxuICAgICAgY29uc3Qgc3RhcnRKdW1wID1cbiAgICAgICAgTWF0aC5tYXgobmV4dFN0YXJ0LCBidWZmZXJJbmZvLnN0YXJ0IHx8IDApIC0gY3VycmVudFRpbWU7XG5cbiAgICAgIC8vIFdoZW4gam9pbmluZyBhIGxpdmUgc3RyZWFtIHdpdGggYXVkaW8gdHJhY2tzLCBhY2NvdW50IGZvciBsaXZlIHBsYXlsaXN0IHdpbmRvdyBzbGlkaW5nIGJ5IGFsbG93aW5nXG4gICAgICAvLyBhIGxhcmdlciBqdW1wIG92ZXIgc3RhcnQgZ2FwcyBjYXVzZWQgYnkgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGJ1ZmZlcmluZyBhIHN0YXJ0IGZyYWdtZW50XG4gICAgICAvLyB0aGF0IGJlZ2lucyBvdmVyIDEgdGFyZ2V0IGR1cmF0aW9uIGFmdGVyIHRoZSB2aWRlbyBzdGFydCBwb3NpdGlvbi5cbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzXG4gICAgICAgID8gdGhpcy5obHMubGV2ZWxzW3RoaXMuaGxzLmN1cnJlbnRMZXZlbF1cbiAgICAgICAgOiBudWxsO1xuICAgICAgY29uc3QgaXNMaXZlID0gbGV2ZWw/LmRldGFpbHM/LmxpdmU7XG4gICAgICBjb25zdCBtYXhTdGFydEdhcEp1bXAgPSBpc0xpdmVcbiAgICAgICAgPyBsZXZlbCEuZGV0YWlscyEudGFyZ2V0ZHVyYXRpb24gKiAyXG4gICAgICAgIDogTUFYX1NUQVJUX0dBUF9KVU1QO1xuICAgICAgY29uc3QgcGFydGlhbE9yR2FwID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChzdGFydEp1bXAgPiAwICYmIChzdGFydEp1bXAgPD0gbWF4U3RhcnRHYXBKdW1wIHx8IHBhcnRpYWxPckdhcCkpIHtcbiAgICAgICAgdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbE9yR2FwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRyYWNraW5nIHN0YWxsIHRpbWVcbiAgICBjb25zdCB0bm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoc3RhbGxlZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gdG5vdztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFsbGVkRHVyYXRpb24gPSB0bm93IC0gc3RhbGxlZDtcbiAgICBpZiAoIXNlZWtpbmcgJiYgc3RhbGxlZER1cmF0aW9uID49IFNUQUxMX01JTklNVU1fRFVSQVRJT05fTVMpIHtcbiAgICAgIC8vIFJlcG9ydCBzdGFsbGluZyBhZnRlciB0cnlpbmcgdG8gZml4XG4gICAgICB0aGlzLl9yZXBvcnRTdGFsbChidWZmZXJJbmZvKTtcbiAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyZWRXaXRoSG9sZXMgPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhcbiAgICAgIG1lZGlhLFxuICAgICAgY3VycmVudFRpbWUsXG4gICAgICBjb25maWcubWF4QnVmZmVySG9sZVxuICAgICk7XG4gICAgdGhpcy5fdHJ5Rml4QnVmZmVyU3RhbGwoYnVmZmVyZWRXaXRoSG9sZXMsIHN0YWxsZWREdXJhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0cyBhbmQgYXR0ZW1wdHMgdG8gZml4IGtub3duIGJ1ZmZlciBzdGFsbGluZyBpc3N1ZXMuXG4gICAqIEBwYXJhbSBidWZmZXJJbmZvIC0gVGhlIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgYnVmZmVyLlxuICAgKiBAcGFyYW0gc3RhbGxlZER1cmF0aW9uTXMgLSBUaGUgYW1vdW50IG9mIHRpbWUgSGxzLmpzIGhhcyBiZWVuIHN0YWxsaW5nIGZvci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3RyeUZpeEJ1ZmZlclN0YWxsKFxuICAgIGJ1ZmZlckluZm86IEJ1ZmZlckluZm8sXG4gICAgc3RhbGxlZER1cmF0aW9uTXM6IG51bWJlclxuICApIHtcbiAgICBjb25zdCB7IGNvbmZpZywgZnJhZ21lbnRUcmFja2VyLCBtZWRpYSB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcblxuICAgIGNvbnN0IHBhcnRpYWwgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICBpZiAocGFydGlhbCkge1xuICAgICAgLy8gVHJ5IHRvIHNraXAgb3ZlciB0aGUgYnVmZmVyIGhvbGUgY2F1c2VkIGJ5IGEgcGFydGlhbCBmcmFnbWVudFxuICAgICAgLy8gVGhpcyBtZXRob2QgaXNuJ3QgbGltaXRlZCBieSB0aGUgc2l6ZSBvZiB0aGUgZ2FwIGJldHdlZW4gYnVmZmVyZWQgcmFuZ2VzXG4gICAgICBjb25zdCB0YXJnZXRUaW1lID0gdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbCk7XG4gICAgICAvLyB3ZSByZXR1cm4gaGVyZSBpbiB0aGlzIGNhc2UsIG1lYW5pbmdcbiAgICAgIC8vIHRoZSBicmFuY2ggYmVsb3cgb25seSBleGVjdXRlcyB3aGVuIHdlIGhhdmVuJ3Qgc2Vla2VkIHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICBpZiAodGFyZ2V0VGltZSB8fCAhdGhpcy5tZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZW4ndCBoYWQgdG8gc2tpcCBvdmVyIGEgYnVmZmVyIGhvbGUgb2YgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgLy8gd2UgbWF5IGp1c3QgaGF2ZSB0byBcIm51ZGdlXCIgdGhlIHBsYXlsaXN0IGFzIHRoZSBicm93c2VyIGRlY29kaW5nL3JlbmRlcmluZyBlbmdpbmVcbiAgICAvLyBuZWVkcyB0byBjcm9zcyBzb21lIHNvcnQgb2YgdGhyZXNob2xkIGNvdmVyaW5nIGFsbCBzb3VyY2UtYnVmZmVycyBjb250ZW50XG4gICAgLy8gdG8gc3RhcnQgcGxheWluZyBwcm9wZXJseS5cbiAgICBpZiAoXG4gICAgICAoYnVmZmVySW5mby5sZW4gPiBjb25maWcubWF4QnVmZmVySG9sZSB8fFxuICAgICAgICAoYnVmZmVySW5mby5uZXh0U3RhcnQgJiZcbiAgICAgICAgICBidWZmZXJJbmZvLm5leHRTdGFydCAtIGN1cnJlbnRUaW1lIDwgY29uZmlnLm1heEJ1ZmZlckhvbGUpKSAmJlxuICAgICAgc3RhbGxlZER1cmF0aW9uTXMgPiBjb25maWcuaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kICogMTAwMFxuICAgICkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1RyeWluZyB0byBudWRnZSBwbGF5aGVhZCBvdmVyIGJ1ZmZlci1ob2xlJyk7XG4gICAgICAvLyBUcnkgdG8gbnVkZ2UgY3VycmVudFRpbWUgb3ZlciBhIGJ1ZmZlciBob2xlIGlmIHdlJ3ZlIGJlZW4gc3RhbGxpbmcgZm9yIHRoZSBjb25maWd1cmVkIGFtb3VudCBvZiBzZWNvbmRzXG4gICAgICAvLyBXZSBvbmx5IHRyeSB0byBqdW1wIHRoZSBob2xlIGlmIGl0J3MgdW5kZXIgdGhlIGNvbmZpZ3VyZWQgc2l6ZVxuICAgICAgLy8gUmVzZXQgc3RhbGxlZCBzbyB0byByZWFybSB3YXRjaGRvZyB0aW1lclxuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgIHRoaXMuX3RyeU51ZGdlQnVmZmVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgQlVGRkVSX1NUQUxMRURfRVJST1IgZXZlbnQsIGJ1dCBvbmx5IG9uY2UgcGVyIHN0YWxsIHBlcmlvZC5cbiAgICogQHBhcmFtIGJ1ZmZlckxlbiAtIFRoZSBwbGF5aGVhZCBkaXN0YW5jZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIHNlZ21lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF9yZXBvcnRTdGFsbChidWZmZXJJbmZvOiBCdWZmZXJJbmZvKSB7XG4gICAgY29uc3QgeyBobHMsIG1lZGlhLCBzdGFsbFJlcG9ydGVkIH0gPSB0aGlzO1xuICAgIGlmICghc3RhbGxSZXBvcnRlZCAmJiBtZWRpYSkge1xuICAgICAgLy8gUmVwb3J0IHN0YWxsZWQgZXJyb3Igb25jZVxuICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBgUGxheWJhY2sgc3RhbGxpbmcgYXQgQCR7XG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWVcbiAgICAgICAgfSBkdWUgdG8gbG93IGJ1ZmZlciAoJHtKU09OLnN0cmluZ2lmeShidWZmZXJJbmZvKX0pYFxuICAgICAgKTtcbiAgICAgIGxvZ2dlci53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgYnVmZmVyOiBidWZmZXJJbmZvLmxlbixcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBqdW1waW5nIG92ZXIga25vd24gZ2FwcyBjYXVzZWQgYnkgcGFydGlhbCBmcmFnbWVudHNcbiAgICogQHBhcmFtIHBhcnRpYWwgLSBUaGUgcGFydGlhbCBmcmFnbWVudCBmb3VuZCBhdCB0aGUgY3VycmVudCB0aW1lICh3aGVyZSBwbGF5YmFjayBpcyBzdGFsbGluZykuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF90cnlTa2lwQnVmZmVySG9sZShwYXJ0aWFsOiBGcmFnbWVudCB8IG51bGwpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgY29uZmlnLCBobHMsIG1lZGlhIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgY3VycmVudFRpbWUgaXMgYmV0d2VlbiB1bmJ1ZmZlcmVkIHJlZ2lvbnMgb2YgcGFydGlhbCBmcmFnbWVudHNcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9XG4gICAgICBjdXJyZW50VGltZSA8IGJ1ZmZlckluZm8uc3RhcnQgPyBidWZmZXJJbmZvLnN0YXJ0IDogYnVmZmVySW5mby5uZXh0U3RhcnQ7XG4gICAgaWYgKHN0YXJ0VGltZSkge1xuICAgICAgY29uc3QgYnVmZmVyU3RhcnZlZCA9IGJ1ZmZlckluZm8ubGVuIDw9IGNvbmZpZy5tYXhCdWZmZXJIb2xlO1xuICAgICAgY29uc3Qgd2FpdGluZyA9XG4gICAgICAgIGJ1ZmZlckluZm8ubGVuID4gMCAmJiBidWZmZXJJbmZvLmxlbiA8IDEgJiYgbWVkaWEucmVhZHlTdGF0ZSA8IDM7XG4gICAgICBjb25zdCBnYXBMZW5ndGggPSBzdGFydFRpbWUgLSBjdXJyZW50VGltZTtcbiAgICAgIGlmIChnYXBMZW5ndGggPiAwICYmIChidWZmZXJTdGFydmVkIHx8IHdhaXRpbmcpKSB7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgbGFyZ2UgZ2FwcyB0byBiZSBza2lwcGVkIGlmIGl0IGlzIGEgc3RhcnQgZ2FwLCBvciBhbGwgZnJhZ21lbnRzIGluIHNraXAgcmFuZ2UgYXJlIHBhcnRpYWxcbiAgICAgICAgaWYgKGdhcExlbmd0aCA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlKSB7XG4gICAgICAgICAgY29uc3QgeyBmcmFnbWVudFRyYWNrZXIgfSA9IHRoaXM7XG4gICAgICAgICAgbGV0IHN0YXJ0R2FwID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGN1cnJlbnRUaW1lID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydEZyYWcgPSBmcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBQbGF5bGlzdExldmVsVHlwZS5NQUlOXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHN0YXJ0RnJhZyAmJiBzdGFydFRpbWUgPCBzdGFydEZyYWcuZW5kKSB7XG4gICAgICAgICAgICAgIHN0YXJ0R2FwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdGFydEdhcCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRQcm92aXNpb25lZCA9XG4gICAgICAgICAgICAgIHBhcnRpYWwgfHxcbiAgICAgICAgICAgICAgZnJhZ21lbnRUcmFja2VyLmdldEFwcGVuZGVkRnJhZyhcbiAgICAgICAgICAgICAgICBjdXJyZW50VGltZSxcbiAgICAgICAgICAgICAgICBQbGF5bGlzdExldmVsVHlwZS5NQUlOXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoc3RhcnRQcm92aXNpb25lZCkge1xuICAgICAgICAgICAgICBsZXQgbW9yZVRvTG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBsZXQgcG9zID0gc3RhcnRQcm92aXNpb25lZC5lbmQ7XG4gICAgICAgICAgICAgIHdoaWxlIChwb3MgPCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm92aXNpb25lZCA9IGZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlzaW9uZWQpIHtcbiAgICAgICAgICAgICAgICAgIHBvcyArPSBwcm92aXNpb25lZC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbW9yZVRvTG9hZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1vcmVUb0xvYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRUaW1lID0gTWF0aC5tYXgoXG4gICAgICAgICAgc3RhcnRUaW1lICsgU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQsXG4gICAgICAgICAgY3VycmVudFRpbWUgKyBTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EU1xuICAgICAgICApO1xuICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICBgc2tpcHBpbmcgaG9sZSwgYWRqdXN0aW5nIGN1cnJlbnRUaW1lIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHt0YXJnZXRUaW1lfWBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcbiAgICAgICAgaWYgKHBhcnRpYWwgJiYgIXBhcnRpYWwuZ2FwKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgZnJhZ21lbnQgbG9hZGVkIHdpdGggYnVmZmVyIGhvbGVzLCBzZWVraW5nIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHt0YXJnZXRUaW1lfWBcbiAgICAgICAgICApO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGZyYWc6IHBhcnRpYWwsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFRpbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGFkdmFuY2luZyB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lIGJ5IGEgc21hbGwgYW1vdW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfdHJ5TnVkZ2VCdWZmZXIoKSB7XG4gICAgY29uc3QgeyBjb25maWcsIGhscywgbWVkaWEsIG51ZGdlUmV0cnkgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgdGhpcy5udWRnZVJldHJ5Kys7XG5cbiAgICBpZiAobnVkZ2VSZXRyeSA8IGNvbmZpZy5udWRnZU1heFJldHJ5KSB7XG4gICAgICBjb25zdCB0YXJnZXRUaW1lID0gY3VycmVudFRpbWUgKyAobnVkZ2VSZXRyeSArIDEpICogY29uZmlnLm51ZGdlT2Zmc2V0O1xuICAgICAgLy8gcGxheWJhY2sgc3RhbGxlZCBpbiBidWZmZXJlZCBhcmVhIC4uLiBsZXQncyBudWRnZSBjdXJyZW50VGltZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBOdWRnaW5nICdjdXJyZW50VGltZScgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3RhcmdldFRpbWV9YFxuICAgICAgKTtcbiAgICAgIGxvZ2dlci53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEwsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBQbGF5aGVhZCBzdGlsbCBub3QgbW92aW5nIHdoaWxlIGVub3VnaCBkYXRhIGJ1ZmZlcmVkIEAke2N1cnJlbnRUaW1lfSBhZnRlciAke2NvbmZpZy5udWRnZU1heFJldHJ5fSBudWRnZXNgXG4gICAgICApO1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgQmFzZVN0cmVhbUNvbnRyb2xsZXIsIHsgU3RhdGUgfSBmcm9tICcuL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgY2hhbmdlVHlwZVN1cHBvcnRlZCB9IGZyb20gJy4uL2lzLXN1cHBvcnRlZCc7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgQnVmZmVySGVscGVyLCBCdWZmZXJJbmZvIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgeyBGcmFnbWVudFN0YXRlIH0gZnJvbSAnLi9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCB7IFBsYXlsaXN0Q29udGV4dFR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7IEVsZW1lbnRhcnlTdHJlYW1UeXBlcywgRnJhZ21lbnQgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IFRyYW5zbXV4ZXJJbnRlcmZhY2UgZnJvbSAnLi4vZGVtdXgvdHJhbnNtdXhlci1pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ2h1bmtNZXRhZGF0YSB9IGZyb20gJy4uL3R5cGVzL3RyYW5zbXV4ZXInO1xuaW1wb3J0IEdhcENvbnRyb2xsZXIgZnJvbSAnLi9nYXAtY29udHJvbGxlcic7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHR5cGUgeyBOZXR3b3JrQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgTGV2ZWwgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgdHlwZSB7IExldmVsRGV0YWlscyB9IGZyb20gJy4uL2xvYWRlci9sZXZlbC1kZXRhaWxzJztcbmltcG9ydCB0eXBlIHsgRnJhZ21lbnRUcmFja2VyIH0gZnJvbSAnLi9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCB0eXBlIEtleUxvYWRlciBmcm9tICcuLi9sb2FkZXIva2V5LWxvYWRlcic7XG5pbXBvcnQgdHlwZSB7IFRyYW5zbXV4ZXJSZXN1bHQgfSBmcm9tICcuLi90eXBlcy90cmFuc211eGVyJztcbmltcG9ydCB0eXBlIHsgVHJhY2tTZXQgfSBmcm9tICcuLi90eXBlcy90cmFjayc7XG5pbXBvcnQgdHlwZSB7IFNvdXJjZUJ1ZmZlck5hbWUgfSBmcm9tICcuLi90eXBlcy9idWZmZXInO1xuaW1wb3J0IHR5cGUge1xuICBBdWRpb1RyYWNrU3dpdGNoZWREYXRhLFxuICBBdWRpb1RyYWNrU3dpdGNoaW5nRGF0YSxcbiAgQnVmZmVyQ3JlYXRlZERhdGEsXG4gIEJ1ZmZlckVPU0RhdGEsXG4gIEJ1ZmZlckZsdXNoZWREYXRhLFxuICBFcnJvckRhdGEsXG4gIEZyYWdCdWZmZXJlZERhdGEsXG4gIEZyYWdMb2FkZWREYXRhLFxuICBGcmFnUGFyc2luZ01ldGFkYXRhRGF0YSxcbiAgRnJhZ1BhcnNpbmdVc2VyZGF0YURhdGEsXG4gIExldmVsTG9hZGVkRGF0YSxcbiAgTGV2ZWxMb2FkaW5nRGF0YSxcbiAgTGV2ZWxzVXBkYXRlZERhdGEsXG4gIE1hbmlmZXN0UGFyc2VkRGF0YSxcbiAgTWVkaWFBdHRhY2hlZERhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwgPSAxMDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmVhbUNvbnRyb2xsZXJcbiAgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlclxuICBpbXBsZW1lbnRzIE5ldHdvcmtDb21wb25lbnRBUElcbntcbiAgcHJpdmF0ZSBhdWRpb0NvZGVjU3dhcDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGdhcENvbnRyb2xsZXI6IEdhcENvbnRyb2xsZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBsZXZlbDogbnVtYmVyID0gLTE7XG4gIHByaXZhdGUgX2ZvcmNlU3RhcnRMb2FkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgYWx0QXVkaW86IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBhdWRpb09ubHk6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBmcmFnUGxheWluZzogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBvbnZwbGF5aW5nOiBFdmVudExpc3RlbmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgb252c2Vla2VkOiBFdmVudExpc3RlbmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZnJhZ0xhc3RLYnBzOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIGNvdWxkQmFja3RyYWNrOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgYmFja3RyYWNrRnJhZ21lbnQ6IEZyYWdtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgYXVkaW9Db2RlY1N3aXRjaDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIHZpZGVvQnVmZmVyOiBhbnkgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBobHM6IEhscyxcbiAgICBmcmFnbWVudFRyYWNrZXI6IEZyYWdtZW50VHJhY2tlcixcbiAgICBrZXlMb2FkZXI6IEtleUxvYWRlclxuICApIHtcbiAgICBzdXBlcihcbiAgICAgIGhscyxcbiAgICAgIGZyYWdtZW50VHJhY2tlcixcbiAgICAgIGtleUxvYWRlcixcbiAgICAgICdbc3RyZWFtLWNvbnRyb2xsZXJdJyxcbiAgICAgIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU5cbiAgICApO1xuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihcbiAgICAgIEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsXG4gICAgICB0aGlzLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkLFxuICAgICAgdGhpc1xuICAgICk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKFxuICAgICAgRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCxcbiAgICAgIHRoaXMub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoaW5nKCk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb246IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmxldmVscykge1xuICAgICAgY29uc3QgeyBsYXN0Q3VycmVudFRpbWUsIGhscyB9ID0gdGhpcztcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXG4gICAgICAgIGxldCBzdGFydExldmVsID0gaGxzLnN0YXJ0TGV2ZWw7XG4gICAgICAgIGlmIChzdGFydExldmVsID09PSAtMSkge1xuICAgICAgICAgIGlmIChobHMuY29uZmlnLnRlc3RCYW5kd2lkdGggJiYgdGhpcy5sZXZlbHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gLTEgOiBndWVzcyBzdGFydCBMZXZlbCBieSBkb2luZyBhIGJpdHJhdGUgdGVzdCBieSBsb2FkaW5nIGZpcnN0IGZyYWdtZW50IG9mIGxvd2VzdCBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydExldmVsID0gaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBuZXcgbGV2ZWwgdG8gcGxheWxpc3QgbG9hZGVyIDogdGhpcyB3aWxsIHRyaWdnZXIgc3RhcnQgbGV2ZWwgbG9hZFxuICAgICAgICAvLyBobHMubmV4dExvYWRMZXZlbCByZW1haW5zIHVudGlsIGl0IGlzIHNldCB0byBhIG5ldyB2YWx1ZSBvciB1bnRpbCBhIG5ldyBmcmFnIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWRcbiAgICAgICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gc3RhcnRMZXZlbDtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiB1bmRlZmluZWQgYnV0IGxhc3RDdXJyZW50VGltZSBzZXQsIHNldCBzdGFydFBvc2l0aW9uIHRvIGxhc3QgY3VycmVudFRpbWVcbiAgICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgIGBPdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKFxuICAgICAgICAgICAgM1xuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPVxuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPVxuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9XG4gICAgICAgICAgc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcbiAgICBzdXBlci5zdG9wTG9hZCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRvVGljaygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19MRVZFTDoge1xuICAgICAgICBjb25zdCB7IGxldmVscywgbGV2ZWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBsZXZlbHM/LltsZXZlbF0/LmRldGFpbHM7XG4gICAgICAgIGlmIChkZXRhaWxzICYmICghZGV0YWlscy5saXZlIHx8IHRoaXMubGV2ZWxMYXN0TG9hZGVkID09PSB0aGlzLmxldmVsKSkge1xuICAgICAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGNvbnN0IHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCB0aGlzLm1lZGlhPy5zZWVraW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKHRoaXMubGV2ZWwpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICB9XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblRpY2tFbmQoKSB7XG4gICAgc3VwZXIub25UaWNrRW5kKCk7XG4gICAgdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgIHRoaXMuY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgfVxuXG4gIHByaXZhdGUgZG9UaWNrSWRsZSgpIHtcbiAgICBjb25zdCB7IGhscywgbGV2ZWxMYXN0TG9hZGVkLCBsZXZlbHMsIG1lZGlhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY29uZmlnLCBuZXh0TG9hZExldmVsOiBsZXZlbCB9ID0gaGxzO1xuXG4gICAgLy8gaWYgc3RhcnQgbGV2ZWwgbm90IHBhcnNlZCB5ZXQgT1JcbiAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAvLyBleGl0IGxvb3AsIGFzIHdlIGVpdGhlciBuZWVkIG1vcmUgaW5mbyAobGV2ZWwgbm90IHBhcnNlZCkgb3Igd2UgbmVlZCBtZWRpYSB0byBiZSBhdHRhY2hlZCB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgIGlmIChcbiAgICAgIGxldmVsTGFzdExvYWRlZCA9PT0gbnVsbCB8fFxuICAgICAgKCFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIFwibWFpblwiIGxldmVsIGlzIGF1ZGlvLW9ubHkgYnV0IHdlIGFyZSBsb2FkaW5nIGFuIGFsdGVybmF0ZSB0cmFjayBpbiB0aGUgc2FtZSBncm91cCwgZG8gbm90IGxvYWQgYW55dGhpbmdcbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiB0aGlzLmF1ZGlvT25seSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghbGV2ZWxzPy5bbGV2ZWxdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGV2ZWxJbmZvID0gbGV2ZWxzW2xldmVsXTtcblxuICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICBpZiAoYnVmZmVySW5mbyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3REZXRhaWxzID0gdGhpcy5nZXRMZXZlbERldGFpbHMoKTtcbiAgICBpZiAobGFzdERldGFpbHMgJiYgdGhpcy5fc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgbGFzdERldGFpbHMpKSB7XG4gICAgICBjb25zdCBkYXRhOiBCdWZmZXJFT1NEYXRhID0ge307XG4gICAgICBpZiAodGhpcy5hbHRBdWRpbykge1xuICAgICAgICBkYXRhLnR5cGUgPSAndmlkZW8nO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRU9TLCBkYXRhKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgbmV4dCBsb2FkIGxldmVsIDogdGhpcyB3aWxsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkIGlmIG5lZWRlZFxuICAgIGlmIChobHMubG9hZExldmVsICE9PSBsZXZlbCAmJiBobHMubWFudWFsTGV2ZWwgPT09IC0xKSB7XG4gICAgICB0aGlzLmxvZyhgQWRhcHRpbmcgdG8gbGV2ZWwgJHtsZXZlbH0gZnJvbSBsZXZlbCAke3RoaXMubGV2ZWx9YCk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuXG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcbiAgICAvLyBhIHVzZWxlc3MgYW5kIG91dGRhdGVkIGZyYWdtZW50ICh0aGF0IG1pZ2h0IGV2ZW4gaW50cm9kdWNlIGxvYWQgZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBvdXQgb2YgdGhlIGxpdmUgcGxheWxpc3QpXG4gICAgaWYgKFxuICAgICAgIWxldmVsRGV0YWlscyB8fFxuICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCB8fFxuICAgICAgKGxldmVsRGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBsZXZlbClcbiAgICApIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuXG4gICAgLy8gY29tcHV0ZSBtYXggQnVmZmVyIExlbmd0aCB0aGF0IHdlIGNvdWxkIGdldCBmcm9tIHRoaXMgbG9hZCBsZXZlbCwgYmFzZWQgb24gbGV2ZWwgYml0cmF0ZS4gZG9uJ3QgYnVmZmVyIG1vcmUgdGhhbiA2MCBNQiBhbmQgbW9yZSB0aGFuIDMwc1xuICAgIGNvbnN0IG1heEJ1ZkxlbiA9IHRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKGxldmVsSW5mby5tYXhCaXRyYXRlKTtcblxuICAgIC8vIFN0YXkgaWRsZSBpZiB3ZSBhcmUgc3RpbGwgd2l0aCBidWZmZXIgbWFyZ2luc1xuICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCAmJlxuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudC5zdGFydCA+IGJ1ZmZlckluZm8uZW5kXG4gICAgKSB7XG4gICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0QnVmZmVyVGltZSA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnRcbiAgICAgID8gdGhpcy5iYWNrdHJhY2tGcmFnbWVudC5zdGFydFxuICAgICAgOiBidWZmZXJJbmZvLmVuZDtcbiAgICBsZXQgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50KHRhcmdldEJ1ZmZlclRpbWUsIGxldmVsRGV0YWlscyk7XG4gICAgLy8gQXZvaWQgYmFja3RyYWNraW5nIGJ5IGxvYWRpbmcgYW4gZWFybGllciBzZWdtZW50IGluIHN0cmVhbXMgd2l0aCBzZWdtZW50cyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGEga2V5IGZyYW1lIChmbGFnZ2VkIGJ5IGBjb3VsZEJhY2t0cmFja2ApXG4gICAgaWYgKFxuICAgICAgdGhpcy5jb3VsZEJhY2t0cmFjayAmJlxuICAgICAgIXRoaXMuZnJhZ1ByZXZpb3VzICYmXG4gICAgICBmcmFnICYmXG4gICAgICBmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnICYmXG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSAhPT0gRnJhZ21lbnRTdGF0ZS5PS1xuICAgICkge1xuICAgICAgY29uc3QgYmFja3RyYWNrU24gPSAodGhpcy5iYWNrdHJhY2tGcmFnbWVudCA/PyBmcmFnKS5zbiBhcyBudW1iZXI7XG4gICAgICBjb25zdCBmcmFnSWR4ID0gYmFja3RyYWNrU24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgIGNvbnN0IGJhY2t0cmFja0ZyYWcgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2ZyYWdJZHggLSAxXTtcbiAgICAgIGlmIChiYWNrdHJhY2tGcmFnICYmIGZyYWcuY2MgPT09IGJhY2t0cmFja0ZyYWcuY2MpIHtcbiAgICAgICAgZnJhZyA9IGJhY2t0cmFja0ZyYWc7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGJhY2t0cmFja0ZyYWcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrdHJhY2tGcmFnbWVudCAmJiBidWZmZXJJbmZvLmxlbikge1xuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgfVxuICAgIC8vIEF2b2lkIGxvb3AgbG9hZGluZyBieSB1c2luZyBuZXh0TG9hZFBvc2l0aW9uIHNldCBmb3IgYmFja3RyYWNraW5nIGFuZCBza2lwcGluZyBjb25zZWN1dGl2ZSBHQVAgdGFnc1xuICAgIGlmIChmcmFnICYmIHRoaXMuaXNMb29wTG9hZGluZyhmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKSkge1xuICAgICAgY29uc3QgZ2FwU3RhcnQgPSBmcmFnLmdhcDtcbiAgICAgIGlmICghZ2FwU3RhcnQpIHtcbiAgICAgICAgLy8gQ2xlYW51cCB0aGUgZnJhZ21lbnQgdHJhY2tlciBiZWZvcmUgdHJ5aW5nIHRvIGZpbmQgdGhlIG5leHQgdW5idWZmZXJlZCBmcmFnbWVudFxuICAgICAgICBjb25zdCB0eXBlID1cbiAgICAgICAgICB0aGlzLmF1ZGlvT25seSAmJiAhdGhpcy5hbHRBdWRpb1xuICAgICAgICAgICAgPyBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9cbiAgICAgICAgICAgIDogRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPO1xuICAgICAgICBjb25zdCBtZWRpYUJ1ZmZlciA9XG4gICAgICAgICAgKHR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT1xuICAgICAgICAgICAgPyB0aGlzLnZpZGVvQnVmZmVyXG4gICAgICAgICAgICA6IHRoaXMubWVkaWFCdWZmZXIpIHx8IHRoaXMubWVkaWE7XG4gICAgICAgIGlmIChtZWRpYUJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhQnVmZmVyLCB0eXBlLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50TG9vcExvYWRpbmcoXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGxldmVsRGV0YWlscyxcbiAgICAgICAgYnVmZmVySW5mbyxcbiAgICAgICAgUGxheWxpc3RMZXZlbFR5cGUuTUFJTixcbiAgICAgICAgbWF4QnVmTGVuXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZyYWcuaW5pdFNlZ21lbnQgJiYgIWZyYWcuaW5pdFNlZ21lbnQuZGF0YSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgZnJhZyA9IGZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxJbmZvLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBsb2FkRnJhZ21lbnQoXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAgbGV2ZWw6IExldmVsLFxuICAgIHRhcmdldEJ1ZmZlclRpbWU6IG51bWJlclxuICApIHtcbiAgICAvLyBDaGVjayBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgY29uc3QgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgaWYgKFxuICAgICAgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQgfHxcbiAgICAgIGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMXG4gICAgKSB7XG4gICAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB0aGlzLl9sb2FkSW5pdFNlZ21lbnQoZnJhZywgbGV2ZWwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgIGBGcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gaXMgYmVpbmcgZG93bmxvYWRlZCB0byB0ZXN0IGJpdHJhdGUgYW5kIHdpbGwgbm90IGJlIGJ1ZmZlcmVkYFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9sb2FkQml0cmF0ZVRlc3RGcmFnKGZyYWcsIGxldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIubG9hZEZyYWdtZW50KGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclRyYWNrZXJJZk5lZWRlZChmcmFnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRCdWZmZXJlZEZyYWcoXG4gICAgICBwb3NpdGlvbixcbiAgICAgIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU5cbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBmb2xsb3dpbmdCdWZmZXJlZEZyYWcoZnJhZzogRnJhZ21lbnQgfCBudWxsKSB7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcbiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhmcmFnLmVuZCArIDAuNSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLypcbiAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIDpcbiAgICAgLSBwYXVzZSBwbGF5YmFjayBpZiBwbGF5aW5nXG4gICAgIC0gY2FuY2VsIGFueSBwZW5kaW5nIGxvYWQgcmVxdWVzdFxuICAgICAtIGFuZCB0cmlnZ2VyIGEgYnVmZmVyIGZsdXNoXG4gICovXG4gIHB1YmxpYyBpbW1lZGlhdGVMZXZlbFN3aXRjaCgpIHtcbiAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrOlxuICAgKiBpbiBvcmRlciB0byBlbnN1cmUgc21vb3RoIGJ1dCBxdWljayBsZXZlbCBzd2l0Y2hpbmcsXG4gICAqIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAqIHdlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBuZXcgc2VnbWVudCBmZXRjaCB0aW1lXG4gICAqL1xuICBwdWJsaWMgbmV4dExldmVsU3dpdGNoKCkge1xuICAgIGNvbnN0IHsgbGV2ZWxzLCBtZWRpYSB9ID0gdGhpcztcbiAgICAvLyBlbnN1cmUgdGhhdCBtZWRpYSBpcyBkZWZpbmVkIGFuZCB0aGF0IG1ldGFkYXRhIGFyZSBhdmFpbGFibGUgKHRvIHJldHJpZXZlIGN1cnJlbnRUaW1lKVxuICAgIGlmIChtZWRpYT8ucmVhZHlTdGF0ZSkge1xuICAgICAgbGV0IGZldGNoZGVsYXk7XG4gICAgICBjb25zdCBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50ICYmIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydCA+IDEpIHtcbiAgICAgICAgLy8gZmx1c2ggYnVmZmVyIHByZWNlZGluZyBjdXJyZW50IGZyYWdtZW50IChmbHVzaCB1bnRpbCBjdXJyZW50IGZyYWdtZW50IHN0YXJ0IG9mZnNldClcbiAgICAgICAgLy8gbWludXMgMXMgdG8gYXZvaWQgdmlkZW8gZnJlZXppbmcsIHRoYXQgY291bGQgaGFwcGVuIGlmIHdlIGZsdXNoIGtleWZyYW1lIG9mIGN1cnJlbnQgdmlkZW8gLi4uXG4gICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydCAtIDEpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gdGhpcy5nZXRMZXZlbERldGFpbHMoKTtcbiAgICAgIGlmIChsZXZlbERldGFpbHM/LmxpdmUpIHtcbiAgICAgICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICAgICAgLy8gRG8gbm90IGZsdXNoIGluIGxpdmUgc3RyZWFtIHdpdGggbG93IGJ1ZmZlclxuICAgICAgICBpZiAoIWJ1ZmZlckluZm8gfHwgYnVmZmVySW5mby5sZW4gPCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW1lZGlhLnBhdXNlZCAmJiBsZXZlbHMpIHtcbiAgICAgICAgLy8gYWRkIGEgc2FmZXR5IGRlbGF5IG9mIDFzXG4gICAgICAgIGNvbnN0IG5leHRMZXZlbElkID0gdGhpcy5obHMubmV4dExvYWRMZXZlbDtcbiAgICAgICAgY29uc3QgbmV4dExldmVsID0gbGV2ZWxzW25leHRMZXZlbElkXTtcbiAgICAgICAgY29uc3QgZnJhZ0xhc3RLYnBzID0gdGhpcy5mcmFnTGFzdEticHM7XG4gICAgICAgIGlmIChmcmFnTGFzdEticHMgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICAgIGZldGNoZGVsYXkgPVxuICAgICAgICAgICAgKHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gKiBuZXh0TGV2ZWwubWF4Qml0cmF0ZSkgL1xuICAgICAgICAgICAgICAoMTAwMCAqIGZyYWdMYXN0S2JwcykgK1xuICAgICAgICAgICAgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICB9XG4gICAgICAvLyB0aGlzLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xuICAgICAgLy8gZmluZCBidWZmZXIgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlYWNoZWQgb25jZSBuZXcgZnJhZ21lbnQgd2lsbCBiZSBmZXRjaGVkXG4gICAgICBjb25zdCBidWZmZXJlZEZyYWcgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSArIGZldGNoZGVsYXkpO1xuICAgICAgaWYgKGJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAvLyB3ZSBjYW4gZmx1c2ggYnVmZmVyIHJhbmdlIGZvbGxvd2luZyB0aGlzIG9uZSB3aXRob3V0IHN0YWxsaW5nIHBsYXliYWNrXG4gICAgICAgIGNvbnN0IG5leHRCdWZmZXJlZEZyYWcgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhidWZmZXJlZEZyYWcpO1xuICAgICAgICBpZiAobmV4dEJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAgIC8vIGlmIHdlIGFyZSBoZXJlLCB3ZSBjYW4gYWxzbyBjYW5jZWwgYW55IGxvYWRpbmcvZGVtdXhpbmcgaW4gcHJvZ3Jlc3MsIGFzIHRoZXkgYXJlIHVzZWxlc3NcbiAgICAgICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgICAgICAvLyBzdGFydCBmbHVzaCBwb3NpdGlvbiBpcyBpbiBuZXh0IGJ1ZmZlcmVkIGZyYWcuIExlYXZlIHNvbWUgcGFkZGluZyBmb3Igbm9uLWluZGVwZW5kZW50IHNlZ21lbnRzIGFuZCBzbW9vdGhlciBwbGF5YmFjay5cbiAgICAgICAgICBjb25zdCBtYXhTdGFydCA9IG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFNcbiAgICAgICAgICAgID8gbmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUU1xuICAgICAgICAgICAgOiBuZXh0QnVmZmVyZWRGcmFnLnN0YXJ0O1xuICAgICAgICAgIGNvbnN0IGZyYWdEdXJhdGlvbiA9IG5leHRCdWZmZXJlZEZyYWcuZHVyYXRpb247XG4gICAgICAgICAgY29uc3Qgc3RhcnRQdHMgPSBNYXRoLm1heChcbiAgICAgICAgICAgIGJ1ZmZlcmVkRnJhZy5lbmQsXG4gICAgICAgICAgICBtYXhTdGFydCArXG4gICAgICAgICAgICAgIE1hdGgubWluKFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgZnJhZ0R1cmF0aW9uIC0gdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSxcbiAgICAgICAgICAgICAgICAgIGZyYWdEdXJhdGlvbiAqIDAuNVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZnJhZ0R1cmF0aW9uICogMC43NVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzdGFydFB0cywgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYWJvcnRDdXJyZW50RnJhZygpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICBmcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnQ3VycmVudCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBTdGF0ZS5LRVlfTE9BRElORzpcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZmx1c2hNYWluQnVmZmVyKHN0YXJ0T2Zmc2V0OiBudW1iZXIsIGVuZE9mZnNldDogbnVtYmVyKSB7XG4gICAgc3VwZXIuZmx1c2hNYWluQnVmZmVyKFxuICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICBlbmRPZmZzZXQsXG4gICAgICB0aGlzLmFsdEF1ZGlvID8gJ3ZpZGVvJyA6IG51bGxcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFBdHRhY2hlZChcbiAgICBldmVudDogRXZlbnRzLk1FRElBX0FUVEFDSEVELFxuICAgIGRhdGE6IE1lZGlhQXR0YWNoZWREYXRhXG4gICkge1xuICAgIHN1cGVyLm9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSk7XG4gICAgY29uc3QgbWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252cGxheWluZyA9IHRoaXMub25NZWRpYVBsYXlpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udnNlZWtlZCA9IHRoaXMub25NZWRpYVNlZWtlZC5iaW5kKHRoaXMpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9udnBsYXlpbmcgYXMgRXZlbnRMaXN0ZW5lcik7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQgYXMgRXZlbnRMaXN0ZW5lcik7XG4gICAgdGhpcy5nYXBDb250cm9sbGVyID0gbmV3IEdhcENvbnRyb2xsZXIoXG4gICAgICB0aGlzLmNvbmZpZyxcbiAgICAgIG1lZGlhLFxuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIsXG4gICAgICB0aGlzLmhsc1xuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBjb25zdCB7IG1lZGlhIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSAmJiB0aGlzLm9udnBsYXlpbmcgJiYgdGhpcy5vbnZzZWVrZWQpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9udnBsYXlpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgdGhpcy5vbnZwbGF5aW5nID0gdGhpcy5vbnZzZWVrZWQgPSBudWxsO1xuICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICAgIGlmICh0aGlzLmdhcENvbnRyb2xsZXIpIHtcbiAgICAgIHRoaXMuZ2FwQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBudWxsO1xuICAgIH1cbiAgICBzdXBlci5vbk1lZGlhRGV0YWNoaW5nKCk7XG4gIH1cblxuICBwcml2YXRlIG9uTWVkaWFQbGF5aW5nKCkge1xuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR19DSEFOR0VEIHRyaWdnZXJpbmdcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIHByaXZhdGUgb25NZWRpYVNlZWtlZCgpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogbnVsbDtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGN1cnJlbnRUaW1lKSkge1xuICAgICAgdGhpcy5sb2coYE1lZGlhIHNlZWtlZCB0byAkeyhjdXJyZW50VGltZSBhcyBudW1iZXIpLnRvRml4ZWQoMyl9YCk7XG4gICAgfVxuXG4gICAgLy8gSWYgc2Vla2VkIHdhcyBpc3N1ZWQgYmVmb3JlIGJ1ZmZlciB3YXMgYXBwZW5kZWQgZG8gbm90IHRpY2sgaW1tZWRpYXRlbHlcbiAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsIHx8IGJ1ZmZlckluZm8ubGVuID09PSAwKSB7XG4gICAgICB0aGlzLndhcm4oXG4gICAgICAgIGBNYWluIGZvcndhcmQgYnVmZmVyIGxlbmd0aCBvbiBcInNlZWtlZFwiIGV2ZW50ICR7XG4gICAgICAgICAgYnVmZmVySW5mbyA/IGJ1ZmZlckluZm8ubGVuIDogJ2VtcHR5J1xuICAgICAgICB9KWBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHX0NIQU5HRUQgdHJpZ2dlcmluZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAvLyByZXNldCBidWZmZXIgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgIHRoaXMubG9nKCdUcmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9SRVNFVCwgdW5kZWZpbmVkKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMubGV2ZWxzID0gdGhpcy5mcmFnUGxheWluZyA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgIHRoaXMuYWx0QXVkaW8gPSB0aGlzLmF1ZGlvT25seSA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0UGFyc2VkKFxuICAgIGV2ZW50OiBFdmVudHMuTUFOSUZFU1RfUEFSU0VELFxuICAgIGRhdGE6IE1hbmlmZXN0UGFyc2VkRGF0YVxuICApIHtcbiAgICBsZXQgYWFjID0gZmFsc2U7XG4gICAgbGV0IGhlYWFjID0gZmFsc2U7XG4gICAgbGV0IGNvZGVjO1xuICAgIGRhdGEubGV2ZWxzLmZvckVhY2goKGxldmVsKSA9PiB7XG4gICAgICAvLyBkZXRlY3QgaWYgd2UgaGF2ZSBkaWZmZXJlbnQga2luZCBvZiBhdWRpbyBjb2RlY3MgdXNlZCBhbW9uZ3N0IHBsYXlsaXN0c1xuICAgICAgY29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEpIHtcbiAgICAgICAgICBhYWMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgIGhlYWFjID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IGFhYyAmJiBoZWFhYyAmJiAhY2hhbmdlVHlwZVN1cHBvcnRlZCgpO1xuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICAnQm90aCBBQUMvSEUtQUFDIGF1ZGlvIGZvdW5kIGluIGxldmVsczsgZGVjbGFyaW5nIGxldmVsIGNvZGVjIGFzIEhFLUFBQydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkxldmVsTG9hZGluZyhldmVudDogRXZlbnRzLkxFVkVMX0xPQURJTkcsIGRhdGE6IExldmVsTG9hZGluZ0RhdGEpIHtcbiAgICBjb25zdCB7IGxldmVscyB9ID0gdGhpcztcbiAgICBpZiAoIWxldmVscyB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5JRExFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2RhdGEubGV2ZWxdO1xuICAgIGlmIChcbiAgICAgICFsZXZlbC5kZXRhaWxzIHx8XG4gICAgICAobGV2ZWwuZGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBkYXRhLmxldmVsKSB8fFxuICAgICAgdGhpcy53YWl0Rm9yQ2RuVHVuZUluKGxldmVsLmRldGFpbHMpXG4gICAgKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uTGV2ZWxMb2FkZWQoZXZlbnQ6IEV2ZW50cy5MRVZFTF9MT0FERUQsIGRhdGE6IExldmVsTG9hZGVkRGF0YSkge1xuICAgIGNvbnN0IHsgbGV2ZWxzIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5ld0xldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgIGNvbnN0IG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgY29uc3QgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb247XG5cbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKGBMZXZlbHMgd2VyZSByZXNldCB3aGlsZSBsb2FkaW5nIGxldmVsICR7bmV3TGV2ZWxJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coXG4gICAgICBgTGV2ZWwgJHtuZXdMZXZlbElkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSR7XG4gICAgICAgIG5ld0RldGFpbHMubGFzdFBhcnRTblxuICAgICAgICAgID8gYFtwYXJ0LSR7bmV3RGV0YWlscy5sYXN0UGFydFNufS0ke25ld0RldGFpbHMubGFzdFBhcnRJbmRleH1dYFxuICAgICAgICAgIDogJydcbiAgICAgIH0sIGNjIFske25ld0RldGFpbHMuc3RhcnRDQ30sICR7bmV3RGV0YWlscy5lbmRDQ31dIGR1cmF0aW9uOiR7ZHVyYXRpb259YFxuICAgICk7XG5cbiAgICBjb25zdCBjdXJMZXZlbCA9IGxldmVsc1tuZXdMZXZlbElkXTtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKFxuICAgICAgZnJhZ0N1cnJlbnQgJiZcbiAgICAgICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgfHxcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkpXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChmcmFnQ3VycmVudC5sZXZlbCAhPT0gZGF0YS5sZXZlbCB8fFxuICAgICAgICAgIGZyYWdDdXJyZW50LnVybElkICE9PSBjdXJMZXZlbC51cmxJZCkgJiZcbiAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5hYm9ydEN1cnJlbnRGcmFnKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNsaWRpbmcgPSAwO1xuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgY3VyTGV2ZWwuZGV0YWlscz8ubGl2ZSkge1xuICAgICAgaWYgKCFuZXdEZXRhaWxzLmZyYWdtZW50c1swXSkge1xuICAgICAgICBuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIGN1ckxldmVsLmRldGFpbHMpO1xuICAgIH1cbiAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXG4gICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfVVBEQVRFRCwge1xuICAgICAgZGV0YWlsczogbmV3RGV0YWlscyxcbiAgICAgIGxldmVsOiBuZXdMZXZlbElkLFxuICAgIH0pO1xuXG4gICAgLy8gb25seSBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgbGV2ZWwgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihuZXdEZXRhaWxzKSkge1xuICAgICAgICAvLyBXYWl0IGZvciBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXJ0UG9zaXRpb24obmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgfSBlbHNlIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgIHRoaXMuc3luY2hyb25pemVUb0xpdmVFZGdlKG5ld0RldGFpbHMpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YTogRnJhZ0xvYWRlZERhdGEpIHtcbiAgICBjb25zdCB7IGZyYWcsIHBhcnQsIHBheWxvYWQgfSA9IGRhdGE7XG4gICAgY29uc3QgeyBsZXZlbHMgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYExldmVscyB3ZXJlIHJlc2V0IHdoaWxlIGZyYWdtZW50IGxvYWQgd2FzIGluIHByb2dyZXNzLiBGcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gd2lsbCBub3QgYmUgYnVmZmVyZWRgXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgY29uc3QgZGV0YWlscyA9IGN1cnJlbnRMZXZlbC5kZXRhaWxzIGFzIExldmVsRGV0YWlscztcbiAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYERyb3BwaW5nIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSBhZnRlciBsZXZlbCBkZXRhaWxzIHdlcmUgcmVzZXRgXG4gICAgICApO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZGVvQ29kZWMgPSBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYztcblxuICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKVxuICAgIGNvbnN0IGFjY3VyYXRlVGltZU9mZnNldCA9IGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZTtcbiAgICBjb25zdCBpbml0U2VnbWVudERhdGEgPSBmcmFnLmluaXRTZWdtZW50Py5kYXRhO1xuICAgIGNvbnN0IGF1ZGlvQ29kZWMgPSB0aGlzLl9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCk7XG5cbiAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgLy8gdGhpcy5sb2coYFRyYW5zbXV4aW5nICR7ZnJhZy5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtmcmFnLmxldmVsfSwgY2MgJHtmcmFnLmNjfWApO1xuICAgIGNvbnN0IHRyYW5zbXV4ZXIgPSAodGhpcy50cmFuc211eGVyID1cbiAgICAgIHRoaXMudHJhbnNtdXhlciB8fFxuICAgICAgbmV3IFRyYW5zbXV4ZXJJbnRlcmZhY2UoXG4gICAgICAgIHRoaXMuaGxzLFxuICAgICAgICBQbGF5bGlzdExldmVsVHlwZS5NQUlOLFxuICAgICAgICB0aGlzLl9oYW5kbGVUcmFuc211eENvbXBsZXRlLmJpbmQodGhpcyksXG4gICAgICAgIHRoaXMuX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaC5iaW5kKHRoaXMpXG4gICAgICApKTtcbiAgICBjb25zdCBwYXJ0SW5kZXggPSBwYXJ0ID8gcGFydC5pbmRleCA6IC0xO1xuICAgIGNvbnN0IHBhcnRpYWwgPSBwYXJ0SW5kZXggIT09IC0xO1xuICAgIGNvbnN0IGNodW5rTWV0YSA9IG5ldyBDaHVua01ldGFkYXRhKFxuICAgICAgZnJhZy5sZXZlbCxcbiAgICAgIGZyYWcuc24gYXMgbnVtYmVyLFxuICAgICAgZnJhZy5zdGF0cy5jaHVua0NvdW50LFxuICAgICAgcGF5bG9hZC5ieXRlTGVuZ3RoLFxuICAgICAgcGFydEluZGV4LFxuICAgICAgcGFydGlhbFxuICAgICk7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tmcmFnLmNjXTtcblxuICAgIHRyYW5zbXV4ZXIucHVzaChcbiAgICAgIHBheWxvYWQsXG4gICAgICBpbml0U2VnbWVudERhdGEsXG4gICAgICBhdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYyxcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgZGV0YWlscy50b3RhbGR1cmF0aW9uLFxuICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgY2h1bmtNZXRhLFxuICAgICAgaW5pdFBUU1xuICAgICk7XG4gIH1cblxuICBwcml2YXRlIG9uQXVkaW9UcmFja1N3aXRjaGluZyhcbiAgICBldmVudDogRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORyxcbiAgICBkYXRhOiBBdWRpb1RyYWNrU3dpdGNoaW5nRGF0YVxuICApIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgY29uc3QgZnJvbUFsdEF1ZGlvID0gdGhpcy5hbHRBdWRpbztcbiAgICBjb25zdCBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XG4gICAgLy8gaWYgd2Ugc3dpdGNoIG9uIG1haW4gYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCBtZWRpYS5idWZmZXJlZFxuICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHdlIHN3aXRjaCB0byBhbHQgYXVkaW86IGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyIGlzIGhhbmRsaW5nIGl0LlxuICAgIC8vIHdlIHdpbGwganVzdCBoYXZlIHRvIGNoYW5nZSBidWZmZXIgc2NoZWR1bGluZyBvbiBhdWRpb1RyYWNrU3dpdGNoZWRcbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICAnU3dpdGNoaW5nIG9uIG1haW4gYXVkaW8sIHVzZSBtZWRpYS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVmaWxsIGF1ZGlvIGJ1ZmZlciBmcm9tIG1haW46IGNhbmNlbCBhbnkgZnJhZyBsb2FkaW5nIHRvIHNwZWVkIHVwIGF1ZGlvIHN3aXRjaFxuICAgICAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIHRvIG1haW4gYXVkaW8gdHJhY2ssIGNhbmNlbCBtYWluIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICBmcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZ0N1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlc3Ryb3kgdHJhbnNtdXhlciB0byBmb3JjZSBpbml0IHNlZ21lbnQgZ2VuZXJhdGlvbiAoZm9sbG93aW5nIGF1ZGlvIHN3aXRjaClcbiAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmF1ZGlvT25seSkge1xuICAgICAgICAvLyBSZXNldCBhdWRpbyB0cmFuc211eGVyIHNvIHdoZW4gc3dpdGNoaW5nIGJhY2sgdG8gbWFpbiBhdWRpbyB3ZSdyZSBub3Qgc3RpbGwgYXBwZW5kaW5nIHdoZXJlIHdlIGxlZnQgb2ZmXG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgIC8vIElmIHN3aXRjaGluZyBmcm9tIGFsdCB0byBtYWluIGF1ZGlvLCBmbHVzaCBhbGwgYXVkaW8gYW5kIHRyaWdnZXIgdHJhY2sgc3dpdGNoZWRcbiAgICAgIGlmIChmcm9tQWx0QXVkaW8pIHtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywge1xuICAgICAgICAgIHN0YXJ0T2Zmc2V0OiAwLFxuICAgICAgICAgIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgIH1cbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkF1ZGlvVHJhY2tTd2l0Y2hlZChcbiAgICBldmVudDogRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELFxuICAgIGRhdGE6IEF1ZGlvVHJhY2tTd2l0Y2hlZERhdGFcbiAgKSB7XG4gICAgY29uc3QgdHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgY29uc3QgYWx0QXVkaW8gPSAhIXRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RyYWNrSWRdLnVybDtcbiAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgIGNvbnN0IHZpZGVvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlcjtcbiAgICAgIC8vIGlmIHdlIHN3aXRjaGVkIG9uIGFsdGVybmF0ZSBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIHZpZGVvIHNvdXJjZWJ1ZmZlciBidWZmZXJlZFxuICAgICAgaWYgKHZpZGVvQnVmZmVyICYmIHRoaXMubWVkaWFCdWZmZXIgIT09IHZpZGVvQnVmZmVyKSB7XG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICdTd2l0Y2hpbmcgb24gYWx0ZXJuYXRlIGF1ZGlvLCB1c2UgdmlkZW8uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdmlkZW9CdWZmZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWx0QXVkaW8gPSBhbHRBdWRpbztcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIHByaXZhdGUgb25CdWZmZXJDcmVhdGVkKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0NSRUFURUQsXG4gICAgZGF0YTogQnVmZmVyQ3JlYXRlZERhdGFcbiAgKSB7XG4gICAgY29uc3QgdHJhY2tzID0gZGF0YS50cmFja3M7XG4gICAgbGV0IG1lZGlhVHJhY2s7XG4gICAgbGV0IG5hbWU7XG4gICAgbGV0IGFsdGVybmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdHlwZSBpbiB0cmFja3MpIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgaWYgKHRyYWNrLmlkID09PSAnbWFpbicpIHtcbiAgICAgICAgbmFtZSA9IHR5cGU7XG4gICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjaztcbiAgICAgICAgLy8ga2VlcCB2aWRlbyBzb3VyY2UgYnVmZmVyIHJlZmVyZW5jZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0cmFja3NbdHlwZV07XG4gICAgICAgICAgaWYgKHZpZGVvVHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSB2aWRlb1RyYWNrLmJ1ZmZlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsdGVybmF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbHRlcm5hdGUgJiYgbWVkaWFUcmFjaykge1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgIGBBbHRlcm5hdGUgdHJhY2sgZm91bmQsIHVzZSAke25hbWV9LmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ2BcbiAgICAgICk7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbWVkaWFUcmFjay5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25GcmFnQnVmZmVyZWQoZXZlbnQ6IEV2ZW50cy5GUkFHX0JVRkZFUkVELCBkYXRhOiBGcmFnQnVmZmVyZWREYXRhKSB7XG4gICAgY29uc3QgeyBmcmFnLCBwYXJ0IH0gPSBkYXRhO1xuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIC8vIElmIGEgbGV2ZWwgc3dpdGNoIHdhcyByZXF1ZXN0ZWQgd2hpbGUgYSBmcmFnbWVudCB3YXMgYnVmZmVyaW5nLCBpdCB3aWxsIGVtaXQgdGhlIEZSQUdfQlVGRkVSRUQgZXZlbnQgdXBvbiBjb21wbGV0aW9uXG4gICAgICAvLyBBdm9pZCBzZXR0aW5nIHN0YXRlIGJhY2sgdG8gSURMRSwgc2luY2UgdGhhdCB3aWxsIGludGVyZmVyZSB3aXRoIGEgbGV2ZWwgc3dpdGNoXG4gICAgICB0aGlzLndhcm4oXG4gICAgICAgIGBGcmFnbWVudCAke2ZyYWcuc259JHtwYXJ0ID8gJyBwOiAnICsgcGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke1xuICAgICAgICAgIGZyYWcubGV2ZWxcbiAgICAgICAgfSBmaW5pc2hlZCBidWZmZXJpbmcsIGJ1dCB3YXMgYWJvcnRlZC4gc3RhdGU6ICR7dGhpcy5zdGF0ZX1gXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgdGhpcy5mcmFnTGFzdEticHMgPSBNYXRoLnJvdW5kKFxuICAgICAgKDggKiBzdGF0cy50b3RhbCkgLyAoc3RhdHMuYnVmZmVyaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpXG4gICAgKTtcbiAgICBpZiAoZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgIH1cbiAgICB0aGlzLmZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIHBhcnQpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkVycm9yKGV2ZW50OiBFdmVudHMuRVJST1IsIGRhdGE6IEVycm9yRGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0dBUDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICB0aGlzLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihQbGF5bGlzdExldmVsVHlwZS5NQUlOLCBkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUjpcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBub24gZmF0YWwgZXJyb3Igd2hpbGUgbG9hZGluZyBsZXZlbCwgaWYgbGV2ZWwgY29udHJvbGxlciBpcyBub3QgcmV0cnlpbmcgdG8gbG9hZCBsZXZlbCwgc3dpdGNoIGJhY2sgdG8gSURMRVxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWRhdGEubGV2ZWxSZXRyeSAmJlxuICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwgJiZcbiAgICAgICAgICBkYXRhLmNvbnRleHQ/LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUxcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgaWYgKCFkYXRhLnBhcmVudCB8fCBkYXRhLnBhcmVudCAhPT0gJ21haW4nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgICAgdGhpcy5yZWNvdmVyV29ya2VyRXJyb3IoZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2tzIHRoZSBoZWFsdGggb2YgdGhlIGJ1ZmZlciBhbmQgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBwbGF5YmFjayBzdGFsbHMuXG4gIHByaXZhdGUgY2hlY2tCdWZmZXIoKSB7XG4gICAgY29uc3QgeyBtZWRpYSwgZ2FwQ29udHJvbGxlciB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhIHx8ICFnYXBDb250cm9sbGVyIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgbWVkaWEgb3IgaWYgdGhlIG1lZGlhIGhhc24ndCBidWZmZXJlZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSB8fCAhQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKS5sZW5ndGgpIHtcbiAgICAgIC8vIFJlc29sdmUgZ2FwcyB1c2luZyB0aGUgbWFpbiBidWZmZXIsIHdob3NlIHJhbmdlcyBhcmUgdGhlIGludGVyc2VjdGlvbnMgb2YgdGhlIEEvViBzb3VyY2VidWZmZXJzXG4gICAgICBjb25zdCBhY3RpdmVGcmFnID0gdGhpcy5zdGF0ZSAhPT0gU3RhdGUuSURMRSA/IHRoaXMuZnJhZ0N1cnJlbnQgOiBudWxsO1xuICAgICAgZ2FwQ29udHJvbGxlci5wb2xsKHRoaXMubGFzdEN1cnJlbnRUaW1lLCBhY3RpdmVGcmFnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkJ1ZmZlckZsdXNoZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfRkxVU0hFRCxcbiAgICB7IHR5cGUgfTogQnVmZmVyRmx1c2hlZERhdGFcbiAgKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZSAhPT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPIHx8XG4gICAgICAodGhpcy5hdWRpb09ubHkgJiYgIXRoaXMuYWx0QXVkaW8pXG4gICAgKSB7XG4gICAgICBjb25zdCBtZWRpYUJ1ZmZlciA9XG4gICAgICAgICh0eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9cbiAgICAgICAgICA/IHRoaXMudmlkZW9CdWZmZXJcbiAgICAgICAgICA6IHRoaXMubWVkaWFCdWZmZXIpIHx8IHRoaXMubWVkaWE7XG4gICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYUJ1ZmZlciwgdHlwZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkxldmVsc1VwZGF0ZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTFNfVVBEQVRFRCxcbiAgICBkYXRhOiBMZXZlbHNVcGRhdGVkRGF0YVxuICApIHtcbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICB9XG5cbiAgcHVibGljIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSAhdGhpcy5hdWRpb0NvZGVjU3dhcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWVrcyB0byB0aGUgc2V0IHN0YXJ0UG9zaXRpb24gaWYgbm90IGVxdWFsIHRvIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUuXG4gICAqL1xuICBwcm90ZWN0ZWQgc2Vla1RvU3RhcnRQb3MoKSB7XG4gICAgY29uc3QgeyBtZWRpYSB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgbGV0IHN0YXJ0UG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgLy8gb25seSBhZGp1c3QgY3VycmVudFRpbWUgaWYgZGlmZmVyZW50IGZyb20gc3RhcnRQb3NpdGlvbiBvciBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxuICAgIC8vIGF0IHRoYXQgc3RhZ2UsIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBidWZmZXJlZCByYW5nZSwgYXMgd2UgcmVhY2ggdGhhdCBjb2RlIGFmdGVyIGZpcnN0IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkXG4gICAgaWYgKHN0YXJ0UG9zaXRpb24gPj0gMCAmJiBjdXJyZW50VGltZSA8IHN0YXJ0UG9zaXRpb24pIHtcbiAgICAgIGlmIChtZWRpYS5zZWVraW5nKSB7XG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgIGBjb3VsZCBub3Qgc2VlayB0byAke3N0YXJ0UG9zaXRpb259LCBhbHJlYWR5IHNlZWtpbmcgYXQgJHtjdXJyZW50VGltZX1gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgIGNvbnN0IGJ1ZmZlclN0YXJ0ID0gYnVmZmVyZWQubGVuZ3RoID8gYnVmZmVyZWQuc3RhcnQoMCkgOiAwO1xuICAgICAgY29uc3QgZGVsdGEgPSBidWZmZXJTdGFydCAtIHN0YXJ0UG9zaXRpb247XG4gICAgICBpZiAoXG4gICAgICAgIGRlbHRhID4gMCAmJlxuICAgICAgICAoZGVsdGEgPCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlIHx8XG4gICAgICAgICAgZGVsdGEgPCB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMubG9nKGBhZGp1c3Rpbmcgc3RhcnQgcG9zaXRpb24gYnkgJHtkZWx0YX0gdG8gbWF0Y2ggYnVmZmVyIHN0YXJ0YCk7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gZGVsdGE7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgYHNlZWsgdG8gdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uICR7c3RhcnRQb3NpdGlvbn0gZnJvbSBjdXJyZW50IHRpbWUgJHtjdXJyZW50VGltZX1gXG4gICAgICApO1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKSB7XG4gICAgbGV0IGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dhcCAmJiBhdWRpb0NvZGVjKSB7XG4gICAgICB0aGlzLmxvZygnU3dhcHBpbmcgYXVkaW8gY29kZWMnKTtcbiAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF1ZGlvQ29kZWM7XG4gIH1cblxuICBwcml2YXRlIF9sb2FkQml0cmF0ZVRlc3RGcmFnKGZyYWc6IEZyYWdtZW50LCBsZXZlbDogTGV2ZWwpIHtcbiAgICBmcmFnLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWcsIGxldmVsKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICAgIGlmICghZGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHN0YXRzID0gZnJhZy5zdGF0cztcbiAgICAgIC8vIEJpdHJhdGUgdGVzdHMgZnJhZ21lbnRzIGFyZSBuZWl0aGVyIHBhcnNlZCBub3IgYnVmZmVyZWRcbiAgICAgIHN0YXRzLnBhcnNpbmcuc3RhcnQgPVxuICAgICAgICBzdGF0cy5wYXJzaW5nLmVuZCA9XG4gICAgICAgIHN0YXRzLmJ1ZmZlcmluZy5zdGFydCA9XG4gICAgICAgIHN0YXRzLmJ1ZmZlcmluZy5lbmQgPVxuICAgICAgICAgIHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FERUQsIGRhdGEgYXMgRnJhZ0xvYWRlZERhdGEpO1xuICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdDogVHJhbnNtdXhlclJlc3VsdCkge1xuICAgIGNvbnN0IGlkID0gJ21haW4nO1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcmVtdXhSZXN1bHQsIGNodW5rTWV0YSB9ID0gdHJhbnNtdXhSZXN1bHQ7XG5cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgdGhpcy5yZXNldFdoZW5NaXNzaW5nQ29udGV4dChjaHVua01ldGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGZyYWcsIHBhcnQsIGxldmVsIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgdmlkZW8sIHRleHQsIGlkMywgaW5pdFNlZ21lbnQgfSA9IHJlbXV4UmVzdWx0O1xuICAgIGNvbnN0IHsgZGV0YWlscyB9ID0gbGV2ZWw7XG4gICAgLy8gVGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGhhbmRsZXMgYXVkaW8gYnVmZmVyaW5nIGlmIEhscy5qcyBpcyBwbGF5aW5nIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIGNvbnN0IGF1ZGlvID0gdGhpcy5hbHRBdWRpbyA/IHVuZGVmaW5lZCA6IHJlbXV4UmVzdWx0LmF1ZGlvO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAvLyBJZiB3ZSBhcmUsIHN1YnNlcXVlbnRseSBjaGVjayBpZiB0aGUgY3VycmVudGx5IGxvYWRpbmcgZnJhZ21lbnQgKGZyYWdDdXJyZW50KSBoYXMgY2hhbmdlZC5cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTSU5HO1xuXG4gICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICBpZiAoaW5pdFNlZ21lbnQ/LnRyYWNrcykge1xuICAgICAgICBjb25zdCBtYXBGcmFnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQgfHwgZnJhZztcbiAgICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQoXG4gICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgaW5pdFNlZ21lbnQudHJhY2tzLFxuICAgICAgICAgIG1hcEZyYWdtZW50LFxuICAgICAgICAgIGNodW5rTWV0YVxuICAgICAgICApO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwge1xuICAgICAgICAgIGZyYWc6IG1hcEZyYWdtZW50LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHRyYWNrczogaW5pdFNlZ21lbnQudHJhY2tzLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyB3b3VsZCBiZSBuaWNlIGlmIE51bWJlci5pc0Zpbml0ZSBhY3RlZCBhcyBhIHR5cGVndWFyZCwgYnV0IGl0IGRvZXNuJ3QuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMDAzOFxuICAgICAgY29uc3QgaW5pdFBUUyA9IGluaXRTZWdtZW50LmluaXRQVFMgYXMgbnVtYmVyO1xuICAgICAgY29uc3QgdGltZXNjYWxlID0gaW5pdFNlZ21lbnQudGltZXNjYWxlIGFzIG51bWJlcjtcbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoaW5pdFBUUykpIHtcbiAgICAgICAgdGhpcy5pbml0UFRTW2ZyYWcuY2NdID0geyBiYXNlVGltZTogaW5pdFBUUywgdGltZXNjYWxlIH07XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5JTklUX1BUU19GT1VORCwgeyBmcmFnLCBpZCwgaW5pdFBUUywgdGltZXNjYWxlIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEF2b2lkIGJ1ZmZlcmluZyBpZiBiYWNrdHJhY2tpbmcgdGhpcyBmcmFnbWVudFxuICAgIGlmICh2aWRlbyAmJiByZW11eFJlc3VsdC5pbmRlcGVuZGVudCAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyB9ID0gdmlkZW87XG4gICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1t2aWRlby50eXBlXSA9IHtcbiAgICAgICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICAgICAgZW5kUFRTLFxuICAgICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgICBlbmREVFMsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmlkZW8uZmlyc3RLZXlGcmFtZSAmJiB2aWRlby5pbmRlcGVuZGVudCAmJiBjaHVua01ldGEuaWQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmlkZW8uZHJvcHBlZCAmJiB2aWRlby5pbmRlcGVuZGVudCkge1xuICAgICAgICAgICAgLy8gQmFja3RyYWNrIGlmIGRyb3BwZWQgZnJhbWVzIGNyZWF0ZSBhIGdhcCBhZnRlciBjdXJyZW50VGltZVxuXG4gICAgICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QnVmZmVyVGltZSA9XG4gICAgICAgICAgICAgIChidWZmZXJJbmZvID8gYnVmZmVySW5mby5lbmQgOiB0aGlzLmdldExvYWRQb3NpdGlvbigpKSArXG4gICAgICAgICAgICAgIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSB2aWRlby5maXJzdEtleUZyYW1lUFRTXG4gICAgICAgICAgICAgID8gdmlkZW8uZmlyc3RLZXlGcmFtZVBUU1xuICAgICAgICAgICAgICA6IHN0YXJ0UFRTO1xuICAgICAgICAgICAgaWYgKHRhcmdldEJ1ZmZlclRpbWUgPCBzdGFydFRpbWUgLSB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKSB7XG4gICAgICAgICAgICAgIHRoaXMuYmFja3RyYWNrKGZyYWcpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdmlkZW8gc3RyZWFtIHN0YXJ0IHRvIGZyYWdtZW50IHN0YXJ0IHNvIHRoYXQgdHJ1bmNhdGVkIHNhbXBsZXMgZG8gbm90IGRpc3RvcnQgdGhlIHRpbWVsaW5lLCBhbmQgbWFyayBpdCBwYXJ0aWFsXG4gICAgICAgICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKFxuICAgICAgICAgICAgICB2aWRlby50eXBlIGFzIEVsZW1lbnRhcnlTdHJlYW1UeXBlcyxcbiAgICAgICAgICAgICAgZnJhZy5zdGFydCxcbiAgICAgICAgICAgICAgZW5kUFRTLFxuICAgICAgICAgICAgICBmcmFnLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmREVFMsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8oXG4gICAgICAgICAgdmlkZW8udHlwZSBhcyBFbGVtZW50YXJ5U3RyZWFtVHlwZXMsXG4gICAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgICAgZW5kUFRTLFxuICAgICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICAgIGVuZERUU1xuICAgICAgICApO1xuICAgICAgICBpZiAodGhpcy5iYWNrdHJhY2tGcmFnbWVudCkge1xuICAgICAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBmcmFnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKHZpZGVvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVtdXhSZXN1bHQuaW5kZXBlbmRlbnQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmJhY2t0cmFjayhmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXVkaW8pIHtcbiAgICAgIGNvbnN0IHsgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyB9ID0gYXVkaW87XG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT10gPSB7XG4gICAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgICAgZW5kUFRTLFxuICAgICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICAgIGVuZERUUyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8oXG4gICAgICAgIEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyxcbiAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUyxcbiAgICAgICAgc3RhcnREVFMsXG4gICAgICAgIGVuZERUU1xuICAgICAgKTtcbiAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKGF1ZGlvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgIH1cblxuICAgIGlmIChkZXRhaWxzICYmIGlkMz8uc2FtcGxlcz8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbWl0dGVkSUQzOiBGcmFnUGFyc2luZ01ldGFkYXRhRGF0YSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIHNhbXBsZXM6IGlkMy5zYW1wbGVzLFxuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cbiAgICBpZiAoZGV0YWlscyAmJiB0ZXh0KSB7XG4gICAgICBjb25zdCBlbWl0dGVkVGV4dDogRnJhZ1BhcnNpbmdVc2VyZGF0YURhdGEgPSB7XG4gICAgICAgIGlkLFxuICAgICAgICBmcmFnLFxuICAgICAgICBkZXRhaWxzLFxuICAgICAgICBzYW1wbGVzOiB0ZXh0LnNhbXBsZXMsXG4gICAgICB9O1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZW1pdHRlZFRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2J1ZmZlckluaXRTZWdtZW50KFxuICAgIGN1cnJlbnRMZXZlbDogTGV2ZWwsXG4gICAgdHJhY2tzOiBUcmFja1NldCxcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGFcbiAgKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmF1ZGlvT25seSA9ICEhdHJhY2tzLmF1ZGlvICYmICF0cmFja3MudmlkZW87XG5cbiAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiAhdGhpcy5hdWRpb09ubHkpIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgY29uc3QgeyBhdWRpbywgdmlkZW8sIGF1ZGlvdmlkZW8gfSA9IHRyYWNrcztcbiAgICBpZiAoYXVkaW8pIHtcbiAgICAgIGxldCBhdWRpb0NvZGVjID0gY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbiB0aGUgY2FzZSB0aGF0IEFBQyBhbmQgSEUtQUFDIGF1ZGlvIGNvZGVjcyBhcmUgc2lnbmFsbGVkIGluIG1hbmlmZXN0LFxuICAgICAgICAvLyBmb3JjZSBIRS1BQUMsIGFzIGl0IHNlZW1zIHRoYXQgbW9zdCBicm93c2VycyBwcmVmZXJzIGl0LlxuICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgbW9ubyBzdHJlYW0sIG9yIGluIEZpcmVmb3hcbiAgICAgICAgaWYgKGF1ZGlvLm1ldGFkYXRhLmNoYW5uZWxDb3VudCAhPT0gMSAmJiB1YS5pbmRleE9mKCdmaXJlZm94JykgPT09IC0xKSB7XG4gICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBIRS1BQUMgaXMgYnJva2VuIG9uIEFuZHJvaWQsIGFsd2F5cyBzaWduYWwgYXVkaW8gY29kZWMgYXMgQUFDIGV2ZW4gaWYgdmFyaWFudCBtYW5pZmVzdCBzdGF0ZXMgb3RoZXJ3aXNlXG4gICAgICBpZiAodWEuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSAmJiBhdWRpby5jb250YWluZXIgIT09ICdhdWRpby9tcGVnJykge1xuICAgICAgICAvLyBFeGNsdWRlIG1wZWcgYXVkaW9cbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICB0aGlzLmxvZyhgQW5kcm9pZDogZm9yY2UgYXVkaW8gY29kZWMgdG8gJHthdWRpb0NvZGVjfWApO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjICYmIGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjICE9PSBhdWRpb0NvZGVjKSB7XG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgIGBTd2FwcGluZyBtYW5pZmVzdCBhdWRpbyBjb2RlYyBcIiR7Y3VycmVudExldmVsLmF1ZGlvQ29kZWN9XCIgZm9yIFwiJHthdWRpb0NvZGVjfVwiYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYXVkaW8ubGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICBhdWRpby5pZCA9ICdtYWluJztcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjoke1xuICAgICAgICAgIGF1ZGlvLmNvbnRhaW5lclxuICAgICAgICB9LCBjb2RlY3Nbc2VsZWN0ZWQvbGV2ZWwvcGFyc2VkXT1bJHthdWRpb0NvZGVjIHx8ICcnfS8ke1xuICAgICAgICAgIGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjIHx8ICcnXG4gICAgICAgIH0vJHthdWRpby5jb2RlY31dYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICB2aWRlby5sZXZlbENvZGVjID0gY3VycmVudExldmVsLnZpZGVvQ29kZWM7XG4gICAgICB2aWRlby5pZCA9ICdtYWluJztcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgSW5pdCB2aWRlbyBidWZmZXIsIGNvbnRhaW5lcjoke1xuICAgICAgICAgIHZpZGVvLmNvbnRhaW5lclxuICAgICAgICB9LCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHtjdXJyZW50TGV2ZWwudmlkZW9Db2RlYyB8fCAnJ30vJHtcbiAgICAgICAgICB2aWRlby5jb2RlY1xuICAgICAgICB9XWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhdWRpb3ZpZGVvKSB7XG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgYEluaXQgYXVkaW92aWRlbyBidWZmZXIsIGNvbnRhaW5lcjoke1xuICAgICAgICAgIGF1ZGlvdmlkZW8uY29udGFpbmVyXG4gICAgICAgIH0sIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske2N1cnJlbnRMZXZlbC5hdHRycy5DT0RFQ1MgfHwgJyd9LyR7XG4gICAgICAgICAgYXVkaW92aWRlby5jb2RlY1xuICAgICAgICB9XWBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XG4gICAgLy8gbG9vcCB0aHJvdWdoIHRyYWNrcyB0aGF0IGFyZSBnb2luZyB0byBiZSBwcm92aWRlZCB0byBidWZmZXJDb250cm9sbGVyXG4gICAgT2JqZWN0LmtleXModHJhY2tzKS5mb3JFYWNoKCh0cmFja05hbWUpID0+IHtcbiAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICBjb25zdCBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgICAgaWYgKGluaXRTZWdtZW50Py5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHtcbiAgICAgICAgICB0eXBlOiB0cmFja05hbWUgYXMgU291cmNlQnVmZmVyTmFtZSxcbiAgICAgICAgICBkYXRhOiBpbml0U2VnbWVudCxcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTogQnVmZmVySW5mbyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8oXG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsXG4gICAgICBQbGF5bGlzdExldmVsVHlwZS5NQUlOXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgYmFja3RyYWNrKGZyYWc6IEZyYWdtZW50KSB7XG4gICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IHRydWU7XG4gICAgLy8gQ2F1c2VzIGZpbmRGcmFnbWVudHMgdG8gYmFja3RyYWNrIHRocm91Z2ggZnJhZ21lbnRzIHRvIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IGZyYWc7XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmZsdXNoQnVmZmVyR2FwKGZyYWcpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0O1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0ZyYWdtZW50Q2hhbmdlZCgpIHtcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMubWVkaWE7XG4gICAgbGV0IGZyYWdQbGF5aW5nQ3VycmVudDogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgICBpZiAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSA+IDEgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICovXG5cbiAgICAgIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUpKSB7XG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lICsgMC4xKSkge1xuICAgICAgICAvKiBlbnN1cmUgdGhhdCBGUkFHX0NIQU5HRUQgZXZlbnQgaXMgdHJpZ2dlcmVkIGF0IHN0YXJ0dXAsXG4gICAgICAgICAgd2hlbiBmaXJzdCB2aWRlbyBmcmFtZSBpcyBkaXNwbGF5ZWQgYW5kIHBsYXliYWNrIGlzIHBhdXNlZC5cbiAgICAgICAgICBhZGQgYSB0b2xlcmFuY2Ugb2YgMTAwbXMsIGluIGNhc2UgY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsXG4gICAgICAgICAgY2hlY2sgaWYgY3VycmVudCBwb3MrMTAwbXMgaXMgYnVmZmVyZWQgYW5kIHVzZSB0aGF0IGJ1ZmZlciByYW5nZVxuICAgICAgICAgIGZvciBGUkFHX0NIQU5HRUQgZXZlbnQgcmVwb3J0aW5nICovXG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lICsgMC4xKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGZyYWdQbGF5aW5nID0gdGhpcy5mcmFnUGxheWluZztcbiAgICAgICAgY29uc3QgZnJhZ0N1cnJlbnRMZXZlbCA9IGZyYWdQbGF5aW5nQ3VycmVudC5sZXZlbDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFmcmFnUGxheWluZyB8fFxuICAgICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudC5zbiAhPT0gZnJhZ1BsYXlpbmcuc24gfHxcbiAgICAgICAgICBmcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnRMZXZlbCB8fFxuICAgICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudC51cmxJZCAhPT0gZnJhZ1BsYXlpbmcudXJsSWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5mcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nQ3VycmVudDtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0NIQU5HRUQsIHsgZnJhZzogZnJhZ1BsYXlpbmdDdXJyZW50IH0pO1xuICAgICAgICAgIGlmICghZnJhZ1BsYXlpbmcgfHwgZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdDdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1NXSVRDSEVELCB7XG4gICAgICAgICAgICAgIGxldmVsOiBmcmFnQ3VycmVudExldmVsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5leHRMZXZlbCgpOiBudW1iZXIge1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLm5leHRCdWZmZXJlZEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBnZXQgY3VycmVudEZyYWcoKTogRnJhZ21lbnQgfCBudWxsIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFnUGxheWluZyB8fCB0aGlzLmdldEFwcGVuZGVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQcm9ncmFtRGF0ZVRpbWUoKTogRGF0ZSB8IG51bGwge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICBjb25zdCBmcmFnID0gdGhpcy5jdXJyZW50RnJhZztcbiAgICAgIGlmIChcbiAgICAgICAgZnJhZyAmJlxuICAgICAgICBOdW1iZXIuaXNGaW5pdGUoY3VycmVudFRpbWUpICYmXG4gICAgICAgIE51bWJlci5pc0Zpbml0ZShmcmFnLnByb2dyYW1EYXRlVGltZSlcbiAgICAgICkge1xuICAgICAgICBjb25zdCBlcG9jTXMgPVxuICAgICAgICAgIChmcmFnLnByb2dyYW1EYXRlVGltZSBhcyBudW1iZXIpICsgKGN1cnJlbnRUaW1lIC0gZnJhZy5zdGFydCkgKiAxMDAwO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZXBvY01zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgY3VycmVudExldmVsKCk6IG51bWJlciB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBnZXQgbmV4dEJ1ZmZlcmVkRnJhZygpIHtcbiAgICBjb25zdCBmcmFnID0gdGhpcy5jdXJyZW50RnJhZztcbiAgICBpZiAoZnJhZykge1xuICAgICAgcmV0dXJuIHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGZyYWcpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBmb3JjZVN0YXJ0TG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VTdGFydExvYWQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBjb21wdXRlIGFuIEV4cG9uZW50aWFsIFdlaWdodGVkIG1vdmluZyBhdmVyYWdlXG4gKiAtIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vdmluZ19hdmVyYWdlI0V4cG9uZW50aWFsX21vdmluZ19hdmVyYWdlXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXG4gKi9cblxuY2xhc3MgRVdNQSB7XG4gIHB1YmxpYyByZWFkb25seSBoYWxmTGlmZTogbnVtYmVyO1xuICBwcml2YXRlIGFscGhhXzogbnVtYmVyO1xuICBwcml2YXRlIGVzdGltYXRlXzogbnVtYmVyO1xuICBwcml2YXRlIHRvdGFsV2VpZ2h0XzogbnVtYmVyO1xuXG4gIC8vICBBYm91dCBoYWxmIG9mIHRoZSBlc3RpbWF0ZWQgdmFsdWUgd2lsbCBiZSBmcm9tIHRoZSBsYXN0IHxoYWxmTGlmZXwgc2FtcGxlcyBieSB3ZWlnaHQuXG4gIGNvbnN0cnVjdG9yKGhhbGZMaWZlOiBudW1iZXIsIGVzdGltYXRlOiBudW1iZXIgPSAwLCB3ZWlnaHQ6IG51bWJlciA9IDApIHtcbiAgICB0aGlzLmhhbGZMaWZlID0gaGFsZkxpZmU7XG4gICAgLy8gTGFyZ2VyIHZhbHVlcyBvZiBhbHBoYSBleHBpcmUgaGlzdG9yaWNhbCBkYXRhIG1vcmUgc2xvd2x5LlxuICAgIHRoaXMuYWxwaGFfID0gaGFsZkxpZmUgPyBNYXRoLmV4cChNYXRoLmxvZygwLjUpIC8gaGFsZkxpZmUpIDogMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IGVzdGltYXRlO1xuICAgIHRoaXMudG90YWxXZWlnaHRfID0gd2VpZ2h0O1xuICB9XG5cbiAgc2FtcGxlKHdlaWdodDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgY29uc3QgYWRqQWxwaGEgPSBNYXRoLnBvdyh0aGlzLmFscGhhXywgd2VpZ2h0KTtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZhbHVlICogKDEgLSBhZGpBbHBoYSkgKyBhZGpBbHBoYSAqIHRoaXMuZXN0aW1hdGVfO1xuICAgIHRoaXMudG90YWxXZWlnaHRfICs9IHdlaWdodDtcbiAgfVxuXG4gIGdldFRvdGFsV2VpZ2h0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxXZWlnaHRfO1xuICB9XG5cbiAgZ2V0RXN0aW1hdGUoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5hbHBoYV8pIHtcbiAgICAgIGNvbnN0IHplcm9GYWN0b3IgPSAxIC0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHRoaXMudG90YWxXZWlnaHRfKTtcbiAgICAgIGlmICh6ZXJvRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXyAvIHplcm9GYWN0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVzdGltYXRlXztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFV01BO1xuIiwiLypcbiAqIEVXTUEgQmFuZHdpZHRoIEVzdGltYXRvclxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICogVHJhY2tzIGJhbmR3aWR0aCBzYW1wbGVzIGFuZCBlc3RpbWF0ZXMgYXZhaWxhYmxlIGJhbmR3aWR0aC5cbiAqIEJhc2VkIG9uIHRoZSBtaW5pbXVtIG9mIHR3byBleHBvbmVudGlhbGx5LXdlaWdodGVkIG1vdmluZyBhdmVyYWdlcyB3aXRoXG4gKiBkaWZmZXJlbnQgaGFsZi1saXZlcy5cbiAqL1xuXG5pbXBvcnQgRVdNQSBmcm9tICcuLi91dGlscy9ld21hJztcblxuY2xhc3MgRXdtYUJhbmRXaWR0aEVzdGltYXRvciB7XG4gIHByaXZhdGUgZGVmYXVsdEVzdGltYXRlXzogbnVtYmVyO1xuICBwcml2YXRlIG1pbldlaWdodF86IG51bWJlcjtcbiAgcHJpdmF0ZSBtaW5EZWxheU1zXzogbnVtYmVyO1xuICBwcml2YXRlIHNsb3dfOiBFV01BO1xuICBwcml2YXRlIGZhc3RfOiBFV01BO1xuICBwcml2YXRlIGRlZmF1bHRUVEZCXzogbnVtYmVyO1xuICBwcml2YXRlIHR0ZmJfOiBFV01BO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHNsb3c6IG51bWJlcixcbiAgICBmYXN0OiBudW1iZXIsXG4gICAgZGVmYXVsdEVzdGltYXRlOiBudW1iZXIsXG4gICAgZGVmYXVsdFRURkI6IG51bWJlciA9IDEwMFxuICApIHtcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93KTtcbiAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCk7XG4gICAgdGhpcy5kZWZhdWx0VFRGQl8gPSBkZWZhdWx0VFRGQjtcbiAgICB0aGlzLnR0ZmJfID0gbmV3IEVXTUEoc2xvdyk7XG4gIH1cblxuICB1cGRhdGUoc2xvdzogbnVtYmVyLCBmYXN0OiBudW1iZXIpIHtcbiAgICBjb25zdCB7IHNsb3dfLCBmYXN0XywgdHRmYl8gfSA9IHRoaXM7XG4gICAgaWYgKHNsb3dfLmhhbGZMaWZlICE9PSBzbG93KSB7XG4gICAgICB0aGlzLnNsb3dfID0gbmV3IEVXTUEoc2xvdywgc2xvd18uZ2V0RXN0aW1hdGUoKSwgc2xvd18uZ2V0VG90YWxXZWlnaHQoKSk7XG4gICAgfVxuICAgIGlmIChmYXN0Xy5oYWxmTGlmZSAhPT0gZmFzdCkge1xuICAgICAgdGhpcy5mYXN0XyA9IG5ldyBFV01BKGZhc3QsIGZhc3RfLmdldEVzdGltYXRlKCksIGZhc3RfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgIH1cbiAgICBpZiAodHRmYl8uaGFsZkxpZmUgIT09IHNsb3cpIHtcbiAgICAgIHRoaXMudHRmYl8gPSBuZXcgRVdNQShzbG93LCB0dGZiXy5nZXRFc3RpbWF0ZSgpLCB0dGZiXy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG4gIH1cblxuICBzYW1wbGUoZHVyYXRpb25NczogbnVtYmVyLCBudW1CeXRlczogbnVtYmVyKSB7XG4gICAgZHVyYXRpb25NcyA9IE1hdGgubWF4KGR1cmF0aW9uTXMsIHRoaXMubWluRGVsYXlNc18pO1xuICAgIGNvbnN0IG51bUJpdHMgPSA4ICogbnVtQnl0ZXM7XG4gICAgLy8gd2VpZ2h0IGlzIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICBjb25zdCBkdXJhdGlvblMgPSBkdXJhdGlvbk1zIC8gMTAwMDtcbiAgICAvLyB2YWx1ZSBpcyBiYW5kd2lkdGggaW4gYml0cy9zXG4gICAgY29uc3QgYmFuZHdpZHRoSW5CcHMgPSBudW1CaXRzIC8gZHVyYXRpb25TO1xuICAgIHRoaXMuZmFzdF8uc2FtcGxlKGR1cmF0aW9uUywgYmFuZHdpZHRoSW5CcHMpO1xuICAgIHRoaXMuc2xvd18uc2FtcGxlKGR1cmF0aW9uUywgYmFuZHdpZHRoSW5CcHMpO1xuICB9XG5cbiAgc2FtcGxlVFRGQih0dGZiOiBudW1iZXIpIHtcbiAgICAvLyB3ZWlnaHQgaXMgZnJlcXVlbmN5IGN1cnZlIGFwcGxpZWQgdG8gVFRGQiBpbiBzZWNvbmRzXG4gICAgLy8gKGxvbmdlciB0aW1lcyBoYXZlIGxlc3Mgd2VpZ2h0IHdpdGggZXhwZWN0ZWQgaW5wdXQgdW5kZXIgMSBzZWNvbmQpXG4gICAgY29uc3Qgc2Vjb25kcyA9IHR0ZmIgLyAxMDAwO1xuICAgIGNvbnN0IHdlaWdodCA9IE1hdGguc3FydCgyKSAqIE1hdGguZXhwKC1NYXRoLnBvdyhzZWNvbmRzLCAyKSAvIDIpO1xuICAgIHRoaXMudHRmYl8uc2FtcGxlKHdlaWdodCwgTWF0aC5tYXgodHRmYiwgNSkpO1xuICB9XG5cbiAgY2FuRXN0aW1hdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZmFzdF8uZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF87XG4gIH1cblxuICBnZXRFc3RpbWF0ZSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmNhbkVzdGltYXRlKCkpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdzbG93IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgICAvLyBjb25zb2xlLmxvZygnZmFzdCBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gVGFrZSB0aGUgbWluaW11bSBvZiB0aGVzZSB0d28gZXN0aW1hdGVzLiAgVGhpcyBzaG91bGQgaGF2ZSB0aGUgZWZmZWN0IG9mXG4gICAgICAvLyBhZGFwdGluZyBkb3duIHF1aWNrbHksIGJ1dCB1cCBtb3JlIHNsb3dseS5cbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZhc3RfLmdldEVzdGltYXRlKCksIHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRFc3RpbWF0ZV87XG4gICAgfVxuICB9XG5cbiAgZ2V0RXN0aW1hdGVUVEZCKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMudHRmYl8uZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnR0ZmJfLmdldEVzdGltYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRUVEZCXztcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge31cbn1cbmV4cG9ydCBkZWZhdWx0IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3I7XG4iLCJpbXBvcnQgRXdtYUJhbmRXaWR0aEVzdGltYXRvciBmcm9tICcuLi91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3InO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSB7IEZyYWdtZW50IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB0eXBlIHsgUGFydCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IExvYWRlclN0YXRzIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuaW1wb3J0IHR5cGUge1xuICBGcmFnTG9hZGluZ0RhdGEsXG4gIEZyYWdMb2FkZWREYXRhLFxuICBGcmFnQnVmZmVyZWREYXRhLFxuICBMZXZlbExvYWRlZERhdGEsXG4gIExldmVsU3dpdGNoaW5nRGF0YSxcbn0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgQWJyQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5cbmNsYXNzIEFickNvbnRyb2xsZXIgaW1wbGVtZW50cyBBYnJDb21wb25lbnRBUEkge1xuICBwcm90ZWN0ZWQgaGxzOiBIbHM7XG4gIHByaXZhdGUgbGFzdExldmVsTG9hZFNlYzogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBsYXN0TG9hZGVkRnJhZ0xldmVsOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIF9uZXh0QXV0b0xldmVsOiBudW1iZXIgPSAtMTtcbiAgcHJpdmF0ZSB0aW1lcjogbnVtYmVyID0gLTE7XG4gIHByaXZhdGUgb25DaGVjazogRnVuY3Rpb24gPSB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKHRoaXMpO1xuICBwcml2YXRlIGZyYWdDdXJyZW50OiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHBhcnRDdXJyZW50OiBQYXJ0IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgYml0cmF0ZVRlc3REZWxheTogbnVtYmVyID0gMDtcblxuICBwdWJsaWMgcmVhZG9ubHkgYndFc3RpbWF0b3I6IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3I7XG5cbiAgY29uc3RydWN0b3IoaGxzOiBIbHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcblxuICAgIGNvbnN0IGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5id0VzdGltYXRvciA9IG5ldyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yKFxuICAgICAgY29uZmlnLmFickV3bWFTbG93Vm9ELFxuICAgICAgY29uZmlnLmFickV3bWFGYXN0Vm9ELFxuICAgICAgY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGVcbiAgICApO1xuXG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMub25DaGVjayA9IG51bGw7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRnJhZ0xvYWRpbmcoZXZlbnQ6IEV2ZW50cy5GUkFHX0xPQURJTkcsIGRhdGE6IEZyYWdMb2FkaW5nRGF0YSkge1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKHRoaXMuaWdub3JlRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgdGhpcy5wYXJ0Q3VycmVudCA9IGRhdGEucGFydCA/PyBudWxsO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMub25DaGVjaywgMTAwKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkxldmVsU3dpdGNoaW5nKFxuICAgIGV2ZW50OiBFdmVudHMuTEVWRUxfU1dJVENISU5HLFxuICAgIGRhdGE6IExldmVsU3dpdGNoaW5nRGF0YVxuICApOiB2b2lkIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VGltZVRvTG9hZEZyYWcoXG4gICAgdGltZVRvRmlyc3RCeXRlU2VjOiBudW1iZXIsXG4gICAgYmFuZHdpZHRoOiBudW1iZXIsXG4gICAgZnJhZ1NpemVCaXRzOiBudW1iZXIsXG4gICAgaXNTd2l0Y2g6IGJvb2xlYW5cbiAgKSB7XG4gICAgY29uc3QgZnJhZ0xvYWRTZWMgPSB0aW1lVG9GaXJzdEJ5dGVTZWMgKyBmcmFnU2l6ZUJpdHMgLyBiYW5kd2lkdGg7XG4gICAgY29uc3QgcGxheWxpc3RMb2FkU2VjID0gaXNTd2l0Y2ggPyB0aGlzLmxhc3RMZXZlbExvYWRTZWMgOiAwO1xuICAgIHJldHVybiBmcmFnTG9hZFNlYyArIHBsYXlsaXN0TG9hZFNlYztcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkxldmVsTG9hZGVkKGV2ZW50OiBFdmVudHMuTEVWRUxfTE9BREVELCBkYXRhOiBMZXZlbExvYWRlZERhdGEpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgY29uc3QgeyB0b3RhbCwgYndFc3RpbWF0ZSB9ID0gZGF0YS5zdGF0cztcbiAgICAvLyBUb3RhbCBpcyB0aGUgYnl0ZWxlbmd0aCBhbmQgYndFc3RpbWF0ZSBpbiBiaXRzL3NlY1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodG90YWwpICYmIE51bWJlci5pc0Zpbml0ZShid0VzdGltYXRlKSkge1xuICAgICAgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjID0gKDggKiB0b3RhbCkgLyBid0VzdGltYXRlO1xuICAgIH1cbiAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUpIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3IudXBkYXRlKGNvbmZpZy5hYnJFd21hU2xvd0xpdmUsIGNvbmZpZy5hYnJFd21hRmFzdExpdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnVwZGF0ZShjb25maWcuYWJyRXdtYVNsb3dWb0QsIGNvbmZpZy5hYnJFd21hRmFzdFZvRCk7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICAgIFRoaXMgbWV0aG9kIG1vbml0b3JzIHRoZSBkb3dubG9hZCByYXRlIG9mIHRoZSBjdXJyZW50IGZyYWdtZW50LCBhbmQgd2lsbCBkb3duc3dpdGNoIGlmIHRoYXQgZnJhZ21lbnQgd2lsbCBub3QgbG9hZFxuICAgICAgcXVpY2tseSBlbm91Z2ggdG8gcHJldmVudCB1bmRlcmJ1ZmZlcmluZ1xuICAgICovXG4gIHByaXZhdGUgX2FiYW5kb25SdWxlc0NoZWNrKCkge1xuICAgIGNvbnN0IHsgZnJhZ0N1cnJlbnQ6IGZyYWcsIHBhcnRDdXJyZW50OiBwYXJ0LCBobHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhdXRvTGV2ZWxFbmFibGVkLCBtZWRpYSB9ID0gaGxzO1xuICAgIGlmICghZnJhZyB8fCAhbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBzdGF0czogTG9hZGVyU3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgY29uc3QgZHVyYXRpb24gPSBwYXJ0ID8gcGFydC5kdXJhdGlvbiA6IGZyYWcuZHVyYXRpb247XG4gICAgY29uc3QgdGltZUxvYWRpbmcgPSBub3cgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0O1xuICAgIC8vIElmIGZyYWcgbG9hZGluZyBpcyBhYm9ydGVkLCBjb21wbGV0ZSwgb3IgZnJvbSBsb3dlc3QgbGV2ZWwsIHN0b3AgdGltZXIgYW5kIHJldHVyblxuICAgIGlmIChcbiAgICAgIHN0YXRzLmFib3J0ZWQgfHxcbiAgICAgIChzdGF0cy5sb2FkZWQgJiYgc3RhdHMubG9hZGVkID09PSBzdGF0cy50b3RhbCkgfHxcbiAgICAgIGZyYWcubGV2ZWwgPT09IDBcbiAgICApIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGNoZWNrIG9ubHkgcnVucyBpZiB3ZSdyZSBpbiBBQlIgbW9kZSBhbmQgYWN0dWFsbHkgcGxheWluZ1xuICAgIGlmIChcbiAgICAgICFhdXRvTGV2ZWxFbmFibGVkIHx8XG4gICAgICBtZWRpYS5wYXVzZWQgfHxcbiAgICAgICFtZWRpYS5wbGF5YmFja1JhdGUgfHxcbiAgICAgICFtZWRpYS5yZWFkeVN0YXRlXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IGhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0dGZiRXN0aW1hdGUgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpO1xuICAgIGNvbnN0IHBsYXliYWNrUmF0ZSA9IE1hdGguYWJzKG1lZGlhLnBsYXliYWNrUmF0ZSk7XG4gICAgLy8gVG8gbWFpbnRhaW4gc3RhYmxlIGFkYXB0aXZlIHBsYXliYWNrLCBvbmx5IGJlZ2luIG1vbml0b3JpbmcgZnJhZyBsb2FkaW5nIGFmdGVyIGhhbGYgb3IgbW9yZSBvZiBpdHMgcGxheWJhY2sgZHVyYXRpb24gaGFzIHBhc3NlZFxuICAgIGlmIChcbiAgICAgIHRpbWVMb2FkaW5nIDw9XG4gICAgICBNYXRoLm1heCh0dGZiRXN0aW1hdGUsIDEwMDAgKiAoZHVyYXRpb24gLyAocGxheWJhY2tSYXRlICogMikpKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyBhbiBlc3RpbWF0ZSBvZiB0aGUgYW1vdW50IHRpbWUgKGluIHNlY29uZHMpIGl0IHdpbGwgdGFrZSB0byBleGhhdXN0IHRoZSBidWZmZXJcbiAgICBjb25zdCBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSBidWZmZXJJbmZvLmxlbiAvIHBsYXliYWNrUmF0ZTtcbiAgICAvLyBPbmx5IGRvd25zd2l0Y2ggaWYgbGVzcyB0aGFuIDIgZnJhZ21lbnQgbGVuZ3RocyBhcmUgYnVmZmVyZWRcbiAgICBpZiAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID49ICgyICogZHVyYXRpb24pIC8gcGxheWJhY2tSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdHRmYiA9IHN0YXRzLmxvYWRpbmcuZmlyc3RcbiAgICAgID8gc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnRcbiAgICAgIDogLTE7XG4gICAgY29uc3QgbG9hZGVkRmlyc3RCeXRlID0gc3RhdHMubG9hZGVkICYmIHR0ZmIgPiAtMTtcbiAgICBjb25zdCBid0VzdGltYXRlOiBudW1iZXIgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gICAgY29uc3QgeyBsZXZlbHMsIG1pbkF1dG9MZXZlbCB9ID0gaGxzO1xuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgIGNvbnN0IGV4cGVjdGVkTGVuID1cbiAgICAgIHN0YXRzLnRvdGFsIHx8XG4gICAgICBNYXRoLm1heChzdGF0cy5sb2FkZWQsIE1hdGgucm91bmQoKGR1cmF0aW9uICogbGV2ZWwubWF4Qml0cmF0ZSkgLyA4KSk7XG4gICAgbGV0IHRpbWVTdHJlYW1pbmcgPSB0aW1lTG9hZGluZyAtIHR0ZmI7XG4gICAgaWYgKHRpbWVTdHJlYW1pbmcgPCAxICYmIGxvYWRlZEZpcnN0Qnl0ZSkge1xuICAgICAgdGltZVN0cmVhbWluZyA9IE1hdGgubWluKHRpbWVMb2FkaW5nLCAoc3RhdHMubG9hZGVkICogOCkgLyBid0VzdGltYXRlKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZFJhdGUgPSBsb2FkZWRGaXJzdEJ5dGVcbiAgICAgID8gKHN0YXRzLmxvYWRlZCAqIDEwMDApIC8gdGltZVN0cmVhbWluZ1xuICAgICAgOiAwO1xuICAgIC8vIGZyYWdMb2FkRGVsYXkgaXMgYW4gZXN0aW1hdGUgb2YgdGhlIHRpbWUgKGluIHNlY29uZHMpIGl0IHdpbGwgdGFrZSB0byBidWZmZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgZnJhZ21lbnRcbiAgICBjb25zdCBmcmFnTG9hZGVkRGVsYXkgPSBsb2FkUmF0ZVxuICAgICAgPyAoZXhwZWN0ZWRMZW4gLSBzdGF0cy5sb2FkZWQpIC8gbG9hZFJhdGVcbiAgICAgIDogKGV4cGVjdGVkTGVuICogOCkgLyBid0VzdGltYXRlICsgdHRmYkVzdGltYXRlIC8gMTAwMDtcbiAgICAvLyBPbmx5IGRvd25zd2l0Y2ggaWYgdGhlIHRpbWUgdG8gZmluaXNoIGxvYWRpbmcgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBhbW91bnQgb2YgYnVmZmVyIGxlZnRcbiAgICBpZiAoZnJhZ0xvYWRlZERlbGF5IDw9IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ3ZSA9IGxvYWRSYXRlID8gbG9hZFJhdGUgKiA4IDogYndFc3RpbWF0ZTtcbiAgICBsZXQgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5OiBudW1iZXIgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG5leHRMb2FkTGV2ZWw6IG51bWJlcjtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBsYXJnZXN0IG9uZSB0aGF0IGF2b2lkcyByZWJ1ZmZlcmluZ1xuICAgIGZvciAoXG4gICAgICBuZXh0TG9hZExldmVsID0gZnJhZy5sZXZlbCAtIDE7XG4gICAgICBuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsO1xuICAgICAgbmV4dExvYWRMZXZlbC0tXG4gICAgKSB7XG4gICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXG4gICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcbiAgICAgIGNvbnN0IGxldmVsTmV4dEJpdHJhdGUgPSBsZXZlbHNbbmV4dExvYWRMZXZlbF0ubWF4Qml0cmF0ZTtcbiAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IHRoaXMuZ2V0VGltZVRvTG9hZEZyYWcoXG4gICAgICAgIHR0ZmJFc3RpbWF0ZSAvIDEwMDAsXG4gICAgICAgIGJ3ZSxcbiAgICAgICAgZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlLFxuICAgICAgICAhbGV2ZWxzW25leHRMb2FkTGV2ZWxdLmRldGFpbHNcbiAgICAgICk7XG4gICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBPbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCBhdCBsb3dlc3QgbGV2ZWwgaW5zdGVhZCBvZiBjb250aW51aW5nXG4gICAgLy8gdG8gbG9hZCB0aGUgY3VycmVudCBvbmVcbiAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID49IGZyYWdMb2FkZWREZWxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIGVzdGltYXRlZCBsb2FkIHRpbWUgb2YgbmV3IHNlZ21lbnQgaXMgY29tcGxldGVseSB1bnJlYXNvbmFibGUsIGlnbm9yZSBhbmQgZG8gbm90IGVtZXJnZW5jeSBzd2l0Y2ggZG93blxuICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPiBkdXJhdGlvbiAqIDEwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhscy5uZXh0TG9hZExldmVsID0gbmV4dExvYWRMZXZlbDtcbiAgICBpZiAobG9hZGVkRmlyc3RCeXRlKSB7XG4gICAgICAvLyBJZiB0aGVyZSBoYXMgYmVlbiBsb2FkaW5nIHByb2dyZXNzLCBzYW1wbGUgYmFuZHdpZHRoIHVzaW5nIGxvYWRpbmcgdGltZSBvZmZzZXQgYnkgbWluaW11bSBUVEZCIHRpbWVcbiAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKFxuICAgICAgICB0aW1lTG9hZGluZyAtIE1hdGgubWluKHR0ZmJFc3RpbWF0ZSwgdHRmYiksXG4gICAgICAgIHN0YXRzLmxvYWRlZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUgaGFzIGJlZW4gbm8gbG9hZGluZyBwcm9ncmVzcywgc2FtcGxlIFRURkJcbiAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQih0aW1lTG9hZGluZyk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgbG9nZ2VyLndhcm4oYFthYnJdIEZyYWdtZW50ICR7ZnJhZy5zbn0ke1xuICAgICAgcGFydCA/ICcgcGFydCAnICsgcGFydC5pbmRleCA6ICcnXG4gICAgfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IGlzIGxvYWRpbmcgdG9vIHNsb3dseTtcbiAgICAgIFRpbWUgdG8gdW5kZXJidWZmZXI6ICR7YnVmZmVyU3RhcnZhdGlvbkRlbGF5LnRvRml4ZWQoMyl9IHNcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGN1cnJlbnQgZnJhZ21lbnQ6ICR7ZnJhZ0xvYWRlZERlbGF5LnRvRml4ZWQoMyl9IHNcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGRvd24gc3dpdGNoIGZyYWdtZW50OiAke2ZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKFxuICAgICAgICAzXG4gICAgICApfSBzXG4gICAgICBUVEZCIGVzdGltYXRlOiAke3R0ZmJ9XG4gICAgICBDdXJyZW50IEJXIGVzdGltYXRlOiAke1xuICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYndFc3RpbWF0ZSkgPyAoYndFc3RpbWF0ZSAvIDEwMjQpLnRvRml4ZWQoMykgOiAnVW5rbm93bidcbiAgICAgIH0gS2Ivc1xuICAgICAgTmV3IEJXIGVzdGltYXRlOiAkeyh0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgLyAxMDI0KS50b0ZpeGVkKFxuICAgICAgICAzXG4gICAgICApfSBLYi9zXG4gICAgICBBYm9ydGluZyBhbmQgc3dpdGNoaW5nIHRvIGxldmVsICR7bmV4dExvYWRMZXZlbH1gKTtcbiAgICBpZiAoZnJhZy5sb2FkZXIpIHtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgICAgIGZyYWcuYWJvcnRSZXF1ZXN0cygpO1xuICAgIH1cbiAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7IGZyYWcsIHBhcnQsIHN0YXRzIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRnJhZ0xvYWRlZChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfTE9BREVELFxuICAgIHsgZnJhZywgcGFydCB9OiBGcmFnTG9hZGVkRGF0YVxuICApIHtcbiAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZVRURkIoc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBzdG9wIG1vbml0b3JpbmcgYncgb25jZSBmcmFnIGxvYWRlZFxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIC8vIHN0b3JlIGxldmVsIGlkIGFmdGVyIHN1Y2Nlc3NmdWwgZnJhZ21lbnQgbG9hZFxuICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IGZyYWcubGV2ZWw7XG4gICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG5cbiAgICAvLyBjb21wdXRlIGxldmVsIGF2ZXJhZ2UgYml0cmF0ZVxuICAgIGlmICh0aGlzLmhscy5jb25maWcuYWJyTWF4V2l0aFJlYWxCaXRyYXRlKSB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnQgPyBwYXJ0LmR1cmF0aW9uIDogZnJhZy5kdXJhdGlvbjtcbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgY29uc3QgbG9hZGVkQnl0ZXMgPVxuICAgICAgICAobGV2ZWwubG9hZGVkID8gbGV2ZWwubG9hZGVkLmJ5dGVzIDogMCkgKyBzdGF0cy5sb2FkZWQ7XG4gICAgICBjb25zdCBsb2FkZWREdXJhdGlvbiA9XG4gICAgICAgIChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuZHVyYXRpb24gOiAwKSArIGR1cmF0aW9uO1xuICAgICAgbGV2ZWwubG9hZGVkID0geyBieXRlczogbG9hZGVkQnl0ZXMsIGR1cmF0aW9uOiBsb2FkZWREdXJhdGlvbiB9O1xuICAgICAgbGV2ZWwucmVhbEJpdHJhdGUgPSBNYXRoLnJvdW5kKCg4ICogbG9hZGVkQnl0ZXMpIC8gbG9hZGVkRHVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgY29uc3QgZnJhZ0J1ZmZlcmVkRGF0YTogRnJhZ0J1ZmZlcmVkRGF0YSA9IHtcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQsXG4gICAgICAgIGlkOiBmcmFnLnR5cGUsXG4gICAgICB9O1xuICAgICAgdGhpcy5vbkZyYWdCdWZmZXJlZChFdmVudHMuRlJBR19CVUZGRVJFRCwgZnJhZ0J1ZmZlcmVkRGF0YSk7XG4gICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uRnJhZ0J1ZmZlcmVkKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19CVUZGRVJFRCxcbiAgICBkYXRhOiBGcmFnQnVmZmVyZWREYXRhXG4gICkge1xuICAgIGNvbnN0IHsgZnJhZywgcGFydCB9ID0gZGF0YTtcbiAgICBjb25zdCBzdGF0cyA9IHBhcnQ/LnN0YXRzLmxvYWRlZCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuXG4gICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWdub3JlRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVXNlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gcGFyc2luZyBhbmQgcmVxdWVzdCBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyBhbmQgcmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZztcbiAgICAvLyByYXRpb25hbGUgaXMgdGhhdCBidWZmZXIgYXBwZW5kaW5nIG9ubHkgaGFwcGVucyBvbmNlIG1lZGlhIGlzIGF0dGFjaGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2hcbiAgICAvLyBpcyB1c2VkLiBJZiB3ZSB1c2VkIGJ1ZmZlcmluZyBpbiB0aGF0IGNhc2UsIG91ciBCVyBlc3RpbWF0ZSBzYW1wbGUgd2lsbCBiZSB2ZXJ5IGxhcmdlLlxuICAgIGNvbnN0IHByb2Nlc3NpbmdNcyA9XG4gICAgICBzdGF0cy5wYXJzaW5nLmVuZCAtXG4gICAgICBzdGF0cy5sb2FkaW5nLnN0YXJ0IC1cbiAgICAgIE1hdGgubWluKFxuICAgICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCxcbiAgICAgICAgdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKVxuICAgICAgKTtcbiAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZShwcm9jZXNzaW5nTXMsIHN0YXRzLmxvYWRlZCk7XG4gICAgc3RhdHMuYndFc3RpbWF0ZSA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcbiAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gcHJvY2Vzc2luZ01zIC8gMTAwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlnbm9yZUZyYWdtZW50KGZyYWc6IEZyYWdtZW50KTogYm9vbGVhbiB7XG4gICAgLy8gT25seSBjb3VudCBub24tYWx0LWF1ZGlvIGZyYWdzIHdoaWNoIHdlcmUgYWN0dWFsbHkgYnVmZmVyZWQgaW4gb3VyIEJXIGNhbGN1bGF0aW9uc1xuICAgIHJldHVybiBmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JztcbiAgfVxuXG4gIHB1YmxpYyBjbGVhclRpbWVyKCkge1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgfVxuXG4gIC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcbiAgZ2V0IG5leHRBdXRvTGV2ZWwoKSB7XG4gICAgY29uc3QgZm9yY2VkQXV0b0xldmVsID0gdGhpcy5fbmV4dEF1dG9MZXZlbDtcbiAgICBjb25zdCBid0VzdGltYXRvciA9IHRoaXMuYndFc3RpbWF0b3I7XG4gICAgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGUsIHJldHVybiBmb3JjZWQgdmFsdWVcbiAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSAmJiAhYndFc3RpbWF0b3IuY2FuRXN0aW1hdGUoKSkge1xuICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIG5leHQgbGV2ZWwgdXNpbmcgQUJSIGxvZ2ljXG4gICAgbGV0IG5leHRBQlJBdXRvTGV2ZWwgPSB0aGlzLmdldE5leHRBQlJBdXRvTGV2ZWwoKTtcbiAgICAvLyB1c2UgZm9yY2VkIGF1dG8gbGV2ZWwgd2hlbiBBQlIgc2VsZWN0ZWQgbGV2ZWwgaGFzIGVycm9yZWRcbiAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSkge1xuICAgICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgaWYgKFxuICAgICAgICBsZXZlbHMubGVuZ3RoID4gTWF0aC5tYXgoZm9yY2VkQXV0b0xldmVsLCBuZXh0QUJSQXV0b0xldmVsKSAmJlxuICAgICAgICBsZXZlbHNbZm9yY2VkQXV0b0xldmVsXS5sb2FkRXJyb3IgPD0gbGV2ZWxzW25leHRBQlJBdXRvTGV2ZWxdLmxvYWRFcnJvclxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmb3JjZWRBdXRvTGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIGZvcmNlZCBhdXRvIGxldmVsIGhhcyBiZWVuIGRlZmluZWQsIHVzZSBpdCB0byBjYXAgQUJSIGNvbXB1dGVkIHF1YWxpdHkgbGV2ZWxcbiAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSkge1xuICAgICAgbmV4dEFCUkF1dG9MZXZlbCA9IE1hdGgubWluKGZvcmNlZEF1dG9MZXZlbCwgbmV4dEFCUkF1dG9MZXZlbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRBQlJBdXRvTGV2ZWw7XG4gIH1cblxuICBwcml2YXRlIGdldE5leHRBQlJBdXRvTGV2ZWwoKTogbnVtYmVyIHtcbiAgICBjb25zdCB7IGZyYWdDdXJyZW50LCBwYXJ0Q3VycmVudCwgaGxzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbWF4QXV0b0xldmVsLCBjb25maWcsIG1pbkF1dG9MZXZlbCwgbWVkaWEgfSA9IGhscztcbiAgICBjb25zdCBjdXJyZW50RnJhZ0R1cmF0aW9uID0gcGFydEN1cnJlbnRcbiAgICAgID8gcGFydEN1cnJlbnQuZHVyYXRpb25cbiAgICAgIDogZnJhZ0N1cnJlbnRcbiAgICAgID8gZnJhZ0N1cnJlbnQuZHVyYXRpb25cbiAgICAgIDogMDtcblxuICAgIC8vIHBsYXliYWNrUmF0ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHBsYXliYWNrIHJhdGU7IGlmIG1lZGlhLnBsYXliYWNrUmF0ZSBpcyAwLCB3ZSB1c2UgMSB0byBsb2FkIGFzXG4gICAgLy8gaWYgd2UncmUgcGxheWluZyBiYWNrIGF0IHRoZSBub3JtYWwgcmF0ZS5cbiAgICBjb25zdCBwbGF5YmFja1JhdGUgPVxuICAgICAgbWVkaWEgJiYgbWVkaWEucGxheWJhY2tSYXRlICE9PSAwID8gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKSA6IDEuMDtcbiAgICBjb25zdCBhdmdidyA9IHRoaXMuYndFc3RpbWF0b3JcbiAgICAgID8gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpXG4gICAgICA6IGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlO1xuICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyB0aGUgd2FsbC1jbG9jayB0aW1lIGxlZnQgdW50aWwgdGhlIHBsYXliYWNrIGJ1ZmZlciBpcyBleGhhdXN0ZWQuXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IGhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgY29uc3QgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID1cbiAgICAgIChidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAwKSAvIHBsYXliYWNrUmF0ZTtcblxuICAgIC8vIEZpcnN0LCBsb29rIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBhIGxldmVsIG1hdGNoaW5nIHdpdGggb3VyIGF2ZyBiYW5kd2lkdGggQU5EIHRoYXQgY291bGQgYWxzbyBndWFyYW50ZWUgbm8gcmVidWZmZXJpbmcgYXQgYWxsXG4gICAgbGV0IGJlc3RMZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChcbiAgICAgIGF2Z2J3LFxuICAgICAgbWluQXV0b0xldmVsLFxuICAgICAgbWF4QXV0b0xldmVsLFxuICAgICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LFxuICAgICAgY29uZmlnLmFickJhbmRXaWR0aEZhY3RvcixcbiAgICAgIGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvclxuICAgICk7XG4gICAgaWYgKGJlc3RMZXZlbCA+PSAwKSB7XG4gICAgICByZXR1cm4gYmVzdExldmVsO1xuICAgIH1cbiAgICBsb2dnZXIudHJhY2UoXG4gICAgICBgW2Ficl0gJHtcbiAgICAgICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID8gJ3JlYnVmZmVyaW5nIGV4cGVjdGVkJyA6ICdidWZmZXIgaXMgZW1wdHknXG4gICAgICB9LCBmaW5kaW5nIG9wdGltYWwgcXVhbGl0eSBsZXZlbGBcbiAgICApO1xuICAgIC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nIC4uLiBsZXQncyB0cnkgdG8gZmluZCBsZXZlbCB0aGF0IHdpbGwgZ3VhcmFudGVlIGxlc3MgdGhhbiBtYXhTdGFydmF0aW9uRGVsYXkgb2YgcmVidWZmZXJpbmdcbiAgICAvLyBpZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgbG9naWMgd2lsbCByZXR1cm4gMFxuICAgIGxldCBtYXhTdGFydmF0aW9uRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uXG4gICAgICA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXkpXG4gICAgICA6IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXk7XG4gICAgbGV0IGJ3RmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvcjtcbiAgICBsZXQgYndVcEZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcjtcblxuICAgIGlmICghYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAvLyBpbiBjYXNlIGJ1ZmZlciBpcyBlbXB0eSwgbGV0J3MgY2hlY2sgaWYgcHJldmlvdXMgZnJhZ21lbnQgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0XG4gICAgICBjb25zdCBiaXRyYXRlVGVzdERlbGF5ID0gdGhpcy5iaXRyYXRlVGVzdERlbGF5O1xuICAgICAgaWYgKGJpdHJhdGVUZXN0RGVsYXkpIHtcbiAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGNhc2UsIHRoZW4gd2UgbmVlZCB0byBhZGp1c3Qgb3VyIG1heCBzdGFydmF0aW9uIGRlbGF5IHVzaW5nIG1heExvYWRpbmdEZWxheSBjb25maWcgdmFsdWVcbiAgICAgICAgLy8gbWF4IHZpZGVvIGxvYWRpbmcgZGVsYXkgdXNlZCBpbiAgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiA6XG4gICAgICAgIC8vIGluIHRoYXQgbW9kZSBBQlIgY29udHJvbGxlciB3aWxsIGVuc3VyZSB0aGF0IHZpZGVvIGxvYWRpbmcgdGltZSAoaWUgdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZpcnN0IGZyYWdtZW50IGF0IGxvd2VzdCBxdWFsaXR5IGxldmVsICtcbiAgICAgICAgLy8gdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZyYWdtZW50IGF0IHRoZSBhcHByb3ByaWF0ZSBxdWFsaXR5IGxldmVsIGlzIGxlc3MgdGhhbiBgYGBtYXhMb2FkaW5nRGVsYXlgYGAgKVxuICAgICAgICAvLyBjYXAgbWF4TG9hZGluZ0RlbGF5IGFuZCBlbnN1cmUgaXQgaXMgbm90IGJpZ2dlciAndGhhbiBiaXRyYXRlIHRlc3QnIGZyYWcgZHVyYXRpb25cbiAgICAgICAgY29uc3QgbWF4TG9hZGluZ0RlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvblxuICAgICAgICAgID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heExvYWRpbmdEZWxheSlcbiAgICAgICAgICA6IGNvbmZpZy5tYXhMb2FkaW5nRGVsYXk7XG4gICAgICAgIG1heFN0YXJ2YXRpb25EZWxheSA9IG1heExvYWRpbmdEZWxheSAtIGJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgIGxvZ2dlci50cmFjZShcbiAgICAgICAgICBgW2Ficl0gYml0cmF0ZSB0ZXN0IHRvb2sgJHtNYXRoLnJvdW5kKFxuICAgICAgICAgICAgMTAwMCAqIGJpdHJhdGVUZXN0RGVsYXlcbiAgICAgICAgICApfW1zLCBzZXQgZmlyc3QgZnJhZ21lbnQgbWF4IGZldGNoRHVyYXRpb24gdG8gJHtNYXRoLnJvdW5kKFxuICAgICAgICAgICAgMTAwMCAqIG1heFN0YXJ2YXRpb25EZWxheVxuICAgICAgICAgICl9IG1zYFxuICAgICAgICApO1xuICAgICAgICAvLyBkb24ndCB1c2UgY29uc2VydmF0aXZlIGZhY3RvciBvbiBiaXRyYXRlIHRlc3RcbiAgICAgICAgYndGYWN0b3IgPSBid1VwRmFjdG9yID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKFxuICAgICAgYXZnYncsXG4gICAgICBtaW5BdXRvTGV2ZWwsXG4gICAgICBtYXhBdXRvTGV2ZWwsXG4gICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgKyBtYXhTdGFydmF0aW9uRGVsYXksXG4gICAgICBid0ZhY3RvcixcbiAgICAgIGJ3VXBGYWN0b3JcbiAgICApO1xuICAgIHJldHVybiBNYXRoLm1heChiZXN0TGV2ZWwsIDApO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kQmVzdExldmVsKFxuICAgIGN1cnJlbnRCdzogbnVtYmVyLFxuICAgIG1pbkF1dG9MZXZlbDogbnVtYmVyLFxuICAgIG1heEF1dG9MZXZlbDogbnVtYmVyLFxuICAgIG1heEZldGNoRHVyYXRpb246IG51bWJlcixcbiAgICBid0ZhY3RvcjogbnVtYmVyLFxuICAgIGJ3VXBGYWN0b3I6IG51bWJlclxuICApOiBudW1iZXIge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgcGFydEN1cnJlbnQsXG4gICAgICBsYXN0TG9hZGVkRnJhZ0xldmVsOiBjdXJyZW50TGV2ZWwsXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsZXZlbHMgfSA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2N1cnJlbnRMZXZlbF07XG4gICAgY29uc3QgbGl2ZSA9ICEhbGV2ZWw/LmRldGFpbHM/LmxpdmU7XG4gICAgY29uc3QgY3VycmVudENvZGVjU2V0ID0gbGV2ZWw/LmNvZGVjU2V0O1xuXG4gICAgY29uc3QgY3VycmVudEZyYWdEdXJhdGlvbiA9IHBhcnRDdXJyZW50XG4gICAgICA/IHBhcnRDdXJyZW50LmR1cmF0aW9uXG4gICAgICA6IGZyYWdDdXJyZW50XG4gICAgICA/IGZyYWdDdXJyZW50LmR1cmF0aW9uXG4gICAgICA6IDA7XG5cbiAgICBjb25zdCB0dGZiRXN0aW1hdGVTZWMgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpIC8gMTAwMDtcbiAgICBsZXQgbGV2ZWxTa2lwcGVkTWluID0gbWluQXV0b0xldmVsO1xuICAgIGxldCBsZXZlbFNraXBwZWRNYXggPSAtMTtcbiAgICBmb3IgKGxldCBpID0gbWF4QXV0b0xldmVsOyBpID49IG1pbkF1dG9MZXZlbDsgaS0tKSB7XG4gICAgICBjb25zdCBsZXZlbEluZm8gPSBsZXZlbHNbaV07XG5cbiAgICAgIGlmIChcbiAgICAgICAgIWxldmVsSW5mbyB8fFxuICAgICAgICAoY3VycmVudENvZGVjU2V0ICYmIGxldmVsSW5mby5jb2RlY1NldCAhPT0gY3VycmVudENvZGVjU2V0KVxuICAgICAgKSB7XG4gICAgICAgIGlmIChsZXZlbEluZm8pIHtcbiAgICAgICAgICBsZXZlbFNraXBwZWRNaW4gPSBNYXRoLm1pbihpLCBsZXZlbFNraXBwZWRNaW4pO1xuICAgICAgICAgIGxldmVsU2tpcHBlZE1heCA9IE1hdGgubWF4KGksIGxldmVsU2tpcHBlZE1heCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWxTa2lwcGVkTWF4ICE9PSAtMSkge1xuICAgICAgICBsb2dnZXIudHJhY2UoXG4gICAgICAgICAgYFthYnJdIFNraXBwZWQgbGV2ZWwocykgJHtsZXZlbFNraXBwZWRNaW59LSR7bGV2ZWxTa2lwcGVkTWF4fSB3aXRoIENPREVDUzpcIiR7bGV2ZWxzW2xldmVsU2tpcHBlZE1heF0uYXR0cnMuQ09ERUNTfVwiOyBub3QgY29tcGF0aWJsZSB3aXRoIFwiJHtsZXZlbC5hdHRycy5DT0RFQ1N9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgICAgY29uc3QgYXZnRHVyYXRpb24gPVxuICAgICAgICAocGFydEN1cnJlbnRcbiAgICAgICAgICA/IGxldmVsRGV0YWlscz8ucGFydFRhcmdldFxuICAgICAgICAgIDogbGV2ZWxEZXRhaWxzPy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24pIHx8IGN1cnJlbnRGcmFnRHVyYXRpb247XG5cbiAgICAgIGxldCBhZGp1c3RlZGJ3OiBudW1iZXI7XG4gICAgICAvLyBmb2xsb3cgYWxnb3JpdGhtIGNhcHR1cmVkIGZyb20gc3RhZ2VmcmlnaHQgOlxuICAgICAgLy8gaHR0cHM6Ly9hbmRyb2lkLmdvb2dsZXNvdXJjZS5jb20vcGxhdGZvcm0vZnJhbWV3b3Jrcy9hdi8rL21hc3Rlci9tZWRpYS9saWJzdGFnZWZyaWdodC9odHRwbGl2ZS9MaXZlU2Vzc2lvbi5jcHBcbiAgICAgIC8vIFBpY2sgdGhlIGhpZ2hlc3QgYmFuZHdpZHRoIHN0cmVhbSBiZWxvdyBvciBlcXVhbCB0byBlc3RpbWF0ZWQgYmFuZHdpZHRoLlxuICAgICAgLy8gY29uc2lkZXIgb25seSA4MCUgb2YgdGhlIGF2YWlsYWJsZSBiYW5kd2lkdGgsIGJ1dCBpZiB3ZSBhcmUgc3dpdGNoaW5nIHVwLFxuICAgICAgLy8gYmUgZXZlbiBtb3JlIGNvbnNlcnZhdGl2ZSAoNzAlKSB0byBhdm9pZCBvdmVyZXN0aW1hdGluZyBhbmQgaW1tZWRpYXRlbHlcbiAgICAgIC8vIHN3aXRjaGluZyBiYWNrLlxuICAgICAgaWYgKGkgPD0gY3VycmVudExldmVsKSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid0ZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid1VwRmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiaXRyYXRlOiBudW1iZXIgPSBsZXZlbHNbaV0ubWF4Qml0cmF0ZTtcbiAgICAgIGNvbnN0IGZldGNoRHVyYXRpb246IG51bWJlciA9IHRoaXMuZ2V0VGltZVRvTG9hZEZyYWcoXG4gICAgICAgIHR0ZmJFc3RpbWF0ZVNlYyxcbiAgICAgICAgYWRqdXN0ZWRidyxcbiAgICAgICAgYml0cmF0ZSAqIGF2Z0R1cmF0aW9uLFxuICAgICAgICBsZXZlbERldGFpbHMgPT09IHVuZGVmaW5lZFxuICAgICAgKTtcblxuICAgICAgbG9nZ2VyLnRyYWNlKFxuICAgICAgICBgW2Ficl0gbGV2ZWw6JHtpfSBhZGp1c3RlZGJ3LWJpdHJhdGU6JHtNYXRoLnJvdW5kKFxuICAgICAgICAgIGFkanVzdGVkYncgLSBiaXRyYXRlXG4gICAgICAgICl9IGF2Z0R1cmF0aW9uOiR7YXZnRHVyYXRpb24udG9GaXhlZChcbiAgICAgICAgICAxXG4gICAgICAgICl9IG1heEZldGNoRHVyYXRpb246JHttYXhGZXRjaER1cmF0aW9uLnRvRml4ZWQoXG4gICAgICAgICAgMVxuICAgICAgICApfSBmZXRjaER1cmF0aW9uOiR7ZmV0Y2hEdXJhdGlvbi50b0ZpeGVkKDEpfWBcbiAgICAgICk7XG4gICAgICAvLyBpZiBhZGp1c3RlZCBidyBpcyBncmVhdGVyIHRoYW4gbGV2ZWwgYml0cmF0ZSBBTkRcbiAgICAgIGlmIChcbiAgICAgICAgYWRqdXN0ZWRidyA+IGJpdHJhdGUgJiZcbiAgICAgICAgLy8gZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiB1bmtub3duIE9SIGxpdmUgc3RyZWFtIE9SIGZyYWdtZW50IGZldGNoRHVyYXRpb24gbGVzcyB0aGFuIG1heCBhbGxvd2VkIGZldGNoIGR1cmF0aW9uLCB0aGVuIHRoaXMgbGV2ZWwgbWF0Y2hlc1xuICAgICAgICAvLyB3ZSBkb24ndCBhY2NvdW50IGZvciBtYXggRmV0Y2ggRHVyYXRpb24gZm9yIGxpdmUgc3RyZWFtcywgdGhpcyBpcyB0byBhdm9pZCBzd2l0Y2hpbmcgZG93biB3aGVuIG5lYXIgdGhlIGVkZ2Ugb2YgbGl2ZSBzbGlkaW5nIHdpbmRvdyAuLi5cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgc3RhcnRMZXZlbCA9IC0xIChiaXRyYXRlVGVzdCkgb24gbGl2ZSBzdHJlYW1zIDogaW4gdGhhdCBjYXNlIHdlIHNob3VsZCBub3QgZXhpdCBsb29wIHNvIHRoYXQgZmluZEJlc3RMZXZlbCB3aWxsIHJldHVybiAtMVxuICAgICAgICAoZmV0Y2hEdXJhdGlvbiA9PT0gMCB8fFxuICAgICAgICAgICFOdW1iZXIuaXNGaW5pdGUoZmV0Y2hEdXJhdGlvbikgfHxcbiAgICAgICAgICAobGl2ZSAmJiAhdGhpcy5iaXRyYXRlVGVzdERlbGF5KSB8fFxuICAgICAgICAgIGZldGNoRHVyYXRpb24gPCBtYXhGZXRjaER1cmF0aW9uKVxuICAgICAgKSB7XG4gICAgICAgIC8vIGFzIHdlIGFyZSBsb29waW5nIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGJlc3QgYWNoaWV2YWJsZSBxdWFsaXR5IGxldmVsXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBub3QgZW5vdWdoIHRpbWUgYnVkZ2V0IGV2ZW4gd2l0aCBxdWFsaXR5IGxldmVsIDAgLi4uIHJlYnVmZmVyaW5nIG1pZ2h0IGhhcHBlblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHNldCBuZXh0QXV0b0xldmVsKG5leHRMZXZlbCkge1xuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWJyQ29udHJvbGxlcjtcbiIsImltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSB7XG4gIEJ1ZmZlck9wZXJhdGlvbixcbiAgQnVmZmVyT3BlcmF0aW9uUXVldWVzLFxuICBTb3VyY2VCdWZmZXJzLFxuICBTb3VyY2VCdWZmZXJOYW1lLFxufSBmcm9tICcuLi90eXBlcy9idWZmZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWZmZXJPcGVyYXRpb25RdWV1ZSB7XG4gIHByaXZhdGUgYnVmZmVyczogU291cmNlQnVmZmVycztcbiAgcHJpdmF0ZSBxdWV1ZXM6IEJ1ZmZlck9wZXJhdGlvblF1ZXVlcyA9IHtcbiAgICB2aWRlbzogW10sXG4gICAgYXVkaW86IFtdLFxuICAgIGF1ZGlvdmlkZW86IFtdLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZUJ1ZmZlclJlZmVyZW5jZTogU291cmNlQnVmZmVycykge1xuICAgIHRoaXMuYnVmZmVycyA9IHNvdXJjZUJ1ZmZlclJlZmVyZW5jZTtcbiAgfVxuXG4gIHB1YmxpYyBhcHBlbmQob3BlcmF0aW9uOiBCdWZmZXJPcGVyYXRpb24sIHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIHF1ZXVlLnB1c2gob3BlcmF0aW9uKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmIHRoaXMuYnVmZmVyc1t0eXBlXSkge1xuICAgICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgaW5zZXJ0QWJvcnQob3BlcmF0aW9uOiBCdWZmZXJPcGVyYXRpb24sIHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIHF1ZXVlLnVuc2hpZnQob3BlcmF0aW9uKTtcbiAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9XG5cbiAgcHVibGljIGFwcGVuZEJsb2NrZXIodHlwZTogU291cmNlQnVmZmVyTmFtZSk6IFByb21pc2U8e30+IHtcbiAgICBsZXQgZXhlY3V0ZTtcbiAgICBjb25zdCBwcm9taXNlOiBQcm9taXNlPHt9PiA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBleGVjdXRlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBjb25zdCBvcGVyYXRpb246IEJ1ZmZlck9wZXJhdGlvbiA9IHtcbiAgICAgIGV4ZWN1dGUsXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7fSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHt9LFxuICAgICAgb25FcnJvcjogKCkgPT4ge30sXG4gICAgfTtcblxuICAgIHRoaXMuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBwdWJsaWMgZXhlY3V0ZU5leHQodHlwZTogU291cmNlQnVmZmVyTmFtZSkge1xuICAgIGNvbnN0IHsgYnVmZmVycywgcXVldWVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNiID0gYnVmZmVyc1t0eXBlXTtcbiAgICBjb25zdCBxdWV1ZSA9IHF1ZXVlc1t0eXBlXTtcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvcGVyYXRpb246IEJ1ZmZlck9wZXJhdGlvbiA9IHF1ZXVlWzBdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gT3BlcmF0aW9ucyBhcmUgZXhwZWN0ZWQgdG8gcmVzdWx0IGluIGFuICd1cGRhdGVlbmQnIGV2ZW50IGJlaW5nIGZpcmVkLiBJZiBub3QsIHRoZSBxdWV1ZSB3aWxsIGxvY2suIE9wZXJhdGlvbnNcbiAgICAgICAgLy8gd2hpY2ggZG8gbm90IGVuZCB3aXRoIHRoaXMgZXZlbnQgbXVzdCBjYWxsIF9vblNCVXBkYXRlRW5kIG1hbnVhbGx5XG4gICAgICAgIG9wZXJhdGlvbi5leGVjdXRlKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICdbYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZV06IFVuaGFuZGxlZCBleGNlcHRpb24gZXhlY3V0aW5nIHRoZSBjdXJyZW50IG9wZXJhdGlvbidcbiAgICAgICAgKTtcbiAgICAgICAgb3BlcmF0aW9uLm9uRXJyb3IoZSk7XG5cbiAgICAgICAgLy8gT25seSBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmLCBvdGhlcndpc2UgdGhlIHVwZGF0ZWVuZCBoYW5kbGVyIHdpbGwgZG8gdGhpcyBmb3IgdXNcbiAgICAgICAgaWYgKCFzYj8udXBkYXRpbmcpIHtcbiAgICAgICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSB7XG4gICAgdGhpcy5xdWV1ZXNbdHlwZV0uc2hpZnQoKTtcbiAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9XG5cbiAgcHVibGljIGN1cnJlbnQodHlwZTogU291cmNlQnVmZmVyTmFtZSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlc1t0eXBlXVswXTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMsIEVycm9yVHlwZXMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgQnVmZmVySGVscGVyIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgeyBnZXRNZWRpYVNvdXJjZSB9IGZyb20gJy4uL3V0aWxzL21lZGlhc291cmNlLWhlbHBlcic7XG5pbXBvcnQgeyBFbGVtZW50YXJ5U3RyZWFtVHlwZXMgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUcmFja1NldCB9IGZyb20gJy4uL3R5cGVzL3RyYWNrJztcbmltcG9ydCBCdWZmZXJPcGVyYXRpb25RdWV1ZSBmcm9tICcuL2J1ZmZlci1vcGVyYXRpb24tcXVldWUnO1xuaW1wb3J0IHtcbiAgQnVmZmVyT3BlcmF0aW9uLFxuICBTb3VyY2VCdWZmZXJzLFxuICBTb3VyY2VCdWZmZXJOYW1lLFxuICBTb3VyY2VCdWZmZXJMaXN0ZW5lcnMsXG59IGZyb20gJy4uL3R5cGVzL2J1ZmZlcic7XG5pbXBvcnQgdHlwZSB7XG4gIExldmVsVXBkYXRlZERhdGEsXG4gIEJ1ZmZlckFwcGVuZGluZ0RhdGEsXG4gIE1lZGlhQXR0YWNoaW5nRGF0YSxcbiAgTWFuaWZlc3RQYXJzZWREYXRhLFxuICBCdWZmZXJDb2RlY3NEYXRhLFxuICBCdWZmZXJFT1NEYXRhLFxuICBCdWZmZXJGbHVzaGluZ0RhdGEsXG4gIEZyYWdQYXJzZWREYXRhLFxuICBGcmFnQ2hhbmdlZERhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUgeyBDaHVua01ldGFkYXRhIH0gZnJvbSAnLi4vdHlwZXMvdHJhbnNtdXhlcic7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWRldGFpbHMnO1xuXG5jb25zdCBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKCk7XG5jb25zdCBWSURFT19DT0RFQ19QUk9GSUxFX1JFUEFDRSA9IC8oW2hhXXZjLikoPzpcXC5bXi4sXSspKy87XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1ZmZlckNvbnRyb2xsZXIgaW1wbGVtZW50cyBDb21wb25lbnRBUEkge1xuICAvLyBUaGUgbGV2ZWwgZGV0YWlscyB1c2VkIHRvIGRldGVybWluZSBkdXJhdGlvbiwgdGFyZ2V0LWR1cmF0aW9uIGFuZCBsaXZlXG4gIHByaXZhdGUgZGV0YWlsczogTGV2ZWxEZXRhaWxzIHwgbnVsbCA9IG51bGw7XG4gIC8vIGNhY2hlIHRoZSBzZWxmIGdlbmVyYXRlZCBvYmplY3QgdXJsIHRvIGRldGVjdCBoaWphY2sgb2YgdmlkZW8gdGFnXG4gIHByaXZhdGUgX29iamVjdFVybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIC8vIEEgcXVldWUgb2YgYnVmZmVyIG9wZXJhdGlvbnMgd2hpY2ggcmVxdWlyZSB0aGUgU291cmNlQnVmZmVyIHRvIG5vdCBiZSB1cGRhdGluZyB1cG9uIGV4ZWN1dGlvblxuICBwcml2YXRlIG9wZXJhdGlvblF1ZXVlITogQnVmZmVyT3BlcmF0aW9uUXVldWU7XG4gIC8vIFJlZmVyZW5jZXMgdG8gZXZlbnQgbGlzdGVuZXJzIGZvciBlYWNoIFNvdXJjZUJ1ZmZlciwgc28gdGhhdCB0aGV5IGNhbiBiZSByZWZlcmVuY2VkIGZvciBldmVudCByZW1vdmFsXG4gIHByaXZhdGUgbGlzdGVuZXJzITogU291cmNlQnVmZmVyTGlzdGVuZXJzO1xuXG4gIHByaXZhdGUgaGxzOiBIbHM7XG5cbiAgLy8gVGhlIG51bWJlciBvZiBCVUZGRVJfQ09ERUMgZXZlbnRzIHJlY2VpdmVkIGJlZm9yZSBhbnkgc291cmNlQnVmZmVycyBhcmUgY3JlYXRlZFxuICBwdWJsaWMgYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZDogbnVtYmVyID0gMDtcblxuICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWRcbiAgcHJpdmF0ZSBfYnVmZmVyQ29kZWNFdmVudHNUb3RhbDogbnVtYmVyID0gMDtcblxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgYXR0YWNoZWQgbWVkaWEgZWxlbWVudFxuICBwdWJsaWMgbWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgYWN0aXZlIG1lZGlhIHNvdXJjZVxuICBwdWJsaWMgbWVkaWFTb3VyY2U6IE1lZGlhU291cmNlIHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gTGFzdCBNUDMgYXVkaW8gY2h1bmsgYXBwZW5kZWRcbiAgcHJpdmF0ZSBsYXN0TXBlZ0F1ZGlvQ2h1bms6IENodW5rTWV0YWRhdGEgfCBudWxsID0gbnVsbDtcblxuICAvLyBjb3VudGVyc1xuICBwdWJsaWMgYXBwZW5kRXJyb3I6IG51bWJlciA9IDA7XG5cbiAgcHVibGljIHRyYWNrczogVHJhY2tTZXQgPSB7fTtcbiAgcHVibGljIHBlbmRpbmdUcmFja3M6IFRyYWNrU2V0ID0ge307XG4gIHB1YmxpYyBzb3VyY2VCdWZmZXIhOiBTb3VyY2VCdWZmZXJzO1xuXG4gIGNvbnN0cnVjdG9yKGhsczogSGxzKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyBoYXNTb3VyY2VUeXBlcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aCA+IDAgfHxcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucGVuZGluZ1RyYWNrcykubGVuZ3RoID4gMFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgfVxuXG4gIHByb3RlY3RlZCByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9FT1MsIHRoaXMub25CdWZmZXJFb3MsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX1BBUlNFRCwgdGhpcy5vbkZyYWdQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHRoaXMub25CdWZmZXJBcHBlbmRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9FT1MsIHRoaXMub25CdWZmZXJFb3MsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX1BBUlNFRCwgdGhpcy5vbkZyYWdQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQ0hBTkdFRCwgdGhpcy5vbkZyYWdDaGFuZ2VkLCB0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgX2luaXRTb3VyY2VCdWZmZXIoKSB7XG4gICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICB0aGlzLm9wZXJhdGlvblF1ZXVlID0gbmV3IEJ1ZmZlck9wZXJhdGlvblF1ZXVlKHRoaXMuc291cmNlQnVmZmVyKTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICAgIGF1ZGlvOiBbXSxcbiAgICAgIHZpZGVvOiBbXSxcbiAgICAgIGF1ZGlvdmlkZW86IFtdLFxuICAgIH07XG4gICAgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgPSBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gMDtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWFuaWZlc3RQYXJzZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsXG4gICAgZGF0YTogTWFuaWZlc3RQYXJzZWREYXRhXG4gICkge1xuICAgIC8vIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIDIgQlVGRkVSX0NPREVDUyBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQsIG9uZSBwZXIgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvLyBzb3VyY2VidWZmZXJzIHdpbGwgYmUgY3JlYXRlZCBhbGwgYXQgb25jZSB3aGVuIHRoZSBleHBlY3RlZCBuYiBvZiB0cmFja3Mgd2lsbCBiZSByZWFjaGVkXG4gICAgLy8gaW4gY2FzZSBhbHQgYXVkaW8gaXMgbm90IHVzZWQsIG9ubHkgb25lIEJVRkZFUl9DT0RFQyBldmVudCB3aWxsIGJlIGZpcmVkIGZyb20gbWFpbiBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIGl0IHdpbGwgY29udGFpbiB0aGUgZXhwZWN0ZWQgbmIgb2Ygc291cmNlIGJ1ZmZlcnMsIG5vIG5lZWQgdG8gY29tcHV0ZSBpdFxuICAgIGxldCBjb2RlY0V2ZW50czogbnVtYmVyID0gMjtcbiAgICBpZiAoKGRhdGEuYXVkaW8gJiYgIWRhdGEudmlkZW8pIHx8ICFkYXRhLmFsdEF1ZGlvIHx8ICFfX1VTRV9BTFRfQVVESU9fXykge1xuICAgICAgY29kZWNFdmVudHMgPSAxO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gY29kZWNFdmVudHM7XG4gICAgbG9nZ2VyLmxvZyhcbiAgICAgIGAke3RoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZH0gYnVmZmVyQ29kZWMgZXZlbnQocykgZXhwZWN0ZWRgXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhQXR0YWNoaW5nKFxuICAgIGV2ZW50OiBFdmVudHMuTUVESUFfQVRUQUNISU5HLFxuICAgIGRhdGE6IE1lZGlhQXR0YWNoaW5nRGF0YVxuICApIHtcbiAgICBjb25zdCBtZWRpYSA9ICh0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSk7XG4gICAgaWYgKG1lZGlhICYmIE1lZGlhU291cmNlKSB7XG4gICAgICBjb25zdCBtcyA9ICh0aGlzLm1lZGlhU291cmNlID0gbmV3IE1lZGlhU291cmNlKCkpO1xuICAgICAgLy8gTWVkaWFTb3VyY2UgbGlzdGVuZXJzIGFyZSBhcnJvdyBmdW5jdGlvbnMgd2l0aCBhIGxleGljYWwgc2NvcGUsIGFuZCBkbyBub3QgbmVlZCB0byBiZSBib3VuZFxuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKTtcbiAgICAgIC8vIGxpbmsgdmlkZW8gYW5kIG1lZGlhIFNvdXJjZVxuICAgICAgbWVkaWEuc3JjID0gc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKG1zKTtcbiAgICAgIC8vIGNhY2hlIHRoZSBsb2NhbGx5IGdlbmVyYXRlZCBvYmplY3QgdXJsXG4gICAgICB0aGlzLl9vYmplY3RVcmwgPSBtZWRpYS5zcmM7XG4gICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbXB0aWVkJywgdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGNvbnN0IHsgbWVkaWEsIG1lZGlhU291cmNlLCBfb2JqZWN0VXJsIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgbG9nZ2VyLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xuICAgICAgaWYgKG1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCByZWFsbHkgY2FyZSBhYm91dCBjaGVja2luZyBzb3VyY2VidWZmZXIgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYFtidWZmZXItY29udHJvbGxlcl06IG9uTWVkaWFEZXRhY2hpbmc6ICR7ZXJyLm1lc3NhZ2V9IHdoaWxlIGNhbGxpbmcgZW5kT2ZTdHJlYW1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2xlYW4gdXAgdGhlIFNvdXJjZUJ1ZmZlcnMgYnkgaW52b2tpbmcgb25CdWZmZXJSZXNldFxuICAgICAgdGhpcy5vbkJ1ZmZlclJlc2V0KCk7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQpO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UpO1xuXG4gICAgICAvLyBEZXRhY2ggcHJvcGVybHkgdGhlIE1lZGlhU291cmNlIGZyb20gdGhlIEhUTUxNZWRpYUVsZW1lbnQgYXNcbiAgICAgIC8vIHN1Z2dlc3RlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdzNjL21lZGlhLXNvdXJjZS9pc3N1ZXMvNTMuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW1wdGllZCcsIHRoaXMuX29uTWVkaWFFbXB0aWVkKTtcbiAgICAgICAgaWYgKF9vYmplY3RVcmwpIHtcbiAgICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwoX29iamVjdFVybCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbiB1cCB2aWRlbyB0YWcgc3JjIG9ubHkgaWYgaXQncyBvdXIgb3duIHVybC4gc29tZSBleHRlcm5hbCBsaWJyYXJpZXMgbWlnaHRcbiAgICAgICAgLy8gaGlqYWNrIHRoZSB2aWRlbyB0YWcgYW5kIGNoYW5nZSBpdHMgJ3NyYycgd2l0aG91dCBkZXN0cm95aW5nIHRoZSBIbHMgaW5zdGFuY2UgZmlyc3RcbiAgICAgICAgaWYgKG1lZGlhLnNyYyA9PT0gX29iamVjdFVybCkge1xuICAgICAgICAgIG1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgbWVkaWEubG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgJ1tidWZmZXItY29udHJvbGxlcl06IG1lZGlhLnNyYyB3YXMgY2hhbmdlZCBieSBhIHRoaXJkIHBhcnR5IC0gc2tpcCBjbGVhbnVwJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0RFVEFDSEVELCB1bmRlZmluZWQpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQnVmZmVyUmVzZXQoKSB7XG4gICAgdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlKTtcbiAgICAgICAgICBpZiAodGhpcy5tZWRpYVNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTeW5jaHJvbm91c2x5IHJlbW92ZSB0aGUgU0IgZnJvbSB0aGUgbWFwIGJlZm9yZSB0aGUgbmV4dCBjYWxsIGluIG9yZGVyIHRvIHByZXZlbnQgYW4gYXN5bmMgZnVuY3Rpb24gZnJvbVxuICAgICAgICAgIC8vIGFjY2Vzc2luZyBpdFxuICAgICAgICAgIHRoaXMuc291cmNlQnVmZmVyW3R5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYFtidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCB0byByZXNldCB0aGUgJHt0eXBlfSBidWZmZXJgLFxuICAgICAgICAgIGVyclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2luaXRTb3VyY2VCdWZmZXIoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkJ1ZmZlckNvZGVjcyhcbiAgICBldmVudDogRXZlbnRzLkJVRkZFUl9DT0RFQ1MsXG4gICAgZGF0YTogQnVmZmVyQ29kZWNzRGF0YVxuICApIHtcbiAgICBjb25zdCBzb3VyY2VCdWZmZXJDb3VudCA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5sZW5ndGg7XG5cbiAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKCh0cmFja05hbWUpID0+IHtcbiAgICAgIGlmIChzb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgICAvLyBjaGVjayBpZiBTb3VyY2VCdWZmZXIgY29kZWMgbmVlZHMgdG8gY2hhbmdlXG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgaWYgKHRyYWNrICYmIHR5cGVvZiB0cmFjay5idWZmZXIuY2hhbmdlVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnN0IHsgaWQsIGNvZGVjLCBsZXZlbENvZGVjLCBjb250YWluZXIsIG1ldGFkYXRhIH0gPVxuICAgICAgICAgICAgZGF0YVt0cmFja05hbWVdO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2RlYyA9ICh0cmFjay5sZXZlbENvZGVjIHx8IHRyYWNrLmNvZGVjKS5yZXBsYWNlKFxuICAgICAgICAgICAgVklERU9fQ09ERUNfUFJPRklMRV9SRVBBQ0UsXG4gICAgICAgICAgICAnJDEnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBuZXh0Q29kZWMgPSAobGV2ZWxDb2RlYyB8fCBjb2RlYykucmVwbGFjZShcbiAgICAgICAgICAgIFZJREVPX0NPREVDX1BST0ZJTEVfUkVQQUNFLFxuICAgICAgICAgICAgJyQxJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRDb2RlYyAhPT0gbmV4dENvZGVjKSB7XG4gICAgICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGAke2NvbnRhaW5lcn07Y29kZWNzPSR7bGV2ZWxDb2RlYyB8fCBjb2RlY31gO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGFuZ2VUeXBlKHRyYWNrTmFtZSwgbWltZVR5cGUpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgICAgYFtidWZmZXItY29udHJvbGxlcl06IHN3aXRjaGluZyBjb2RlYyAke2N1cnJlbnRDb2RlY30gdG8gJHtuZXh0Q29kZWN9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gPSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjogdHJhY2suYnVmZmVyLFxuICAgICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgICBsZXZlbENvZGVjLFxuICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgc291cmNlIGJ1ZmZlcihzKSBub3QgY3JlYXRlZCB5ZXQsIGFwcGVuZGVkIGJ1ZmZlciB0cmFja3MgaW4gdGhpcy5wZW5kaW5nVHJhY2tzXG4gICAgICAgIHRoaXMucGVuZGluZ1RyYWNrc1t0cmFja05hbWVdID0gZGF0YVt0cmFja05hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaWYgc291cmNlYnVmZmVycyBhbHJlYWR5IGNyZWF0ZWQsIGRvIG5vdGhpbmcgLi4uXG4gICAgaWYgKHNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gTWF0aC5tYXgoXG4gICAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgLSAxLFxuICAgICAgMFxuICAgICk7XG4gICAgaWYgKHRoaXMubWVkaWFTb3VyY2UgJiYgdGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFwcGVuZENoYW5nZVR5cGUodHlwZSwgbWltZVR5cGUpIHtcbiAgICBjb25zdCB7IG9wZXJhdGlvblF1ZXVlIH0gPSB0aGlzO1xuICAgIGNvbnN0IG9wZXJhdGlvbjogQnVmZmVyT3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgYFtidWZmZXItY29udHJvbGxlcl06IGNoYW5naW5nICR7dHlwZX0gc291cmNlQnVmZmVyIHR5cGUgdG8gJHttaW1lVHlwZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzYi5jaGFuZ2VUeXBlKG1pbWVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHt9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge30sXG4gICAgICBvbkVycm9yOiAoZSkgPT4ge1xuICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIHRvIGNoYW5nZSAke3R5cGV9IFNvdXJjZUJ1ZmZlciB0eXBlYCxcbiAgICAgICAgICBlXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgIH07XG5cbiAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQob3BlcmF0aW9uLCB0eXBlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkJ1ZmZlckFwcGVuZGluZyhcbiAgICBldmVudDogRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsXG4gICAgZXZlbnREYXRhOiBCdWZmZXJBcHBlbmRpbmdEYXRhXG4gICkge1xuICAgIGNvbnN0IHsgaGxzLCBvcGVyYXRpb25RdWV1ZSwgdHJhY2tzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZGF0YSwgdHlwZSwgZnJhZywgcGFydCwgY2h1bmtNZXRhIH0gPSBldmVudERhdGE7XG4gICAgY29uc3QgY2h1bmtTdGF0cyA9IGNodW5rTWV0YS5idWZmZXJpbmdbdHlwZV07XG5cbiAgICBjb25zdCBidWZmZXJBcHBlbmRpbmdTdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY2h1bmtTdGF0cy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIGNvbnN0IGZyYWdCdWZmZXJpbmcgPSBmcmFnLnN0YXRzLmJ1ZmZlcmluZztcbiAgICBjb25zdCBwYXJ0QnVmZmVyaW5nID0gcGFydCA/IHBhcnQuc3RhdHMuYnVmZmVyaW5nIDogbnVsbDtcbiAgICBpZiAoZnJhZ0J1ZmZlcmluZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZ0J1ZmZlcmluZy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIH1cbiAgICBpZiAocGFydEJ1ZmZlcmluZyAmJiBwYXJ0QnVmZmVyaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBwYXJ0QnVmZmVyaW5nLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogT25seSB1cGRhdGUgdGltZXN0YW1wT2Zmc2V0IHdoZW4gYXVkaW8vbXBlZyBmcmFnbWVudCBvciBwYXJ0IGlzIG5vdCBjb250aWd1b3VzIHdpdGggcHJldmlvdXNseSBhcHBlbmRlZFxuICAgIC8vIEFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgKGRlc2lyZWQgcG9pbnQgaW4gdGhlIHRpbWVsaW5lIHdoZXJlIHRoZSBuZXh0IGZyYW1lcyBzaG91bGQgYmUgYXBwZW5kZWQpXG4gICAgLy8gaW4gQ2hyb21lIGJyb3dzZXIgd2hlbiB3ZSBkZXRlY3QgTVBFRyBhdWRpbyBjb250YWluZXIgYW5kIHRpbWUgZGVsdGEgYmV0d2VlbiBsZXZlbCBQVFMgYW5kIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YFxuICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiAxMDBtcyAodGhpcyBpcyBlbm91Z2ggdG8gaGFuZGxlIHNlZWsgZm9yIFZPRCBvciBsZXZlbCBjaGFuZ2UgZm9yIExJVkUgdmlkZW9zKS5cbiAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzMzMiNpc3N1ZWNvbW1lbnQtMjU3OTg2NDg2XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICBsZXQgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPSBmYWxzZTtcbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiBhdWRpb1RyYWNrPy5jb250YWluZXIgPT09ICdhdWRpby9tcGVnJykge1xuICAgICAgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPVxuICAgICAgICAhdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgfHxcbiAgICAgICAgY2h1bmtNZXRhLmlkID09PSAxIHx8XG4gICAgICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rLnNuICE9PSBjaHVua01ldGEuc247XG4gICAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IGNodW5rTWV0YTtcbiAgICB9XG5cbiAgICBjb25zdCBmcmFnU3RhcnQgPSBmcmFnLnN0YXJ0O1xuICAgIGNvbnN0IG9wZXJhdGlvbjogQnVmZmVyT3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICBjaHVua1N0YXRzLmV4ZWN1dGVTdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGlmIChjaGVja1RpbWVzdGFtcE9mZnNldCkge1xuICAgICAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGZyYWdTdGFydCAtIHNiLnRpbWVzdGFtcE9mZnNldDtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMC4xKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICAgICAgICAgYFtidWZmZXItY29udHJvbGxlcl06IFVwZGF0aW5nIGF1ZGlvIFNvdXJjZUJ1ZmZlciB0aW1lc3RhbXBPZmZzZXQgdG8gJHtmcmFnU3RhcnR9IChkZWx0YTogJHtkZWx0YX0pIHNuOiAke2ZyYWcuc259KWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgc2IudGltZXN0YW1wT2Zmc2V0ID0gZnJhZ1N0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZEV4ZWN1dG9yKGRhdGEsIHR5cGUpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiAke3R5cGV9IFNvdXJjZUJ1ZmZlciB1cGRhdGVzdGFydGApO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiAke3R5cGV9IFNvdXJjZUJ1ZmZlciB1cGRhdGVlbmRgKTtcbiAgICAgICAgY29uc3QgZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY2h1bmtTdGF0cy5leGVjdXRlRW5kID0gY2h1bmtTdGF0cy5lbmQgPSBlbmQ7XG4gICAgICAgIGlmIChmcmFnQnVmZmVyaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgZnJhZ0J1ZmZlcmluZy5maXJzdCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydEJ1ZmZlcmluZyAmJiBwYXJ0QnVmZmVyaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgcGFydEJ1ZmZlcmluZy5maXJzdCA9IGVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc291cmNlQnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0aW1lUmFuZ2VzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICB0aW1lUmFuZ2VzW3R5cGVdID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNvdXJjZUJ1ZmZlclt0eXBlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBlbmRFcnJvciA9IDA7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBwYXJ0LFxuICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgICB0aW1lUmFuZ2VzLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAoZXJyKSA9PiB7XG4gICAgICAgIC8vIGluIGNhc2UgYW55IGVycm9yIG9jY3VyZWQgd2hpbGUgYXBwZW5kaW5nLCBwdXQgYmFjayBzZWdtZW50IGluIHNlZ21lbnRzIHRhYmxlXG4gICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogRXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgdHJ5aW5nIHRvIGFwcGVuZCB0byB0aGUgJHt0eXBlfSBTb3VyY2VCdWZmZXJgLFxuICAgICAgICAgIGVyclxuICAgICAgICApO1xuICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGFydCxcbiAgICAgICAgICBjaHVua01ldGEsXG4gICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gRE9NRXhjZXB0aW9uLlFVT1RBX0VYQ0VFREVEX0VSUikge1xuICAgICAgICAgIC8vIFF1b3RhRXhjZWVkZWRFcnJvcjogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNxdW90YWV4Y2VlZGVkZXJyb3JcbiAgICAgICAgICAvLyBsZXQncyBzdG9wIGFwcGVuZGluZyBhbnkgc2VnbWVudHMsIGFuZCByZXBvcnQgQlVGRkVSX0ZVTExfRVJST1IgZXJyb3JcbiAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IrKztcbiAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I7XG4gICAgICAgICAgLyogd2l0aCBVSEQgY29udGVudCwgd2UgY291bGQgZ2V0IGxvb3Agb2YgcXVvdGEgZXhjZWVkZWQgZXJyb3IgdW50aWxcbiAgICAgICAgICAgIGJyb3dzZXIgaXMgYWJsZSB0byBldmljdCBzb21lIGRhdGEgZnJvbSBzb3VyY2VidWZmZXIuIFJldHJ5aW5nIGNhbiBoZWxwIHJlY292ZXIuXG4gICAgICAgICAgKi9cbiAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvciA+IGhscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkICR7aGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5fSB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBzb3VyY2VCdWZmZXJgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgfTtcbiAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQob3BlcmF0aW9uLCB0eXBlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkJ1ZmZlckZsdXNoaW5nKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0ZMVVNISU5HLFxuICAgIGRhdGE6IEJ1ZmZlckZsdXNoaW5nRGF0YVxuICApIHtcbiAgICBjb25zdCB7IG9wZXJhdGlvblF1ZXVlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZsdXNoT3BlcmF0aW9uID0gKHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUpOiBCdWZmZXJPcGVyYXRpb24gPT4gKHtcbiAgICAgIGV4ZWN1dGU6IHRoaXMucmVtb3ZlRXhlY3V0b3IuYmluZChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZGF0YS5zdGFydE9mZnNldCxcbiAgICAgICAgZGF0YS5lbmRPZmZzZXRcbiAgICAgICksXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7XG4gICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogU3RhcnRlZCBmbHVzaGluZyAke2RhdGEuc3RhcnRPZmZzZXR9IC0+ICR7ZGF0YS5lbmRPZmZzZXR9IGZvciAke3R5cGV9IFNvdXJjZSBCdWZmZXJgKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogRmluaXNoZWQgZmx1c2hpbmcgJHtkYXRhLnN0YXJ0T2Zmc2V0fSAtPiAke2RhdGEuZW5kT2Zmc2V0fSBmb3IgJHt0eXBlfSBTb3VyY2UgQnVmZmVyYCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB7IHR5cGUgfSk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogKGUpID0+IHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYFtidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCB0byByZW1vdmUgZnJvbSAke3R5cGV9IFNvdXJjZUJ1ZmZlcmAsXG4gICAgICAgICAgZVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGlmIChkYXRhLnR5cGUpIHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChmbHVzaE9wZXJhdGlvbihkYXRhLnR5cGUpLCBkYXRhLnR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkuZm9yRWFjaCgodHlwZTogU291cmNlQnVmZmVyTmFtZSkgPT4ge1xuICAgICAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQoZmx1c2hPcGVyYXRpb24odHlwZSksIHR5cGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uRnJhZ1BhcnNlZChldmVudDogRXZlbnRzLkZSQUdfUEFSU0VELCBkYXRhOiBGcmFnUGFyc2VkRGF0YSkge1xuICAgIGNvbnN0IHsgZnJhZywgcGFydCB9ID0gZGF0YTtcbiAgICBjb25zdCBidWZmZXJzQXBwZW5kZWRUbzogQXJyYXk8U291cmNlQnVmZmVyTmFtZT4gPSBbXTtcbiAgICBjb25zdCBlbGVtZW50YXJ5U3RyZWFtcyA9IHBhcnRcbiAgICAgID8gcGFydC5lbGVtZW50YXJ5U3RyZWFtc1xuICAgICAgOiBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT10pIHtcbiAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ2F1ZGlvdmlkZW8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT10pIHtcbiAgICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgnYXVkaW8nKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dKSB7XG4gICAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ3ZpZGVvJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb25VbmJsb2NrZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgZnJhZy5zdGF0cy5idWZmZXJpbmcuZW5kID0gbm93O1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgcGFydC5zdGF0cy5idWZmZXJpbmcuZW5kID0gbm93O1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB7XG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBpZDogZnJhZy50eXBlLFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChidWZmZXJzQXBwZW5kZWRUby5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICBgRnJhZ21lbnRzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgRWxlbWVudGFyeVN0cmVhbVR5cGUgc2V0LiB0eXBlOiAke2ZyYWcudHlwZX0gbGV2ZWw6ICR7ZnJhZy5sZXZlbH0gc246ICR7ZnJhZy5zbn1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuYmxvY2tCdWZmZXJzKG9uVW5ibG9ja2VkLCBidWZmZXJzQXBwZW5kZWRUbyk7XG4gIH1cblxuICBwcml2YXRlIG9uRnJhZ0NoYW5nZWQoZXZlbnQ6IEV2ZW50cy5GUkFHX0NIQU5HRUQsIGRhdGE6IEZyYWdDaGFuZ2VkRGF0YSkge1xuICAgIHRoaXMuZmx1c2hCYWNrQnVmZmVyKCk7XG4gIH1cblxuICAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIGVuZGVkIGFuZCB0cmlnZ2VyIGNoZWNrRW9zKClcbiAgLy8gYW4gdW5kZWZpbmVkIGRhdGEudHlwZSB3aWxsIG1hcmsgYWxsIGJ1ZmZlcnMgYXMgRU9TLlxuICBwcm90ZWN0ZWQgb25CdWZmZXJFb3MoZXZlbnQ6IEV2ZW50cy5CVUZGRVJfRU9TLCBkYXRhOiBCdWZmZXJFT1NEYXRhKSB7XG4gICAgY29uc3QgZW5kZWQgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkucmVkdWNlKChhY2MsIHR5cGUpID0+IHtcbiAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICBpZiAoc2IgJiYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICBzYi5lbmRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoIXNiLmVuZGVkKSB7XG4gICAgICAgICAgc2IuZW5kZWQgPSB0cnVlO1xuICAgICAgICAgIGxvZ2dlci5sb2coYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gc291cmNlQnVmZmVyIG5vdyBFT1NgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyAmJiAhISghc2IgfHwgc2IuZW5kZWQpO1xuICAgIH0sIHRydWUpO1xuXG4gICAgaWYgKGVuZGVkKSB7XG4gICAgICBsb2dnZXIubG9nKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBRdWV1ZWluZyBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpYCk7XG4gICAgICB0aGlzLmJsb2NrQnVmZmVycygoKSA9PiB7XG4gICAgICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgIHNiLmVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgbWVkaWFTb3VyY2UgfSA9IHRoaXM7XG4gICAgICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgYFtidWZmZXItY29udHJvbGxlcl06IENvdWxkIG5vdCBjYWxsIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCkuIG1lZGlhU291cmNlLnJlYWR5U3RhdGU6ICR7bWVkaWFTb3VyY2UucmVhZHlTdGF0ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmxvZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQ2FsbGluZyBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpYCk7XG4gICAgICAgIC8vIEFsbG93IHRoaXMgdG8gdGhyb3cgYW5kIGJlIGNhdWdodCBieSB0aGUgZW5xdWV1ZWluZyBmdW5jdGlvblxuICAgICAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uTGV2ZWxVcGRhdGVkKFxuICAgIGV2ZW50OiBFdmVudHMuTEVWRUxfVVBEQVRFRCxcbiAgICB7IGRldGFpbHMgfTogTGV2ZWxVcGRhdGVkRGF0YVxuICApIHtcbiAgICBpZiAoIWRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuXG4gICAgaWYgKHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYmxvY2tCdWZmZXJzKHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24uYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgICB9XG4gIH1cblxuICBmbHVzaEJhY2tCdWZmZXIoKSB7XG4gICAgY29uc3QgeyBobHMsIGRldGFpbHMsIG1lZGlhLCBzb3VyY2VCdWZmZXIgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSB8fCBkZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlQnVmZmVyVHlwZXMgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCk7XG4gICAgaWYgKCFzb3VyY2VCdWZmZXJUeXBlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IGZvciBkZXByZWNhdGVkIGxpdmVCYWNrQnVmZmVyTGVuZ3RoXG4gICAgY29uc3QgYmFja0J1ZmZlckxlbmd0aCA9XG4gICAgICBkZXRhaWxzLmxpdmUgJiYgaGxzLmNvbmZpZy5saXZlQmFja0J1ZmZlckxlbmd0aCAhPT0gbnVsbFxuICAgICAgICA/IGhscy5jb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGhcbiAgICAgICAgOiBobHMuY29uZmlnLmJhY2tCdWZmZXJMZW5ndGg7XG5cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShiYWNrQnVmZmVyTGVuZ3RoKSB8fCBiYWNrQnVmZmVyTGVuZ3RoIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgdGFyZ2V0RHVyYXRpb24gPSBkZXRhaWxzLmxldmVsVGFyZ2V0RHVyYXRpb247XG4gICAgY29uc3QgbWF4QmFja0J1ZmZlckxlbmd0aCA9IE1hdGgubWF4KGJhY2tCdWZmZXJMZW5ndGgsIHRhcmdldER1cmF0aW9uKTtcbiAgICBjb25zdCB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPVxuICAgICAgTWF0aC5mbG9vcihjdXJyZW50VGltZSAvIHRhcmdldER1cmF0aW9uKSAqIHRhcmdldER1cmF0aW9uIC1cbiAgICAgIG1heEJhY2tCdWZmZXJMZW5ndGg7XG4gICAgc291cmNlQnVmZmVyVHlwZXMuZm9yRWFjaCgodHlwZTogU291cmNlQnVmZmVyTmFtZSkgPT4ge1xuICAgICAgY29uc3Qgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICBpZiAoc2IpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc2IpO1xuICAgICAgICAvLyB3aGVuIHRhcmdldCBidWZmZXIgc3RhcnQgZXhjZWVkcyBhY3R1YWwgYnVmZmVyIHN0YXJ0XG4gICAgICAgIGlmIChcbiAgICAgICAgICBidWZmZXJlZC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID4gYnVmZmVyZWQuc3RhcnQoMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkJBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gU3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBldmVudDpcbiAgICAgICAgICBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVELCB7XG4gICAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHNiLmVuZGVkICYmXG4gICAgICAgICAgICBidWZmZXJlZC5lbmQoYnVmZmVyZWQubGVuZ3RoIC0gMSkgLSBjdXJyZW50VGltZSA8IHRhcmdldER1cmF0aW9uICogMlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgIGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBDYW5ub3QgZmx1c2ggJHt0eXBlfSBiYWNrIGJ1ZmZlciB3aGlsZSBTb3VyY2VCdWZmZXIgaXMgaW4gZW5kZWQgc3RhdGVgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiAwLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24sXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byBjdXJyZW50IGxldmVsIGR1cmF0aW9uIG9yIG92ZXJyaWRlIHRvIEluZmluaXR5IGlmIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyXG4gICAqICdsaXZlRHVyYXRpb25JbmZpbml0eWAgaXMgc2V0IHRvIGB0cnVlYFxuICAgKiBNb3JlIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zNTVcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuZGV0YWlscyB8fFxuICAgICAgIXRoaXMubWVkaWEgfHxcbiAgICAgICF0aGlzLm1lZGlhU291cmNlIHx8XG4gICAgICB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJ1xuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGRldGFpbHMsIGhscywgbWVkaWEsIG1lZGlhU291cmNlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxldmVsRHVyYXRpb24gPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydCArIGRldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICBjb25zdCBtZWRpYUR1cmF0aW9uID0gbWVkaWEuZHVyYXRpb247XG4gICAgY29uc3QgbXNEdXJhdGlvbiA9IE51bWJlci5pc0Zpbml0ZShtZWRpYVNvdXJjZS5kdXJhdGlvbilcbiAgICAgID8gbWVkaWFTb3VyY2UuZHVyYXRpb25cbiAgICAgIDogMDtcblxuICAgIGlmIChkZXRhaWxzLmxpdmUgJiYgaGxzLmNvbmZpZy5saXZlRHVyYXRpb25JbmZpbml0eSkge1xuICAgICAgLy8gT3ZlcnJpZGUgZHVyYXRpb24gdG8gSW5maW5pdHlcbiAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaXMgc2V0IHRvIEluZmluaXR5J1xuICAgICAgKTtcbiAgICAgIG1lZGlhU291cmNlLmR1cmF0aW9uID0gSW5maW5pdHk7XG4gICAgICB0aGlzLnVwZGF0ZVNlZWthYmxlUmFuZ2UoZGV0YWlscyk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIChsZXZlbER1cmF0aW9uID4gbXNEdXJhdGlvbiAmJiBsZXZlbER1cmF0aW9uID4gbWVkaWFEdXJhdGlvbikgfHxcbiAgICAgICFOdW1iZXIuaXNGaW5pdGUobWVkaWFEdXJhdGlvbilcbiAgICApIHtcbiAgICAgIC8vIGxldmVsRHVyYXRpb24gd2FzIHRoZSBsYXN0IHZhbHVlIHdlIHNldC5cbiAgICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxuICAgICAgLy8gb25seSB1cGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxuICAgICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbFxuICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgYFtidWZmZXItY29udHJvbGxlcl06IFVwZGF0aW5nIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byAke2xldmVsRHVyYXRpb24udG9GaXhlZChcbiAgICAgICAgICAzXG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICAgIG1lZGlhU291cmNlLmR1cmF0aW9uID0gbGV2ZWxEdXJhdGlvbjtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVTZWVrYWJsZVJhbmdlKGxldmVsRGV0YWlscykge1xuICAgIGNvbnN0IG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzO1xuICAgIGNvbnN0IGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbiAmJiBsZXZlbERldGFpbHMubGl2ZSAmJiBtZWRpYVNvdXJjZT8uc2V0TGl2ZVNlZWthYmxlUmFuZ2UpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZnJhZ21lbnRzWzBdLnN0YXJ0KTtcbiAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBzdGFydCArIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICAgIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja1BlbmRpbmdUcmFja3MoKSB7XG4gICAgY29uc3QgeyBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkLCBvcGVyYXRpb25RdWV1ZSwgcGVuZGluZ1RyYWNrcyB9ID0gdGhpcztcblxuICAgIC8vIENoZWNrIGlmIHdlJ3ZlIHJlY2VpdmVkIGFsbCBvZiB0aGUgZXhwZWN0ZWQgYnVmZmVyQ29kZWMgZXZlbnRzLiBXaGVuIG5vbmUgcmVtYWluLCBjcmVhdGUgYWxsIHRoZSBzb3VyY2VCdWZmZXJzIGF0IG9uY2UuXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgTVNFIHNwZWMgYWxsb3dzIGltcGxlbWVudGF0aW9ucyB0byB0aHJvdyBRdW90YUV4Y2VlZGVkRXJyb3JzIGlmIGNyZWF0aW5nIG5ldyBzb3VyY2VCdWZmZXJzIGFmdGVyXG4gICAgLy8gZGF0YSBoYXMgYmVlbiBhcHBlbmRlZCB0byBleGlzdGluZyBvbmVzLlxuICAgIC8vIDIgdHJhY2tzIGlzIHRoZSBtYXggKG9uZSBmb3IgYXVkaW8sIG9uZSBmb3IgdmlkZW8pLiBJZiB3ZSd2ZSByZWFjaCB0aGlzIG1heCBnbyBhaGVhZCBhbmQgY3JlYXRlIHRoZSBidWZmZXJzLlxuICAgIGNvbnN0IHBlbmRpbmdUcmFja3NDb3VudCA9IE9iamVjdC5rZXlzKHBlbmRpbmdUcmFja3MpLmxlbmd0aDtcbiAgICBpZiAoXG4gICAgICAocGVuZGluZ1RyYWNrc0NvdW50ICYmICFidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkKSB8fFxuICAgICAgcGVuZGluZ1RyYWNrc0NvdW50ID09PSAyXG4gICAgKSB7XG4gICAgICAvLyBvaywgbGV0J3MgY3JlYXRlIHRoZW0gbm93ICFcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgLy8gYXBwZW5kIGFueSBwZW5kaW5nIHNlZ21lbnRzIG5vdyAhXG4gICAgICBjb25zdCBidWZmZXJzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB7IHRyYWNrczogdGhpcy50cmFja3MgfSk7XG4gICAgICAgIGJ1ZmZlcnMuZm9yRWFjaCgodHlwZTogU291cmNlQnVmZmVyTmFtZSkgPT4ge1xuICAgICAgICAgIG9wZXJhdGlvblF1ZXVlLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICdjb3VsZCBub3QgY3JlYXRlIHNvdXJjZSBidWZmZXIgZm9yIG1lZGlhIGNvZGVjKHMpJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGNyZWF0ZVNvdXJjZUJ1ZmZlcnModHJhY2tzOiBUcmFja1NldCkge1xuICAgIGNvbnN0IHsgc291cmNlQnVmZmVyLCBtZWRpYVNvdXJjZSB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhU291cmNlKSB7XG4gICAgICB0aHJvdyBFcnJvcignY3JlYXRlU291cmNlQnVmZmVycyBjYWxsZWQgd2hlbiBtZWRpYVNvdXJjZSB3YXMgbnVsbCcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgIGlmICghc291cmNlQnVmZmVyW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lIGFzIGtleW9mIFRyYWNrU2V0XTtcbiAgICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgYHNvdXJjZSBidWZmZXIgZXhpc3RzIGZvciB0cmFjayAke3RyYWNrTmFtZX0sIGhvd2V2ZXIgdHJhY2sgZG9lcyBub3RgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1c2UgbGV2ZWxDb2RlYyBhcyBmaXJzdCBwcmlvcml0eVxuICAgICAgICBjb25zdCBjb2RlYyA9IHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWM7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gYCR7dHJhY2suY29udGFpbmVyfTtjb2RlY3M9JHtjb2RlY31gO1xuICAgICAgICBsb2dnZXIubG9nKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBjcmVhdGluZyBzb3VyY2VCdWZmZXIoJHttaW1lVHlwZX0pYCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2IgPSAoc291cmNlQnVmZmVyW3RyYWNrTmFtZV0gPVxuICAgICAgICAgICAgbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWVUeXBlKSk7XG4gICAgICAgICAgY29uc3Qgc2JOYW1lID0gdHJhY2tOYW1lIGFzIFNvdXJjZUJ1ZmZlck5hbWU7XG4gICAgICAgICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcihzYk5hbWUsICd1cGRhdGVzdGFydCcsIHRoaXMuX29uU0JVcGRhdGVTdGFydCk7XG4gICAgICAgICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcihzYk5hbWUsICd1cGRhdGVlbmQnLCB0aGlzLl9vblNCVXBkYXRlRW5kKTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ2Vycm9yJywgdGhpcy5fb25TQlVwZGF0ZUVycm9yKTtcbiAgICAgICAgICB0aGlzLnRyYWNrc1t0cmFja05hbWVdID0ge1xuICAgICAgICAgICAgYnVmZmVyOiBzYixcbiAgICAgICAgICAgIGNvZGVjOiBjb2RlYyxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyLFxuICAgICAgICAgICAgbGV2ZWxDb2RlYzogdHJhY2subGV2ZWxDb2RlYyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0cmFjay5tZXRhZGF0YSxcbiAgICAgICAgICAgIGlkOiB0cmFjay5pZCxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFkZCBzb3VyY2VCdWZmZXI6ICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBLZWVwIGFzIGFycm93IGZ1bmN0aW9ucyBzbyB0aGF0IHdlIGNhbiBkaXJlY3RseSByZWZlcmVuY2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IGFzIGV2ZW50IGxpc3RlbmVyc1xuICBwcml2YXRlIF9vbk1lZGlhU291cmNlT3BlbiA9ICgpID0+IHtcbiAgICBjb25zdCB7IG1lZGlhLCBtZWRpYVNvdXJjZSB9ID0gdGhpcztcbiAgICBsb2dnZXIubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBzb3VyY2Ugb3BlbmVkJyk7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbXB0aWVkJywgdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHsgbWVkaWEgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAvLyBvbmNlIHJlY2VpdmVkLCBkb24ndCBsaXN0ZW4gYW55bW9yZSB0byBzb3VyY2VvcGVuIGV2ZW50XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICB9O1xuXG4gIHByaXZhdGUgX29uTWVkaWFTb3VyY2VDbG9zZSA9ICgpID0+IHtcbiAgICBsb2dnZXIubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBzb3VyY2UgY2xvc2VkJyk7XG4gIH07XG5cbiAgcHJpdmF0ZSBfb25NZWRpYVNvdXJjZUVuZGVkID0gKCkgPT4ge1xuICAgIGxvZ2dlci5sb2coJ1tidWZmZXItY29udHJvbGxlcl06IE1lZGlhIHNvdXJjZSBlbmRlZCcpO1xuICB9O1xuXG4gIHByaXZhdGUgX29uTWVkaWFFbXB0aWVkID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgbWVkaWEsIF9vYmplY3RVcmwgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLnNyYyAhPT0gX29iamVjdFVybCkge1xuICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICBgTWVkaWEgZWxlbWVudCBzcmMgd2FzIHNldCB3aGlsZSBhdHRhY2hpbmcgTWVkaWFTb3VyY2UgKCR7X29iamVjdFVybH0gPiAke21lZGlhLnNyY30pYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBfb25TQlVwZGF0ZVN0YXJ0KHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUpIHtcbiAgICBjb25zdCB7IG9wZXJhdGlvblF1ZXVlIH0gPSB0aGlzO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgb3BlcmF0aW9uLm9uU3RhcnQoKTtcbiAgfVxuXG4gIHByaXZhdGUgX29uU0JVcGRhdGVFbmQodHlwZTogU291cmNlQnVmZmVyTmFtZSkge1xuICAgIGNvbnN0IHsgb3BlcmF0aW9uUXVldWUgfSA9IHRoaXM7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gb3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcbiAgICBvcGVyYXRpb24ub25Db21wbGV0ZSgpO1xuICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gIH1cblxuICBwcml2YXRlIF9vblNCVXBkYXRlRXJyb3IodHlwZTogU291cmNlQnVmZmVyTmFtZSwgZXZlbnQ6IEV2ZW50KSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7dHlwZX0gU291cmNlQnVmZmVyIGVycm9yYCk7XG4gICAgbG9nZ2VyLmVycm9yKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiAke2Vycm9yfWAsIGV2ZW50KTtcbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgLy8gU291cmNlQnVmZmVyIGVycm9ycyBhcmUgbm90IG5lY2Vzc2FyaWx5IGZhdGFsOyBpZiBzbywgdGhlIEhUTUxNZWRpYUVsZW1lbnQgd2lsbCBmaXJlIGFuIGVycm9yIGV2ZW50XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUixcbiAgICAgIGVycm9yLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgIH0pO1xuICAgIC8vIHVwZGF0ZWVuZCBpcyBhbHdheXMgZmlyZWQgYWZ0ZXIgZXJyb3IsIHNvIHdlJ2xsIGFsbG93IHRoYXQgdG8gc2hpZnQgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIG9mZiBvZiB0aGUgcXVldWVcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLm9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgaWYgKG9wZXJhdGlvbikge1xuICAgICAgb3BlcmF0aW9uLm9uRXJyb3IoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgbWV0aG9kIG11c3QgcmVzdWx0IGluIGFuIHVwZGF0ZWVuZCBldmVudDsgaWYgcmVtb3ZlIGlzIG5vdCBjYWxsZWQsIF9vblNCVXBkYXRlRW5kIG11c3QgYmUgY2FsbGVkIG1hbnVhbGx5XG4gIHByaXZhdGUgcmVtb3ZlRXhlY3V0b3IoXG4gICAgdHlwZTogU291cmNlQnVmZmVyTmFtZSxcbiAgICBzdGFydE9mZnNldDogbnVtYmVyLFxuICAgIGVuZE9mZnNldDogbnVtYmVyXG4gICkge1xuICAgIGNvbnN0IHsgbWVkaWEsIG1lZGlhU291cmNlLCBvcGVyYXRpb25RdWV1ZSwgc291cmNlQnVmZmVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIGlmICghbWVkaWEgfHwgIW1lZGlhU291cmNlIHx8ICFzYikge1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgIGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBBdHRlbXB0aW5nIHRvIHJlbW92ZSBmcm9tIHRoZSAke3R5cGV9IFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0YFxuICAgICAgKTtcbiAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhRHVyYXRpb24gPSBOdW1iZXIuaXNGaW5pdGUobWVkaWEuZHVyYXRpb24pXG4gICAgICA/IG1lZGlhLmR1cmF0aW9uXG4gICAgICA6IEluZmluaXR5O1xuICAgIGNvbnN0IG1zRHVyYXRpb24gPSBOdW1iZXIuaXNGaW5pdGUobWVkaWFTb3VyY2UuZHVyYXRpb24pXG4gICAgICA/IG1lZGlhU291cmNlLmR1cmF0aW9uXG4gICAgICA6IEluZmluaXR5O1xuICAgIGNvbnN0IHJlbW92ZVN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnRPZmZzZXQpO1xuICAgIGNvbnN0IHJlbW92ZUVuZCA9IE1hdGgubWluKGVuZE9mZnNldCwgbWVkaWFEdXJhdGlvbiwgbXNEdXJhdGlvbik7XG4gICAgaWYgKHJlbW92ZUVuZCA+IHJlbW92ZVN0YXJ0ICYmICFzYi5lbmRpbmcpIHtcbiAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICBsb2dnZXIubG9nKFxuICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogUmVtb3ZpbmcgWyR7cmVtb3ZlU3RhcnR9LCR7cmVtb3ZlRW5kfV0gZnJvbSB0aGUgJHt0eXBlfSBTb3VyY2VCdWZmZXJgXG4gICAgICApO1xuICAgICAgc2IucmVtb3ZlKHJlbW92ZVN0YXJ0LCByZW1vdmVFbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDeWNsZSB0aGUgcXVldWVcbiAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBtZXRob2QgbXVzdCByZXN1bHQgaW4gYW4gdXBkYXRlZW5kIGV2ZW50OyBpZiBhcHBlbmQgaXMgbm90IGNhbGxlZCwgX29uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgcHJpdmF0ZSBhcHBlbmRFeGVjdXRvcihkYXRhOiBVaW50OEFycmF5LCB0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSB7XG4gICAgY29uc3QgeyBvcGVyYXRpb25RdWV1ZSwgc291cmNlQnVmZmVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIGlmICghc2IpIHtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICBgW2J1ZmZlci1jb250cm9sbGVyXTogQXR0ZW1wdGluZyB0byBhcHBlbmQgdG8gdGhlICR7dHlwZX0gU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RgXG4gICAgICApO1xuICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgIHNiLmFwcGVuZEJ1ZmZlcihkYXRhKTtcbiAgfVxuXG4gIC8vIEVucXVldWVzIGFuIG9wZXJhdGlvbiB0byBlYWNoIFNvdXJjZUJ1ZmZlciBxdWV1ZSB3aGljaCwgdXBvbiBleGVjdXRpb24sIHJlc29sdmVzIGEgcHJvbWlzZS4gV2hlbiBhbGwgcHJvbWlzZXNcbiAgLy8gcmVzb2x2ZSwgdGhlIG9uVW5ibG9ja2VkIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkLiBGdW5jdGlvbnMgY2FsbGluZyB0aGlzIG1ldGhvZCBkbyBub3QgbmVlZCB0byB1bmJsb2NrIHRoZSBxdWV1ZVxuICAvLyB1cG9uIGNvbXBsZXRpb24sIHNpbmNlIHdlIGFscmVhZHkgZG8gaXQgaGVyZVxuICBwcml2YXRlIGJsb2NrQnVmZmVycyhcbiAgICBvblVuYmxvY2tlZDogKCkgPT4gdm9pZCxcbiAgICBidWZmZXJzOiBBcnJheTxTb3VyY2VCdWZmZXJOYW1lPiA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKVxuICApIHtcbiAgICBpZiAoIWJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKFxuICAgICAgICAnW2J1ZmZlci1jb250cm9sbGVyXTogQmxvY2tpbmcgb3BlcmF0aW9uIHJlcXVlc3RlZCwgYnV0IG5vIFNvdXJjZUJ1ZmZlcnMgZXhpc3QnXG4gICAgICApO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihvblVuYmxvY2tlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgb3BlcmF0aW9uUXVldWUgfSA9IHRoaXM7XG5cbiAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nICR7YnVmZmVyc30gU291cmNlQnVmZmVyYCk7XG4gICAgY29uc3QgYmxvY2tpbmdPcGVyYXRpb25zID0gYnVmZmVycy5tYXAoKHR5cGUpID0+XG4gICAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmRCbG9ja2VyKHR5cGUgYXMgU291cmNlQnVmZmVyTmFtZSlcbiAgICApO1xuICAgIFByb21pc2UuYWxsKGJsb2NraW5nT3BlcmF0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nIG9wZXJhdGlvbiByZXNvbHZlZDsgdW5ibG9ja2luZyAke2J1ZmZlcnN9IFNvdXJjZUJ1ZmZlcmApO1xuICAgICAgb25VbmJsb2NrZWQoKTtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAvLyBPbmx5IGN5Y2xlIHRoZSBxdWV1ZSBpZiB0aGUgU0IgaXMgbm90IHVwZGF0aW5nLiBUaGVyZSdzIGEgYnVnIGluIENocm9tZSB3aGljaCBzZXRzIHRoZSBTQiB1cGRhdGluZyBmbGFnIHRvXG4gICAgICAgIC8vIHRydWUgd2hlbiBjaGFuZ2luZyB0aGUgTWVkaWFTb3VyY2UgZHVyYXRpb24gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk1OTM1OSZjYW49MiZxPW1lZGlhc291cmNlJTIwZHVyYXRpb24pXG4gICAgICAgIC8vIFdoaWxlIHRoaXMgaXMgYSB3b3JrYXJvdW5kLCBpdCdzIHByb2JhYmx5IHVzZWZ1bCB0byBoYXZlIGFyb3VuZFxuICAgICAgICBpZiAoIXNiPy51cGRhdGluZykge1xuICAgICAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRTb3VyY2VCdWZmZXJUeXBlcygpOiBBcnJheTxTb3VyY2VCdWZmZXJOYW1lPiB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVyKSBhcyBBcnJheTxTb3VyY2VCdWZmZXJOYW1lPjtcbiAgfVxuXG4gIHByaXZhdGUgYWRkQnVmZmVyTGlzdGVuZXIoXG4gICAgdHlwZTogU291cmNlQnVmZmVyTmFtZSxcbiAgICBldmVudDogc3RyaW5nLFxuICAgIGZuOiBGdW5jdGlvblxuICApIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lciA9IGZuLmJpbmQodGhpcywgdHlwZSk7XG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7IGV2ZW50LCBsaXN0ZW5lciB9KTtcbiAgICBidWZmZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmVCdWZmZXJMaXN0ZW5lcnModHlwZTogU291cmNlQnVmZmVyTmFtZSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLmZvckVhY2goKGwpID0+IHtcbiAgICAgIGJ1ZmZlci5yZW1vdmVFdmVudExpc3RlbmVyKGwuZXZlbnQsIGwubGlzdGVuZXIpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogY2FwIHN0cmVhbSBsZXZlbCB0byBtZWRpYSBzaXplIGRpbWVuc2lvbiBjb250cm9sbGVyXG4gKi9cblxuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgTGV2ZWwgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgdHlwZSB7XG4gIE1hbmlmZXN0UGFyc2VkRGF0YSxcbiAgQnVmZmVyQ29kZWNzRGF0YSxcbiAgTWVkaWFBdHRhY2hpbmdEYXRhLFxuICBGUFNEcm9wTGV2ZWxDYXBwaW5nRGF0YSxcbn0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcbmltcG9ydCBTdHJlYW1Db250cm9sbGVyIGZyb20gJy4vc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRBUEkgfSBmcm9tICcuLi90eXBlcy9jb21wb25lbnQtYXBpJztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuXG50eXBlIFJlc3RyaWN0ZWRMZXZlbCA9IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXI7IGJpdHJhdGU6IG51bWJlciB9O1xuY2xhc3MgQ2FwTGV2ZWxDb250cm9sbGVyIGltcGxlbWVudHMgQ29tcG9uZW50QVBJIHtcbiAgcHJpdmF0ZSBobHM6IEhscztcbiAgcHJpdmF0ZSBhdXRvTGV2ZWxDYXBwaW5nOiBudW1iZXI7XG4gIHByaXZhdGUgZmlyc3RMZXZlbDogbnVtYmVyO1xuICBwcml2YXRlIG1lZGlhOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbDtcbiAgcHJpdmF0ZSByZXN0cmljdGVkTGV2ZWxzOiBSZXN0cmljdGVkTGV2ZWxbXTtcbiAgcHJpdmF0ZSB0aW1lcjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIGNsaWVudFJlY3Q6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSB8IG51bGw7XG4gIHByaXZhdGUgc3RyZWFtQ29udHJvbGxlcj86IFN0cmVhbUNvbnRyb2xsZXI7XG5cbiAgY29uc3RydWN0b3IoaGxzOiBIbHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5maXJzdExldmVsID0gLTE7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuXG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgcHVibGljIHNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcjogU3RyZWFtQ29udHJvbGxlcikge1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHN0cmVhbUNvbnRyb2xsZXI7XG4gIH1cblxuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcigpO1xuICAgIGlmICh0aGlzLmhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgIHRoaXMuc3RvcENhcHBpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBudWxsO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuRlBTX0RST1BfTEVWRUxfQ0FQUElORywgdGhpcy5vbkZwc0Ryb3BMZXZlbENhcHBpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdW5yZWdpc3Rlckxpc3RlbmVyKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHRoaXMub25GcHNEcm9wTGV2ZWxDYXBwaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkZwc0Ryb3BMZXZlbENhcHBpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLFxuICAgIGRhdGE6IEZQU0Ryb3BMZXZlbENhcHBpbmdEYXRhXG4gICkge1xuICAgIC8vIERvbid0IGFkZCBhIHJlc3RyaWN0ZWQgbGV2ZWwgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tkYXRhLmRyb3BwZWRMZXZlbF07XG4gICAgaWYgKHRoaXMuaXNMZXZlbEFsbG93ZWQobGV2ZWwpKSB7XG4gICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMucHVzaCh7XG4gICAgICAgIGJpdHJhdGU6IGxldmVsLmJpdHJhdGUsXG4gICAgICAgIGhlaWdodDogbGV2ZWwuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogbGV2ZWwud2lkdGgsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NZWRpYUF0dGFjaGluZyhcbiAgICBldmVudDogRXZlbnRzLk1FRElBX0FUVEFDSElORyxcbiAgICBkYXRhOiBNZWRpYUF0dGFjaGluZ0RhdGFcbiAgKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1hbmlmZXN0UGFyc2VkKFxuICAgIGV2ZW50OiBFdmVudHMuTUFOSUZFU1RfUEFSU0VELFxuICAgIGRhdGE6IE1hbmlmZXN0UGFyc2VkRGF0YVxuICApIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSBkYXRhLmZpcnN0TGV2ZWw7XG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gU3RhcnQgY2FwcGluZyBpbW1lZGlhdGVseSBpZiB0aGUgbWFuaWZlc3QgaGFzIHNpZ25hbGVkIHZpZGVvIGNvZGVjc1xuICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgICB9XG4gIH1cblxuICAvLyBPbmx5IGFjdGl2YXRlIGNhcHBpbmcgd2hlbiBwbGF5aW5nIGEgdmlkZW8gc3RyZWFtOyBvdGhlcndpc2UsIG11bHRpLWJpdHJhdGUgYXVkaW8tb25seSBzdHJlYW1zIHdpbGwgYmUgcmVzdHJpY3RlZFxuICAvLyB0byB0aGUgZmlyc3QgbGV2ZWxcbiAgcHJvdGVjdGVkIG9uQnVmZmVyQ29kZWNzKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0NPREVDUyxcbiAgICBkYXRhOiBCdWZmZXJDb2RlY3NEYXRhXG4gICkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplICYmIGRhdGEudmlkZW8pIHtcbiAgICAgIC8vIElmIHRoZSBtYW5pZmVzdCBkaWQgbm90IHNpZ25hbCBhIHZpZGVvIGNvZGVjIGNhcHBpbmcgaGFzIGJlZW4gZGVmZXJyZWQgdW50aWwgd2UncmUgY2VydGFpbiB2aWRlbyBpcyBwcmVzZW50XG4gICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHRoaXMuc3RvcENhcHBpbmcoKTtcbiAgfVxuXG4gIGRldGVjdFBsYXllclNpemUoKSB7XG4gICAgaWYgKHRoaXMubWVkaWEgJiYgdGhpcy5tZWRpYUhlaWdodCA+IDAgJiYgdGhpcy5tZWRpYVdpZHRoID4gMCkge1xuICAgICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgaWYgKGxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gdGhpcy5nZXRNYXhMZXZlbChsZXZlbHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA+IHRoaXMuYXV0b0xldmVsQ2FwcGluZyAmJlxuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlclxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBpZiBhdXRvIGxldmVsIGNhcHBpbmcgaGFzIGEgaGlnaGVyIHZhbHVlIGZvciB0aGUgcHJldmlvdXMgb25lLCBmbHVzaCB0aGUgYnVmZmVyIHVzaW5nIG5leHRMZXZlbFN3aXRjaFxuICAgICAgICAgIC8vIHVzdWFsbHkgaGFwcGVuIHdoZW4gdGhlIHVzZXIgZ28gdG8gdGhlIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gaGxzLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcbiAgICovXG4gIGdldE1heExldmVsKGNhcExldmVsSW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgIGlmICghbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkTGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihcbiAgICAgIChsZXZlbCwgaW5kZXgpID0+IHRoaXMuaXNMZXZlbEFsbG93ZWQobGV2ZWwpICYmIGluZGV4IDw9IGNhcExldmVsSW5kZXhcbiAgICApO1xuXG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyLmdldE1heExldmVsQnlNZWRpYVNpemUoXG4gICAgICB2YWxpZExldmVscyxcbiAgICAgIHRoaXMubWVkaWFXaWR0aCxcbiAgICAgIHRoaXMubWVkaWFIZWlnaHRcbiAgICApO1xuICB9XG5cbiAgc3RhcnRDYXBwaW5nKCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAvLyBEb24ndCByZXNldCBjYXBwaW5nIGlmIHN0YXJ0ZWQgdHdpY2U7IHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgbWFuaWZlc3Qgc2lnbmFscyBhIHZpZGVvIGNvZGVjXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLmhscy5maXJzdExldmVsID0gdGhpcy5nZXRNYXhMZXZlbCh0aGlzLmZpcnN0TGV2ZWwpO1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLmRldGVjdFBsYXllclNpemUuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gIH1cblxuICBzdG9wQ2FwcGluZygpIHtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSAtMTtcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0RGltZW5zaW9ucygpOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0ge1xuICAgIGlmICh0aGlzLmNsaWVudFJlY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudFJlY3Q7XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBib3VuZHNSZWN0ID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgfTtcblxuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgY2xpZW50UmVjdCA9IG1lZGlhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgYm91bmRzUmVjdC53aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gICAgICBib3VuZHNSZWN0LmhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICAgICAgaWYgKCFib3VuZHNSZWN0LndpZHRoICYmICFib3VuZHNSZWN0LmhlaWdodCkge1xuICAgICAgICAvLyBXaGVuIHRoZSBtZWRpYSBlbGVtZW50IGhhcyBubyB3aWR0aCBvciBoZWlnaHQgKGVxdWl2YWxlbnQgdG8gbm90IGJlaW5nIGluIHRoZSBET00pLFxuICAgICAgICAvLyB0aGVuIHVzZSBpdHMgd2lkdGggYW5kIGhlaWdodCBhdHRyaWJ1dGVzIChtZWRpYS53aWR0aCwgbWVkaWEuaGVpZ2h0KVxuICAgICAgICBib3VuZHNSZWN0LndpZHRoID1cbiAgICAgICAgICBjbGllbnRSZWN0LnJpZ2h0IC0gY2xpZW50UmVjdC5sZWZ0IHx8IG1lZGlhLndpZHRoIHx8IDA7XG4gICAgICAgIGJvdW5kc1JlY3QuaGVpZ2h0ID1cbiAgICAgICAgICBjbGllbnRSZWN0LmJvdHRvbSAtIGNsaWVudFJlY3QudG9wIHx8IG1lZGlhLmhlaWdodCB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsaWVudFJlY3QgPSBib3VuZHNSZWN0O1xuICAgIHJldHVybiBib3VuZHNSZWN0O1xuICB9XG5cbiAgZ2V0IG1lZGlhV2lkdGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaW1lbnNpb25zKCkud2lkdGggKiB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgfVxuXG4gIGdldCBtZWRpYUhlaWdodCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbnMoKS5oZWlnaHQgKiB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgfVxuXG4gIGdldCBjb250ZW50U2NhbGVGYWN0b3IoKTogbnVtYmVyIHtcbiAgICBsZXQgcGl4ZWxSYXRpbyA9IDE7XG4gICAgaWYgKCF0aGlzLmhscy5jb25maWcuaWdub3JlRGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGl4ZWxSYXRpbyA9IHNlbGYuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcbiAgfVxuXG4gIHByaXZhdGUgaXNMZXZlbEFsbG93ZWQobGV2ZWw6IExldmVsKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcmVzdHJpY3RlZExldmVscyA9IHRoaXMucmVzdHJpY3RlZExldmVscztcbiAgICByZXR1cm4gIXJlc3RyaWN0ZWRMZXZlbHMuc29tZSgocmVzdHJpY3RlZExldmVsKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBsZXZlbC5iaXRyYXRlID09PSByZXN0cmljdGVkTGV2ZWwuYml0cmF0ZSAmJlxuICAgICAgICBsZXZlbC53aWR0aCA9PT0gcmVzdHJpY3RlZExldmVsLndpZHRoICYmXG4gICAgICAgIGxldmVsLmhlaWdodCA9PT0gcmVzdHJpY3RlZExldmVsLmhlaWdodFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRNYXhMZXZlbEJ5TWVkaWFTaXplKFxuICAgIGxldmVsczogQXJyYXk8TGV2ZWw+LFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXJcbiAgKTogbnVtYmVyIHtcbiAgICBpZiAoIWxldmVscz8ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8gTGV2ZWxzIGNhbiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMgYnV0IGRpZmZlcmluZyBiYW5kd2lkdGhzIC0gc2luY2UgbGV2ZWxzIGFyZSBvcmRlcmVkLCB3ZSBjYW4gbG9vayB0byB0aGUgbmV4dFxuICAgIC8vIHRvIGRldGVybWluZSB3aGV0aGVyIHdlJ3ZlIGNob3NlbiB0aGUgZ3JlYXRlc3QgYmFuZHdpZHRoIGZvciB0aGUgbWVkaWEncyBkaW1lbnNpb25zXG4gICAgY29uc3QgYXRHcmVhdGVzdEJhbmR3aWR0aCA9IChjdXJMZXZlbCwgbmV4dExldmVsKSA9PiB7XG4gICAgICBpZiAoIW5leHRMZXZlbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3VyTGV2ZWwud2lkdGggIT09IG5leHRMZXZlbC53aWR0aCB8fFxuICAgICAgICBjdXJMZXZlbC5oZWlnaHQgIT09IG5leHRMZXZlbC5oZWlnaHRcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIElmIHdlIHJ1biB0aHJvdWdoIHRoZSBsb29wIHdpdGhvdXQgYnJlYWtpbmcsIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnMgYXJlIGdyZWF0ZXIgdGhhbiBldmVyeSBsZXZlbCwgc28gZGVmYXVsdCB0b1xuICAgIC8vIHRoZSBtYXggbGV2ZWxcbiAgICBsZXQgbWF4TGV2ZWxJbmRleCA9IGxldmVscy5sZW5ndGggLSAxO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgaWYgKFxuICAgICAgICAobGV2ZWwud2lkdGggPj0gd2lkdGggfHwgbGV2ZWwuaGVpZ2h0ID49IGhlaWdodCkgJiZcbiAgICAgICAgYXRHcmVhdGVzdEJhbmR3aWR0aChsZXZlbCwgbGV2ZWxzW2kgKyAxXSlcbiAgICAgICkge1xuICAgICAgICBtYXhMZXZlbEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heExldmVsSW5kZXg7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FwTGV2ZWxDb250cm9sbGVyO1xuIiwiaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5pbXBvcnQgdHlwZSB7IE1lZGlhQXR0YWNoaW5nRGF0YSB9IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgU3RyZWFtQ29udHJvbGxlciBmcm9tICcuL3N0cmVhbS1jb250cm9sbGVyJztcblxuY2xhc3MgRlBTQ29udHJvbGxlciBpbXBsZW1lbnRzIENvbXBvbmVudEFQSSB7XG4gIHByaXZhdGUgaGxzOiBIbHM7XG4gIHByaXZhdGUgaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIHRpbWVyPzogbnVtYmVyO1xuICBwcml2YXRlIG1lZGlhOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbGFzdFRpbWU6IGFueTtcbiAgcHJpdmF0ZSBsYXN0RHJvcHBlZEZyYW1lczogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBsYXN0RGVjb2RlZEZyYW1lczogbnVtYmVyID0gMDtcbiAgLy8gc3RyZWFtIGNvbnRyb2xsZXIgbXVzdCBiZSBwcm92aWRlZCBhcyBhIGRlcGVuZGVuY3khXG4gIHByaXZhdGUgc3RyZWFtQ29udHJvbGxlciE6IFN0cmVhbUNvbnRyb2xsZXI7XG5cbiAgY29uc3RydWN0b3IoaGxzOiBIbHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcblxuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXI6IFN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBzdHJlYW1Db250cm9sbGVyO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgfVxuXG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NZWRpYUF0dGFjaGluZyhcbiAgICBldmVudDogRXZlbnRzLk1FRElBX0FUVEFDSElORyxcbiAgICBkYXRhOiBNZWRpYUF0dGFjaGluZ0RhdGFcbiAgKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGlmIChjb25maWcuY2FwTGV2ZWxPbkZQU0Ryb3ApIHtcbiAgICAgIGNvbnN0IG1lZGlhID1cbiAgICAgICAgZGF0YS5tZWRpYSBpbnN0YW5jZW9mIHNlbGYuSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgICAgaWYgKG1lZGlhICYmIHR5cGVvZiBtZWRpYS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbChcbiAgICAgICAgdGhpcy5jaGVja0ZQU0ludGVydmFsLmJpbmQodGhpcyksXG4gICAgICAgIGNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjaGVja0ZQUyhcbiAgICB2aWRlbzogSFRNTFZpZGVvRWxlbWVudCxcbiAgICBkZWNvZGVkRnJhbWVzOiBudW1iZXIsXG4gICAgZHJvcHBlZEZyYW1lczogbnVtYmVyXG4gICkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKGRlY29kZWRGcmFtZXMpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RUaW1lKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJpb2QgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREcm9wcGVkID0gZHJvcHBlZEZyYW1lcyAtIHRoaXMubGFzdERyb3BwZWRGcmFtZXM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREZWNvZGVkID0gZGVjb2RlZEZyYW1lcyAtIHRoaXMubGFzdERlY29kZWRGcmFtZXM7XG4gICAgICAgIGNvbnN0IGRyb3BwZWRGUFMgPSAoMTAwMCAqIGN1cnJlbnREcm9wcGVkKSAvIGN1cnJlbnRQZXJpb2Q7XG4gICAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlBTX0RST1AsIHtcbiAgICAgICAgICBjdXJyZW50RHJvcHBlZDogY3VycmVudERyb3BwZWQsXG4gICAgICAgICAgY3VycmVudERlY29kZWQ6IGN1cnJlbnREZWNvZGVkLFxuICAgICAgICAgIHRvdGFsRHJvcHBlZEZyYW1lczogZHJvcHBlZEZyYW1lcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkcm9wcGVkRlBTID4gMCkge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2NoZWNrRlBTIDogZHJvcHBlZEZQUy9kZWNvZGVkRlBTOicgKyBkcm9wcGVkRlBTLygxMDAwICogY3VycmVudERlY29kZWQgLyBjdXJyZW50UGVyaW9kKSk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY3VycmVudERyb3BwZWQgPlxuICAgICAgICAgICAgaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGN1cnJlbnREZWNvZGVkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gaGxzLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAnZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgK1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID4gMCAmJlxuICAgICAgICAgICAgICAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8XG4gICAgICAgICAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPj0gY3VycmVudExldmVsKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IGN1cnJlbnRMZXZlbCxcbiAgICAgICAgICAgICAgICBkcm9wcGVkTGV2ZWw6IGhscy5jdXJyZW50TGV2ZWwsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IGRyb3BwZWRGcmFtZXM7XG4gICAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gZGVjb2RlZEZyYW1lcztcbiAgICB9XG4gIH1cblxuICBjaGVja0ZQU0ludGVydmFsKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcbiAgICAgICAgY29uc3QgdmlkZW9QbGF5YmFja1F1YWxpdHkgPSB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgICAgICB0aGlzLmNoZWNrRlBTKFxuICAgICAgICAgIHZpZGVvLFxuICAgICAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsXG4gICAgICAgICAgdmlkZW9QbGF5YmFja1F1YWxpdHkuZHJvcHBlZFZpZGVvRnJhbWVzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIVE1MVmlkZW9FbGVtZW50IGRvZXNuJ3QgaW5jbHVkZSB0aGUgd2Via2l0IHR5cGVzXG4gICAgICAgIHRoaXMuY2hlY2tGUFMoXG4gICAgICAgICAgdmlkZW8sXG4gICAgICAgICAgKHZpZGVvIGFzIGFueSkud2Via2l0RGVjb2RlZEZyYW1lQ291bnQgYXMgbnVtYmVyLFxuICAgICAgICAgICh2aWRlbyBhcyBhbnkpLndlYmtpdERyb3BwZWRGcmFtZUNvdW50IGFzIG51bWJlclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGUFNDb250cm9sbGVyO1xuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB0eXBlIHtcbiAgTG9hZGVyQ2FsbGJhY2tzLFxuICBMb2FkZXJDb250ZXh0LFxuICBMb2FkZXJTdGF0cyxcbiAgTG9hZGVyLFxuICBMb2FkZXJDb25maWd1cmF0aW9uLFxuICBMb2FkZXJSZXNwb25zZSxcbn0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7IExvYWRTdGF0cyB9IGZyb20gJy4uL2xvYWRlci9sb2FkLXN0YXRzJztcbmltcG9ydCB7IHR5cGUgSGxzQ29uZmlnLCBSZXRyeUNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBnZXRSZXRyeURlbGF5LCBzaG91bGRSZXRyeSB9IGZyb20gJy4vZXJyb3ItaGVscGVyJztcblxuY29uc3QgQUdFX0hFQURFUl9MSU5FX1JFR0VYID0gL15hZ2U6XFxzKltcXGQuXStcXHMqJC9pbTtcblxuY2xhc3MgWGhyTG9hZGVyIGltcGxlbWVudHMgTG9hZGVyPExvYWRlckNvbnRleHQ+IHtcbiAgcHJpdmF0ZSB4aHJTZXR1cDpcbiAgICB8ICgoeGhyOiBYTUxIdHRwUmVxdWVzdCwgdXJsOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkKVxuICAgIHwgbnVsbDtcbiAgcHJpdmF0ZSByZXF1ZXN0VGltZW91dD86IG51bWJlcjtcbiAgcHJpdmF0ZSByZXRyeVRpbWVvdXQ/OiBudW1iZXI7XG4gIHByaXZhdGUgcmV0cnlEZWxheTogbnVtYmVyO1xuICBwcml2YXRlIGNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGNhbGxiYWNrczogTG9hZGVyQ2FsbGJhY2tzPExvYWRlckNvbnRleHQ+IHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBjb250ZXh0ITogTG9hZGVyQ29udGV4dDtcblxuICBwcml2YXRlIGxvYWRlcjogWE1MSHR0cFJlcXVlc3QgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIHN0YXRzOiBMb2FkZXJTdGF0cztcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEhsc0NvbmZpZykge1xuICAgIHRoaXMueGhyU2V0dXAgPSBjb25maWcgPyBjb25maWcueGhyU2V0dXAgfHwgbnVsbCA6IG51bGw7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBMb2FkU3RhdHMoKTtcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSAwO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgfVxuXG4gIGFib3J0SW50ZXJuYWwoKSB7XG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXI7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgbG9hZGVyLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgaWYgKGxvYWRlci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFib3J0KCkge1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIGlmICh0aGlzLmNhbGxiYWNrcz8ub25BYm9ydCkge1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMubG9hZGVyKTtcbiAgICB9XG4gIH1cblxuICBsb2FkKFxuICAgIGNvbnRleHQ6IExvYWRlckNvbnRleHQsXG4gICAgY29uZmlnOiBMb2FkZXJDb25maWd1cmF0aW9uLFxuICAgIGNhbGxiYWNrczogTG9hZGVyQ2FsbGJhY2tzPExvYWRlckNvbnRleHQ+XG4gICkge1xuICAgIGlmICh0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4nKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0cy5sb2FkaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIHRoaXMubG9hZEludGVybmFsKCk7XG4gIH1cblxuICBsb2FkSW50ZXJuYWwoKSB7XG4gICAgY29uc3QgeyBjb25maWcsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyID0gKHRoaXMubG9hZGVyID0gbmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QoKSk7XG5cbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgc3RhdHMubG9hZGluZy5maXJzdCA9IDA7XG4gICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICBjb25zdCB4aHJTZXR1cCA9IHRoaXMueGhyU2V0dXA7XG5cbiAgICBpZiAoeGhyU2V0dXApIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0cy5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgICAgcmV0dXJuIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHMuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICAgIHRoaXMub3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcyEub25FcnJvcihcbiAgICAgICAgICAgIHsgY29kZTogeGhyLnN0YXR1cywgdGV4dDogZXJyb3IubWVzc2FnZSB9LFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHhocixcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW5BbmRTZW5kWGhyKHhociwgY29udGV4dCwgY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBvcGVuQW5kU2VuZFhocihcbiAgICB4aHI6IFhNTEh0dHBSZXF1ZXN0LFxuICAgIGNvbnRleHQ6IExvYWRlckNvbnRleHQsXG4gICAgY29uZmlnOiBMb2FkZXJDb25maWd1cmF0aW9uXG4gICkge1xuICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMuY29udGV4dC5oZWFkZXJzO1xuICAgIGNvbnN0IHsgbWF4VGltZVRvRmlyc3RCeXRlTXMsIG1heExvYWRUaW1lTXMgfSA9IGNvbmZpZy5sb2FkUG9saWN5O1xuICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXG4gICAgICAgICdSYW5nZScsXG4gICAgICAgICdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgKGNvbnRleHQucmFuZ2VFbmQgLSAxKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5yZWFkeXN0YXRlY2hhbmdlLmJpbmQodGhpcyk7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBjb250ZXh0LnJlc3BvbnNlVHlwZSBhcyBYTUxIdHRwUmVxdWVzdFJlc3BvbnNlVHlwZTtcbiAgICAvLyBzZXR1cCB0aW1lb3V0IGJlZm9yZSB3ZSBwZXJmb3JtIHJlcXVlc3RcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICBjb25maWcudGltZW91dCA9XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNcyAmJiBOdW1iZXIuaXNGaW5pdGUobWF4VGltZVRvRmlyc3RCeXRlTXMpXG4gICAgICAgID8gbWF4VGltZVRvRmlyc3RCeXRlTXNcbiAgICAgICAgOiBtYXhMb2FkVGltZU1zO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoXG4gICAgICB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksXG4gICAgICBjb25maWcudGltZW91dFxuICAgICk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfVxuXG4gIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0LCBsb2FkZXI6IHhociwgc3RhdHMgfSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0IHx8ICF4aHIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnIGFzIExvYWRlckNvbmZpZ3VyYXRpb247XG5cbiAgICAvLyBkb24ndCBwcm9jZWVkIGlmIHhociBoYXMgYmVlbiBhYm9ydGVkXG4gICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyA+PSBIRUFERVJTX1JFQ0VJVkVEXG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgaWYgKHN0YXRzLmxvYWRpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgc3RhdHMubG9hZGluZy5maXJzdCA9IE1hdGgubWF4KFxuICAgICAgICAgIHNlbGYucGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgc3RhdHMubG9hZGluZy5zdGFydFxuICAgICAgICApO1xuICAgICAgICAvLyByZWFkeVN0YXRlID49IDIgQU5EIHJlYWR5U3RhdGUgIT09NCAocmVhZHlTdGF0ZSA9IEhFQURFUlNfUkVDRUlWRUQgfHwgTE9BRElORykgcmVhcm0gdGltZW91dCBhcyB4aHIgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICBpZiAoY29uZmlnLnRpbWVvdXQgIT09IGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXMpIHtcbiAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgICBjb25maWcudGltZW91dCA9IGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXM7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dChcbiAgICAgICAgICAgIHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXMgLVxuICAgICAgICAgICAgICAoc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHhoci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgLy8gaHR0cCBzdGF0dXMgYmV0d2VlbiAyMDAgdG8gMjk5IGFyZSBhbGwgc3VjY2Vzc2Z1bFxuICAgICAgICBjb25zdCB1c2VSZXNwb25zZSA9IHhoci5yZXNwb25zZVR5cGUgIT09ICd0ZXh0JztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN0YXR1cyA+PSAyMDAgJiZcbiAgICAgICAgICBzdGF0dXMgPCAzMDAgJiZcbiAgICAgICAgICAoKHVzZVJlc3BvbnNlICYmIHhoci5yZXNwb25zZSkgfHwgeGhyLnJlc3BvbnNlVGV4dCAhPT0gbnVsbClcbiAgICAgICAgKSB7XG4gICAgICAgICAgc3RhdHMubG9hZGluZy5lbmQgPSBNYXRoLm1heChcbiAgICAgICAgICAgIHNlbGYucGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0XG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gdXNlUmVzcG9uc2UgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgIGNvbnN0IGxlbiA9XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSBsZW47XG4gICAgICAgICAgc3RhdHMuYndFc3RpbWF0ZSA9XG4gICAgICAgICAgICAoc3RhdHMudG90YWwgKiA4MDAwKSAvIChzdGF0cy5sb2FkaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgICAgIGlmICghdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb25Qcm9ncmVzcyA9IHRoaXMuY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGRhdGEsIHhocik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2U6IExvYWRlclJlc3BvbnNlID0ge1xuICAgICAgICAgICAgdXJsOiB4aHIucmVzcG9uc2VVUkwsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgY29kZTogc3RhdHVzLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCB4aHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHJldHJ5Q29uZmlnID0gY29uZmlnLmxvYWRQb2xpY3kuZXJyb3JSZXRyeTtcbiAgICAgICAgICBjb25zdCByZXRyeUNvdW50ID0gc3RhdHMucmV0cnk7XG4gICAgICAgICAgLy8gaWYgbWF4IG5iIG9mIHJldHJpZXMgcmVhY2hlZCBvciBpZiBodHRwIHN0YXR1cyBiZXR3ZWVuIDQwMCBhbmQgNDk5IChzdWNoIGVycm9yIGNhbm5vdCBiZSByZWNvdmVyZWQsIHJldHJ5aW5nIGlzIHVzZWxlc3MpLCByZXR1cm4gZXJyb3JcbiAgICAgICAgICBpZiAoc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIGZhbHNlLCBzdGF0dXMpKSB7XG4gICAgICAgICAgICB0aGlzLnJldHJ5KHJldHJ5Q29uZmlnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfWApO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MhLm9uRXJyb3IoXG4gICAgICAgICAgICAgIHsgY29kZTogc3RhdHVzLCB0ZXh0OiB4aHIuc3RhdHVzVGV4dCB9LFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICB4aHIsXG4gICAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvYWR0aW1lb3V0KCkge1xuICAgIGNvbnN0IHJldHJ5Q29uZmlnID0gdGhpcy5jb25maWc/LmxvYWRQb2xpY3kudGltZW91dFJldHJ5O1xuICAgIGNvbnN0IHJldHJ5Q291bnQgPSB0aGlzLnN0YXRzLnJldHJ5O1xuICAgIGlmIChzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgdHJ1ZSkpIHtcbiAgICAgIHRoaXMucmV0cnkocmV0cnlDb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybihgdGltZW91dCB3aGlsZSBsb2FkaW5nICR7dGhpcy5jb250ZXh0LnVybH1gKTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzO1xuICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgICAgY2FsbGJhY2tzLm9uVGltZW91dCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMubG9hZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXRyeShyZXRyeUNvbmZpZzogUmV0cnlDb25maWcpIHtcbiAgICBjb25zdCB7IGNvbnRleHQsIHN0YXRzIH0gPSB0aGlzO1xuICAgIHRoaXMucmV0cnlEZWxheSA9IGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHN0YXRzLnJldHJ5KTtcbiAgICBzdGF0cy5yZXRyeSsrO1xuICAgIGxvZ2dlci53YXJuKFxuICAgICAgYCR7c3RhdHVzID8gJ0hUVFAgU3RhdHVzICcgKyBzdGF0dXMgOiAnVGltZW91dCd9IHdoaWxlIGxvYWRpbmcgJHtcbiAgICAgICAgY29udGV4dC51cmxcbiAgICAgIH0sIHJldHJ5aW5nICR7c3RhdHMucmV0cnl9LyR7cmV0cnlDb25maWcubWF4TnVtUmV0cnl9IGluICR7XG4gICAgICAgIHRoaXMucmV0cnlEZWxheVxuICAgICAgfW1zYFxuICAgICk7XG4gICAgLy8gYWJvcnQgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlXG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIC8vIHNjaGVkdWxlIHJldHJ5XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KFxuICAgICAgdGhpcy5sb2FkSW50ZXJuYWwuYmluZCh0aGlzKSxcbiAgICAgIHRoaXMucmV0cnlEZWxheVxuICAgICk7XG4gIH1cblxuICBsb2FkcHJvZ3Jlc3MoZXZlbnQ6IFByb2dyZXNzRXZlbnQpIHtcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG5cbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgfVxuICB9XG5cbiAgZ2V0Q2FjaGVBZ2UoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgbGV0IHJlc3VsdDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKFxuICAgICAgdGhpcy5sb2FkZXIgJiZcbiAgICAgIEFHRV9IRUFERVJfTElORV9SRUdFWC50ZXN0KHRoaXMubG9hZGVyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICkge1xuICAgICAgY29uc3QgYWdlSGVhZGVyID0gdGhpcy5sb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2FnZScpO1xuICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldFJlc3BvbnNlSGVhZGVyKG5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmIChcbiAgICAgIHRoaXMubG9hZGVyICYmXG4gICAgICBuZXcgUmVnRXhwKGBeJHtuYW1lfTpcXFxccypbXFxcXGQuXStcXFxccyokYCwgJ2ltJykudGVzdChcbiAgICAgICAgdGhpcy5sb2FkZXIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRlci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWGhyTG9hZGVyO1xuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2h1bmtDYWNoZSB7XG4gIHByaXZhdGUgY2h1bmtzOiBBcnJheTxVaW50OEFycmF5PiA9IFtdO1xuICBwdWJsaWMgZGF0YUxlbmd0aDogbnVtYmVyID0gMDtcblxuICBwdXNoKGNodW5rOiBVaW50OEFycmF5KSB7XG4gICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgdGhpcy5kYXRhTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuXG4gIGZsdXNoKCk6IFVpbnQ4QXJyYXkge1xuICAgIGNvbnN0IHsgY2h1bmtzLCBkYXRhTGVuZ3RoIH0gPSB0aGlzO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKCFjaHVua3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfSBlbHNlIGlmIChjaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXN1bHQgPSBjaHVua3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGNvbmNhdFVpbnQ4QXJyYXlzKGNodW5rcywgZGF0YUxlbmd0aCk7XG4gICAgfVxuICAgIHRoaXMucmVzZXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jaHVua3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbmNhdFVpbnQ4QXJyYXlzKFxuICBjaHVua3M6IEFycmF5PFVpbnQ4QXJyYXk+LFxuICBkYXRhTGVuZ3RoOiBudW1iZXJcbik6IFVpbnQ4QXJyYXkge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgcmVzdWx0LnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQge1xuICBMb2FkZXJDYWxsYmFja3MsXG4gIExvYWRlckNvbnRleHQsXG4gIExvYWRlcixcbiAgTG9hZGVyU3RhdHMsXG4gIExvYWRlckNvbmZpZ3VyYXRpb24sXG4gIExvYWRlck9uUHJvZ3Jlc3MsXG4gIExvYWRlclJlc3BvbnNlLFxufSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHsgTG9hZFN0YXRzIH0gZnJvbSAnLi4vbG9hZGVyL2xvYWQtc3RhdHMnO1xuaW1wb3J0IENodW5rQ2FjaGUgZnJvbSAnLi4vZGVtdXgvY2h1bmstY2FjaGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hTdXBwb3J0ZWQoKSB7XG4gIGlmIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc2VsZi5mZXRjaCAmJlxuICAgIHNlbGYuQWJvcnRDb250cm9sbGVyICYmXG4gICAgc2VsZi5SZWFkYWJsZVN0cmVhbSAmJlxuICAgIHNlbGYuUmVxdWVzdFxuICApIHtcbiAgICB0cnkge1xuICAgICAgbmV3IHNlbGYuUmVhZGFibGVTdHJlYW0oe30pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogbm9vcCAqL1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IEJZVEVSQU5HRSA9IC8oXFxkKyktKFxcZCspXFwvKFxcZCspLztcblxuY2xhc3MgRmV0Y2hMb2FkZXIgaW1wbGVtZW50cyBMb2FkZXI8TG9hZGVyQ29udGV4dD4ge1xuICBwcml2YXRlIGZldGNoU2V0dXA6IEZ1bmN0aW9uO1xuICBwcml2YXRlIHJlcXVlc3RUaW1lb3V0PzogbnVtYmVyO1xuICBwcml2YXRlIHJlcXVlc3QhOiBSZXF1ZXN0O1xuICBwcml2YXRlIHJlc3BvbnNlITogUmVzcG9uc2U7XG4gIHByaXZhdGUgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyO1xuICBwdWJsaWMgY29udGV4dCE6IExvYWRlckNvbnRleHQ7XG4gIHByaXZhdGUgY29uZmlnOiBMb2FkZXJDb25maWd1cmF0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY2FsbGJhY2tzOiBMb2FkZXJDYWxsYmFja3M8TG9hZGVyQ29udGV4dD4gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIHN0YXRzOiBMb2FkZXJTdGF0cztcbiAgcHJpdmF0ZSBsb2FkZXI6IFJlc3BvbnNlIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnIC8qIEhsc0NvbmZpZyAqLykge1xuICAgIHRoaXMuZmV0Y2hTZXR1cCA9IGNvbmZpZy5mZXRjaFNldHVwIHx8IGdldFJlcXVlc3Q7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IHNlbGYuQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBMb2FkU3RhdHMoKTtcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5sb2FkZXIgPSB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gIH1cblxuICBhYm9ydEludGVybmFsKCk6IHZvaWQge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5yZXNwb25zZTtcbiAgICBpZiAoIXJlc3BvbnNlPy5vaykge1xuICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIGFib3J0KCk6IHZvaWQge1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIGlmICh0aGlzLmNhbGxiYWNrcz8ub25BYm9ydCkge1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMucmVzcG9uc2UpO1xuICAgIH1cbiAgfVxuXG4gIGxvYWQoXG4gICAgY29udGV4dDogTG9hZGVyQ29udGV4dCxcbiAgICBjb25maWc6IExvYWRlckNvbmZpZ3VyYXRpb24sXG4gICAgY2FsbGJhY2tzOiBMb2FkZXJDYWxsYmFja3M8TG9hZGVyQ29udGV4dD5cbiAgKTogdm9pZCB7XG4gICAgY29uc3Qgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIGlmIChzdGF0cy5sb2FkaW5nLnN0YXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRlciBjYW4gb25seSBiZSB1c2VkIG9uY2UuJyk7XG4gICAgfVxuICAgIHN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgY29uc3QgaW5pdFBhcmFtcyA9IGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQsIHRoaXMuY29udHJvbGxlci5zaWduYWwpO1xuICAgIGNvbnN0IG9uUHJvZ3Jlc3M6IExvYWRlck9uUHJvZ3Jlc3M8TG9hZGVyQ29udGV4dD4gfCB1bmRlZmluZWQgPVxuICAgICAgY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XG4gICAgY29uc3QgaXNBcnJheUJ1ZmZlciA9IGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInO1xuICAgIGNvbnN0IExFTkdUSCA9IGlzQXJyYXlCdWZmZXIgPyAnYnl0ZUxlbmd0aCcgOiAnbGVuZ3RoJztcbiAgICBjb25zdCB7IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zLCBtYXhMb2FkVGltZU1zIH0gPSBjb25maWcubG9hZFBvbGljeTtcblxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5mZXRjaFNldHVwKGNvbnRleHQsIGluaXRQYXJhbXMpO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIGNvbmZpZy50aW1lb3V0ID1cbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zICYmIE51bWJlci5pc0Zpbml0ZShtYXhUaW1lVG9GaXJzdEJ5dGVNcylcbiAgICAgICAgPyBtYXhUaW1lVG9GaXJzdEJ5dGVNc1xuICAgICAgICA6IG1heExvYWRUaW1lTXM7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgIGNhbGxiYWNrcy5vblRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIHRoaXMucmVzcG9uc2UpO1xuICAgIH0sIGNvbmZpZy50aW1lb3V0KTtcblxuICAgIHNlbGZcbiAgICAgIC5mZXRjaCh0aGlzLnJlcXVlc3QpXG4gICAgICAudGhlbigocmVzcG9uc2U6IFJlc3BvbnNlKTogUHJvbWlzZTxzdHJpbmcgfCBBcnJheUJ1ZmZlcj4gPT4ge1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5sb2FkZXIgPSByZXNwb25zZTtcblxuICAgICAgICBjb25zdCBmaXJzdCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuc3RhcnQpO1xuXG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICBjb25maWcudGltZW91dCA9IG1heExvYWRUaW1lTXM7XG4gICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgICAgIGNhbGxiYWNrcy5vblRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIHRoaXMucmVzcG9uc2UpO1xuICAgICAgICB9LCBtYXhMb2FkVGltZU1zIC0gKGZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCkpO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCB7IHN0YXR1cywgc3RhdHVzVGV4dCB9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgdGhyb3cgbmV3IEZldGNoRXJyb3IoXG4gICAgICAgICAgICBzdGF0dXNUZXh0IHx8ICdmZXRjaCwgYmFkIG5ldHdvcmsgcmVzcG9uc2UnLFxuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSBmaXJzdDtcblxuICAgICAgICBzdGF0cy50b3RhbCA9IGdldENvbnRlbnRMZW5ndGgocmVzcG9uc2UuaGVhZGVycykgfHwgc3RhdHMudG90YWw7XG5cbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgTnVtYmVyLmlzRmluaXRlKGNvbmZpZy5oaWdoV2F0ZXJNYXJrKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRQcm9ncmVzc2l2ZWx5KFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBjb25maWcuaGlnaFdhdGVyTWFyayxcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3NcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdqc29uJykge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigocmVzcG9uc2VEYXRhOiBzdHJpbmcgfCBBcnJheUJ1ZmZlcikgPT4ge1xuICAgICAgICBjb25zdCB7IHJlc3BvbnNlIH0gPSB0aGlzO1xuICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgc3RhdHMubG9hZGluZy5lbmQgPSBNYXRoLm1heChcbiAgICAgICAgICBzZWxmLnBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3RcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdG90YWwgPSByZXNwb25zZURhdGFbTEVOR1RIXTtcbiAgICAgICAgaWYgKHRvdGFsKSB7XG4gICAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvYWRlclJlc3BvbnNlOiBMb2FkZXJSZXNwb25zZSA9IHtcbiAgICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvblByb2dyZXNzICYmICFOdW1iZXIuaXNGaW5pdGUoY29uZmlnLmhpZ2hXYXRlck1hcmspKSB7XG4gICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgcmVzcG9uc2VEYXRhLCByZXNwb25zZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFja3Mub25TdWNjZXNzKGxvYWRlclJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgcmVzcG9uc2UpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENPUlMgZXJyb3JzIHJlc3VsdCBpbiBhbiB1bmRlZmluZWQgY29kZS4gU2V0IGl0IHRvIDAgaGVyZSB0byBhbGlnbiB3aXRoIFhIUidzIGJlaGF2aW9yXG4gICAgICAgIC8vIHdoZW4gZGVzdHJveWluZywgJ2Vycm9yJyBpdHNlbGYgY2FuIGJlIHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBjb2RlOiBudW1iZXIgPSAhZXJyb3IgPyAwIDogZXJyb3IuY29kZSB8fCAwO1xuICAgICAgICBjb25zdCB0ZXh0OiBzdHJpbmcgPSAhZXJyb3IgPyBudWxsIDogZXJyb3IubWVzc2FnZTtcbiAgICAgICAgY2FsbGJhY2tzLm9uRXJyb3IoXG4gICAgICAgICAgeyBjb2RlLCB0ZXh0IH0sXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBlcnJvciA/IGVycm9yLmRldGFpbHMgOiBudWxsLFxuICAgICAgICAgIHN0YXRzXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGdldENhY2hlQWdlKCk6IG51bWJlciB8IG51bGwge1xuICAgIGxldCByZXN1bHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICBjb25zdCBhZ2VIZWFkZXIgPSB0aGlzLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdhZ2UnKTtcbiAgICAgIHJlc3VsdCA9IGFnZUhlYWRlciA/IHBhcnNlRmxvYXQoYWdlSGVhZGVyKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRSZXNwb25zZUhlYWRlcihuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZSA/IHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQobmFtZSkgOiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBsb2FkUHJvZ3Jlc3NpdmVseShcbiAgICByZXNwb25zZTogUmVzcG9uc2UsXG4gICAgc3RhdHM6IExvYWRlclN0YXRzLFxuICAgIGNvbnRleHQ6IExvYWRlckNvbnRleHQsXG4gICAgaGlnaFdhdGVyTWFyazogbnVtYmVyID0gMCxcbiAgICBvblByb2dyZXNzOiBMb2FkZXJPblByb2dyZXNzPExvYWRlckNvbnRleHQ+XG4gICk6IFByb21pc2U8QXJyYXlCdWZmZXI+IHtcbiAgICBjb25zdCBjaHVua0NhY2hlID0gbmV3IENodW5rQ2FjaGUoKTtcbiAgICBjb25zdCByZWFkZXIgPSAocmVzcG9uc2UuYm9keSBhcyBSZWFkYWJsZVN0cmVhbSkuZ2V0UmVhZGVyKCk7XG5cbiAgICBjb25zdCBwdW1wID0gKCk6IFByb21pc2U8QXJyYXlCdWZmZXI+ID0+IHtcbiAgICAgIHJldHVybiByZWFkZXJcbiAgICAgICAgLnJlYWQoKVxuICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgIGlmIChkYXRhLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChjaHVua0NhY2hlLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmtDYWNoZS5mbHVzaCgpLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2h1bms6IFVpbnQ4QXJyYXkgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgIGNvbnN0IGxlbiA9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICBzdGF0cy5sb2FkZWQgKz0gbGVuO1xuICAgICAgICAgIGlmIChsZW4gPCBoaWdoV2F0ZXJNYXJrIHx8IGNodW5rQ2FjaGUuZGF0YUxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgY2h1bmsgaXMgdG9vIHNtYWxsIHRvIHRvIGJlIGVtaXR0ZWQgb3IgdGhlIGNhY2hlIGFscmVhZHkgaGFzIGRhdGFcbiAgICAgICAgICAgIC8vIFB1c2ggaXQgdG8gdGhlIGNhY2hlXG4gICAgICAgICAgICBjaHVua0NhY2hlLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgaWYgKGNodW5rQ2FjaGUuZGF0YUxlbmd0aCA+PSBoaWdoV2F0ZXJNYXJrKSB7XG4gICAgICAgICAgICAgIC8vIGZsdXNoIGluIG9yZGVyIHRvIGpvaW4gdGhlIHR5cGVkIGFycmF5c1xuICAgICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVua0NhY2hlLmZsdXNoKCksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBub3RoaW5nIGNhY2hlZCBhbHJlYWR5LCBhbmQgdGhlIGNoYWNoZSBpcyBsYXJnZSBlbm91Z2hcbiAgICAgICAgICAgIC8vIGp1c3QgZW1pdCB0aGUgcHJvZ3Jlc3MgZXZlbnRcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rLCByZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLyogYWJvcnRlZCAqL1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHB1bXAoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXF1ZXN0UGFyYW1ldGVycyhjb250ZXh0OiBMb2FkZXJDb250ZXh0LCBzaWduYWwpOiBhbnkge1xuICBjb25zdCBpbml0UGFyYW1zOiBhbnkgPSB7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBtb2RlOiAnY29ycycsXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgc2lnbmFsLFxuICAgIGhlYWRlcnM6IG5ldyBzZWxmLkhlYWRlcnMoT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dC5oZWFkZXJzKSksXG4gIH07XG5cbiAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICBpbml0UGFyYW1zLmhlYWRlcnMuc2V0KFxuICAgICAgJ1JhbmdlJyxcbiAgICAgICdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgU3RyaW5nKGNvbnRleHQucmFuZ2VFbmQgLSAxKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gaW5pdFBhcmFtcztcbn1cblxuZnVuY3Rpb24gZ2V0Qnl0ZVJhbmdlTGVuZ3RoKGJ5dGVSYW5nZUhlYWRlcjogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgcmVzdWx0ID0gQllURVJBTkdFLmV4ZWMoYnl0ZVJhbmdlSGVhZGVyKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiBwYXJzZUludChyZXN1bHRbMl0pIC0gcGFyc2VJbnQocmVzdWx0WzFdKSArIDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29udGVudExlbmd0aChoZWFkZXJzOiBIZWFkZXJzKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgY29udGVudFJhbmdlID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtUmFuZ2UnKTtcbiAgaWYgKGNvbnRlbnRSYW5nZSkge1xuICAgIGNvbnN0IGJ5dGVSYW5nZUxlbmd0aCA9IGdldEJ5dGVSYW5nZUxlbmd0aChjb250ZW50UmFuZ2UpO1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoYnl0ZVJhbmdlTGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGJ5dGVSYW5nZUxlbmd0aDtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29udGVudExlbmd0aCA9IGhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpO1xuICBpZiAoY29udGVudExlbmd0aCkge1xuICAgIHJldHVybiBwYXJzZUludChjb250ZW50TGVuZ3RoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXF1ZXN0KGNvbnRleHQ6IExvYWRlckNvbnRleHQsIGluaXRQYXJhbXM6IGFueSk6IFJlcXVlc3Qge1xuICByZXR1cm4gbmV3IHNlbGYuUmVxdWVzdChjb250ZXh0LnVybCwgaW5pdFBhcmFtcyk7XG59XG5cbmNsYXNzIEZldGNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyBjb2RlOiBudW1iZXI7XG4gIHB1YmxpYyBkZXRhaWxzOiBhbnk7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgY29kZTogbnVtYmVyLCBkZXRhaWxzOiBhbnkpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmV0Y2hMb2FkZXI7XG4iLCJpbXBvcnQgQWJyQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXInO1xuaW1wb3J0IEF1ZGlvU3RyZWFtQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IEF1ZGlvVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyJztcbmltcG9ydCB7IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciB9IGZyb20gJy4vY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IEJ1ZmZlckNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyJztcbmltcG9ydCB7IFRpbWVsaW5lQ29udHJvbGxlciB9IGZyb20gJy4vY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyJztcbmltcG9ydCBDYXBMZXZlbENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyJztcbmltcG9ydCBGUFNDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9mcHMtY29udHJvbGxlcic7XG5pbXBvcnQgRU1FQ29udHJvbGxlciwge1xuICBNZWRpYUtleVNlc3Npb25Db250ZXh0LFxufSBmcm9tICcuL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXInO1xuaW1wb3J0IENNQ0RDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9jbWNkLWNvbnRyb2xsZXInO1xuaW1wb3J0IENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2NvbnRlbnQtc3RlZXJpbmctY29udHJvbGxlcic7XG5pbXBvcnQgRXJyb3JDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9lcnJvci1jb250cm9sbGVyJztcbmltcG9ydCBYaHJMb2FkZXIgZnJvbSAnLi91dGlscy94aHItbG9hZGVyJztcbmltcG9ydCBGZXRjaExvYWRlciwgeyBmZXRjaFN1cHBvcnRlZCB9IGZyb20gJy4vdXRpbHMvZmV0Y2gtbG9hZGVyJztcbmltcG9ydCBDdWVzIGZyb20gJy4vdXRpbHMvY3Vlcyc7XG5pbXBvcnQgeyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgfSBmcm9tICcuL3V0aWxzL21lZGlha2V5cy1oZWxwZXInO1xuaW1wb3J0IHsgSUxvZ2dlciwgbG9nZ2VyIH0gZnJvbSAnLi91dGlscy9sb2dnZXInO1xuXG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi9obHMnO1xuaW1wb3J0IHR5cGUgeyBDdWVzSW50ZXJmYWNlIH0gZnJvbSAnLi91dGlscy9jdWVzJztcbmltcG9ydCB0eXBlIHsgTWVkaWFLZXlGdW5jLCBLZXlTeXN0ZW1zIH0gZnJvbSAnLi91dGlscy9tZWRpYWtleXMtaGVscGVyJztcbmltcG9ydCB0eXBlIHtcbiAgRnJhZ21lbnRMb2FkZXJDb250ZXh0LFxuICBMb2FkZXIsXG4gIExvYWRlckNvbnRleHQsXG4gIFBsYXlsaXN0TG9hZGVyQ29udGV4dCxcbn0gZnJvbSAnLi90eXBlcy9sb2FkZXInO1xuXG5leHBvcnQgdHlwZSBBQlJDb250cm9sbGVyQ29uZmlnID0ge1xuICBhYnJFd21hRmFzdExpdmU6IG51bWJlcjtcbiAgYWJyRXdtYVNsb3dMaXZlOiBudW1iZXI7XG4gIGFickV3bWFGYXN0Vm9EOiBudW1iZXI7XG4gIGFickV3bWFTbG93Vm9EOiBudW1iZXI7XG4gIC8qKlxuICAgKiBEZWZhdWx0IGJhbmR3aWR0aCBlc3RpbWF0ZSBpbiBiaXRzL3MgcHJpb3IgdG8gY29sbGVjdGluZyBmcmFnbWVudCBiYW5kd2lkdGggc2FtcGxlc1xuICAgKi9cbiAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTogbnVtYmVyO1xuICBhYnJCYW5kV2lkdGhGYWN0b3I6IG51bWJlcjtcbiAgYWJyQmFuZFdpZHRoVXBGYWN0b3I6IG51bWJlcjtcbiAgYWJyTWF4V2l0aFJlYWxCaXRyYXRlOiBib29sZWFuO1xuICBtYXhTdGFydmF0aW9uRGVsYXk6IG51bWJlcjtcbiAgbWF4TG9hZGluZ0RlbGF5OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBCdWZmZXJDb250cm9sbGVyQ29uZmlnID0ge1xuICBhcHBlbmRFcnJvck1heFJldHJ5OiBudW1iZXI7XG4gIGJhY2tCdWZmZXJMZW5ndGg6IG51bWJlcjtcbiAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYmFja0J1ZmZlckxlbmd0aFxuICAgKi9cbiAgbGl2ZUJhY2tCdWZmZXJMZW5ndGg6IG51bWJlciB8IG51bGw7XG59O1xuXG5leHBvcnQgdHlwZSBDYXBMZXZlbENvbnRyb2xsZXJDb25maWcgPSB7XG4gIGNhcExldmVsVG9QbGF5ZXJTaXplOiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgQ01DRENvbnRyb2xsZXJDb25maWcgPSB7XG4gIHNlc3Npb25JZD86IHN0cmluZztcbiAgY29udGVudElkPzogc3RyaW5nO1xuICB1c2VIZWFkZXJzPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIERSTVN5c3RlbU9wdGlvbnMgPSB7XG4gIGF1ZGlvUm9idXN0bmVzcz86IHN0cmluZztcbiAgdmlkZW9Sb2J1c3RuZXNzPzogc3RyaW5nO1xuICBhdWRpb0VuY3J5cHRpb25TY2hlbWU/OiBzdHJpbmcgfCBudWxsO1xuICB2aWRlb0VuY3J5cHRpb25TY2hlbWU/OiBzdHJpbmcgfCBudWxsO1xuICBwZXJzaXN0ZW50U3RhdGU/OiBNZWRpYUtleXNSZXF1aXJlbWVudDtcbiAgZGlzdGluY3RpdmVJZGVudGlmaWVyPzogTWVkaWFLZXlzUmVxdWlyZW1lbnQ7XG4gIHNlc3Npb25UeXBlcz86IHN0cmluZ1tdO1xuICBzZXNzaW9uVHlwZT86IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIERSTVN5c3RlbUNvbmZpZ3VyYXRpb24gPSB7XG4gIGxpY2Vuc2VVcmw6IHN0cmluZztcbiAgc2VydmVyQ2VydGlmaWNhdGVVcmw/OiBzdHJpbmc7XG4gIGdlbmVyYXRlUmVxdWVzdD86IChcbiAgICB0aGlzOiBIbHMsXG4gICAgaW5pdERhdGFUeXBlOiBzdHJpbmcsXG4gICAgaW5pdERhdGE6IEFycmF5QnVmZmVyIHwgbnVsbCxcbiAgICBrZXlDb250ZXh0OiBNZWRpYUtleVNlc3Npb25Db250ZXh0XG4gICkgPT5cbiAgICB8IHsgaW5pdERhdGFUeXBlOiBzdHJpbmc7IGluaXREYXRhOiBBcnJheUJ1ZmZlciB8IG51bGwgfVxuICAgIHwgdW5kZWZpbmVkXG4gICAgfCBuZXZlcjtcbn07XG5cbmV4cG9ydCB0eXBlIERSTVN5c3RlbXNDb25maWd1cmF0aW9uID0gUGFydGlhbDxcbiAgUmVjb3JkPEtleVN5c3RlbXMsIERSTVN5c3RlbUNvbmZpZ3VyYXRpb24+XG4+O1xuXG5leHBvcnQgdHlwZSBFTUVDb250cm9sbGVyQ29uZmlnID0ge1xuICBsaWNlbnNlWGhyU2V0dXA/OiAoXG4gICAgdGhpczogSGxzLFxuICAgIHhocjogWE1MSHR0cFJlcXVlc3QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAga2V5Q29udGV4dDogTWVkaWFLZXlTZXNzaW9uQ29udGV4dCxcbiAgICBsaWNlbnNlQ2hhbGxlbmdlOiBVaW50OEFycmF5XG4gICkgPT4gdm9pZCB8IFVpbnQ4QXJyYXkgfCBQcm9taXNlPFVpbnQ4QXJyYXkgfCB2b2lkPjtcbiAgbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2s/OiAoXG4gICAgdGhpczogSGxzLFxuICAgIHhocjogWE1MSHR0cFJlcXVlc3QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAga2V5Q29udGV4dDogTWVkaWFLZXlTZXNzaW9uQ29udGV4dFxuICApID0+IEFycmF5QnVmZmVyO1xuICBlbWVFbmFibGVkOiBib29sZWFuO1xuICB3aWRldmluZUxpY2Vuc2VVcmw/OiBzdHJpbmc7XG4gIGRybVN5c3RlbXM6IERSTVN5c3RlbXNDb25maWd1cmF0aW9uO1xuICBkcm1TeXN0ZW1PcHRpb25zOiBEUk1TeXN0ZW1PcHRpb25zO1xuICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jOiBNZWRpYUtleUZ1bmMgfCBudWxsO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBGcmFnbWVudExvYWRlckNvbnN0cnVjdG9yIHtcbiAgbmV3IChjb25mZzogSGxzQ29uZmlnKTogTG9hZGVyPEZyYWdtZW50TG9hZGVyQ29udGV4dD47XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGZyYWdMb2FkUG9saWN5LmRlZmF1bHRcbiAqL1xuZXhwb3J0IHR5cGUgRnJhZ21lbnRMb2FkZXJDb25maWcgPSB7XG4gIGZyYWdMb2FkaW5nVGltZU91dDogbnVtYmVyO1xuICBmcmFnTG9hZGluZ01heFJldHJ5OiBudW1iZXI7XG4gIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogbnVtYmVyO1xuICBmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dDogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgRlBTQ29udHJvbGxlckNvbmZpZyA9IHtcbiAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGJvb2xlYW47XG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kOiBudW1iZXI7XG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBMZXZlbENvbnRyb2xsZXJDb25maWcgPSB7XG4gIHN0YXJ0TGV2ZWw/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBNUDRSZW11eGVyQ29uZmlnID0ge1xuICBzdHJldGNoU2hvcnRWaWRlb1RyYWNrOiBib29sZWFuO1xuICBtYXhBdWRpb0ZyYW1lc0RyaWZ0OiBudW1iZXI7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFBsYXlsaXN0TG9hZGVyQ29uc3RydWN0b3Ige1xuICBuZXcgKGNvbmZnOiBIbHNDb25maWcpOiBMb2FkZXI8UGxheWxpc3RMb2FkZXJDb250ZXh0Pjtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQgYW5kIHBsYXlsaXN0TG9hZFBvbGljeS5kZWZhdWx0XG4gKi9cbmV4cG9ydCB0eXBlIFBsYXlsaXN0TG9hZGVyQ29uZmlnID0ge1xuICBtYW5pZmVzdExvYWRpbmdUaW1lT3V0OiBudW1iZXI7XG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiBudW1iZXI7XG4gIG1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk6IG51bWJlcjtcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiBudW1iZXI7XG5cbiAgbGV2ZWxMb2FkaW5nVGltZU91dDogbnVtYmVyO1xuICBsZXZlbExvYWRpbmdNYXhSZXRyeTogbnVtYmVyO1xuICBsZXZlbExvYWRpbmdSZXRyeURlbGF5OiBudW1iZXI7XG4gIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgSGxzTG9hZFBvbGljaWVzID0ge1xuICBmcmFnTG9hZFBvbGljeTogTG9hZFBvbGljeTtcbiAga2V5TG9hZFBvbGljeTogTG9hZFBvbGljeTtcbiAgY2VydExvYWRQb2xpY3k6IExvYWRQb2xpY3k7XG4gIHBsYXlsaXN0TG9hZFBvbGljeTogTG9hZFBvbGljeTtcbiAgbWFuaWZlc3RMb2FkUG9saWN5OiBMb2FkUG9saWN5O1xuICBzdGVlcmluZ01hbmlmZXN0TG9hZFBvbGljeTogTG9hZFBvbGljeTtcbn07XG5cbmV4cG9ydCB0eXBlIExvYWRQb2xpY3kgPSB7XG4gIGRlZmF1bHQ6IExvYWRlckNvbmZpZztcbn07XG5cbmV4cG9ydCB0eXBlIExvYWRlckNvbmZpZyA9IHtcbiAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IG51bWJlcjsgLy8gTWF4IHRpbWUgdG8gZmlyc3QgYnl0ZVxuICBtYXhMb2FkVGltZU1zOiBudW1iZXI7IC8vIE1heCB0aW1lIGZvciBsb2FkIGNvbXBsZXRpb25cbiAgdGltZW91dFJldHJ5OiBSZXRyeUNvbmZpZyB8IG51bGw7XG4gIGVycm9yUmV0cnk6IFJldHJ5Q29uZmlnIHwgbnVsbDtcbn07XG5cbmV4cG9ydCB0eXBlIFJldHJ5Q29uZmlnID0ge1xuICBtYXhOdW1SZXRyeTogbnVtYmVyOyAvLyBNYXhpbXVtIG51bWJlciBvZiByZXRyaWVzXG4gIHJldHJ5RGVsYXlNczogbnVtYmVyOyAvLyBSZXRyeSBkZWxheSA9IDJecmV0cnlDb3VudCAqIHJldHJ5RGVsYXlNcyAoZXhwb25lbnRpYWwpIG9yIHJldHJ5Q291bnQgKiByZXRyeURlbGF5TXMgKGxpbmVhcilcbiAgbWF4UmV0cnlEZWxheU1zOiBudW1iZXI7IC8vIE1heGltdW0gZGVsYXkgYmV0d2VlbiByZXRyaWVzXG4gIGJhY2tvZmY/OiAnZXhwb25lbnRpYWwnIHwgJ2xpbmVhcic7IC8vIHVzZWQgdG8gZGV0ZXJtaW5lIHJldHJ5IGJhY2tvZmYgZHVyYXRpb24gKHNlZSByZXRyeURlbGF5TXMpXG59O1xuXG5leHBvcnQgdHlwZSBTdHJlYW1Db250cm9sbGVyQ29uZmlnID0ge1xuICBhdXRvU3RhcnRMb2FkOiBib29sZWFuO1xuICBzdGFydFBvc2l0aW9uOiBudW1iZXI7XG4gIGRlZmF1bHRBdWRpb0NvZGVjPzogc3RyaW5nO1xuICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogbnVtYmVyO1xuICBtYXhCdWZmZXJMZW5ndGg6IG51bWJlcjtcbiAgbWF4QnVmZmVyU2l6ZTogbnVtYmVyO1xuICBtYXhCdWZmZXJIb2xlOiBudW1iZXI7XG4gIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogbnVtYmVyO1xuICBudWRnZU9mZnNldDogbnVtYmVyO1xuICBudWRnZU1heFJldHJ5OiBudW1iZXI7XG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IG51bWJlcjtcbiAgbWF4TWF4QnVmZmVyTGVuZ3RoOiBudW1iZXI7XG4gIHN0YXJ0RnJhZ1ByZWZldGNoOiBib29sZWFuO1xuICB0ZXN0QmFuZHdpZHRoOiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgTGF0ZW5jeUNvbnRyb2xsZXJDb25maWcgPSB7XG4gIGxpdmVTeW5jRHVyYXRpb25Db3VudDogbnVtYmVyO1xuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IG51bWJlcjtcbiAgbGl2ZVN5bmNEdXJhdGlvbj86IG51bWJlcjtcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbj86IG51bWJlcjtcbiAgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIE1ldGFkYXRhQ29udHJvbGxlckNvbmZpZyA9IHtcbiAgZW5hYmxlRGF0ZVJhbmdlTWV0YWRhdGFDdWVzOiBib29sZWFuO1xuICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzOiBib29sZWFuO1xuICBlbmFibGVJRDNNZXRhZGF0YUN1ZXM6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBUaW1lbGluZUNvbnRyb2xsZXJDb25maWcgPSB7XG4gIGN1ZUhhbmRsZXI6IEN1ZXNJbnRlcmZhY2U7XG4gIGVuYWJsZVdlYlZUVDogYm9vbGVhbjtcbiAgZW5hYmxlSU1TQzE6IGJvb2xlYW47XG4gIGVuYWJsZUNFQTcwOENhcHRpb25zOiBib29sZWFuO1xuICBjYXB0aW9uc1RleHRUcmFjazFMYWJlbDogc3RyaW5nO1xuICBjYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGU6IHN0cmluZztcbiAgY2FwdGlvbnNUZXh0VHJhY2syTGFiZWw6IHN0cmluZztcbiAgY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlOiBzdHJpbmc7XG4gIGNhcHRpb25zVGV4dFRyYWNrM0xhYmVsOiBzdHJpbmc7XG4gIGNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZTogc3RyaW5nO1xuICBjYXB0aW9uc1RleHRUcmFjazRMYWJlbDogc3RyaW5nO1xuICBjYXB0aW9uc1RleHRUcmFjazRMYW5ndWFnZUNvZGU6IHN0cmluZztcbiAgcmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5OiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgVFNEZW11eGVyQ29uZmlnID0ge1xuICBmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5OiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgSGxzQ29uZmlnID0ge1xuICBkZWJ1ZzogYm9vbGVhbiB8IElMb2dnZXI7XG4gIGVuYWJsZVdvcmtlcjogYm9vbGVhbjtcbiAgd29ya2VyUGF0aDogbnVsbCB8IHN0cmluZztcbiAgZW5hYmxlU29mdHdhcmVBRVM6IGJvb2xlYW47XG4gIG1pbkF1dG9CaXRyYXRlOiBudW1iZXI7XG4gIGlnbm9yZURldmljZVBpeGVsUmF0aW86IGJvb2xlYW47XG4gIGxvYWRlcjogeyBuZXcgKGNvbmZnOiBIbHNDb25maWcpOiBMb2FkZXI8TG9hZGVyQ29udGV4dD4gfTtcbiAgZkxvYWRlcj86IEZyYWdtZW50TG9hZGVyQ29uc3RydWN0b3I7XG4gIHBMb2FkZXI/OiBQbGF5bGlzdExvYWRlckNvbnN0cnVjdG9yO1xuICBmZXRjaFNldHVwPzogKGNvbnRleHQ6IExvYWRlckNvbnRleHQsIGluaXRQYXJhbXM6IGFueSkgPT4gUmVxdWVzdDtcbiAgeGhyU2V0dXA/OiAoeGhyOiBYTUxIdHRwUmVxdWVzdCwgdXJsOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuXG4gIC8vIEFsdCBBdWRpb1xuICBhdWRpb1N0cmVhbUNvbnRyb2xsZXI/OiB0eXBlb2YgQXVkaW9TdHJlYW1Db250cm9sbGVyO1xuICBhdWRpb1RyYWNrQ29udHJvbGxlcj86IHR5cGVvZiBBdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgLy8gU3VidGl0bGVcbiAgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyPzogdHlwZW9mIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcbiAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI/OiB0eXBlb2YgU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gIHRpbWVsaW5lQ29udHJvbGxlcj86IHR5cGVvZiBUaW1lbGluZUNvbnRyb2xsZXI7XG4gIC8vIEVNRVxuICBlbWVDb250cm9sbGVyPzogdHlwZW9mIEVNRUNvbnRyb2xsZXI7XG4gIC8vIENNQ0RcbiAgY21jZD86IENNQ0RDb250cm9sbGVyQ29uZmlnO1xuICBjbWNkQ29udHJvbGxlcj86IHR5cGVvZiBDTUNEQ29udHJvbGxlcjtcbiAgLy8gQ29udGVudCBTdGVlcmluZ1xuICBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyPzogdHlwZW9mIENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI7XG5cbiAgYWJyQ29udHJvbGxlcjogdHlwZW9mIEFickNvbnRyb2xsZXI7XG4gIGJ1ZmZlckNvbnRyb2xsZXI6IHR5cGVvZiBCdWZmZXJDb250cm9sbGVyO1xuICBjYXBMZXZlbENvbnRyb2xsZXI6IHR5cGVvZiBDYXBMZXZlbENvbnRyb2xsZXI7XG4gIGVycm9yQ29udHJvbGxlcjogdHlwZW9mIEVycm9yQ29udHJvbGxlcjtcbiAgZnBzQ29udHJvbGxlcjogdHlwZW9mIEZQU0NvbnRyb2xsZXI7XG4gIHByb2dyZXNzaXZlOiBib29sZWFuO1xuICBsb3dMYXRlbmN5TW9kZTogYm9vbGVhbjtcbn0gJiBBQlJDb250cm9sbGVyQ29uZmlnICZcbiAgQnVmZmVyQ29udHJvbGxlckNvbmZpZyAmXG4gIENhcExldmVsQ29udHJvbGxlckNvbmZpZyAmXG4gIEVNRUNvbnRyb2xsZXJDb25maWcgJlxuICBGUFNDb250cm9sbGVyQ29uZmlnICZcbiAgTGV2ZWxDb250cm9sbGVyQ29uZmlnICZcbiAgTVA0UmVtdXhlckNvbmZpZyAmXG4gIFN0cmVhbUNvbnRyb2xsZXJDb25maWcgJlxuICBMYXRlbmN5Q29udHJvbGxlckNvbmZpZyAmXG4gIE1ldGFkYXRhQ29udHJvbGxlckNvbmZpZyAmXG4gIFRpbWVsaW5lQ29udHJvbGxlckNvbmZpZyAmXG4gIFRTRGVtdXhlckNvbmZpZyAmXG4gIEhsc0xvYWRQb2xpY2llcyAmXG4gIEZyYWdtZW50TG9hZGVyQ29uZmlnICZcbiAgUGxheWxpc3RMb2FkZXJDb25maWc7XG5cbmNvbnN0IGRlZmF1bHRMb2FkUG9saWN5OiBMb2FkZXJDb25maWcgPSB7XG4gIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiA4MDAwLFxuICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgdGltZW91dFJldHJ5OiBudWxsLFxuICBlcnJvclJldHJ5OiBudWxsLFxufTtcblxuLyoqXG4gKiBAaWdub3JlXG4gKiBJZiBwb3NzaWJsZSwga2VlcCBobHNEZWZhdWx0Q29uZmlnIHNoYWxsb3dcbiAqIEl0IGlzIGNsb25lZCB3aGVuZXZlciBhIG5ldyBIbHMgaW5zdGFuY2UgaXMgY3JlYXRlZCwgYnkga2VlcGluZyB0aGUgY29uZmlnXG4gKiBzaGFsbG93IHRoZSBwcm9wZXJ0aWVzIGFyZSBjbG9uZWQsIGFuZCB3ZSBkb24ndCBlbmQgdXAgbWFuaXB1bGF0aW5nIHRoZSBkZWZhdWx0XG4gKi9cbmV4cG9ydCBjb25zdCBobHNEZWZhdWx0Q29uZmlnOiBIbHNDb25maWcgPSB7XG4gIGF1dG9TdGFydExvYWQ6IHRydWUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgc3RhcnRQb3NpdGlvbjogLTEsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZGVmYXVsdEF1ZGlvQ29kZWM6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWJ1ZzogZmFsc2UsIC8vIHVzZWQgYnkgbG9nZ2VyXG4gIGNhcExldmVsT25GUFNEcm9wOiBmYWxzZSwgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBjYXBMZXZlbFRvUGxheWVyU2l6ZTogZmFsc2UsIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgaWdub3JlRGV2aWNlUGl4ZWxSYXRpbzogZmFsc2UsIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgaW5pdGlhbExpdmVNYW5pZmVzdFNpemU6IDEsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVyTGVuZ3RoOiAzMCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBiYWNrQnVmZmVyTGVuZ3RoOiBJbmZpbml0eSwgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBtYXhCdWZmZXJTaXplOiA2MCAqIDEwMDAgKiAxMDAwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlckhvbGU6IDAuMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBoaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IDIsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbnVkZ2VPZmZzZXQ6IDAuMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBudWRnZU1heFJldHJ5OiAzLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IDAuMjUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50OiAzLCAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LCAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb246IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU6IDEsIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVEdXJhdGlvbkluZmluaXR5OiBmYWxzZSwgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGJhY2tCdWZmZXJMZW5ndGhcbiAgICovXG4gIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBudWxsLCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIG1heE1heEJ1ZmZlckxlbmd0aDogNjAwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGVuYWJsZVdvcmtlcjogdHJ1ZSwgLy8gdXNlZCBieSB0cmFuc211eGVyXG4gIHdvcmtlclBhdGg6IG51bGwsIC8vIHVzZWQgYnkgdHJhbnNtdXhlclxuICBlbmFibGVTb2Z0d2FyZUFFUzogdHJ1ZSwgLy8gdXNlZCBieSBkZWNyeXB0ZXJcbiAgc3RhcnRMZXZlbDogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGxldmVsLWNvbnRyb2xsZXJcbiAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kOiA1MDAwLCAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiAwLjIsIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMywgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBsb2FkZXI6IFhockxvYWRlcixcbiAgLy8gbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgZkxvYWRlcjogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBwTG9hZGVyOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIHhoclNldHVwOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgeGhyLWxvYWRlclxuICBsaWNlbnNlWGhyU2V0dXA6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjazogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGFickNvbnRyb2xsZXI6IEFickNvbnRyb2xsZXIsXG4gIGJ1ZmZlckNvbnRyb2xsZXI6IEJ1ZmZlckNvbnRyb2xsZXIsXG4gIGNhcExldmVsQ29udHJvbGxlcjogQ2FwTGV2ZWxDb250cm9sbGVyLFxuICBlcnJvckNvbnRyb2xsZXI6IEVycm9yQ29udHJvbGxlcixcbiAgZnBzQ29udHJvbGxlcjogRlBTQ29udHJvbGxlcixcbiAgc3RyZXRjaFNob3J0VmlkZW9UcmFjazogZmFsc2UsIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgbWF4QXVkaW9GcmFtZXNEcmlmdDogMSwgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxuICBmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5OiB0cnVlLCAvLyB1c2VkIGJ5IHRzLWRlbXV4ZXJcbiAgYWJyRXdtYUZhc3RMaXZlOiAzLCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFTbG93TGl2ZTogOSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hRmFzdFZvRDogMywgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hU2xvd1ZvRDogOSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsIC8vIDUwMCBrYnBzICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickJhbmRXaWR0aEZhY3RvcjogMC45NSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJCYW5kV2lkdGhVcEZhY3RvcjogMC43LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFick1heFdpdGhSZWFsQml0cmF0ZTogZmFsc2UsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWF4U3RhcnZhdGlvbkRlbGF5OiA0LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1heExvYWRpbmdEZWxheTogNCwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtaW5BdXRvQml0cmF0ZTogMCwgLy8gdXNlZCBieSBobHNcbiAgZW1lRW5hYmxlZDogZmFsc2UsIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgd2lkZXZpbmVMaWNlbnNlVXJsOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgZHJtU3lzdGVtczoge30sIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgZHJtU3lzdGVtT3B0aW9uczoge30sIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYzogX19VU0VfRU1FX0RSTV9fXG4gICAgPyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcbiAgICA6IG51bGwsIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgdGVzdEJhbmR3aWR0aDogdHJ1ZSxcbiAgcHJvZ3Jlc3NpdmU6IGZhbHNlLFxuICBsb3dMYXRlbmN5TW9kZTogdHJ1ZSxcbiAgY21jZDogdW5kZWZpbmVkLFxuICBlbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXM6IHRydWUsXG4gIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM6IHRydWUsXG4gIGVuYWJsZUlEM01ldGFkYXRhQ3VlczogdHJ1ZSxcblxuICBjZXJ0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IGRlZmF1bHRMb2FkUG9saWN5LFxuICB9LFxuICBrZXlMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDgwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDIwMDAwLFxuICAgICAgICBiYWNrb2ZmOiAnbGluZWFyJyxcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiA4LFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMjAwMDAsXG4gICAgICAgIGJhY2tvZmY6ICdsaW5lYXInLFxuICAgICAgfSxcbiAgICB9LFxuICB9LFxuICBtYW5pZmVzdExvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogSW5maW5pdHksXG4gICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDAsXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDAsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG4gIHBsYXlsaXN0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiAxMDAwMCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMCxcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbiAgZnJhZ0xvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAxMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDQsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwLFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDYsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwLFxuICAgICAgfSxcbiAgICB9LFxuICB9LFxuICBzdGVlcmluZ01hbmlmZXN0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IF9fVVNFX0NPTlRFTlRfU1RFRVJJTkdfX1xuICAgICAgPyB7XG4gICAgICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICA6IGRlZmF1bHRMb2FkUG9saWN5LFxuICB9LFxuXG4gIC8vIFRoZXNlIGRlZmF1bHQgc2V0dGluZ3MgYXJlIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgdGhlIGFib3ZlIHBvbGljaWVzXG4gIC8vIGFuZCBhcmUgbWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgbWFuaWZlc3RMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiAxLFxuICBtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICBsZXZlbExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnk6IDQsXG4gIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gIGZyYWdMb2FkaW5nVGltZU91dDogMjAwMDAsXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnk6IDYsXG4gIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuXG4gIC8vIER5bmFtaWMgTW9kdWxlc1xuICAuLi50aW1lbGluZUNvbmZpZygpLFxuICBzdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI6IF9fVVNFX1NVQlRJVExFU19fXG4gICAgPyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJcbiAgICA6IHVuZGVmaW5lZCxcbiAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI6IF9fVVNFX1NVQlRJVExFU19fXG4gICAgPyBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlclxuICAgIDogdW5kZWZpbmVkLFxuICB0aW1lbGluZUNvbnRyb2xsZXI6IF9fVVNFX1NVQlRJVExFU19fID8gVGltZWxpbmVDb250cm9sbGVyIDogdW5kZWZpbmVkLFxuICBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IF9fVVNFX0FMVF9BVURJT19fID8gQXVkaW9TdHJlYW1Db250cm9sbGVyIDogdW5kZWZpbmVkLFxuICBhdWRpb1RyYWNrQ29udHJvbGxlcjogX19VU0VfQUxUX0FVRElPX18gPyBBdWRpb1RyYWNrQ29udHJvbGxlciA6IHVuZGVmaW5lZCxcbiAgZW1lQ29udHJvbGxlcjogX19VU0VfRU1FX0RSTV9fID8gRU1FQ29udHJvbGxlciA6IHVuZGVmaW5lZCxcbiAgY21jZENvbnRyb2xsZXI6IF9fVVNFX0NNQ0RfXyA/IENNQ0RDb250cm9sbGVyIDogdW5kZWZpbmVkLFxuICBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyOiBfX1VTRV9DT05URU5UX1NURUVSSU5HX19cbiAgICA/IENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXJcbiAgICA6IHVuZGVmaW5lZCxcbn07XG5cbmZ1bmN0aW9uIHRpbWVsaW5lQ29uZmlnKCk6IFRpbWVsaW5lQ29udHJvbGxlckNvbmZpZyB7XG4gIHJldHVybiB7XG4gICAgY3VlSGFuZGxlcjogQ3VlcywgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlV2ViVlRUOiBfX1VTRV9TVUJUSVRMRVNfXywgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlSU1TQzE6IF9fVVNFX1NVQlRJVExFU19fLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVDRUE3MDhDYXB0aW9uczogX19VU0VfU1VCVElUTEVTX18sIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhYmVsOiAnRW5nbGlzaCcsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZTogJ2VuJywgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2syTGFiZWw6ICdTcGFuaXNoJywgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlOiAnZXMnLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazNMYWJlbDogJ1Vua25vd24gQ0MnLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazNMYW5ndWFnZUNvZGU6ICcnLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazRMYWJlbDogJ1Vua25vd24gQ0MnLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazRMYW5ndWFnZUNvZGU6ICcnLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICByZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHk6IHRydWUsXG4gIH07XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDb25maWcoXG4gIGRlZmF1bHRDb25maWc6IEhsc0NvbmZpZyxcbiAgdXNlckNvbmZpZzogUGFydGlhbDxIbHNDb25maWc+XG4pOiBIbHNDb25maWcge1xuICBpZiAoXG4gICAgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8XG4gICAgICB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiZcbiAgICAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbilcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvbid0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb25cIlxuICAgICk7XG4gIH1cblxuICBpZiAoXG4gICAgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCA8PVxuICAgICAgICB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRcIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcImxpdmVTeW5jRHVyYXRpb25Db3VudFwiJ1xuICAgICk7XG4gIH1cblxuICBpZiAoXG4gICAgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA8PSB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24pXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvblwiIG11c3QgYmUgZ3JlYXRlciB0aGFuIFwibGl2ZVN5bmNEdXJhdGlvblwiJ1xuICAgICk7XG4gIH1cblxuICBjb25zdCBkZWZhdWx0c0NvcHkgPSBkZWVwQ3B5KGRlZmF1bHRDb25maWcpO1xuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggZGVwcmVjYXRlZCBjb25maWcgdmFsdWVzXG4gIGNvbnN0IGRlcHJlY2F0ZWRTZXR0aW5nVHlwZXMgPSBbJ21hbmlmZXN0JywgJ2xldmVsJywgJ2ZyYWcnXTtcbiAgY29uc3QgZGVwcmVjYXRlZFNldHRpbmdzID0gW1xuICAgICdUaW1lT3V0JyxcbiAgICAnTWF4UmV0cnknLFxuICAgICdSZXRyeURlbGF5JyxcbiAgICAnTWF4UmV0cnlUaW1lb3V0JyxcbiAgXTtcbiAgZGVwcmVjYXRlZFNldHRpbmdUeXBlcy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgY29uc3QgcG9saWN5TmFtZSA9IGAke3R5cGUgPT09ICdsZXZlbCcgPyAncGxheWxpc3QnIDogdHlwZX1Mb2FkUG9saWN5YDtcbiAgICBjb25zdCBwb2xpY3lOb3RTZXQgPSB1c2VyQ29uZmlnW3BvbGljeU5hbWVdID09PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVwb3J0OiBzdHJpbmdbXSA9IFtdO1xuICAgIGRlcHJlY2F0ZWRTZXR0aW5ncy5mb3JFYWNoKChzZXR0aW5nKSA9PiB7XG4gICAgICBjb25zdCBkZXByZWNhdGVkU2V0dGluZyA9IGAke3R5cGV9TG9hZGluZyR7c2V0dGluZ31gO1xuICAgICAgY29uc3QgdmFsdWUgPSB1c2VyQ29uZmlnW2RlcHJlY2F0ZWRTZXR0aW5nXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHBvbGljeU5vdFNldCkge1xuICAgICAgICByZXBvcnQucHVzaChkZXByZWNhdGVkU2V0dGluZyk7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzOiBMb2FkZXJDb25maWcgPSBkZWZhdWx0c0NvcHlbcG9saWN5TmFtZV0uZGVmYXVsdDtcbiAgICAgICAgdXNlckNvbmZpZ1twb2xpY3lOYW1lXSA9IHsgZGVmYXVsdDogc2V0dGluZ3MgfTtcbiAgICAgICAgc3dpdGNoIChzZXR0aW5nKSB7XG4gICAgICAgICAgY2FzZSAnVGltZU91dCc6XG4gICAgICAgICAgICBzZXR0aW5ncy5tYXhMb2FkVGltZU1zID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy5tYXhUaW1lVG9GaXJzdEJ5dGVNcyA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTWF4UmV0cnknOlxuICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeSEubWF4TnVtUmV0cnkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldHRpbmdzLnRpbWVvdXRSZXRyeSEubWF4TnVtUmV0cnkgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1JldHJ5RGVsYXknOlxuICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeSEucmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy50aW1lb3V0UmV0cnkhLnJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTWF4UmV0cnlUaW1lb3V0JzpcbiAgICAgICAgICAgIHNldHRpbmdzLmVycm9yUmV0cnkhLm1heFJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0dGluZ3MudGltZW91dFJldHJ5IS5tYXhSZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJlcG9ydC5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICBgaGxzLmpzIGNvbmZpZzogXCIke3JlcG9ydC5qb2luKFxuICAgICAgICAgICdcIiwgXCInXG4gICAgICAgICl9XCIgc2V0dGluZyhzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIFwiJHtwb2xpY3lOYW1lfVwiOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHVzZXJDb25maWdbcG9saWN5TmFtZV1cbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5kZWZhdWx0c0NvcHksXG4gICAgLi4udXNlckNvbmZpZyxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVlcENweShvYmo6IGFueSk6IGFueSB7XG4gIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICByZXR1cm4gb2JqLm1hcChkZWVwQ3B5KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSBkZWVwQ3B5KG9ialtrZXldKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlU3RyZWFtaW5nTW9kZShjb25maWcpIHtcbiAgY29uc3QgY3VycmVudExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gIGlmIChjdXJyZW50TG9hZGVyICE9PSBGZXRjaExvYWRlciAmJiBjdXJyZW50TG9hZGVyICE9PSBYaHJMb2FkZXIpIHtcbiAgICAvLyBJZiBhIGRldmVsb3BlciBoYXMgY29uZmlndXJlZCB0aGVpciBvd24gbG9hZGVyLCByZXNwZWN0IHRoYXQgY2hvaWNlXG4gICAgbG9nZ2VyLmxvZyhcbiAgICAgICdbY29uZmlnXTogQ3VzdG9tIGxvYWRlciBkZXRlY3RlZCwgY2Fubm90IGVuYWJsZSBwcm9ncmVzc2l2ZSBzdHJlYW1pbmcnXG4gICAgKTtcbiAgICBjb25maWcucHJvZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5ID0gZmV0Y2hTdXBwb3J0ZWQoKTtcbiAgICBpZiAoY2FuU3RyZWFtUHJvZ3Jlc3NpdmVseSkge1xuICAgICAgY29uZmlnLmxvYWRlciA9IEZldGNoTG9hZGVyO1xuICAgICAgY29uZmlnLnByb2dyZXNzaXZlID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUyA9IHRydWU7XG4gICAgICBsb2dnZXIubG9nKCdbY29uZmlnXTogUHJvZ3Jlc3NpdmUgc3RyZWFtaW5nIGVuYWJsZWQsIHVzaW5nIEZldGNoTG9hZGVyJyk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBidWlsZEFic29sdXRlVVJMIH0gZnJvbSAndXJsLXRvb2xraXQnO1xuaW1wb3J0IFBsYXlsaXN0TG9hZGVyIGZyb20gJy4vbG9hZGVyL3BsYXlsaXN0LWxvYWRlcic7XG5pbXBvcnQgSUQzVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQgTGF0ZW5jeUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2xhdGVuY3ktY29udHJvbGxlcic7XG5pbXBvcnQgTGV2ZWxDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyJztcbmltcG9ydCB7IEZyYWdtZW50VHJhY2tlciB9IGZyb20gJy4vY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCBLZXlMb2FkZXIgZnJvbSAnLi9sb2FkZXIva2V5LWxvYWRlcic7XG5pbXBvcnQgU3RyZWFtQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgaXNTdXBwb3J0ZWQgfSBmcm9tICcuL2lzLXN1cHBvcnRlZCc7XG5pbXBvcnQgeyBsb2dnZXIsIGVuYWJsZUxvZ3MgfSBmcm9tICcuL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBlbmFibGVTdHJlYW1pbmdNb2RlLCBobHNEZWZhdWx0Q29uZmlnLCBtZXJnZUNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi9ldmVudHMnO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgSGRjcExldmVscyB9IGZyb20gJy4vdHlwZXMvbGV2ZWwnO1xuaW1wb3J0IHR5cGUgeyBIbHNFdmVudEVtaXR0ZXIsIEhsc0xpc3RlbmVycyB9IGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCB0eXBlIEF1ZGlvVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIEFickNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Fici1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIEJ1ZmZlckNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIENhcExldmVsQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgQ01DRENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2NtY2QtY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSBFTUVDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9lbWUtY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudEFQSSwgTmV0d29ya0NvbXBvbmVudEFQSSB9IGZyb20gJy4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSB7IE1lZGlhUGxheWxpc3QgfSBmcm9tICcuL3R5cGVzL21lZGlhLXBsYXlsaXN0JztcbmltcG9ydCB0eXBlIHsgSGxzQ29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBIZGNwTGV2ZWwsIExldmVsIH0gZnJvbSAnLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgdHlwZSB7IEJ1ZmZlckluZm8gfSBmcm9tICcuL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHR5cGUgQXVkaW9TdHJlYW1Db250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSBCYXNlUGxheWxpc3RDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgQmFzZVN0cmVhbUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvY29udGVudC1zdGVlcmluZy1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIEVycm9yQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvZXJyb3ItY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSBGUFNDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9mcHMtY29udHJvbGxlcic7XG5cbi8qKlxuICogVGhlIGBIbHNgIGNsYXNzIGlzIHRoZSBjb3JlIG9mIHRoZSBITFMuanMgbGlicmFyeSB1c2VkIHRvIGluc3RhbnRpYXRlIHBsYXllciBpbnN0YW5jZXMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhscyBpbXBsZW1lbnRzIEhsc0V2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUgc3RhdGljIGRlZmF1bHRDb25maWc6IEhsc0NvbmZpZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIHJ1bnRpbWUgY29uZmlndXJhdGlvbiB1c2VkIGJ5IHRoZSBwbGF5ZXIuIEF0IGluc3RhbnRpYXRpb24gdGhpcyBpcyBjb21iaW5hdGlvbiBvZiBgaGxzLnVzZXJDb25maWdgIG1lcmdlZCBvdmVyIGBIbHMuRGVmYXVsdENvbmZpZ2AuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgY29uZmlnOiBIbHNDb25maWc7XG5cbiAgLyoqXG4gICAqIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBwcm92aWRlZCBvbiBwbGF5ZXIgaW5zdGFudGlhdGlvbi5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSB1c2VyQ29uZmlnOiBQYXJ0aWFsPEhsc0NvbmZpZz47XG5cbiAgcHJpdmF0ZSBjb3JlQ29tcG9uZW50czogQ29tcG9uZW50QVBJW107XG4gIHByaXZhdGUgbmV0d29ya0NvbnRyb2xsZXJzOiBOZXR3b3JrQ29tcG9uZW50QVBJW107XG4gIHByaXZhdGUgX2VtaXR0ZXI6IEhsc0V2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgcHJpdmF0ZSBfYXV0b0xldmVsQ2FwcGluZzogbnVtYmVyO1xuICBwcml2YXRlIF9tYXhIZGNwTGV2ZWw6IEhkY3BMZXZlbCA9IG51bGw7XG4gIHByaXZhdGUgYWJyQ29udHJvbGxlcjogQWJyQ29udHJvbGxlcjtcbiAgcHJpdmF0ZSBidWZmZXJDb250cm9sbGVyOiBCdWZmZXJDb250cm9sbGVyO1xuICBwcml2YXRlIGNhcExldmVsQ29udHJvbGxlcjogQ2FwTGV2ZWxDb250cm9sbGVyO1xuICBwcml2YXRlIGxhdGVuY3lDb250cm9sbGVyOiBMYXRlbmN5Q29udHJvbGxlcjtcbiAgcHJpdmF0ZSBsZXZlbENvbnRyb2xsZXI6IExldmVsQ29udHJvbGxlcjtcbiAgcHJpdmF0ZSBzdHJlYW1Db250cm9sbGVyOiBTdHJlYW1Db250cm9sbGVyO1xuICBwcml2YXRlIGF1ZGlvVHJhY2tDb250cm9sbGVyOiBBdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgcHJpdmF0ZSBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjogU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gIHByaXZhdGUgZW1lQ29udHJvbGxlcjogRU1FQ29udHJvbGxlcjtcbiAgcHJpdmF0ZSBjbWNkQ29udHJvbGxlcjogQ01DRENvbnRyb2xsZXI7XG4gIHByaXZhdGUgX21lZGlhOiBIVE1MTWVkaWFFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgdXJsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogR2V0IHRoZSB2aWRlby1kZXYvaGxzLmpzIHBhY2thZ2UgdmVyc2lvbi5cbiAgICovXG4gIHN0YXRpYyBnZXQgdmVyc2lvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiBfX1ZFUlNJT05fXztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcmVxdWlyZWQgTWVkaWFTb3VyY2UgRXh0ZW5zaW9ucyBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgc3RhdGljIGlzU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc1N1cHBvcnRlZCgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBFdmVudHMoKTogdHlwZW9mIEV2ZW50cyB7XG4gICAgcmV0dXJuIEV2ZW50cztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXJyb3JUeXBlcygpOiB0eXBlb2YgRXJyb3JUeXBlcyB7XG4gICAgcmV0dXJuIEVycm9yVHlwZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEVycm9yRGV0YWlscygpOiB0eXBlb2YgRXJyb3JEZXRhaWxzIHtcbiAgICByZXR1cm4gRXJyb3JEZXRhaWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGFwcGxpZWQgdG8gbmV3IGluc3RhbmNlcy5cbiAgICovXG4gIHN0YXRpYyBnZXQgRGVmYXVsdENvbmZpZygpOiBIbHNDb25maWcge1xuICAgIGlmICghSGxzLmRlZmF1bHRDb25maWcpIHtcbiAgICAgIHJldHVybiBobHNEZWZhdWx0Q29uZmlnO1xuICAgIH1cblxuICAgIHJldHVybiBIbHMuZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYXBwbGllZCB0byBuZXcgaW5zdGFuY2VzLlxuICAgKi9cbiAgc3RhdGljIHNldCBEZWZhdWx0Q29uZmlnKGRlZmF1bHRDb25maWc6IEhsc0NvbmZpZykge1xuICAgIEhscy5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGFuIEhMUyBjbGllbnQgdGhhdCBjYW4gYXR0YWNoIHRvIGV4YWN0bHkgb25lIGBIVE1MTWVkaWFFbGVtZW50YC5cbiAgICogQHBhcmFtIHVzZXJDb25maWcgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgYXBwbGllZCBvdmVyIGBIbHMuRGVmYXVsdENvbmZpZ2BcbiAgICovXG4gIGNvbnN0cnVjdG9yKHVzZXJDb25maWc6IFBhcnRpYWw8SGxzQ29uZmlnPiA9IHt9KSB7XG4gICAgZW5hYmxlTG9ncyh1c2VyQ29uZmlnLmRlYnVnIHx8IGZhbHNlLCAnSGxzIGluc3RhbmNlJyk7XG4gICAgY29uc3QgY29uZmlnID0gKHRoaXMuY29uZmlnID0gbWVyZ2VDb25maWcoSGxzLkRlZmF1bHRDb25maWcsIHVzZXJDb25maWcpKTtcbiAgICB0aGlzLnVzZXJDb25maWcgPSB1c2VyQ29uZmlnO1xuXG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuXG4gICAgaWYgKGNvbmZpZy5wcm9ncmVzc2l2ZSkge1xuICAgICAgZW5hYmxlU3RyZWFtaW5nTW9kZShjb25maWcpO1xuICAgIH1cblxuICAgIC8vIGNvcmUgY29udHJvbGxlcnMgYW5kIG5ldHdvcmsgbG9hZGVyc1xuICAgIGNvbnN0IHtcbiAgICAgIGFickNvbnRyb2xsZXI6IENvbmZpZ0FickNvbnRyb2xsZXIsXG4gICAgICBidWZmZXJDb250cm9sbGVyOiBDb25maWdCdWZmZXJDb250cm9sbGVyLFxuICAgICAgY2FwTGV2ZWxDb250cm9sbGVyOiBDb25maWdDYXBMZXZlbENvbnRyb2xsZXIsXG4gICAgICBlcnJvckNvbnRyb2xsZXI6IENvbmZpZ0Vycm9yQ29udHJvbGxlcixcbiAgICAgIGZwc0NvbnRyb2xsZXI6IENvbmZpZ0Zwc0NvbnRyb2xsZXIsXG4gICAgfSA9IGNvbmZpZztcbiAgICBjb25zdCBlcnJvckNvbnRyb2xsZXIgPSBuZXcgQ29uZmlnRXJyb3JDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IGFickNvbnRyb2xsZXIgPSAodGhpcy5hYnJDb250cm9sbGVyID0gbmV3IENvbmZpZ0FickNvbnRyb2xsZXIodGhpcykpO1xuICAgIGNvbnN0IGJ1ZmZlckNvbnRyb2xsZXIgPSAodGhpcy5idWZmZXJDb250cm9sbGVyID1cbiAgICAgIG5ldyBDb25maWdCdWZmZXJDb250cm9sbGVyKHRoaXMpKTtcbiAgICBjb25zdCBjYXBMZXZlbENvbnRyb2xsZXIgPSAodGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPVxuICAgICAgbmV3IENvbmZpZ0NhcExldmVsQ29udHJvbGxlcih0aGlzKSk7XG5cbiAgICBjb25zdCBmcHNDb250cm9sbGVyID0gbmV3IENvbmZpZ0Zwc0NvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgcGxheUxpc3RMb2FkZXIgPSBuZXcgUGxheWxpc3RMb2FkZXIodGhpcyk7XG4gICAgY29uc3QgaWQzVHJhY2tDb250cm9sbGVyID0gbmV3IElEM1RyYWNrQ29udHJvbGxlcih0aGlzKTtcblxuICAgIGNvbnN0IENvbmZpZ0NvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgPSBjb25maWcuY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcbiAgICAvLyBDb25lbnRTdGVlcmluZ0NvbnRyb2xsZXIgaXMgZGVmaW5lZCBiZWZvcmUgTGV2ZWxDb250cm9sbGVyIHRvIHJlY2VpdmUgTXVsdGl2YXJpYW50IFBsYXlsaXN0IGV2ZW50cyBmaXJzdFxuICAgIGNvbnN0IGNvbnRlbnRTdGVlcmluZyA9IENvbmZpZ0NvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXJcbiAgICAgID8gbmV3IENvbmZpZ0NvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIodGhpcylcbiAgICAgIDogbnVsbDtcbiAgICBjb25zdCBsZXZlbENvbnRyb2xsZXIgPSAodGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKFxuICAgICAgdGhpcyxcbiAgICAgIGNvbnRlbnRTdGVlcmluZ1xuICAgICkpO1xuICAgIC8vIEZyYWdtZW50VHJhY2tlciBtdXN0IGJlIGRlZmluZWQgYmVmb3JlIFN0cmVhbUNvbnRyb2xsZXIgYmVjYXVzZSB0aGUgb3JkZXIgb2YgZXZlbnQgaGFuZGxpbmcgaXMgaW1wb3J0YW50XG4gICAgY29uc3QgZnJhZ21lbnRUcmFja2VyID0gbmV3IEZyYWdtZW50VHJhY2tlcih0aGlzKTtcbiAgICBjb25zdCBrZXlMb2FkZXIgPSBuZXcgS2V5TG9hZGVyKHRoaXMuY29uZmlnKTtcbiAgICBjb25zdCBzdHJlYW1Db250cm9sbGVyID0gKHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG5ldyBTdHJlYW1Db250cm9sbGVyKFxuICAgICAgdGhpcyxcbiAgICAgIGZyYWdtZW50VHJhY2tlcixcbiAgICAgIGtleUxvYWRlclxuICAgICkpO1xuXG4gICAgLy8gQ2FwIGxldmVsIGNvbnRyb2xsZXIgdXNlcyBzdHJlYW1Db250cm9sbGVyIHRvIGZsdXNoIHRoZSBidWZmZXJcbiAgICBjYXBMZXZlbENvbnRyb2xsZXIuc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKTtcbiAgICAvLyBmcHNDb250cm9sbGVyIHVzZXMgc3RyZWFtQ29udHJvbGxlciB0byBzd2l0Y2ggd2hlbiBmcmFtZXMgYXJlIGJlaW5nIGRyb3BwZWRcbiAgICBmcHNDb250cm9sbGVyLnNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcik7XG5cbiAgICBjb25zdCBuZXR3b3JrQ29udHJvbGxlcnM6IE5ldHdvcmtDb21wb25lbnRBUElbXSA9IFtcbiAgICAgIHBsYXlMaXN0TG9hZGVyLFxuICAgICAgbGV2ZWxDb250cm9sbGVyLFxuICAgICAgc3RyZWFtQ29udHJvbGxlcixcbiAgICBdO1xuICAgIGlmIChjb250ZW50U3RlZXJpbmcpIHtcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5zcGxpY2UoMSwgMCwgY29udGVudFN0ZWVyaW5nKTtcbiAgICB9XG5cbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IG5ldHdvcmtDb250cm9sbGVycztcbiAgICBjb25zdCBjb3JlQ29tcG9uZW50czogQ29tcG9uZW50QVBJW10gPSBbXG4gICAgICBhYnJDb250cm9sbGVyLFxuICAgICAgYnVmZmVyQ29udHJvbGxlcixcbiAgICAgIGNhcExldmVsQ29udHJvbGxlcixcbiAgICAgIGZwc0NvbnRyb2xsZXIsXG4gICAgICBpZDNUcmFja0NvbnRyb2xsZXIsXG4gICAgICBmcmFnbWVudFRyYWNrZXIsXG4gICAgXTtcblxuICAgIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoXG4gICAgICBjb25maWcuYXVkaW9UcmFja0NvbnRyb2xsZXIsXG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnNcbiAgICApO1xuICAgIGNvbnN0IEF1ZGlvU3RyZWFtQ29udHJvbGxlckNsYXNzID0gY29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiAgICBpZiAoQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3MpIHtcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKFxuICAgICAgICBuZXcgQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3ModGhpcywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBtdXN0IGJlIGRlZmluZWQgYmVmb3JlIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcbiAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKFxuICAgICAgY29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyLFxuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzXG4gICAgKTtcbiAgICBjb25zdCBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcyA9IGNvbmZpZy5zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgaWYgKFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChcbiAgICAgICAgbmV3IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlckNsYXNzKHRoaXMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy50aW1lbGluZUNvbnRyb2xsZXIsIGNvcmVDb21wb25lbnRzKTtcbiAgICBrZXlMb2FkZXIuZW1lQ29udHJvbGxlciA9IHRoaXMuZW1lQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihcbiAgICAgIGNvbmZpZy5lbWVDb250cm9sbGVyLFxuICAgICAgY29yZUNvbXBvbmVudHNcbiAgICApO1xuICAgIHRoaXMuY21jZENvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoXG4gICAgICBjb25maWcuY21jZENvbnRyb2xsZXIsXG4gICAgICBjb3JlQ29tcG9uZW50c1xuICAgICk7XG4gICAgdGhpcy5sYXRlbmN5Q29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihcbiAgICAgIExhdGVuY3lDb250cm9sbGVyLFxuICAgICAgY29yZUNvbXBvbmVudHNcbiAgICApO1xuXG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IGNvcmVDb21wb25lbnRzO1xuXG4gICAgLy8gRXJyb3IgY29udHJvbGxlciBoYW5kbGVzIGVycm9ycyBiZWZvcmUgYW5kIGFmdGVyIGFsbCBvdGhlciBjb250cm9sbGVyc1xuICAgIC8vIFRoaXMgbGlzdGVuZXIgd2lsbCBiZSBpbnZva2VkIGFmdGVyIGFsbCBvdGhlciBjb250cm9sbGVycyBlcnJvciBsaXN0ZW5lcnNcbiAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChlcnJvckNvbnRyb2xsZXIpO1xuICAgIGNvbnN0IG9uRXJyb3JPdXQgPSBlcnJvckNvbnRyb2xsZXIub25FcnJvck91dDtcbiAgICBpZiAodHlwZW9mIG9uRXJyb3JPdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMub24oRXZlbnRzLkVSUk9SLCBvbkVycm9yT3V0LCBlcnJvckNvbnRyb2xsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUNvbnRyb2xsZXIoQ29udHJvbGxlckNsYXNzLCBjb21wb25lbnRzKSB7XG4gICAgaWYgKENvbnRyb2xsZXJDbGFzcykge1xuICAgICAgY29uc3QgY29udHJvbGxlckluc3RhbmNlID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzKTtcbiAgICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChjb250cm9sbGVySW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRyb2xsZXJJbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBEZWxlZ2F0ZSB0aGUgRXZlbnRFbWl0dGVyIHRocm91Z2ggdGhlIHB1YmxpYyBBUEkgb2YgSGxzLmpzXG4gIG9uPEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnMsIENvbnRleHQgPSB1bmRlZmluZWQ+KFxuICAgIGV2ZW50OiBFLFxuICAgIGxpc3RlbmVyOiBIbHNMaXN0ZW5lcnNbRV0sXG4gICAgY29udGV4dDogQ29udGV4dCA9IHRoaXMgYXMgYW55XG4gICkge1xuICAgIHRoaXMuX2VtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfVxuXG4gIG9uY2U8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycywgQ29udGV4dCA9IHVuZGVmaW5lZD4oXG4gICAgZXZlbnQ6IEUsXG4gICAgbGlzdGVuZXI6IEhsc0xpc3RlbmVyc1tFXSxcbiAgICBjb250ZXh0OiBDb250ZXh0ID0gdGhpcyBhcyBhbnlcbiAgKSB7XG4gICAgdGhpcy5fZW1pdHRlci5vbmNlKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCk7XG4gIH1cblxuICByZW1vdmVBbGxMaXN0ZW5lcnM8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oZXZlbnQ/OiBFIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpO1xuICB9XG5cbiAgb2ZmPEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnMsIENvbnRleHQgPSB1bmRlZmluZWQ+KFxuICAgIGV2ZW50OiBFLFxuICAgIGxpc3RlbmVyPzogSGxzTGlzdGVuZXJzW0VdIHwgdW5kZWZpbmVkLFxuICAgIGNvbnRleHQ6IENvbnRleHQgPSB0aGlzIGFzIGFueSxcbiAgICBvbmNlPzogYm9vbGVhbiB8IHVuZGVmaW5lZFxuICApIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9mZihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQsIG9uY2UpO1xuICB9XG5cbiAgbGlzdGVuZXJzPEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnM+KGV2ZW50OiBFKTogSGxzTGlzdGVuZXJzW0VdW10ge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmxpc3RlbmVycyhldmVudCk7XG4gIH1cblxuICBlbWl0PEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnM+KFxuICAgIGV2ZW50OiBFLFxuICAgIG5hbWU6IEUsXG4gICAgZXZlbnRPYmplY3Q6IFBhcmFtZXRlcnM8SGxzTGlzdGVuZXJzW0VdPlsxXVxuICApOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5lbWl0KGV2ZW50LCBuYW1lLCBldmVudE9iamVjdCk7XG4gIH1cblxuICB0cmlnZ2VyPEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnM+KFxuICAgIGV2ZW50OiBFLFxuICAgIGV2ZW50T2JqZWN0OiBQYXJhbWV0ZXJzPEhsc0xpc3RlbmVyc1tFXT5bMV1cbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmRlYnVnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCBldmVudCwgZXZlbnRPYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCBldmVudCwgZXZlbnRPYmplY3QpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgJ0FuIGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIGhhbmRsaW5nIGV2ZW50ICcgK1xuICAgICAgICAgICAgZXZlbnQgK1xuICAgICAgICAgICAgJy4gRXJyb3IgbWVzc2FnZTogXCInICtcbiAgICAgICAgICAgIGUubWVzc2FnZSArXG4gICAgICAgICAgICAnXCIuIEhlcmUgaXMgYSBzdGFja3RyYWNlOicsXG4gICAgICAgICAgZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsaXN0ZW5lckNvdW50PEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnM+KGV2ZW50OiBFKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXN0cm95Jyk7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5ERVNUUk9ZSU5HLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICB0aGlzLnVybCA9IG51bGw7XG5cbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKChjb21wb25lbnQpID0+IGNvbXBvbmVudC5kZXN0cm95KCkpO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmZvckVhY2goKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LmRlc3Ryb3koKSk7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgIC8vIFJlbW92ZSBhbnkgcmVmZXJlbmNlcyB0aGF0IGNvdWxkIGJlIGhlbGQgaW4gY29uZmlnIG9wdGlvbnMgb3IgY2FsbGJhY2tzXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uZmlnLnhoclNldHVwID0gY29uZmlnLmZldGNoU2V0dXAgPSB1bmRlZmluZWQ7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMudXNlckNvbmZpZyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgSGxzLmpzIHRvIGEgbWVkaWEgZWxlbWVudFxuICAgKi9cbiAgYXR0YWNoTWVkaWEobWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgICBsb2dnZXIubG9nKCdhdHRhY2hNZWRpYScpO1xuICAgIHRoaXMuX21lZGlhID0gbWVkaWE7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHsgbWVkaWE6IG1lZGlhIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaCBIbHMuanMgZnJvbSB0aGUgbWVkaWFcbiAgICovXG4gIGRldGFjaE1lZGlhKCkge1xuICAgIGxvZ2dlci5sb2coJ2RldGFjaE1lZGlhJyk7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHVuZGVmaW5lZCk7XG4gICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIFVSTC4gQ2FuIGJlIHJlbGF0aXZlIG9yIGFic29sdXRlLlxuICAgKi9cbiAgbG9hZFNvdXJjZSh1cmw6IHN0cmluZykge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgbG9hZGVkU291cmNlID0gdGhpcy51cmw7XG4gICAgY29uc3QgbG9hZGluZ1NvdXJjZSA9ICh0aGlzLnVybCA9IGJ1aWxkQWJzb2x1dGVVUkwoXG4gICAgICBzZWxmLmxvY2F0aW9uLmhyZWYsXG4gICAgICB1cmwsXG4gICAgICB7XG4gICAgICAgIGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSxcbiAgICAgIH1cbiAgICApKTtcbiAgICBsb2dnZXIubG9nKGBsb2FkU291cmNlOiR7bG9hZGluZ1NvdXJjZX1gKTtcbiAgICBpZiAoXG4gICAgICBtZWRpYSAmJlxuICAgICAgbG9hZGVkU291cmNlICYmXG4gICAgICAobG9hZGVkU291cmNlICE9PSBsb2FkaW5nU291cmNlIHx8IHRoaXMuYnVmZmVyQ29udHJvbGxlci5oYXNTb3VyY2VUeXBlcygpKVxuICAgICkge1xuICAgICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgfVxuICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHsgdXJsOiB1cmwgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgbG9hZGluZyBkYXRhIGZyb20gdGhlIHN0cmVhbSBzb3VyY2UuXG4gICAqIERlcGVuZGluZyBvbiBkZWZhdWx0IGNvbmZpZywgY2xpZW50IHN0YXJ0cyBsb2FkaW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBhIHNvdXJjZSBpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFBvc2l0aW9uIC0gU2V0IHRoZSBzdGFydCBwb3NpdGlvbiB0byBzdHJlYW0gZnJvbS5cbiAgICogRGVmYXVsdHMgdG8gLTEgKE5vbmU6IHN0YXJ0cyBmcm9tIGVhcmxpZXN0IHBvaW50KVxuICAgKi9cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb246IG51bWJlciA9IC0xKSB7XG4gICAgbG9nZ2VyLmxvZyhgc3RhcnRMb2FkKCR7c3RhcnRQb3NpdGlvbn0pYCk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaCgoY29udHJvbGxlcikgPT4ge1xuICAgICAgY29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsb2FkaW5nIG9mIGFueSBzdHJlYW0gZGF0YS5cbiAgICovXG4gIHN0b3BMb2FkKCkge1xuICAgIGxvZ2dlci5sb2coJ3N0b3BMb2FkJyk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaCgoY29udHJvbGxlcikgPT4ge1xuICAgICAgY29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3YXAgdGhyb3VnaCBwb3NzaWJsZSBhdWRpbyBjb2RlY3MgaW4gdGhlIHN0cmVhbSAoZm9yIGV4YW1wbGUgdG8gc3dpdGNoIGZyb20gc3RlcmVvIHRvIDUuMSlcbiAgICovXG4gIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIGxvZ2dlci5sb2coJ3N3YXBBdWRpb0NvZGVjJyk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLnN3YXBBdWRpb0NvZGVjKCk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgbWVkaWEtZWxlbWVudCBmYWlscywgdGhpcyBhbGxvd3MgdG8gZGV0YWNoIGFuZCB0aGVuIHJlLWF0dGFjaCBpdFxuICAgKiBhcyBvbmUgY2FsbCAoY29udmVuaWVuY2UgbWV0aG9kKS5cbiAgICpcbiAgICogQXV0b21hdGljIHJlY292ZXJ5IG9mIG1lZGlhLWVycm9ycyBieSB0aGlzIHByb2Nlc3MgaXMgY29uZmlndXJhYmxlLlxuICAgKi9cbiAgcmVjb3Zlck1lZGlhRXJyb3IoKSB7XG4gICAgbG9nZ2VyLmxvZygncmVjb3Zlck1lZGlhRXJyb3InKTtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMuX21lZGlhO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUxldmVsKGxldmVsSW5kZXgsIHVybElkID0gMCkge1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnJlbW92ZUxldmVsKGxldmVsSW5kZXgsIHVybElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBsZXZlbHMgKHZhcmlhbnRzKSBzb3J0ZWQgYnkgSERDUC1MRVZFTCwgQkFORFdJRFRILCBTQ09SRSwgYW5kIFJFU09MVVRJT04gKGhlaWdodClcbiAgICovXG4gIGdldCBsZXZlbHMoKTogTGV2ZWxbXSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWxzO1xuICAgIHJldHVybiBsZXZlbHMgPyBsZXZlbHMgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBxdWFsaXR5IGxldmVsICh2YXJpYW50KSBjdXJyZW50bHkgcGxheWVkXG4gICAqL1xuICBnZXQgY3VycmVudExldmVsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggaW1tZWRpYXRlbHkuIFRoaXMgd2lsbCBmbHVzaCB0aGUgY3VycmVudCBidWZmZXIgdG8gcmVwbGFjZSB0aGUgcXVhbGl0eSBhc2FwLiBUaGF0IG1lYW5zIHBsYXliYWNrIHdpbGwgaW50ZXJydXB0IGF0IGxlYXN0IHNob3J0bHkgdG8gcmUtYnVmZmVyIGFuZCByZS1zeW5jIGV2ZW50dWFsbHkuIFNldCB0byAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbi5cbiAgICovXG4gIHNldCBjdXJyZW50TGV2ZWwobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIGxvZ2dlci5sb2coYHNldCBjdXJyZW50TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxvYWRMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5jbGVhclRpbWVyKCk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmltbWVkaWF0ZUxldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgbmV4dCBxdWFsaXR5IGxldmVsIGxvYWRlZCBhcyBzY2hlZHVsZWQgYnkgc3RyZWFtIGNvbnRyb2xsZXIuXG4gICAqL1xuICBnZXQgbmV4dExldmVsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEuXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHZpZGVvIHF1YWxpdHkgYXNhcCwgd2l0aG91dCBpbnRlcnJ1cHRpbmcgcGxheWJhY2suXG4gICAqIE1heSBhYm9ydCBjdXJyZW50IGxvYWRpbmcgb2YgZGF0YSwgYW5kIGZsdXNoIHBhcnRzIG9mIGJ1ZmZlciAob3V0c2lkZSBjdXJyZW50bHkgcGxheWVkIGZyYWdtZW50IHJlZ2lvbikuXG4gICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBuZXh0TGV2ZWwobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIGxvZ2dlci5sb2coYHNldCBuZXh0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHF1YWxpdHkgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSBvciBsYXN0IChvZiBub25lIGlzIGxvYWRlZCBjdXJyZW50bHkpIHNlZ21lbnRcbiAgICovXG4gIGdldCBsb2FkTGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEgaW4gYSBjb25zZXJ2YXRpdmUgd2F5LlxuICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSBxdWFsaXR5IHdpdGhvdXQgZmx1c2hpbmcsIGJ1dCBpbnRlcnJ1cHQgY3VycmVudCBsb2FkaW5nLlxuICAgKiBUaHVzIHRoZSBtb21lbnQgd2hlbiB0aGUgcXVhbGl0eSBzd2l0Y2ggd2lsbCBhcHBlYXIgaW4gZWZmZWN0IHdpbGwgb25seSBiZSBhZnRlciB0aGUgYWxyZWFkeSBleGlzdGluZyBidWZmZXIuXG4gICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBsb2FkTGV2ZWwobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIGxvZ2dlci5sb2coYHNldCBsb2FkTGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkXG4gICAqL1xuICBnZXQgbmV4dExvYWRMZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIHNlZ21lbnQgaW4gYSBmdWxseSBcIm5vbi1kZXN0cnVjdGl2ZVwiIHdheS5cbiAgICogU2FtZSBhcyBgbG9hZExldmVsYCBidXQgd2lsbCB3YWl0IGZvciBuZXh0IHN3aXRjaCAodW50aWwgY3VycmVudCBsb2FkaW5nIGlzIGRvbmUpLlxuICAgKi9cbiAgc2V0IG5leHRMb2FkTGV2ZWwobGV2ZWw6IG51bWJlcikge1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gXCJmaXJzdCBsZXZlbFwiOiBsaWtlIGEgZGVmYXVsdCBsZXZlbCwgaWYgbm90IHNldCxcbiAgICogZmFsbHMgYmFjayB0byBpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0XG4gICAqL1xuICBnZXQgZmlyc3RMZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBcImZpcnN0LWxldmVsXCIsIHNlZSBnZXR0ZXIuXG4gICAqL1xuICBzZXQgZmlyc3RMZXZlbChuZXdMZXZlbDogbnVtYmVyKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGZpcnN0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICogKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgKi9cbiAgZ2V0IHN0YXJ0TGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICogKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgKi9cbiAgc2V0IHN0YXJ0TGV2ZWwobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIGxvZ2dlci5sb2coYHNldCBzdGFydExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgLy8gaWYgbm90IGluIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBkZXRlY3Rpb24sIGVuc3VyZSBzdGFydExldmVsIGlzIGdyZWF0ZXIgdGhhbiBtaW5BdXRvTGV2ZWxcbiAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICBuZXdMZXZlbCA9IE1hdGgubWF4KG5ld0xldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gICAgfVxuXG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgbGV2ZWwgY2FwcGluZyBpcyBlbmFibGVkLlxuICAgKiBEZWZhdWx0IHZhbHVlIGlzIHNldCB2aWEgYGNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZWAuXG4gICAqL1xuICBnZXQgY2FwTGV2ZWxUb1BsYXllclNpemUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgbGV2ZWwgY2FwcGluZy4gSWYgZGlzYWJsZWQgYWZ0ZXIgcHJldmlvdXNseSBlbmFibGVkLCBgbmV4dExldmVsU3dpdGNoYCB3aWxsIGJlIGltbWVkaWF0ZWx5IGNhbGxlZC5cbiAgICovXG4gIHNldCBjYXBMZXZlbFRvUGxheWVyU2l6ZShzaG91bGRTdGFydENhcHBpbmc6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZSA9ICEhc2hvdWxkU3RhcnRDYXBwaW5nO1xuXG4gICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplICE9PSB0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyLnN0YXJ0Q2FwcGluZygpOyAvLyBJZiBjYXBwaW5nIG9jY3VycywgbmV4dExldmVsU3dpdGNoIHdpbGwgaGFwcGVuIGJhc2VkIG9uIHNpemUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdG9wQ2FwcGluZygpO1xuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpOyAvLyBOb3cgd2UncmUgdW5jYXBwZWQsIGdldCB0aGUgbmV4dCBsZXZlbCBhc2FwLlxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSA9IG5ld0NhcExldmVsVG9QbGF5ZXJTaXplO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAqL1xuICBnZXQgYXV0b0xldmVsQ2FwcGluZygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmFuZHdpZHRoIGVzdGltYXRlIGluIGJpdHMgcGVyIHNlY29uZCwgd2hlbiBhdmFpbGFibGUuIE90aGVyd2lzZSwgYE5hTmAgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBnZXQgYmFuZHdpZHRoRXN0aW1hdGUoKTogbnVtYmVyIHtcbiAgICBjb25zdCB7IGJ3RXN0aW1hdG9yIH0gPSB0aGlzLmFickNvbnRyb2xsZXI7XG4gICAgaWYgKCFid0VzdGltYXRvcikge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIGJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRpbWUgdG8gZmlyc3QgYnl0ZSBlc3RpbWF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHR0ZmJFc3RpbWF0ZSgpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgYndFc3RpbWF0b3IgfSA9IHRoaXMuYWJyQ29udHJvbGxlcjtcbiAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxuICAgKi9cbiAgc2V0IGF1dG9MZXZlbENhcHBpbmcobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIGlmICh0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nICE9PSBuZXdMZXZlbCkge1xuICAgICAgbG9nZ2VyLmxvZyhgc2V0IGF1dG9MZXZlbENhcHBpbmc6JHtuZXdMZXZlbH1gKTtcbiAgICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSBuZXdMZXZlbDtcbiAgICB9XG4gIH1cblxuICBnZXQgbWF4SGRjcExldmVsKCk6IEhkY3BMZXZlbCB7XG4gICAgcmV0dXJuIHRoaXMuX21heEhkY3BMZXZlbDtcbiAgfVxuXG4gIHNldCBtYXhIZGNwTGV2ZWwodmFsdWU6IEhkY3BMZXZlbCkge1xuICAgIGlmIChIZGNwTGV2ZWxzLmluZGV4T2YodmFsdWUpID4gLTEpIHtcbiAgICAgIHRoaXMuX21heEhkY3BMZXZlbCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBlbmFibGVkXG4gICAqL1xuICBnZXQgYXV0b0xldmVsRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIExldmVsIHNldCBtYW51YWxseSAoaWYgYW55KVxuICAgKi9cbiAgZ2V0IG1hbnVhbExldmVsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIG1pbiBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gY29uZmlnLm1pbkF1dG9CaXRyYXRlXG4gICAqL1xuICBnZXQgbWluQXV0b0xldmVsKCk6IG51bWJlciB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgY29uZmlnOiB7IG1pbkF1dG9CaXRyYXRlIH0sXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHJldHVybiAwO1xuXG4gICAgY29uc3QgbGVuID0gbGV2ZWxzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAobGV2ZWxzW2ldLm1heEJpdHJhdGUgPj0gbWluQXV0b0JpdHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogbWF4IGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBhdXRvTGV2ZWxDYXBwaW5nXG4gICAqL1xuICBnZXQgbWF4QXV0b0xldmVsKCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBsZXZlbHMsIGF1dG9MZXZlbENhcHBpbmcsIG1heEhkY3BMZXZlbCB9ID0gdGhpcztcblxuICAgIGxldCBtYXhBdXRvTGV2ZWw7XG4gICAgaWYgKGF1dG9MZXZlbENhcHBpbmcgPT09IC0xICYmIGxldmVscyAmJiBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICBtYXhBdXRvTGV2ZWwgPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QXV0b0xldmVsID0gYXV0b0xldmVsQ2FwcGluZztcbiAgICB9XG5cbiAgICBpZiAobWF4SGRjcExldmVsKSB7XG4gICAgICBmb3IgKGxldCBpID0gbWF4QXV0b0xldmVsOyBpLS07ICkge1xuICAgICAgICBjb25zdCBoZGNwTGV2ZWwgPSBsZXZlbHNbaV0uYXR0cnNbJ0hEQ1AtTEVWRUwnXTtcbiAgICAgICAgaWYgKGhkY3BMZXZlbCAmJiBoZGNwTGV2ZWwgPD0gbWF4SGRjcExldmVsKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4QXV0b0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIG5leHQgYXV0b21hdGljYWxseSBzZWxlY3RlZCBxdWFsaXR5IGxldmVsXG4gICAqL1xuICBnZXQgbmV4dEF1dG9MZXZlbCgpOiBudW1iZXIge1xuICAgIC8vIGVuc3VyZSBuZXh0IGF1dG8gbGV2ZWwgaXMgYmV0d2VlbiAgbWluIGFuZCBtYXggYXV0byBsZXZlbFxuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgIE1hdGgubWF4KHRoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCksXG4gICAgICB0aGlzLm1heEF1dG9MZXZlbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogdGhpcyBzZXR0ZXIgaXMgdXNlZCB0byBmb3JjZSBuZXh0IGF1dG8gbGV2ZWwuXG4gICAqIHRoaXMgaXMgdXNlZnVsIHRvIGZvcmNlIGEgc3dpdGNoIGRvd24gaW4gYXV0byBtb2RlOlxuICAgKiBpbiBjYXNlIG9mIGxvYWQgZXJyb3Igb24gbGV2ZWwgTiwgaGxzLmpzIGNhbiBzZXQgbmV4dEF1dG9MZXZlbCB0byBOLTEgZm9yIGV4YW1wbGUpXG4gICAqIGZvcmNlZCB2YWx1ZSBpcyB2YWxpZCBmb3Igb25lIGZyYWdtZW50LiB1cG9uIHN1Y2Nlc3NmdWwgZnJhZyBsb2FkaW5nIGF0IGZvcmNlZCBsZXZlbCxcbiAgICogdGhpcyB2YWx1ZSB3aWxsIGJlIHJlc2V0dGVkIHRvIC0xIGJ5IEFCUiBjb250cm9sbGVyLlxuICAgKi9cbiAgc2V0IG5leHRBdXRvTGV2ZWwobmV4dExldmVsOiBudW1iZXIpIHtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCA9IE1hdGgubWF4KHRoaXMubWluQXV0b0xldmVsLCBuZXh0TGV2ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgZGF0ZXRpbWUgdmFsdWUgcmVsYXRpdmUgdG8gbWVkaWEuY3VycmVudFRpbWUgZm9yIHRoZSBhY3RpdmUgbGV2ZWwgUHJvZ3JhbSBEYXRlIFRpbWUgaWYgcHJlc2VudFxuICAgKi9cbiAgcHVibGljIGdldCBwbGF5aW5nRGF0ZSgpOiBEYXRlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50UHJvZ3JhbURhdGVUaW1lO1xuICB9XG5cbiAgcHVibGljIGdldCBtYWluRm9yd2FyZEJ1ZmZlckluZm8oKTogQnVmZmVySW5mbyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2Ygc2VsZWN0YWJsZSBhdWRpbyB0cmFja3NcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrcygpOiBBcnJheTxNZWRpYVBsYXlsaXN0PiB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cylcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrKCk6IG51bWJlciB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3RzIGFuIGF1ZGlvIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHNcbiAgICovXG4gIHNldCBhdWRpb1RyYWNrKGF1ZGlvVHJhY2tJZDogbnVtYmVyKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChhdWRpb1RyYWNrQ29udHJvbGxlcikge1xuICAgICAgYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA9IGF1ZGlvVHJhY2tJZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0XG4gICAqL1xuICBnZXQgc3VidGl0bGVUcmFja3MoKTogQXJyYXk8TWVkaWFQbGF5bGlzdD4ge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXJcbiAgICAgID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFja3NcbiAgICAgIDogW107XG4gIH1cblxuICAvKipcbiAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cylcbiAgICovXG4gIGdldCBzdWJ0aXRsZVRyYWNrKCk6IG51bWJlciB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgfVxuXG4gIGdldCBtZWRpYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWE7XG4gIH1cblxuICAvKipcbiAgICogc2VsZWN0IGFuIHN1YnRpdGxlIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHNcbiAgICovXG4gIHNldCBzdWJ0aXRsZVRyYWNrKHN1YnRpdGxlVHJhY2tJZDogbnVtYmVyKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBzdWJ0aXRsZSBkaXNwbGF5IGlzIGVuYWJsZWQgb3Igbm90XG4gICAqL1xuICBnZXQgc3VidGl0bGVEaXNwbGF5KCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXJcbiAgICAgID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5XG4gICAgICA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZS9kaXNhYmxlIHN1YnRpdGxlIGRpc3BsYXkgcmVuZGVyaW5nXG4gICAqL1xuICBzZXQgc3VidGl0bGVEaXNwbGF5KHZhbHVlOiBib29sZWFuKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCBtb2RlIGZvciBMb3ctTGF0ZW5jeSBITFMgbG9hZGluZ1xuICAgKi9cbiAgZ2V0IGxvd0xhdGVuY3lNb2RlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBMb3ctTGF0ZW5jeSBITFMgcGFydCBwbGF5bGlzdCBhbmQgc2VnbWVudCBsb2FkaW5nLCBhbmQgc3RhcnQgbGl2ZSBzdHJlYW1zIGF0IHBsYXlsaXN0IFBBUlQtSE9MRC1CQUNLIHJhdGhlciB0aGFuIEhPTEQtQkFDSy5cbiAgICovXG4gIHNldCBsb3dMYXRlbmN5TW9kZShtb2RlOiBib29sZWFuKSB7XG4gICAgdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgPSBtb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiBsaXZlIHN5bmMgcG9pbnQgKGllIGVkZ2Ugb2YgbGl2ZSBwb3NpdGlvbiBtaW51cyBzYWZldHkgZGVsYXkgZGVmaW5lZCBieSBgYGBobHMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25gYGApXG4gICAqIEByZXR1cm5zIG51bGwgcHJpb3IgdG8gbG9hZGluZyBsaXZlIFBsYXlsaXN0XG4gICAqL1xuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzdGltYXRlZCBwb3NpdGlvbiAoaW4gc2Vjb25kcykgb2YgbGl2ZSBlZGdlIChpZSBlZGdlIG9mIGxpdmUgcGxheWxpc3QgcGx1cyB0aW1lIHN5bmMgcGxheWxpc3QgYWR2YW5jZWQpXG4gICAqIEByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgKi9cbiAgZ2V0IGxhdGVuY3koKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5sYXRlbmN5O1xuICB9XG5cbiAgLyoqXG4gICAqIG1heGltdW0gZGlzdGFuY2UgZnJvbSB0aGUgZWRnZSBiZWZvcmUgdGhlIHBsYXllciBzZWVrcyBmb3J3YXJkIHRvIGBgYGhscy5saXZlU3luY1Bvc2l0aW9uYGBgXG4gICAqIGNvbmZpZ3VyZWQgdXNpbmcgYGBgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50YGBgIChtdWx0aXBsZSBvZiB0YXJnZXQgZHVyYXRpb24pIG9yIGBgYGxpdmVNYXhMYXRlbmN5RHVyYXRpb25gYGBcbiAgICogQHJldHVybnMgMCBiZWZvcmUgZmlyc3QgcGxheWxpc3QgaXMgbG9hZGVkXG4gICAqL1xuICBnZXQgbWF4TGF0ZW5jeSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLm1heExhdGVuY3k7XG4gIH1cblxuICAvKipcbiAgICogdGFyZ2V0IGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYXMgY2FsY3VsYXRlZCBieSB0aGUgbGF0ZW5jeSBjb250cm9sbGVyXG4gICAqL1xuICBnZXQgdGFyZ2V0TGF0ZW5jeSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci50YXJnZXRMYXRlbmN5O1xuICB9XG5cbiAgLyoqXG4gICAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBlZGdlIG9mIHRoZSBjdXJyZW50IGxpdmUgcGxheWxpc3QgaXMgYWR2YW5jaW5nIG9yIDEgaWYgdGhlcmUgaXMgbm9uZVxuICAgKi9cbiAgZ2V0IGRyaWZ0KCk6IG51bWJlciB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmRyaWZ0O1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCB0byB0cnVlIHdoZW4gc3RhcnRMb2FkIGlzIGNhbGxlZCBiZWZvcmUgTUFOSUZFU1RfUEFSU0VEIGV2ZW50XG4gICAqL1xuICBnZXQgZm9yY2VTdGFydExvYWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5mb3JjZVN0YXJ0TG9hZDtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSB7XG4gIE1lZGlhUGxheWxpc3QsXG4gIEVycm9yRGV0YWlscyxcbiAgRXJyb3JUeXBlcyxcbiAgRXZlbnRzLFxuICBMZXZlbCxcbiAgSGxzTGlzdGVuZXJzLFxuICBIbHNFdmVudEVtaXR0ZXIsXG4gIEhsc0NvbmZpZyxcbiAgQnVmZmVySW5mbyxcbiAgSGRjcExldmVscyxcbiAgSGRjcExldmVsLFxuICBBYnJDb250cm9sbGVyLFxuICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIsXG4gIEF1ZGlvVHJhY2tDb250cm9sbGVyLFxuICBCYXNlUGxheWxpc3RDb250cm9sbGVyLFxuICBCYXNlU3RyZWFtQ29udHJvbGxlcixcbiAgQnVmZmVyQ29udHJvbGxlcixcbiAgQ2FwTGV2ZWxDb250cm9sbGVyLFxuICBDTUNEQ29udHJvbGxlcixcbiAgQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlcixcbiAgRU1FQ29udHJvbGxlcixcbiAgRXJyb3JDb250cm9sbGVyLFxuICBGUFNDb250cm9sbGVyLFxuICBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcixcbn07XG5leHBvcnQgdHlwZSB7XG4gIENvbXBvbmVudEFQSSxcbiAgQWJyQ29tcG9uZW50QVBJLFxuICBOZXR3b3JrQ29tcG9uZW50QVBJLFxufSBmcm9tICcuL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuZXhwb3J0IHR5cGUge1xuICBBQlJDb250cm9sbGVyQ29uZmlnLFxuICBCdWZmZXJDb250cm9sbGVyQ29uZmlnLFxuICBDYXBMZXZlbENvbnRyb2xsZXJDb25maWcsXG4gIENNQ0RDb250cm9sbGVyQ29uZmlnLFxuICBFTUVDb250cm9sbGVyQ29uZmlnLFxuICBEUk1TeXN0ZW1zQ29uZmlndXJhdGlvbixcbiAgRFJNU3lzdGVtT3B0aW9ucyxcbiAgRlBTQ29udHJvbGxlckNvbmZpZyxcbiAgRnJhZ21lbnRMb2FkZXJDb25maWcsXG4gIEZyYWdtZW50TG9hZGVyQ29uc3RydWN0b3IsXG4gIEhsc0xvYWRQb2xpY2llcyxcbiAgTGV2ZWxDb250cm9sbGVyQ29uZmlnLFxuICBMb2FkZXJDb25maWcsXG4gIExvYWRQb2xpY3ksXG4gIE1QNFJlbXV4ZXJDb25maWcsXG4gIFBsYXlsaXN0TG9hZGVyQ29uZmlnLFxuICBQbGF5bGlzdExvYWRlckNvbnN0cnVjdG9yLFxuICBSZXRyeUNvbmZpZyxcbiAgU3RyZWFtQ29udHJvbGxlckNvbmZpZyxcbiAgTGF0ZW5jeUNvbnRyb2xsZXJDb25maWcsXG4gIE1ldGFkYXRhQ29udHJvbGxlckNvbmZpZyxcbiAgVGltZWxpbmVDb250cm9sbGVyQ29uZmlnLFxuICBUU0RlbXV4ZXJDb25maWcsXG59IGZyb20gJy4vY29uZmlnJztcbmV4cG9ydCB0eXBlIHsgTWVkaWFLZXlTZXNzaW9uQ29udGV4dCB9IGZyb20gJy4vY29udHJvbGxlci9lbWUtY29udHJvbGxlcic7XG5leHBvcnQgdHlwZSB7IElMb2dnZXIgfSBmcm9tICcuL3V0aWxzL2xvZ2dlcic7XG5leHBvcnQgdHlwZSB7IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciB9IGZyb20gJy4vY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlcic7XG5leHBvcnQgdHlwZSB7IFRpbWVsaW5lQ29udHJvbGxlciB9IGZyb20gJy4vY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyJztcbmV4cG9ydCB0eXBlIHsgQ3Vlc0ludGVyZmFjZSB9IGZyb20gJy4vdXRpbHMvY3Vlcyc7XG5leHBvcnQgdHlwZSB7XG4gIE1lZGlhS2V5RnVuYyxcbiAgS2V5U3lzdGVtcyxcbiAgS2V5U3lzdGVtRm9ybWF0cyxcbn0gZnJvbSAnLi91dGlscy9tZWRpYWtleXMtaGVscGVyJztcbmV4cG9ydCB0eXBlIHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi9sb2FkZXIvZGF0ZS1yYW5nZSc7XG5leHBvcnQgdHlwZSB7IExvYWRTdGF0cyB9IGZyb20gJy4vbG9hZGVyL2xvYWQtc3RhdHMnO1xuZXhwb3J0IHR5cGUgeyBMZXZlbEtleSB9IGZyb20gJy4vbG9hZGVyL2xldmVsLWtleSc7XG5leHBvcnQgdHlwZSB7IExldmVsRGV0YWlscyB9IGZyb20gJy4vbG9hZGVyL2xldmVsLWRldGFpbHMnO1xuZXhwb3J0IHR5cGUgeyBTb3VyY2VCdWZmZXJOYW1lIH0gZnJvbSAnLi90eXBlcy9idWZmZXInO1xuZXhwb3J0IHR5cGUge1xuICBNZXRhZGF0YVNhbXBsZSxcbiAgTWV0YWRhdGFTY2hlbWEsXG4gIFVzZXJkYXRhU2FtcGxlLFxufSBmcm9tICcuL3R5cGVzL2RlbXV4ZXInO1xuZXhwb3J0IHR5cGUge1xuICBIbHNTa2lwLFxuICBIbHNVcmxQYXJhbWV0ZXJzLFxuICBMZXZlbEF0dHJpYnV0ZXMsXG4gIExldmVsUGFyc2VkLFxuICBWYXJpYWJsZU1hcCxcbn0gZnJvbSAnLi90eXBlcy9sZXZlbCc7XG5leHBvcnQgdHlwZSB7XG4gIFBsYXlsaXN0TGV2ZWxUeXBlLFxuICBIbHNDaHVua1BlcmZvcm1hbmNlVGltaW5nLFxuICBIbHNQZXJmb3JtYW5jZVRpbWluZyxcbiAgSGxzUHJvZ3Jlc3NpdmVQZXJmb3JtYW5jZVRpbWluZyxcbiAgUGxheWxpc3RDb250ZXh0VHlwZSxcbiAgUGxheWxpc3RMb2FkZXJDb250ZXh0LFxuICBGcmFnbWVudExvYWRlckNvbnRleHQsXG4gIExvYWRlcixcbiAgTG9hZGVyU3RhdHMsXG4gIExvYWRlckNvbnRleHQsXG4gIExvYWRlclJlc3BvbnNlLFxuICBMb2FkZXJDb25maWd1cmF0aW9uLFxuICBMb2FkZXJDYWxsYmFja3MsXG4gIExvYWRlck9uUHJvZ3Jlc3MsXG4gIExvYWRlck9uQWJvcnQsXG4gIExvYWRlck9uRXJyb3IsXG4gIExvYWRlck9uU3VjY2VzcyxcbiAgTG9hZGVyT25UaW1lb3V0LFxufSBmcm9tICcuL3R5cGVzL2xvYWRlcic7XG5leHBvcnQgdHlwZSB7XG4gIE1lZGlhQXR0cmlidXRlcyxcbiAgTWVkaWFQbGF5bGlzdFR5cGUsXG4gIE1haW5QbGF5bGlzdFR5cGUsXG4gIEF1ZGlvUGxheWxpc3RUeXBlLFxuICBTdWJ0aXRsZVBsYXlsaXN0VHlwZSxcbn0gZnJvbSAnLi90eXBlcy9tZWRpYS1wbGF5bGlzdCc7XG5leHBvcnQgdHlwZSB7IFRyYWNrLCBUcmFja1NldCB9IGZyb20gJy4vdHlwZXMvdHJhY2snO1xuZXhwb3J0IHR5cGUgeyBDaHVua01ldGFkYXRhIH0gZnJvbSAnLi90eXBlcy90cmFuc211eGVyJztcbmV4cG9ydCB0eXBlIHtcbiAgQmFzZVNlZ21lbnQsXG4gIEZyYWdtZW50LFxuICBQYXJ0LFxuICBFbGVtZW50YXJ5U3RyZWFtcyxcbiAgRWxlbWVudGFyeVN0cmVhbVR5cGVzLFxuICBFbGVtZW50YXJ5U3RyZWFtSW5mbyxcbn0gZnJvbSAnLi9sb2FkZXIvZnJhZ21lbnQnO1xuZXhwb3J0IHR5cGUge1xuICBUcmFja0xvYWRpbmdEYXRhLFxuICBUcmFja0xvYWRlZERhdGEsXG4gIEF1ZGlvVHJhY2tMb2FkZWREYXRhLFxuICBBdWRpb1RyYWNrc1VwZGF0ZWREYXRhLFxuICBBdWRpb1RyYWNrU3dpdGNoZWREYXRhLFxuICBBdWRpb1RyYWNrU3dpdGNoaW5nRGF0YSxcbiAgQmFja0J1ZmZlckRhdGEsXG4gIEJ1ZmZlckFwcGVuZGVkRGF0YSxcbiAgQnVmZmVyQXBwZW5kaW5nRGF0YSxcbiAgQnVmZmVyQ29kZWNzRGF0YSxcbiAgQnVmZmVyQ3JlYXRlZERhdGEsXG4gIEJ1ZmZlckVPU0RhdGEsXG4gIEJ1ZmZlckZsdXNoZWREYXRhLFxuICBCdWZmZXJGbHVzaGluZ0RhdGEsXG4gIEN1ZXNQYXJzZWREYXRhLFxuICBFcnJvckRhdGEsXG4gIEZQU0Ryb3BEYXRhLFxuICBGUFNEcm9wTGV2ZWxDYXBwaW5nRGF0YSxcbiAgRnJhZ0J1ZmZlcmVkRGF0YSxcbiAgRnJhZ0NoYW5nZWREYXRhLFxuICBGcmFnRGVjcnlwdGVkRGF0YSxcbiAgRnJhZ0xvYWRlZERhdGEsXG4gIEZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZERhdGEsXG4gIEZyYWdMb2FkaW5nRGF0YSxcbiAgRnJhZ1BhcnNlZERhdGEsXG4gIEZyYWdQYXJzaW5nSW5pdFNlZ21lbnREYXRhLFxuICBGcmFnUGFyc2luZ01ldGFkYXRhRGF0YSxcbiAgRnJhZ1BhcnNpbmdVc2VyZGF0YURhdGEsXG4gIEluaXRQVFNGb3VuZERhdGEsXG4gIEtleUxvYWRlZERhdGEsXG4gIEtleUxvYWRpbmdEYXRhLFxuICBMZXZlbExvYWRlZERhdGEsXG4gIExldmVsTG9hZGluZ0RhdGEsXG4gIExldmVsUFRTVXBkYXRlZERhdGEsXG4gIExldmVsc1VwZGF0ZWREYXRhLFxuICBMZXZlbFN3aXRjaGVkRGF0YSxcbiAgTGV2ZWxTd2l0Y2hpbmdEYXRhLFxuICBMZXZlbFVwZGF0ZWREYXRhLFxuICBMaXZlQmFja0J1ZmZlckRhdGEsXG4gIENvbnRlbnRTdGVlcmluZ09wdGlvbnMsXG4gIE1hbmlmZXN0TG9hZGVkRGF0YSxcbiAgTWFuaWZlc3RMb2FkaW5nRGF0YSxcbiAgTWFuaWZlc3RQYXJzZWREYXRhLFxuICBNZWRpYUF0dGFjaGVkRGF0YSxcbiAgTWVkaWFBdHRhY2hpbmdEYXRhLFxuICBOb25OYXRpdmVUZXh0VHJhY2ssXG4gIE5vbk5hdGl2ZVRleHRUcmFja3NEYXRhLFxuICBTdWJ0aXRsZUZyYWdQcm9jZXNzZWREYXRhLFxuICBTdWJ0aXRsZVRyYWNrTG9hZGVkRGF0YSxcbiAgU3VidGl0bGVUcmFja3NVcGRhdGVkRGF0YSxcbiAgU3VidGl0bGVUcmFja1N3aXRjaERhdGEsXG59IGZyb20gJy4vdHlwZXMvZXZlbnRzJztcbmV4cG9ydCB0eXBlIHtcbiAgTmV0d29ya0Vycm9yQWN0aW9uLFxuICBFcnJvckFjdGlvbkZsYWdzLFxuICBJRXJyb3JBY3Rpb24sXG59IGZyb20gJy4vY29udHJvbGxlci9lcnJvci1jb250cm9sbGVyJztcbmV4cG9ydCB0eXBlIHsgQXR0ckxpc3QgfSBmcm9tICcuL3V0aWxzL2F0dHItbGlzdCc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hls.js/dist/hls.light.js\n");

/***/ })

}]);