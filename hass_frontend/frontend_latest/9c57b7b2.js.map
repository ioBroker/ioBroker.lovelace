{"version":3,"file":"9c57b7b2.js","mappings":";AA6HA;;;AAGA;AACA;AAKA;AACA;AACA;;;AAGA;;AAIA;;;;;AArBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3FA","sources":["webpack://home-assistant-frontend/./src/panels/lovelace/cards/hui-map-card.ts"],"sourcesContent":["import { HassEntities, HassEntity } from \"home-assistant-js-websocket\";\nimport { LatLngTuple } from \"leaflet\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { mdiImageFilterCenterFocus } from \"@mdi/js\";\nimport memoizeOne from \"memoize-one\";\nimport { computeDomain } from \"../../../common/entity/compute_domain\";\nimport parseAspectRatio from \"../../../common/util/parse-aspect-ratio\";\nimport \"../../../components/ha-card\";\nimport \"../../../components/ha-icon-button\";\nimport { fetchRecent } from \"../../../data/history\";\nimport { HomeAssistant } from \"../../../types\";\nimport { findEntities } from \"../common/find-entities\";\nimport { processConfigEntities } from \"../common/process-config-entities\";\nimport { EntityConfig } from \"../entity-rows/types\";\nimport { LovelaceCard } from \"../types\";\nimport { MapCardConfig } from \"./types\";\nimport \"../../../components/map/ha-map\";\nimport type { HaMap, HaMapPaths } from \"../../../components/map/ha-map\";\nimport { getColorByIndex } from \"../../../common/color/colors\";\n\nconst MINUTE = 60000;\n\n@customElement(\"hui-map-card\")\nclass HuiMapCard extends LitElement implements LovelaceCard {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean, reflect: true })\n  public isPanel = false;\n\n  @state()\n  private _history?: HassEntity[][];\n\n  @state()\n  private _config?: MapCardConfig;\n\n  @query(\"ha-map\")\n  private _map?: HaMap;\n\n  private _date?: Date;\n\n  private _configEntities?: string[];\n\n  private _colorDict: Record<string, string> = {};\n\n  private _colorIndex = 0;\n\n  public setConfig(config: MapCardConfig): void {\n    if (!config) {\n      throw new Error(\"Error in card configuration.\");\n    }\n\n    if (!config.entities?.length && !config.geo_location_sources) {\n      throw new Error(\n        \"Either entities or geo_location_sources must be specified\"\n      );\n    }\n    if (config.entities && !Array.isArray(config.entities)) {\n      throw new Error(\"Entities need to be an array\");\n    }\n    if (\n      config.geo_location_sources &&\n      !Array.isArray(config.geo_location_sources)\n    ) {\n      throw new Error(\"Geo_location_sources needs to be an array\");\n    }\n\n    this._config = config;\n    this._configEntities = (\n      config.entities\n        ? processConfigEntities<EntityConfig>(config.entities)\n        : []\n    ).map((entity) => entity.entity);\n\n    this._cleanupHistory();\n  }\n\n  public getCardSize(): number {\n    if (!this._config?.aspect_ratio) {\n      return 7;\n    }\n\n    const ratio = parseAspectRatio(this._config.aspect_ratio);\n    const ar =\n      ratio && ratio.w > 0 && ratio.h > 0\n        ? `${((100 * ratio.h) / ratio.w).toFixed(2)}`\n        : \"100\";\n    return 1 + Math.floor(Number(ar) / 25) || 3;\n  }\n\n  public static async getConfigElement() {\n    await import(\"../editor/config-elements/hui-map-card-editor\");\n    return document.createElement(\"hui-map-card-editor\");\n  }\n\n  public static getStubConfig(\n    hass: HomeAssistant,\n    entities: string[],\n    entitiesFallback: string[]\n  ): MapCardConfig {\n    const includeDomains = [\"device_tracker\"];\n    const maxEntities = 2;\n    const foundEntities = findEntities(\n      hass,\n      maxEntities,\n      entities,\n      entitiesFallback,\n      includeDomains\n    );\n\n    return { type: \"map\", entities: foundEntities };\n  }\n\n  protected render(): TemplateResult {\n    if (!this._config) {\n      return html``;\n    }\n    return html`\n      <ha-card id=\"card\" .header=${this._config.title}>\n        <div id=\"root\">\n          <ha-map\n            .hass=${this.hass}\n            .entities=${this._getEntities(\n              this.hass.states,\n              this._config,\n              this._configEntities\n            )}\n            .zoom=${this._config.default_zoom ?? 14}\n            .paths=${this._getHistoryPaths(this._config, this._history)}\n            .darkMode=${this._config.dark_mode}\n          ></ha-map>\n          <ha-icon-button\n            .label=${this.hass!.localize(\n              \"ui.panel.lovelace.cards.map.reset_focus\"\n            )}\n            .path=${mdiImageFilterCenterFocus}\n            @click=${this._fitMap}\n            tabindex=\"0\"\n          ></ha-icon-button>\n        </div>\n      </ha-card>\n    `;\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues) {\n    if (!changedProps.has(\"hass\") || changedProps.size > 1) {\n      return true;\n    }\n\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n\n    if (!oldHass || !this._configEntities) {\n      return true;\n    }\n\n    if (oldHass.themes.darkMode !== this.hass.themes.darkMode) {\n      return true;\n    }\n\n    // Check if any state has changed\n    for (const entity of this._configEntities) {\n      if (oldHass.states[entity] !== this.hass!.states[entity]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  protected firstUpdated(changedProps: PropertyValues): void {\n    super.firstUpdated(changedProps);\n    const root = this.shadowRoot!.getElementById(\"root\");\n\n    if (!this._config || this.isPanel || !root) {\n      return;\n    }\n\n    if (!this._config.aspect_ratio) {\n      root.style.paddingBottom = \"100%\";\n      return;\n    }\n\n    const ratio = parseAspectRatio(this._config.aspect_ratio);\n\n    root.style.paddingBottom =\n      ratio && ratio.w > 0 && ratio.h > 0\n        ? `${((100 * ratio.h) / ratio.w).toFixed(2)}%`\n        : (root.style.paddingBottom = \"100%\");\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (this._config?.hours_to_show && this._configEntities?.length) {\n      if (changedProps.has(\"_config\")) {\n        this._getHistory();\n      } else if (Date.now() - this._date!.getTime() >= MINUTE) {\n        this._getHistory();\n      }\n    }\n  }\n\n  private _fitMap() {\n    this._map?.fitMap();\n  }\n\n  private _getColor(entityId: string): string {\n    let color = this._colorDict[entityId];\n    if (color) {\n      return color;\n    }\n    color = getColorByIndex(this._colorIndex);\n    this._colorIndex++;\n    this._colorDict[entityId] = color;\n    return color;\n  }\n\n  private _getEntities = memoizeOne(\n    (\n      states: HassEntities,\n      config: MapCardConfig,\n      configEntities?: string[]\n    ) => {\n      if (!states || !config) {\n        return undefined;\n      }\n\n      let entities = configEntities || [];\n\n      if (config.geo_location_sources) {\n        const geoEntities: string[] = [];\n        // Calculate visible geo location sources\n        const includesAll = config.geo_location_sources.includes(\"all\");\n        for (const stateObj of Object.values(states)) {\n          if (\n            computeDomain(stateObj.entity_id) === \"geo_location\" &&\n            (includesAll ||\n              config.geo_location_sources.includes(stateObj.attributes.source))\n          ) {\n            geoEntities.push(stateObj.entity_id);\n          }\n        }\n\n        entities = [...entities, ...geoEntities];\n      }\n\n      return entities.map((entity) => ({\n        entity_id: entity,\n        color: this._getColor(entity),\n      }));\n    }\n  );\n\n  private _getHistoryPaths = memoizeOne(\n    (\n      config: MapCardConfig,\n      history?: HassEntity[][]\n    ): HaMapPaths[] | undefined => {\n      if (!config.hours_to_show || !history) {\n        return undefined;\n      }\n\n      const paths: HaMapPaths[] = [];\n\n      for (const entityStates of history) {\n        if (entityStates?.length <= 1) {\n          continue;\n        }\n        // filter location data from states and remove all invalid locations\n        const points = entityStates.reduce(\n          (accumulator: LatLngTuple[], entityState) => {\n            const latitude = entityState.attributes.latitude;\n            const longitude = entityState.attributes.longitude;\n            if (latitude && longitude) {\n              accumulator.push([latitude, longitude] as LatLngTuple);\n            }\n            return accumulator;\n          },\n          []\n        ) as LatLngTuple[];\n\n        paths.push({\n          points,\n          color: this._getColor(entityStates[0].entity_id),\n          gradualOpacity: 0.8,\n        });\n      }\n      return paths;\n    }\n  );\n\n  private async _getHistory(): Promise<void> {\n    this._date = new Date();\n\n    if (!this._configEntities) {\n      return;\n    }\n\n    const entityIds = this._configEntities!.join(\",\");\n    const endTime = new Date();\n    const startTime = new Date();\n    startTime.setHours(endTime.getHours() - this._config!.hours_to_show!);\n    const skipInitialState = false;\n    const significantChangesOnly = false;\n    const minimalResponse = false;\n\n    const stateHistory = await fetchRecent(\n      this.hass,\n      entityIds,\n      startTime,\n      endTime,\n      skipInitialState,\n      significantChangesOnly,\n      minimalResponse\n    );\n\n    if (stateHistory.length < 1) {\n      return;\n    }\n    this._history = stateHistory;\n  }\n\n  private _cleanupHistory() {\n    if (!this._history) {\n      return;\n    }\n    if (this._config!.hours_to_show! <= 0) {\n      this._history = undefined;\n    } else {\n      // remove unused entities\n      this._history = this._history!.reduce(\n        (accumulator: HassEntity[][], entityStates) => {\n          const entityId = entityStates[0].entity_id;\n          if (this._configEntities?.includes(entityId)) {\n            accumulator.push(entityStates);\n          }\n          return accumulator;\n        },\n        []\n      ) as HassEntity[][];\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-card {\n        overflow: hidden;\n        width: 100%;\n        height: 100%;\n      }\n\n      ha-map {\n        z-index: 0;\n        border: none;\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background: inherit;\n      }\n\n      ha-icon-button {\n        position: absolute;\n        top: 75px;\n        left: 3px;\n        outline: none;\n      }\n\n      #root {\n        position: relative;\n      }\n\n      :host([ispanel]) #root {\n        height: 100%;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-map-card\": HuiMapCard;\n  }\n}\n"],"names":[],"sourceRoot":""}