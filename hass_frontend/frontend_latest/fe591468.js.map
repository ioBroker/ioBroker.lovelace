{"version":3,"file":"fe591468.js","mappings":";AAsIA;;AAEA;;;AAKA;AACA;AACA;AACA;;;;;;AAdA;;;;;;;;;;AA3GA","sources":["webpack://home-assistant-frontend/./src/panels/lovelace/cards/hui-history-graph-card.ts"],"sourcesContent":["import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { throttle } from \"../../../common/util/throttle\";\nimport \"../../../components/ha-card\";\nimport \"../../../components/chart/state-history-charts\";\nimport { CacheConfig, getRecentWithCache } from \"../../../data/cached-history\";\nimport { HistoryResult } from \"../../../data/history\";\nimport { HomeAssistant } from \"../../../types\";\nimport { hasConfigOrEntitiesChanged } from \"../common/has-changed\";\nimport { processConfigEntities } from \"../common/process-config-entities\";\nimport { EntityConfig } from \"../entity-rows/types\";\nimport { LovelaceCard } from \"../types\";\nimport { HistoryGraphCardConfig } from \"./types\";\n\n@customElement(\"hui-history-graph-card\")\nexport class HuiHistoryGraphCard extends LitElement implements LovelaceCard {\n  public static async getConfigElement() {\n    await import(\"../editor/config-elements/hui-history-graph-card-editor\");\n    return document.createElement(\"hui-history-graph-card-editor\");\n  }\n\n  public static getStubConfig(): HistoryGraphCardConfig {\n    // Hard coded to sun.sun to prevent high server load when it would pick an entity with a lot of state changes\n    return { type: \"history-graph\", entities: [\"sun.sun\"] };\n  }\n\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @state() private _stateHistory?: HistoryResult;\n\n  @state() private _config?: HistoryGraphCardConfig;\n\n  private _configEntities?: EntityConfig[];\n\n  private _names: Record<string, string> = {};\n\n  private _cacheConfig?: CacheConfig;\n\n  private _fetching = false;\n\n  private _throttleGetStateHistory?: () => void;\n\n  public getCardSize(): number {\n    return this._config?.title\n      ? 2\n      : 0 + 2 * (this._configEntities?.length || 1);\n  }\n\n  public setConfig(config: HistoryGraphCardConfig): void {\n    if (!config.entities || !Array.isArray(config.entities)) {\n      throw new Error(\"Entities need to be an array\");\n    }\n\n    if (!config.entities.length) {\n      throw new Error(\"You must include at least one entity\");\n    }\n\n    this._configEntities = config.entities\n      ? processConfigEntities(config.entities)\n      : [];\n\n    const _entities: string[] = [];\n\n    this._configEntities.forEach((entity) => {\n      _entities.push(entity.entity);\n      if (entity.name) {\n        this._names[entity.entity] = entity.name;\n      }\n    });\n\n    this._throttleGetStateHistory = throttle(() => {\n      this._getStateHistory();\n    }, config.refresh_interval || 10 * 1000);\n\n    this._cacheConfig = {\n      cacheKey: _entities.join(),\n      hoursToShow: config.hours_to_show || 24,\n    };\n\n    this._config = config;\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    if (changedProps.has(\"_stateHistory\")) {\n      return true;\n    }\n    return hasConfigOrEntitiesChanged(this, changedProps);\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    super.updated(changedProps);\n    if (\n      !this._config ||\n      !this.hass ||\n      !this._throttleGetStateHistory ||\n      !this._cacheConfig\n    ) {\n      return;\n    }\n\n    if (!changedProps.has(\"_config\") && !changedProps.has(\"hass\")) {\n      return;\n    }\n\n    const oldConfig = changedProps.get(\"_config\") as\n      | HistoryGraphCardConfig\n      | undefined;\n\n    if (\n      changedProps.has(\"_config\") &&\n      (oldConfig?.entities !== this._config.entities ||\n        oldConfig?.hours_to_show !== this._config.hours_to_show)\n    ) {\n      this._throttleGetStateHistory();\n    } else if (changedProps.has(\"hass\")) {\n      // wait for commit of data (we only account for the default setting of 1 sec)\n      setTimeout(this._throttleGetStateHistory, 1000);\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass || !this._config) {\n      return html``;\n    }\n\n    return html`\n      <ha-card .header=${this._config.title}>\n        <div\n          class=\"content ${classMap({\n            \"has-header\": !!this._config.title,\n          })}\"\n        >\n          <state-history-charts\n            .hass=${this.hass}\n            .isLoadingData=${!this._stateHistory}\n            .historyData=${this._stateHistory}\n            .names=${this._names}\n            up-to-now\n            no-single\n          ></state-history-charts>\n        </div>\n      </ha-card>\n    `;\n  }\n\n  private async _getStateHistory(): Promise<void> {\n    if (this._fetching) {\n      return;\n    }\n    this._fetching = true;\n    try {\n      this._stateHistory = {\n        ...(await getRecentWithCache(\n          this.hass!,\n          this._cacheConfig!.cacheKey,\n          this._cacheConfig!,\n          this.hass!.localize,\n          this.hass!.language\n        )),\n      };\n    } finally {\n      this._fetching = false;\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-card {\n        height: 100%;\n      }\n      .content {\n        padding: 16px;\n      }\n      .has-header {\n        padding-top: 0;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-history-graph-card\": HuiHistoryGraphCard;\n  }\n}\n"],"names":[],"sourceRoot":""}