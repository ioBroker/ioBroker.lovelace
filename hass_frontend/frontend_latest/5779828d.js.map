{"version":3,"file":"5779828d.js","mappings":";AA6BA;;;;AAIA;AACA;AACA;AACA;;;;AA9BA;;;;;;;;AAAA;;AC6BA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClBA;;AAEA;AACA;AACA;;;AAvBA;;;;;;;ACRA;;;ACwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5BA;;;;;;;AAAA;;ACqCA;;AAEA;;AAGA;AACA;AACA;;AAEA;;;AAIA;AACA;AACA;AACA;AAEA;;;;AAOA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/DA;;;;;;;;;;;;;AAAA;ACSA;;AAqCA;AACA;AACA;AACA;;;AAOA;;AAMA;;;AAGA;AACA;;;;AAIA;AACA;AAGA;;;;;AAKA;;AAEA;;AAjEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;ACRA;AACA;AACA;AACA;;AAvBA;;AC4BA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;;;;AASA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AAGA;AAEA;;;AArDA;;;;;AAAA;;ACmCA;AAKA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;AAEA;;AAGA;AACA;;AAEA;AACA;AAjDA;;;;;;;;;;;;;;;;;;AAAA;;ACwBA;;AAGA;;AAEA;AAEA;AAGA;;AAGA;;AAEA;AAEA;;;AA9CA;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACkNA","sources":["webpack://home-assistant-frontend/./src/components/ha-button-menu.ts","webpack://home-assistant-frontend/./src/components/ha-duration-input.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-boolean.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-constant.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-float.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-integer.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-multi_select.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-positive_time_period_dict.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-select.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-string.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form.ts","webpack://home-assistant-frontend/./src/components/paper-time-input.js"],"sourcesContent":["import \"@material/mwc-menu\";\nimport type { Corner, Menu } from \"@material/mwc-menu\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\n\n@customElement(\"ha-button-menu\")\nexport class HaButtonMenu extends LitElement {\n  @property() public corner: Corner = \"TOP_START\";\n\n  @property({ type: Boolean }) public multi = false;\n\n  @property({ type: Boolean }) public activatable = false;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public fixed = false;\n\n  @query(\"mwc-menu\", true) private _menu?: Menu;\n\n  public get items() {\n    return this._menu?.items;\n  }\n\n  public get selected() {\n    return this._menu?.selected;\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <div @click=${this._handleClick}>\n        <slot name=\"trigger\"></slot>\n      </div>\n      <mwc-menu\n        .corner=${this.corner}\n        .fixed=${this.fixed}\n        .multi=${this.multi}\n        .activatable=${this.activatable}\n      >\n        <slot></slot>\n      </mwc-menu>\n    `;\n  }\n\n  private _handleClick(): void {\n    if (this.disabled) {\n      return;\n    }\n    this._menu!.anchor = this;\n    this._menu!.show();\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: inline-block;\n        position: relative;\n      }\n      ::slotted([disabled]) {\n        color: var(--disabled-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-button-menu\": HaButtonMenu;\n  }\n}\n","import { html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport \"./paper-time-input\";\n\nexport interface HaDurationData {\n  hours?: number;\n  minutes?: number;\n  seconds?: number;\n  milliseconds?: number;\n}\n\n@customElement(\"ha-duration-input\")\nclass HaDurationInput extends LitElement {\n  @property({ attribute: false }) public data!: HaDurationData;\n\n  @property() public label?: string;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @property({ type: Boolean }) public enableMillisecond?: boolean;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @query(\"paper-time-input\", true) private _input?: HTMLElement;\n\n  public focus() {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <paper-time-input\n        .label=${this.label}\n        .required=${this.required}\n        .autoValidate=${this.required}\n        .disabled=${this.disabled}\n        error-message=\"Required\"\n        enable-second\n        .enableMillisecond=${this.enableMillisecond}\n        format=\"24\"\n        .hour=${this._parseDuration(this._hours)}\n        .min=${this._parseDuration(this._minutes)}\n        .sec=${this._parseDuration(this._seconds)}\n        .millisec=${this._parseDurationMillisec(this._milliseconds)}\n        @hour-changed=${this._hourChanged}\n        @min-changed=${this._minChanged}\n        @sec-changed=${this._secChanged}\n        @millisec-changed=${this._millisecChanged}\n        float-input-labels\n        no-hours-limit\n        always-float-input-labels\n        hour-label=\"hh\"\n        min-label=\"mm\"\n        sec-label=\"ss\"\n        millisec-label=\"ms\"\n      ></paper-time-input>\n    `;\n  }\n\n  private get _hours() {\n    return this.data && this.data.hours ? Number(this.data.hours) : 0;\n  }\n\n  private get _minutes() {\n    return this.data && this.data.minutes ? Number(this.data.minutes) : 0;\n  }\n\n  private get _seconds() {\n    return this.data && this.data.seconds ? Number(this.data.seconds) : 0;\n  }\n\n  private get _milliseconds() {\n    return this.data && this.data.milliseconds\n      ? Number(this.data.milliseconds)\n      : 0;\n  }\n\n  private _parseDuration(value) {\n    return value.toString().padStart(2, \"0\");\n  }\n\n  private _parseDurationMillisec(value) {\n    return value.toString().padStart(3, \"0\");\n  }\n\n  private _hourChanged(ev) {\n    this._durationChanged(ev, \"hours\");\n  }\n\n  private _minChanged(ev) {\n    this._durationChanged(ev, \"minutes\");\n  }\n\n  private _secChanged(ev) {\n    this._durationChanged(ev, \"seconds\");\n  }\n\n  private _millisecChanged(ev) {\n    this._durationChanged(ev, \"milliseconds\");\n  }\n\n  private _durationChanged(ev, unit) {\n    let value = Number(ev.detail.value);\n\n    if (value === this[`_${unit}`]) {\n      return;\n    }\n\n    let hours = this._hours;\n    let minutes = this._minutes;\n\n    if (unit === \"seconds\" && value > 59) {\n      minutes += Math.floor(value / 60);\n      value %= 60;\n    }\n\n    if (unit === \"minutes\" && value > 59) {\n      hours += Math.floor(value / 60);\n      value %= 60;\n    }\n\n    const newValue: HaDurationData = {\n      hours,\n      minutes,\n      seconds: this._seconds,\n    };\n\n    if (this.enableMillisecond || this._milliseconds) {\n      newValue.milliseconds = this._milliseconds;\n    }\n\n    newValue[unit] = value;\n\n    fireEvent(this, \"value-changed\", {\n      value: newValue,\n    });\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-duration-input\": HaDurationInput;\n  }\n}\n","import \"@material/mwc-formfield\";\nimport { html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type {\n  HaFormBooleanData,\n  HaFormBooleanSchema,\n  HaFormElement,\n} from \"./types\";\nimport type { HaCheckbox } from \"../ha-checkbox\";\nimport \"../ha-checkbox\";\n\n@customElement(\"ha-form-boolean\")\nexport class HaFormBoolean extends LitElement implements HaFormElement {\n  @property() public schema!: HaFormBooleanSchema;\n\n  @property() public data!: HaFormBooleanData;\n\n  @property() public label!: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @query(\"ha-checkbox\", true) private _input?: HTMLElement;\n\n  public focus() {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <mwc-formfield .label=${this.label}>\n        <ha-checkbox\n          .checked=${this.data}\n          .disabled=${this.disabled}\n          @change=${this._valueChanged}\n        ></ha-checkbox>\n      </mwc-formfield>\n    `;\n  }\n\n  private _valueChanged(ev: Event) {\n    fireEvent(this, \"value-changed\", {\n      value: (ev.target as HaCheckbox).checked,\n    });\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-boolean\": HaFormBoolean;\n  }\n}\n","import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { HaFormConstantSchema, HaFormElement } from \"./types\";\n\n@customElement(\"ha-form-constant\")\nexport class HaFormConstant extends LitElement implements HaFormElement {\n  @property({ attribute: false }) public schema!: HaFormConstantSchema;\n\n  @property() public label!: string;\n\n  protected render(): TemplateResult {\n    return html`<span class=\"label\">${this.label}</span>: ${this.schema.value}`;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n      }\n      .label {\n        font-weight: 500;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-constant\": HaFormConstant;\n  }\n}\n","import \"@material/mwc-textfield\";\nimport type { TextField } from \"@material/mwc-textfield\";\nimport { css, html, LitElement, TemplateResult, PropertyValues } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { HaFormElement, HaFormFloatData, HaFormFloatSchema } from \"./types\";\n\n@customElement(\"ha-form-float\")\nexport class HaFormFloat extends LitElement implements HaFormElement {\n  @property() public schema!: HaFormFloatSchema;\n\n  @property() public data!: HaFormFloatData;\n\n  @property() public label!: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @query(\"mwc-textfield\") private _input?: HTMLElement;\n\n  public focus() {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <mwc-textfield\n        inputMode=\"decimal\"\n        .label=${this.label}\n        .value=${this.data !== undefined ? this.data : \"\"}\n        .disabled=${this.disabled}\n        .required=${this.schema.required}\n        .autoValidate=${this.schema.required}\n        .suffix=${this.schema.description?.suffix}\n        .validationMessage=${this.schema.required ? \"Required\" : undefined}\n        @input=${this._valueChanged}\n      ></mwc-textfield>\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (changedProps.has(\"schema\")) {\n      this.toggleAttribute(\"own-margin\", !!this.schema.required);\n    }\n  }\n\n  private _valueChanged(ev: Event) {\n    const source = ev.target as TextField;\n    const rawValue = source.value.replace(\",\", \".\");\n\n    let value: number | undefined;\n\n    if (rawValue.endsWith(\".\")) {\n      return;\n    }\n\n    if (rawValue !== \"\") {\n      value = parseFloat(rawValue);\n      if (isNaN(value)) {\n        value = undefined;\n      }\n    }\n\n    // Detect anything changed\n    if (this.data === value) {\n      // parseFloat will drop invalid text at the end, in that case update textfield\n      const newRawValue = value === undefined ? \"\" : String(value);\n      if (source.value !== newRawValue) {\n        source.value = newRawValue;\n      }\n      return;\n    }\n\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n\n  static styles = css`\n    :host([own-margin]) {\n      margin-bottom: 5px;\n    }\n    mwc-textfield {\n      display: block;\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-float\": HaFormFloat;\n  }\n}\n","import \"@material/mwc-textfield\";\nimport type { TextField } from \"@material/mwc-textfield\";\nimport \"@material/mwc-slider\";\nimport type { Slider } from \"@material/mwc-slider\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  TemplateResult,\n  PropertyValues,\n} from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { HaCheckbox } from \"../ha-checkbox\";\nimport { HaFormElement, HaFormIntegerData, HaFormIntegerSchema } from \"./types\";\n\n@customElement(\"ha-form-integer\")\nexport class HaFormInteger extends LitElement implements HaFormElement {\n  @property() public schema!: HaFormIntegerSchema;\n\n  @property() public data?: HaFormIntegerData;\n\n  @property() public label?: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @query(\"paper-input ha-slider\") private _input?: HTMLElement;\n\n  private _lastValue?: HaFormIntegerData;\n\n  public focus() {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (\n      this.schema.valueMin !== undefined &&\n      this.schema.valueMax !== undefined &&\n      this.schema.valueMax - this.schema.valueMin < 256\n    ) {\n      return html`\n        <div>\n          ${this.label}\n          <div class=\"flex\">\n            ${this.schema.optional\n              ? html`\n                  <ha-checkbox\n                    @change=${this._handleCheckboxChange}\n                    .checked=${this.data !== undefined}\n                    .disabled=${this.disabled}\n                  ></ha-checkbox>\n                `\n              : \"\"}\n            <mwc-slider\n              discrete\n              .value=${this._value}\n              .min=${this.schema.valueMin}\n              .max=${this.schema.valueMax}\n              .disabled=${this.disabled ||\n              (this.data === undefined && this.schema.optional)}\n              @change=${this._valueChanged}\n            ></mwc-slider>\n          </div>\n        </div>\n      `;\n    }\n\n    return html`\n      <mwc-textfield\n        type=\"number\"\n        inputMode=\"numeric\"\n        .label=${this.label}\n        .value=${this.data !== undefined ? this.data : \"\"}\n        .disabled=${this.disabled}\n        .required=${this.schema.required}\n        .autoValidate=${this.schema.required}\n        .suffix=${this.schema.description?.suffix}\n        .validationMessage=${this.schema.required ? \"Required\" : undefined}\n        @input=${this._valueChanged}\n      ></mwc-textfield>\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (changedProps.has(\"schema\")) {\n      this.toggleAttribute(\n        \"own-margin\",\n        !(\"valueMin\" in this.schema && \"valueMax\" in this.schema) &&\n          !!this.schema.required\n      );\n    }\n  }\n\n  private get _value() {\n    if (this.data !== undefined) {\n      return this.data;\n    }\n\n    if (this.schema.optional) {\n      return this.schema.valueMin || 0;\n    }\n\n    return (\n      this.schema.description?.suggested_value ||\n      this.schema.default ||\n      this.schema.valueMin ||\n      0\n    );\n  }\n\n  private _handleCheckboxChange(ev: Event) {\n    const checked = (ev.target as HaCheckbox).checked;\n    let value: HaFormIntegerData | undefined;\n    if (checked) {\n      for (const candidate of [\n        this._lastValue,\n        this.schema.description?.suggested_value as HaFormIntegerData,\n        this.schema.default,\n        0,\n      ]) {\n        if (candidate !== undefined) {\n          value = candidate;\n          break;\n        }\n      }\n    } else {\n      // We track last value so user can disable and enable a field without losing\n      // their value.\n      this._lastValue = this.data;\n    }\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n\n  private _valueChanged(ev: Event) {\n    const source = ev.target as TextField | Slider;\n    const rawValue = source.value;\n\n    let value: number | undefined;\n\n    if (rawValue !== \"\") {\n      value = parseInt(String(rawValue));\n    }\n\n    if (this.data === value) {\n      // parseInt will drop invalid text at the end, in that case update textfield\n      const newRawValue = value === undefined ? \"\" : String(value);\n      if (source.value !== newRawValue) {\n        source.value = newRawValue;\n      }\n      return;\n    }\n\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host([own-margin]) {\n        margin-bottom: 5px;\n      }\n      .flex {\n        display: flex;\n      }\n      mwc-slider {\n        flex: 1;\n      }\n      mwc-textfield {\n        display: block;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-integer\": HaFormInteger;\n  }\n}\n","import { mdiMenuDown, mdiMenuUp } from \"@mdi/js\";\nimport \"@material/mwc-textfield\";\nimport \"@material/mwc-formfield\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  TemplateResult,\n  PropertyValues,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport \"../ha-button-menu\";\nimport \"../ha-svg-icon\";\nimport {\n  HaFormElement,\n  HaFormMultiSelectData,\n  HaFormMultiSelectSchema,\n} from \"./types\";\nimport \"../ha-checkbox\";\nimport type { HaCheckbox } from \"../ha-checkbox\";\n\nfunction optionValue(item: string | string[]): string {\n  return Array.isArray(item) ? item[0] : item;\n}\n\nfunction optionLabel(item: string | string[]): string {\n  return Array.isArray(item) ? item[1] || item[0] : item;\n}\n\nconst SHOW_ALL_ENTRIES_LIMIT = 6;\n\n@customElement(\"ha-form-multi_select\")\nexport class HaFormMultiSelect extends LitElement implements HaFormElement {\n  @property() public schema!: HaFormMultiSelectSchema;\n\n  @property() public data!: HaFormMultiSelectData;\n\n  @property() public label!: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @state() private _opened = false;\n\n  @query(\"ha-button-menu\") private _input?: HTMLElement;\n\n  public focus(): void {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    const options = Array.isArray(this.schema.options)\n      ? this.schema.options\n      : Object.entries(this.schema.options);\n    const data = this.data || [];\n\n    const renderedOptions = options.map((item: string | [string, string]) => {\n      const value = optionValue(item);\n      return html`\n        <mwc-formfield .label=${optionLabel(item)}>\n          <ha-checkbox\n            .checked=${data.includes(value)}\n            .value=${value}\n            .disabled=${this.disabled}\n            @change=${this._valueChanged}\n          ></ha-checkbox>\n        </mwc-formfield>\n      `;\n    });\n\n    // We will just render all checkboxes.\n    if (options.length < SHOW_ALL_ENTRIES_LIMIT) {\n      return html`<div>${this.label}${renderedOptions}</div> `;\n    }\n\n    return html`\n      <ha-button-menu\n        .disabled=${this.disabled}\n        fixed\n        corner=\"BOTTOM_START\"\n        @opened=${this._handleOpen}\n        @closed=${this._handleClose}\n      >\n        <mwc-textfield\n          slot=\"trigger\"\n          .label=${this.label}\n          .value=${data\n            .map((value) => this.schema.options![value] || value)\n            .join(\", \")}\n          .disabled=${this.disabled}\n          tabindex=\"-1\"\n        ></mwc-textfield>\n        <ha-svg-icon\n          slot=\"trigger\"\n          .path=${this._opened ? mdiMenuUp : mdiMenuDown}\n        ></ha-svg-icon>\n        ${renderedOptions}\n      </ha-button-menu>\n    `;\n  }\n\n  protected firstUpdated() {\n    this.updateComplete.then(() => {\n      const { formElement, mdcRoot } =\n        this.shadowRoot?.querySelector(\"mwc-textfield\") || ({} as any);\n      if (formElement) {\n        formElement.style.textOverflow = \"ellipsis\";\n      }\n      if (mdcRoot) {\n        mdcRoot.style.cursor = \"pointer\";\n      }\n    });\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (changedProps.has(\"schema\")) {\n      this.toggleAttribute(\n        \"own-margin\",\n        Object.keys(this.schema.options).length >= SHOW_ALL_ENTRIES_LIMIT &&\n          !!this.schema.required\n      );\n    }\n  }\n\n  private _valueChanged(ev: CustomEvent): void {\n    const { value, checked } = ev.target as HaCheckbox;\n\n    let newValue: string[];\n\n    if (checked) {\n      if (!this.data) {\n        newValue = [value];\n      } else if (this.data.includes(value)) {\n        return;\n      } else {\n        newValue = [...this.data, value];\n      }\n    } else {\n      if (!this.data.includes(value)) {\n        return;\n      }\n      newValue = this.data.filter((v) => v !== value);\n    }\n\n    fireEvent(this, \"value-changed\", {\n      value: newValue,\n    });\n  }\n\n  private _handleOpen(ev: Event): void {\n    ev.stopPropagation();\n    this._opened = true;\n    this.toggleAttribute(\"opened\", true);\n  }\n\n  private _handleClose(ev: Event): void {\n    ev.stopPropagation();\n    this._opened = false;\n    this.toggleAttribute(\"opened\", false);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host([own-margin]) {\n        margin-bottom: 5px;\n      }\n      ha-button-menu {\n        display: block;\n        cursor: pointer;\n      }\n      mwc-formfield {\n        display: block;\n        padding-right: 16px;\n      }\n      mwc-textfield {\n        display: block;\n        pointer-events: none;\n      }\n      ha-svg-icon {\n        color: var(--input-dropdown-icon-color);\n        position: absolute;\n        right: 1em;\n        top: 1em;\n        cursor: pointer;\n      }\n      :host([opened]) ha-svg-icon {\n        color: var(--primary-color);\n      }\n      :host([opened]) ha-button-menu {\n        --mdc-text-field-idle-line-color: var(--input-hover-line-color);\n        --mdc-text-field-label-ink-color: var(--primary-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-multi_select\": HaFormMultiSelect;\n  }\n}\n","import { html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport \"../ha-duration-input\";\nimport { HaFormElement, HaFormTimeData, HaFormTimeSchema } from \"./types\";\n\n@customElement(\"ha-form-positive_time_period_dict\")\nexport class HaFormTimePeriod extends LitElement implements HaFormElement {\n  @property() public schema!: HaFormTimeSchema;\n\n  @property() public data!: HaFormTimeData;\n\n  @property() public label!: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @query(\"ha-time-input\", true) private _input?: HTMLElement;\n\n  public focus() {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-duration-input\n        .label=${this.label}\n        .required=${this.schema.required}\n        .data=${this.data}\n        .disabled=${this.disabled}\n      ></ha-duration-input>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-positive_time_period_dict\": HaFormTimePeriod;\n  }\n}\n","import \"@material/mwc-select\";\nimport type { Select } from \"@material/mwc-select\";\nimport \"@material/mwc-list/mwc-list-item\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport \"../ha-radio\";\nimport { HaFormElement, HaFormSelectData, HaFormSelectSchema } from \"./types\";\n\nimport { stopPropagation } from \"../../common/dom/stop_propagation\";\nimport type { HaRadio } from \"../ha-radio\";\n\n@customElement(\"ha-form-select\")\nexport class HaFormSelect extends LitElement implements HaFormElement {\n  @property({ attribute: false }) public schema!: HaFormSelectSchema;\n\n  @property() public data!: HaFormSelectData;\n\n  @property() public label!: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @query(\"mwc-select\", true) private _input?: HTMLElement;\n\n  public focus() {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.schema.optional && this.schema.options!.length < 6) {\n      return html`\n        <div>\n          ${this.label}\n          ${this.schema.options.map(\n            ([value, label]) => html`\n              <mwc-formfield .label=${label}>\n                <ha-radio\n                  .checked=${value === this.data}\n                  .value=${value}\n                  .disabled=${this.disabled}\n                  @change=${this._valueChanged}\n                ></ha-radio>\n              </mwc-formfield>\n            `\n          )}\n        </div>\n      `;\n    }\n\n    return html`\n      <mwc-select\n        fixedMenuPosition\n        naturalMenuWidth\n        .label=${this.label}\n        .value=${this.data}\n        .disabled=${this.disabled}\n        @closed=${stopPropagation}\n        @selected=${this._valueChanged}\n      >\n        ${this.schema.optional\n          ? html`<mwc-list-item value=\"\"></mwc-list-item>`\n          : \"\"}\n        ${this.schema.options!.map(\n          ([value, label]) => html`\n            <mwc-list-item .value=${value}>${label}</mwc-list-item>\n          `\n        )}\n      </mwc-select>\n    `;\n  }\n\n  private _valueChanged(ev: CustomEvent) {\n    ev.stopPropagation();\n    let value: string | undefined = (ev.target as Select | HaRadio).value;\n\n    if (value === this.data) {\n      return;\n    }\n\n    if (value === \"\") {\n      value = undefined;\n    }\n\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      mwc-select,\n      mwc-formfield {\n        display: block;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-select\": HaFormSelect;\n  }\n}\n","import { mdiEye, mdiEyeOff } from \"@mdi/js\";\nimport \"@material/mwc-textfield\";\nimport type { TextField } from \"@material/mwc-textfield\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  TemplateResult,\n  PropertyValues,\n} from \"lit\";\nimport { customElement, property, state, query } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport \"../ha-icon-button\";\nimport type {\n  HaFormElement,\n  HaFormStringData,\n  HaFormStringSchema,\n} from \"./types\";\n\nconst MASKED_FIELDS = [\"password\", \"secret\", \"token\"];\n\n@customElement(\"ha-form-string\")\nexport class HaFormString extends LitElement implements HaFormElement {\n  @property() public schema!: HaFormStringSchema;\n\n  @property() public data!: HaFormStringData;\n\n  @property() public label!: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @state() private _unmaskedPassword = false;\n\n  @query(\"mwc-textfield\") private _input?: HTMLElement;\n\n  public focus(): void {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    const isPassword = MASKED_FIELDS.some((field) =>\n      this.schema.name.includes(field)\n    );\n    return html`\n      <mwc-textfield\n        .type=${!isPassword\n          ? this._stringType\n          : this._unmaskedPassword\n          ? \"text\"\n          : \"password\"}\n        .label=${this.label}\n        .value=${this.data || \"\"}\n        .disabled=${this.disabled}\n        .required=${this.schema.required}\n        .autoValidate=${this.schema.required}\n        .suffix=${isPassword\n          ? // reserve some space for the icon.\n            html`<div style=\"width: 24px\"></div>`\n          : this.schema.description?.suffix}\n        .validationMessage=${this.schema.required ? \"Required\" : undefined}\n        @input=${this._valueChanged}\n      ></mwc-textfield>\n      ${isPassword\n        ? html`<ha-icon-button\n            toggles\n            .label=${`${this._unmaskedPassword ? \"Hide\" : \"Show\"} password`}\n            @click=${this._toggleUnmaskedPassword}\n            tabindex=\"-1\"\n            .path=${this._unmaskedPassword ? mdiEyeOff : mdiEye}\n          ></ha-icon-button>`\n        : \"\"}\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (changedProps.has(\"schema\")) {\n      this.toggleAttribute(\"own-margin\", !!this.schema.required);\n    }\n  }\n\n  private _toggleUnmaskedPassword(): void {\n    this._unmaskedPassword = !this._unmaskedPassword;\n  }\n\n  private _valueChanged(ev: Event): void {\n    let value: string | undefined = (ev.target as TextField).value;\n    if (this.data === value) {\n      return;\n    }\n    if (value === \"\" && this.schema.optional) {\n      value = undefined;\n    }\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n\n  private get _stringType(): string {\n    if (this.schema.format) {\n      if ([\"email\", \"url\"].includes(this.schema.format)) {\n        return this.schema.format;\n      }\n      if (this.schema.format === \"fqdnurl\") {\n        return \"url\";\n      }\n    }\n    return \"text\";\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        position: relative;\n      }\n      :host([own-margin]) {\n        margin-bottom: 5px;\n      }\n      mwc-textfield {\n        display: block;\n      }\n      ha-icon-button {\n        position: absolute;\n        top: 1em;\n        right: 12px;\n        --mdc-icon-button-size: 24px;\n        color: var(--secondary-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-string\": HaFormString;\n  }\n}\n","import { css, CSSResultGroup, html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { dynamicElement } from \"../../common/dom/dynamic-element-directive\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport \"../ha-alert\";\nimport \"./ha-form-boolean\";\nimport \"./ha-form-constant\";\nimport \"./ha-form-float\";\nimport \"./ha-form-integer\";\nimport \"./ha-form-multi_select\";\nimport \"./ha-form-positive_time_period_dict\";\nimport \"./ha-form-select\";\nimport \"./ha-form-string\";\nimport { HaFormElement, HaFormDataContainer, HaFormSchema } from \"./types\";\n\nconst getValue = (obj, item) => (obj ? obj[item.name] : null);\n\n@customElement(\"ha-form\")\nexport class HaForm extends LitElement implements HaFormElement {\n  @property() public data!: HaFormDataContainer;\n\n  @property() public schema!: HaFormSchema[];\n\n  @property() public error?: Record<string, string>;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property() public computeError?: (schema: HaFormSchema, error) => string;\n\n  @property() public computeLabel?: (schema: HaFormSchema) => string;\n\n  public focus() {\n    const root = this.shadowRoot?.querySelector(\".root\");\n    if (!root) {\n      return;\n    }\n    for (const child of root.children) {\n      if (child.tagName !== \"HA-ALERT\") {\n        (child as HTMLElement).focus();\n        break;\n      }\n    }\n  }\n\n  protected render() {\n    return html`\n      <div class=\"root\">\n        ${this.error && this.error.base\n          ? html`\n              <ha-alert alert-type=\"error\">\n                ${this._computeError(this.error.base, this.schema)}\n              </ha-alert>\n            `\n          : \"\"}\n        ${this.schema.map((item) => {\n          const error = getValue(this.error, item);\n          return html`\n            ${error\n              ? html`\n                  <ha-alert own-margin alert-type=\"error\">\n                    ${this._computeError(error, item)}\n                  </ha-alert>\n                `\n              : \"\"}\n            ${dynamicElement(`ha-form-${item.type}`, {\n              schema: item,\n              data: getValue(this.data, item),\n              label: this._computeLabel(item),\n              disabled: this.disabled,\n            })}\n          `;\n        })}\n      </div>\n    `;\n  }\n\n  protected createRenderRoot() {\n    const root = super.createRenderRoot();\n    // attach it as soon as possible to make sure we fetch all events.\n    root.addEventListener(\"value-changed\", (ev) => {\n      ev.stopPropagation();\n      const schema = (ev.target as HaFormElement).schema as HaFormSchema;\n      fireEvent(this, \"value-changed\", {\n        value: { ...this.data, [schema.name]: ev.detail.value },\n      });\n    });\n    return root;\n  }\n\n  private _computeLabel(schema: HaFormSchema) {\n    return this.computeLabel\n      ? this.computeLabel(schema)\n      : schema\n      ? schema.name\n      : \"\";\n  }\n\n  private _computeError(error, schema: HaFormSchema | HaFormSchema[]) {\n    return this.computeError ? this.computeError(error, schema) : error;\n  }\n\n  static get styles(): CSSResultGroup {\n    // .root has overflow: auto to avoid margin collapse\n    return css`\n      .root {\n        margin-bottom: -24px;\n        overflow: auto;\n      }\n      .root > * {\n        display: block;\n      }\n      .root > *:not([own-margin]) {\n        margin-bottom: 24px;\n      }\n      ha-alert[own-margin] {\n        margin-bottom: 4px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form\": HaForm;\n  }\n}\n","/**\nAdapted from paper-time-input from\nhttps://github.com/ryanburns23/paper-time-input\nMIT Licensed. Copyright (c) 2017 Ryan Burns\n\n`<paper-time-input>` Polymer element to accept a time with paper-input & paper-dropdown-menu\nInspired by the time input in google forms\n\n### Styling\n\n`<paper-time-input>` provides the following custom properties and mixins for styling:\n\nCustom property | Description | Default\n----------------|-------------|----------\n`--paper-time-input-dropdown-ripple-color` | dropdown ripple color | `--primary-color`\n`--paper-time-input-cotnainer` | Mixin applied to the inputs | `{}`\n`--paper-time-dropdown-input-cotnainer` | Mixin applied to the dropdown input | `{}`\n*/\nimport \"@polymer/paper-dropdown-menu/paper-dropdown-menu\";\nimport \"@polymer/paper-input/paper-input\";\nimport \"@polymer/paper-item/paper-item\";\nimport \"@polymer/paper-listbox/paper-listbox\";\nimport { html } from \"@polymer/polymer/lib/utils/html-tag\";\n/* eslint-plugin-disable lit */\nimport { PolymerElement } from \"@polymer/polymer/polymer-element\";\n\nexport class PaperTimeInput extends PolymerElement {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: block;\n          @apply --paper-font-common-base;\n        }\n\n        paper-input {\n          width: 30px;\n          text-align: center;\n          --paper-input-container-input: {\n            /* Damn you firefox\n             * Needed to hide spin num in firefox\n             * http://stackoverflow.com/questions/3790935/can-i-hide-the-html5-number-input-s-spin-box\n             */\n            -moz-appearance: textfield;\n            @apply --paper-time-input-cotnainer;\n          }\n          --paper-input-container-input-webkit-spinner: {\n            -webkit-appearance: none;\n            margin: 0;\n            display: none;\n          }\n          --paper-input-container-shared-input-style_-_-webkit-appearance: textfield;\n        }\n\n        paper-dropdown-menu {\n          width: 55px;\n          padding: 0;\n          /* Force ripple to use the whole container */\n          --paper-dropdown-menu-ripple: {\n            color: var(\n              --paper-time-input-dropdown-ripple-color,\n              var(--primary-color)\n            );\n          }\n          --paper-input-container-input: {\n            @apply --paper-font-button;\n            text-align: center;\n            padding-left: 5px;\n            @apply --paper-time-dropdown-input-cotnainer;\n          }\n          --paper-input-container-underline: {\n            border-color: transparent;\n          }\n          --paper-input-container-underline-focus: {\n            border-color: transparent;\n          }\n        }\n\n        paper-item {\n          cursor: pointer;\n          text-align: center;\n          font-size: 14px;\n        }\n\n        paper-listbox {\n          padding: 0;\n        }\n\n        label {\n          @apply --paper-font-caption;\n          color: var(\n            --paper-input-container-color,\n            var(--secondary-text-color)\n          );\n        }\n\n        .time-input-wrap {\n          @apply --layout-horizontal;\n          @apply --layout-no-wrap;\n          justify-content: var(--paper-time-input-justify-content, normal);\n        }\n\n        [hidden] {\n          display: none !important;\n        }\n\n        #millisec {\n          width: 38px;\n        }\n\n        .no-suffix {\n          margin-left: -2px;\n        }\n      </style>\n\n      <label hidden$=\"[[hideLabel]]\">[[label]]</label>\n      <div class=\"time-input-wrap\">\n        <!-- Hour Input -->\n        <paper-input\n          id=\"hour\"\n          type=\"number\"\n          inputmode=\"numeric\"\n          value=\"{{hour}}\"\n          label=\"[[hourLabel]]\"\n          on-change=\"_shouldFormatHour\"\n          on-focus=\"_onFocus\"\n          required\n          prevent-invalid-input\n          auto-validate=\"[[autoValidate]]\"\n          maxlength=\"2\"\n          max=\"[[_computeHourMax(format)]]\"\n          min=\"0\"\n          no-label-float$=\"[[!floatInputLabels]]\"\n          always-float-label$=\"[[alwaysFloatInputLabels]]\"\n          disabled=\"[[disabled]]\"\n        >\n          <span suffix slot=\"suffix\">:</span>\n        </paper-input>\n\n        <!-- Min Input -->\n        <paper-input\n          class$=\"[[_computeClassNames(enableSecond)]]\"\n          id=\"min\"\n          type=\"number\"\n          inputmode=\"numeric\"\n          value=\"{{min}}\"\n          label=\"[[minLabel]]\"\n          on-change=\"_formatMin\"\n          on-focus=\"_onFocus\"\n          required\n          auto-validate=\"[[autoValidate]]\"\n          prevent-invalid-input\n          maxlength=\"2\"\n          max=\"59\"\n          min=\"0\"\n          no-label-float$=\"[[!floatInputLabels]]\"\n          always-float-label$=\"[[alwaysFloatInputLabels]]\"\n          disabled=\"[[disabled]]\"\n        >\n          <span hidden$=\"[[!enableSecond]]\" suffix slot=\"suffix\">:</span>\n        </paper-input>\n\n        <!-- Sec Input -->\n        <paper-input\n          class$=\"[[_computeClassNames(enableMillisecond)]]\"\n          id=\"sec\"\n          type=\"number\"\n          inputmode=\"numeric\"\n          value=\"{{sec}}\"\n          label=\"[[secLabel]]\"\n          on-change=\"_formatSec\"\n          on-focus=\"_onFocus\"\n          required\n          auto-validate=\"[[autoValidate]]\"\n          prevent-invalid-input\n          maxlength=\"2\"\n          max=\"59\"\n          min=\"0\"\n          no-label-float$=\"[[!floatInputLabels]]\"\n          always-float-label$=\"[[alwaysFloatInputLabels]]\"\n          disabled=\"[[disabled]]\"\n          hidden$=\"[[!enableSecond]]\"\n        >\n          <span hidden$=\"[[!enableMillisecond]]\" suffix slot=\"suffix\">:</span>\n        </paper-input>\n\n        <!-- Millisec Input -->\n        <paper-input\n          id=\"millisec\"\n          type=\"number\"\n          value=\"{{millisec}}\"\n          label=\"[[millisecLabel]]\"\n          on-change=\"_formatMillisec\"\n          on-focus=\"_onFocus\"\n          required\n          auto-validate=\"[[autoValidate]]\"\n          prevent-invalid-input\n          maxlength=\"3\"\n          max=\"999\"\n          min=\"0\"\n          no-label-float$=\"[[!floatInputLabels]]\"\n          always-float-label$=\"[[alwaysFloatInputLabels]]\"\n          disabled=\"[[disabled]]\"\n          hidden$=\"[[!enableMillisecond]]\"\n        >\n        </paper-input>\n\n        <!-- Dropdown Menu -->\n        <paper-dropdown-menu\n          id=\"dropdown\"\n          required=\"\"\n          hidden$=\"[[_equal(format, 24)]]\"\n          no-label-float=\"\"\n          disabled=\"[[disabled]]\"\n        >\n          <paper-listbox\n            attr-for-selected=\"name\"\n            selected=\"{{amPm}}\"\n            slot=\"dropdown-content\"\n          >\n            <paper-item name=\"AM\">AM</paper-item>\n            <paper-item name=\"PM\">PM</paper-item>\n          </paper-listbox>\n        </paper-dropdown-menu>\n      </div>\n    `;\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Label for the input\n       */\n      label: {\n        type: String,\n        value: \"Time\",\n      },\n      /**\n       * auto validate time inputs\n       */\n      autoValidate: {\n        type: Boolean,\n        value: true,\n      },\n      /**\n       * hides the label\n       */\n      hideLabel: {\n        type: Boolean,\n        value: false,\n      },\n      /**\n       * float the input labels\n       */\n      floatInputLabels: {\n        type: Boolean,\n        value: false,\n      },\n      /**\n       * always float the input labels\n       */\n      alwaysFloatInputLabels: {\n        type: Boolean,\n        value: false,\n      },\n      /**\n       * 12 or 24 hr format\n       */\n      format: {\n        type: Number,\n        value: 12,\n      },\n      /**\n       * disables the inputs\n       */\n      disabled: {\n        type: Boolean,\n        value: false,\n      },\n      /**\n       * hour\n       */\n      hour: {\n        type: String,\n        notify: true,\n      },\n      /**\n       * minute\n       */\n      min: {\n        type: String,\n        notify: true,\n      },\n      /**\n       * second\n       */\n      sec: {\n        type: String,\n        notify: true,\n      },\n      /**\n       * milli second\n       */\n      millisec: {\n        type: String,\n        notify: true,\n      },\n      /**\n       * Label for the hour input\n       */\n      hourLabel: {\n        type: String,\n        value: \"\",\n      },\n      /**\n       * Label for the min input\n       */\n      minLabel: {\n        type: String,\n        value: \"\",\n      },\n      /**\n       * Label for the sec input\n       */\n      secLabel: {\n        type: String,\n        value: \"\",\n      },\n      /**\n       * Label for the milli sec input\n       */\n      millisecLabel: {\n        type: String,\n        value: \"\",\n      },\n      /**\n       * show the sec field\n       */\n      enableSecond: {\n        type: Boolean,\n        value: false,\n      },\n      /**\n       * show the milli sec field\n       */\n      enableMillisecond: {\n        type: Boolean,\n        value: false,\n      },\n      /**\n       * limit hours input\n       */\n      noHoursLimit: {\n        type: Boolean,\n        value: false,\n      },\n      /**\n       * AM or PM\n       */\n      amPm: {\n        type: String,\n        notify: true,\n        value: \"AM\",\n      },\n      /**\n       * Formatted time string\n       */\n      value: {\n        type: String,\n        notify: true,\n        readOnly: true,\n        computed: \"_computeTime(min, hour, sec, millisec, amPm)\",\n      },\n    };\n  }\n\n  /**\n   * Validate the inputs\n   * @return {boolean}\n   */\n  validate() {\n    let valid = true;\n    // Validate hour & min fields\n    if (!this.$.hour.validate() || !this.$.min.validate()) {\n      valid = false;\n    }\n    // Validate second field\n    if (this.enableSecond && !this.$.sec.validate()) {\n      valid = false;\n    }\n    // Validate milli second field\n    if (this.enableMillisecond && !this.$.millisec.validate()) {\n      valid = false;\n    }\n    // Validate AM PM if 12 hour time\n    if (this.format === 12 && !this.$.dropdown.validate()) {\n      valid = false;\n    }\n    return valid;\n  }\n\n  /**\n   * Create time string\n   */\n  _computeTime(min, hour, sec, millisec, amPm) {\n    let str;\n    if (\n      hour ||\n      min ||\n      (sec && this.enableSecond) ||\n      (millisec && this.enableMillisecond)\n    ) {\n      hour = hour || \"00\";\n      min = min || \"00\";\n      sec = sec || \"00\";\n      millisec = millisec || \"000\";\n      str = hour + \":\" + min;\n      // add sec field\n      if (this.enableSecond && sec) {\n        str = str + \":\" + sec;\n      }\n      // add milli sec field\n      if (this.enableMillisecond && millisec) {\n        str = str + \":\" + millisec;\n      }\n      // No ampm on 24 hr time\n      if (this.format === 12) {\n        str = str + \" \" + amPm;\n      }\n    }\n\n    return str;\n  }\n\n  _onFocus(ev) {\n    ev.target.inputElement.inputElement.select();\n  }\n\n  /**\n   * Format milli sec\n   */\n  _formatMillisec() {\n    if (this.millisec.toString().length === 1) {\n      this.millisec = this.millisec.toString().padStart(3, \"0\");\n    }\n  }\n\n  /**\n   * Format sec\n   */\n  _formatSec() {\n    if (this.sec.toString().length === 1) {\n      this.sec = this.sec.toString().padStart(2, \"0\");\n    }\n  }\n\n  /**\n   * Format min\n   */\n  _formatMin() {\n    if (this.min.toString().length === 1) {\n      this.min = this.min.toString().padStart(2, \"0\");\n    }\n  }\n\n  /**\n   * Format hour\n   */\n  _shouldFormatHour() {\n    if (this.format === 24 && this.hour.toString().length === 1) {\n      this.hour = this.hour.toString().padStart(2, \"0\");\n    }\n  }\n\n  /**\n   * 24 hour format has a max hr of 23\n   */\n  _computeHourMax(format) {\n    if (this.noHoursLimit) {\n      return null;\n    }\n    if (format === 12) {\n      return format;\n    }\n    return 23;\n  }\n\n  _equal(n1, n2) {\n    return n1 === n2;\n  }\n\n  _computeClassNames(hasSuffix) {\n    return hasSuffix ? \" \" : \"no-suffix\";\n  }\n}\n\ncustomElements.define(\"paper-time-input\", PaperTimeInput);\n"],"names":[],"sourceRoot":""}